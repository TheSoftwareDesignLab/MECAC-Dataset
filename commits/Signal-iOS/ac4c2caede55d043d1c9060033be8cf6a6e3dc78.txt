Rewrite BlockingManager to be transaction aware

This maintains much of the spirit of the original implementation while
being almost a total rewrite of its implementation. Before,
BlockingManager would load it's entire state into memory and only touch
the database if there's a compelling reason.

This new implementation maintains this behavior. Block state is always
kept in memory (there's certainly a more efficient way to do this but
that's out-of-scope for this change). The difference is now every time
the cached state is accessed, BlockingManager consults a change tag
stored in the database.

By requiring a transaction to access block state, we can make sure that
our block state remains up-to-date in cases where the database is
changed by another process..