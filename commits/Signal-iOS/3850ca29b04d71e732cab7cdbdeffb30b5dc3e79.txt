Bigger hack to fix problem with lesser hack.

There were two symptoms to this bad "leave app while dismissing keyboard"
state...

The first, most noticeable symptom was that the main window no longer respected
the device orientation. This was caused by UIKit temporarily disabling
autorotate during an interactive keyboard dismissal, and not cleaning up after
itself when we hid the window mid dismissal due to our screen protection
feature. This was solved previously in: ca0a555f8

The second symptom remained, and is solved by this commit. Wherein after
getting in this bad state, the interactive keyboard dismiss function behaves
oddly. Normally when interactively dismissing the keyboard in a scroll view,
the keyboard top follows your finger, until you lift up your finger, at which
point, depending on how close you are to the bottom, the keyboard should
completely dismiss, or cancel and return to its fully popped position. In the
degraded state, the keyboard would follow your finger, but when you lifted your
finger, it would stay where your finger left it, it would not complete/cancel
the dismiss.

The solution is, instead of only re-enabling autorotate, to use a higher level
private method which is called upon complete/cancellation of the interactive
dismissal. The method, `UIScrollToDismissSupport#finishScrollViewTransition`,
as well as re-enabling autorotate, does some other work to restore the UI to
it's normal post interactive-keyboard-dismiss gesture state.

For posterity here's the decompiled pseudocode:

```
/* @class UIScrollToDismissSupport */
-(void)finishScrollViewTransition {
    *(int8_t *)&self->_scrollViewTransitionFinishing = 0x0;
    [self->_controller setInterfaceAutorotationDisabled:0x0];
    [self hideScrollViewHorizontalScrollIndicator:0x0];
    ebx = *ivar_offset(_scrollViewNotificationInfo);
    [*(self + ebx) release];
    *(self + ebx) = 0x0;
    esi = *ivar_offset(_scrollViewForTransition);
    [*(self + esi) release];
    *(self + esi) = 0x0;
    return;
}
```