Add additionally loaded items to the top and bottom of the scroll rather than paging between chunks of them

This commit switches the timeline to LazyVStack, allowing us to handle more items in the feed at once. This was not done earlier because managing the scroll position in SwiftUI for this use case was unsatisfactory prior to iOS18 and we were previously targeting iOS17.

The behavior is now very similar to what it was with the old UITableView implementations, but we have not reintroduced the “gap loader”. Therefore, when newer posts are loaded and a gap is detected, the feed will be replaced and scroll will jump to the top if the newest old item is still visible.  If the newest old item is no longer visible (user scrolled away before the fetch completed), the snackbar will indicate new items are available, but they will not be displayed until another refresh or tap on the snackbar.  Currently, the snackbar is only shown in the Home timeline.

Details:

* Bumps deployment target to iOS18

* Includes the item type in the SwiftUI id of the TimelineItem, to avoid potential conflicts with items of different type sharing the same database id

* Uses LazyVStack for the feed items.
    - Unfortunately, LazyVStack does not cope well with dynamically sized rows appearing from the top. They take on their real size as they begin to appear in the viewport, causing them to suddenly expand into the viewable area, which makes the scrolling feel extremely jumpy.
    - To keep the scroll experience acceptable, the height of any row initially appearing above the visible area is now precalculated before the row is added to the feed.

* Manages the scroll using the new SwiftUI scrollPosition. This is key to keeping the scroll stable when adding new items to the feed (especially newer items) and even when simply navigating back to the feed from another screen.
    - Unfortunately, the system behavior of jumping to the top of the scrollview when you tap on the status bar does not update the scrollPosition. If left unaddressed, this would create confusion if you were scrolled well down in the feed, tapped the status bar to get to the top, then switched tabs (or tapped on a visible post to view its thread) without scrolling the feed first.  When you eventually returned to the feed, the scrollPosition from before you jumped to the top of the feed would be remembered and enforced.
    - Unfortunately again, fixing this is not entirely simple. To resolve it, we track the visibility of the first item and correct the scrollPosition if it becomes visible while the scrollPosition is something else. However, the visibility tracking mechanism reports the view as becoming visible any time you return to the feed, even your scroll position further down in the list will be restored before you ever see the top item. Thus we also rely on the visiblity of the overall view, so that we can avoid overcorrecting when returning to the feed from somewhere else (which would result in losing your place every time).
    - More unfortunate yet (because it remains unresolved), the scroll offset will sometimes shift noticeably when returning from another screen. It seems likely this is happening when the current scrollPosition refers to a row that is taller than the viewport.

* Adds an app-wide cache of post view models to avoid recalculating heights unnecessarily. This also allows updates like edits, favorites, etc, to be handled centrally so that the displayed info stays in sync across various feeds.
    - To avoid holding onto models no longer needed by any active feed, the central cache holds the models weakly. This means that each feed must hold a strong reference to the models it requires.
    - The empty wrappers left behind by abandoned models will not be removed automatically, so they must be intentionally purged from the cache. Currently, this is done whenever incorporating an update.
    - Filter context and thread context are no longer held in the view model, since they vary across timelines.
    - The MastodonPostActionHandler has also been removed from the view model, because it has to have access to the current view in order to navigate properly.

Fixes IOS-556