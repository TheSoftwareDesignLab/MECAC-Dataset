diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 3922a7f9c3a..e4e9c570f9e 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -142,7 +142,7 @@
                 <action android:name="android.bluetooth.device.action.ACL_DISCONNECTED" />
                 <action android:name="io.homeassistant.companion.android.background.REQUEST_SENSORS_UPDATE" />
                 <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
-                <action android:name="io.homeassistant.companion.android.widgets.template.TemplateWidget.RECEIVE_DATA" />
+                <action android:name="io.homeassistant.companion.android.widgets.template.BaseWidgetProvider.RECEIVE_DATA" />
             </intent-filter>
 
             <meta-data
diff --git a/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt b/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt
index 3961ad283a5..2a6aa8a53b4 100644
--- a/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt
@@ -144,24 +144,13 @@ open class HomeAssistantApplication : Application() {
         val mediaPlayerWidget = MediaPlayerControlsWidget()
         val templateWidget = TemplateWidget()
 
-        registerReceiver(
-            buttonWidget,
-            IntentFilter(Intent.ACTION_SCREEN_ON)
-        )
-
-        registerReceiver(
-            entityWidget,
-            IntentFilter(Intent.ACTION_SCREEN_ON)
-        )
-
-        registerReceiver(
-            mediaPlayerWidget,
-            IntentFilter(Intent.ACTION_SCREEN_ON)
-        )
-
-        registerReceiver(
-            templateWidget,
-            IntentFilter(Intent.ACTION_SCREEN_ON)
-        )
+        val screenIntentFilter = IntentFilter()
+        screenIntentFilter.addAction(Intent.ACTION_SCREEN_ON)
+        screenIntentFilter.addAction(Intent.ACTION_SCREEN_OFF)
+
+        registerReceiver(buttonWidget, screenIntentFilter)
+        registerReceiver(entityWidget, screenIntentFilter)
+        registerReceiver(mediaPlayerWidget, screenIntentFilter)
+        registerReceiver(templateWidget, screenIntentFilter)
     }
 }
diff --git a/app/src/main/java/io/homeassistant/companion/android/widgets/BaseWidgetProvider.kt b/app/src/main/java/io/homeassistant/companion/android/widgets/BaseWidgetProvider.kt
new file mode 100644
index 00000000000..e4efbec1ef4
--- /dev/null
+++ b/app/src/main/java/io/homeassistant/companion/android/widgets/BaseWidgetProvider.kt
@@ -0,0 +1,113 @@
+package io.homeassistant.companion.android.widgets
+
+import android.appwidget.AppWidgetManager
+import android.appwidget.AppWidgetProvider
+import android.content.Context
+import android.content.Intent
+import android.os.Bundle
+import android.widget.RemoteViews
+import io.homeassistant.companion.android.common.data.integration.Entity
+import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.cancel
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.collect
+import kotlinx.coroutines.launch
+import javax.inject.Inject
+
+abstract class BaseWidgetProvider : AppWidgetProvider() {
+
+    companion object {
+        const val UPDATE_VIEW =
+            "io.homeassistant.companion.android.widgets.template.BaseWidgetProvider.UPDATE_VIEW"
+        const val RECEIVE_DATA =
+            "io.homeassistant.companion.android.widgets.template.TemplateWidget.RECEIVE_DATA"
+    }
+
+    private var entityUpdates: Flow<Entity<*>>? = null
+
+    @Inject
+    protected lateinit var integrationUseCase: IntegrationRepository
+    protected var mainScope: CoroutineScope = CoroutineScope(Dispatchers.Main + Job())
+    protected var lastIntent = ""
+
+    override fun onUpdate(
+        context: Context,
+        appWidgetManager: AppWidgetManager,
+        appWidgetIds: IntArray
+    ) {
+        // There may be multiple widgets active, so update all of them
+        for (appWidgetId in appWidgetIds) {
+            mainScope.launch {
+                val views = getWidgetRemoteViews(context, appWidgetId)
+                appWidgetManager.updateAppWidget(appWidgetId, views)
+            }
+        }
+    }
+
+    override fun onReceive(context: Context, intent: Intent) {
+        lastIntent = intent.action.toString()
+        val appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
+
+        super.onReceive(context, intent)
+        when (lastIntent) {
+            UPDATE_VIEW -> updateView(context, appWidgetId)
+            RECEIVE_DATA -> {
+                saveEntityConfiguration(
+                    context,
+                    intent.extras,
+                    appWidgetId
+                )
+                onScreenOn(context)
+            }
+            Intent.ACTION_SCREEN_ON -> onScreenOn(context)
+            Intent.ACTION_SCREEN_OFF -> onScreenOff()
+        }
+    }
+
+    private fun onScreenOn(context: Context) {
+        mainScope = CoroutineScope(Dispatchers.Main + Job())
+        if (entityUpdates == null) {
+            mainScope.launch {
+                if (!integrationUseCase.isRegistered()) {
+                    return@launch
+                }
+                updateAllWidgets(context)
+                entityUpdates = integrationUseCase.getEntityUpdates()
+                entityUpdates!!.collect {
+                    updateAllWidgets(context)
+                }
+            }
+        }
+    }
+
+    private fun onScreenOff() {
+        mainScope.cancel()
+        entityUpdates = null
+    }
+
+    private fun updateAllWidgets(
+        context: Context
+    ) {
+        getAllWidgetIds(context).forEach {
+            updateView(context, it)
+        }
+    }
+
+    private fun updateView(
+        context: Context,
+        appWidgetId: Int,
+        appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(context)
+    ) {
+        mainScope.launch {
+            val views = getWidgetRemoteViews(context, appWidgetId)
+            appWidgetManager.updateAppWidget(appWidgetId, views)
+        }
+    }
+
+    abstract suspend fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews
+    abstract fun getAllWidgetIds(context: Context): List<Int>
+    abstract fun saveEntityConfiguration(context: Context, extras: Bundle?, appWidgetId: Int)
+}
diff --git a/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidget.kt b/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidget.kt
index ce360164222..af4bd05c78f 100644
--- a/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidget.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidget.kt
@@ -2,10 +2,8 @@ package io.homeassistant.companion.android.widgets.entity
 
 import android.app.PendingIntent
 import android.appwidget.AppWidgetManager
-import android.appwidget.AppWidgetProvider
 import android.content.Context
 import android.content.Intent
-import android.net.ConnectivityManager
 import android.os.Bundle
 import android.util.Log
 import android.util.TypedValue
@@ -14,25 +12,16 @@ import android.widget.Toast
 import dagger.hilt.android.AndroidEntryPoint
 import io.homeassistant.companion.android.R
 import io.homeassistant.companion.android.common.data.integration.Entity
-import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.widget.StaticWidgetDao
 import io.homeassistant.companion.android.database.widget.StaticWidgetEntity
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
+import io.homeassistant.companion.android.widgets.BaseWidgetProvider
 import kotlinx.coroutines.launch
-import javax.inject.Inject
 
 @AndroidEntryPoint
-class EntityWidget : AppWidgetProvider() {
+class EntityWidget : BaseWidgetProvider() {
 
     companion object {
         private const val TAG = "StaticWidget"
-        internal const val RECEIVE_DATA =
-            "io.homeassistant.companion.android.widgets.entity.StaticWidget.RECEIVE_DATA"
-        internal const val UPDATE_ENTITY =
-            "io.homeassistant.companion.android.widgets.entity.StaticWidget.UPDATE_ENTITY"
 
         internal const val EXTRA_ENTITY_ID = "EXTRA_ENTITY_ID"
         internal const val EXTRA_ATTRIBUTE_IDS = "EXTRA_ATTRIBUTE_IDS"
@@ -40,69 +29,16 @@ class EntityWidget : AppWidgetProvider() {
         internal const val EXTRA_TEXT_SIZE = "EXTRA_TEXT_SIZE"
         internal const val EXTRA_STATE_SEPARATOR = "EXTRA_STATE_SEPARATOR"
         internal const val EXTRA_ATTRIBUTE_SEPARATOR = "EXTRA_ATTRIBUTE_SEPARATOR"
-
-        private var lastIntent = ""
-    }
-
-    @Inject
-    lateinit var integrationUseCase: IntegrationRepository
-
-    private lateinit var staticWidgetDao: StaticWidgetDao
-
-    private val mainScope: CoroutineScope = CoroutineScope(Dispatchers.Main + Job())
-
-    override fun onUpdate(
-        context: Context,
-        appWidgetManager: AppWidgetManager,
-        appWidgetIds: IntArray
-    ) {
-        staticWidgetDao = AppDatabase.getInstance(context).staticWidgetDao()
-        // There may be multiple widgets active, so update all of them
-        appWidgetIds.forEach { appWidgetId ->
-            updateAppWidget(
-                context,
-                appWidgetId,
-                appWidgetManager
-            )
-        }
-    }
-
-    private fun updateAppWidget(
-        context: Context,
-        appWidgetId: Int,
-        appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(context)
-    ) {
-        if (!isConnectionActive(context)) {
-            Log.d(TAG, "Skipping widget update since network connection is not active")
-            return
-        }
-
-        mainScope.launch {
-            val views = getWidgetRemoteViews(context, appWidgetId)
-            appWidgetManager.updateAppWidget(appWidgetId, views)
-        }
     }
 
-    private fun updateAllWidgets(
-        context: Context,
-        staticWidgetEntityList: Array<StaticWidgetEntity>?
-    ) {
-        if (staticWidgetEntityList != null) {
-            Log.d(TAG, "Updating all widgets")
-            for (item in staticWidgetEntityList) {
-                updateAppWidget(context, item.id)
-            }
-        }
-    }
-
-    private suspend fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews {
+    override suspend fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews {
         val intent = Intent(context, EntityWidget::class.java).apply {
-            action = UPDATE_ENTITY
+            action = UPDATE_VIEW
             putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
         }
 
         val views = RemoteViews(context.packageName, R.layout.widget_static).apply {
-            val widget = staticWidgetDao.get(appWidgetId)
+            val widget = AppDatabase.getInstance(context).staticWidgetDao().get(appWidgetId)
             if (widget != null) {
                 val entityId: String = widget.entityId
                 val attributeIds: String? = widget.attributeIds
@@ -117,7 +53,14 @@ class EntityWidget : AppWidgetProvider() {
                 )
                 setTextViewText(
                     R.id.widgetText,
-                    resolveTextToShow(context, entityId, attributeIds, stateSeparator, attributeSeparator, appWidgetId)
+                    resolveTextToShow(
+                        context,
+                        entityId,
+                        attributeIds,
+                        stateSeparator,
+                        attributeSeparator,
+                        appWidgetId
+                    )
                 )
                 setTextViewText(
                     R.id.widgetLabel,
@@ -138,6 +81,10 @@ class EntityWidget : AppWidgetProvider() {
         return views
     }
 
+    override fun getAllWidgetIds(context: Context): List<Int> {
+        return AppDatabase.getInstance(context).staticWidgetDao().getAll()?.map { it.id }.orEmpty()
+    }
+
     private suspend fun resolveTextToShow(
         context: Context,
         entityId: String?,
@@ -146,16 +93,21 @@ class EntityWidget : AppWidgetProvider() {
         attributeSeparator: String,
         appWidgetId: Int
     ): CharSequence? {
+        val staticWidgetDao = AppDatabase.getInstance(context).staticWidgetDao()
         var entity: Entity<Map<String, Any>>? = null
         try {
             entity = entityId?.let { integrationUseCase.getEntity(it) }
         } catch (e: Exception) {
             Log.e(TAG, "Unable to fetch entity", e)
-            if (lastIntent == UPDATE_ENTITY)
-                Toast.makeText(context, R.string.widget_entity_fetch_error, Toast.LENGTH_LONG).show()
+            if (lastIntent == UPDATE_VIEW)
+                Toast.makeText(context, R.string.widget_entity_fetch_error, Toast.LENGTH_LONG)
+                    .show()
         }
         if (attributeIds == null) {
-            staticWidgetDao.updateWidgetLastUpdate(appWidgetId, entity?.state ?: staticWidgetDao.get(appWidgetId)?.lastUpdate ?: "")
+            staticWidgetDao.updateWidgetLastUpdate(
+                appWidgetId,
+                entity?.state ?: staticWidgetDao.get(appWidgetId)?.lastUpdate ?: ""
+            )
             return staticWidgetDao.get(appWidgetId)?.lastUpdate
         }
 
@@ -163,42 +115,23 @@ class EntityWidget : AppWidgetProvider() {
         var attributeValues: List<String?>
         try {
             fetchedAttributes = entity?.attributes as? Map<*, *> ?: mapOf<String, String>()
-            attributeValues = attributeIds.split(",").map { id -> fetchedAttributes.get(id)?.toString() }
-            val lastUpdate = entity?.state.plus(if (attributeValues.isNotEmpty()) stateSeparator else "").plus(attributeValues.joinToString(attributeSeparator))
+            attributeValues =
+                attributeIds.split(",").map { id -> fetchedAttributes.get(id)?.toString() }
+            val lastUpdate =
+                entity?.state.plus(if (attributeValues.isNotEmpty()) stateSeparator else "")
+                    .plus(attributeValues.joinToString(attributeSeparator))
             staticWidgetDao.updateWidgetLastUpdate(appWidgetId, lastUpdate)
             return lastUpdate
         } catch (e: Exception) {
             Log.e(TAG, "Unable to fetch entity state and attributes", e)
-            if (lastIntent == UPDATE_ENTITY)
-                Toast.makeText(context, R.string.widget_entity_fetch_error, Toast.LENGTH_LONG).show()
+            if (lastIntent == UPDATE_VIEW)
+                Toast.makeText(context, R.string.widget_entity_fetch_error, Toast.LENGTH_LONG)
+                    .show()
         }
         return staticWidgetDao.get(appWidgetId)?.lastUpdate
     }
 
-    override fun onReceive(context: Context, intent: Intent) {
-        lastIntent = intent.action.toString()
-        val appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
-
-        Log.d(
-            TAG,
-            "Broadcast received: " + System.lineSeparator() +
-                "Broadcast action: " + lastIntent + System.lineSeparator() +
-                "AppWidgetId: " + appWidgetId
-        )
-
-        staticWidgetDao = AppDatabase.getInstance(context).staticWidgetDao()
-        val staticWidgetList = staticWidgetDao.getAll()
-
-        super.onReceive(context, intent)
-
-        when (lastIntent) {
-            RECEIVE_DATA -> saveEntityConfiguration(context, intent.extras, appWidgetId)
-            UPDATE_ENTITY -> updateAppWidget(context, appWidgetId)
-            Intent.ACTION_SCREEN_ON -> updateAllWidgets(context, staticWidgetList)
-        }
-    }
-
-    private fun saveEntityConfiguration(context: Context, extras: Bundle?, appWidgetId: Int) {
+    override fun saveEntityConfiguration(context: Context, extras: Bundle?, appWidgetId: Int) {
         if (extras == null) return
 
         val entitySelection: String? = extras.getString(EXTRA_ENTITY_ID)
@@ -214,6 +147,7 @@ class EntityWidget : AppWidgetProvider() {
         }
 
         mainScope.launch {
+            val staticWidgetDao = AppDatabase.getInstance(context).staticWidgetDao()
             Log.d(
                 TAG,
                 "Saving entity state config data:" + System.lineSeparator() +
@@ -238,15 +172,9 @@ class EntityWidget : AppWidgetProvider() {
     }
 
     override fun onDeleted(context: Context, appWidgetIds: IntArray) {
-        staticWidgetDao = AppDatabase.getInstance(context).staticWidgetDao()
+        val staticWidgetDao = AppDatabase.getInstance(context).staticWidgetDao()
         appWidgetIds.forEach { appWidgetId ->
             staticWidgetDao.delete(appWidgetId)
         }
     }
-
-    private fun isConnectionActive(context: Context): Boolean {
-        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
-        val activeNetworkInfo = connectivityManager.activeNetworkInfo
-        return activeNetworkInfo?.isConnected ?: false
-    }
 }
diff --git a/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt b/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt
index a43fab0d3e6..5effe970404 100644
--- a/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt
@@ -21,6 +21,7 @@ import io.homeassistant.companion.android.common.data.integration.Entity
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
 import io.homeassistant.companion.android.database.AppDatabase
 import io.homeassistant.companion.android.databinding.WidgetStaticConfigureBinding
+import io.homeassistant.companion.android.widgets.BaseWidgetProvider
 import io.homeassistant.companion.android.widgets.common.SingleItemArrayAdapter
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
@@ -186,7 +187,7 @@ class EntityWidgetConfigureActivity : BaseActivity() {
 
             // Set up a broadcast intent and pass the service call data as extras
             val intent = Intent()
-            intent.action = EntityWidget.RECEIVE_DATA
+            intent.action = BaseWidgetProvider.RECEIVE_DATA
             intent.component = ComponentName(context, EntityWidget::class.java)
 
             intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
diff --git a/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidget.kt b/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidget.kt
index 7d03151009b..a670eca1bf6 100644
--- a/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidget.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidget.kt
@@ -2,10 +2,8 @@ package io.homeassistant.companion.android.widgets.template
 
 import android.app.PendingIntent
 import android.appwidget.AppWidgetManager
-import android.appwidget.AppWidgetProvider
 import android.content.Context
 import android.content.Intent
-import android.net.ConnectivityManager
 import android.os.Bundle
 import android.text.Html.fromHtml
 import android.util.Log
@@ -13,90 +11,32 @@ import android.widget.RemoteViews
 import android.widget.Toast
 import dagger.hilt.android.AndroidEntryPoint
 import io.homeassistant.companion.android.R
-import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.widget.TemplateWidgetDao
 import io.homeassistant.companion.android.database.widget.TemplateWidgetEntity
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.Job
+import io.homeassistant.companion.android.widgets.BaseWidgetProvider
 import kotlinx.coroutines.launch
-import javax.inject.Inject
 
 @AndroidEntryPoint
-class TemplateWidget : AppWidgetProvider() {
+class TemplateWidget : BaseWidgetProvider() {
     companion object {
         private const val TAG = "TemplateWidget"
-        private const val UPDATE_VIEW =
-            "io.homeassistant.companion.android.widgets.template.TemplateWidget.UPDATE_VIEW"
-        internal const val RECEIVE_DATA =
-            "io.homeassistant.companion.android.widgets.template.TemplateWidget.RECEIVE_DATA"
-
         internal const val EXTRA_TEMPLATE = "extra_template"
-        private var lastIntent = ""
-    }
-
-    @Inject
-    lateinit var integrationUseCase: IntegrationRepository
-
-    private lateinit var templateWidgetDao: TemplateWidgetDao
-
-    private val mainScope: CoroutineScope = CoroutineScope(Dispatchers.Main + Job())
-
-    override fun onUpdate(
-        context: Context,
-        appWidgetManager: AppWidgetManager,
-        appWidgetIds: IntArray
-    ) {
-        templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
-        // There may be multiple widgets active, so update all of them
-        for (appWidgetId in appWidgetIds) {
-            mainScope.launch {
-                val views = getWidgetRemoteViews(context, appWidgetId)
-                appWidgetManager.updateAppWidget(appWidgetId, views)
-            }
-        }
     }
 
     override fun onDeleted(context: Context, appWidgetIds: IntArray) {
-        templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
+        val templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
         // When the user deletes the widget, delete the preference associated with it.
         for (appWidgetId in appWidgetIds) {
             templateWidgetDao.delete(appWidgetId)
         }
     }
 
-    override fun onEnabled(context: Context) {
-        // Enter relevant functionality for when the first widget is created
-    }
-
-    override fun onDisabled(context: Context) {
-        // Enter relevant functionality for when the last widget is disabled
-    }
-
-    override fun onReceive(context: Context, intent: Intent) {
-        lastIntent = intent.action.toString()
-        val appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1)
-
-        Log.d(
-            TAG,
-            "Broadcast received: " + System.lineSeparator() +
-                "Broadcast action: " + lastIntent + System.lineSeparator() +
-                "AppWidgetId: " + appWidgetId
-        )
-
-        templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
-        val templateWidgetList = templateWidgetDao.getAll()
-
-        super.onReceive(context, intent)
-        when (lastIntent) {
-            UPDATE_VIEW -> updateView(context, appWidgetId)
-            RECEIVE_DATA -> saveEntityConfiguration(context, intent.extras, appWidgetId)
-            Intent.ACTION_SCREEN_ON -> updateAllWidgets(context, templateWidgetList)
-        }
+    override fun getAllWidgetIds(context: Context): List<Int> {
+        val templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
+        return templateWidgetDao.getAll()?.map { it.id }.orEmpty()
     }
 
-    private suspend fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews {
+    override suspend fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews {
         // Every time AppWidgetManager.updateAppWidget(...) is called, the button listener
         // and label need to be re-assigned, or the next time the layout updates
         // (e.g home screen rotation) the widget will fall back on its default layout
@@ -107,6 +47,7 @@ class TemplateWidget : AppWidgetProvider() {
             putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
         }
 
+        val templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
         val widget = templateWidgetDao.get(appWidgetId)
 
         return RemoteViews(context.packageName, R.layout.widget_template).apply {
@@ -128,7 +69,8 @@ class TemplateWidget : AppWidgetProvider() {
                 } catch (e: Exception) {
                     Log.e(TAG, "Unable to render template: ${widget.template}", e)
                     if (lastIntent == UPDATE_VIEW)
-                        Toast.makeText(context, R.string.widget_template_error, Toast.LENGTH_LONG).show()
+                        Toast.makeText(context, R.string.widget_template_error, Toast.LENGTH_LONG)
+                            .show()
                 }
                 setTextViewText(
                     R.id.widgetTemplateText,
@@ -138,36 +80,7 @@ class TemplateWidget : AppWidgetProvider() {
         }
     }
 
-    private fun updateView(
-        context: Context,
-        appWidgetId: Int,
-        appWidgetManager: AppWidgetManager = AppWidgetManager.getInstance(context)
-    ) {
-        if (!isConnectionActive(context)) {
-            Log.d(TAG, "Skipping widget update since network connection is not active")
-            return
-        }
-
-        Log.d(TAG, "Updating Template Widget View: $appWidgetId")
-        mainScope.launch {
-            val views = getWidgetRemoteViews(context, appWidgetId)
-            appWidgetManager.updateAppWidget(appWidgetId, views)
-        }
-    }
-
-    private fun updateAllWidgets(
-        context: Context,
-        templateWidgetList: Array<TemplateWidgetEntity>?
-    ) {
-        if (templateWidgetList != null) {
-            Log.d(TAG, "Updating all widgets")
-            for (item in templateWidgetList) {
-                updateView(context, item.id)
-            }
-        }
-    }
-
-    private fun saveEntityConfiguration(context: Context, extras: Bundle?, appWidgetId: Int) {
+    override fun saveEntityConfiguration(context: Context, extras: Bundle?, appWidgetId: Int) {
         if (extras == null) return
 
         val template: String? = extras.getString(EXTRA_TEMPLATE)
@@ -176,6 +89,7 @@ class TemplateWidget : AppWidgetProvider() {
             Log.e(TAG, "Did not receive complete widget data")
             return
         }
+        val templateWidgetDao = AppDatabase.getInstance(context).templateWidgetDao()
 
         mainScope.launch {
             templateWidgetDao.add(
@@ -188,10 +102,4 @@ class TemplateWidget : AppWidgetProvider() {
             onUpdate(context, AppWidgetManager.getInstance(context), intArrayOf(appWidgetId))
         }
     }
-
-    private fun isConnectionActive(context: Context): Boolean {
-        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
-        val activeNetworkInfo = connectivityManager.activeNetworkInfo
-        return activeNetworkInfo?.isConnected ?: false
-    }
 }
diff --git a/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt b/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt
index 08642554ba8..24764a0e95d 100644
--- a/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt
@@ -15,6 +15,7 @@ import io.homeassistant.companion.android.R
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
 import io.homeassistant.companion.android.database.AppDatabase
 import io.homeassistant.companion.android.databinding.WidgetTemplateConfigureBinding
+import io.homeassistant.companion.android.widgets.BaseWidgetProvider
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.Job
@@ -92,7 +93,7 @@ class TemplateWidgetConfigureActivity : BaseActivity() {
 
         binding.addButton.setOnClickListener {
             val createIntent = Intent().apply {
-                action = TemplateWidget.RECEIVE_DATA
+                action = BaseWidgetProvider.RECEIVE_DATA
                 component = ComponentName(applicationContext, TemplateWidget::class.java)
                 putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                 putExtra(TemplateWidget.EXTRA_TEMPLATE, binding.templateText.text.toString())
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/DataModule.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/DataModule.kt
index 64d617f4c8a..ba57aad0407 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/DataModule.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/DataModule.kt
@@ -28,6 +28,7 @@ import io.homeassistant.companion.android.common.data.wifi.WifiHelper
 import io.homeassistant.companion.android.common.data.wifi.WifiHelperImpl
 import okhttp3.OkHttpClient
 import javax.inject.Named
+import javax.inject.Singleton
 
 @Module
 @InstallIn(SingletonComponent::class)
@@ -35,19 +36,23 @@ abstract class DataModule {
 
     companion object {
         @Provides
+        @Singleton
         fun provideAuthenticationService(homeAssistantApis: HomeAssistantApis): AuthenticationService =
             homeAssistantApis.retrofit.create(AuthenticationService::class.java)
 
         @Provides
+        @Singleton
         fun providesIntegrationService(homeAssistantApis: HomeAssistantApis): IntegrationService =
             homeAssistantApis.retrofit.create(IntegrationService::class.java)
 
         @Provides
+        @Singleton
         fun providesOkHttpClient(homeAssistantApis: HomeAssistantApis): OkHttpClient =
             homeAssistantApis.okHttpClient
 
         @Provides
         @Named("url")
+        @Singleton
         fun provideUrlLocalStorage(@ApplicationContext appContext: Context): LocalStorage =
             LocalStorageImpl(
                 appContext.getSharedPreferences(
@@ -58,6 +63,7 @@ abstract class DataModule {
 
         @Provides
         @Named("session")
+        @Singleton
         fun provideSessionLocalStorage(@ApplicationContext appContext: Context): LocalStorage =
             LocalStorageImpl(
                 appContext.getSharedPreferences(
@@ -68,6 +74,7 @@ abstract class DataModule {
 
         @Provides
         @Named("integration")
+        @Singleton
         fun provideIntegrationLocalStorage(@ApplicationContext appContext: Context): LocalStorage =
             LocalStorageImpl(
                 appContext.getSharedPreferences(
@@ -78,6 +85,7 @@ abstract class DataModule {
 
         @Provides
         @Named("themes")
+        @Singleton
         fun providePrefsLocalStorage(@ApplicationContext appContext: Context): LocalStorage =
             LocalStorageImpl(
                 appContext.getSharedPreferences(
@@ -88,43 +96,54 @@ abstract class DataModule {
 
         @Provides
         @Named("manufacturer")
+        @Singleton
         fun provideDeviceManufacturer(): String = Build.MANUFACTURER
 
         @Provides
         @Named("model")
+        @Singleton
         fun provideDeviceModel(): String = Build.MODEL
 
         @Provides
         @Named("osVersion")
+        @Singleton
         fun provideDeviceOsVersion() = Build.VERSION.SDK_INT.toString()
 
         @SuppressLint("HardwareIds")
         @Provides
         @Named("deviceId")
+        @Singleton
         fun provideDeviceId(@ApplicationContext appContext: Context) = Settings.Secure.getString(
             appContext.contentResolver,
             Settings.Secure.ANDROID_ID
         )
 
         @Provides
+        @Singleton
         fun wifiManager(@ApplicationContext appContext: Context) = appContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
     }
 
     @Binds
+    @Singleton
     abstract fun bindAuthRepository(authenticationRepository: AuthenticationRepositoryImpl): AuthenticationRepository
 
     @Binds
+    @Singleton
     abstract fun bindIntegrationRepository(integrationRepository: IntegrationRepositoryImpl): IntegrationRepository
 
     @Binds
+    @Singleton
     abstract fun bindPrefsRepository(prefsRepository: PrefsRepositoryImpl): PrefsRepository
 
     @Binds
+    @Singleton
     abstract fun bindUrlRepository(urlRepository: UrlRepositoryImpl): UrlRepository
 
     @Binds
+    @Singleton
     abstract fun bindWebSocketRepository(webSocketRepository: WebSocketRepositoryImpl): WebSocketRepository
 
     @Binds
+    @Singleton
     abstract fun bindWifiRepository(wifiHelper: WifiHelperImpl): WifiHelper
 }
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt
index 426c037918b..6c96a4fa033 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt
@@ -31,6 +31,8 @@ import kotlinx.coroutines.flow.shareIn
 import kotlinx.coroutines.isActive
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.suspendCancellableCoroutine
+import kotlinx.coroutines.sync.Mutex
+import kotlinx.coroutines.sync.withLock
 import kotlinx.coroutines.withTimeout
 import okhttp3.OkHttpClient
 import okhttp3.Request
@@ -57,7 +59,9 @@ class WebSocketRepositoryImpl @Inject constructor(
     private val responseCallbackJobs = mutableMapOf<Long, CancellableContinuation<SocketResponse>>()
     private val id = AtomicLong(1)
     private var connection: WebSocket? = null
+    private val connectedMutex = Mutex()
     private var connected = Job()
+    private val stateChangedMutex = Mutex()
     private var stateChangedFlow: SharedFlow<StateChangedEvent>? = null
 
     @ExperimentalCoroutinesApi
@@ -123,62 +127,65 @@ class WebSocketRepositoryImpl @Inject constructor(
 
     @ExperimentalCoroutinesApi
     override suspend fun getStateChanges(): Flow<StateChangedEvent> {
-        if (stateChangedFlow == null) {
+        stateChangedMutex.withLock {
+            if (stateChangedFlow == null) {
 
-            val response = sendMessage(
-                mapOf(
-                    "type" to "subscribe_events",
-                    "event_type" to "state_changed"
+                val response = sendMessage(
+                    mapOf(
+                        "type" to "subscribe_events",
+                        "event_type" to "state_changed"
+                    )
                 )
-            )
 
-            stateChangedFlow = callbackFlow {
-                producerScope = this
-                awaitClose {
-                    Log.d(TAG, "Unsubscribing from state_changes")
-                    ioScope.launch {
-                        sendMessage(
-                            mapOf(
-                                "type" to "unsubscribe_events",
-                                "subscription" to response.id
+                stateChangedFlow = callbackFlow {
+                    producerScope = this
+                    awaitClose {
+                        Log.d(TAG, "Unsubscribing from state_changes")
+                        ioScope.launch {
+                            sendMessage(
+                                mapOf(
+                                    "type" to "unsubscribe_events",
+                                    "subscription" to response.id
+                                )
                             )
-                        )
+                        }
+                        producerScope = null
+                        stateChangedFlow = null
                     }
-                    producerScope = null
-                    stateChangedFlow = null
-                }
-            }.shareIn(ioScope, SharingStarted.WhileSubscribed())
-        }
+                }.shareIn(ioScope, SharingStarted.WhileSubscribed())
+            }
 
-        return stateChangedFlow!!
+            return stateChangedFlow!!
+        }
     }
 
     /**
      * This method will
      */
-    @Synchronized
     private suspend fun connect() {
-        if (connection != null && connected.isCompleted) {
-            return
-        }
+        connectedMutex.withLock {
+            if (connection != null && connected.isCompleted) {
+                return
+            }
 
-        val url = urlRepository.getUrl() ?: throw Exception("Unable to get URL for WebSocket")
-        val urlString = url.toString()
-            .replace("https://", "wss://")
-            .replace("http://", "ws://")
-            .plus("api/websocket")
+            val url = urlRepository.getUrl() ?: throw Exception("Unable to get URL for WebSocket")
+            val urlString = url.toString()
+                .replace("https://", "wss://")
+                .replace("http://", "ws://")
+                .plus("api/websocket")
 
-        connection = okHttpClient.newWebSocket(
-            Request.Builder().url(urlString).build(),
-            this
-        )
+            connection = okHttpClient.newWebSocket(
+                Request.Builder().url(urlString).build(),
+                this
+            )
 
-        // Preemptively send auth
-        authenticate()
+            // Preemptively send auth
+            authenticate()
 
-        // Wait up to 30 seconds for auth response
-        withTimeout(30000) {
-            connected.join()
+            // Wait up to 30 seconds for auth response
+            withTimeout(30000) {
+                connected.join()
+            }
         }
     }
 
