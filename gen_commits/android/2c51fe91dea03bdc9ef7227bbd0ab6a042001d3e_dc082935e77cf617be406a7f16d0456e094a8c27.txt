diff --git a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidget.kt b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidget.kt
index 92e79b274db..d1992930d77 100644
--- a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidget.kt
+++ b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidget.kt
@@ -158,7 +158,7 @@ class ButtonWidget : AppWidgetProvider() {
         context.startActivity(intent)
     }
 
-    private fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews {
+    private suspend fun getWidgetRemoteViews(context: Context, appWidgetId: Int): RemoteViews {
         // Every time AppWidgetManager.updateAppWidget(...) is called, the button listener
         // and label need to be re-assigned, or the next time the layout updates
         // (e.g home screen rotation) the widget will fall back on its default layout
@@ -278,9 +278,8 @@ class ButtonWidget : AppWidgetProvider() {
         loadingViews.setViewVisibility(R.id.widgetImageButtonLayout, View.GONE)
         appWidgetManager.partiallyUpdateAppWidget(appWidgetId, loadingViews)
 
-        val widget = buttonWidgetDao.get(appWidgetId)
-
         mainScope.launch {
+            val widget = buttonWidgetDao.get(appWidgetId)
             // Set default feedback as negative
             var feedbackColor = R.drawable.widget_button_background_red
             var feedbackIcon = R.drawable.ic_clear_black
diff --git a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidgetConfigureActivity.kt b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidgetConfigureActivity.kt
index e088409f858..078de405ca7 100644
--- a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidgetConfigureActivity.kt
+++ b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/button/ButtonWidgetConfigureActivity.kt
@@ -50,14 +50,15 @@ import io.homeassistant.companion.android.widgets.common.SingleItemArrayAdapter
 import io.homeassistant.companion.android.widgets.common.WidgetDynamicFieldAdapter
 import io.homeassistant.companion.android.widgets.common.WidgetUtils
 import javax.inject.Inject
+import kotlinx.coroutines.Job
 import kotlinx.coroutines.launch
 import timber.log.Timber
 
 @AndroidEntryPoint
 class ButtonWidgetConfigureActivity : BaseWidgetConfigureActivity() {
     companion object {
-        @Suppress("ktlint:standard:max-line-length")
-        private const val PIN_WIDGET_CALLBACK = "io.homeassistant.companion.android.widgets.button.ButtonWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
+        private const val PIN_WIDGET_CALLBACK =
+            "io.homeassistant.companion.android.widgets.button.ButtonWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
     }
 
     @Inject
@@ -123,80 +124,88 @@ class ButtonWidgetConfigureActivity : BaseWidgetConfigureActivity() {
 
     private val actionTextWatcher: TextWatcher = (
         object : TextWatcher {
+            private var ongoingJob: Job? = null
+
             @SuppressLint("NotifyDataSetChanged")
             override fun afterTextChanged(p0: Editable?) {
                 val actionText: String = p0.toString()
+                // To make sure only one job at the time is updating the data we keep a reference to the job and cancel
+                // it if it gets call again.
+                ongoingJob?.cancel()
+                ongoingJob = lifecycleScope.launch {
+                    if (actions[selectedServerId].orEmpty().keys.contains(actionText)) {
+                        Timber.d("Valid domain and action--processing dynamic fields")
+
+                        // Make sure there are not already any dynamic fields created
+                        // This can happen if selecting the drop-down twice or pasting
+                        dynamicFields.clear()
 
-                if (actions[selectedServerId].orEmpty().keys.contains(actionText)) {
-                    Timber.d("Valid domain and action--processing dynamic fields")
-
-                    // Make sure there are not already any dynamic fields created
-                    // This can happen if selecting the drop-down twice or pasting
-                    dynamicFields.clear()
-
-                    // We only call this if servicesAvailable was fetched and is not null,
-                    // so we can safely assume that it is not null here
-                    val actionData = actions[selectedServerId]!![actionText]!!.actionData
-                    val target = actionData.target
-                    val fields = actionData.fields
-
-                    val fieldKeys = fields.keys
-                    Timber.d("Fields applicable to this action: $fields")
-
-                    val existingActionData = mutableMapOf<String, Any?>()
-                    val addedFields = mutableListOf<String>()
-                    buttonWidgetDao.get(appWidgetId)?.let { buttonWidget ->
-                        if (
-                            buttonWidget.serverId != selectedServerId ||
-                            "${buttonWidget.domain}.${buttonWidget.service}" != actionText
-                        ) {
-                            return@let
+                        // We only call this if servicesAvailable was fetched and is not null,
+                        // so we can safely assume that it is not null here
+                        val actionData = actions[selectedServerId]!![actionText]!!.actionData
+                        val target = actionData.target
+                        val fields = actionData.fields
+
+                        val fieldKeys = fields.keys
+                        Timber.d("Fields applicable to this action: $fields")
+
+                        val existingActionData = mutableMapOf<String, Any?>()
+                        val addedFields = mutableListOf<String>()
+                        buttonWidgetDao.get(appWidgetId)?.let { buttonWidget ->
+                            if (
+                                buttonWidget.serverId != selectedServerId ||
+                                "${buttonWidget.domain}.${buttonWidget.service}" != actionText
+                            ) {
+                                return@let
+                            }
+
+                            val dbMap: Map<String, Any?> = kotlinJsonMapper.decodeFromString(
+                                MapAnySerializer,
+                                buttonWidget.serviceData,
+                            )
+                            for (item in dbMap) {
+                                val value =
+                                    item.value.toString().replace("[", "").replace("]", "") +
+                                        if (item.key == "entity_id") ", " else ""
+                                existingActionData[item.key] = value.ifEmpty { null }
+                                addedFields.add(item.key)
+                            }
                         }
 
-                        val dbMap: Map<String, Any?> = kotlinJsonMapper.decodeFromString(
-                            MapAnySerializer,
-                            buttonWidget.serviceData,
-                        )
-                        for (item in dbMap) {
-                            val value =
-                                item.value.toString().replace("[", "").replace("]", "") +
-                                    if (item.key == "entity_id") ", " else ""
-                            existingActionData[item.key] = value.ifEmpty { null }
-                            addedFields.add(item.key)
+                        if (target != false) {
+                            dynamicFields.add(
+                                0,
+                                ActionFieldBinder(actionText, "entity_id", existingActionData["entity_id"]),
+                            )
                         }
-                    }
-
-                    if (target != false) {
-                        dynamicFields.add(
-                            0,
-                            ActionFieldBinder(actionText, "entity_id", existingActionData["entity_id"]),
-                        )
-                    }
-
-                    fieldKeys.sorted().forEach { fieldKey ->
-                        Timber.d("Creating a text input box for $fieldKey")
 
-                        // Insert a dynamic layout
-                        // IDs get priority and go at the top, since the other fields
-                        // are usually optional but the ID is required
-                        if (fieldKey.contains("_id")) {
-                            dynamicFields.add(0, ActionFieldBinder(actionText, fieldKey, existingActionData[fieldKey]))
-                        } else {
-                            dynamicFields.add(ActionFieldBinder(actionText, fieldKey, existingActionData[fieldKey]))
+                        fieldKeys.sorted().forEach { fieldKey ->
+                            Timber.d("Creating a text input box for $fieldKey")
+
+                            // Insert a dynamic layout
+                            // IDs get priority and go at the top, since the other fields
+                            // are usually optional but the ID is required
+                            if (fieldKey.contains("_id")) {
+                                dynamicFields.add(
+                                    0,
+                                    ActionFieldBinder(actionText, fieldKey, existingActionData[fieldKey]),
+                                )
+                            } else {
+                                dynamicFields.add(ActionFieldBinder(actionText, fieldKey, existingActionData[fieldKey]))
+                            }
+                        }
+                        addedFields.minus("entity_id").minus(fieldKeys).forEach { extraFieldKey ->
+                            Timber.d("Creating a text input box for extra $extraFieldKey")
+                            dynamicFields.add(
+                                ActionFieldBinder(actionText, extraFieldKey, existingActionData[extraFieldKey]),
+                            )
                         }
-                    }
-                    addedFields.minus("entity_id").minus(fieldKeys).forEach { extraFieldKey ->
-                        Timber.d("Creating a text input box for extra $extraFieldKey")
-                        dynamicFields.add(
-                            ActionFieldBinder(actionText, extraFieldKey, existingActionData[extraFieldKey]),
-                        )
-                    }
-
-                    dynamicFieldAdapter.notifyDataSetChanged()
-                } else {
-                    if (dynamicFields.size > 0) {
-                        dynamicFields.clear()
                         dynamicFieldAdapter.notifyDataSetChanged()
+                    } else {
+                        if (dynamicFields.isNotEmpty()) {
+                            dynamicFields.clear()
+                            dynamicFieldAdapter.notifyDataSetChanged()
+                        }
                     }
                 }
             }
@@ -241,41 +250,71 @@ class ButtonWidgetConfigureActivity : BaseWidgetConfigureActivity() {
             return
         }
 
-        val buttonWidget = buttonWidgetDao.get(appWidgetId)
         val backgroundTypeValues = WidgetUtils.getBackgroundOptionList(this)
         binding.backgroundType.adapter =
             ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, backgroundTypeValues)
 
-        if (buttonWidget != null) {
-            val actionText = "${buttonWidget.domain}.${buttonWidget.service}"
-            binding.widgetTextConfigService.setText(actionText)
-            binding.label.setText(buttonWidget.label)
-            binding.backgroundType.setSelection(
-                WidgetUtils.getSelectedBackgroundOption(
-                    this,
-                    buttonWidget.backgroundType,
-                    backgroundTypeValues,
-                ),
-            )
-            binding.textColor.isVisible = buttonWidget.backgroundType == WidgetBackgroundType.TRANSPARENT
-            binding.textColorWhite.isChecked =
-                buttonWidget.textColor?.let { it.toColorInt() == ContextCompat.getColor(this, android.R.color.white) }
-                    ?: true
-            binding.textColorBlack.isChecked =
-                buttonWidget.textColor?.let {
-                    it.toColorInt() ==
-                        ContextCompat.getColor(this, commonR.color.colorWidgetButtonLabelBlack)
-                }
-                    ?: false
+        lifecycleScope.launch {
+            val buttonWidget = buttonWidgetDao.get(appWidgetId)
+            if (buttonWidget != null) {
+                val actionText = "${buttonWidget.domain}.${buttonWidget.service}"
+                binding.widgetTextConfigService.setText(actionText)
+                binding.label.setText(buttonWidget.label)
+                binding.backgroundType.setSelection(
+                    WidgetUtils.getSelectedBackgroundOption(
+                        this@ButtonWidgetConfigureActivity,
+                        buttonWidget.backgroundType,
+                        backgroundTypeValues,
+                    ),
+                )
+                binding.textColor.isVisible = buttonWidget.backgroundType == WidgetBackgroundType.TRANSPARENT
+                binding.textColorWhite.isChecked =
+                    buttonWidget.textColor?.let {
+                        it.toColorInt() == ContextCompat.getColor(
+                            this@ButtonWidgetConfigureActivity,
+                            android.R.color.white,
+                        )
+                    }
+                        ?: true
+                binding.textColorBlack.isChecked =
+                    buttonWidget.textColor?.let {
+                        it.toColorInt() ==
+                            ContextCompat.getColor(
+                                this@ButtonWidgetConfigureActivity,
+                                commonR.color.colorWidgetButtonLabelBlack,
+                            )
+                    }
+                        ?: false
 
-            binding.addButton.setText(commonR.string.update_widget)
+                binding.addButton.setText(commonR.string.update_widget)
 
-            binding.widgetCheckboxRequireAuthentication.isChecked = buttonWidget.requireAuthentication
-        } else {
-            binding.backgroundType.setSelection(0)
-        }
+                binding.widgetCheckboxRequireAuthentication.isChecked = buttonWidget.requireAuthentication
+            } else {
+                binding.backgroundType.setSelection(0)
+            }
 
-        setupServerSelect(buttonWidget?.serverId)
+            setupServerSelect(buttonWidget?.serverId)
+
+            // Do this off the main thread, takes a second or two...
+            runOnUiThread {
+                // Create an icon pack and load all drawables.
+                val iconName = buttonWidget?.iconName ?: "mdi:flash"
+                val icon = CommunityMaterial.getIconByMdiName(iconName) ?: CommunityMaterial.Icon2.cmd_flash
+                onIconDialogIconsSelected(icon)
+                binding.widgetConfigIconSelector.setOnClickListener {
+                    var alertDialog: DialogFragment? = null
+
+                    alertDialog = IconDialogFragment(
+                        callback = {
+                            onIconDialogIconsSelected(it)
+                            alertDialog?.dismiss()
+                        },
+                    )
+
+                    alertDialog.show(supportFragmentManager, IconDialogFragment.TAG)
+                }
+            }
+        }
 
         actionAdapter = SingleItemArrayAdapter(this) {
             if (it != null) getActionString(it) else ""
@@ -360,26 +399,6 @@ class ButtonWidgetConfigureActivity : BaseWidgetConfigureActivity() {
         dynamicFieldAdapter = WidgetDynamicFieldAdapter(HashMap(), HashMap(), dynamicFields)
         binding.widgetConfigFieldsLayout.adapter = dynamicFieldAdapter
         binding.widgetConfigFieldsLayout.layoutManager = LinearLayoutManager(this)
-
-        // Do this off the main thread, takes a second or two...
-        runOnUiThread {
-            // Create an icon pack and load all drawables.
-            val iconName = buttonWidget?.iconName ?: "mdi:flash"
-            val icon = CommunityMaterial.getIconByMdiName(iconName) ?: CommunityMaterial.Icon2.cmd_flash
-            onIconDialogIconsSelected(icon)
-            binding.widgetConfigIconSelector.setOnClickListener {
-                var alertDialog: DialogFragment? = null
-
-                alertDialog = IconDialogFragment(
-                    callback = {
-                        onIconDialogIconsSelected(it)
-                        alertDialog?.dismiss()
-                    },
-                )
-
-                alertDialog.show(supportFragmentManager, IconDialogFragment.TAG)
-            }
-        }
     }
 
     override fun onNewIntent(intent: Intent) {
diff --git a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/camera/CameraWidgetConfigureActivity.kt b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/camera/CameraWidgetConfigureActivity.kt
index 96cc5f2fa2a..f16b076c62b 100755
--- a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/camera/CameraWidgetConfigureActivity.kt
+++ b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/camera/CameraWidgetConfigureActivity.kt
@@ -28,15 +28,14 @@ import io.homeassistant.companion.android.widgets.BaseWidgetConfigureActivity
 import io.homeassistant.companion.android.widgets.common.SingleItemArrayAdapter
 import javax.inject.Inject
 import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
 import timber.log.Timber
 
 @AndroidEntryPoint
 class CameraWidgetConfigureActivity : BaseWidgetConfigureActivity() {
 
     companion object {
-        @Suppress("ktlint:standard:max-line-length")
-        private const val PIN_WIDGET_CALLBACK = "io.homeassistant.companion.android.widgets.camera.CameraWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
+        private const val PIN_WIDGET_CALLBACK =
+            "io.homeassistant.companion.android.widgets.camera.CameraWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
     }
 
     private lateinit var binding: WidgetCameraConfigureBinding
@@ -114,13 +113,13 @@ class CameraWidgetConfigureActivity : BaseWidgetConfigureActivity() {
         }
         initTapActionsSpinner()
 
-        val cameraWidget = cameraWidgetDao.get(appWidgetId)
-        if (cameraWidget != null) {
-            setCurrentTapAction(tapAction = cameraWidget.tapAction)
-            binding.widgetTextConfigEntityId.setText(cameraWidget.entityId)
-            binding.addButton.setText(commonR.string.update_widget)
-            val entity = runBlocking {
-                try {
+        lifecycleScope.launch {
+            val cameraWidget = cameraWidgetDao.get(appWidgetId)
+            if (cameraWidget != null) {
+                setCurrentTapAction(tapAction = cameraWidget.tapAction)
+                binding.widgetTextConfigEntityId.setText(cameraWidget.entityId)
+                binding.addButton.setText(commonR.string.update_widget)
+                val entity = try {
                     serverManager.integrationRepository(cameraWidget.serverId).getEntity(cameraWidget.entityId)
                 } catch (e: Exception) {
                     Timber.e(e, "Unable to get entity information")
@@ -128,13 +127,14 @@ class CameraWidgetConfigureActivity : BaseWidgetConfigureActivity() {
                         .show()
                     null
                 }
+
+                if (entity != null) {
+                    selectedEntity = entity as Entity?
+                }
             }
-            if (entity != null) {
-                selectedEntity = entity as Entity?
-            }
-        }
 
-        setupServerSelect(cameraWidget?.serverId)
+            setupServerSelect(cameraWidget?.serverId)
+        }
 
         entityAdapter = SingleItemArrayAdapter(this) { it?.entityId ?: "" }
 
diff --git a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt
index a1d8295b5e4..98b19de6d07 100644
--- a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt
+++ b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/entity/EntityWidgetConfigureActivity.kt
@@ -40,15 +40,14 @@ import io.homeassistant.companion.android.widgets.common.SingleItemArrayAdapter
 import io.homeassistant.companion.android.widgets.common.WidgetUtils
 import javax.inject.Inject
 import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
 import timber.log.Timber
 
 @AndroidEntryPoint
 class EntityWidgetConfigureActivity : BaseWidgetConfigureActivity() {
 
     companion object {
-        @Suppress("ktlint:standard:max-line-length")
-        private const val PIN_WIDGET_CALLBACK = "io.homeassistant.companion.android.widgets.entity.EntityWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
+        private const val PIN_WIDGET_CALLBACK =
+            "io.homeassistant.companion.android.widgets.entity.EntityWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
     }
 
     @Inject
@@ -132,23 +131,15 @@ class EntityWidgetConfigureActivity : BaseWidgetConfigureActivity() {
             return
         }
 
-        val staticWidget = staticWidgetDao.get(appWidgetId)
+        lifecycleScope.launch {
+            val staticWidget = staticWidgetDao.get(appWidgetId)
 
-        val tapActionValues =
-            listOf(getString(commonR.string.widget_tap_action_toggle), getString(commonR.string.refresh))
-        binding.tapActionList.adapter =
-            ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, tapActionValues)
-        val backgroundTypeValues = WidgetUtils.getBackgroundOptionList(this)
-        binding.backgroundType.adapter =
-            ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, backgroundTypeValues)
-
-        if (staticWidget != null) {
-            binding.widgetTextConfigEntityId.setText(staticWidget.entityId)
-            binding.label.setText(staticWidget.label)
-            binding.textSize.setText(staticWidget.textSize.toInt().toString())
-            binding.stateSeparator.setText(staticWidget.stateSeparator)
-            val entity = runBlocking {
-                try {
+            if (staticWidget != null) {
+                binding.widgetTextConfigEntityId.setText(staticWidget.entityId)
+                binding.label.setText(staticWidget.label)
+                binding.textSize.setText(staticWidget.textSize.toInt().toString())
+                binding.stateSeparator.setText(staticWidget.stateSeparator)
+                val entity = try {
                     serverManager.integrationRepository(staticWidget.serverId).getEntity(staticWidget.entityId)
                 } catch (e: Exception) {
                     Timber.e(e, "Unable to get entity information")
@@ -156,54 +147,71 @@ class EntityWidgetConfigureActivity : BaseWidgetConfigureActivity() {
                         .show()
                     null
                 }
-            }
 
-            val attributeIds = staticWidget.attributeIds
-            if (!attributeIds.isNullOrEmpty()) {
-                binding.appendAttributeValueCheckbox.isChecked = true
-                appendAttributes = true
-                for (item in attributeIds.split(',')) {
-                    selectedAttributeIds.add(item)
+                val attributeIds = staticWidget.attributeIds
+                if (!attributeIds.isNullOrEmpty()) {
+                    binding.appendAttributeValueCheckbox.isChecked = true
+                    appendAttributes = true
+                    for (item in attributeIds.split(',')) {
+                        selectedAttributeIds.add(item)
+                    }
+                    binding.widgetTextConfigAttribute.setText(attributeIds.replace(",", ", "))
+                    binding.attributeValueLinearLayout.visibility = VISIBLE
+                    binding.attributeSeparator.setText(staticWidget.attributeSeparator)
                 }
-                binding.widgetTextConfigAttribute.setText(attributeIds.replace(",", ", "))
-                binding.attributeValueLinearLayout.visibility = VISIBLE
-                binding.attributeSeparator.setText(staticWidget.attributeSeparator)
-            }
-            if (entity != null) {
-                selectedEntity = entity
-                setupAttributes()
-            }
-
-            val toggleable = entity?.domain in EntityExt.APP_PRESS_ACTION_DOMAINS
-            binding.tapAction.isVisible = toggleable
-            binding.tapActionList.setSelection(
-                if (toggleable &&
-                    staticWidget.tapAction == WidgetTapAction.TOGGLE
-                ) {
-                    0
-                } else {
-                    1
-                },
-            )
-            binding.textColor.visibility =
-                if (staticWidget.backgroundType == WidgetBackgroundType.TRANSPARENT) View.VISIBLE else View.GONE
-            binding.textColorWhite.isChecked =
-                staticWidget.textColor?.let { it.toColorInt() == ContextCompat.getColor(this, android.R.color.white) }
-                    ?: true
-            binding.textColorBlack.isChecked =
-                staticWidget.textColor?.let {
-                    it.toColorInt() ==
-                        ContextCompat.getColor(this, commonR.color.colorWidgetButtonLabelBlack)
+                if (entity != null) {
+                    selectedEntity = entity
+                    setupAttributes()
                 }
-                    ?: false
 
-            binding.addButton.setText(commonR.string.update_widget)
-        } else {
-            binding.backgroundType.setSelection(0)
+                val toggleable = entity?.domain in EntityExt.APP_PRESS_ACTION_DOMAINS
+                binding.tapAction.isVisible = toggleable
+                binding.tapActionList.setSelection(
+                    if (toggleable &&
+                        staticWidget.tapAction == WidgetTapAction.TOGGLE
+                    ) {
+                        0
+                    } else {
+                        1
+                    },
+                )
+                binding.textColor.visibility =
+                    if (staticWidget.backgroundType == WidgetBackgroundType.TRANSPARENT) View.VISIBLE else View.GONE
+                binding.textColorWhite.isChecked =
+                    staticWidget.textColor?.let {
+                        it.toColorInt() == ContextCompat.getColor(
+                            this@EntityWidgetConfigureActivity,
+                            android.R.color.white,
+                        )
+                    }
+                        ?: true
+                binding.textColorBlack.isChecked =
+                    staticWidget.textColor?.let {
+                        it.toColorInt() ==
+                            ContextCompat.getColor(
+                                this@EntityWidgetConfigureActivity,
+                                commonR.color.colorWidgetButtonLabelBlack,
+                            )
+                    }
+                        ?: false
+
+                binding.addButton.setText(commonR.string.update_widget)
+            } else {
+                binding.backgroundType.setSelection(0)
+            }
+
+            setupServerSelect(staticWidget?.serverId)
         }
-        entityAdapter = SingleItemArrayAdapter(this) { it?.entityId ?: "" }
 
-        setupServerSelect(staticWidget?.serverId)
+        val tapActionValues =
+            listOf(getString(commonR.string.widget_tap_action_toggle), getString(commonR.string.refresh))
+        binding.tapActionList.adapter =
+            ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, tapActionValues)
+        val backgroundTypeValues = WidgetUtils.getBackgroundOptionList(this)
+        binding.backgroundType.adapter =
+            ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, backgroundTypeValues)
+
+        entityAdapter = SingleItemArrayAdapter(this) { it?.entityId ?: "" }
 
         binding.widgetTextConfigEntityId.setAdapter(entityAdapter)
         binding.widgetTextConfigEntityId.onFocusChangeListener = dropDownOnFocus
@@ -311,7 +319,7 @@ class EntityWidgetConfigureActivity : BaseWidgetConfigureActivity() {
     }
 
     private fun setupAttributes() {
-        val fetchedAttributes = selectedEntity?.attributes as? Map<String, String>
+        val fetchedAttributes = selectedEntity?.attributes
         val attributesAdapter = ArrayAdapter<String>(this, android.R.layout.simple_dropdown_item_1line)
         binding.widgetTextConfigAttribute.setAdapter(attributesAdapter)
         attributesAdapter.addAll(*fetchedAttributes?.keys.orEmpty().toTypedArray())
diff --git a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/mediaplayer/MediaPlayerControlsWidgetConfigureActivity.kt b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/mediaplayer/MediaPlayerControlsWidgetConfigureActivity.kt
index 2d0aadb0d73..5d8ad26b464 100644
--- a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/mediaplayer/MediaPlayerControlsWidgetConfigureActivity.kt
+++ b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/mediaplayer/MediaPlayerControlsWidgetConfigureActivity.kt
@@ -37,7 +37,8 @@ class MediaPlayerControlsWidgetConfigureActivity : BaseWidgetConfigureActivity()
 
     companion object {
         @Suppress("ktlint:standard:max-line-length")
-        private const val PIN_WIDGET_CALLBACK = "io.homeassistant.companion.android.widgets.media_player_controls.MediaPlayerControlsWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
+        private const val PIN_WIDGET_CALLBACK =
+            "io.homeassistant.companion.android.widgets.media_player_controls.MediaPlayerControlsWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
     }
 
     private var requestLauncherSetup = false
@@ -120,45 +121,48 @@ class MediaPlayerControlsWidgetConfigureActivity : BaseWidgetConfigureActivity()
             return
         }
 
-        val mediaPlayerWidget = mediaPlayerControlsWidgetDao.get(appWidgetId)
-
         val backgroundTypeValues = WidgetUtils.getBackgroundOptionList(this)
         binding.backgroundType.adapter =
             ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, backgroundTypeValues)
-        if (mediaPlayerWidget != null) {
-            binding.label.setText(mediaPlayerWidget.label)
-            binding.widgetTextConfigEntityId.setText(mediaPlayerWidget.entityId)
-            binding.widgetShowVolumeButtonCheckbox.isChecked = mediaPlayerWidget.showVolume
-            binding.widgetShowSeekButtonsCheckbox.isChecked = mediaPlayerWidget.showSeek
-            binding.widgetShowSkipButtonsCheckbox.isChecked = mediaPlayerWidget.showSkip
-            binding.widgetShowMediaPlayerSource.isChecked = mediaPlayerWidget.showSource
-            binding.backgroundType.setSelection(
-                WidgetUtils.getSelectedBackgroundOption(
-                    this,
-                    mediaPlayerWidget.backgroundType,
-                    backgroundTypeValues,
-                ),
-            )
-            val entities = runBlocking {
-                try {
-                    mediaPlayerWidget.entityId.split(",").map { s ->
-                        serverManager.integrationRepository(mediaPlayerWidget.serverId).getEntity(s.trim())
+
+        lifecycleScope.launch {
+            val mediaPlayerWidget = mediaPlayerControlsWidgetDao.get(appWidgetId)
+
+            if (mediaPlayerWidget != null) {
+                binding.label.setText(mediaPlayerWidget.label)
+                binding.widgetTextConfigEntityId.setText(mediaPlayerWidget.entityId)
+                binding.widgetShowVolumeButtonCheckbox.isChecked = mediaPlayerWidget.showVolume
+                binding.widgetShowSeekButtonsCheckbox.isChecked = mediaPlayerWidget.showSeek
+                binding.widgetShowSkipButtonsCheckbox.isChecked = mediaPlayerWidget.showSkip
+                binding.widgetShowMediaPlayerSource.isChecked = mediaPlayerWidget.showSource
+                binding.backgroundType.setSelection(
+                    WidgetUtils.getSelectedBackgroundOption(
+                        this@MediaPlayerControlsWidgetConfigureActivity,
+                        mediaPlayerWidget.backgroundType,
+                        backgroundTypeValues,
+                    ),
+                )
+                val entities = runBlocking {
+                    try {
+                        mediaPlayerWidget.entityId.split(",").map { s ->
+                            serverManager.integrationRepository(mediaPlayerWidget.serverId).getEntity(s.trim())
+                        }
+                    } catch (e: Exception) {
+                        Timber.e(e, "Unable to get entity information")
+                        Toast.makeText(applicationContext, commonR.string.widget_entity_fetch_error, Toast.LENGTH_LONG)
+                            .show()
+                        null
                     }
-                } catch (e: Exception) {
-                    Timber.e(e, "Unable to get entity information")
-                    Toast.makeText(applicationContext, commonR.string.widget_entity_fetch_error, Toast.LENGTH_LONG)
-                        .show()
-                    null
                 }
+                if (entities != null) {
+                    selectedEntities.addAll(entities)
+                }
+                binding.addButton.setText(commonR.string.update_widget)
             }
-            if (entities != null) {
-                selectedEntities.addAll(entities)
-            }
-            binding.addButton.setText(commonR.string.update_widget)
+            setupServerSelect(mediaPlayerWidget?.serverId)
         }
-        entityAdapter = SingleItemArrayAdapter(this) { it?.entityId ?: "" }
 
-        setupServerSelect(mediaPlayerWidget?.serverId)
+        entityAdapter = SingleItemArrayAdapter(this) { it?.entityId ?: "" }
 
         binding.widgetTextConfigEntityId.setAdapter(entityAdapter)
         binding.widgetTextConfigEntityId.setTokenizer(MultiAutoCompleteTextView.CommaTokenizer())
diff --git a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt
index 4c5d73e882f..3a460b04386 100644
--- a/app/src/main/kotlin/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt
+++ b/app/src/main/kotlin/io/homeassistant/companion/android/widgets/template/TemplateWidgetConfigureActivity.kt
@@ -37,8 +37,8 @@ import timber.log.Timber
 @AndroidEntryPoint
 class TemplateWidgetConfigureActivity : BaseWidgetConfigureActivity() {
     companion object {
-        @Suppress("ktlint:standard:max-line-length")
-        private const val PIN_WIDGET_CALLBACK = "io.homeassistant.companion.android.widgets.template.TemplateWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
+        private const val PIN_WIDGET_CALLBACK =
+            "io.homeassistant.companion.android.widgets.template.TemplateWidgetConfigureActivity.PIN_WIDGET_CALLBACK"
     }
 
     @Inject
@@ -86,43 +86,57 @@ class TemplateWidgetConfigureActivity : BaseWidgetConfigureActivity() {
             return
         }
 
-        val templateWidget = templateWidgetDao.get(appWidgetId)
-
         val backgroundTypeValues = WidgetUtils.getBackgroundOptionList(this)
         binding.backgroundType.adapter =
-            ArrayAdapter(this, android.R.layout.simple_spinner_dropdown_item, backgroundTypeValues)
+            ArrayAdapter(
+                this,
+                android.R.layout.simple_spinner_dropdown_item,
+                backgroundTypeValues,
+            )
 
-        setupServerSelect(templateWidget?.serverId)
+        lifecycleScope.launch {
+            val templateWidget = templateWidgetDao.get(appWidgetId)
 
-        if (templateWidget != null) {
-            binding.templateText.setText(templateWidget.template)
-            binding.textSize.setText(templateWidget.textSize.toInt().toString())
-            binding.addButton.setText(commonR.string.update_widget)
-            if (templateWidget.template.isNotEmpty()) {
-                renderTemplateText(templateWidget.template)
+            setupServerSelect(templateWidget?.serverId)
+
+            if (templateWidget != null) {
+                binding.templateText.setText(templateWidget.template)
+                binding.textSize.setText(templateWidget.textSize.toInt().toString())
+                binding.addButton.setText(commonR.string.update_widget)
+                if (templateWidget.template.isNotEmpty()) {
+                    renderTemplateText(templateWidget.template)
+                } else {
+                    binding.renderedTemplate.text = getString(commonR.string.empty_template)
+                    binding.addButton.isEnabled = false
+                }
+                binding.backgroundType.setSelection(
+                    WidgetUtils.getSelectedBackgroundOption(
+                        this@TemplateWidgetConfigureActivity,
+                        templateWidget.backgroundType,
+                        backgroundTypeValues,
+                    ),
+                )
+                binding.textColor.isVisible = templateWidget.backgroundType == WidgetBackgroundType.TRANSPARENT
+                binding.textColorWhite.isChecked =
+                    templateWidget.textColor?.let {
+                        it.toColorInt() == ContextCompat.getColor(
+                            this@TemplateWidgetConfigureActivity,
+                            android.R.color.white,
+                        )
+                    }
+                        ?: true
+                binding.textColorBlack.isChecked =
+                    templateWidget.textColor?.let {
+                        it.toColorInt() ==
+                            ContextCompat.getColor(
+                                this@TemplateWidgetConfigureActivity,
+                                commonR.color.colorWidgetButtonLabelBlack,
+                            )
+                    }
+                        ?: false
             } else {
-                binding.renderedTemplate.text = getString(commonR.string.empty_template)
-                binding.addButton.isEnabled = false
+                binding.backgroundType.setSelection(0)
             }
-            binding.backgroundType.setSelection(
-                WidgetUtils.getSelectedBackgroundOption(
-                    this,
-                    templateWidget.backgroundType,
-                    backgroundTypeValues,
-                ),
-            )
-            binding.textColor.isVisible = templateWidget.backgroundType == WidgetBackgroundType.TRANSPARENT
-            binding.textColorWhite.isChecked =
-                templateWidget.textColor?.let { it.toColorInt() == ContextCompat.getColor(this, android.R.color.white) }
-                    ?: true
-            binding.textColorBlack.isChecked =
-                templateWidget.textColor?.let {
-                    it.toColorInt() ==
-                        ContextCompat.getColor(this, commonR.color.colorWidgetButtonLabelBlack)
-                }
-                    ?: false
-        } else {
-            binding.backgroundType.setSelection(0)
         }
 
         binding.templateText.doAfterTextChanged { renderTemplateText() }
diff --git a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/ButtonWidgetDao.kt b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/ButtonWidgetDao.kt
index 8da579a626a..030eebe5e13 100644
--- a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/ButtonWidgetDao.kt
+++ b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/ButtonWidgetDao.kt
@@ -10,7 +10,7 @@ import kotlinx.coroutines.flow.Flow
 interface ButtonWidgetDao : WidgetDao {
 
     @Query("SELECT * FROM button_widgets WHERE id = :id")
-    fun get(id: Int): ButtonWidgetEntity?
+    suspend fun get(id: Int): ButtonWidgetEntity?
 
     @Insert(onConflict = OnConflictStrategy.REPLACE)
     suspend fun add(buttonWidgetEntity: ButtonWidgetEntity)
diff --git a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/CameraWidgetDao.kt b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/CameraWidgetDao.kt
index 628c99a7192..e638d8814be 100755
--- a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/CameraWidgetDao.kt
+++ b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/CameraWidgetDao.kt
@@ -10,7 +10,7 @@ import kotlinx.coroutines.flow.Flow
 interface CameraWidgetDao : WidgetDao {
 
     @Query("SELECT * FROM camera_widgets WHERE id = :id")
-    fun get(id: Int): CameraWidgetEntity?
+    suspend fun get(id: Int): CameraWidgetEntity?
 
     @Insert(onConflict = OnConflictStrategy.REPLACE)
     suspend fun add(cameraWidgetEntity: CameraWidgetEntity)
diff --git a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/MediaPlayerControlsWidgetDao.kt b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/MediaPlayerControlsWidgetDao.kt
index e1f87d4e58b..22235322177 100644
--- a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/MediaPlayerControlsWidgetDao.kt
+++ b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/MediaPlayerControlsWidgetDao.kt
@@ -10,7 +10,7 @@ import kotlinx.coroutines.flow.Flow
 interface MediaPlayerControlsWidgetDao : WidgetDao {
 
     @Query("SELECT * FROM media_player_controls_widgets WHERE id = :id")
-    fun get(id: Int): MediaPlayerControlsWidgetEntity?
+    suspend fun get(id: Int): MediaPlayerControlsWidgetEntity?
 
     @Insert(onConflict = OnConflictStrategy.REPLACE)
     suspend fun add(mediaPlayCtrlWidgetEntity: MediaPlayerControlsWidgetEntity)
diff --git a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/StaticWidgetDao.kt b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/StaticWidgetDao.kt
index 750ae0f8f2f..0dc7af84390 100644
--- a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/StaticWidgetDao.kt
+++ b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/StaticWidgetDao.kt
@@ -10,7 +10,7 @@ import kotlinx.coroutines.flow.Flow
 interface StaticWidgetDao : WidgetDao {
 
     @Query("SELECT * FROM static_widget WHERE id = :id")
-    fun get(id: Int): StaticWidgetEntity?
+    suspend fun get(id: Int): StaticWidgetEntity?
 
     @Insert(onConflict = OnConflictStrategy.REPLACE)
     suspend fun add(staticWidgetEntity: StaticWidgetEntity)
diff --git a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/TemplateWidgetDao.kt b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/TemplateWidgetDao.kt
index 72b0a49eaae..8eeb6c2e249 100644
--- a/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/TemplateWidgetDao.kt
+++ b/common/src/main/kotlin/io/homeassistant/companion/android/database/widget/TemplateWidgetDao.kt
@@ -10,7 +10,7 @@ import kotlinx.coroutines.flow.Flow
 interface TemplateWidgetDao : WidgetDao {
 
     @Query("SELECT * FROM template_widgets WHERE id = :id")
-    fun get(id: Int): TemplateWidgetEntity?
+    suspend fun get(id: Int): TemplateWidgetEntity?
 
     @Insert(onConflict = OnConflictStrategy.REPLACE)
     suspend fun add(templateWidgetEntity: TemplateWidgetEntity)
