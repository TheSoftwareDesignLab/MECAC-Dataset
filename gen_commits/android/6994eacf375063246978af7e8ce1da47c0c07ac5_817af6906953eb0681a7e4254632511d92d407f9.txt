diff --git a/app/src/full/AndroidManifest.xml b/app/src/full/AndroidManifest.xml
index 5ec79db1884..e0f5fc4f3ff 100644
--- a/app/src/full/AndroidManifest.xml
+++ b/app/src/full/AndroidManifest.xml
@@ -4,7 +4,7 @@
     package="io.homeassistant.companion.android">
 
     <application
-        android:name=".HomeAssistantApplication" >
+        android:name="io.homeassistant.companion.android.HomeAssistantApplication" >
         <meta-data android:name="io.sentry.auto-init" android:value="false" />
         <meta-data android:name="io.sentry.release" android:value="${sentryRelease}" />
 
@@ -23,7 +23,7 @@
             android:exported="true" />
 
         <service
-            android:name=".notifications.MessagingService"
+            android:name=".notifications.FirebaseCloudMessagingService"
             android:exported="false">
             <intent-filter>
                 <action android:name="com.google.firebase.MESSAGING_EVENT" />
diff --git a/app/src/full/java/io/homeassistant/companion/android/notifications/FirebaseCloudMessagingService.kt b/app/src/full/java/io/homeassistant/companion/android/notifications/FirebaseCloudMessagingService.kt
new file mode 100644
index 00000000000..460da4db50f
--- /dev/null
+++ b/app/src/full/java/io/homeassistant/companion/android/notifications/FirebaseCloudMessagingService.kt
@@ -0,0 +1,64 @@
+package io.homeassistant.companion.android.notifications
+
+import android.util.Log
+import com.google.firebase.messaging.FirebaseMessagingService
+import com.google.firebase.messaging.RemoteMessage
+import dagger.hilt.android.AndroidEntryPoint
+import io.homeassistant.companion.android.common.data.authentication.AuthenticationRepository
+import io.homeassistant.companion.android.common.data.authentication.SessionState
+import io.homeassistant.companion.android.common.data.integration.DeviceRegistration
+import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.launch
+import javax.inject.Inject
+
+@AndroidEntryPoint
+class FirebaseCloudMessagingService : FirebaseMessagingService() {
+    companion object {
+        private const val TAG = "FCMService"
+    }
+
+    @Inject
+    lateinit var integrationUseCase: IntegrationRepository
+
+    @Inject
+    lateinit var authenticationUseCase: AuthenticationRepository
+
+    @Inject
+    lateinit var messagingManager: MessagingManager
+
+    private val mainScope: CoroutineScope = CoroutineScope(Dispatchers.Main + Job())
+
+    override fun onMessageReceived(remoteMessage: RemoteMessage) {
+        Log.d(TAG, "From: ${remoteMessage.from}")
+
+        messagingManager.handleMessage(remoteMessage.data)
+    }
+
+    /**
+     * Called if InstanceID token is updated. This may occur if the security of
+     * the previous token had been compromised. Note that this is called when the InstanceID token
+     * is initially generated so this is where you would retrieve the token.
+     */
+    override fun onNewToken(token: String) {
+        mainScope.launch {
+            Log.d(TAG, "Refreshed token: $token")
+            if (authenticationUseCase.getSessionState() == SessionState.ANONYMOUS) {
+                Log.d(TAG, "Not trying to update registration since we aren't authenticated.")
+                return@launch
+            }
+            try {
+                integrationUseCase.updateRegistration(
+                    DeviceRegistration(
+                        pushToken = token
+                    )
+                )
+            } catch (e: Exception) {
+                // TODO: Store for update later
+                Log.e(TAG, "Issue updating token", e)
+            }
+        }
+    }
+}
diff --git a/app/src/full/java/io/homeassistant/companion/android/sensors/GeocodeSensorManager.kt b/app/src/full/java/io/homeassistant/companion/android/sensors/GeocodeSensorManager.kt
index dce5a9c0795..d6dc9ad6483 100644
--- a/app/src/full/java/io/homeassistant/companion/android/sensors/GeocodeSensorManager.kt
+++ b/app/src/full/java/io/homeassistant/companion/android/sensors/GeocodeSensorManager.kt
@@ -9,7 +9,7 @@ import android.util.Log
 import com.google.android.gms.location.LocationServices
 import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import io.homeassistant.companion.android.location.HighAccuracyLocationService
 import io.homeassistant.companion.android.common.R as commonR
 
@@ -72,7 +72,7 @@ class GeocodeSensorManager : SensorManager {
                 val minAccuracy = sensorSettings
                     .firstOrNull { it.name == SETTING_ACCURACY }?.value?.toIntOrNull()
                     ?: DEFAULT_MINIMUM_ACCURACY
-                sensorDao.add(Setting(geocodedLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
+                sensorDao.add(SensorSetting(geocodedLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
 
                 if (location.accuracy <= minAccuracy)
                     address = Geocoder(context)
diff --git a/app/src/full/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt b/app/src/full/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
index b7e29d498f1..71a4e041e17 100644
--- a/app/src/full/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
+++ b/app/src/full/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
@@ -29,7 +29,7 @@ import io.homeassistant.companion.android.common.sensors.LocationSensorManagerBa
 import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
 import io.homeassistant.companion.android.database.sensor.Attribute
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import io.homeassistant.companion.android.location.HighAccuracyLocationService
 import io.homeassistant.companion.android.util.DisabledLocationHandler
 import kotlinx.coroutines.CoroutineScope
@@ -116,7 +116,7 @@ class LocationSensorManager : LocationSensorManagerBase() {
 
         fun setHighAccuracyModeSetting(context: Context, enabled: Boolean) {
             val sensorDao = AppDatabase.getInstance(context).sensorDao()
-            sensorDao.add(Setting(backgroundLocation.id, SETTING_HIGH_ACCURACY_MODE, enabled.toString(), "toggle"))
+            sensorDao.add(SensorSetting(backgroundLocation.id, SETTING_HIGH_ACCURACY_MODE, enabled.toString(), "toggle"))
         }
 
         fun getHighAccuracyModeIntervalSetting(context: Context): Int {
@@ -292,7 +292,7 @@ class LocationSensorManager : LocationSensorManagerBase() {
             updateIntervalHighAccuracySecondsInt = DEFAULT_UPDATE_INTERVAL_HA_SECONDS
 
             val sensorDao = AppDatabase.getInstance(latestContext).sensorDao()
-            sensorDao.add(Setting(backgroundLocation.id, SETTING_HIGH_ACCURACY_MODE_UPDATE_INTERVAL, updateIntervalHighAccuracySecondsInt.toString(), "number"))
+            sensorDao.add(SensorSetting(backgroundLocation.id, SETTING_HIGH_ACCURACY_MODE_UPDATE_INTERVAL, updateIntervalHighAccuracySecondsInt.toString(), "number"))
         }
         return updateIntervalHighAccuracySecondsInt
     }
@@ -448,7 +448,7 @@ class LocationSensorManager : LocationSensorManagerBase() {
             val minAccuracy = sensorSettings
                 .firstOrNull { it.name == SETTING_ACCURACY }?.value?.toIntOrNull()
                 ?: DEFAULT_MINIMUM_ACCURACY
-            sensorDao.add(Setting(backgroundLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
+            sensorDao.add(SensorSetting(backgroundLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
             if (location.accuracy > minAccuracy) {
                 Log.w(TAG, "Location accuracy didn't meet requirements, disregarding: $location")
             } else {
@@ -547,7 +547,7 @@ class LocationSensorManager : LocationSensorManagerBase() {
         val minAccuracy = sensorSettings
             .firstOrNull { it.name == SETTING_ACCURACY }?.value?.toIntOrNull()
             ?: DEFAULT_MINIMUM_ACCURACY
-        sensorDao.add(Setting(zoneLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
+        sensorDao.add(SensorSetting(zoneLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
 
         if (geofencingEvent.triggeringLocation.accuracy > minAccuracy) {
             Log.w(
@@ -719,7 +719,7 @@ class LocationSensorManager : LocationSensorManagerBase() {
             highAccuracyTriggerRangeInt = DEFAULT_TRIGGER_RANGE_METERS
 
             val sensorDao = AppDatabase.getInstance(latestContext).sensorDao()
-            sensorDao.add(Setting(backgroundLocation.id, SETTING_HIGH_ACCURACY_MODE_TRIGGER_RANGE_ZONE, highAccuracyTriggerRangeInt.toString(), "number"))
+            sensorDao.add(SensorSetting(backgroundLocation.id, SETTING_HIGH_ACCURACY_MODE_TRIGGER_RANGE_ZONE, highAccuracyTriggerRangeInt.toString(), "number"))
         }
 
         return highAccuracyTriggerRangeInt
@@ -765,11 +765,11 @@ class LocationSensorManager : LocationSensorManagerBase() {
         val minAccuracy = sensorSettings
             .firstOrNull { it.name == SETTING_ACCURACY }?.value?.toIntOrNull()
             ?: DEFAULT_MINIMUM_ACCURACY
-        sensorDao.add(Setting(singleAccurateLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
+        sensorDao.add(SensorSetting(singleAccurateLocation.id, SETTING_ACCURACY, minAccuracy.toString(), "number"))
         val minTimeBetweenUpdates = sensorSettings
             .firstOrNull { it.name == SETTING_ACCURATE_UPDATE_TIME }?.value?.toIntOrNull()
             ?: 60000
-        sensorDao.add(Setting(singleAccurateLocation.id, SETTING_ACCURATE_UPDATE_TIME, minTimeBetweenUpdates.toString(), "number"))
+        sensorDao.add(SensorSetting(singleAccurateLocation.id, SETTING_ACCURATE_UPDATE_TIME, minTimeBetweenUpdates.toString(), "number"))
 
         // Only update accurate location at most once a minute
         if (now < latestAccurateLocation + minTimeBetweenUpdates) {
@@ -891,6 +891,6 @@ class LocationSensorManager : LocationSensorManagerBase() {
                 )
             }
         } else
-            sensorDao.add(Setting(singleAccurateLocation.id, SETTING_INCLUDE_SENSOR_UPDATE, "false", "toggle"))
+            sensorDao.add(SensorSetting(singleAccurateLocation.id, SETTING_INCLUDE_SENSOR_UPDATE, "false", "toggle"))
     }
 }
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
index 27e07eaa4d3..4cd763d6686 100644
--- a/app/src/main/AndroidManifest.xml
+++ b/app/src/main/AndroidManifest.xml
@@ -48,7 +48,7 @@
     <uses-feature android:name="android.hardware.bluetooth" android:required="false" />
 
     <application
-        android:name=".HomeAssistantApplication"
+        android:name="io.homeassistant.companion.android.HomeAssistantApplication"
         android:allowBackup="true"
         android:fullBackupContent="@xml/backup_rules"
         android:dataExtractionRules="@xml/backup_rules_android12"
@@ -62,6 +62,20 @@
         tools:ignore="GoogleAppIndexingWarning">
 
         <!-- Start things like SensorWorker on device boot -->
+        <receiver android:name=".websocket.WebsocketBroadcastReceiver"
+            android:exported="true">
+            <intent-filter>
+                <action android:name="android.intent.action.BOOT_COMPLETED" />
+                <action android:name="android.intent.action.MY_PACKAGE_REPLACED" />
+                <action android:name="android.intent.action.MY_PACKAGE_SUSPENDED" />
+                <action android:name="android.intent.action.MY_PACKAGE_UNSUSPENDED" />
+                <action android:name="android.intent.action.QUICKBOOT_POWERON" />
+                <action android:name="com.htc.intent.action.QUICKBOOT_POWERON" />
+                <action android:name="android.app.action.NEXT_ALARM_CLOCK_CHANGED" />
+                <action android:name="android.bluetooth.device.action.ACL_CONNECTED" />
+                <action android:name="android.bluetooth.device.action.ACL_DISCONNECTED" />
+            </intent-filter>
+        </receiver>
         <receiver android:name=".sensors.SensorReceiver"
             android:exported="true">
             <intent-filter>
diff --git a/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt b/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt
index 8cdc71fc6e3..e1877212b21 100644
--- a/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/HomeAssistantApplication.kt
@@ -15,6 +15,7 @@ import io.homeassistant.companion.android.common.data.prefs.PrefsRepository
 import io.homeassistant.companion.android.common.sensors.LastUpdateManager
 import io.homeassistant.companion.android.database.AppDatabase
 import io.homeassistant.companion.android.sensors.SensorReceiver
+import io.homeassistant.companion.android.websocket.WebsocketBroadcastReceiver
 import io.homeassistant.companion.android.widgets.button.ButtonWidget
 import io.homeassistant.companion.android.widgets.entity.EntityWidget
 import io.homeassistant.companion.android.widgets.media_player_controls.MediaPlayerControlsWidget
@@ -43,6 +44,16 @@ open class HomeAssistantApplication : Application() {
             )
         }
 
+        // This will make sure we start/stop when we actually need too.
+        registerReceiver(
+            WebsocketBroadcastReceiver(),
+            IntentFilter().apply {
+                addAction(Intent.ACTION_SCREEN_OFF)
+                addAction(Intent.ACTION_SCREEN_ON)
+                addAction(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED)
+            }
+        )
+
         val sensorReceiver = SensorReceiver()
         // This will cause the sensor to be updated every time the OS broadcasts that a cable was plugged/unplugged.
         // This should be nearly instantaneous allowing automations to fire immediately when a phone is plugged
diff --git a/app/src/full/java/io/homeassistant/companion/android/notifications/MessagingService.kt b/app/src/main/java/io/homeassistant/companion/android/notifications/MessagingManager.kt
similarity index 76%
rename from app/src/full/java/io/homeassistant/companion/android/notifications/MessagingService.kt
rename to app/src/main/java/io/homeassistant/companion/android/notifications/MessagingManager.kt
index 3cc4c796d08..c4a4b09facb 100644
--- a/app/src/full/java/io/homeassistant/companion/android/notifications/MessagingService.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/notifications/MessagingManager.kt
@@ -7,6 +7,7 @@ import android.app.NotificationManager
 import android.app.PendingIntent
 import android.bluetooth.BluetoothManager
 import android.content.ComponentName
+import android.content.Context
 import android.content.Intent
 import android.graphics.Bitmap
 import android.graphics.BitmapFactory
@@ -37,16 +38,12 @@ import androidx.core.content.ContextCompat
 import androidx.core.content.getSystemService
 import androidx.core.text.HtmlCompat
 import androidx.core.text.isDigitsOnly
-import com.google.firebase.messaging.FirebaseMessagingService
-import com.google.firebase.messaging.RemoteMessage
 import com.mikepenz.iconics.IconicsDrawable
 import com.mikepenz.iconics.utils.toAndroidIconCompat
 import com.vdurmont.emoji.EmojiParser
-import dagger.hilt.android.AndroidEntryPoint
+import dagger.hilt.android.qualifiers.ApplicationContext
 import io.homeassistant.companion.android.R
 import io.homeassistant.companion.android.common.data.authentication.AuthenticationRepository
-import io.homeassistant.companion.android.common.data.authentication.SessionState
-import io.homeassistant.companion.android.common.data.integration.DeviceRegistration
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
 import io.homeassistant.companion.android.common.data.url.UrlRepository
 import io.homeassistant.companion.android.database.AppDatabase
@@ -72,8 +69,12 @@ import java.util.Locale
 import javax.inject.Inject
 import io.homeassistant.companion.android.common.R as commonR
 
-@AndroidEntryPoint
-class MessagingService : FirebaseMessagingService() {
+class MessagingManager @Inject constructor(
+    @ApplicationContext val context: Context,
+    private val integrationUseCase: IntegrationRepository,
+    private val urlUseCase: UrlRepository,
+    private val authenticationUseCase: AuthenticationRepository
+) {
     companion object {
         const val TAG = "MessagingService"
 
@@ -176,215 +177,200 @@ class MessagingService : FirebaseMessagingService() {
         )
     }
 
-    @Inject
-    lateinit var integrationUseCase: IntegrationRepository
-
-    @Inject
-    lateinit var urlUseCase: UrlRepository
+    private val mainScope: CoroutineScope = CoroutineScope(Dispatchers.Main + Job())
 
-    @Inject
-    lateinit var authenticationUseCase: AuthenticationRepository
+    fun handleMessage(jsonData: Map<String, String>) {
 
-    private val mainScope: CoroutineScope = CoroutineScope(Dispatchers.Main + Job())
+        val jsonObject = JSONObject(jsonData)
+        val notificationDao = AppDatabase.getInstance(context).notificationDao()
+        val now = System.currentTimeMillis()
+        val notificationRow =
+            NotificationItem(0, now, jsonData[MESSAGE].toString(), jsonObject.toString())
+        notificationDao.add(notificationRow)
 
-    override fun onMessageReceived(remoteMessage: RemoteMessage) {
-        Log.d(TAG, "From: ${remoteMessage.from}")
-
-        // Check if message contains a data payload.
-        remoteMessage.data.let {
-            Log.d(TAG, "Message data payload: " + remoteMessage.data)
-            val jsonData: Map<String, String> = it
-            val jsonObject = JSONObject(jsonData)
-            val notificationDao = AppDatabase.getInstance(applicationContext).notificationDao()
-            val now = System.currentTimeMillis()
-            val notificationRow =
-                NotificationItem(0, now, it[MESSAGE].toString(), jsonObject.toString())
-            notificationDao.add(notificationRow)
-
-            when {
-                it[MESSAGE] == REQUEST_LOCATION_UPDATE -> {
-                    Log.d(TAG, "Request location update")
-                    requestAccurateLocationUpdate()
-                }
-                it[MESSAGE] == CLEAR_NOTIFICATION && !it["tag"].isNullOrBlank() -> {
-                    Log.d(TAG, "Clearing notification with tag: ${it["tag"]}")
-                    clearNotification(it["tag"]!!)
-                }
-                it[MESSAGE] == REMOVE_CHANNEL && !it["channel"].isNullOrBlank() -> {
-                    Log.d(TAG, "Removing Notification channel ${it["channel"]}")
-                    removeNotificationChannel(it["channel"]!!)
-                }
-                it[MESSAGE] == TTS -> {
-                    Log.d(TAG, "Sending notification title to TTS")
-                    speakNotification(it)
-                }
-                it[MESSAGE] in DEVICE_COMMANDS -> {
-                    Log.d(TAG, "Processing device command")
-                    when (it[MESSAGE]) {
-                        COMMAND_DND -> {
-                            if (it[TITLE] in DND_COMMANDS) {
-                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
-                                    handleDeviceCommands(it)
-                                else {
-                                    mainScope.launch {
-                                        Log.d(
-                                            TAG,
-                                            "Posting notification to device as it does not support DND commands"
-                                        )
-                                        sendNotification(it)
-                                    }
-                                }
-                            } else {
+        when {
+            jsonData[MESSAGE] == REQUEST_LOCATION_UPDATE -> {
+                Log.d(TAG, "Request location update")
+                requestAccurateLocationUpdate()
+            }
+            jsonData[MESSAGE] == CLEAR_NOTIFICATION && !jsonData["tag"].isNullOrBlank() -> {
+                Log.d(TAG, "Clearing notification with tag: ${jsonData["tag"]}")
+                clearNotification(jsonData["tag"]!!)
+            }
+            jsonData[MESSAGE] == REMOVE_CHANNEL && !jsonData["channel"].isNullOrBlank() -> {
+                Log.d(TAG, "Removing Notification channel ${jsonData["channel"]}")
+                removeNotificationChannel(jsonData["channel"]!!)
+            }
+            jsonData[MESSAGE] == TTS -> {
+                Log.d(TAG, "Sending notification title to TTS")
+                speakNotification(jsonData)
+            }
+            jsonData[MESSAGE] in DEVICE_COMMANDS -> {
+                Log.d(TAG, "Processing device command")
+                when (jsonData[MESSAGE]) {
+                    COMMAND_DND -> {
+                        if (jsonData[TITLE] in DND_COMMANDS) {
+                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
+                                handleDeviceCommands(jsonData)
+                            else {
                                 mainScope.launch {
                                     Log.d(
                                         TAG,
-                                        "Invalid DND command received, posting notification to device"
+                                        "Posting notification to device as it does not support DND commands"
                                     )
-                                    sendNotification(it)
+                                    sendNotification(jsonData)
                                 }
                             }
-                        }
-                        COMMAND_RINGER_MODE -> {
-                            if (it[TITLE] in RM_COMMANDS) {
-                                handleDeviceCommands(it)
-                            } else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid ringer mode command received, posting notification to device"
-                                    )
-                                    sendNotification(it)
-                                }
+                        } else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid DND command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
                             }
                         }
-                        COMMAND_BROADCAST_INTENT -> {
-                            if (!it[TITLE].isNullOrEmpty() && !it["channel"].isNullOrEmpty())
-                                handleDeviceCommands(it)
-                            else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid broadcast command received, posting notification to device"
-                                    )
-                                    sendNotification(it)
-                                }
+                    }
+                    COMMAND_RINGER_MODE -> {
+                        if (jsonData[TITLE] in RM_COMMANDS) {
+                            handleDeviceCommands(jsonData)
+                        } else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid ringer mode command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
                             }
                         }
-                        COMMAND_VOLUME_LEVEL -> {
-                            if (!it["channel"].isNullOrEmpty() && it["channel"] in CHANNEL_VOLUME_STREAM &&
-                                !it[TITLE].isNullOrEmpty() && it[TITLE]?.toIntOrNull() != null
-                            )
-                                handleDeviceCommands(it)
-                            else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid volume command received, posting notification to device"
-                                    )
-                                    sendNotification(it)
-                                }
+                    }
+                    COMMAND_BROADCAST_INTENT -> {
+                        if (!jsonData[TITLE].isNullOrEmpty() && !jsonData["channel"].isNullOrEmpty())
+                            handleDeviceCommands(jsonData)
+                        else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid broadcast command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
                             }
                         }
-                        COMMAND_BLUETOOTH -> {
-                            if (!it[TITLE].isNullOrEmpty() && it[TITLE] in ENABLE_COMMANDS)
-                                handleDeviceCommands(it)
-                            else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid bluetooth command received, posting notification to device"
-                                    )
-                                    sendNotification(it)
-                                }
+                    }
+                    COMMAND_VOLUME_LEVEL -> {
+                        if (!jsonData["channel"].isNullOrEmpty() && jsonData["channel"] in CHANNEL_VOLUME_STREAM &&
+                            !jsonData[TITLE].isNullOrEmpty() && jsonData[TITLE]?.toIntOrNull() != null
+                        )
+                            handleDeviceCommands(jsonData)
+                        else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid volume command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
                             }
                         }
-                        COMMAND_BLE_TRANSMITTER -> {
-                            if (!it[TITLE].isNullOrEmpty() && it[TITLE] in ENABLE_COMMANDS)
-                                handleDeviceCommands(it)
-                            else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid ble transmitter command received, posting notification to device"
-                                    )
-                                    sendNotification(it)
-                                }
+                    }
+                    COMMAND_BLUETOOTH -> {
+                        if (!jsonData[TITLE].isNullOrEmpty() && jsonData[TITLE] in ENABLE_COMMANDS)
+                            handleDeviceCommands(jsonData)
+                        else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid bluetooth command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
                             }
                         }
-                        COMMAND_HIGH_ACCURACY_MODE -> {
-                            if (!it[TITLE].isNullOrEmpty() && it[TITLE] in ENABLE_COMMANDS)
-                                handleDeviceCommands(it)
-                            else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid high accuracy mode command received, posting notification to device"
-                                    )
-                                }
+                    }
+                    COMMAND_BLE_TRANSMITTER -> {
+                        if (!jsonData[TITLE].isNullOrEmpty() && jsonData[TITLE] in ENABLE_COMMANDS)
+                            handleDeviceCommands(jsonData)
+                        else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid ble transmitter command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
                             }
                         }
-                        COMMAND_ACTIVITY -> {
-                            if (!it["tag"].isNullOrEmpty())
-                                handleDeviceCommands(it)
-                            else {
-                                mainScope.launch {
-                                    Log.d(
-                                        TAG,
-                                        "Invalid activity command received, posting notification to device"
-                                    )
-                                    sendNotification(it)
-                                }
+                    }
+                    COMMAND_HIGH_ACCURACY_MODE -> {
+                        if (!jsonData[TITLE].isNullOrEmpty() && jsonData[TITLE] in ENABLE_COMMANDS)
+                            handleDeviceCommands(jsonData)
+                        else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid high accuracy mode command received, posting notification to device"
+                                )
                             }
                         }
-                        COMMAND_WEBVIEW -> {
-                            handleDeviceCommands(it)
-                        }
-                        COMMAND_SCREEN_ON -> {
-                            handleDeviceCommands(it)
+                    }
+                    COMMAND_ACTIVITY -> {
+                        if (!jsonData["tag"].isNullOrEmpty())
+                            handleDeviceCommands(jsonData)
+                        else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid activity command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
+                            }
                         }
-                        COMMAND_MEDIA -> {
-                            if (!it[TITLE].isNullOrEmpty() && it[TITLE] in MEDIA_COMMANDS && !it["channel"].isNullOrEmpty()) {
-                                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
-                                    handleDeviceCommands(it)
-                                } else {
-                                    mainScope.launch {
-                                        Log.d(
-                                            TAG,
-                                            "Posting notification to device as it does not support media commands"
-                                        )
-                                        sendNotification(it)
-                                    }
-                                }
+                    }
+                    COMMAND_WEBVIEW -> {
+                        handleDeviceCommands(jsonData)
+                    }
+                    COMMAND_SCREEN_ON -> {
+                        handleDeviceCommands(jsonData)
+                    }
+                    COMMAND_MEDIA -> {
+                        if (!jsonData[TITLE].isNullOrEmpty() && jsonData[TITLE] in MEDIA_COMMANDS && !jsonData["channel"].isNullOrEmpty()) {
+                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
+                                handleDeviceCommands(jsonData)
                             } else {
                                 mainScope.launch {
                                     Log.d(
                                         TAG,
-                                        "Invalid media command received, posting notification to device"
+                                        "Posting notification to device as it does not support media commands"
                                     )
-                                    sendNotification(it)
+                                    sendNotification(jsonData)
                                 }
                             }
+                        } else {
+                            mainScope.launch {
+                                Log.d(
+                                    TAG,
+                                    "Invalid media command received, posting notification to device"
+                                )
+                                sendNotification(jsonData)
+                            }
                         }
-                        else -> Log.d(TAG, "No command received")
                     }
-                }
-                else -> mainScope.launch {
-                    Log.d(TAG, "Creating notification with following data: $it")
-                    sendNotification(it)
+                    else -> Log.d(TAG, "No command received")
                 }
             }
+            else -> mainScope.launch {
+                Log.d(TAG, "Creating notification with following data: $jsonData")
+                sendNotification(jsonData)
+            }
         }
     }
 
     private fun requestAccurateLocationUpdate() {
-        val intent = Intent(this, LocationSensorManager::class.java)
+        val intent = Intent(context, LocationSensorManager::class.java)
         intent.action = LocationSensorManager.ACTION_REQUEST_ACCURATE_LOCATION_UPDATE
 
-        sendBroadcast(intent)
+        context.sendBroadcast(intent)
     }
 
     private fun clearNotification(tag: String) {
-        val notificationManagerCompat = NotificationManagerCompat.from(this)
+        val notificationManagerCompat = NotificationManagerCompat.from(context)
 
         val messageId = tag.hashCode()
 
@@ -393,7 +379,7 @@ class MessagingService : FirebaseMessagingService() {
     }
 
     private fun removeNotificationChannel(channelName: String) {
-        val notificationManagerCompat = NotificationManagerCompat.from(this)
+        val notificationManagerCompat = NotificationManagerCompat.from(context)
 
         val channelID: String = createChannelID(channelName)
 
@@ -405,22 +391,21 @@ class MessagingService : FirebaseMessagingService() {
     private fun speakNotification(data: Map<String, String>) {
         var textToSpeech: TextToSpeech? = null
         var tts = data[TITLE]
-        val audioManager =
-            applicationContext.getSystemService<AudioManager>()!!
-        val currentAlarmVolume = audioManager.getStreamVolume(AudioManager.STREAM_ALARM)
-        val maxAlarmVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_ALARM)
+        val audioManager = context.getSystemService<AudioManager>()
+        val currentAlarmVolume = audioManager?.getStreamVolume(AudioManager.STREAM_ALARM)
+        val maxAlarmVolume = audioManager?.getStreamMaxVolume(AudioManager.STREAM_ALARM)
         if (tts.isNullOrEmpty())
-            tts = getString(commonR.string.tts_no_title)
+            tts = context.getString(commonR.string.tts_no_title)
         textToSpeech = TextToSpeech(
-            applicationContext
+            context
         ) {
             if (it == TextToSpeech.SUCCESS) {
                 val listener = object : UtteranceProgressListener() {
                     override fun onStart(p0: String?) {
                         if (data["channel"] == ALARM_STREAM_MAX)
-                            audioManager.setStreamVolume(
+                            audioManager?.setStreamVolume(
                                 AudioManager.STREAM_ALARM,
-                                maxAlarmVolume,
+                                maxAlarmVolume!!,
                                 0
                             )
                     }
@@ -429,9 +414,9 @@ class MessagingService : FirebaseMessagingService() {
                         textToSpeech?.stop()
                         textToSpeech?.shutdown()
                         if (data["channel"] == ALARM_STREAM_MAX)
-                            audioManager.setStreamVolume(
+                            audioManager?.setStreamVolume(
                                 AudioManager.STREAM_ALARM,
-                                currentAlarmVolume,
+                                currentAlarmVolume!!,
                                 0
                             )
                     }
@@ -440,9 +425,9 @@ class MessagingService : FirebaseMessagingService() {
                         textToSpeech?.stop()
                         textToSpeech?.shutdown()
                         if (data["channel"] == ALARM_STREAM_MAX)
-                            audioManager.setStreamVolume(
+                            audioManager?.setStreamVolume(
                                 AudioManager.STREAM_ALARM,
-                                currentAlarmVolume,
+                                currentAlarmVolume!!,
                                 0
                             )
                     }
@@ -460,8 +445,8 @@ class MessagingService : FirebaseMessagingService() {
             } else {
                 Handler(Looper.getMainLooper()).post {
                     Toast.makeText(
-                        applicationContext,
-                        getString(commonR.string.tts_error, tts),
+                        context,
+                        context.getString(commonR.string.tts_error, tts),
                         Toast.LENGTH_LONG
                     ).show()
                 }
@@ -476,19 +461,19 @@ class MessagingService : FirebaseMessagingService() {
             COMMAND_DND -> {
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                     val notificationManager =
-                        applicationContext.getSystemService<NotificationManager>()!!
-                    if (!notificationManager.isNotificationPolicyAccessGranted) {
+                        context.getSystemService<NotificationManager>()
+                    if (notificationManager?.isNotificationPolicyAccessGranted == false) {
                         notifyMissingPermission(data[MESSAGE].toString())
                     } else {
                         when (title) {
-                            DND_ALARMS_ONLY -> notificationManager.setInterruptionFilter(
+                            DND_ALARMS_ONLY -> notificationManager?.setInterruptionFilter(
                                 NotificationManager.INTERRUPTION_FILTER_ALARMS
                             )
-                            DND_ALL -> notificationManager.setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_ALL)
-                            DND_NONE -> notificationManager.setInterruptionFilter(
+                            DND_ALL -> notificationManager?.setInterruptionFilter(NotificationManager.INTERRUPTION_FILTER_ALL)
+                            DND_NONE -> notificationManager?.setInterruptionFilter(
                                 NotificationManager.INTERRUPTION_FILTER_NONE
                             )
-                            DND_PRIORITY_ONLY -> notificationManager.setInterruptionFilter(
+                            DND_PRIORITY_ONLY -> notificationManager?.setInterruptionFilter(
                                 NotificationManager.INTERRUPTION_FILTER_PRIORITY
                             )
                             else -> Log.d(TAG, "Skipping invalid command")
@@ -497,18 +482,17 @@ class MessagingService : FirebaseMessagingService() {
                 }
             }
             COMMAND_RINGER_MODE -> {
-                val audioManager =
-                    applicationContext.getSystemService<AudioManager>()!!
+                val audioManager = context.getSystemService<AudioManager>()
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                     val notificationManager =
-                        applicationContext.getSystemService<NotificationManager>()!!
-                    if (!notificationManager.isNotificationPolicyAccessGranted) {
+                        context.getSystemService<NotificationManager>()
+                    if (notificationManager?.isNotificationPolicyAccessGranted == false) {
                         notifyMissingPermission(data[MESSAGE].toString())
                     } else {
-                        processRingerMode(audioManager, title)
+                        processRingerMode(audioManager!!, title)
                     }
                 } else {
-                    processRingerMode(audioManager, title)
+                    processRingerMode(audioManager!!, title)
                 }
             }
             COMMAND_BROADCAST_INTENT -> {
@@ -524,12 +508,12 @@ class MessagingService : FirebaseMessagingService() {
                     if (!packageName.isNullOrEmpty() && !className.isNullOrEmpty())
                         intent.setClassName(packageName, className)
                     Log.d(TAG, "Sending broadcast intent")
-                    applicationContext.sendBroadcast(intent)
+                    context.sendBroadcast(intent)
                 } catch (e: Exception) {
                     Log.e(TAG, "Unable to send broadcast intent please check command format", e)
                     Handler(Looper.getMainLooper()).post {
                         Toast.makeText(
-                            applicationContext,
+                            context,
                             commonR.string.broadcast_intent_error,
                             Toast.LENGTH_LONG
                         ).show()
@@ -538,30 +522,28 @@ class MessagingService : FirebaseMessagingService() {
             }
             COMMAND_VOLUME_LEVEL -> {
                 val audioManager =
-                    applicationContext.getSystemService<AudioManager>()!!
+                    context.getSystemService<AudioManager>()
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                    val notificationManager =
-                        applicationContext.getSystemService<NotificationManager>()!!
-                    if (!notificationManager.isNotificationPolicyAccessGranted) {
+                    val notificationManager = context.getSystemService<NotificationManager>()
+                    if (notificationManager?.isNotificationPolicyAccessGranted == false) {
                         notifyMissingPermission(data[MESSAGE].toString())
                     } else {
                         processStreamVolume(
-                            audioManager,
+                            audioManager!!,
                             data["channel"].toString(),
                             title!!.toInt()
                         )
                     }
                 } else {
                     processStreamVolume(
-                        audioManager,
+                        audioManager!!,
                         data["channel"].toString(),
                         title!!.toInt()
                     )
                 }
             }
             COMMAND_BLUETOOTH -> {
-                val bluetoothAdapter =
-                    applicationContext.getSystemService<BluetoothManager>()?.adapter
+                val bluetoothAdapter = context.getSystemService<BluetoothManager>()?.adapter
                 if (title == TURN_OFF)
                     bluetoothAdapter?.disable()
                 if (title == TURN_ON)
@@ -569,25 +551,25 @@ class MessagingService : FirebaseMessagingService() {
             }
             COMMAND_BLE_TRANSMITTER -> {
                 if (title == TURN_OFF)
-                    BluetoothSensorManager.enableDisableBLETransmitter(applicationContext, false)
+                    BluetoothSensorManager.enableDisableBLETransmitter(context, false)
                 if (title == TURN_ON)
-                    BluetoothSensorManager.enableDisableBLETransmitter(applicationContext, true)
+                    BluetoothSensorManager.enableDisableBLETransmitter(context, true)
             }
             COMMAND_HIGH_ACCURACY_MODE -> {
                 if (title == TURN_OFF) {
-                    LocationSensorManager.setHighAccuracyModeSetting(applicationContext, false)
+                    LocationSensorManager.setHighAccuracyModeSetting(context, false)
                 }
                 if (title == TURN_ON) {
-                    LocationSensorManager.setHighAccuracyModeSetting(applicationContext, true)
+                    LocationSensorManager.setHighAccuracyModeSetting(context, true)
                 }
-                val intent = Intent(this, LocationSensorManager::class.java)
+                val intent = Intent(context, LocationSensorManager::class.java)
                 intent.action = LocationSensorManager.ACTION_FORCE_HIGH_ACCURACY
                 intent.putExtra("command", title)
-                applicationContext.sendBroadcast(intent)
+                context.sendBroadcast(intent)
             }
             COMMAND_ACTIVITY -> {
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                    if (!Settings.canDrawOverlays(applicationContext))
+                    if (!Settings.canDrawOverlays(context))
                         notifyMissingPermission(data[MESSAGE].toString())
                     else
                         processActivityCommand(data)
@@ -596,7 +578,7 @@ class MessagingService : FirebaseMessagingService() {
             }
             COMMAND_WEBVIEW -> {
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-                    if (!Settings.canDrawOverlays(applicationContext))
+                    if (!Settings.canDrawOverlays(context))
                         notifyMissingPermission(data[MESSAGE].toString())
                     else
                         openWebview(title)
@@ -612,21 +594,20 @@ class MessagingService : FirebaseMessagingService() {
                     }
                 }
 
-                val powerManager =
-                    applicationContext.getSystemService<PowerManager>()!!
-                val wakeLock = powerManager.newWakeLock(
+                val powerManager = context.getSystemService<PowerManager>()
+                val wakeLock = powerManager?.newWakeLock(
                     PowerManager.FULL_WAKE_LOCK or
                         PowerManager.ACQUIRE_CAUSES_WAKEUP or
                         PowerManager.ON_AFTER_RELEASE,
                     "HomeAssistant::NotificationScreenOnWakeLock"
                 )
-                wakeLock.acquire(1 * 30 * 1000L /*30 seconds */)
-                wakeLock.release()
+                wakeLock?.acquire(1 * 30 * 1000L /*30 seconds */)
+                wakeLock?.release()
             }
             COMMAND_MEDIA -> {
                 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1) {
-                    if (!NotificationManagerCompat.getEnabledListenerPackages(applicationContext)
-                        .contains(applicationContext.packageName)
+                    if (!NotificationManagerCompat.getEnabledListenerPackages(context)
+                        .contains(context.packageName)
                     )
                         notifyMissingPermission(data[MESSAGE].toString())
                     else {
@@ -669,7 +650,7 @@ class MessagingService : FirebaseMessagingService() {
      *
      */
     private suspend fun sendNotification(data: Map<String, String>) {
-        val notificationManagerCompat = NotificationManagerCompat.from(this)
+        val notificationManagerCompat = NotificationManagerCompat.from(context)
 
         val tag = data["tag"]
         val messageId = tag?.hashCode() ?: System.currentTimeMillis().toInt()
@@ -694,7 +675,7 @@ class MessagingService : FirebaseMessagingService() {
 
         val channelId = handleChannel(notificationManagerCompat, data)
 
-        val notificationBuilder = NotificationCompat.Builder(this, channelId)
+        val notificationBuilder = NotificationCompat.Builder(context, channelId)
 
         handleSmallIcon(notificationBuilder, data)
 
@@ -780,7 +761,7 @@ class MessagingService : FirebaseMessagingService() {
         if (data[NOTIFICATION_ICON]?.startsWith("mdi") == true && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
             val iconName = data[NOTIFICATION_ICON]!!.split(":")[1]
             val iconDrawable =
-                IconicsDrawable(applicationContext, "cmd-$iconName").toAndroidIconCompat()
+                IconicsDrawable(context, "cmd-$iconName").toAndroidIconCompat()
             builder.setSmallIcon(iconDrawable)
         } else
             builder.setSmallIcon(commonR.drawable.ic_stat_ic_notification)
@@ -806,13 +787,13 @@ class MessagingService : FirebaseMessagingService() {
 
     ) {
 
-        val deleteIntent = Intent(this, NotificationDeleteReceiver::class.java).apply {
+        val deleteIntent = Intent(context, NotificationDeleteReceiver::class.java).apply {
             putExtra(NotificationDeleteReceiver.EXTRA_DATA, HashMap(data))
             putExtra(NotificationDeleteReceiver.EXTRA_NOTIFICATION_GROUP, group)
             putExtra(NotificationDeleteReceiver.EXTRA_NOTIFICATION_GROUP_ID, groupId)
         }
         val deletePendingIntent = PendingIntent.getBroadcast(
-            this,
+            context,
             messageId,
             deleteIntent,
             PendingIntent.FLAG_CANCEL_CURRENT or PendingIntent.FLAG_IMMUTABLE
@@ -839,7 +820,7 @@ class MessagingService : FirebaseMessagingService() {
         data: Map<String, String>
     ): NotificationCompat.Builder {
 
-        val groupNotificationBuilder = NotificationCompat.Builder(this, channelId)
+        val groupNotificationBuilder = NotificationCompat.Builder(context, channelId)
             .setStyle(
                 NotificationCompat.BigTextStyle()
                     .setSummaryText(
@@ -864,11 +845,11 @@ class MessagingService : FirebaseMessagingService() {
             builder.setCategory(Notification.CATEGORY_ALARM)
             builder.setSound(
                 RingtoneManager.getActualDefaultRingtoneUri(
-                    applicationContext,
+                    context,
                     RingtoneManager.TYPE_ALARM
                 )
                     ?: RingtoneManager.getActualDefaultRingtoneUri(
-                        applicationContext,
+                        context,
                         RingtoneManager.TYPE_RINGTONE
                     ),
                 AudioManager.STREAM_ALARM
@@ -898,7 +879,7 @@ class MessagingService : FirebaseMessagingService() {
                 Log.e(TAG, "Unable to parse color", e)
             }
         }
-        return ContextCompat.getColor(this, default)
+        return ContextCompat.getColor(context, default)
     }
 
     private fun handleLegacyLedColor(
@@ -1102,7 +1083,7 @@ class MessagingService : FirebaseMessagingService() {
                     data["action_${i}_uri"],
                     data
                 )
-                val eventIntent = Intent(this, NotificationActionReceiver::class.java).apply {
+                val eventIntent = Intent(context, NotificationActionReceiver::class.java).apply {
                     action = NotificationActionReceiver.FIRE_EVENT
                     if (data["sticky"]?.toBoolean() != true) {
                         putExtra(NotificationActionReceiver.EXTRA_NOTIFICATION_TAG, tag)
@@ -1126,11 +1107,11 @@ class MessagingService : FirebaseMessagingService() {
                     }
                     REPLY -> {
                         val remoteInput: RemoteInput = RemoteInput.Builder(KEY_TEXT_REPLY).run {
-                            setLabel(getString(commonR.string.action_reply))
+                            setLabel(context.getString(commonR.string.action_reply))
                             build()
                         }
                         val replyPendingIntent = PendingIntent.getBroadcast(
-                            this,
+                            context,
                             0,
                             eventIntent,
                             PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE
@@ -1146,12 +1127,16 @@ class MessagingService : FirebaseMessagingService() {
                     }
                     else -> {
                         val actionPendingIntent = PendingIntent.getBroadcast(
-                            this,
+                            context,
                             (notificationAction.title.hashCode() + System.currentTimeMillis()).toInt(),
                             eventIntent,
                             PendingIntent.FLAG_IMMUTABLE
                         )
-                        builder.addAction(commonR.drawable.ic_stat_ic_notification, notificationAction.title, actionPendingIntent)
+                        builder.addAction(
+                            commonR.drawable.ic_stat_ic_notification,
+                            notificationAction.title,
+                            actionPendingIntent
+                        )
                     }
                 }
             }
@@ -1163,10 +1148,10 @@ class MessagingService : FirebaseMessagingService() {
     ): PendingIntent {
         val intent = when {
             uri.isBlank() -> {
-                WebViewActivity.newInstance(this)
+                WebViewActivity.newInstance(context)
             }
             uri.startsWith(APP_PREFIX) -> {
-                packageManager.getLaunchIntentForPackage(uri.substringAfter(APP_PREFIX))
+                context.packageManager.getLaunchIntentForPackage(uri.substringAfter(APP_PREFIX))
             }
             UrlHandler.isAbsoluteUrl(uri) -> {
                 Intent(Intent.ACTION_VIEW).apply {
@@ -1174,15 +1159,15 @@ class MessagingService : FirebaseMessagingService() {
                 }
             }
             else -> {
-                WebViewActivity.newInstance(this, uri)
+                WebViewActivity.newInstance(context, uri)
             }
-        } ?: WebViewActivity.newInstance(this)
+        } ?: WebViewActivity.newInstance(context)
 
         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
         intent.addFlags(Intent.FLAG_ACTIVITY_MULTIPLE_TASK)
 
         return PendingIntent.getActivity(
-            this,
+            context,
             (uri.hashCode() + System.currentTimeMillis()).toInt(),
             intent,
             PendingIntent.FLAG_IMMUTABLE
@@ -1258,11 +1243,11 @@ class MessagingService : FirebaseMessagingService() {
             .build()
         channel.setSound(
             RingtoneManager.getActualDefaultRingtoneUri(
-                applicationContext,
+                context,
                 RingtoneManager.TYPE_ALARM
             )
                 ?: RingtoneManager.getActualDefaultRingtoneUri(
-                    applicationContext,
+                    context,
                     RingtoneManager.TYPE_RINGTONE
                 ),
             audioAttributes
@@ -1302,24 +1287,24 @@ class MessagingService : FirebaseMessagingService() {
         val intent =
             Intent(Settings.ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS)
         intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
-        startActivity(intent)
+        context.startActivity(intent)
     }
 
     @RequiresApi(Build.VERSION_CODES.M)
     private fun requestSystemAlertPermission() {
         val intent = Intent(
             Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
-            Uri.parse("package:$packageName")
+            Uri.parse("package:${context.packageName}")
         )
         intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
-        startActivity(intent)
+        context.startActivity(intent)
     }
 
     @RequiresApi(Build.VERSION_CODES.LOLLIPOP_MR1)
     private fun requestNotificationPermission() {
         val intent = Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS)
         intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
-        startActivity(intent)
+        context.startActivity(intent)
     }
 
     private fun getKeyEvent(key: String): Int {
@@ -1338,11 +1323,10 @@ class MessagingService : FirebaseMessagingService() {
 
     private fun processMediaCommand(data: Map<String, String>) {
         val title = data[TITLE]
-        val mediaSessionManager =
-            applicationContext.getSystemService<MediaSessionManager>()!!
+        val mediaSessionManager = context.getSystemService<MediaSessionManager>()!!
         val mediaList = mediaSessionManager.getActiveSessions(
             ComponentName(
-                applicationContext,
+                context,
                 NotificationSensorManager::class.java
             )
         )
@@ -1352,7 +1336,7 @@ class MessagingService : FirebaseMessagingService() {
                 if (item.packageName == data["channel"]) {
                     hasCorrectPackage = true
                     val mediaSessionController =
-                        MediaController(applicationContext, item.sessionToken)
+                        MediaController(context, item.sessionToken)
                     val success = mediaSessionController.dispatchMediaButtonEvent(
                         KeyEvent(
                             KeyEvent.ACTION_DOWN,
@@ -1466,9 +1450,9 @@ class MessagingService : FirebaseMessagingService() {
             intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
             if (!packageName.isNullOrEmpty()) {
                 intent.setPackage(packageName)
-                startActivity(intent)
-            } else if (intent.resolveActivity(applicationContext.packageManager) != null)
-                startActivity(intent)
+                context.startActivity(intent)
+            } else if (intent.resolveActivity(context.packageManager) != null)
+                context.startActivity(intent)
             else
                 mainScope.launch {
                     Log.d(
@@ -1481,7 +1465,7 @@ class MessagingService : FirebaseMessagingService() {
             Log.e(TAG, "Unable to send activity intent please check command format", e)
             Handler(Looper.getMainLooper()).post {
                 Toast.makeText(
-                    applicationContext,
+                    context,
                     commonR.string.activity_intent_error,
                     Toast.LENGTH_LONG
                 ).show()
@@ -1492,11 +1476,11 @@ class MessagingService : FirebaseMessagingService() {
     private fun openWebview(title: String?) {
         try {
             val intent = if (title.isNullOrEmpty())
-                WebViewActivity.newInstance(applicationContext)
+                WebViewActivity.newInstance(context)
             else
-                WebViewActivity.newInstance(applicationContext, title)
+                WebViewActivity.newInstance(context, title)
             intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK
-            startActivity(intent)
+            context.startActivity(intent)
         } catch (e: Exception) {
             Log.e(TAG, "Unable to open webview", e)
         }
@@ -1504,14 +1488,14 @@ class MessagingService : FirebaseMessagingService() {
 
     private fun notifyMissingPermission(type: String) {
         val appManager =
-            applicationContext.getSystemService<ActivityManager>()!!
-        val currentProcess = appManager.runningAppProcesses
+            context.getSystemService<ActivityManager>()
+        val currentProcess = appManager?.runningAppProcesses
         if (currentProcess != null) {
             for (item in currentProcess) {
-                if (applicationContext.applicationInfo.processName == item.processName) {
+                if (context.applicationInfo.processName == item.processName) {
                     if (item.importance != ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                         val data =
-                            mutableMapOf(MESSAGE to getString(commonR.string.missing_command_permission))
+                            mutableMapOf(MESSAGE to context.getString(commonR.string.missing_command_permission))
                         runBlocking {
                             sendNotification(data)
                         }
@@ -1532,29 +1516,4 @@ class MessagingService : FirebaseMessagingService() {
             }
         }
     }
-
-    /**
-     * Called if InstanceID token is updated. This may occur if the security of
-     * the previous token had been compromised. Note that this is called when the InstanceID token
-     * is initially generated so this is where you would retrieve the token.
-     */
-    override fun onNewToken(token: String) {
-        mainScope.launch {
-            Log.d(TAG, "Refreshed token: $token")
-            if (authenticationUseCase.getSessionState() == SessionState.ANONYMOUS) {
-                Log.d(TAG, "Not trying to update registration since we aren't authenticated.")
-                return@launch
-            }
-            try {
-                integrationUseCase.updateRegistration(
-                    DeviceRegistration(
-                        pushToken = token
-                    )
-                )
-            } catch (e: Exception) {
-                // TODO: Store for update later
-                Log.e(TAG, "Issue updating token", e)
-            }
-        }
-    }
 }
diff --git a/app/src/full/java/io/homeassistant/companion/android/notifications/NotificationAction.kt b/app/src/main/java/io/homeassistant/companion/android/notifications/NotificationAction.kt
similarity index 100%
rename from app/src/full/java/io/homeassistant/companion/android/notifications/NotificationAction.kt
rename to app/src/main/java/io/homeassistant/companion/android/notifications/NotificationAction.kt
diff --git a/app/src/full/java/io/homeassistant/companion/android/notifications/NotificationActionReceiver.kt b/app/src/main/java/io/homeassistant/companion/android/notifications/NotificationActionReceiver.kt
similarity index 93%
rename from app/src/full/java/io/homeassistant/companion/android/notifications/NotificationActionReceiver.kt
rename to app/src/main/java/io/homeassistant/companion/android/notifications/NotificationActionReceiver.kt
index 07ad7231f32..88aff3d3afb 100644
--- a/app/src/full/java/io/homeassistant/companion/android/notifications/NotificationActionReceiver.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/notifications/NotificationActionReceiver.kt
@@ -10,6 +10,7 @@ import androidx.core.app.NotificationManagerCompat
 import androidx.core.app.RemoteInput
 import dagger.hilt.android.AndroidEntryPoint
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
+import io.homeassistant.companion.android.notifications.MessagingManager.Companion.KEY_TEXT_REPLY
 import io.homeassistant.companion.android.util.cancel
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
@@ -62,8 +63,7 @@ class NotificationActionReceiver : BroadcastReceiver() {
         if (notificationAction.key == "REPLY") {
             notificationAction.data += Pair(
                 "reply_text",
-                RemoteInput.getResultsFromIntent(intent)
-                    .getCharSequence(MessagingService.KEY_TEXT_REPLY).toString()
+                RemoteInput.getResultsFromIntent(intent).getCharSequence(KEY_TEXT_REPLY).toString()
             )
         }
 
diff --git a/app/src/full/java/io/homeassistant/companion/android/notifications/NotificationDeleteReceiver.kt b/app/src/main/java/io/homeassistant/companion/android/notifications/NotificationDeleteReceiver.kt
similarity index 100%
rename from app/src/full/java/io/homeassistant/companion/android/notifications/NotificationDeleteReceiver.kt
rename to app/src/main/java/io/homeassistant/companion/android/notifications/NotificationDeleteReceiver.kt
diff --git a/app/src/main/java/io/homeassistant/companion/android/sensors/BluetoothSensorManager.kt b/app/src/main/java/io/homeassistant/companion/android/sensors/BluetoothSensorManager.kt
index 6b2a6730917..1736bc1d47d 100644
--- a/app/src/main/java/io/homeassistant/companion/android/sensors/BluetoothSensorManager.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/sensors/BluetoothSensorManager.kt
@@ -8,7 +8,7 @@ import io.homeassistant.companion.android.bluetooth.ble.IBeaconTransmitter
 import io.homeassistant.companion.android.bluetooth.ble.TransmitterManager
 import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import java.util.UUID
 import kotlin.collections.ArrayList
 import io.homeassistant.companion.android.common.R as commonR
@@ -67,7 +67,7 @@ class BluetoothSensorManager : SensorManager {
             if (transmitEnabled) {
                 TransmitterManager.startTransmitting(context, bleTransmitterDevice)
             }
-            sensorDao.add(Setting(bleTransmitter.id, SETTING_BLE_TRANSMIT_ENABLED, transmitEnabled.toString(), "toggle"))
+            sensorDao.add(SensorSetting(bleTransmitter.id, SETTING_BLE_TRANSMIT_ENABLED, transmitEnabled.toString(), "toggle"))
         }
     }
 
diff --git a/app/src/main/java/io/homeassistant/companion/android/sensors/LastRebootSensorManager.kt b/app/src/main/java/io/homeassistant/companion/android/sensors/LastRebootSensorManager.kt
index a609c03b616..1b6b5e27f12 100644
--- a/app/src/main/java/io/homeassistant/companion/android/sensors/LastRebootSensorManager.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/sensors/LastRebootSensorManager.kt
@@ -6,7 +6,7 @@ import android.os.SystemClock
 import android.util.Log
 import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import java.text.SimpleDateFormat
 import java.util.Calendar
 import java.util.Date
@@ -68,7 +68,7 @@ class LastRebootSensorManager : SensorManager {
         val sensorSetting = sensorDao.getSettings(lastRebootSensor.id)
         val lastTimeMillis = fullSensor?.attributes?.firstOrNull { it.name == TIME_MILLISECONDS }?.value?.toLongOrNull() ?: 0L
         val settingDeadband = sensorSetting.firstOrNull { it.name == SETTING_DEADBAND }?.value?.toIntOrNull() ?: 60000
-        sensorDao.add(Setting(lastRebootSensor.id, SETTING_DEADBAND, settingDeadband.toString(), "number"))
+        sensorDao.add(SensorSetting(lastRebootSensor.id, SETTING_DEADBAND, settingDeadband.toString(), "number"))
         try {
             timeInMillis = System.currentTimeMillis() - SystemClock.elapsedRealtime()
             val diffMillis = (timeInMillis - lastTimeMillis).absoluteValue
diff --git a/app/src/main/java/io/homeassistant/companion/android/sensors/NetworkSensorManager.kt b/app/src/main/java/io/homeassistant/companion/android/sensors/NetworkSensorManager.kt
index 730047315f6..c3f748555be 100644
--- a/app/src/main/java/io/homeassistant/companion/android/sensors/NetworkSensorManager.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/sensors/NetworkSensorManager.kt
@@ -10,7 +10,7 @@ import androidx.core.content.getSystemService
 import io.homeassistant.companion.android.BuildConfig
 import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import okhttp3.Call
 import okhttp3.Callback
 import okhttp3.OkHttpClient
@@ -199,8 +199,8 @@ class NetworkSensorManager : SensorManager {
         val currentSetting = sensorSettings.firstOrNull { it.name == settingName }?.value ?: ""
         if (getCurrentBSSID == "true") {
             if (currentSetting == "") {
-                sensorDao.add(Setting(bssidState.id, SETTING_GET_CURRENT_BSSID, "false", "toggle"))
-                sensorDao.add(Setting(bssidState.id, settingName, bssid, "string"))
+                sensorDao.add(SensorSetting(bssidState.id, SETTING_GET_CURRENT_BSSID, "false", "toggle"))
+                sensorDao.add(SensorSetting(bssidState.id, settingName, bssid, "string"))
             }
         } else {
             if (currentSetting != "")
@@ -208,7 +208,7 @@ class NetworkSensorManager : SensorManager {
             else
                 sensorDao.removeSetting(bssidState.id, settingName)
 
-            sensorDao.add(Setting(bssidState.id, SETTING_GET_CURRENT_BSSID, "false", "toggle"))
+            sensorDao.add(SensorSetting(bssidState.id, SETTING_GET_CURRENT_BSSID, "false", "toggle"))
         }
 
         val icon = if (bssid != "<not connected>") "mdi:wifi" else "mdi:wifi-off"
diff --git a/app/src/main/java/io/homeassistant/companion/android/sensors/NextAlarmManager.kt b/app/src/main/java/io/homeassistant/companion/android/sensors/NextAlarmManager.kt
index db97bc5f644..ac96d2cfcd2 100644
--- a/app/src/main/java/io/homeassistant/companion/android/sensors/NextAlarmManager.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/sensors/NextAlarmManager.kt
@@ -7,7 +7,7 @@ import androidx.core.content.getSystemService
 import io.homeassistant.companion.android.BuildConfig
 import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import java.text.SimpleDateFormat
 import java.util.Calendar
 import java.util.Date
@@ -85,7 +85,7 @@ class NextAlarmManager : SensorManager {
                         return
                     }
                 } else {
-                    sensorDao.add(Setting(nextAlarm.id, SETTING_ALLOW_LIST, allowPackageList, "list-apps"))
+                    sensorDao.add(SensorSetting(nextAlarm.id, SETTING_ALLOW_LIST, allowPackageList, "list-apps"))
                 }
 
                 val cal: Calendar = GregorianCalendar()
diff --git a/app/src/main/java/io/homeassistant/companion/android/sensors/SensorDetailFragment.kt b/app/src/main/java/io/homeassistant/companion/android/sensors/SensorDetailFragment.kt
index 75ba4222128..dfdbebfcf9e 100644
--- a/app/src/main/java/io/homeassistant/companion/android/sensors/SensorDetailFragment.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/sensors/SensorDetailFragment.kt
@@ -27,7 +27,7 @@ import io.homeassistant.companion.android.common.sensors.SensorManager
 import io.homeassistant.companion.android.database.AppDatabase
 import io.homeassistant.companion.android.database.sensor.Sensor
 import io.homeassistant.companion.android.database.sensor.SensorDao
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import io.homeassistant.companion.android.util.DisabledLocationHandler
 import io.homeassistant.companion.android.util.LocationPermissionInfoHandler
 import kotlinx.coroutines.runBlocking
@@ -238,7 +238,7 @@ class SensorDetailFragment(
                         pref.setOnPreferenceChangeListener { _, newState ->
                             val isEnabled = newState as Boolean
 
-                            sensorDao.add(Setting(basicSensor.id, setting.name, isEnabled.toString(), "toggle", setting.enabled))
+                            sensorDao.add(SensorSetting(basicSensor.id, setting.name, isEnabled.toString(), "toggle", setting.enabled))
                             sensorManager.requestSensorUpdate(requireContext())
                             return@setOnPreferenceChangeListener true
                         }
@@ -256,7 +256,7 @@ class SensorDetailFragment(
                         pref.isIconSpaceReserved = false
                         pref.isSingleLineTitle = false
                         pref.setOnPreferenceChangeListener { _, newState ->
-                            sensorDao.add(Setting(basicSensor.id, setting.name, newState as String, "list", setting.entries, setting.enabled))
+                            sensorDao.add(SensorSetting(basicSensor.id, setting.name, newState as String, "list", setting.entries, setting.enabled))
                             sensorManager.requestSensorUpdate(requireContext())
                             return@setOnPreferenceChangeListener true
                         }
@@ -290,7 +290,7 @@ class SensorDetailFragment(
 
                         pref.setOnPreferenceChangeListener { _, newValue ->
                             sensorDao.add(
-                                Setting(
+                                SensorSetting(
                                     basicSensor.id,
                                     setting.name,
                                     newValue as String,
@@ -424,7 +424,7 @@ class SensorDetailFragment(
 
     private fun createListPreference(
         key: String,
-        setting: Setting,
+        sensorSetting: SensorSetting,
         sensorDao: SensorDao,
         entries: List<String>
     ): Preference {
@@ -432,8 +432,8 @@ class SensorDetailFragment(
         val pref = findPreference(key)
             ?: MultiSelectListPreference(requireContext())
         pref.key = key
-        pref.isEnabled = setting.enabled
-        pref.title = getTranslatedTitle(setting.name)
+        pref.isEnabled = sensorSetting.enabled
+        pref.title = getTranslatedTitle(sensorSetting.name)
         pref.dialogTitle = pref.title
         pref.entries = entries.toTypedArray()
         pref.entryValues = entries.toTypedArray()
@@ -441,18 +441,18 @@ class SensorDetailFragment(
         pref.isSingleLineTitle = false
 
         // If selected list values are empty, but the setting.value is filled, then set the selected list value to the setting value
-        if ((pref.values == null || pref.values.isEmpty()) && setting.value.isNotEmpty()) pref.values = setting.value.split(", ").map { it }.toSet()
+        if ((pref.values == null || pref.values.isEmpty()) && sensorSetting.value.isNotEmpty()) pref.values = sensorSetting.value.split(", ").map { it }.toSet()
 
         pref.summary = pref.values.toString()
 
         pref.setOnPreferenceChangeListener { _, newValue ->
             sensorDao.add(
-                Setting(
+                SensorSetting(
                     basicSensor.id,
-                    setting.name,
+                    sensorSetting.name,
                     newValue.toString().replace("[", "").replace("]", ""),
-                    setting.valueType,
-                    setting.enabled
+                    sensorSetting.valueType,
+                    sensorSetting.enabled
                 )
             )
             sensorManager.requestSensorUpdate(requireContext())
@@ -466,7 +466,7 @@ class SensorDetailFragment(
             }
             pref.summary = pref.values.toString()
         } else
-            pref.summary = setting.value
+            pref.summary = sensorSetting.value
 
         return pref
     }
diff --git a/app/src/main/java/io/homeassistant/companion/android/settings/SettingsFragment.kt b/app/src/main/java/io/homeassistant/companion/android/settings/SettingsFragment.kt
index ec6331aa3ae..af02f931271 100644
--- a/app/src/main/java/io/homeassistant/companion/android/settings/SettingsFragment.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/settings/SettingsFragment.kt
@@ -37,6 +37,7 @@ import io.homeassistant.companion.android.settings.shortcuts.ManageShortcutsSett
 import io.homeassistant.companion.android.settings.ssid.SsidDialogFragment
 import io.homeassistant.companion.android.settings.ssid.SsidPreference
 import io.homeassistant.companion.android.settings.wear.SettingsWearActivity
+import io.homeassistant.companion.android.settings.websocket.WebsocketSettingFragment
 import io.homeassistant.companion.android.settings.widgets.ManageWidgetsSettingsFragment
 import io.homeassistant.companion.android.util.DisabledLocationHandler
 import io.homeassistant.companion.android.util.LocationPermissionInfoHandler
@@ -189,23 +190,36 @@ class SettingsFragment constructor(
             }
         }
 
-        if (BuildConfig.FLAVOR == "full") {
-            findPreference<PreferenceCategory>("notifications")?.let {
-                it.isVisible = true
+        findPreference<PreferenceCategory>("notifications")?.let {
+            it.isVisible = true
+        }
+
+        findPreference<Preference>("local_notifications")?.let {
+            it.setOnPreferenceClickListener {
+                parentFragmentManager
+                    .beginTransaction()
+                    .replace(R.id.content, WebsocketSettingFragment::class.java, null)
+                    .addToBackStack(getString(commonR.string.notifications))
+                    .commit()
+                return@setOnPreferenceClickListener true
             }
-            findPreference<Preference>("notification_history")?.let {
-                it.isVisible = true
-                it.setOnPreferenceClickListener {
-                    parentFragmentManager
-                        .beginTransaction()
-                        .replace(R.id.content, NotificationHistoryFragment::class.java, null)
-                        .addToBackStack(getString(commonR.string.notifications))
-                        .commit()
-                    return@setOnPreferenceClickListener true
-                }
+        }
+
+        findPreference<Preference>("notification_history")?.let {
+            it.isVisible = true
+            it.setOnPreferenceClickListener {
+                parentFragmentManager
+                    .beginTransaction()
+                    .replace(R.id.content, NotificationHistoryFragment::class.java, null)
+                    .addToBackStack(getString(commonR.string.notifications))
+                    .commit()
+                return@setOnPreferenceClickListener true
             }
+        }
 
+        if (BuildConfig.FLAVOR == "full") {
             findPreference<Preference>("notification_rate_limit")?.let {
+
                 lifecycleScope.launch(Dispatchers.Main) {
                     // Runs in IO Dispatcher
                     val rateLimits = presenter.getNotificationRateLimits()
@@ -227,23 +241,22 @@ class SettingsFragment constructor(
                     }
                 }
             }
-            findPreference<SwitchPreference>("crash_reporting")?.let {
-                it.isVisible = BuildConfig.FLAVOR == "full"
-                it.setOnPreferenceChangeListener { _, newValue ->
-                    val checked = newValue as Boolean
-
-                    true
-                }
+        }
+        findPreference<SwitchPreference>("crash_reporting")?.let {
+            it.isVisible = BuildConfig.FLAVOR == "full"
+            it.setOnPreferenceChangeListener { _, newValue ->
+                val checked = newValue as Boolean
+                true
             }
+        }
 
-            val pm = requireContext().packageManager
-            val hasWearApp = pm.getLaunchIntentForPackage("com.google.android.wearable.app")
-            val hasSamsungApp = pm.getLaunchIntentForPackage("com.samsung.android.app.watchmanager")
-            findPreference<PreferenceCategory>("wear_category")?.isVisible = BuildConfig.FLAVOR == "full" && (hasWearApp != null || hasSamsungApp != null)
-            findPreference<Preference>("wear_settings")?.setOnPreferenceClickListener {
-                startActivity(SettingsWearActivity.newInstance(requireContext()))
-                return@setOnPreferenceClickListener true
-            }
+        val pm = requireContext().packageManager
+        val hasWearApp = pm.getLaunchIntentForPackage("com.google.android.wearable.app")
+        val hasSamsungApp = pm.getLaunchIntentForPackage("com.samsung.android.app.watchmanager")
+        findPreference<PreferenceCategory>("wear_category")?.isVisible = BuildConfig.FLAVOR == "full" && (hasWearApp != null || hasSamsungApp != null)
+        findPreference<Preference>("wear_settings")?.setOnPreferenceClickListener {
+            startActivity(SettingsWearActivity.newInstance(requireContext()))
+            return@setOnPreferenceClickListener true
         }
 
         findPreference<Preference>("changelog")?.let {
diff --git a/app/src/main/java/io/homeassistant/companion/android/settings/websocket/WebsocketSettingFragment.kt b/app/src/main/java/io/homeassistant/companion/android/settings/websocket/WebsocketSettingFragment.kt
new file mode 100644
index 00000000000..83e090812e9
--- /dev/null
+++ b/app/src/main/java/io/homeassistant/companion/android/settings/websocket/WebsocketSettingFragment.kt
@@ -0,0 +1,36 @@
+package io.homeassistant.companion.android.settings.websocket
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.compose.runtime.collectAsState
+import androidx.compose.ui.platform.ComposeView
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.viewModels
+import com.google.android.material.composethemeadapter.MdcTheme
+import io.homeassistant.companion.android.settings.websocket.views.WebsocketSettingView
+
+class WebsocketSettingFragment : Fragment() {
+
+    val viewModel: WebsocketSettingViewModel by viewModels()
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        savedInstanceState: Bundle?
+    ): View {
+        return ComposeView(requireContext()).apply {
+            setContent {
+                MdcTheme {
+                    val settings = viewModel.getWebsocketSettingFlow(0)
+                        .collectAsState(initial = viewModel.getWebsocketSetting(0))
+                    WebsocketSettingView(
+                        websocketSetting = settings.value.websocketSetting,
+                        onSettingChanged = { viewModel.updateWebsocketSetting(0, it) }
+                    )
+                }
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/io/homeassistant/companion/android/settings/websocket/WebsocketSettingViewModel.kt b/app/src/main/java/io/homeassistant/companion/android/settings/websocket/WebsocketSettingViewModel.kt
new file mode 100644
index 00000000000..05b4837c4f2
--- /dev/null
+++ b/app/src/main/java/io/homeassistant/companion/android/settings/websocket/WebsocketSettingViewModel.kt
@@ -0,0 +1,38 @@
+package io.homeassistant.companion.android.settings.websocket
+
+import android.app.Application
+import androidx.lifecycle.AndroidViewModel
+import io.homeassistant.companion.android.database.AppDatabase
+import io.homeassistant.companion.android.database.settings.Setting
+import io.homeassistant.companion.android.database.settings.WebsocketSetting
+import io.homeassistant.companion.android.websocket.WebsocketManager
+import kotlinx.coroutines.flow.Flow
+import javax.inject.Inject
+
+class WebsocketSettingViewModel @Inject constructor(
+    application: Application
+) : AndroidViewModel(
+    application
+) {
+    private val settingsDao = AppDatabase.getInstance(application).settingsDao()
+
+    fun getWebsocketSetting(id: Int): Setting {
+        var setting = settingsDao.get(id)
+        if (setting == null) {
+            setting = Setting(id, WebsocketSetting.SCREEN_ON)
+            settingsDao.insert(setting)
+        }
+        return setting
+    }
+
+    // Once we support more than one instance we can get the setting per instance
+    fun getWebsocketSettingFlow(id: Int): Flow<Setting> = settingsDao.getFlow(id)
+
+    fun updateWebsocketSetting(id: Int, setting: WebsocketSetting) {
+        settingsDao.get(id)?.let {
+            it.websocketSetting = setting
+            settingsDao.update(it)
+        }
+        WebsocketManager.start(getApplication())
+    }
+}
diff --git a/app/src/main/java/io/homeassistant/companion/android/settings/websocket/views/WebsocketSettingView.kt b/app/src/main/java/io/homeassistant/companion/android/settings/websocket/views/WebsocketSettingView.kt
new file mode 100644
index 00000000000..485030f2704
--- /dev/null
+++ b/app/src/main/java/io/homeassistant/companion/android/settings/websocket/views/WebsocketSettingView.kt
@@ -0,0 +1,60 @@
+package io.homeassistant.companion.android.settings.websocket.views
+
+import androidx.compose.foundation.layout.Column
+import androidx.compose.foundation.layout.Row
+import androidx.compose.foundation.layout.fillMaxWidth
+import androidx.compose.foundation.layout.padding
+import androidx.compose.foundation.selection.selectable
+import androidx.compose.material.RadioButton
+import androidx.compose.material.Text
+import androidx.compose.runtime.Composable
+import androidx.compose.ui.Alignment
+import androidx.compose.ui.Modifier
+import androidx.compose.ui.res.stringResource
+import androidx.compose.ui.unit.dp
+import io.homeassistant.companion.android.common.R
+import io.homeassistant.companion.android.database.settings.WebsocketSetting
+
+@Composable
+fun WebsocketSettingView(
+    websocketSetting: WebsocketSetting,
+    onSettingChanged: (WebsocketSetting) -> Unit
+) {
+    Column(modifier = Modifier.padding(20.dp)) {
+        Row(verticalAlignment = Alignment.CenterVertically) {
+            Text(stringResource(R.string.websocket_setting_description))
+        }
+        RadioButtonRow(
+            text = stringResource(R.string.websocket_setting_never),
+            selected = websocketSetting == WebsocketSetting.NEVER,
+            onClick = { onSettingChanged(WebsocketSetting.NEVER) }
+        )
+        RadioButtonRow(
+            text = stringResource(R.string.websocket_setting_while_screen_on),
+            selected = websocketSetting == WebsocketSetting.SCREEN_ON,
+            onClick = { onSettingChanged(WebsocketSetting.SCREEN_ON) }
+        )
+        RadioButtonRow(
+            text = stringResource(R.string.websocket_setting_always),
+            selected = websocketSetting == WebsocketSetting.ALWAYS,
+            onClick = { onSettingChanged(WebsocketSetting.ALWAYS) }
+        )
+    }
+}
+
+@Composable
+fun RadioButtonRow(
+    text: String,
+    selected: Boolean,
+    onClick: () -> Unit
+) {
+    Row(
+        modifier = Modifier
+            .fillMaxWidth()
+            .selectable(selected = selected, onClick = onClick),
+        verticalAlignment = Alignment.CenterVertically
+    ) {
+        RadioButton(selected = selected, onClick = onClick)
+        Text(text)
+    }
+}
diff --git a/app/src/main/java/io/homeassistant/companion/android/websocket/WebsocketBroadcastReceiver.kt b/app/src/main/java/io/homeassistant/companion/android/websocket/WebsocketBroadcastReceiver.kt
new file mode 100644
index 00000000000..7a704c3a203
--- /dev/null
+++ b/app/src/main/java/io/homeassistant/companion/android/websocket/WebsocketBroadcastReceiver.kt
@@ -0,0 +1,11 @@
+package io.homeassistant.companion.android.websocket
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+
+class WebsocketBroadcastReceiver : BroadcastReceiver() {
+    override fun onReceive(context: Context, intent: Intent) {
+        WebsocketManager.start(context)
+    }
+}
diff --git a/app/src/main/java/io/homeassistant/companion/android/websocket/WebsocketManager.kt b/app/src/main/java/io/homeassistant/companion/android/websocket/WebsocketManager.kt
new file mode 100644
index 00000000000..4bf3f54e72c
--- /dev/null
+++ b/app/src/main/java/io/homeassistant/companion/android/websocket/WebsocketManager.kt
@@ -0,0 +1,178 @@
+package io.homeassistant.companion.android.websocket
+
+import android.app.NotificationChannel
+import android.app.NotificationManager
+import android.content.Context
+import android.hardware.display.DisplayManager
+import android.os.Build
+import android.util.Log
+import android.view.Display
+import androidx.core.app.NotificationCompat
+import androidx.core.content.getSystemService
+import androidx.work.Constraints
+import androidx.work.CoroutineWorker
+import androidx.work.ExistingPeriodicWorkPolicy
+import androidx.work.ForegroundInfo
+import androidx.work.NetworkType
+import androidx.work.PeriodicWorkRequestBuilder
+import androidx.work.WorkManager
+import androidx.work.WorkerParameters
+import dagger.hilt.EntryPoint
+import dagger.hilt.InstallIn
+import dagger.hilt.android.EntryPointAccessors
+import dagger.hilt.components.SingletonComponent
+import io.homeassistant.companion.android.BuildConfig
+import io.homeassistant.companion.android.common.R
+import io.homeassistant.companion.android.common.data.websocket.WebSocketRepository
+import io.homeassistant.companion.android.database.AppDatabase
+import io.homeassistant.companion.android.database.settings.WebsocketSetting
+import io.homeassistant.companion.android.notifications.MessagingManager
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.cancelAndJoin
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.withContext
+import java.util.concurrent.TimeUnit
+
+@ExperimentalCoroutinesApi
+class WebsocketManager(
+    appContext: Context,
+    workerParams: WorkerParameters
+) : CoroutineWorker(appContext, workerParams) {
+
+    companion object {
+        private const val TAG = "WebSockManager"
+        private const val CHANNEL_ID = "Websocket"
+        private const val NOTIFICATION_ID = 65423
+        private val DEFAULT_WEBSOCKET_SETTING = if (BuildConfig.FLAVOR == "full") WebsocketSetting.SCREEN_ON else WebsocketSetting.ALWAYS
+
+        fun start(context: Context) {
+            val constraints = Constraints.Builder()
+                .setRequiredNetworkType(NetworkType.CONNECTED)
+                .build()
+
+            val websocketNotifications =
+                PeriodicWorkRequestBuilder<WebsocketManager>(15, TimeUnit.MINUTES)
+                    .setConstraints(constraints)
+                    .build()
+
+            WorkManager.getInstance(context)
+                .enqueueUniquePeriodicWork(
+                    TAG,
+                    ExistingPeriodicWorkPolicy.REPLACE,
+                    websocketNotifications
+                )
+        }
+    }
+
+    private val notificationManager = applicationContext.getSystemService<NotificationManager>()!!
+
+    private val entryPoint = EntryPointAccessors
+        .fromApplication(applicationContext, WebsocketManagerEntryPoint::class.java)
+
+    private val websocketRepository: WebSocketRepository = entryPoint.websocketRepository()
+    private val messagingManager: MessagingManager = entryPoint.messagingManager()
+
+    private val settingsDao = AppDatabase.getInstance(appContext).settingsDao()
+
+    @EntryPoint
+    @InstallIn(SingletonComponent::class)
+    interface WebsocketManagerEntryPoint {
+        fun websocketRepository(): WebSocketRepository
+        fun messagingManager(): MessagingManager
+    }
+
+    override suspend fun doWork(): Result {
+        if (!shouldWeRun()) {
+            return Result.success()
+        }
+
+        Log.d(TAG, "Starting to listen to Websocket")
+        createNotification()
+
+        // Start listening for notifications
+        val job = withContext(Dispatchers.IO) {
+            return@withContext launch { collectNotifications() }
+        }
+
+        // play ping pong to ensure we have a connection.
+        ensureConnectionAlive()
+
+        job.cancelAndJoin()
+
+        Log.d(TAG, "Done listening to Websocket")
+
+        return Result.success()
+    }
+
+    private fun shouldWeRun(): Boolean {
+        val dm = applicationContext.getSystemService(Context.DISPLAY_SERVICE) as DisplayManager
+        val displayOff = dm.displays.all { it.state == Display.STATE_OFF }
+        val setting = settingsDao.get(0)?.websocketSetting ?: DEFAULT_WEBSOCKET_SETTING
+        if (setting == WebsocketSetting.NEVER) {
+            return false
+        } else if (displayOff && setting == WebsocketSetting.SCREEN_ON) {
+            return false
+        }
+
+        return true
+    }
+
+    private suspend fun ensureConnectionAlive() {
+        do {
+            delay(30000)
+        } while (websocketRepository.sendPing() && shouldWeRun())
+    }
+
+    private suspend fun collectNotifications() {
+        websocketRepository.getNotifications()?.collect {
+            if (it.containsKey("hass_confirm_id"))
+                websocketRepository.ackNotification(it["hass_confirm_id"].toString())
+            val flattened = mutableMapOf<String, String>()
+            if (it.containsKey("data")) {
+                for ((key, value) in it["data"] as Map<*, *>) {
+                    if (key == "actions" && value is List<*>) {
+                        value.forEachIndexed { i, action ->
+                            if (action is Map<*, *>) {
+                                flattened["action_${i + 1}_key"] = action["action"].toString()
+                                flattened["action_${i + 1}_title"] = action["title"].toString()
+                                flattened["action_${i + 1}_uri"] = action["uri"].toString()
+                            }
+                        }
+                    } else {
+                        flattened[key.toString()] = value.toString()
+                    }
+                }
+            }
+            // Message and title are in the root unlike all the others.
+            listOf("message", "title").forEach { key ->
+                if (it.containsKey(key))
+                    flattened[key] = it[key].toString()
+            }
+            messagingManager.handleMessage(flattened)
+        }
+    }
+
+    private suspend fun createNotification() {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            var notificationChannel =
+                notificationManager.getNotificationChannel(CHANNEL_ID)
+            if (notificationChannel == null) {
+                notificationChannel = NotificationChannel(
+                    CHANNEL_ID,
+                    CHANNEL_ID,
+                    NotificationManager.IMPORTANCE_LOW
+                )
+                notificationManager.createNotificationChannel(notificationChannel)
+            }
+        }
+
+        val notification = NotificationCompat.Builder(applicationContext, CHANNEL_ID)
+            .setSmallIcon(R.drawable.ic_stat_ic_notification)
+            .setContentTitle(applicationContext.getString(R.string.websocket_listening))
+            .setPriority(NotificationCompat.PRIORITY_LOW)
+            .build()
+        setForeground(ForegroundInfo(NOTIFICATION_ID, notification))
+    }
+}
diff --git a/app/src/main/java/io/homeassistant/companion/android/webview/WebViewActivity.kt b/app/src/main/java/io/homeassistant/companion/android/webview/WebViewActivity.kt
index a875ed7b4de..8e04e71208b 100644
--- a/app/src/main/java/io/homeassistant/companion/android/webview/WebViewActivity.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/webview/WebViewActivity.kt
@@ -78,8 +78,10 @@ import io.homeassistant.companion.android.settings.language.LanguagesManager
 import io.homeassistant.companion.android.themes.ThemesManager
 import io.homeassistant.companion.android.util.DisabledLocationHandler
 import io.homeassistant.companion.android.util.isStarted
+import io.homeassistant.companion.android.websocket.WebsocketManager
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.GlobalScope
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.delay
@@ -602,6 +604,7 @@ class WebViewActivity : BaseActivity(), io.homeassistant.companion.android.webvi
         }
     }
 
+    @ExperimentalCoroutinesApi
     override fun onResume() {
         super.onResume()
         if ((currentLang != languagesManager.getCurrentLang()) || currentAutoplay != presenter.isAutoPlayVideoEnabled())
@@ -619,6 +622,7 @@ class WebViewActivity : BaseActivity(), io.homeassistant.companion.android.webvi
             window.clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
 
         SensorWorker.start(this)
+        WebsocketManager.start(this)
         checkAndWarnForDisabledLocation()
     }
 
diff --git a/app/src/main/res/xml/preferences.xml b/app/src/main/res/xml/preferences.xml
index 0d4cb01710b..5bbaf4c179e 100644
--- a/app/src/main/res/xml/preferences.xml
+++ b/app/src/main/res/xml/preferences.xml
@@ -112,6 +112,10 @@
         android:title="@string/notifications"
         android:key="notifications"
         app:isPreferenceVisible="false">
+        <Preference
+            android:key="local_notifications"
+            android:title="@string/websocket_setting_name"
+            android:summary="@string/websocket_setting_summary" />
         <Preference
             android:key="notification_history"
             app:isPreferenceVisible="false"
diff --git a/app/src/minimal/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt b/app/src/minimal/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
index e7c10f6f934..9c3dd5b614b 100644
--- a/app/src/minimal/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
+++ b/app/src/minimal/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
@@ -19,6 +19,8 @@ class LocationSensorManager : LocationSensorManagerBase(), SensorManager {
             "io.homeassistant.companion.android.background.PROCESS_UPDATES"
         const val ACTION_PROCESS_GEO =
             "io.homeassistant.companion.android.background.PROCESS_GEOFENCE"
+        const val ACTION_FORCE_HIGH_ACCURACY =
+            "io.homeassistant.companion.android.background.FORCE_HIGH_ACCURACY"
 
         val backgroundLocation = SensorManager.BasicSensor(
             "location_background",
@@ -39,6 +41,8 @@ class LocationSensorManager : LocationSensorManagerBase(), SensorManager {
             commonR.string.sensor_description_location_accurate
         )
         internal const val TAG = "LocBroadcastReceiver"
+
+        fun setHighAccuracyModeSetting(context: Context, enabled: Boolean) {}
     }
 
     override fun onReceive(context: Context, intent: Intent) {
diff --git a/app/src/quest/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt b/app/src/quest/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
index e7c10f6f934..9c3dd5b614b 100755
--- a/app/src/quest/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
+++ b/app/src/quest/java/io/homeassistant/companion/android/sensors/LocationSensorManager.kt
@@ -19,6 +19,8 @@ class LocationSensorManager : LocationSensorManagerBase(), SensorManager {
             "io.homeassistant.companion.android.background.PROCESS_UPDATES"
         const val ACTION_PROCESS_GEO =
             "io.homeassistant.companion.android.background.PROCESS_GEOFENCE"
+        const val ACTION_FORCE_HIGH_ACCURACY =
+            "io.homeassistant.companion.android.background.FORCE_HIGH_ACCURACY"
 
         val backgroundLocation = SensorManager.BasicSensor(
             "location_background",
@@ -39,6 +41,8 @@ class LocationSensorManager : LocationSensorManagerBase(), SensorManager {
             commonR.string.sensor_description_location_accurate
         )
         internal const val TAG = "LocBroadcastReceiver"
+
+        fun setHighAccuracyModeSetting(context: Context, enabled: Boolean) {}
     }
 
     override fun onReceive(context: Context, intent: Intent) {
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/integration/IntegrationRepository.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/integration/IntegrationRepository.kt
index dacf8863da6..9d7aef6552a 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/integration/IntegrationRepository.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/integration/IntegrationRepository.kt
@@ -12,6 +12,7 @@ interface IntegrationRepository {
     suspend fun isRegistered(): Boolean
 
     suspend fun getNotificationRateLimits(): RateLimitResponse
+
     suspend fun renderTemplate(template: String, variables: Map<String, String>): String
 
     suspend fun updateLocation(updateLocation: UpdateLocation)
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/integration/impl/IntegrationRepositoryImpl.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/integration/impl/IntegrationRepositoryImpl.kt
index ae0ccf2c598..1bc5d3be794 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/integration/impl/IntegrationRepositoryImpl.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/integration/impl/IntegrationRepositoryImpl.kt
@@ -622,14 +622,7 @@ class IntegrationRepositoryImpl @Inject constructor(
     private suspend fun createUpdateRegistrationRequest(deviceRegistration: DeviceRegistration): RegisterDeviceRequest {
         val oldDeviceRegistration = getRegistration()
         val pushToken = deviceRegistration.pushToken ?: oldDeviceRegistration.pushToken
-        val appData = if (pushToken == null) {
-            null
-        } else {
-            hashMapOf(
-                "push_url" to PUSH_URL,
-                "push_token" to pushToken
-            )
-        }
+
         return RegisterDeviceRequest(
             null,
             null,
@@ -640,7 +633,11 @@ class IntegrationRepositoryImpl @Inject constructor(
             null,
             osVersion,
             null,
-            appData,
+            hashMapOf(
+                // TODO: This is a hack and should be fixed in core
+                "push_url" to if (!pushToken.isNullOrBlank()) PUSH_URL else "http://0.0.0.0/",
+                "push_token" to (pushToken ?: "")
+            ),
             null
         )
     }
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepository.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepository.kt
index b1b83dc7d7b..f5f87757a48 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepository.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepository.kt
@@ -4,6 +4,8 @@ import java.net.URL
 
 interface UrlRepository {
 
+    suspend fun getWebhookId(): String?
+
     suspend fun getApiUrls(): Array<URL>
 
     suspend fun saveRegistrationUrls(cloudHookUrl: String?, remoteUiUrl: String?, webhookId: String)
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepositoryImpl.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepositoryImpl.kt
index 9fc6f63c689..790bdf222ac 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepositoryImpl.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/url/UrlRepositoryImpl.kt
@@ -26,6 +26,10 @@ class UrlRepositoryImpl @Inject constructor(
         private const val TAG = "UrlRepository"
     }
 
+    override suspend fun getWebhookId(): String? {
+        return localStorage.getString(PREF_WEBHOOK_ID)
+    }
+
     override suspend fun getApiUrls(): Array<URL> {
         val retVal = ArrayList<URL>()
         val webhook = localStorage.getString(PREF_WEBHOOK_ID)
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/WebSocketRepository.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/WebSocketRepository.kt
index f261fde1467..8ee7d2f5e74 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/WebSocketRepository.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/WebSocketRepository.kt
@@ -26,4 +26,6 @@ interface WebSocketRepository {
     suspend fun getAreaRegistryUpdates(): Flow<AreaRegistryUpdatedEvent>?
     suspend fun getDeviceRegistryUpdates(): Flow<DeviceRegistryUpdatedEvent>?
     suspend fun getEntityRegistryUpdates(): Flow<EntityRegistryUpdatedEvent>?
+    suspend fun getNotifications(): Flow<Map<String, Any>>?
+    suspend fun ackNotification(confirmId: String): Boolean
 }
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt
index 78fee9219fa..505ca348453 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/websocket/impl/WebSocketRepositoryImpl.kt
@@ -4,6 +4,7 @@ import android.util.Log
 import com.fasterxml.jackson.core.type.TypeReference
 import com.fasterxml.jackson.databind.DeserializationFeature
 import com.fasterxml.jackson.databind.PropertyNamingStrategies
+import com.fasterxml.jackson.module.kotlin.contains
 import com.fasterxml.jackson.module.kotlin.convertValue
 import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
 import com.fasterxml.jackson.module.kotlin.readValue
@@ -30,6 +31,7 @@ import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.channels.ProducerScope
 import kotlinx.coroutines.channels.awaitClose
+import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.Flow
 import kotlinx.coroutines.flow.SharedFlow
 import kotlinx.coroutines.flow.SharingStarted
@@ -58,11 +60,14 @@ class WebSocketRepositoryImpl @Inject constructor(
 ) : WebSocketRepository, WebSocketListener() {
 
     companion object {
+        private const val TAG = "WebSocketRepository"
+
         private const val EVENT_STATE_CHANGED = "state_changed"
         private const val EVENT_AREA_REGISTRY_UPDATED = "area_registry_updated"
         private const val EVENT_DEVICE_REGISTRY_UPDATED = "device_registry_updated"
         private const val EVENT_ENTITY_REGISTRY_UPDATED = "entity_registry_updated"
-        private const val TAG = "WebSocketRepository"
+
+        private const val DISCONNECT_DELAY = 10000L
     }
 
     private val ioScope = CoroutineScope(Dispatchers.IO + Job())
@@ -76,8 +81,10 @@ class WebSocketRepositoryImpl @Inject constructor(
     private var connected = Job()
     private val eventSubscriptionMutex = Mutex()
     private val eventSubscriptionFlow = mutableMapOf<String, SharedFlow<*>>()
-
     private var eventSubscriptionProducerScope = mutableMapOf<String, ProducerScope<Any>>()
+    private val notificationMutex = Mutex()
+    private var notificationFlow: Flow<Map<String, Any>>? = null
+    private var notificationProducerScope: ProducerScope<Map<String, Any>>? = null
 
     override suspend fun sendPing(): Boolean {
         val socketResponse = sendMessage(
@@ -203,6 +210,48 @@ class WebSocketRepositoryImpl @Inject constructor(
         return eventSubscriptionFlow[eventType]!! as Flow<T>
     }
 
+    override suspend fun getNotifications(): Flow<Map<String, Any>>? {
+        notificationMutex.withLock {
+            if (notificationFlow == null) {
+                val response = sendMessage(
+                    mapOf(
+                        "type" to "mobile_app/push_notification_channel",
+                        "webhook_id" to urlRepository.getWebhookId(),
+                        "support_confirm" to true
+                    )
+                )
+
+                if (response == null) {
+                    Log.e(TAG, "Unable to register for notifications")
+                    return null
+                }
+
+                notificationFlow = callbackFlow {
+                    notificationProducerScope = this
+                    awaitClose {
+                        // TODO: Is there a way to unsubscribe?
+                        notificationFlow = null
+                        notificationProducerScope = null
+                        connection?.close(1001, "Done listening to notifications.")
+                    }
+                }.shareIn(ioScope, SharingStarted.WhileSubscribed(DISCONNECT_DELAY))
+            }
+
+            return notificationFlow
+        }
+    }
+
+    override suspend fun ackNotification(confirmId: String): Boolean {
+        val response = sendMessage(
+            mapOf(
+                "type" to "mobile_app/push_notification_confirm",
+                "webhook_id" to urlRepository.getWebhookId(),
+                "confirm_id" to confirmId
+            )
+        )
+        return response?.success == true
+    }
+
     private suspend fun connect(): Boolean {
         connectedMutex.withLock {
             if (connection != null && connected.isCompleted) {
@@ -249,19 +298,19 @@ class WebSocketRepositoryImpl @Inject constructor(
     }
 
     private suspend fun sendMessage(request: Map<*, *>): SocketResponse? {
-        val requestId = id.getAndIncrement()
-        val outbound = request.plus("id" to requestId)
         return if (connect()) {
-            Log.d(TAG, "Sending message $requestId: $outbound")
             withTimeoutOrNull(30000) {
                 suspendCancellableCoroutine { cont ->
+                    val requestId = id.getAndIncrement()
+                    val outbound = request.plus("id" to requestId)
+                    Log.d(TAG, "Sending message $requestId: $outbound")
                     responseCallbackJobs[requestId] = cont
                     connection!!.send(mapper.writeValueAsString(outbound))
                     Log.d(TAG, "Message number $requestId sent")
                 }
             }
         } else {
-            Log.e(TAG, "Unable to send message $requestId: $outbound")
+            Log.e(TAG, "Unable to send message $request")
             null
         }
     }
@@ -306,6 +355,15 @@ class WebSocketRepositoryImpl @Inject constructor(
                 eventResponseClass
             )
             eventSubscriptionProducerScope[eventResponse.eventType]?.send(eventResponse.data)
+        } else if (response.event?.contains("hass_confirm_id") == true) {
+            if (notificationProducerScope?.isActive == true) {
+                notificationProducerScope?.send(
+                    mapper.convertValue(
+                        response.event,
+                        object : TypeReference<Map<String, Any>>() {}
+                    )
+                )
+            }
         }
     }
 
@@ -313,8 +371,9 @@ class WebSocketRepositoryImpl @Inject constructor(
         connected = Job()
         connection = null
         // If we still have flows flowing
-        if (eventSubscriptionFlow.any() && ioScope.isActive) {
+        if ((eventSubscriptionFlow.any() || notificationFlow != null) && ioScope.isActive) {
             ioScope.launch {
+                delay(10000)
                 if (connect()) {
                     eventSubscriptionFlow.forEach { (eventType, _) ->
                         val resp = sendMessage(
@@ -327,6 +386,19 @@ class WebSocketRepositoryImpl @Inject constructor(
                             Log.e(TAG, "Issue re-registering event subscriptions")
                         }
                     }
+                    if (notificationFlow != null) {
+                        val response = sendMessage(
+                            mapOf(
+                                "type" to "mobile_app/push_notification_channel",
+                                "webhook_id" to urlRepository.getWebhookId(),
+                                "support_confirm" to true
+                            )
+                        )
+
+                        if (response == null) {
+                            Log.e(TAG, "Unable to re-register for notifications")
+                        }
+                    }
                 }
             }
         }
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/sensors/LastUpdateManager.kt b/common/src/main/java/io/homeassistant/companion/android/common/sensors/LastUpdateManager.kt
index 182b60539b4..e4fe905a965 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/sensors/LastUpdateManager.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/sensors/LastUpdateManager.kt
@@ -3,7 +3,7 @@ package io.homeassistant.companion.android.common.sensors
 import android.content.Context
 import android.util.Log
 import io.homeassistant.companion.android.database.AppDatabase
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import io.homeassistant.companion.android.common.R as commonR
 
 class LastUpdateManager : SensorManager {
@@ -69,11 +69,11 @@ class LastUpdateManager : SensorManager {
         val intentSetting = allSettings.firstOrNull { it.name == intentSettingName }?.value ?: ""
         if (addNewIntent == "true") {
             if (intentSetting == "") {
-                sensorDao.add(Setting(lastUpdate.id, SETTING_ADD_NEW_INTENT, "false", "toggle"))
-                sensorDao.add(Setting(lastUpdate.id, intentSettingName, intentAction, "string"))
+                sensorDao.add(SensorSetting(lastUpdate.id, SETTING_ADD_NEW_INTENT, "false", "toggle"))
+                sensorDao.add(SensorSetting(lastUpdate.id, intentSettingName, intentAction, "string"))
             }
         } else {
-            sensorDao.add(Setting(lastUpdate.id, SETTING_ADD_NEW_INTENT, "false", "toggle"))
+            sensorDao.add(SensorSetting(lastUpdate.id, SETTING_ADD_NEW_INTENT, "false", "toggle"))
         }
         for (setting in allSettings) {
             if (setting.value == "")
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/sensors/SensorManager.kt b/common/src/main/java/io/homeassistant/companion/android/common/sensors/SensorManager.kt
index f48a09e1a3f..9233ec6d327 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/sensors/SensorManager.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/sensors/SensorManager.kt
@@ -10,7 +10,7 @@ import androidx.core.content.getSystemService
 import io.homeassistant.companion.android.database.AppDatabase
 import io.homeassistant.companion.android.database.sensor.Attribute
 import io.homeassistant.companion.android.database.sensor.Sensor
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
 import io.homeassistant.companion.android.common.R as commonR
 
 interface SensorManager {
@@ -153,7 +153,7 @@ interface SensorManager {
             .firstOrNull { it.name == settingName }
             ?.value
         if (setting == null)
-            sensorDao.add(Setting(sensor.id, settingName, default, settingType, entries, enabled))
+            sensorDao.add(SensorSetting(sensor.id, settingName, default, settingType, entries, enabled))
 
         return setting ?: default
     }
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/AppDatabase.kt b/common/src/main/java/io/homeassistant/companion/android/database/AppDatabase.kt
index dda215610a8..da21e82567a 100644
--- a/common/src/main/java/io/homeassistant/companion/android/database/AppDatabase.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/database/AppDatabase.kt
@@ -30,7 +30,10 @@ import io.homeassistant.companion.android.database.sensor.Attribute
 import io.homeassistant.companion.android.database.sensor.EntriesTypeConverter
 import io.homeassistant.companion.android.database.sensor.Sensor
 import io.homeassistant.companion.android.database.sensor.SensorDao
-import io.homeassistant.companion.android.database.sensor.Setting
+import io.homeassistant.companion.android.database.sensor.SensorSetting
+import io.homeassistant.companion.android.database.settings.LocalNotificationSettingConverter
+import io.homeassistant.companion.android.database.settings.Setting
+import io.homeassistant.companion.android.database.settings.SettingsDao
 import io.homeassistant.companion.android.database.wear.Favorites
 import io.homeassistant.companion.android.database.wear.FavoritesDao
 import io.homeassistant.companion.android.database.widget.ButtonWidgetDao
@@ -51,7 +54,7 @@ import io.homeassistant.companion.android.common.R as commonR
         Attribute::class,
         Authentication::class,
         Sensor::class,
-        Setting::class,
+        SensorSetting::class,
         ButtonWidgetEntity::class,
         CameraWidgetEntity::class,
         MediaPlayerControlsWidgetEntity::class,
@@ -59,12 +62,16 @@ import io.homeassistant.companion.android.common.R as commonR
         TemplateWidgetEntity::class,
         NotificationItem::class,
         TileEntity::class,
-        Favorites::class
+        Favorites::class,
+        Setting::class
     ],
-    version = 20,
+    version = 21,
     exportSchema = false
 )
-@TypeConverters(EntriesTypeConverter::class)
+@TypeConverters(
+    LocalNotificationSettingConverter::class,
+    EntriesTypeConverter::class
+)
 abstract class AppDatabase : RoomDatabase() {
     abstract fun authenticationDao(): AuthenticationDao
     abstract fun sensorDao(): SensorDao
@@ -76,6 +83,7 @@ abstract class AppDatabase : RoomDatabase() {
     abstract fun notificationDao(): NotificationDao
     abstract fun tileDao(): TileDao
     abstract fun favoritesDao(): FavoritesDao
+    abstract fun settingsDao(): SettingsDao
 
     companion object {
         private const val DATABASE_NAME = "HomeAssistantDB"
@@ -119,7 +127,8 @@ abstract class AppDatabase : RoomDatabase() {
                     MIGRATION_16_17,
                     MIGRATION_17_18,
                     MIGRATION_18_19,
-                    MIGRATION_19_20
+                    MIGRATION_19_20,
+                    MIGRATION_20_21
                 )
                 .fallbackToDestructiveMigration()
                 .build()
@@ -454,6 +463,12 @@ abstract class AppDatabase : RoomDatabase() {
             }
         }
 
+        private val MIGRATION_20_21 = object : Migration(20, 21) {
+            override fun migrate(database: SupportSQLiteDatabase) {
+                database.execSQL("CREATE TABLE IF NOT EXISTS `settings` (`id` INTEGER NOT NULL, `websocketSetting` TEXT NOT NULL, PRIMARY KEY(`id`))")
+            }
+        }
+
         private fun createNotificationChannel() {
             if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                 val notificationManager = appContext.getSystemService<NotificationManager>()!!
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorDao.kt b/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorDao.kt
index 9bc72967802..38518e2d8d5 100644
--- a/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorDao.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorDao.kt
@@ -19,7 +19,7 @@ interface SensorDao {
 
     @Transaction
     @Query("SELECT * FROM sensor_settings WHERE sensor_id = :id")
-    fun getSettings(id: String): List<Setting>
+    fun getSettings(id: String): List<SensorSetting>
 
     @Insert(onConflict = OnConflictStrategy.IGNORE)
     fun add(sensor: Sensor)
@@ -28,7 +28,7 @@ interface SensorDao {
     fun add(attribute: Attribute)
 
     @Insert(onConflict = OnConflictStrategy.REPLACE)
-    fun add(setting: Setting)
+    fun add(sensorSetting: SensorSetting)
 
     @Query("DELETE FROM sensor_settings WHERE sensor_id = :sensorId AND name = :settingName")
     fun removeSetting(sensorId: String, settingName: String)
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/sensor/Setting.kt b/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorSetting.kt
similarity index 97%
rename from common/src/main/java/io/homeassistant/companion/android/database/sensor/Setting.kt
rename to common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorSetting.kt
index 81e74410799..f72f38472cd 100644
--- a/common/src/main/java/io/homeassistant/companion/android/database/sensor/Setting.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorSetting.kt
@@ -5,7 +5,7 @@ import androidx.room.Entity
 import androidx.room.TypeConverter
 
 @Entity(tableName = "sensor_settings", primaryKeys = ["sensor_id", "name"])
-data class Setting(
+data class SensorSetting(
     @ColumnInfo(name = "sensor_id")
     val sensorId: String,
     @ColumnInfo(name = "name")
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorWithSettings.kt b/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorWithSettings.kt
index 754c6947e6f..c8beb516fe7 100644
--- a/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorWithSettings.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/database/sensor/SensorWithSettings.kt
@@ -10,5 +10,5 @@ data class SensorWithSettings(
         parentColumn = "id",
         entityColumn = "sensor_id"
     )
-    val settings: List<Setting>
+    val sensorSettings: List<SensorSetting>
 )
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/settings/Setting.kt b/common/src/main/java/io/homeassistant/companion/android/database/settings/Setting.kt
new file mode 100644
index 00000000000..e380ea6a672
--- /dev/null
+++ b/common/src/main/java/io/homeassistant/companion/android/database/settings/Setting.kt
@@ -0,0 +1,14 @@
+package io.homeassistant.companion.android.database.settings
+
+import androidx.room.ColumnInfo
+import androidx.room.Entity
+import androidx.room.PrimaryKey
+
+@Entity(tableName = "settings")
+data class Setting(
+    @PrimaryKey
+    @ColumnInfo(name = "id")
+    val id: Int,
+    @ColumnInfo(name = "websocketSetting")
+    var websocketSetting: WebsocketSetting
+)
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/settings/SettingsDao.kt b/common/src/main/java/io/homeassistant/companion/android/database/settings/SettingsDao.kt
new file mode 100644
index 00000000000..0391b5b64d9
--- /dev/null
+++ b/common/src/main/java/io/homeassistant/companion/android/database/settings/SettingsDao.kt
@@ -0,0 +1,24 @@
+package io.homeassistant.companion.android.database.settings
+
+import androidx.room.Dao
+import androidx.room.Insert
+import androidx.room.OnConflictStrategy
+import androidx.room.Query
+import androidx.room.Update
+import kotlinx.coroutines.flow.Flow
+
+@Dao
+interface SettingsDao {
+
+    @Insert(onConflict = OnConflictStrategy.REPLACE)
+    fun insert(setting: Setting)
+
+    @Query("SELECT * FROM Settings WHERE id = :id")
+    fun get(id: Int): Setting?
+
+    @Query("SELECT * FROM Settings WHERE id = :id")
+    fun getFlow(id: Int): Flow<Setting>
+
+    @Update
+    fun update(setting: Setting)
+}
diff --git a/common/src/main/java/io/homeassistant/companion/android/database/settings/WebsocketSetting.kt b/common/src/main/java/io/homeassistant/companion/android/database/settings/WebsocketSetting.kt
new file mode 100644
index 00000000000..8c2c4c7fbd7
--- /dev/null
+++ b/common/src/main/java/io/homeassistant/companion/android/database/settings/WebsocketSetting.kt
@@ -0,0 +1,16 @@
+package io.homeassistant.companion.android.database.settings
+
+import androidx.room.TypeConverter
+
+enum class WebsocketSetting {
+    NEVER,
+    SCREEN_ON,
+    ALWAYS
+}
+
+class LocalNotificationSettingConverter {
+    @TypeConverter
+    fun toLocalNotificationSetting(setting: String): WebsocketSetting = WebsocketSetting.valueOf(setting)
+    @TypeConverter
+    fun fromLocalNotificationSetting(setting: WebsocketSetting): String = setting.name
+}
diff --git a/common/src/main/res/values/strings.xml b/common/src/main/res/values/strings.xml
index 76a27d0dbca..73253f13821 100644
--- a/common/src/main/res/values/strings.xml
+++ b/common/src/main/res/values/strings.xml
@@ -685,6 +685,7 @@
     <string name="wear_os_settings_title">Wear OS Settings</string>
     <string name="wear_set_favorites">Select your favorite entities to appear at the top of the wear home screen. You can also drag and drop to change the order in which they appear.</string>
     <string name="wear_settings">Wear Device Settings</string>
+    <string name="websocket_listening">Listening to Home Assistant via Websocket</string>
     <string name="webview_error_AUTH_SCHEME">Unsupported authentication scheme (not basic or digest), please check network settings.</string>
     <string name="webview_error_AUTHENTICATION">User authentication failed on server, please check server settings.</string>
     <string name="webview_error_description">Encountered error :</string>
@@ -738,5 +739,10 @@
     <string name="basic_sensor_name_last_used_app">Last Used App</string>
     <string name="sensor_description_last_used_app">Application name or package name of the last used application on the device</string>
     <string name="sensor_name_last_app">Last Used App</string>
-
+    <string name="websocket_setting_name">Websocket Settings</string>
+    <string name="websocket_setting_summary">Manage when we are in direct communication with your server via websockets.</string>
+    <string name="websocket_setting_description">Please select when you would like the application to attempt to directly communicate with your Home Assistant instance for all communication.  This will include push notifications, if you are on a minimal build this needs to be always to consistently get push notifications.</string>
+    <string name="websocket_setting_never">Never</string>
+    <string name="websocket_setting_while_screen_on">While Screen On</string>
+    <string name="websocket_setting_always">Always</string>
 </resources>
\ No newline at end of file
