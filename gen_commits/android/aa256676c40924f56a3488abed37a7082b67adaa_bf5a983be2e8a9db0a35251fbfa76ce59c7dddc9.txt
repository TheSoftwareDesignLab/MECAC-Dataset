diff --git a/app/src/main/java/io/homeassistant/companion/android/controls/CoverControl.kt b/app/src/main/java/io/homeassistant/companion/android/controls/CoverControl.kt
index 5b89a111995..a1260e49ab5 100644
--- a/app/src/main/java/io/homeassistant/companion/android/controls/CoverControl.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/controls/CoverControl.kt
@@ -14,6 +14,7 @@ import android.service.controls.templates.ToggleTemplate
 import androidx.annotation.RequiresApi
 import io.homeassistant.companion.android.common.data.integration.Entity
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
+import io.homeassistant.companion.android.common.data.integration.getCoverPosition
 import io.homeassistant.companion.android.common.data.websocket.impl.entities.AreaRegistryResponse
 import io.homeassistant.companion.android.common.R as commonR
 
@@ -36,14 +37,7 @@ object CoverControl : HaControl {
                 else -> entity.state
             }
         )
-        val minValue = 0f
-        val maxValue = 100f
-        var currentValue =
-            (entity.attributes["current_position"] as? Number)?.toFloat() ?: 0f
-        if (currentValue < minValue)
-            currentValue = minValue
-        if (currentValue > maxValue)
-            currentValue = maxValue
+        val position = entity.getCoverPosition()
         control.setControlTemplate(
             if ((entity.attributes["supported_features"] as Int) and SUPPORT_SET_POSITION == SUPPORT_SET_POSITION)
                 ToggleRangeTemplate(
@@ -52,9 +46,9 @@ object CoverControl : HaControl {
                     "",
                     RangeTemplate(
                         entity.entityId,
-                        minValue,
-                        maxValue,
-                        currentValue,
+                        position?.min ?: 0f,
+                        position?.max ?: 100f,
+                        position?.value ?: 0f,
                         1f,
                         "%.0f%%"
                     )
diff --git a/app/src/main/java/io/homeassistant/companion/android/controls/FanControl.kt b/app/src/main/java/io/homeassistant/companion/android/controls/FanControl.kt
index 3cbb23f7dec..013a6050e5a 100644
--- a/app/src/main/java/io/homeassistant/companion/android/controls/FanControl.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/controls/FanControl.kt
@@ -14,6 +14,7 @@ import android.service.controls.templates.ToggleTemplate
 import androidx.annotation.RequiresApi
 import io.homeassistant.companion.android.common.data.integration.Entity
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
+import io.homeassistant.companion.android.common.data.integration.getFanSpeed
 import io.homeassistant.companion.android.common.data.integration.supportsFanSetSpeed
 import io.homeassistant.companion.android.common.data.websocket.impl.entities.AreaRegistryResponse
 import io.homeassistant.companion.android.common.R as commonR
@@ -27,14 +28,7 @@ object FanControl : HaControl {
         area: AreaRegistryResponse?
     ): Control.StatefulBuilder {
         if (entity.supportsFanSetSpeed()) {
-            val minValue = 0f
-            val maxValue = 100f
-            var currentValue =
-                (entity.attributes["percentage"] as? Number)?.toFloat() ?: 0f
-            if (currentValue < minValue)
-                currentValue = minValue
-            if (currentValue > maxValue)
-                currentValue = maxValue
+            val position = entity.getFanSpeed()
             control.setControlTemplate(
                 ToggleRangeTemplate(
                     entity.entityId,
@@ -42,9 +36,9 @@ object FanControl : HaControl {
                     "",
                     RangeTemplate(
                         entity.entityId,
-                        minValue,
-                        maxValue,
-                        currentValue,
+                        position?.min ?: 0f,
+                        position?.max ?: 100f,
+                        position?.value ?: 0f,
                         1f,
                         "%.0f%%"
                     )
diff --git a/app/src/main/java/io/homeassistant/companion/android/controls/LightControl.kt b/app/src/main/java/io/homeassistant/companion/android/controls/LightControl.kt
index 3ca255cfa31..08796ec5859 100644
--- a/app/src/main/java/io/homeassistant/companion/android/controls/LightControl.kt
+++ b/app/src/main/java/io/homeassistant/companion/android/controls/LightControl.kt
@@ -14,6 +14,7 @@ import android.service.controls.templates.ToggleTemplate
 import androidx.annotation.RequiresApi
 import io.homeassistant.companion.android.common.data.integration.Entity
 import io.homeassistant.companion.android.common.data.integration.IntegrationRepository
+import io.homeassistant.companion.android.common.data.integration.getLightBrightness
 import io.homeassistant.companion.android.common.data.integration.supportsLightBrightness
 import io.homeassistant.companion.android.common.data.websocket.impl.entities.AreaRegistryResponse
 import io.homeassistant.companion.android.common.R as commonR
@@ -26,13 +27,7 @@ object LightControl : HaControl {
         entity: Entity<Map<String, Any>>,
         area: AreaRegistryResponse?
     ): Control.StatefulBuilder {
-        val minValue = 0f
-        val maxValue = 100f
-        var currentValue = (entity.attributes["brightness"] as? Number)?.toFloat()?.div(255f)?.times(100) ?: 0f
-        if (currentValue < minValue)
-            currentValue = minValue
-        if (currentValue > maxValue)
-            currentValue = maxValue
+        val position = entity.getLightBrightness()
         control.setControlTemplate(
             if (entity.supportsLightBrightness())
                 ToggleRangeTemplate(
@@ -41,9 +36,9 @@ object LightControl : HaControl {
                     "",
                     RangeTemplate(
                         entity.entityId,
-                        minValue,
-                        maxValue,
-                        currentValue,
+                        position?.min ?: 0f,
+                        position?.max ?: 100f,
+                        position?.value ?: 0f,
                         1f,
                         "%.0f%%"
                     )
diff --git a/common/src/main/java/io/homeassistant/companion/android/common/data/integration/Entity.kt b/common/src/main/java/io/homeassistant/companion/android/common/data/integration/Entity.kt
index 8421f679c51..9d42529f6a2 100644
--- a/common/src/main/java/io/homeassistant/companion/android/common/data/integration/Entity.kt
+++ b/common/src/main/java/io/homeassistant/companion/android/common/data/integration/Entity.kt
@@ -1,5 +1,6 @@
 package io.homeassistant.companion.android.common.data.integration
 
+import android.graphics.Color
 import android.util.Log
 import java.util.Calendar
 
@@ -12,6 +13,12 @@ data class Entity<T>(
     val context: Map<String, Any>?
 )
 
+data class EntityPosition(
+    val value: Float,
+    val min: Float,
+    val max: Float
+)
+
 object EntityExt {
     const val TAG = "EntityExt"
 
@@ -25,6 +32,29 @@ object EntityExt {
 val <T> Entity<T>.domain: String
     get() = this.entityId.split(".")[0]
 
+fun <T> Entity<T>.getCoverPosition(): EntityPosition? {
+    // https://github.com/home-assistant/frontend/blob/dev/src/dialogs/more-info/controls/more-info-cover.ts#L33
+    return try {
+        if (
+            domain != "cover" ||
+            (attributes as Map<*, *>)["current_position"] == null
+        ) return null
+
+        val minValue = 0f
+        val maxValue = 100f
+        val currentValue = (attributes["current_position"] as? Number)?.toFloat() ?: 0f
+
+        EntityPosition(
+            value = currentValue.coerceAtLeast(minValue).coerceAtMost(maxValue),
+            min = minValue,
+            max = maxValue
+        )
+    } catch (e: Exception) {
+        Log.e(EntityExt.TAG, "Unable to get getCoverPosition", e)
+        null
+    }
+}
+
 fun <T> Entity<T>.supportsFanSetSpeed(): Boolean {
     return try {
         if (domain != "fan") return false
@@ -35,6 +65,26 @@ fun <T> Entity<T>.supportsFanSetSpeed(): Boolean {
     }
 }
 
+fun <T> Entity<T>.getFanSpeed(): EntityPosition? {
+    // https://github.com/home-assistant/frontend/blob/dev/src/dialogs/more-info/controls/more-info-fan.js#L48
+    return try {
+        if (!supportsFanSetSpeed()) return null
+
+        val minValue = 0f
+        val maxValue = 100f
+        val currentValue = ((attributes as Map<*, *>)["percentage"] as? Number)?.toFloat() ?: 0f
+
+        EntityPosition(
+            value = currentValue.coerceAtLeast(minValue).coerceAtMost(maxValue),
+            min = minValue,
+            max = maxValue
+        )
+    } catch (e: Exception) {
+        Log.e(EntityExt.TAG, "Unable to get getLightBrightness", e)
+        null
+    }
+}
+
 fun <T> Entity<T>.supportsLightBrightness(): Boolean {
     return try {
         if (domain != "light") return false
@@ -52,6 +102,33 @@ fun <T> Entity<T>.supportsLightBrightness(): Boolean {
     }
 }
 
+fun <T> Entity<T>.getLightBrightness(): EntityPosition? {
+    // https://github.com/home-assistant/frontend/blob/dev/src/dialogs/more-info/controls/more-info-light.ts#L90
+    return try {
+        if (!supportsLightBrightness()) return null
+
+        when (state) {
+            "on" -> {
+                val minValue = 0f
+                val maxValue = 100f
+                val currentValue =
+                    ((attributes as Map<*, *>)["brightness"] as? Number)?.toFloat()?.div(255f)?.times(100)
+                        ?: 0f
+
+                EntityPosition(
+                    value = currentValue.coerceAtLeast(minValue).coerceAtMost(maxValue),
+                    min = minValue,
+                    max = maxValue
+                )
+            }
+            else -> null
+        }
+    } catch (e: Exception) {
+        Log.e(EntityExt.TAG, "Unable to get getLightBrightness", e)
+        null
+    }
+}
+
 fun <T> Entity<T>.supportsLightColorTemperature(): Boolean {
     return try {
         if (domain != "light") return false
@@ -65,3 +142,21 @@ fun <T> Entity<T>.supportsLightColorTemperature(): Boolean {
         false
     }
 }
+
+fun <T> Entity<T>.getLightColor(): Int? {
+    // https://github.com/home-assistant/frontend/blob/dev/src/panels/lovelace/cards/hui-light-card.ts#L243
+    return try {
+        if (domain != "light") return null
+
+        when {
+            state != "off" && (attributes as Map<*, *>)["rgb_color"] != null -> {
+                val (r, g, b) = (attributes["rgb_color"] as List<Int>)
+                Color.rgb(r, g, b)
+            }
+            else -> null
+        }
+    } catch (e: Exception) {
+        Log.e(EntityExt.TAG, "Unable to get getLightColor", e)
+        null
+    }
+}
diff --git a/wear/build.gradle.kts b/wear/build.gradle.kts
index c487dcc2dfc..70261f93600 100644
--- a/wear/build.gradle.kts
+++ b/wear/build.gradle.kts
@@ -64,6 +64,9 @@ android {
 
     kotlinOptions {
         jvmTarget = "11"
+        // Temporarily required to implement an interface from Compose because they use @JvmDefault
+        // Remove when kotlin-gradle-plugin is >=1.6.20 (https://issuetracker.google.com/issues/217593040)
+        freeCompilerArgs = freeCompilerArgs + "-Xjvm-default=all"
     }
 
     lint {
diff --git a/wear/src/main/java/io/homeassistant/companion/android/home/views/DetailsPanelView.kt b/wear/src/main/java/io/homeassistant/companion/android/home/views/DetailsPanelView.kt
index 94135922539..c11a8d8b472 100644
--- a/wear/src/main/java/io/homeassistant/companion/android/home/views/DetailsPanelView.kt
+++ b/wear/src/main/java/io/homeassistant/companion/android/home/views/DetailsPanelView.kt
@@ -29,6 +29,8 @@ import io.homeassistant.companion.android.common.R
 import io.homeassistant.companion.android.common.data.integration.Entity
 import io.homeassistant.companion.android.common.data.integration.EntityExt
 import io.homeassistant.companion.android.common.data.integration.domain
+import io.homeassistant.companion.android.common.data.integration.getFanSpeed
+import io.homeassistant.companion.android.common.data.integration.getLightBrightness
 import io.homeassistant.companion.android.common.data.integration.supportsFanSetSpeed
 import io.homeassistant.companion.android.common.data.integration.supportsLightBrightness
 import io.homeassistant.companion.android.common.data.integration.supportsLightColorTemperature
@@ -98,14 +100,14 @@ fun DetailsPanelView(
             if (entity.domain == "fan") {
                 if (entity.supportsFanSetSpeed()) {
                     item {
-                        FanSpeedSlider(attributes, onFanSpeedChanged, isToastEnabled, isHapticEnabled)
+                        FanSpeedSlider(entity, onFanSpeedChanged, isToastEnabled, isHapticEnabled)
                     }
                 }
             }
             if (entity.domain == "light") {
                 if (entity.supportsLightBrightness()) {
                     item {
-                        BrightnessSlider(attributes, onBrightnessChanged, isToastEnabled, isHapticEnabled)
+                        BrightnessSlider(entity, onBrightnessChanged, isToastEnabled, isHapticEnabled)
                     }
                 }
 
@@ -159,44 +161,37 @@ fun DetailsPanelView(
 
 @Composable
 fun FanSpeedSlider(
-    attributes: Map<*, *>,
+    entity: Entity<*>,
     onFanSpeedChanged: (Float) -> Unit,
     isToastEnabled: Boolean,
     isHapticEnabled: Boolean
 ) {
     val haptic = LocalHapticFeedback.current
     val context = LocalContext.current
-
-    val minValue = 0f
-    val maxValue = 100f
-    var currentValue = (attributes["percentage"] as? Number)?.toFloat() ?: 0f
-    if (currentValue < minValue)
-        currentValue = minValue
-    if (currentValue > maxValue)
-        currentValue = maxValue
+    val position = entity.getFanSpeed() ?: return
 
     Column {
         Text(
-            stringResource(R.string.speed, currentValue.toInt()),
+            stringResource(R.string.speed, position.value.toInt()),
             modifier = Modifier
                 .fillMaxWidth()
                 .padding(horizontal = 8.dp)
         )
         InlineSlider(
-            value = currentValue,
+            value = position.value,
             onValueChange = {
                 onFanSpeedChanged(it)
                 onSliderChangedFeedback(
                     isToastEnabled,
                     isHapticEnabled,
-                    it > currentValue,
+                    it > position.value,
                     context.getString(R.string.slider_fan_speed),
                     context,
                     haptic
                 )
             },
             steps = 9,
-            valueRange = minValue..maxValue,
+            valueRange = position.min..position.max,
             decreaseIcon = {
                 Image(
                     asset = CommunityMaterial.Icon2.cmd_fan_minus,
@@ -216,46 +211,37 @@ fun FanSpeedSlider(
 
 @Composable
 fun BrightnessSlider(
-    attributes: Map<*, *>,
+    entity: Entity<*>,
     onBrightnessChanged: (Float) -> Unit,
     isToastEnabled: Boolean,
     isHapticEnabled: Boolean
 ) {
     val haptic = LocalHapticFeedback.current
     val context = LocalContext.current
-
-    val minValue = 0f
-    val maxValue = 100f
-    var currentValue =
-        (attributes["brightness"] as? Number)?.toFloat()?.div(255f)?.times(100)
-            ?: 0f
-    if (currentValue < minValue)
-        currentValue = minValue
-    if (currentValue > maxValue)
-        currentValue = maxValue
+    val position = entity.getLightBrightness() ?: return
 
     Column {
         Text(
-            stringResource(R.string.brightness, currentValue.toInt()),
+            stringResource(R.string.brightness, position.value.toInt()),
             modifier = Modifier
                 .fillMaxWidth()
                 .padding(horizontal = 8.dp)
         )
         InlineSlider(
-            value = currentValue,
+            value = position.value,
             onValueChange = { brightness ->
                 onBrightnessChanged(brightness.div(100).times(255))
                 onSliderChangedFeedback(
                     isToastEnabled,
                     isHapticEnabled,
-                    brightness > currentValue,
+                    brightness > position.value,
                     context.getString(R.string.slider_light_brightness),
                     context,
                     haptic
                 )
             },
             steps = 20,
-            valueRange = minValue..maxValue,
+            valueRange = position.min..position.max,
             decreaseIcon = {
                 Image(
                     asset = CommunityMaterial.Icon.cmd_brightness_4,
diff --git a/wear/src/main/java/io/homeassistant/companion/android/home/views/EntityUi.kt b/wear/src/main/java/io/homeassistant/companion/android/home/views/EntityUi.kt
index 5add742bbdb..b6c05267d61 100644
--- a/wear/src/main/java/io/homeassistant/companion/android/home/views/EntityUi.kt
+++ b/wear/src/main/java/io/homeassistant/companion/android/home/views/EntityUi.kt
@@ -25,6 +25,7 @@ import io.homeassistant.companion.android.common.data.integration.Entity
 import io.homeassistant.companion.android.common.data.integration.domain
 import io.homeassistant.companion.android.home.HomePresenterImpl
 import io.homeassistant.companion.android.theme.wearColorPalette
+import io.homeassistant.companion.android.util.WearToggleChip
 import io.homeassistant.companion.android.util.getIcon
 import io.homeassistant.companion.android.util.onEntityClickedFeedback
 import io.homeassistant.companion.android.util.previewEntity1
@@ -93,7 +94,8 @@ fun EntityUi(
                     else
                         stringResource(R.string.disabled)
                 )
-            }
+            },
+            colors = WearToggleChip.entityToggleChipBackgroundColors(entity, isChecked)
         )
     } else {
         Chip(
diff --git a/wear/src/main/java/io/homeassistant/companion/android/util/WearToggleChip.kt b/wear/src/main/java/io/homeassistant/companion/android/util/WearToggleChip.kt
new file mode 100644
index 00000000000..38da5c8be3c
--- /dev/null
+++ b/wear/src/main/java/io/homeassistant/companion/android/util/WearToggleChip.kt
@@ -0,0 +1,440 @@
+package io.homeassistant.companion.android.util
+
+import androidx.compose.runtime.Composable
+import androidx.compose.runtime.State
+import androidx.compose.runtime.rememberUpdatedState
+import androidx.compose.ui.geometry.Size
+import androidx.compose.ui.graphics.Brush
+import androidx.compose.ui.graphics.Color
+import androidx.compose.ui.graphics.ColorFilter
+import androidx.compose.ui.graphics.compositeOver
+import androidx.compose.ui.graphics.drawscope.DrawScope
+import androidx.compose.ui.graphics.painter.Painter
+import androidx.compose.ui.platform.LocalLayoutDirection
+import androidx.compose.ui.unit.LayoutDirection
+import androidx.wear.compose.material.ContentAlpha
+import androidx.wear.compose.material.MaterialTheme
+import androidx.wear.compose.material.ToggleChipColors
+import androidx.wear.compose.material.ToggleChipDefaults
+import androidx.wear.compose.material.contentColorFor
+import io.homeassistant.companion.android.common.data.integration.Entity
+import io.homeassistant.companion.android.common.data.integration.EntityPosition
+import io.homeassistant.companion.android.common.data.integration.domain
+import io.homeassistant.companion.android.common.data.integration.getCoverPosition
+import io.homeassistant.companion.android.common.data.integration.getFanSpeed
+import io.homeassistant.companion.android.common.data.integration.getLightBrightness
+import io.homeassistant.companion.android.common.data.integration.getLightColor
+
+object WearToggleChip {
+    /**
+     * A function that provides chip colors that mostly follow the default toggle chip colors, but when supported
+     * provide a background for active entities that reflects their state (position and color). Gradient code
+     * is based on [androidx.wear.compose.material.ToggleChipDefaults.toggleChipColors].
+     *
+     * @param entity The entity state on which the background for the active state should be based
+     */
+    @Composable
+    fun entityToggleChipBackgroundColors(entity: Entity<*>, checked: Boolean): ToggleChipColors {
+        // For a toggleable entity, a custom background should only be used if it has:
+        // a. a position (eg. fan speed, light brightness)
+        // b. a custom color (eg. light color)
+        // If there is a position (a) but no color (b), use the default (theme) color for the 'active' part.
+        // If there is a color (b) but no position (a), use a smooth gradient similar to ToggleChip.
+        // If it doesn't have either or is 'off', it should use the default chip background.
+
+        val hasPosition = when (entity.domain) {
+            "cover" -> entity.state != "closed" && entity.getCoverPosition() != null
+            "fan" -> checked && entity.getFanSpeed() != null
+            "light" -> checked && entity.getLightBrightness() != null
+            else -> false
+        }
+        val hasColor = entity.getLightColor() != null
+        val gradientDirection = LocalLayoutDirection.current
+
+        val contentBackgroundColor = if (hasColor) {
+            val entityColor = entity.getLightColor()
+            if (entityColor != null) Color(entityColor) else MaterialTheme.colors.primary
+        } else {
+            MaterialTheme.colors.primary
+        }
+
+        return when {
+            (hasPosition || hasColor) -> {
+                val checkedStartBackgroundColor = contentBackgroundColor.copy(alpha = 0.5f)
+                    .compositeOver(MaterialTheme.colors.surface)
+                val checkedEndBackgroundColor = MaterialTheme.colors.surface.copy(alpha = 0f)
+                    .compositeOver(MaterialTheme.colors.surface)
+                val uncheckedBackgroundColor = MaterialTheme.colors.surface
+
+                var checkedBackgroundColors = listOf(
+                    checkedStartBackgroundColor,
+                    checkedEndBackgroundColor
+                )
+                var disabledCheckedBackgroundColors = listOf(
+                    checkedStartBackgroundColor.copy(alpha = ContentAlpha.disabled),
+                    checkedEndBackgroundColor.copy(alpha = ContentAlpha.disabled)
+                )
+                val uncheckedBackgroundColors = listOf(
+                    uncheckedBackgroundColor,
+                    uncheckedBackgroundColor
+                )
+                val disabledUncheckedBackgroundColors = listOf(
+                    uncheckedBackgroundColor.copy(alpha = ContentAlpha.disabled),
+                    uncheckedBackgroundColor.copy(alpha = ContentAlpha.disabled)
+                )
+                if (gradientDirection != LayoutDirection.Ltr) {
+                    checkedBackgroundColors = checkedBackgroundColors.reversed()
+                    disabledCheckedBackgroundColors = disabledCheckedBackgroundColors.reversed()
+                    // No need to reverse unchecked
+                }
+
+                val checkedBackgroundPaint: Painter
+                val disabledCheckedBackgroundPaint: Painter
+                val uncheckedBackgroundPaint: Painter
+                val disabledUncheckedBackgroundPaint: Painter
+                if (hasPosition) {
+                    // Insert colors in the middle again to act as a 'hard stop'
+                    checkedBackgroundColors = checkedBackgroundColors.toMutableList().apply {
+                        addAll(1, checkedBackgroundColors)
+                    }
+                    disabledCheckedBackgroundColors = disabledCheckedBackgroundColors.toMutableList().apply {
+                        addAll(1, disabledCheckedBackgroundColors)
+                    }
+
+                    // Use position info to provide stop points
+                    // Minimum/maximum stops are not set to 0f/1f to make 1%/100% values visible
+                    val position = when (entity.domain) {
+                        "cover" -> entity.getCoverPosition()
+                        "fan" -> entity.getFanSpeed()
+                        "light" -> entity.getLightBrightness()
+                        else -> null
+                    } ?: EntityPosition(value = 1f, min = 0f, max = 2f) // This should never happen
+                    val positionValueRelative = if (gradientDirection == LayoutDirection.Ltr) {
+                        ((position.value - position.min) / (position.max - position.min))
+                    } else {
+                        1 - ((position.value - position.min) / (position.max - position.min))
+                    }
+                    val checkedColorStops = checkedBackgroundColors.mapIndexed { index, color ->
+                        when (index) {
+                            0 -> 0.025f to color
+                            1, 2 -> positionValueRelative to color
+                            else -> 0.975f to color // index: 3
+                        }
+                    }.toTypedArray()
+                    val disabledCheckedColorStops = disabledCheckedBackgroundColors.mapIndexed { index, color ->
+                        when (index) {
+                            0 -> 0.025f to color
+                            1, 2 -> positionValueRelative to color
+                            else -> 0.975f to color // index: 3
+                        }
+                    }.toTypedArray()
+
+                    // Painters that use the color stops
+                    // For unchecked with position, we can reuse the checked painter
+                    checkedBackgroundPaint = WearBrushPainter(
+                        Brush.horizontalGradient(*checkedColorStops)
+                    )
+                    disabledCheckedBackgroundPaint = WearBrushPainter(
+                        Brush.horizontalGradient(*disabledCheckedColorStops)
+                    )
+                    uncheckedBackgroundPaint = WearBrushPainter(
+                        Brush.horizontalGradient(*checkedColorStops)
+                    )
+                    disabledUncheckedBackgroundPaint = WearBrushPainter(
+                        Brush.horizontalGradient(*disabledCheckedColorStops)
+                    )
+                } else {
+                    // Color should be towards the end to match other enabled ToggleChips
+                    // No need to reverse unchecked because it is the same color
+                    checkedBackgroundColors = checkedBackgroundColors.reversed()
+                    disabledCheckedBackgroundColors = disabledCheckedBackgroundColors.reversed()
+
+                    // Painters that match ToggleChipDefaults
+                    checkedBackgroundPaint = WearBrushPainter(Brush.linearGradient(checkedBackgroundColors))
+                    disabledCheckedBackgroundPaint = WearBrushPainter(Brush.linearGradient(disabledCheckedBackgroundColors))
+                    uncheckedBackgroundPaint = WearBrushPainter(Brush.linearGradient(uncheckedBackgroundColors))
+                    disabledUncheckedBackgroundPaint = WearBrushPainter(Brush.linearGradient(disabledUncheckedBackgroundColors))
+                }
+
+                defaultChipColors().apply {
+                    checkedBackgroundPainter = checkedBackgroundPaint
+                    disabledCheckedBackgroundPainter = disabledCheckedBackgroundPaint
+                    uncheckedBackgroundPainter = uncheckedBackgroundPaint
+                    disabledUncheckedBackgroundPainter = disabledUncheckedBackgroundPaint
+                }
+            }
+            else -> ToggleChipDefaults.toggleChipColors()
+        }
+    }
+
+    /**
+     * A copy of [androidx.wear.compose.material.ToggleChipDefaults.toggleChipColors] that returns
+     * [WearToggleChipColors] which allows the app to set the Painter for advanced use cases instead
+     * of only providing a Color.
+     */
+    @Composable
+    private fun defaultChipColors(
+        checkedStartBackgroundColor: Color =
+            MaterialTheme.colors.surface.copy(alpha = 0f)
+                .compositeOver(MaterialTheme.colors.surface),
+        checkedEndBackgroundColor: Color =
+            MaterialTheme.colors.primary.copy(alpha = 0.5f)
+                .compositeOver(MaterialTheme.colors.surface),
+        checkedContentColor: Color = MaterialTheme.colors.onSurface,
+        checkedSecondaryContentColor: Color = MaterialTheme.colors.onSurfaceVariant,
+        checkedToggleControlColor: Color = MaterialTheme.colors.secondary,
+        uncheckedStartBackgroundColor: Color = MaterialTheme.colors.surface,
+        uncheckedEndBackgroundColor: Color = uncheckedStartBackgroundColor,
+        uncheckedContentColor: Color = contentColorFor(checkedEndBackgroundColor),
+        uncheckedSecondaryContentColor: Color = uncheckedContentColor,
+        uncheckedToggleControlColor: Color = uncheckedContentColor,
+        gradientDirection: LayoutDirection = LocalLayoutDirection.current
+    ): WearToggleChipColors {
+        val checkedBackgroundColors: List<Color>
+        val disabledCheckedBackgroundColors: List<Color>
+        if (gradientDirection == LayoutDirection.Ltr) {
+            checkedBackgroundColors = listOf(
+                checkedStartBackgroundColor,
+                checkedEndBackgroundColor
+            )
+            disabledCheckedBackgroundColors = listOf(
+                checkedStartBackgroundColor.copy(alpha = ContentAlpha.disabled),
+                checkedEndBackgroundColor.copy(alpha = ContentAlpha.disabled)
+            )
+        } else {
+            checkedBackgroundColors = listOf(
+                checkedEndBackgroundColor,
+                checkedStartBackgroundColor
+            )
+            disabledCheckedBackgroundColors = listOf(
+                checkedEndBackgroundColor.copy(alpha = ContentAlpha.disabled),
+                checkedStartBackgroundColor.copy(alpha = ContentAlpha.disabled),
+            )
+        }
+        val uncheckedBackgroundColors: List<Color>
+        val disabledUncheckedBackgroundColors: List<Color>
+        if (gradientDirection == LayoutDirection.Ltr) {
+            uncheckedBackgroundColors = listOf(
+                uncheckedStartBackgroundColor,
+                uncheckedEndBackgroundColor
+            )
+            disabledUncheckedBackgroundColors = listOf(
+                uncheckedStartBackgroundColor.copy(alpha = ContentAlpha.disabled),
+                uncheckedEndBackgroundColor.copy(alpha = ContentAlpha.disabled)
+            )
+        } else {
+            uncheckedBackgroundColors = listOf(
+                uncheckedEndBackgroundColor,
+                uncheckedStartBackgroundColor
+            )
+            disabledUncheckedBackgroundColors = listOf(
+                uncheckedEndBackgroundColor.copy(alpha = ContentAlpha.disabled),
+                uncheckedStartBackgroundColor.copy(alpha = ContentAlpha.disabled),
+            )
+        }
+
+        return WearToggleChipColors(
+            checkedBackgroundPainter = WearBrushPainter(Brush.linearGradient(checkedBackgroundColors)),
+            checkedContentColor = checkedContentColor,
+            checkedSecondaryContentColor = checkedSecondaryContentColor,
+            checkedIconColor = checkedToggleControlColor,
+            uncheckedBackgroundPainter = WearBrushPainter(
+                Brush.linearGradient(uncheckedBackgroundColors)
+            ),
+            uncheckedContentColor = uncheckedContentColor,
+            uncheckedSecondaryContentColor = uncheckedSecondaryContentColor,
+            uncheckedIconColor = uncheckedToggleControlColor,
+            disabledCheckedBackgroundPainter = WearBrushPainter(
+                Brush.linearGradient(disabledCheckedBackgroundColors)
+            ),
+            disabledCheckedContentColor = checkedContentColor.copy(alpha = ContentAlpha.disabled),
+            disabledCheckedSecondaryContentColor = checkedSecondaryContentColor.copy(
+                alpha = ContentAlpha.disabled
+            ),
+            disabledCheckedIconColor = checkedToggleControlColor.copy(
+                alpha = ContentAlpha.disabled
+            ),
+            disabledUncheckedBackgroundPainter = WearBrushPainter(
+                Brush.linearGradient(disabledUncheckedBackgroundColors)
+            ),
+            disabledUncheckedContentColor = uncheckedContentColor.copy(
+                alpha = ContentAlpha.disabled
+            ),
+            disabledUncheckedSecondaryContentColor = uncheckedSecondaryContentColor.copy(
+                alpha = ContentAlpha.disabled
+            ),
+            disabledUncheckedIconColor = uncheckedToggleControlColor.copy(
+                alpha = ContentAlpha.disabled
+            )
+        )
+    }
+}
+
+/**
+ * A copy of [androidx.wear.compose.material.DefaultToggleChipColors] with a public constructor and mutable
+ * properties to allow the app to set the Painter for advanced use cases instead of only providing a Color.
+ */
+class WearToggleChipColors(
+    var checkedBackgroundPainter: Painter,
+    var checkedContentColor: Color,
+    var checkedSecondaryContentColor: Color,
+    var checkedIconColor: Color,
+    var disabledCheckedBackgroundPainter: Painter,
+    var disabledCheckedContentColor: Color,
+    var disabledCheckedSecondaryContentColor: Color,
+    var disabledCheckedIconColor: Color,
+    var uncheckedBackgroundPainter: Painter,
+    var uncheckedContentColor: Color,
+    var uncheckedSecondaryContentColor: Color,
+    var uncheckedIconColor: Color,
+    var disabledUncheckedBackgroundPainter: Painter,
+    var disabledUncheckedContentColor: Color,
+    var disabledUncheckedSecondaryContentColor: Color,
+    var disabledUncheckedIconColor: Color,
+) : ToggleChipColors {
+
+    @Composable
+    override fun background(enabled: Boolean, checked: Boolean): State<Painter> {
+        return rememberUpdatedState(
+            if (enabled) {
+                if (checked) checkedBackgroundPainter else uncheckedBackgroundPainter
+            } else {
+                if (checked) disabledCheckedBackgroundPainter else
+                    disabledUncheckedBackgroundPainter
+            }
+        )
+    }
+
+    @Composable
+    override fun contentColor(enabled: Boolean, checked: Boolean): State<Color> {
+        return rememberUpdatedState(
+            if (enabled) {
+                if (checked) checkedContentColor else uncheckedContentColor
+            } else {
+                if (checked) disabledCheckedContentColor else disabledUncheckedContentColor
+            }
+        )
+    }
+
+    @Composable
+    override fun secondaryContentColor(enabled: Boolean, checked: Boolean): State<Color> {
+        return rememberUpdatedState(
+            if (enabled) {
+                if (checked) checkedSecondaryContentColor else uncheckedSecondaryContentColor
+            } else {
+                if (checked) disabledCheckedSecondaryContentColor else
+                    disabledUncheckedSecondaryContentColor
+            }
+        )
+    }
+
+    @Composable
+    override fun toggleControlColor(enabled: Boolean, checked: Boolean): State<Color> {
+        return rememberUpdatedState(
+            if (enabled) {
+                if (checked) checkedIconColor else uncheckedIconColor
+            } else {
+                if (checked) disabledCheckedIconColor else disabledUncheckedIconColor
+            }
+        )
+    }
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other == null) return false
+        if (this::class != other::class) return false
+
+        other as WearToggleChipColors
+
+        if (checkedBackgroundPainter != other.checkedBackgroundPainter) return false
+        if (checkedContentColor != other.checkedContentColor) return false
+        if (checkedIconColor != other.checkedIconColor) return false
+        if (checkedSecondaryContentColor != other.checkedSecondaryContentColor) return false
+        if (uncheckedBackgroundPainter != other.uncheckedBackgroundPainter) return false
+        if (uncheckedContentColor != other.uncheckedContentColor) return false
+        if (uncheckedIconColor != other.uncheckedIconColor) return false
+        if (uncheckedSecondaryContentColor != other.uncheckedSecondaryContentColor) return false
+        if (disabledCheckedBackgroundPainter != other.disabledCheckedBackgroundPainter) return false
+        if (disabledCheckedContentColor != other.disabledCheckedContentColor) return false
+        if (disabledCheckedIconColor != other.disabledCheckedIconColor) return false
+        if (disabledCheckedSecondaryContentColor !=
+            other.disabledCheckedSecondaryContentColor
+        ) return false
+        if (disabledUncheckedBackgroundPainter !=
+            other.disabledUncheckedBackgroundPainter
+        ) return false
+        if (disabledUncheckedContentColor != other.disabledUncheckedContentColor) return false
+        if (disabledUncheckedIconColor != other.disabledUncheckedIconColor) return false
+        if (disabledUncheckedSecondaryContentColor !=
+            other.disabledUncheckedSecondaryContentColor
+        ) return false
+
+        return true
+    }
+
+    override fun hashCode(): Int {
+        var result = checkedBackgroundPainter.hashCode()
+        result = 31 * result + checkedContentColor.hashCode()
+        result = 31 * result + checkedSecondaryContentColor.hashCode()
+        result = 31 * result + checkedIconColor.hashCode()
+        result = 31 * result + uncheckedBackgroundPainter.hashCode()
+        result = 31 * result + uncheckedContentColor.hashCode()
+        result = 31 * result + uncheckedSecondaryContentColor.hashCode()
+        result = 31 * result + uncheckedIconColor.hashCode()
+        result = 31 * result + disabledCheckedBackgroundPainter.hashCode()
+        result = 31 * result + disabledCheckedContentColor.hashCode()
+        result = 31 * result + disabledCheckedSecondaryContentColor.hashCode()
+        result = 31 * result + disabledCheckedIconColor.hashCode()
+        result = 31 * result + disabledUncheckedBackgroundPainter.hashCode()
+        result = 31 * result + disabledUncheckedContentColor.hashCode()
+        result = 31 * result + disabledUncheckedSecondaryContentColor.hashCode()
+        result = 31 * result + disabledUncheckedIconColor.hashCode()
+        return result
+    }
+}
+
+/**
+ * A copy of [androidx.wear.compose.material.BrushPainter] because that class is marked as internal,
+ * but contains an important override of the `intrinsicSize` property to Size.Unspecified which allows
+ * it to work when using a horizontal gradient as the Chip background.
+ * [androidx.compose.ui.graphics.painter.BrushPainter] only works for gradients that do not specify
+ * offsets, so only linear gradients from top left to bottom right (= diagonal).
+ */
+class WearBrushPainter(val brush: Brush) : Painter() {
+    private var alpha: Float = 1.0f
+
+    private var colorFilter: ColorFilter? = null
+
+    override fun DrawScope.onDraw() {
+        drawRect(brush = brush, alpha = alpha, colorFilter = colorFilter)
+    }
+
+    override fun applyAlpha(alpha: Float): Boolean {
+        this.alpha = alpha
+        return true
+    }
+
+    override fun applyColorFilter(colorFilter: ColorFilter?): Boolean {
+        this.colorFilter = colorFilter
+        return true
+    }
+
+    override fun equals(other: Any?): Boolean {
+        if (this === other) return true
+        if (other !is WearBrushPainter) return false
+
+        if (brush != other.brush) return false
+
+        return true
+    }
+
+    override fun hashCode(): Int {
+        return brush.hashCode()
+    }
+
+    override fun toString(): String {
+        return "ColorPainter(brush=$brush)"
+    }
+
+    override val intrinsicSize: Size = Size.Unspecified
+}
