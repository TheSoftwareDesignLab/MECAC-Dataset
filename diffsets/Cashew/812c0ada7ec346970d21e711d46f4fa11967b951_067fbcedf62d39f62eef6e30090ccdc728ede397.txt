diff --git a/budget/lib/database/tables.dart b/budget/lib/database/tables.dart
index 7ff9c1bdf..c1c3fed1b 100644
--- a/budget/lib/database/tables.dart
+++ b/budget/lib/database/tables.dart
@@ -15,7 +15,7 @@ export 'platform/shared.dart';
 import 'dart:convert';
 part 'tables.g.dart';
 
-int schemaVersionGlobal = 33;
+int schemaVersionGlobal = 34;
 
 // Generate database code
 // flutter packages pub run build_runner build --delete-conflicting-outputs
@@ -163,6 +163,7 @@ class Wallets extends Table {
       dateTime().withDefault(Constant(DateTime.now())).nullable()();
   IntColumn get order => integer()();
   TextColumn get currency => text().nullable()();
+  IntColumn get decimals => integer().withDefault(Constant(2))();
 }
 
 @DataClassName('Transaction')
@@ -537,6 +538,9 @@ class FinanceDatabase extends _$FinanceDatabase {
             await migrator.alterTable(TableMigration(transactions));
             await migrator.deleteTable("Labels");
           }
+          if (from <= 33) {
+            await migrator.addColumn(wallets, wallets.decimals);
+          }
         },
       );
 
@@ -1007,49 +1011,46 @@ class FinanceDatabase extends _$FinanceDatabase {
     List<Budget> budgetsList = await (select(budgets)
           ..orderBy([(b) => OrderingTerm.asc(b.order)]))
         .get();
-    if (newPosition > oldPosition) {
-      for (Budget budget in budgetsList) {
-        await (update(budgets)
-              ..where(
-                (b) =>
-                    b.budgetPk.equals(budget.budgetPk) &
-                    b.order.isBiggerOrEqualValue(oldPosition) &
-                    b.order.isSmallerOrEqualValue(newPosition),
-              ))
-            .write(
-          BudgetsCompanion(
-            order: Value(budget.order - 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
-      }
-    } else {
-      for (Budget budget in budgetsList) {
-        await (update(budgets)
-              ..where(
-                (b) =>
-                    b.budgetPk.equals(budget.budgetPk) &
-                    b.order.isBiggerOrEqualValue(newPosition) &
-                    b.order.isSmallerOrEqualValue(oldPosition),
-              ))
-            .write(
-          BudgetsCompanion(
-            order: Value(budget.order + 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
+
+    await batch((batch) {
+      if (newPosition > oldPosition) {
+        for (Budget budget in budgetsList) {
+          batch.update(
+            budgets,
+            BudgetsCompanion(
+              order: Value(budget.order - 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (b) =>
+                b.budgetPk.equals(budget.budgetPk) &
+                b.order.isBiggerOrEqualValue(oldPosition) &
+                b.order.isSmallerOrEqualValue(newPosition),
+          );
+        }
+      } else {
+        for (Budget budget in budgetsList) {
+          batch.update(
+            budgets,
+            BudgetsCompanion(
+              order: Value(budget.order + 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (b) =>
+                b.budgetPk.equals(budget.budgetPk) &
+                b.order.isBiggerOrEqualValue(newPosition) &
+                b.order.isSmallerOrEqualValue(oldPosition),
+          );
+        }
       }
-    }
-    await (update(budgets)
-          ..where(
-            (b) => b.budgetPk.equals(budgetPk),
-          ))
-        .write(
-      BudgetsCompanion(
-        order: Value(newPosition),
-        dateTimeModified: Value(DateTime.now()),
-      ),
-    );
+      batch.update(
+        budgets,
+        BudgetsCompanion(
+          order: Value(newPosition),
+          dateTimeModified: Value(DateTime.now()),
+        ),
+        where: (b) => b.budgetPk.equals(budgetPk),
+      );
+    });
   }
 
   Future<bool> shiftBudgets(int direction, int pastIndexIncluding) async {
@@ -1179,49 +1180,45 @@ class FinanceDatabase extends _$FinanceDatabase {
     List<TransactionWallet> walletsList = await (select(wallets)
           ..orderBy([(w) => OrderingTerm.asc(w.order)]))
         .get();
-    if (newPosition > oldPosition) {
-      for (TransactionWallet wallet in walletsList) {
-        await (update(wallets)
-              ..where(
-                (w) =>
-                    w.walletPk.equals(wallet.walletPk) &
-                    w.order.isBiggerOrEqualValue(oldPosition) &
-                    w.order.isSmallerOrEqualValue(newPosition),
-              ))
-            .write(
-          WalletsCompanion(
-            order: Value(wallet.order - 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
-      }
-    } else {
-      for (TransactionWallet wallet in walletsList) {
-        await (update(wallets)
-              ..where(
-                (w) =>
-                    w.walletPk.equals(wallet.walletPk) &
-                    w.order.isBiggerOrEqualValue(newPosition) &
-                    w.order.isSmallerOrEqualValue(oldPosition),
-              ))
-            .write(
-          WalletsCompanion(
-            order: Value(wallet.order + 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
+    await batch((batch) {
+      if (newPosition > oldPosition) {
+        for (TransactionWallet wallet in walletsList) {
+          batch.update(
+            wallets,
+            WalletsCompanion(
+              order: Value(wallet.order - 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (w) =>
+                w.walletPk.equals(wallet.walletPk) &
+                w.order.isBiggerOrEqualValue(oldPosition) &
+                w.order.isSmallerOrEqualValue(newPosition),
+          );
+        }
+      } else {
+        for (TransactionWallet wallet in walletsList) {
+          batch.update(
+            wallets,
+            WalletsCompanion(
+              order: Value(wallet.order + 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (w) =>
+                w.walletPk.equals(wallet.walletPk) &
+                w.order.isBiggerOrEqualValue(newPosition) &
+                w.order.isSmallerOrEqualValue(oldPosition),
+          );
+        }
       }
-    }
-    await (update(wallets)
-          ..where(
-            (w) => w.walletPk.equals(walletPk),
-          ))
-        .write(
-      WalletsCompanion(
-        order: Value(newPosition),
-        dateTimeModified: Value(DateTime.now()),
-      ),
-    );
+      batch.update(
+        wallets,
+        WalletsCompanion(
+          order: Value(newPosition),
+          dateTimeModified: Value(DateTime.now()),
+        ),
+        where: (w) => w.walletPk.equals(walletPk),
+      );
+    });
   }
 
   Future<bool> shiftWallets(int direction, int pastIndexIncluding) async {
@@ -1413,6 +1410,12 @@ class FinanceDatabase extends _$FinanceDatabase {
         .watchSingle();
   }
 
+  Stream<TransactionCategory> watchCategory(int categoryPk,
+      {int? limit, int? offset}) {
+    return (select(categories)..where((t) => t.categoryPk.equals(categoryPk)))
+        .watchSingle();
+  }
+
   Future<CategoryBudgetLimit> getCategoryBudgetLimitInstance(
       int categoryLimitPk,
       {int? limit,
@@ -1457,51 +1460,47 @@ class FinanceDatabase extends _$FinanceDatabase {
         await (select(associatedTitles)
               ..orderBy([(t) => OrderingTerm.asc(t.order)]))
             .get();
-    if (newPosition > oldPosition) {
-      for (TransactionAssociatedTitle associatedTitle in associatedTitlesList) {
-        await (update(associatedTitles)
-              ..where(
-                (t) =>
-                    t.associatedTitlePk
-                        .equals(associatedTitle.associatedTitlePk) &
-                    t.order.isBiggerOrEqualValue(oldPosition) &
-                    t.order.isSmallerOrEqualValue(newPosition),
-              ))
-            .write(
-          AssociatedTitlesCompanion(
-            order: Value(associatedTitle.order - 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
-      }
-    } else {
-      for (TransactionAssociatedTitle associatedTitle in associatedTitlesList) {
-        await (update(associatedTitles)
-              ..where(
-                (t) =>
-                    t.associatedTitlePk
-                        .equals(associatedTitle.associatedTitlePk) &
-                    t.order.isBiggerOrEqualValue(newPosition) &
-                    t.order.isSmallerOrEqualValue(oldPosition),
-              ))
-            .write(
-          AssociatedTitlesCompanion(
-            order: Value(associatedTitle.order + 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
+    await batch((batch) {
+      if (newPosition > oldPosition) {
+        for (TransactionAssociatedTitle associatedTitle
+            in associatedTitlesList) {
+          batch.update(
+            associatedTitles,
+            AssociatedTitlesCompanion(
+              order: Value(associatedTitle.order - 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (t) =>
+                t.associatedTitlePk.equals(associatedTitle.associatedTitlePk) &
+                t.order.isBiggerOrEqualValue(oldPosition) &
+                t.order.isSmallerOrEqualValue(newPosition),
+          );
+        }
+      } else {
+        for (TransactionAssociatedTitle associatedTitle
+            in associatedTitlesList) {
+          batch.update(
+            associatedTitles,
+            AssociatedTitlesCompanion(
+              order: Value(associatedTitle.order + 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (t) =>
+                t.associatedTitlePk.equals(associatedTitle.associatedTitlePk) &
+                t.order.isBiggerOrEqualValue(newPosition) &
+                t.order.isSmallerOrEqualValue(oldPosition),
+          );
+        }
       }
-    }
-    await (update(associatedTitles)
-          ..where(
-            (t) => t.associatedTitlePk.equals(associatedTitlePk),
-          ))
-        .write(
-      AssociatedTitlesCompanion(
-        order: Value(newPosition),
-        dateTimeModified: Value(DateTime.now()),
-      ),
-    );
+      batch.update(
+        associatedTitles,
+        AssociatedTitlesCompanion(
+          order: Value(newPosition),
+          dateTimeModified: Value(DateTime.now()),
+        ),
+        where: (t) => t.associatedTitlePk.equals(associatedTitlePk),
+      );
+    });
   }
 
   Future<bool> fixOrderBudgets() async {
@@ -2220,6 +2219,15 @@ class FinanceDatabase extends _$FinanceDatabase {
         .watch();
   }
 
+  Stream<Map<int, TransactionCategory>> watchAllCategoriesMapped(
+      {int? limit, int? offset}) {
+    return (select(categories)
+          ..limit(limit ?? DEFAULT_LIMIT, offset: offset ?? DEFAULT_OFFSET))
+        .watch()
+        .map((categoryList) =>
+            {for (var category in categoryList) category.categoryPk: category});
+  }
+
   Future<List<TransactionCategory>> getAllCategories(
       {int? limit, int? offset, List<int>? categoryFks, bool? allCategories}) {
     return (select(categories)
@@ -2231,6 +2239,16 @@ class FinanceDatabase extends _$FinanceDatabase {
         .get();
   }
 
+  Future<List<int>> getAllCategoryPks(
+      {int? limit, int? offset, List<int>? categoryFks, bool? allCategories}) {
+    return (select(categories)
+          ..orderBy([(c) => OrderingTerm.asc(c.order)])
+          ..limit(limit ?? DEFAULT_LIMIT, offset: offset ?? DEFAULT_OFFSET))
+        .get()
+        .then(
+            (result) => result.map((category) => category.categoryPk).toList());
+  }
+
   Future<List<Budget>> getAllBudgets({bool? sharedBudgetsOnly}) {
     return (select(budgets)
           ..where((b) => ((sharedBudgetsOnly == null
@@ -2272,49 +2290,45 @@ class FinanceDatabase extends _$FinanceDatabase {
     List<TransactionCategory> categoriesList = await (select(categories)
           ..orderBy([(c) => OrderingTerm.asc(c.order)]))
         .get();
-    if (newPosition > oldPosition) {
-      for (TransactionCategory category in categoriesList) {
-        await (update(categories)
-              ..where(
-                (c) =>
-                    c.categoryPk.equals(category.categoryPk) &
-                    c.order.isBiggerOrEqualValue(oldPosition) &
-                    c.order.isSmallerOrEqualValue(newPosition),
-              ))
-            .write(
-          CategoriesCompanion(
-            order: Value(category.order - 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
-      }
-    } else {
-      for (TransactionCategory category in categoriesList) {
-        await (update(categories)
-              ..where(
-                (c) =>
-                    c.categoryPk.equals(category.categoryPk) &
-                    c.order.isBiggerOrEqualValue(newPosition) &
-                    c.order.isSmallerOrEqualValue(oldPosition),
-              ))
-            .write(
-          CategoriesCompanion(
-            order: Value(category.order + 1),
-            dateTimeModified: Value(DateTime.now()),
-          ),
-        );
+    await batch((batch) {
+      if (newPosition > oldPosition) {
+        for (TransactionCategory category in categoriesList) {
+          batch.update(
+            categories,
+            CategoriesCompanion(
+              order: Value(category.order - 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (c) =>
+                c.categoryPk.equals(category.categoryPk) &
+                c.order.isBiggerOrEqualValue(oldPosition) &
+                c.order.isSmallerOrEqualValue(newPosition),
+          );
+        }
+      } else {
+        for (TransactionCategory category in categoriesList) {
+          batch.update(
+            categories,
+            CategoriesCompanion(
+              order: Value(category.order + 1),
+              dateTimeModified: Value(DateTime.now()),
+            ),
+            where: (c) =>
+                c.categoryPk.equals(category.categoryPk) &
+                c.order.isBiggerOrEqualValue(newPosition) &
+                c.order.isSmallerOrEqualValue(oldPosition),
+          );
+        }
       }
-    }
-    await (update(categories)
-          ..where(
-            (c) => c.categoryPk.equals(categoryPk),
-          ))
-        .write(
-      CategoriesCompanion(
-        order: Value(newPosition),
-        dateTimeModified: Value(DateTime.now()),
-      ),
-    );
+      batch.update(
+        categories,
+        CategoriesCompanion(
+          order: Value(newPosition),
+          dateTimeModified: Value(DateTime.now()),
+        ),
+        where: (c) => c.categoryPk.equals(categoryPk),
+      );
+    });
   }
 
   Future<bool> shiftCategories(int direction, int pastIndexIncluding) async {
diff --git a/budget/lib/database/tables.g.dart b/budget/lib/database/tables.g.dart
index 309ac5227..94bfa5dbe 100644
--- a/budget/lib/database/tables.g.dart
+++ b/budget/lib/database/tables.g.dart
@@ -66,6 +66,14 @@ class $WalletsTable extends Wallets
   late final GeneratedColumn<String> currency = GeneratedColumn<String>(
       'currency', aliasedName, true,
       type: DriftSqlType.string, requiredDuringInsert: false);
+  static const VerificationMeta _decimalsMeta =
+      const VerificationMeta('decimals');
+  @override
+  late final GeneratedColumn<int> decimals = GeneratedColumn<int>(
+      'decimals', aliasedName, false,
+      type: DriftSqlType.int,
+      requiredDuringInsert: false,
+      defaultValue: Constant(2));
   @override
   List<GeneratedColumn> get $columns => [
         walletPk,
@@ -75,7 +83,8 @@ class $WalletsTable extends Wallets
         dateCreated,
         dateTimeModified,
         order,
-        currency
+        currency,
+        decimals
       ];
   @override
   String get aliasedName => _alias ?? 'wallets';
@@ -126,6 +135,10 @@ class $WalletsTable extends Wallets
       context.handle(_currencyMeta,
           currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta));
     }
+    if (data.containsKey('decimals')) {
+      context.handle(_decimalsMeta,
+          decimals.isAcceptableOrUnknown(data['decimals']!, _decimalsMeta));
+    }
     return context;
   }
 
@@ -151,6 +164,8 @@ class $WalletsTable extends Wallets
           .read(DriftSqlType.int, data['${effectivePrefix}order'])!,
       currency: attachedDatabase.typeMapping
           .read(DriftSqlType.string, data['${effectivePrefix}currency']),
+      decimals: attachedDatabase.typeMapping
+          .read(DriftSqlType.int, data['${effectivePrefix}decimals'])!,
     );
   }
 
@@ -170,6 +185,7 @@ class TransactionWallet extends DataClass
   final DateTime? dateTimeModified;
   final int order;
   final String? currency;
+  final int decimals;
   const TransactionWallet(
       {required this.walletPk,
       required this.name,
@@ -178,7 +194,8 @@ class TransactionWallet extends DataClass
       required this.dateCreated,
       this.dateTimeModified,
       required this.order,
-      this.currency});
+      this.currency,
+      required this.decimals});
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
@@ -198,6 +215,7 @@ class TransactionWallet extends DataClass
     if (!nullToAbsent || currency != null) {
       map['currency'] = Variable<String>(currency);
     }
+    map['decimals'] = Variable<int>(decimals);
     return map;
   }
 
@@ -218,6 +236,7 @@ class TransactionWallet extends DataClass
       currency: currency == null && nullToAbsent
           ? const Value.absent()
           : Value(currency),
+      decimals: Value(decimals),
     );
   }
 
@@ -234,6 +253,7 @@ class TransactionWallet extends DataClass
           serializer.fromJson<DateTime?>(json['dateTimeModified']),
       order: serializer.fromJson<int>(json['order']),
       currency: serializer.fromJson<String?>(json['currency']),
+      decimals: serializer.fromJson<int>(json['decimals']),
     );
   }
   @override
@@ -248,6 +268,7 @@ class TransactionWallet extends DataClass
       'dateTimeModified': serializer.toJson<DateTime?>(dateTimeModified),
       'order': serializer.toJson<int>(order),
       'currency': serializer.toJson<String?>(currency),
+      'decimals': serializer.toJson<int>(decimals),
     };
   }
 
@@ -259,7 +280,8 @@ class TransactionWallet extends DataClass
           DateTime? dateCreated,
           Value<DateTime?> dateTimeModified = const Value.absent(),
           int? order,
-          Value<String?> currency = const Value.absent()}) =>
+          Value<String?> currency = const Value.absent(),
+          int? decimals}) =>
       TransactionWallet(
         walletPk: walletPk ?? this.walletPk,
         name: name ?? this.name,
@@ -271,6 +293,7 @@ class TransactionWallet extends DataClass
             : this.dateTimeModified,
         order: order ?? this.order,
         currency: currency.present ? currency.value : this.currency,
+        decimals: decimals ?? this.decimals,
       );
   @override
   String toString() {
@@ -282,14 +305,15 @@ class TransactionWallet extends DataClass
           ..write('dateCreated: $dateCreated, ')
           ..write('dateTimeModified: $dateTimeModified, ')
           ..write('order: $order, ')
-          ..write('currency: $currency')
+          ..write('currency: $currency, ')
+          ..write('decimals: $decimals')
           ..write(')'))
         .toString();
   }
 
   @override
   int get hashCode => Object.hash(walletPk, name, colour, iconName, dateCreated,
-      dateTimeModified, order, currency);
+      dateTimeModified, order, currency, decimals);
   @override
   bool operator ==(Object other) =>
       identical(this, other) ||
@@ -301,7 +325,8 @@ class TransactionWallet extends DataClass
           other.dateCreated == this.dateCreated &&
           other.dateTimeModified == this.dateTimeModified &&
           other.order == this.order &&
-          other.currency == this.currency);
+          other.currency == this.currency &&
+          other.decimals == this.decimals);
 }
 
 class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
@@ -313,6 +338,7 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
   final Value<DateTime?> dateTimeModified;
   final Value<int> order;
   final Value<String?> currency;
+  final Value<int> decimals;
   const WalletsCompanion({
     this.walletPk = const Value.absent(),
     this.name = const Value.absent(),
@@ -322,6 +348,7 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
     this.dateTimeModified = const Value.absent(),
     this.order = const Value.absent(),
     this.currency = const Value.absent(),
+    this.decimals = const Value.absent(),
   });
   WalletsCompanion.insert({
     this.walletPk = const Value.absent(),
@@ -332,6 +359,7 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
     this.dateTimeModified = const Value.absent(),
     required int order,
     this.currency = const Value.absent(),
+    this.decimals = const Value.absent(),
   })  : name = Value(name),
         order = Value(order);
   static Insertable<TransactionWallet> custom({
@@ -343,6 +371,7 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
     Expression<DateTime>? dateTimeModified,
     Expression<int>? order,
     Expression<String>? currency,
+    Expression<int>? decimals,
   }) {
     return RawValuesInsertable({
       if (walletPk != null) 'wallet_pk': walletPk,
@@ -353,6 +382,7 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
       if (dateTimeModified != null) 'date_time_modified': dateTimeModified,
       if (order != null) 'order': order,
       if (currency != null) 'currency': currency,
+      if (decimals != null) 'decimals': decimals,
     });
   }
 
@@ -364,7 +394,8 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
       Value<DateTime>? dateCreated,
       Value<DateTime?>? dateTimeModified,
       Value<int>? order,
-      Value<String?>? currency}) {
+      Value<String?>? currency,
+      Value<int>? decimals}) {
     return WalletsCompanion(
       walletPk: walletPk ?? this.walletPk,
       name: name ?? this.name,
@@ -374,6 +405,7 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
       dateTimeModified: dateTimeModified ?? this.dateTimeModified,
       order: order ?? this.order,
       currency: currency ?? this.currency,
+      decimals: decimals ?? this.decimals,
     );
   }
 
@@ -404,6 +436,9 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
     if (currency.present) {
       map['currency'] = Variable<String>(currency.value);
     }
+    if (decimals.present) {
+      map['decimals'] = Variable<int>(decimals.value);
+    }
     return map;
   }
 
@@ -417,7 +452,8 @@ class WalletsCompanion extends UpdateCompanion<TransactionWallet> {
           ..write('dateCreated: $dateCreated, ')
           ..write('dateTimeModified: $dateTimeModified, ')
           ..write('order: $order, ')
-          ..write('currency: $currency')
+          ..write('currency: $currency, ')
+          ..write('decimals: $decimals')
           ..write(')'))
         .toString();
   }
diff --git a/budget/lib/functions.dart b/budget/lib/functions.dart
index 69773d381..b73289a7d 100644
--- a/budget/lib/functions.dart
+++ b/budget/lib/functions.dart
@@ -32,46 +32,54 @@ extension CapExtension on String {
       .join(" ");
 }
 
-String convertToMoney(double amount,
-    {String? currencyKey, bool showCurrency = true, double? finalNumber}) {
-  {
-    if (amount == -0.0) {
-      amount = amount.abs();
-    }
-    if (amount == double.infinity) {
-      return "Infinity";
-    }
-    final currency = new NumberFormat("#,##0.00", "en_US");
-    String formatOutput = currency.format(amount);
-    if (finalNumber != null &&
-        !finalNumber.abs().toStringAsFixed(5).split(".")[1].startsWith("00")) {
-      return (showCurrency ? getCurrencyString(currencyKey: currencyKey) : '') +
-          currency.format(amount);
-    }
-    if ((finalNumber != null &&
-            finalNumber
-                .abs()
-                .toStringAsFixed(5)
-                .split(".")[1]
-                .startsWith("00")) ||
-        formatOutput.substring(formatOutput.length - 2) == "00") {
-      // Do not show the zeroes
-      return (showCurrency ? getCurrencyString(currencyKey: currencyKey) : '') +
-          formatOutput.replaceRange(
-              formatOutput.length - 3, formatOutput.length, '');
-    }
-    return (showCurrency ? getCurrencyString(currencyKey: currencyKey) : '') +
-        currency.format(amount);
-  }
-}
-
-int moneyDecimals(double amount) {
-  final currency = new NumberFormat("#,##0.00", "en_US");
+String convertToMoney(
+  double amount, {
+  String? currencyKey,
+  bool showCurrency = true,
+  double? finalNumber,
+  int? decimals,
+}) {
+  int numberDecimals = decimals ?? appStateSettings["selectedWalletDecimals"];
+  numberDecimals = numberDecimals > 2 && amount.toString().split('.').length > 1
+      ? amount.toString().split('.')[1].length < numberDecimals
+          ? amount.toString().split('.')[1].length
+          : numberDecimals
+      : numberDecimals;
+
+  if (amount == -0.0) {
+    amount = amount.abs();
+  }
+  if (amount == double.infinity) {
+    return "Infinity";
+  }
+  NumberFormat currency = new NumberFormat.currency(
+    decimalDigits: numberDecimals,
+    locale: Platform.localeName,
+    symbol: (showCurrency ? getCurrencyString(currencyKey: currencyKey) : ''),
+  );
   String formatOutput = currency.format(amount);
-  if (formatOutput.substring(formatOutput.length - 2) == "00") {
-    return 0;
-  }
-  return 2;
+
+  if (finalNumber != null &&
+      !finalNumber
+          .abs()
+          .toStringAsFixed(numberDecimals)
+          .split(".")[1]
+          .startsWith("0" * numberDecimals)) {
+    return currency.format(amount);
+  }
+  if ((finalNumber != null &&
+          finalNumber
+              .abs()
+              .toStringAsFixed(numberDecimals)
+              .split(".")[1]
+              .startsWith("0" * numberDecimals)) ||
+      formatOutput.substring(formatOutput.length - numberDecimals) ==
+          "0" * numberDecimals) {
+    // Do not show the zeroes
+    return formatOutput.replaceRange(
+        formatOutput.length - numberDecimals - 1, formatOutput.length, '');
+  }
+  return currency.format(amount);
 }
 
 // assume selected wallets currency
diff --git a/budget/lib/main.dart b/budget/lib/main.dart
index 44381b812..0553810a8 100644
--- a/budget/lib/main.dart
+++ b/budget/lib/main.dart
@@ -264,6 +264,7 @@ Future<bool> initializeDatabase() async {
         order: 0,
         currency: "usd",
         dateTimeModified: null,
+        decimals: 2,
       ),
       customDateTimeModified: DateTime(0),
     );
diff --git a/budget/lib/pages/aboutPage.dart b/budget/lib/pages/aboutPage.dart
index 90051d53c..fd6f12f3c 100644
--- a/budget/lib/pages/aboutPage.dart
+++ b/budget/lib/pages/aboutPage.dart
@@ -239,7 +239,9 @@ class AboutPage extends StatelessWidget {
                       ", db-v" +
                       schemaVersionGlobal.toString(),
                   applicationLegalese:
-                      "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.");
+                      "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE." +
+                          "\n\n" +
+                          "Please note that the exchange rates provided within this app are for informational purposes only and should not be used as a basis for making investment decisions. While we strive to provide accurate and up-to-date information, we cannot guarantee the accuracy or completeness of the rates displayed within the app. Additionally, these rates are provided as estimates and may not reflect the exact exchange rates that you would receive in a real-world transaction. We strongly recommend that you consult with a financial advisor or do your own research before making any investment decisions. By using this app, you acknowledge that you understand and accept these limitations and that you assume full responsibility for any decisions made based on the information provided within the app.");
             },
           ),
         ),
diff --git a/budget/lib/pages/addTransactionPage.dart b/budget/lib/pages/addTransactionPage.dart
index eb218ca4e..1841234d3 100644
--- a/budget/lib/pages/addTransactionPage.dart
+++ b/budget/lib/pages/addTransactionPage.dart
@@ -926,15 +926,19 @@ class _AddTransactionPageState extends State<AddTransactionPage>
                                     count: selectedAmount ?? 0,
                                     duration: Duration(milliseconds: 1000),
                                     dynamicDecimals: true,
+                                    decimals: selectedWallet?.decimals,
                                     initialCount: selectedAmount ?? 0,
                                     textBuilder: (number) {
                                       return Align(
                                         alignment: Alignment.centerRight,
                                         child: TextFont(
                                           textAlign: TextAlign.right,
-                                          text: convertToMoney(number,
-                                              showCurrency: false,
-                                              finalNumber: selectedAmount ?? 0),
+                                          text: convertToMoney(
+                                            number,
+                                            showCurrency: false,
+                                            finalNumber: selectedAmount ?? 0,
+                                            decimals: selectedWallet?.decimals,
+                                          ),
                                           walletPkForCurrency: selectedWalletPk,
                                           onlyShowCurrencyIcon: appStateSettings[
                                                       "cachedWalletCurrencies"]
@@ -944,6 +948,7 @@ class _AddTransactionPageState extends State<AddTransactionPage>
                                           fontSize: 32,
                                           fontWeight: FontWeight.bold,
                                           maxLines: 1,
+                                          autoSizeText: true,
                                         ),
                                       );
                                     },
diff --git a/budget/lib/pages/addWalletPage.dart b/budget/lib/pages/addWalletPage.dart
index 75c042975..e89fdb39f 100644
--- a/budget/lib/pages/addWalletPage.dart
+++ b/budget/lib/pages/addWalletPage.dart
@@ -1,13 +1,17 @@
 import 'package:budget/database/tables.dart';
 import 'package:budget/main.dart';
+import 'package:budget/pages/addBudgetPage.dart';
 import 'package:budget/pages/addTransactionPage.dart';
 import 'package:budget/pages/editWalletsPage.dart';
 import 'package:budget/struct/databaseGlobal.dart';
+import 'package:budget/widgets/button.dart';
+import 'package:budget/widgets/noResults.dart';
 import 'package:budget/widgets/openBottomSheet.dart';
 import 'package:budget/widgets/openPopup.dart';
 import 'package:budget/widgets/pageFramework.dart';
 import 'package:budget/widgets/popupFramework.dart';
 import 'package:budget/widgets/saveBottomButton.dart';
+import 'package:budget/widgets/selectAmount.dart';
 import 'package:budget/widgets/selectColor.dart';
 import 'package:budget/widgets/tappable.dart';
 import 'package:budget/widgets/textInput.dart';
@@ -32,6 +36,8 @@ class AddWalletPage extends StatefulWidget {
 }
 
 class _AddWalletPageState extends State<AddWalletPage> {
+  GlobalKey<PageFrameworkState> addWalletPageKey = GlobalKey();
+
   bool? canAddWallet;
 
   String? selectedTitle;
@@ -41,6 +47,7 @@ class _AddWalletPageState extends State<AddWalletPage> {
   bool customCurrencyIcon = false;
   String? searchCurrency = "";
   String selectedCurrency = "";
+  int selectedDecimals = 2;
 
   late FocusNode _periodLengthFocusNode;
 
@@ -106,6 +113,12 @@ class _AddWalletPageState extends State<AddWalletPage> {
   Future addWallet() async {
     print("Added wallet");
     await database.createOrUpdateWallet(await createTransactionWallet());
+    if (appStateSettings["selectedWallet"] == widget.wallet?.walletPk) {
+      updateSettings("selectedWalletDecimals", selectedDecimals,
+          updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
+      updateSettings("selectedWalletCurrency", selectedCurrency,
+          updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
+    }
     Navigator.pop(context);
   }
 
@@ -122,6 +135,7 @@ class _AddWalletPageState extends State<AddWalletPage> {
       dateTimeModified: null,
       order: widget.wallet != null ? widget.wallet!.order : numberOfWallets,
       currency: selectedCurrency,
+      decimals: selectedDecimals,
     );
   }
 
@@ -150,6 +164,7 @@ class _AddWalletPageState extends State<AddWalletPage> {
           ? null
           : HexColor(widget.wallet!.colour);
       selectedCurrency = widget.wallet!.currency ?? "usd";
+      selectedDecimals = widget.wallet!.decimals;
     } else {}
     populateCurrencies();
   }
@@ -204,6 +219,50 @@ class _AddWalletPageState extends State<AddWalletPage> {
 
   @override
   Widget build(BuildContext context) {
+    List<Widget> currencyList = [];
+    for (int index = 0; index < currencies.keys.length; index++) {
+      String key = currencies.keys.toList()[index];
+      currencyList.add(Padding(
+        padding: const EdgeInsets.only(left: 18.0, right: 18, bottom: 5),
+        child: Tappable(
+          color: selectedCurrency == key
+              ? Theme.of(context).colorScheme.secondaryContainer
+              : getColor(context, "lightDarkAccent"),
+          borderRadius: 13,
+          onTap: () {
+            FocusScopeNode currentFocus = FocusScope.of(context);
+            if (!currentFocus.hasPrimaryFocus) {
+              currentFocus.unfocus();
+            }
+            setSelectedCurrency(key);
+          },
+          child: Padding(
+            padding: const EdgeInsets.symmetric(horizontal: 17, vertical: 10),
+            child: Row(
+              mainAxisAlignment: MainAxisAlignment.spaceBetween,
+              children: [
+                Row(
+                  children: [
+                    TextFont(
+                        text: currencies[key]?["CountryName"] ??
+                            currencies[key]?["Currency"]),
+                  ],
+                ),
+                Row(
+                  children: [
+                    TextFont(
+                        text: currencies[key]["Symbol"] +
+                            " " +
+                            currencies[key]["Code"]),
+                  ],
+                )
+              ],
+            ),
+          ),
+        ),
+      ));
+    }
+
     return WillPopScope(
       onWillPop: () async {
         if (widget.wallet != null) {
@@ -226,6 +285,7 @@ class _AddWalletPageState extends State<AddWalletPage> {
           }
         },
         child: PageFramework(
+          key: addWalletPageKey,
           resizeToAvoidBottomInset: true,
           dragDownToDismiss: true,
           title: widget.title,
@@ -253,6 +313,23 @@ class _AddWalletPageState extends State<AddWalletPage> {
             }
           },
           actions: [
+            IconButton(
+              tooltip: "Info",
+              onPressed: () {
+                openPopup(
+                  context,
+                  title: "Exchange Rate Notice",
+                  description:
+                      "The exchange rates displayed within this app are for informational purposes only and should not be used for investment decisions. These rates are estimates and may not reflect actual rates. By using this app, you acknowledge that you understand and accept these limitations and that you assume full responsibility for any decisions made based on the information provided within the app.",
+                  icon: Icons.info,
+                  onCancel: () {
+                    Navigator.pop(context);
+                  },
+                  onCancelLabel: "OK",
+                );
+              },
+              icon: Icon(Icons.info),
+            ),
             widget.wallet != null && widget.wallet!.walletPk != 0
                 ? IconButton(
                     tooltip: "Delete wallet",
@@ -311,85 +388,74 @@ class _AddWalletPageState extends State<AddWalletPage> {
             SliverToBoxAdapter(
               child: SizedBox(height: 15),
             ),
-            SliverToBoxAdapter(
-              child: Padding(
-                padding: const EdgeInsets.symmetric(horizontal: 20),
-                child: TextFont(
-                  text: "Select Currency",
-                  textColor: getColor(context, "textLight"),
-                  fontSize: 16,
-                ),
-              ),
-            ),
-            SliverToBoxAdapter(
-              child: SizedBox(height: 10),
-            ),
-            SliverToBoxAdapter(
-              child: TextInput(
-                labelText: "Search currencies...",
-                icon: Icons.search_rounded,
-                onChanged: (text) {
-                  searchCurrencies(text);
-                },
-              ),
-            ),
-            SliverToBoxAdapter(
-              child: SizedBox(height: 15),
-            ),
-            SliverList(
-              delegate: SliverChildBuilderDelegate(
-                (BuildContext context, int index) {
-                  String key = currencies.keys.toList()[index];
-                  return Padding(
-                    padding:
-                        const EdgeInsets.only(left: 18.0, right: 18, bottom: 5),
-                    child: Tappable(
-                      color: selectedCurrency == key
-                          ? Theme.of(context).colorScheme.secondaryContainer
-                          : getColor(context, "lightDarkAccent"),
-                      borderRadius: 13,
-                      onTap: () {
-                        FocusScopeNode currentFocus = FocusScope.of(context);
-                        if (!currentFocus.hasPrimaryFocus) {
-                          currentFocus.unfocus();
-                        }
-                        setSelectedCurrency(key);
-                      },
-                      child: Padding(
-                        padding: const EdgeInsets.symmetric(
-                            horizontal: 17, vertical: 10),
-                        child: Wrap(
-                          alignment: WrapAlignment.spaceBetween,
-                          crossAxisAlignment: WrapCrossAlignment.center,
-                          children: [
-                            IntrinsicWidth(
-                              child: Row(
-                                children: [
-                                  TextFont(
-                                      text: currencies[key]?["CountryName"] ??
-                                          currencies[key]?["Currency"]),
-                                ],
-                              ),
-                            ),
-                            IntrinsicWidth(
-                              child: Row(
-                                children: [
-                                  TextFont(
-                                      text: currencies[key]["Symbol"] +
-                                          " " +
-                                          currencies[key]["Code"]),
-                                ],
-                              ),
-                            )
-                          ],
+            SliverStickyLabelDivider(
+              info: "Select Currency",
+              sliver: ColumnSliver(children: [
+                SizedBox(height: 10),
+                Row(
+                  children: [
+                    Expanded(
+                      child: Focus(
+                        onFocusChange: (hasFocus) {
+                          if (hasFocus)
+                            addWalletPageKey.currentState?.scrollTo(200);
+                        },
+                        child: TextInput(
+                          labelText: "Search currencies...",
+                          icon: Icons.search_rounded,
+                          onChanged: (text) {
+                            searchCurrencies(text);
+                          },
+                          padding: EdgeInsets.only(left: 18),
                         ),
                       ),
                     ),
-                  );
-                },
-                childCount: currencies.keys.length, //snapshot.data?.length
-              ),
+                    SizedBox(width: 10),
+                    ButtonIcon(
+                        onTap: () {
+                          openBottomSheet(
+                            context,
+                            PopupFramework(
+                              title: "Decimal Precision",
+                              child: SelectAmountValue(
+                                amountPassed: selectedDecimals.toString(),
+                                setSelectedAmount: (amount, _) {
+                                  selectedDecimals = amount.toInt();
+                                  if (amount > 10) {
+                                    selectedDecimals = 10;
+                                  } else if (amount < 0) {
+                                    selectedDecimals = 0;
+                                  }
+                                  setState(() {});
+                                },
+                                next: () async {
+                                  determineBottomButton();
+                                  Navigator.pop(context);
+                                },
+                                nextLabel: "Set Amount",
+                              ),
+                            ),
+                          );
+                        },
+                        icon: Icons.more_horiz_rounded),
+                    SizedBox(width: 18),
+                  ],
+                ),
+                SizedBox(height: 15),
+                currencyList.length <= 1
+                    ? NoResults(
+                        message: "No currencies found.",
+                      )
+                    : SizedBox.shrink(),
+                ...currencyList,
+                currencyList.length < 5
+                    ? SizedBox(
+                        height: 180,
+                      )
+                    : SizedBox.shrink(),
+              ]),
             ),
+
             SliverToBoxAdapter(child: SizedBox(height: 60)),
             // SliverToBoxAdapter(
             //   child: KeyboardHeightAreaAnimated(),
diff --git a/budget/lib/pages/budgetPage.dart b/budget/lib/pages/budgetPage.dart
index 9137e2915..45c321b0c 100644
--- a/budget/lib/pages/budgetPage.dart
+++ b/budget/lib/pages/budgetPage.dart
@@ -441,8 +441,6 @@ class _BudgetPageContentState extends State<_BudgetPageContent> {
                 child: Padding(
                   padding: const EdgeInsets.only(bottom: 13),
                   child: Container(
-                    padding:
-                        EdgeInsets.only(left: 5, right: 7, bottom: 12, top: 18),
                     margin: EdgeInsets.symmetric(horizontal: 13),
                     decoration: BoxDecoration(
                       borderRadius: BorderRadius.all(Radius.circular(15)),
@@ -462,6 +460,8 @@ class _BudgetPageContentState extends State<_BudgetPageContent> {
                       budgetRange: budgetRange,
                       budgetColorScheme: budgetColorScheme,
                       showIfNone: false,
+                      padding: EdgeInsets.only(
+                          left: 5, right: 7, bottom: 12, top: 18),
                     ),
                   ),
                 ),
@@ -665,6 +665,7 @@ class BudgetLineGraph extends StatefulWidget {
     required this.budgetColorScheme,
     this.showPastSpending = true,
     this.showIfNone = true,
+    this.padding = EdgeInsets.zero,
     super.key,
   });
 
@@ -677,6 +678,7 @@ class BudgetLineGraph extends StatefulWidget {
   final ColorScheme budgetColorScheme;
   final bool showPastSpending;
   final bool showIfNone;
+  final EdgeInsets padding;
 
   @override
   State<BudgetLineGraph> createState() => _BudgetLineGraphState();
@@ -828,33 +830,37 @@ class _BudgetLineGraphState extends State<BudgetLineGraph> {
               widget.selectedCategoryPk != -1 && widget.selectedCategory != null
                   ? HexColor(widget.selectedCategory!.colour)
                   : widget.budgetColorScheme.primary;
-          if (totalZeroes == pointsList[0].length) return SizedBox.shrink();
-          return LineChartWrapper(
-            color: lineColor,
-            verticalLineAt: widget.isPastBudget == true
-                ? null
-                : (widget.budgetRange.end
-                        .difference((widget.dateForRange ?? DateTime.now()))
-                        .inDays)
-                    .toDouble(),
-            endDate: widget.budgetRange.end,
-            points: pointsList,
-            isCurved: true,
-            colors: [
-              for (int index = 0; index < snapshot.data!.length; index++)
-                index == 0
-                    ? lineColor
-                    : (widget.selectedCategoryPk != -1 &&
-                                widget.selectedCategory != null
-                            ? lineColor
-                            : widget.budgetColorScheme.tertiary)
-                        .withOpacity((index) / snapshot.data!.length)
-            ],
-            horizontalLineAt: widget.budget.amount *
-                ((DateTime.now().millisecondsSinceEpoch -
-                        widget.budgetRange.start.millisecondsSinceEpoch) /
-                    (widget.budgetRange.end.millisecondsSinceEpoch -
-                        widget.budgetRange.start.millisecondsSinceEpoch)),
+          if (widget.showIfNone == false && totalZeroes == pointsList[0].length)
+            return SizedBox.shrink();
+          return Padding(
+            padding: widget.padding,
+            child: LineChartWrapper(
+              color: lineColor,
+              verticalLineAt: widget.isPastBudget == true
+                  ? null
+                  : (widget.budgetRange.end
+                          .difference((widget.dateForRange ?? DateTime.now()))
+                          .inDays)
+                      .toDouble(),
+              endDate: widget.budgetRange.end,
+              points: pointsList,
+              isCurved: true,
+              colors: [
+                for (int index = 0; index < snapshot.data!.length; index++)
+                  index == 0
+                      ? lineColor
+                      : (widget.selectedCategoryPk != -1 &&
+                                  widget.selectedCategory != null
+                              ? lineColor
+                              : widget.budgetColorScheme.tertiary)
+                          .withOpacity((index) / snapshot.data!.length)
+              ],
+              horizontalLineAt: widget.budget.amount *
+                  ((DateTime.now().millisecondsSinceEpoch -
+                          widget.budgetRange.start.millisecondsSinceEpoch) /
+                      (widget.budgetRange.end.millisecondsSinceEpoch -
+                          widget.budgetRange.start.millisecondsSinceEpoch)),
+            ),
           );
         }
         return SizedBox.shrink();
diff --git a/budget/lib/pages/budgetsListPage.dart b/budget/lib/pages/budgetsListPage.dart
index d4b2d583e..cd85aa1bb 100644
--- a/budget/lib/pages/budgetsListPage.dart
+++ b/budget/lib/pages/budgetsListPage.dart
@@ -4,8 +4,10 @@ import 'package:budget/widgets/budgetContainer.dart';
 import 'package:budget/widgets/openBottomSheet.dart';
 import 'package:budget/widgets/pageFramework.dart';
 import 'package:budget/widgets/textWidgets.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart'
+    hide SliverReorderableList, ReorderableDelayedDragStartListener;
 import 'package:flutter/services.dart';
+import 'package:budget/struct/reorderable_list.dart';
 
 class BudgetsListPage extends StatefulWidget {
   const BudgetsListPage({Key? key}) : super(key: key);
@@ -74,6 +76,7 @@ class BudgetsListPageState extends State<BudgetsListPage>
                       await database.moveBudget(
                           oldBudget.budgetPk, _intNew, oldBudget.order);
                     }
+                    return true;
                   },
                   onReorderStart: (index) {
                     HapticFeedback.heavyImpact();
diff --git a/budget/lib/pages/debugPage.dart b/budget/lib/pages/debugPage.dart
index 4f0dc51c7..0e0cd4689 100644
--- a/budget/lib/pages/debugPage.dart
+++ b/budget/lib/pages/debugPage.dart
@@ -5,6 +5,7 @@ import 'package:budget/widgets/button.dart';
 import 'package:budget/widgets/globalSnackBar.dart';
 import 'package:budget/widgets/openSnackbar.dart';
 import 'package:budget/widgets/pageFramework.dart';
+import 'package:budget/widgets/settingsContainers.dart';
 import 'package:budget/widgets/textWidgets.dart';
 import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
@@ -22,6 +23,16 @@ class DebugPage extends StatelessWidget {
       appBarBackgroundColor: Theme.of(context).colorScheme.secondaryContainer,
       appBarBackgroundColorStart: Theme.of(context).canvasColor,
       listWidgets: [
+        SettingsContainerDropdown(
+          title: "Font",
+          icon: Icons.font_download_rounded,
+          initial: appStateSettings["font"],
+          items: ["Avenir", "Inter", "DMSans", "OpenSans", "Metropolis"],
+          onChanged: (value) {
+            updateSettings("font", value,
+                updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
+          },
+        ),
         SliderSelector(
           min: 0,
           max: 3,
diff --git a/budget/lib/pages/editAssociatedTitlesPage.dart b/budget/lib/pages/editAssociatedTitlesPage.dart
index dbbc7b26c..6ecc33243 100644
--- a/budget/lib/pages/editAssociatedTitlesPage.dart
+++ b/budget/lib/pages/editAssociatedTitlesPage.dart
@@ -1,4 +1,3 @@
-import 'package:budget/colors.dart';
 import 'package:budget/database/tables.dart';
 import 'package:budget/functions.dart';
 import 'package:budget/main.dart';
@@ -16,9 +15,10 @@ import 'package:budget/widgets/pageFramework.dart';
 import 'package:budget/widgets/settingsContainers.dart';
 import 'package:budget/widgets/textInput.dart';
 import 'package:budget/widgets/textWidgets.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart' hide SliverReorderableList;
 import 'package:flutter/services.dart' hide TextInput;
 import 'package:budget/widgets/editRowEntry.dart';
+import 'package:budget/struct/reorderable_list.dart';
 
 class EditAssociatedTitlesPage extends StatefulWidget {
   EditAssociatedTitlesPage({
@@ -130,129 +130,141 @@ class _EditAssociatedTitlesPageState extends State<EditAssociatedTitlesPage> {
               icon: Icons.add_box_rounded,
             ),
           ),
-          StreamBuilder<List<TransactionAssociatedTitle>>(
-            stream: database.watchAllAssociatedTitles(
-                searchFor: searchValue == "" ? null : searchValue),
-            builder: (context, snapshot) {
-              // print(snapshot.data);
-              if (snapshot.hasData && (snapshot.data ?? []).length <= 0) {
-                return SliverToBoxAdapter(
-                  child: NoResults(
-                    message: "No associated category titles found.",
-                  ),
-                );
-              }
-              if (snapshot.hasData && (snapshot.data ?? []).length > 0) {
-                return SliverReorderableList(
-                  onReorderStart: (index) {
-                    HapticFeedback.heavyImpact();
-                    setState(() {
-                      dragDownToDismissEnabled = false;
-                      currentReorder = index;
-                    });
-                  },
-                  onReorderEnd: (_) {
-                    setState(() {
-                      dragDownToDismissEnabled = true;
-                      currentReorder = -1;
-                    });
-                  },
-                  itemBuilder: (context, index) {
-                    TransactionAssociatedTitle associatedTitle =
-                        snapshot.data![index];
-                    return EditRowEntry(
-                      canReorder: searchValue == "" &&
-                          (snapshot.data ?? []).length != 1,
-                      onTap: () {
-                        openBottomSheet(
-                          context,
-                          AddAssociatedTitlePage(
-                            title: "Add Title",
-                            associatedTitle: associatedTitle,
-                          ),
-                        );
-                      },
-                      padding: EdgeInsets.symmetric(vertical: 7, horizontal: 7),
-                      currentReorder:
-                          currentReorder != -1 && currentReorder != index,
-                      index: index,
-                      backgroundColor: getColor(context, "lightDarkAccent")!,
-                      content: Row(
-                        mainAxisAlignment: MainAxisAlignment.start,
-                        crossAxisAlignment: CrossAxisAlignment.center,
-                        children: [
-                          CategoryIcon(
-                            categoryPk: associatedTitle.categoryFk,
-                            size: 25,
-                            margin: EdgeInsets.zero,
-                            sizePadding: 20,
-                            borderRadius: 15,
-                          ),
-                          SizedBox(width: 15),
-                          Expanded(
-                            child: TextFont(
-                              text: associatedTitle.title +
-                                  " - " +
-                                  associatedTitle.order.toString(),
-                              fontWeight: FontWeight.bold,
-                              fontSize: 19,
-                              maxLines: 10,
+          StreamBuilder<Map<int, TransactionCategory>>(
+              stream: database.watchAllCategoriesMapped(),
+              builder: (context, mappedCategoriesSnapshot) {
+                return StreamBuilder<List<TransactionAssociatedTitle>>(
+                  stream: database.watchAllAssociatedTitles(
+                      searchFor: searchValue == "" ? null : searchValue),
+                  builder: (context, snapshot) {
+                    // print(snapshot.data);
+                    if (snapshot.hasData && (snapshot.data ?? []).length <= 0) {
+                      return SliverToBoxAdapter(
+                        child: NoResults(
+                          message: "No associated category titles found.",
+                        ),
+                      );
+                    }
+                    if (snapshot.hasData && (snapshot.data ?? []).length > 0) {
+                      return SliverReorderableList(
+                        onReorderStart: (index) {
+                          HapticFeedback.heavyImpact();
+                          setState(() {
+                            dragDownToDismissEnabled = false;
+                            currentReorder = index;
+                          });
+                        },
+                        onReorderEnd: (_) {
+                          setState(() {
+                            dragDownToDismissEnabled = true;
+                            currentReorder = -1;
+                          });
+                        },
+                        itemBuilder: (context, index) {
+                          TransactionAssociatedTitle associatedTitle =
+                              snapshot.data![index];
+                          return EditRowEntry(
+                            canReorder: searchValue == "" &&
+                                (snapshot.data ?? []).length != 1,
+                            onTap: () {
+                              openBottomSheet(
+                                context,
+                                AddAssociatedTitlePage(
+                                  title: "Add Title",
+                                  associatedTitle: associatedTitle,
+                                ),
+                              );
+                            },
+                            padding: EdgeInsets.symmetric(
+                                vertical: 7, horizontal: 7),
+                            currentReorder:
+                                currentReorder != -1 && currentReorder != index,
+                            index: index,
+                            content: Row(
+                              mainAxisAlignment: MainAxisAlignment.start,
+                              crossAxisAlignment: CrossAxisAlignment.center,
+                              children: [
+                                SizedBox(width: 3),
+                                CategoryIcon(
+                                  categoryPk: associatedTitle.categoryFk,
+                                  size: 25,
+                                  margin: EdgeInsets.zero,
+                                  sizePadding: 20,
+                                  borderRadius: 1000,
+                                  category: mappedCategoriesSnapshot
+                                      .data![associatedTitle.categoryFk],
+                                ),
+                                SizedBox(width: 15),
+                                Expanded(
+                                  child: TextFont(
+                                    text: associatedTitle.title
+                                    // +
+                                    //     " - " +
+                                    //     associatedTitle.order.toString()
+                                    ,
+                                    fontWeight: FontWeight.bold,
+                                    fontSize: 19,
+                                    maxLines: 10,
+                                  ),
+                                ),
+                              ],
                             ),
-                          ),
-                        ],
-                      ),
-                      onDelete: () {
-                        openPopup(
-                          context,
-                          title: "Delete " + associatedTitle.title + "?",
-                          icon: Icons.delete_rounded,
-                          onCancel: () {
-                            Navigator.pop(context);
-                          },
-                          onCancelLabel: "Cancel",
-                          onSubmit: () async {
-                            await database.deleteAssociatedTitle(
-                                associatedTitle.associatedTitlePk,
-                                associatedTitle.order);
-                            Navigator.pop(context);
-                            openSnackbar(
-                              SnackbarMessage(
-                                  title: "Deleted " + associatedTitle.title,
-                                  icon: Icons.delete),
-                            );
-                          },
-                          onSubmitLabel: "Delete",
-                        );
-                      },
-                      openPage: Container(),
-                      key: ValueKey(index),
-                    );
-                  },
-                  itemCount: snapshot.data!.length,
-                  onReorder: (_intPrevious, _intNew) async {
-                    TransactionAssociatedTitle oldTitle =
-                        snapshot.data![_intPrevious];
-
-                    _intNew = snapshot.data!.length - _intNew;
-                    _intPrevious = snapshot.data!.length - _intPrevious;
+                            onDelete: () {
+                              openPopup(
+                                context,
+                                title: "Delete " + associatedTitle.title + "?",
+                                icon: Icons.delete_rounded,
+                                onCancel: () {
+                                  Navigator.pop(context);
+                                },
+                                onCancelLabel: "Cancel",
+                                onSubmit: () async {
+                                  await database.deleteAssociatedTitle(
+                                      associatedTitle.associatedTitlePk,
+                                      associatedTitle.order);
+                                  Navigator.pop(context);
+                                  openSnackbar(
+                                    SnackbarMessage(
+                                        title:
+                                            "Deleted " + associatedTitle.title,
+                                        icon: Icons.delete),
+                                  );
+                                },
+                                onSubmitLabel: "Delete",
+                              );
+                            },
+                            openPage: Container(),
+                            key: ValueKey(index),
+                          );
+                        },
+                        itemCount: snapshot.data!.length,
+                        onReorder: (_intPrevious, _intNew) async {
+                          TransactionAssociatedTitle oldTitle =
+                              snapshot.data![_intPrevious];
+                          _intNew = snapshot.data!.length - _intNew;
+                          _intPrevious = snapshot.data!.length - _intPrevious;
+                          if (_intNew > _intPrevious) {
+                            await database.moveAssociatedTitle(
+                                oldTitle.associatedTitlePk,
+                                _intNew - 1,
+                                oldTitle.order);
+                          } else {
+                            await database.moveAssociatedTitle(
+                                oldTitle.associatedTitlePk,
+                                _intNew,
+                                oldTitle.order);
+                          }
 
-                    if (_intNew > _intPrevious) {
-                      await database.moveAssociatedTitle(
-                          oldTitle.associatedTitlePk,
-                          _intNew - 1,
-                          oldTitle.order);
-                    } else {
-                      await database.moveAssociatedTitle(
-                          oldTitle.associatedTitlePk, _intNew, oldTitle.order);
+                          return true;
+                        },
+                      );
                     }
+                    return SliverToBoxAdapter(
+                      child: Container(),
+                    );
                   },
                 );
-              }
-              return SliverToBoxAdapter(
-                child: Container(),
-              );
-            },
-          ),
+              }),
           SliverToBoxAdapter(
             child: SizedBox(height: 85),
           ),
diff --git a/budget/lib/pages/editBudgetPage.dart b/budget/lib/pages/editBudgetPage.dart
index 370c59f61..e1479610a 100644
--- a/budget/lib/pages/editBudgetPage.dart
+++ b/budget/lib/pages/editBudgetPage.dart
@@ -19,8 +19,9 @@ import 'package:budget/widgets/settingsContainers.dart';
 import 'package:budget/widgets/textInput.dart';
 import 'package:budget/widgets/textWidgets.dart';
 import 'package:budget/widgets/editRowEntry.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart' hide SliverReorderableList;
 import 'package:flutter/services.dart' hide TextInput;
+import 'package:budget/struct/reorderable_list.dart';
 
 class EditBudgetPage extends StatefulWidget {
   EditBudgetPage({
@@ -222,7 +223,8 @@ class _EditBudgetPageState extends State<EditBudgetPage> {
                                 fontSize: 15,
                               ),
                               Container(height: 2),
-                              budget.sharedKey == null
+                              budget.sharedKey == null &&
+                                      !budget.addedTransactionsOnly
                                   ? TextFont(
                                       text: budget.categoryFks == null ||
                                               budget.categoryFks!.length == 0
@@ -247,7 +249,7 @@ class _EditBudgetPageState extends State<EditBudgetPage> {
                                                     " transaction"),
                                             fontSize: 14,
                                             textColor:
-                                                getColor(context, "black")!
+                                                getColor(context, "black")
                                                     .withOpacity(0.65),
                                           );
                                         } else {
@@ -256,7 +258,7 @@ class _EditBudgetPageState extends State<EditBudgetPage> {
                                             text: "/ transactions",
                                             fontSize: 14,
                                             textColor:
-                                                getColor(context, "black")!
+                                                getColor(context, "black")
                                                     .withOpacity(0.65),
                                           );
                                         }
@@ -344,6 +346,7 @@ class _EditBudgetPageState extends State<EditBudgetPage> {
                       await database.moveBudget(
                           oldBudget.budgetPk, _intNew, oldBudget.order);
                     }
+                    return true;
                   },
                 );
               }
diff --git a/budget/lib/pages/editCategoriesPage.dart b/budget/lib/pages/editCategoriesPage.dart
index c576f65fd..b34866e19 100644
--- a/budget/lib/pages/editCategoriesPage.dart
+++ b/budget/lib/pages/editCategoriesPage.dart
@@ -18,9 +18,10 @@ import 'package:budget/widgets/openSnackbar.dart';
 import 'package:budget/widgets/pageFramework.dart';
 import 'package:budget/widgets/textInput.dart';
 import 'package:budget/widgets/textWidgets.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart' hide SliverReorderableList;
 import 'package:flutter/services.dart' hide TextInput;
 import 'package:budget/widgets/editRowEntry.dart';
+import 'package:budget/struct/reorderable_list.dart';
 
 class EditCategoriesPage extends StatefulWidget {
   EditCategoriesPage({
@@ -125,13 +126,6 @@ class _EditCategoriesPageState extends State<EditCategoriesPage> {
                   },
                   itemBuilder: (context, index) {
                     TransactionCategory category = snapshot.data![index];
-                    Color backgroundColor = dynamicPastel(
-                        context,
-                        HexColor(category.colour,
-                            defaultColor:
-                                Theme.of(context).colorScheme.primary),
-                        amountLight: 0.55,
-                        amountDark: 0.35);
                     return EditRowEntry(
                       canReorder: searchValue == "" &&
                           (snapshot.data ?? []).length != 1,
@@ -140,15 +134,16 @@ class _EditCategoriesPageState extends State<EditCategoriesPage> {
                       padding:
                           EdgeInsets.symmetric(horizontal: 10, vertical: 5),
                       key: ValueKey(index),
-                      backgroundColor: backgroundColor,
                       content: Row(
                         crossAxisAlignment: CrossAxisAlignment.center,
                         children: [
                           CategoryIcon(
                             categoryPk: category.categoryPk,
-                            size: 40,
+                            size: 31,
                             category: category,
                             canEditByLongPress: false,
+                            borderRadius: 1000,
+                            sizePadding: 23,
                           ),
                           Container(width: 5),
                           Expanded(
@@ -157,9 +152,11 @@ class _EditCategoriesPageState extends State<EditCategoriesPage> {
                               mainAxisSize: MainAxisSize.min,
                               children: [
                                 TextFont(
-                                  text: category.name +
-                                      " - " +
-                                      category.order.toString(),
+                                  text: category.name
+                                  // +
+                                  //     " - " +
+                                  //     category.order.toString()
+                                  ,
                                   fontWeight: FontWeight.bold,
                                   fontSize: 19,
                                 ),
@@ -177,7 +174,7 @@ class _EditCategoriesPageState extends State<EditCategoriesPage> {
                                             pluralString(snapshot.data![0] == 1,
                                                 " transaction"),
                                         fontSize: 14,
-                                        textColor: getColor(context, "black")!
+                                        textColor: getColor(context, "black")
                                             .withOpacity(0.65),
                                       );
                                     } else {
@@ -185,7 +182,7 @@ class _EditCategoriesPageState extends State<EditCategoriesPage> {
                                         textAlign: TextAlign.left,
                                         text: "/ transactions",
                                         fontSize: 14,
-                                        textColor: getColor(context, "black")!
+                                        textColor: getColor(context, "black")
                                             .withOpacity(0.65),
                                       );
                                     }
@@ -218,6 +215,7 @@ class _EditCategoriesPageState extends State<EditCategoriesPage> {
                       await database.moveCategory(
                           oldCategory.categoryPk, _intNew, oldCategory.order);
                     }
+                    return true;
                   },
                 );
               }
diff --git a/budget/lib/pages/editWalletsPage.dart b/budget/lib/pages/editWalletsPage.dart
index 33562d589..d2fb3d426 100644
--- a/budget/lib/pages/editWalletsPage.dart
+++ b/budget/lib/pages/editWalletsPage.dart
@@ -15,9 +15,10 @@ import 'package:budget/widgets/pageFramework.dart';
 import 'package:budget/widgets/settingsContainers.dart';
 import 'package:budget/widgets/textInput.dart';
 import 'package:budget/widgets/textWidgets.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart' hide SliverReorderableList;
 import 'package:flutter/services.dart' hide TextInput;
 import 'package:budget/widgets/editRowEntry.dart';
+import 'package:budget/struct/reorderable_list.dart';
 
 class EditWalletsPage extends StatefulWidget {
   EditWalletsPage({
@@ -182,7 +183,7 @@ class _EditWalletsPageState extends State<EditWalletsPage> {
                                       pluralString(snapshot.data![0] == 1,
                                           " transaction"),
                                   fontSize: 14,
-                                  textColor: getColor(context, "black")!
+                                  textColor: getColor(context, "black")
                                       .withOpacity(0.65),
                                 );
                               } else {
@@ -190,7 +191,7 @@ class _EditWalletsPageState extends State<EditWalletsPage> {
                                     textAlign: TextAlign.left,
                                     text: "/ transactions",
                                     fontSize: 14,
-                                    textColor: getColor(context, "black")!
+                                    textColor: getColor(context, "black")
                                         .withOpacity(0.65));
                               }
                             },
@@ -218,6 +219,7 @@ class _EditWalletsPageState extends State<EditWalletsPage> {
                       await database.moveWallet(
                           oldWallet.walletPk, _intNew, oldWallet.order);
                     }
+                    return true;
                   },
                 );
               }
@@ -258,6 +260,8 @@ void deleteWalletPopup(context, TransactionWallet wallet,
         TransactionWallet defaultWallet = await database.getWalletInstance(0);
         updateSettings("selectedWalletCurrency", defaultWallet.currency,
             updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
+        updateSettings("selectedWalletDecimals", defaultWallet.decimals,
+            updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
       }
       Navigator.pop(context);
       openSnackbar(
diff --git a/budget/lib/pages/homePage.dart b/budget/lib/pages/homePage.dart
index dbb8e1ae1..76d9d0add 100644
--- a/budget/lib/pages/homePage.dart
+++ b/budget/lib/pages/homePage.dart
@@ -254,6 +254,9 @@ class HomePageState extends State<HomePage>
                                       onTap: () {
                                         enterNameBottomSheet(context);
                                       },
+                                      onLongPress: () {
+                                        enterNameBottomSheet(context);
+                                      },
                                       borderRadius: 15,
                                       child: child ?? SizedBox.shrink(),
                                     ),
@@ -846,7 +849,7 @@ class UpcomingTransactions extends StatelessWidget {
                                     snapshot.data == null
                                 ? 0
                                 : (snapshot.data ?? 0).abs(),
-                            duration: Duration(milliseconds: 2500),
+                            duration: Duration(milliseconds: 1500),
                             dynamicDecimals: true,
                             initialCount: (0),
                             textBuilder: (number) {
@@ -856,11 +859,15 @@ class UpcomingTransactions extends StatelessWidget {
                                             snapshot.data == null
                                         ? 0
                                         : (snapshot.data ?? 0).abs()),
-                                fontSize: 24,
                                 textColor: overdueTransactions
                                     ? getColor(context, "unPaidRed")
                                     : getColor(context, "unPaidYellow"),
                                 fontWeight: FontWeight.bold,
+                                autoSizeText: true,
+                                fontSize: 24,
+                                maxFontSize: 24,
+                                minFontSize: 10,
+                                maxLines: 1,
                               );
                             },
                           );
diff --git a/budget/lib/pages/settingsPage.dart b/budget/lib/pages/settingsPage.dart
index 35c8743d8..f87e7b13f 100644
--- a/budget/lib/pages/settingsPage.dart
+++ b/budget/lib/pages/settingsPage.dart
@@ -127,16 +127,6 @@ class SettingsPageState extends State<SettingsPage>
             }
           },
         ),
-        SettingsContainerDropdown(
-          title: "Font",
-          icon: Icons.font_download_rounded,
-          initial: appStateSettings["font"],
-          items: ["Avenir", "Inter", "DMSans", "OpenSans", "Metropolis"],
-          onChanged: (value) {
-            updateSettings("font", value,
-                updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
-          },
-        ),
         EnterName(),
         SettingsHeader(title: "Preferences"),
         // In the future, each wallet will have its own currency
diff --git a/budget/lib/pages/walletDetailsPage.dart b/budget/lib/pages/walletDetailsPage.dart
index 4daeeff20..81d3b1647 100644
--- a/budget/lib/pages/walletDetailsPage.dart
+++ b/budget/lib/pages/walletDetailsPage.dart
@@ -277,11 +277,15 @@ class IncomeTransactionsSummary extends StatelessWidget {
                                 ? 0
                                 : (snapshot.data ?? 0).abs(),
                           ),
-                          fontSize: 21,
                           textColor: incomeTransactions
                               ? getColor(context, "incomeGreen")
                               : Theme.of(context).colorScheme.error,
                           fontWeight: FontWeight.bold,
+                          autoSizeText: true,
+                          fontSize: 21,
+                          maxFontSize: 21,
+                          minFontSize: 10,
+                          maxLines: 1,
                         );
                       },
                     );
diff --git a/budget/lib/struct/defaultPreferences.dart b/budget/lib/struct/defaultPreferences.dart
index d7410484e..b1b2b0b28 100644
--- a/budget/lib/struct/defaultPreferences.dart
+++ b/budget/lib/struct/defaultPreferences.dart
@@ -13,6 +13,7 @@ Map<String, dynamic> defaultPreferences() {
     "theme": "system",
     "selectedWallet": 0,
     "selectedWalletCurrency": "usd",
+    "selectedWalletDecimals": 2,
     "selectedSubscriptionType": 0,
     "accentColor": toHexString(Color(0xFF1B447A)),
     "accentSystemColor": true,
diff --git a/budget/lib/struct/reorderable_list.dart b/budget/lib/struct/reorderable_list.dart
new file mode 100644
index 000000000..9451aaaeb
--- /dev/null
+++ b/budget/lib/struct/reorderable_list.dart
@@ -0,0 +1,1445 @@
+// Copyright 2014 The Flutter Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+import 'package:flutter/gestures.dart';
+import 'package:flutter/scheduler.dart';
+import 'package:flutter/material.dart';
+
+// Examples can assume:
+// class MyDataObject {}
+
+/// A callback used by [ReorderableList] to report that a list item has moved
+/// to a new position in the list.
+///
+/// Implementations should remove the corresponding list item at [oldIndex]
+/// and reinsert it at [newIndex].
+///
+/// If [oldIndex] is before [newIndex], removing the item at [oldIndex] from the
+/// list will reduce the list's length by one. Implementations will need to
+/// account for this when inserting before [newIndex].
+///
+/// {@youtube 560 315 https://www.youtube.com/watch?v=3fB1mxOsqJE}
+///
+/// {@tool snippet}
+///
+/// ```dart
+/// final List<MyDataObject> backingList = <MyDataObject>[/* ... */];
+///
+/// void handleReorder(int oldIndex, int newIndex) {
+///   if (oldIndex < newIndex) {
+///     // removing the item at oldIndex will shorten the list by 1.
+///     newIndex -= 1;
+///   }
+///   final MyDataObject element = backingList.removeAt(oldIndex);
+///   backingList.insert(newIndex, element);
+/// }
+/// ```
+/// {@end-tool}
+///
+/// See also:
+///
+///  * [ReorderableList], a widget list that allows the user to reorder
+///    its items.
+///  * [SliverReorderableList], a sliver list that allows the user to reorder
+///    its items.
+///  * [ReorderableListView], a Material Design list that allows the user to
+///    reorder its items.
+typedef ReorderCallback = Future<bool> Function(int oldIndex, int newIndex);
+
+/// Signature for the builder callback used to decorate the dragging item in
+/// [ReorderableList] and [SliverReorderableList].
+///
+/// The [child] will be the item that is being dragged, and [index] is the
+/// position of the item in the list.
+///
+/// The [animation] will be driven forward from 0.0 to 1.0 while the item is
+/// being picked up during a drag operation, and reversed from 1.0 to 0.0 when
+/// the item is dropped. This can be used to animate properties of the proxy
+/// like an elevation or border.
+///
+/// The returned value will typically be the [child] wrapped in other widgets.
+typedef ReorderItemProxyDecorator = Widget Function(
+    Widget child, int index, Animation<double> animation);
+
+/// A scrolling container that allows the user to interactively reorder the
+/// list items.
+///
+/// This widget is similar to one created by [ListView.builder], and uses
+/// an [IndexedWidgetBuilder] to create each item.
+///
+/// It is up to the application to wrap each child (or an internal part of the
+/// child such as a drag handle) with a drag listener that will recognize
+/// the start of an item drag and then start the reorder by calling
+/// [ReorderableListState.startItemDragReorder]. This is most easily achieved
+/// by wrapping each child in a [ReorderableDragStartListener] or a
+/// [ReorderableDelayedDragStartListener]. These will take care of recognizing
+/// the start of a drag gesture and call the list state's
+/// [ReorderableListState.startItemDragReorder] method.
+///
+/// This widget's [ReorderableListState] can be used to manually start an item
+/// reorder, or cancel a current drag. To refer to the
+/// [ReorderableListState] either provide a [GlobalKey] or use the static
+/// [ReorderableList.of] method from an item's build method.
+///
+/// See also:
+///
+///  * [SliverReorderableList], a sliver list that allows the user to reorder
+///    its items.
+///  * [ReorderableListView], a Material Design list that allows the user to
+///    reorder its items.
+class ReorderableList extends StatefulWidget {
+  /// Creates a scrolling container that allows the user to interactively
+  /// reorder the list items.
+  ///
+  /// The [itemCount] must be greater than or equal to zero.
+  const ReorderableList({
+    super.key,
+    required this.itemBuilder,
+    required this.itemCount,
+    required this.onReorder,
+    this.onReorderStart,
+    this.onReorderEnd,
+    this.itemExtent,
+    this.prototypeItem,
+    this.proxyDecorator,
+    this.padding,
+    this.scrollDirection = Axis.vertical,
+    this.reverse = false,
+    this.controller,
+    this.primary,
+    this.physics,
+    this.shrinkWrap = false,
+    this.anchor = 0.0,
+    this.cacheExtent,
+    this.dragStartBehavior = DragStartBehavior.start,
+    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,
+    this.restorationId,
+    this.clipBehavior = Clip.hardEdge,
+  })  : assert(itemCount >= 0),
+        assert(
+          itemExtent == null || prototypeItem == null,
+          'You can only pass itemExtent or prototypeItem, not both',
+        );
+
+  /// {@template flutter.widgets.reorderable_list.itemBuilder}
+  /// Called, as needed, to build list item widgets.
+  ///
+  /// List items are only built when they're scrolled into view.
+  ///
+  /// The [IndexedWidgetBuilder] index parameter indicates the item's
+  /// position in the list. The value of the index parameter will be between
+  /// zero and one less than [itemCount]. All items in the list must have a
+  /// unique [Key], and should have some kind of listener to start the drag
+  /// (usually a [ReorderableDragStartListener] or
+  /// [ReorderableDelayedDragStartListener]).
+  /// {@endtemplate}
+  final IndexedWidgetBuilder itemBuilder;
+
+  /// {@template flutter.widgets.reorderable_list.itemCount}
+  /// The number of items in the list.
+  ///
+  /// It must be a non-negative integer. When zero, nothing is displayed and
+  /// the widget occupies no space.
+  /// {@endtemplate}
+  final int itemCount;
+
+  /// {@template flutter.widgets.reorderable_list.onReorder}
+  /// A callback used by the list to report that a list item has been dragged
+  /// to a new location in the list and the application should update the order
+  /// of the items.
+  /// {@endtemplate}
+  final ReorderCallback onReorder;
+
+  /// {@template flutter.widgets.reorderable_list.onReorderStart}
+  /// A callback that is called when an item drag has started.
+  ///
+  /// The index parameter of the callback is the index of the selected item.
+  ///
+  /// See also:
+  ///
+  ///   * [onReorderEnd], which is a called when the dragged item is dropped.
+  ///   * [onReorder], which reports that a list item has been dragged to a new
+  ///     location.
+  /// {@endtemplate}
+  final void Function(int index)? onReorderStart;
+
+  /// {@template flutter.widgets.reorderable_list.onReorderEnd}
+  /// A callback that is called when the dragged item is dropped.
+  ///
+  /// The index parameter of the callback is the index where the item is
+  /// dropped. Unlike [onReorder], this is called even when the list item is
+  /// dropped in the same location.
+  ///
+  /// See also:
+  ///
+  ///   * [onReorderStart], which is a called when an item drag has started.
+  ///   * [onReorder], which reports that a list item has been dragged to a new
+  ///     location.
+  /// {@endtemplate}
+  final void Function(int index)? onReorderEnd;
+
+  /// {@template flutter.widgets.reorderable_list.proxyDecorator}
+  /// A callback that allows the app to add an animated decoration around
+  /// an item when it is being dragged.
+  /// {@endtemplate}
+  final ReorderItemProxyDecorator? proxyDecorator;
+
+  /// {@template flutter.widgets.reorderable_list.padding}
+  /// The amount of space by which to inset the list contents.
+  ///
+  /// It defaults to `EdgeInsets.all(0)`.
+  /// {@endtemplate}
+  final EdgeInsetsGeometry? padding;
+
+  /// {@macro flutter.widgets.scroll_view.scrollDirection}
+  final Axis scrollDirection;
+
+  /// {@macro flutter.widgets.scroll_view.reverse}
+  final bool reverse;
+
+  /// {@macro flutter.widgets.scroll_view.controller}
+  final ScrollController? controller;
+
+  /// {@macro flutter.widgets.scroll_view.primary}
+  final bool? primary;
+
+  /// {@macro flutter.widgets.scroll_view.physics}
+  final ScrollPhysics? physics;
+
+  /// {@macro flutter.widgets.scroll_view.shrinkWrap}
+  final bool shrinkWrap;
+
+  /// {@macro flutter.widgets.scroll_view.anchor}
+  final double anchor;
+
+  /// {@macro flutter.rendering.RenderViewportBase.cacheExtent}
+  final double? cacheExtent;
+
+  /// {@macro flutter.widgets.scrollable.dragStartBehavior}
+  final DragStartBehavior dragStartBehavior;
+
+  /// {@macro flutter.widgets.scroll_view.keyboardDismissBehavior}
+  ///
+  /// The default is [ScrollViewKeyboardDismissBehavior.manual]
+  final ScrollViewKeyboardDismissBehavior keyboardDismissBehavior;
+
+  /// {@macro flutter.widgets.scrollable.restorationId}
+  final String? restorationId;
+
+  /// {@macro flutter.material.Material.clipBehavior}
+  ///
+  /// Defaults to [Clip.hardEdge].
+  final Clip clipBehavior;
+
+  /// {@macro flutter.widgets.list_view.itemExtent}
+  final double? itemExtent;
+
+  /// {@macro flutter.widgets.list_view.prototypeItem}
+  final Widget? prototypeItem;
+
+  /// The state from the closest instance of this class that encloses the given
+  /// context.
+  ///
+  /// This method is typically used by [ReorderableList] item widgets that
+  /// insert or remove items in response to user input.
+  ///
+  /// If no [ReorderableList] surrounds the given context, then this function
+  /// will assert in debug mode and throw an exception in release mode.
+  ///
+  /// This method can be expensive (it walks the element tree).
+  ///
+  /// See also:
+  ///
+  ///  * [maybeOf], a similar function that will return null if no
+  ///    [ReorderableList] ancestor is found.
+  static ReorderableListState of(BuildContext context) {
+    final ReorderableListState? result =
+        context.findAncestorStateOfType<ReorderableListState>();
+    assert(() {
+      if (result == null) {
+        throw FlutterError.fromParts(<DiagnosticsNode>[
+          ErrorSummary(
+              'ReorderableList.of() called with a context that does not contain a ReorderableList.'),
+          ErrorDescription(
+            'No ReorderableList ancestor could be found starting from the context that was passed to ReorderableList.of().',
+          ),
+          ErrorHint(
+            'This can happen when the context provided is from the same StatefulWidget that '
+            'built the ReorderableList. Please see the ReorderableList documentation for examples '
+            'of how to refer to an ReorderableListState object:\n'
+            '  https://api.flutter.dev/flutter/widgets/ReorderableListState-class.html',
+          ),
+          context.describeElement('The context used was'),
+        ]);
+      }
+      return true;
+    }());
+    return result!;
+  }
+
+  /// The state from the closest instance of this class that encloses the given
+  /// context.
+  ///
+  /// This method is typically used by [ReorderableList] item widgets that insert
+  /// or remove items in response to user input.
+  ///
+  /// If no [ReorderableList] surrounds the context given, then this function will
+  /// return null.
+  ///
+  /// This method can be expensive (it walks the element tree).
+  ///
+  /// See also:
+  ///
+  ///  * [of], a similar function that will throw if no [ReorderableList] ancestor
+  ///    is found.
+  static ReorderableListState? maybeOf(BuildContext context) {
+    return context.findAncestorStateOfType<ReorderableListState>();
+  }
+
+  @override
+  ReorderableListState createState() => ReorderableListState();
+}
+
+/// The state for a list that allows the user to interactively reorder
+/// the list items.
+///
+/// An app that needs to start a new item drag or cancel an existing one
+/// can refer to the [ReorderableList]'s state with a global key:
+///
+/// ```dart
+/// GlobalKey<ReorderableListState> listKey = GlobalKey<ReorderableListState>();
+/// // ...
+/// Widget build(BuildContext context) {
+///   return ReorderableList(
+///     key: listKey,
+///     itemBuilder: (BuildContext context, int index) => const SizedBox(height: 10.0),
+///     itemCount: 5,
+///     onReorder: (int oldIndex, int newIndex) {
+///        // ...
+///     },
+///   );
+/// }
+/// // ...
+/// listKey.currentState!.cancelReorder();
+/// ```
+class ReorderableListState extends State<ReorderableList> {
+  final GlobalKey<SliverReorderableListState> _sliverReorderableListKey =
+      GlobalKey();
+
+  /// Initiate the dragging of the item at [index] that was started with
+  /// the pointer down [event].
+  ///
+  /// The given [recognizer] will be used to recognize and start the drag
+  /// item tracking and lead to either an item reorder, or a canceled drag.
+  /// The list will take ownership of the returned recognizer and will dispose
+  /// it when it is no longer needed.
+  ///
+  /// Most applications will not use this directly, but will wrap the item
+  /// (or part of the item, like a drag handle) in either a
+  /// [ReorderableDragStartListener] or [ReorderableDelayedDragStartListener]
+  /// which call this for the application.
+  void startItemDragReorder({
+    required int index,
+    required PointerDownEvent event,
+    required MultiDragGestureRecognizer recognizer,
+  }) {
+    _sliverReorderableListKey.currentState!.startItemDragReorder(
+        index: index, event: event, recognizer: recognizer);
+  }
+
+  /// Cancel any item drag in progress.
+  ///
+  /// This should be called before any major changes to the item list
+  /// occur so that any item drags will not get confused by
+  /// changes to the underlying list.
+  ///
+  /// If no drag is active, this will do nothing.
+  void cancelReorder() {
+    _sliverReorderableListKey.currentState!.cancelReorder();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return CustomScrollView(
+      scrollDirection: widget.scrollDirection,
+      reverse: widget.reverse,
+      controller: widget.controller,
+      primary: widget.primary,
+      physics: widget.physics,
+      shrinkWrap: widget.shrinkWrap,
+      anchor: widget.anchor,
+      cacheExtent: widget.cacheExtent,
+      dragStartBehavior: widget.dragStartBehavior,
+      keyboardDismissBehavior: widget.keyboardDismissBehavior,
+      restorationId: widget.restorationId,
+      clipBehavior: widget.clipBehavior,
+      slivers: <Widget>[
+        SliverPadding(
+          padding: widget.padding ?? EdgeInsets.zero,
+          sliver: SliverReorderableList(
+            key: _sliverReorderableListKey,
+            itemExtent: widget.itemExtent,
+            prototypeItem: widget.prototypeItem,
+            itemBuilder: widget.itemBuilder,
+            itemCount: widget.itemCount,
+            onReorder: widget.onReorder,
+            onReorderStart: widget.onReorderStart,
+            onReorderEnd: widget.onReorderEnd,
+            proxyDecorator: widget.proxyDecorator,
+          ),
+        ),
+      ],
+    );
+  }
+}
+
+/// A sliver list that allows the user to interactively reorder the list items.
+///
+/// It is up to the application to wrap each child (or an internal part of the
+/// child) with a drag listener that will recognize the start of an item drag
+/// and then start the reorder by calling
+/// [SliverReorderableListState.startItemDragReorder]. This is most easily
+/// achieved by wrapping each child in a [ReorderableDragStartListener] or
+/// a [ReorderableDelayedDragStartListener]. These will take care of
+/// recognizing the start of a drag gesture and call the list state's start
+/// item drag method.
+///
+/// This widget's [SliverReorderableListState] can be used to manually start an item
+/// reorder, or cancel a current drag that's already underway. To refer to the
+/// [SliverReorderableListState] either provide a [GlobalKey] or use the static
+/// [SliverReorderableList.of] method from an item's build method.
+///
+/// See also:
+///
+///  * [ReorderableList], a regular widget list that allows the user to reorder
+///    its items.
+///  * [ReorderableListView], a Material Design list that allows the user to
+///    reorder its items.
+class SliverReorderableList extends StatefulWidget {
+  /// Creates a sliver list that allows the user to interactively reorder its
+  /// items.
+  ///
+  /// The [itemCount] must be greater than or equal to zero.
+  const SliverReorderableList({
+    super.key,
+    required this.itemBuilder,
+    this.findChildIndexCallback,
+    required this.itemCount,
+    required this.onReorder,
+    this.onReorderStart,
+    this.onReorderEnd,
+    this.itemExtent,
+    this.prototypeItem,
+    this.proxyDecorator,
+  })  : assert(itemCount >= 0),
+        assert(
+          itemExtent == null || prototypeItem == null,
+          'You can only pass itemExtent or prototypeItem, not both',
+        );
+
+  /// {@macro flutter.widgets.reorderable_list.itemBuilder}
+  final IndexedWidgetBuilder itemBuilder;
+
+  /// {@macro flutter.widgets.SliverChildBuilderDelegate.findChildIndexCallback}
+  final ChildIndexGetter? findChildIndexCallback;
+
+  /// {@macro flutter.widgets.reorderable_list.itemCount}
+  final int itemCount;
+
+  /// {@macro flutter.widgets.reorderable_list.onReorder}
+  final ReorderCallback onReorder;
+
+  /// {@macro flutter.widgets.reorderable_list.onReorderStart}
+  final void Function(int)? onReorderStart;
+
+  /// {@macro flutter.widgets.reorderable_list.onReorderEnd}
+  final void Function(int)? onReorderEnd;
+
+  /// {@macro flutter.widgets.reorderable_list.proxyDecorator}
+  final ReorderItemProxyDecorator? proxyDecorator;
+
+  /// {@macro flutter.widgets.list_view.itemExtent}
+  final double? itemExtent;
+
+  /// {@macro flutter.widgets.list_view.prototypeItem}
+  final Widget? prototypeItem;
+
+  @override
+  SliverReorderableListState createState() => SliverReorderableListState();
+
+  /// The state from the closest instance of this class that encloses the given
+  /// context.
+  ///
+  /// This method is typically used by [SliverReorderableList] item widgets to
+  /// start or cancel an item drag operation.
+  ///
+  /// If no [SliverReorderableList] surrounds the context given, this function
+  /// will assert in debug mode and throw an exception in release mode.
+  ///
+  /// This method can be expensive (it walks the element tree).
+  ///
+  /// See also:
+  ///
+  ///  * [maybeOf], a similar function that will return null if no
+  ///    [SliverReorderableList] ancestor is found.
+  static SliverReorderableListState of(BuildContext context) {
+    final SliverReorderableListState? result =
+        context.findAncestorStateOfType<SliverReorderableListState>();
+    assert(() {
+      if (result == null) {
+        throw FlutterError.fromParts(<DiagnosticsNode>[
+          ErrorSummary(
+            'SliverReorderableList.of() called with a context that does not contain a SliverReorderableList.',
+          ),
+          ErrorDescription(
+            'No SliverReorderableList ancestor could be found starting from the context that was passed to SliverReorderableList.of().',
+          ),
+          ErrorHint(
+            'This can happen when the context provided is from the same StatefulWidget that '
+            'built the SliverReorderableList. Please see the SliverReorderableList documentation for examples '
+            'of how to refer to an SliverReorderableList object:\n'
+            '  https://api.flutter.dev/flutter/widgets/SliverReorderableListState-class.html',
+          ),
+          context.describeElement('The context used was'),
+        ]);
+      }
+      return true;
+    }());
+    return result!;
+  }
+
+  /// The state from the closest instance of this class that encloses the given
+  /// context.
+  ///
+  /// This method is typically used by [SliverReorderableList] item widgets that
+  /// insert or remove items in response to user input.
+  ///
+  /// If no [SliverReorderableList] surrounds the context given, this function
+  /// will return null.
+  ///
+  /// This method can be expensive (it walks the element tree).
+  ///
+  /// See also:
+  ///
+  ///  * [of], a similar function that will throw if no [SliverReorderableList]
+  ///    ancestor is found.
+  static SliverReorderableListState? maybeOf(BuildContext context) {
+    return context.findAncestorStateOfType<SliverReorderableListState>();
+  }
+}
+
+/// The state for a sliver list that allows the user to interactively reorder
+/// the list items.
+///
+/// An app that needs to start a new item drag or cancel an existing one
+/// can refer to the [SliverReorderableList]'s state with a global key:
+///
+/// ```dart
+/// // (e.g. in a stateful widget)
+/// GlobalKey<SliverReorderableListState> listKey = GlobalKey<SliverReorderableListState>();
+///
+/// // ...
+///
+/// @override
+/// Widget build(BuildContext context) {
+///   return SliverReorderableList(
+///     key: listKey,
+///     itemBuilder: (BuildContext context, int index) => const SizedBox(height: 10.0),
+///     itemCount: 5,
+///     onReorder: (int oldIndex, int newIndex) {
+///        // ...
+///     },
+///   );
+/// }
+///
+/// // ...
+///
+/// void _stop() {
+///   listKey.currentState!.cancelReorder();
+/// }
+/// ```
+///
+/// [ReorderableDragStartListener] and [ReorderableDelayedDragStartListener]
+/// refer to their [SliverReorderableList] with the static
+/// [SliverReorderableList.of] method.
+class SliverReorderableListState extends State<SliverReorderableList>
+    with TickerProviderStateMixin {
+  // Map of index -> child state used manage where the dragging item will need
+  // to be inserted.
+  final Map<int, _ReorderableItemState> _items = <int, _ReorderableItemState>{};
+
+  OverlayEntry? _overlayEntry;
+  int? _dragIndex;
+  _DragInfo? _dragInfo;
+  int? _insertIndex;
+  Offset? _finalDropPosition;
+  MultiDragGestureRecognizer? _recognizer;
+  int? _recognizerPointer;
+  // To implement the gap for the dragged item, we replace the dragged item
+  // with a zero sized box, and then translate all of the later items down
+  // by the size of the dragged item. This allows us to keep the order of the
+  // list, while still being able to animate the gap between the items. However
+  // for the first frame of the drag, the item has not yet been replaced, so
+  // the calculation for the gap is off by the size of the gap. This flag is
+  // used to determine if the transition to the zero sized box has completed,
+  // so the gap calculation can compensate for it.
+  bool _dragStartTransitionComplete = false;
+
+  EdgeDraggingAutoScroller? _autoScroller;
+
+  late ScrollableState _scrollable;
+  Axis get _scrollDirection => axisDirectionToAxis(_scrollable.axisDirection);
+  bool get _reverse =>
+      _scrollable.axisDirection == AxisDirection.up ||
+      _scrollable.axisDirection == AxisDirection.left;
+
+  @override
+  void didChangeDependencies() {
+    super.didChangeDependencies();
+    _scrollable = Scrollable.of(context);
+    if (_autoScroller?.scrollable != _scrollable) {
+      _autoScroller?.stopAutoScroll();
+      _autoScroller = EdgeDraggingAutoScroller(_scrollable,
+          onScrollViewScrolled: _handleScrollableAutoScrolled);
+    }
+  }
+
+  @override
+  void didUpdateWidget(covariant SliverReorderableList oldWidget) {
+    super.didUpdateWidget(oldWidget);
+    if (widget.itemCount != oldWidget.itemCount) {
+      cancelReorder();
+    }
+  }
+
+  @override
+  void dispose() {
+    _dragReset();
+    super.dispose();
+  }
+
+  /// Initiate the dragging of the item at [index] that was started with
+  /// the pointer down [event].
+  ///
+  /// The given [recognizer] will be used to recognize and start the drag
+  /// item tracking and lead to either an item reorder, or a canceled drag.
+  ///
+  /// Most applications will not use this directly, but will wrap the item
+  /// (or part of the item, like a drag handle) in either a
+  /// [ReorderableDragStartListener] or [ReorderableDelayedDragStartListener]
+  /// which call this method when they detect the gesture that triggers a drag
+  /// start.
+  void startItemDragReorder({
+    required int index,
+    required PointerDownEvent event,
+    required MultiDragGestureRecognizer recognizer,
+  }) {
+    assert(0 <= index && index < widget.itemCount);
+    setState(() {
+      if (_dragInfo != null) {
+        cancelReorder();
+      } else if (_recognizer != null && _recognizerPointer != event.pointer) {
+        _recognizer!.dispose();
+        _recognizer = null;
+        _recognizerPointer = null;
+      }
+
+      if (_items.containsKey(index)) {
+        _dragIndex = index;
+        _recognizer = recognizer
+          ..onStart = _dragStart
+          ..addPointer(event);
+        _recognizerPointer = event.pointer;
+      } else {
+        // TODO(darrenaustin): Can we handle this better, maybe scroll to the item?
+        throw Exception('Attempting to start a drag on a non-visible item');
+      }
+    });
+  }
+
+  /// Cancel any item drag in progress.
+  ///
+  /// This should be called before any major changes to the item list
+  /// occur so that any item drags will not get confused by
+  /// changes to the underlying list.
+  ///
+  /// If a drag operation is in progress, this will immediately reset
+  /// the list to back to its pre-drag state.
+  ///
+  /// If no drag is active, this will do nothing.
+  void cancelReorder() {
+    setState(() {
+      _dragReset();
+    });
+  }
+
+  void _registerItem(_ReorderableItemState item) {
+    _items[item.index] = item;
+    if (item.index == _dragInfo?.index) {
+      item.dragging = true;
+      item.rebuild();
+    }
+  }
+
+  void _unregisterItem(int index, _ReorderableItemState item) {
+    final _ReorderableItemState? currentItem = _items[index];
+    if (currentItem == item) {
+      _items.remove(index);
+    }
+  }
+
+  Drag? _dragStart(Offset position) {
+    assert(_dragInfo == null);
+    final _ReorderableItemState item = _items[_dragIndex!]!;
+    item.dragging = true;
+    widget.onReorderStart?.call(_dragIndex!);
+    item.rebuild();
+    _dragStartTransitionComplete = false;
+    SchedulerBinding.instance.addPostFrameCallback((Duration duration) {
+      _dragStartTransitionComplete = true;
+    });
+
+    _insertIndex = item.index;
+    _dragInfo = _DragInfo(
+      item: item,
+      initialPosition: position,
+      scrollDirection: _scrollDirection,
+      onUpdate: _dragUpdate,
+      onCancel: _dragCancel,
+      onEnd: _dragEnd,
+      onDropCompleted: _dropCompleted,
+      proxyDecorator: widget.proxyDecorator,
+      tickerProvider: this,
+    );
+    _dragInfo!.startDrag();
+
+    final OverlayState overlay = Overlay.of(context, debugRequiredFor: widget);
+    assert(_overlayEntry == null);
+    _overlayEntry = OverlayEntry(builder: _dragInfo!.createProxy);
+    overlay.insert(_overlayEntry!);
+
+    for (final _ReorderableItemState childItem in _items.values) {
+      if (childItem == item || !childItem.mounted) {
+        continue;
+      }
+      childItem.updateForGap(
+          _insertIndex!, _dragInfo!.itemExtent, false, _reverse);
+    }
+    return _dragInfo;
+  }
+
+  void _dragUpdate(_DragInfo item, Offset position, Offset delta) {
+    setState(() {
+      _overlayEntry?.markNeedsBuild();
+      _dragUpdateItems();
+      _autoScroller?.startAutoScrollIfNecessary(_dragTargetRect);
+    });
+  }
+
+  void _dragCancel(_DragInfo item) {
+    setState(() {
+      _dragReset();
+    });
+  }
+
+  void _dragEnd(_DragInfo item) {
+    setState(() {
+      if (_insertIndex == item.index) {
+        _finalDropPosition = _itemOffsetAt(_insertIndex! + (_reverse ? 1 : 0));
+      } else if (_insertIndex! < widget.itemCount - 1) {
+        // Find the location of the item we want to insert before
+        _finalDropPosition = _itemOffsetAt(_insertIndex!);
+      } else {
+        // Inserting into the last spot on the list. If it's the only spot, put
+        // it back where it was. Otherwise, grab the second to last and move
+        // down by the gap.
+        final int itemIndex =
+            _items.length > 1 ? _insertIndex! - 1 : _insertIndex!;
+        if (_reverse) {
+          _finalDropPosition = _itemOffsetAt(itemIndex) -
+              _extentOffset(item.itemExtent, _scrollDirection);
+        } else {
+          _finalDropPosition = _itemOffsetAt(itemIndex) +
+              _extentOffset(item.itemExtent, _scrollDirection);
+        }
+      }
+    });
+    widget.onReorderEnd?.call(_insertIndex!);
+  }
+
+  void _dropCompleted() async {
+    final int fromIndex = _dragIndex!;
+    final int toIndex = _insertIndex!;
+    if (fromIndex != toIndex) {
+      await widget.onReorder.call(fromIndex, toIndex);
+    }
+    setState(() {
+      _dragReset();
+    });
+  }
+
+  void _dragReset() {
+    if (_dragInfo != null) {
+      if (_dragIndex != null && _items.containsKey(_dragIndex)) {
+        final _ReorderableItemState dragItem = _items[_dragIndex!]!;
+        dragItem._dragging = false;
+        dragItem.rebuild();
+        _dragIndex = null;
+      }
+      _dragInfo?.dispose();
+      _dragInfo = null;
+      _autoScroller?.stopAutoScroll();
+      _resetItemGap();
+      _recognizer?.dispose();
+      _recognizer = null;
+      _overlayEntry?.remove();
+      _overlayEntry = null;
+      _finalDropPosition = null;
+    }
+  }
+
+  void _resetItemGap() {
+    for (final _ReorderableItemState item in _items.values) {
+      item.resetGap();
+    }
+  }
+
+  void _handleScrollableAutoScrolled() {
+    if (_dragInfo == null) {
+      return;
+    }
+    _dragUpdateItems();
+    // Continue scrolling if the drag is still in progress.
+    _autoScroller?.startAutoScrollIfNecessary(_dragTargetRect);
+  }
+
+  void _dragUpdateItems() {
+    assert(_dragInfo != null);
+    final double gapExtent = _dragInfo!.itemExtent;
+    final double proxyItemStart = _offsetExtent(
+        _dragInfo!.dragPosition - _dragInfo!.dragOffset, _scrollDirection);
+    final double proxyItemEnd = proxyItemStart + gapExtent;
+
+    // Find the new index for inserting the item being dragged.
+    int newIndex = _insertIndex!;
+    for (final _ReorderableItemState item in _items.values) {
+      if (item.index == _dragIndex! || !item.mounted) {
+        continue;
+      }
+
+      Rect geometry = item.targetGeometry();
+      if (!_dragStartTransitionComplete && _dragIndex! <= item.index) {
+        // Transition is not complete, so each item after the dragged item is still
+        // in its normal location and not moved up for the zero sized box that will
+        // replace the dragged item.
+        final Offset transitionOffset =
+            _extentOffset(_reverse ? -gapExtent : gapExtent, _scrollDirection);
+        geometry = (geometry.topLeft - transitionOffset) & geometry.size;
+      }
+      final double itemStart =
+          _scrollDirection == Axis.vertical ? geometry.top : geometry.left;
+      final double itemExtent =
+          _scrollDirection == Axis.vertical ? geometry.height : geometry.width;
+      final double itemEnd = itemStart + itemExtent;
+      final double itemMiddle = itemStart + itemExtent / 2;
+
+      if (_reverse) {
+        if (itemEnd >= proxyItemEnd && proxyItemEnd >= itemMiddle) {
+          // The start of the proxy is in the beginning half of the item, so
+          // we should swap the item with the gap and we are done looking for
+          // the new index.
+          newIndex = item.index;
+          break;
+        } else if (itemMiddle >= proxyItemStart &&
+            proxyItemStart >= itemStart) {
+          // The end of the proxy is in the ending half of the item, so
+          // we should swap the item with the gap and we are done looking for
+          // the new index.
+          newIndex = item.index + 1;
+          break;
+        } else if (itemStart > proxyItemEnd && newIndex < (item.index + 1)) {
+          newIndex = item.index + 1;
+        } else if (proxyItemStart > itemEnd && newIndex > item.index) {
+          newIndex = item.index;
+        }
+      } else {
+        if (itemStart <= proxyItemStart && proxyItemStart <= itemMiddle) {
+          // The start of the proxy is in the beginning half of the item, so
+          // we should swap the item with the gap and we are done looking for
+          // the new index.
+          newIndex = item.index;
+          break;
+        } else if (itemMiddle <= proxyItemEnd && proxyItemEnd <= itemEnd) {
+          // The end of the proxy is in the ending half of the item, so
+          // we should swap the item with the gap and we are done looking for
+          // the new index.
+          newIndex = item.index + 1;
+          break;
+        } else if (itemEnd < proxyItemStart && newIndex < (item.index + 1)) {
+          newIndex = item.index + 1;
+        } else if (proxyItemEnd < itemStart && newIndex > item.index) {
+          newIndex = item.index;
+        }
+      }
+    }
+
+    if (newIndex != _insertIndex) {
+      _insertIndex = newIndex;
+      for (final _ReorderableItemState item in _items.values) {
+        if (item.index == _dragIndex! || !item.mounted) {
+          continue;
+        }
+        item.updateForGap(newIndex, gapExtent, true, _reverse);
+      }
+    }
+  }
+
+  Rect get _dragTargetRect {
+    final Offset origin = _dragInfo!.dragPosition - _dragInfo!.dragOffset;
+    return Rect.fromLTWH(origin.dx, origin.dy, _dragInfo!.itemSize.width,
+        _dragInfo!.itemSize.height);
+  }
+
+  Offset _itemOffsetAt(int index) {
+    final RenderBox itemRenderBox =
+        _items[index]!.context.findRenderObject()! as RenderBox;
+    return itemRenderBox.localToGlobal(Offset.zero);
+  }
+
+  Widget _itemBuilder(BuildContext context, int index) {
+    if (_dragInfo != null && index >= widget.itemCount) {
+      switch (_scrollDirection) {
+        case Axis.horizontal:
+          return SizedBox(width: _dragInfo!.itemExtent);
+        case Axis.vertical:
+          return SizedBox(height: _dragInfo!.itemExtent);
+      }
+    }
+    final Widget child = widget.itemBuilder(context, index);
+    assert(child.key != null, 'All list items must have a key');
+    final OverlayState overlay = Overlay.of(context, debugRequiredFor: widget);
+    return _ReorderableItem(
+      key: _ReorderableItemGlobalKey(child.key!, index, this),
+      index: index,
+      capturedThemes:
+          InheritedTheme.capture(from: context, to: overlay.context),
+      child: child,
+    );
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    assert(debugCheckHasOverlay(context));
+    final SliverChildBuilderDelegate childrenDelegate =
+        SliverChildBuilderDelegate(
+      _itemBuilder,
+      // When dragging, the dragged item is still in the list but has been replaced
+      // by a zero height SizedBox, so that the gap can move around. To make the
+      // list extent stable we add a dummy entry to the end.
+      childCount: widget.itemCount + (_dragInfo != null ? 1 : 0),
+      findChildIndexCallback: widget.findChildIndexCallback,
+    );
+    if (widget.itemExtent != null) {
+      return SliverFixedExtentList(
+        delegate: childrenDelegate,
+        itemExtent: widget.itemExtent!,
+      );
+    } else if (widget.prototypeItem != null) {
+      return SliverPrototypeExtentList(
+        delegate: childrenDelegate,
+        prototypeItem: widget.prototypeItem!,
+      );
+    }
+    return SliverList(delegate: childrenDelegate);
+  }
+}
+
+class _ReorderableItem extends StatefulWidget {
+  const _ReorderableItem({
+    required Key key,
+    required this.index,
+    required this.child,
+    required this.capturedThemes,
+  }) : super(key: key);
+
+  final int index;
+  final Widget child;
+  final CapturedThemes capturedThemes;
+
+  @override
+  _ReorderableItemState createState() => _ReorderableItemState();
+}
+
+class _ReorderableItemState extends State<_ReorderableItem> {
+  late SliverReorderableListState _listState;
+
+  Offset _startOffset = Offset.zero;
+  Offset _targetOffset = Offset.zero;
+  AnimationController? _offsetAnimation;
+
+  Key get key => widget.key!;
+  int get index => widget.index;
+
+  bool get dragging => _dragging;
+  set dragging(bool dragging) {
+    if (mounted) {
+      setState(() {
+        _dragging = dragging;
+      });
+    }
+  }
+
+  bool _dragging = false;
+
+  @override
+  void initState() {
+    _listState = SliverReorderableList.of(context);
+    _listState._registerItem(this);
+    super.initState();
+  }
+
+  @override
+  void dispose() {
+    _offsetAnimation?.dispose();
+    _listState._unregisterItem(index, this);
+    super.dispose();
+  }
+
+  @override
+  void didUpdateWidget(covariant _ReorderableItem oldWidget) {
+    super.didUpdateWidget(oldWidget);
+    if (oldWidget.index != widget.index) {
+      _listState._unregisterItem(oldWidget.index, this);
+      _listState._registerItem(this);
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    if (_dragging) {
+      return const SizedBox();
+    }
+    _listState._registerItem(this);
+    return Transform(
+      transform: Matrix4.translationValues(offset.dx, offset.dy, 0.0),
+      child: widget.child,
+    );
+  }
+
+  @override
+  void deactivate() {
+    _listState._unregisterItem(index, this);
+    super.deactivate();
+  }
+
+  Offset get offset {
+    if (_offsetAnimation != null) {
+      final double animValue =
+          Curves.easeInOut.transform(_offsetAnimation!.value);
+      return Offset.lerp(_startOffset, _targetOffset, animValue)!;
+    }
+    return _targetOffset;
+  }
+
+  void updateForGap(
+      int gapIndex, double gapExtent, bool animate, bool reverse) {
+    final Offset newTargetOffset = (gapIndex <= index)
+        ? _extentOffset(
+            reverse ? -gapExtent : gapExtent, _listState._scrollDirection)
+        : Offset.zero;
+    if (newTargetOffset != _targetOffset) {
+      _targetOffset = newTargetOffset;
+      if (animate) {
+        if (_offsetAnimation == null) {
+          _offsetAnimation = AnimationController(
+            vsync: _listState,
+            duration: const Duration(milliseconds: 250),
+          )
+            ..addListener(rebuild)
+            ..addStatusListener((AnimationStatus status) {
+              if (status == AnimationStatus.completed) {
+                _startOffset = _targetOffset;
+                _offsetAnimation!.dispose();
+                _offsetAnimation = null;
+              }
+            })
+            ..forward();
+        } else {
+          _startOffset = offset;
+          _offsetAnimation!.forward(from: 0.0);
+        }
+      } else {
+        if (_offsetAnimation != null) {
+          _offsetAnimation!.dispose();
+          _offsetAnimation = null;
+        }
+        _startOffset = _targetOffset;
+      }
+      rebuild();
+    }
+  }
+
+  void resetGap() {
+    if (_offsetAnimation != null) {
+      _offsetAnimation!.dispose();
+      _offsetAnimation = null;
+    }
+    _startOffset = Offset.zero;
+    _targetOffset = Offset.zero;
+    rebuild();
+  }
+
+  Rect targetGeometry() {
+    final RenderBox itemRenderBox = context.findRenderObject()! as RenderBox;
+    final Offset itemPosition =
+        itemRenderBox.localToGlobal(Offset.zero) + _targetOffset;
+    return itemPosition & itemRenderBox.size;
+  }
+
+  void rebuild() {
+    if (mounted) {
+      setState(() {});
+    }
+  }
+}
+
+/// A wrapper widget that will recognize the start of a drag on the wrapped
+/// widget by a [PointerDownEvent], and immediately initiate dragging the
+/// wrapped item to a new location in a reorderable list.
+///
+/// See also:
+///
+///  * [ReorderableDelayedDragStartListener], a similar wrapper that will
+///    only recognize the start after a long press event.
+///  * [ReorderableList], a widget list that allows the user to reorder
+///    its items.
+///  * [SliverReorderableList], a sliver list that allows the user to reorder
+///    its items.
+///  * [ReorderableListView], a Material Design list that allows the user to
+///    reorder its items.
+class ReorderableDragStartListener extends StatelessWidget {
+  /// Creates a listener for a drag immediately following a pointer down
+  /// event over the given child widget.
+  ///
+  /// This is most commonly used to wrap part of a list item like a drag
+  /// handle.
+  const ReorderableDragStartListener({
+    super.key,
+    required this.child,
+    required this.index,
+    this.enabled = true,
+  });
+
+  /// The widget for which the application would like to respond to a tap and
+  /// drag gesture by starting a reordering drag on a reorderable list.
+  final Widget child;
+
+  /// The index of the associated item that will be dragged in the list.
+  final int index;
+
+  /// Whether the [child] item can be dragged and moved in the list.
+  ///
+  /// If true, the item can be moved to another location in the list when the
+  /// user taps on the child. If false, tapping on the child will be ignored.
+  final bool enabled;
+
+  @override
+  Widget build(BuildContext context) {
+    return Listener(
+      onPointerDown: enabled
+          ? (PointerDownEvent event) => _startDragging(context, event)
+          : null,
+      child: child,
+    );
+  }
+
+  /// Provides the gesture recognizer used to indicate the start of a reordering
+  /// drag operation.
+  ///
+  /// By default this returns an [ImmediateMultiDragGestureRecognizer] but
+  /// subclasses can use this to customize the drag start gesture.
+  @protected
+  MultiDragGestureRecognizer createRecognizer() {
+    return ImmediateMultiDragGestureRecognizer(debugOwner: this);
+  }
+
+  void _startDragging(BuildContext context, PointerDownEvent event) {
+    final DeviceGestureSettings? gestureSettings =
+        MediaQuery.maybeOf(context)?.gestureSettings;
+    final SliverReorderableListState? list =
+        SliverReorderableList.maybeOf(context);
+    list?.startItemDragReorder(
+      index: index,
+      event: event,
+      recognizer: createRecognizer()..gestureSettings = gestureSettings,
+    );
+  }
+}
+
+/// A wrapper widget that will recognize the start of a drag operation by
+/// looking for a long press event. Once it is recognized, it will start
+/// a drag operation on the wrapped item in the reorderable list.
+///
+/// See also:
+///
+///  * [ReorderableDragStartListener], a similar wrapper that will
+///    recognize the start of the drag immediately after a pointer down event.
+///  * [ReorderableList], a widget list that allows the user to reorder
+///    its items.
+///  * [SliverReorderableList], a sliver list that allows the user to reorder
+///    its items.
+///  * [ReorderableListView], a Material Design list that allows the user to
+///    reorder its items.
+class ReorderableDelayedDragStartListener extends ReorderableDragStartListener {
+  /// Creates a listener for an drag following a long press event over the
+  /// given child widget.
+  ///
+  /// This is most commonly used to wrap an entire list item in a reorderable
+  /// list.
+  const ReorderableDelayedDragStartListener({
+    super.key,
+    required super.child,
+    required super.index,
+    super.enabled,
+  });
+
+  @override
+  MultiDragGestureRecognizer createRecognizer() {
+    return DelayedMultiDragGestureRecognizer(debugOwner: this);
+  }
+}
+
+typedef _DragItemUpdate = void Function(
+    _DragInfo item, Offset position, Offset delta);
+typedef _DragItemCallback = void Function(_DragInfo item);
+
+class _DragInfo extends Drag {
+  _DragInfo({
+    required _ReorderableItemState item,
+    Offset initialPosition = Offset.zero,
+    this.scrollDirection = Axis.vertical,
+    this.onUpdate,
+    this.onEnd,
+    this.onCancel,
+    this.onDropCompleted,
+    this.proxyDecorator,
+    required this.tickerProvider,
+  }) {
+    final RenderBox itemRenderBox =
+        item.context.findRenderObject()! as RenderBox;
+    listState = item._listState;
+    index = item.index;
+    child = item.widget.child;
+    capturedThemes = item.widget.capturedThemes;
+    dragPosition = initialPosition;
+    dragOffset = itemRenderBox.globalToLocal(initialPosition);
+    itemSize = item.context.size!;
+    itemExtent = _sizeExtent(itemSize, scrollDirection);
+    scrollable = Scrollable.of(item.context);
+  }
+
+  final Axis scrollDirection;
+  final _DragItemUpdate? onUpdate;
+  final _DragItemCallback? onEnd;
+  final _DragItemCallback? onCancel;
+  final VoidCallback? onDropCompleted;
+  final ReorderItemProxyDecorator? proxyDecorator;
+  final TickerProvider tickerProvider;
+
+  late SliverReorderableListState listState;
+  late int index;
+  late Widget child;
+  late Offset dragPosition;
+  late Offset dragOffset;
+  late Size itemSize;
+  late double itemExtent;
+  late CapturedThemes capturedThemes;
+  ScrollableState? scrollable;
+  AnimationController? _proxyAnimation;
+
+  void dispose() {
+    _proxyAnimation?.dispose();
+  }
+
+  void startDrag() {
+    _proxyAnimation = AnimationController(
+      vsync: tickerProvider,
+      duration: const Duration(milliseconds: 250),
+    )
+      ..addStatusListener((AnimationStatus status) {
+        if (status == AnimationStatus.dismissed) {
+          _dropCompleted();
+        }
+      })
+      ..forward();
+  }
+
+  @override
+  void update(DragUpdateDetails details) {
+    final Offset delta = _restrictAxis(details.delta, scrollDirection);
+    dragPosition += delta;
+    onUpdate?.call(this, dragPosition, details.delta);
+  }
+
+  @override
+  void end(DragEndDetails details) {
+    _proxyAnimation!.reverse();
+    onEnd?.call(this);
+  }
+
+  @override
+  void cancel() {
+    _proxyAnimation?.dispose();
+    _proxyAnimation = null;
+    onCancel?.call(this);
+  }
+
+  void _dropCompleted() {
+    _proxyAnimation?.dispose();
+    _proxyAnimation = null;
+    onDropCompleted?.call();
+  }
+
+  Widget createProxy(BuildContext context) {
+    return capturedThemes.wrap(
+      _proxyAnimation == null
+          ? SizedBox.shrink()
+          : _DragItemProxy(
+              listState: listState,
+              index: index,
+              size: itemSize,
+              animation: _proxyAnimation!,
+              position: dragPosition - dragOffset - _overlayOrigin(context),
+              proxyDecorator: proxyDecorator,
+              child: child,
+            ),
+    );
+  }
+}
+
+Offset _overlayOrigin(BuildContext context) {
+  final OverlayState overlay =
+      Overlay.of(context, debugRequiredFor: context.widget);
+  final RenderBox overlayBox = overlay.context.findRenderObject()! as RenderBox;
+  return overlayBox.localToGlobal(Offset.zero);
+}
+
+class _DragItemProxy extends StatelessWidget {
+  const _DragItemProxy({
+    required this.listState,
+    required this.index,
+    required this.child,
+    required this.position,
+    required this.size,
+    required this.animation,
+    required this.proxyDecorator,
+  });
+
+  final SliverReorderableListState listState;
+  final int index;
+  final Widget child;
+  final Offset position;
+  final Size size;
+  final AnimationController animation;
+  final ReorderItemProxyDecorator? proxyDecorator;
+
+  @override
+  Widget build(BuildContext context) {
+    final Widget proxyChild =
+        proxyDecorator?.call(child, index, animation.view) ?? child;
+    final Offset overlayOrigin = _overlayOrigin(context);
+
+    return MediaQuery(
+      // Remove the top padding so that any nested list views in the item
+      // won't pick up the scaffold's padding in the overlay.
+      data: MediaQuery.of(context).removePadding(removeTop: true),
+      child: AnimatedBuilder(
+        animation: animation,
+        builder: (BuildContext context, Widget? child) {
+          Offset effectivePosition = position;
+          final Offset? dropPosition = listState._finalDropPosition;
+          if (dropPosition != null) {
+            effectivePosition = Offset.lerp(dropPosition - overlayOrigin,
+                effectivePosition, Curves.easeOut.transform(animation.value))!;
+          }
+          return Positioned(
+            left: effectivePosition.dx,
+            top: effectivePosition.dy,
+            child: SizedBox(
+              width: size.width,
+              height: size.height,
+              child: child,
+            ),
+          );
+        },
+        child: proxyChild,
+      ),
+    );
+  }
+}
+
+double _sizeExtent(Size size, Axis scrollDirection) {
+  switch (scrollDirection) {
+    case Axis.horizontal:
+      return size.width;
+    case Axis.vertical:
+      return size.height;
+  }
+}
+
+double _offsetExtent(Offset offset, Axis scrollDirection) {
+  switch (scrollDirection) {
+    case Axis.horizontal:
+      return offset.dx;
+    case Axis.vertical:
+      return offset.dy;
+  }
+}
+
+Offset _extentOffset(double extent, Axis scrollDirection) {
+  switch (scrollDirection) {
+    case Axis.horizontal:
+      return Offset(extent, 0.0);
+    case Axis.vertical:
+      return Offset(0.0, extent);
+  }
+}
+
+Offset _restrictAxis(Offset offset, Axis scrollDirection) {
+  switch (scrollDirection) {
+    case Axis.horizontal:
+      return Offset(offset.dx, 0.0);
+    case Axis.vertical:
+      return Offset(0.0, offset.dy);
+  }
+}
+
+// A global key that takes its identity from the object and uses a value of a
+// particular type to identify itself.
+//
+// The difference with GlobalObjectKey is that it uses [==] instead of [identical]
+// of the objects used to generate widgets.
+@optionalTypeArgs
+class _ReorderableItemGlobalKey extends GlobalObjectKey {
+  const _ReorderableItemGlobalKey(this.subKey, this.index, this.state)
+      : super(subKey);
+
+  final Key subKey;
+  final int index;
+  final SliverReorderableListState state;
+
+  @override
+  bool operator ==(Object other) {
+    if (other.runtimeType != runtimeType) {
+      return false;
+    }
+    return other is _ReorderableItemGlobalKey &&
+        other.subKey == subKey &&
+        other.index == index &&
+        other.state == state;
+  }
+
+  @override
+  int get hashCode => Object.hash(subKey, index, state);
+}
diff --git a/budget/lib/widgets/accountAndBackup.dart b/budget/lib/widgets/accountAndBackup.dart
index 48b5941f3..e4fcf4424 100644
--- a/budget/lib/widgets/accountAndBackup.dart
+++ b/budget/lib/widgets/accountAndBackup.dart
@@ -423,6 +423,8 @@ Future<bool> syncData() async {
         await database.getWalletInstance(appStateSettings["selectedWallet"]);
     updateSettings("selectedWalletCurrency", selectedWallet.currency,
         updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
+    updateSettings("selectedWalletDecimals", selectedWallet.decimals,
+        updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
   } catch (e) {
     print("Selected wallet not found: " + e.toString());
     await setPrimaryWallet((await database.getAllWallets())[0]);
diff --git a/budget/lib/widgets/editRowEntry.dart b/budget/lib/widgets/editRowEntry.dart
index 5b8aa9bfe..d264f4523 100644
--- a/budget/lib/widgets/editRowEntry.dart
+++ b/budget/lib/widgets/editRowEntry.dart
@@ -1,12 +1,20 @@
+import 'package:budget/colors.dart';
+import 'package:budget/functions.dart';
+import 'package:budget/main.dart';
 import 'package:budget/widgets/openContainerNavigation.dart';
 import 'package:budget/widgets/tappable.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart'
+    hide
+        SliverReorderableList,
+        ReorderableDragStartListener,
+        ReorderableDelayedDragStartListener;
+import 'package:budget/struct/reorderable_list.dart';
 
 class EditRowEntry extends StatelessWidget {
   const EditRowEntry(
       {required this.index,
       required this.content,
-      required this.backgroundColor,
+      this.backgroundColor,
       required this.openPage,
       required this.onDelete,
       this.onTap,
@@ -20,7 +28,7 @@ class EditRowEntry extends StatelessWidget {
       : super(key: key);
   final int index;
   final Widget content;
-  final Color backgroundColor;
+  final Color? backgroundColor;
   final Widget openPage;
   final VoidCallback onDelete;
   final EdgeInsets? padding;
@@ -33,92 +41,222 @@ class EditRowEntry extends StatelessWidget {
 
   @override
   Widget build(BuildContext context) {
-    Widget container = OpenContainerNavigation(
-      openPage: openPage,
-      closedColor: backgroundColor,
-      borderRadius: 18,
-      button: (openContainer) {
-        return Tappable(
-          borderRadius: 18,
-          color: backgroundColor,
-          onTap: () {
-            FocusScopeNode currentFocus = FocusScope.of(context);
-            if (!currentFocus.hasPrimaryFocus) {
-              currentFocus.unfocus();
-            }
-            if (onTap != null)
-              onTap!();
-            else
-              openContainer();
-          },
-          child: IntrinsicHeight(
-            child: Row(
-              crossAxisAlignment: CrossAxisAlignment.center,
-              mainAxisSize: MainAxisSize.max,
-              children: [
-                Expanded(
-                  child: Container(
-                    padding: padding ??
-                        EdgeInsets.only(
-                          left: 25,
-                          right: 10,
-                          top: 15,
-                          bottom: 15,
-                        ),
-                    child: content,
+    Widget container = Container(
+      decoration: BoxDecoration(
+        boxShadow: appStateSettings["materialYou"]
+            ? []
+            : boxShadowCheck(boxShadowGeneral(context)),
+      ),
+      child: OpenContainerNavigation(
+        openPage: openPage,
+        closedColor: appStateSettings["materialYou"]
+            ? dynamicPastel(
+                context,
+                Theme.of(context).colorScheme.secondaryContainer,
+                amount: 0.5,
+              )
+            : getColor(context, "lightDarkAccentHeavyLight"),
+        borderRadius: 18,
+        button: (openContainer) {
+          return Tappable(
+            borderRadius: 18,
+            color: appStateSettings["materialYou"]
+                ? dynamicPastel(
+                    context,
+                    Theme.of(context).colorScheme.secondaryContainer,
+                    amount: 0.5,
+                  )
+                : getColor(context, "lightDarkAccentHeavyLight"),
+            onTap: () {
+              FocusScopeNode currentFocus = FocusScope.of(context);
+              if (!currentFocus.hasPrimaryFocus) {
+                currentFocus.unfocus();
+              }
+              if (onTap != null)
+                onTap!();
+              else
+                openContainer();
+            },
+            child: IntrinsicHeight(
+              child: Row(
+                crossAxisAlignment: CrossAxisAlignment.center,
+                mainAxisSize: MainAxisSize.max,
+                children: [
+                  backgroundColor != null
+                      ? Container(
+                          width: 5,
+                          color: dynamicPastel(
+                            context,
+                            backgroundColor!,
+                            amount: 0.1,
+                            inverse: true,
+                          ),
+                        )
+                      : SizedBox.shrink(),
+                  Expanded(
+                    child: Container(
+                      padding: padding ??
+                          EdgeInsets.only(
+                            left: 25 - 3,
+                            right: 10,
+                            top: 15,
+                            bottom: 15,
+                          ),
+                      child: content,
+                    ),
                   ),
-                ),
-                extraIcon != null
-                    ? Tappable(
-                        color: Colors.transparent,
-                        borderRadius: 18,
-                        child: Container(
-                            height: double.infinity,
-                            width: 40,
-                            child: Icon(extraIcon)),
-                        onTap: onExtra,
-                      )
-                    : SizedBox.shrink(),
-                canDelete
-                    ? Tappable(
-                        color: Colors.transparent,
-                        borderRadius: 18,
-                        child: Container(
-                            height: double.infinity,
-                            width: 40,
-                            child: Icon(Icons.delete_rounded)),
-                        onTap: onDelete,
-                      )
-                    : SizedBox.shrink(),
-                canReorder
-                    ? ReorderableDragStartListener(
-                        index: index,
-                        child: Tappable(
+                  extraIcon != null
+                      ? Tappable(
                           color: Colors.transparent,
                           borderRadius: 18,
                           child: Container(
-                              margin: EdgeInsets.only(right: 10),
+                              height: double.infinity,
                               width: 40,
+                              child: Icon(extraIcon)),
+                          onTap: onExtra,
+                        )
+                      : SizedBox.shrink(),
+                  canDelete
+                      ? Tappable(
+                          color: Colors.transparent,
+                          borderRadius: 18,
+                          child: Container(
                               height: double.infinity,
-                              child: Icon(Icons.drag_handle_rounded)),
-                          onTap: () {},
-                        ),
-                      )
-                    : Opacity(
-                        opacity: 0.2,
-                        child: Container(
-                          margin: EdgeInsets.only(right: 10),
-                          width: 40,
-                          height: double.infinity,
-                          child: Icon(Icons.drag_handle_rounded),
+                              width: 40,
+                              child: Icon(Icons.delete_rounded)),
+                          onTap: onDelete,
+                        )
+                      : SizedBox.shrink(),
+                  canReorder
+                      ? ReorderableDragStartListener(
+                          index: index,
+                          child: Tappable(
+                            color: Colors.transparent,
+                            borderRadius: 18,
+                            child: Container(
+                                margin: EdgeInsets.only(right: 10),
+                                width: 40,
+                                height: double.infinity,
+                                child: Icon(Icons.drag_handle_rounded)),
+                            onTap: () {},
+                          ),
+                        )
+                      : Opacity(
+                          opacity: 0.2,
+                          child: Container(
+                            margin: EdgeInsets.only(right: 10),
+                            width: 40,
+                            height: double.infinity,
+                            child: Icon(Icons.drag_handle_rounded),
+                          ),
                         ),
-                      ),
-              ],
+                ],
+              ),
             ),
-          ),
-        );
-      },
+          );
+        },
+      ),
     );
+    // alternative theme:
+    // container = OpenContainerNavigation(
+    //   openPage: openPage,
+    //   closedColor: dynamicPastel(context, backgroundColor, amount: 0.6),
+    //   borderRadius: 15,
+    //   button: (openContainer) {
+    //     return Tappable(
+    //       borderRadius: 15,
+    //       color: dynamicPastel(context, backgroundColor, amount: 0.6),
+    //       onTap: () {
+    //         FocusScopeNode currentFocus = FocusScope.of(context);
+    //         if (!currentFocus.hasPrimaryFocus) {
+    //           currentFocus.unfocus();
+    //         }
+    //         if (onTap != null)
+    //           onTap!();
+    //         else
+    //           openContainer();
+    //       },
+    //       child: Container(
+    //         decoration: BoxDecoration(
+    //           border: Border.all(
+    //             color: dynamicPastel(
+    //                 context,
+    //                 dynamicPastel(context, backgroundColor,
+    //                     inverse: true, amount: 0.3),
+    //                 amount: 0.3),
+    //             width: 2,
+    //           ),
+    //           borderRadius: BorderRadius.circular(15),
+    //         ),
+    //         child: IntrinsicHeight(
+    //           child: Row(
+    //             crossAxisAlignment: CrossAxisAlignment.center,
+    //             mainAxisSize: MainAxisSize.max,
+    //             children: [
+    //               Expanded(
+    //                 child: Container(
+    //                   padding: padding ??
+    //                       EdgeInsets.only(
+    //                         left: 25,
+    //                         right: 10,
+    //                         top: 15,
+    //                         bottom: 15,
+    //                       ),
+    //                   child: content,
+    //                 ),
+    //               ),
+    //               extraIcon != null
+    //                   ? Tappable(
+    //                       color: Colors.transparent,
+    //                       borderRadius: 18,
+    //                       child: Container(
+    //                           height: double.infinity,
+    //                           width: 40,
+    //                           child: Icon(extraIcon)),
+    //                       onTap: onExtra,
+    //                     )
+    //                   : SizedBox.shrink(),
+    //               canDelete
+    //                   ? Tappable(
+    //                       color: Colors.transparent,
+    //                       borderRadius: 18,
+    //                       child: Container(
+    //                           height: double.infinity,
+    //                           width: 40,
+    //                           child: Icon(Icons.delete_rounded)),
+    //                       onTap: onDelete,
+    //                     )
+    //                   : SizedBox.shrink(),
+    //               canReorder
+    //                   ? ReorderableDragStartListener(
+    //                       index: index,
+    //                       child: Tappable(
+    //                         color: Colors.transparent,
+    //                         borderRadius: 18,
+    //                         child: Container(
+    //                             margin: EdgeInsets.only(right: 10),
+    //                             width: 40,
+    //                             height: double.infinity,
+    //                             child: Icon(Icons.drag_handle_rounded)),
+    //                         onTap: () {},
+    //                       ),
+    //                     )
+    //                   : Opacity(
+    //                       opacity: 0.2,
+    //                       child: Container(
+    //                         margin: EdgeInsets.only(right: 10),
+    //                         width: 40,
+    //                         height: double.infinity,
+    //                         child: Icon(Icons.drag_handle_rounded),
+    //                       ),
+    //                     ),
+    //             ],
+    //           ),
+    //         ),
+    //       ),
+    //     );
+    //   },
+    // );
     if (!canReorder) {
       return Padding(
         padding: EdgeInsets.symmetric(horizontal: 10, vertical: 5),
diff --git a/budget/lib/widgets/fadeIn.dart b/budget/lib/widgets/fadeIn.dart
index 6e6ea0ce0..6bb048792 100644
--- a/budget/lib/widgets/fadeIn.dart
+++ b/budget/lib/widgets/fadeIn.dart
@@ -228,7 +228,7 @@ class CountNumber extends StatefulWidget {
     this.duration = const Duration(milliseconds: 3000),
     this.curve = Curves.easeOutQuint,
     this.initialCount = 0,
-    this.decimals = 2,
+    this.decimals,
     this.dynamicDecimals = false,
     this.lazyFirstRender = true,
   }) : super(key: key);
@@ -239,7 +239,7 @@ class CountNumber extends StatefulWidget {
   final Duration duration;
   final Curve curve;
   final double initialCount;
-  final int decimals;
+  final int? decimals;
   final bool dynamicDecimals;
   final bool lazyFirstRender;
 
@@ -248,14 +248,22 @@ class CountNumber extends StatefulWidget {
 }
 
 class _CountNumberState extends State<CountNumber> {
+  late int finalDecimalPlaces =
+      ((widget.decimals ?? appStateSettings["selectedWalletDecimals"]) > 2
+          ? widget.count.toString().split('.')[1].length <
+                  (widget.decimals ??
+                      appStateSettings["selectedWalletDecimals"])
+              ? widget.count.toString().split('.')[1].length
+              : (widget.decimals ?? appStateSettings["selectedWalletDecimals"])
+          : (widget.decimals ?? appStateSettings["selectedWalletDecimals"]));
   double previousAmount = 0;
-  int decimals = 2;
+  late int decimals = finalDecimalPlaces;
   bool lazyFirstRender = true;
   @override
   void initState() {
     super.initState();
     previousAmount = widget.initialCount;
-    decimals = widget.decimals;
+    decimals = finalDecimalPlaces;
     lazyFirstRender = widget.lazyFirstRender;
   }
 
@@ -265,13 +273,22 @@ class _CountNumberState extends State<CountNumber> {
       if (widget.count % 1 == 0) {
         decimals = 0;
       } else {
-        decimals = widget.decimals;
+        decimals =
+            ((widget.decimals ?? appStateSettings["selectedWalletDecimals"]) > 2
+                ? widget.count.toString().split('.')[1].length <
+                        (widget.decimals ??
+                            appStateSettings["selectedWalletDecimals"])
+                    ? widget.count.toString().split('.')[1].length
+                    : (widget.decimals ??
+                        appStateSettings["selectedWalletDecimals"])
+                : (widget.decimals ??
+                    appStateSettings["selectedWalletDecimals"]));
       }
     }
 
     if (appStateSettings["batterySaver"]) {
       return widget.textBuilder(
-        double.parse((widget.count).toStringAsFixed(widget.decimals)),
+        double.parse((widget.count).toStringAsFixed(finalDecimalPlaces)),
       );
     }
 
diff --git a/budget/lib/widgets/noResults.dart b/budget/lib/widgets/noResults.dart
index d52e58b77..8aac79fec 100644
--- a/budget/lib/widgets/noResults.dart
+++ b/budget/lib/widgets/noResults.dart
@@ -4,16 +4,21 @@ import 'package:budget/widgets/textWidgets.dart';
 import 'package:flutter/material.dart';
 
 class NoResults extends StatelessWidget {
-  const NoResults({Key? key, required this.message, this.tintColor})
-      : super(key: key);
+  const NoResults({
+    Key? key,
+    required this.message,
+    this.tintColor,
+    this.padding = const EdgeInsets.only(top: 35, right: 30, left: 30),
+  }) : super(key: key);
   final String message;
   final Color? tintColor;
+  final EdgeInsets padding;
 
   @override
   Widget build(BuildContext context) {
     return Center(
       child: Padding(
-        padding: const EdgeInsets.only(top: 35, right: 30, left: 30),
+        padding: padding,
         child: Column(
           children: [
             Container(
diff --git a/budget/lib/widgets/openPopup.dart b/budget/lib/widgets/openPopup.dart
index 327d5d292..99c900861 100644
--- a/budget/lib/widgets/openPopup.dart
+++ b/budget/lib/widgets/openPopup.dart
@@ -99,8 +99,13 @@ Future<T?> openPopup<T extends Object?>(
           child: ConstrainedBox(
             constraints: BoxConstraints(maxWidth: getWidthBottomSheet(context)),
             child: Container(
-              padding: EdgeInsets.symmetric(horizontal: 25, vertical: 10),
-              margin: EdgeInsets.symmetric(horizontal: 20),
+              padding: EdgeInsets.symmetric(horizontal: 25, vertical: 0),
+              margin: EdgeInsets.only(
+                left: 20,
+                right: 20,
+                top: MediaQuery.of(context).padding.top + 20,
+                bottom: MediaQuery.of(context).padding.bottom + 20,
+              ),
               decoration: BoxDecoration(
                 color: appStateSettings["materialYou"]
                     ? dynamicPastel(context,
@@ -110,114 +115,116 @@ Future<T?> openPopup<T extends Object?>(
                 borderRadius: BorderRadius.circular(22),
                 boxShadow: boxShadowGeneral(context),
               ),
-              child: Column(
-                mainAxisSize: MainAxisSize.min,
-                children: [
-                  SizedBox(height: 7),
-                  Padding(
-                    padding: const EdgeInsets.symmetric(
-                        vertical: 8.0, horizontal: 10),
-                    child: Icon(
-                      icon,
-                      size: 65,
-                      color: Theme.of(context).colorScheme.primary,
+              child: SingleChildScrollView(
+                child: Column(
+                  mainAxisSize: MainAxisSize.min,
+                  children: [
+                    SizedBox(height: 17),
+                    Padding(
+                      padding: const EdgeInsets.symmetric(
+                          vertical: 8.0, horizontal: 10),
+                      child: Icon(
+                        icon,
+                        size: 65,
+                        color: Theme.of(context).colorScheme.primary,
+                      ),
                     ),
-                  ),
-                  Padding(
-                    padding: const EdgeInsets.symmetric(
-                        vertical: 8.0, horizontal: 10),
-                    child: TextFont(
-                      textAlign: TextAlign.center,
-                      text: title ?? "",
-                      fontSize: 23,
-                      fontWeight: FontWeight.bold,
-                      maxLines: 5,
-                      textColor:
-                          Theme.of(context).colorScheme.onPrimaryContainer,
+                    Padding(
+                      padding: const EdgeInsets.symmetric(
+                          vertical: 8.0, horizontal: 10),
+                      child: TextFont(
+                        textAlign: TextAlign.center,
+                        text: title ?? "",
+                        fontSize: 23,
+                        fontWeight: FontWeight.bold,
+                        maxLines: 5,
+                        textColor:
+                            Theme.of(context).colorScheme.onPrimaryContainer,
+                      ),
                     ),
-                  ),
-                  description != "" && description != null
-                      ? Padding(
-                          padding: const EdgeInsets.symmetric(
-                              vertical: 8.0, horizontal: 10),
-                          child: TextFont(
-                            textAlign: TextAlign.center,
-                            text: description,
-                            fontSize: 17,
-                            maxLines: 100,
-                          ),
-                        )
-                      : SizedBox.shrink(),
-                  onSubmitLabel != null || onCancelLabel != null
-                      ? Padding(
-                          padding: const EdgeInsets.symmetric(vertical: 16.0),
-                          child: Wrap(
-                            alignment: WrapAlignment.center,
-                            runSpacing: 10,
-                            children: [
-                              Row(
-                                mainAxisAlignment: MainAxisAlignment.center,
-                                mainAxisSize: MainAxisSize.min,
-                                children: [
-                                  onCancelLabel != null
-                                      ? Padding(
-                                          padding: const EdgeInsets.symmetric(
-                                              horizontal: 8.0),
-                                          child: Button(
-                                              color: Theme.of(context)
-                                                  .colorScheme
-                                                  .secondaryContainer,
-                                              label: onCancelLabel,
-                                              height: 50,
-                                              onTap: onCancel ?? () {}),
-                                        )
-                                      : SizedBox.shrink(),
-                                ],
-                              ),
-                              Row(
-                                mainAxisAlignment: MainAxisAlignment.center,
-                                mainAxisSize: MainAxisSize.min,
-                                children: [
-                                  onExtraLabel != null
-                                      ? Padding(
-                                          padding: const EdgeInsets.symmetric(
-                                              horizontal: 8.0),
-                                          child: Button(
-                                              color: Theme.of(context)
-                                                  .colorScheme
-                                                  .secondaryContainer,
-                                              label: onExtraLabel,
-                                              height: 50,
-                                              onTap: onExtra ?? () {}),
-                                        )
-                                      : SizedBox.shrink(),
-                                ],
-                              ),
-                              Row(
-                                mainAxisAlignment: MainAxisAlignment.center,
-                                mainAxisSize: MainAxisSize.min,
-                                children: [
-                                  onSubmitLabel != null
-                                      ? Padding(
-                                          padding: const EdgeInsets.symmetric(
-                                              horizontal: 8.0),
-                                          child: Button(
-                                              color: Theme.of(context)
-                                                  .colorScheme
-                                                  .tertiaryContainer,
-                                              label: onSubmitLabel,
-                                              height: 50,
-                                              onTap: onSubmit ?? () {}),
-                                        )
-                                      : SizedBox.shrink(),
-                                ],
-                              ),
-                            ],
-                          ),
-                        )
-                      : SizedBox.shrink(),
-                  SizedBox(height: 6),
-                ],
+                    description != "" && description != null
+                        ? Padding(
+                            padding: const EdgeInsets.symmetric(
+                                vertical: 8.0, horizontal: 10),
+                            child: TextFont(
+                              textAlign: TextAlign.center,
+                              text: description,
+                              fontSize: 17,
+                              maxLines: 100,
+                            ),
+                          )
+                        : SizedBox.shrink(),
+                    onSubmitLabel != null || onCancelLabel != null
+                        ? Padding(
+                            padding: const EdgeInsets.symmetric(vertical: 16.0),
+                            child: Wrap(
+                              alignment: WrapAlignment.center,
+                              runSpacing: 10,
+                              children: [
+                                Row(
+                                  mainAxisAlignment: MainAxisAlignment.center,
+                                  mainAxisSize: MainAxisSize.min,
+                                  children: [
+                                    onCancelLabel != null
+                                        ? Padding(
+                                            padding: const EdgeInsets.symmetric(
+                                                horizontal: 8.0),
+                                            child: Button(
+                                                color: Theme.of(context)
+                                                    .colorScheme
+                                                    .secondaryContainer,
+                                                label: onCancelLabel,
+                                                height: 50,
+                                                onTap: onCancel ?? () {}),
+                                          )
+                                        : SizedBox.shrink(),
+                                  ],
+                                ),
+                                Row(
+                                  mainAxisAlignment: MainAxisAlignment.center,
+                                  mainAxisSize: MainAxisSize.min,
+                                  children: [
+                                    onExtraLabel != null
+                                        ? Padding(
+                                            padding: const EdgeInsets.symmetric(
+                                                horizontal: 8.0),
+                                            child: Button(
+                                                color: Theme.of(context)
+                                                    .colorScheme
+                                                    .secondaryContainer,
+                                                label: onExtraLabel,
+                                                height: 50,
+                                                onTap: onExtra ?? () {}),
+                                          )
+                                        : SizedBox.shrink(),
+                                  ],
+                                ),
+                                Row(
+                                  mainAxisAlignment: MainAxisAlignment.center,
+                                  mainAxisSize: MainAxisSize.min,
+                                  children: [
+                                    onSubmitLabel != null
+                                        ? Padding(
+                                            padding: const EdgeInsets.symmetric(
+                                                horizontal: 8.0),
+                                            child: Button(
+                                                color: Theme.of(context)
+                                                    .colorScheme
+                                                    .tertiaryContainer,
+                                                label: onSubmitLabel,
+                                                height: 50,
+                                                onTap: onSubmit ?? () {}),
+                                          )
+                                        : SizedBox.shrink(),
+                                  ],
+                                ),
+                              ],
+                            ),
+                          )
+                        : SizedBox.shrink(),
+                    SizedBox(height: 16),
+                  ],
+                ),
               ),
             ),
           ),
diff --git a/budget/lib/widgets/pageFramework.dart b/budget/lib/widgets/pageFramework.dart
index 9d85c5922..6ac98ba62 100644
--- a/budget/lib/widgets/pageFramework.dart
+++ b/budget/lib/widgets/pageFramework.dart
@@ -99,6 +99,11 @@ class PageFrameworkState extends State<PageFramework>
         duration: Duration(milliseconds: duration), curve: Curves.elasticOut);
   }
 
+  void scrollTo(double position, {duration = 1200}) {
+    _scrollController.animateTo(position,
+        duration: Duration(milliseconds: duration), curve: Curves.easeInOut);
+  }
+
   void initState() {
     super.initState();
     _animationControllerShift = AnimationController(
diff --git a/budget/lib/widgets/pieChart.dart b/budget/lib/widgets/pieChart.dart
index 494e2d0d8..fe55e393f 100644
--- a/budget/lib/widgets/pieChart.dart
+++ b/budget/lib/widgets/pieChart.dart
@@ -78,7 +78,7 @@ class PieChartWrapper extends StatelessWidget {
                 height: enableDoubleColumn(context) == false ? 105 : 130,
                 decoration: BoxDecoration(
                   color: middleColor?.withOpacity(0.2) ??
-                      getColor(context, "white")!.withOpacity(0.2),
+                      getColor(context, "white").withOpacity(0.2),
                   shape: BoxShape.circle,
                 ),
               ),
diff --git a/budget/lib/widgets/selectAmount.dart b/budget/lib/widgets/selectAmount.dart
index 42dfbcdfa..b54d6bc45 100644
--- a/budget/lib/widgets/selectAmount.dart
+++ b/budget/lib/widgets/selectAmount.dart
@@ -49,6 +49,7 @@ class SelectAmount extends StatefulWidget {
 }
 
 class _SelectAmountState extends State<SelectAmount> {
+  late int numberDecimals;
   String amount = "";
 
   FocusNode _focusNode = FocusNode();
@@ -62,10 +63,16 @@ class _SelectAmountState extends State<SelectAmount> {
     super.initState();
     selectedWallet = widget.selectedWallet;
     walletPkForCurrency = widget.walletPkForCurrency;
-    amount = widget.amountPassed;
-    if (amount.endsWith(".0")) {
-      amount = widget.amountPassed.replaceAll(".0", "");
-    }
+    numberDecimals = widget.selectedWallet?.decimals ??
+        appStateSettings["selectedWalletDecimals"];
+    try {
+      amount =
+          double.parse(widget.amountPassed).toStringAsFixed(numberDecimals);
+    } catch (e) {}
+    amount = removeTrailingZeroes(amount);
+    // if (amount.endsWith(".0")) {
+    //   amount = widget.amountPassed.replaceAll(".0", "");
+    // }
     _focusAttachment = _focusNode.attach(context, onKeyEvent: (node, event) {
       if (event.runtimeType == KeyDownEvent &&
               event.logicalKey.keyLabel == "Go Back" ||
@@ -332,7 +339,8 @@ class _SelectAmountState extends State<SelectAmount> {
   bool canChange() {
     if (includesOperations(amount, false)) {
       return true;
-    } else if (amount.contains(".") && amount.split(".")[1].length >= 2) {
+    } else if (amount.contains(".") &&
+        amount.split(".")[1].length >= numberDecimals) {
       return false;
     }
     return true;
@@ -343,22 +351,29 @@ class _SelectAmountState extends State<SelectAmount> {
     _focusAttachment.reparent();
     String amountConverted = amount == ""
         ? "0"
-        : includesOperations(amount, false)
-            ? convertToMoney(calculateResult(amount), showCurrency: false)
-            : convertToMoney(
-                    double.tryParse(amount.substring(amount.length - 1) ==
-                                    "." ||
-                                (amount.length > 2 &&
-                                    amount.substring(amount.length - 2) == ".0")
-                            ? amount.substring(0, amount.length - 1)
-                            : amount) ??
-                        0,
-                    showCurrency: false) +
-                (amount.substring(amount.length - 1) == "." ? "." : "") +
-                (amount.length > 2 &&
-                        amount.substring(amount.length - 2) == ".0"
-                    ? ".0"
-                    : "");
+        : numberDecimals > 2
+            ? includesOperations(amount, false)
+                ? calculateResult(amount).toString()
+                : amount
+            : includesOperations(amount, false)
+                ? convertToMoney(calculateResult(amount), showCurrency: false)
+                : convertToMoney(
+                        double.tryParse(
+                                amount.substring(amount.length - 1) == "." ||
+                                        (amount.length > numberDecimals &&
+                                            amount.substring(amount.length -
+                                                    numberDecimals) ==
+                                                ".0")
+                                    ? amount.substring(0, amount.length - 1)
+                                    : amount) ??
+                            0,
+                        showCurrency: false) +
+                    (amount.substring(amount.length - 1) == "." ? "." : "") +
+                    (amount.length > numberDecimals &&
+                            amount.substring(amount.length - numberDecimals) ==
+                                ".0"
+                        ? ".0"
+                        : "");
     return Column(
       children: [
         Center(
@@ -511,6 +526,18 @@ class _SelectAmountState extends State<SelectAmount> {
                                                 widget.allWallets![index];
                                             walletPkForCurrency = widget
                                                 .allWallets![index].walletPk;
+                                            numberDecimals = selectedWallet
+                                                    ?.decimals ??
+                                                appStateSettings[
+                                                    "selectedWalletDecimals"];
+                                            try {
+                                              amount = double.parse(amount)
+                                                  .toStringAsFixed(
+                                                      numberDecimals);
+                                            } catch (e) {}
+                                            amount =
+                                                removeTrailingZeroes(amount);
+                                            addToAmount("");
                                           });
                                         },
                                       ),
@@ -1068,3 +1095,17 @@ class _SelectAmountValueState extends State<SelectAmountValue> {
     );
   }
 }
+
+String removeTrailingZeroes(String input) {
+  if (!input.contains('.')) {
+    return input;
+  }
+  int index = input.length - 1;
+  while (input[index] == '0') {
+    index--;
+  }
+  if (input[index] == '.') {
+    index--;
+  }
+  return input.substring(0, index + 1);
+}
diff --git a/budget/lib/widgets/selectCategory.dart b/budget/lib/widgets/selectCategory.dart
index b10bb8780..f186ff186 100644
--- a/budget/lib/widgets/selectCategory.dart
+++ b/budget/lib/widgets/selectCategory.dart
@@ -7,7 +7,8 @@ import 'package:budget/widgets/categoryIcon.dart';
 import 'package:budget/widgets/openBottomSheet.dart';
 import 'package:budget/widgets/tappable.dart';
 import 'package:budget/widgets/textWidgets.dart';
-import 'package:flutter/material.dart';
+import 'package:flutter/material.dart'
+    hide SliverReorderableList, ReorderableDelayedDragStartListener;
 import 'package:flutter/services.dart';
 import 'package:reorderable_grid_view/reorderable_grid_view.dart';
 
diff --git a/budget/lib/widgets/selectColor.dart b/budget/lib/widgets/selectColor.dart
index 164ba44d0..b5c843752 100644
--- a/budget/lib/widgets/selectColor.dart
+++ b/budget/lib/widgets/selectColor.dart
@@ -165,6 +165,7 @@ class _SelectColorState extends State<SelectColor> {
                       Color accentColor = SystemTheme.accentColor.accent;
                       updateSettings("accentColor", toHexString(accentColor),
                           updateGlobalState: true);
+                      generateColors();
                     } else {
                       widget.setSelectedColor!(selectedColor);
                     }
@@ -386,7 +387,7 @@ class _ColorIconCustomState extends State<ColorIconCustom> {
             child: ColorPicker(
               colorSliderPosition: colorSliderPosition,
               shadeSliderPosition: shadeSliderPosition,
-              ringColor: getColor(context, "black")!,
+              ringColor: getColor(context, "black"),
               ringSize: 10,
               width: getWidthBottomSheet(context) - 100,
               onChange: (color, colorSliderPositionPassed,
diff --git a/budget/lib/widgets/showChangelog.dart b/budget/lib/widgets/showChangelog.dart
index d370adea1..174487e88 100644
--- a/budget/lib/widgets/showChangelog.dart
+++ b/budget/lib/widgets/showChangelog.dart
@@ -8,6 +8,12 @@ import 'package:flutter/material.dart';
 
 Future<void> showChangelog(context, {forceShow = false}) async {
   String changelog = """
+    Changed design of edit/reorder cards
+    Reordering now uses batch updating
+    Fixed reordering animation glitches
+    Improved currency picker, add wallet page
+    Popup can scroll when too large
+    Started on custom decimal place precision for wallet
     Fixed wallet currencies icons
     Biometrics unlock required verification to enable/disable
     Improved biometrics unlock page
diff --git a/budget/lib/widgets/transactionEntry.dart b/budget/lib/widgets/transactionEntry.dart
index 549881be4..a422b28e1 100644
--- a/budget/lib/widgets/transactionEntry.dart
+++ b/budget/lib/widgets/transactionEntry.dart
@@ -727,20 +727,22 @@ class TransactionEntry extends StatelessWidget {
                               Row(
                                 children: [
                                   CountNumber(
-                                    count: (transaction.amount.abs()),
+                                    count: (transaction.amount.abs()) *
+                                        (amountRatioToPrimaryCurrencyGivenPk(
+                                                transaction.walletFk) ??
+                                            1),
                                     duration: Duration(milliseconds: 2000),
                                     dynamicDecimals: true,
-                                    initialCount: (transaction.amount.abs()),
+                                    initialCount: (transaction.amount.abs()) *
+                                        (amountRatioToPrimaryCurrencyGivenPk(
+                                                transaction.walletFk) ??
+                                            1),
                                     textBuilder: (number) {
                                       return TextFont(
                                         text: convertToMoney(
-                                            number *
-                                                (amountRatioToPrimaryCurrencyGivenPk(
-                                                        transaction.walletFk) ??
-                                                    1),
-                                            showCurrency: false,
-                                            finalNumber:
-                                                (transaction.amount.abs())),
+                                          number,
+                                          showCurrency: false,
+                                        ),
                                         fontSize: 19 -
                                             (transaction.walletFk !=
                                                     appStateSettings[
@@ -750,7 +752,7 @@ class TransactionEntry extends StatelessWidget {
                                         fontWeight: FontWeight.bold,
                                         textColor: textColor,
                                         walletPkForCurrency:
-                                            transaction.walletFk,
+                                            appStateSettings["selectedWallet"],
                                         onlyShowCurrencyIcon: true,
                                       );
                                     },
@@ -763,8 +765,11 @@ class TransactionEntry extends StatelessWidget {
                                       padding: const EdgeInsets.only(top: 1),
                                       child: TextFont(
                                         text: convertToMoney(
-                                            transaction.amount.abs(),
-                                            showCurrency: false),
+                                          transaction.amount.abs(),
+                                          showCurrency: false,
+                                          decimals: 2,
+                                          // TODO this should match the decimal count of transaction.walletFk
+                                        ),
                                         fontSize: 12,
                                         textColor: textColor.withOpacity(0.6),
                                         walletPkForCurrency:
diff --git a/budget/lib/widgets/walletEntry.dart b/budget/lib/widgets/walletEntry.dart
index 6be4733c5..6a4f2d89a 100644
--- a/budget/lib/widgets/walletEntry.dart
+++ b/budget/lib/widgets/walletEntry.dart
@@ -97,8 +97,9 @@ class _WalletEntryState extends State<WalletEntry>
                             builder: (context, snapshot) {
                               return CountNumber(
                                 count: (snapshot.data ?? 0 * -1),
-                                duration: Duration(milliseconds: 4000),
+                                duration: Duration(milliseconds: 1500),
                                 dynamicDecimals: true,
+                                decimals: widget.wallet.decimals,
                                 initialCount: (snapshot.data ?? 0 * -1),
                                 textBuilder: (number) {
                                   return TextFont(
@@ -128,7 +129,7 @@ class _WalletEntryState extends State<WalletEntry>
                                       pluralString(snapshot.data![0] == 1,
                                           " transaction"),
                                   fontSize: 14,
-                                  textColor: getColor(context, "black")!
+                                  textColor: getColor(context, "black")
                                       .withOpacity(0.65),
                                 );
                               } else {
@@ -168,6 +169,8 @@ Future<bool> setPrimaryWallet(TransactionWallet wallet) async {
       await database.getWalletInstance(wallet.walletPk);
   updateSettings("selectedWalletCurrency", defaultWallet.currency,
       updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
+  updateSettings("selectedWalletDecimals", defaultWallet.decimals,
+      updateGlobalState: true, pagesNeedingRefresh: [0, 1, 2, 3]);
   return true;
 }
 
