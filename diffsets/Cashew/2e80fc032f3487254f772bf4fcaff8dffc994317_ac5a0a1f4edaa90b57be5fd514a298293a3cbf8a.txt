diff --git a/budget/lib/database/tables.dart b/budget/lib/database/tables.dart
index 8d616f42c..d1fca7efa 100644
--- a/budget/lib/database/tables.dart
+++ b/budget/lib/database/tables.dart
@@ -10,7 +10,7 @@ export 'platform/shared.dart';
 import 'dart:convert';
 part 'tables.g.dart';
 
-int schemaVersionGlobal = 13;
+int schemaVersionGlobal = 14;
 
 // Generate database code
 // flutter packages pub run build_runner build
@@ -43,14 +43,12 @@ class IntListInColumnConverter extends TypeConverter<List<int>, String> {
   @override
   List<int>? mapToDart(String? string_from_db) {
     if (string_from_db == null) return null;
-    // return label_fks_from_db.split(',').map(int.parse).toList();
     return new List<int>.from(json.decode(string_from_db));
   }
 
   @override
   String? mapToSql(List<int>? ints) {
     if (ints == null) return null;
-    // throw label_fks.map((fk) => toString).join(',');
     return json.encode(ints);
   }
 }
@@ -60,18 +58,31 @@ class StringListInColumnConverter extends TypeConverter<List<String>, String> {
   @override
   List<String>? mapToDart(String? string_from_db) {
     if (string_from_db == null) return null;
-    // return label_fks_from_db.split(',').map(int.parse).toList();
     return new List<String>.from(json.decode(string_from_db));
   }
 
   @override
   String? mapToSql(List<String>? strings) {
     if (strings == null) return null;
-    // throw label_fks.map((fk) => toString).join(',');
     return json.encode(strings);
   }
 }
 
+class DoubleListInColumnConverter extends TypeConverter<List<double>, String> {
+  const DoubleListInColumnConverter();
+  @override
+  List<double>? mapToDart(String? string_from_db) {
+    if (string_from_db == null) return null;
+    return new List<double>.from(json.decode(string_from_db));
+  }
+
+  @override
+  String? mapToSql(List<double>? doubles) {
+    if (doubles == null) return null;
+    return json.encode(doubles);
+  }
+}
+
 @DataClassName('TransactionWallet')
 class Wallets extends Table {
   IntColumn get walletPk => integer().autoIncrement()();
@@ -89,8 +100,8 @@ class Transactions extends Table {
   TextColumn get name => text().withLength(max: NAME_LIMIT)();
   RealColumn get amount => real()();
   TextColumn get note => text().withLength(max: NOTE_LIMIT)();
-  IntColumn get categoryFk => integer()();
-  IntColumn get walletFk => integer()();
+  IntColumn get categoryFk => integer().references(Categories, #categoryPk)();
+  IntColumn get walletFk => integer().references(Wallets, #walletPk)();
   TextColumn get labelFks =>
       text().map(const IntListInColumnConverter()).nullable()();
   DateTimeColumn get dateCreated =>
@@ -128,7 +139,7 @@ class Categories extends Table {
 class AssociatedTitles extends Table {
   IntColumn get associatedTitlePk => integer().autoIncrement()();
   TextColumn get title => text().withLength(max: NAME_LIMIT)();
-  IntColumn get categoryFk => integer()();
+  IntColumn get categoryFk => integer().references(Categories, #categoryPk)();
   DateTimeColumn get dateCreated =>
       dateTime().clientDefault(() => new DateTime.now())();
   IntColumn get order => integer()();
@@ -139,7 +150,7 @@ class AssociatedTitles extends Table {
 class Labels extends Table {
   IntColumn get label_pk => integer().autoIncrement()();
   TextColumn get name => text().withLength(max: NAME_LIMIT)();
-  IntColumn get categoryFk => integer()();
+  IntColumn get categoryFk => integer().references(Categories, #categoryPk)();
   DateTimeColumn get dateCreated =>
       dateTime().clientDefault(() => new DateTime.now())();
   IntColumn get order => integer()();
@@ -164,7 +175,7 @@ class Budgets extends Table {
       dateTime().clientDefault(() => new DateTime.now())();
   BoolColumn get pinned => boolean().withDefault(const Constant(false))();
   IntColumn get order => integer()();
-  IntColumn get walletFk => integer()();
+  IntColumn get walletFk => integer().references(Wallets, #walletPk)();
 }
 
 @DataClassName('TransactionTabs')
@@ -188,6 +199,30 @@ class AppSettings extends Table {
       dateTime().clientDefault(() => new DateTime.now())();
 }
 
+@DataClassName('BillSplitter')
+class BillSplitters extends Table {
+  IntColumn get billSplitterPk => integer().autoIncrement()();
+  TextColumn get name => text().withLength(max: NAME_LIMIT)();
+  DateTimeColumn get dateCreated =>
+      dateTime().clientDefault(() => new DateTime.now())();
+  IntColumn get order => integer()();
+}
+
+@DataClassName('BillSplitterTransaction')
+class BillSplitterTransactions extends Table {
+  IntColumn get billSplitterTransactionPk => integer().autoIncrement()();
+  IntColumn get billSplitterFk =>
+      integer().references(BillSplitters, #billSplitterPk)();
+  TextColumn get name => text().withLength(max: NAME_LIMIT)();
+  RealColumn get cost => real()();
+  TextColumn get personNames =>
+      text().map(const StringListInColumnConverter()).nullable()();
+  TextColumn get personsPercents =>
+      text().map(const DoubleListInColumnConverter()).nullable()();
+  DateTimeColumn get dateCreated =>
+      dateTime().clientDefault(() => new DateTime.now())();
+}
+
 class TransactionWithCategory {
   final TransactionCategory category;
   final Transaction transaction;
@@ -213,6 +248,8 @@ class CategoryWithTotal {
   AssociatedTitles,
   Budgets,
   AppSettings,
+  BillSplitters,
+  BillSplitterTransactions,
 ])
 class FinanceDatabase extends _$FinanceDatabase {
   // FinanceDatabase() : super(_openConnection());
@@ -237,6 +274,11 @@ class FinanceDatabase extends _$FinanceDatabase {
             await migrator.addColumn(
                 transactions, transactions.createdAnotherFutureTransaction);
           }
+          if (from <= 13) {
+            await migrator.createTable($BillSplittersTable(database));
+            await migrator
+                .createTable($BillSplitterTransactionsTable(database));
+          }
         },
       );
 
@@ -664,7 +706,98 @@ class FinanceDatabase extends _$FinanceDatabase {
         .watch();
   }
 
-  Future getAmountOfBudgets() async {
+  Stream<List<BillSplitter>> watchAllBillSplitters() {
+    return (select(billSplitters)..orderBy([(b) => OrderingTerm.desc(b.order)]))
+        .watch();
+  }
+
+  Stream<List<BillSplitterTransaction>> watchAllBillSplitterTransactions(
+      int billSplitterFk) {
+    return (select(billSplitterTransactions)
+          ..where((tbl) => tbl.billSplitterFk.equals(billSplitterFk))
+          ..orderBy([(b) => OrderingTerm.desc(b.dateCreated)]))
+        .watch();
+  }
+
+  Future<int> createOrUpdateBillSplitter(BillSplitter billSplitter) {
+    return into(billSplitters).insertOnConflictUpdate(billSplitter);
+  }
+
+  Future<int> getAmountOfBillSplitters() async {
+    return (await select(billSplitters).get()).length;
+  }
+
+  Future deleteBillSplitter(int billSplitterPk, int order) async {
+    await database.shiftBillSplitters(-1, order);
+    return (delete(billSplitters)
+          ..where((t) => t.billSplitterPk.equals(billSplitterPk)))
+        .go();
+  }
+
+  Future<bool> shiftBillSplitters(int direction, int pastIndexIncluding) async {
+    List<BillSplitter> billSplittersList = await (select(billSplitters)
+          ..orderBy([(t) => OrderingTerm.asc(t.order)]))
+        .get();
+    if (direction == -1 || direction == 1) {
+      for (BillSplitter billSplitter in billSplittersList) {
+        await (update(billSplitters)
+              ..where(
+                (t) =>
+                    t.order.isBiggerOrEqualValue(pastIndexIncluding) &
+                    t.billSplitterPk.equals(billSplitter.billSplitterPk),
+              ))
+            .write(
+          BillSplittersCompanion(order: Value(billSplitter.order + direction)),
+        );
+      }
+    } else {
+      return false;
+    }
+    return true;
+  }
+
+  Future moveBillSplitter(
+      int billSplitterPk, int newPosition, int oldPosition) async {
+    List<BillSplitter> billSplittersList = await (select(billSplitters)
+          ..orderBy([(t) => OrderingTerm.asc(t.order)]))
+        .get();
+    if (newPosition > oldPosition) {
+      for (BillSplitter billSplitter in billSplittersList) {
+        await (update(billSplitters)
+              ..where(
+                (t) =>
+                    t.billSplitterPk.equals(billSplitter.billSplitterPk) &
+                    t.order.isBiggerOrEqualValue(oldPosition) &
+                    t.order.isSmallerOrEqualValue(newPosition),
+              ))
+            .write(
+          BillSplittersCompanion(order: Value(billSplitter.order - 1)),
+        );
+      }
+    } else {
+      for (BillSplitter billSplitter in billSplittersList) {
+        await (update(billSplitters)
+              ..where(
+                (t) =>
+                    t.billSplitterPk.equals(billSplitter.billSplitterPk) &
+                    t.order.isBiggerOrEqualValue(newPosition) &
+                    t.order.isSmallerOrEqualValue(oldPosition),
+              ))
+            .write(
+          BillSplittersCompanion(order: Value(billSplitter.order + 1)),
+        );
+      }
+    }
+    await (update(billSplitters)
+          ..where(
+            (t) => t.billSplitterPk.equals(billSplitterPk),
+          ))
+        .write(
+      BillSplittersCompanion(order: Value(newPosition)),
+    );
+  }
+
+  Future<int> getAmountOfBudgets() async {
     return (await select(budgets).get()).length;
   }
 
diff --git a/budget/lib/database/tables.g.dart b/budget/lib/database/tables.g.dart
index a4ec924ff..d98899ff4 100644
--- a/budget/lib/database/tables.g.dart
+++ b/budget/lib/database/tables.g.dart
@@ -339,528 +339,267 @@ class $WalletsTable extends Wallets
   }
 }
 
-class Transaction extends DataClass implements Insertable<Transaction> {
-  final int transactionPk;
+class TransactionCategory extends DataClass
+    implements Insertable<TransactionCategory> {
+  final int categoryPk;
   final String name;
-  final double amount;
-  final String note;
-  final int categoryFk;
-  final int walletFk;
-  final List<int>? labelFks;
+  final String? colour;
+  final String? iconName;
   final DateTime dateCreated;
+  final int order;
   final bool income;
-  final int? periodLength;
-  final BudgetReoccurence? reoccurrence;
-  final TransactionSpecialType? type;
-  final bool paid;
-  final bool? createdAnotherFutureTransaction;
-  final bool skipPaid;
-  final MethodAdded? methodAdded;
-  Transaction(
-      {required this.transactionPk,
+  TransactionCategory(
+      {required this.categoryPk,
       required this.name,
-      required this.amount,
-      required this.note,
-      required this.categoryFk,
-      required this.walletFk,
-      this.labelFks,
+      this.colour,
+      this.iconName,
       required this.dateCreated,
-      required this.income,
-      this.periodLength,
-      this.reoccurrence,
-      this.type,
-      required this.paid,
-      this.createdAnotherFutureTransaction,
-      required this.skipPaid,
-      this.methodAdded});
-  factory Transaction.fromData(Map<String, dynamic> data, {String? prefix}) {
+      required this.order,
+      required this.income});
+  factory TransactionCategory.fromData(Map<String, dynamic> data,
+      {String? prefix}) {
     final effectivePrefix = prefix ?? '';
-    return Transaction(
-      transactionPk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}transaction_pk'])!,
+    return TransactionCategory(
+      categoryPk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}category_pk'])!,
       name: const StringType()
           .mapFromDatabaseResponse(data['${effectivePrefix}name'])!,
-      amount: const RealType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}amount'])!,
-      note: const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}note'])!,
-      categoryFk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}category_fk'])!,
-      walletFk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}wallet_fk'])!,
-      labelFks: $TransactionsTable.$converter0.mapToDart(const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}label_fks'])),
+      colour: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}colour']),
+      iconName: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}icon_name']),
       dateCreated: const DateTimeType()
           .mapFromDatabaseResponse(data['${effectivePrefix}date_created'])!,
+      order: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}order'])!,
       income: const BoolType()
           .mapFromDatabaseResponse(data['${effectivePrefix}income'])!,
-      periodLength: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}period_length']),
-      reoccurrence: $TransactionsTable.$converter1.mapToDart(const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}reoccurrence'])),
-      type: $TransactionsTable.$converter2.mapToDart(const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}type'])),
-      paid: const BoolType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}paid'])!,
-      createdAnotherFutureTransaction: const BoolType().mapFromDatabaseResponse(
-          data['${effectivePrefix}created_another_future_transaction']),
-      skipPaid: const BoolType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}skip_paid'])!,
-      methodAdded: $TransactionsTable.$converter3.mapToDart(const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}method_added'])),
     );
   }
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    map['transaction_pk'] = Variable<int>(transactionPk);
+    map['category_pk'] = Variable<int>(categoryPk);
     map['name'] = Variable<String>(name);
-    map['amount'] = Variable<double>(amount);
-    map['note'] = Variable<String>(note);
-    map['category_fk'] = Variable<int>(categoryFk);
-    map['wallet_fk'] = Variable<int>(walletFk);
-    if (!nullToAbsent || labelFks != null) {
-      final converter = $TransactionsTable.$converter0;
-      map['label_fks'] = Variable<String?>(converter.mapToSql(labelFks));
+    if (!nullToAbsent || colour != null) {
+      map['colour'] = Variable<String?>(colour);
+    }
+    if (!nullToAbsent || iconName != null) {
+      map['icon_name'] = Variable<String?>(iconName);
     }
     map['date_created'] = Variable<DateTime>(dateCreated);
+    map['order'] = Variable<int>(order);
     map['income'] = Variable<bool>(income);
-    if (!nullToAbsent || periodLength != null) {
-      map['period_length'] = Variable<int?>(periodLength);
-    }
-    if (!nullToAbsent || reoccurrence != null) {
-      final converter = $TransactionsTable.$converter1;
-      map['reoccurrence'] = Variable<int?>(converter.mapToSql(reoccurrence));
-    }
-    if (!nullToAbsent || type != null) {
-      final converter = $TransactionsTable.$converter2;
-      map['type'] = Variable<int?>(converter.mapToSql(type));
-    }
-    map['paid'] = Variable<bool>(paid);
-    if (!nullToAbsent || createdAnotherFutureTransaction != null) {
-      map['created_another_future_transaction'] =
-          Variable<bool?>(createdAnotherFutureTransaction);
-    }
-    map['skip_paid'] = Variable<bool>(skipPaid);
-    if (!nullToAbsent || methodAdded != null) {
-      final converter = $TransactionsTable.$converter3;
-      map['method_added'] = Variable<int?>(converter.mapToSql(methodAdded));
-    }
     return map;
   }
 
-  TransactionsCompanion toCompanion(bool nullToAbsent) {
-    return TransactionsCompanion(
-      transactionPk: Value(transactionPk),
+  CategoriesCompanion toCompanion(bool nullToAbsent) {
+    return CategoriesCompanion(
+      categoryPk: Value(categoryPk),
       name: Value(name),
-      amount: Value(amount),
-      note: Value(note),
-      categoryFk: Value(categoryFk),
-      walletFk: Value(walletFk),
-      labelFks: labelFks == null && nullToAbsent
+      colour:
+          colour == null && nullToAbsent ? const Value.absent() : Value(colour),
+      iconName: iconName == null && nullToAbsent
           ? const Value.absent()
-          : Value(labelFks),
+          : Value(iconName),
       dateCreated: Value(dateCreated),
+      order: Value(order),
       income: Value(income),
-      periodLength: periodLength == null && nullToAbsent
-          ? const Value.absent()
-          : Value(periodLength),
-      reoccurrence: reoccurrence == null && nullToAbsent
-          ? const Value.absent()
-          : Value(reoccurrence),
-      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
-      paid: Value(paid),
-      createdAnotherFutureTransaction:
-          createdAnotherFutureTransaction == null && nullToAbsent
-              ? const Value.absent()
-              : Value(createdAnotherFutureTransaction),
-      skipPaid: Value(skipPaid),
-      methodAdded: methodAdded == null && nullToAbsent
-          ? const Value.absent()
-          : Value(methodAdded),
     );
   }
 
-  factory Transaction.fromJson(Map<String, dynamic> json,
+  factory TransactionCategory.fromJson(Map<String, dynamic> json,
       {ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
-    return Transaction(
-      transactionPk: serializer.fromJson<int>(json['transactionPk']),
+    return TransactionCategory(
+      categoryPk: serializer.fromJson<int>(json['categoryPk']),
       name: serializer.fromJson<String>(json['name']),
-      amount: serializer.fromJson<double>(json['amount']),
-      note: serializer.fromJson<String>(json['note']),
-      categoryFk: serializer.fromJson<int>(json['categoryFk']),
-      walletFk: serializer.fromJson<int>(json['walletFk']),
-      labelFks: serializer.fromJson<List<int>?>(json['labelFks']),
+      colour: serializer.fromJson<String?>(json['colour']),
+      iconName: serializer.fromJson<String?>(json['iconName']),
       dateCreated: serializer.fromJson<DateTime>(json['dateCreated']),
+      order: serializer.fromJson<int>(json['order']),
       income: serializer.fromJson<bool>(json['income']),
-      periodLength: serializer.fromJson<int?>(json['periodLength']),
-      reoccurrence:
-          serializer.fromJson<BudgetReoccurence?>(json['reoccurrence']),
-      type: serializer.fromJson<TransactionSpecialType?>(json['type']),
-      paid: serializer.fromJson<bool>(json['paid']),
-      createdAnotherFutureTransaction:
-          serializer.fromJson<bool?>(json['createdAnotherFutureTransaction']),
-      skipPaid: serializer.fromJson<bool>(json['skipPaid']),
-      methodAdded: serializer.fromJson<MethodAdded?>(json['methodAdded']),
     );
   }
   @override
   Map<String, dynamic> toJson({ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
     return <String, dynamic>{
-      'transactionPk': serializer.toJson<int>(transactionPk),
+      'categoryPk': serializer.toJson<int>(categoryPk),
       'name': serializer.toJson<String>(name),
-      'amount': serializer.toJson<double>(amount),
-      'note': serializer.toJson<String>(note),
-      'categoryFk': serializer.toJson<int>(categoryFk),
-      'walletFk': serializer.toJson<int>(walletFk),
-      'labelFks': serializer.toJson<List<int>?>(labelFks),
+      'colour': serializer.toJson<String?>(colour),
+      'iconName': serializer.toJson<String?>(iconName),
       'dateCreated': serializer.toJson<DateTime>(dateCreated),
+      'order': serializer.toJson<int>(order),
       'income': serializer.toJson<bool>(income),
-      'periodLength': serializer.toJson<int?>(periodLength),
-      'reoccurrence': serializer.toJson<BudgetReoccurence?>(reoccurrence),
-      'type': serializer.toJson<TransactionSpecialType?>(type),
-      'paid': serializer.toJson<bool>(paid),
-      'createdAnotherFutureTransaction':
-          serializer.toJson<bool?>(createdAnotherFutureTransaction),
-      'skipPaid': serializer.toJson<bool>(skipPaid),
-      'methodAdded': serializer.toJson<MethodAdded?>(methodAdded),
     };
   }
 
-  Transaction copyWith(
-          {int? transactionPk,
+  TransactionCategory copyWith(
+          {int? categoryPk,
           String? name,
-          double? amount,
-          String? note,
-          int? categoryFk,
-          int? walletFk,
-          List<int>? labelFks,
+          String? colour,
+          String? iconName,
           DateTime? dateCreated,
-          bool? income,
-          int? periodLength,
-          BudgetReoccurence? reoccurrence,
-          TransactionSpecialType? type,
-          bool? paid,
-          bool? createdAnotherFutureTransaction,
-          bool? skipPaid,
-          MethodAdded? methodAdded}) =>
-      Transaction(
-        transactionPk: transactionPk ?? this.transactionPk,
+          int? order,
+          bool? income}) =>
+      TransactionCategory(
+        categoryPk: categoryPk ?? this.categoryPk,
         name: name ?? this.name,
-        amount: amount ?? this.amount,
-        note: note ?? this.note,
-        categoryFk: categoryFk ?? this.categoryFk,
-        walletFk: walletFk ?? this.walletFk,
-        labelFks: labelFks ?? this.labelFks,
+        colour: colour ?? this.colour,
+        iconName: iconName ?? this.iconName,
         dateCreated: dateCreated ?? this.dateCreated,
+        order: order ?? this.order,
         income: income ?? this.income,
-        periodLength: periodLength ?? this.periodLength,
-        reoccurrence: reoccurrence ?? this.reoccurrence,
-        type: type ?? this.type,
-        paid: paid ?? this.paid,
-        createdAnotherFutureTransaction: createdAnotherFutureTransaction ??
-            this.createdAnotherFutureTransaction,
-        skipPaid: skipPaid ?? this.skipPaid,
-        methodAdded: methodAdded ?? this.methodAdded,
       );
   @override
   String toString() {
-    return (StringBuffer('Transaction(')
-          ..write('transactionPk: $transactionPk, ')
+    return (StringBuffer('TransactionCategory(')
+          ..write('categoryPk: $categoryPk, ')
           ..write('name: $name, ')
-          ..write('amount: $amount, ')
-          ..write('note: $note, ')
-          ..write('categoryFk: $categoryFk, ')
-          ..write('walletFk: $walletFk, ')
-          ..write('labelFks: $labelFks, ')
+          ..write('colour: $colour, ')
+          ..write('iconName: $iconName, ')
           ..write('dateCreated: $dateCreated, ')
-          ..write('income: $income, ')
-          ..write('periodLength: $periodLength, ')
-          ..write('reoccurrence: $reoccurrence, ')
-          ..write('type: $type, ')
-          ..write('paid: $paid, ')
-          ..write(
-              'createdAnotherFutureTransaction: $createdAnotherFutureTransaction, ')
-          ..write('skipPaid: $skipPaid, ')
-          ..write('methodAdded: $methodAdded')
+          ..write('order: $order, ')
+          ..write('income: $income')
           ..write(')'))
         .toString();
   }
 
   @override
   int get hashCode => Object.hash(
-      transactionPk,
-      name,
-      amount,
-      note,
-      categoryFk,
-      walletFk,
-      labelFks,
-      dateCreated,
-      income,
-      periodLength,
-      reoccurrence,
-      type,
-      paid,
-      createdAnotherFutureTransaction,
-      skipPaid,
-      methodAdded);
+      categoryPk, name, colour, iconName, dateCreated, order, income);
   @override
   bool operator ==(Object other) =>
       identical(this, other) ||
-      (other is Transaction &&
-          other.transactionPk == this.transactionPk &&
+      (other is TransactionCategory &&
+          other.categoryPk == this.categoryPk &&
           other.name == this.name &&
-          other.amount == this.amount &&
-          other.note == this.note &&
-          other.categoryFk == this.categoryFk &&
-          other.walletFk == this.walletFk &&
-          other.labelFks == this.labelFks &&
+          other.colour == this.colour &&
+          other.iconName == this.iconName &&
           other.dateCreated == this.dateCreated &&
-          other.income == this.income &&
-          other.periodLength == this.periodLength &&
-          other.reoccurrence == this.reoccurrence &&
-          other.type == this.type &&
-          other.paid == this.paid &&
-          other.createdAnotherFutureTransaction ==
-              this.createdAnotherFutureTransaction &&
-          other.skipPaid == this.skipPaid &&
-          other.methodAdded == this.methodAdded);
+          other.order == this.order &&
+          other.income == this.income);
 }
 
-class TransactionsCompanion extends UpdateCompanion<Transaction> {
-  final Value<int> transactionPk;
+class CategoriesCompanion extends UpdateCompanion<TransactionCategory> {
+  final Value<int> categoryPk;
   final Value<String> name;
-  final Value<double> amount;
-  final Value<String> note;
-  final Value<int> categoryFk;
-  final Value<int> walletFk;
-  final Value<List<int>?> labelFks;
+  final Value<String?> colour;
+  final Value<String?> iconName;
   final Value<DateTime> dateCreated;
+  final Value<int> order;
   final Value<bool> income;
-  final Value<int?> periodLength;
-  final Value<BudgetReoccurence?> reoccurrence;
-  final Value<TransactionSpecialType?> type;
-  final Value<bool> paid;
-  final Value<bool?> createdAnotherFutureTransaction;
-  final Value<bool> skipPaid;
-  final Value<MethodAdded?> methodAdded;
-  const TransactionsCompanion({
-    this.transactionPk = const Value.absent(),
+  const CategoriesCompanion({
+    this.categoryPk = const Value.absent(),
     this.name = const Value.absent(),
-    this.amount = const Value.absent(),
-    this.note = const Value.absent(),
-    this.categoryFk = const Value.absent(),
-    this.walletFk = const Value.absent(),
-    this.labelFks = const Value.absent(),
+    this.colour = const Value.absent(),
+    this.iconName = const Value.absent(),
     this.dateCreated = const Value.absent(),
+    this.order = const Value.absent(),
     this.income = const Value.absent(),
-    this.periodLength = const Value.absent(),
-    this.reoccurrence = const Value.absent(),
-    this.type = const Value.absent(),
-    this.paid = const Value.absent(),
-    this.createdAnotherFutureTransaction = const Value.absent(),
-    this.skipPaid = const Value.absent(),
-    this.methodAdded = const Value.absent(),
   });
-  TransactionsCompanion.insert({
-    this.transactionPk = const Value.absent(),
+  CategoriesCompanion.insert({
+    this.categoryPk = const Value.absent(),
     required String name,
-    required double amount,
-    required String note,
-    required int categoryFk,
-    required int walletFk,
-    this.labelFks = const Value.absent(),
+    this.colour = const Value.absent(),
+    this.iconName = const Value.absent(),
     this.dateCreated = const Value.absent(),
+    required int order,
     this.income = const Value.absent(),
-    this.periodLength = const Value.absent(),
-    this.reoccurrence = const Value.absent(),
-    this.type = const Value.absent(),
-    this.paid = const Value.absent(),
-    this.createdAnotherFutureTransaction = const Value.absent(),
-    this.skipPaid = const Value.absent(),
-    this.methodAdded = const Value.absent(),
   })  : name = Value(name),
-        amount = Value(amount),
-        note = Value(note),
-        categoryFk = Value(categoryFk),
-        walletFk = Value(walletFk);
-  static Insertable<Transaction> custom({
-    Expression<int>? transactionPk,
+        order = Value(order);
+  static Insertable<TransactionCategory> custom({
+    Expression<int>? categoryPk,
     Expression<String>? name,
-    Expression<double>? amount,
-    Expression<String>? note,
-    Expression<int>? categoryFk,
-    Expression<int>? walletFk,
-    Expression<List<int>?>? labelFks,
+    Expression<String?>? colour,
+    Expression<String?>? iconName,
     Expression<DateTime>? dateCreated,
+    Expression<int>? order,
     Expression<bool>? income,
-    Expression<int?>? periodLength,
-    Expression<BudgetReoccurence?>? reoccurrence,
-    Expression<TransactionSpecialType?>? type,
-    Expression<bool>? paid,
-    Expression<bool?>? createdAnotherFutureTransaction,
-    Expression<bool>? skipPaid,
-    Expression<MethodAdded?>? methodAdded,
   }) {
     return RawValuesInsertable({
-      if (transactionPk != null) 'transaction_pk': transactionPk,
+      if (categoryPk != null) 'category_pk': categoryPk,
       if (name != null) 'name': name,
-      if (amount != null) 'amount': amount,
-      if (note != null) 'note': note,
-      if (categoryFk != null) 'category_fk': categoryFk,
-      if (walletFk != null) 'wallet_fk': walletFk,
-      if (labelFks != null) 'label_fks': labelFks,
+      if (colour != null) 'colour': colour,
+      if (iconName != null) 'icon_name': iconName,
       if (dateCreated != null) 'date_created': dateCreated,
+      if (order != null) 'order': order,
       if (income != null) 'income': income,
-      if (periodLength != null) 'period_length': periodLength,
-      if (reoccurrence != null) 'reoccurrence': reoccurrence,
-      if (type != null) 'type': type,
-      if (paid != null) 'paid': paid,
-      if (createdAnotherFutureTransaction != null)
-        'created_another_future_transaction': createdAnotherFutureTransaction,
-      if (skipPaid != null) 'skip_paid': skipPaid,
-      if (methodAdded != null) 'method_added': methodAdded,
     });
   }
 
-  TransactionsCompanion copyWith(
-      {Value<int>? transactionPk,
+  CategoriesCompanion copyWith(
+      {Value<int>? categoryPk,
       Value<String>? name,
-      Value<double>? amount,
-      Value<String>? note,
-      Value<int>? categoryFk,
-      Value<int>? walletFk,
-      Value<List<int>?>? labelFks,
+      Value<String?>? colour,
+      Value<String?>? iconName,
       Value<DateTime>? dateCreated,
-      Value<bool>? income,
-      Value<int?>? periodLength,
-      Value<BudgetReoccurence?>? reoccurrence,
-      Value<TransactionSpecialType?>? type,
-      Value<bool>? paid,
-      Value<bool?>? createdAnotherFutureTransaction,
-      Value<bool>? skipPaid,
-      Value<MethodAdded?>? methodAdded}) {
-    return TransactionsCompanion(
-      transactionPk: transactionPk ?? this.transactionPk,
+      Value<int>? order,
+      Value<bool>? income}) {
+    return CategoriesCompanion(
+      categoryPk: categoryPk ?? this.categoryPk,
       name: name ?? this.name,
-      amount: amount ?? this.amount,
-      note: note ?? this.note,
-      categoryFk: categoryFk ?? this.categoryFk,
-      walletFk: walletFk ?? this.walletFk,
-      labelFks: labelFks ?? this.labelFks,
+      colour: colour ?? this.colour,
+      iconName: iconName ?? this.iconName,
       dateCreated: dateCreated ?? this.dateCreated,
+      order: order ?? this.order,
       income: income ?? this.income,
-      periodLength: periodLength ?? this.periodLength,
-      reoccurrence: reoccurrence ?? this.reoccurrence,
-      type: type ?? this.type,
-      paid: paid ?? this.paid,
-      createdAnotherFutureTransaction: createdAnotherFutureTransaction ??
-          this.createdAnotherFutureTransaction,
-      skipPaid: skipPaid ?? this.skipPaid,
-      methodAdded: methodAdded ?? this.methodAdded,
     );
   }
 
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    if (transactionPk.present) {
-      map['transaction_pk'] = Variable<int>(transactionPk.value);
+    if (categoryPk.present) {
+      map['category_pk'] = Variable<int>(categoryPk.value);
     }
     if (name.present) {
       map['name'] = Variable<String>(name.value);
     }
-    if (amount.present) {
-      map['amount'] = Variable<double>(amount.value);
-    }
-    if (note.present) {
-      map['note'] = Variable<String>(note.value);
-    }
-    if (categoryFk.present) {
-      map['category_fk'] = Variable<int>(categoryFk.value);
-    }
-    if (walletFk.present) {
-      map['wallet_fk'] = Variable<int>(walletFk.value);
+    if (colour.present) {
+      map['colour'] = Variable<String?>(colour.value);
     }
-    if (labelFks.present) {
-      final converter = $TransactionsTable.$converter0;
-      map['label_fks'] = Variable<String?>(converter.mapToSql(labelFks.value));
+    if (iconName.present) {
+      map['icon_name'] = Variable<String?>(iconName.value);
     }
     if (dateCreated.present) {
       map['date_created'] = Variable<DateTime>(dateCreated.value);
     }
+    if (order.present) {
+      map['order'] = Variable<int>(order.value);
+    }
     if (income.present) {
       map['income'] = Variable<bool>(income.value);
     }
-    if (periodLength.present) {
-      map['period_length'] = Variable<int?>(periodLength.value);
-    }
-    if (reoccurrence.present) {
-      final converter = $TransactionsTable.$converter1;
-      map['reoccurrence'] =
-          Variable<int?>(converter.mapToSql(reoccurrence.value));
-    }
-    if (type.present) {
-      final converter = $TransactionsTable.$converter2;
-      map['type'] = Variable<int?>(converter.mapToSql(type.value));
-    }
-    if (paid.present) {
-      map['paid'] = Variable<bool>(paid.value);
-    }
-    if (createdAnotherFutureTransaction.present) {
-      map['created_another_future_transaction'] =
-          Variable<bool?>(createdAnotherFutureTransaction.value);
-    }
-    if (skipPaid.present) {
-      map['skip_paid'] = Variable<bool>(skipPaid.value);
-    }
-    if (methodAdded.present) {
-      final converter = $TransactionsTable.$converter3;
-      map['method_added'] =
-          Variable<int?>(converter.mapToSql(methodAdded.value));
-    }
     return map;
   }
 
   @override
   String toString() {
-    return (StringBuffer('TransactionsCompanion(')
-          ..write('transactionPk: $transactionPk, ')
+    return (StringBuffer('CategoriesCompanion(')
+          ..write('categoryPk: $categoryPk, ')
           ..write('name: $name, ')
-          ..write('amount: $amount, ')
-          ..write('note: $note, ')
-          ..write('categoryFk: $categoryFk, ')
-          ..write('walletFk: $walletFk, ')
-          ..write('labelFks: $labelFks, ')
+          ..write('colour: $colour, ')
+          ..write('iconName: $iconName, ')
           ..write('dateCreated: $dateCreated, ')
-          ..write('income: $income, ')
-          ..write('periodLength: $periodLength, ')
-          ..write('reoccurrence: $reoccurrence, ')
-          ..write('type: $type, ')
-          ..write('paid: $paid, ')
-          ..write(
-              'createdAnotherFutureTransaction: $createdAnotherFutureTransaction, ')
-          ..write('skipPaid: $skipPaid, ')
-          ..write('methodAdded: $methodAdded')
+          ..write('order: $order, ')
+          ..write('income: $income')
           ..write(')'))
         .toString();
   }
 }
 
-class $TransactionsTable extends Transactions
-    with TableInfo<$TransactionsTable, Transaction> {
+class $CategoriesTable extends Categories
+    with TableInfo<$CategoriesTable, TransactionCategory> {
   @override
   final GeneratedDatabase attachedDatabase;
   final String? _alias;
-  $TransactionsTable(this.attachedDatabase, [this._alias]);
-  final VerificationMeta _transactionPkMeta =
-      const VerificationMeta('transactionPk');
+  $CategoriesTable(this.attachedDatabase, [this._alias]);
+  final VerificationMeta _categoryPkMeta = const VerificationMeta('categoryPk');
   @override
-  late final GeneratedColumn<int?> transactionPk = GeneratedColumn<int?>(
-      'transaction_pk', aliasedName, false,
+  late final GeneratedColumn<int?> categoryPk = GeneratedColumn<int?>(
+      'category_pk', aliasedName, false,
       type: const IntType(),
       requiredDuringInsert: false,
       defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
@@ -871,34 +610,18 @@ class $TransactionsTable extends Transactions
       additionalChecks: GeneratedColumn.checkTextLength(),
       type: const StringType(),
       requiredDuringInsert: true);
-  final VerificationMeta _amountMeta = const VerificationMeta('amount');
-  @override
-  late final GeneratedColumn<double?> amount = GeneratedColumn<double?>(
-      'amount', aliasedName, false,
-      type: const RealType(), requiredDuringInsert: true);
-  final VerificationMeta _noteMeta = const VerificationMeta('note');
+  final VerificationMeta _colourMeta = const VerificationMeta('colour');
   @override
-  late final GeneratedColumn<String?> note = GeneratedColumn<String?>(
-      'note', aliasedName, false,
+  late final GeneratedColumn<String?> colour = GeneratedColumn<String?>(
+      'colour', aliasedName, true,
       additionalChecks: GeneratedColumn.checkTextLength(),
       type: const StringType(),
-      requiredDuringInsert: true);
-  final VerificationMeta _categoryFkMeta = const VerificationMeta('categoryFk');
-  @override
-  late final GeneratedColumn<int?> categoryFk = GeneratedColumn<int?>(
-      'category_fk', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  final VerificationMeta _walletFkMeta = const VerificationMeta('walletFk');
-  @override
-  late final GeneratedColumn<int?> walletFk = GeneratedColumn<int?>(
-      'wallet_fk', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  final VerificationMeta _labelFksMeta = const VerificationMeta('labelFks');
+      requiredDuringInsert: false);
+  final VerificationMeta _iconNameMeta = const VerificationMeta('iconName');
   @override
-  late final GeneratedColumnWithTypeConverter<List<int>, String?> labelFks =
-      GeneratedColumn<String?>('label_fks', aliasedName, true,
-              type: const StringType(), requiredDuringInsert: false)
-          .withConverter<List<int>>($TransactionsTable.$converter0);
+  late final GeneratedColumn<String?> iconName = GeneratedColumn<String?>(
+      'icon_name', aliasedName, true,
+      type: const StringType(), requiredDuringInsert: false);
   final VerificationMeta _dateCreatedMeta =
       const VerificationMeta('dateCreated');
   @override
@@ -907,6 +630,11 @@ class $TransactionsTable extends Transactions
           type: const IntType(),
           requiredDuringInsert: false,
           clientDefault: () => new DateTime.now());
+  final VerificationMeta _orderMeta = const VerificationMeta('order');
+  @override
+  late final GeneratedColumn<int?> order = GeneratedColumn<int?>(
+      'order', aliasedName, false,
+      type: const IntType(), requiredDuringInsert: true);
   final VerificationMeta _incomeMeta = const VerificationMeta('income');
   @override
   late final GeneratedColumn<bool?> income = GeneratedColumn<bool?>(
@@ -915,93 +643,24 @@ class $TransactionsTable extends Transactions
       requiredDuringInsert: false,
       defaultConstraints: 'CHECK (income IN (0, 1))',
       defaultValue: const Constant(false));
-  final VerificationMeta _periodLengthMeta =
-      const VerificationMeta('periodLength');
-  @override
-  late final GeneratedColumn<int?> periodLength = GeneratedColumn<int?>(
-      'period_length', aliasedName, true,
-      type: const IntType(), requiredDuringInsert: false);
-  final VerificationMeta _reoccurrenceMeta =
-      const VerificationMeta('reoccurrence');
-  @override
-  late final GeneratedColumnWithTypeConverter<BudgetReoccurence?, int?>
-      reoccurrence = GeneratedColumn<int?>('reoccurrence', aliasedName, true,
-              type: const IntType(), requiredDuringInsert: false)
-          .withConverter<BudgetReoccurence?>($TransactionsTable.$converter1);
-  final VerificationMeta _typeMeta = const VerificationMeta('type');
-  @override
-  late final GeneratedColumnWithTypeConverter<TransactionSpecialType?, int?>
-      type = GeneratedColumn<int?>('type', aliasedName, true,
-              type: const IntType(), requiredDuringInsert: false)
-          .withConverter<TransactionSpecialType?>(
-              $TransactionsTable.$converter2);
-  final VerificationMeta _paidMeta = const VerificationMeta('paid');
-  @override
-  late final GeneratedColumn<bool?> paid = GeneratedColumn<bool?>(
-      'paid', aliasedName, false,
-      type: const BoolType(),
-      requiredDuringInsert: false,
-      defaultConstraints: 'CHECK (paid IN (0, 1))',
-      defaultValue: const Constant(false));
-  final VerificationMeta _createdAnotherFutureTransactionMeta =
-      const VerificationMeta('createdAnotherFutureTransaction');
-  @override
-  late final GeneratedColumn<bool?> createdAnotherFutureTransaction =
-      GeneratedColumn<bool?>(
-          'created_another_future_transaction', aliasedName, true,
-          type: const BoolType(),
-          requiredDuringInsert: false,
-          defaultConstraints:
-              'CHECK (created_another_future_transaction IN (0, 1))',
-          defaultValue: const Constant(false));
-  final VerificationMeta _skipPaidMeta = const VerificationMeta('skipPaid');
-  @override
-  late final GeneratedColumn<bool?> skipPaid = GeneratedColumn<bool?>(
-      'skip_paid', aliasedName, false,
-      type: const BoolType(),
-      requiredDuringInsert: false,
-      defaultConstraints: 'CHECK (skip_paid IN (0, 1))',
-      defaultValue: const Constant(false));
-  final VerificationMeta _methodAddedMeta =
-      const VerificationMeta('methodAdded');
-  @override
-  late final GeneratedColumnWithTypeConverter<MethodAdded?, int?> methodAdded =
-      GeneratedColumn<int?>('method_added', aliasedName, true,
-              type: const IntType(), requiredDuringInsert: false)
-          .withConverter<MethodAdded?>($TransactionsTable.$converter3);
   @override
-  List<GeneratedColumn> get $columns => [
-        transactionPk,
-        name,
-        amount,
-        note,
-        categoryFk,
-        walletFk,
-        labelFks,
-        dateCreated,
-        income,
-        periodLength,
-        reoccurrence,
-        type,
-        paid,
-        createdAnotherFutureTransaction,
-        skipPaid,
-        methodAdded
-      ];
+  List<GeneratedColumn> get $columns =>
+      [categoryPk, name, colour, iconName, dateCreated, order, income];
   @override
-  String get aliasedName => _alias ?? 'transactions';
+  String get aliasedName => _alias ?? 'categories';
   @override
-  String get actualTableName => 'transactions';
+  String get actualTableName => 'categories';
   @override
-  VerificationContext validateIntegrity(Insertable<Transaction> instance,
+  VerificationContext validateIntegrity(
+      Insertable<TransactionCategory> instance,
       {bool isInserting = false}) {
     final context = VerificationContext();
     final data = instance.toColumns(true);
-    if (data.containsKey('transaction_pk')) {
+    if (data.containsKey('category_pk')) {
       context.handle(
-          _transactionPkMeta,
-          transactionPk.isAcceptableOrUnknown(
-              data['transaction_pk']!, _transactionPkMeta));
+          _categoryPkMeta,
+          categoryPk.isAcceptableOrUnknown(
+              data['category_pk']!, _categoryPkMeta));
     }
     if (data.containsKey('name')) {
       context.handle(
@@ -1009,355 +668,569 @@ class $TransactionsTable extends Transactions
     } else if (isInserting) {
       context.missing(_nameMeta);
     }
-    if (data.containsKey('amount')) {
-      context.handle(_amountMeta,
-          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
-    } else if (isInserting) {
-      context.missing(_amountMeta);
-    }
-    if (data.containsKey('note')) {
-      context.handle(
-          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
-    } else if (isInserting) {
-      context.missing(_noteMeta);
-    }
-    if (data.containsKey('category_fk')) {
-      context.handle(
-          _categoryFkMeta,
-          categoryFk.isAcceptableOrUnknown(
-              data['category_fk']!, _categoryFkMeta));
-    } else if (isInserting) {
-      context.missing(_categoryFkMeta);
+    if (data.containsKey('colour')) {
+      context.handle(_colourMeta,
+          colour.isAcceptableOrUnknown(data['colour']!, _colourMeta));
     }
-    if (data.containsKey('wallet_fk')) {
-      context.handle(_walletFkMeta,
-          walletFk.isAcceptableOrUnknown(data['wallet_fk']!, _walletFkMeta));
-    } else if (isInserting) {
-      context.missing(_walletFkMeta);
+    if (data.containsKey('icon_name')) {
+      context.handle(_iconNameMeta,
+          iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta));
     }
-    context.handle(_labelFksMeta, const VerificationResult.success());
     if (data.containsKey('date_created')) {
       context.handle(
           _dateCreatedMeta,
           dateCreated.isAcceptableOrUnknown(
               data['date_created']!, _dateCreatedMeta));
     }
+    if (data.containsKey('order')) {
+      context.handle(
+          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
+    } else if (isInserting) {
+      context.missing(_orderMeta);
+    }
     if (data.containsKey('income')) {
       context.handle(_incomeMeta,
           income.isAcceptableOrUnknown(data['income']!, _incomeMeta));
     }
-    if (data.containsKey('period_length')) {
-      context.handle(
-          _periodLengthMeta,
-          periodLength.isAcceptableOrUnknown(
-              data['period_length']!, _periodLengthMeta));
-    }
-    context.handle(_reoccurrenceMeta, const VerificationResult.success());
-    context.handle(_typeMeta, const VerificationResult.success());
-    if (data.containsKey('paid')) {
-      context.handle(
-          _paidMeta, paid.isAcceptableOrUnknown(data['paid']!, _paidMeta));
-    }
-    if (data.containsKey('created_another_future_transaction')) {
-      context.handle(
-          _createdAnotherFutureTransactionMeta,
-          createdAnotherFutureTransaction.isAcceptableOrUnknown(
-              data['created_another_future_transaction']!,
-              _createdAnotherFutureTransactionMeta));
-    }
-    if (data.containsKey('skip_paid')) {
-      context.handle(_skipPaidMeta,
-          skipPaid.isAcceptableOrUnknown(data['skip_paid']!, _skipPaidMeta));
-    }
-    context.handle(_methodAddedMeta, const VerificationResult.success());
     return context;
   }
 
   @override
-  Set<GeneratedColumn> get $primaryKey => {transactionPk};
+  Set<GeneratedColumn> get $primaryKey => {categoryPk};
   @override
-  Transaction map(Map<String, dynamic> data, {String? tablePrefix}) {
-    return Transaction.fromData(data,
+  TransactionCategory map(Map<String, dynamic> data, {String? tablePrefix}) {
+    return TransactionCategory.fromData(data,
         prefix: tablePrefix != null ? '$tablePrefix.' : null);
   }
 
   @override
-  $TransactionsTable createAlias(String alias) {
-    return $TransactionsTable(attachedDatabase, alias);
+  $CategoriesTable createAlias(String alias) {
+    return $CategoriesTable(attachedDatabase, alias);
   }
-
-  static TypeConverter<List<int>, String> $converter0 =
-      const IntListInColumnConverter();
-  static TypeConverter<BudgetReoccurence?, int> $converter1 =
-      const EnumIndexConverter<BudgetReoccurence>(BudgetReoccurence.values);
-  static TypeConverter<TransactionSpecialType?, int> $converter2 =
-      const EnumIndexConverter<TransactionSpecialType>(
-          TransactionSpecialType.values);
-  static TypeConverter<MethodAdded?, int> $converter3 =
-      const EnumIndexConverter<MethodAdded>(MethodAdded.values);
 }
 
-class TransactionCategory extends DataClass
-    implements Insertable<TransactionCategory> {
-  final int categoryPk;
+class Transaction extends DataClass implements Insertable<Transaction> {
+  final int transactionPk;
   final String name;
-  final String? colour;
-  final String? iconName;
+  final double amount;
+  final String note;
+  final int categoryFk;
+  final int walletFk;
+  final List<int>? labelFks;
   final DateTime dateCreated;
-  final int order;
   final bool income;
-  TransactionCategory(
-      {required this.categoryPk,
+  final int? periodLength;
+  final BudgetReoccurence? reoccurrence;
+  final TransactionSpecialType? type;
+  final bool paid;
+  final bool? createdAnotherFutureTransaction;
+  final bool skipPaid;
+  final MethodAdded? methodAdded;
+  Transaction(
+      {required this.transactionPk,
       required this.name,
-      this.colour,
-      this.iconName,
+      required this.amount,
+      required this.note,
+      required this.categoryFk,
+      required this.walletFk,
+      this.labelFks,
       required this.dateCreated,
-      required this.order,
-      required this.income});
-  factory TransactionCategory.fromData(Map<String, dynamic> data,
-      {String? prefix}) {
-    final effectivePrefix = prefix ?? '';
-    return TransactionCategory(
-      categoryPk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}category_pk'])!,
-      name: const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}name'])!,
-      colour: const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}colour']),
-      iconName: const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}icon_name']),
+      required this.income,
+      this.periodLength,
+      this.reoccurrence,
+      this.type,
+      required this.paid,
+      this.createdAnotherFutureTransaction,
+      required this.skipPaid,
+      this.methodAdded});
+  factory Transaction.fromData(Map<String, dynamic> data, {String? prefix}) {
+    final effectivePrefix = prefix ?? '';
+    return Transaction(
+      transactionPk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}transaction_pk'])!,
+      name: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}name'])!,
+      amount: const RealType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}amount'])!,
+      note: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}note'])!,
+      categoryFk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}category_fk'])!,
+      walletFk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}wallet_fk'])!,
+      labelFks: $TransactionsTable.$converter0.mapToDart(const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}label_fks'])),
       dateCreated: const DateTimeType()
           .mapFromDatabaseResponse(data['${effectivePrefix}date_created'])!,
-      order: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}order'])!,
       income: const BoolType()
           .mapFromDatabaseResponse(data['${effectivePrefix}income'])!,
+      periodLength: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}period_length']),
+      reoccurrence: $TransactionsTable.$converter1.mapToDart(const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}reoccurrence'])),
+      type: $TransactionsTable.$converter2.mapToDart(const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}type'])),
+      paid: const BoolType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}paid'])!,
+      createdAnotherFutureTransaction: const BoolType().mapFromDatabaseResponse(
+          data['${effectivePrefix}created_another_future_transaction']),
+      skipPaid: const BoolType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}skip_paid'])!,
+      methodAdded: $TransactionsTable.$converter3.mapToDart(const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}method_added'])),
     );
   }
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    map['category_pk'] = Variable<int>(categoryPk);
+    map['transaction_pk'] = Variable<int>(transactionPk);
     map['name'] = Variable<String>(name);
-    if (!nullToAbsent || colour != null) {
-      map['colour'] = Variable<String?>(colour);
-    }
-    if (!nullToAbsent || iconName != null) {
-      map['icon_name'] = Variable<String?>(iconName);
+    map['amount'] = Variable<double>(amount);
+    map['note'] = Variable<String>(note);
+    map['category_fk'] = Variable<int>(categoryFk);
+    map['wallet_fk'] = Variable<int>(walletFk);
+    if (!nullToAbsent || labelFks != null) {
+      final converter = $TransactionsTable.$converter0;
+      map['label_fks'] = Variable<String?>(converter.mapToSql(labelFks));
     }
     map['date_created'] = Variable<DateTime>(dateCreated);
-    map['order'] = Variable<int>(order);
     map['income'] = Variable<bool>(income);
+    if (!nullToAbsent || periodLength != null) {
+      map['period_length'] = Variable<int?>(periodLength);
+    }
+    if (!nullToAbsent || reoccurrence != null) {
+      final converter = $TransactionsTable.$converter1;
+      map['reoccurrence'] = Variable<int?>(converter.mapToSql(reoccurrence));
+    }
+    if (!nullToAbsent || type != null) {
+      final converter = $TransactionsTable.$converter2;
+      map['type'] = Variable<int?>(converter.mapToSql(type));
+    }
+    map['paid'] = Variable<bool>(paid);
+    if (!nullToAbsent || createdAnotherFutureTransaction != null) {
+      map['created_another_future_transaction'] =
+          Variable<bool?>(createdAnotherFutureTransaction);
+    }
+    map['skip_paid'] = Variable<bool>(skipPaid);
+    if (!nullToAbsent || methodAdded != null) {
+      final converter = $TransactionsTable.$converter3;
+      map['method_added'] = Variable<int?>(converter.mapToSql(methodAdded));
+    }
     return map;
   }
 
-  CategoriesCompanion toCompanion(bool nullToAbsent) {
-    return CategoriesCompanion(
-      categoryPk: Value(categoryPk),
+  TransactionsCompanion toCompanion(bool nullToAbsent) {
+    return TransactionsCompanion(
+      transactionPk: Value(transactionPk),
       name: Value(name),
-      colour:
-          colour == null && nullToAbsent ? const Value.absent() : Value(colour),
-      iconName: iconName == null && nullToAbsent
+      amount: Value(amount),
+      note: Value(note),
+      categoryFk: Value(categoryFk),
+      walletFk: Value(walletFk),
+      labelFks: labelFks == null && nullToAbsent
           ? const Value.absent()
-          : Value(iconName),
+          : Value(labelFks),
       dateCreated: Value(dateCreated),
-      order: Value(order),
       income: Value(income),
+      periodLength: periodLength == null && nullToAbsent
+          ? const Value.absent()
+          : Value(periodLength),
+      reoccurrence: reoccurrence == null && nullToAbsent
+          ? const Value.absent()
+          : Value(reoccurrence),
+      type: type == null && nullToAbsent ? const Value.absent() : Value(type),
+      paid: Value(paid),
+      createdAnotherFutureTransaction:
+          createdAnotherFutureTransaction == null && nullToAbsent
+              ? const Value.absent()
+              : Value(createdAnotherFutureTransaction),
+      skipPaid: Value(skipPaid),
+      methodAdded: methodAdded == null && nullToAbsent
+          ? const Value.absent()
+          : Value(methodAdded),
     );
   }
 
-  factory TransactionCategory.fromJson(Map<String, dynamic> json,
+  factory Transaction.fromJson(Map<String, dynamic> json,
       {ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
-    return TransactionCategory(
-      categoryPk: serializer.fromJson<int>(json['categoryPk']),
+    return Transaction(
+      transactionPk: serializer.fromJson<int>(json['transactionPk']),
       name: serializer.fromJson<String>(json['name']),
-      colour: serializer.fromJson<String?>(json['colour']),
-      iconName: serializer.fromJson<String?>(json['iconName']),
+      amount: serializer.fromJson<double>(json['amount']),
+      note: serializer.fromJson<String>(json['note']),
+      categoryFk: serializer.fromJson<int>(json['categoryFk']),
+      walletFk: serializer.fromJson<int>(json['walletFk']),
+      labelFks: serializer.fromJson<List<int>?>(json['labelFks']),
       dateCreated: serializer.fromJson<DateTime>(json['dateCreated']),
-      order: serializer.fromJson<int>(json['order']),
       income: serializer.fromJson<bool>(json['income']),
+      periodLength: serializer.fromJson<int?>(json['periodLength']),
+      reoccurrence:
+          serializer.fromJson<BudgetReoccurence?>(json['reoccurrence']),
+      type: serializer.fromJson<TransactionSpecialType?>(json['type']),
+      paid: serializer.fromJson<bool>(json['paid']),
+      createdAnotherFutureTransaction:
+          serializer.fromJson<bool?>(json['createdAnotherFutureTransaction']),
+      skipPaid: serializer.fromJson<bool>(json['skipPaid']),
+      methodAdded: serializer.fromJson<MethodAdded?>(json['methodAdded']),
     );
   }
   @override
   Map<String, dynamic> toJson({ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
     return <String, dynamic>{
-      'categoryPk': serializer.toJson<int>(categoryPk),
+      'transactionPk': serializer.toJson<int>(transactionPk),
       'name': serializer.toJson<String>(name),
-      'colour': serializer.toJson<String?>(colour),
-      'iconName': serializer.toJson<String?>(iconName),
+      'amount': serializer.toJson<double>(amount),
+      'note': serializer.toJson<String>(note),
+      'categoryFk': serializer.toJson<int>(categoryFk),
+      'walletFk': serializer.toJson<int>(walletFk),
+      'labelFks': serializer.toJson<List<int>?>(labelFks),
       'dateCreated': serializer.toJson<DateTime>(dateCreated),
-      'order': serializer.toJson<int>(order),
       'income': serializer.toJson<bool>(income),
+      'periodLength': serializer.toJson<int?>(periodLength),
+      'reoccurrence': serializer.toJson<BudgetReoccurence?>(reoccurrence),
+      'type': serializer.toJson<TransactionSpecialType?>(type),
+      'paid': serializer.toJson<bool>(paid),
+      'createdAnotherFutureTransaction':
+          serializer.toJson<bool?>(createdAnotherFutureTransaction),
+      'skipPaid': serializer.toJson<bool>(skipPaid),
+      'methodAdded': serializer.toJson<MethodAdded?>(methodAdded),
     };
   }
 
-  TransactionCategory copyWith(
-          {int? categoryPk,
+  Transaction copyWith(
+          {int? transactionPk,
           String? name,
-          String? colour,
-          String? iconName,
+          double? amount,
+          String? note,
+          int? categoryFk,
+          int? walletFk,
+          List<int>? labelFks,
           DateTime? dateCreated,
-          int? order,
-          bool? income}) =>
-      TransactionCategory(
-        categoryPk: categoryPk ?? this.categoryPk,
+          bool? income,
+          int? periodLength,
+          BudgetReoccurence? reoccurrence,
+          TransactionSpecialType? type,
+          bool? paid,
+          bool? createdAnotherFutureTransaction,
+          bool? skipPaid,
+          MethodAdded? methodAdded}) =>
+      Transaction(
+        transactionPk: transactionPk ?? this.transactionPk,
         name: name ?? this.name,
-        colour: colour ?? this.colour,
-        iconName: iconName ?? this.iconName,
+        amount: amount ?? this.amount,
+        note: note ?? this.note,
+        categoryFk: categoryFk ?? this.categoryFk,
+        walletFk: walletFk ?? this.walletFk,
+        labelFks: labelFks ?? this.labelFks,
         dateCreated: dateCreated ?? this.dateCreated,
-        order: order ?? this.order,
         income: income ?? this.income,
+        periodLength: periodLength ?? this.periodLength,
+        reoccurrence: reoccurrence ?? this.reoccurrence,
+        type: type ?? this.type,
+        paid: paid ?? this.paid,
+        createdAnotherFutureTransaction: createdAnotherFutureTransaction ??
+            this.createdAnotherFutureTransaction,
+        skipPaid: skipPaid ?? this.skipPaid,
+        methodAdded: methodAdded ?? this.methodAdded,
       );
   @override
   String toString() {
-    return (StringBuffer('TransactionCategory(')
-          ..write('categoryPk: $categoryPk, ')
+    return (StringBuffer('Transaction(')
+          ..write('transactionPk: $transactionPk, ')
           ..write('name: $name, ')
-          ..write('colour: $colour, ')
-          ..write('iconName: $iconName, ')
+          ..write('amount: $amount, ')
+          ..write('note: $note, ')
+          ..write('categoryFk: $categoryFk, ')
+          ..write('walletFk: $walletFk, ')
+          ..write('labelFks: $labelFks, ')
           ..write('dateCreated: $dateCreated, ')
-          ..write('order: $order, ')
-          ..write('income: $income')
+          ..write('income: $income, ')
+          ..write('periodLength: $periodLength, ')
+          ..write('reoccurrence: $reoccurrence, ')
+          ..write('type: $type, ')
+          ..write('paid: $paid, ')
+          ..write(
+              'createdAnotherFutureTransaction: $createdAnotherFutureTransaction, ')
+          ..write('skipPaid: $skipPaid, ')
+          ..write('methodAdded: $methodAdded')
           ..write(')'))
         .toString();
   }
 
   @override
   int get hashCode => Object.hash(
-      categoryPk, name, colour, iconName, dateCreated, order, income);
+      transactionPk,
+      name,
+      amount,
+      note,
+      categoryFk,
+      walletFk,
+      labelFks,
+      dateCreated,
+      income,
+      periodLength,
+      reoccurrence,
+      type,
+      paid,
+      createdAnotherFutureTransaction,
+      skipPaid,
+      methodAdded);
   @override
   bool operator ==(Object other) =>
       identical(this, other) ||
-      (other is TransactionCategory &&
-          other.categoryPk == this.categoryPk &&
+      (other is Transaction &&
+          other.transactionPk == this.transactionPk &&
           other.name == this.name &&
-          other.colour == this.colour &&
-          other.iconName == this.iconName &&
+          other.amount == this.amount &&
+          other.note == this.note &&
+          other.categoryFk == this.categoryFk &&
+          other.walletFk == this.walletFk &&
+          other.labelFks == this.labelFks &&
           other.dateCreated == this.dateCreated &&
-          other.order == this.order &&
-          other.income == this.income);
+          other.income == this.income &&
+          other.periodLength == this.periodLength &&
+          other.reoccurrence == this.reoccurrence &&
+          other.type == this.type &&
+          other.paid == this.paid &&
+          other.createdAnotherFutureTransaction ==
+              this.createdAnotherFutureTransaction &&
+          other.skipPaid == this.skipPaid &&
+          other.methodAdded == this.methodAdded);
 }
 
-class CategoriesCompanion extends UpdateCompanion<TransactionCategory> {
-  final Value<int> categoryPk;
+class TransactionsCompanion extends UpdateCompanion<Transaction> {
+  final Value<int> transactionPk;
   final Value<String> name;
-  final Value<String?> colour;
-  final Value<String?> iconName;
+  final Value<double> amount;
+  final Value<String> note;
+  final Value<int> categoryFk;
+  final Value<int> walletFk;
+  final Value<List<int>?> labelFks;
   final Value<DateTime> dateCreated;
-  final Value<int> order;
   final Value<bool> income;
-  const CategoriesCompanion({
-    this.categoryPk = const Value.absent(),
+  final Value<int?> periodLength;
+  final Value<BudgetReoccurence?> reoccurrence;
+  final Value<TransactionSpecialType?> type;
+  final Value<bool> paid;
+  final Value<bool?> createdAnotherFutureTransaction;
+  final Value<bool> skipPaid;
+  final Value<MethodAdded?> methodAdded;
+  const TransactionsCompanion({
+    this.transactionPk = const Value.absent(),
     this.name = const Value.absent(),
-    this.colour = const Value.absent(),
-    this.iconName = const Value.absent(),
+    this.amount = const Value.absent(),
+    this.note = const Value.absent(),
+    this.categoryFk = const Value.absent(),
+    this.walletFk = const Value.absent(),
+    this.labelFks = const Value.absent(),
     this.dateCreated = const Value.absent(),
-    this.order = const Value.absent(),
     this.income = const Value.absent(),
+    this.periodLength = const Value.absent(),
+    this.reoccurrence = const Value.absent(),
+    this.type = const Value.absent(),
+    this.paid = const Value.absent(),
+    this.createdAnotherFutureTransaction = const Value.absent(),
+    this.skipPaid = const Value.absent(),
+    this.methodAdded = const Value.absent(),
   });
-  CategoriesCompanion.insert({
-    this.categoryPk = const Value.absent(),
+  TransactionsCompanion.insert({
+    this.transactionPk = const Value.absent(),
     required String name,
-    this.colour = const Value.absent(),
-    this.iconName = const Value.absent(),
+    required double amount,
+    required String note,
+    required int categoryFk,
+    required int walletFk,
+    this.labelFks = const Value.absent(),
     this.dateCreated = const Value.absent(),
-    required int order,
     this.income = const Value.absent(),
+    this.periodLength = const Value.absent(),
+    this.reoccurrence = const Value.absent(),
+    this.type = const Value.absent(),
+    this.paid = const Value.absent(),
+    this.createdAnotherFutureTransaction = const Value.absent(),
+    this.skipPaid = const Value.absent(),
+    this.methodAdded = const Value.absent(),
   })  : name = Value(name),
-        order = Value(order);
-  static Insertable<TransactionCategory> custom({
-    Expression<int>? categoryPk,
+        amount = Value(amount),
+        note = Value(note),
+        categoryFk = Value(categoryFk),
+        walletFk = Value(walletFk);
+  static Insertable<Transaction> custom({
+    Expression<int>? transactionPk,
     Expression<String>? name,
-    Expression<String?>? colour,
-    Expression<String?>? iconName,
+    Expression<double>? amount,
+    Expression<String>? note,
+    Expression<int>? categoryFk,
+    Expression<int>? walletFk,
+    Expression<List<int>?>? labelFks,
     Expression<DateTime>? dateCreated,
-    Expression<int>? order,
     Expression<bool>? income,
+    Expression<int?>? periodLength,
+    Expression<BudgetReoccurence?>? reoccurrence,
+    Expression<TransactionSpecialType?>? type,
+    Expression<bool>? paid,
+    Expression<bool?>? createdAnotherFutureTransaction,
+    Expression<bool>? skipPaid,
+    Expression<MethodAdded?>? methodAdded,
   }) {
     return RawValuesInsertable({
-      if (categoryPk != null) 'category_pk': categoryPk,
+      if (transactionPk != null) 'transaction_pk': transactionPk,
       if (name != null) 'name': name,
-      if (colour != null) 'colour': colour,
-      if (iconName != null) 'icon_name': iconName,
+      if (amount != null) 'amount': amount,
+      if (note != null) 'note': note,
+      if (categoryFk != null) 'category_fk': categoryFk,
+      if (walletFk != null) 'wallet_fk': walletFk,
+      if (labelFks != null) 'label_fks': labelFks,
       if (dateCreated != null) 'date_created': dateCreated,
-      if (order != null) 'order': order,
       if (income != null) 'income': income,
+      if (periodLength != null) 'period_length': periodLength,
+      if (reoccurrence != null) 'reoccurrence': reoccurrence,
+      if (type != null) 'type': type,
+      if (paid != null) 'paid': paid,
+      if (createdAnotherFutureTransaction != null)
+        'created_another_future_transaction': createdAnotherFutureTransaction,
+      if (skipPaid != null) 'skip_paid': skipPaid,
+      if (methodAdded != null) 'method_added': methodAdded,
     });
   }
 
-  CategoriesCompanion copyWith(
-      {Value<int>? categoryPk,
+  TransactionsCompanion copyWith(
+      {Value<int>? transactionPk,
       Value<String>? name,
-      Value<String?>? colour,
-      Value<String?>? iconName,
+      Value<double>? amount,
+      Value<String>? note,
+      Value<int>? categoryFk,
+      Value<int>? walletFk,
+      Value<List<int>?>? labelFks,
       Value<DateTime>? dateCreated,
-      Value<int>? order,
-      Value<bool>? income}) {
-    return CategoriesCompanion(
-      categoryPk: categoryPk ?? this.categoryPk,
+      Value<bool>? income,
+      Value<int?>? periodLength,
+      Value<BudgetReoccurence?>? reoccurrence,
+      Value<TransactionSpecialType?>? type,
+      Value<bool>? paid,
+      Value<bool?>? createdAnotherFutureTransaction,
+      Value<bool>? skipPaid,
+      Value<MethodAdded?>? methodAdded}) {
+    return TransactionsCompanion(
+      transactionPk: transactionPk ?? this.transactionPk,
       name: name ?? this.name,
-      colour: colour ?? this.colour,
-      iconName: iconName ?? this.iconName,
+      amount: amount ?? this.amount,
+      note: note ?? this.note,
+      categoryFk: categoryFk ?? this.categoryFk,
+      walletFk: walletFk ?? this.walletFk,
+      labelFks: labelFks ?? this.labelFks,
       dateCreated: dateCreated ?? this.dateCreated,
-      order: order ?? this.order,
       income: income ?? this.income,
+      periodLength: periodLength ?? this.periodLength,
+      reoccurrence: reoccurrence ?? this.reoccurrence,
+      type: type ?? this.type,
+      paid: paid ?? this.paid,
+      createdAnotherFutureTransaction: createdAnotherFutureTransaction ??
+          this.createdAnotherFutureTransaction,
+      skipPaid: skipPaid ?? this.skipPaid,
+      methodAdded: methodAdded ?? this.methodAdded,
     );
   }
 
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    if (categoryPk.present) {
-      map['category_pk'] = Variable<int>(categoryPk.value);
+    if (transactionPk.present) {
+      map['transaction_pk'] = Variable<int>(transactionPk.value);
     }
     if (name.present) {
       map['name'] = Variable<String>(name.value);
     }
-    if (colour.present) {
-      map['colour'] = Variable<String?>(colour.value);
+    if (amount.present) {
+      map['amount'] = Variable<double>(amount.value);
     }
-    if (iconName.present) {
-      map['icon_name'] = Variable<String?>(iconName.value);
+    if (note.present) {
+      map['note'] = Variable<String>(note.value);
+    }
+    if (categoryFk.present) {
+      map['category_fk'] = Variable<int>(categoryFk.value);
+    }
+    if (walletFk.present) {
+      map['wallet_fk'] = Variable<int>(walletFk.value);
+    }
+    if (labelFks.present) {
+      final converter = $TransactionsTable.$converter0;
+      map['label_fks'] = Variable<String?>(converter.mapToSql(labelFks.value));
     }
     if (dateCreated.present) {
       map['date_created'] = Variable<DateTime>(dateCreated.value);
     }
-    if (order.present) {
-      map['order'] = Variable<int>(order.value);
-    }
     if (income.present) {
       map['income'] = Variable<bool>(income.value);
     }
+    if (periodLength.present) {
+      map['period_length'] = Variable<int?>(periodLength.value);
+    }
+    if (reoccurrence.present) {
+      final converter = $TransactionsTable.$converter1;
+      map['reoccurrence'] =
+          Variable<int?>(converter.mapToSql(reoccurrence.value));
+    }
+    if (type.present) {
+      final converter = $TransactionsTable.$converter2;
+      map['type'] = Variable<int?>(converter.mapToSql(type.value));
+    }
+    if (paid.present) {
+      map['paid'] = Variable<bool>(paid.value);
+    }
+    if (createdAnotherFutureTransaction.present) {
+      map['created_another_future_transaction'] =
+          Variable<bool?>(createdAnotherFutureTransaction.value);
+    }
+    if (skipPaid.present) {
+      map['skip_paid'] = Variable<bool>(skipPaid.value);
+    }
+    if (methodAdded.present) {
+      final converter = $TransactionsTable.$converter3;
+      map['method_added'] =
+          Variable<int?>(converter.mapToSql(methodAdded.value));
+    }
     return map;
   }
 
   @override
   String toString() {
-    return (StringBuffer('CategoriesCompanion(')
-          ..write('categoryPk: $categoryPk, ')
+    return (StringBuffer('TransactionsCompanion(')
+          ..write('transactionPk: $transactionPk, ')
           ..write('name: $name, ')
-          ..write('colour: $colour, ')
-          ..write('iconName: $iconName, ')
+          ..write('amount: $amount, ')
+          ..write('note: $note, ')
+          ..write('categoryFk: $categoryFk, ')
+          ..write('walletFk: $walletFk, ')
+          ..write('labelFks: $labelFks, ')
           ..write('dateCreated: $dateCreated, ')
-          ..write('order: $order, ')
-          ..write('income: $income')
+          ..write('income: $income, ')
+          ..write('periodLength: $periodLength, ')
+          ..write('reoccurrence: $reoccurrence, ')
+          ..write('type: $type, ')
+          ..write('paid: $paid, ')
+          ..write(
+              'createdAnotherFutureTransaction: $createdAnotherFutureTransaction, ')
+          ..write('skipPaid: $skipPaid, ')
+          ..write('methodAdded: $methodAdded')
           ..write(')'))
         .toString();
   }
 }
 
-class $CategoriesTable extends Categories
-    with TableInfo<$CategoriesTable, TransactionCategory> {
+class $TransactionsTable extends Transactions
+    with TableInfo<$TransactionsTable, Transaction> {
   @override
   final GeneratedDatabase attachedDatabase;
   final String? _alias;
-  $CategoriesTable(this.attachedDatabase, [this._alias]);
-  final VerificationMeta _categoryPkMeta = const VerificationMeta('categoryPk');
+  $TransactionsTable(this.attachedDatabase, [this._alias]);
+  final VerificationMeta _transactionPkMeta =
+      const VerificationMeta('transactionPk');
   @override
-  late final GeneratedColumn<int?> categoryPk = GeneratedColumn<int?>(
-      'category_pk', aliasedName, false,
+  late final GeneratedColumn<int?> transactionPk = GeneratedColumn<int?>(
+      'transaction_pk', aliasedName, false,
       type: const IntType(),
       requiredDuringInsert: false,
       defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
@@ -1368,31 +1241,46 @@ class $CategoriesTable extends Categories
       additionalChecks: GeneratedColumn.checkTextLength(),
       type: const StringType(),
       requiredDuringInsert: true);
-  final VerificationMeta _colourMeta = const VerificationMeta('colour');
+  final VerificationMeta _amountMeta = const VerificationMeta('amount');
   @override
-  late final GeneratedColumn<String?> colour = GeneratedColumn<String?>(
-      'colour', aliasedName, true,
+  late final GeneratedColumn<double?> amount = GeneratedColumn<double?>(
+      'amount', aliasedName, false,
+      type: const RealType(), requiredDuringInsert: true);
+  final VerificationMeta _noteMeta = const VerificationMeta('note');
+  @override
+  late final GeneratedColumn<String?> note = GeneratedColumn<String?>(
+      'note', aliasedName, false,
       additionalChecks: GeneratedColumn.checkTextLength(),
       type: const StringType(),
-      requiredDuringInsert: false);
-  final VerificationMeta _iconNameMeta = const VerificationMeta('iconName');
+      requiredDuringInsert: true);
+  final VerificationMeta _categoryFkMeta = const VerificationMeta('categoryFk');
   @override
-  late final GeneratedColumn<String?> iconName = GeneratedColumn<String?>(
-      'icon_name', aliasedName, true,
-      type: const StringType(), requiredDuringInsert: false);
-  final VerificationMeta _dateCreatedMeta =
-      const VerificationMeta('dateCreated');
+  late final GeneratedColumn<int?> categoryFk = GeneratedColumn<int?>(
+      'category_fk', aliasedName, false,
+      type: const IntType(),
+      requiredDuringInsert: true,
+      defaultConstraints: 'REFERENCES categories (category_pk)');
+  final VerificationMeta _walletFkMeta = const VerificationMeta('walletFk');
   @override
-  late final GeneratedColumn<DateTime?> dateCreated =
-      GeneratedColumn<DateTime?>('date_created', aliasedName, false,
-          type: const IntType(),
-          requiredDuringInsert: false,
-          clientDefault: () => new DateTime.now());
-  final VerificationMeta _orderMeta = const VerificationMeta('order');
+  late final GeneratedColumn<int?> walletFk = GeneratedColumn<int?>(
+      'wallet_fk', aliasedName, false,
+      type: const IntType(),
+      requiredDuringInsert: true,
+      defaultConstraints: 'REFERENCES wallets (wallet_pk)');
+  final VerificationMeta _labelFksMeta = const VerificationMeta('labelFks');
   @override
-  late final GeneratedColumn<int?> order = GeneratedColumn<int?>(
-      'order', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
+  late final GeneratedColumnWithTypeConverter<List<int>, String?> labelFks =
+      GeneratedColumn<String?>('label_fks', aliasedName, true,
+              type: const StringType(), requiredDuringInsert: false)
+          .withConverter<List<int>>($TransactionsTable.$converter0);
+  final VerificationMeta _dateCreatedMeta =
+      const VerificationMeta('dateCreated');
+  @override
+  late final GeneratedColumn<DateTime?> dateCreated =
+      GeneratedColumn<DateTime?>('date_created', aliasedName, false,
+          type: const IntType(),
+          requiredDuringInsert: false,
+          clientDefault: () => new DateTime.now());
   final VerificationMeta _incomeMeta = const VerificationMeta('income');
   @override
   late final GeneratedColumn<bool?> income = GeneratedColumn<bool?>(
@@ -1401,24 +1289,93 @@ class $CategoriesTable extends Categories
       requiredDuringInsert: false,
       defaultConstraints: 'CHECK (income IN (0, 1))',
       defaultValue: const Constant(false));
+  final VerificationMeta _periodLengthMeta =
+      const VerificationMeta('periodLength');
   @override
-  List<GeneratedColumn> get $columns =>
-      [categoryPk, name, colour, iconName, dateCreated, order, income];
+  late final GeneratedColumn<int?> periodLength = GeneratedColumn<int?>(
+      'period_length', aliasedName, true,
+      type: const IntType(), requiredDuringInsert: false);
+  final VerificationMeta _reoccurrenceMeta =
+      const VerificationMeta('reoccurrence');
   @override
-  String get aliasedName => _alias ?? 'categories';
+  late final GeneratedColumnWithTypeConverter<BudgetReoccurence?, int?>
+      reoccurrence = GeneratedColumn<int?>('reoccurrence', aliasedName, true,
+              type: const IntType(), requiredDuringInsert: false)
+          .withConverter<BudgetReoccurence?>($TransactionsTable.$converter1);
+  final VerificationMeta _typeMeta = const VerificationMeta('type');
   @override
-  String get actualTableName => 'categories';
+  late final GeneratedColumnWithTypeConverter<TransactionSpecialType?, int?>
+      type = GeneratedColumn<int?>('type', aliasedName, true,
+              type: const IntType(), requiredDuringInsert: false)
+          .withConverter<TransactionSpecialType?>(
+              $TransactionsTable.$converter2);
+  final VerificationMeta _paidMeta = const VerificationMeta('paid');
   @override
-  VerificationContext validateIntegrity(
-      Insertable<TransactionCategory> instance,
+  late final GeneratedColumn<bool?> paid = GeneratedColumn<bool?>(
+      'paid', aliasedName, false,
+      type: const BoolType(),
+      requiredDuringInsert: false,
+      defaultConstraints: 'CHECK (paid IN (0, 1))',
+      defaultValue: const Constant(false));
+  final VerificationMeta _createdAnotherFutureTransactionMeta =
+      const VerificationMeta('createdAnotherFutureTransaction');
+  @override
+  late final GeneratedColumn<bool?> createdAnotherFutureTransaction =
+      GeneratedColumn<bool?>(
+          'created_another_future_transaction', aliasedName, true,
+          type: const BoolType(),
+          requiredDuringInsert: false,
+          defaultConstraints:
+              'CHECK (created_another_future_transaction IN (0, 1))',
+          defaultValue: const Constant(false));
+  final VerificationMeta _skipPaidMeta = const VerificationMeta('skipPaid');
+  @override
+  late final GeneratedColumn<bool?> skipPaid = GeneratedColumn<bool?>(
+      'skip_paid', aliasedName, false,
+      type: const BoolType(),
+      requiredDuringInsert: false,
+      defaultConstraints: 'CHECK (skip_paid IN (0, 1))',
+      defaultValue: const Constant(false));
+  final VerificationMeta _methodAddedMeta =
+      const VerificationMeta('methodAdded');
+  @override
+  late final GeneratedColumnWithTypeConverter<MethodAdded?, int?> methodAdded =
+      GeneratedColumn<int?>('method_added', aliasedName, true,
+              type: const IntType(), requiredDuringInsert: false)
+          .withConverter<MethodAdded?>($TransactionsTable.$converter3);
+  @override
+  List<GeneratedColumn> get $columns => [
+        transactionPk,
+        name,
+        amount,
+        note,
+        categoryFk,
+        walletFk,
+        labelFks,
+        dateCreated,
+        income,
+        periodLength,
+        reoccurrence,
+        type,
+        paid,
+        createdAnotherFutureTransaction,
+        skipPaid,
+        methodAdded
+      ];
+  @override
+  String get aliasedName => _alias ?? 'transactions';
+  @override
+  String get actualTableName => 'transactions';
+  @override
+  VerificationContext validateIntegrity(Insertable<Transaction> instance,
       {bool isInserting = false}) {
     final context = VerificationContext();
     final data = instance.toColumns(true);
-    if (data.containsKey('category_pk')) {
+    if (data.containsKey('transaction_pk')) {
       context.handle(
-          _categoryPkMeta,
-          categoryPk.isAcceptableOrUnknown(
-              data['category_pk']!, _categoryPkMeta));
+          _transactionPkMeta,
+          transactionPk.isAcceptableOrUnknown(
+              data['transaction_pk']!, _transactionPkMeta));
     }
     if (data.containsKey('name')) {
       context.handle(
@@ -1426,45 +1383,92 @@ class $CategoriesTable extends Categories
     } else if (isInserting) {
       context.missing(_nameMeta);
     }
-    if (data.containsKey('colour')) {
-      context.handle(_colourMeta,
-          colour.isAcceptableOrUnknown(data['colour']!, _colourMeta));
+    if (data.containsKey('amount')) {
+      context.handle(_amountMeta,
+          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
+    } else if (isInserting) {
+      context.missing(_amountMeta);
     }
-    if (data.containsKey('icon_name')) {
-      context.handle(_iconNameMeta,
-          iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta));
+    if (data.containsKey('note')) {
+      context.handle(
+          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
+    } else if (isInserting) {
+      context.missing(_noteMeta);
+    }
+    if (data.containsKey('category_fk')) {
+      context.handle(
+          _categoryFkMeta,
+          categoryFk.isAcceptableOrUnknown(
+              data['category_fk']!, _categoryFkMeta));
+    } else if (isInserting) {
+      context.missing(_categoryFkMeta);
+    }
+    if (data.containsKey('wallet_fk')) {
+      context.handle(_walletFkMeta,
+          walletFk.isAcceptableOrUnknown(data['wallet_fk']!, _walletFkMeta));
+    } else if (isInserting) {
+      context.missing(_walletFkMeta);
     }
+    context.handle(_labelFksMeta, const VerificationResult.success());
     if (data.containsKey('date_created')) {
       context.handle(
           _dateCreatedMeta,
           dateCreated.isAcceptableOrUnknown(
               data['date_created']!, _dateCreatedMeta));
     }
-    if (data.containsKey('order')) {
-      context.handle(
-          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
-    } else if (isInserting) {
-      context.missing(_orderMeta);
-    }
     if (data.containsKey('income')) {
       context.handle(_incomeMeta,
           income.isAcceptableOrUnknown(data['income']!, _incomeMeta));
     }
+    if (data.containsKey('period_length')) {
+      context.handle(
+          _periodLengthMeta,
+          periodLength.isAcceptableOrUnknown(
+              data['period_length']!, _periodLengthMeta));
+    }
+    context.handle(_reoccurrenceMeta, const VerificationResult.success());
+    context.handle(_typeMeta, const VerificationResult.success());
+    if (data.containsKey('paid')) {
+      context.handle(
+          _paidMeta, paid.isAcceptableOrUnknown(data['paid']!, _paidMeta));
+    }
+    if (data.containsKey('created_another_future_transaction')) {
+      context.handle(
+          _createdAnotherFutureTransactionMeta,
+          createdAnotherFutureTransaction.isAcceptableOrUnknown(
+              data['created_another_future_transaction']!,
+              _createdAnotherFutureTransactionMeta));
+    }
+    if (data.containsKey('skip_paid')) {
+      context.handle(_skipPaidMeta,
+          skipPaid.isAcceptableOrUnknown(data['skip_paid']!, _skipPaidMeta));
+    }
+    context.handle(_methodAddedMeta, const VerificationResult.success());
     return context;
   }
 
   @override
-  Set<GeneratedColumn> get $primaryKey => {categoryPk};
+  Set<GeneratedColumn> get $primaryKey => {transactionPk};
   @override
-  TransactionCategory map(Map<String, dynamic> data, {String? tablePrefix}) {
-    return TransactionCategory.fromData(data,
+  Transaction map(Map<String, dynamic> data, {String? tablePrefix}) {
+    return Transaction.fromData(data,
         prefix: tablePrefix != null ? '$tablePrefix.' : null);
   }
 
   @override
-  $CategoriesTable createAlias(String alias) {
-    return $CategoriesTable(attachedDatabase, alias);
+  $TransactionsTable createAlias(String alias) {
+    return $TransactionsTable(attachedDatabase, alias);
   }
+
+  static TypeConverter<List<int>, String> $converter0 =
+      const IntListInColumnConverter();
+  static TypeConverter<BudgetReoccurence?, int> $converter1 =
+      const EnumIndexConverter<BudgetReoccurence>(BudgetReoccurence.values);
+  static TypeConverter<TransactionSpecialType?, int> $converter2 =
+      const EnumIndexConverter<TransactionSpecialType>(
+          TransactionSpecialType.values);
+  static TypeConverter<MethodAdded?, int> $converter3 =
+      const EnumIndexConverter<MethodAdded>(MethodAdded.values);
 }
 
 class TransactionLabel extends DataClass
@@ -1690,7 +1694,9 @@ class $LabelsTable extends Labels
   @override
   late final GeneratedColumn<int?> categoryFk = GeneratedColumn<int?>(
       'category_fk', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
+      type: const IntType(),
+      requiredDuringInsert: true,
+      defaultConstraints: 'REFERENCES categories (category_pk)');
   final VerificationMeta _dateCreatedMeta =
       const VerificationMeta('dateCreated');
   @override
@@ -2011,7 +2017,9 @@ class $AssociatedTitlesTable extends AssociatedTitles
   @override
   late final GeneratedColumn<int?> categoryFk = GeneratedColumn<int?>(
       'category_fk', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
+      type: const IntType(),
+      requiredDuringInsert: true,
+      defaultConstraints: 'REFERENCES categories (category_pk)');
   final VerificationMeta _dateCreatedMeta =
       const VerificationMeta('dateCreated');
   @override
@@ -2069,489 +2077,1101 @@ class $AssociatedTitlesTable extends AssociatedTitles
     }
     if (data.containsKey('date_created')) {
       context.handle(
-          _dateCreatedMeta,
-          dateCreated.isAcceptableOrUnknown(
-              data['date_created']!, _dateCreatedMeta));
+          _dateCreatedMeta,
+          dateCreated.isAcceptableOrUnknown(
+              data['date_created']!, _dateCreatedMeta));
+    }
+    if (data.containsKey('order')) {
+      context.handle(
+          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
+    } else if (isInserting) {
+      context.missing(_orderMeta);
+    }
+    if (data.containsKey('is_exact_match')) {
+      context.handle(
+          _isExactMatchMeta,
+          isExactMatch.isAcceptableOrUnknown(
+              data['is_exact_match']!, _isExactMatchMeta));
+    }
+    return context;
+  }
+
+  @override
+  Set<GeneratedColumn> get $primaryKey => {associatedTitlePk};
+  @override
+  TransactionAssociatedTitle map(Map<String, dynamic> data,
+      {String? tablePrefix}) {
+    return TransactionAssociatedTitle.fromData(data,
+        prefix: tablePrefix != null ? '$tablePrefix.' : null);
+  }
+
+  @override
+  $AssociatedTitlesTable createAlias(String alias) {
+    return $AssociatedTitlesTable(attachedDatabase, alias);
+  }
+}
+
+class Budget extends DataClass implements Insertable<Budget> {
+  final int budgetPk;
+  final String name;
+  final double amount;
+  final String? colour;
+  final DateTime startDate;
+  final DateTime endDate;
+  final List<int>? categoryFks;
+  final bool allCategoryFks;
+  final int periodLength;
+  final BudgetReoccurence? reoccurrence;
+  final DateTime dateCreated;
+  final bool pinned;
+  final int order;
+  final int walletFk;
+  Budget(
+      {required this.budgetPk,
+      required this.name,
+      required this.amount,
+      this.colour,
+      required this.startDate,
+      required this.endDate,
+      this.categoryFks,
+      required this.allCategoryFks,
+      required this.periodLength,
+      this.reoccurrence,
+      required this.dateCreated,
+      required this.pinned,
+      required this.order,
+      required this.walletFk});
+  factory Budget.fromData(Map<String, dynamic> data, {String? prefix}) {
+    final effectivePrefix = prefix ?? '';
+    return Budget(
+      budgetPk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}budget_pk'])!,
+      name: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}name'])!,
+      amount: const RealType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}amount'])!,
+      colour: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}colour']),
+      startDate: const DateTimeType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}start_date'])!,
+      endDate: const DateTimeType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}end_date'])!,
+      categoryFks: $BudgetsTable.$converter0.mapToDart(const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}category_fks'])),
+      allCategoryFks: const BoolType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}all_category_fks'])!,
+      periodLength: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}period_length'])!,
+      reoccurrence: $BudgetsTable.$converter1.mapToDart(const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}reoccurrence'])),
+      dateCreated: const DateTimeType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}date_created'])!,
+      pinned: const BoolType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}pinned'])!,
+      order: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}order'])!,
+      walletFk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}wallet_fk'])!,
+    );
+  }
+  @override
+  Map<String, Expression> toColumns(bool nullToAbsent) {
+    final map = <String, Expression>{};
+    map['budget_pk'] = Variable<int>(budgetPk);
+    map['name'] = Variable<String>(name);
+    map['amount'] = Variable<double>(amount);
+    if (!nullToAbsent || colour != null) {
+      map['colour'] = Variable<String?>(colour);
+    }
+    map['start_date'] = Variable<DateTime>(startDate);
+    map['end_date'] = Variable<DateTime>(endDate);
+    if (!nullToAbsent || categoryFks != null) {
+      final converter = $BudgetsTable.$converter0;
+      map['category_fks'] = Variable<String?>(converter.mapToSql(categoryFks));
+    }
+    map['all_category_fks'] = Variable<bool>(allCategoryFks);
+    map['period_length'] = Variable<int>(periodLength);
+    if (!nullToAbsent || reoccurrence != null) {
+      final converter = $BudgetsTable.$converter1;
+      map['reoccurrence'] = Variable<int?>(converter.mapToSql(reoccurrence));
+    }
+    map['date_created'] = Variable<DateTime>(dateCreated);
+    map['pinned'] = Variable<bool>(pinned);
+    map['order'] = Variable<int>(order);
+    map['wallet_fk'] = Variable<int>(walletFk);
+    return map;
+  }
+
+  BudgetsCompanion toCompanion(bool nullToAbsent) {
+    return BudgetsCompanion(
+      budgetPk: Value(budgetPk),
+      name: Value(name),
+      amount: Value(amount),
+      colour:
+          colour == null && nullToAbsent ? const Value.absent() : Value(colour),
+      startDate: Value(startDate),
+      endDate: Value(endDate),
+      categoryFks: categoryFks == null && nullToAbsent
+          ? const Value.absent()
+          : Value(categoryFks),
+      allCategoryFks: Value(allCategoryFks),
+      periodLength: Value(periodLength),
+      reoccurrence: reoccurrence == null && nullToAbsent
+          ? const Value.absent()
+          : Value(reoccurrence),
+      dateCreated: Value(dateCreated),
+      pinned: Value(pinned),
+      order: Value(order),
+      walletFk: Value(walletFk),
+    );
+  }
+
+  factory Budget.fromJson(Map<String, dynamic> json,
+      {ValueSerializer? serializer}) {
+    serializer ??= driftRuntimeOptions.defaultSerializer;
+    return Budget(
+      budgetPk: serializer.fromJson<int>(json['budgetPk']),
+      name: serializer.fromJson<String>(json['name']),
+      amount: serializer.fromJson<double>(json['amount']),
+      colour: serializer.fromJson<String?>(json['colour']),
+      startDate: serializer.fromJson<DateTime>(json['startDate']),
+      endDate: serializer.fromJson<DateTime>(json['endDate']),
+      categoryFks: serializer.fromJson<List<int>?>(json['categoryFks']),
+      allCategoryFks: serializer.fromJson<bool>(json['allCategoryFks']),
+      periodLength: serializer.fromJson<int>(json['periodLength']),
+      reoccurrence:
+          serializer.fromJson<BudgetReoccurence?>(json['reoccurrence']),
+      dateCreated: serializer.fromJson<DateTime>(json['dateCreated']),
+      pinned: serializer.fromJson<bool>(json['pinned']),
+      order: serializer.fromJson<int>(json['order']),
+      walletFk: serializer.fromJson<int>(json['walletFk']),
+    );
+  }
+  @override
+  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
+    serializer ??= driftRuntimeOptions.defaultSerializer;
+    return <String, dynamic>{
+      'budgetPk': serializer.toJson<int>(budgetPk),
+      'name': serializer.toJson<String>(name),
+      'amount': serializer.toJson<double>(amount),
+      'colour': serializer.toJson<String?>(colour),
+      'startDate': serializer.toJson<DateTime>(startDate),
+      'endDate': serializer.toJson<DateTime>(endDate),
+      'categoryFks': serializer.toJson<List<int>?>(categoryFks),
+      'allCategoryFks': serializer.toJson<bool>(allCategoryFks),
+      'periodLength': serializer.toJson<int>(periodLength),
+      'reoccurrence': serializer.toJson<BudgetReoccurence?>(reoccurrence),
+      'dateCreated': serializer.toJson<DateTime>(dateCreated),
+      'pinned': serializer.toJson<bool>(pinned),
+      'order': serializer.toJson<int>(order),
+      'walletFk': serializer.toJson<int>(walletFk),
+    };
+  }
+
+  Budget copyWith(
+          {int? budgetPk,
+          String? name,
+          double? amount,
+          String? colour,
+          DateTime? startDate,
+          DateTime? endDate,
+          List<int>? categoryFks,
+          bool? allCategoryFks,
+          int? periodLength,
+          BudgetReoccurence? reoccurrence,
+          DateTime? dateCreated,
+          bool? pinned,
+          int? order,
+          int? walletFk}) =>
+      Budget(
+        budgetPk: budgetPk ?? this.budgetPk,
+        name: name ?? this.name,
+        amount: amount ?? this.amount,
+        colour: colour ?? this.colour,
+        startDate: startDate ?? this.startDate,
+        endDate: endDate ?? this.endDate,
+        categoryFks: categoryFks ?? this.categoryFks,
+        allCategoryFks: allCategoryFks ?? this.allCategoryFks,
+        periodLength: periodLength ?? this.periodLength,
+        reoccurrence: reoccurrence ?? this.reoccurrence,
+        dateCreated: dateCreated ?? this.dateCreated,
+        pinned: pinned ?? this.pinned,
+        order: order ?? this.order,
+        walletFk: walletFk ?? this.walletFk,
+      );
+  @override
+  String toString() {
+    return (StringBuffer('Budget(')
+          ..write('budgetPk: $budgetPk, ')
+          ..write('name: $name, ')
+          ..write('amount: $amount, ')
+          ..write('colour: $colour, ')
+          ..write('startDate: $startDate, ')
+          ..write('endDate: $endDate, ')
+          ..write('categoryFks: $categoryFks, ')
+          ..write('allCategoryFks: $allCategoryFks, ')
+          ..write('periodLength: $periodLength, ')
+          ..write('reoccurrence: $reoccurrence, ')
+          ..write('dateCreated: $dateCreated, ')
+          ..write('pinned: $pinned, ')
+          ..write('order: $order, ')
+          ..write('walletFk: $walletFk')
+          ..write(')'))
+        .toString();
+  }
+
+  @override
+  int get hashCode => Object.hash(
+      budgetPk,
+      name,
+      amount,
+      colour,
+      startDate,
+      endDate,
+      categoryFks,
+      allCategoryFks,
+      periodLength,
+      reoccurrence,
+      dateCreated,
+      pinned,
+      order,
+      walletFk);
+  @override
+  bool operator ==(Object other) =>
+      identical(this, other) ||
+      (other is Budget &&
+          other.budgetPk == this.budgetPk &&
+          other.name == this.name &&
+          other.amount == this.amount &&
+          other.colour == this.colour &&
+          other.startDate == this.startDate &&
+          other.endDate == this.endDate &&
+          other.categoryFks == this.categoryFks &&
+          other.allCategoryFks == this.allCategoryFks &&
+          other.periodLength == this.periodLength &&
+          other.reoccurrence == this.reoccurrence &&
+          other.dateCreated == this.dateCreated &&
+          other.pinned == this.pinned &&
+          other.order == this.order &&
+          other.walletFk == this.walletFk);
+}
+
+class BudgetsCompanion extends UpdateCompanion<Budget> {
+  final Value<int> budgetPk;
+  final Value<String> name;
+  final Value<double> amount;
+  final Value<String?> colour;
+  final Value<DateTime> startDate;
+  final Value<DateTime> endDate;
+  final Value<List<int>?> categoryFks;
+  final Value<bool> allCategoryFks;
+  final Value<int> periodLength;
+  final Value<BudgetReoccurence?> reoccurrence;
+  final Value<DateTime> dateCreated;
+  final Value<bool> pinned;
+  final Value<int> order;
+  final Value<int> walletFk;
+  const BudgetsCompanion({
+    this.budgetPk = const Value.absent(),
+    this.name = const Value.absent(),
+    this.amount = const Value.absent(),
+    this.colour = const Value.absent(),
+    this.startDate = const Value.absent(),
+    this.endDate = const Value.absent(),
+    this.categoryFks = const Value.absent(),
+    this.allCategoryFks = const Value.absent(),
+    this.periodLength = const Value.absent(),
+    this.reoccurrence = const Value.absent(),
+    this.dateCreated = const Value.absent(),
+    this.pinned = const Value.absent(),
+    this.order = const Value.absent(),
+    this.walletFk = const Value.absent(),
+  });
+  BudgetsCompanion.insert({
+    this.budgetPk = const Value.absent(),
+    required String name,
+    required double amount,
+    this.colour = const Value.absent(),
+    required DateTime startDate,
+    required DateTime endDate,
+    this.categoryFks = const Value.absent(),
+    required bool allCategoryFks,
+    required int periodLength,
+    this.reoccurrence = const Value.absent(),
+    this.dateCreated = const Value.absent(),
+    this.pinned = const Value.absent(),
+    required int order,
+    required int walletFk,
+  })  : name = Value(name),
+        amount = Value(amount),
+        startDate = Value(startDate),
+        endDate = Value(endDate),
+        allCategoryFks = Value(allCategoryFks),
+        periodLength = Value(periodLength),
+        order = Value(order),
+        walletFk = Value(walletFk);
+  static Insertable<Budget> custom({
+    Expression<int>? budgetPk,
+    Expression<String>? name,
+    Expression<double>? amount,
+    Expression<String?>? colour,
+    Expression<DateTime>? startDate,
+    Expression<DateTime>? endDate,
+    Expression<List<int>?>? categoryFks,
+    Expression<bool>? allCategoryFks,
+    Expression<int>? periodLength,
+    Expression<BudgetReoccurence?>? reoccurrence,
+    Expression<DateTime>? dateCreated,
+    Expression<bool>? pinned,
+    Expression<int>? order,
+    Expression<int>? walletFk,
+  }) {
+    return RawValuesInsertable({
+      if (budgetPk != null) 'budget_pk': budgetPk,
+      if (name != null) 'name': name,
+      if (amount != null) 'amount': amount,
+      if (colour != null) 'colour': colour,
+      if (startDate != null) 'start_date': startDate,
+      if (endDate != null) 'end_date': endDate,
+      if (categoryFks != null) 'category_fks': categoryFks,
+      if (allCategoryFks != null) 'all_category_fks': allCategoryFks,
+      if (periodLength != null) 'period_length': periodLength,
+      if (reoccurrence != null) 'reoccurrence': reoccurrence,
+      if (dateCreated != null) 'date_created': dateCreated,
+      if (pinned != null) 'pinned': pinned,
+      if (order != null) 'order': order,
+      if (walletFk != null) 'wallet_fk': walletFk,
+    });
+  }
+
+  BudgetsCompanion copyWith(
+      {Value<int>? budgetPk,
+      Value<String>? name,
+      Value<double>? amount,
+      Value<String?>? colour,
+      Value<DateTime>? startDate,
+      Value<DateTime>? endDate,
+      Value<List<int>?>? categoryFks,
+      Value<bool>? allCategoryFks,
+      Value<int>? periodLength,
+      Value<BudgetReoccurence?>? reoccurrence,
+      Value<DateTime>? dateCreated,
+      Value<bool>? pinned,
+      Value<int>? order,
+      Value<int>? walletFk}) {
+    return BudgetsCompanion(
+      budgetPk: budgetPk ?? this.budgetPk,
+      name: name ?? this.name,
+      amount: amount ?? this.amount,
+      colour: colour ?? this.colour,
+      startDate: startDate ?? this.startDate,
+      endDate: endDate ?? this.endDate,
+      categoryFks: categoryFks ?? this.categoryFks,
+      allCategoryFks: allCategoryFks ?? this.allCategoryFks,
+      periodLength: periodLength ?? this.periodLength,
+      reoccurrence: reoccurrence ?? this.reoccurrence,
+      dateCreated: dateCreated ?? this.dateCreated,
+      pinned: pinned ?? this.pinned,
+      order: order ?? this.order,
+      walletFk: walletFk ?? this.walletFk,
+    );
+  }
+
+  @override
+  Map<String, Expression> toColumns(bool nullToAbsent) {
+    final map = <String, Expression>{};
+    if (budgetPk.present) {
+      map['budget_pk'] = Variable<int>(budgetPk.value);
+    }
+    if (name.present) {
+      map['name'] = Variable<String>(name.value);
+    }
+    if (amount.present) {
+      map['amount'] = Variable<double>(amount.value);
+    }
+    if (colour.present) {
+      map['colour'] = Variable<String?>(colour.value);
+    }
+    if (startDate.present) {
+      map['start_date'] = Variable<DateTime>(startDate.value);
+    }
+    if (endDate.present) {
+      map['end_date'] = Variable<DateTime>(endDate.value);
+    }
+    if (categoryFks.present) {
+      final converter = $BudgetsTable.$converter0;
+      map['category_fks'] =
+          Variable<String?>(converter.mapToSql(categoryFks.value));
+    }
+    if (allCategoryFks.present) {
+      map['all_category_fks'] = Variable<bool>(allCategoryFks.value);
+    }
+    if (periodLength.present) {
+      map['period_length'] = Variable<int>(periodLength.value);
+    }
+    if (reoccurrence.present) {
+      final converter = $BudgetsTable.$converter1;
+      map['reoccurrence'] =
+          Variable<int?>(converter.mapToSql(reoccurrence.value));
+    }
+    if (dateCreated.present) {
+      map['date_created'] = Variable<DateTime>(dateCreated.value);
+    }
+    if (pinned.present) {
+      map['pinned'] = Variable<bool>(pinned.value);
+    }
+    if (order.present) {
+      map['order'] = Variable<int>(order.value);
+    }
+    if (walletFk.present) {
+      map['wallet_fk'] = Variable<int>(walletFk.value);
+    }
+    return map;
+  }
+
+  @override
+  String toString() {
+    return (StringBuffer('BudgetsCompanion(')
+          ..write('budgetPk: $budgetPk, ')
+          ..write('name: $name, ')
+          ..write('amount: $amount, ')
+          ..write('colour: $colour, ')
+          ..write('startDate: $startDate, ')
+          ..write('endDate: $endDate, ')
+          ..write('categoryFks: $categoryFks, ')
+          ..write('allCategoryFks: $allCategoryFks, ')
+          ..write('periodLength: $periodLength, ')
+          ..write('reoccurrence: $reoccurrence, ')
+          ..write('dateCreated: $dateCreated, ')
+          ..write('pinned: $pinned, ')
+          ..write('order: $order, ')
+          ..write('walletFk: $walletFk')
+          ..write(')'))
+        .toString();
+  }
+}
+
+class $BudgetsTable extends Budgets with TableInfo<$BudgetsTable, Budget> {
+  @override
+  final GeneratedDatabase attachedDatabase;
+  final String? _alias;
+  $BudgetsTable(this.attachedDatabase, [this._alias]);
+  final VerificationMeta _budgetPkMeta = const VerificationMeta('budgetPk');
+  @override
+  late final GeneratedColumn<int?> budgetPk = GeneratedColumn<int?>(
+      'budget_pk', aliasedName, false,
+      type: const IntType(),
+      requiredDuringInsert: false,
+      defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
+  final VerificationMeta _nameMeta = const VerificationMeta('name');
+  @override
+  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
+      'name', aliasedName, false,
+      additionalChecks: GeneratedColumn.checkTextLength(),
+      type: const StringType(),
+      requiredDuringInsert: true);
+  final VerificationMeta _amountMeta = const VerificationMeta('amount');
+  @override
+  late final GeneratedColumn<double?> amount = GeneratedColumn<double?>(
+      'amount', aliasedName, false,
+      type: const RealType(), requiredDuringInsert: true);
+  final VerificationMeta _colourMeta = const VerificationMeta('colour');
+  @override
+  late final GeneratedColumn<String?> colour = GeneratedColumn<String?>(
+      'colour', aliasedName, true,
+      additionalChecks: GeneratedColumn.checkTextLength(),
+      type: const StringType(),
+      requiredDuringInsert: false);
+  final VerificationMeta _startDateMeta = const VerificationMeta('startDate');
+  @override
+  late final GeneratedColumn<DateTime?> startDate = GeneratedColumn<DateTime?>(
+      'start_date', aliasedName, false,
+      type: const IntType(), requiredDuringInsert: true);
+  final VerificationMeta _endDateMeta = const VerificationMeta('endDate');
+  @override
+  late final GeneratedColumn<DateTime?> endDate = GeneratedColumn<DateTime?>(
+      'end_date', aliasedName, false,
+      type: const IntType(), requiredDuringInsert: true);
+  final VerificationMeta _categoryFksMeta =
+      const VerificationMeta('categoryFks');
+  @override
+  late final GeneratedColumnWithTypeConverter<List<int>, String?> categoryFks =
+      GeneratedColumn<String?>('category_fks', aliasedName, true,
+              type: const StringType(), requiredDuringInsert: false)
+          .withConverter<List<int>>($BudgetsTable.$converter0);
+  final VerificationMeta _allCategoryFksMeta =
+      const VerificationMeta('allCategoryFks');
+  @override
+  late final GeneratedColumn<bool?> allCategoryFks = GeneratedColumn<bool?>(
+      'all_category_fks', aliasedName, false,
+      type: const BoolType(),
+      requiredDuringInsert: true,
+      defaultConstraints: 'CHECK (all_category_fks IN (0, 1))');
+  final VerificationMeta _periodLengthMeta =
+      const VerificationMeta('periodLength');
+  @override
+  late final GeneratedColumn<int?> periodLength = GeneratedColumn<int?>(
+      'period_length', aliasedName, false,
+      type: const IntType(), requiredDuringInsert: true);
+  final VerificationMeta _reoccurrenceMeta =
+      const VerificationMeta('reoccurrence');
+  @override
+  late final GeneratedColumnWithTypeConverter<BudgetReoccurence?, int?>
+      reoccurrence = GeneratedColumn<int?>('reoccurrence', aliasedName, true,
+              type: const IntType(), requiredDuringInsert: false)
+          .withConverter<BudgetReoccurence?>($BudgetsTable.$converter1);
+  final VerificationMeta _dateCreatedMeta =
+      const VerificationMeta('dateCreated');
+  @override
+  late final GeneratedColumn<DateTime?> dateCreated =
+      GeneratedColumn<DateTime?>('date_created', aliasedName, false,
+          type: const IntType(),
+          requiredDuringInsert: false,
+          clientDefault: () => new DateTime.now());
+  final VerificationMeta _pinnedMeta = const VerificationMeta('pinned');
+  @override
+  late final GeneratedColumn<bool?> pinned = GeneratedColumn<bool?>(
+      'pinned', aliasedName, false,
+      type: const BoolType(),
+      requiredDuringInsert: false,
+      defaultConstraints: 'CHECK (pinned IN (0, 1))',
+      defaultValue: const Constant(false));
+  final VerificationMeta _orderMeta = const VerificationMeta('order');
+  @override
+  late final GeneratedColumn<int?> order = GeneratedColumn<int?>(
+      'order', aliasedName, false,
+      type: const IntType(), requiredDuringInsert: true);
+  final VerificationMeta _walletFkMeta = const VerificationMeta('walletFk');
+  @override
+  late final GeneratedColumn<int?> walletFk = GeneratedColumn<int?>(
+      'wallet_fk', aliasedName, false,
+      type: const IntType(),
+      requiredDuringInsert: true,
+      defaultConstraints: 'REFERENCES wallets (wallet_pk)');
+  @override
+  List<GeneratedColumn> get $columns => [
+        budgetPk,
+        name,
+        amount,
+        colour,
+        startDate,
+        endDate,
+        categoryFks,
+        allCategoryFks,
+        periodLength,
+        reoccurrence,
+        dateCreated,
+        pinned,
+        order,
+        walletFk
+      ];
+  @override
+  String get aliasedName => _alias ?? 'budgets';
+  @override
+  String get actualTableName => 'budgets';
+  @override
+  VerificationContext validateIntegrity(Insertable<Budget> instance,
+      {bool isInserting = false}) {
+    final context = VerificationContext();
+    final data = instance.toColumns(true);
+    if (data.containsKey('budget_pk')) {
+      context.handle(_budgetPkMeta,
+          budgetPk.isAcceptableOrUnknown(data['budget_pk']!, _budgetPkMeta));
+    }
+    if (data.containsKey('name')) {
+      context.handle(
+          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
+    } else if (isInserting) {
+      context.missing(_nameMeta);
+    }
+    if (data.containsKey('amount')) {
+      context.handle(_amountMeta,
+          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
+    } else if (isInserting) {
+      context.missing(_amountMeta);
+    }
+    if (data.containsKey('colour')) {
+      context.handle(_colourMeta,
+          colour.isAcceptableOrUnknown(data['colour']!, _colourMeta));
+    }
+    if (data.containsKey('start_date')) {
+      context.handle(_startDateMeta,
+          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
+    } else if (isInserting) {
+      context.missing(_startDateMeta);
+    }
+    if (data.containsKey('end_date')) {
+      context.handle(_endDateMeta,
+          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
+    } else if (isInserting) {
+      context.missing(_endDateMeta);
+    }
+    context.handle(_categoryFksMeta, const VerificationResult.success());
+    if (data.containsKey('all_category_fks')) {
+      context.handle(
+          _allCategoryFksMeta,
+          allCategoryFks.isAcceptableOrUnknown(
+              data['all_category_fks']!, _allCategoryFksMeta));
+    } else if (isInserting) {
+      context.missing(_allCategoryFksMeta);
+    }
+    if (data.containsKey('period_length')) {
+      context.handle(
+          _periodLengthMeta,
+          periodLength.isAcceptableOrUnknown(
+              data['period_length']!, _periodLengthMeta));
+    } else if (isInserting) {
+      context.missing(_periodLengthMeta);
+    }
+    context.handle(_reoccurrenceMeta, const VerificationResult.success());
+    if (data.containsKey('date_created')) {
+      context.handle(
+          _dateCreatedMeta,
+          dateCreated.isAcceptableOrUnknown(
+              data['date_created']!, _dateCreatedMeta));
+    }
+    if (data.containsKey('pinned')) {
+      context.handle(_pinnedMeta,
+          pinned.isAcceptableOrUnknown(data['pinned']!, _pinnedMeta));
+    }
+    if (data.containsKey('order')) {
+      context.handle(
+          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
+    } else if (isInserting) {
+      context.missing(_orderMeta);
+    }
+    if (data.containsKey('wallet_fk')) {
+      context.handle(_walletFkMeta,
+          walletFk.isAcceptableOrUnknown(data['wallet_fk']!, _walletFkMeta));
+    } else if (isInserting) {
+      context.missing(_walletFkMeta);
+    }
+    return context;
+  }
+
+  @override
+  Set<GeneratedColumn> get $primaryKey => {budgetPk};
+  @override
+  Budget map(Map<String, dynamic> data, {String? tablePrefix}) {
+    return Budget.fromData(data,
+        prefix: tablePrefix != null ? '$tablePrefix.' : null);
+  }
+
+  @override
+  $BudgetsTable createAlias(String alias) {
+    return $BudgetsTable(attachedDatabase, alias);
+  }
+
+  static TypeConverter<List<int>, String> $converter0 =
+      const IntListInColumnConverter();
+  static TypeConverter<BudgetReoccurence?, int> $converter1 =
+      const EnumIndexConverter<BudgetReoccurence>(BudgetReoccurence.values);
+}
+
+class AppSetting extends DataClass implements Insertable<AppSetting> {
+  final int settingsPk;
+  final String settingsJSON;
+  final DateTime dateUpdated;
+  AppSetting(
+      {required this.settingsPk,
+      required this.settingsJSON,
+      required this.dateUpdated});
+  factory AppSetting.fromData(Map<String, dynamic> data, {String? prefix}) {
+    final effectivePrefix = prefix ?? '';
+    return AppSetting(
+      settingsPk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}settings_pk'])!,
+      settingsJSON: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}settings_j_s_o_n'])!,
+      dateUpdated: const DateTimeType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}date_updated'])!,
+    );
+  }
+  @override
+  Map<String, Expression> toColumns(bool nullToAbsent) {
+    final map = <String, Expression>{};
+    map['settings_pk'] = Variable<int>(settingsPk);
+    map['settings_j_s_o_n'] = Variable<String>(settingsJSON);
+    map['date_updated'] = Variable<DateTime>(dateUpdated);
+    return map;
+  }
+
+  AppSettingsCompanion toCompanion(bool nullToAbsent) {
+    return AppSettingsCompanion(
+      settingsPk: Value(settingsPk),
+      settingsJSON: Value(settingsJSON),
+      dateUpdated: Value(dateUpdated),
+    );
+  }
+
+  factory AppSetting.fromJson(Map<String, dynamic> json,
+      {ValueSerializer? serializer}) {
+    serializer ??= driftRuntimeOptions.defaultSerializer;
+    return AppSetting(
+      settingsPk: serializer.fromJson<int>(json['settingsPk']),
+      settingsJSON: serializer.fromJson<String>(json['settingsJSON']),
+      dateUpdated: serializer.fromJson<DateTime>(json['dateUpdated']),
+    );
+  }
+  @override
+  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
+    serializer ??= driftRuntimeOptions.defaultSerializer;
+    return <String, dynamic>{
+      'settingsPk': serializer.toJson<int>(settingsPk),
+      'settingsJSON': serializer.toJson<String>(settingsJSON),
+      'dateUpdated': serializer.toJson<DateTime>(dateUpdated),
+    };
+  }
+
+  AppSetting copyWith(
+          {int? settingsPk, String? settingsJSON, DateTime? dateUpdated}) =>
+      AppSetting(
+        settingsPk: settingsPk ?? this.settingsPk,
+        settingsJSON: settingsJSON ?? this.settingsJSON,
+        dateUpdated: dateUpdated ?? this.dateUpdated,
+      );
+  @override
+  String toString() {
+    return (StringBuffer('AppSetting(')
+          ..write('settingsPk: $settingsPk, ')
+          ..write('settingsJSON: $settingsJSON, ')
+          ..write('dateUpdated: $dateUpdated')
+          ..write(')'))
+        .toString();
+  }
+
+  @override
+  int get hashCode => Object.hash(settingsPk, settingsJSON, dateUpdated);
+  @override
+  bool operator ==(Object other) =>
+      identical(this, other) ||
+      (other is AppSetting &&
+          other.settingsPk == this.settingsPk &&
+          other.settingsJSON == this.settingsJSON &&
+          other.dateUpdated == this.dateUpdated);
+}
+
+class AppSettingsCompanion extends UpdateCompanion<AppSetting> {
+  final Value<int> settingsPk;
+  final Value<String> settingsJSON;
+  final Value<DateTime> dateUpdated;
+  const AppSettingsCompanion({
+    this.settingsPk = const Value.absent(),
+    this.settingsJSON = const Value.absent(),
+    this.dateUpdated = const Value.absent(),
+  });
+  AppSettingsCompanion.insert({
+    this.settingsPk = const Value.absent(),
+    required String settingsJSON,
+    this.dateUpdated = const Value.absent(),
+  }) : settingsJSON = Value(settingsJSON);
+  static Insertable<AppSetting> custom({
+    Expression<int>? settingsPk,
+    Expression<String>? settingsJSON,
+    Expression<DateTime>? dateUpdated,
+  }) {
+    return RawValuesInsertable({
+      if (settingsPk != null) 'settings_pk': settingsPk,
+      if (settingsJSON != null) 'settings_j_s_o_n': settingsJSON,
+      if (dateUpdated != null) 'date_updated': dateUpdated,
+    });
+  }
+
+  AppSettingsCompanion copyWith(
+      {Value<int>? settingsPk,
+      Value<String>? settingsJSON,
+      Value<DateTime>? dateUpdated}) {
+    return AppSettingsCompanion(
+      settingsPk: settingsPk ?? this.settingsPk,
+      settingsJSON: settingsJSON ?? this.settingsJSON,
+      dateUpdated: dateUpdated ?? this.dateUpdated,
+    );
+  }
+
+  @override
+  Map<String, Expression> toColumns(bool nullToAbsent) {
+    final map = <String, Expression>{};
+    if (settingsPk.present) {
+      map['settings_pk'] = Variable<int>(settingsPk.value);
+    }
+    if (settingsJSON.present) {
+      map['settings_j_s_o_n'] = Variable<String>(settingsJSON.value);
+    }
+    if (dateUpdated.present) {
+      map['date_updated'] = Variable<DateTime>(dateUpdated.value);
+    }
+    return map;
+  }
+
+  @override
+  String toString() {
+    return (StringBuffer('AppSettingsCompanion(')
+          ..write('settingsPk: $settingsPk, ')
+          ..write('settingsJSON: $settingsJSON, ')
+          ..write('dateUpdated: $dateUpdated')
+          ..write(')'))
+        .toString();
+  }
+}
+
+class $AppSettingsTable extends AppSettings
+    with TableInfo<$AppSettingsTable, AppSetting> {
+  @override
+  final GeneratedDatabase attachedDatabase;
+  final String? _alias;
+  $AppSettingsTable(this.attachedDatabase, [this._alias]);
+  final VerificationMeta _settingsPkMeta = const VerificationMeta('settingsPk');
+  @override
+  late final GeneratedColumn<int?> settingsPk = GeneratedColumn<int?>(
+      'settings_pk', aliasedName, false,
+      type: const IntType(),
+      requiredDuringInsert: false,
+      defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
+  final VerificationMeta _settingsJSONMeta =
+      const VerificationMeta('settingsJSON');
+  @override
+  late final GeneratedColumn<String?> settingsJSON = GeneratedColumn<String?>(
+      'settings_j_s_o_n', aliasedName, false,
+      type: const StringType(), requiredDuringInsert: true);
+  final VerificationMeta _dateUpdatedMeta =
+      const VerificationMeta('dateUpdated');
+  @override
+  late final GeneratedColumn<DateTime?> dateUpdated =
+      GeneratedColumn<DateTime?>('date_updated', aliasedName, false,
+          type: const IntType(),
+          requiredDuringInsert: false,
+          clientDefault: () => new DateTime.now());
+  @override
+  List<GeneratedColumn> get $columns => [settingsPk, settingsJSON, dateUpdated];
+  @override
+  String get aliasedName => _alias ?? 'app_settings';
+  @override
+  String get actualTableName => 'app_settings';
+  @override
+  VerificationContext validateIntegrity(Insertable<AppSetting> instance,
+      {bool isInserting = false}) {
+    final context = VerificationContext();
+    final data = instance.toColumns(true);
+    if (data.containsKey('settings_pk')) {
+      context.handle(
+          _settingsPkMeta,
+          settingsPk.isAcceptableOrUnknown(
+              data['settings_pk']!, _settingsPkMeta));
     }
-    if (data.containsKey('order')) {
+    if (data.containsKey('settings_j_s_o_n')) {
       context.handle(
-          _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
+          _settingsJSONMeta,
+          settingsJSON.isAcceptableOrUnknown(
+              data['settings_j_s_o_n']!, _settingsJSONMeta));
     } else if (isInserting) {
-      context.missing(_orderMeta);
+      context.missing(_settingsJSONMeta);
     }
-    if (data.containsKey('is_exact_match')) {
+    if (data.containsKey('date_updated')) {
       context.handle(
-          _isExactMatchMeta,
-          isExactMatch.isAcceptableOrUnknown(
-              data['is_exact_match']!, _isExactMatchMeta));
+          _dateUpdatedMeta,
+          dateUpdated.isAcceptableOrUnknown(
+              data['date_updated']!, _dateUpdatedMeta));
     }
     return context;
   }
 
   @override
-  Set<GeneratedColumn> get $primaryKey => {associatedTitlePk};
+  Set<GeneratedColumn> get $primaryKey => {settingsPk};
   @override
-  TransactionAssociatedTitle map(Map<String, dynamic> data,
-      {String? tablePrefix}) {
-    return TransactionAssociatedTitle.fromData(data,
+  AppSetting map(Map<String, dynamic> data, {String? tablePrefix}) {
+    return AppSetting.fromData(data,
         prefix: tablePrefix != null ? '$tablePrefix.' : null);
   }
 
   @override
-  $AssociatedTitlesTable createAlias(String alias) {
-    return $AssociatedTitlesTable(attachedDatabase, alias);
+  $AppSettingsTable createAlias(String alias) {
+    return $AppSettingsTable(attachedDatabase, alias);
   }
 }
 
-class Budget extends DataClass implements Insertable<Budget> {
-  final int budgetPk;
+class BillSplitter extends DataClass implements Insertable<BillSplitter> {
+  final int billSplitterPk;
   final String name;
-  final double amount;
-  final String? colour;
-  final DateTime startDate;
-  final DateTime endDate;
-  final List<int>? categoryFks;
-  final bool allCategoryFks;
-  final int periodLength;
-  final BudgetReoccurence? reoccurrence;
   final DateTime dateCreated;
-  final bool pinned;
   final int order;
-  final int walletFk;
-  Budget(
-      {required this.budgetPk,
+  BillSplitter(
+      {required this.billSplitterPk,
       required this.name,
-      required this.amount,
-      this.colour,
-      required this.startDate,
-      required this.endDate,
-      this.categoryFks,
-      required this.allCategoryFks,
-      required this.periodLength,
-      this.reoccurrence,
       required this.dateCreated,
-      required this.pinned,
-      required this.order,
-      required this.walletFk});
-  factory Budget.fromData(Map<String, dynamic> data, {String? prefix}) {
+      required this.order});
+  factory BillSplitter.fromData(Map<String, dynamic> data, {String? prefix}) {
     final effectivePrefix = prefix ?? '';
-    return Budget(
-      budgetPk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}budget_pk'])!,
+    return BillSplitter(
+      billSplitterPk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}bill_splitter_pk'])!,
       name: const StringType()
           .mapFromDatabaseResponse(data['${effectivePrefix}name'])!,
-      amount: const RealType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}amount'])!,
-      colour: const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}colour']),
-      startDate: const DateTimeType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}start_date'])!,
-      endDate: const DateTimeType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}end_date'])!,
-      categoryFks: $BudgetsTable.$converter0.mapToDart(const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}category_fks'])),
-      allCategoryFks: const BoolType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}all_category_fks'])!,
-      periodLength: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}period_length'])!,
-      reoccurrence: $BudgetsTable.$converter1.mapToDart(const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}reoccurrence'])),
       dateCreated: const DateTimeType()
           .mapFromDatabaseResponse(data['${effectivePrefix}date_created'])!,
-      pinned: const BoolType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}pinned'])!,
       order: const IntType()
           .mapFromDatabaseResponse(data['${effectivePrefix}order'])!,
-      walletFk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}wallet_fk'])!,
     );
   }
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    map['budget_pk'] = Variable<int>(budgetPk);
+    map['bill_splitter_pk'] = Variable<int>(billSplitterPk);
     map['name'] = Variable<String>(name);
-    map['amount'] = Variable<double>(amount);
-    if (!nullToAbsent || colour != null) {
-      map['colour'] = Variable<String?>(colour);
-    }
-    map['start_date'] = Variable<DateTime>(startDate);
-    map['end_date'] = Variable<DateTime>(endDate);
-    if (!nullToAbsent || categoryFks != null) {
-      final converter = $BudgetsTable.$converter0;
-      map['category_fks'] = Variable<String?>(converter.mapToSql(categoryFks));
-    }
-    map['all_category_fks'] = Variable<bool>(allCategoryFks);
-    map['period_length'] = Variable<int>(periodLength);
-    if (!nullToAbsent || reoccurrence != null) {
-      final converter = $BudgetsTable.$converter1;
-      map['reoccurrence'] = Variable<int?>(converter.mapToSql(reoccurrence));
-    }
     map['date_created'] = Variable<DateTime>(dateCreated);
-    map['pinned'] = Variable<bool>(pinned);
     map['order'] = Variable<int>(order);
-    map['wallet_fk'] = Variable<int>(walletFk);
     return map;
   }
 
-  BudgetsCompanion toCompanion(bool nullToAbsent) {
-    return BudgetsCompanion(
-      budgetPk: Value(budgetPk),
+  BillSplittersCompanion toCompanion(bool nullToAbsent) {
+    return BillSplittersCompanion(
+      billSplitterPk: Value(billSplitterPk),
       name: Value(name),
-      amount: Value(amount),
-      colour:
-          colour == null && nullToAbsent ? const Value.absent() : Value(colour),
-      startDate: Value(startDate),
-      endDate: Value(endDate),
-      categoryFks: categoryFks == null && nullToAbsent
-          ? const Value.absent()
-          : Value(categoryFks),
-      allCategoryFks: Value(allCategoryFks),
-      periodLength: Value(periodLength),
-      reoccurrence: reoccurrence == null && nullToAbsent
-          ? const Value.absent()
-          : Value(reoccurrence),
       dateCreated: Value(dateCreated),
-      pinned: Value(pinned),
       order: Value(order),
-      walletFk: Value(walletFk),
     );
   }
 
-  factory Budget.fromJson(Map<String, dynamic> json,
+  factory BillSplitter.fromJson(Map<String, dynamic> json,
       {ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
-    return Budget(
-      budgetPk: serializer.fromJson<int>(json['budgetPk']),
+    return BillSplitter(
+      billSplitterPk: serializer.fromJson<int>(json['billSplitterPk']),
       name: serializer.fromJson<String>(json['name']),
-      amount: serializer.fromJson<double>(json['amount']),
-      colour: serializer.fromJson<String?>(json['colour']),
-      startDate: serializer.fromJson<DateTime>(json['startDate']),
-      endDate: serializer.fromJson<DateTime>(json['endDate']),
-      categoryFks: serializer.fromJson<List<int>?>(json['categoryFks']),
-      allCategoryFks: serializer.fromJson<bool>(json['allCategoryFks']),
-      periodLength: serializer.fromJson<int>(json['periodLength']),
-      reoccurrence:
-          serializer.fromJson<BudgetReoccurence?>(json['reoccurrence']),
       dateCreated: serializer.fromJson<DateTime>(json['dateCreated']),
-      pinned: serializer.fromJson<bool>(json['pinned']),
       order: serializer.fromJson<int>(json['order']),
-      walletFk: serializer.fromJson<int>(json['walletFk']),
     );
   }
   @override
   Map<String, dynamic> toJson({ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
     return <String, dynamic>{
-      'budgetPk': serializer.toJson<int>(budgetPk),
+      'billSplitterPk': serializer.toJson<int>(billSplitterPk),
       'name': serializer.toJson<String>(name),
-      'amount': serializer.toJson<double>(amount),
-      'colour': serializer.toJson<String?>(colour),
-      'startDate': serializer.toJson<DateTime>(startDate),
-      'endDate': serializer.toJson<DateTime>(endDate),
-      'categoryFks': serializer.toJson<List<int>?>(categoryFks),
-      'allCategoryFks': serializer.toJson<bool>(allCategoryFks),
-      'periodLength': serializer.toJson<int>(periodLength),
-      'reoccurrence': serializer.toJson<BudgetReoccurence?>(reoccurrence),
       'dateCreated': serializer.toJson<DateTime>(dateCreated),
-      'pinned': serializer.toJson<bool>(pinned),
       'order': serializer.toJson<int>(order),
-      'walletFk': serializer.toJson<int>(walletFk),
     };
   }
 
-  Budget copyWith(
-          {int? budgetPk,
+  BillSplitter copyWith(
+          {int? billSplitterPk,
           String? name,
-          double? amount,
-          String? colour,
-          DateTime? startDate,
-          DateTime? endDate,
-          List<int>? categoryFks,
-          bool? allCategoryFks,
-          int? periodLength,
-          BudgetReoccurence? reoccurrence,
           DateTime? dateCreated,
-          bool? pinned,
-          int? order,
-          int? walletFk}) =>
-      Budget(
-        budgetPk: budgetPk ?? this.budgetPk,
+          int? order}) =>
+      BillSplitter(
+        billSplitterPk: billSplitterPk ?? this.billSplitterPk,
         name: name ?? this.name,
-        amount: amount ?? this.amount,
-        colour: colour ?? this.colour,
-        startDate: startDate ?? this.startDate,
-        endDate: endDate ?? this.endDate,
-        categoryFks: categoryFks ?? this.categoryFks,
-        allCategoryFks: allCategoryFks ?? this.allCategoryFks,
-        periodLength: periodLength ?? this.periodLength,
-        reoccurrence: reoccurrence ?? this.reoccurrence,
         dateCreated: dateCreated ?? this.dateCreated,
-        pinned: pinned ?? this.pinned,
         order: order ?? this.order,
-        walletFk: walletFk ?? this.walletFk,
       );
   @override
   String toString() {
-    return (StringBuffer('Budget(')
-          ..write('budgetPk: $budgetPk, ')
+    return (StringBuffer('BillSplitter(')
+          ..write('billSplitterPk: $billSplitterPk, ')
           ..write('name: $name, ')
-          ..write('amount: $amount, ')
-          ..write('colour: $colour, ')
-          ..write('startDate: $startDate, ')
-          ..write('endDate: $endDate, ')
-          ..write('categoryFks: $categoryFks, ')
-          ..write('allCategoryFks: $allCategoryFks, ')
-          ..write('periodLength: $periodLength, ')
-          ..write('reoccurrence: $reoccurrence, ')
           ..write('dateCreated: $dateCreated, ')
-          ..write('pinned: $pinned, ')
-          ..write('order: $order, ')
-          ..write('walletFk: $walletFk')
+          ..write('order: $order')
           ..write(')'))
         .toString();
   }
 
   @override
-  int get hashCode => Object.hash(
-      budgetPk,
-      name,
-      amount,
-      colour,
-      startDate,
-      endDate,
-      categoryFks,
-      allCategoryFks,
-      periodLength,
-      reoccurrence,
-      dateCreated,
-      pinned,
-      order,
-      walletFk);
+  int get hashCode => Object.hash(billSplitterPk, name, dateCreated, order);
   @override
   bool operator ==(Object other) =>
       identical(this, other) ||
-      (other is Budget &&
-          other.budgetPk == this.budgetPk &&
+      (other is BillSplitter &&
+          other.billSplitterPk == this.billSplitterPk &&
           other.name == this.name &&
-          other.amount == this.amount &&
-          other.colour == this.colour &&
-          other.startDate == this.startDate &&
-          other.endDate == this.endDate &&
-          other.categoryFks == this.categoryFks &&
-          other.allCategoryFks == this.allCategoryFks &&
-          other.periodLength == this.periodLength &&
-          other.reoccurrence == this.reoccurrence &&
           other.dateCreated == this.dateCreated &&
-          other.pinned == this.pinned &&
-          other.order == this.order &&
-          other.walletFk == this.walletFk);
-}
-
-class BudgetsCompanion extends UpdateCompanion<Budget> {
-  final Value<int> budgetPk;
-  final Value<String> name;
-  final Value<double> amount;
-  final Value<String?> colour;
-  final Value<DateTime> startDate;
-  final Value<DateTime> endDate;
-  final Value<List<int>?> categoryFks;
-  final Value<bool> allCategoryFks;
-  final Value<int> periodLength;
-  final Value<BudgetReoccurence?> reoccurrence;
-  final Value<DateTime> dateCreated;
-  final Value<bool> pinned;
-  final Value<int> order;
-  final Value<int> walletFk;
-  const BudgetsCompanion({
-    this.budgetPk = const Value.absent(),
-    this.name = const Value.absent(),
-    this.amount = const Value.absent(),
-    this.colour = const Value.absent(),
-    this.startDate = const Value.absent(),
-    this.endDate = const Value.absent(),
-    this.categoryFks = const Value.absent(),
-    this.allCategoryFks = const Value.absent(),
-    this.periodLength = const Value.absent(),
-    this.reoccurrence = const Value.absent(),
+          other.order == this.order);
+}
+
+class BillSplittersCompanion extends UpdateCompanion<BillSplitter> {
+  final Value<int> billSplitterPk;
+  final Value<String> name;
+  final Value<DateTime> dateCreated;
+  final Value<int> order;
+  const BillSplittersCompanion({
+    this.billSplitterPk = const Value.absent(),
+    this.name = const Value.absent(),
     this.dateCreated = const Value.absent(),
-    this.pinned = const Value.absent(),
     this.order = const Value.absent(),
-    this.walletFk = const Value.absent(),
   });
-  BudgetsCompanion.insert({
-    this.budgetPk = const Value.absent(),
+  BillSplittersCompanion.insert({
+    this.billSplitterPk = const Value.absent(),
     required String name,
-    required double amount,
-    this.colour = const Value.absent(),
-    required DateTime startDate,
-    required DateTime endDate,
-    this.categoryFks = const Value.absent(),
-    required bool allCategoryFks,
-    required int periodLength,
-    this.reoccurrence = const Value.absent(),
     this.dateCreated = const Value.absent(),
-    this.pinned = const Value.absent(),
     required int order,
-    required int walletFk,
   })  : name = Value(name),
-        amount = Value(amount),
-        startDate = Value(startDate),
-        endDate = Value(endDate),
-        allCategoryFks = Value(allCategoryFks),
-        periodLength = Value(periodLength),
-        order = Value(order),
-        walletFk = Value(walletFk);
-  static Insertable<Budget> custom({
-    Expression<int>? budgetPk,
+        order = Value(order);
+  static Insertable<BillSplitter> custom({
+    Expression<int>? billSplitterPk,
     Expression<String>? name,
-    Expression<double>? amount,
-    Expression<String?>? colour,
-    Expression<DateTime>? startDate,
-    Expression<DateTime>? endDate,
-    Expression<List<int>?>? categoryFks,
-    Expression<bool>? allCategoryFks,
-    Expression<int>? periodLength,
-    Expression<BudgetReoccurence?>? reoccurrence,
     Expression<DateTime>? dateCreated,
-    Expression<bool>? pinned,
     Expression<int>? order,
-    Expression<int>? walletFk,
   }) {
     return RawValuesInsertable({
-      if (budgetPk != null) 'budget_pk': budgetPk,
+      if (billSplitterPk != null) 'bill_splitter_pk': billSplitterPk,
       if (name != null) 'name': name,
-      if (amount != null) 'amount': amount,
-      if (colour != null) 'colour': colour,
-      if (startDate != null) 'start_date': startDate,
-      if (endDate != null) 'end_date': endDate,
-      if (categoryFks != null) 'category_fks': categoryFks,
-      if (allCategoryFks != null) 'all_category_fks': allCategoryFks,
-      if (periodLength != null) 'period_length': periodLength,
-      if (reoccurrence != null) 'reoccurrence': reoccurrence,
       if (dateCreated != null) 'date_created': dateCreated,
-      if (pinned != null) 'pinned': pinned,
       if (order != null) 'order': order,
-      if (walletFk != null) 'wallet_fk': walletFk,
     });
   }
 
-  BudgetsCompanion copyWith(
-      {Value<int>? budgetPk,
+  BillSplittersCompanion copyWith(
+      {Value<int>? billSplitterPk,
       Value<String>? name,
-      Value<double>? amount,
-      Value<String?>? colour,
-      Value<DateTime>? startDate,
-      Value<DateTime>? endDate,
-      Value<List<int>?>? categoryFks,
-      Value<bool>? allCategoryFks,
-      Value<int>? periodLength,
-      Value<BudgetReoccurence?>? reoccurrence,
       Value<DateTime>? dateCreated,
-      Value<bool>? pinned,
-      Value<int>? order,
-      Value<int>? walletFk}) {
-    return BudgetsCompanion(
-      budgetPk: budgetPk ?? this.budgetPk,
+      Value<int>? order}) {
+    return BillSplittersCompanion(
+      billSplitterPk: billSplitterPk ?? this.billSplitterPk,
       name: name ?? this.name,
-      amount: amount ?? this.amount,
-      colour: colour ?? this.colour,
-      startDate: startDate ?? this.startDate,
-      endDate: endDate ?? this.endDate,
-      categoryFks: categoryFks ?? this.categoryFks,
-      allCategoryFks: allCategoryFks ?? this.allCategoryFks,
-      periodLength: periodLength ?? this.periodLength,
-      reoccurrence: reoccurrence ?? this.reoccurrence,
       dateCreated: dateCreated ?? this.dateCreated,
-      pinned: pinned ?? this.pinned,
       order: order ?? this.order,
-      walletFk: walletFk ?? this.walletFk,
     );
   }
 
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    if (budgetPk.present) {
-      map['budget_pk'] = Variable<int>(budgetPk.value);
+    if (billSplitterPk.present) {
+      map['bill_splitter_pk'] = Variable<int>(billSplitterPk.value);
     }
     if (name.present) {
       map['name'] = Variable<String>(name.value);
     }
-    if (amount.present) {
-      map['amount'] = Variable<double>(amount.value);
-    }
-    if (colour.present) {
-      map['colour'] = Variable<String?>(colour.value);
-    }
-    if (startDate.present) {
-      map['start_date'] = Variable<DateTime>(startDate.value);
-    }
-    if (endDate.present) {
-      map['end_date'] = Variable<DateTime>(endDate.value);
-    }
-    if (categoryFks.present) {
-      final converter = $BudgetsTable.$converter0;
-      map['category_fks'] =
-          Variable<String?>(converter.mapToSql(categoryFks.value));
-    }
-    if (allCategoryFks.present) {
-      map['all_category_fks'] = Variable<bool>(allCategoryFks.value);
-    }
-    if (periodLength.present) {
-      map['period_length'] = Variable<int>(periodLength.value);
-    }
-    if (reoccurrence.present) {
-      final converter = $BudgetsTable.$converter1;
-      map['reoccurrence'] =
-          Variable<int?>(converter.mapToSql(reoccurrence.value));
-    }
     if (dateCreated.present) {
       map['date_created'] = Variable<DateTime>(dateCreated.value);
     }
-    if (pinned.present) {
-      map['pinned'] = Variable<bool>(pinned.value);
-    }
     if (order.present) {
       map['order'] = Variable<int>(order.value);
     }
-    if (walletFk.present) {
-      map['wallet_fk'] = Variable<int>(walletFk.value);
-    }
     return map;
   }
 
   @override
   String toString() {
-    return (StringBuffer('BudgetsCompanion(')
-          ..write('budgetPk: $budgetPk, ')
+    return (StringBuffer('BillSplittersCompanion(')
+          ..write('billSplitterPk: $billSplitterPk, ')
           ..write('name: $name, ')
-          ..write('amount: $amount, ')
-          ..write('colour: $colour, ')
-          ..write('startDate: $startDate, ')
-          ..write('endDate: $endDate, ')
-          ..write('categoryFks: $categoryFks, ')
-          ..write('allCategoryFks: $allCategoryFks, ')
-          ..write('periodLength: $periodLength, ')
-          ..write('reoccurrence: $reoccurrence, ')
           ..write('dateCreated: $dateCreated, ')
-          ..write('pinned: $pinned, ')
-          ..write('order: $order, ')
-          ..write('walletFk: $walletFk')
+          ..write('order: $order')
           ..write(')'))
         .toString();
   }
 }
 
-class $BudgetsTable extends Budgets with TableInfo<$BudgetsTable, Budget> {
+class $BillSplittersTable extends BillSplitters
+    with TableInfo<$BillSplittersTable, BillSplitter> {
   @override
   final GeneratedDatabase attachedDatabase;
   final String? _alias;
-  $BudgetsTable(this.attachedDatabase, [this._alias]);
-  final VerificationMeta _budgetPkMeta = const VerificationMeta('budgetPk');
+  $BillSplittersTable(this.attachedDatabase, [this._alias]);
+  final VerificationMeta _billSplitterPkMeta =
+      const VerificationMeta('billSplitterPk');
   @override
-  late final GeneratedColumn<int?> budgetPk = GeneratedColumn<int?>(
-      'budget_pk', aliasedName, false,
+  late final GeneratedColumn<int?> billSplitterPk = GeneratedColumn<int?>(
+      'bill_splitter_pk', aliasedName, false,
       type: const IntType(),
       requiredDuringInsert: false,
       defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
@@ -2562,56 +3182,6 @@ class $BudgetsTable extends Budgets with TableInfo<$BudgetsTable, Budget> {
       additionalChecks: GeneratedColumn.checkTextLength(),
       type: const StringType(),
       requiredDuringInsert: true);
-  final VerificationMeta _amountMeta = const VerificationMeta('amount');
-  @override
-  late final GeneratedColumn<double?> amount = GeneratedColumn<double?>(
-      'amount', aliasedName, false,
-      type: const RealType(), requiredDuringInsert: true);
-  final VerificationMeta _colourMeta = const VerificationMeta('colour');
-  @override
-  late final GeneratedColumn<String?> colour = GeneratedColumn<String?>(
-      'colour', aliasedName, true,
-      additionalChecks: GeneratedColumn.checkTextLength(),
-      type: const StringType(),
-      requiredDuringInsert: false);
-  final VerificationMeta _startDateMeta = const VerificationMeta('startDate');
-  @override
-  late final GeneratedColumn<DateTime?> startDate = GeneratedColumn<DateTime?>(
-      'start_date', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  final VerificationMeta _endDateMeta = const VerificationMeta('endDate');
-  @override
-  late final GeneratedColumn<DateTime?> endDate = GeneratedColumn<DateTime?>(
-      'end_date', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  final VerificationMeta _categoryFksMeta =
-      const VerificationMeta('categoryFks');
-  @override
-  late final GeneratedColumnWithTypeConverter<List<int>, String?> categoryFks =
-      GeneratedColumn<String?>('category_fks', aliasedName, true,
-              type: const StringType(), requiredDuringInsert: false)
-          .withConverter<List<int>>($BudgetsTable.$converter0);
-  final VerificationMeta _allCategoryFksMeta =
-      const VerificationMeta('allCategoryFks');
-  @override
-  late final GeneratedColumn<bool?> allCategoryFks = GeneratedColumn<bool?>(
-      'all_category_fks', aliasedName, false,
-      type: const BoolType(),
-      requiredDuringInsert: true,
-      defaultConstraints: 'CHECK (all_category_fks IN (0, 1))');
-  final VerificationMeta _periodLengthMeta =
-      const VerificationMeta('periodLength');
-  @override
-  late final GeneratedColumn<int?> periodLength = GeneratedColumn<int?>(
-      'period_length', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  final VerificationMeta _reoccurrenceMeta =
-      const VerificationMeta('reoccurrence');
-  @override
-  late final GeneratedColumnWithTypeConverter<BudgetReoccurence?, int?>
-      reoccurrence = GeneratedColumn<int?>('reoccurrence', aliasedName, true,
-              type: const IntType(), requiredDuringInsert: false)
-          .withConverter<BudgetReoccurence?>($BudgetsTable.$converter1);
   final VerificationMeta _dateCreatedMeta =
       const VerificationMeta('dateCreated');
   @override
@@ -2620,385 +3190,497 @@ class $BudgetsTable extends Budgets with TableInfo<$BudgetsTable, Budget> {
           type: const IntType(),
           requiredDuringInsert: false,
           clientDefault: () => new DateTime.now());
-  final VerificationMeta _pinnedMeta = const VerificationMeta('pinned');
-  @override
-  late final GeneratedColumn<bool?> pinned = GeneratedColumn<bool?>(
-      'pinned', aliasedName, false,
-      type: const BoolType(),
-      requiredDuringInsert: false,
-      defaultConstraints: 'CHECK (pinned IN (0, 1))',
-      defaultValue: const Constant(false));
   final VerificationMeta _orderMeta = const VerificationMeta('order');
   @override
   late final GeneratedColumn<int?> order = GeneratedColumn<int?>(
       'order', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  final VerificationMeta _walletFkMeta = const VerificationMeta('walletFk');
-  @override
-  late final GeneratedColumn<int?> walletFk = GeneratedColumn<int?>(
-      'wallet_fk', aliasedName, false,
-      type: const IntType(), requiredDuringInsert: true);
-  @override
-  List<GeneratedColumn> get $columns => [
-        budgetPk,
-        name,
-        amount,
-        colour,
-        startDate,
-        endDate,
-        categoryFks,
-        allCategoryFks,
-        periodLength,
-        reoccurrence,
-        dateCreated,
-        pinned,
-        order,
-        walletFk
-      ];
-  @override
-  String get aliasedName => _alias ?? 'budgets';
-  @override
-  String get actualTableName => 'budgets';
-  @override
-  VerificationContext validateIntegrity(Insertable<Budget> instance,
-      {bool isInserting = false}) {
-    final context = VerificationContext();
-    final data = instance.toColumns(true);
-    if (data.containsKey('budget_pk')) {
-      context.handle(_budgetPkMeta,
-          budgetPk.isAcceptableOrUnknown(data['budget_pk']!, _budgetPkMeta));
-    }
-    if (data.containsKey('name')) {
-      context.handle(
-          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
-    } else if (isInserting) {
-      context.missing(_nameMeta);
-    }
-    if (data.containsKey('amount')) {
-      context.handle(_amountMeta,
-          amount.isAcceptableOrUnknown(data['amount']!, _amountMeta));
-    } else if (isInserting) {
-      context.missing(_amountMeta);
-    }
-    if (data.containsKey('colour')) {
-      context.handle(_colourMeta,
-          colour.isAcceptableOrUnknown(data['colour']!, _colourMeta));
-    }
-    if (data.containsKey('start_date')) {
-      context.handle(_startDateMeta,
-          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
-    } else if (isInserting) {
-      context.missing(_startDateMeta);
-    }
-    if (data.containsKey('end_date')) {
-      context.handle(_endDateMeta,
-          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
-    } else if (isInserting) {
-      context.missing(_endDateMeta);
-    }
-    context.handle(_categoryFksMeta, const VerificationResult.success());
-    if (data.containsKey('all_category_fks')) {
+      type: const IntType(), requiredDuringInsert: true);
+  @override
+  List<GeneratedColumn> get $columns =>
+      [billSplitterPk, name, dateCreated, order];
+  @override
+  String get aliasedName => _alias ?? 'bill_splitters';
+  @override
+  String get actualTableName => 'bill_splitters';
+  @override
+  VerificationContext validateIntegrity(Insertable<BillSplitter> instance,
+      {bool isInserting = false}) {
+    final context = VerificationContext();
+    final data = instance.toColumns(true);
+    if (data.containsKey('bill_splitter_pk')) {
       context.handle(
-          _allCategoryFksMeta,
-          allCategoryFks.isAcceptableOrUnknown(
-              data['all_category_fks']!, _allCategoryFksMeta));
-    } else if (isInserting) {
-      context.missing(_allCategoryFksMeta);
+          _billSplitterPkMeta,
+          billSplitterPk.isAcceptableOrUnknown(
+              data['bill_splitter_pk']!, _billSplitterPkMeta));
     }
-    if (data.containsKey('period_length')) {
+    if (data.containsKey('name')) {
       context.handle(
-          _periodLengthMeta,
-          periodLength.isAcceptableOrUnknown(
-              data['period_length']!, _periodLengthMeta));
+          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
     } else if (isInserting) {
-      context.missing(_periodLengthMeta);
+      context.missing(_nameMeta);
     }
-    context.handle(_reoccurrenceMeta, const VerificationResult.success());
     if (data.containsKey('date_created')) {
       context.handle(
           _dateCreatedMeta,
           dateCreated.isAcceptableOrUnknown(
               data['date_created']!, _dateCreatedMeta));
     }
-    if (data.containsKey('pinned')) {
-      context.handle(_pinnedMeta,
-          pinned.isAcceptableOrUnknown(data['pinned']!, _pinnedMeta));
-    }
     if (data.containsKey('order')) {
       context.handle(
           _orderMeta, order.isAcceptableOrUnknown(data['order']!, _orderMeta));
     } else if (isInserting) {
       context.missing(_orderMeta);
     }
-    if (data.containsKey('wallet_fk')) {
-      context.handle(_walletFkMeta,
-          walletFk.isAcceptableOrUnknown(data['wallet_fk']!, _walletFkMeta));
-    } else if (isInserting) {
-      context.missing(_walletFkMeta);
-    }
     return context;
   }
 
   @override
-  Set<GeneratedColumn> get $primaryKey => {budgetPk};
+  Set<GeneratedColumn> get $primaryKey => {billSplitterPk};
   @override
-  Budget map(Map<String, dynamic> data, {String? tablePrefix}) {
-    return Budget.fromData(data,
+  BillSplitter map(Map<String, dynamic> data, {String? tablePrefix}) {
+    return BillSplitter.fromData(data,
         prefix: tablePrefix != null ? '$tablePrefix.' : null);
   }
 
   @override
-  $BudgetsTable createAlias(String alias) {
-    return $BudgetsTable(attachedDatabase, alias);
+  $BillSplittersTable createAlias(String alias) {
+    return $BillSplittersTable(attachedDatabase, alias);
   }
-
-  static TypeConverter<List<int>, String> $converter0 =
-      const IntListInColumnConverter();
-  static TypeConverter<BudgetReoccurence?, int> $converter1 =
-      const EnumIndexConverter<BudgetReoccurence>(BudgetReoccurence.values);
 }
 
-class AppSetting extends DataClass implements Insertable<AppSetting> {
-  final int settingsPk;
-  final String settingsJSON;
-  final DateTime dateUpdated;
-  AppSetting(
-      {required this.settingsPk,
-      required this.settingsJSON,
-      required this.dateUpdated});
-  factory AppSetting.fromData(Map<String, dynamic> data, {String? prefix}) {
+class BillSplitterTransaction extends DataClass
+    implements Insertable<BillSplitterTransaction> {
+  final int billSplitterTransactionPk;
+  final int billSplitterFk;
+  final String name;
+  final double cost;
+  final List<String>? personNames;
+  final List<double>? personsPercents;
+  final DateTime dateCreated;
+  BillSplitterTransaction(
+      {required this.billSplitterTransactionPk,
+      required this.billSplitterFk,
+      required this.name,
+      required this.cost,
+      this.personNames,
+      this.personsPercents,
+      required this.dateCreated});
+  factory BillSplitterTransaction.fromData(Map<String, dynamic> data,
+      {String? prefix}) {
     final effectivePrefix = prefix ?? '';
-    return AppSetting(
-      settingsPk: const IntType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}settings_pk'])!,
-      settingsJSON: const StringType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}settings_j_s_o_n'])!,
-      dateUpdated: const DateTimeType()
-          .mapFromDatabaseResponse(data['${effectivePrefix}date_updated'])!,
+    return BillSplitterTransaction(
+      billSplitterTransactionPk: const IntType().mapFromDatabaseResponse(
+          data['${effectivePrefix}bill_splitter_transaction_pk'])!,
+      billSplitterFk: const IntType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}bill_splitter_fk'])!,
+      name: const StringType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}name'])!,
+      cost: const RealType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}cost'])!,
+      personNames: $BillSplitterTransactionsTable.$converter0.mapToDart(
+          const StringType()
+              .mapFromDatabaseResponse(data['${effectivePrefix}person_names'])),
+      personsPercents: $BillSplitterTransactionsTable.$converter1.mapToDart(
+          const StringType().mapFromDatabaseResponse(
+              data['${effectivePrefix}persons_percents'])),
+      dateCreated: const DateTimeType()
+          .mapFromDatabaseResponse(data['${effectivePrefix}date_created'])!,
     );
   }
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    map['settings_pk'] = Variable<int>(settingsPk);
-    map['settings_j_s_o_n'] = Variable<String>(settingsJSON);
-    map['date_updated'] = Variable<DateTime>(dateUpdated);
+    map['bill_splitter_transaction_pk'] =
+        Variable<int>(billSplitterTransactionPk);
+    map['bill_splitter_fk'] = Variable<int>(billSplitterFk);
+    map['name'] = Variable<String>(name);
+    map['cost'] = Variable<double>(cost);
+    if (!nullToAbsent || personNames != null) {
+      final converter = $BillSplitterTransactionsTable.$converter0;
+      map['person_names'] = Variable<String?>(converter.mapToSql(personNames));
+    }
+    if (!nullToAbsent || personsPercents != null) {
+      final converter = $BillSplitterTransactionsTable.$converter1;
+      map['persons_percents'] =
+          Variable<String?>(converter.mapToSql(personsPercents));
+    }
+    map['date_created'] = Variable<DateTime>(dateCreated);
     return map;
   }
 
-  AppSettingsCompanion toCompanion(bool nullToAbsent) {
-    return AppSettingsCompanion(
-      settingsPk: Value(settingsPk),
-      settingsJSON: Value(settingsJSON),
-      dateUpdated: Value(dateUpdated),
+  BillSplitterTransactionsCompanion toCompanion(bool nullToAbsent) {
+    return BillSplitterTransactionsCompanion(
+      billSplitterTransactionPk: Value(billSplitterTransactionPk),
+      billSplitterFk: Value(billSplitterFk),
+      name: Value(name),
+      cost: Value(cost),
+      personNames: personNames == null && nullToAbsent
+          ? const Value.absent()
+          : Value(personNames),
+      personsPercents: personsPercents == null && nullToAbsent
+          ? const Value.absent()
+          : Value(personsPercents),
+      dateCreated: Value(dateCreated),
     );
   }
 
-  factory AppSetting.fromJson(Map<String, dynamic> json,
+  factory BillSplitterTransaction.fromJson(Map<String, dynamic> json,
       {ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
-    return AppSetting(
-      settingsPk: serializer.fromJson<int>(json['settingsPk']),
-      settingsJSON: serializer.fromJson<String>(json['settingsJSON']),
-      dateUpdated: serializer.fromJson<DateTime>(json['dateUpdated']),
+    return BillSplitterTransaction(
+      billSplitterTransactionPk:
+          serializer.fromJson<int>(json['billSplitterTransactionPk']),
+      billSplitterFk: serializer.fromJson<int>(json['billSplitterFk']),
+      name: serializer.fromJson<String>(json['name']),
+      cost: serializer.fromJson<double>(json['cost']),
+      personNames: serializer.fromJson<List<String>?>(json['personNames']),
+      personsPercents:
+          serializer.fromJson<List<double>?>(json['personsPercents']),
+      dateCreated: serializer.fromJson<DateTime>(json['dateCreated']),
     );
   }
   @override
   Map<String, dynamic> toJson({ValueSerializer? serializer}) {
     serializer ??= driftRuntimeOptions.defaultSerializer;
     return <String, dynamic>{
-      'settingsPk': serializer.toJson<int>(settingsPk),
-      'settingsJSON': serializer.toJson<String>(settingsJSON),
-      'dateUpdated': serializer.toJson<DateTime>(dateUpdated),
+      'billSplitterTransactionPk':
+          serializer.toJson<int>(billSplitterTransactionPk),
+      'billSplitterFk': serializer.toJson<int>(billSplitterFk),
+      'name': serializer.toJson<String>(name),
+      'cost': serializer.toJson<double>(cost),
+      'personNames': serializer.toJson<List<String>?>(personNames),
+      'personsPercents': serializer.toJson<List<double>?>(personsPercents),
+      'dateCreated': serializer.toJson<DateTime>(dateCreated),
     };
   }
 
-  AppSetting copyWith(
-          {int? settingsPk, String? settingsJSON, DateTime? dateUpdated}) =>
-      AppSetting(
-        settingsPk: settingsPk ?? this.settingsPk,
-        settingsJSON: settingsJSON ?? this.settingsJSON,
-        dateUpdated: dateUpdated ?? this.dateUpdated,
+  BillSplitterTransaction copyWith(
+          {int? billSplitterTransactionPk,
+          int? billSplitterFk,
+          String? name,
+          double? cost,
+          List<String>? personNames,
+          List<double>? personsPercents,
+          DateTime? dateCreated}) =>
+      BillSplitterTransaction(
+        billSplitterTransactionPk:
+            billSplitterTransactionPk ?? this.billSplitterTransactionPk,
+        billSplitterFk: billSplitterFk ?? this.billSplitterFk,
+        name: name ?? this.name,
+        cost: cost ?? this.cost,
+        personNames: personNames ?? this.personNames,
+        personsPercents: personsPercents ?? this.personsPercents,
+        dateCreated: dateCreated ?? this.dateCreated,
       );
   @override
   String toString() {
-    return (StringBuffer('AppSetting(')
-          ..write('settingsPk: $settingsPk, ')
-          ..write('settingsJSON: $settingsJSON, ')
-          ..write('dateUpdated: $dateUpdated')
+    return (StringBuffer('BillSplitterTransaction(')
+          ..write('billSplitterTransactionPk: $billSplitterTransactionPk, ')
+          ..write('billSplitterFk: $billSplitterFk, ')
+          ..write('name: $name, ')
+          ..write('cost: $cost, ')
+          ..write('personNames: $personNames, ')
+          ..write('personsPercents: $personsPercents, ')
+          ..write('dateCreated: $dateCreated')
           ..write(')'))
         .toString();
   }
 
   @override
-  int get hashCode => Object.hash(settingsPk, settingsJSON, dateUpdated);
+  int get hashCode => Object.hash(billSplitterTransactionPk, billSplitterFk,
+      name, cost, personNames, personsPercents, dateCreated);
   @override
   bool operator ==(Object other) =>
       identical(this, other) ||
-      (other is AppSetting &&
-          other.settingsPk == this.settingsPk &&
-          other.settingsJSON == this.settingsJSON &&
-          other.dateUpdated == this.dateUpdated);
+      (other is BillSplitterTransaction &&
+          other.billSplitterTransactionPk == this.billSplitterTransactionPk &&
+          other.billSplitterFk == this.billSplitterFk &&
+          other.name == this.name &&
+          other.cost == this.cost &&
+          other.personNames == this.personNames &&
+          other.personsPercents == this.personsPercents &&
+          other.dateCreated == this.dateCreated);
 }
 
-class AppSettingsCompanion extends UpdateCompanion<AppSetting> {
-  final Value<int> settingsPk;
-  final Value<String> settingsJSON;
-  final Value<DateTime> dateUpdated;
-  const AppSettingsCompanion({
-    this.settingsPk = const Value.absent(),
-    this.settingsJSON = const Value.absent(),
-    this.dateUpdated = const Value.absent(),
+class BillSplitterTransactionsCompanion
+    extends UpdateCompanion<BillSplitterTransaction> {
+  final Value<int> billSplitterTransactionPk;
+  final Value<int> billSplitterFk;
+  final Value<String> name;
+  final Value<double> cost;
+  final Value<List<String>?> personNames;
+  final Value<List<double>?> personsPercents;
+  final Value<DateTime> dateCreated;
+  const BillSplitterTransactionsCompanion({
+    this.billSplitterTransactionPk = const Value.absent(),
+    this.billSplitterFk = const Value.absent(),
+    this.name = const Value.absent(),
+    this.cost = const Value.absent(),
+    this.personNames = const Value.absent(),
+    this.personsPercents = const Value.absent(),
+    this.dateCreated = const Value.absent(),
   });
-  AppSettingsCompanion.insert({
-    this.settingsPk = const Value.absent(),
-    required String settingsJSON,
-    this.dateUpdated = const Value.absent(),
-  }) : settingsJSON = Value(settingsJSON);
-  static Insertable<AppSetting> custom({
-    Expression<int>? settingsPk,
-    Expression<String>? settingsJSON,
-    Expression<DateTime>? dateUpdated,
+  BillSplitterTransactionsCompanion.insert({
+    this.billSplitterTransactionPk = const Value.absent(),
+    required int billSplitterFk,
+    required String name,
+    required double cost,
+    this.personNames = const Value.absent(),
+    this.personsPercents = const Value.absent(),
+    this.dateCreated = const Value.absent(),
+  })  : billSplitterFk = Value(billSplitterFk),
+        name = Value(name),
+        cost = Value(cost);
+  static Insertable<BillSplitterTransaction> custom({
+    Expression<int>? billSplitterTransactionPk,
+    Expression<int>? billSplitterFk,
+    Expression<String>? name,
+    Expression<double>? cost,
+    Expression<List<String>?>? personNames,
+    Expression<List<double>?>? personsPercents,
+    Expression<DateTime>? dateCreated,
   }) {
     return RawValuesInsertable({
-      if (settingsPk != null) 'settings_pk': settingsPk,
-      if (settingsJSON != null) 'settings_j_s_o_n': settingsJSON,
-      if (dateUpdated != null) 'date_updated': dateUpdated,
+      if (billSplitterTransactionPk != null)
+        'bill_splitter_transaction_pk': billSplitterTransactionPk,
+      if (billSplitterFk != null) 'bill_splitter_fk': billSplitterFk,
+      if (name != null) 'name': name,
+      if (cost != null) 'cost': cost,
+      if (personNames != null) 'person_names': personNames,
+      if (personsPercents != null) 'persons_percents': personsPercents,
+      if (dateCreated != null) 'date_created': dateCreated,
     });
   }
 
-  AppSettingsCompanion copyWith(
-      {Value<int>? settingsPk,
-      Value<String>? settingsJSON,
-      Value<DateTime>? dateUpdated}) {
-    return AppSettingsCompanion(
-      settingsPk: settingsPk ?? this.settingsPk,
-      settingsJSON: settingsJSON ?? this.settingsJSON,
-      dateUpdated: dateUpdated ?? this.dateUpdated,
+  BillSplitterTransactionsCompanion copyWith(
+      {Value<int>? billSplitterTransactionPk,
+      Value<int>? billSplitterFk,
+      Value<String>? name,
+      Value<double>? cost,
+      Value<List<String>?>? personNames,
+      Value<List<double>?>? personsPercents,
+      Value<DateTime>? dateCreated}) {
+    return BillSplitterTransactionsCompanion(
+      billSplitterTransactionPk:
+          billSplitterTransactionPk ?? this.billSplitterTransactionPk,
+      billSplitterFk: billSplitterFk ?? this.billSplitterFk,
+      name: name ?? this.name,
+      cost: cost ?? this.cost,
+      personNames: personNames ?? this.personNames,
+      personsPercents: personsPercents ?? this.personsPercents,
+      dateCreated: dateCreated ?? this.dateCreated,
     );
   }
 
   @override
   Map<String, Expression> toColumns(bool nullToAbsent) {
     final map = <String, Expression>{};
-    if (settingsPk.present) {
-      map['settings_pk'] = Variable<int>(settingsPk.value);
+    if (billSplitterTransactionPk.present) {
+      map['bill_splitter_transaction_pk'] =
+          Variable<int>(billSplitterTransactionPk.value);
     }
-    if (settingsJSON.present) {
-      map['settings_j_s_o_n'] = Variable<String>(settingsJSON.value);
+    if (billSplitterFk.present) {
+      map['bill_splitter_fk'] = Variable<int>(billSplitterFk.value);
     }
-    if (dateUpdated.present) {
-      map['date_updated'] = Variable<DateTime>(dateUpdated.value);
+    if (name.present) {
+      map['name'] = Variable<String>(name.value);
+    }
+    if (cost.present) {
+      map['cost'] = Variable<double>(cost.value);
+    }
+    if (personNames.present) {
+      final converter = $BillSplitterTransactionsTable.$converter0;
+      map['person_names'] =
+          Variable<String?>(converter.mapToSql(personNames.value));
+    }
+    if (personsPercents.present) {
+      final converter = $BillSplitterTransactionsTable.$converter1;
+      map['persons_percents'] =
+          Variable<String?>(converter.mapToSql(personsPercents.value));
+    }
+    if (dateCreated.present) {
+      map['date_created'] = Variable<DateTime>(dateCreated.value);
     }
     return map;
   }
 
   @override
   String toString() {
-    return (StringBuffer('AppSettingsCompanion(')
-          ..write('settingsPk: $settingsPk, ')
-          ..write('settingsJSON: $settingsJSON, ')
-          ..write('dateUpdated: $dateUpdated')
+    return (StringBuffer('BillSplitterTransactionsCompanion(')
+          ..write('billSplitterTransactionPk: $billSplitterTransactionPk, ')
+          ..write('billSplitterFk: $billSplitterFk, ')
+          ..write('name: $name, ')
+          ..write('cost: $cost, ')
+          ..write('personNames: $personNames, ')
+          ..write('personsPercents: $personsPercents, ')
+          ..write('dateCreated: $dateCreated')
           ..write(')'))
         .toString();
   }
 }
 
-class $AppSettingsTable extends AppSettings
-    with TableInfo<$AppSettingsTable, AppSetting> {
+class $BillSplitterTransactionsTable extends BillSplitterTransactions
+    with TableInfo<$BillSplitterTransactionsTable, BillSplitterTransaction> {
   @override
   final GeneratedDatabase attachedDatabase;
   final String? _alias;
-  $AppSettingsTable(this.attachedDatabase, [this._alias]);
-  final VerificationMeta _settingsPkMeta = const VerificationMeta('settingsPk');
+  $BillSplitterTransactionsTable(this.attachedDatabase, [this._alias]);
+  final VerificationMeta _billSplitterTransactionPkMeta =
+      const VerificationMeta('billSplitterTransactionPk');
   @override
-  late final GeneratedColumn<int?> settingsPk = GeneratedColumn<int?>(
-      'settings_pk', aliasedName, false,
+  late final GeneratedColumn<int?> billSplitterTransactionPk =
+      GeneratedColumn<int?>('bill_splitter_transaction_pk', aliasedName, false,
+          type: const IntType(),
+          requiredDuringInsert: false,
+          defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
+  final VerificationMeta _billSplitterFkMeta =
+      const VerificationMeta('billSplitterFk');
+  @override
+  late final GeneratedColumn<int?> billSplitterFk = GeneratedColumn<int?>(
+      'bill_splitter_fk', aliasedName, false,
       type: const IntType(),
-      requiredDuringInsert: false,
-      defaultConstraints: 'PRIMARY KEY AUTOINCREMENT');
-  final VerificationMeta _settingsJSONMeta =
-      const VerificationMeta('settingsJSON');
+      requiredDuringInsert: true,
+      defaultConstraints: 'REFERENCES bill_splitters (bill_splitter_pk)');
+  final VerificationMeta _nameMeta = const VerificationMeta('name');
   @override
-  late final GeneratedColumn<String?> settingsJSON = GeneratedColumn<String?>(
-      'settings_j_s_o_n', aliasedName, false,
-      type: const StringType(), requiredDuringInsert: true);
-  final VerificationMeta _dateUpdatedMeta =
-      const VerificationMeta('dateUpdated');
+  late final GeneratedColumn<String?> name = GeneratedColumn<String?>(
+      'name', aliasedName, false,
+      additionalChecks: GeneratedColumn.checkTextLength(),
+      type: const StringType(),
+      requiredDuringInsert: true);
+  final VerificationMeta _costMeta = const VerificationMeta('cost');
   @override
-  late final GeneratedColumn<DateTime?> dateUpdated =
-      GeneratedColumn<DateTime?>('date_updated', aliasedName, false,
+  late final GeneratedColumn<double?> cost = GeneratedColumn<double?>(
+      'cost', aliasedName, false,
+      type: const RealType(), requiredDuringInsert: true);
+  final VerificationMeta _personNamesMeta =
+      const VerificationMeta('personNames');
+  @override
+  late final GeneratedColumnWithTypeConverter<List<String>, String?>
+      personNames = GeneratedColumn<String?>('person_names', aliasedName, true,
+              type: const StringType(), requiredDuringInsert: false)
+          .withConverter<List<String>>(
+              $BillSplitterTransactionsTable.$converter0);
+  final VerificationMeta _personsPercentsMeta =
+      const VerificationMeta('personsPercents');
+  @override
+  late final GeneratedColumnWithTypeConverter<List<double>, String?>
+      personsPercents = GeneratedColumn<String?>(
+              'persons_percents', aliasedName, true,
+              type: const StringType(), requiredDuringInsert: false)
+          .withConverter<List<double>>(
+              $BillSplitterTransactionsTable.$converter1);
+  final VerificationMeta _dateCreatedMeta =
+      const VerificationMeta('dateCreated');
+  @override
+  late final GeneratedColumn<DateTime?> dateCreated =
+      GeneratedColumn<DateTime?>('date_created', aliasedName, false,
           type: const IntType(),
           requiredDuringInsert: false,
           clientDefault: () => new DateTime.now());
   @override
-  List<GeneratedColumn> get $columns => [settingsPk, settingsJSON, dateUpdated];
+  List<GeneratedColumn> get $columns => [
+        billSplitterTransactionPk,
+        billSplitterFk,
+        name,
+        cost,
+        personNames,
+        personsPercents,
+        dateCreated
+      ];
   @override
-  String get aliasedName => _alias ?? 'app_settings';
+  String get aliasedName => _alias ?? 'bill_splitter_transactions';
   @override
-  String get actualTableName => 'app_settings';
+  String get actualTableName => 'bill_splitter_transactions';
   @override
-  VerificationContext validateIntegrity(Insertable<AppSetting> instance,
+  VerificationContext validateIntegrity(
+      Insertable<BillSplitterTransaction> instance,
       {bool isInserting = false}) {
     final context = VerificationContext();
     final data = instance.toColumns(true);
-    if (data.containsKey('settings_pk')) {
+    if (data.containsKey('bill_splitter_transaction_pk')) {
       context.handle(
-          _settingsPkMeta,
-          settingsPk.isAcceptableOrUnknown(
-              data['settings_pk']!, _settingsPkMeta));
+          _billSplitterTransactionPkMeta,
+          billSplitterTransactionPk.isAcceptableOrUnknown(
+              data['bill_splitter_transaction_pk']!,
+              _billSplitterTransactionPkMeta));
     }
-    if (data.containsKey('settings_j_s_o_n')) {
+    if (data.containsKey('bill_splitter_fk')) {
       context.handle(
-          _settingsJSONMeta,
-          settingsJSON.isAcceptableOrUnknown(
-              data['settings_j_s_o_n']!, _settingsJSONMeta));
+          _billSplitterFkMeta,
+          billSplitterFk.isAcceptableOrUnknown(
+              data['bill_splitter_fk']!, _billSplitterFkMeta));
     } else if (isInserting) {
-      context.missing(_settingsJSONMeta);
+      context.missing(_billSplitterFkMeta);
     }
-    if (data.containsKey('date_updated')) {
+    if (data.containsKey('name')) {
       context.handle(
-          _dateUpdatedMeta,
-          dateUpdated.isAcceptableOrUnknown(
-              data['date_updated']!, _dateUpdatedMeta));
+          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
+    } else if (isInserting) {
+      context.missing(_nameMeta);
+    }
+    if (data.containsKey('cost')) {
+      context.handle(
+          _costMeta, cost.isAcceptableOrUnknown(data['cost']!, _costMeta));
+    } else if (isInserting) {
+      context.missing(_costMeta);
+    }
+    context.handle(_personNamesMeta, const VerificationResult.success());
+    context.handle(_personsPercentsMeta, const VerificationResult.success());
+    if (data.containsKey('date_created')) {
+      context.handle(
+          _dateCreatedMeta,
+          dateCreated.isAcceptableOrUnknown(
+              data['date_created']!, _dateCreatedMeta));
     }
     return context;
   }
 
   @override
-  Set<GeneratedColumn> get $primaryKey => {settingsPk};
+  Set<GeneratedColumn> get $primaryKey => {billSplitterTransactionPk};
   @override
-  AppSetting map(Map<String, dynamic> data, {String? tablePrefix}) {
-    return AppSetting.fromData(data,
+  BillSplitterTransaction map(Map<String, dynamic> data,
+      {String? tablePrefix}) {
+    return BillSplitterTransaction.fromData(data,
         prefix: tablePrefix != null ? '$tablePrefix.' : null);
   }
 
   @override
-  $AppSettingsTable createAlias(String alias) {
-    return $AppSettingsTable(attachedDatabase, alias);
+  $BillSplitterTransactionsTable createAlias(String alias) {
+    return $BillSplitterTransactionsTable(attachedDatabase, alias);
   }
+
+  static TypeConverter<List<String>, String> $converter0 =
+      const StringListInColumnConverter();
+  static TypeConverter<List<double>, String> $converter1 =
+      const DoubleListInColumnConverter();
 }
 
 abstract class _$FinanceDatabase extends GeneratedDatabase {
   _$FinanceDatabase(QueryExecutor e) : super(SqlTypeSystem.defaultInstance, e);
   late final $WalletsTable wallets = $WalletsTable(this);
-  late final $TransactionsTable transactions = $TransactionsTable(this);
   late final $CategoriesTable categories = $CategoriesTable(this);
+  late final $TransactionsTable transactions = $TransactionsTable(this);
   late final $LabelsTable labels = $LabelsTable(this);
   late final $AssociatedTitlesTable associatedTitles =
       $AssociatedTitlesTable(this);
   late final $BudgetsTable budgets = $BudgetsTable(this);
   late final $AppSettingsTable appSettings = $AppSettingsTable(this);
+  late final $BillSplittersTable billSplitters = $BillSplittersTable(this);
+  late final $BillSplitterTransactionsTable billSplitterTransactions =
+      $BillSplitterTransactionsTable(this);
   @override
   Iterable<TableInfo> get allTables => allSchemaEntities.whereType<TableInfo>();
   @override
   List<DatabaseSchemaEntity> get allSchemaEntities => [
         wallets,
-        transactions,
         categories,
+        transactions,
         labels,
         associatedTitles,
         budgets,
-        appSettings
+        appSettings,
+        billSplitters,
+        billSplitterTransactions
       ];
 }
diff --git a/budget/lib/pages/addBillSplitterTransactionPage.dart b/budget/lib/pages/addBillSplitterTransactionPage.dart
new file mode 100644
index 000000000..472b67765
--- /dev/null
+++ b/budget/lib/pages/addBillSplitterTransactionPage.dart
@@ -0,0 +1,394 @@
+import 'dart:developer';
+
+import 'package:budget/database/tables.dart';
+import 'package:budget/functions.dart';
+import 'package:budget/pages/addTransactionPage.dart';
+import 'package:budget/struct/databaseGlobal.dart';
+import 'package:budget/widgets/button.dart';
+import 'package:budget/widgets/categoryEntry.dart';
+import 'package:budget/widgets/dropdownSelect.dart';
+import 'package:budget/widgets/fadeIn.dart';
+import 'package:budget/widgets/openBottomSheet.dart';
+import 'package:budget/widgets/openPopup.dart';
+import 'package:budget/widgets/pageFramework.dart';
+import 'package:budget/widgets/popupFramework.dart';
+import 'package:budget/widgets/radioItems.dart';
+import 'package:budget/widgets/selectAmount.dart';
+import 'package:budget/widgets/selectCategory.dart';
+import 'package:budget/widgets/selectColor.dart';
+import 'package:budget/widgets/tappable.dart';
+import 'package:budget/widgets/textInput.dart';
+import 'package:budget/widgets/textWidgets.dart';
+import 'package:budget/widgets/transactionEntry.dart';
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/foundation.dart';
+import 'package:flutter/material.dart';
+import 'dart:async';
+import 'package:budget/colors.dart';
+import 'package:math_expressions/math_expressions.dart';
+
+class AddBillSplitterTransaction extends StatefulWidget {
+  AddBillSplitterTransaction({
+    Key? key,
+    required this.title,
+    this.billSplitterTransaction,
+  }) : super(key: key);
+  final String title;
+
+  //When a transaction is passed in, we are editing that transaction
+  final BillSplitterTransaction? billSplitterTransaction;
+
+  @override
+  _AddBillSplitterTransactionState createState() =>
+      _AddBillSplitterTransactionState();
+}
+
+class _AddBillSplitterTransactionState
+    extends State<AddBillSplitterTransaction> {
+  bool? canAddBudget;
+
+  double? selectedAmount;
+  String? selectedAmountCalculation;
+  String? selectedTitle;
+
+  Future<void> selectTitle() async {
+    openBottomSheet(
+      context,
+      PopupFramework(
+        title: "Enter Name",
+        child: SelectText(
+          setSelectedText: setSelectedTitle,
+          labelText: "Name",
+          selectedText: selectedTitle,
+        ),
+      ),
+      snap: false,
+    );
+  }
+
+  Future<void> selectAmount(BuildContext context) async {
+    openBottomSheet(
+      context,
+      PopupFramework(
+        title: "Enter Amount",
+        child: SelectAmount(
+          amountPassed: selectedAmountCalculation ?? "",
+          setSelectedAmount: setSelectedAmount,
+          next: () async {
+            Navigator.pop(context);
+          },
+          nextLabel: "Set Amount",
+        ),
+      ),
+    );
+  }
+
+  void setSelectedAmount(double amount, String amountCalculation) {
+    if (amount == selectedAmount) {
+      selectedAmountCalculation = amountCalculation;
+    } else {
+      setState(() {
+        selectedAmount = amount;
+        selectedAmountCalculation = amountCalculation;
+      });
+    }
+    determineBottomButton();
+    return;
+  }
+
+  void setSelectedTitle(String title) {
+    setState(() {
+      selectedTitle = title;
+    });
+    determineBottomButton();
+    return;
+  }
+
+  // Future addBudget() async {
+  //   print("Added budget");
+  //   await database.createOrUpdateBudget(await createBudget());
+  //   print(await database.getAmountOfBudgets());
+  //   Navigator.pop(context);
+  // }
+
+  // Future<Budget> createBudget() async {
+  //   List<int> categoryFks = [];
+  //   for (TransactionCategory category in selectedCategories ?? []) {
+  //     categoryFks.add(category.categoryPk);
+  //   }
+  //   return await Budget(
+  //     budgetPk: widget.budget != null
+  //         ? widget.budget!.budgetPk
+  //         : DateTime.now().millisecondsSinceEpoch,
+  //     name: selectedTitle ?? "",
+  //     amount: selectedAmount ?? 0,
+  //     colour: toHexString(selectedColor),
+  //     startDate: selectedStartDate,
+  //     endDate: selectedEndDate ?? DateTime.now(),
+  //     categoryFks: categoryFks,
+  //     allCategoryFks: selectedAllCategories,
+  //     periodLength: selectedPeriodLength,
+  //     reoccurrence: mapRecurrence(selectedRecurrence),
+  //     dateCreated:
+  //         widget.budget != null ? widget.budget!.dateCreated : DateTime.now(),
+  //     pinned: true,
+  //     order: widget.budget != null
+  //         ? widget.budget!.order
+  //         : await database.getAmountOfBudgets(),
+  //     walletFk: 0,
+  //   );
+  // }
+
+  @override
+  void initState() {
+    super.initState();
+    if (widget.billSplitterTransaction != null) {
+      //We are editing a budget
+      //Fill in the information from the passed in budget
+      selectedTitle = widget.billSplitterTransaction!.name;
+
+      selectedAmount = widget.billSplitterTransaction!.cost;
+      var amountString =
+          widget.billSplitterTransaction!.cost.toStringAsFixed(2);
+      if (amountString.substring(amountString.length - 2) == "00") {
+        selectedAmountCalculation =
+            amountString.substring(0, amountString.length - 3);
+      } else {
+        selectedAmountCalculation = amountString;
+      }
+
+      WidgetsBinding.instance.addPostFrameCallback((_) {
+        updateInitial();
+      });
+    }
+  }
+
+  @override
+  void dispose() {
+    super.dispose();
+  }
+
+  updateInitial() async {
+    //Set to false because we can't save until we made some changes
+    setState(() {
+      canAddBudget = false;
+    });
+  }
+
+  determineBottomButton() {
+    if (selectedTitle != null &&
+        (selectedAmount ?? 0) >= 0 &&
+        selectedAmount != null) {
+      if (canAddBudget != true) {
+        this.setState(() {
+          canAddBudget = true;
+        });
+        return true;
+      }
+    } else {
+      if (canAddBudget != false) {
+        this.setState(() {
+          canAddBudget = false;
+        });
+        return false;
+      }
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return WillPopScope(
+      onWillPop: () async {
+        if (widget.billSplitterTransaction != null) {
+          discardChangesPopup(
+            context,
+            previousObject: widget.billSplitterTransaction,
+            currentObject: "await createBudget()",
+          );
+        } else {
+          discardChangesPopup(context);
+        }
+        return false;
+      },
+      child: Scaffold(
+        resizeToAvoidBottomInset: false,
+        body: GestureDetector(
+          onTap: () {
+            //Minimize keyboard when tap non interactive widget
+            FocusScopeNode currentFocus = FocusScope.of(context);
+            if (!currentFocus.hasPrimaryFocus) {
+              currentFocus.unfocus();
+            }
+          },
+          child: Stack(
+            children: [
+              PageFramework(
+                title: widget.title,
+                navbar: false,
+                onBackButton: () async {
+                  if (widget.billSplitterTransaction != null) {
+                    discardChangesPopup(
+                      context,
+                      previousObject: widget.billSplitterTransaction,
+                      currentObject: "await createBudget()",
+                    );
+                  } else {
+                    discardChangesPopup(context);
+                  }
+                },
+                onDragDownToDissmiss: () async {
+                  if (widget.billSplitterTransaction != null) {
+                    discardChangesPopup(
+                      context,
+                      previousObject: widget.billSplitterTransaction,
+                      currentObject: "await createBudget()",
+                    );
+                  } else {
+                    discardChangesPopup(context);
+                  }
+                },
+                listWidgets: [
+                  Container(height: 20),
+                  Padding(
+                    padding: const EdgeInsets.symmetric(horizontal: 20),
+                    child: kIsWeb
+                        ? TextInput(
+                            labelText: "Name",
+                            bubbly: false,
+                            initialValue: selectedTitle,
+                            onChanged: (text) {
+                              setSelectedTitle(text);
+                            },
+                            padding: EdgeInsets.only(left: 7, right: 7),
+                            fontSize: 30,
+                            fontWeight: FontWeight.bold,
+                            topContentPadding: 20,
+                          )
+                        : TappableTextEntry(
+                            title: selectedTitle,
+                            placeholder: "Name",
+                            onTap: () {
+                              selectTitle();
+                            },
+                            autoSizeText: true,
+                            padding: EdgeInsets.symmetric(
+                                vertical: 10, horizontal: 10),
+                          ),
+                  ),
+                  TappableTextEntry(
+                    title: convertToMoney(selectedAmount ?? 0),
+                    placeholder: convertToMoney(0),
+                    showPlaceHolderWhenTextEquals: convertToMoney(0),
+                    onTap: () {
+                      selectAmount(context);
+                    },
+                    fontSize: 35,
+                    fontWeight: FontWeight.bold,
+                    internalPadding:
+                        EdgeInsets.symmetric(vertical: 2, horizontal: 4),
+                    padding: EdgeInsets.symmetric(vertical: 10, horizontal: 3),
+                  ),
+                  Align(
+                    alignment: Alignment.bottomCenter,
+                    child: canAddBudget ?? false
+                        ? Button(
+                            label: widget.billSplitterTransaction == null
+                                ? "Add Budget"
+                                : "Save Changes",
+                            width: MediaQuery.of(context).size.width,
+                            height: 50,
+                            onTap: () {
+                              // addBudget();
+                            },
+                            hasBottomExtraSafeArea: true,
+                          )
+                        : Button(
+                            label: widget.billSplitterTransaction == null
+                                ? "Add Transaction"
+                                : "Save Changes",
+                            width: MediaQuery.of(context).size.width,
+                            height: 50,
+                            onTap: () {},
+                            color: Colors.grey,
+                            hasBottomExtraSafeArea: true,
+                          ),
+                  ),
+                ],
+              ),
+            ],
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class TappableTextEntry extends StatelessWidget {
+  const TappableTextEntry({
+    Key? key,
+    required this.title,
+    required this.placeholder,
+    required this.onTap,
+    this.fontSize,
+    this.fontWeight,
+    this.padding = const EdgeInsets.symmetric(vertical: 0),
+    this.internalPadding =
+        const EdgeInsets.symmetric(vertical: 6, horizontal: 12),
+    this.autoSizeText = false,
+    this.showPlaceHolderWhenTextEquals,
+  }) : super(key: key);
+
+  final String? title;
+  final String placeholder;
+  final VoidCallback onTap;
+  final EdgeInsets padding;
+  final EdgeInsets internalPadding;
+  final double? fontSize;
+  final FontWeight? fontWeight;
+  final bool autoSizeText;
+  final String? showPlaceHolderWhenTextEquals;
+
+  @override
+  Widget build(BuildContext context) {
+    return Tappable(
+      onTap: onTap,
+      color: Colors.transparent,
+      borderRadius: 15,
+      child: Padding(
+        padding: padding,
+        child: Container(
+          padding: internalPadding,
+          decoration: BoxDecoration(
+            border: Border(
+                bottom: BorderSide(
+                    width: 1.5,
+                    color: Theme.of(context).colorScheme.lightDarkAccentHeavy)),
+          ),
+          child: IntrinsicWidth(
+            child: Align(
+              alignment: Alignment.centerLeft,
+              child: TextFont(
+                autoSizeText: autoSizeText,
+                maxLines: 1,
+                minFontSize: 16,
+                textAlign: TextAlign.left,
+                fontSize: fontSize ?? 35,
+                fontWeight: fontWeight ?? FontWeight.bold,
+                text: title == null ||
+                        title == "" ||
+                        title == showPlaceHolderWhenTextEquals
+                    ? placeholder
+                    : title ?? "",
+                textColor: title == null ||
+                        title == "" ||
+                        title == showPlaceHolderWhenTextEquals
+                    ? Theme.of(context).colorScheme.textLight
+                    : Theme.of(context).colorScheme.black,
+              ),
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
diff --git a/budget/lib/pages/billSplitterPage.dart b/budget/lib/pages/billSplitterPage.dart
new file mode 100644
index 000000000..85954231a
--- /dev/null
+++ b/budget/lib/pages/billSplitterPage.dart
@@ -0,0 +1,139 @@
+import 'dart:convert';
+import 'dart:developer';
+import 'dart:io';
+import 'package:budget/colors.dart';
+import 'package:budget/database/binary_string_conversion.dart';
+import 'package:budget/database/tables.dart';
+import 'package:budget/pages/addBillSplitterTransactionPage.dart';
+import 'package:budget/pages/addBudgetPage.dart';
+import 'package:budget/pages/addTransactionPage.dart';
+import 'package:budget/pages/editBudgetPage.dart';
+import 'package:budget/pages/editCategoriesPage.dart';
+import 'package:budget/pages/editWalletsPage.dart';
+import 'package:budget/struct/databaseGlobal.dart';
+import 'package:budget/widgets/accountAndBackup.dart';
+import 'package:budget/widgets/button.dart';
+import 'package:budget/widgets/editRowEntry.dart';
+import 'package:budget/widgets/fab.dart';
+import 'package:budget/widgets/fadeIn.dart';
+import 'package:budget/widgets/globalSnackBar.dart';
+import 'package:budget/widgets/openBottomSheet.dart';
+import 'package:budget/widgets/openPopup.dart';
+import 'package:budget/widgets/openSnackbar.dart';
+import 'package:budget/widgets/pageFramework.dart';
+import 'package:budget/widgets/popupFramework.dart';
+import 'package:budget/widgets/selectCategoryImage.dart';
+import 'package:budget/widgets/selectColor.dart';
+import 'package:budget/widgets/settingsContainers.dart';
+import 'package:budget/widgets/tappable.dart';
+import 'package:budget/widgets/textWidgets.dart';
+import 'package:budget/widgets/transactionEntry.dart';
+import 'package:drift/drift.dart' hide Column;
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/foundation.dart';
+import 'package:flutter/material.dart';
+import 'package:budget/main.dart';
+import 'package:flutter/services.dart';
+import 'package:intl/intl.dart';
+import 'package:math_expressions/math_expressions.dart';
+import 'package:path_provider/path_provider.dart';
+import 'package:path/path.dart' as p;
+import 'package:share_plus/share_plus.dart';
+import 'package:googleapis/drive/v3.dart' as drive;
+import 'package:google_sign_in/google_sign_in.dart' as signIn;
+import 'package:http/http.dart' as http;
+import 'package:universal_html/html.dart' as html;
+import 'dart:math' as math;
+import 'package:file_picker/file_picker.dart';
+import '../functions.dart';
+
+class BillSplitterPage extends StatefulWidget {
+  const BillSplitterPage({required this.billSplitter, Key? key})
+      : super(key: key);
+
+  final BillSplitter billSplitter;
+
+  @override
+  State<BillSplitterPage> createState() => _BillSplitterPageState();
+}
+
+class _BillSplitterPageState extends State<BillSplitterPage> {
+  @override
+  Widget build(BuildContext context) {
+    return PageFramework(
+      floatingActionButton: AnimatedScaleDelayed(
+        child: Padding(
+          padding: EdgeInsets.only(bottom: bottomPaddingSafeArea),
+          child: FAB(
+            tooltip: "Add Entry",
+            openPage: AddBillSplitterTransaction(
+              title: "Add Entry",
+            ),
+          ),
+        ),
+      ),
+      dragDownToDismiss: true,
+      title: widget.billSplitter.name,
+      navbar: false,
+      appBarBackgroundColor: Theme.of(context).colorScheme.secondaryContainer,
+      appBarBackgroundColorStart: Theme.of(context).canvasColor,
+      slivers: [
+        StreamBuilder<List<BillSplitterTransaction>>(
+          stream: database.watchAllBillSplitterTransactions(
+              widget.billSplitter.billSplitterPk),
+          builder: (context, snapshot) {
+            if (snapshot.hasData) {
+              if (snapshot.data!.length <= 0) {
+                return SliverToBoxAdapter(
+                  child: Center(
+                    child: Padding(
+                      padding:
+                          const EdgeInsets.only(top: 85, right: 15, left: 15),
+                      child: TextFont(
+                          fontSize: 22,
+                          fontWeight: FontWeight.bold,
+                          text: "No bills."),
+                    ),
+                  ),
+                );
+              }
+              return SliverList(
+                delegate: SliverChildBuilderDelegate(
+                  (BuildContext context, int index) {
+                    BillSplitterTransaction billSplitterTransaction =
+                        snapshot.data![index];
+                    return Tappable(
+                      color: Theme.of(context).colorScheme.lightDarkAccent,
+                      child: Column(
+                        crossAxisAlignment: CrossAxisAlignment.start,
+                        children: [],
+                      ),
+                    );
+                  },
+                  childCount: snapshot.data?.length,
+                ),
+              );
+            } else {
+              return SliverToBoxAdapter(
+                child: Center(
+                  child: Padding(
+                    padding:
+                        const EdgeInsets.only(top: 85, right: 15, left: 15),
+                    child: TextFont(
+                        fontSize: 22,
+                        fontWeight: FontWeight.bold,
+                        text: "No bills."),
+                  ),
+                ),
+              );
+            }
+          },
+        ),
+        // Wipe all remaining pixels off - sometimes graphics artifacts are left behind
+        SliverToBoxAdapter(
+          child: Container(height: 70, color: Theme.of(context).canvasColor),
+        ),
+      ],
+    );
+  }
+}
diff --git a/budget/lib/pages/editBillSplitterPage.dart b/budget/lib/pages/editBillSplitterPage.dart
new file mode 100644
index 000000000..a88c01847
--- /dev/null
+++ b/budget/lib/pages/editBillSplitterPage.dart
@@ -0,0 +1,240 @@
+import 'dart:convert';
+import 'dart:developer';
+import 'dart:io';
+import 'package:budget/colors.dart';
+import 'package:budget/database/binary_string_conversion.dart';
+import 'package:budget/database/tables.dart';
+import 'package:budget/pages/addBudgetPage.dart';
+import 'package:budget/pages/addTransactionPage.dart';
+import 'package:budget/pages/billSplitterPage.dart';
+import 'package:budget/pages/editBudgetPage.dart';
+import 'package:budget/pages/editCategoriesPage.dart';
+import 'package:budget/pages/editWalletsPage.dart';
+import 'package:budget/struct/databaseGlobal.dart';
+import 'package:budget/widgets/accountAndBackup.dart';
+import 'package:budget/widgets/button.dart';
+import 'package:budget/widgets/editRowEntry.dart';
+import 'package:budget/widgets/fab.dart';
+import 'package:budget/widgets/fadeIn.dart';
+import 'package:budget/widgets/globalSnackBar.dart';
+import 'package:budget/widgets/openBottomSheet.dart';
+import 'package:budget/widgets/openPopup.dart';
+import 'package:budget/widgets/openSnackbar.dart';
+import 'package:budget/widgets/pageFramework.dart';
+import 'package:budget/widgets/popupFramework.dart';
+import 'package:budget/widgets/selectCategoryImage.dart';
+import 'package:budget/widgets/selectColor.dart';
+import 'package:budget/widgets/settingsContainers.dart';
+import 'package:budget/widgets/textWidgets.dart';
+import 'package:budget/widgets/transactionEntry.dart';
+import 'package:drift/drift.dart' hide Column;
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/foundation.dart';
+import 'package:flutter/material.dart';
+import 'package:budget/main.dart';
+import 'package:flutter/services.dart';
+import 'package:intl/intl.dart';
+import 'package:math_expressions/math_expressions.dart';
+import 'package:path_provider/path_provider.dart';
+import 'package:path/path.dart' as p;
+import 'package:share_plus/share_plus.dart';
+import 'package:googleapis/drive/v3.dart' as drive;
+import 'package:google_sign_in/google_sign_in.dart' as signIn;
+import 'package:http/http.dart' as http;
+import 'package:universal_html/html.dart' as html;
+import 'dart:math' as math;
+import 'package:file_picker/file_picker.dart';
+import '../functions.dart';
+
+class EditBillSplitterPage extends StatefulWidget {
+  const EditBillSplitterPage({Key? key}) : super(key: key);
+
+  @override
+  State<EditBillSplitterPage> createState() => _EditBillSplitterPageState();
+}
+
+class _EditBillSplitterPageState extends State<EditBillSplitterPage> {
+  bool dragDownToDismissEnabled = true;
+  int currentReorder = -1;
+
+  @override
+  Widget build(BuildContext context) {
+    return PageFramework(
+      dragDownToDismissEnabled: dragDownToDismissEnabled,
+      floatingActionButton: AnimatedScaleDelayed(
+        child: Padding(
+          padding: EdgeInsets.only(bottom: bottomPaddingSafeArea),
+          child: FAB(
+            tooltip: "Add Bill",
+            openPage: SizedBox.shrink(),
+            onTap: () {
+              openBottomSheet(
+                context,
+                PopupFramework(
+                  title: "Enter Title",
+                  child: SelectText(
+                    setSelectedText: (_) {},
+                    labelText: "Title",
+                    selectedText: "",
+                    nextWithInput: (input) async {
+                      int length = await database.getAmountOfBillSplitters();
+                      await database.createOrUpdateBillSplitter(
+                        BillSplitter(
+                          billSplitterPk: DateTime.now().millisecondsSinceEpoch,
+                          name: input.trim(),
+                          dateCreated: DateTime.now(),
+                          order: length,
+                        ),
+                      );
+                    },
+                  ),
+                ),
+                snap: false,
+              );
+            },
+          ),
+        ),
+      ),
+      dragDownToDismiss: true,
+      title: "Bill Splitter",
+      navbar: false,
+      appBarBackgroundColor: Theme.of(context).colorScheme.secondaryContainer,
+      appBarBackgroundColorStart: Theme.of(context).canvasColor,
+      slivers: [
+        StreamBuilder<List<BillSplitter>>(
+          stream: database.watchAllBillSplitters(),
+          builder: (context, snapshot) {
+            if (snapshot.hasData) {
+              if (snapshot.data!.length <= 0) {
+                return SliverToBoxAdapter(
+                  child: Center(
+                    child: Padding(
+                      padding:
+                          const EdgeInsets.only(top: 85, right: 15, left: 15),
+                      child: TextFont(
+                          fontSize: 22,
+                          fontWeight: FontWeight.bold,
+                          text: "No bills."),
+                    ),
+                  ),
+                );
+              }
+              return SliverReorderableList(
+                onReorderStart: (index) {
+                  HapticFeedback.heavyImpact();
+                  setState(() {
+                    dragDownToDismissEnabled = false;
+                    currentReorder = index;
+                  });
+                },
+                onReorderEnd: (_) {
+                  setState(() {
+                    dragDownToDismissEnabled = true;
+                    currentReorder = -1;
+                  });
+                },
+                itemBuilder: (context, index) {
+                  BillSplitter billSplitter = snapshot.data![index];
+                  return EditRowEntry(
+                    canReorder: (snapshot.data ?? []).length != 1,
+                    padding: EdgeInsets.symmetric(vertical: 7, horizontal: 7),
+                    currentReorder:
+                        currentReorder != -1 && currentReorder != index,
+                    index: index,
+                    backgroundColor:
+                        Theme.of(context).colorScheme.lightDarkAccent,
+                    content: Padding(
+                      padding: const EdgeInsets.symmetric(
+                          horizontal: 20, vertical: 8),
+                      child: Column(
+                        crossAxisAlignment: CrossAxisAlignment.start,
+                        children: [
+                          TextFont(
+                            text: billSplitter.name +
+                                " - " +
+                                billSplitter.order.toString(),
+                            fontWeight: FontWeight.bold,
+                            fontSize: 21,
+                            maxLines: 10,
+                          ),
+                          TextFont(
+                            text: getWordedDateShortMore(
+                                billSplitter.dateCreated),
+                            fontSize: 15,
+                            maxLines: 10,
+                            textColor: Theme.of(context).colorScheme.textLight,
+                          ),
+                        ],
+                      ),
+                    ),
+                    onDelete: () {
+                      openPopup(
+                        context,
+                        title: "Delete " + billSplitter.name + "?",
+                        icon: Icons.delete_rounded,
+                        onCancel: () {
+                          Navigator.pop(context);
+                        },
+                        onCancelLabel: "Cancel",
+                        onSubmit: () async {
+                          await database.deleteBillSplitter(
+                              billSplitter.billSplitterPk,
+                              billSplitter.billSplitterPk);
+                          Navigator.pop(context);
+                          openSnackbar(
+                            SnackbarMessage(
+                                title: "Deleted " + billSplitter.name,
+                                icon: Icons.delete),
+                          );
+                        },
+                        onSubmitLabel: "Delete",
+                      );
+                    },
+                    openPage: BillSplitterPage(billSplitter: billSplitter),
+                    key: ValueKey(index),
+                  );
+                },
+                itemCount: snapshot.data!.length,
+                onReorder: (_intPrevious, _intNew) async {
+                  BillSplitter oldBillSplitter = snapshot.data![_intPrevious];
+
+                  _intNew = snapshot.data!.length - _intNew;
+                  _intPrevious = snapshot.data!.length - _intPrevious;
+
+                  if (_intNew > _intPrevious) {
+                    await database.moveBillSplitter(
+                        oldBillSplitter.billSplitterPk,
+                        _intNew - 1,
+                        oldBillSplitter.order);
+                  } else {
+                    await database.moveBillSplitter(
+                        oldBillSplitter.billSplitterPk,
+                        _intNew,
+                        oldBillSplitter.order);
+                  }
+                },
+              );
+            } else {
+              return SliverToBoxAdapter(
+                child: Center(
+                  child: Padding(
+                    padding:
+                        const EdgeInsets.only(top: 85, right: 15, left: 15),
+                    child: TextFont(
+                        fontSize: 22,
+                        fontWeight: FontWeight.bold,
+                        text: "No bills."),
+                  ),
+                ),
+              );
+            }
+          },
+        ),
+        // Wipe all remaining pixels off - sometimes graphics artifacts are left behind
+        SliverToBoxAdapter(
+          child: Container(height: 70, color: Theme.of(context).canvasColor),
+        ),
+      ],
+    );
+  }
+}
diff --git a/budget/lib/pages/settingsPage.dart b/budget/lib/pages/settingsPage.dart
index 1f66dad18..0f6c04666 100644
--- a/budget/lib/pages/settingsPage.dart
+++ b/budget/lib/pages/settingsPage.dart
@@ -6,7 +6,9 @@ import 'package:budget/database/binary_string_conversion.dart';
 import 'package:budget/database/tables.dart';
 import 'package:budget/pages/aboutPage.dart';
 import 'package:budget/pages/autoTransactionsPageEmail.dart';
+import 'package:budget/pages/billSplitterPage.dart';
 import 'package:budget/pages/editAssociatedTitlesPage.dart';
+import 'package:budget/pages/editBillSplitterPage.dart';
 import 'package:budget/pages/editBudgetPage.dart';
 import 'package:budget/pages/editCategoriesPage.dart';
 import 'package:budget/pages/editWalletsPage.dart';
@@ -78,7 +80,7 @@ class SettingsPageState extends State<SettingsPage>
   Widget build(BuildContext context) {
     return PageFramework(
       key: pageState,
-      title: "Settings",
+      title: "More",
       backButton: false,
       navbar: true,
       appBarBackgroundColor: Theme.of(context).colorScheme.secondaryContainer,
@@ -89,18 +91,23 @@ class SettingsPageState extends State<SettingsPage>
           title: "About Budget App",
           icon: Icons.info_outline_rounded,
         ),
-        SettingsHeader(title: "Data"),
+        SettingsHeader(title: "Tools"),
         // SettingsContainerOpenPage(
         //   openPage: ColorsPage(),
         //   title: "Colors",
         //   icon: Icons.color_lens,
         // ),
+        SettingsContainerOpenPage(
+          openPage: EditBillSplitterPage(),
+          title: "Bill Splitter",
+          icon: Icons.vertical_split_rounded,
+        ),
         SettingsContainerOpenPage(
           openPage: SubscriptionsPage(),
           title: "Subscriptions",
           icon: Icons.event_repeat_rounded,
         ),
-
+        SettingsHeader(title: "Data"),
         SettingsContainerOpenPage(
           openPage: EditWalletsPage(title: "Edit Wallets"),
           title: "Edit Wallets",
@@ -267,33 +274,36 @@ class SettingsPageState extends State<SettingsPage>
           initialValue: appStateSettings["batterySaver"],
           icon: Icons.battery_charging_full_rounded,
         ),
-        kIsWeb ? SizedBox.shrink() : SettingsContainerSwitch(
-          title: "Notifications",
-          description: "Send add transaction reminders",
-          onSwitched: (value) async {
-            updateSettings("notifications", value, updateGlobalState: false);
+        kIsWeb
+            ? SizedBox.shrink()
+            : SettingsContainerSwitch(
+                title: "Notifications",
+                description: "Send add transaction reminders",
+                onSwitched: (value) async {
+                  updateSettings("notifications", value,
+                      updateGlobalState: false);
 
-            AndroidNotificationDetails androidNotificationDetails =
-                AndroidNotificationDetails(
-              'transactionReminders',
-              'Transaction Reminders',
-              importance: Importance.max,
-              priority: Priority.high,
-              color: Theme.of(context).colorScheme.primary,
-            );
-            NotificationDetails notificationDetails =
-                NotificationDetails(android: androidNotificationDetails);
-            await flutterLocalNotificationsPlugin.show(
-              0,
-              'Add Transactions',
-              'Don\'t forget to add transactions from today!',
-              notificationDetails,
-              payload: 'addTransaction',
-            );
-          },
-          initialValue: appStateSettings["notifications"],
-          icon: Icons.notifications_rounded,
-        ),
+                  AndroidNotificationDetails androidNotificationDetails =
+                      AndroidNotificationDetails(
+                    'transactionReminders',
+                    'Transaction Reminders',
+                    importance: Importance.max,
+                    priority: Priority.high,
+                    color: Theme.of(context).colorScheme.primary,
+                  );
+                  NotificationDetails notificationDetails =
+                      NotificationDetails(android: androidNotificationDetails);
+                  await flutterLocalNotificationsPlugin.show(
+                    0,
+                    'Add Transactions',
+                    'Don\'t forget to add transactions from today!',
+                    notificationDetails,
+                    payload: 'addTransaction',
+                  );
+                },
+                initialValue: appStateSettings["notifications"],
+                icon: Icons.notifications_rounded,
+              ),
         SettingsHeader(title: "Automations"),
         // SettingsContainerOpenPage(
         //   openPage: AutoTransactionsPage(),
diff --git a/budget/lib/widgets/bottomNavBar.dart b/budget/lib/widgets/bottomNavBar.dart
index 922cec20b..3b8d9a3ce 100644
--- a/budget/lib/widgets/bottomNavBar.dart
+++ b/budget/lib/widgets/bottomNavBar.dart
@@ -98,8 +98,8 @@ class BottomNavBarState extends State<BottomNavBar> {
                       label: "Budgets",
                     ),
                     NavigationDestination(
-                      icon: Icon(Icons.settings_rounded),
-                      label: "Settings",
+                      icon: Icon(Icons.more_horiz_rounded),
+                      label: "More",
                     ),
                   ],
                   selectedIndex: selectedIndex,
