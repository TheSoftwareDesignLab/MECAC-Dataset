diff --git a/frontend/appflowy_flutter/integration_test/desktop/document/document_test_runner_4.dart b/frontend/appflowy_flutter/integration_test/desktop/document/document_test_runner_4.dart
index b98c1aad626c0..a05545753e4bf 100644
--- a/frontend/appflowy_flutter/integration_test/desktop/document/document_test_runner_4.dart
+++ b/frontend/appflowy_flutter/integration_test/desktop/document/document_test_runner_4.dart
@@ -11,6 +11,8 @@ import 'document_with_file_test.dart' as document_with_file_test;
 import 'document_with_image_block_test.dart' as document_with_image_block_test;
 import 'document_with_multi_image_block_test.dart'
     as document_with_multi_image_block_test;
+import 'document_with_simple_table_test.dart'
+    as document_with_simple_table_test;
 
 void main() {
   IntegrationTestWidgetsFlutterBinding.ensureInitialized();
@@ -25,4 +27,5 @@ void main() {
   document_block_option_test.main();
   document_find_menu_test.main();
   document_toolbar_test.main();
+  document_with_simple_table_test.main();
 }
diff --git a/frontend/appflowy_flutter/integration_test/desktop/document/document_with_simple_table_test.dart b/frontend/appflowy_flutter/integration_test/desktop/document/document_with_simple_table_test.dart
new file mode 100644
index 0000000000000..f9db73d7ef028
--- /dev/null
+++ b/frontend/appflowy_flutter/integration_test/desktop/document/document_with_simple_table_test.dart
@@ -0,0 +1,42 @@
+import 'package:appflowy/generated/locale_keys.g.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:easy_localization/easy_localization.dart';
+import 'package:flutter_test/flutter_test.dart';
+import 'package:integration_test/integration_test.dart';
+
+import '../../shared/util.dart';
+
+const String heading1 = "Heading 1";
+const String heading2 = "Heading 2";
+const String heading3 = "Heading 3";
+
+void main() {
+  IntegrationTestWidgetsFlutterBinding.ensureInitialized();
+
+  group('simple table block test:', () {
+    testWidgets('insert a simple table block', (tester) async {
+      await tester.initializeAppFlowy();
+      await tester.tapAnonymousSignInButton();
+
+      await tester.createNewPageWithNameUnderParent(
+        name: 'simple_table_test',
+      );
+
+      await tester.editor.tapLineOfEditorAt(0);
+      await insertTableInDocument(tester);
+
+      // validate the table is inserted
+      expect(find.byType(SimpleTableBlockWidget), findsOneWidget);
+    });
+  });
+}
+
+/// Insert a table in the document
+Future<void> insertTableInDocument(WidgetTester tester) async {
+  // open the actions menu and insert the outline block
+  await tester.editor.showSlashMenu();
+  await tester.editor.tapSlashMenuItemWithName(
+    LocaleKeys.document_slashMenu_name_table.tr(),
+  );
+  await tester.pumpAndSettle();
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/application/document_data_pb_extension.dart b/frontend/appflowy_flutter/lib/plugins/document/application/document_data_pb_extension.dart
index 91faccf484dc2..f9a80864f1497 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/application/document_data_pb_extension.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/application/document_data_pb_extension.dart
@@ -204,6 +204,19 @@ extension NodeToBlock on Node {
   }
 
   String _dataAdapter(String type, Attributes attributes) {
-    return jsonEncode(attributes);
+    try {
+      return jsonEncode(
+        attributes,
+        toEncodable: (value) {
+          if (value is Map) {
+            return jsonEncode(value);
+          }
+          return value;
+        },
+      );
+    } catch (e) {
+      Log.error('encode attributes error: $e');
+      return '{}';
+    }
   }
 }
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_configuration.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_configuration.dart
index e164afa635866..f15159ea634d7 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_configuration.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_configuration.dart
@@ -5,6 +5,10 @@ import 'package:appflowy/plugins/document/presentation/editor_page.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/actions/mobile_block_action_buttons.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/code_block/code_block_copy_button.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/plugins.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
 import 'package:appflowy/plugins/document/presentation/editor_style.dart';
 import 'package:appflowy_editor/appflowy_editor.dart';
 import 'package:appflowy_editor_plugins/appflowy_editor_plugins.dart';
@@ -125,8 +129,9 @@ void _customBlockOptionActions(
     final actions = _buildOptionActions(context, entry.key);
 
     if (UniversalPlatform.isDesktop) {
-      builder.showActions =
-          (node) => node.parent?.type != TableCellBlockKeys.type;
+      builder.showActions = (node) =>
+          node.parent?.type != TableCellBlockKeys.type &&
+          node.parent?.type != SimpleTableCellBlockKeys.type;
       builder.configuration = builder.configuration.copyWith(
         blockSelectionAreaMargin: (_) => const EdgeInsets.symmetric(
           vertical: 1,
@@ -286,6 +291,18 @@ Map<String, BlockComponentBuilder> _buildBlockComponentBuilderMap(
     errorBlockComponentBuilderKey: ErrorBlockComponentBuilder(
       configuration: configuration,
     ),
+    SimpleTableBlockKeys.type: _buildSimpleTableBlockComponentBuilder(
+      context,
+      configuration,
+    ),
+    SimpleTableRowBlockKeys.type: _buildSimpleTableRowBlockComponentBuilder(
+      context,
+      configuration,
+    ),
+    SimpleTableCellBlockKeys.type: _buildSimpleTableCellBlockComponentBuilder(
+      context,
+      configuration,
+    ),
   };
 
   final builders = {
@@ -296,6 +313,27 @@ Map<String, BlockComponentBuilder> _buildBlockComponentBuilderMap(
   return builders;
 }
 
+SimpleTableBlockComponentBuilder _buildSimpleTableBlockComponentBuilder(
+  BuildContext context,
+  BlockComponentConfiguration configuration,
+) {
+  return SimpleTableBlockComponentBuilder(configuration: configuration);
+}
+
+SimpleTableRowBlockComponentBuilder _buildSimpleTableRowBlockComponentBuilder(
+  BuildContext context,
+  BlockComponentConfiguration configuration,
+) {
+  return SimpleTableRowBlockComponentBuilder(configuration: configuration);
+}
+
+SimpleTableCellBlockComponentBuilder _buildSimpleTableCellBlockComponentBuilder(
+  BuildContext context,
+  BlockComponentConfiguration configuration,
+) {
+  return SimpleTableCellBlockComponentBuilder(configuration: configuration);
+}
+
 ParagraphBlockComponentBuilder _buildParagraphBlockComponentBuilder(
   BuildContext context,
   BlockComponentConfiguration configuration,
@@ -303,7 +341,17 @@ ParagraphBlockComponentBuilder _buildParagraphBlockComponentBuilder(
   String Function(Node)? placeholderText,
 ) {
   return ParagraphBlockComponentBuilder(
-    configuration: configuration.copyWith(placeholderText: placeholderText),
+    configuration: configuration.copyWith(
+      placeholderText: placeholderText,
+      textStyle: (node) {
+        if (node.isInHeaderColumn || node.isInHeaderRow) {
+          return configuration.textStyle(node).copyWith(
+                fontWeight: FontWeight.bold,
+              );
+        }
+        return configuration.textStyle(node);
+      },
+    ),
     showPlaceholder: showParagraphPlaceholder,
   );
 }
@@ -315,6 +363,14 @@ TodoListBlockComponentBuilder _buildTodoListBlockComponentBuilder(
   return TodoListBlockComponentBuilder(
     configuration: configuration.copyWith(
       placeholderText: (_) => LocaleKeys.blockPlaceholders_todoList.tr(),
+      textStyle: (node) {
+        if (node.isInHeaderColumn || node.isInHeaderRow) {
+          return configuration.textStyle(node).copyWith(
+                fontWeight: FontWeight.bold,
+              );
+        }
+        return configuration.textStyle(node);
+      },
     ),
     iconBuilder: (_, node, onCheck) => TodoListIcon(
       node: node,
@@ -335,6 +391,14 @@ BulletedListBlockComponentBuilder _buildBulletedListBlockComponentBuilder(
   return BulletedListBlockComponentBuilder(
     configuration: configuration.copyWith(
       placeholderText: (_) => LocaleKeys.blockPlaceholders_bulletList.tr(),
+      textStyle: (node) {
+        if (node.isInHeaderColumn || node.isInHeaderRow) {
+          return configuration.textStyle(node).copyWith(
+                fontWeight: FontWeight.bold,
+              );
+        }
+        return configuration.textStyle(node);
+      },
     ),
     iconBuilder: (_, node) => BulletedListIcon(node: node),
   );
@@ -347,6 +411,14 @@ NumberedListBlockComponentBuilder _buildNumberedListBlockComponentBuilder(
   return NumberedListBlockComponentBuilder(
     configuration: configuration.copyWith(
       placeholderText: (_) => LocaleKeys.blockPlaceholders_numberList.tr(),
+      textStyle: (node) {
+        if (node.isInHeaderColumn || node.isInHeaderRow) {
+          return configuration.textStyle(node).copyWith(
+                fontWeight: FontWeight.bold,
+              );
+        }
+        return configuration.textStyle(node);
+      },
     ),
     iconBuilder: (_, node, textDirection) => NumberedListIcon(
       node: node,
@@ -362,6 +434,14 @@ QuoteBlockComponentBuilder _buildQuoteBlockComponentBuilder(
   return QuoteBlockComponentBuilder(
     configuration: configuration.copyWith(
       placeholderText: (_) => LocaleKeys.blockPlaceholders_quote.tr(),
+      textStyle: (node) {
+        if (node.isInHeaderColumn || node.isInHeaderRow) {
+          return configuration.textStyle(node).copyWith(
+                fontWeight: FontWeight.bold,
+              );
+        }
+        return configuration.textStyle(node);
+      },
     ),
   );
 }
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/actions/drag_to_reorder/visual_drag_area.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/actions/drag_to_reorder/visual_drag_area.dart
index c8889cd2e17d9..ede11b8b9e299 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/actions/drag_to_reorder/visual_drag_area.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/actions/drag_to_reorder/visual_drag_area.dart
@@ -1,3 +1,5 @@
+import 'dart:math';
+
 import 'package:appflowy_editor/appflowy_editor.dart';
 import 'package:flutter/material.dart';
 
@@ -46,7 +48,7 @@ class VisualDragArea extends StatelessWidget {
 
     Widget child = Container(
       height: 2,
-      width: width,
+      width: max(width, 0.0),
       color: Theme.of(context).colorScheme.primary,
     );
 
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/file/file_block_component.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/file/file_block_component.dart
index f0af6e77eab84..e4dd1d4e4a4c0 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/file/file_block_component.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/file/file_block_component.dart
@@ -346,6 +346,7 @@ class FileBlockComponentState extends State<FileBlockComponent>
       controller.show();
       dropManagerState?.add(FileBlockKeys.type);
     } else {
+      editorState.updateSelectionWithReason(null, extraInfo: {});
       showUploadFileMobileMenu();
     }
   }
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/keyboard_interceptor/keyboard_interceptor.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/keyboard_interceptor/keyboard_interceptor.dart
index 3b170bf76f5b1..047eed37cf181 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/keyboard_interceptor/keyboard_interceptor.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/keyboard_interceptor/keyboard_interceptor.dart
@@ -1,3 +1,4 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
 import 'package:appflowy_editor/appflowy_editor.dart';
 import 'package:appflowy_editor_plugins/appflowy_editor_plugins.dart';
 import 'package:flutter/services.dart';
@@ -15,6 +16,34 @@ class EditorKeyboardInterceptor extends AppFlowyKeyboardServiceInterceptor {
     );
   }
 
+  @override
+  Future<bool> interceptDelete(
+    TextEditingDeltaDeletion deletion,
+    EditorState editorState,
+  ) async {
+    // check if the current selection is in a code block
+    final (isInTableCell, selection, tableCellNode, node) =
+        editorState.isCurrentSelectionInTableCell();
+    if (!isInTableCell ||
+        selection == null ||
+        tableCellNode == null ||
+        node == null) {
+      return false;
+    }
+
+    final onlyContainsOneChild = tableCellNode.children.length == 1;
+    final isParagraphNode =
+        tableCellNode.children.first.type == ParagraphBlockKeys.type;
+    if (onlyContainsOneChild &&
+        selection.isCollapsed &&
+        selection.end.offset == 0 &&
+        isParagraphNode) {
+      return true;
+    }
+
+    return false;
+  }
+
   /// Check if the backtick pressed event should be handled
   Future<bool> _checkIfBacktickPressed(
     EditorState editorState,
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/shortcuts/command_shortcuts.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/shortcuts/command_shortcuts.dart
index 46ded666ff3f1..b25ac1a880022 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/shortcuts/command_shortcuts.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/shortcuts/command_shortcuts.dart
@@ -1,6 +1,7 @@
 import 'package:appflowy/generated/locale_keys.g.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/align_toolbar_item/custom_text_align_command.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/plugins.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_commands.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/undo_redo/custom_undo_redo_commands.dart';
 import 'package:appflowy/workspace/presentation/settings/widgets/emoji_picker/emoji_picker.dart';
 import 'package:appflowy_editor/appflowy_editor.dart';
@@ -15,6 +16,8 @@ final List<CommandShortcutEvent> defaultCommandShortcutEvents = [
 
 // Command shortcuts are order-sensitive. Verify order when modifying.
 List<CommandShortcutEvent> commandShortcutEvents = [
+  ...simpleTableCommands,
+
   customExitEditingCommand,
   backspaceToTitle,
   removeToggleHeadingStyle,
@@ -45,6 +48,7 @@ List<CommandShortcutEvent> commandShortcutEvents = [
         undoCommand,
         redoCommand,
         exitEditingCommand,
+        // ...tableCommands,
       ].contains(shortcut),
     ),
 
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/slash_menu/slash_menu_items.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/slash_menu/slash_menu_items.dart
index 3d022b0de628d..f1bd344e89f3f 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/slash_menu/slash_menu_items.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/slash_menu/slash_menu_items.dart
@@ -8,6 +8,9 @@ import 'package:appflowy/plugins/document/presentation/editor_plugins/image/imag
 import 'package:appflowy/plugins/document/presentation/editor_plugins/mention/slash_menu_items.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/plugins.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/shared_context/shared_context.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart';
 import 'package:appflowy/workspace/application/view/view_service.dart';
 import 'package:appflowy/workspace/presentation/settings/widgets/emoji_picker/emoji_menu_item.dart';
 import 'package:appflowy_backend/protobuf/flowy-folder/view.pb.dart';
@@ -596,16 +599,44 @@ SelectionMenuItem tableSlashMenuItem = SelectionMenuItem(
       return;
     }
 
-    final tableNode = TableNode.fromList([
-      ['', ''],
-      ['', ''],
-    ]);
+    final tableNode = simpleTableBlockNode(
+      children: [
+        simpleTableRowBlockNode(
+          children: [
+            simpleTableCellBlockNode(
+              children: [
+                paragraphNode(),
+              ],
+            ),
+            simpleTableCellBlockNode(
+              children: [
+                paragraphNode(),
+              ],
+            ),
+          ],
+        ),
+        simpleTableRowBlockNode(
+          children: [
+            simpleTableCellBlockNode(
+              children: [
+                paragraphNode(),
+              ],
+            ),
+            simpleTableCellBlockNode(
+              children: [
+                paragraphNode(),
+              ],
+            ),
+          ],
+        ),
+      ],
+    );
 
     final transaction = editorState.transaction;
     final delta = currentNode.delta;
     if (delta != null && delta.isEmpty) {
       transaction
-        ..insertNode(selection.end.path, tableNode.node)
+        ..insertNode(selection.end.path, tableNode)
         ..deleteNode(currentNode);
       transaction.afterSelection = Selection.collapsed(
         Position(
@@ -613,7 +644,7 @@ SelectionMenuItem tableSlashMenuItem = SelectionMenuItem(
         ),
       );
     } else {
-      transaction.insertNode(selection.end.path.next, tableNode.node);
+      transaction.insertNode(selection.end.path.next, tableNode);
       transaction.afterSelection = Selection.collapsed(
         Position(
           path: selection.end.path.next + [0, 0],
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shared_widget.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shared_widget.dart
new file mode 100644
index 0000000000000..c504e0280705a
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shared_widget.dart
@@ -0,0 +1,633 @@
+import 'package:appflowy/generated/flowy_svgs.g.dart';
+import 'package:appflowy/generated/locale_keys.g.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/plugins.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_more_action.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:easy_localization/easy_localization.dart';
+import 'package:flowy_infra/theme_extension.dart';
+import 'package:flowy_infra_ui/flowy_infra_ui.dart';
+import 'package:flutter/material.dart';
+import 'package:provider/provider.dart';
+
+class SimpleTableReorderButton extends StatelessWidget {
+  const SimpleTableReorderButton({
+    super.key,
+    required this.isShowingMenu,
+    required this.type,
+  });
+
+  final ValueNotifier<bool> isShowingMenu;
+  final SimpleTableMoreActionType type;
+
+  @override
+  Widget build(BuildContext context) {
+    return ValueListenableBuilder(
+      valueListenable: isShowingMenu,
+      builder: (context, isShowingMenu, child) {
+        return MouseRegion(
+          cursor: SystemMouseCursors.click,
+          child: Container(
+            decoration: BoxDecoration(
+              color: isShowingMenu
+                  ? context.simpleTableMoreActionHoverColor
+                  : Theme.of(context).colorScheme.surface,
+              borderRadius: BorderRadius.circular(8.0),
+              border: Border.all(
+                color: context.simpleTableMoreActionBorderColor,
+              ),
+            ),
+            height: 16.0,
+            width: 16.0,
+            child: FlowySvg(
+              type.reorderIconSvg,
+              color: isShowingMenu ? Colors.white : null,
+              size: const Size.square(16.0),
+            ),
+          ),
+        );
+      },
+    );
+  }
+}
+
+class SimpleTableAddRowHoverButton extends StatelessWidget {
+  const SimpleTableAddRowHoverButton({
+    super.key,
+    required this.editorState,
+    required this.node,
+  });
+
+  final EditorState editorState;
+  final Node node;
+
+  @override
+  Widget build(BuildContext context) {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return const SizedBox.shrink();
+    }
+
+    return ValueListenableBuilder(
+      valueListenable: context.read<SimpleTableContext>().hoveringTableCell,
+      builder: (context, tableCell, child) {
+        if (tableCell == null) {
+          return const SizedBox.shrink();
+        }
+        final showRowButton = tableCell.rowIndex + 1 == tableCell.rowLength;
+        return showRowButton
+            ? Positioned(
+                bottom: 0,
+                left: SimpleTableConstants.tableLeftPadding -
+                    SimpleTableConstants.cellBorderWidth,
+                right: SimpleTableConstants.addRowButtonRightPadding,
+                child: SimpleTableAddRowButton(
+                  onTap: () => editorState.addRowInTable(node),
+                ),
+              )
+            : const SizedBox.shrink();
+      },
+    );
+  }
+}
+
+class SimpleTableAddRowButton extends StatelessWidget {
+  const SimpleTableAddRowButton({
+    super.key,
+    this.onTap,
+  });
+
+  final VoidCallback? onTap;
+
+  @override
+  Widget build(BuildContext context) {
+    return FlowyTooltip(
+      message: LocaleKeys.document_plugins_simpleTable_clickToAddNewRow.tr(),
+      child: GestureDetector(
+        behavior: HitTestBehavior.translucent,
+        onTap: onTap,
+        child: MouseRegion(
+          cursor: SystemMouseCursors.click,
+          child: Container(
+            height: SimpleTableConstants.addRowButtonHeight,
+            margin: const EdgeInsets.symmetric(
+              vertical: SimpleTableConstants.addRowButtonPadding,
+            ),
+            decoration: BoxDecoration(
+              borderRadius: BorderRadius.circular(
+                SimpleTableConstants.addRowButtonRadius,
+              ),
+              color: context.simpleTableMoreActionBackgroundColor,
+            ),
+            child: const FlowySvg(
+              FlowySvgs.add_s,
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class SimpleTableAddColumnHoverButton extends StatelessWidget {
+  const SimpleTableAddColumnHoverButton({
+    super.key,
+    required this.editorState,
+    required this.node,
+  });
+
+  final EditorState editorState;
+  final Node node;
+
+  @override
+  Widget build(BuildContext context) {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return const SizedBox.shrink();
+    }
+
+    return ValueListenableBuilder(
+      valueListenable: context.read<SimpleTableContext>().hoveringTableCell,
+      builder: (context, tableCell, child) {
+        if (tableCell == null) {
+          return const SizedBox.shrink();
+        }
+        final showColumnButton =
+            tableCell.columnIndex + 1 == tableCell.columnLength;
+        return showColumnButton
+            ? Positioned(
+                top: SimpleTableConstants.tableTopPadding -
+                    SimpleTableConstants.cellBorderWidth,
+                bottom: SimpleTableConstants.addColumnButtonBottomPadding,
+                right: 0,
+                child: SimpleTableAddColumnButton(
+                  onTap: () {
+                    editorState.addColumnInTable(node);
+                  },
+                ),
+              )
+            : const SizedBox.shrink();
+      },
+    );
+  }
+}
+
+class SimpleTableAddColumnButton extends StatelessWidget {
+  const SimpleTableAddColumnButton({
+    super.key,
+    this.onTap,
+  });
+
+  final VoidCallback? onTap;
+
+  @override
+  Widget build(BuildContext context) {
+    return FlowyTooltip(
+      message: LocaleKeys.document_plugins_simpleTable_clickToAddNewColumn.tr(),
+      child: GestureDetector(
+        behavior: HitTestBehavior.translucent,
+        onTap: onTap,
+        child: MouseRegion(
+          cursor: SystemMouseCursors.click,
+          child: Container(
+            width: SimpleTableConstants.addColumnButtonWidth,
+            margin: const EdgeInsets.symmetric(
+              horizontal: SimpleTableConstants.addColumnButtonPadding,
+            ),
+            decoration: BoxDecoration(
+              borderRadius: BorderRadius.circular(
+                SimpleTableConstants.addColumnButtonRadius,
+              ),
+              color: context.simpleTableMoreActionBackgroundColor,
+            ),
+            child: const FlowySvg(
+              FlowySvgs.add_s,
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class SimpleTableAddColumnAndRowHoverButton extends StatelessWidget {
+  const SimpleTableAddColumnAndRowHoverButton({
+    super.key,
+    required this.editorState,
+    required this.node,
+  });
+
+  final EditorState editorState;
+  final Node node;
+
+  @override
+  Widget build(BuildContext context) {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return const SizedBox.shrink();
+    }
+
+    return ValueListenableBuilder(
+      valueListenable: context.read<SimpleTableContext>().hoveringTableCell,
+      builder: (context, tableCell, child) {
+        if (tableCell == null) {
+          return const SizedBox.shrink();
+        }
+        final showAddColumnAndRowButton =
+            tableCell.rowIndex + 1 == tableCell.rowLength ||
+                tableCell.columnIndex + 1 == tableCell.columnLength;
+        return showAddColumnAndRowButton
+            ? Positioned(
+                bottom: SimpleTableConstants.addRowButtonPadding,
+                right: SimpleTableConstants.addColumnButtonPadding,
+                child: SimpleTableAddColumnAndRowButton(
+                  onTap: () => editorState.addColumnAndRowInTable(node),
+                ),
+              )
+            : const SizedBox.shrink();
+      },
+    );
+  }
+}
+
+class SimpleTableAddColumnAndRowButton extends StatelessWidget {
+  const SimpleTableAddColumnAndRowButton({
+    super.key,
+    this.onTap,
+  });
+
+  final VoidCallback? onTap;
+
+  @override
+  Widget build(BuildContext context) {
+    return FlowyTooltip(
+      message: LocaleKeys.document_plugins_simpleTable_clickToAddNewRowAndColumn
+          .tr(),
+      child: GestureDetector(
+        behavior: HitTestBehavior.translucent,
+        onTap: onTap,
+        child: MouseRegion(
+          cursor: SystemMouseCursors.click,
+          child: Container(
+            width: SimpleTableConstants.addColumnAndRowButtonWidth,
+            height: SimpleTableConstants.addColumnAndRowButtonHeight,
+            decoration: BoxDecoration(
+              borderRadius: BorderRadius.circular(
+                SimpleTableConstants.addColumnAndRowButtonCornerRadius,
+              ),
+              color: context.simpleTableMoreActionBackgroundColor,
+            ),
+            child: const FlowySvg(
+              FlowySvgs.add_s,
+            ),
+          ),
+        ),
+      ),
+    );
+  }
+}
+
+class SimpleTableRowDivider extends StatelessWidget {
+  const SimpleTableRowDivider({
+    super.key,
+  });
+
+  @override
+  Widget build(BuildContext context) {
+    return VerticalDivider(
+      color: context.simpleTableBorderColor,
+      width: 1.0,
+    );
+  }
+}
+
+class SimpleTableColumnDivider extends StatelessWidget {
+  const SimpleTableColumnDivider({super.key});
+
+  @override
+  Widget build(BuildContext context) {
+    return Divider(
+      color: context.simpleTableBorderColor,
+      height: 1.0,
+    );
+  }
+}
+
+class SimpleTableAlignMenu extends StatefulWidget {
+  const SimpleTableAlignMenu({
+    super.key,
+    required this.type,
+    required this.tableCellNode,
+    this.mutex,
+  });
+
+  final SimpleTableMoreActionType type;
+  final Node tableCellNode;
+  final PopoverMutex? mutex;
+
+  @override
+  State<SimpleTableAlignMenu> createState() => _SimpleTableAlignMenuState();
+}
+
+class _SimpleTableAlignMenuState extends State<SimpleTableAlignMenu> {
+  final PopoverController controller = PopoverController();
+  bool isOpen = false;
+
+  @override
+  Widget build(BuildContext context) {
+    final align = switch (widget.type) {
+      SimpleTableMoreActionType.column => widget.tableCellNode.columnAlign,
+      SimpleTableMoreActionType.row => widget.tableCellNode.rowAlign,
+    };
+    return AppFlowyPopover(
+      controller: controller,
+      asBarrier: true,
+      mutex: widget.mutex,
+      child: SimpleTableBasicButton(
+        leftIconSvg: align.leftIconSvg,
+        text: LocaleKeys.document_plugins_simpleTable_moreActions_align.tr(),
+        onTap: () {
+          if (!isOpen) {
+            controller.show();
+          }
+        },
+      ),
+      onClose: () => isOpen = false,
+      popupBuilder: (_) {
+        isOpen = true;
+        return Column(
+          mainAxisSize: MainAxisSize.min,
+          children: [
+            _buildAlignButton(context, TableAlign.left),
+            _buildAlignButton(context, TableAlign.center),
+            _buildAlignButton(context, TableAlign.right),
+          ],
+        );
+      },
+    );
+  }
+
+  Widget _buildAlignButton(BuildContext context, TableAlign align) {
+    return SimpleTableBasicButton(
+      leftIconSvg: align.leftIconSvg,
+      text: align.name,
+      onTap: () {
+        switch (widget.type) {
+          case SimpleTableMoreActionType.column:
+            context.read<EditorState>().updateColumnAlign(
+                  tableCellNode: widget.tableCellNode,
+                  align: align,
+                );
+            break;
+          case SimpleTableMoreActionType.row:
+            context.read<EditorState>().updateRowAlign(
+                  tableCellNode: widget.tableCellNode,
+                  align: align,
+                );
+            break;
+        }
+
+        PopoverContainer.of(context).close();
+      },
+    );
+  }
+}
+
+class SimpleTableBasicButton extends StatelessWidget {
+  const SimpleTableBasicButton({
+    super.key,
+    required this.text,
+    required this.onTap,
+    this.leftIconSvg,
+    this.leftIconBuilder,
+    this.rightIcon,
+  });
+
+  final FlowySvgData? leftIconSvg;
+  final String text;
+  final VoidCallback onTap;
+  final Widget Function(bool onHover)? leftIconBuilder;
+  final Widget? rightIcon;
+
+  @override
+  Widget build(BuildContext context) {
+    return Container(
+      height: SimpleTableConstants.moreActionHeight,
+      padding: SimpleTableConstants.moreActionPadding,
+      child: FlowyIconTextButton(
+        margin: SimpleTableConstants.moreActionHorizontalMargin,
+        leftIconBuilder: _buildLeftIcon,
+        iconPadding: 10.0,
+        textBuilder: (onHover) => FlowyText.regular(
+          text,
+          fontSize: 14.0,
+          figmaLineHeight: 18.0,
+        ),
+        onTap: onTap,
+        rightIconBuilder: (onHover) => rightIcon ?? const SizedBox.shrink(),
+      ),
+    );
+  }
+
+  Widget _buildLeftIcon(bool onHover) {
+    if (leftIconBuilder != null) {
+      return leftIconBuilder!(onHover);
+    }
+    return leftIconSvg != null
+        ? FlowySvg(leftIconSvg!)
+        : const SizedBox.shrink();
+  }
+}
+
+class SimpleTableColumnResizeHandle extends StatefulWidget {
+  const SimpleTableColumnResizeHandle({
+    super.key,
+    required this.node,
+  });
+
+  final Node node;
+
+  @override
+  State<SimpleTableColumnResizeHandle> createState() =>
+      _SimpleTableColumnResizeHandleState();
+}
+
+class _SimpleTableColumnResizeHandleState
+    extends State<SimpleTableColumnResizeHandle> {
+  bool isStartDragging = false;
+
+  @override
+  Widget build(BuildContext context) {
+    return MouseRegion(
+      cursor: SystemMouseCursors.resizeColumn,
+      onEnter: (event) => context
+          .read<SimpleTableContext>()
+          .hoveringOnResizeHandle
+          .value = widget.node,
+      onExit: (event) {
+        Future.delayed(const Duration(milliseconds: 100), () {
+          // the onExit event will be triggered before dragging started.
+          // delay the hiding of the resize handle to avoid flickering.
+          if (!isStartDragging) {
+            context.read<SimpleTableContext>().hoveringOnResizeHandle.value =
+                null;
+          }
+        });
+      },
+      child: GestureDetector(
+        onHorizontalDragStart: (details) {
+          isStartDragging = true;
+        },
+        onHorizontalDragUpdate: (details) {
+          context.read<EditorState>().updateColumnWidthInMemory(
+                tableCellNode: widget.node,
+                deltaX: details.delta.dx,
+              );
+        },
+        onHorizontalDragEnd: (details) {
+          context.read<SimpleTableContext>().hoveringOnResizeHandle.value =
+              null;
+          isStartDragging = false;
+          context.read<EditorState>().updateColumnWidth(
+                tableCellNode: widget.node,
+                width: widget.node.columnWidth,
+              );
+        },
+        child: ValueListenableBuilder<Node?>(
+          valueListenable: context.read<SimpleTableContext>().hoveringTableCell,
+          builder: (context, hoveringCell, child) {
+            return ValueListenableBuilder(
+              valueListenable:
+                  context.read<SimpleTableContext>().hoveringOnResizeHandle,
+              builder: (context, hoveringOnResizeHandle, child) {
+                final isSameRowIndex = hoveringOnResizeHandle?.columnIndex ==
+                    widget.node.columnIndex;
+                return Opacity(
+                  opacity: isSameRowIndex ? 1.0 : 0.0,
+                  child: Container(
+                    height: double.infinity,
+                    width: SimpleTableConstants.resizeHandleWidth,
+                    color: Theme.of(context).colorScheme.primary,
+                  ),
+                );
+              },
+            );
+          },
+        ),
+      ),
+    );
+  }
+}
+
+class SimpleTableBackgroundColorMenu extends StatefulWidget {
+  const SimpleTableBackgroundColorMenu({
+    super.key,
+    required this.type,
+    required this.tableCellNode,
+    this.mutex,
+  });
+
+  final SimpleTableMoreActionType type;
+  final Node tableCellNode;
+  final PopoverMutex? mutex;
+
+  @override
+  State<SimpleTableBackgroundColorMenu> createState() =>
+      _SimpleTableBackgroundColorMenuState();
+}
+
+class _SimpleTableBackgroundColorMenuState
+    extends State<SimpleTableBackgroundColorMenu> {
+  final PopoverController controller = PopoverController();
+  bool isOpen = false;
+
+  @override
+  Widget build(BuildContext context) {
+    final backgroundColor = switch (widget.type) {
+      SimpleTableMoreActionType.row =>
+        widget.tableCellNode.buildRowColor(context),
+      SimpleTableMoreActionType.column =>
+        widget.tableCellNode.buildColumnColor(context),
+    };
+    return AppFlowyPopover(
+      controller: controller,
+      mutex: widget.mutex,
+      asBarrier: true,
+      popupBuilder: (_) {
+        isOpen = true;
+        return _buildColorOptionMenu(
+          context,
+          controller,
+        );
+      },
+      onClose: () => isOpen = false,
+      direction: PopoverDirection.rightWithCenterAligned,
+      animationDuration: Durations.short3,
+      beginScaleFactor: 1.0,
+      beginOpacity: 0.8,
+      child: SimpleTableBasicButton(
+        leftIconBuilder: (onHover) => ColorOptionIcon(
+          color: backgroundColor ?? Colors.transparent,
+        ),
+        text: LocaleKeys.document_plugins_simpleTable_moreActions_color.tr(),
+        onTap: () {
+          if (!isOpen) {
+            controller.show();
+          }
+        },
+      ),
+    );
+  }
+
+  Widget _buildColorOptionMenu(
+    BuildContext context,
+    PopoverController controller,
+  ) {
+    final colors = [
+      // reset to default background color
+      FlowyColorOption(
+        color: Colors.transparent,
+        i18n: LocaleKeys.document_plugins_optionAction_defaultColor.tr(),
+        id: optionActionColorDefaultColor,
+      ),
+      ...FlowyTint.values.map(
+        (e) => FlowyColorOption(
+          color: e.color(context),
+          i18n: e.tintName(AppFlowyEditorL10n.current),
+          id: e.id,
+        ),
+      ),
+    ];
+
+    return FlowyColorPicker(
+      colors: colors,
+      border: Border.all(
+        color: AFThemeExtension.of(context).onBackground,
+      ),
+      onTap: (option, index) {
+        switch (widget.type) {
+          case SimpleTableMoreActionType.column:
+            context.read<EditorState>().updateColumnBackgroundColor(
+                  tableCellNode: widget.tableCellNode,
+                  color: option.id,
+                );
+            break;
+          case SimpleTableMoreActionType.row:
+            context.read<EditorState>().updateRowBackgroundColor(
+                  tableCellNode: widget.tableCellNode,
+                  color: option.id,
+                );
+            break;
+        }
+
+        controller.close();
+        PopoverContainer.of(context).close();
+      },
+    );
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_down_command.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_down_command.dart
new file mode 100644
index 0000000000000..125a53a8079e0
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_down_command.dart
@@ -0,0 +1,81 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:collection/collection.dart';
+import 'package:flutter/material.dart';
+
+final CommandShortcutEvent arrowDownInTableCell = CommandShortcutEvent(
+  key: 'Press arrow down in table cell',
+  getDescription: () =>
+      AppFlowyEditorL10n.current.cmdTableMoveToDownCellAtSameOffset,
+  command: 'arrow down',
+  handler: _arrowDownInTableCellHandler,
+);
+
+/// Move the selection to the next cell in the same column.
+///
+/// Only handle the case when the selection is in the first line of the cell.
+KeyEventResult _arrowDownInTableCellHandler(EditorState editorState) {
+  final (isInTableCell, selection, tableCellNode, node) =
+      editorState.isCurrentSelectionInTableCell();
+  if (!isInTableCell ||
+      selection == null ||
+      tableCellNode == null ||
+      node == null) {
+    return KeyEventResult.ignored;
+  }
+
+  final isInLastLine = node.path.last + 1 == node.parent?.children.length;
+  if (!isInLastLine) {
+    return KeyEventResult.ignored;
+  }
+
+  Selection? newSelection = editorState.selection;
+  final rowIndex = tableCellNode.rowIndex;
+  final parentTableNode = tableCellNode.parentTableNode;
+  if (parentTableNode == null) {
+    return KeyEventResult.ignored;
+  }
+
+  if (rowIndex == parentTableNode.rowLength - 1) {
+    // focus on the next block
+    final nextNode = tableCellNode.next;
+    if (nextNode != null) {
+      final nextFocusableSibling = parentTableNode.getNextFocusableSibling();
+      if (nextFocusableSibling != null) {
+        final length = nextFocusableSibling.delta?.length ?? 0;
+        newSelection = Selection.collapsed(
+          Position(
+            path: nextFocusableSibling.path,
+            offset: length,
+          ),
+        );
+      }
+    }
+  } else {
+    // focus on next cell in the same column
+    final nextCell = tableCellNode.getNextCellInSameColumn();
+    if (nextCell != null) {
+      final offset = selection.end.offset;
+      // get the first children of the next cell
+      final firstChild = nextCell.children.firstWhereOrNull(
+        (c) => c.delta != null,
+      );
+      if (firstChild != null) {
+        final length = firstChild.delta?.length ?? 0;
+        newSelection = Selection.collapsed(
+          Position(
+            path: firstChild.path,
+            offset: offset.clamp(0, length),
+          ),
+        );
+      }
+    }
+  }
+
+  if (newSelection != null) {
+    editorState.updateSelectionWithReason(newSelection);
+  }
+
+  return KeyEventResult.handled;
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_left_command.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_left_command.dart
new file mode 100644
index 0000000000000..647fd86c3700f
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_left_command.dart
@@ -0,0 +1,19 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+final CommandShortcutEvent arrowLeftInTableCell = CommandShortcutEvent(
+  key: 'Press arrow left in table cell',
+  getDescription: () => AppFlowyEditorL10n
+      .current.cmdTableMoveToRightCellIfItsAtTheEndOfCurrentCell,
+  command: 'arrow left',
+  handler: (editorState) => editorState.moveToPreviousCell(
+    editorState,
+    (result) {
+      // only handle the case when the selection is at the beginning of the cell
+      if (0 != result.$2?.end.offset) {
+        return false;
+      }
+      return true;
+    },
+  ),
+);
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_right_command.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_right_command.dart
new file mode 100644
index 0000000000000..24b8085479893
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_right_command.dart
@@ -0,0 +1,19 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+final CommandShortcutEvent arrowRightInTableCell = CommandShortcutEvent(
+  key: 'Press arrow right in table cell',
+  getDescription: () => AppFlowyEditorL10n
+      .current.cmdTableMoveToRightCellIfItsAtTheEndOfCurrentCell,
+  command: 'arrow right',
+  handler: (editorState) => editorState.moveToNextCell(
+    editorState,
+    (result) {
+      // only handle the case when the selection is at the end of the cell
+      final node = result.$4;
+      final length = node?.delta?.length ?? 0;
+      final selection = result.$2;
+      return selection?.end.offset == length;
+    },
+  ),
+);
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_up_command.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_up_command.dart
new file mode 100644
index 0000000000000..a3978c6eef59d
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_up_command.dart
@@ -0,0 +1,77 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:collection/collection.dart';
+import 'package:flutter/material.dart';
+
+final CommandShortcutEvent arrowUpInTableCell = CommandShortcutEvent(
+  key: 'Press arrow up in table cell',
+  getDescription: () =>
+      AppFlowyEditorL10n.current.cmdTableMoveToUpCellAtSameOffset,
+  command: 'arrow up',
+  handler: _arrowUpInTableCellHandler,
+);
+
+/// Move the selection to the previous cell in the same column.
+///
+/// Only handle the case when the selection is in the first line of the cell.
+KeyEventResult _arrowUpInTableCellHandler(EditorState editorState) {
+  final (isInTableCell, selection, tableCellNode, node) =
+      editorState.isCurrentSelectionInTableCell();
+  if (!isInTableCell ||
+      selection == null ||
+      tableCellNode == null ||
+      node == null) {
+    return KeyEventResult.ignored;
+  }
+
+  final isInFirstLine = node.path.last == 0;
+  if (!isInFirstLine) {
+    return KeyEventResult.ignored;
+  }
+
+  Selection? newSelection = editorState.selection;
+  final rowIndex = tableCellNode.rowIndex;
+  if (rowIndex == 0) {
+    // focus on the previous block
+    final previousNode = tableCellNode.parentTableNode;
+    if (previousNode != null) {
+      final previousFocusableSibling =
+          previousNode.getPreviousFocusableSibling();
+      if (previousFocusableSibling != null) {
+        final length = previousFocusableSibling.delta?.length ?? 0;
+        newSelection = Selection.collapsed(
+          Position(
+            path: previousFocusableSibling.path,
+            offset: length,
+          ),
+        );
+      }
+    }
+  } else {
+    // focus on previous cell in the same column
+    final previousCell = tableCellNode.getPreviousCellInSameColumn();
+    if (previousCell != null) {
+      final offset = selection.end.offset;
+      // get the last children of the previous cell
+      final lastChild = previousCell.children.lastWhereOrNull(
+        (c) => c.delta != null,
+      );
+      if (lastChild != null) {
+        final length = lastChild.delta?.length ?? 0;
+        newSelection = Selection.collapsed(
+          Position(
+            path: lastChild.path,
+            offset: offset.clamp(0, length),
+          ),
+        );
+      }
+    }
+  }
+
+  if (newSelection != null) {
+    editorState.updateSelectionWithReason(newSelection);
+  }
+
+  return KeyEventResult.handled;
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_backspace_command.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_backspace_command.dart
new file mode 100644
index 0000000000000..14ea25ab3afcb
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_backspace_command.dart
@@ -0,0 +1,33 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:flutter/material.dart';
+
+final CommandShortcutEvent backspaceInTableCell = CommandShortcutEvent(
+  key: 'Press backspace in table cell',
+  getDescription: () => 'Ignore the backspace key in table cell',
+  command: 'backspace',
+  handler: _backspaceInTableCellHandler,
+);
+
+KeyEventResult _backspaceInTableCellHandler(EditorState editorState) {
+  final (isInTableCell, selection, tableCellNode, node) =
+      editorState.isCurrentSelectionInTableCell();
+  if (!isInTableCell ||
+      selection == null ||
+      tableCellNode == null ||
+      node == null) {
+    return KeyEventResult.ignored;
+  }
+
+  final onlyContainsOneChild = tableCellNode.children.length == 1;
+  final isParagraphNode =
+      tableCellNode.children.first.type == ParagraphBlockKeys.type;
+  if (onlyContainsOneChild &&
+      selection.isCollapsed &&
+      selection.end.offset == 0 &&
+      isParagraphNode) {
+    return KeyEventResult.skipRemainingHandlers;
+  }
+
+  return KeyEventResult.ignored;
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_commands.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_commands.dart
new file mode 100644
index 0000000000000..8a5b53dd1ee5c
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_commands.dart
@@ -0,0 +1,16 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_down_command.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_left_command.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_right_command.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_arrow_up_command.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_backspace_command.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_tab_command.dart';
+
+final simpleTableCommands = [
+  arrowUpInTableCell,
+  arrowDownInTableCell,
+  arrowLeftInTableCell,
+  arrowRightInTableCell,
+  tabInTableCell,
+  shiftTabInTableCell,
+  backspaceInTableCell,
+];
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_tab_command.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_tab_command.dart
new file mode 100644
index 0000000000000..a2466617c70a5
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/simple_table_tab_command.dart
@@ -0,0 +1,35 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+final CommandShortcutEvent tabInTableCell = CommandShortcutEvent(
+  key: 'Press tab in table cell',
+  getDescription: () => 'Move the selection to the next cell',
+  command: 'tab',
+  handler: (editorState) => editorState.moveToNextCell(
+    editorState,
+    (result) {
+      final tableCellNode = result.$3;
+      if (tableCellNode?.isLastCellInTable ?? false) {
+        return false;
+      }
+      return true;
+    },
+  ),
+);
+
+final CommandShortcutEvent shiftTabInTableCell = CommandShortcutEvent(
+  key: 'Press shift + tab in table cell',
+  getDescription: () => 'Move the selection to the previous cell',
+  command: 'shift+tab',
+  handler: (editorState) => editorState.moveToPreviousCell(
+    editorState,
+    (result) {
+      final tableCellNode = result.$3;
+      if (tableCellNode?.isFirstCellInTable ?? false) {
+        return false;
+      }
+      return true;
+    },
+  ),
+);
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart
new file mode 100644
index 0000000000000..f4d49babe39a9
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/shortcuts/table_command_extension.dart
@@ -0,0 +1,147 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:collection/collection.dart';
+import 'package:flutter/material.dart';
+
+typedef IsInTableCellResult = (
+  bool isInTableCell,
+  Selection? selection,
+  Node? tableCellNode,
+  Node? node,
+);
+
+extension TableCommandExtension on EditorState {
+  /// Return a tuple, the first element is a boolean indicating whether the current selection is in a table cell,
+  /// the second element is the node that is the parent of the table cell if the current selection is in a table cell,
+  /// otherwise it is null.
+  /// The third element is the node that is the current selection.
+  IsInTableCellResult isCurrentSelectionInTableCell() {
+    final selection = this.selection;
+    if (selection == null || !selection.isCollapsed) {
+      return (false, null, null, null);
+    }
+
+    final node = document.nodeAtPath(selection.end.path);
+    final tableCellParent = node?.findParent(
+      (node) => node.type == SimpleTableCellBlockKeys.type,
+    );
+    final isInTableCell = tableCellParent != null;
+    return (isInTableCell, selection, tableCellParent, node);
+  }
+
+  /// Move the selection to the previous cell
+  KeyEventResult moveToPreviousCell(
+    EditorState editorState,
+    bool Function(IsInTableCellResult result) shouldHandle,
+  ) {
+    final (isInTableCell, selection, tableCellNode, node) =
+        editorState.isCurrentSelectionInTableCell();
+    if (!isInTableCell ||
+        selection == null ||
+        tableCellNode == null ||
+        node == null) {
+      return KeyEventResult.ignored;
+    }
+
+    if (!shouldHandle((isInTableCell, selection, tableCellNode, node))) {
+      return KeyEventResult.ignored;
+    }
+
+    Selection? newSelection;
+
+    final previousCell = tableCellNode.getPreviousCellInSameRow();
+    if (previousCell != null && !previousCell.path.equals(tableCellNode.path)) {
+      // get the last children of the previous cell
+      final lastChild = previousCell.children.lastWhereOrNull(
+        (c) => c.delta != null,
+      );
+      if (lastChild != null) {
+        newSelection = Selection.collapsed(
+          Position(
+            path: lastChild.path,
+            offset: lastChild.delta?.length ?? 0,
+          ),
+        );
+      }
+    } else {
+      // focus on the previous block
+      final previousNode = tableCellNode.parentTableNode;
+      if (previousNode != null) {
+        final previousFocusableSibling =
+            previousNode.getPreviousFocusableSibling();
+        if (previousFocusableSibling != null) {
+          final length = previousFocusableSibling.delta?.length ?? 0;
+          newSelection = Selection.collapsed(
+            Position(
+              path: previousFocusableSibling.path,
+              offset: length,
+            ),
+          );
+        }
+      }
+    }
+
+    if (newSelection != null) {
+      editorState.updateSelectionWithReason(newSelection);
+    }
+
+    return KeyEventResult.handled;
+  }
+
+  /// Move the selection to the next cell
+  KeyEventResult moveToNextCell(
+    EditorState editorState,
+    bool Function(IsInTableCellResult result) shouldHandle,
+  ) {
+    final (isInTableCell, selection, tableCellNode, node) =
+        editorState.isCurrentSelectionInTableCell();
+    if (!isInTableCell ||
+        selection == null ||
+        tableCellNode == null ||
+        node == null) {
+      return KeyEventResult.ignored;
+    }
+
+    if (!shouldHandle((isInTableCell, selection, tableCellNode, node))) {
+      return KeyEventResult.ignored;
+    }
+
+    Selection? newSelection;
+
+    final nextCell = tableCellNode.getNextCellInSameRow();
+    if (nextCell != null && !nextCell.path.equals(tableCellNode.path)) {
+      // get the first children of the next cell
+      final firstChild = nextCell.children.firstWhereOrNull(
+        (c) => c.delta != null,
+      );
+      if (firstChild != null) {
+        newSelection = Selection.collapsed(
+          Position(
+            path: firstChild.path,
+          ),
+        );
+      }
+    } else {
+      // focus on the previous block
+      final nextNode = tableCellNode.parentTableNode;
+      if (nextNode != null) {
+        final nextFocusableSibling = nextNode.getNextFocusableSibling();
+        nextNode.getNextFocusableSibling();
+        if (nextFocusableSibling != null) {
+          newSelection = Selection.collapsed(
+            Position(
+              path: nextFocusableSibling.path,
+            ),
+          );
+        }
+      }
+    }
+
+    if (newSelection != null) {
+      editorState.updateSelectionWithReason(newSelection);
+    }
+
+    return KeyEventResult.handled;
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart
new file mode 100644
index 0000000000000..ff97a8379b582
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart
@@ -0,0 +1,361 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shared_widget.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:flutter/material.dart';
+import 'package:provider/provider.dart';
+
+typedef SimpleTableColumnWidthMap = Map<String, double>;
+typedef SimpleTableRowAlignMap = Map<String, String>;
+typedef SimpleTableColumnAlignMap = Map<String, String>;
+typedef SimpleTableColorMap = Map<String, String>;
+
+class SimpleTableBlockKeys {
+  const SimpleTableBlockKeys._();
+
+  static const String type = 'simple_table';
+
+  // enable header row
+  // it's a bool value, default is false
+  static const String enableHeaderRow = 'enable_header_row';
+
+  // enable column header
+  // it's a bool value, default is false
+  static const String enableHeaderColumn = 'enable_header_column';
+
+  // column colors
+  // it's a `SimpleTableColorMap` value, {column_index: color, ...}
+  // the number of colors should be the same as the number of columns
+  static const String columnColors = 'column_colors';
+
+  // row colors
+  // it's a `SimpleTableColorMap` value, {row_index: color, ...}
+  // the number of colors should be the same as the number of rows
+  static const String rowColors = 'row_colors';
+
+  // column alignments
+  // it's a `SimpleTableColumnAlignMap` value, {column_index: align, ...}
+  // the value should be one of the following: 'left', 'center', 'right'
+  static const String columnAligns = 'column_aligns';
+
+  // row alignments
+  // it's a `SimpleTableRowAlignMap` value, {row_index: align, ...}
+  // the value should be one of the following: 'top', 'center', 'bottom'
+  static const String rowAligns = 'row_aligns';
+
+  // column widths
+  // it's a `SimpleTableColumnWidthMap` value, {column_index: width, ...}
+  static const String columnWidths = 'column_widths';
+}
+
+Node simpleTableBlockNode({
+  bool enableHeaderRow = false,
+  bool enableHeaderColumn = false,
+  SimpleTableColorMap? columnColors,
+  SimpleTableColorMap? rowColors,
+  SimpleTableColumnAlignMap? columnAligns,
+  SimpleTableRowAlignMap? rowAligns,
+  SimpleTableColumnWidthMap? columnWidths,
+  required List<Node> children,
+}) {
+  assert(children.every((e) => e.type == SimpleTableRowBlockKeys.type));
+
+  return Node(
+    type: SimpleTableBlockKeys.type,
+    attributes: {
+      SimpleTableBlockKeys.enableHeaderRow: enableHeaderRow,
+      SimpleTableBlockKeys.enableHeaderColumn: enableHeaderColumn,
+      SimpleTableBlockKeys.columnColors: columnColors,
+      SimpleTableBlockKeys.rowColors: rowColors,
+      SimpleTableBlockKeys.columnAligns: columnAligns,
+      SimpleTableBlockKeys.rowAligns: rowAligns,
+      SimpleTableBlockKeys.columnWidths: columnWidths,
+    },
+    children: children,
+  );
+}
+
+/// Create a simple table block node with the given column and row count.
+///
+/// The table will have cells filled with paragraph nodes.
+///
+/// For example, if you want to create a table with 2 columns and 3 rows, you can use:
+/// ```dart
+/// final table = createSimpleTableBlockNode(columnCount: 2, rowCount: 3);
+/// ```
+///
+/// | cell 1 | cell 2 |
+/// | cell 3 | cell 4 |
+/// | cell 5 | cell 6 |
+Node createSimpleTableBlockNode({
+  required int columnCount,
+  required int rowCount,
+  String? defaultContent,
+}) {
+  final rows = List.generate(rowCount, (_) {
+    final cells = List.generate(
+      columnCount,
+      (_) => simpleTableCellBlockNode(
+        children: [paragraphNode(text: defaultContent)],
+      ),
+    );
+    return simpleTableRowBlockNode(children: cells);
+  });
+
+  return simpleTableBlockNode(children: rows);
+}
+
+class SimpleTableBlockComponentBuilder extends BlockComponentBuilder {
+  SimpleTableBlockComponentBuilder({
+    super.configuration,
+  });
+
+  @override
+  BlockComponentWidget build(BlockComponentContext blockComponentContext) {
+    final node = blockComponentContext.node;
+    return SimpleTableBlockWidget(
+      key: node.key,
+      node: node,
+      configuration: configuration,
+      showActions: showActions(node),
+      actionBuilder: (context, state) => actionBuilder(
+        blockComponentContext,
+        state,
+      ),
+    );
+  }
+
+  @override
+  BlockComponentValidate get validate => (node) => node.children.isNotEmpty;
+}
+
+class SimpleTableBlockWidget extends BlockComponentStatefulWidget {
+  const SimpleTableBlockWidget({
+    super.key,
+    required super.node,
+    super.showActions,
+    super.actionBuilder,
+    super.configuration = const BlockComponentConfiguration(),
+  });
+
+  @override
+  State<SimpleTableBlockWidget> createState() => _SimpleTableBlockWidgetState();
+}
+
+class _SimpleTableBlockWidgetState extends State<SimpleTableBlockWidget>
+    with
+        SelectableMixin,
+        BlockComponentConfigurable,
+        BlockComponentTextDirectionMixin,
+        BlockComponentBackgroundColorMixin {
+  @override
+  BlockComponentConfiguration get configuration => widget.configuration;
+
+  @override
+  Node get node => widget.node;
+
+  @override
+  late EditorState editorState = context.read<EditorState>();
+
+  final tableKey = GlobalKey();
+
+  final simpleTableContext = SimpleTableContext();
+  final scrollController = ScrollController();
+
+  @override
+  void initState() {
+    super.initState();
+
+    editorState.selectionNotifier.addListener(_onSelectionChanged);
+  }
+
+  @override
+  void dispose() {
+    simpleTableContext.dispose();
+    editorState.selectionNotifier.removeListener(_onSelectionChanged);
+    scrollController.dispose();
+
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    Widget child = Transform.translate(
+      offset: const Offset(
+        -SimpleTableConstants.tableLeftPadding,
+        0,
+      ),
+      child: _buildTable(),
+    );
+
+    child = Container(
+      alignment: Alignment.topLeft,
+      padding: padding,
+      child: child,
+    );
+
+    if (widget.showActions && widget.actionBuilder != null) {
+      child = BlockComponentActionWrapper(
+        node: node,
+        actionBuilder: widget.actionBuilder!,
+        child: child,
+      );
+    }
+
+    return child;
+  }
+
+  Widget _buildTable() {
+    const bottomPadding = SimpleTableConstants.addRowButtonHeight +
+        2 * SimpleTableConstants.addRowButtonPadding;
+    const rightPadding = SimpleTableConstants.addColumnButtonWidth +
+        2 * SimpleTableConstants.addColumnButtonPadding;
+    // IntrinsicWidth and IntrinsicHeight are used to make the table size fit the content.
+    return Provider.value(
+      value: simpleTableContext,
+      child: MouseRegion(
+        onEnter: (event) => simpleTableContext.isHoveringOnTable.value = true,
+        onExit: (event) {
+          simpleTableContext.isHoveringOnTable.value = false;
+          simpleTableContext.hoveringTableCell.value = null;
+        },
+        child: Stack(
+          children: [
+            Scrollbar(
+              controller: scrollController,
+              child: SingleChildScrollView(
+                controller: scrollController,
+                scrollDirection: Axis.horizontal,
+                child: Padding(
+                  padding: const EdgeInsets.only(
+                    top: SimpleTableConstants.tableTopPadding,
+                    left: SimpleTableConstants.tableLeftPadding,
+                    bottom: bottomPadding,
+                    right: rightPadding,
+                  ),
+                  child: IntrinsicWidth(
+                    child: IntrinsicHeight(
+                      child: Column(
+                        mainAxisSize: MainAxisSize.min,
+                        crossAxisAlignment: CrossAxisAlignment.start,
+                        children: _buildRows(),
+                      ),
+                    ),
+                  ),
+                ),
+              ),
+            ),
+            SimpleTableAddColumnHoverButton(
+              editorState: editorState,
+              node: node,
+            ),
+            SimpleTableAddRowHoverButton(
+              editorState: editorState,
+              node: node,
+            ),
+            SimpleTableAddColumnAndRowHoverButton(
+              editorState: editorState,
+              node: node,
+            ),
+          ],
+        ),
+      ),
+    );
+  }
+
+  List<Widget> _buildRows() {
+    final List<Widget> rows = [];
+
+    if (SimpleTableConstants.borderType == SimpleTableBorderRenderType.table) {
+      rows.add(const SimpleTableColumnDivider());
+    }
+
+    for (final child in node.children) {
+      rows.add(editorState.renderer.build(context, child));
+
+      if (SimpleTableConstants.borderType ==
+          SimpleTableBorderRenderType.table) {
+        rows.add(const SimpleTableColumnDivider());
+      }
+    }
+
+    return rows;
+  }
+
+  void _onSelectionChanged() {
+    final selection = editorState.selectionNotifier.value;
+    final selectionType = editorState.selectionType;
+    if (selectionType == SelectionType.block &&
+        widget.node.path.inSelection(selection)) {
+      simpleTableContext.isSelectingTable.value = true;
+    } else {
+      simpleTableContext.isSelectingTable.value = false;
+    }
+  }
+
+  RenderBox get _renderBox => context.findRenderObject() as RenderBox;
+
+  @override
+  Position start() => Position(path: widget.node.path);
+
+  @override
+  Position end() => Position(path: widget.node.path, offset: 1);
+
+  @override
+  Position getPositionInOffset(Offset start) => end();
+
+  @override
+  List<Rect> getRectsInSelection(
+    Selection selection, {
+    bool shiftWithBaseOffset = false,
+  }) {
+    final parentBox = context.findRenderObject();
+    final tableBox = tableKey.currentContext?.findRenderObject();
+    if (parentBox is RenderBox && tableBox is RenderBox) {
+      return [
+        (shiftWithBaseOffset
+                ? tableBox.localToGlobal(Offset.zero, ancestor: parentBox)
+                : Offset.zero) &
+            tableBox.size,
+      ];
+    }
+    return [Offset.zero & _renderBox.size];
+  }
+
+  @override
+  Selection getSelectionInRange(Offset start, Offset end) => Selection.single(
+        path: widget.node.path,
+        startOffset: 0,
+        endOffset: 1,
+      );
+
+  @override
+  bool get shouldCursorBlink => false;
+
+  @override
+  CursorStyle get cursorStyle => CursorStyle.cover;
+
+  @override
+  Offset localToGlobal(
+    Offset offset, {
+    bool shiftWithBaseOffset = false,
+  }) =>
+      _renderBox.localToGlobal(offset);
+
+  @override
+  Rect getBlockRect({
+    bool shiftWithBaseOffset = false,
+  }) {
+    return getRectsInSelection(Selection.invalid()).first;
+  }
+
+  @override
+  Rect? getCursorRectInPosition(
+    Position position, {
+    bool shiftWithBaseOffset = false,
+  }) {
+    final size = _renderBox.size;
+    return Rect.fromLTWH(-size.width / 2.0, 0, size.width, size.height);
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart
new file mode 100644
index 0000000000000..51097498fff5c
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart
@@ -0,0 +1,397 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shared_widget.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_more_action.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:flutter/material.dart';
+import 'package:provider/provider.dart';
+
+class SimpleTableCellBlockKeys {
+  const SimpleTableCellBlockKeys._();
+
+  static const String type = 'simple_table_cell';
+}
+
+Node simpleTableCellBlockNode({
+  List<Node>? children,
+}) {
+  // Default children is a paragraph node.
+  children ??= [
+    paragraphNode(),
+  ];
+
+  return Node(
+    type: SimpleTableCellBlockKeys.type,
+    children: children,
+  );
+}
+
+class SimpleTableCellBlockComponentBuilder extends BlockComponentBuilder {
+  SimpleTableCellBlockComponentBuilder({
+    super.configuration,
+  });
+
+  @override
+  BlockComponentWidget build(BlockComponentContext blockComponentContext) {
+    final node = blockComponentContext.node;
+    return SimpleTableCellBlockWidget(
+      key: node.key,
+      node: node,
+      configuration: configuration,
+      showActions: showActions(node),
+      actionBuilder: (context, state) => actionBuilder(
+        blockComponentContext,
+        state,
+      ),
+    );
+  }
+
+  @override
+  BlockComponentValidate get validate => (node) => true;
+}
+
+class SimpleTableCellBlockWidget extends BlockComponentStatefulWidget {
+  const SimpleTableCellBlockWidget({
+    super.key,
+    required super.node,
+    super.showActions,
+    super.actionBuilder,
+    super.configuration = const BlockComponentConfiguration(),
+  });
+
+  @override
+  State<SimpleTableCellBlockWidget> createState() =>
+      _SimpleTableCellBlockWidgetState();
+}
+
+class _SimpleTableCellBlockWidgetState extends State<SimpleTableCellBlockWidget>
+    with
+        BlockComponentConfigurable,
+        BlockComponentTextDirectionMixin,
+        BlockComponentBackgroundColorMixin {
+  @override
+  BlockComponentConfiguration get configuration => widget.configuration;
+
+  @override
+  Node get node => widget.node;
+
+  @override
+  late EditorState editorState = context.read<EditorState>();
+
+  late SimpleTableContext simpleTableContext =
+      context.read<SimpleTableContext>();
+
+  @override
+  void initState() {
+    super.initState();
+
+    simpleTableContext.isSelectingTable.addListener(_onSelectingTableChanged);
+    node.parentTableNode?.addListener(_onSelectingTableChanged);
+  }
+
+  @override
+  void dispose() {
+    simpleTableContext.isSelectingTable.removeListener(
+      _onSelectingTableChanged,
+    );
+    node.parentTableNode?.removeListener(_onSelectingTableChanged);
+
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return MouseRegion(
+      hitTestBehavior: HitTestBehavior.opaque,
+      onEnter: (event) => simpleTableContext.hoveringTableCell.value = node,
+      child: Stack(
+        clipBehavior: Clip.none,
+        children: [
+          _buildCell(),
+          Positioned(
+            top: 0,
+            bottom: 0,
+            left: -SimpleTableConstants.tableLeftPadding,
+            child: _buildRowMoreActionButton(),
+          ),
+          Positioned(
+            left: 0,
+            right: 0,
+            top: -SimpleTableConstants.tableTopPadding,
+            child: _buildColumnMoreActionButton(),
+          ),
+          Positioned(
+            right: 0,
+            top: 0,
+            bottom: 0,
+            child: SimpleTableColumnResizeHandle(
+              node: node,
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildCell() {
+    return ValueListenableBuilder(
+      valueListenable: simpleTableContext.selectingColumn,
+      builder: (context, selectingColumn, child) {
+        return ValueListenableBuilder(
+          valueListenable: simpleTableContext.selectingRow,
+          builder: (context, selectingRow, _) {
+            return DecoratedBox(
+              decoration: _buildDecoration(),
+              child: child!,
+            );
+          },
+        );
+      },
+      child: Column(
+        children: node.children.map(_buildCellContent).toList(),
+      ),
+    );
+  }
+
+  Widget _buildCellContent(Node childNode) {
+    final alignment = _buildAlignment();
+    return Container(
+      padding: SimpleTableConstants.cellEdgePadding,
+      constraints: const BoxConstraints(
+        minWidth: SimpleTableConstants.minimumColumnWidth,
+      ),
+      width: node.columnWidth,
+      alignment: alignment,
+      child: IntrinsicWidth(
+        child: IntrinsicHeight(
+          child: editorState.renderer.build(context, childNode),
+        ),
+      ),
+    );
+  }
+
+  Widget _buildRowMoreActionButton() {
+    final columnIndex = node.columnIndex;
+    final rowIndex = node.rowIndex;
+
+    if (columnIndex != 0) {
+      return const SizedBox.shrink();
+    }
+
+    return SimpleTableMoreActionMenu(
+      index: rowIndex,
+      type: SimpleTableMoreActionType.row,
+    );
+  }
+
+  Widget _buildColumnMoreActionButton() {
+    final columnIndex = node.columnIndex;
+    final rowIndex = node.rowIndex;
+
+    if (rowIndex != 0) {
+      return const SizedBox.shrink();
+    }
+
+    return SimpleTableMoreActionMenu(
+      index: columnIndex,
+      type: SimpleTableMoreActionType.column,
+    );
+  }
+
+  Alignment _buildAlignment() {
+    Alignment alignment = Alignment.topLeft;
+    if (node.columnAlign != TableAlign.left) {
+      alignment = node.columnAlign.alignment;
+    } else if (node.rowAlign != TableAlign.left) {
+      alignment = node.rowAlign.alignment;
+    }
+    return alignment;
+  }
+
+  Decoration _buildDecoration() {
+    final backgroundColor = _buildBackgroundColor();
+    final border = _buildBorder();
+
+    return BoxDecoration(
+      border: border,
+      color: backgroundColor,
+    );
+  }
+
+  Color? _buildBackgroundColor() {
+    // Priority: column color > row color > header color > default color
+
+    final columnColor = node.buildColumnColor(context);
+    if (columnColor != null && columnColor != Colors.transparent) {
+      return columnColor;
+    }
+
+    final rowColor = node.buildRowColor(context);
+    if (rowColor != null && rowColor != Colors.transparent) {
+      return rowColor;
+    }
+
+    // Check if the cell is in the header.
+    // If the cell is in the header, set the background color to the default header color.
+    // Otherwise, set the background color to null.
+    if (_isInHeader()) {
+      return context.simpleTableDefaultHeaderColor;
+    }
+
+    return Theme.of(context).colorScheme.surface;
+  }
+
+  Border? _buildBorder() {
+    if (SimpleTableConstants.borderType != SimpleTableBorderRenderType.cell) {
+      return null;
+    }
+
+    final tableContext = context.watch<SimpleTableContext>();
+    final isCellInSelectedColumn =
+        node.columnIndex == tableContext.selectingColumn.value;
+    final isCellInSelectedRow =
+        node.rowIndex == tableContext.selectingRow.value;
+    if (tableContext.isSelectingTable.value) {
+      return _buildSelectingTableBorder();
+    } else if (isCellInSelectedColumn) {
+      return _buildColumnBorder();
+    } else if (isCellInSelectedRow) {
+      return _buildRowBorder();
+    } else {
+      return _buildCellBorder();
+    }
+  }
+
+  bool _isInHeader() {
+    final isHeaderColumnEnabled = node.isHeaderColumnEnabled;
+    final isHeaderRowEnabled = node.isHeaderRowEnabled;
+    final cellPosition = node.cellPosition;
+    final isFirstColumn = cellPosition.$1 == 0;
+    final isFirstRow = cellPosition.$2 == 0;
+
+    return isHeaderColumnEnabled && isFirstRow ||
+        isHeaderRowEnabled && isFirstColumn;
+  }
+
+  /// the column border means the `VERTICAL` border of the cell
+  ///
+  ///      ____
+  /// | 1 | 2 |
+  /// | 3 | 4 |
+  ///     |___|
+  ///
+  /// the border wrapping the cell 2 and cell 4 is the column border
+  Border _buildColumnBorder() {
+    return Border(
+      left: BorderSide(
+        color: Theme.of(context).colorScheme.primary,
+        width: 2,
+      ),
+      right: BorderSide(
+        color: Theme.of(context).colorScheme.primary,
+        width: 2.5,
+      ),
+      top: node.rowIndex == 0
+          ? BorderSide(
+              color: Theme.of(context).colorScheme.primary,
+              width: 2,
+            )
+          : BorderSide(
+              color: context.simpleTableBorderColor,
+            ),
+      bottom: node.rowIndex + 1 == node.parentTableNode?.rowLength
+          ? BorderSide(
+              color: Theme.of(context).colorScheme.primary,
+              width: 2,
+            )
+          : BorderSide.none,
+    );
+  }
+
+  /// the row border means the `HORIZONTAL` border of the cell
+  ///
+  ///  ________
+  /// | 1 | 2 |
+  /// |_______|
+  /// | 3 | 4 |
+  ///
+  /// the border wrapping the cell 1 and cell 2 is the row border
+  Border _buildRowBorder() {
+    return Border(
+      top: BorderSide(
+        color: Theme.of(context).colorScheme.primary,
+        width: 2,
+      ),
+      bottom: BorderSide(
+        color: Theme.of(context).colorScheme.primary,
+        width: 2.5,
+      ),
+      left: node.columnIndex == 0
+          ? BorderSide(
+              color: Theme.of(context).colorScheme.primary,
+              width: 2,
+            )
+          : BorderSide(
+              color: context.simpleTableBorderColor,
+            ),
+      right: node.columnIndex + 1 == node.parentTableNode?.columnLength
+          ? BorderSide(
+              color: Theme.of(context).colorScheme.primary,
+              width: 2,
+            )
+          : BorderSide.none,
+    );
+  }
+
+  Border _buildCellBorder() {
+    return Border.all(
+      color: context.simpleTableBorderColor,
+      strokeAlign: BorderSide.strokeAlignCenter,
+    );
+  }
+
+  Border _buildSelectingTableBorder() {
+    final rowIndex = node.rowIndex;
+    final columnIndex = node.columnIndex;
+
+    return Border(
+      top: rowIndex == 0
+          ? _buildDefaultBorderSide()
+          : BorderSide(
+              color: context.simpleTableBorderColor,
+              width: 0.5,
+            ),
+      bottom: rowIndex + 1 == node.parentTableNode?.rowLength
+          ? _buildDefaultBorderSide()
+          : BorderSide(
+              color: context.simpleTableBorderColor,
+              width: 0.5,
+            ),
+      left: columnIndex == 0
+          ? _buildDefaultBorderSide()
+          : BorderSide(
+              color: context.simpleTableBorderColor,
+              width: 0.5,
+            ),
+      right: columnIndex + 1 == node.parentTableNode?.columnLength
+          ? _buildDefaultBorderSide()
+          : BorderSide(
+              color: context.simpleTableBorderColor,
+              width: 0.5,
+            ),
+    );
+  }
+
+  BorderSide _buildDefaultBorderSide() {
+    return BorderSide(
+      color: Theme.of(context).colorScheme.primary,
+      width: 2,
+    );
+  }
+
+  void _onSelectingTableChanged() {
+    if (mounted) {
+      setState(() {});
+    }
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart
new file mode 100644
index 0000000000000..142cf1695e119
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart
@@ -0,0 +1,155 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy/util/theme_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:flutter/material.dart';
+
+const enableTableDebugLog = false;
+
+class SimpleTableContext {
+  SimpleTableContext() {
+    if (enableTableDebugLog) {
+      isHoveringOnTable.addListener(_onHoveringOnTableChanged);
+      hoveringTableCell.addListener(_onHoveringTableNodeChanged);
+      selectingColumn.addListener(_onSelectingColumnChanged);
+      selectingRow.addListener(_onSelectingRowChanged);
+      isSelectingTable.addListener(_onSelectingTableChanged);
+    }
+  }
+
+  final ValueNotifier<bool> isHoveringOnTable = ValueNotifier(false);
+  final ValueNotifier<Node?> hoveringTableCell = ValueNotifier(null);
+  final ValueNotifier<Node?> hoveringOnResizeHandle = ValueNotifier(null);
+  final ValueNotifier<int?> selectingColumn = ValueNotifier(null);
+  final ValueNotifier<int?> selectingRow = ValueNotifier(null);
+  final ValueNotifier<bool> isSelectingTable = ValueNotifier(false);
+
+  void _onHoveringOnTableChanged() {
+    if (!enableTableDebugLog) {
+      return;
+    }
+
+    Log.debug('isHoveringOnTable: ${isHoveringOnTable.value}');
+  }
+
+  void _onHoveringTableNodeChanged() {
+    if (!enableTableDebugLog) {
+      return;
+    }
+
+    final node = hoveringTableCell.value;
+    if (node == null) {
+      return;
+    }
+
+    Log.debug('hoveringTableNode: $node, ${node.cellPosition}');
+  }
+
+  void _onSelectingColumnChanged() {
+    if (!enableTableDebugLog) {
+      return;
+    }
+
+    Log.debug('selectingColumn: ${selectingColumn.value}');
+  }
+
+  void _onSelectingRowChanged() {
+    if (!enableTableDebugLog) {
+      return;
+    }
+
+    Log.debug('selectingRow: ${selectingRow.value}');
+  }
+
+  void _onSelectingTableChanged() {
+    if (!enableTableDebugLog) {
+      return;
+    }
+
+    Log.debug('isSelectingTable: ${isSelectingTable.value}');
+  }
+
+  void dispose() {
+    isHoveringOnTable.dispose();
+    hoveringTableCell.dispose();
+    hoveringOnResizeHandle.dispose();
+    selectingColumn.dispose();
+    selectingRow.dispose();
+    isSelectingTable.dispose();
+  }
+}
+
+class SimpleTableConstants {
+  // Table
+  static const defaultColumnWidth = 120.0;
+  static const minimumColumnWidth = 36.0;
+
+  static const tableTopPadding = 8.0;
+  static const tableLeftPadding = 8.0;
+
+  // Add row button
+  static const addRowButtonHeight = 16.0;
+  static const addRowButtonPadding = 2.0;
+  static const addRowButtonRadius = 4.0;
+  static const addRowButtonRightPadding =
+      addColumnButtonWidth + addColumnButtonPadding * 2;
+
+  // Add column button
+  static const addColumnButtonWidth = 16.0;
+  static const addColumnButtonPadding = 2.0;
+  static const addColumnButtonRadius = 4.0;
+  static const addColumnButtonBottomPadding =
+      addRowButtonHeight + addRowButtonPadding * 2;
+
+  // Add column and row button
+  static const addColumnAndRowButtonWidth = addColumnButtonWidth;
+  static const addColumnAndRowButtonHeight = addRowButtonHeight;
+  static const addColumnAndRowButtonCornerRadius = addColumnButtonWidth / 2.0;
+
+  // Table cell
+  static const cellEdgePadding = EdgeInsets.symmetric(
+    horizontal: 9.0,
+    vertical: 2.0,
+  );
+  static const cellBorderWidth = 1.0;
+  static const resizeHandleWidth = 3.0;
+
+  static const borderType = SimpleTableBorderRenderType.cell;
+
+  // Table more action
+  static const moreActionHeight = 34.0;
+  static const moreActionPadding = EdgeInsets.symmetric(vertical: 2.0);
+  static const moreActionHorizontalMargin =
+      EdgeInsets.symmetric(horizontal: 6.0);
+}
+
+enum SimpleTableBorderRenderType {
+  cell,
+  table,
+}
+
+extension SimpleTableColors on BuildContext {
+  Color get simpleTableBorderColor => Theme.of(this).isLightMode
+      ? const Color(0xFFE4E5E5)
+      : const Color(0xFF3A3F49);
+
+  Color get simpleTableDividerColor => Theme.of(this).isLightMode
+      ? const Color(0x141F2329)
+      : const Color(0xFF23262B).withOpacity(0.5);
+
+  Color get simpleTableMoreActionBackgroundColor => Theme.of(this).isLightMode
+      ? const Color(0xFFF2F3F5)
+      : const Color(0xFF2D3036);
+
+  Color get simpleTableMoreActionBorderColor => Theme.of(this).isLightMode
+      ? const Color(0xFFCFD3D9)
+      : const Color(0xFF44484E);
+
+  Color get simpleTableMoreActionHoverColor => Theme.of(this).isLightMode
+      ? const Color(0xFF00C8FF)
+      : const Color(0xFF00C8FF);
+
+  Color get simpleTableDefaultHeaderColor => Theme.of(this).isLightMode
+      ? const Color(0xFFF2F2F2)
+      : const Color(0x08FFFFFF);
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_more_action.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_more_action.dart
new file mode 100644
index 0000000000000..068496a8c79bb
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_more_action.dart
@@ -0,0 +1,670 @@
+import 'package:appflowy/generated/flowy_svgs.g.dart';
+import 'package:appflowy/generated/locale_keys.g.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shared_widget.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy/workspace/presentation/widgets/toggle/toggle.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:easy_localization/easy_localization.dart';
+import 'package:flowy_infra_ui/flowy_infra_ui.dart';
+import 'package:flutter/material.dart';
+import 'package:provider/provider.dart';
+
+enum SimpleTableMoreActionType {
+  column,
+  row;
+
+  List<SimpleTableMoreAction> get actions {
+    switch (this) {
+      case SimpleTableMoreActionType.row:
+        return [
+          SimpleTableMoreAction.insertAbove,
+          SimpleTableMoreAction.insertBelow,
+          SimpleTableMoreAction.duplicate,
+          SimpleTableMoreAction.clearContents,
+          SimpleTableMoreAction.delete,
+          SimpleTableMoreAction.divider,
+          SimpleTableMoreAction.align,
+          SimpleTableMoreAction.backgroundColor,
+        ];
+      case SimpleTableMoreActionType.column:
+        return [
+          SimpleTableMoreAction.insertLeft,
+          SimpleTableMoreAction.insertRight,
+          SimpleTableMoreAction.duplicate,
+          SimpleTableMoreAction.clearContents,
+          SimpleTableMoreAction.delete,
+          SimpleTableMoreAction.divider,
+          SimpleTableMoreAction.align,
+          SimpleTableMoreAction.backgroundColor,
+        ];
+    }
+  }
+
+  FlowySvgData get reorderIconSvg {
+    switch (this) {
+      case SimpleTableMoreActionType.column:
+        return FlowySvgs.table_reorder_column_s;
+      case SimpleTableMoreActionType.row:
+        return FlowySvgs.table_reorder_row_s;
+    }
+  }
+}
+
+enum SimpleTableMoreAction {
+  insertLeft,
+  insertRight,
+  insertAbove,
+  insertBelow,
+  duplicate,
+  clearContents,
+  delete,
+  align,
+  backgroundColor,
+  enableHeaderColumn,
+  enableHeaderRow,
+  divider;
+
+  String get name {
+    return switch (this) {
+      SimpleTableMoreAction.align =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_align.tr(),
+      SimpleTableMoreAction.backgroundColor =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_color.tr(),
+      SimpleTableMoreAction.enableHeaderColumn =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_headerColumn.tr(),
+      SimpleTableMoreAction.enableHeaderRow =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_headerRow.tr(),
+      SimpleTableMoreAction.insertLeft =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_insertLeft.tr(),
+      SimpleTableMoreAction.insertRight =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_insertRight.tr(),
+      SimpleTableMoreAction.insertBelow =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_insertBelow.tr(),
+      SimpleTableMoreAction.insertAbove =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_insertAbove.tr(),
+      SimpleTableMoreAction.clearContents =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_clearContents.tr(),
+      SimpleTableMoreAction.delete =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_delete.tr(),
+      SimpleTableMoreAction.duplicate =>
+        LocaleKeys.document_plugins_simpleTable_moreActions_duplicate.tr(),
+      SimpleTableMoreAction.divider => throw UnimplementedError(),
+    };
+  }
+
+  FlowySvgData get leftIconSvg {
+    return switch (this) {
+      SimpleTableMoreAction.insertLeft => FlowySvgs.table_insert_left_s,
+      SimpleTableMoreAction.insertRight => FlowySvgs.table_insert_right_s,
+      SimpleTableMoreAction.insertAbove => FlowySvgs.table_insert_above_s,
+      SimpleTableMoreAction.insertBelow => FlowySvgs.table_insert_below_s,
+      SimpleTableMoreAction.duplicate => FlowySvgs.duplicate_s,
+      SimpleTableMoreAction.clearContents => FlowySvgs.table_clear_content_s,
+      SimpleTableMoreAction.delete => FlowySvgs.trash_s,
+      SimpleTableMoreAction.enableHeaderColumn =>
+        FlowySvgs.table_header_column_s,
+      SimpleTableMoreAction.enableHeaderRow => FlowySvgs.table_header_row_s,
+      SimpleTableMoreAction.divider =>
+        throw UnsupportedError('divider icon is not supported'),
+      SimpleTableMoreAction.align =>
+        throw UnsupportedError('align icon is not supported'),
+      SimpleTableMoreAction.backgroundColor =>
+        throw UnsupportedError('background color icon is not supported'),
+    };
+  }
+}
+
+class SimpleTableMoreActionMenu extends StatefulWidget {
+  const SimpleTableMoreActionMenu({
+    super.key,
+    required this.index,
+    required this.type,
+  });
+
+  final int index;
+  final SimpleTableMoreActionType type;
+
+  @override
+  State<SimpleTableMoreActionMenu> createState() =>
+      _SimpleTableMoreActionMenuState();
+}
+
+class _SimpleTableMoreActionMenuState extends State<SimpleTableMoreActionMenu> {
+  ValueNotifier<bool> isShowingMenu = ValueNotifier(false);
+
+  @override
+  void dispose() {
+    isShowingMenu.dispose();
+
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    return Align(
+      alignment: widget.type == SimpleTableMoreActionType.row
+          ? Alignment.centerLeft
+          : Alignment.topCenter,
+      child: ValueListenableBuilder<bool>(
+        valueListenable: isShowingMenu,
+        builder: (context, isShowingMenu, child) {
+          return ValueListenableBuilder(
+            valueListenable:
+                context.read<SimpleTableContext>().hoveringTableCell,
+            builder: (context, hoveringTableNode, child) {
+              final hoveringIndex =
+                  widget.type == SimpleTableMoreActionType.column
+                      ? hoveringTableNode?.columnIndex
+                      : hoveringTableNode?.rowIndex;
+
+              if (hoveringIndex != widget.index && !isShowingMenu) {
+                return const SizedBox.shrink();
+              }
+
+              return child!;
+            },
+            child: SimpleTableMoreActionPopup(
+              index: widget.index,
+              isShowingMenu: this.isShowingMenu,
+              type: widget.type,
+            ),
+          );
+        },
+      ),
+    );
+  }
+}
+
+class SimpleTableMoreActionPopup extends StatefulWidget {
+  const SimpleTableMoreActionPopup({
+    super.key,
+    required this.index,
+    required this.isShowingMenu,
+    required this.type,
+  });
+
+  final int index;
+  final ValueNotifier<bool> isShowingMenu;
+  final SimpleTableMoreActionType type;
+
+  @override
+  State<SimpleTableMoreActionPopup> createState() =>
+      _SimpleTableMoreActionPopupState();
+}
+
+class _SimpleTableMoreActionPopupState
+    extends State<SimpleTableMoreActionPopup> {
+  late final editorState = context.read<EditorState>();
+  SelectionGestureInterceptor? gestureInterceptor;
+
+  RenderBox? get renderBox => context.findRenderObject() as RenderBox?;
+
+  @override
+  void initState() {
+    super.initState();
+
+    final tableCellNode =
+        context.read<SimpleTableContext>().hoveringTableCell.value;
+    gestureInterceptor = SelectionGestureInterceptor(
+      key: 'simple_table_more_action_popup_interceptor_${tableCellNode?.id}',
+      canTap: (details) => !_isTapInBounds(details.globalPosition),
+    );
+    editorState.service.selectionService.registerGestureInterceptor(
+      gestureInterceptor!,
+    );
+  }
+
+  @override
+  void dispose() {
+    if (gestureInterceptor != null) {
+      editorState.service.selectionService.unregisterGestureInterceptor(
+        gestureInterceptor!.key,
+      );
+    }
+
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final tableCellNode =
+        context.read<SimpleTableContext>().hoveringTableCell.value;
+    return AppFlowyPopover(
+      onOpen: () {
+        widget.isShowingMenu.value = true;
+        switch (widget.type) {
+          case SimpleTableMoreActionType.column:
+            context.read<SimpleTableContext>().selectingColumn.value =
+                tableCellNode?.columnIndex;
+          case SimpleTableMoreActionType.row:
+            context.read<SimpleTableContext>().selectingRow.value =
+                tableCellNode?.rowIndex;
+        }
+      },
+      onClose: () {
+        widget.isShowingMenu.value = false;
+
+        // clear the selecting index
+        context.read<SimpleTableContext>().selectingColumn.value = null;
+        context.read<SimpleTableContext>().selectingRow.value = null;
+      },
+      direction: widget.type == SimpleTableMoreActionType.row
+          ? PopoverDirection.bottomWithCenterAligned
+          : PopoverDirection.bottomWithLeftAligned,
+      offset: widget.type == SimpleTableMoreActionType.row
+          ? const Offset(24, 14)
+          : const Offset(-14, 8),
+      popupBuilder: (_) {
+        if (tableCellNode == null) {
+          return const SizedBox.shrink();
+        }
+        return MultiProvider(
+          providers: [
+            Provider.value(
+              value: context.read<SimpleTableContext>(),
+            ),
+            Provider.value(
+              value: context.read<EditorState>(),
+            ),
+          ],
+          child: SimpleTableMoreActionList(
+            type: widget.type,
+            index: widget.index,
+            tableCellNode: tableCellNode,
+          ),
+        );
+      },
+      child: SimpleTableReorderButton(
+        isShowingMenu: widget.isShowingMenu,
+        type: widget.type,
+      ),
+    );
+  }
+
+  bool _isTapInBounds(Offset offset) {
+    if (renderBox == null) {
+      return false;
+    }
+
+    final localPosition = renderBox!.globalToLocal(offset);
+    final result = renderBox!.paintBounds.contains(localPosition);
+    if (result) {
+      editorState.selection = null;
+    }
+    return result;
+  }
+}
+
+class SimpleTableMoreActionList extends StatelessWidget {
+  const SimpleTableMoreActionList({
+    super.key,
+    required this.type,
+    required this.index,
+    required this.tableCellNode,
+  });
+
+  final SimpleTableMoreActionType type;
+  final int index;
+  final Node tableCellNode;
+
+  @override
+  Widget build(BuildContext context) {
+    return Column(
+      mainAxisSize: MainAxisSize.min,
+      children: _buildActions()
+          .map(
+            (action) => SimpleTableMoreActionItem(
+              type: type,
+              action: action,
+              tableCellNode: tableCellNode,
+            ),
+          )
+          .toList(),
+    );
+  }
+
+  List<SimpleTableMoreAction> _buildActions() {
+    final actions = type.actions;
+
+    // if the index is 0, add the divider and enable header action
+    if (index == 0) {
+      actions.addAll([
+        SimpleTableMoreAction.divider,
+        if (type == SimpleTableMoreActionType.column)
+          SimpleTableMoreAction.enableHeaderColumn,
+        if (type == SimpleTableMoreActionType.row)
+          SimpleTableMoreAction.enableHeaderRow,
+      ]);
+    }
+
+    // if the table only contains one row or one column, remove the delete action
+    if (tableCellNode.rowLength == 1 && type == SimpleTableMoreActionType.row) {
+      actions.remove(SimpleTableMoreAction.delete);
+    }
+
+    if (tableCellNode.columnLength == 1 &&
+        type == SimpleTableMoreActionType.column) {
+      actions.remove(SimpleTableMoreAction.delete);
+    }
+
+    return actions;
+  }
+}
+
+class SimpleTableMoreActionItem extends StatefulWidget {
+  const SimpleTableMoreActionItem({
+    super.key,
+    required this.type,
+    required this.action,
+    required this.tableCellNode,
+  });
+
+  final SimpleTableMoreActionType type;
+  final SimpleTableMoreAction action;
+  final Node tableCellNode;
+
+  @override
+  State<SimpleTableMoreActionItem> createState() =>
+      _SimpleTableMoreActionItemState();
+}
+
+class _SimpleTableMoreActionItemState extends State<SimpleTableMoreActionItem> {
+  // ensure the background color menu and align menu exclusive
+  final mutex = PopoverMutex();
+
+  ValueNotifier<bool> isEnableHeader = ValueNotifier(false);
+
+  @override
+  void initState() {
+    super.initState();
+
+    _initEnableHeader();
+  }
+
+  @override
+  void dispose() {
+    isEnableHeader.dispose();
+
+    super.dispose();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    if (widget.action == SimpleTableMoreAction.divider) {
+      return _buildDivider(context);
+    } else if (widget.action == SimpleTableMoreAction.align) {
+      return _buildAlignMenu(context);
+    } else if (widget.action == SimpleTableMoreAction.backgroundColor) {
+      return _buildBackgroundColorMenu(context);
+    } else if (widget.action == SimpleTableMoreAction.enableHeaderColumn) {
+      return _buildEnableHeaderButton(context);
+    } else if (widget.action == SimpleTableMoreAction.enableHeaderRow) {
+      return _buildEnableHeaderButton(context);
+    }
+
+    return _buildActionButton(context);
+  }
+
+  Widget _buildDivider(BuildContext context) {
+    return const FlowyDivider(
+      padding: EdgeInsets.symmetric(
+        vertical: 4.0,
+      ),
+    );
+  }
+
+  Widget _buildAlignMenu(BuildContext context) {
+    return SimpleTableAlignMenu(
+      type: widget.type,
+      tableCellNode: widget.tableCellNode,
+      mutex: mutex,
+    );
+  }
+
+  Widget _buildBackgroundColorMenu(BuildContext context) {
+    return SimpleTableBackgroundColorMenu(
+      type: widget.type,
+      tableCellNode: widget.tableCellNode,
+      mutex: mutex,
+    );
+  }
+
+  Widget _buildEnableHeaderButton(BuildContext context) {
+    return SimpleTableBasicButton(
+      text: widget.action.name,
+      leftIconSvg: widget.action.leftIconSvg,
+      rightIcon: ValueListenableBuilder(
+        valueListenable: isEnableHeader,
+        builder: (context, isEnableHeader, child) {
+          return Toggle(
+            value: isEnableHeader,
+            onChanged: (value) => _toggleEnableHeader(),
+            padding: EdgeInsets.zero,
+          );
+        },
+      ),
+      onTap: _toggleEnableHeader,
+    );
+  }
+
+  Widget _buildActionButton(BuildContext context) {
+    return Container(
+      height: SimpleTableConstants.moreActionHeight,
+      padding: SimpleTableConstants.moreActionPadding,
+      child: FlowyIconTextButton(
+        margin: SimpleTableConstants.moreActionHorizontalMargin,
+        leftIconBuilder: (onHover) => FlowySvg(
+          widget.action.leftIconSvg,
+          color: widget.action == SimpleTableMoreAction.delete && onHover
+              ? Theme.of(context).colorScheme.error
+              : null,
+        ),
+        iconPadding: 10.0,
+        textBuilder: (onHover) => FlowyText.regular(
+          widget.action.name,
+          fontSize: 14.0,
+          figmaLineHeight: 18.0,
+          color: widget.action == SimpleTableMoreAction.delete && onHover
+              ? Theme.of(context).colorScheme.error
+              : null,
+        ),
+        onTap: _onAction,
+      ),
+    );
+  }
+
+  void _onAction() {
+    switch (widget.action) {
+      case SimpleTableMoreAction.delete:
+        switch (widget.type) {
+          case SimpleTableMoreActionType.column:
+            _deleteColumn();
+            break;
+          case SimpleTableMoreActionType.row:
+            _deleteRow();
+            break;
+        }
+        break;
+      case SimpleTableMoreAction.insertLeft:
+        _insertColumnLeft();
+        break;
+      case SimpleTableMoreAction.insertRight:
+        _insertColumnRight();
+        break;
+      case SimpleTableMoreAction.insertAbove:
+        _insertRowAbove();
+        break;
+      case SimpleTableMoreAction.insertBelow:
+        _insertRowBelow();
+        break;
+      case SimpleTableMoreAction.clearContents:
+        _clearContent();
+        break;
+      case SimpleTableMoreAction.duplicate:
+        switch (widget.type) {
+          case SimpleTableMoreActionType.column:
+            _duplicateColumn();
+            break;
+          case SimpleTableMoreActionType.row:
+            _duplicateRow();
+            break;
+        }
+        break;
+      default:
+        break;
+    }
+
+    PopoverContainer.of(context).close();
+  }
+
+  void _duplicateRow() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final editorState = context.read<EditorState>();
+    editorState.duplicateRowInTable(table, node.rowIndex);
+  }
+
+  void _duplicateColumn() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final editorState = context.read<EditorState>();
+    editorState.duplicateColumnInTable(table, node.columnIndex);
+  }
+
+  void _toggleEnableHeader() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+
+    isEnableHeader.value = !isEnableHeader.value;
+
+    final (table, _, _) = value;
+    final editorState = context.read<EditorState>();
+    switch (widget.type) {
+      case SimpleTableMoreActionType.column:
+        editorState.toggleEnableHeaderColumn(
+          table,
+          isEnableHeader.value,
+        );
+      case SimpleTableMoreActionType.row:
+        editorState.toggleEnableHeaderRow(
+          table,
+          isEnableHeader.value,
+        );
+    }
+  }
+
+  void _clearContent() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final editorState = context.read<EditorState>();
+    if (widget.type == SimpleTableMoreActionType.column) {
+      editorState.clearContentAtColumnIndex(table, node.columnIndex);
+    } else if (widget.type == SimpleTableMoreActionType.row) {
+      editorState.clearContentAtRowIndex(table, node.rowIndex);
+    }
+  }
+
+  void _insertColumnLeft() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final columnIndex = node.columnIndex;
+    final editorState = context.read<EditorState>();
+    editorState.insertColumnInTable(table, columnIndex);
+  }
+
+  void _insertColumnRight() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final columnIndex = node.columnIndex;
+    final editorState = context.read<EditorState>();
+    editorState.insertColumnInTable(table, columnIndex + 1);
+  }
+
+  void _insertRowAbove() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final rowIndex = node.rowIndex;
+    final editorState = context.read<EditorState>();
+    editorState.insertRowInTable(table, rowIndex);
+  }
+
+  void _insertRowBelow() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final rowIndex = node.rowIndex;
+    final editorState = context.read<EditorState>();
+    editorState.insertRowInTable(table, rowIndex + 1);
+  }
+
+  void _deleteRow() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final rowIndex = node.rowIndex;
+    final editorState = context.read<EditorState>();
+    editorState.deleteRowInTable(table, rowIndex);
+  }
+
+  void _deleteColumn() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value == null) {
+      return;
+    }
+    final (table, node, _) = value;
+    final columnIndex = node.columnIndex;
+    final editorState = context.read<EditorState>();
+    editorState.deleteColumnInTable(table, columnIndex);
+  }
+
+  (Node, Node, TableCellPosition)? _getTableAndTableCellAndCellPosition() {
+    final cell = widget.tableCellNode;
+    final table = cell.parent?.parent;
+    if (table == null || table.type != SimpleTableBlockKeys.type) {
+      return null;
+    }
+    return (table, cell, cell.cellPosition);
+  }
+
+  void _initEnableHeader() {
+    final value = _getTableAndTableCellAndCellPosition();
+    if (value != null) {
+      final (table, _, _) = value;
+      if (widget.type == SimpleTableMoreActionType.column) {
+        isEnableHeader.value = table
+                .attributes[SimpleTableBlockKeys.enableHeaderColumn] as bool? ??
+            false;
+      } else if (widget.type == SimpleTableMoreActionType.row) {
+        isEnableHeader.value =
+            table.attributes[SimpleTableBlockKeys.enableHeaderRow] as bool? ??
+                false;
+      }
+    }
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart
new file mode 100644
index 0000000000000..ccfc3f973cc4a
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart
@@ -0,0 +1,106 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/shared_widget.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:flutter/material.dart';
+import 'package:provider/provider.dart';
+
+class SimpleTableRowBlockKeys {
+  const SimpleTableRowBlockKeys._();
+
+  static const String type = 'simple_table_row';
+}
+
+Node simpleTableRowBlockNode({
+  List<Node> children = const [],
+}) {
+  return Node(
+    type: SimpleTableRowBlockKeys.type,
+    children: children,
+  );
+}
+
+class SimpleTableRowBlockComponentBuilder extends BlockComponentBuilder {
+  SimpleTableRowBlockComponentBuilder({
+    super.configuration,
+  });
+
+  @override
+  BlockComponentWidget build(BlockComponentContext blockComponentContext) {
+    final node = blockComponentContext.node;
+    return SimpleTableRowBlockWidget(
+      key: node.key,
+      node: node,
+      configuration: configuration,
+      showActions: showActions(node),
+      actionBuilder: (context, state) => actionBuilder(
+        blockComponentContext,
+        state,
+      ),
+    );
+  }
+
+  @override
+  BlockComponentValidate get validate => (node) => node.children.isNotEmpty;
+}
+
+class SimpleTableRowBlockWidget extends BlockComponentStatefulWidget {
+  const SimpleTableRowBlockWidget({
+    super.key,
+    required super.node,
+    super.showActions,
+    super.actionBuilder,
+    super.configuration = const BlockComponentConfiguration(),
+  });
+
+  @override
+  State<SimpleTableRowBlockWidget> createState() =>
+      _SimpleTableRowBlockWidgetState();
+}
+
+class _SimpleTableRowBlockWidgetState extends State<SimpleTableRowBlockWidget>
+    with
+        BlockComponentConfigurable,
+        BlockComponentTextDirectionMixin,
+        BlockComponentBackgroundColorMixin {
+  @override
+  BlockComponentConfiguration get configuration => widget.configuration;
+
+  @override
+  Node get node => widget.node;
+
+  @override
+  late EditorState editorState = context.read<EditorState>();
+
+  @override
+  Widget build(BuildContext context) {
+    return IntrinsicHeight(
+      child: Row(
+        crossAxisAlignment: CrossAxisAlignment.stretch,
+        children: _buildCells(),
+      ),
+    );
+  }
+
+  List<Widget> _buildCells() {
+    final List<Widget> cells = [];
+
+    for (var i = 0; i < node.children.length; i++) {
+      // border
+      if (i == 0 &&
+          SimpleTableConstants.borderType ==
+              SimpleTableBorderRenderType.table) {
+        cells.add(const SimpleTableRowDivider());
+      }
+
+      cells.add(editorState.renderer.build(context, node.children[i]));
+
+      // border
+      if (SimpleTableConstants.borderType ==
+          SimpleTableBorderRenderType.table) {
+        cells.add(const SimpleTableRowDivider());
+      }
+    }
+
+    return cells;
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_content_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_content_operation.dart
new file mode 100644
index 0000000000000..c1d10df27b050
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_content_operation.dart
@@ -0,0 +1,83 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+extension TableContentOperation on EditorState {
+  /// Clear the content of the column at the given index.
+  ///
+  /// Before:
+  /// Given column index: 0
+  /// Row 1: | 0 | 1 |  The content of these cells will be cleared
+  /// Row 2: | 2 | 3 |
+  ///
+  /// Call this function with column index 0 will clear the first column of the table.
+  ///
+  /// After:
+  /// Row 1: |   |   |
+  /// Row 2: | 2 | 3 |
+  Future<void> clearContentAtRowIndex(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    if (index < 0 || index >= node.columnLength) {
+      Log.warn('clear content in column: index out of range: $index');
+      return;
+    }
+
+    Log.info('clear content in column: $index in table ${node.id}');
+
+    final transaction = this.transaction;
+
+    final row = node.children[index];
+    for (var i = 0; i < row.children.length; i++) {
+      final cell = row.children[i];
+      transaction.insertNode(cell.path.next, simpleTableCellBlockNode());
+      transaction.deleteNode(cell);
+    }
+    await apply(transaction);
+  }
+
+  /// Clear the content of the row at the given index.
+  ///
+  /// Before:
+  /// Given row index: 1
+  ///               The content of these cells will be cleared
+  /// Row 1: | 0 | 1 |
+  /// Row 2: | 2 | 3 |
+  ///
+  /// Call this function with row index 1 will clear the second row of the table.
+  ///
+  /// After:
+  /// Row 1: | 0 |   |
+  /// Row 2: | 2 |   |
+  Future<void> clearContentAtColumnIndex(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    if (index < 0 || index >= node.columnLength) {
+      Log.warn('clear content in column: index out of range: $index');
+      return;
+    }
+
+    Log.info('clear content in column: $index in table ${node.id}');
+
+    final transaction = this.transaction;
+    for (var i = 0; i < node.rowLength; i++) {
+      final row = node.children[i];
+      final cell = index >= row.children.length
+          ? row.children.last
+          : row.children[index];
+      transaction.insertNode(cell.path.next, simpleTableCellBlockNode());
+      transaction.deleteNode(cell);
+    }
+    await apply(transaction);
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_delete_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_delete_operation.dart
new file mode 100644
index 0000000000000..f2e6d511c7e87
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_delete_operation.dart
@@ -0,0 +1,101 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+extension TableDeletionOperations on EditorState {
+  /// Delete a row at the given index.
+  ///
+  /// Before:
+  /// Given index: 0
+  /// Row 1: |   |   |   |  This row will be deleted
+  /// Row 2: |   |   |   |
+  ///
+  /// Call this function with index 0 will delete the first row of the table.
+  ///
+  /// After:
+  /// Row 1: |   |   |   |
+  Future<void> deleteRowInTable(
+    Node node,
+    int index,
+  ) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    final rowLength = node.rowLength;
+    if (index < 0 || index >= rowLength) {
+      Log.warn(
+        'delete row: index out of range: $index, row length: $rowLength',
+      );
+      return;
+    }
+
+    Log.info('delete row: $index in table ${node.id}');
+
+    final attributes = node.mapTableAttributes(
+      node,
+      type: TableMapOperationType.deleteRow,
+      index: index,
+    );
+
+    final row = node.children[index];
+    final transaction = this.transaction;
+    transaction.deleteNode(row);
+    if (attributes != null) {
+      transaction.updateNode(node, attributes);
+    }
+    await apply(transaction);
+  }
+
+  /// Delete a column at the given index.
+  ///
+  /// Before:
+  /// Given index: 2
+  ///                   This column will be deleted
+  /// Row 1: | 0 | 1 | 2 |
+  /// Row 2: |   |   |   |
+  ///
+  /// Call this function with index 2 will delete the third column of the table.
+  ///
+  /// After:
+  /// Row 1: | 0 | 1 |
+  /// Row 2: |   |   |
+  Future<void> deleteColumnInTable(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    final rowLength = node.rowLength;
+    final columnLength = node.columnLength;
+    if (index < 0 || index >= columnLength) {
+      Log.warn(
+        'delete column: index out of range: $index, column length: $columnLength',
+      );
+      return;
+    }
+
+    Log.info('delete column: $index in table ${node.id}');
+
+    final attributes = node.mapTableAttributes(
+      node,
+      type: TableMapOperationType.deleteColumn,
+      index: index,
+    );
+
+    final transaction = this.transaction;
+    for (var i = 0; i < rowLength; i++) {
+      final row = node.children[i];
+      transaction.deleteNode(row.children[index]);
+    }
+    if (attributes != null) {
+      transaction.updateNode(node, attributes);
+    }
+    await apply(transaction);
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_duplicate_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_duplicate_operation.dart
new file mode 100644
index 0000000000000..8c83aa2a66244
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_duplicate_operation.dart
@@ -0,0 +1,103 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+extension TableDuplicationOperations on EditorState {
+  /// Duplicate a row at the given index.
+  ///
+  /// Before:
+  /// | 0 | 1 | 2 |
+  /// | 3 | 4 | 5 |  This row will be duplicated
+  ///
+  /// Call this function with index 1 will duplicate the second row of the table.
+  ///
+  /// After:
+  /// | 0 | 1 | 2 |
+  /// | 3 | 4 | 5 |
+  /// | 3 | 4 | 5 |  New row
+  Future<void> duplicateRowInTable(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    final columnLength = node.columnLength;
+    final rowLength = node.rowLength;
+
+    if (index < 0 || index >= rowLength) {
+      Log.warn(
+        'duplicate row: index out of range: $index, row length: $rowLength',
+      );
+      return;
+    }
+
+    Log.info(
+      'duplicate row in table ${node.id} at index: $index, column length: $columnLength, row length: $rowLength',
+    );
+
+    final attributes = node.mapTableAttributes(
+      node,
+      type: TableMapOperationType.duplicateRow,
+      index: index,
+    );
+
+    final newRow = node.children[index].copyWith();
+    final transaction = this.transaction;
+    final path = index >= columnLength
+        ? node.children.last.path.next
+        : node.children[index].path;
+    transaction.insertNode(path, newRow);
+    if (attributes != null) {
+      transaction.updateNode(node, attributes);
+    }
+    await apply(transaction);
+  }
+
+  Future<void> duplicateColumnInTable(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    final columnLength = node.columnLength;
+    final rowLength = node.rowLength;
+
+    if (index < 0 || index >= columnLength) {
+      Log.warn(
+        'duplicate column: index out of range: $index, column length: $columnLength',
+      );
+      return;
+    }
+
+    Log.info(
+      'duplicate column in table ${node.id} at index: $index, column length: $columnLength, row length: $rowLength',
+    );
+
+    final attributes = node.mapTableAttributes(
+      node,
+      type: TableMapOperationType.duplicateColumn,
+      index: index,
+    );
+
+    final transaction = this.transaction;
+    for (var i = 0; i < rowLength; i++) {
+      final row = node.children[i];
+      final path = index >= rowLength
+          ? row.children.last.path.next
+          : row.children[index].path;
+      final newCell = row.children[index].copyWith();
+      transaction.insertNode(
+        path,
+        newCell,
+      );
+    }
+    if (attributes != null) {
+      transaction.updateNode(node, attributes);
+    }
+    await apply(transaction);
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_header_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_header_operation.dart
new file mode 100644
index 0000000000000..f2c341c548510
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_header_operation.dart
@@ -0,0 +1,39 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+extension TableHeaderOperation on EditorState {
+  /// Toggle the enable header column of the table.
+  Future<void> toggleEnableHeaderColumn(Node node, bool enable) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    Log.info('toggle enable header column: $enable in table ${node.id}');
+
+    final transaction = this.transaction;
+    transaction.updateNode(node, {
+      SimpleTableBlockKeys.enableHeaderColumn: enable,
+    });
+    await apply(transaction);
+  }
+
+  /// Toggle the enable header row of the table.
+  Future<void> toggleEnableHeaderRow(Node node, bool enable) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    Log.info('toggle enable header row: $enable in table ${node.id}');
+
+    final transaction = this.transaction;
+    transaction.updateNode(node, {
+      SimpleTableBlockKeys.enableHeaderRow: enable,
+    });
+    await apply(transaction);
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_insert_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_insert_operation.dart
new file mode 100644
index 0000000000000..70ab268b0c832
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_insert_operation.dart
@@ -0,0 +1,195 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+extension TableInsertionOperations on EditorState {
+  /// Add a row at the end of the table.
+  ///
+  /// Before:
+  /// Row 1: |   |   |   |
+  /// Row 2: |   |   |   |
+  ///
+  /// Call this function will add a row at the end of the table.
+  ///
+  /// After:
+  /// Row 1: |   |   |   |
+  /// Row 2: |   |   |   |
+  /// Row 3: |   |   |   |  New row
+  ///
+  Future<void> addRowInTable(Node node) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      Log.warn('node is not a table node: ${node.type}');
+      return;
+    }
+
+    await insertRowInTable(node, node.rowLength);
+  }
+
+  /// Add a column at the end of the table.
+  ///
+  /// Before:
+  /// Row 1: |   |   |   |
+  /// Row 2: |   |   |   |
+  ///
+  /// Call this function will add a column at the end of the table.
+  ///
+  /// After:
+  ///                       New column
+  /// Row 1: |   |   |   |   |
+  /// Row 2: |   |   |   |   |
+  Future<void> addColumnInTable(Node node) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      Log.warn('node is not a table node: ${node.type}');
+      return;
+    }
+
+    await insertColumnInTable(node, node.columnLength);
+  }
+
+  /// Add a column and a row at the end of the table.
+  ///
+  /// Before:
+  /// Row 1: |   |   |   |
+  /// Row 2: |   |   |   |
+  ///
+  /// Call this function will add a column and a row at the end of the table.
+  ///
+  /// After:
+  ///                       New column
+  /// Row 1: |   |   |   |   |
+  /// Row 2: |   |   |   |   |
+  /// Row 3: |   |   |   |   |  New row
+  Future<void> addColumnAndRowInTable(Node node) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    await addColumnInTable(node);
+    await addRowInTable(node);
+  }
+
+  /// Add a column at the given index.
+  ///
+  /// Before:
+  /// Given index: 1
+  /// Row 1: | 0 | 1 |
+  /// Row 2: |   |   |
+  ///
+  /// Call this function with index 1 will add a column at the second position of the table.
+  ///
+  /// After:        New column
+  /// Row 1: | 0 |   | 1 |
+  /// Row 2: |   |   |   |
+  Future<void> insertColumnInTable(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      Log.warn('node is not a table node: ${node.type}');
+      return;
+    }
+
+    final columnLength = node.rowLength;
+    final rowLength = node.columnLength;
+
+    Log.info(
+      'add column in table ${node.id} at index: $index, column length: $columnLength, row length: $rowLength',
+    );
+
+    if (index < 0) {
+      Log.warn(
+        'insert column: index out of range: $index, column length: $columnLength',
+      );
+      return;
+    }
+
+    final attributes = node.mapTableAttributes(
+      node,
+      type: TableMapOperationType.insertColumn,
+      index: index,
+    );
+
+    final transaction = this.transaction;
+    for (var i = 0; i < columnLength; i++) {
+      final row = node.children[i];
+      // if the index is greater than the row length, we add the new column at the end of the row.
+      final path = index >= rowLength
+          ? row.children.last.path.next
+          : row.children[index].path;
+      transaction.insertNode(
+        path,
+        simpleTableCellBlockNode(),
+      );
+    }
+    if (attributes != null) {
+      transaction.updateNode(node, attributes);
+    }
+    await apply(transaction);
+  }
+
+  /// Add a row at the given index.
+  ///
+  /// Before:
+  /// Given index: 1
+  /// Row 1: |   |   |
+  /// Row 2: |   |   |
+  ///
+  /// Call this function with index 1 will add a row at the second position of the table.
+  ///
+  /// After:
+  /// Row 1: |   |   |
+  /// Row 2: |   |   |
+  /// Row 3: |   |   |  New row
+  Future<void> insertRowInTable(Node node, int index) async {
+    assert(node.type == SimpleTableBlockKeys.type);
+
+    if (node.type != SimpleTableBlockKeys.type) {
+      return;
+    }
+
+    if (index < 0) {
+      Log.warn(
+        'insert row: index out of range: $index',
+      );
+      return;
+    }
+
+    final columnLength = node.rowLength;
+    final rowLength = node.columnLength;
+
+    Log.info(
+      'insert row in table ${node.id} at index: $index, column length: $columnLength, row length: $rowLength',
+    );
+
+    final newRow = simpleTableRowBlockNode(
+      children: [
+        for (var i = 0; i < rowLength; i++) simpleTableCellBlockNode(),
+      ],
+    );
+
+    final attributes = node.mapTableAttributes(
+      node,
+      type: TableMapOperationType.insertRow,
+      index: index,
+    );
+
+    final transaction = this.transaction;
+    final path = index >= columnLength
+        ? node.children.last.path.next
+        : node.children[index].path;
+    transaction.insertNode(path, newRow);
+    if (attributes != null) {
+      transaction.updateNode(node, attributes);
+    }
+    await apply(transaction);
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart
new file mode 100644
index 0000000000000..5b06716581679
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart
@@ -0,0 +1,500 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+enum TableMapOperationType {
+  insertRow,
+  deleteRow,
+  insertColumn,
+  deleteColumn,
+  duplicateRow,
+  duplicateColumn,
+}
+
+extension TableMapOperation on Node {
+  Attributes? mapTableAttributes(
+    Node node, {
+    required TableMapOperationType type,
+    required int index,
+  }) {
+    assert(this.type == SimpleTableBlockKeys.type);
+
+    if (this.type != SimpleTableBlockKeys.type) {
+      return null;
+    }
+
+    Attributes? attributes;
+
+    switch (type) {
+      case TableMapOperationType.insertRow:
+        attributes = _mapRowInsertionAttributes(index);
+      case TableMapOperationType.insertColumn:
+        attributes = _mapColumnInsertionAttributes(index);
+      case TableMapOperationType.duplicateRow:
+        attributes = _mapRowDuplicationAttributes(index);
+      case TableMapOperationType.duplicateColumn:
+        attributes = _mapColumnDuplicationAttributes(index);
+      case TableMapOperationType.deleteRow:
+        attributes = _mapRowDeletionAttributes(index);
+      case TableMapOperationType.deleteColumn:
+        attributes = _mapColumnDeletionAttributes(index);
+    }
+
+    // clear the attributes that are null
+    attributes?.removeWhere((key, value) => value == null);
+
+    return attributes;
+  }
+
+  /// Map the attributes of a row insertion operation.
+  ///
+  /// When inserting a row, the attributes of the table after the index should be updated
+  /// For example:
+  /// Before:
+  /// |  0  |  1  |  2  |
+  /// |  3  |  4  |  5  |  insert a new row here
+  ///
+  /// The original attributes of the table:
+  /// {
+  ///   "rowColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///   }
+  /// }
+  ///
+  /// Insert a row at index 1:
+  /// |  0  |  1  |  2  |
+  /// |     |     |     |  new row
+  /// |  3  |  4  |  5  |
+  ///
+  /// The new attributes of the table:
+  /// {
+  ///   "rowColors": {
+  ///     0: "#FF0000",
+  ///     2: "#00FF00",  The attributes of the original second row
+  ///   }
+  /// }
+  Attributes? _mapRowInsertionAttributes(int index) {
+    final attributes = this.attributes;
+    try {
+      final rowColors = _remapSource(
+        this.rowColors,
+        index,
+        comparator: (iKey, index) => iKey >= index,
+      );
+
+      final rowAligns = _remapSource(
+        this.rowAligns,
+        index,
+        comparator: (iKey, index) => iKey >= index,
+      );
+
+      return attributes
+          .mergeValues(
+            SimpleTableBlockKeys.rowColors,
+            rowColors,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.rowAligns,
+            rowAligns,
+          );
+    } catch (e) {
+      Log.warn('Failed to map row insertion attributes: $e');
+      return attributes;
+    }
+  }
+
+  /// Map the attributes of a column insertion operation.
+  ///
+  /// When inserting a column, the attributes of the table after the index should be updated
+  /// For example:
+  /// Before:
+  /// |  0  |  1  |
+  /// |  2  |  3  |
+  ///
+  /// The original attributes of the table:
+  /// {
+  ///   "columnColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///   }
+  /// }
+  ///
+  /// Insert a column at index 1:
+  /// |  0  |     |  1  |
+  /// |  2  |     |  3  |
+  ///
+  /// The new attributes of the table:
+  /// {
+  ///   "columnColors": {
+  ///     0: "#FF0000",
+  ///     2: "#00FF00",  The attributes of the original second column
+  ///   }
+  /// }
+  Attributes? _mapColumnInsertionAttributes(int index) {
+    final attributes = this.attributes;
+    try {
+      final columnColors = _remapSource(
+        this.columnColors,
+        index,
+        comparator: (iKey, index) => iKey >= index,
+      );
+
+      final columnAligns = _remapSource(
+        this.columnAligns,
+        index,
+        comparator: (iKey, index) => iKey >= index,
+      );
+
+      final columnWidths = _remapSource(
+        this.columnWidths,
+        index,
+        comparator: (iKey, index) => iKey >= index,
+      );
+
+      return attributes
+          .mergeValues(
+            SimpleTableBlockKeys.columnColors,
+            columnColors,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.columnAligns,
+            columnAligns,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.columnWidths,
+            columnWidths,
+          );
+    } catch (e) {
+      Log.warn('Failed to map row insertion attributes: $e');
+      return attributes;
+    }
+  }
+
+  /// Map the attributes of a row duplication operation.
+  ///
+  /// When duplicating a row, the attributes of the table after the index should be updated
+  /// For example:
+  /// Before:
+  /// |  0  |  1  |  2  |
+  /// |  3  |  4  |  5  |
+  ///
+  /// The original attributes of the table:
+  /// {
+  ///   "rowColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///   }
+  /// }
+  ///
+  /// Duplicate the row at index 1:
+  /// |  0  |  1  |  2  |
+  /// |  3  |  4  |  5  |
+  /// |  3  |  4  |  5  |  duplicated row
+  ///
+  /// The new attributes of the table:
+  /// {
+  ///   "rowColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///     2: "#00FF00",  The attributes of the original second row
+  ///   }
+  /// }
+  Attributes? _mapRowDuplicationAttributes(int index) {
+    final attributes = this.attributes;
+    try {
+      final (rowColors, duplicatedRowColor) = _findDuplicatedEntryAndRemap(
+        this.rowColors,
+        index,
+      );
+
+      final (rowAligns, duplicatedRowAlign) = _findDuplicatedEntryAndRemap(
+        this.rowAligns,
+        index,
+      );
+
+      return attributes
+          .mergeValues(
+            SimpleTableBlockKeys.rowColors,
+            rowColors,
+            duplicatedEntry: duplicatedRowColor,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.rowAligns,
+            rowAligns,
+            duplicatedEntry: duplicatedRowAlign,
+          );
+    } catch (e) {
+      Log.warn('Failed to map row insertion attributes: $e');
+      return attributes;
+    }
+  }
+
+  /// Map the attributes of a column duplication operation.
+  ///
+  /// When duplicating a column, the attributes of the table after the index should be updated
+  /// For example:
+  /// Before:
+  /// |  0  |  1  |
+  /// |  2  |  3  |
+  ///
+  /// The original attributes of the table:
+  /// {
+  ///   "columnColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///   }
+  /// }
+  ///
+  /// Duplicate the column at index 1:
+  /// |  0  |  1  |  1  |  duplicated column
+  /// |  2  |  3  |  2  |  duplicated column
+  ///
+  /// The new attributes of the table:
+  /// {
+  ///   "columnColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///     2: "#00FF00",  The attributes of the original second column
+  ///   }
+  /// }
+  Attributes? _mapColumnDuplicationAttributes(int index) {
+    final attributes = this.attributes;
+    try {
+      final (columnColors, duplicatedColumnColor) =
+          _findDuplicatedEntryAndRemap(
+        this.columnColors,
+        index,
+      );
+
+      final (columnAligns, duplicatedColumnAlign) =
+          _findDuplicatedEntryAndRemap(
+        this.columnAligns,
+        index,
+      );
+
+      final (columnWidths, duplicatedColumnWidth) =
+          _findDuplicatedEntryAndRemap(
+        this.columnWidths,
+        index,
+      );
+
+      return attributes
+          .mergeValues(
+            SimpleTableBlockKeys.columnColors,
+            columnColors,
+            duplicatedEntry: duplicatedColumnColor,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.columnAligns,
+            columnAligns,
+            duplicatedEntry: duplicatedColumnAlign,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.columnWidths,
+            columnWidths,
+            duplicatedEntry: duplicatedColumnWidth,
+          );
+    } catch (e) {
+      Log.warn('Failed to map column duplication attributes: $e');
+      return attributes;
+    }
+  }
+
+  /// Map the attributes of a column deletion operation.
+  ///
+  /// When deleting a column, the attributes of the table after the index should be updated
+  ///
+  /// For example:
+  /// Before:
+  /// |  0  |  1  |  2  |
+  /// |  3  |  4  |  5  |
+  ///
+  /// The original attributes of the table:
+  /// {
+  ///   "columnColors": {
+  ///     0: "#FF0000",
+  ///     2: "#00FF00",
+  ///   }
+  /// }
+  ///
+  /// Delete the column at index 1:
+  /// |  0  |  2  |
+  /// |  3  |  5  |
+  ///
+  /// The new attributes of the table:
+  /// {
+  ///   "columnColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",  The attributes of the original second column
+  ///   }
+  /// }
+  Attributes? _mapColumnDeletionAttributes(int index) {
+    final attributes = this.attributes;
+    try {
+      final columnColors = _remapSource(
+        this.columnColors,
+        index,
+        increment: false,
+        comparator: (iKey, index) => iKey > index,
+        filterIndex: index,
+      );
+      final columnAligns = _remapSource(
+        this.columnAligns,
+        index,
+        increment: false,
+        comparator: (iKey, index) => iKey > index,
+        filterIndex: index,
+      );
+      final columnWidths = _remapSource(
+        this.columnWidths,
+        index,
+        increment: false,
+        comparator: (iKey, index) => iKey > index,
+        filterIndex: index,
+      );
+
+      return attributes
+          .mergeValues(
+            SimpleTableBlockKeys.columnColors,
+            columnColors,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.columnAligns,
+            columnAligns,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.columnWidths,
+            columnWidths,
+          );
+    } catch (e) {
+      Log.warn('Failed to map column deletion attributes: $e');
+      return attributes;
+    }
+  }
+
+  /// Map the attributes of a row deletion operation.
+  ///
+  /// When deleting a row, the attributes of the table after the index should be updated
+  ///
+  /// For example:
+  /// Before:
+  /// |  0  |  1  |  2  |  delete this row
+  /// |  3  |  4  |  5  |
+  ///
+  /// The original attributes of the table:
+  /// {
+  ///   "rowColors": {
+  ///     0: "#FF0000",
+  ///     1: "#00FF00",
+  ///   }
+  /// }
+  ///
+  /// Delete the row at index 0:
+  /// |  3  |  4  |  5  |
+  ///
+  /// The new attributes of the table:
+  /// {
+  ///   "rowColors": {
+  ///     0: "#00FF00",
+  ///   }
+  /// }
+  Attributes? _mapRowDeletionAttributes(int index) {
+    final attributes = this.attributes;
+    try {
+      final rowColors = _remapSource(
+        this.rowColors,
+        index,
+        increment: false,
+        comparator: (iKey, index) => iKey > index,
+        filterIndex: index,
+      );
+      final rowAligns = _remapSource(
+        this.rowAligns,
+        index,
+        increment: false,
+        comparator: (iKey, index) => iKey > index,
+        filterIndex: index,
+      );
+
+      return attributes
+          .mergeValues(
+            SimpleTableBlockKeys.rowColors,
+            rowColors,
+          )
+          .mergeValues(
+            SimpleTableBlockKeys.rowAligns,
+            rowAligns,
+          );
+    } catch (e) {
+      Log.warn('Failed to map row deletion attributes: $e');
+      return attributes;
+    }
+  }
+}
+
+/// Find the duplicated entry and remap the source.
+///
+/// All the entries after the index will be remapped to the new index.
+(Map<String, dynamic> newSource, MapEntry? duplicatedEntry)
+    _findDuplicatedEntryAndRemap(
+  Map<String, dynamic> source,
+  int index, {
+  bool increment = true,
+}) {
+  MapEntry? duplicatedEntry;
+  final newSource = source.map((key, value) {
+    final iKey = int.parse(key);
+    if (iKey == index) {
+      duplicatedEntry = MapEntry(key, value);
+    }
+    if (iKey >= index) {
+      return MapEntry((iKey + (increment ? 1 : -1)).toString(), value);
+    }
+    return MapEntry(key, value);
+  });
+  return (newSource, duplicatedEntry);
+}
+
+/// Remap the source to the new index.
+///
+/// All the entries after the index will be remapped to the new index.
+Map<String, dynamic> _remapSource(
+  Map<String, dynamic> source,
+  int index, {
+  bool increment = true,
+  required bool Function(int iKey, int index) comparator,
+  int? filterIndex,
+}) {
+  var newSource = {...source};
+  if (filterIndex != null) {
+    newSource.remove(filterIndex.toString());
+  }
+  newSource = newSource.map((key, value) {
+    final iKey = int.parse(key);
+    if (comparator(iKey, index)) {
+      return MapEntry((iKey + (increment ? 1 : -1)).toString(), value);
+    }
+    return MapEntry(key, value);
+  });
+  return newSource;
+}
+
+extension TableMapOperationAttributes on Attributes {
+  Attributes mergeValues(
+    String key,
+    Map<String, dynamic> newSource, {
+    MapEntry? duplicatedEntry,
+  }) {
+    final result = {...this};
+
+    if (duplicatedEntry != null) {
+      newSource[duplicatedEntry.key] = duplicatedEntry.value;
+    }
+
+    result[key] = newSource;
+
+    return result;
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart
new file mode 100644
index 0000000000000..b199b6cc90e85
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart
@@ -0,0 +1,500 @@
+import 'package:appflowy/generated/flowy_svgs.g.dart';
+import 'package:appflowy/plugins/document/presentation/editor_page.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_row_block_component.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:flutter/material.dart';
+
+typedef TableCellPosition = (int, int);
+
+enum TableAlign {
+  left,
+  center,
+  right;
+
+  String get name => switch (this) {
+        TableAlign.left => 'Left',
+        TableAlign.center => 'Center',
+        TableAlign.right => 'Right',
+      };
+
+  FlowySvgData get leftIconSvg => switch (this) {
+        TableAlign.left => FlowySvgs.table_align_left_s,
+        TableAlign.center => FlowySvgs.table_align_center_s,
+        TableAlign.right => FlowySvgs.table_align_right_s,
+      };
+
+  Alignment get alignment => switch (this) {
+        TableAlign.left => Alignment.topLeft,
+        TableAlign.center => Alignment.topCenter,
+        TableAlign.right => Alignment.topRight,
+      };
+}
+
+extension TableNodeExtension on Node {
+  /// The number of rows in the table.
+  ///
+  /// The acceptable node is a table node, table row node or table cell node.
+  ///
+  /// Example:
+  ///
+  /// Row 1: |   |   |   |
+  /// Row 2: |   |   |   |
+  ///
+  /// The row length is 2.
+  int get rowLength {
+    final parentTableNode = this.parentTableNode;
+
+    if (parentTableNode == null ||
+        parentTableNode.type != SimpleTableBlockKeys.type) {
+      return -1;
+    }
+
+    return parentTableNode.children.length;
+  }
+
+  /// The number of rows in the table.
+  ///
+  /// The acceptable node is a table node, table row node or table cell node.
+  ///
+  /// Example:
+  ///
+  /// Row 1: |   |   |   |
+  /// Row 2: |   |   |   |
+  ///
+  /// The column length is 3.
+  int get columnLength {
+    final parentTableNode = this.parentTableNode;
+
+    if (parentTableNode == null ||
+        parentTableNode.type != SimpleTableBlockKeys.type) {
+      return -1;
+    }
+
+    return parentTableNode.children.firstOrNull?.children.length ?? 0;
+  }
+
+  TableCellPosition get cellPosition {
+    assert(type == SimpleTableCellBlockKeys.type);
+    return (rowIndex, columnIndex);
+  }
+
+  int get rowIndex {
+    assert(type == SimpleTableCellBlockKeys.type);
+    return path.parent.last;
+  }
+
+  int get columnIndex {
+    assert(type == SimpleTableCellBlockKeys.type);
+    return path.last;
+  }
+
+  bool get isHeaderColumnEnabled {
+    try {
+      return parentTableNode
+              ?.attributes[SimpleTableBlockKeys.enableHeaderColumn] ??
+          false;
+    } catch (e) {
+      Log.warn('get is header column enabled: $e');
+      return false;
+    }
+  }
+
+  bool get isHeaderRowEnabled {
+    try {
+      return parentTableNode
+              ?.attributes[SimpleTableBlockKeys.enableHeaderRow] ??
+          false;
+    } catch (e) {
+      Log.warn('get is header row enabled: $e');
+      return false;
+    }
+  }
+
+  TableAlign get rowAlign {
+    final parentTableNode = this.parentTableNode;
+
+    if (parentTableNode == null) {
+      return TableAlign.left;
+    }
+
+    try {
+      final rowAligns =
+          parentTableNode.attributes[SimpleTableBlockKeys.rowAligns];
+      final align = rowAligns?[rowIndex.toString()];
+      return TableAlign.values.firstWhere(
+        (e) => e.name == align,
+        orElse: () => TableAlign.left,
+      );
+    } catch (e) {
+      Log.warn('get row align: $e');
+      return TableAlign.left;
+    }
+  }
+
+  TableAlign get columnAlign {
+    final parentTableNode = this.parentTableNode;
+
+    if (parentTableNode == null) {
+      return TableAlign.left;
+    }
+
+    try {
+      final columnAligns =
+          parentTableNode.attributes[SimpleTableBlockKeys.columnAligns];
+      final align = columnAligns?[columnIndex.toString()];
+      return TableAlign.values.firstWhere(
+        (e) => e.name == align,
+        orElse: () => TableAlign.left,
+      );
+    } catch (e) {
+      Log.warn('get column align: $e');
+      return TableAlign.left;
+    }
+  }
+
+  Node? get parentTableNode {
+    Node? tableNode;
+
+    if (type == SimpleTableBlockKeys.type) {
+      tableNode = this;
+    } else if (type == SimpleTableRowBlockKeys.type) {
+      tableNode = parent;
+    } else if (type == SimpleTableCellBlockKeys.type) {
+      tableNode = parent?.parent;
+    }
+
+    if (tableNode == null || tableNode.type != SimpleTableBlockKeys.type) {
+      return null;
+    }
+
+    return tableNode;
+  }
+
+  double get columnWidth {
+    final parentTableNode = this.parentTableNode;
+
+    if (parentTableNode == null) {
+      return SimpleTableConstants.defaultColumnWidth;
+    }
+
+    try {
+      final columnWidths =
+          parentTableNode.attributes[SimpleTableBlockKeys.columnWidths];
+      final width = columnWidths?[columnIndex.toString()];
+      return width ?? SimpleTableConstants.defaultColumnWidth;
+    } catch (e) {
+      Log.warn('get column width: $e');
+      return SimpleTableConstants.defaultColumnWidth;
+    }
+  }
+
+  /// Build the row color.
+  ///
+  /// Default is null.
+  Color? buildRowColor(BuildContext context) {
+    try {
+      final rawRowColors =
+          parentTableNode?.attributes[SimpleTableBlockKeys.rowColors];
+      if (rawRowColors == null) {
+        return null;
+      }
+      final color = rawRowColors[rowIndex.toString()];
+      if (color == null) {
+        return null;
+      }
+      return buildEditorCustomizedColor(context, this, color);
+    } catch (e) {
+      Log.warn('get row color: $e');
+      return null;
+    }
+  }
+
+  /// Build the column color.
+  ///
+  /// Default is null.
+  Color? buildColumnColor(BuildContext context) {
+    try {
+      final columnColors =
+          parentTableNode?.attributes[SimpleTableBlockKeys.columnColors];
+      if (columnColors == null) {
+        return null;
+      }
+      final color = columnColors[columnIndex.toString()];
+      if (color == null) {
+        return null;
+      }
+      return buildEditorCustomizedColor(context, this, color);
+    } catch (e) {
+      Log.warn('get column color: $e');
+      return null;
+    }
+  }
+
+  /// Whether the current node is in the header column.
+  ///
+  /// Default is false.
+  bool get isInHeaderColumn {
+    final parentTableNode = parent?.parentTableNode;
+    if (parentTableNode == null ||
+        parentTableNode.type != SimpleTableBlockKeys.type) {
+      return false;
+    }
+    return parentTableNode.isHeaderColumnEnabled && parent?.columnIndex == 0;
+  }
+
+  /// Whether the current node is in the header row.
+  ///
+  /// Default is false.
+  bool get isInHeaderRow {
+    final parentTableNode = parent?.parentTableNode;
+    if (parentTableNode == null ||
+        parentTableNode.type != SimpleTableBlockKeys.type) {
+      return false;
+    }
+    return parentTableNode.isHeaderRowEnabled && parent?.rowIndex == 0;
+  }
+
+  SimpleTableRowAlignMap get rowAligns {
+    final rawRowAligns =
+        parentTableNode?.attributes[SimpleTableBlockKeys.rowAligns];
+    if (rawRowAligns == null) {
+      return SimpleTableRowAlignMap();
+    }
+    try {
+      return SimpleTableRowAlignMap.from(rawRowAligns);
+    } catch (e) {
+      Log.warn('get row aligns: $e');
+      return SimpleTableRowAlignMap();
+    }
+  }
+
+  SimpleTableColorMap get rowColors {
+    final rawRowColors =
+        parentTableNode?.attributes[SimpleTableBlockKeys.rowColors];
+    if (rawRowColors == null) {
+      return SimpleTableColorMap();
+    }
+    try {
+      return SimpleTableColorMap.from(rawRowColors);
+    } catch (e) {
+      Log.warn('get row colors: $e');
+      return SimpleTableColorMap();
+    }
+  }
+
+  SimpleTableColorMap get columnColors {
+    final rawColumnColors =
+        parentTableNode?.attributes[SimpleTableBlockKeys.columnColors];
+    if (rawColumnColors == null) {
+      return SimpleTableColorMap();
+    }
+    try {
+      return SimpleTableColorMap.from(rawColumnColors);
+    } catch (e) {
+      Log.warn('get column colors: $e');
+      return SimpleTableColorMap();
+    }
+  }
+
+  SimpleTableRowAlignMap get columnAligns {
+    final rawColumnAligns =
+        parentTableNode?.attributes[SimpleTableBlockKeys.columnAligns];
+    if (rawColumnAligns == null) {
+      return SimpleTableRowAlignMap();
+    }
+    try {
+      return SimpleTableRowAlignMap.from(rawColumnAligns);
+    } catch (e) {
+      Log.warn('get column aligns: $e');
+      return SimpleTableRowAlignMap();
+    }
+  }
+
+  SimpleTableColumnWidthMap get columnWidths {
+    final rawColumnWidths =
+        parentTableNode?.attributes[SimpleTableBlockKeys.columnWidths];
+    if (rawColumnWidths == null) {
+      return SimpleTableColumnWidthMap();
+    }
+    try {
+      return SimpleTableColumnWidthMap.from(rawColumnWidths);
+    } catch (e) {
+      Log.warn('get column widths: $e');
+      return SimpleTableColumnWidthMap();
+    }
+  }
+
+  /// Get the previous cell in the same column. If the row index is 0, it will return the same cell.
+  Node? getPreviousCellInSameColumn() {
+    assert(type == SimpleTableCellBlockKeys.type);
+    final parentTableNode = this.parentTableNode;
+    if (parentTableNode == null) {
+      return null;
+    }
+
+    final columnIndex = this.columnIndex;
+    final rowIndex = this.rowIndex;
+
+    if (rowIndex == 0) {
+      return this;
+    }
+
+    final previousColumn = parentTableNode.children[rowIndex - 1];
+    final previousCell = previousColumn.children[columnIndex];
+    return previousCell;
+  }
+
+  /// Get the next cell in the same column. If the row index is the last row, it will return the same cell.
+  Node? getNextCellInSameColumn() {
+    assert(type == SimpleTableCellBlockKeys.type);
+    final parentTableNode = this.parentTableNode;
+    if (parentTableNode == null) {
+      return null;
+    }
+
+    final columnIndex = this.columnIndex;
+    final rowIndex = this.rowIndex;
+
+    if (rowIndex == parentTableNode.rowLength - 1) {
+      return this;
+    }
+
+    final nextColumn = parentTableNode.children[rowIndex + 1];
+    final nextCell = nextColumn.children[columnIndex];
+    return nextCell;
+  }
+
+  /// Get the right cell in the same row. If the column index is the last column, it will return the same cell.
+  Node? getNextCellInSameRow() {
+    assert(type == SimpleTableCellBlockKeys.type);
+    final parentTableNode = this.parentTableNode;
+    if (parentTableNode == null) {
+      return null;
+    }
+
+    final columnIndex = this.columnIndex;
+    final rowIndex = this.rowIndex;
+
+    // the last cell
+    if (columnIndex == parentTableNode.columnLength - 1 &&
+        rowIndex == parentTableNode.rowLength - 1) {
+      return this;
+    }
+
+    if (columnIndex == parentTableNode.columnLength - 1) {
+      final nextRow = parentTableNode.children[rowIndex + 1];
+      final nextCell = nextRow.children.first;
+      return nextCell;
+    }
+
+    final nextColumn = parentTableNode.children[rowIndex];
+    final nextCell = nextColumn.children[columnIndex + 1];
+    return nextCell;
+  }
+
+  /// Get the previous cell in the same row. If the column index is 0, it will return the same cell.
+  Node? getPreviousCellInSameRow() {
+    assert(type == SimpleTableCellBlockKeys.type);
+    final parentTableNode = this.parentTableNode;
+    if (parentTableNode == null) {
+      return null;
+    }
+
+    final columnIndex = this.columnIndex;
+    final rowIndex = this.rowIndex;
+
+    if (columnIndex == 0 && rowIndex == 0) {
+      return this;
+    }
+
+    if (columnIndex == 0) {
+      final previousRow = parentTableNode.children[rowIndex - 1];
+      final previousCell = previousRow.children.last;
+      return previousCell;
+    }
+
+    final previousColumn = parentTableNode.children[rowIndex];
+    final previousCell = previousColumn.children[columnIndex - 1];
+    return previousCell;
+  }
+
+  /// Get the previous focusable sibling.
+  ///
+  /// If the current node is the first child of its parent, it will return itself.
+  Node? getPreviousFocusableSibling() {
+    final parent = this.parent;
+    if (parent == null) {
+      return null;
+    }
+    final parentTableNode = this.parentTableNode;
+    if (parentTableNode == null) {
+      return null;
+    }
+    if (parentTableNode.path == [0]) {
+      return this;
+    }
+    final previous = parentTableNode.previous;
+    if (previous == null) {
+      return null;
+    }
+    var children = previous.children;
+    if (children.isEmpty) {
+      return previous;
+    }
+    while (children.isNotEmpty) {
+      children = children.last.children;
+    }
+    return children.lastWhere((c) => c.delta != null);
+  }
+
+  /// Get the next focusable sibling.
+  ///
+  /// If the current node is the last child of its parent, it will return itself.
+  Node? getNextFocusableSibling() {
+    final next = this.next;
+    if (next == null) {
+      return null;
+    }
+    return next;
+  }
+
+  /// Is the last cell in the table.
+  bool get isLastCellInTable {
+    return columnIndex + 1 == parentTableNode?.columnLength &&
+        rowIndex + 1 == parentTableNode?.rowLength;
+  }
+
+  /// Is the first cell in the table.
+  bool get isFirstCellInTable {
+    return columnIndex == 0 && rowIndex == 0;
+  }
+
+  /// Get the table cell node by the row index and column index.
+  ///
+  /// If the current node is not a table cell node, it will return null.
+  /// Or if the row index or column index is out of range, it will return null.
+  Node? getTableCellNode({
+    required int rowIndex,
+    required int columnIndex,
+  }) {
+    assert(type == SimpleTableBlockKeys.type);
+
+    if (type != SimpleTableBlockKeys.type) {
+      return null;
+    }
+
+    if (rowIndex < 0 || rowIndex >= rowLength) {
+      return null;
+    }
+
+    if (columnIndex < 0 || columnIndex >= columnLength) {
+      return null;
+    }
+
+    return children[rowIndex].children[columnIndex];
+  }
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart
new file mode 100644
index 0000000000000..0eb64fb5b78ad
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart
@@ -0,0 +1,8 @@
+export 'table_content_operation.dart';
+export 'table_delete_operation.dart';
+export 'table_duplicate_operation.dart';
+export 'table_header_operation.dart';
+export 'table_insert_operation.dart';
+export 'table_map_operation.dart';
+export 'table_node_extension.dart';
+export 'table_style_operation.dart';
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_style_operation.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_style_operation.dart
new file mode 100644
index 0000000000000..99df9d769fa7c
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/table/table_operations/table_style_operation.dart
@@ -0,0 +1,236 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_cell_block_component.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_map_operation.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_node_extension.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:universal_platform/universal_platform.dart';
+
+extension TableOptionOperation on EditorState {
+  /// Update the column width of the table in memory. Call this function when dragging the table column.
+  ///
+  /// The deltaX is the change of the column width.
+  Future<void> updateColumnWidthInMemory({
+    required Node tableCellNode,
+    required double deltaX,
+  }) async {
+    // Disable in mobile
+    if (UniversalPlatform.isMobile) {
+      return;
+    }
+
+    assert(tableCellNode.type == SimpleTableCellBlockKeys.type);
+
+    if (tableCellNode.type != SimpleTableCellBlockKeys.type) {
+      return;
+    }
+
+    // when dragging the table column, we need to update the column width in memory.
+    // so that the table can render the column with the new width.
+    // but don't need to persist to the database immediately.
+    // only persist to the database when the drag is completed.
+    final columnIndex = tableCellNode.columnIndex;
+    final parentTableNode = tableCellNode.parentTableNode;
+    if (parentTableNode == null) {
+      Log.warn('parent table node is null');
+      return;
+    }
+
+    final width = tableCellNode.columnWidth + deltaX;
+
+    try {
+      final columnWidths =
+          parentTableNode.attributes[SimpleTableBlockKeys.columnWidths] ??
+              SimpleTableColumnWidthMap();
+      final newAttributes = {
+        ...parentTableNode.attributes,
+        SimpleTableBlockKeys.columnWidths: {
+          ...columnWidths,
+          columnIndex.toString(): width.clamp(
+            SimpleTableConstants.minimumColumnWidth,
+            double.infinity,
+          ),
+        },
+      };
+
+      parentTableNode.updateAttributes(newAttributes);
+    } catch (e) {
+      Log.warn('update column width in memory: $e');
+    }
+  }
+
+  /// Update the column width of the table. Call this function after the drag is completed.
+  Future<void> updateColumnWidth({
+    required Node tableCellNode,
+    required double width,
+  }) async {
+    // Disable in mobile
+    if (UniversalPlatform.isMobile) {
+      return;
+    }
+
+    assert(tableCellNode.type == SimpleTableCellBlockKeys.type);
+
+    if (tableCellNode.type != SimpleTableCellBlockKeys.type) {
+      return;
+    }
+
+    final columnIndex = tableCellNode.columnIndex;
+    final parentTableNode = tableCellNode.parentTableNode;
+    if (parentTableNode == null) {
+      Log.warn('parent table node is null');
+      return;
+    }
+
+    final transaction = this.transaction;
+    final columnWidths =
+        parentTableNode.attributes[SimpleTableBlockKeys.columnWidths] ??
+            SimpleTableColumnWidthMap();
+    transaction.updateNode(parentTableNode, {
+      SimpleTableBlockKeys.columnWidths: {
+        ...columnWidths,
+        columnIndex.toString(): width.clamp(
+          SimpleTableConstants.minimumColumnWidth,
+          double.infinity,
+        ),
+      },
+    });
+    await apply(transaction);
+  }
+
+  /// Update the align of the column at the index where the table cell node is located.
+  ///
+  /// Before:
+  /// Given table cell node:
+  /// Row 1: | 0 | 1 |
+  /// Row 2: |2  |3  |  This column will be updated
+  ///
+  /// Call this function will update the align of the column where the table cell node is located.
+  ///
+  /// After:
+  /// Row 1: | 0 | 1 |
+  /// Row 2: | 2 | 3 |  This column is updated, texts are aligned to the center
+  Future<void> updateColumnAlign({
+    required Node tableCellNode,
+    required TableAlign align,
+  }) async {
+    assert(tableCellNode.type == SimpleTableCellBlockKeys.type);
+
+    final parentTableNode = tableCellNode.parentTableNode;
+
+    if (parentTableNode == null) {
+      Log.warn('parent table node is null');
+      return;
+    }
+
+    final transaction = this.transaction;
+    final columnIndex = tableCellNode.columnIndex;
+    final attributes = parentTableNode.attributes.mergeValues(
+      SimpleTableBlockKeys.columnAligns,
+      parentTableNode.columnAligns,
+      duplicatedEntry: MapEntry(columnIndex.toString(), align.name),
+    );
+    transaction.updateNode(parentTableNode, attributes);
+    await apply(transaction);
+  }
+
+  /// Update the align of the row at the index where the table cell node is located.
+  ///
+  /// Before:
+  /// Given table cell node:
+  ///               This row will be updated
+  /// Row 1: | 0 |1  |
+  /// Row 2: | 2 |3  |
+  ///
+  /// Call this function will update the align of the row where the table cell node is located.
+  ///
+  /// After:
+  ///               This row is updated, texts are aligned to the center
+  /// Row 1: | 0 | 1 |
+  /// Row 2: | 2 | 3 |
+  Future<void> updateRowAlign({
+    required Node tableCellNode,
+    required TableAlign align,
+  }) async {
+    assert(tableCellNode.type == SimpleTableCellBlockKeys.type);
+
+    final parentTableNode = tableCellNode.parentTableNode;
+
+    if (parentTableNode == null) {
+      Log.warn('parent table node is null');
+      return;
+    }
+
+    final transaction = this.transaction;
+    final rowIndex = tableCellNode.rowIndex;
+    final attributes = parentTableNode.attributes.mergeValues(
+      SimpleTableBlockKeys.rowAligns,
+      parentTableNode.rowAligns,
+      duplicatedEntry: MapEntry(rowIndex.toString(), align.name),
+    );
+    transaction.updateNode(parentTableNode, attributes);
+    await apply(transaction);
+  }
+
+  /// Update the background color of the column at the index where the table cell node is located.
+  Future<void> updateColumnBackgroundColor({
+    required Node tableCellNode,
+    required String color,
+  }) async {
+    assert(tableCellNode.type == SimpleTableCellBlockKeys.type);
+
+    final parentTableNode = tableCellNode.parentTableNode;
+
+    if (parentTableNode == null) {
+      Log.warn('parent table node is null');
+      return;
+    }
+
+    final columnIndex = tableCellNode.columnIndex;
+
+    Log.info(
+      'update column background color: $color at column $columnIndex in table ${parentTableNode.id}',
+    );
+
+    final transaction = this.transaction;
+    final attributes = parentTableNode.attributes.mergeValues(
+      SimpleTableBlockKeys.columnColors,
+      parentTableNode.columnColors,
+      duplicatedEntry: MapEntry(columnIndex.toString(), color),
+    );
+    transaction.updateNode(parentTableNode, attributes);
+    await apply(transaction);
+  }
+
+  /// Update the background color of the row at the index where the table cell node is located.
+  Future<void> updateRowBackgroundColor({
+    required Node tableCellNode,
+    required String color,
+  }) async {
+    assert(tableCellNode.type == SimpleTableCellBlockKeys.type);
+
+    final parentTableNode = tableCellNode.parentTableNode;
+
+    if (parentTableNode == null) {
+      Log.warn('parent table node is null');
+      return;
+    }
+
+    final rowIndex = tableCellNode.rowIndex;
+
+    Log.info(
+      'update row background color: $color at row $rowIndex in table ${parentTableNode.id}',
+    );
+
+    final transaction = this.transaction;
+
+    final attributes = parentTableNode.attributes.mergeValues(
+      SimpleTableBlockKeys.rowColors,
+      parentTableNode.rowColors,
+      duplicatedEntry: MapEntry(rowIndex.toString(), color),
+    );
+    transaction.updateNode(parentTableNode, attributes);
+    await apply(transaction);
+  }
+}
diff --git a/frontend/appflowy_flutter/packages/flowy_infra_ui/lib/style_widget/color_picker.dart b/frontend/appflowy_flutter/packages/flowy_infra_ui/lib/style_widget/color_picker.dart
index afb4a787ed5b3..1f8329e04122a 100644
--- a/frontend/appflowy_flutter/packages/flowy_infra_ui/lib/style_widget/color_picker.dart
+++ b/frontend/appflowy_flutter/packages/flowy_infra_ui/lib/style_widget/color_picker.dart
@@ -58,22 +58,18 @@ class FlowyColorPicker extends StatelessWidget {
       checkmark = const FlowySvg(FlowySvgData("grid/checkmark"));
     }
 
-    final colorIcon = SizedBox.square(
-      dimension: iconSize,
-      child: DecoratedBox(
-        decoration: BoxDecoration(
-          color: option.color,
-          shape: BoxShape.circle,
-        ),
-      ),
+    final colorIcon = ColorOptionIcon(
+      color: option.color,
+      iconSize: iconSize,
     );
 
     return SizedBox(
       height: itemHeight,
       child: FlowyButton(
-        text: FlowyText.medium(option.i18n),
+        text: FlowyText(option.i18n),
         leftIcon: colorIcon,
         rightIcon: checkmark,
+        iconPadding: 10,
         onTap: () {
           onTap?.call(option, i);
         },
@@ -81,3 +77,30 @@ class FlowyColorPicker extends StatelessWidget {
     );
   }
 }
+
+class ColorOptionIcon extends StatelessWidget {
+  const ColorOptionIcon({
+    super.key,
+    required this.color,
+    this.iconSize = 16.0,
+  });
+
+  final Color color;
+  final double iconSize;
+
+  @override
+  Widget build(BuildContext context) {
+    return SizedBox.square(
+      dimension: iconSize,
+      child: DecoratedBox(
+        decoration: BoxDecoration(
+          color: color,
+          shape: BoxShape.circle,
+          border: color == Colors.transparent
+              ? Border.all(color: const Color(0xFFCFD3D9))
+              : null,
+        ),
+      ),
+    );
+  }
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_contente_operation_test.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_contente_operation_test.dart
new file mode 100644
index 0000000000000..72c76485d370e
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_contente_operation_test.dart
@@ -0,0 +1,109 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+import 'simple_table_test_helper.dart';
+
+void main() {
+  group('Simple table content operation:', () {
+    setUpAll(() {
+      Log.shared.disableLog = true;
+    });
+
+    tearDownAll(() {
+      Log.shared.disableLog = false;
+    });
+
+    test('clear content at row 1', () async {
+      const defaultContent = 'default content';
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+        defaultContent: defaultContent,
+      );
+      await editorState.clearContentAtRowIndex(tableNode, 0);
+      for (var i = 0; i < tableNode.rowLength; i++) {
+        for (var j = 0; j < tableNode.columnLength; j++) {
+          expect(
+            tableNode
+                .getTableCellNode(rowIndex: i, columnIndex: j)
+                ?.children
+                .first
+                .delta
+                ?.toPlainText(),
+            i == 0 ? '' : defaultContent,
+          );
+        }
+      }
+    });
+
+    test('clear content at row 3', () async {
+      const defaultContent = 'default content';
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+        defaultContent: defaultContent,
+      );
+      await editorState.clearContentAtRowIndex(tableNode, 2);
+      for (var i = 0; i < tableNode.rowLength; i++) {
+        for (var j = 0; j < tableNode.columnLength; j++) {
+          expect(
+            tableNode
+                .getTableCellNode(rowIndex: i, columnIndex: j)
+                ?.children
+                .first
+                .delta
+                ?.toPlainText(),
+            i == 2 ? '' : defaultContent,
+          );
+        }
+      }
+    });
+
+    test('clear content at column 1', () async {
+      const defaultContent = 'default content';
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+        defaultContent: defaultContent,
+      );
+      await editorState.clearContentAtColumnIndex(tableNode, 0);
+      for (var i = 0; i < tableNode.rowLength; i++) {
+        for (var j = 0; j < tableNode.columnLength; j++) {
+          expect(
+            tableNode
+                .getTableCellNode(rowIndex: i, columnIndex: j)
+                ?.children
+                .first
+                .delta
+                ?.toPlainText(),
+            j == 0 ? '' : defaultContent,
+          );
+        }
+      }
+    });
+
+    test('clear content at column 4', () async {
+      const defaultContent = 'default content';
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+        defaultContent: defaultContent,
+      );
+      await editorState.clearContentAtColumnIndex(tableNode, 3);
+      for (var i = 0; i < tableNode.rowLength; i++) {
+        for (var j = 0; j < tableNode.columnLength; j++) {
+          expect(
+            tableNode
+                .getTableCellNode(rowIndex: i, columnIndex: j)
+                ?.children
+                .first
+                .delta
+                ?.toPlainText(),
+            j == 3 ? '' : defaultContent,
+          );
+        }
+      }
+    });
+  });
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_delete_operation_test.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_delete_operation_test.dart
new file mode 100644
index 0000000000000..dfaef53459d3a
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_delete_operation_test.dart
@@ -0,0 +1,174 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+import 'simple_table_test_helper.dart';
+
+void main() {
+  group('Simple table delete operation:', () {
+    setUpAll(() {
+      Log.shared.disableLog = true;
+    });
+
+    tearDownAll(() {
+      Log.shared.disableLog = false;
+    });
+
+    test('delete 2 rows in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      await editorState.deleteRowInTable(tableNode, 0);
+      await editorState.deleteRowInTable(tableNode, 0);
+      expect(tableNode.rowLength, 1);
+      expect(tableNode.columnLength, 4);
+    });
+
+    test('delete 2 columns in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      await editorState.deleteColumnInTable(tableNode, 0);
+      await editorState.deleteColumnInTable(tableNode, 0);
+      expect(tableNode.rowLength, 3);
+      expect(tableNode.columnLength, 2);
+    });
+
+    test('delete a row and a column in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      await editorState.deleteColumnInTable(tableNode, 0);
+      await editorState.deleteRowInTable(tableNode, 0);
+      expect(tableNode.rowLength, 2);
+      expect(tableNode.columnLength, 3);
+    });
+
+    test('delete a row with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // delete the row 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 1, columnIndex: 0);
+      await editorState.updateRowBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableCellNode.rowColors, {
+        '1': '0xFF0000FF',
+      });
+      await editorState.updateRowAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.deleteRowInTable(tableNode, 1);
+      expect(tableNode.rowLength, 2);
+      expect(tableNode.columnLength, 4);
+      expect(tableCellNode.rowColors, {});
+      expect(tableNode.rowAligns, {});
+    });
+
+    test('delete a row with background and align (2)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // delete the row 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 1, columnIndex: 0);
+      await editorState.updateRowBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableCellNode.rowColors, {
+        '1': '0xFF0000FF',
+      });
+      await editorState.updateRowAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.deleteRowInTable(tableNode, 0);
+      expect(tableNode.rowLength, 2);
+      expect(tableNode.columnLength, 4);
+      expect(tableCellNode.rowColors, {
+        '0': '0xFF0000FF',
+      });
+      expect(tableNode.rowAligns, {
+        '0': TableAlign.center.name,
+      });
+    });
+
+    test('delete a column with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // delete the column 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 1);
+      await editorState.updateColumnBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableCellNode.columnColors, {
+        '1': '0xFF0000FF',
+      });
+      await editorState.updateColumnAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.deleteColumnInTable(tableNode, 1);
+      expect(tableNode.rowLength, 3);
+      expect(tableNode.columnLength, 3);
+      expect(tableCellNode.columnColors, {});
+      expect(tableNode.columnAligns, {});
+    });
+
+    test('delete a column with background (2)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // delete the column 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 1);
+      await editorState.updateColumnBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableCellNode.columnColors, {
+        '1': '0xFF0000FF',
+      });
+      await editorState.updateColumnAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.deleteColumnInTable(tableNode, 0);
+      expect(tableNode.rowLength, 3);
+      expect(tableNode.columnLength, 3);
+      expect(tableCellNode.columnColors, {
+        '0': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '0': TableAlign.center.name,
+      });
+    });
+  });
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_duplicate_operation_test.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_duplicate_operation_test.dart
new file mode 100644
index 0000000000000..63a26724611cf
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_duplicate_operation_test.dart
@@ -0,0 +1,165 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+import 'simple_table_test_helper.dart';
+
+void main() {
+  group('Simple table delete operation:', () {
+    setUpAll(() {
+      Log.shared.disableLog = true;
+    });
+
+    tearDownAll(() {
+      Log.shared.disableLog = false;
+    });
+
+    test('duplicate a row', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      await editorState.duplicateRowInTable(tableNode, 0);
+      expect(tableNode.rowLength, 4);
+      expect(tableNode.columnLength, 4);
+    });
+
+    test('duplicate a column', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      await editorState.duplicateColumnInTable(tableNode, 0);
+      expect(tableNode.rowLength, 3);
+      expect(tableNode.columnLength, 5);
+    });
+
+    test('duplicate a row with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // duplicate the row 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 1, columnIndex: 0);
+      await editorState.updateRowBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableCellNode.rowColors, {
+        '1': '0xFF0000FF',
+      });
+      await editorState.updateRowAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.duplicateRowInTable(tableNode, 1);
+      expect(tableCellNode.rowColors, {
+        '1': '0xFF0000FF',
+        '2': '0xFF0000FF',
+      });
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+        '2': TableAlign.center.name,
+      });
+    });
+
+    test('duplicate a row with background and align (2)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // duplicate the row 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 1, columnIndex: 0);
+      await editorState.updateRowBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableCellNode.rowColors, {
+        '1': '0xFF0000FF',
+      });
+      await editorState.updateRowAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.duplicateRowInTable(tableNode, 2);
+      expect(tableCellNode.rowColors, {
+        '1': '0xFF0000FF',
+      });
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+      });
+    });
+
+    test('duplicate a column with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // duplicate the column 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 1);
+      await editorState.updateColumnBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      await editorState.updateColumnAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.columnColors, {
+        '1': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.duplicateColumnInTable(tableNode, 1);
+      expect(tableCellNode.columnColors, {
+        '1': '0xFF0000FF',
+        '2': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+        '2': TableAlign.center.name,
+      });
+    });
+
+    test('duplicate a column with background and align (2)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 3,
+        columnCount: 4,
+      );
+      // duplicate the column 1
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 1);
+      await editorState.updateColumnBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      await editorState.updateColumnAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.columnColors, {
+        '1': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+      });
+      await editorState.duplicateColumnInTable(tableNode, 2);
+      expect(tableCellNode.columnColors, {
+        '1': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+      });
+    });
+  });
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_header_operation_test.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_header_operation_test.dart
new file mode 100644
index 0000000000000..c19aa9206d62b
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_header_operation_test.dart
@@ -0,0 +1,47 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+import 'simple_table_test_helper.dart';
+
+void main() {
+  group('Simple table header operation:', () {
+    setUpAll(() {
+      Log.shared.disableLog = true;
+    });
+
+    tearDownAll(() {
+      Log.shared.disableLog = false;
+    });
+
+    test('enable header column in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // default is not header column
+      expect(tableNode.isHeaderColumnEnabled, false);
+      await editorState.toggleEnableHeaderColumn(tableNode, true);
+      expect(tableNode.isHeaderColumnEnabled, true);
+      await editorState.toggleEnableHeaderColumn(tableNode, false);
+      expect(tableNode.isHeaderColumnEnabled, false);
+      expect(tableNode.rowLength, 2);
+      expect(tableNode.columnLength, 3);
+    });
+
+    test('enable header row in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // default is not header row
+      expect(tableNode.isHeaderRowEnabled, false);
+      await editorState.toggleEnableHeaderRow(tableNode, true);
+      expect(tableNode.isHeaderRowEnabled, true);
+      await editorState.toggleEnableHeaderRow(tableNode, false);
+      expect(tableNode.isHeaderRowEnabled, false);
+      expect(tableNode.rowLength, 2);
+      expect(tableNode.columnLength, 3);
+    });
+  });
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_insert_operation_test.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_insert_operation_test.dart
new file mode 100644
index 0000000000000..b351f3dd690a2
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_insert_operation_test.dart
@@ -0,0 +1,194 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+import 'simple_table_test_helper.dart';
+
+void main() {
+  group('Simple table insert operation:', () {
+    setUpAll(() {
+      Log.shared.disableLog = true;
+    });
+
+    tearDownAll(() {
+      Log.shared.disableLog = false;
+    });
+
+    test('add 2 rows in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      await editorState.addRowInTable(tableNode);
+      await editorState.addRowInTable(tableNode);
+      expect(tableNode.rowLength, 4);
+      expect(tableNode.columnLength, 3);
+    });
+
+    test('add 2 columns in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      await editorState.addColumnInTable(tableNode);
+      await editorState.addColumnInTable(tableNode);
+      expect(tableNode.rowLength, 2);
+      expect(tableNode.columnLength, 5);
+    });
+
+    test('add 2 rows and 2 columns in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      await editorState.addColumnAndRowInTable(tableNode);
+      await editorState.addColumnAndRowInTable(tableNode);
+      expect(tableNode.rowLength, 4);
+      expect(tableNode.columnLength, 5);
+    });
+
+    test('insert a row at the first position in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      await editorState.insertRowInTable(tableNode, 0);
+      expect(tableNode.rowLength, 3);
+      expect(tableNode.columnLength, 3);
+    });
+
+    test('insert a column at the first position in table', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      await editorState.insertColumnInTable(tableNode, 0);
+      expect(tableNode.columnLength, 4);
+      expect(tableNode.rowLength, 2);
+    });
+
+    test('insert a row with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // insert the row at the first position
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 0);
+      await editorState.updateRowBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableNode.rowColors, {
+        '0': '0xFF0000FF',
+      });
+      await editorState.updateRowAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.rowAligns, {
+        '0': TableAlign.center.name,
+      });
+      await editorState.insertRowInTable(tableNode, 0);
+      expect(tableNode.rowColors, {
+        '1': '0xFF0000FF',
+      });
+      expect(tableNode.rowAligns, {
+        '1': TableAlign.center.name,
+      });
+    });
+
+    test('insert a row with background and align (2)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // insert the row at the first position
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 0);
+      await editorState.updateRowBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      expect(tableNode.rowColors, {
+        '0': '0xFF0000FF',
+      });
+      await editorState.updateRowAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.rowAligns, {
+        '0': TableAlign.center.name,
+      });
+      await editorState.insertRowInTable(tableNode, 1);
+      expect(tableNode.rowColors, {
+        '0': '0xFF0000FF',
+      });
+      expect(tableNode.rowAligns, {
+        '0': TableAlign.center.name,
+      });
+    });
+
+    test('insert a column with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // insert the column at the first position
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 0);
+      await editorState.updateColumnBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      await editorState.updateColumnAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.columnColors, {
+        '0': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '0': TableAlign.center.name,
+      });
+      await editorState.insertColumnInTable(tableNode, 0);
+      expect(tableNode.columnColors, {
+        '1': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '1': TableAlign.center.name,
+      });
+    });
+
+    test('insert a column with background and align (1)', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // insert the column at the first position
+      final tableCellNode =
+          tableNode.getTableCellNode(rowIndex: 0, columnIndex: 0);
+      await editorState.updateColumnBackgroundColor(
+        tableCellNode: tableCellNode!,
+        color: '0xFF0000FF',
+      );
+      await editorState.updateColumnAlign(
+        tableCellNode: tableCellNode,
+        align: TableAlign.center,
+      );
+      expect(tableNode.columnColors, {
+        '0': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '0': TableAlign.center.name,
+      });
+      await editorState.insertColumnInTable(tableNode, 1);
+      expect(tableNode.columnColors, {
+        '0': '0xFF0000FF',
+      });
+      expect(tableNode.columnAligns, {
+        '0': TableAlign.center.name,
+      });
+    });
+  });
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_style_operation_test.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_style_operation_test.dart
new file mode 100644
index 0000000000000..fc076a597da08
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_style_operation_test.dart
@@ -0,0 +1,179 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_constants.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/table_operations/table_operations.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+import 'simple_table_test_helper.dart';
+
+void main() {
+  group('Simple table style operation:', () {
+    setUpAll(() {
+      Log.shared.disableLog = true;
+    });
+
+    tearDownAll(() {
+      Log.shared.disableLog = false;
+    });
+
+    test('update column width in memory', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      // check the default column width
+      expect(tableNode.columnWidths, isEmpty);
+      final tableCellNode = tableNode.getTableCellNode(
+        rowIndex: 0,
+        columnIndex: 0,
+      );
+      await editorState.updateColumnWidthInMemory(
+        tableCellNode: tableCellNode!,
+        deltaX: 100,
+      );
+      expect(tableNode.columnWidths, {
+        '0': SimpleTableConstants.defaultColumnWidth + 100,
+      });
+
+      // set the width less than the minimum column width
+      await editorState.updateColumnWidthInMemory(
+        tableCellNode: tableCellNode,
+        deltaX: -1000,
+      );
+      expect(tableNode.columnWidths, {
+        '0': SimpleTableConstants.minimumColumnWidth,
+      });
+    });
+
+    test('update column width', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      expect(tableNode.columnWidths, isEmpty);
+
+      for (var i = 0; i < tableNode.columnLength; i++) {
+        final tableCellNode = tableNode.getTableCellNode(
+          rowIndex: 0,
+          columnIndex: i,
+        );
+        await editorState.updateColumnWidth(
+          tableCellNode: tableCellNode!,
+          width: 100,
+        );
+      }
+      expect(tableNode.columnWidths, {
+        '0': 100,
+        '1': 100,
+        '2': 100,
+      });
+
+      // set the width less than the minimum column width
+      for (var i = 0; i < tableNode.columnLength; i++) {
+        final tableCellNode = tableNode.getTableCellNode(
+          rowIndex: 0,
+          columnIndex: i,
+        );
+        await editorState.updateColumnWidth(
+          tableCellNode: tableCellNode!,
+          width: -1000,
+        );
+      }
+      expect(tableNode.columnWidths, {
+        '0': SimpleTableConstants.minimumColumnWidth,
+        '1': SimpleTableConstants.minimumColumnWidth,
+        '2': SimpleTableConstants.minimumColumnWidth,
+      });
+    });
+
+    test('update column align', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+      for (var i = 0; i < tableNode.columnLength; i++) {
+        final tableCellNode = tableNode.getTableCellNode(
+          rowIndex: 0,
+          columnIndex: i,
+        );
+        await editorState.updateColumnAlign(
+          tableCellNode: tableCellNode!,
+          align: TableAlign.center,
+        );
+      }
+      expect(tableNode.columnAligns, {
+        '0': TableAlign.center.name,
+        '1': TableAlign.center.name,
+        '2': TableAlign.center.name,
+      });
+    });
+
+    test('update row align', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+
+      for (var i = 0; i < tableNode.rowLength; i++) {
+        final tableCellNode = tableNode.getTableCellNode(
+          rowIndex: i,
+          columnIndex: 0,
+        );
+        await editorState.updateRowAlign(
+          tableCellNode: tableCellNode!,
+          align: TableAlign.center,
+        );
+      }
+
+      expect(tableNode.rowAligns, {
+        '0': TableAlign.center.name,
+        '1': TableAlign.center.name,
+      });
+    });
+
+    test('update column background color', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+
+      for (var i = 0; i < tableNode.columnLength; i++) {
+        final tableCellNode = tableNode.getTableCellNode(
+          rowIndex: 0,
+          columnIndex: i,
+        );
+        await editorState.updateColumnBackgroundColor(
+          tableCellNode: tableCellNode!,
+          color: '0xFF0000FF',
+        );
+      }
+      expect(tableNode.columnColors, {
+        '0': '0xFF0000FF',
+        '1': '0xFF0000FF',
+        '2': '0xFF0000FF',
+      });
+    });
+
+    test('update row background color', () async {
+      final (editorState, tableNode) = createEditorStateAndTable(
+        rowCount: 2,
+        columnCount: 3,
+      );
+
+      for (var i = 0; i < tableNode.rowLength; i++) {
+        final tableCellNode = tableNode.getTableCellNode(
+          rowIndex: i,
+          columnIndex: 0,
+        );
+        await editorState.updateRowBackgroundColor(
+          tableCellNode: tableCellNode!,
+          color: '0xFF0000FF',
+        );
+      }
+
+      expect(tableNode.rowColors, {
+        '0': '0xFF0000FF',
+        '1': '0xFF0000FF',
+      });
+    });
+  });
+}
diff --git a/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_test_helper.dart b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_test_helper.dart
new file mode 100644
index 0000000000000..be6d60cc41856
--- /dev/null
+++ b/frontend/appflowy_flutter/test/unit_test/simple_table/simple_table_test_helper.dart
@@ -0,0 +1,22 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/table/simple_table_block_component.dart';
+import 'package:appflowy_editor/appflowy_editor.dart';
+
+(EditorState editorState, Node tableNode) createEditorStateAndTable({
+  required int rowCount,
+  required int columnCount,
+  String? defaultContent,
+}) {
+  final document = Document.blank()
+    ..insert(
+      [0],
+      [
+        createSimpleTableBlockNode(
+          columnCount: columnCount,
+          rowCount: rowCount,
+          defaultContent: defaultContent,
+        ),
+      ],
+    );
+  final editorState = EditorState(document: document);
+  return (editorState, document.nodeAtPath([0])!);
+}
diff --git a/frontend/resources/flowy_icons/16x/table_align_center.svg b/frontend/resources/flowy_icons/16x/table_align_center.svg
new file mode 100644
index 0000000000000..a3e462df06f5a
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_align_center.svg
@@ -0,0 +1,5 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M13.625 4.25H2.375" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M11.125 8H4.875" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M12.375 11.75H3.625" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_align_left.svg b/frontend/resources/flowy_icons/16x/table_align_left.svg
new file mode 100644
index 0000000000000..0f71e7fc3c7fd
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_align_left.svg
@@ -0,0 +1,5 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M13.625 4.25H2.375" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M9.875 8H2.375" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M11.125 11.75H2.375" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_align_right.svg b/frontend/resources/flowy_icons/16x/table_align_right.svg
new file mode 100644
index 0000000000000..de3efa902a929
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_align_right.svg
@@ -0,0 +1,5 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M13.625 4.25H2.375" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M13.625 8H6.125" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+<path d="M13.625 11.75H4.875" stroke="#1F2329" stroke-linecap="round" stroke-linejoin="round"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_clear_content.svg b/frontend/resources/flowy_icons/16x/table_clear_content.svg
new file mode 100644
index 0000000000000..8afeb2dd65b6d
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_clear_content.svg
@@ -0,0 +1,4 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M8.77563 11.6528C8.95869 11.8358 9.2555 11.8358 9.43856 11.6528C9.62162 11.4697 9.62162 11.1729 9.43856 10.9898L8.77563 11.6528ZM5.01018 6.56145C4.82713 6.37839 4.53033 6.37839 4.34727 6.56145C4.16421 6.74451 4.16421 7.04131 4.34727 7.22437L5.01018 6.56145ZM11.7279 8.03756L8.03756 11.7279L8.7005 12.3908L12.3908 8.7005L11.7279 8.03756ZM4.27212 7.96244L7.96244 4.27212L7.2995 3.60921L3.60921 7.2995L4.27212 7.96244ZM4.27212 11.7279C3.74086 11.1966 3.37647 10.8308 3.13908 10.5197C2.90995 10.2194 2.84375 10.0257 2.84375 9.84513H1.90625C1.90625 10.3131 2.10099 10.7046 2.39375 11.0884C2.67826 11.4613 3.09669 11.8783 3.60921 12.3908L4.27212 11.7279ZM3.60921 7.2995C3.09669 7.812 2.67826 8.22906 2.39375 8.60194C2.10099 8.98562 1.90625 9.37719 1.90625 9.84513H2.84375C2.84375 9.66456 2.90995 9.47094 3.13908 9.17062C3.37647 8.8595 3.74086 8.49369 4.27212 7.96244L3.60921 7.2995ZM8.03756 11.7279C7.50631 12.2591 7.1405 12.6236 6.82937 12.8609C6.52907 13.0901 6.33541 13.1562 6.15485 13.1562V14.0938C6.62281 14.0938 7.01438 13.899 7.39806 13.6062C7.77094 13.3217 8.188 12.9033 8.7005 12.3908L8.03756 11.7279ZM3.60921 12.3908C4.12173 12.9033 4.53876 13.3217 4.91164 13.6062C5.29535 13.899 5.68689 14.0938 6.15485 14.0938V13.1562C5.97429 13.1562 5.78062 13.0901 5.48031 12.8609C5.16918 12.6236 4.80338 12.2591 4.27212 11.7279L3.60921 12.3908ZM11.7279 4.27212C12.2591 4.80338 12.6236 5.16918 12.8609 5.48031C13.0901 5.78062 13.1562 5.97429 13.1562 6.15485H14.0938C14.0938 5.68689 13.899 5.29535 13.6062 4.91164C13.3217 4.53876 12.9033 4.12173 12.3908 3.60921L11.7279 4.27212ZM12.3908 8.7005C12.9033 8.188 13.3217 7.77094 13.6062 7.39806C13.899 7.01438 14.0938 6.62281 14.0938 6.15485H13.1562C13.1562 6.33541 13.0901 6.52907 12.8609 6.82937C12.6236 7.1405 12.2591 7.50631 11.7279 8.03756L12.3908 8.7005ZM12.3908 3.60921C11.8783 3.09669 11.4613 2.67826 11.0884 2.39375C10.7046 2.10099 10.3131 1.90625 9.84513 1.90625V2.84375C10.0257 2.84375 10.2194 2.90995 10.5197 3.13908C10.8308 3.37647 11.1966 3.74086 11.7279 4.27212L12.3908 3.60921ZM7.96244 4.27212C8.49369 3.74086 8.8595 3.37647 9.17062 3.13908C9.47094 2.90995 9.66456 2.84375 9.84513 2.84375V1.90625C9.37719 1.90625 8.98562 2.10099 8.60194 2.39375C8.22906 2.67826 7.812 3.09669 7.2995 3.60921L7.96244 4.27212ZM9.43856 10.9898L5.01018 6.56145L4.34727 7.22437L8.77563 11.6528L9.43856 10.9898Z" fill="#1F2329"/>
+<path d="M6.125 13.625H13.625" stroke="#1F2329" stroke-linecap="round"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_header_column.svg b/frontend/resources/flowy_icons/16x/table_header_column.svg
new file mode 100644
index 0000000000000..2be55acd55229
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_header_column.svg
@@ -0,0 +1,4 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M14.415 13.1609C14.415 13.5549 14.3045 13.8625 14.0835 14.0836C13.8624 14.3046 13.5549 14.415 13.1608 14.415H2.83917C2.44514 14.415 2.13757 14.3046 1.91646 14.0836C1.69548 13.8625 1.585 13.5549 1.585 13.1609L1.585 2.83921C1.585 2.44518 1.69548 2.13761 1.91646 1.9165C2.13757 1.69553 2.44514 1.58504 2.83917 1.58504H13.1608C13.5549 1.58504 13.8624 1.69553 14.0835 1.9165C14.3045 2.13761 14.415 2.44518 14.415 2.83921V13.1609ZM9.9175 8.49754V13.4159H13.1594C13.2342 13.4159 13.2957 13.3918 13.3437 13.3438C13.3918 13.2957 13.4158 13.2343 13.4158 13.1594V8.49754H9.9175ZM9.9175 7.49837H13.4158V2.84066C13.4158 2.7658 13.3918 2.70434 13.3437 2.65629C13.2957 2.60823 13.2342 2.58421 13.1594 2.58421H9.9175V7.49837ZM8.91833 8.49754H5.40375V13.4159H8.91833V8.49754ZM8.91833 7.49837V2.58421H5.40375L5.40375 7.49837L8.91833 7.49837ZM4.40458 13.4159L4.40458 2.58421H2.84062C2.76576 2.58421 2.7043 2.60823 2.65625 2.65629C2.60819 2.70434 2.58416 2.7658 2.58416 2.84066L2.58416 13.1594C2.58416 13.2343 2.60819 13.2957 2.65625 13.3438C2.7043 13.3918 2.76576 13.4159 2.84062 13.4159H4.40458Z" fill="#1F2329"/>
+<rect x="2" y="14" width="12" height="3" transform="rotate(-90 2 14)" fill="#1F2329"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_header_row.svg b/frontend/resources/flowy_icons/16x/table_header_row.svg
new file mode 100644
index 0000000000000..19943b9f175f5
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_header_row.svg
@@ -0,0 +1,4 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M2.83913 14.415C2.4451 14.415 2.13753 14.3045 1.91642 14.0835C1.69545 13.8624 1.58496 13.5548 1.58496 13.1608V2.83913C1.58496 2.4451 1.69545 2.13753 1.91642 1.91642C2.13753 1.69545 2.4451 1.58496 2.83913 1.58496H13.1608C13.5548 1.58496 13.8624 1.69545 14.0835 1.91642C14.3045 2.13753 14.415 2.4451 14.415 2.83913V13.1608C14.415 13.5548 14.3045 13.8624 14.0835 14.0835C13.8624 14.3045 13.5548 14.415 13.1608 14.415H2.83913ZM7.50246 9.91746H2.58413V13.1593C2.58413 13.2342 2.60816 13.2957 2.65621 13.3437C2.70427 13.3918 2.76572 13.4158 2.84059 13.4158H7.50246V9.91746ZM8.50163 9.91746V13.4158H13.1593C13.2342 13.4158 13.2957 13.3918 13.3437 13.3437C13.3918 13.2957 13.4158 13.2342 13.4158 13.1593V9.91746H8.50163ZM7.50246 8.91829V5.40371H2.58413V8.91829H7.50246ZM8.50163 8.91829H13.4158V5.40371H8.50163V8.91829ZM2.58413 4.40454H13.4158V2.84059C13.4158 2.76572 13.3918 2.70427 13.3437 2.65621C13.2957 2.60816 13.2342 2.58413 13.1593 2.58413H2.84059C2.76572 2.58413 2.70427 2.60816 2.65621 2.65621C2.60816 2.70427 2.58413 2.76572 2.58413 2.84059V4.40454Z" fill="#1F2329"/>
+<rect x="2" y="2" width="12" height="3" fill="#1F2329"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_insert_above.svg b/frontend/resources/flowy_icons/16x/table_insert_above.svg
new file mode 100644
index 0000000000000..16ffb6a33ce62
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_insert_above.svg
@@ -0,0 +1,3 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M2.58413 8.96704V13.6593C2.58413 13.7342 2.60816 13.7957 2.65621 13.8437C2.70427 13.8918 2.76572 13.9158 2.84059 13.9158H13.1593C13.2342 13.9158 13.2957 13.8918 13.3437 13.8437C13.3918 13.7957 13.4158 13.7342 13.4158 13.6593V8.96704H2.58413ZM2.84059 14.915C2.49531 14.915 2.19968 14.792 1.95371 14.5462C1.70788 14.3002 1.58496 14.0046 1.58496 13.6593V3.34059C1.58496 2.99531 1.70753 2.69968 1.95267 2.45371C2.19781 2.20788 2.49253 2.08496 2.83684 2.08496H3.66913C3.80663 2.08496 3.92552 2.13378 4.02579 2.23142C4.12607 2.32906 4.17621 2.44475 4.17621 2.5785C4.17621 2.71531 4.12711 2.83378 4.02892 2.93392C3.93073 3.03406 3.81267 3.08413 3.67475 3.08413H2.84059C2.76572 3.08413 2.70427 3.10816 2.65621 3.15621C2.60816 3.20427 2.58413 3.26572 2.58413 3.34059V7.96788H13.4158V3.34059C13.4158 3.26572 13.3918 3.20427 13.3437 3.15621C13.2957 3.10816 13.2342 3.08413 13.1593 3.08413H12.3298C12.1929 3.08413 12.0751 3.0351 11.9762 2.93704C11.8772 2.83913 11.8277 2.72302 11.8277 2.58871C11.8277 2.45441 11.8763 2.33684 11.9737 2.236C12.0709 2.13531 12.1888 2.08496 12.3275 2.08496H13.1639C13.5103 2.08496 13.8054 2.20788 14.0493 2.45371C14.2931 2.69968 14.415 2.99531 14.415 3.34059V13.6593C14.415 14.0046 14.292 14.3002 14.0462 14.5462C13.8002 14.792 13.5046 14.915 13.1593 14.915H2.84059ZM7.50246 3.08413H6.24996C6.11204 3.08413 5.99461 3.0351 5.89767 2.93704C5.80086 2.83913 5.75246 2.72302 5.75246 2.58871C5.75246 2.45441 5.80086 2.33684 5.89767 2.236C5.99461 2.13531 6.11204 2.08496 6.24996 2.08496H7.50246V0.832461C7.50246 0.6976 7.55045 0.580932 7.64642 0.48246C7.74253 0.384127 7.85899 0.334961 7.99579 0.334961C8.1326 0.334961 8.25107 0.384127 8.35121 0.48246C8.45149 0.580932 8.50163 0.6976 8.50163 0.832461V2.08496H9.74996C9.88788 2.08496 10.006 2.13378 10.1043 2.23142C10.2025 2.32906 10.2516 2.44475 10.2516 2.5785C10.2516 2.71531 10.2025 2.83378 10.1043 2.93392C10.006 3.03406 9.88788 3.08413 9.74996 3.08413H8.50163V4.33246C8.50163 4.47052 8.45288 4.58864 8.35538 4.68684C8.25802 4.78503 8.14093 4.83413 8.00413 4.83413C7.86732 4.83413 7.74948 4.78503 7.65059 4.68684C7.55184 4.58864 7.50246 4.47052 7.50246 4.33246V3.08413Z" fill="black"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_insert_below.svg b/frontend/resources/flowy_icons/16x/table_insert_below.svg
new file mode 100644
index 0000000000000..acfa64a346da4
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_insert_below.svg
@@ -0,0 +1,3 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M13.4158 7.03288V2.34059C13.4158 2.26572 13.3918 2.20427 13.3437 2.15621C13.2957 2.10816 13.2342 2.08413 13.1593 2.08413H2.84059C2.76572 2.08413 2.70427 2.10816 2.65621 2.15621C2.60816 2.20427 2.58413 2.26572 2.58413 2.34059V7.03288H13.4158ZM2.836 13.915C2.48961 13.915 2.19447 13.792 1.95059 13.5462C1.70684 13.3002 1.58496 13.0046 1.58496 12.6593V2.34059C1.58496 1.99531 1.70788 1.69968 1.95371 1.45371C2.19968 1.20788 2.49531 1.08496 2.84059 1.08496H13.1593C13.5046 1.08496 13.8002 1.20788 14.0462 1.45371C14.292 1.69968 14.415 1.99531 14.415 2.34059V12.6593C14.415 13.0046 14.2924 13.3002 14.0473 13.5462C13.8021 13.792 13.5074 13.915 13.1631 13.915H12.3308C12.1933 13.915 12.0751 13.866 11.9762 13.7681C11.8772 13.67 11.8277 13.5539 11.8277 13.4195C11.8277 13.2852 11.8761 13.1677 11.9731 13.067C12.0699 12.9662 12.1873 12.9158 12.3252 12.9158H13.1593C13.2342 12.9158 13.2957 12.8918 13.3437 12.8437C13.3918 12.7957 13.4158 12.7342 13.4158 12.6593V8.03204H2.58413V12.6593C2.58413 12.7342 2.60816 12.7957 2.65621 12.8437C2.70427 12.8918 2.76572 12.9158 2.84059 12.9158H3.67017C3.80698 12.9158 3.92552 12.9646 4.02579 13.0623C4.12607 13.1599 4.17621 13.2756 4.17621 13.4093C4.17621 13.5461 4.12691 13.6646 4.02829 13.7648C3.92968 13.8649 3.81107 13.915 3.67246 13.915H2.836ZM8.00413 15.665C7.86732 15.665 7.74948 15.6159 7.65059 15.5177C7.55184 15.4195 7.50246 15.3014 7.50246 15.1635V13.915H6.24996C6.11204 13.915 5.99461 13.866 5.89767 13.7681C5.80086 13.67 5.75246 13.5539 5.75246 13.4195C5.75246 13.2852 5.80086 13.1677 5.89767 13.067C5.99461 12.9662 6.11204 12.9158 6.24996 12.9158H7.50246V11.6635C7.50246 11.5285 7.55045 11.4118 7.64642 11.3135C7.74253 11.215 7.85899 11.1658 7.99579 11.1658C8.1326 11.1658 8.25107 11.215 8.35121 11.3135C8.45149 11.4118 8.50163 11.5285 8.50163 11.6635V12.9158H9.74996C9.88788 12.9158 10.006 12.9646 10.1043 13.0623C10.2025 13.1599 10.2516 13.2756 10.2516 13.4093C10.2516 13.5461 10.2025 13.6646 10.1043 13.7648C10.006 13.8649 9.88788 13.915 9.74996 13.915H8.50163V15.1635C8.50163 15.3014 8.45288 15.4195 8.35538 15.5177C8.25802 15.6159 8.14093 15.665 8.00413 15.665Z" fill="black"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_insert_left.svg b/frontend/resources/flowy_icons/16x/table_insert_left.svg
new file mode 100644
index 0000000000000..3da61207b4cb9
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_insert_left.svg
@@ -0,0 +1,3 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M8.96709 13.4158H13.6594C13.7342 13.4158 13.7957 13.3918 13.8438 13.3437C13.8918 13.2957 13.9158 13.2342 13.9158 13.1593V2.84059C13.9158 2.76572 13.8918 2.70427 13.8438 2.65621C13.7957 2.60816 13.7342 2.58413 13.6594 2.58413H8.96709V13.4158ZM3.34063 14.415C2.99535 14.415 2.69973 14.2924 2.45376 14.0473C2.20792 13.8021 2.08501 13.5074 2.08501 13.1631V12.3308C2.08501 12.1933 2.13369 12.0744 2.23105 11.9741C2.32855 11.8738 2.44501 11.8237 2.58042 11.8237C2.71598 11.8237 2.83383 11.8728 2.93397 11.971C3.0341 12.0692 3.08417 12.1873 3.08417 12.3252V13.1593C3.08417 13.2342 3.1082 13.2957 3.15626 13.3437C3.20431 13.3918 3.26577 13.4158 3.34063 13.4158H7.96792V2.58413H3.34063C3.26577 2.58413 3.20431 2.60816 3.15626 2.65621C3.1082 2.70427 3.08417 2.76572 3.08417 2.84059V3.67017C3.08417 3.80697 3.03515 3.92482 2.93709 4.02371C2.83917 4.12274 2.72306 4.17225 2.58876 4.17225C2.45445 4.17225 2.33688 4.12357 2.23605 4.02621C2.13535 3.92899 2.08501 3.81107 2.08501 3.67246V2.836C2.08501 2.48961 2.20792 2.19447 2.45376 1.95059C2.69973 1.70684 2.99535 1.58496 3.34063 1.58496H13.6594C14.0047 1.58496 14.3003 1.70788 14.5463 1.95371C14.7921 2.19968 14.915 2.49531 14.915 2.84059V13.1593C14.915 13.5046 14.7921 13.8002 14.5463 14.0462C14.3003 14.292 14.0047 14.415 13.6594 14.415H3.34063ZM2.58876 10.2475C2.45445 10.2475 2.33688 10.1991 2.23605 10.1023C2.13535 10.0053 2.08501 9.88788 2.08501 9.74996V8.49746H0.836465C0.698548 8.49746 0.580493 8.44947 0.482298 8.3535C0.384104 8.25739 0.335007 8.14093 0.335007 8.00413C0.335007 7.86732 0.384104 7.74885 0.482298 7.64871C0.580493 7.54843 0.698548 7.49829 0.836465 7.49829H2.08501V6.24996C2.08501 6.11204 2.13369 5.99392 2.23105 5.89559C2.32855 5.79739 2.44501 5.74829 2.58042 5.74829C2.71598 5.74829 2.83383 5.79739 2.93397 5.89559C3.0341 5.99392 3.08417 6.11204 3.08417 6.24996V7.49829H4.33646C4.47147 7.49829 4.58813 7.54704 4.68647 7.64454C4.78494 7.74191 4.83417 7.85899 4.83417 7.99579C4.83417 8.1326 4.78494 8.25045 4.68647 8.34934C4.58813 8.44809 4.47147 8.49746 4.33646 8.49746H3.08417V9.74996C3.08417 9.88788 3.03515 10.0053 2.93709 10.1023C2.83917 10.1991 2.72306 10.2475 2.58876 10.2475Z" fill="black"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_insert_right.svg b/frontend/resources/flowy_icons/16x/table_insert_right.svg
new file mode 100644
index 0000000000000..2852bd389de57
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_insert_right.svg
@@ -0,0 +1,3 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M7.03292 2.58413H2.34063C2.26577 2.58413 2.20431 2.60816 2.15626 2.65621C2.1082 2.70427 2.08417 2.76572 2.08417 2.84059V13.1593C2.08417 13.2342 2.1082 13.2957 2.15626 13.3437C2.20431 13.3918 2.26577 13.4158 2.34063 13.4158H7.03292V2.58413ZM2.34063 14.415C1.99535 14.415 1.69973 14.292 1.45376 14.0462C1.20792 13.8002 1.08501 13.5046 1.08501 13.1593V2.84059C1.08501 2.49531 1.20792 2.19968 1.45376 1.95371C1.69973 1.70788 1.99535 1.58496 2.34063 1.58496H12.6594C13.0047 1.58496 13.3003 1.70753 13.5463 1.95267C13.7921 2.19781 13.915 2.49253 13.915 2.83684V3.66913C13.915 3.80663 13.866 3.92482 13.7681 4.02371C13.6701 4.12274 13.5539 4.17225 13.4196 4.17225C13.2853 4.17225 13.1678 4.12378 13.0671 4.02684C12.9663 3.93003 12.9158 3.81267 12.9158 3.67475V2.84059C12.9158 2.76572 12.8918 2.70427 12.8438 2.65621C12.7957 2.60816 12.7342 2.58413 12.6594 2.58413H8.03209V13.4158H12.6594C12.7342 13.4158 12.7957 13.3918 12.8438 13.3437C12.8918 13.2957 12.9158 13.2342 12.9158 13.1593V12.3298C12.9158 12.1929 12.9646 12.0744 13.0621 11.9741C13.1595 11.8738 13.2758 11.8237 13.4113 11.8237C13.5468 11.8237 13.6647 11.873 13.7648 11.9716C13.8649 12.0702 13.915 12.1889 13.915 12.3275V13.1639C13.915 13.5103 13.7921 13.8054 13.5463 14.0493C13.3003 14.2931 13.0047 14.415 12.6594 14.415H2.34063ZM13.4196 10.2475C13.2853 10.2475 13.1678 10.1991 13.0671 10.1023C12.9663 10.0053 12.9158 9.88788 12.9158 9.74996V8.49746H11.6675C11.5295 8.49746 11.4113 8.44947 11.3131 8.3535C11.2149 8.25739 11.1658 8.14093 11.1658 8.00413C11.1658 7.86732 11.2149 7.74885 11.3131 7.64871C11.4113 7.54843 11.5295 7.49829 11.6675 7.49829H12.9158V6.24996C12.9158 6.11204 12.9646 5.99392 13.0621 5.89559C13.1595 5.79739 13.2758 5.74829 13.4113 5.74829C13.5468 5.74829 13.6647 5.79739 13.7648 5.89559C13.8649 5.99392 13.915 6.11204 13.915 6.24996V7.49829H15.1675C15.3024 7.49829 15.419 7.54704 15.5175 7.64454C15.6158 7.74191 15.665 7.85899 15.665 7.99579C15.665 8.1326 15.6158 8.25045 15.5175 8.34934C15.419 8.44809 15.3024 8.49746 15.1675 8.49746H13.915V9.74996C13.915 9.88788 13.866 10.0053 13.7681 10.1023C13.6701 10.1991 13.5539 10.2475 13.4196 10.2475Z" fill="black"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_reorder_column.svg b/frontend/resources/flowy_icons/16x/table_reorder_column.svg
new file mode 100644
index 0000000000000..96142c1ecc31e
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_reorder_column.svg
@@ -0,0 +1,4 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M6.5 4.5V11.5" stroke="#8F959E" stroke-linecap="round"/>
+<path d="M9.5 4.5V11.5" stroke="#8F959E" stroke-linecap="round"/>
+</svg>
diff --git a/frontend/resources/flowy_icons/16x/table_reorder_row.svg b/frontend/resources/flowy_icons/16x/table_reorder_row.svg
new file mode 100644
index 0000000000000..9bd9dc2c14c00
--- /dev/null
+++ b/frontend/resources/flowy_icons/16x/table_reorder_row.svg
@@ -0,0 +1,4 @@
+<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
+<path d="M4.5 9.5H11.5" stroke="white" stroke-linecap="round"/>
+<path d="M4.5 6.5L11.5 6.5" stroke="white" stroke-linecap="round"/>
+</svg>
diff --git a/frontend/resources/translations/en.json b/frontend/resources/translations/en.json
index 8a4bd69e8c03b..5bd759937117e 100644
--- a/frontend/resources/translations/en.json
+++ b/frontend/resources/translations/en.json
@@ -1704,13 +1704,31 @@
       "insertDate": "Insert date",
       "emoji": "Emoji",
       "toggleList": "Toggle list",
-      "emptyToggleHeading": "Empty toggle heading {}. Click to add content",
-      "emptyToggleList": "Empty toggle list. Click to add content",
+      "emptyToggleHeading": "Empty toggle h{}. Click to add content.",
+      "emptyToggleList": "Empty toggle list. Click to add content.",
       "quoteList": "Quote list",
       "numberedList": "Numbered list",
       "bulletedList": "Bulleted list",
       "todoList": "Todo list",
       "callout": "Callout",
+      "simpleTable": {
+        "moreActions": {
+          "color": "Color",
+          "align": "Align",
+          "delete": "Delete",
+          "duplicate": "Duplicate",
+          "insertLeft": "Insert left",
+          "insertRight": "Insert right",
+          "insertAbove": "Insert above",
+          "insertBelow": "Insert below",
+          "headerColumn": "Header column",
+          "headerRow": "Header row",
+          "clearContents": "Clear contents"
+        },
+        "clickToAddNewRow": "Click to add a new row",
+        "clickToAddNewColumn": "Click to add a new column",
+        "clickToAddNewRowAndColumn": "Click to add a new row and column"
+      },
       "cover": {
         "changeCover": "Change Cover",
         "colors": "Colors",
