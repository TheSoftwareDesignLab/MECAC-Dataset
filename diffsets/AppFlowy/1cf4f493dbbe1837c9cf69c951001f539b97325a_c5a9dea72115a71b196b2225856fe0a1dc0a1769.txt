diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_page.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_page.dart
index f5be9246b3a38..cb07ebab35eb5 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_page.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_page.dart
@@ -127,7 +127,7 @@ class _AppFlowyEditorPageState extends State<AppFlowyEditorPage> {
   ];
 
   final List<ToolbarItem> toolbarItems = [
-    smartEditItem..isActive = onlyShowInSingleTextTypeSelectionAndExcludeTable,
+    smartEditItem..isActive = onlyShowInTextType,
     paragraphItem..isActive = onlyShowInSingleTextTypeSelectionAndExcludeTable,
     headingsToolbarItem
       ..isActive = onlyShowInSingleTextTypeSelectionAndExcludeTable,
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/image/unsplash_image_widget.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/image/unsplash_image_widget.dart
index 2a71f44f57740..949e946188e09 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/image/unsplash_image_widget.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/image/unsplash_image_widget.dart
@@ -1,7 +1,6 @@
-import 'package:flutter/material.dart';
-
 import 'package:appflowy/mobile/presentation/widgets/flowy_mobile_search_text_field.dart';
 import 'package:flowy_infra_ui/flowy_infra_ui.dart';
+import 'package:flutter/material.dart';
 import 'package:unsplash_client/unsplash_client.dart';
 
 const _accessKeyA = 'YyD-LbW5bVolHWZBq5fWRM_';
@@ -154,7 +153,7 @@ class _UnsplashImagesState extends State<_UnsplashImages> {
           photo: photo,
           isSelected: index == _selectedPhotoIndex,
           onTap: () {
-            widget.onSelectUnsplashImage(photo.urls.regular.toString());
+            widget.onSelectUnsplashImage(photo.urls.full.toString());
             setState(() => _selectedPhotoIndex = index);
           },
         );
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_bloc.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_bloc.dart
new file mode 100644
index 0000000000000..077b0117ddf06
--- /dev/null
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_bloc.dart
@@ -0,0 +1,221 @@
+import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/service/ai_client.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_action.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/plugins.dart';
+import 'package:appflowy/startup/startup.dart';
+import 'package:appflowy/user/application/ai_service.dart';
+import 'package:appflowy_backend/log.dart';
+import 'package:appflowy_editor/appflowy_editor.dart' hide Log;
+import 'package:flutter/foundation.dart';
+import 'package:flutter_bloc/flutter_bloc.dart';
+import 'package:freezed_annotation/freezed_annotation.dart';
+
+part 'smart_edit_bloc.freezed.dart';
+
+class SmartEditBloc extends Bloc<SmartEditEvent, SmartEditState> {
+  SmartEditBloc({
+    required this.node,
+    required this.editorState,
+    required this.action,
+  }) : super(
+          SmartEditState.initial(action),
+        ) {
+    on<SmartEditEvent>((event, emit) async {
+      await event.when(
+        initial: () async {
+          aiRepository = await getIt.getAsync<AIRepository>();
+        },
+        started: () async {
+          await _requestCompletions();
+        },
+        rewrite: () async {
+          await _requestCompletions(rewrite: true);
+        },
+        replace: () async {
+          await _replace();
+          await _exit();
+        },
+        insertBelow: () async {
+          await _insertBelow();
+          await _exit();
+        },
+        cancel: () async {
+          isCanceled = true;
+          await _exit();
+        },
+        update: (result, isLoading) async {
+          emit(
+            state.copyWith(
+              result: result,
+              loading: isLoading,
+            ),
+          );
+        },
+      );
+    });
+  }
+
+  final Node node;
+  final EditorState editorState;
+  final SmartEditAction action;
+
+  late final AIRepository aiRepository;
+
+  bool isCanceled = false;
+
+  Future<void> _requestCompletions({
+    bool rewrite = false,
+  }) async {
+    if (rewrite) {
+      add(const SmartEditEvent.update('', true));
+    }
+
+    Log.info('[smart_edit] request completions');
+
+    final content = node.attributes[SmartEditBlockKeys.content] as String;
+    await aiRepository.streamCompletion(
+      text: content,
+      completionType: completionTypeFromInt(state.action),
+      onStart: () async {
+        if (isCanceled) {
+          return;
+        }
+        Log.info('[smart_edit] start generating');
+        add(const SmartEditEvent.update('', true));
+      },
+      onProcess: (text) async {
+        if (isCanceled) {
+          return;
+        }
+        // only display the log in debug mode
+        if (kDebugMode) {
+          Log.debug('[smart_edit] onProcess: $text');
+        }
+        final newResult = state.result + text;
+        add(SmartEditEvent.update(newResult, false));
+      },
+      onEnd: () async {
+        if (isCanceled) {
+          return;
+        }
+        Log.info('[smart_edit] end generating');
+        add(SmartEditEvent.update('${state.result}\n', false));
+      },
+      onError: (error) async {
+        if (isCanceled) {
+          return;
+        }
+        Log.info('[smart_edit] onError: $error');
+        await _exit();
+      },
+    );
+  }
+
+  Future<void> _insertBelow() async {
+    // check the selection is not empty
+    final selection = editorState.selection?.normalized;
+    if (selection == null) {
+      return;
+    }
+    // return if the result is empty
+    final result = state.result.trim();
+    if (result.isEmpty) {
+      return;
+    }
+    final insertedText = result.split('\n')
+      ..removeWhere((element) => element.isEmpty);
+    final transaction = editorState.transaction;
+    // todo: keep the style of the current node
+    transaction.insertNodes(
+      selection.end.path.next,
+      insertedText.map(
+        (e) => paragraphNode(
+          text: e,
+        ),
+      ),
+    );
+    final start = Position(path: selection.end.path.next);
+    final end = Position(
+      path: [selection.end.path.next.first + insertedText.length],
+    );
+    transaction.afterSelection = Selection(
+      start: start,
+      end: end,
+    );
+    await editorState.apply(transaction);
+  }
+
+  Future<void> _replace() async {
+    final result = state.result.trim();
+    if (result.isEmpty) {
+      return;
+    }
+
+    final selection = editorState.selection?.normalized;
+    if (selection == null) {
+      return;
+    }
+    final nodes = editorState.getNodesInSelection(selection);
+    if (nodes.isEmpty || !nodes.every((element) => element.delta != null)) {
+      return;
+    }
+
+    final replaceTexts = result.split('\n')
+      ..removeWhere((element) => element.isEmpty);
+    final transaction = editorState.transaction;
+    transaction.replaceTexts(
+      nodes,
+      selection,
+      replaceTexts,
+    );
+    await editorState.apply(transaction);
+
+    int endOffset = replaceTexts.last.length;
+    if (replaceTexts.length == 1) {
+      endOffset += selection.start.offset;
+    }
+    final end = Position(
+      path: [selection.start.path.first + replaceTexts.length - 1],
+      offset: endOffset,
+    );
+    editorState.selection = Selection(
+      start: selection.start,
+      end: end,
+    );
+  }
+
+  Future<void> _exit() async {
+    final transaction = editorState.transaction..deleteNode(node);
+    await editorState.apply(
+      transaction,
+      options: const ApplyOptions(
+        recordUndo: false,
+      ),
+    );
+  }
+}
+
+@freezed
+class SmartEditEvent with _$SmartEditEvent {
+  const factory SmartEditEvent.initial() = _Initial;
+  const factory SmartEditEvent.started() = _Started;
+  const factory SmartEditEvent.rewrite() = _Rewrite;
+  const factory SmartEditEvent.replace() = _Replace;
+  const factory SmartEditEvent.insertBelow() = _InsertBelow;
+  const factory SmartEditEvent.cancel() = _Cancel;
+  const factory SmartEditEvent.update(String result, bool isLoading) = _Update;
+}
+
+@freezed
+class SmartEditState with _$SmartEditState {
+  const factory SmartEditState({
+    required bool loading,
+    required String result,
+    required SmartEditAction action,
+  }) = _SmartEditState;
+
+  factory SmartEditState.initial(SmartEditAction action) => SmartEditState(
+        loading: true,
+        action: action,
+        result: '',
+      );
+}
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_node_widget.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_node_widget.dart
index 04e83fb758bf7..99b23008c4321 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_node_widget.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_node_widget.dart
@@ -1,22 +1,15 @@
 import 'dart:async';
 
 import 'package:appflowy/generated/locale_keys.g.dart';
-import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/service/ai_client.dart';
-import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/service/error.dart';
-import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/widgets/discard_dialog.dart';
 import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_action.dart';
-import 'package:appflowy/startup/startup.dart';
-import 'package:appflowy/user/application/ai_service.dart';
-import 'package:appflowy/workspace/presentation/home/toast.dart';
+import 'package:appflowy/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_bloc.dart';
+import 'package:appflowy/workspace/presentation/widgets/dialogs.dart';
 import 'package:appflowy_editor/appflowy_editor.dart';
 import 'package:appflowy_popover/appflowy_popover.dart';
 import 'package:easy_localization/easy_localization.dart';
 import 'package:flowy_infra_ui/flowy_infra_ui.dart';
 import 'package:flutter/material.dart';
-import 'package:http/http.dart' as http;
-import 'package:provider/provider.dart';
-
-import 'ai_limit_dialog.dart';
+import 'package:flutter_bloc/flutter_bloc.dart';
 
 class SmartEditBlockKeys {
   const SmartEditBlockKeys._();
@@ -29,6 +22,8 @@ class SmartEditBlockKeys {
   static const action = 'action';
 
   /// The input of the smart edit.
+  ///
+  /// The content is a string that using '\n\n' as separator.
   static const content = 'content';
 }
 
@@ -85,242 +80,203 @@ class SmartEditBlockComponentWidget extends BlockComponentStatefulWidget {
 class _SmartEditBlockComponentWidgetState
     extends State<SmartEditBlockComponentWidget> {
   final popoverController = PopoverController();
-  final key = GlobalKey(debugLabel: 'smart_edit_input');
 
   late final editorState = context.read<EditorState>();
+  late final action = SmartEditAction
+      .values[widget.node.attributes[SmartEditBlockKeys.action] as int];
+  late SmartEditBloc smartEditBloc;
 
   @override
   void initState() {
     super.initState();
 
-    // todo: don't use a popover to show the content of the smart edit.
     WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
       popoverController.show();
     });
+
+    smartEditBloc = SmartEditBloc(
+      node: widget.node,
+      editorState: editorState,
+      action: action,
+    )..add(const SmartEditEvent.initial());
+  }
+
+  @override
+  void dispose() {
+    smartEditBloc.close();
+
+    super.dispose();
   }
 
   @override
   void reassemble() {
     super.reassemble();
 
-    final transaction = editorState.transaction..deleteNode(widget.node);
-    editorState.apply(transaction);
+    _removeNode();
   }
 
   @override
   Widget build(BuildContext context) {
     final width = _getEditorWidth();
 
-    return AppFlowyPopover(
-      controller: popoverController,
-      direction: PopoverDirection.bottomWithLeftAligned,
-      triggerActions: PopoverTriggerFlags.none,
-      margin: EdgeInsets.zero,
-      constraints: BoxConstraints(maxWidth: width),
-      child: const SizedBox(
-        width: double.infinity,
-      ),
-      canClose: () async {
-        final completer = Completer<bool>();
-        final state = key.currentState as _SmartEditInputWidgetState;
-        if (state.result.isEmpty) {
-          completer.complete(true);
-        } else {
-          await showDialog(
-            context: context,
-            builder: (context) {
-              return DiscardDialog(
-                onConfirm: () => completer.complete(true),
-                onCancel: () => completer.complete(false),
-              );
-            },
+    return BlocProvider.value(
+      value: smartEditBloc,
+      child: AppFlowyPopover(
+        controller: popoverController,
+        direction: PopoverDirection.bottomWithLeftAligned,
+        triggerActions: PopoverTriggerFlags.none,
+        margin: EdgeInsets.zero,
+        offset: const Offset(40, 0), // align the editor block
+        windowPadding: EdgeInsets.zero,
+        constraints: BoxConstraints(maxWidth: width),
+        canClose: () async {
+          final completer = Completer<bool>();
+          final state = smartEditBloc.state;
+          if (state.result.isEmpty) {
+            completer.complete(true);
+          } else {
+            await showCancelAndConfirmDialog(
+              context: context,
+              title: LocaleKeys.document_plugins_discardResponse.tr(),
+              description: '',
+              confirmLabel: LocaleKeys.button_discard.tr(),
+              onConfirm: () => completer.complete(true),
+              onCancel: () => completer.complete(false),
+            );
+          }
+          return completer.future;
+        },
+        onClose: _removeNode,
+        popupBuilder: (BuildContext popoverContext) {
+          return BlocProvider.value(
+            // request the result when opening the popover
+            value: smartEditBloc..add(const SmartEditEvent.started()),
+            child: const SmartEditInputContent(),
           );
-        }
-        return completer.future;
-      },
-      onClose: () {
-        final transaction = editorState.transaction..deleteNode(widget.node);
-        editorState.apply(transaction);
-      },
-      popupBuilder: (BuildContext popoverContext) {
-        return SmartEditInputWidget(
-          key: key,
-          node: widget.node,
-          editorState: editorState,
-        );
-      },
+        },
+        child: const SizedBox(
+          width: double.infinity,
+        ),
+      ),
     );
   }
 
   double _getEditorWidth() {
     var width = double.infinity;
-    final editorSize = editorState.renderBox?.size;
-    final padding = editorState.editorStyle.padding;
-    if (editorSize != null) {
-      width = editorSize.width - padding.left - padding.right;
-    }
+    try {
+      final editorSize = editorState.renderBox?.size;
+      final padding = editorState.editorStyle.padding;
+      if (editorSize != null) {
+        width = editorSize.width - padding.left - padding.right;
+      }
+    } catch (_) {}
     return width;
   }
-}
-
-class SmartEditInputWidget extends StatefulWidget {
-  const SmartEditInputWidget({
-    required super.key,
-    required this.node,
-    required this.editorState,
-  });
 
-  final Node node;
-  final EditorState editorState;
-
-  @override
-  State<SmartEditInputWidget> createState() => _SmartEditInputWidgetState();
-}
-
-class _SmartEditInputWidgetState extends State<SmartEditInputWidget> {
-  final focusNode = FocusNode();
-  final client = http.Client();
-
-  SmartEditAction get action => SmartEditAction.from(
-        widget.node.attributes[SmartEditBlockKeys.action],
-      );
-  String get content => widget.node.attributes[SmartEditBlockKeys.content];
-  EditorState get editorState => widget.editorState;
-
-  bool loading = true;
-  String result = '';
-
-  @override
-  void initState() {
-    super.initState();
-
-    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
-      editorState.service.keyboardService?.disable();
-      // editorState.selection = null;
-    });
-
-    focusNode.requestFocus();
-    _requestCompletions();
+  void _removeNode() {
+    final transaction = editorState.transaction..deleteNode(widget.node);
+    editorState.apply(transaction);
   }
+}
 
-  @override
-  void dispose() {
-    client.close();
-    focusNode.dispose();
-    super.dispose();
-  }
+class SmartEditInputContent extends StatelessWidget {
+  const SmartEditInputContent({super.key});
 
   @override
   Widget build(BuildContext context) {
-    return Card(
-      elevation: 5,
-      color: Theme.of(context).colorScheme.surface,
-      child: Container(
-        margin: const EdgeInsets.all(10),
-        child: _buildSmartEditPanel(context),
-      ),
+    return BlocBuilder<SmartEditBloc, SmartEditState>(
+      builder: (context, state) {
+        return Card(
+          elevation: 5,
+          color: Theme.of(context).colorScheme.surface,
+          margin: EdgeInsets.zero,
+          shape: RoundedRectangleBorder(
+            borderRadius: BorderRadius.circular(10),
+          ),
+          child: Container(
+            margin: const EdgeInsets.all(16),
+            child: Column(
+              mainAxisSize: MainAxisSize.min,
+              crossAxisAlignment: CrossAxisAlignment.start,
+              children: [
+                FlowyText.medium(
+                  state.action.name,
+                  fontSize: 14,
+                ),
+                const VSpace(16),
+                state.loading
+                    ? _buildLoadingWidget(context)
+                    : _buildResultWidget(context, state),
+                const VSpace(16),
+                const _SmartEditFooterWidget(),
+              ],
+            ),
+          ),
+        );
+      },
     );
   }
 
-  Widget _buildSmartEditPanel(BuildContext context) {
-    return Column(
-      mainAxisSize: MainAxisSize.min,
-      crossAxisAlignment: CrossAxisAlignment.start,
-      children: [
-        FlowyText.medium(
-          action.name,
-          fontSize: 14,
-        ),
-        // _buildHeaderWidget(context),
-        const Space(0, 10),
-        _buildResultWidget(context),
-        const Space(0, 10),
-        _buildInputFooterWidget(context),
-      ],
+  Widget _buildResultWidget(BuildContext context, SmartEditState state) {
+    // todo: replace it with appflowy_editor
+    return Flexible(
+      child: FlowyText.regular(
+        state.result,
+        maxLines: null,
+      ),
     );
   }
 
-  Widget _buildResultWidget(BuildContext context) {
-    final loadingWidget = Padding(
-      padding: const EdgeInsets.symmetric(horizontal: 4.0),
-      child: SizedBox.fromSize(
-        size: const Size.square(14),
-        child: const CircularProgressIndicator(),
-      ),
-    );
-    if (result.isEmpty || loading) {
-      return loadingWidget;
-    }
-    return Flexible(
-      child: Text(
-        result,
+  Widget _buildLoadingWidget(BuildContext context) {
+    return const Padding(
+      padding: EdgeInsets.symmetric(horizontal: 4.0),
+      child: SizedBox.square(
+        dimension: 14,
+        child: CircularProgressIndicator(
+          strokeWidth: 2.0,
+        ),
       ),
     );
   }
+}
 
-  Widget _buildInputFooterWidget(BuildContext context) {
+class _SmartEditFooterWidget extends StatelessWidget {
+  const _SmartEditFooterWidget();
+
+  @override
+  Widget build(BuildContext context) {
     return Row(
       children: [
-        FlowyRichTextButton(
-          TextSpan(
-            children: [
-              TextSpan(
-                text: LocaleKeys.document_plugins_autoGeneratorRewrite.tr(),
-                style: Theme.of(context).textTheme.bodyMedium,
-              ),
-            ],
-          ),
-          onPressed: () => _requestCompletions(rewrite: true),
+        OutlinedRoundedButton(
+          text: LocaleKeys.document_plugins_autoGeneratorRewrite.tr(),
+          onTap: () =>
+              context.read<SmartEditBloc>().add(const SmartEditEvent.rewrite()),
         ),
-        const Space(10, 0),
-        FlowyRichTextButton(
-          TextSpan(
-            children: [
-              TextSpan(
-                text: LocaleKeys.button_replace.tr(),
-                style: Theme.of(context).textTheme.bodyMedium,
-              ),
-            ],
-          ),
-          onPressed: () async {
-            await _onReplace();
-            await _onExit();
-          },
+        const HSpace(10),
+        OutlinedRoundedButton(
+          text: LocaleKeys.button_replace.tr(),
+          onTap: () =>
+              context.read<SmartEditBloc>().add(const SmartEditEvent.replace()),
         ),
-        const Space(10, 0),
-        FlowyRichTextButton(
-          TextSpan(
-            children: [
-              TextSpan(
-                text: LocaleKeys.button_insertBelow.tr(),
-                style: Theme.of(context).textTheme.bodyMedium,
-              ),
-            ],
-          ),
-          onPressed: () async {
-            await _onInsertBelow();
-            await _onExit();
-          },
+        const HSpace(10),
+        OutlinedRoundedButton(
+          text: LocaleKeys.button_insertBelow.tr(),
+          onTap: () => context
+              .read<SmartEditBloc>()
+              .add(const SmartEditEvent.insertBelow()),
         ),
-        const Space(10, 0),
-        FlowyRichTextButton(
-          TextSpan(
-            children: [
-              TextSpan(
-                text: LocaleKeys.button_cancel.tr(),
-                style: Theme.of(context).textTheme.bodyMedium,
-              ),
-            ],
-          ),
-          onPressed: () async => _onExit(),
+        const HSpace(10),
+        OutlinedRoundedButton(
+          text: LocaleKeys.button_cancel.tr(),
+          onTap: () =>
+              context.read<SmartEditBloc>().add(const SmartEditEvent.cancel()),
         ),
-        const Spacer(),
         Expanded(
           child: Container(
             alignment: Alignment.centerRight,
-            child: FlowyText.regular(
+            child: Text(
               LocaleKeys.document_plugins_warning.tr(),
-              color: Theme.of(context).hintColor,
+              style: TextStyle(color: Theme.of(context).hintColor),
               overflow: TextOverflow.ellipsis,
             ),
           ),
@@ -328,113 +284,4 @@ class _SmartEditInputWidgetState extends State<SmartEditInputWidget> {
       ],
     );
   }
-
-  Future<void> _onReplace() async {
-    final selection = editorState.selection?.normalized;
-    if (selection == null) {
-      return;
-    }
-    final nodes = editorState.getNodesInSelection(selection);
-    if (nodes.isEmpty || !nodes.every((element) => element.delta != null)) {
-      return;
-    }
-    final replaceTexts = result.split('\n')
-      ..removeWhere((element) => element.isEmpty);
-    final transaction = editorState.transaction;
-    transaction.replaceTexts(
-      nodes,
-      selection,
-      replaceTexts,
-    );
-    await editorState.apply(transaction);
-
-    int endOffset = replaceTexts.last.length;
-    if (replaceTexts.length == 1) {
-      endOffset += selection.start.offset;
-    }
-
-    editorState.selection = Selection(
-      start: selection.start,
-      end: Position(
-        path: [selection.start.path.first + replaceTexts.length - 1],
-        offset: endOffset,
-      ),
-    );
-  }
-
-  Future<void> _onInsertBelow() async {
-    final selection = editorState.selection?.normalized;
-    if (selection == null) {
-      return;
-    }
-    final insertedText = result.split('\n')
-      ..removeWhere((element) => element.isEmpty);
-    final transaction = editorState.transaction;
-    transaction.insertNodes(
-      selection.end.path.next,
-      insertedText.map(
-        (e) => paragraphNode(
-          text: e,
-        ),
-      ),
-    );
-    transaction.afterSelection = Selection(
-      start: Position(path: selection.end.path.next),
-      end: Position(
-        path: [selection.end.path.next.first + insertedText.length],
-      ),
-    );
-    await editorState.apply(transaction);
-  }
-
-  Future<void> _onExit() async {
-    final transaction = editorState.transaction..deleteNode(widget.node);
-    return editorState.apply(
-      transaction,
-      options: const ApplyOptions(
-        recordUndo: false,
-      ),
-    );
-  }
-
-  Future<void> _requestCompletions({bool rewrite = false}) async {
-    if (rewrite) {
-      setState(() {
-        loading = true;
-        result = "";
-      });
-    }
-    final aiResitory = await getIt.getAsync<AIRepository>();
-    await aiResitory.streamCompletion(
-      text: content,
-      completionType: completionTypeFromInt(action),
-      onStart: () async {
-        setState(() {
-          loading = false;
-        });
-      },
-      onProcess: (text) async {
-        setState(() {
-          result += text;
-        });
-      },
-      onEnd: () async {
-        setState(() {
-          result += '\n';
-        });
-      },
-      onError: (error) async {
-        if (error.isLimitExceeded) {
-          showAILimitDialog(context, error.message);
-        } else {
-          showSnackBarMessage(
-            context,
-            error.message,
-            showCancel: true,
-          );
-        }
-        await _onExit();
-      },
-    );
-  }
 }
diff --git a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_toolbar_item.dart b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_toolbar_item.dart
index f50dcd5fbd08d..b8d92fe6b3c8a 100644
--- a/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_toolbar_item.dart
+++ b/frontend/appflowy_flutter/lib/plugins/document/presentation/editor_plugins/openai/widgets/smart_edit_toolbar_item.dart
@@ -6,7 +6,7 @@ import 'package:appflowy/user/application/user_service.dart';
 import 'package:appflowy/workspace/presentation/home/toast.dart';
 import 'package:appflowy/workspace/presentation/widgets/pop_up_action.dart';
 import 'package:appflowy_backend/protobuf/flowy-user/protobuf.dart';
-import 'package:appflowy_editor/appflowy_editor.dart';
+import 'package:appflowy_editor/appflowy_editor.dart' hide Log;
 import 'package:appflowy_popover/appflowy_popover.dart';
 import 'package:easy_localization/easy_localization.dart';
 import 'package:flowy_infra_ui/flowy_infra_ui.dart';
@@ -59,6 +59,7 @@ class _SmartEditActionListState extends State<SmartEditActionList> {
   @override
   Widget build(BuildContext context) {
     return PopoverActionList<SmartEditActionWrapper>(
+      offset: const Offset(-5, 5),
       direction: PopoverDirection.bottomWithLeftAligned,
       actions: SmartEditAction.values
           .map((action) => SmartEditActionWrapper(action))
@@ -120,10 +121,10 @@ class _SmartEditActionListState extends State<SmartEditActionList> {
     if (selection == null) {
       return;
     }
-    final input = widget.editorState.getTextInSelection(selection);
-    while (input.last.isEmpty) {
-      input.removeLast();
-    }
+
+    // support multiple paragraphs
+    final input = _getTextInSelection(selection);
+
     final transaction = widget.editorState.transaction;
     transaction.insertNode(
       selection.normalized.end.path.next,
@@ -140,4 +141,24 @@ class _SmartEditActionListState extends State<SmartEditActionList> {
       withUpdateSelection: false,
     );
   }
+
+  List<String> _getTextInSelection(
+    Selection selection,
+  ) {
+    final res = <String>[];
+    if (selection.isCollapsed) {
+      return res;
+    }
+    final nodes = widget.editorState.getNodesInSelection(selection);
+    for (final node in nodes) {
+      final delta = node.delta;
+      if (delta == null) {
+        continue;
+      }
+      final startIndex = node == nodes.first ? selection.startIndex : 0;
+      final endIndex = node == nodes.last ? selection.endIndex : delta.length;
+      res.add(delta.slice(startIndex, endIndex).toPlainText());
+    }
+    return res;
+  }
 }
diff --git a/frontend/appflowy_flutter/lib/workspace/presentation/widgets/dialogs.dart b/frontend/appflowy_flutter/lib/workspace/presentation/widgets/dialogs.dart
index e993c5f79e949..3547fb988b9ea 100644
--- a/frontend/appflowy_flutter/lib/workspace/presentation/widgets/dialogs.dart
+++ b/frontend/appflowy_flutter/lib/workspace/presentation/widgets/dialogs.dart
@@ -466,6 +466,7 @@ Future<void> showCancelAndConfirmDialog({
   required String title,
   required String description,
   VoidCallback? onConfirm,
+  VoidCallback? onCancel,
   String? confirmLabel,
 }) {
   return showDialog(
@@ -483,6 +484,7 @@ Future<void> showCancelAndConfirmDialog({
             onConfirm: () => onConfirm?.call(),
             confirmLabel: confirmLabel,
             confirmButtonColor: Theme.of(context).colorScheme.primary,
+            onCancel: () => onCancel?.call(),
           ),
         ),
       );
