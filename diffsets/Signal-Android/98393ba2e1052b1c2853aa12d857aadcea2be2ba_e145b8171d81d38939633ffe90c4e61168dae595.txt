diff --git a/src/org/thoughtcrime/securesms/ConversationActivity.java b/src/org/thoughtcrime/securesms/ConversationActivity.java
index 49d64a0c62e..cfec8a0c87c 100644
--- a/src/org/thoughtcrime/securesms/ConversationActivity.java
+++ b/src/org/thoughtcrime/securesms/ConversationActivity.java
@@ -266,7 +266,7 @@ protected void onPause() {
     super.onConfigurationChanged(newConfig);
     composeText.setTransport(sendButton.getSelectedTransport());
     quickAttachmentDrawer.onConfigurationChanged();
-    if (container.getCurrentInput() == emojiDrawer) container.hideAttachedInput();
+    if (container.getCurrentInput() == emojiDrawer) container.hideAttachedInput(true);
   }
 
   @Override
diff --git a/src/org/thoughtcrime/securesms/components/InputAwareLayout.java b/src/org/thoughtcrime/securesms/components/InputAwareLayout.java
index 5436ec91502..9906ffc02b0 100644
--- a/src/org/thoughtcrime/securesms/components/InputAwareLayout.java
+++ b/src/org/thoughtcrime/securesms/components/InputAwareLayout.java
@@ -26,7 +26,7 @@ public InputAwareLayout(Context context, AttributeSet attrs, int defStyle) {
   }
 
   @Override public void onKeyboardShown() {
-    hideAttachedInput();
+    hideAttachedInput(true);
   }
 
   public void show(@NonNull final EditText imeTarget, @NonNull final InputView input) {
@@ -52,11 +52,11 @@ public InputView getCurrentInput() {
 
   public void hideCurrentInput(EditText imeTarget) {
     if (isKeyboardOpen()) hideSoftkey(imeTarget, null);
-    else                  hideAttachedInput();
+    else                  hideAttachedInput(false);
   }
 
-  public void hideAttachedInput() {
-    if (current != null) current.hide(true);
+  public void hideAttachedInput(boolean instant) {
+    if (current != null) current.hide(instant);
     current = null;
   }
 
@@ -67,7 +67,7 @@ public boolean isInputOpen() {
   public void showSoftkey(final EditText inputTarget) {
     postOnKeyboardOpen(new Runnable() {
       @Override public void run() {
-        hideAttachedInput();
+        hideAttachedInput(true);
       }
     });
     inputTarget.post(new Runnable() {
diff --git a/src/org/thoughtcrime/securesms/components/camera/QuickAttachmentDrawer.java b/src/org/thoughtcrime/securesms/components/camera/QuickAttachmentDrawer.java
index 291e0a6984f..c3ce1f00fc4 100644
--- a/src/org/thoughtcrime/securesms/components/camera/QuickAttachmentDrawer.java
+++ b/src/org/thoughtcrime/securesms/components/camera/QuickAttachmentDrawer.java
@@ -50,6 +50,7 @@ public class QuickAttachmentDrawer extends ViewGroup implements InputView {
   private int                       rotation;
   private AttachmentDrawerListener  listener;
   private int                       halfExpandedHeight;
+  private ObjectAnimator            animator;
 
   private DrawerState drawerState      = DrawerState.COLLAPSED;
   private Rect        drawChildrenRect = new Rect();
@@ -108,7 +109,7 @@ public void onConfigurationChanged() {
         quickCamera.onPause();
       }
       updateControlsView();
-      setDrawerStateAndUpdate(drawerState);
+      setDrawerStateAndUpdate(drawerState, true);
     }
   }
 
@@ -152,6 +153,10 @@ private void updateHalfExpandedAnchorPoint() {
 
   @Override
   protected void onLayout(boolean changed, int l, int t, int r, int b) {
+    if (changed && drawerState == DrawerState.FULL_EXPANDED) {
+      setSlideOffset(getMeasuredHeight());
+    }
+
     final int paddingLeft = getPaddingLeft();
     final int paddingTop  = getPaddingTop();
 
@@ -281,6 +286,10 @@ private void setDrawerState(DrawerState drawerState) {
       fullScreenButton.setImageResource(R.drawable.quick_camera_fullscreen);
       break;
     case HALF_EXPANDED:
+      if (isLandscape()) {
+        setDrawerState(DrawerState.FULL_EXPANDED);
+        return;
+      }
       fullScreenButton.setImageResource(R.drawable.quick_camera_fullscreen);
       break;
     case FULL_EXPANDED:
@@ -471,14 +480,18 @@ private int computeCoverTopPosition(int slideOffset) {
   }
 
   private void slideTo(int slideOffset, boolean forceInstant) {
+    if (animator != null) {
+      animator.cancel();
+      animator = null;
+    }
+
     if (!forceInstant) {
-      ObjectAnimator animator = ObjectAnimator.ofInt(this, "slideOffset", this.slideOffset, slideOffset);
+      animator = ObjectAnimator.ofInt(this, "slideOffset", this.slideOffset, slideOffset);
       animator.setInterpolator(new FastOutSlowInInterpolator());
       animator.setDuration(400);
       animator.start();
       ViewCompat.postInvalidateOnAnimation(this);
     } else {
-      Log.w(TAG, "quick sliding to " + slideOffset);
       this.slideOffset = slideOffset;
       requestLayout();
       invalidate();
