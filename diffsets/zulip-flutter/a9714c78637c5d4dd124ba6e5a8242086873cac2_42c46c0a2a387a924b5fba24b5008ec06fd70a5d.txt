diff --git a/lib/widgets/scrolling.dart b/lib/widgets/scrolling.dart
index 9b58a9fd5a..e31969948f 100644
--- a/lib/widgets/scrolling.dart
+++ b/lib/widgets/scrolling.dart
@@ -56,6 +56,31 @@ class ScrollToEndActivity extends DrivenScrollActivity {
     required super.curve,
     required super.vsync,
   });
+
+  ScrollPosition get _position => delegate as ScrollPosition;
+
+  @override
+  bool applyMoveTo(double value) {
+    bool done = false;
+    if (value > _position.maxScrollExtent) {
+      // The activity has reached the end.
+      // Stop at exactly the end, rather than causing overscroll.
+      // Possibly some overscroll would actually be desirable, but:
+      // TODO(upstream) stretch-overscroll seems busted, inverted:
+      //   Is this formula (from [_StretchController.absorbImpact] really right?
+      //     _stretchSizeTween.end =
+      //       math.min(_stretchIntensity + (_flingFriction / velocity), 1.0);
+      //   Seems to take low velocity to the largest stretch, and high velocity
+      //   to the smallest stretch.
+      //   Specifically, a very slow fling produces a very large stretch,
+      //   while other flings produce small stretches that vary little
+      //   between modest speed (~300 px/s) and top speed (8000 px/s).
+      value = _position.maxScrollExtent;
+      done = true;
+    }
+    if (!super.applyMoveTo(value)) return false;
+    return !done;
+  }
 }
 
 /// A version of [ScrollPosition] adapted for the Zulip message list,
diff --git a/test/widgets/scrolling_test.dart b/test/widgets/scrolling_test.dart
index 2a1e94a5bd..f84adb6972 100644
--- a/test/widgets/scrolling_test.dart
+++ b/test/widgets/scrolling_test.dart
@@ -296,6 +296,44 @@ void main() {
 
         debugDefaultTargetPlatformOverride = null;
       });
+
+      testWidgets('on overscroll, stop', (tester) async {
+        debugDefaultTargetPlatformOverride = TargetPlatform.iOS;
+        await prepare(tester, topHeight: 400, bottomHeight: 1000);
+
+        // Scroll up…
+        position.jumpTo(400);
+        await tester.pump();
+        check(position.extentAfter).equals(600);
+
+        // … then invoke `scrollToEnd`…
+        position.scrollToEnd();
+        await tester.pump();
+
+        // … but have the bottom sliver turn out to be shorter than it was.
+        await prepare(tester, topHeight: 400, bottomHeight: 600,
+          reuseController: true);
+        check(position.extentAfter).equals(200);
+
+        // Let the scrolling animation proceed until it hits the end.
+        int steps = 0;
+        while (position.extentAfter > 0) {
+          check(++steps).isLessThan(100);
+          await tester.pump(Duration(milliseconds: 11));
+        }
+
+        // This is the very first frame where the position reached the end.
+        // It's at exactly the end, no farther…
+        check(position.pixels - position.maxScrollExtent).equals(0);
+
+        // … and the animation is done.  Nothing further happens.
+        check(position.activity).isA<IdleScrollActivity>();
+        await tester.pump(Duration(milliseconds: 11));
+        check(position.pixels - position.maxScrollExtent).equals(0);
+        check(position.activity).isA<IdleScrollActivity>();
+
+        debugDefaultTargetPlatformOverride = null;
+      });
     });
   });
 }
