diff --git a/lib/notifications/display.dart b/lib/notifications/display.dart
index 3fb9c51c7b..5b73c0b05c 100644
--- a/lib/notifications/display.dart
+++ b/lib/notifications/display.dart
@@ -3,23 +3,16 @@ import 'dart:io';
 
 import 'package:collection/collection.dart';
 import 'package:flutter/foundation.dart';
-import 'package:flutter/widgets.dart' hide Notification;
 import 'package:http/http.dart' as http;
 
 import '../api/model/model.dart';
 import '../api/notifications.dart';
-import '../generated/l10n/zulip_localizations.dart';
 import '../host/android_notifications.dart';
 import '../log.dart';
 import '../model/binding.dart';
 import '../model/localizations.dart';
 import '../model/narrow.dart';
-import '../widgets/app.dart';
 import '../widgets/color.dart';
-import '../widgets/dialog.dart';
-import '../widgets/message_list.dart';
-import '../widgets/page.dart';
-import '../widgets/store.dart';
 import '../widgets/theme.dart';
 import 'open.dart';
 
@@ -482,62 +475,6 @@ class NotificationDisplayManager {
 
   static String _personKey(Uri realmUrl, int userId) => "$realmUrl|$userId";
 
-  /// Provides the route and the account ID by parsing the notification URL.
-  ///
-  /// The URL must have been generated using [NotificationOpenPayload.buildUrl]
-  /// while creating the notification.
-  ///
-  /// Returns null and shows an error dialog if the associated account is not
-  /// found in the global store.
-  static AccountRoute<void>? routeForNotification({
-    required BuildContext context,
-    required Uri url,
-  }) {
-    assert(defaultTargetPlatform == TargetPlatform.android);
-
-    final globalStore = GlobalStoreWidget.of(context);
-
-    assert(debugLog('got notif: url: $url'));
-    assert(url.scheme == 'zulip' && url.host == 'notification');
-    final payload = NotificationOpenPayload.parseUrl(url);
-
-    final account = globalStore.accounts.firstWhereOrNull(
-      (account) => account.realmUrl.origin == payload.realmUrl.origin
-                && account.userId == payload.userId);
-    if (account == null) { // TODO(log)
-      final zulipLocalizations = ZulipLocalizations.of(context);
-      showErrorDialog(context: context,
-        title: zulipLocalizations.errorNotificationOpenTitle,
-        message: zulipLocalizations.errorNotificationOpenAccountNotFound);
-      return null;
-    }
-
-    return MessageListPage.buildRoute(
-      accountId: account.id,
-      // TODO(#1565): Open at specific message, not just conversation
-      narrow: payload.narrow);
-  }
-
-  /// Navigates to the [MessageListPage] of the specific conversation
-  /// given the `zulip://notification/…` Android intent data URL,
-  /// generated with [NotificationOpenPayload.buildUrl] while creating
-  /// the notification.
-  static Future<void> navigateForNotification(Uri url) async {
-    assert(defaultTargetPlatform == TargetPlatform.android);
-    assert(debugLog('opened notif: url: $url'));
-
-    NavigatorState navigator = await ZulipApp.navigator;
-    final context = navigator.context;
-    assert(context.mounted);
-    if (!context.mounted) return; // TODO(linter): this is impossible as there's no actual async gap, but the use_build_context_synchronously lint doesn't see that
-
-    final route = routeForNotification(context: context, url: url);
-    if (route == null) return; // TODO(log)
-
-    // TODO(nav): Better interact with existing nav stack on notif open
-    unawaited(navigator.push(route));
-  }
-
   static Future<Uint8List?> _fetchBitmap(Uri url) async {
     try {
       // TODO timeout to prevent waiting indefinitely
diff --git a/lib/notifications/open.dart b/lib/notifications/open.dart
index d087109d17..50f3998054 100644
--- a/lib/notifications/open.dart
+++ b/lib/notifications/open.dart
@@ -1,5 +1,80 @@
+import 'dart:async';
+
+import 'package:collection/collection.dart';
+import 'package:flutter/foundation.dart';
+import 'package:flutter/widgets.dart';
+
 import '../api/model/model.dart';
+import '../generated/l10n/zulip_localizations.dart';
+import '../log.dart';
 import '../model/narrow.dart';
+import '../widgets/app.dart';
+import '../widgets/dialog.dart';
+import '../widgets/message_list.dart';
+import '../widgets/page.dart';
+import '../widgets/store.dart';
+
+/// Responds to the user opening a notification.
+class NotificationOpenService {
+
+  /// Provides the route and the account ID by parsing the notification URL.
+  ///
+  /// The URL must have been generated using [NotificationOpenPayload.buildUrl]
+  /// while creating the notification.
+  ///
+  /// Returns null and shows an error dialog if the associated account is not
+  /// found in the global store.
+  ///
+  /// The context argument should be a descendant of the app's main [Navigator].
+  static AccountRoute<void>? routeForNotification({
+    required BuildContext context,
+    required Uri url,
+  }) {
+    assert(defaultTargetPlatform == TargetPlatform.android);
+
+    final globalStore = GlobalStoreWidget.of(context);
+
+    assert(debugLog('got notif: url: $url'));
+    assert(url.scheme == 'zulip' && url.host == 'notification');
+    final payload = NotificationOpenPayload.parseUrl(url);
+
+    final account = globalStore.accounts.firstWhereOrNull(
+      (account) => account.realmUrl.origin == payload.realmUrl.origin
+                && account.userId == payload.userId);
+    if (account == null) { // TODO(log)
+      final zulipLocalizations = ZulipLocalizations.of(context);
+      showErrorDialog(context: context,
+        title: zulipLocalizations.errorNotificationOpenTitle,
+        message: zulipLocalizations.errorNotificationOpenAccountNotFound);
+      return null;
+    }
+
+    return MessageListPage.buildRoute(
+      accountId: account.id,
+      // TODO(#1565): Open at specific message, not just conversation
+      narrow: payload.narrow);
+  }
+
+  /// Navigates to the [MessageListPage] of the specific conversation
+  /// given the `zulip://notification/…` Android intent data URL,
+  /// generated with [NotificationOpenPayload.buildUrl] while creating
+  /// the notification.
+  static Future<void> navigateForNotification(Uri url) async {
+    assert(defaultTargetPlatform == TargetPlatform.android);
+    assert(debugLog('opened notif: url: $url'));
+
+    NavigatorState navigator = await ZulipApp.navigator;
+    final context = navigator.context;
+    assert(context.mounted);
+    if (!context.mounted) return; // TODO(linter): this is impossible as there's no actual async gap, but the use_build_context_synchronously lint doesn't see that
+
+    final route = routeForNotification(context: context, url: url);
+    if (route == null) return; // TODO(log)
+
+    // TODO(nav): Better interact with existing nav stack on notif open
+    unawaited(navigator.push(route));
+  }
+}
 
 /// The information contained in 'zulip://notification/…' internal
 /// Android intent data URL, used for notification-open flow.
diff --git a/lib/widgets/app.dart b/lib/widgets/app.dart
index 54ba92588b..8017bf67b0 100644
--- a/lib/widgets/app.dart
+++ b/lib/widgets/app.dart
@@ -9,7 +9,7 @@ import '../log.dart';
 import '../model/actions.dart';
 import '../model/localizations.dart';
 import '../model/store.dart';
-import '../notifications/display.dart';
+import '../notifications/open.dart';
 import 'about_zulip.dart';
 import 'dialog.dart';
 import 'home.dart';
@@ -176,7 +176,7 @@ class _ZulipAppState extends State<ZulipApp> with WidgetsBindingObserver {
 
     final initialRouteUrl = Uri.tryParse(initialRoute);
     if (initialRouteUrl case Uri(scheme: 'zulip', host: 'notification')) {
-      final route = NotificationDisplayManager.routeForNotification(
+      final route = NotificationOpenService.routeForNotification(
         context: context,
         url: initialRouteUrl);
 
@@ -209,7 +209,7 @@ class _ZulipAppState extends State<ZulipApp> with WidgetsBindingObserver {
         await LoginPage.handleWebAuthUrl(url);
         return true;
       case Uri(scheme: 'zulip', host: 'notification') && var url:
-        await NotificationDisplayManager.navigateForNotification(url);
+        await NotificationOpenService.navigateForNotification(url);
         return true;
     }
     return super.didPushRouteInformation(routeInformation);
diff --git a/test/notifications/display_test.dart b/test/notifications/display_test.dart
index b991d8bfec..3cbb96308c 100644
--- a/test/notifications/display_test.dart
+++ b/test/notifications/display_test.dart
@@ -1,4 +1,3 @@
-import 'dart:async';
 import 'dart:io';
 import 'dart:typed_data';
 
@@ -6,7 +5,6 @@ import 'package:checks/checks.dart';
 import 'package:collection/collection.dart';
 import 'package:fake_async/fake_async.dart';
 import 'package:firebase_messaging/firebase_messaging.dart';
-import 'package:flutter/material.dart' hide Notification;
 import 'package:flutter_test/flutter_test.dart';
 import 'package:http/http.dart' as http;
 import 'package:http/testing.dart' as http_testing;
@@ -20,21 +18,13 @@ import 'package:zulip/model/store.dart';
 import 'package:zulip/notifications/display.dart';
 import 'package:zulip/notifications/open.dart';
 import 'package:zulip/notifications/receive.dart';
-import 'package:zulip/widgets/app.dart';
 import 'package:zulip/widgets/color.dart';
-import 'package:zulip/widgets/home.dart';
-import 'package:zulip/widgets/message_list.dart';
-import 'package:zulip/widgets/page.dart';
 import 'package:zulip/widgets/theme.dart';
 
 import '../example_data.dart' as eg;
 import '../fake_async.dart';
 import '../model/binding.dart';
 import '../test_images.dart';
-import '../test_navigation.dart';
-import '../widgets/dialog_checks.dart';
-import '../widgets/message_list_checks.dart';
-import '../widgets/page_checks.dart';
 
 MessageFcmMessage messageFcmMessage(
   Message zulipMessage, {
@@ -1033,227 +1023,6 @@ void main() {
       check(testBinding.androidNotificationHost.activeNotifications).isEmpty();
     })));
   });
-
-  group('NotificationDisplayManager open', () {
-    late List<Route<void>> pushedRoutes;
-
-    void takeStartingRoutes({Account? account, bool withAccount = true}) {
-      account ??= eg.selfAccount;
-      final expected = <Condition<Object?>>[
-        if (withAccount)
-          (it) => it.isA<MaterialAccountWidgetRoute>()
-            ..accountId.equals(account!.id)
-            ..page.isA<HomePage>()
-        else
-          (it) => it.isA<WidgetRoute>().page.isA<ChooseAccountPage>(),
-      ];
-      check(pushedRoutes.take(expected.length)).deepEquals(expected);
-      pushedRoutes.removeRange(0, expected.length);
-    }
-
-    Future<void> prepare(WidgetTester tester,
-        {bool early = false, bool withAccount = true}) async {
-      await init(addSelfAccount: false);
-      pushedRoutes = [];
-      final testNavObserver = TestNavigatorObserver()
-        ..onPushed = (route, prevRoute) => pushedRoutes.add(route);
-      // This uses [ZulipApp] instead of [TestZulipApp] because notification
-      // logic uses `await ZulipApp.navigator`.
-      await tester.pumpWidget(ZulipApp(navigatorObservers: [testNavObserver]));
-      if (early) {
-        check(pushedRoutes).isEmpty();
-        return;
-      }
-      await tester.pump();
-      takeStartingRoutes(withAccount: withAccount);
-      check(pushedRoutes).isEmpty();
-    }
-
-    Future<void> openNotification(WidgetTester tester, Account account, Message message) async {
-      final data = messageFcmMessage(message, account: account);
-      final intentDataUrl = NotificationOpenPayload(
-        realmUrl: data.realmUrl,
-        userId: data.userId,
-        narrow: switch (data.recipient) {
-        FcmMessageChannelRecipient(:var streamId, :var topic) =>
-          TopicNarrow(streamId, topic),
-        FcmMessageDmRecipient(:var allRecipientIds) =>
-          DmNarrow(allRecipientIds: allRecipientIds, selfUserId: data.userId),
-      }).buildUrl();
-      unawaited(
-        WidgetsBinding.instance.handlePushRoute(intentDataUrl.toString()));
-      await tester.idle(); // let navigateForNotification find navigator
-    }
-
-    void matchesNavigation(Subject<Route<void>> route, Account account, Message message) {
-      route.isA<MaterialAccountWidgetRoute>()
-        ..accountId.equals(account.id)
-        ..page.isA<MessageListPage>()
-          .initNarrow.equals(SendableNarrow.ofMessage(message,
-            selfUserId: account.userId));
-    }
-
-    Future<void> checkOpenNotification(WidgetTester tester, Account account, Message message) async {
-      await openNotification(tester, account, message);
-      matchesNavigation(check(pushedRoutes).single, account, message);
-      pushedRoutes.clear();
-    }
-
-    testWidgets('stream message', (tester) async {
-      addTearDown(testBinding.reset);
-      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
-      await prepare(tester);
-      await checkOpenNotification(tester, eg.selfAccount, eg.streamMessage());
-    });
-
-    testWidgets('direct message', (tester) async {
-      addTearDown(testBinding.reset);
-      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
-      await prepare(tester);
-      await checkOpenNotification(tester, eg.selfAccount,
-        eg.dmMessage(from: eg.otherUser, to: [eg.selfUser]));
-    });
-
-    testWidgets('account queried by realmUrl origin component', (tester) async {
-      addTearDown(testBinding.reset);
-      await testBinding.globalStore.add(
-        eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example')),
-        eg.initialSnapshot());
-      await prepare(tester);
-
-      await checkOpenNotification(tester,
-        eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example/')),
-        eg.streamMessage());
-      await checkOpenNotification(tester,
-        eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example')),
-        eg.streamMessage());
-    });
-
-    testWidgets('no accounts', (tester) async {
-      await prepare(tester, withAccount: false);
-      await openNotification(tester, eg.selfAccount, eg.streamMessage());
-      await tester.pump();
-      check(pushedRoutes.single).isA<DialogRoute<void>>();
-      await tester.tap(find.byWidget(checkErrorDialog(tester,
-        expectedTitle: zulipLocalizations.errorNotificationOpenTitle,
-        expectedMessage: zulipLocalizations.errorNotificationOpenAccountNotFound)));
-    });
-
-    testWidgets('mismatching account', (tester) async {
-      addTearDown(testBinding.reset);
-      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
-      await prepare(tester);
-      await openNotification(tester, eg.otherAccount, eg.streamMessage());
-      await tester.pump();
-      check(pushedRoutes.single).isA<DialogRoute<void>>();
-      await tester.tap(find.byWidget(checkErrorDialog(tester,
-        expectedTitle: zulipLocalizations.errorNotificationOpenTitle,
-        expectedMessage: zulipLocalizations.errorNotificationOpenAccountNotFound)));
-    });
-
-    testWidgets('find account among several', (tester) async {
-      addTearDown(testBinding.reset);
-      final realmUrlA = Uri.parse('https://a-chat.example/');
-      final realmUrlB = Uri.parse('https://chat-b.example/');
-      final user1 = eg.user();
-      final user2 = eg.user();
-      final accounts = [
-        eg.account(id: 1001, realmUrl: realmUrlA, user: user1),
-        eg.account(id: 1002, realmUrl: realmUrlA, user: user2),
-        eg.account(id: 1003, realmUrl: realmUrlB, user: user1),
-        eg.account(id: 1004, realmUrl: realmUrlB, user: user2),
-      ];
-      for (final account in accounts) {
-        await testBinding.globalStore.add(account, eg.initialSnapshot());
-      }
-      await prepare(tester);
-
-      await checkOpenNotification(tester, accounts[0], eg.streamMessage());
-      await checkOpenNotification(tester, accounts[1], eg.streamMessage());
-      await checkOpenNotification(tester, accounts[2], eg.streamMessage());
-      await checkOpenNotification(tester, accounts[3], eg.streamMessage());
-    });
-
-    testWidgets('wait for app to become ready', (tester) async {
-      addTearDown(testBinding.reset);
-      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
-      await prepare(tester, early: true);
-      final message = eg.streamMessage();
-      await openNotification(tester, eg.selfAccount, message);
-      // The app should still not be ready (or else this test won't work right).
-      check(ZulipApp.ready.value).isFalse();
-      check(ZulipApp.navigatorKey.currentState).isNull();
-      // And the openNotification hasn't caused any navigation yet.
-      check(pushedRoutes).isEmpty();
-
-      // Now let the GlobalStore get loaded and the app's main UI get mounted.
-      await tester.pump();
-      // The navigator first pushes the starting routes…
-      takeStartingRoutes();
-      // … and then the one the notification leads to.
-      matchesNavigation(check(pushedRoutes).single, eg.selfAccount, message);
-    });
-
-    testWidgets('at app launch', (tester) async {
-      addTearDown(testBinding.reset);
-      // Set up a value for `PlatformDispatcher.defaultRouteName` to return,
-      // for determining the intial route.
-      final account = eg.selfAccount;
-      final message = eg.streamMessage();
-      final data = messageFcmMessage(message, account: account);
-      final intentDataUrl = NotificationOpenPayload(
-        realmUrl: data.realmUrl,
-        userId: data.userId,
-        narrow: switch (data.recipient) {
-          FcmMessageChannelRecipient(:var streamId, :var topic) =>
-            TopicNarrow(streamId, topic),
-          FcmMessageDmRecipient(:var allRecipientIds) =>
-            DmNarrow(allRecipientIds: allRecipientIds, selfUserId: data.userId),
-        }).buildUrl();
-      addTearDown(tester.binding.platformDispatcher.clearDefaultRouteNameTestValue);
-      tester.binding.platformDispatcher.defaultRouteNameTestValue = intentDataUrl.toString();
-
-      // Now start the app.
-      await testBinding.globalStore.add(account, eg.initialSnapshot());
-      await prepare(tester, early: true);
-      check(pushedRoutes).isEmpty(); // GlobalStore hasn't loaded yet
-
-      // Once the app is ready, we navigate to the conversation.
-      await tester.pump();
-      takeStartingRoutes();
-      matchesNavigation(check(pushedRoutes).single, account, message);
-    });
-
-    testWidgets('uses associated account as initial account; if initial route', (tester) async {
-      addTearDown(testBinding.reset);
-
-      final accountA = eg.selfAccount;
-      final accountB = eg.otherAccount;
-      final message = eg.streamMessage();
-      final data = messageFcmMessage(message, account: accountB);
-      await testBinding.globalStore.add(accountA, eg.initialSnapshot());
-      await testBinding.globalStore.add(accountB, eg.initialSnapshot());
-
-      final intentDataUrl = NotificationOpenPayload(
-        realmUrl: data.realmUrl,
-        userId: data.userId,
-        narrow: switch (data.recipient) {
-          FcmMessageChannelRecipient(:var streamId, :var topic) =>
-            TopicNarrow(streamId, topic),
-          FcmMessageDmRecipient(:var allRecipientIds) =>
-            DmNarrow(allRecipientIds: allRecipientIds, selfUserId: data.userId),
-        }).buildUrl();
-      addTearDown(tester.binding.platformDispatcher.clearDefaultRouteNameTestValue);
-      tester.binding.platformDispatcher.defaultRouteNameTestValue = intentDataUrl.toString();
-
-      await prepare(tester, early: true);
-      check(pushedRoutes).isEmpty(); // GlobalStore hasn't loaded yet
-
-      await tester.pump();
-      takeStartingRoutes(account: accountB);
-      matchesNavigation(check(pushedRoutes).single, accountB, message);
-    });
-  });
 }
 
 extension on Subject<CopySoundResourceToMediaStoreCall> {
diff --git a/test/notifications/open_test.dart b/test/notifications/open_test.dart
index c9960118b6..a08e999c1e 100644
--- a/test/notifications/open_test.dart
+++ b/test/notifications/open_test.dart
@@ -1,13 +1,266 @@
+import 'dart:async';
+
 import 'package:checks/checks.dart';
+import 'package:flutter/material.dart';
 import 'package:flutter_test/flutter_test.dart';
+import 'package:zulip/api/model/model.dart';
+import 'package:zulip/api/notifications.dart';
+import 'package:zulip/model/database.dart';
+import 'package:zulip/model/localizations.dart';
 import 'package:zulip/model/narrow.dart';
 import 'package:zulip/notifications/open.dart';
+import 'package:zulip/notifications/receive.dart';
+import 'package:zulip/widgets/app.dart';
+import 'package:zulip/widgets/home.dart';
+import 'package:zulip/widgets/message_list.dart';
+import 'package:zulip/widgets/page.dart';
 
 import '../example_data.dart' as eg;
+import '../model/binding.dart';
 import '../model/narrow_checks.dart';
 import '../stdlib_checks.dart';
+import '../test_navigation.dart';
+import '../widgets/dialog_checks.dart';
+import '../widgets/message_list_checks.dart';
+import '../widgets/page_checks.dart';
+import 'display_test.dart';
 
 void main() {
+  TestZulipBinding.ensureInitialized();
+  final zulipLocalizations = GlobalLocalizations.zulipLocalizations;
+
+  Future<void> init({bool addSelfAccount = true}) async {
+    if (addSelfAccount) {
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+    }
+    addTearDown(testBinding.reset);
+    testBinding.firebaseMessagingInitialToken = '012abc';
+    addTearDown(NotificationService.debugReset);
+    NotificationService.debugBackgroundIsolateIsLive = false;
+    await NotificationService.instance.start();
+  }
+
+  group('NotificationOpenService', () {
+    late List<Route<void>> pushedRoutes;
+
+    void takeStartingRoutes({Account? account, bool withAccount = true}) {
+      account ??= eg.selfAccount;
+      final expected = <Condition<Object?>>[
+        if (withAccount)
+          (it) => it.isA<MaterialAccountWidgetRoute>()
+            ..accountId.equals(account!.id)
+            ..page.isA<HomePage>()
+        else
+          (it) => it.isA<WidgetRoute>().page.isA<ChooseAccountPage>(),
+      ];
+      check(pushedRoutes.take(expected.length)).deepEquals(expected);
+      pushedRoutes.removeRange(0, expected.length);
+    }
+
+    Future<void> prepare(WidgetTester tester,
+        {bool early = false, bool withAccount = true}) async {
+      await init(addSelfAccount: false);
+      pushedRoutes = [];
+      final testNavObserver = TestNavigatorObserver()
+        ..onPushed = (route, prevRoute) => pushedRoutes.add(route);
+      // This uses [ZulipApp] instead of [TestZulipApp] because notification
+      // logic uses `await ZulipApp.navigator`.
+      await tester.pumpWidget(ZulipApp(navigatorObservers: [testNavObserver]));
+      if (early) {
+        check(pushedRoutes).isEmpty();
+        return;
+      }
+      await tester.pump();
+      takeStartingRoutes(withAccount: withAccount);
+      check(pushedRoutes).isEmpty();
+    }
+
+    Future<void> openNotification(WidgetTester tester, Account account, Message message) async {
+      final data = messageFcmMessage(message, account: account);
+      final intentDataUrl = NotificationOpenPayload(
+        realmUrl: data.realmUrl,
+        userId: data.userId,
+        narrow: switch (data.recipient) {
+        FcmMessageChannelRecipient(:var streamId, :var topic) =>
+          TopicNarrow(streamId, topic),
+        FcmMessageDmRecipient(:var allRecipientIds) =>
+          DmNarrow(allRecipientIds: allRecipientIds, selfUserId: data.userId),
+      }).buildUrl();
+      unawaited(
+        WidgetsBinding.instance.handlePushRoute(intentDataUrl.toString()));
+      await tester.idle(); // let navigateForNotification find navigator
+    }
+
+    void matchesNavigation(Subject<Route<void>> route, Account account, Message message) {
+      route.isA<MaterialAccountWidgetRoute>()
+        ..accountId.equals(account.id)
+        ..page.isA<MessageListPage>()
+          .initNarrow.equals(SendableNarrow.ofMessage(message,
+            selfUserId: account.userId));
+    }
+
+    Future<void> checkOpenNotification(WidgetTester tester, Account account, Message message) async {
+      await openNotification(tester, account, message);
+      matchesNavigation(check(pushedRoutes).single, account, message);
+      pushedRoutes.clear();
+    }
+
+    testWidgets('stream message', (tester) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+      await prepare(tester);
+      await checkOpenNotification(tester, eg.selfAccount, eg.streamMessage());
+    });
+
+    testWidgets('direct message', (tester) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+      await prepare(tester);
+      await checkOpenNotification(tester, eg.selfAccount,
+        eg.dmMessage(from: eg.otherUser, to: [eg.selfUser]));
+    });
+
+    testWidgets('account queried by realmUrl origin component', (tester) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(
+        eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example')),
+        eg.initialSnapshot());
+      await prepare(tester);
+
+      await checkOpenNotification(tester,
+        eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example/')),
+        eg.streamMessage());
+      await checkOpenNotification(tester,
+        eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example')),
+        eg.streamMessage());
+    });
+
+    testWidgets('no accounts', (tester) async {
+      await prepare(tester, withAccount: false);
+      await openNotification(tester, eg.selfAccount, eg.streamMessage());
+      await tester.pump();
+      check(pushedRoutes.single).isA<DialogRoute<void>>();
+      await tester.tap(find.byWidget(checkErrorDialog(tester,
+        expectedTitle: zulipLocalizations.errorNotificationOpenTitle,
+        expectedMessage: zulipLocalizations.errorNotificationOpenAccountNotFound)));
+    });
+
+    testWidgets('mismatching account', (tester) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+      await prepare(tester);
+      await openNotification(tester, eg.otherAccount, eg.streamMessage());
+      await tester.pump();
+      check(pushedRoutes.single).isA<DialogRoute<void>>();
+      await tester.tap(find.byWidget(checkErrorDialog(tester,
+        expectedTitle: zulipLocalizations.errorNotificationOpenTitle,
+        expectedMessage: zulipLocalizations.errorNotificationOpenAccountNotFound)));
+    });
+
+    testWidgets('find account among several', (tester) async {
+      addTearDown(testBinding.reset);
+      final realmUrlA = Uri.parse('https://a-chat.example/');
+      final realmUrlB = Uri.parse('https://chat-b.example/');
+      final user1 = eg.user();
+      final user2 = eg.user();
+      final accounts = [
+        eg.account(id: 1001, realmUrl: realmUrlA, user: user1),
+        eg.account(id: 1002, realmUrl: realmUrlA, user: user2),
+        eg.account(id: 1003, realmUrl: realmUrlB, user: user1),
+        eg.account(id: 1004, realmUrl: realmUrlB, user: user2),
+      ];
+      for (final account in accounts) {
+        await testBinding.globalStore.add(account, eg.initialSnapshot());
+      }
+      await prepare(tester);
+
+      await checkOpenNotification(tester, accounts[0], eg.streamMessage());
+      await checkOpenNotification(tester, accounts[1], eg.streamMessage());
+      await checkOpenNotification(tester, accounts[2], eg.streamMessage());
+      await checkOpenNotification(tester, accounts[3], eg.streamMessage());
+    });
+
+    testWidgets('wait for app to become ready', (tester) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+      await prepare(tester, early: true);
+      final message = eg.streamMessage();
+      await openNotification(tester, eg.selfAccount, message);
+      // The app should still not be ready (or else this test won't work right).
+      check(ZulipApp.ready.value).isFalse();
+      check(ZulipApp.navigatorKey.currentState).isNull();
+      // And the openNotification hasn't caused any navigation yet.
+      check(pushedRoutes).isEmpty();
+
+      // Now let the GlobalStore get loaded and the app's main UI get mounted.
+      await tester.pump();
+      // The navigator first pushes the starting routes…
+      takeStartingRoutes();
+      // … and then the one the notification leads to.
+      matchesNavigation(check(pushedRoutes).single, eg.selfAccount, message);
+    });
+
+    testWidgets('at app launch', (tester) async {
+      addTearDown(testBinding.reset);
+      // Set up a value for `PlatformDispatcher.defaultRouteName` to return,
+      // for determining the intial route.
+      final account = eg.selfAccount;
+      final message = eg.streamMessage();
+      final data = messageFcmMessage(message, account: account);
+      final intentDataUrl = NotificationOpenPayload(
+        realmUrl: data.realmUrl,
+        userId: data.userId,
+        narrow: switch (data.recipient) {
+          FcmMessageChannelRecipient(:var streamId, :var topic) =>
+            TopicNarrow(streamId, topic),
+          FcmMessageDmRecipient(:var allRecipientIds) =>
+            DmNarrow(allRecipientIds: allRecipientIds, selfUserId: data.userId),
+        }).buildUrl();
+      addTearDown(tester.binding.platformDispatcher.clearDefaultRouteNameTestValue);
+      tester.binding.platformDispatcher.defaultRouteNameTestValue = intentDataUrl.toString();
+
+      // Now start the app.
+      await testBinding.globalStore.add(account, eg.initialSnapshot());
+      await prepare(tester, early: true);
+      check(pushedRoutes).isEmpty(); // GlobalStore hasn't loaded yet
+
+      // Once the app is ready, we navigate to the conversation.
+      await tester.pump();
+      takeStartingRoutes();
+      matchesNavigation(check(pushedRoutes).single, account, message);
+    });
+
+    testWidgets('uses associated account as initial account; if initial route', (tester) async {
+      addTearDown(testBinding.reset);
+
+      final accountA = eg.selfAccount;
+      final accountB = eg.otherAccount;
+      final message = eg.streamMessage();
+      final data = messageFcmMessage(message, account: accountB);
+      await testBinding.globalStore.add(accountA, eg.initialSnapshot());
+      await testBinding.globalStore.add(accountB, eg.initialSnapshot());
+
+      final intentDataUrl = NotificationOpenPayload(
+        realmUrl: data.realmUrl,
+        userId: data.userId,
+        narrow: switch (data.recipient) {
+          FcmMessageChannelRecipient(:var streamId, :var topic) =>
+            TopicNarrow(streamId, topic),
+          FcmMessageDmRecipient(:var allRecipientIds) =>
+            DmNarrow(allRecipientIds: allRecipientIds, selfUserId: data.userId),
+        }).buildUrl();
+      addTearDown(tester.binding.platformDispatcher.clearDefaultRouteNameTestValue);
+      tester.binding.platformDispatcher.defaultRouteNameTestValue = intentDataUrl.toString();
+
+      await prepare(tester, early: true);
+      check(pushedRoutes).isEmpty(); // GlobalStore hasn't loaded yet
+
+      await tester.pump();
+      takeStartingRoutes(account: accountB);
+      matchesNavigation(check(pushedRoutes).single, accountB, message);
+    });
+  });
+
   group('NotificationOpenPayload', () {
     test('smoke round-trip', () {
       // DM narrow
