diff --git a/lib/model/message.dart b/lib/model/message.dart
index 5d30a17ce9..1e3abbbcdb 100644
--- a/lib/model/message.dart
+++ b/lib/model/message.dart
@@ -152,6 +152,7 @@ class MessageStoreImpl with MessageStore {
     final newStreamId = event.newStreamId; // null if topic-only move
     final origTopic = event.origTopic;
     final newTopic = event.newTopic;
+    final propagateMode = event.propagateMode;
 
     if (origTopic == null) {
       // There was no move.
@@ -178,6 +179,11 @@ class MessageStoreImpl with MessageStore {
       assert(debugLog('Malformed UpdateMessageEvent: move but no origStreamId')); // TODO(log)
       return;
     }
+    if (propagateMode == null) {
+      // The `propagate_mode` field (aka propagateMode) is documented to be present on moves.
+      assert(debugLog('Malformed UpdateMessageEvent: move but no propagateMode')); // TODO(log)
+      return;
+    }
 
     final wasResolveOrUnresolve = (newStreamId == null
       && MessageEditState.topicMoveWasResolveOrUnresolve(origTopic, newTopic!));
@@ -215,6 +221,7 @@ class MessageStoreImpl with MessageStore {
         origTopic: origTopic,
         newTopic: newTopic ?? origTopic,
         messageIds: event.messageIds,
+        propagateMode: propagateMode,
       );
     }
   }
diff --git a/lib/model/message_list.dart b/lib/model/message_list.dart
index 29453c2778..f20960e221 100644
--- a/lib/model/message_list.dart
+++ b/lib/model/message_list.dart
@@ -359,7 +359,7 @@ class MessageListView with ChangeNotifier, _MessageSequence {
   }
 
   final PerAccountStore store;
-  final Narrow narrow;
+  Narrow narrow;
 
   /// Whether [message] should actually appear in this message list,
   /// given that it does belong to the narrow.
@@ -535,12 +535,24 @@ class MessageListView with ChangeNotifier, _MessageSequence {
     }
   }
 
+  void _handlePropagateMode(PropagateMode propagateMode, Narrow newNarrow) {
+    switch (propagateMode) {
+      case PropagateMode.changeAll:
+      case PropagateMode.changeLater:
+        narrow = newNarrow;
+        _reset();
+        fetchInitial();
+      case PropagateMode.changeOne:
+    }
+  }
+
   void messagesMoved({
     required int origStreamId,
     required int newStreamId,
     required String origTopic,
     required String newTopic,
     required List<int> messageIds,
+    required PropagateMode propagateMode,
   }) {
     switch (narrow) {
       case DmNarrow():
@@ -571,7 +583,9 @@ class MessageListView with ChangeNotifier, _MessageSequence {
           case (false, false): return;
           case (true,  true ): return; // TODO(log) no-op move
           case (false, true ): _messagesMovedIntoNarrow();
-          case (true,  false): _messagesMovedFromNarrow(messageIds); // TODO handle propagateMode
+          case (true,  false):
+            _messagesMovedFromNarrow(messageIds);
+            _handlePropagateMode(propagateMode, TopicNarrow(newStreamId, newTopic));
         }
     }
   }
diff --git a/lib/widgets/message_list.dart b/lib/widgets/message_list.dart
index 0e88b4a9ff..4df50ccd37 100644
--- a/lib/widgets/message_list.dart
+++ b/lib/widgets/message_list.dart
@@ -232,6 +232,12 @@ class _MessageListPageState extends State<MessageListPage> implements MessageLis
     narrow = widget.initNarrow;
   }
 
+  void _narrowChanged(Narrow newNarrow) {
+    setState(() {
+      narrow = newNarrow;
+    });
+  }
+
   @override
   Widget build(BuildContext context) {
     final store = PerAccountStoreWidget.of(context);
@@ -289,7 +295,7 @@ class _MessageListPageState extends State<MessageListPage> implements MessageLis
               removeBottom: ComposeBox.hasComposeBox(narrow),
 
               child: Expanded(
-                child: MessageList(narrow: narrow))),
+                child: MessageList(narrow: narrow, onNarrowChanged: _narrowChanged))),
             ComposeBox(controllerKey: _composeBoxKey, narrow: narrow),
           ]))));
   }
@@ -368,9 +374,10 @@ const _kShortMessageHeight = 80;
 const kFetchMessagesBufferPixels = (kMessageListFetchBatchSize / 2) * _kShortMessageHeight;
 
 class MessageList extends StatefulWidget {
-  const MessageList({super.key, required this.narrow});
+  const MessageList({super.key, required this.narrow, required this.onNarrowChanged});
 
   final Narrow narrow;
+  final void Function(Narrow newNarrow) onNarrowChanged;
 
   @override
   State<StatefulWidget> createState() => _MessageListState();
@@ -407,6 +414,11 @@ class _MessageListState extends State<MessageList> with PerAccountStoreAwareStat
   }
 
   void _modelChanged() {
+    if (model!.narrow != widget.narrow) {
+      // A message move event occurred, where propagate mode is
+      // [PropagateMode.changeAll] or [PropagateMode.changeLater].
+      widget.onNarrowChanged(model!.narrow);
+    }
     setState(() {
       // The actual state lives in the [MessageListView] model.
       // This method was called because that just changed.
diff --git a/test/example_data.dart b/test/example_data.dart
index 8b385eb4f6..41abc88bc1 100644
--- a/test/example_data.dart
+++ b/test/example_data.dart
@@ -472,6 +472,7 @@ UpdateMessageEvent _updateMessageMoveEvent(
   String? origContent,
   String? newContent,
   required List<MessageFlag> flags,
+  PropagateMode propagateMode = PropagateMode.changeOne,
 }) {
   assert(newTopic != origTopic
          || (newStreamId != null && newStreamId != origStreamId));
@@ -486,7 +487,7 @@ UpdateMessageEvent _updateMessageMoveEvent(
     editTimestamp: 1234567890, // TODO generate timestamp
     origStreamId: origStreamId,
     newStreamId: newStreamId,
-    propagateMode: null,
+    propagateMode: propagateMode,
     origTopic: origTopic,
     newTopic: newTopic,
     origContent: origContent,
@@ -503,6 +504,7 @@ UpdateMessageEvent updateMessageEventMoveFrom({
   int? newStreamId,
   String? newTopic,
   String? newContent,
+  PropagateMode propagateMode = PropagateMode.changeOne,
 }) {
   assert(origMessages.isNotEmpty);
   final origMessage = origMessages.first;
@@ -516,6 +518,7 @@ UpdateMessageEvent updateMessageEventMoveFrom({
     origContent: origContent,
     newContent: newContent,
     flags: origMessage.flags,
+    propagateMode: propagateMode,
   );
 }
 
@@ -525,6 +528,7 @@ UpdateMessageEvent updateMessageEventMoveTo({
   int? origStreamId,
   String? origTopic,
   String? origContent,
+  PropagateMode propagateMode = PropagateMode.changeOne,
 }) {
   assert(newMessages.isNotEmpty);
   final newMessage = newMessages.first;
@@ -542,6 +546,7 @@ UpdateMessageEvent updateMessageEventMoveTo({
     origContent: origContent,
     newContent: newContent,
     flags: newMessage.flags,
+    propagateMode: propagateMode,
   );
 }
 
diff --git a/test/flutter_checks.dart b/test/flutter_checks.dart
index d0906d849b..641a2d8de1 100644
--- a/test/flutter_checks.dart
+++ b/test/flutter_checks.dart
@@ -60,8 +60,14 @@ extension TextChecks on Subject<Text> {
   Subject<TextStyle?> get style => has((t) => t.style, 'style');
 }
 
+extension TextEditingControllerChecks on Subject<TextEditingController> {
+  Subject<String?> get text => has((t) => t.text, 'text');
+}
+
 extension TextFieldChecks on Subject<TextField> {
   Subject<TextCapitalization?> get textCapitalization => has((t) => t.textCapitalization, 'textCapitalization');
+  Subject<InputDecoration?> get decoration => has((t) => t.decoration, 'decoration');
+  Subject<TextEditingController?> get controller => has((t) => t.controller, 'controller');
 }
 
 extension TextStyleChecks on Subject<TextStyle> {
@@ -131,3 +137,7 @@ extension MaterialChecks on Subject<Material> {
   Subject<Color?> get color => has((x) => x.color, 'color');
   // TODO more
 }
+
+extension InputDecorationChecks on Subject<InputDecoration> {
+  Subject<String?> get hintText => has((x) => x.hintText, 'hintText');
+}
diff --git a/test/model/message_list_test.dart b/test/model/message_list_test.dart
index bfcf87a62e..ce1f582b1e 100644
--- a/test/model/message_list_test.dart
+++ b/test/model/message_list_test.dart
@@ -587,6 +587,37 @@ void main() {
         checkHasMessages(initialMessages);
         checkNotNotified();
       });
+
+      void testMessageMove(PropagateMode propagateMode) => awaitFakeAsync((async) async {
+        await prepareNarrow(narrow, initialMessages + movedMessages);
+        connection.prepare(delay: const Duration(seconds: 1), json: newestResult(
+          foundOldest: false,
+          messages: movedMessages,
+        ).toJson());
+        await store.handleEvent(eg.updateMessageEventMoveFrom(
+          origMessages: movedMessages,
+          newTopic: 'new',
+          newStreamId: otherStream.streamId,
+          propagateMode: propagateMode,
+        ));
+        checkNotifiedOnce();
+        async.elapse(const Duration(seconds: 1));
+        checkHasMessages(initialMessages);
+        check(model).narrow.equals(ChannelNarrow(stream.streamId));
+        checkNotNotified();
+      });
+
+      test('do not follow when propagateMode = changeOne', () {
+        testMessageMove(PropagateMode.changeOne);
+      });
+
+      test('do not follow when propagateMode = changeLater', () {
+        testMessageMove(PropagateMode.changeLater);
+      });
+
+      test('do not follow when propagateMode = changeAll', () {
+        testMessageMove(PropagateMode.changeAll);
+      });
     });
 
     group('in topic narrow', () {
@@ -674,6 +705,68 @@ void main() {
           checkNotNotified();
         }));
       });
+
+      void handleMoveEvent(PropagateMode propagateMode) => awaitFakeAsync((async) async {
+        await prepareNarrow(narrow, initialMessages + movedMessages);
+        connection.prepare(delay: const Duration(seconds: 1), json: newestResult(
+          foundOldest: false,
+          messages: movedMessages,
+        ).toJson());
+        await store.handleEvent(eg.updateMessageEventMoveFrom(
+          origMessages: movedMessages,
+          newTopic: 'new',
+          newStreamId: otherStream.streamId,
+          propagateMode: propagateMode,
+        ));
+        checkNotifiedOnce();
+        async.elapse(const Duration(seconds: 1));
+      });
+
+      test('do not follow to the new narrow when propagateMode = changeOne', () {
+        handleMoveEvent(PropagateMode.changeOne);
+        checkNotNotified();
+        checkHasMessages(initialMessages);
+        check(model).narrow.equals(TopicNarrow(stream.streamId, 'topic'));
+      });
+
+      test('follow to the new narrow when propagateMode = changeLater', () {
+        handleMoveEvent(PropagateMode.changeLater);
+        checkNotifiedOnce();
+        checkHasMessages(movedMessages);
+        check(model).narrow.equals(TopicNarrow(otherStream.streamId, 'new'));
+      });
+
+      test('follow to the new narrow when propagateMode = changeAll', () {
+        handleMoveEvent(PropagateMode.changeAll);
+        checkNotifiedOnce();
+        checkHasMessages(movedMessages);
+        check(model).narrow.equals(TopicNarrow(otherStream.streamId, 'new'));
+      });
+
+      test('handle move event before initial fetch', () => awaitFakeAsync((async) async {
+        await prepare(narrow: narrow);
+        final subscription = eg.subscription(stream);
+        await store.addStream(stream);
+        await store.addSubscription(subscription);
+        final followedMessage = eg.streamMessage(stream: stream, topic: 'new');
+
+        connection.prepare(delay: const Duration(seconds: 2), json: newestResult(
+          foundOldest: true,
+          messages: [followedMessage],
+        ).toJson());
+
+        check(model).fetched.isFalse();
+        checkHasMessages([]);
+        await store.handleEvent(eg.updateMessageEventMoveTo(
+          origTopic: 'topic',
+          newMessages: [followedMessage],
+          propagateMode: PropagateMode.changeAll,
+        ));
+        check(model).narrow.equals(TopicNarrow(stream.streamId, 'new'));
+
+        async.elapse(const Duration(seconds: 2));
+        checkHasMessages([followedMessage]);
+      }));
     });
 
     group('fetch races', () {
diff --git a/test/widgets/message_list_test.dart b/test/widgets/message_list_test.dart
index 3f89a10878..071823bf65 100644
--- a/test/widgets/message_list_test.dart
+++ b/test/widgets/message_list_test.dart
@@ -14,6 +14,7 @@ import 'package:zulip/api/route/messages.dart';
 import 'package:zulip/model/localizations.dart';
 import 'package:zulip/model/narrow.dart';
 import 'package:zulip/model/store.dart';
+import 'package:zulip/widgets/autocomplete.dart';
 import 'package:zulip/widgets/content.dart';
 import 'package:zulip/widgets/emoji_reaction.dart';
 import 'package:zulip/widgets/icons.dart';
@@ -620,6 +621,95 @@ void main() {
     });
   });
 
+  group('Update Narrow on message move', () {
+    const topic = 'foo';
+    final channel = eg.stream(name: 'move test stream');
+    final otherChannel = eg.stream(name: 'other move test stream');
+    final narrow = TopicNarrow(channel.streamId, topic);
+
+    void prepareGetMessageResponse(List<Message> messages) {
+      connection.prepare(json: newestResult(
+        foundOldest: false, messages: messages).toJson());
+    }
+
+    void handleMessageMoveEvent(List<StreamMessage> messages, String newTopic, {int? newChannelId}) {
+      store.handleEvent(eg.updateMessageEventMoveFrom(
+        origMessages: messages,
+        newTopic: newTopic,
+        newStreamId: newChannelId,
+        propagateMode: PropagateMode.changeAll));
+    }
+
+    testWidgets('compose box send message after move', (WidgetTester tester) async {
+      final message = eg.streamMessage(stream: channel, topic: topic, content: 'Message to move');
+      await setupMessageListPage(tester, narrow: narrow, messages: [message], streams: [channel, otherChannel]);
+
+      final channelContentInputFinder = find.descendant(
+        of: find.byType(ComposeAutocomplete),
+        matching: find.byType(TextField));
+
+      await tester.enterText(channelContentInputFinder, 'Some text');
+      check(tester.widget<TextField>(channelContentInputFinder))
+        ..decoration.isNotNull().hintText.equals('Message #${channel.name} > $topic')
+        ..controller.isNotNull().text.equals('Some text');
+
+      prepareGetMessageResponse([message]);
+      handleMessageMoveEvent([message], 'new topic', newChannelId: otherChannel.streamId);
+      await tester.pump(const Duration(seconds: 1));
+      check(tester.widget<TextField>(channelContentInputFinder))
+        ..decoration.isNotNull().hintText.equals('Message #${otherChannel.name} > new topic')
+        ..controller.isNotNull().text.equals('Some text');
+
+      connection.prepare(json: SendMessageResult(id: 1).toJson());
+      await tester.tap(find.byIcon(Icons.send));
+      await tester.pump();
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages')
+        ..bodyFields.deepEquals({
+          'type': 'stream',
+          'to': '${otherChannel.streamId}',
+          'topic': 'new topic',
+          'content': 'Some text',
+          'read_by_sender': 'true'});
+      await tester.pumpAndSettle();
+    });
+
+    testWidgets('Move to narrow with existing messages', (WidgetTester tester) async {
+      final message = eg.streamMessage(stream: channel, topic: topic, content: 'Message to move');
+      await setupMessageListPage(tester, narrow: narrow, messages: [message], streams: [channel]);
+      check(find.textContaining('Existing message').evaluate()).length.equals(0);
+      check(find.textContaining('Message to move').evaluate()).length.equals(1);
+
+      final existingMessage = eg.streamMessage(
+        stream: eg.stream(), topic: 'new topic', content: 'Existing message');
+      prepareGetMessageResponse([existingMessage, message]);
+      handleMessageMoveEvent([message], 'new topic');
+      await tester.pump(const Duration(seconds: 1));
+
+      check(find.textContaining('Existing message').evaluate()).length.equals(1);
+      check(find.textContaining('Message to move').evaluate()).length.equals(1);
+    });
+
+    testWidgets('show new topic in TopicNarrow after move', (tester) async {
+      final message = eg.streamMessage(stream: channel, topic: topic, content: 'Message to move');
+      await setupMessageListPage(tester, narrow: narrow, messages: [message], streams: [channel]);
+
+      prepareGetMessageResponse([message]);
+      handleMessageMoveEvent([message], 'new topic');
+      await tester.pump(const Duration(seconds: 1));
+
+      check(find.descendant(
+        of: find.byType(RecipientHeader),
+        matching: find.text('new topic')).evaluate()
+      ).length.equals(1);
+      check(find.descendant(
+        of: find.byType(MessageListAppBarTitle),
+        matching: find.text('${channel.name} > new topic')).evaluate()
+      ).length.equals(1);
+    });
+  });
+
   group('recipient headers', () {
     group('StreamMessageRecipientHeader', () {
       final stream = eg.stream(name: 'stream name');
