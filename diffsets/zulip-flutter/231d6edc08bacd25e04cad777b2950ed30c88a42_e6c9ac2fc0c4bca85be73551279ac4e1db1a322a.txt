diff --git a/lib/model/store.dart b/lib/model/store.dart
index 63f846bf6a..ddce0217b1 100644
--- a/lib/model/store.dart
+++ b/lib/model/store.dart
@@ -277,6 +277,13 @@ class PerAccountStore extends ChangeNotifier with EmojiStore, ChannelStore, Mess
       accountId: accountId,
       selfUserId: account.userId,
       userSettings: initialSnapshot.userSettings,
+      typingNotifier: TypingNotifier(
+        connection: connection,
+        typingStoppedWaitPeriod: Duration(
+          milliseconds: initialSnapshot.serverTypingStoppedWaitPeriodMilliseconds),
+        typingStartedWaitPeriod: Duration(
+          milliseconds: initialSnapshot.serverTypingStartedWaitPeriodMilliseconds),
+      ),
       users: Map.fromEntries(
         initialSnapshot.realmUsers
         .followedBy(initialSnapshot.realmNonActiveUsers)
@@ -311,6 +318,7 @@ class PerAccountStore extends ChangeNotifier with EmojiStore, ChannelStore, Mess
     required this.accountId,
     required this.selfUserId,
     required this.userSettings,
+    required this.typingNotifier,
     required this.users,
     required this.typingStatus,
     required ChannelStoreImpl channels,
@@ -413,6 +421,8 @@ class PerAccountStore extends ChangeNotifier with EmojiStore, ChannelStore, Mess
 
   final UserSettings? userSettings; // TODO(server-5)
 
+  final TypingNotifier typingNotifier;
+
   ////////////////////////////////
   // Users and data about them.
 
@@ -493,6 +503,7 @@ class PerAccountStore extends ChangeNotifier with EmojiStore, ChannelStore, Mess
     unreads.dispose();
     _messages.dispose();
     typingStatus.dispose();
+    typingNotifier.dispose();
     updateMachine?.dispose();
     connection.close();
     _disposed = true;
diff --git a/lib/model/typing_status.dart b/lib/model/typing_status.dart
index 934d69d6e8..2ea7187eee 100644
--- a/lib/model/typing_status.dart
+++ b/lib/model/typing_status.dart
@@ -2,7 +2,10 @@ import 'dart:async';
 
 import 'package:flutter/foundation.dart';
 
+import '../api/core.dart';
 import '../api/model/events.dart';
+import '../api/route/typing.dart';
+import 'binding.dart';
 import 'narrow.dart';
 
 /// The model for tracking the typing status organized by narrows.
@@ -84,3 +87,148 @@ class TypingStatus extends ChangeNotifier {
     }
   }
 }
+
+/// Sends the self-user's typing-status updates.
+///
+/// See also:
+///  * https://github.com/zulip/zulip/blob/52a9846cdf4abfbe937a94559690d508e95f4065/web/shared/src/typing_status.ts
+///  * https://zulip.readthedocs.io/en/latest/subsystems/typing-indicators.html
+class TypingNotifier {
+  TypingNotifier({
+    required this.connection,
+    required this.typingStoppedWaitPeriod,
+    required this.typingStartedWaitPeriod,
+  });
+
+  final ApiConnection connection;
+  final Duration typingStoppedWaitPeriod;
+  final Duration typingStartedWaitPeriod;
+
+  SendableNarrow? _currentDestination;
+
+  /// Records time elapsed since the last time we notify the server;
+  /// this is `null` when the user is not actively typing.
+  Stopwatch? _sinceLastPing;
+
+  /// A timer that resets on every [keystroke].
+  ///
+  /// Upon its expiry, the user is considered idle and
+  /// a "typing stopped" notice will be sent.
+  Timer? _idleTimer;
+
+  void dispose() {
+    _idleTimer?.cancel();
+  }
+
+  /// Updates the server, if needed, that a keystroke was made when
+  /// composing a new message to [destination].
+  ///
+  /// To be called on all keystrokes in the composing session.
+  /// Sends "typing started" notices, throttled appropriately,
+  /// for repeated calls to the same [destination].
+  ///
+  /// If [destination] differs from the previous call, such as after a topic
+  /// input change, sends a "typing stopped" notice for the old destination.
+  ///
+  /// Keeps a timer to send a "typing stopped" notice when this and
+  /// [stoppedComposing] haven't been called in some time.
+  void keystroke(SendableNarrow destination) {
+    if (!debugEnable) return;
+
+    if (_currentDestination != null) {
+      if (destination == _currentDestination) {
+        // Nothing has really changed, except we may need
+        // to send a ping to the server and extend out our idle time.
+        if (_sinceLastPing!.elapsed > typingStartedWaitPeriod) {
+          _actuallyPingServer();
+        }
+        _startOrExtendIdleTimer();
+        return;
+      }
+
+      _stopLastNotification();
+    }
+
+    // We just started typing to this destination, so notify the server.
+    _currentDestination = destination;
+    _startOrExtendIdleTimer();
+    _actuallyPingServer();
+  }
+
+  /// Sends the server a "typing stopped" notice for the destination of
+  /// the current composing session, if there is one.
+  ///
+  /// To be called on cues that the user has exited a new-message composing session,
+  /// e.g., send button tapped, compose box unfocused, nav changed, app quit.
+  ///
+  /// If [keystroke] hasn't been called in some time, does nothing.
+  ///
+  /// Otherwise:
+  /// - Users will see our user's typing indicator disappear immediately
+  ///   instead of after [keystroke]'s timer.
+  /// - [keystroke]'s timer is canceled.
+  ///
+  /// (This has no "destination" param because the user can really only compose
+  /// to one destination at a time. This function acts on the current session
+  /// regardless of its destination.)
+  void stoppedComposing() {
+    if (!debugEnable) return;
+
+    if (_currentDestination != null) {
+      _stopLastNotification();
+    }
+  }
+
+  void _startOrExtendIdleTimer() {
+    _idleTimer?.cancel();
+    _idleTimer = Timer(typingStoppedWaitPeriod, _stopLastNotification);
+  }
+
+  void _actuallyPingServer() {
+    // This allows us to use [clock.stopwatch] only when testing.
+    _sinceLastPing = ZulipBinding.instance.stopwatch()..start();
+
+    unawaited(setTypingStatus(
+      connection,
+      op: TypingOp.start,
+      destination: _currentDestination!.destination));
+  }
+
+  void _stopLastNotification() {
+    assert(_currentDestination != null);
+    final destination = _currentDestination!;
+
+    _idleTimer!.cancel();
+    _currentDestination = null;
+    _sinceLastPing = null;
+
+    unawaited(setTypingStatus(
+      connection,
+      op: TypingOp.stop,
+      destination: destination.destination));
+  }
+
+  /// In debug mode, controls whether typing notices should be sent.
+  ///
+  /// Outside of debug mode, this is always true and the setter has no effect.
+  static bool get debugEnable {
+    bool result = true;
+    assert(() {
+      result = _debugEnable;
+      return true;
+    }());
+    return result;
+  }
+  static bool _debugEnable = true;
+  static set debugEnable(bool value) {
+    assert(() {
+      _debugEnable = value;
+      return true;
+    }());
+  }
+
+  @visibleForTesting
+  static void debugReset() {
+    _debugEnable = true;
+  }
+}
diff --git a/test/model/typing_status_test.dart b/test/model/typing_status_test.dart
index a30a69bea6..f9a4a852e6 100644
--- a/test/model/typing_status_test.dart
+++ b/test/model/typing_status_test.dart
@@ -1,14 +1,25 @@
+import 'dart:convert';
+
 import 'package:checks/checks.dart';
+import 'package:fake_async/fake_async.dart';
 import 'package:flutter_test/flutter_test.dart';
+import 'package:http/http.dart' as http;
 import 'package:zulip/api/model/events.dart';
 import 'package:zulip/api/model/model.dart';
 import 'package:zulip/model/narrow.dart';
+import 'package:zulip/model/store.dart';
 import 'package:zulip/model/typing_status.dart';
 
+import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
 import '../fake_async.dart';
+import '../stdlib_checks.dart';
+import 'binding.dart';
+import 'test_store.dart';
 
 void main() {
+  TestZulipBinding.ensureInitialized();
+
   late TypingStatus model;
   late int notifiedCount;
 
@@ -210,4 +221,283 @@ void main() {
       checkNotifiedOnce();
     }));
   });
+
+  group('handle set typing status', () {
+    late PerAccountStore store;
+    late TypingNotifier model;
+    late FakeApiConnection connection;
+    late TopicNarrow narrow;
+
+    void checkSetTypingStatusRequests(
+      FakeApiConnection connection,
+      List<(TypingOp, SendableNarrow)> requests,
+    ) {
+      Condition<Object?> conditionTypingRequest(Map<String, String> expected) {
+        return (Subject<Object?> it) => it.isA<http.Request>()
+          ..method.equals('POST')
+          ..url.path.equals('/api/v1/typing')
+          ..bodyFields.deepEquals(expected);
+      }
+
+      check(connection.takeRequests()).deepEquals([
+        for (final (op, narrow) in requests)
+          switch (narrow) {
+            TopicNarrow() => conditionTypingRequest({
+              'type': 'channel',
+              'op': op.toJson(),
+              'stream_id': narrow.streamId.toString(),
+              'topic': narrow.topic}),
+            DmNarrow() => conditionTypingRequest({
+              'type': 'direct',
+              'op': op.toJson(),
+              'to': jsonEncode(narrow.allRecipientIds)}),
+          }
+      ]);
+    }
+
+    void checkTypingRequest(TypingOp op, SendableNarrow narrow) =>
+      checkSetTypingStatusRequests(connection, [(op, narrow)]);
+
+    Future<void> prepare() async {
+      addTearDown(testBinding.reset);
+      // Only test with the latest behavior of the setTypingStatus API.
+      // (Legacy variations are covered by setTypingStatus's own tests.)
+      final account = eg.account(
+        user: eg.selfUser, zulipFeatureLevel: eg.futureZulipFeatureLevel);
+      store = eg.store(account: account, initialSnapshot: eg.initialSnapshot(
+        zulipFeatureLevel: eg.futureZulipFeatureLevel));
+      model = store.typingNotifier;
+      connection = store.connection as FakeApiConnection;
+
+      final channel = eg.stream();
+      await store.addStream(channel);
+      await store.addSubscription(eg.subscription(channel));
+      narrow = TopicNarrow(channel.streamId, 'topic');
+    }
+
+    /// Prepares store and triggers a "typing started" notice.
+    Future<void> prepareStartTyping(FakeAsync async) async {
+      await prepare();
+      connection.prepare(json: {});
+      model.keystroke(narrow);
+      checkTypingRequest(TypingOp.start, narrow);
+
+      // Finish the pending API request first,
+      // so that the idle timer is the only timer left.
+      async.elapse(Duration.zero);
+      check(async.pendingTimers).single;
+    }
+
+    test('start typing repeatedly extends idle timer', () => awaitFakeAsync((async) async {
+      // t = 0ms: Start typing. The idle timer is set to typingStoppedWaitPeriod.
+      await prepareStartTyping(async);
+
+      const waitTime = Duration(milliseconds: 100);
+      // [waitTime] should not be long enough
+      // to trigger a "typing stopped" notice.
+      assert(waitTime < model.typingStoppedWaitPeriod);
+
+      async.elapse(waitTime);
+      // t = 100ms: The idle timer is reset to typingStoppedWaitPeriod.
+      connection.prepare(json: {});
+      model.keystroke(narrow);
+      check(connection.lastRequest).isNull();
+      check(async.pendingTimers).single;
+
+      async.elapse(model.typingStoppedWaitPeriod - const Duration(milliseconds: 1));
+      // t = typingStoppedWaitPeriod + 99ms:
+      //   Since the timer was reset at t = 100ms, the "typing stopped" notice has
+      //   not been sent yet.
+      check(connection.lastRequest).isNull();
+      check(async.pendingTimers).single;
+
+      async.elapse(const Duration(milliseconds: 1));
+      // t = typingStoppedWaitPeriod + 100ms:
+      //   The new timer expires and the "typing stopped" notice is sent.
+      checkTypingRequest(TypingOp.stop, narrow);
+    }));
+
+    test('start typing repeatedly does not resend "typing started" notices', () => awaitFakeAsync((async) async {
+      // t = 0ms: Start typing.
+      await prepareStartTyping(async);
+
+      const waitInterval = Duration(milliseconds: 2000);
+      // [waitInterval] should not be long enough
+      // to trigger a "typing stopped" notice.
+      assert(waitInterval < model.typingStoppedWaitPeriod);
+      // [waitInterval] should be short enough
+      // that the loop below runs more than once.
+      assert(waitInterval < model.typingStartedWaitPeriod);
+
+      while (async.elapsed <= model.typingStartedWaitPeriod) {
+        // t <= typingStartedWaitPeriod: "Typing started" notices are throttled.
+        model.keystroke(narrow);
+        check(connection.lastRequest).isNull();
+
+        async.elapse(waitInterval);
+      }
+
+      // t > typingStartedWaitPeriod: Resume sending "typing started" notices.
+      connection.prepare(json: {});
+      model.keystroke(narrow);
+      checkTypingRequest(TypingOp.start, narrow);
+
+      // Ensures that a "typing stopped" notice is sent when the test ends.
+      connection.prepare(json: {});
+      async.flushTimers();
+      checkTypingRequest(TypingOp.stop, narrow);
+    }));
+
+    test('after stopped wait period, send a "typing stopped" notice', () => awaitFakeAsync((async) async {
+      await prepareStartTyping(async);
+
+      connection.prepare(json: {});
+      async.elapse(model.typingStoppedWaitPeriod);
+      checkTypingRequest(TypingOp.stop, narrow);
+      check(async.pendingTimers).isEmpty();
+    }));
+
+    test('actively stopping typing cancels the idle timer', () => awaitFakeAsync((async) async {
+      await prepareStartTyping(async);
+
+      connection.prepare(json: {});
+      model.stoppedComposing();
+      checkTypingRequest(TypingOp.stop, narrow);
+
+      async.elapse(Duration.zero);
+      check(async.pendingTimers).isEmpty();
+    }));
+
+    test('stop typing then start typing should result in a new "typing started" notice', () => awaitFakeAsync((async) async {
+      await prepareStartTyping(async);
+
+      connection.prepare(json: {});
+      model.stoppedComposing();
+      checkTypingRequest(TypingOp.stop, narrow);
+
+      // The "typing started" notice would have been throttled if we did not
+      // reset the TypingNotifier internal states before sending the "typing
+      // stopped" notice.
+      connection.prepare(json: {});
+      model.keystroke(narrow);
+      checkTypingRequest(TypingOp.start, narrow);
+
+      // Ensures that a "typing stopped" notice is sent when the test ends.
+      connection.prepare(json: {});
+      async.flushTimers();
+      checkTypingRequest(TypingOp.stop, narrow);
+    }));
+
+    test('disposing store cancels the idle timer', () => awaitFakeAsync((async) async {
+      await prepareStartTyping(async);
+
+      store.dispose();
+      check(async.pendingTimers).isEmpty();
+    }));
+
+    test('start typing in a different destination resets the idle timer', () => awaitFakeAsync((async) async {
+      await prepare();
+      final topicNarrow = narrow;
+      final dmNarrow = DmNarrow.withUsers(
+        [eg.otherUser.userId], selfUserId: eg.selfUser.userId);
+
+      const waitTime = Duration(milliseconds: 100);
+      // [waitTime] should not be long enough
+      // to trigger a "typing stopped" notice.
+      assert(waitTime < model.typingStoppedWaitPeriod);
+
+      // t = 0ms: Start typing. The idle timer is set to typingStoppedWaitPeriod.
+      connection.prepare(json: {});
+      model.keystroke(topicNarrow);
+      checkTypingRequest(TypingOp.start, topicNarrow);
+
+      async.elapse(Duration.zero);
+      check(async.pendingTimers).single;
+
+      async.elapse(waitTime);
+      // t = 100ms:
+      //   Start typing in a different narrow. The timer should be reset
+      //   and the previous typing indicator should be dismissed.
+      connection.prepare(json: {});
+      connection.prepare(json: {});
+      model.keystroke(dmNarrow);
+      checkSetTypingStatusRequests(connection,
+        [(TypingOp.stop, topicNarrow), (TypingOp.start, dmNarrow)]);
+
+      async.elapse(Duration.zero);
+      check(async.pendingTimers).single;
+
+      async.elapse(model.typingStoppedWaitPeriod - waitTime);
+      // t = typingStoppedPeriod:
+      //   Because the old timer has been canceled at t = 100ms,
+      //   no "typing stopped" notice has been sent yet.
+      check(connection.lastRequest).isNull();
+      check(async.pendingTimers).single;
+
+      connection.prepare(json: {});
+      async.elapse(waitTime);
+      // t = typingStoppedPeriod + 100ms:
+      //   The new timer has expired, and a "typing stopped" notice is expected.
+      checkTypingRequest(TypingOp.stop, dmNarrow);
+    }));
+
+    test('start typing in a different destination resets typing started wait timeout', () => awaitFakeAsync((async) async {
+      await prepare();
+      final topicNarrow = narrow;
+      final dmNarrow = DmNarrow.withUsers(
+        [eg.otherUser.userId], selfUserId: eg.selfUser.userId);
+
+      const waitInterval = Duration(milliseconds: 2000);
+      // [waitInterval] should not be long enough
+      // to trigger a "typing stopped" notice.
+      assert(waitInterval < model.typingStoppedWaitPeriod);
+
+      // t = 0ms: Start typing. The typing started time is set to 0ms.
+      connection.prepare(json: {});
+      model.keystroke(topicNarrow);
+      checkTypingRequest(TypingOp.start, topicNarrow);
+
+      async.elapse(waitInterval);
+      // t = waitInterval * 1:
+      //   Start typing in a different narrow.  The last time we sent
+      //   a "typing started" notice should be reset to t.
+      //   The previous typing indicator should be dismissed
+      //   as we start the new one, which results in two requests.
+      connection.prepare(json: {});
+      connection.prepare(json: {});
+      model.keystroke(dmNarrow);
+      checkSetTypingStatusRequests(connection,
+        [(TypingOp.stop, topicNarrow), (TypingOp.start, dmNarrow)]);
+
+      while (async.elapsed <= model.typingStartedWaitPeriod) {
+        // t <= typingStartedWaitPeriod: "still typing" requests are throttled.
+        model.keystroke(dmNarrow);
+        check(connection.lastRequest).isNull();
+
+        async.elapse(waitInterval);
+      }
+
+      assert(async.elapsed > model.typingStartedWaitPeriod);
+      assert(async.elapsed <= model.typingStartedWaitPeriod + waitInterval);
+      // typingStartedWaitPeriod < t <= typingStartedWaitPeriod + waitInterval * 1:
+      //   The "still typing" requests are still throttled, because it hasn't
+      //   been a full typingStartedWaitPeriod since the last time we sent
+      //   a "typing started" notice at t = waitInterval * 1.
+      model.keystroke(dmNarrow);
+      check(connection.lastRequest).isNull();
+
+      async.elapse(waitInterval);
+      // t > typingStartedWaitPeriod + waitInterval * 1:
+      //   Resume sending "typing started" notices, because it has been just
+      //   enough time since the last time we sent a "typing started" notice.
+      connection.prepare(json: {});
+      model.keystroke(dmNarrow);
+      checkTypingRequest(TypingOp.start, dmNarrow);
+
+      // Ensures that a "typing stopped" notice is sent when the test ends.
+      connection.prepare(json: {});
+      async.flushTimers();
+      checkTypingRequest(TypingOp.stop, dmNarrow);
+    }));
+  });
 }
