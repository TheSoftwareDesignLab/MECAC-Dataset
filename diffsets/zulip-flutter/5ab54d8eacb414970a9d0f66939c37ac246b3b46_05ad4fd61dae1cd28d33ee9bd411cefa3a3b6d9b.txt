diff --git a/lib/widgets/scrolling.dart b/lib/widgets/scrolling.dart
index 665659aefa..7ceff8b745 100644
--- a/lib/widgets/scrolling.dart
+++ b/lib/widgets/scrolling.dart
@@ -1,4 +1,5 @@
 import 'package:flutter/material.dart';
+import 'package:flutter/rendering.dart';
 
 /// A [SingleChildScrollView] that always shows a Material [Scrollbar].
 ///
@@ -37,3 +38,209 @@ class _SingleChildScrollViewWithScrollbarState
         child: widget.child));
   }
 }
+
+/// Specifies an order in which to paint the slivers of a [CustomScrollView].
+///
+/// Whichever order the slivers are painted in,
+/// they will be hit-tested in the opposite order.
+///
+/// This can also be thought of as an ordering in the z-direction:
+/// whichever sliver is painted last (and hit-tested first) is on top,
+/// because it will paint over other slivers if there is overlap.
+/// Similarly, whichever sliver is painted first (and hit-tested last)
+/// is on the bottom.
+enum SliverPaintOrder {
+  /// The first sliver paints on top, and the last sliver on bottom.
+  ///
+  /// The slivers are painted in the reverse order of [CustomScrollView.slivers],
+  /// and hit-tested in the same order as [CustomScrollView.slivers].
+  firstIsTop,
+
+  /// The last sliver paints on top, and the first sliver on bottom.
+  ///
+  /// The slivers are painted in the same order as [CustomScrollView.slivers],
+  /// and hit-tested in the reverse order.
+  lastIsTop,
+
+  /// The default order for [CustomScrollView]: the center sliver paints on top,
+  /// and the first sliver paints on bottom.
+  ///
+  /// If [CustomScrollView.center] is null or corresponds to the first sliver
+  /// in [CustomScrollView.slivers], this order is equivalent to [firstIsTop].
+  /// Otherwise, the [CustomScrollView.center] sliver paints on top;
+  /// it's followed in the z-order by the slivers after it to the end
+  /// of the list, then the slivers before the center in reverse order,
+  /// with the first sliver in the list at the bottom in the z-direction.
+  centerTopFirstBottom,
+}
+
+/// A [CustomScrollView] with control over the paint order, or z-order,
+/// between slivers.
+///
+/// This is just like [CustomScrollView] except it adds the [paintOrder_] field.
+///
+/// (Actually there's one [CustomScrollView] feature this doesn't implement:
+/// [shrinkWrap] always has its default value of false.  That feature would be
+/// easy to add if desired.)
+// TODO(upstream): Pending PR: https://github.com/flutter/flutter/pull/164818
+//   Notes from before sending that PR:
+//   Add an option [ScrollView.zOrder]?  (An enum, or possibly
+//   a delegate.)  Or at minimum document on [ScrollView.center] the
+//   existing behavior, which is counterintuitive.
+//   Nearest related upstream feature requests I find are for a "z-index",
+//   for CustomScrollView, Column, Row, and Stack respectively:
+//     https://github.com/flutter/flutter/issues/121173#issuecomment-1712825747
+//     https://github.com/flutter/flutter/issues/121173
+//     https://github.com/flutter/flutter/issues/121173#issuecomment-1914959184
+//     https://github.com/flutter/flutter/issues/70836
+//   A delegate would give enough flexibility for that and much else,
+//   but I'm not sure how many use cases wouldn't be covered by a small enum.
+//
+//   Ah, and here's a more on-point issue (more recently):
+//     https://github.com/flutter/flutter/issues/145592
+//
+// TODO: perhaps sticky_header should configure a CustomPaintOrderScrollView automatically?
+class CustomPaintOrderScrollView extends CustomScrollView {
+  const CustomPaintOrderScrollView({
+    super.key,
+    super.scrollDirection,
+    super.reverse,
+    super.controller,
+    super.primary,
+    super.physics,
+    super.scrollBehavior,
+    // super.shrinkWrap, // omitted, always false
+    super.center,
+    super.anchor,
+    super.cacheExtent,
+    super.slivers,
+    super.semanticChildCount,
+    super.dragStartBehavior,
+    super.keyboardDismissBehavior,
+    super.restorationId,
+    super.clipBehavior,
+    super.hitTestBehavior,
+    SliverPaintOrder paintOrder = SliverPaintOrder.centerTopFirstBottom,
+  }) : paintOrder_ = paintOrder;
+
+  /// The order in which to paint the slivers;
+  /// equivalently, the order in which to arrange them in the z-direction.
+  ///
+  /// Whichever order the slivers are painted in,
+  /// they will be hit-tested in the opposite order.
+  ///
+  /// To think of this as an ordering in the z-direction:
+  /// whichever sliver is painted last (and hit-tested first) is on top,
+  /// because it will paint over other slivers if there is overlap.
+  /// Similarly, whichever sliver is painted first (and hit-tested last)
+  /// is on the bottom.
+  ///
+  /// This defaults to [SliverPaintOrder.centerTopFirstBottom],
+  /// the behavior of the [CustomScrollView] base class.
+  final SliverPaintOrder paintOrder_;
+
+  @override
+  Widget buildViewport(BuildContext context, ViewportOffset offset,
+      AxisDirection axisDirection, List<Widget> slivers) {
+    return CustomPaintOrderViewport(
+      axisDirection: axisDirection,
+      offset: offset,
+      slivers: slivers,
+      cacheExtent: cacheExtent,
+      center: center,
+      anchor: anchor,
+      clipBehavior: clipBehavior,
+      paintOrder_: paintOrder_,
+    );
+  }
+}
+
+/// The viewport configured by a [CustomPaintOrderScrollView].
+class CustomPaintOrderViewport extends Viewport {
+  CustomPaintOrderViewport({
+    super.key,
+    super.axisDirection,
+    super.crossAxisDirection,
+    super.anchor,
+    required super.offset,
+    super.center,
+    super.cacheExtent,
+    super.cacheExtentStyle,
+    super.slivers,
+    super.clipBehavior,
+    required this.paintOrder_,
+  });
+
+  final SliverPaintOrder paintOrder_;
+
+  @override
+  RenderViewport createRenderObject(BuildContext context) {
+    return RenderCustomPaintOrderViewport(
+      axisDirection: axisDirection,
+      crossAxisDirection: crossAxisDirection
+        ?? Viewport.getDefaultCrossAxisDirection(context, axisDirection),
+      anchor: anchor,
+      offset: offset,
+      cacheExtent: cacheExtent,
+      cacheExtentStyle: cacheExtentStyle,
+      clipBehavior: clipBehavior,
+      paintOrder_: paintOrder_,
+    );
+  }
+}
+
+/// The render object configured by a [CustomPaintOrderViewport].
+class RenderCustomPaintOrderViewport extends RenderViewport {
+  RenderCustomPaintOrderViewport({
+    super.axisDirection,
+    required super.crossAxisDirection,
+    required super.offset,
+    super.anchor,
+    super.children,
+    super.center,
+    super.cacheExtent,
+    super.cacheExtentStyle,
+    super.clipBehavior,
+    required this.paintOrder_,
+  });
+
+  final SliverPaintOrder paintOrder_;
+
+  Iterable<RenderSliver> get _lastToFirst {
+    final List<RenderSliver> children = <RenderSliver>[];
+    RenderSliver? child = lastChild;
+    while (child != null) {
+      children.add(child);
+      child = childBefore(child);
+    }
+    return children;
+  }
+
+  Iterable<RenderSliver> get _firstToLast {
+    final List<RenderSliver> children = <RenderSliver>[];
+    RenderSliver? child = firstChild;
+    while (child != null) {
+      children.add(child);
+      child = childAfter(child);
+    }
+    return children;
+  }
+
+  @override
+  Iterable<RenderSliver> get childrenInPaintOrder {
+    return switch (paintOrder_) {
+      SliverPaintOrder.firstIsTop => _lastToFirst,
+      SliverPaintOrder.lastIsTop => _firstToLast,
+      SliverPaintOrder.centerTopFirstBottom => super.childrenInPaintOrder,
+    };
+  }
+
+  @override
+  Iterable<RenderSliver> get childrenInHitTestOrder {
+    return switch (paintOrder_) {
+      SliverPaintOrder.firstIsTop => _firstToLast,
+      SliverPaintOrder.lastIsTop => _lastToFirst,
+      SliverPaintOrder.centerTopFirstBottom => super.childrenInHitTestOrder,
+    };
+  }
+}
diff --git a/test/widgets/scrolling_test.dart b/test/widgets/scrolling_test.dart
new file mode 100644
index 0000000000..bfb010ccf0
--- /dev/null
+++ b/test/widgets/scrolling_test.dart
@@ -0,0 +1,191 @@
+import 'package:checks/checks.dart';
+// ignore: undefined_hidden_name // anticipates https://github.com/flutter/flutter/pull/164818
+import 'package:flutter/rendering.dart' hide SliverPaintOrder;
+// ignore: undefined_hidden_name // anticipates https://github.com/flutter/flutter/pull/164818
+import 'package:flutter/widgets.dart' hide SliverPaintOrder;
+import 'package:flutter_test/flutter_test.dart';
+import 'package:zulip/widgets/scrolling.dart';
+
+void main() {
+  group('CustomPaintOrderScrollView paint order', () {
+    final paintLog = <int>[];
+
+    Widget makeSliver(int i) {
+      return SliverToBoxAdapter(
+        key: ValueKey(i),
+        child: CustomPaint(
+          painter: TestCustomPainter()
+            ..onPaint = (_, _) => paintLog.add(i),
+          child: Text('Item $i')));
+    }
+
+    testWidgets('firstIsTop', (tester) async {
+      addTearDown(paintLog.clear);
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomPaintOrderScrollView(
+          paintOrder: SliverPaintOrder.firstIsTop,
+          center: ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+
+      // First sliver paints last, over other slivers; last sliver paints first.
+      check(paintLog).deepEquals([4, 3, 2, 1, 0]);
+    });
+
+    testWidgets('lastIsTop', (tester) async {
+      addTearDown(paintLog.clear);
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomPaintOrderScrollView(
+          paintOrder: SliverPaintOrder.lastIsTop,
+          center: ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+
+      // Last sliver paints last, over other slivers; first sliver paints first.
+      check(paintLog).deepEquals([0, 1, 2, 3, 4]);
+    });
+
+    // This test will fail if a corresponding upstream PR lands:
+    //   https://github.com/flutter/flutter/pull/164818
+    // because that eliminates the quirky centerTopFirstBottom behavior.
+    // In that case, skip this test for a quick fix; or go ahead and
+    // rip out CustomPaintOrderScrollView in favor of CustomScrollView.
+    // (Greg has a draft commit ready which does the latter.)
+    testWidgets('centerTopFirstBottom', (tester) async {
+      addTearDown(paintLog.clear);
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomPaintOrderScrollView(
+          paintOrder: SliverPaintOrder.centerTopFirstBottom,
+          center: ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+
+      // The particular order CustomScrollView paints in.
+      check(paintLog).deepEquals([0, 1, 4, 3, 2]);
+
+      // Check that CustomScrollView indeed paints in the same order.
+      final result = paintLog.toList();
+      paintLog.clear();
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomScrollView(
+          center: ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+      check(paintLog).deepEquals(result);
+    });
+  });
+
+  group('CustomPaintOrderScrollView hit-test order', () {
+    Widget makeSliver(int i) {
+      return _AllOverlapSliver(key: ValueKey<int>(i), id: i);
+    }
+
+    List<int> sliverIds(Iterable<HitTestEntry> path) => [
+        for (final e in path)
+          if (e.target case _RenderAllOverlapSliver(:final id))
+            id,
+      ];
+
+    testWidgets('firstIsTop', (WidgetTester tester) async {
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomPaintOrderScrollView(
+          paintOrder: SliverPaintOrder.firstIsTop,
+          center: const ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+
+      final result = tester.hitTestOnBinding(const Offset(400, 300));
+      check(sliverIds(result.path)).deepEquals([0, 1, 2, 3, 4]);
+    });
+
+    testWidgets('lastIsTop', (WidgetTester tester) async {
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomPaintOrderScrollView(
+          paintOrder: SliverPaintOrder.lastIsTop,
+          center: const ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+
+      final result = tester.hitTestOnBinding(const Offset(400, 300));
+      check(sliverIds(result.path)).deepEquals([4, 3, 2, 1, 0]);
+    });
+
+    // This test will fail if the upstream PR 164818 lands.
+    // In that case the test is no longer needed and we'll take it out;
+    // see comment on other centerTopFirstBottom test above.
+    testWidgets('centerTopFirstBottom', (tester) async {
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomPaintOrderScrollView(
+          paintOrder: SliverPaintOrder.centerTopFirstBottom,
+          center: const ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+
+      final result = tester.hitTestOnBinding(const Offset(400, 300));
+      // The particular order CustomScrollView hit-tests in.
+      check(sliverIds(result.path)).deepEquals([2, 3, 4, 1, 0]);
+
+      // Check that CustomScrollView indeed hit-tests in the same order.
+      await tester.pumpWidget(Directionality(textDirection: TextDirection.ltr,
+        child: CustomScrollView(
+          center: const ValueKey(2), anchor: 0.5,
+          slivers: List.generate(5, makeSliver))));
+      check(sliverIds(tester.hitTestOnBinding(const Offset(400, 300)).path))
+        .deepEquals(sliverIds(result.path));
+    });
+  });
+}
+
+class TestCustomPainter extends CustomPainter {
+  void Function(Canvas canvas, Size size)? onPaint;
+
+  @override
+  void paint(Canvas canvas, Size size) {
+    if (onPaint != null) onPaint!(canvas, size);
+  }
+
+  @override
+  bool shouldRepaint(covariant CustomPainter oldDelegate) {
+    return true;
+  }
+}
+
+/// A sliver that overlaps with other slivers as far as possible,
+/// and does nothing else.
+class _AllOverlapSliver extends LeafRenderObjectWidget {
+  const _AllOverlapSliver({super.key, required this.id});
+
+  final int id;
+
+  @override
+  RenderObject createRenderObject(BuildContext context) => _RenderAllOverlapSliver(id);
+}
+
+class _RenderAllOverlapSliver extends RenderSliver {
+  _RenderAllOverlapSliver(this.id);
+
+  final int id;
+
+  @override
+  void performLayout() {
+    geometry = SliverGeometry(
+      paintExtent: constraints.remainingPaintExtent,
+      maxPaintExtent: constraints.remainingPaintExtent,
+      layoutExtent: 0.0,
+    );
+  }
+
+  @override
+  bool hitTest(
+    SliverHitTestResult result, {
+    required double mainAxisPosition,
+    required double crossAxisPosition,
+  }) {
+    if (mainAxisPosition >= 0.0 &&
+        mainAxisPosition < geometry!.hitTestExtent &&
+        crossAxisPosition >= 0.0 &&
+        crossAxisPosition < constraints.crossAxisExtent) {
+      result.add(
+        SliverHitTestEntry(
+          this,
+          mainAxisPosition: mainAxisPosition,
+          crossAxisPosition: crossAxisPosition,
+        ),
+      );
+    }
+    return false;
+  }
+}
