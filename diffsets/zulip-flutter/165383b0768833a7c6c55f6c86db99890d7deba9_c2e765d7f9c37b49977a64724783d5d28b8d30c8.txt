diff --git a/lib/model/content.dart b/lib/model/content.dart
index 8fc8dc60cf..66ed09a011 100644
--- a/lib/model/content.dart
+++ b/lib/model/content.dart
@@ -120,9 +120,26 @@ class UnimplementedBlockContentNode extends BlockContentNode
 class BlockInlineContainerNode extends BlockContentNode {
   const BlockInlineContainerNode({
     super.debugHtmlNode,
+    required this.links,
     required this.nodes,
   });
 
+  /// A list of all [LinkNode] descendants.
+  ///
+  /// An empty list is represented as null.
+  ///
+  /// Because this lists all descendants that are [LinkNode]s,
+  /// it carries no information that couldn't be computed from [nodes].
+  /// It exists as an optimization, to allow a widget interpreting this node
+  /// to obtain that list during build without having to walk the [nodes] tree.
+  //
+  // We leave [links] out of [debugFillProperties], because it should carry
+  // no information that's not already in [nodes].
+  // Our tests validate that invariant systematically
+  // (see `_checkLinks` in `test/model/content_checks.dart`),
+  // and give a specialized error message if it fails.
+  final List<LinkNode>? links; // TODO perhaps use `const []` instead of null
+
   final List<InlineContentNode> nodes;
 
   @override
@@ -153,8 +170,12 @@ class LineBreakNode extends BlockContentNode {
 ///
 /// See also [parseImplicitParagraphBlockContentList].
 class ParagraphNode extends BlockInlineContainerNode {
-  const ParagraphNode(
-    {super.debugHtmlNode, required super.nodes, this.wasImplicit = false});
+  const ParagraphNode({
+    super.debugHtmlNode,
+    this.wasImplicit = false,
+    required super.links,
+    required super.nodes,
+  });
 
   /// True when there was no corresponding `p` element in the original HTML.
   final bool wasImplicit;
@@ -171,6 +192,7 @@ enum HeadingLevel { h1, h2, h3, h4, h5, h6 }
 class HeadingNode extends BlockInlineContainerNode {
   const HeadingNode({
     super.debugHtmlNode,
+    required super.links,
     required super.nodes,
     required this.level,
   });
@@ -380,6 +402,12 @@ class LinkNode extends InlineContainerNode {
   // TODO(#71): Use [LinkNode.url] to open links
   final String url; // Left as a string, to defer parsing until link actually followed.
 
+  // Unlike other [ContentNode]s, the identity is useful to show in debugging
+  // because the identical [LinkNode]s are expected in the enclosing
+  // [BlockInlineContainerNode.links].
+  @override
+  String toStringShort() => "${objectRuntimeType(this, 'LinkNode')}#${shortHash(this)}";
+
   @override
   void debugFillProperties(DiagnosticPropertiesBuilder properties) {
     super.debugFillProperties(properties);
@@ -470,6 +498,18 @@ class _ZulipContentParser {
   /// and should be read or updated only inside an assertion.
   _ParserContext _debugParserContext = _ParserContext.block;
 
+  /// The links found so far in the current block inline container.
+  ///
+  /// Empty is represented as null.
+  /// This is also null when not within a block inline container.
+  List<LinkNode>? _linkNodes;
+
+  List<LinkNode>? _takeLinkNodes() {
+    final result = _linkNodes;
+    _linkNodes = null;
+    return result;
+  }
+
   static final _emojiClassRegexp = RegExp(r"^emoji(-[0-9a-f]+)?$");
 
   InlineContentNode parseInlineContent(dom.Node node) {
@@ -509,7 +549,9 @@ class _ZulipContentParser {
                     || classes.contains('stream'))))) {
       final href = element.attributes['href'];
       if (href == null) return unimplemented();
-      return LinkNode(nodes: nodes(), url: href, debugHtmlNode: debugHtmlNode);
+      final link = LinkNode(nodes: nodes(), url: href, debugHtmlNode: debugHtmlNode);
+      (_linkNodes ??= []).add(link);
+      return link;
     }
 
     if (localName == 'span'
@@ -546,7 +588,7 @@ class _ZulipContentParser {
     return nodes.map(parseInlineContent).toList(growable: false);
   }
 
-  List<InlineContentNode> parseBlockInline(List<dom.Node> nodes) {
+  ({List<InlineContentNode> nodes, List<LinkNode>? links}) parseBlockInline(List<dom.Node> nodes) {
     assert(_debugParserContext == _ParserContext.block);
     assert(() {
       _debugParserContext = _ParserContext.inline;
@@ -557,7 +599,7 @@ class _ZulipContentParser {
       _debugParserContext = _ParserContext.block;
       return true;
     }());
-    return resultNodes;
+    return (nodes: resultNodes, links: _takeLinkNodes());
   }
 
   BlockContentNode parseListNode(dom.Element element) {
@@ -687,8 +729,10 @@ class _ZulipContentParser {
     }
 
     if (localName == 'p' && classes.isEmpty) {
+      final parsed = parseBlockInline(element.nodes);
       return ParagraphNode(debugHtmlNode: debugHtmlNode,
-        nodes: parseBlockInline(element.nodes));
+        links: parsed.links,
+        nodes: parsed.nodes);
     }
 
     HeadingLevel? headingLevel;
@@ -702,9 +746,11 @@ class _ZulipContentParser {
     }
     if (headingLevel == HeadingLevel.h6 && classes.isEmpty) {
       // TODO(#192) handle h1, h2, h3, h4, h5
+      final parsed = parseBlockInline(element.nodes);
       return HeadingNode(debugHtmlNode: debugHtmlNode,
         level: headingLevel!,
-        nodes: parseBlockInline(element.nodes));
+        links: parsed.links,
+        nodes: parsed.nodes);
     }
 
     if ((localName == 'ol' || localName == 'ul') && classes.isEmpty) {
@@ -759,9 +805,11 @@ class _ZulipContentParser {
     final List<BlockContentNode> result = [];
     final List<dom.Node> currentParagraph = [];
     void consumeParagraph() {
+      final parsed = parseBlockInline(currentParagraph);
       result.add(ParagraphNode(
         wasImplicit: true,
-        nodes: parseBlockInline(currentParagraph)));
+        links: parsed.links,
+        nodes: parsed.nodes));
       currentParagraph.clear();
     }
 
diff --git a/test/model/content_checks.dart b/test/model/content_checks.dart
index c9f38af1a7..da993c7423 100644
--- a/test/model/content_checks.dart
+++ b/test/model/content_checks.dart
@@ -3,6 +3,11 @@ import 'package:flutter/foundation.dart';
 import 'package:zulip/model/content.dart';
 
 extension ContentNodeChecks on Subject<ContentNode> {
+  // In [expected], for the `links` field of [ParagraphNode] or
+  // any other [BlockInlineContainerNode] subclass, use `null`.
+  // This field will be ignored in [expected], and instead the
+  // field's value in [actual] will be checked for accuracy against
+  // the [BlockInlineContainerNode.nodes] field on the same node.
   void equalsNode(ContentNode expected) {
     return context.expect(() => prefixFirst('equals ', literal(expected)), (actual) {
       final which = _compareDiagnosticsNodes(
@@ -58,5 +63,55 @@ Iterable<String>? _compareDiagnosticsNodes(DiagnosticsNode actual, DiagnosticsNo
     }
   }
 
+  if (actual.value is BlockInlineContainerNode) {
+    final failure = _checkLinks(actual.value as BlockInlineContainerNode);
+    if (failure != null) {
+      return failure;
+    }
+  }
+
   return null;
 }
+
+Iterable<String>? _checkLinks(BlockInlineContainerNode node) {
+  final foundLinks = _findLinkNodes(node.nodes).toList();
+  final which = () {
+    var actualLinks = node.links;
+    if (actualLinks != null && actualLinks.isEmpty) {
+      return ['has empty non-null links'];
+    }
+    actualLinks ??= [];
+    if (actualLinks.length != foundLinks.length) {
+      return ['has ${actualLinks.length} links while nodes has ${foundLinks.length}'];
+    }
+    for (int i = 0; i < foundLinks.length; i++) {
+      if (!identical(actualLinks[i], foundLinks[i])) {
+        return ['has a mismatch in links at element $i'];
+      }
+    }
+  }();
+
+  if (which == null) return null;
+
+  return [
+    ...which,
+    'Actual links property:',
+    ...indent(literal(node.links)),
+    'Expected links, from actual nodes:',
+    ...indent(literal(foundLinks)),
+  ];
+}
+
+Iterable<LinkNode> _findLinkNodes(Iterable<InlineContentNode> nodes) {
+  return nodes.expand((node) {
+    if (node is! InlineContainerNode) return const [];
+    if (node is LinkNode) {
+      // HTML disallows `a` as a descendant of `a`:
+      //   https://html.spec.whatwg.org/#the-a-element (see "Content model")
+      // and Dart's HTML parser seems not to produce it in the DOM.
+      assert(_findLinkNodes(node.nodes).isEmpty);
+      return [node];
+    }
+    return _findLinkNodes(node.nodes);
+  });
+}
diff --git a/test/model/content_test.dart b/test/model/content_test.dart
index 2fb64ed121..274496d48e 100644
--- a/test/model/content_test.dart
+++ b/test/model/content_test.dart
@@ -52,18 +52,18 @@ void main() {
   //
 
   void testParseInline(String name, String html, InlineContentNode node) {
-    testParse(name, html, [ParagraphNode(nodes: [node])]);
+    testParse(name, html, [ParagraphNode(links: null, nodes: [node])]);
   }
 
   testParse('parse a plain-text paragraph',
     // "hello world"
-    '<p>hello world</p>', const [ParagraphNode(nodes: [
+    '<p>hello world</p>', const [ParagraphNode(links: null, nodes: [
       TextNode('hello world'),
     ])]);
 
   testParse('parse <br> inside a paragraph',
     // "a\nb"
-    '<p>a<br>\nb</p>', const [ParagraphNode(nodes: [
+    '<p>a<br>\nb</p>', const [ParagraphNode(links: null, nodes: [
       TextNode('a'),
       LineBreakInlineNode(),
       TextNode('\nb'),
@@ -90,25 +90,27 @@ void main() {
     const StrongNode(nodes: [EmphasisNode(nodes: [InlineCodeNode(nodes: [
       TextNode('word')])])]));
 
-  testParseInline('parse link',
-    // "[text](https://example/)"
-    '<p><a href="https://example/">text</a></p>',
-    const LinkNode(url: 'https://example/', nodes: [TextNode('text')]));
-
-  testParseInline('parse #-mention of stream',
-    // "#**general**"
-    '<p><a class="stream" data-stream-id="2" href="/#narrow/stream/2-general">'
-        '#general</a></p>',
-    const LinkNode(url: '/#narrow/stream/2-general',
-      nodes: [TextNode('#general')]));
-
-  testParseInline('parse #-mention of topic',
-    // "#**mobile-team>zulip-flutter**"
-    '<p><a class="stream-topic" data-stream-id="243" '
-        'href="/#narrow/stream/243-mobile-team/topic/zulip-flutter">'
-        '#mobile-team &gt; zulip-flutter</a></p>',
-    const LinkNode(url: '/#narrow/stream/243-mobile-team/topic/zulip-flutter',
-      nodes: [TextNode('#mobile-team > zulip-flutter')]));
+  group('LinkNode', () {
+    testParseInline('parse link',
+      // "[text](https://example/)"
+      '<p><a href="https://example/">text</a></p>',
+      const LinkNode(url: 'https://example/', nodes: [TextNode('text')]));
+
+    testParseInline('parse #-mention of stream',
+      // "#**general**"
+      '<p><a class="stream" data-stream-id="2" href="/#narrow/stream/2-general">'
+          '#general</a></p>',
+      const LinkNode(url: '/#narrow/stream/2-general',
+        nodes: [TextNode('#general')]));
+
+    testParseInline('parse #-mention of topic',
+      // "#**mobile-team>zulip-flutter**"
+      '<p><a class="stream-topic" data-stream-id="243" '
+          'href="/#narrow/stream/243-mobile-team/topic/zulip-flutter">'
+          '#mobile-team &gt; zulip-flutter</a></p>',
+      const LinkNode(url: '/#narrow/stream/243-mobile-team/topic/zulip-flutter',
+        nodes: [TextNode('#mobile-team > zulip-flutter')]));
+  });
 
   testParseInline('parse nested link, strong, em, code',
     // "[***`word`***](https://example/)"
@@ -118,6 +120,12 @@ void main() {
       nodes: [StrongNode(nodes: [EmphasisNode(nodes: [InlineCodeNode(nodes: [
         TextNode('word')])])])]));
 
+  testParseInline('parse nested strong, em, link',
+    // "***[t](/u)***"
+    '<p><strong><em><a href="/u">t</a></em></strong></p>',
+    const StrongNode(nodes: [EmphasisNode(nodes: [LinkNode(url: '/u',
+      nodes: [TextNode('t')])])]));
+
   group('parse @-mentions', () {
     testParseInline('plain user @-mention',
       // "@**Greg Price**"
@@ -156,28 +164,28 @@ void main() {
   testParse('parse <br> in block context',
     '<br><p>a</p><br>', const [ // TODO not sure how to reproduce this example
       LineBreakNode(),
-      ParagraphNode(nodes: [TextNode('a')]),
+      ParagraphNode(links: null, nodes: [TextNode('a')]),
       LineBreakNode(),
     ]);
 
   testParse('parse two plain-text paragraphs',
     // "hello\n\nworld"
     '<p>hello</p>\n<p>world</p>', const [
-      ParagraphNode(nodes: [TextNode('hello')]),
-      ParagraphNode(nodes: [TextNode('world')]),
+      ParagraphNode(links: null, nodes: [TextNode('hello')]),
+      ParagraphNode(links: null, nodes: [TextNode('world')]),
     ]);
 
   group('parse headings', () {
     testParse('plain h6',
       // "###### six"
       '<h6>six</h6>', const [
-        HeadingNode(level: HeadingLevel.h6, nodes: [TextNode('six')])]);
+        HeadingNode(level: HeadingLevel.h6, links: null, nodes: [TextNode('six')])]);
 
     testParse('containing inline markup',
       // "###### one [***`two`***](https://example/)"
       '<h6>one <a href="https://example/"><strong><em><code>two'
           '</code></em></strong></a></h6>', const [
-        HeadingNode(level: HeadingLevel.h6, nodes: [
+        HeadingNode(level: HeadingLevel.h6, links: null, nodes: [
           TextNode('one '),
           LinkNode(url: 'https://example/',
             nodes: [StrongNode(nodes: [EmphasisNode(nodes: [
@@ -187,9 +195,9 @@ void main() {
     testParse('amidst paragraphs',
       // "intro\n###### section\ntext"
       "<p>intro</p>\n<h6>section</h6>\n<p>text</p>", const [
-        ParagraphNode(nodes: [TextNode('intro')]),
-        HeadingNode(level: HeadingLevel.h6, nodes: [TextNode('section')]),
-        ParagraphNode(nodes: [TextNode('text')]),
+        ParagraphNode(links: null, nodes: [TextNode('intro')]),
+        HeadingNode(level: HeadingLevel.h6, links: null, nodes: [TextNode('section')]),
+        ParagraphNode(links: null, nodes: [TextNode('text')]),
       ]);
 
     testParse('h1, h2, h3, h4, h5 unimplemented',
@@ -208,8 +216,8 @@ void main() {
       // "1. first\n2. then"
       '<ol>\n<li>first</li>\n<li>then</li>\n</ol>', const [
         ListNode(ListStyle.ordered, [
-          [ParagraphNode(wasImplicit: true, nodes: [TextNode('first')])],
-          [ParagraphNode(wasImplicit: true, nodes: [TextNode('then')])],
+          [ParagraphNode(wasImplicit: true, links: null, nodes: [TextNode('first')])],
+          [ParagraphNode(wasImplicit: true, links: null, nodes: [TextNode('then')])],
         ]),
       ]);
 
@@ -217,8 +225,8 @@ void main() {
       // "* something\n* another"
       '<ul>\n<li>something</li>\n<li>another</li>\n</ul>', const [
         ListNode(ListStyle.unordered, [
-          [ParagraphNode(wasImplicit: true, nodes: [TextNode('something')])],
-          [ParagraphNode(wasImplicit: true, nodes: [TextNode('another')])],
+          [ParagraphNode(wasImplicit: true, links: null, nodes: [TextNode('something')])],
+          [ParagraphNode(wasImplicit: true, links: null, nodes: [TextNode('another')])],
         ]),
       ]);
 
@@ -226,7 +234,7 @@ void main() {
       // "* a\n  b"
       '<ul>\n<li>a<br>\n  b</li>\n</ul>', const [
         ListNode(ListStyle.unordered, [
-          [ParagraphNode(wasImplicit: true, nodes: [
+          [ParagraphNode(wasImplicit: true, links: null, nodes: [
             TextNode('a'),
             LineBreakInlineNode(),
             TextNode('\n  b'), // TODO: this renders misaligned
@@ -239,17 +247,49 @@ void main() {
       '<ul>\n<li>\n<p>a</p>\n<p>b</p>\n</li>\n</ul>', const [
         ListNode(ListStyle.unordered, [
           [
-            ParagraphNode(nodes: [TextNode('a')]),
-            ParagraphNode(nodes: [TextNode('b')]),
+            ParagraphNode(links: null, nodes: [TextNode('a')]),
+            ParagraphNode(links: null, nodes: [TextNode('b')]),
           ],
         ]),
       ]);
   });
 
+  group('track links inside block-inline containers', () {
+    testParse('multiple links in paragraph',
+      // "before[text](/there)mid[other](/else)after"
+      '<p>before<a href="/there">text</a>mid'
+          '<a href="/else">other</a>after</p>', const [
+        ParagraphNode(links: null, nodes: [
+          TextNode('before'),
+          LinkNode(url: '/there', nodes: [TextNode('text')]),
+          TextNode('mid'),
+          LinkNode(url: '/else', nodes: [TextNode('other')]),
+          TextNode('after'),
+        ])]);
+
+    testParse('link in heading',
+      // "###### [t](/u)\nhi"
+      '<h6><a href="/u">t</a></h6>\n<p>hi</p>', const [
+        HeadingNode(links: null, level: HeadingLevel.h6, nodes: [
+          LinkNode(url: '/u', nodes: [TextNode('t')]),
+        ]),
+        ParagraphNode(links: null, nodes: [TextNode('hi')]),
+      ]);
+
+    testParse('link in list item',
+      // "* [t](/u)"
+      '<ul>\n<li><a href="/u">t</a></li>\n</ul>', const [
+        ListNode(ListStyle.unordered, [
+          [ParagraphNode(links: null, wasImplicit: true, nodes: [
+            LinkNode(url: '/u', nodes: [TextNode('t')]),
+          ])],
+        ])]);
+  });
+
   testParse('parse quotations',
     // "```quote\nwords\n```"
     '<blockquote>\n<p>words</p>\n</blockquote>', const [
-      QuotationNode([ParagraphNode(nodes: [TextNode('words')])]),
+      QuotationNode([ParagraphNode(links: null, nodes: [TextNode('words')])]),
     ]);
 
   testParse('parse code blocks, no language',
@@ -283,13 +323,13 @@ void main() {
         '<code>four\n</code></pre></div>\n\n</li>\n</ol>', const [
       ListNode(ListStyle.ordered, [[
         QuotationNode([
-          HeadingNode(level: HeadingLevel.h6, nodes: [TextNode('two')]),
+          HeadingNode(level: HeadingLevel.h6, links: null, nodes: [TextNode('two')]),
           ListNode(ListStyle.unordered, [[
-            ParagraphNode(wasImplicit: true, nodes: [TextNode('three')]),
+            ParagraphNode(wasImplicit: true, links: null, nodes: [TextNode('three')]),
           ]]),
         ]),
         CodeBlockNode(text: 'four'),
-        ParagraphNode(wasImplicit: true, nodes: [TextNode('\n\n')]), // TODO avoid this; it renders wrong
+        ParagraphNode(wasImplicit: true, links: null, nodes: [TextNode('\n\n')]), // TODO avoid this; it renders wrong
       ]]),
     ]);
 }
