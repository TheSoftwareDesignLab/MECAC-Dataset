diff --git a/lib/widgets/app.dart b/lib/widgets/app.dart
index 3ff1eee459..281e0ffbee 100644
--- a/lib/widgets/app.dart
+++ b/lib/widgets/app.dart
@@ -15,6 +15,7 @@ import 'page.dart';
 import 'recent_dm_conversations.dart';
 import 'store.dart';
 import 'subscription_list.dart';
+import 'text.dart';
 
 class ZulipApp extends StatelessWidget {
   const ZulipApp({super.key, this.navigatorObservers});
@@ -81,6 +82,7 @@ class ZulipApp extends StatelessWidget {
   @override
   Widget build(BuildContext context) {
     final theme = ThemeData(
+      typography: zulipTypography(context),
       appBarTheme: const AppBarTheme(
         // This prevents an elevation change in [AppBar]s so they stop turning
         // darker if there is something scrolled underneath it. See docs:
diff --git a/lib/widgets/text.dart b/lib/widgets/text.dart
index 2939859ff3..ce8eb611fa 100644
--- a/lib/widgets/text.dart
+++ b/lib/widgets/text.dart
@@ -1,6 +1,113 @@
 import 'dart:io';
 import 'package:flutter/foundation.dart';
-import 'package:flutter/widgets.dart';
+import 'package:flutter/material.dart';
+
+/// An app-wide [Typography] for Zulip, customized from the Material default.
+///
+/// Include this in the app-wide [MaterialApp.theme].
+///
+/// We expect these text styles to be the basis of all the styles chosen by the
+/// Material library's widgets, such as the default styling of
+/// an [AppBar]'s title, of an [ElevatedButton]'s label, and so on.
+///
+/// Applies [kDefaultFontFamily] and [kDefaultFontFamilyFallback],
+/// being faithful to the Material-default font weights
+/// by running them through [weightVariableTextStyle].
+/// (That is needed because [kDefaultFontFamily] is a variable-weight font).
+///
+/// When building on top of these [TextStyles], callers that wish to specify
+/// a different font weight are still responsible for reprocessing the style
+/// with [weightVariableTextStyle] before passing it to a [Text].
+/// (Widgets in the Material library won't do this; they aren't yet equipped
+/// to set font weights on variable-weight fonts. If this causes visible bugs,
+/// we should investigate and fix, but such bugs should become less likely as
+/// we transition from Material's widgets to our own bespoke ones.)
+Typography zulipTypography(BuildContext context) {
+  final typography = Theme.of(context).typography;
+
+  Typography result = typography.copyWith(
+    black: typography.black.apply(
+      fontFamily: kDefaultFontFamily,
+      fontFamilyFallback: defaultFontFamilyFallback),
+    white: typography.white.apply(
+      fontFamily: kDefaultFontFamily,
+      fontFamilyFallback: defaultFontFamilyFallback),
+
+    dense:       _weightVariableTextTheme(context, typography.dense),
+    englishLike: _weightVariableTextTheme(context, typography.englishLike),
+    tall:        _weightVariableTextTheme(context, typography.tall),
+  );
+
+  assert(() {
+    // Set [TextStyle.debugLabel] for all styles, like:
+    //   "zulipTypography black titleMedium"
+
+    mkAddLabel(String debugTextThemeLabel)
+      => (TextStyle? maybeInputStyle, String debugStyleLabel)
+      => maybeInputStyle?.copyWith(debugLabel: '$debugTextThemeLabel $debugStyleLabel');
+
+    result = result.copyWith(
+      black:       _convertTextTheme(result.black,       mkAddLabel('zulipTypography black')),
+      white:       _convertTextTheme(result.white,       mkAddLabel('zulipTypography white')),
+      englishLike: _convertTextTheme(result.englishLike, mkAddLabel('zulipTypography englishLike')),
+      dense:       _convertTextTheme(result.dense,       mkAddLabel('zulipTypography dense')),
+      tall:        _convertTextTheme(result.tall,        mkAddLabel('zulipTypography tall')),
+    );
+    return true;
+  }());
+
+  return result;
+}
+
+/// Convert a geometry [TextTheme] to one that works with "wght"-variable fonts.
+///
+/// A "geometry [TextTheme]" is a [TextTheme] that's meant to specify
+/// font weight and other parameters about shape, size, distance, etc.
+/// See [Typography].
+///
+/// This looks at each of the [TextStyle]s found on the input [TextTheme]
+/// (such as [TextTheme.bodyMedium]),
+/// and uses [weightVariableTextStyle] to adjust the [TextStyle].
+/// Fields that are null in the input [TextTheme] remain null in the output.
+///
+/// For each input [TextStyle], the `wght` value passed
+/// to [weightVariableTextStyle] is based on the input's [TextStyle.fontWeight].
+/// A null [TextStyle.fontWeight] is interpreted as the normal font weight.
+TextTheme _weightVariableTextTheme(BuildContext context, TextTheme input) {
+  TextStyle? convert(TextStyle? maybeInputStyle, _) {
+    if (maybeInputStyle == null) {
+      return null;
+    }
+    final inputFontWeight = maybeInputStyle.fontWeight;
+    return maybeInputStyle.merge(weightVariableTextStyle(context,
+      wght: inputFontWeight != null
+        ? wghtFromFontWeight(inputFontWeight)
+        : null));
+  }
+
+  return _convertTextTheme(input, convert);
+}
+
+TextTheme _convertTextTheme(
+  TextTheme input,
+  TextStyle? Function(TextStyle?, String debugStyleLabel) converter,
+) => TextTheme(
+  displayLarge:   converter(input.displayLarge,   'displayLarge'),
+  displayMedium:  converter(input.displayMedium,  'displayMedium'),
+  displaySmall:   converter(input.displaySmall,   'displaySmall'),
+  headlineLarge:  converter(input.headlineLarge,  'headlineLarge'),
+  headlineMedium: converter(input.headlineMedium, 'headlineMedium'),
+  headlineSmall:  converter(input.headlineSmall,  'headlineSmall'),
+  titleLarge:     converter(input.titleLarge,     'titleLarge'),
+  titleMedium:    converter(input.titleMedium,    'titleMedium'),
+  titleSmall:     converter(input.titleSmall,     'titleSmall'),
+  bodyLarge:      converter(input.bodyLarge,      'bodyLarge'),
+  bodyMedium:     converter(input.bodyMedium,     'bodyMedium'),
+  bodySmall:      converter(input.bodySmall,      'bodySmall'),
+  labelLarge:     converter(input.labelLarge,     'labelLarge'),
+  labelMedium:    converter(input.labelMedium,    'labelMedium'),
+  labelSmall:     converter(input.labelSmall,     'labelSmall'),
+);
 
 /// The [TextStyle.fontFamily] to use in most of the app.
 ///
@@ -145,3 +252,12 @@ FontWeight clampVariableFontWeight(double wght) {
     }
   }
 }
+
+/// A good guess at a font's "wght" value to match a given [FontWeight].
+///
+/// Returns [FontWeight.value] as a double.
+///
+/// This might not be exactly where the font designer would land on their
+/// font's own custom-defined "wght" axis. But it's a great guess,
+/// at least without knowledge of the particular font.
+double wghtFromFontWeight(FontWeight fontWeight) => fontWeight.value.toDouble();
diff --git a/test/flutter_checks.dart b/test/flutter_checks.dart
index 6fcd4a1a18..81977e9933 100644
--- a/test/flutter_checks.dart
+++ b/test/flutter_checks.dart
@@ -54,8 +54,37 @@ extension TextFieldChecks on Subject<TextField> {
 
 extension TextStyleChecks on Subject<TextStyle> {
   Subject<bool> get inherit => has((t) => t.inherit, 'inherit');
-  Subject<List<FontVariation>?> get fontVariations => has((t) => t.fontVariations, 'fontVariations');
   Subject<FontWeight?> get fontWeight => has((t) => t.fontWeight, 'fontWeight');
+  Subject<List<FontVariation>?> get fontVariations => has((t) => t.fontVariations, 'fontVariations');
+  Subject<String?> get fontFamily => has((t) => t.fontFamily, 'fontFamily');
+  Subject<List<String>?> get fontFamilyFallback => has((t) => t.fontFamilyFallback, 'fontFamilyFallback');
 
   // TODO others
 }
+
+
+extension TextThemeChecks on Subject<TextTheme> {
+  Subject<TextStyle?> get displayLarge => has((t) => t.displayLarge, 'displayLarge');
+  Subject<TextStyle?> get displayMedium => has((t) => t.displayMedium, 'displayMedium');
+  Subject<TextStyle?> get displaySmall => has((t) => t.displaySmall, 'displaySmall');
+  Subject<TextStyle?> get headlineLarge => has((t) => t.headlineLarge, 'headlineLarge');
+  Subject<TextStyle?> get headlineMedium => has((t) => t.headlineMedium, 'headlineMedium');
+  Subject<TextStyle?> get headlineSmall => has((t) => t.headlineSmall, 'headlineSmall');
+  Subject<TextStyle?> get titleLarge => has((t) => t.titleLarge, 'titleLarge');
+  Subject<TextStyle?> get titleMedium => has((t) => t.titleMedium, 'titleMedium');
+  Subject<TextStyle?> get titleSmall => has((t) => t.titleSmall, 'titleSmall');
+  Subject<TextStyle?> get bodyLarge => has((t) => t.bodyLarge, 'bodyLarge');
+  Subject<TextStyle?> get bodyMedium => has((t) => t.bodyMedium, 'bodyMedium');
+  Subject<TextStyle?> get bodySmall => has((t) => t.bodySmall, 'bodySmall');
+  Subject<TextStyle?> get labelLarge => has((t) => t.labelLarge, 'labelLarge');
+  Subject<TextStyle?> get labelMedium => has((t) => t.labelMedium, 'labelMedium');
+  Subject<TextStyle?> get labelSmall => has((t) => t.labelSmall, 'labelSmall');
+}
+
+extension TypographyChecks on Subject<Typography> {
+  Subject<TextTheme> get black => has((t) => t.black, 'black');
+  Subject<TextTheme> get white => has((t) => t.white, 'white');
+  Subject<TextTheme> get englishLike => has((t) => t.englishLike, 'englishLike');
+  Subject<TextTheme> get dense => has((t) => t.dense, 'dense');
+  Subject<TextTheme> get tall => has((t) => t.tall, 'tall');
+}
diff --git a/test/widgets/text_test.dart b/test/widgets/text_test.dart
index 95b01aa22e..e8c98481ed 100644
--- a/test/widgets/text_test.dart
+++ b/test/widgets/text_test.dart
@@ -7,6 +7,63 @@ import 'package:zulip/widgets/text.dart';
 import '../flutter_checks.dart';
 
 void main() {
+  group('zulipTypography', () {
+    Future<Typography> getZulipTypography(WidgetTester tester, {
+      required bool platformRequestsBold,
+    }) async {
+      late final Typography result;
+      await tester.pumpWidget(
+        MediaQuery(data: MediaQueryData(boldText: platformRequestsBold),
+          child: Builder(builder: (context) {
+            result = zulipTypography(context);
+            return const SizedBox.shrink();
+          })));
+      return result;
+    }
+
+    matchesFontFamilies(Subject<TextStyle> it) => it
+      ..fontFamily.equals(kDefaultFontFamily)
+      ..fontFamilyFallback.isNotNull().deepEquals(defaultFontFamilyFallback);
+
+    matchesWeight(FontWeight weight) => (Subject<TextStyle> it) => it
+      ..fontWeight.equals(weight)
+      ..fontVariations.isNotNull().contains(
+          FontVariation('wght', wghtFromFontWeight(weight)));
+
+    for (final platformRequestsBold in [false, true]) {
+      final description = platformRequestsBold
+        ? 'platform requests bold'
+        : 'platform does not request bold';
+      testWidgets(description, (tester) async {
+        check(await getZulipTypography(tester, platformRequestsBold: platformRequestsBold))
+          ..black.bodyMedium.isNotNull().which(matchesFontFamilies)
+          ..white.bodyMedium.isNotNull().which(matchesFontFamilies)
+          ..englishLike.bodyMedium.isNotNull().which(
+              matchesWeight(platformRequestsBold ? FontWeight.w700 : FontWeight.w400))
+          ..dense.bodyMedium.isNotNull().which(
+              matchesWeight(platformRequestsBold ? FontWeight.w700 : FontWeight.w400))
+          ..tall.bodyMedium.isNotNull().which(
+              matchesWeight(platformRequestsBold ? FontWeight.w700 : FontWeight.w400));
+      });
+    }
+
+    test('Typography has the assumed fields', () {
+      check(Typography().toDiagnosticsNode().getProperties().map((n) => n.name).toList())
+        .unorderedEquals(['black', 'white', 'englishLike', 'dense', 'tall']);
+    });
+  });
+
+  test('_convertTextTheme: TextTheme has the assumed fields', () {
+    check(const TextTheme().toDiagnosticsNode().getProperties().map((n) => n.name).toList())
+      .unorderedEquals([
+        'displayLarge',  'displayMedium',  'displaySmall',
+        'headlineLarge', 'headlineMedium', 'headlineSmall',
+        'titleLarge',    'titleMedium',    'titleSmall',
+        'bodyLarge',     'bodyMedium',     'bodySmall',
+        'labelLarge',    'labelMedium',    'labelSmall',
+      ]);
+  });
+
   group('weightVariableTextStyle', () {
     Future<void> testWeights(
       String description, {
