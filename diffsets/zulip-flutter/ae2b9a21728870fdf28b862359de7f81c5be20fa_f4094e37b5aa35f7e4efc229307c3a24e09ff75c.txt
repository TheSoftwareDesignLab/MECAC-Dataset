diff --git a/lib/widgets/autocomplete.dart b/lib/widgets/autocomplete.dart
index 7445370e7a..cb5d9d078c 100644
--- a/lib/widgets/autocomplete.dart
+++ b/lib/widgets/autocomplete.dart
@@ -3,7 +3,6 @@ import 'package:flutter/material.dart';
 import '../generated/l10n/zulip_localizations.dart';
 import '../model/emoji.dart';
 import '../model/store.dart';
-import 'content.dart';
 import 'emoji.dart';
 import 'icons.dart';
 import 'store.dart';
@@ -13,6 +12,7 @@ import '../model/narrow.dart';
 import 'compose_box.dart';
 import 'text.dart';
 import 'theme.dart';
+import 'user.dart';
 
 abstract class AutocompleteField<QueryT extends AutocompleteQuery, ResultT extends AutocompleteResult> extends StatefulWidget {
   const AutocompleteField({
diff --git a/lib/widgets/content.dart b/lib/widgets/content.dart
index 551956966e..5d6dfa5084 100644
--- a/lib/widgets/content.dart
+++ b/lib/widgets/content.dart
@@ -10,16 +10,11 @@ import 'package:intl/intl.dart' as intl;
 import '../api/core.dart';
 import '../api/model/model.dart';
 import '../generated/l10n/zulip_localizations.dart';
-import '../model/avatar_url.dart';
-import '../model/binding.dart';
 import '../model/content.dart';
-import '../model/emoji.dart';
 import '../model/internal_link.dart';
-import '../model/presence.dart';
 import 'actions.dart';
 import 'code_block.dart';
 import 'dialog.dart';
-import 'emoji.dart';
 import 'icons.dart';
 import 'inset_shadow.dart';
 import 'katex.dart';
@@ -1542,368 +1537,6 @@ class RealmContentNetworkImage extends StatelessWidget {
   }
 }
 
-/// A rounded square with size [size] showing a user's avatar.
-class Avatar extends StatelessWidget {
-  const Avatar({
-    super.key,
-    required this.userId,
-    required this.size,
-    required this.borderRadius,
-    this.backgroundColor,
-    this.showPresence = true,
-    this.replaceIfMuted = true,
-  });
-
-  final int userId;
-  final double size;
-  final double borderRadius;
-  final Color? backgroundColor;
-  final bool showPresence;
-  final bool replaceIfMuted;
-
-  @override
-  Widget build(BuildContext context) {
-    // (The backgroundColor is only meaningful if presence will be shown;
-    // see [PresenceCircle.backgroundColor].)
-    assert(backgroundColor == null || showPresence);
-    return AvatarShape(
-      size: size,
-      borderRadius: borderRadius,
-      backgroundColor: backgroundColor,
-      userIdForPresence: showPresence ? userId : null,
-      child: AvatarImage(userId: userId, size: size, replaceIfMuted: replaceIfMuted));
-  }
-}
-
-/// The appropriate avatar image for a user ID.
-///
-/// If the user isn't found, gives a [SizedBox.shrink].
-///
-/// Wrap this with [AvatarShape].
-class AvatarImage extends StatelessWidget {
-  const AvatarImage({
-    super.key,
-    required this.userId,
-    required this.size,
-    this.replaceIfMuted = true,
-  });
-
-  final int userId;
-  final double size;
-  final bool replaceIfMuted;
-
-  @override
-  Widget build(BuildContext context) {
-    final store = PerAccountStoreWidget.of(context);
-    final user = store.getUser(userId);
-
-    if (user == null) { // TODO(log)
-      return const SizedBox.shrink();
-    }
-
-    if (replaceIfMuted && store.isUserMuted(userId)) {
-      return _AvatarPlaceholder(size: size);
-    }
-
-    final resolvedUrl = switch (user.avatarUrl) {
-      null          => null, // TODO(#255): handle computing gravatars
-      var avatarUrl => store.tryResolveUrl(avatarUrl),
-    };
-
-    if (resolvedUrl == null) {
-      return const SizedBox.shrink();
-    }
-
-    final avatarUrl = AvatarUrl.fromUserData(resolvedUrl: resolvedUrl);
-    final physicalSize = (MediaQuery.devicePixelRatioOf(context) * size).ceil();
-
-    return RealmContentNetworkImage(
-      avatarUrl.get(physicalSize),
-      filterQuality: FilterQuality.medium,
-      fit: BoxFit.cover,
-    );
-  }
-}
-
-/// A placeholder avatar for muted users.
-///
-/// Wrap this with [AvatarShape].
-// TODO(#1558) use this as a fallback in more places (?) and update dartdoc.
-class _AvatarPlaceholder extends StatelessWidget {
-  const _AvatarPlaceholder({required this.size});
-
-  /// The size of the placeholder box.
-  ///
-  /// This should match the `size` passed to the wrapping [AvatarShape].
-  /// The placeholder's icon will be scaled proportionally to this.
-  final double size;
-
-  @override
-  Widget build(BuildContext context) {
-    final designVariables = DesignVariables.of(context);
-    return DecoratedBox(
-      decoration: BoxDecoration(color: designVariables.avatarPlaceholderBg),
-      child: Icon(ZulipIcons.person,
-        // Where the avatar placeholder appears in the Figma,
-        // this is how the icon is sized proportionally to its box.
-        size: size * 20 / 32,
-        color: designVariables.avatarPlaceholderIcon));
-  }
-}
-
-/// A rounded square shape, to wrap an [AvatarImage] or similar.
-///
-/// If [userIdForPresence] is provided, this will paint a [PresenceCircle]
-/// on the shape.
-class AvatarShape extends StatelessWidget {
-  const AvatarShape({
-    super.key,
-    required this.size,
-    required this.borderRadius,
-    this.backgroundColor,
-    this.userIdForPresence,
-    required this.child,
-  });
-
-  final double size;
-  final double borderRadius;
-  final Color? backgroundColor;
-  final int? userIdForPresence;
-  final Widget child;
-
-  @override
-  Widget build(BuildContext context) {
-    // (The backgroundColor is only meaningful if presence will be shown;
-    // see [PresenceCircle.backgroundColor].)
-    assert(backgroundColor == null || userIdForPresence != null);
-
-    Widget result = SizedBox.square(
-      dimension: size,
-      child: ClipRRect(
-        borderRadius: BorderRadius.all(Radius.circular(borderRadius)),
-        clipBehavior: Clip.antiAlias,
-        child: child));
-
-    if (userIdForPresence != null) {
-      final presenceCircleSize = size / 4; // TODO(design) is this right?
-      result = Stack(children: [
-        result,
-        Positioned.directional(textDirection: Directionality.of(context),
-          end: 0,
-          bottom: 0,
-          child: PresenceCircle(
-            userId: userIdForPresence!,
-            size: presenceCircleSize,
-            backgroundColor: backgroundColor)),
-      ]);
-    }
-
-    return result;
-  }
-}
-
-/// The green or orange-gradient circle representing [PresenceStatus].
-///
-/// [backgroundColor] must not be [Colors.transparent].
-/// It exists to match the background on which the avatar image is painted.
-/// If [backgroundColor] is not passed, [DesignVariables.mainBackground] is used.
-///
-/// By default, nothing paints for a user in the "offline" status
-/// (i.e. a user without a [PresenceStatus]).
-/// Pass true for [explicitOffline] to paint a gray circle.
-class PresenceCircle extends StatefulWidget {
-  const PresenceCircle({
-    super.key,
-    required this.userId,
-    required this.size,
-    this.backgroundColor,
-    this.explicitOffline = false,
-  });
-
-  final int userId;
-  final double size;
-  final Color? backgroundColor;
-  final bool explicitOffline;
-
-  /// Creates a [WidgetSpan] with a [PresenceCircle], for use in rich text
-  /// before a user's name.
-  ///
-  /// The [PresenceCircle] will have `explicitOffline: true`.
-  static InlineSpan asWidgetSpan({
-    required int userId,
-    required double fontSize,
-    required TextScaler textScaler,
-    Color? backgroundColor,
-  }) {
-    final size = textScaler.scale(fontSize) / 2;
-    return WidgetSpan(
-      alignment: PlaceholderAlignment.middle,
-      child: Padding(
-        padding: const EdgeInsetsDirectional.only(end: 4),
-        child: PresenceCircle(
-          userId: userId,
-          size: size,
-          backgroundColor: backgroundColor,
-          explicitOffline: true)));
-  }
-
-  @override
-  State<PresenceCircle> createState() => _PresenceCircleState();
-}
-
-class _PresenceCircleState extends State<PresenceCircle> with PerAccountStoreAwareStateMixin {
-  Presence? model;
-
-  @override
-  void onNewStore() {
-    model?.removeListener(_modelChanged);
-    model = PerAccountStoreWidget.of(context).presence
-      ..addListener(_modelChanged);
-  }
-
-  @override
-  void dispose() {
-    model!.removeListener(_modelChanged);
-    super.dispose();
-  }
-
-  void _modelChanged() {
-    setState(() {
-      // The actual state lives in [model].
-      // This method was called because that just changed.
-    });
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final status = model!.presenceStatusForUser(
-      widget.userId, utcNow: ZulipBinding.instance.utcNow());
-    final designVariables = DesignVariables.of(context);
-    final effectiveBackgroundColor = widget.backgroundColor ?? designVariables.mainBackground;
-    assert(effectiveBackgroundColor != Colors.transparent);
-
-    Color? color;
-    LinearGradient? gradient;
-    switch (status) {
-      case null:
-        if (widget.explicitOffline) {
-          // TODO(a11y) this should be an open circle, like on web,
-          //   to differentiate by shape (vs. the "active" status which is also
-          //   a solid circle)
-          color = designVariables.statusAway;
-        } else {
-          return SizedBox.square(dimension: widget.size);
-        }
-      case PresenceStatus.active:
-        color = designVariables.statusOnline;
-      case PresenceStatus.idle:
-        gradient = LinearGradient(
-          begin: AlignmentDirectional.centerStart,
-          end: AlignmentDirectional.centerEnd,
-          colors: [designVariables.statusIdle, effectiveBackgroundColor],
-          stops: [0.05, 1.00],
-        );
-    }
-
-    return SizedBox.square(dimension: widget.size,
-      child: DecoratedBox(
-        decoration: BoxDecoration(
-          border: Border.all(
-            color: effectiveBackgroundColor,
-            width: 2,
-            strokeAlign: BorderSide.strokeAlignOutside),
-          color: color,
-          gradient: gradient,
-          shape: BoxShape.circle)));
-  }
-}
-
-/// A user status emoji to be displayed in different parts of the app.
-///
-/// Use [padding] to control the padding of status emoji from neighboring
-/// widgets.
-/// When there is no status emoji to be shown, the padding will be omitted too.
-///
-/// Use [neverAnimate] to forcefully disable the animation for animated emojis.
-/// Defaults to true.
-class UserStatusEmoji extends StatelessWidget {
-  const UserStatusEmoji({
-    super.key,
-    required this.userId,
-    required this.size,
-    this.padding = EdgeInsets.zero,
-    this.neverAnimate = true,
-  });
-
-  final int userId;
-  final double size;
-  final EdgeInsetsGeometry padding;
-  final bool neverAnimate;
-
-  static const double _spanPadding = 4;
-
-  /// Creates a [WidgetSpan] with a [UserStatusEmoji], for use in rich text;
-  /// before or after a text span.
-  ///
-  /// Use [position] to tell the emoji span where it is located relative to
-  /// another span, so that it can adjust the necessary padding from it.
-  static InlineSpan asWidgetSpan({
-    required int userId,
-    required double fontSize,
-    required TextScaler textScaler,
-    StatusEmojiPosition position = StatusEmojiPosition.after,
-    bool neverAnimate = true,
-  }) {
-    final (double paddingStart, double paddingEnd) = switch (position) {
-      StatusEmojiPosition.before => (0,            _spanPadding),
-      StatusEmojiPosition.after  => (_spanPadding, 0),
-    };
-    final size = textScaler.scale(fontSize);
-    return WidgetSpan(
-      alignment: PlaceholderAlignment.middle,
-      child: UserStatusEmoji(userId: userId, size: size,
-        padding: EdgeInsetsDirectional.only(start: paddingStart, end: paddingEnd),
-        neverAnimate: neverAnimate));
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final store = PerAccountStoreWidget.of(context);
-    final emoji = store.getUserStatus(userId).emoji;
-
-    final placeholder = SizedBox.shrink();
-    if (emoji == null) return placeholder;
-
-    final emojiDisplay = store.emojiDisplayFor(
-      emojiType: emoji.reactionType,
-      emojiCode: emoji.emojiCode,
-      emojiName: emoji.emojiName)
-        // Web doesn't seem to respect the emojiset user settings for user status.
-        // .resolve(store.userSettings)
-    ;
-    return switch (emojiDisplay) {
-      UnicodeEmojiDisplay() => Padding(
-        padding: padding,
-        child: UnicodeEmojiWidget(size: size, emojiDisplay: emojiDisplay)),
-      ImageEmojiDisplay() => Padding(
-        padding: padding,
-        child: ImageEmojiWidget(
-          size: size,
-          emojiDisplay: emojiDisplay,
-          neverAnimate: neverAnimate,
-          // If image emoji fails to load, show nothing.
-          errorBuilder: (_, _, _) => placeholder)),
-      // The user-status feature doesn't support a :text_emoji:-style display.
-      // Also, if an image emoji's URL string doesn't parse, it'll fall back to
-      // a :text_emoji:-style display. We show nothing for this case.
-      TextEmojiDisplay() => placeholder,
-    };
-  }
-}
-
-/// The position of the status emoji span relative to another text span.
-enum StatusEmojiPosition { before, after }
-
 //
 // Small helpers.
 //
diff --git a/lib/widgets/home.dart b/lib/widgets/home.dart
index dd269e03f7..a1dea0dff8 100644
--- a/lib/widgets/home.dart
+++ b/lib/widgets/home.dart
@@ -10,7 +10,6 @@ import 'app.dart';
 import 'app_bar.dart';
 import 'button.dart';
 import 'color.dart';
-import 'content.dart';
 import 'icons.dart';
 import 'inbox.dart';
 import 'inset_shadow.dart';
@@ -23,6 +22,7 @@ import 'store.dart';
 import 'subscription_list.dart';
 import 'text.dart';
 import 'theme.dart';
+import 'user.dart';
 
 enum _HomePageTab {
   inbox,
diff --git a/lib/widgets/lightbox.dart b/lib/widgets/lightbox.dart
index 7199c72a5c..bf11522036 100644
--- a/lib/widgets/lightbox.dart
+++ b/lib/widgets/lightbox.dart
@@ -14,6 +14,7 @@ import 'content.dart';
 import 'dialog.dart';
 import 'page.dart';
 import 'store.dart';
+import 'user.dart';
 
 /// Identifies which [LightboxHero]s should match up with each other
 /// to produce a hero animation.
diff --git a/lib/widgets/message_list.dart b/lib/widgets/message_list.dart
index 3cc767f0c5..0371a29b75 100644
--- a/lib/widgets/message_list.dart
+++ b/lib/widgets/message_list.dart
@@ -31,6 +31,7 @@ import 'store.dart';
 import 'text.dart';
 import 'theme.dart';
 import 'topic_list.dart';
+import 'user.dart';
 
 /// Message-list styles that differ between light and dark themes.
 class MessageListTheme extends ThemeExtension<MessageListTheme> {
diff --git a/lib/widgets/new_dm_sheet.dart b/lib/widgets/new_dm_sheet.dart
index e67b62e382..682adea91c 100644
--- a/lib/widgets/new_dm_sheet.dart
+++ b/lib/widgets/new_dm_sheet.dart
@@ -6,13 +6,13 @@ import '../model/autocomplete.dart';
 import '../model/narrow.dart';
 import '../model/store.dart';
 import 'color.dart';
-import 'content.dart';
 import 'icons.dart';
 import 'message_list.dart';
 import 'page.dart';
 import 'store.dart';
 import 'text.dart';
 import 'theme.dart';
+import 'user.dart';
 
 void showNewDmSheet(BuildContext context) {
   final pageContext = PageRoot.contextOf(context);
diff --git a/lib/widgets/profile.dart b/lib/widgets/profile.dart
index 6576e2a0fe..9b65831b29 100644
--- a/lib/widgets/profile.dart
+++ b/lib/widgets/profile.dart
@@ -17,6 +17,7 @@ import 'remote_settings.dart';
 import 'store.dart';
 import 'text.dart';
 import 'theme.dart';
+import 'user.dart';
 
 class _TextStyles {
   static const primaryFieldText = TextStyle(fontSize: 20);
diff --git a/lib/widgets/recent_dm_conversations.dart b/lib/widgets/recent_dm_conversations.dart
index 96ecfdbef4..f4846bf943 100644
--- a/lib/widgets/recent_dm_conversations.dart
+++ b/lib/widgets/recent_dm_conversations.dart
@@ -4,7 +4,6 @@ import '../generated/l10n/zulip_localizations.dart';
 import '../model/narrow.dart';
 import '../model/recent_dm_conversations.dart';
 import '../model/unreads.dart';
-import 'content.dart';
 import 'icons.dart';
 import 'message_list.dart';
 import 'new_dm_sheet.dart';
@@ -13,6 +12,7 @@ import 'store.dart';
 import 'text.dart';
 import 'theme.dart';
 import 'unread_count_badge.dart';
+import 'user.dart';
 
 class RecentDmConversationsPageBody extends StatefulWidget {
   const RecentDmConversationsPageBody({super.key});
diff --git a/lib/widgets/user.dart b/lib/widgets/user.dart
new file mode 100644
index 0000000000..9406580fb2
--- /dev/null
+++ b/lib/widgets/user.dart
@@ -0,0 +1,374 @@
+import 'package:flutter/material.dart';
+
+import '../api/model/model.dart';
+import '../model/avatar_url.dart';
+import '../model/binding.dart';
+import '../model/emoji.dart';
+import '../model/presence.dart';
+import 'content.dart';
+import 'emoji.dart';
+import 'icons.dart';
+import 'store.dart';
+import 'theme.dart';
+
+/// A rounded square with size [size] showing a user's avatar.
+class Avatar extends StatelessWidget {
+  const Avatar({
+    super.key,
+    required this.userId,
+    required this.size,
+    required this.borderRadius,
+    this.backgroundColor,
+    this.showPresence = true,
+    this.replaceIfMuted = true,
+  });
+
+  final int userId;
+  final double size;
+  final double borderRadius;
+  final Color? backgroundColor;
+  final bool showPresence;
+  final bool replaceIfMuted;
+
+  @override
+  Widget build(BuildContext context) {
+    // (The backgroundColor is only meaningful if presence will be shown;
+    // see [PresenceCircle.backgroundColor].)
+    assert(backgroundColor == null || showPresence);
+    return AvatarShape(
+      size: size,
+      borderRadius: borderRadius,
+      backgroundColor: backgroundColor,
+      userIdForPresence: showPresence ? userId : null,
+      child: AvatarImage(userId: userId, size: size, replaceIfMuted: replaceIfMuted));
+  }
+}
+
+/// The appropriate avatar image for a user ID.
+///
+/// If the user isn't found, gives a [SizedBox.shrink].
+///
+/// Wrap this with [AvatarShape].
+class AvatarImage extends StatelessWidget {
+  const AvatarImage({
+    super.key,
+    required this.userId,
+    required this.size,
+    this.replaceIfMuted = true,
+  });
+
+  final int userId;
+  final double size;
+  final bool replaceIfMuted;
+
+  @override
+  Widget build(BuildContext context) {
+    final store = PerAccountStoreWidget.of(context);
+    final user = store.getUser(userId);
+
+    if (user == null) { // TODO(log)
+      return const SizedBox.shrink();
+    }
+
+    if (replaceIfMuted && store.isUserMuted(userId)) {
+      return _AvatarPlaceholder(size: size);
+    }
+
+    final resolvedUrl = switch (user.avatarUrl) {
+      null          => null, // TODO(#255): handle computing gravatars
+      var avatarUrl => store.tryResolveUrl(avatarUrl),
+    };
+
+    if (resolvedUrl == null) {
+      return const SizedBox.shrink();
+    }
+
+    final avatarUrl = AvatarUrl.fromUserData(resolvedUrl: resolvedUrl);
+    final physicalSize = (MediaQuery.devicePixelRatioOf(context) * size).ceil();
+
+    return RealmContentNetworkImage(
+      avatarUrl.get(physicalSize),
+      filterQuality: FilterQuality.medium,
+      fit: BoxFit.cover,
+    );
+  }
+}
+
+/// A placeholder avatar for muted users.
+///
+/// Wrap this with [AvatarShape].
+// TODO(#1558) use this as a fallback in more places (?) and update dartdoc.
+class _AvatarPlaceholder extends StatelessWidget {
+  const _AvatarPlaceholder({required this.size});
+
+  /// The size of the placeholder box.
+  ///
+  /// This should match the `size` passed to the wrapping [AvatarShape].
+  /// The placeholder's icon will be scaled proportionally to this.
+  final double size;
+
+  @override
+  Widget build(BuildContext context) {
+    final designVariables = DesignVariables.of(context);
+    return DecoratedBox(
+      decoration: BoxDecoration(color: designVariables.avatarPlaceholderBg),
+      child: Icon(ZulipIcons.person,
+        // Where the avatar placeholder appears in the Figma,
+        // this is how the icon is sized proportionally to its box.
+        size: size * 20 / 32,
+        color: designVariables.avatarPlaceholderIcon));
+  }
+}
+
+/// A rounded square shape, to wrap an [AvatarImage] or similar.
+///
+/// If [userIdForPresence] is provided, this will paint a [PresenceCircle]
+/// on the shape.
+class AvatarShape extends StatelessWidget {
+  const AvatarShape({
+    super.key,
+    required this.size,
+    required this.borderRadius,
+    this.backgroundColor,
+    this.userIdForPresence,
+    required this.child,
+  });
+
+  final double size;
+  final double borderRadius;
+  final Color? backgroundColor;
+  final int? userIdForPresence;
+  final Widget child;
+
+  @override
+  Widget build(BuildContext context) {
+    // (The backgroundColor is only meaningful if presence will be shown;
+    // see [PresenceCircle.backgroundColor].)
+    assert(backgroundColor == null || userIdForPresence != null);
+
+    Widget result = SizedBox.square(
+      dimension: size,
+      child: ClipRRect(
+        borderRadius: BorderRadius.all(Radius.circular(borderRadius)),
+        clipBehavior: Clip.antiAlias,
+        child: child));
+
+    if (userIdForPresence != null) {
+      final presenceCircleSize = size / 4; // TODO(design) is this right?
+      result = Stack(children: [
+        result,
+        Positioned.directional(textDirection: Directionality.of(context),
+          end: 0,
+          bottom: 0,
+          child: PresenceCircle(
+            userId: userIdForPresence!,
+            size: presenceCircleSize,
+            backgroundColor: backgroundColor)),
+      ]);
+    }
+
+    return result;
+  }
+}
+
+/// The green or orange-gradient circle representing [PresenceStatus].
+///
+/// [backgroundColor] must not be [Colors.transparent].
+/// It exists to match the background on which the avatar image is painted.
+/// If [backgroundColor] is not passed, [DesignVariables.mainBackground] is used.
+///
+/// By default, nothing paints for a user in the "offline" status
+/// (i.e. a user without a [PresenceStatus]).
+/// Pass true for [explicitOffline] to paint a gray circle.
+class PresenceCircle extends StatefulWidget {
+  const PresenceCircle({
+    super.key,
+    required this.userId,
+    required this.size,
+    this.backgroundColor,
+    this.explicitOffline = false,
+  });
+
+  final int userId;
+  final double size;
+  final Color? backgroundColor;
+  final bool explicitOffline;
+
+  /// Creates a [WidgetSpan] with a [PresenceCircle], for use in rich text
+  /// before a user's name.
+  ///
+  /// The [PresenceCircle] will have `explicitOffline: true`.
+  static InlineSpan asWidgetSpan({
+    required int userId,
+    required double fontSize,
+    required TextScaler textScaler,
+    Color? backgroundColor,
+  }) {
+    final size = textScaler.scale(fontSize) / 2;
+    return WidgetSpan(
+      alignment: PlaceholderAlignment.middle,
+      child: Padding(
+        padding: const EdgeInsetsDirectional.only(end: 4),
+        child: PresenceCircle(
+          userId: userId,
+          size: size,
+          backgroundColor: backgroundColor,
+          explicitOffline: true)));
+  }
+
+  @override
+  State<PresenceCircle> createState() => _PresenceCircleState();
+}
+
+class _PresenceCircleState extends State<PresenceCircle> with PerAccountStoreAwareStateMixin {
+  Presence? model;
+
+  @override
+  void onNewStore() {
+    model?.removeListener(_modelChanged);
+    model = PerAccountStoreWidget.of(context).presence
+      ..addListener(_modelChanged);
+  }
+
+  @override
+  void dispose() {
+    model!.removeListener(_modelChanged);
+    super.dispose();
+  }
+
+  void _modelChanged() {
+    setState(() {
+      // The actual state lives in [model].
+      // This method was called because that just changed.
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final status = model!.presenceStatusForUser(
+      widget.userId, utcNow: ZulipBinding.instance.utcNow());
+    final designVariables = DesignVariables.of(context);
+    final effectiveBackgroundColor = widget.backgroundColor ?? designVariables.mainBackground;
+    assert(effectiveBackgroundColor != Colors.transparent);
+
+    Color? color;
+    LinearGradient? gradient;
+    switch (status) {
+      case null:
+        if (widget.explicitOffline) {
+          // TODO(a11y) this should be an open circle, like on web,
+          //   to differentiate by shape (vs. the "active" status which is also
+          //   a solid circle)
+          color = designVariables.statusAway;
+        } else {
+          return SizedBox.square(dimension: widget.size);
+        }
+      case PresenceStatus.active:
+        color = designVariables.statusOnline;
+      case PresenceStatus.idle:
+        gradient = LinearGradient(
+          begin: AlignmentDirectional.centerStart,
+          end: AlignmentDirectional.centerEnd,
+          colors: [designVariables.statusIdle, effectiveBackgroundColor],
+          stops: [0.05, 1.00],
+        );
+    }
+
+    return SizedBox.square(dimension: widget.size,
+      child: DecoratedBox(
+        decoration: BoxDecoration(
+          border: Border.all(
+            color: effectiveBackgroundColor,
+            width: 2,
+            strokeAlign: BorderSide.strokeAlignOutside),
+          color: color,
+          gradient: gradient,
+          shape: BoxShape.circle)));
+  }
+}
+
+/// A user status emoji to be displayed in different parts of the app.
+///
+/// Use [padding] to control the padding of status emoji from neighboring
+/// widgets.
+/// When there is no status emoji to be shown, the padding will be omitted too.
+///
+/// Use [neverAnimate] to forcefully disable the animation for animated emojis.
+/// Defaults to true.
+class UserStatusEmoji extends StatelessWidget {
+  const UserStatusEmoji({
+    super.key,
+    required this.userId,
+    required this.size,
+    this.padding = EdgeInsets.zero,
+    this.neverAnimate = true,
+  });
+
+  final int userId;
+  final double size;
+  final EdgeInsetsGeometry padding;
+  final bool neverAnimate;
+
+  static const double _spanPadding = 4;
+
+  /// Creates a [WidgetSpan] with a [UserStatusEmoji], for use in rich text;
+  /// before or after a text span.
+  ///
+  /// Use [position] to tell the emoji span where it is located relative to
+  /// another span, so that it can adjust the necessary padding from it.
+  static InlineSpan asWidgetSpan({
+    required int userId,
+    required double fontSize,
+    required TextScaler textScaler,
+    StatusEmojiPosition position = StatusEmojiPosition.after,
+    bool neverAnimate = true,
+  }) {
+    final (double paddingStart, double paddingEnd) = switch (position) {
+      StatusEmojiPosition.before => (0,            _spanPadding),
+      StatusEmojiPosition.after  => (_spanPadding, 0),
+    };
+    final size = textScaler.scale(fontSize);
+    return WidgetSpan(
+      alignment: PlaceholderAlignment.middle,
+      child: UserStatusEmoji(userId: userId, size: size,
+        padding: EdgeInsetsDirectional.only(start: paddingStart, end: paddingEnd),
+        neverAnimate: neverAnimate));
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final store = PerAccountStoreWidget.of(context);
+    final emoji = store.getUserStatus(userId).emoji;
+
+    final placeholder = SizedBox.shrink();
+    if (emoji == null) return placeholder;
+
+    final emojiDisplay = store.emojiDisplayFor(
+      emojiType: emoji.reactionType,
+      emojiCode: emoji.emojiCode,
+      emojiName: emoji.emojiName)
+        // Web doesn't seem to respect the emojiset user settings for user status.
+        // .resolve(store.userSettings)
+    ;
+    return switch (emojiDisplay) {
+      UnicodeEmojiDisplay() => Padding(
+        padding: padding,
+        child: UnicodeEmojiWidget(size: size, emojiDisplay: emojiDisplay)),
+      ImageEmojiDisplay() => Padding(
+        padding: padding,
+        child: ImageEmojiWidget(
+          size: size,
+          emojiDisplay: emojiDisplay,
+          neverAnimate: neverAnimate,
+          // If image emoji fails to load, show nothing.
+          errorBuilder: (_, _, _) => placeholder)),
+      // The user-status feature doesn't support a :text_emoji:-style display.
+      // Also, if an image emoji's URL string doesn't parse, it'll fall back to
+      // a :text_emoji:-style display. We show nothing for this case.
+      TextEmojiDisplay() => placeholder,
+    };
+  }
+}
+
+/// The position of the status emoji span relative to another text span.
+enum StatusEmojiPosition { before, after }
diff --git a/test/widgets/action_sheet_test.dart b/test/widgets/action_sheet_test.dart
index 3ca737dd40..631856efde 100644
--- a/test/widgets/action_sheet_test.dart
+++ b/test/widgets/action_sheet_test.dart
@@ -32,6 +32,7 @@ import 'package:zulip/widgets/inbox.dart';
 import 'package:zulip/widgets/message_list.dart';
 import 'package:share_plus_platform_interface/method_channel/method_channel_share.dart';
 import 'package:zulip/widgets/subscription_list.dart';
+import 'package:zulip/widgets/user.dart';
 import '../api/fake_api.dart';
 
 import '../example_data.dart' as eg;
diff --git a/test/widgets/autocomplete_test.dart b/test/widgets/autocomplete_test.dart
index 118db51c18..ddcfc26036 100644
--- a/test/widgets/autocomplete_test.dart
+++ b/test/widgets/autocomplete_test.dart
@@ -16,8 +16,8 @@ import 'package:zulip/model/store.dart';
 import 'package:zulip/model/typing_status.dart';
 import 'package:zulip/widgets/autocomplete.dart';
 import 'package:zulip/widgets/compose_box.dart';
-import 'package:zulip/widgets/content.dart';
 import 'package:zulip/widgets/message_list.dart';
+import 'package:zulip/widgets/user.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
diff --git a/test/widgets/checks.dart b/test/widgets/checks.dart
index 3ea33750e1..69ff9a5f22 100644
--- a/test/widgets/checks.dart
+++ b/test/widgets/checks.dart
@@ -13,6 +13,7 @@ import 'package:zulip/widgets/page.dart';
 import 'package:zulip/widgets/profile.dart';
 import 'package:zulip/widgets/store.dart';
 import 'package:zulip/widgets/unread_count_badge.dart';
+import 'package:zulip/widgets/user.dart';
 
 extension ChannelColorSwatchChecks on Subject<ChannelColorSwatch> {
   Subject<Color> get base => has((s) => s.base, 'base');
diff --git a/test/widgets/content_test.dart b/test/widgets/content_test.dart
index 4995317890..0075f50b11 100644
--- a/test/widgets/content_test.dart
+++ b/test/widgets/content_test.dart
@@ -25,7 +25,6 @@ import '../model/binding.dart';
 import '../model/content_test.dart';
 import '../model/store_checks.dart';
 import '../model/test_store.dart';
-import '../stdlib_checks.dart';
 import '../test_images.dart';
 import '../test_navigation.dart';
 import 'checks.dart';
@@ -1284,69 +1283,6 @@ void main() {
     });
   });
 
-  group('AvatarImage', () {
-    late PerAccountStore store;
-
-    Future<Uri?> actualUrl(WidgetTester tester, String avatarUrl, [double? size]) async {
-      addTearDown(testBinding.reset);
-      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
-      store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
-      final user = eg.user(avatarUrl: avatarUrl);
-      await store.addUser(user);
-
-      prepareBoringImageHttpClient();
-      await tester.pumpWidget(GlobalStoreWidget(
-        child: PerAccountStoreWidget(accountId: eg.selfAccount.id,
-          child: AvatarImage(userId: user.userId, size: size ?? 30))));
-      await tester.pump();
-      await tester.pump();
-      tester.widget(find.byType(AvatarImage));
-      final widgets = tester.widgetList<RealmContentNetworkImage>(
-        find.byType(RealmContentNetworkImage));
-      return widgets.firstOrNull?.src;
-    }
-
-    testWidgets('smoke with absolute URL', (tester) async {
-      const avatarUrl = 'https://example/avatar.png';
-      check(await actualUrl(tester, avatarUrl)).isNotNull()
-        .asString.equals(avatarUrl);
-      debugNetworkImageHttpClientProvider = null;
-    });
-
-    testWidgets('smoke with relative URL', (tester) async {
-      const avatarUrl = '/avatar.png';
-      check(await actualUrl(tester, avatarUrl))
-        .equals(store.tryResolveUrl(avatarUrl)!);
-      debugNetworkImageHttpClientProvider = null;
-    });
-
-   testWidgets('absolute URL, larger size', (tester) async {
-      tester.view.devicePixelRatio = 2.5;
-      addTearDown(tester.view.resetDevicePixelRatio);
-
-      const avatarUrl = 'https://example/avatar.png';
-      check(await actualUrl(tester, avatarUrl, 50)).isNotNull()
-        .asString.equals(avatarUrl.replaceAll('.png', '-medium.png'));
-      debugNetworkImageHttpClientProvider = null;
-    });
-
-    testWidgets('relative URL, larger size', (tester) async {
-      tester.view.devicePixelRatio = 2.5;
-      addTearDown(tester.view.resetDevicePixelRatio);
-
-      const avatarUrl = '/avatar.png';
-      check(await actualUrl(tester, avatarUrl, 50))
-        .equals(store.tryResolveUrl('/avatar-medium.png')!);
-      debugNetworkImageHttpClientProvider = null;
-    });
-
-    testWidgets('smoke with invalid URL', (tester) async {
-      const avatarUrl = '::not a URL::';
-      check(await actualUrl(tester, avatarUrl)).isNull();
-      debugNetworkImageHttpClientProvider = null;
-    });
-  });
-
   group('MessageTable', () {
     testFontWeight('bold column header label',
       // | a | b | c | d |
diff --git a/test/widgets/lightbox_test.dart b/test/widgets/lightbox_test.dart
index 365e550bd9..dbeb06a3fd 100644
--- a/test/widgets/lightbox_test.dart
+++ b/test/widgets/lightbox_test.dart
@@ -17,6 +17,7 @@ import 'package:zulip/widgets/app.dart';
 import 'package:zulip/widgets/content.dart';
 import 'package:zulip/widgets/lightbox.dart';
 import 'package:zulip/widgets/message_list.dart';
+import 'package:zulip/widgets/user.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
diff --git a/test/widgets/message_list_test.dart b/test/widgets/message_list_test.dart
index b491777e8e..a7c4b14dbf 100644
--- a/test/widgets/message_list_test.dart
+++ b/test/widgets/message_list_test.dart
@@ -34,6 +34,7 @@ import 'package:zulip/widgets/store.dart';
 import 'package:zulip/widgets/channel_colors.dart';
 import 'package:zulip/widgets/theme.dart';
 import 'package:zulip/widgets/topic_list.dart';
+import 'package:zulip/widgets/user.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
diff --git a/test/widgets/new_dm_sheet_test.dart b/test/widgets/new_dm_sheet_test.dart
index 72a0ecab18..ae77e9643f 100644
--- a/test/widgets/new_dm_sheet_test.dart
+++ b/test/widgets/new_dm_sheet_test.dart
@@ -7,11 +7,11 @@ import 'package:zulip/basic.dart';
 import 'package:zulip/model/store.dart';
 import 'package:zulip/widgets/app_bar.dart';
 import 'package:zulip/widgets/compose_box.dart';
-import 'package:zulip/widgets/content.dart';
 import 'package:zulip/widgets/home.dart';
 import 'package:zulip/widgets/icons.dart';
 import 'package:zulip/widgets/new_dm_sheet.dart';
 import 'package:zulip/widgets/store.dart';
+import 'package:zulip/widgets/user.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
diff --git a/test/widgets/profile_test.dart b/test/widgets/profile_test.dart
index e03b665cda..271062aedb 100644
--- a/test/widgets/profile_test.dart
+++ b/test/widgets/profile_test.dart
@@ -19,6 +19,7 @@ import 'package:zulip/widgets/message_list.dart';
 import 'package:zulip/widgets/page.dart';
 import 'package:zulip/widgets/remote_settings.dart';
 import 'package:zulip/widgets/profile.dart';
+import 'package:zulip/widgets/user.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
diff --git a/test/widgets/recent_dm_conversations_test.dart b/test/widgets/recent_dm_conversations_test.dart
index 4f524f33f4..a947420dad 100644
--- a/test/widgets/recent_dm_conversations_test.dart
+++ b/test/widgets/recent_dm_conversations_test.dart
@@ -8,13 +8,13 @@ import 'package:zulip/api/model/model.dart';
 import 'package:zulip/basic.dart';
 import 'package:zulip/model/narrow.dart';
 import 'package:zulip/model/store.dart';
-import 'package:zulip/widgets/content.dart';
 import 'package:zulip/widgets/home.dart';
 import 'package:zulip/widgets/icons.dart';
 import 'package:zulip/widgets/message_list.dart';
 import 'package:zulip/widgets/new_dm_sheet.dart';
 import 'package:zulip/widgets/page.dart';
 import 'package:zulip/widgets/recent_dm_conversations.dart';
+import 'package:zulip/widgets/user.dart';
 
 import '../example_data.dart' as eg;
 import '../flutter_checks.dart';
diff --git a/test/widgets/user_test.dart b/test/widgets/user_test.dart
new file mode 100644
index 0000000000..5078da0497
--- /dev/null
+++ b/test/widgets/user_test.dart
@@ -0,0 +1,82 @@
+import 'package:checks/checks.dart';
+import 'package:flutter/cupertino.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter/rendering.dart';
+import 'package:flutter_test/flutter_test.dart';
+import 'package:zulip/model/store.dart';
+import 'package:zulip/widgets/content.dart';
+import 'package:zulip/widgets/store.dart';
+import 'package:zulip/widgets/user.dart';
+
+import '../example_data.dart' as eg;
+import '../model/binding.dart';
+import '../model/test_store.dart';
+import '../stdlib_checks.dart';
+import '../test_images.dart';
+
+void main() {
+  TestZulipBinding.ensureInitialized();
+
+  group('AvatarImage', () {
+    late PerAccountStore store;
+
+    Future<Uri?> actualUrl(WidgetTester tester, String avatarUrl, [double? size]) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+      store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+      final user = eg.user(avatarUrl: avatarUrl);
+      await store.addUser(user);
+
+      prepareBoringImageHttpClient();
+      await tester.pumpWidget(GlobalStoreWidget(
+        child: PerAccountStoreWidget(accountId: eg.selfAccount.id,
+          child: AvatarImage(userId: user.userId, size: size ?? 30))));
+      await tester.pump();
+      await tester.pump();
+      tester.widget(find.byType(AvatarImage));
+      final widgets = tester.widgetList<RealmContentNetworkImage>(
+        find.byType(RealmContentNetworkImage));
+      return widgets.firstOrNull?.src;
+    }
+
+    testWidgets('smoke with absolute URL', (tester) async {
+      const avatarUrl = 'https://example/avatar.png';
+      check(await actualUrl(tester, avatarUrl)).isNotNull()
+        .asString.equals(avatarUrl);
+      debugNetworkImageHttpClientProvider = null;
+    });
+
+    testWidgets('smoke with relative URL', (tester) async {
+      const avatarUrl = '/avatar.png';
+      check(await actualUrl(tester, avatarUrl))
+        .equals(store.tryResolveUrl(avatarUrl)!);
+      debugNetworkImageHttpClientProvider = null;
+    });
+
+   testWidgets('absolute URL, larger size', (tester) async {
+      tester.view.devicePixelRatio = 2.5;
+      addTearDown(tester.view.resetDevicePixelRatio);
+
+      const avatarUrl = 'https://example/avatar.png';
+      check(await actualUrl(tester, avatarUrl, 50)).isNotNull()
+        .asString.equals(avatarUrl.replaceAll('.png', '-medium.png'));
+      debugNetworkImageHttpClientProvider = null;
+    });
+
+    testWidgets('relative URL, larger size', (tester) async {
+      tester.view.devicePixelRatio = 2.5;
+      addTearDown(tester.view.resetDevicePixelRatio);
+
+      const avatarUrl = '/avatar.png';
+      check(await actualUrl(tester, avatarUrl, 50))
+        .equals(store.tryResolveUrl('/avatar-medium.png')!);
+      debugNetworkImageHttpClientProvider = null;
+    });
+
+    testWidgets('smoke with invalid URL', (tester) async {
+      const avatarUrl = '::not a URL::';
+      check(await actualUrl(tester, avatarUrl)).isNull();
+      debugNetworkImageHttpClientProvider = null;
+    });
+  });
+}
