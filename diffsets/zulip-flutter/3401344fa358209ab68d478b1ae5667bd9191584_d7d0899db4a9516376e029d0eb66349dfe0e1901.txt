diff --git a/ios/Runner.xcodeproj/project.pbxproj b/ios/Runner.xcodeproj/project.pbxproj
index b4928e2220..7df051a142 100644
--- a/ios/Runner.xcodeproj/project.pbxproj
+++ b/ios/Runner.xcodeproj/project.pbxproj
@@ -13,6 +13,7 @@
 		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
 		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
 		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
+		B34E9F092D776BEB0009AED2 /* Notifications.g.swift in Sources */ = {isa = PBXBuildFile; fileRef = B34E9F082D776BEB0009AED2 /* Notifications.g.swift */; };
 		F311C174AF9C005CE4AADD72 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 3EAE3F3F518B95B7BFEB4FE7 /* Pods_Runner.framework */; };
 /* End PBXBuildFile section */
 
@@ -48,6 +49,7 @@
 		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
 		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
 		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		B34E9F082D776BEB0009AED2 /* Notifications.g.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Notifications.g.swift; sourceTree = "<group>"; };
 		B3AF53A72CA20BD10039801D /* Zulip.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Zulip.xcconfig; path = Flutter/Zulip.xcconfig; sourceTree = "<group>"; };
 /* End PBXFileReference section */
 
@@ -115,6 +117,7 @@
 				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
 				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
 				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
+				B34E9F082D776BEB0009AED2 /* Notifications.g.swift */,
 				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
 			);
 			path = Runner;
@@ -297,6 +300,7 @@
 			buildActionMask = 2147483647;
 			files = (
 				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
+				B34E9F092D776BEB0009AED2 /* Notifications.g.swift in Sources */,
 				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
diff --git a/ios/Runner/AppDelegate.swift b/ios/Runner/AppDelegate.swift
index b636303481..33a0fe72cb 100644
--- a/ios/Runner/AppDelegate.swift
+++ b/ios/Runner/AppDelegate.swift
@@ -8,6 +8,26 @@ import Flutter
     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
   ) -> Bool {
     GeneratedPluginRegistrant.register(with: self)
+    let controller = window?.rootViewController as! FlutterViewController
+
+    // Retrieve the remote notification payload from launch options;
+    // this will be null if the launch wasn't triggered by a notification.
+    let notificationPayload = launchOptions?[.remoteNotification] as? [AnyHashable : Any]
+    let api = NotificationHostApiImpl(notificationPayload.map { NotificationDataFromLaunch(payload: $0) })
+    NotificationHostApiSetup.setUp(binaryMessenger: controller.binaryMessenger, api: api)
+
     return super.application(application, didFinishLaunchingWithOptions: launchOptions)
   }
 }
+
+private class NotificationHostApiImpl: NotificationHostApi {
+  private let maybeDataFromLaunch: NotificationDataFromLaunch?
+
+  init(_ maybeDataFromLaunch: NotificationDataFromLaunch?) {
+    self.maybeDataFromLaunch = maybeDataFromLaunch
+  }
+
+  func getNotificationDataFromLaunch() -> NotificationDataFromLaunch? {
+    maybeDataFromLaunch
+  }
+}
diff --git a/ios/Runner/Notifications.g.swift b/ios/Runner/Notifications.g.swift
new file mode 100644
index 0000000000..342953fbad
--- /dev/null
+++ b/ios/Runner/Notifications.g.swift
@@ -0,0 +1,235 @@
+// Autogenerated from Pigeon (v25.3.1), do not edit directly.
+// See also: https://pub.dev/packages/pigeon
+
+import Foundation
+
+#if os(iOS)
+  import Flutter
+#elseif os(macOS)
+  import FlutterMacOS
+#else
+  #error("Unsupported platform.")
+#endif
+
+/// Error class for passing custom error details to Dart side.
+final class PigeonError: Error {
+  let code: String
+  let message: String?
+  let details: Sendable?
+
+  init(code: String, message: String?, details: Sendable?) {
+    self.code = code
+    self.message = message
+    self.details = details
+  }
+
+  var localizedDescription: String {
+    return
+      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
+  }
+}
+
+private func wrapResult(_ result: Any?) -> [Any?] {
+  return [result]
+}
+
+private func wrapError(_ error: Any) -> [Any?] {
+  if let pigeonError = error as? PigeonError {
+    return [
+      pigeonError.code,
+      pigeonError.message,
+      pigeonError.details,
+    ]
+  }
+  if let flutterError = error as? FlutterError {
+    return [
+      flutterError.code,
+      flutterError.message,
+      flutterError.details,
+    ]
+  }
+  return [
+    "\(error)",
+    "\(type(of: error))",
+    "Stacktrace: \(Thread.callStackSymbols)",
+  ]
+}
+
+private func isNullish(_ value: Any?) -> Bool {
+  return value is NSNull || value == nil
+}
+
+private func nilOrValue<T>(_ value: Any?) -> T? {
+  if value is NSNull { return nil }
+  return value as! T?
+}
+
+func deepEqualsNotifications(_ lhs: Any?, _ rhs: Any?) -> Bool {
+  let cleanLhs = nilOrValue(lhs) as Any?
+  let cleanRhs = nilOrValue(rhs) as Any?
+  switch (cleanLhs, cleanRhs) {
+  case (nil, nil):
+    return true
+
+  case (nil, _), (_, nil):
+    return false
+
+  case is (Void, Void):
+    return true
+
+  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
+    return cleanLhsHashable == cleanRhsHashable
+
+  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
+    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
+    for (index, element) in cleanLhsArray.enumerated() {
+      if !deepEqualsNotifications(element, cleanRhsArray[index]) {
+        return false
+      }
+    }
+    return true
+
+  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
+    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
+    for (key, cleanLhsValue) in cleanLhsDictionary {
+      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
+      if !deepEqualsNotifications(cleanLhsValue, cleanRhsDictionary[key]!) {
+        return false
+      }
+    }
+    return true
+
+  default:
+    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
+    return false
+  }
+}
+
+func deepHashNotifications(value: Any?, hasher: inout Hasher) {
+  if let valueList = value as? [AnyHashable] {
+     for item in valueList { deepHashNotifications(value: item, hasher: &hasher) }
+     return
+  }
+
+  if let valueDict = value as? [AnyHashable: AnyHashable] {
+    for key in valueDict.keys { 
+      hasher.combine(key)
+      deepHashNotifications(value: valueDict[key]!, hasher: &hasher)
+    }
+    return
+  }
+
+  if let hashableValue = value as? AnyHashable {
+    hasher.combine(hashableValue.hashValue)
+  }
+
+  return hasher.combine(String(describing: value))
+}
+
+    
+
+/// Generated class from Pigeon that represents data sent in messages.
+struct NotificationDataFromLaunch: Hashable {
+  /// The raw payload that is attached to the notification,
+  /// holding the information required to carry out the navigation.
+  ///
+  /// See [NotificationHostApi.getNotificationDataFromLaunch].
+  var payload: [AnyHashable?: Any?]
+
+
+  // swift-format-ignore: AlwaysUseLowerCamelCase
+  static func fromList(_ pigeonVar_list: [Any?]) -> NotificationDataFromLaunch? {
+    let payload = pigeonVar_list[0] as! [AnyHashable?: Any?]
+
+    return NotificationDataFromLaunch(
+      payload: payload
+    )
+  }
+  func toList() -> [Any?] {
+    return [
+      payload
+    ]
+  }
+  static func == (lhs: NotificationDataFromLaunch, rhs: NotificationDataFromLaunch) -> Bool {
+    return deepEqualsNotifications(lhs.toList(), rhs.toList())  }
+  func hash(into hasher: inout Hasher) {
+    deepHashNotifications(value: toList(), hasher: &hasher)
+  }
+}
+
+private class NotificationsPigeonCodecReader: FlutterStandardReader {
+  override func readValue(ofType type: UInt8) -> Any? {
+    switch type {
+    case 129:
+      return NotificationDataFromLaunch.fromList(self.readValue() as! [Any?])
+    default:
+      return super.readValue(ofType: type)
+    }
+  }
+}
+
+private class NotificationsPigeonCodecWriter: FlutterStandardWriter {
+  override func writeValue(_ value: Any) {
+    if let value = value as? NotificationDataFromLaunch {
+      super.writeByte(129)
+      super.writeValue(value.toList())
+    } else {
+      super.writeValue(value)
+    }
+  }
+}
+
+private class NotificationsPigeonCodecReaderWriter: FlutterStandardReaderWriter {
+  override func reader(with data: Data) -> FlutterStandardReader {
+    return NotificationsPigeonCodecReader(data: data)
+  }
+
+  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
+    return NotificationsPigeonCodecWriter(data: data)
+  }
+}
+
+class NotificationsPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
+  static let shared = NotificationsPigeonCodec(readerWriter: NotificationsPigeonCodecReaderWriter())
+}
+
+/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
+protocol NotificationHostApi {
+  /// Retrieves notification data if the app was launched by tapping on a notification.
+  ///
+  /// Returns `launchOptions.remoteNotification`,
+  /// which is the raw APNs data dictionary
+  /// if the app launch was opened by a notification tap,
+  /// else null. See Apple doc:
+  ///   https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/remotenotification
+  func getNotificationDataFromLaunch() throws -> NotificationDataFromLaunch?
+}
+
+/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
+class NotificationHostApiSetup {
+  static var codec: FlutterStandardMessageCodec { NotificationsPigeonCodec.shared }
+  /// Sets up an instance of `NotificationHostApi` to handle messages through the `binaryMessenger`.
+  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: NotificationHostApi?, messageChannelSuffix: String = "") {
+    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
+    /// Retrieves notification data if the app was launched by tapping on a notification.
+    ///
+    /// Returns `launchOptions.remoteNotification`,
+    /// which is the raw APNs data dictionary
+    /// if the app launch was opened by a notification tap,
+    /// else null. See Apple doc:
+    ///   https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/remotenotification
+    let getNotificationDataFromLaunchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.zulip.NotificationHostApi.getNotificationDataFromLaunch\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
+    if let api = api {
+      getNotificationDataFromLaunchChannel.setMessageHandler { _, reply in
+        do {
+          let result = try api.getNotificationDataFromLaunch()
+          reply(wrapResult(result))
+        } catch {
+          reply(wrapError(error))
+        }
+      }
+    } else {
+      getNotificationDataFromLaunchChannel.setMessageHandler(nil)
+    }
+  }
+}
diff --git a/lib/host/notifications.dart b/lib/host/notifications.dart
new file mode 100644
index 0000000000..6c3e593e2c
--- /dev/null
+++ b/lib/host/notifications.dart
@@ -0,0 +1 @@
+export './notifications.g.dart';
diff --git a/lib/host/notifications.g.dart b/lib/host/notifications.g.dart
new file mode 100644
index 0000000000..d8448d60b8
--- /dev/null
+++ b/lib/host/notifications.g.dart
@@ -0,0 +1,146 @@
+// Autogenerated from Pigeon (v25.3.1), do not edit directly.
+// See also: https://pub.dev/packages/pigeon
+// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers
+
+import 'dart:async';
+import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;
+
+import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
+import 'package:flutter/services.dart';
+
+PlatformException _createConnectionError(String channelName) {
+  return PlatformException(
+    code: 'channel-error',
+    message: 'Unable to establish connection on channel: "$channelName".',
+  );
+}
+bool _deepEquals(Object? a, Object? b) {
+  if (a is List && b is List) {
+    return a.length == b.length &&
+        a.indexed
+        .every(((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]));
+  }
+  if (a is Map && b is Map) {
+    return a.length == b.length && a.entries.every((MapEntry<Object?, Object?> entry) =>
+        (b as Map<Object?, Object?>).containsKey(entry.key) &&
+        _deepEquals(entry.value, b[entry.key]));
+  }
+  return a == b;
+}
+
+
+class NotificationDataFromLaunch {
+  NotificationDataFromLaunch({
+    required this.payload,
+  });
+
+  /// The raw payload that is attached to the notification,
+  /// holding the information required to carry out the navigation.
+  ///
+  /// See [NotificationHostApi.getNotificationDataFromLaunch].
+  Map<Object?, Object?> payload;
+
+  List<Object?> _toList() {
+    return <Object?>[
+      payload,
+    ];
+  }
+
+  Object encode() {
+    return _toList();  }
+
+  static NotificationDataFromLaunch decode(Object result) {
+    result as List<Object?>;
+    return NotificationDataFromLaunch(
+      payload: (result[0] as Map<Object?, Object?>?)!.cast<Object?, Object?>(),
+    );
+  }
+
+  @override
+  // ignore: avoid_equals_and_hash_code_on_mutable_classes
+  bool operator ==(Object other) {
+    if (other is! NotificationDataFromLaunch || other.runtimeType != runtimeType) {
+      return false;
+    }
+    if (identical(this, other)) {
+      return true;
+    }
+    return _deepEquals(encode(), other.encode());
+  }
+
+  @override
+  // ignore: avoid_equals_and_hash_code_on_mutable_classes
+  int get hashCode => Object.hashAll(_toList())
+;
+}
+
+
+class _PigeonCodec extends StandardMessageCodec {
+  const _PigeonCodec();
+  @override
+  void writeValue(WriteBuffer buffer, Object? value) {
+    if (value is int) {
+      buffer.putUint8(4);
+      buffer.putInt64(value);
+    }    else if (value is NotificationDataFromLaunch) {
+      buffer.putUint8(129);
+      writeValue(buffer, value.encode());
+    } else {
+      super.writeValue(buffer, value);
+    }
+  }
+
+  @override
+  Object? readValueOfType(int type, ReadBuffer buffer) {
+    switch (type) {
+      case 129: 
+        return NotificationDataFromLaunch.decode(readValue(buffer)!);
+      default:
+        return super.readValueOfType(type, buffer);
+    }
+  }
+}
+
+class NotificationHostApi {
+  /// Constructor for [NotificationHostApi].  The [binaryMessenger] named argument is
+  /// available for dependency injection.  If it is left null, the default
+  /// BinaryMessenger will be used which routes to the host platform.
+  NotificationHostApi({BinaryMessenger? binaryMessenger, String messageChannelSuffix = ''})
+      : pigeonVar_binaryMessenger = binaryMessenger,
+        pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty ? '.$messageChannelSuffix' : '';
+  final BinaryMessenger? pigeonVar_binaryMessenger;
+
+  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();
+
+  final String pigeonVar_messageChannelSuffix;
+
+  /// Retrieves notification data if the app was launched by tapping on a notification.
+  ///
+  /// Returns `launchOptions.remoteNotification`,
+  /// which is the raw APNs data dictionary
+  /// if the app launch was opened by a notification tap,
+  /// else null. See Apple doc:
+  ///   https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/remotenotification
+  Future<NotificationDataFromLaunch?> getNotificationDataFromLaunch() async {
+    final String pigeonVar_channelName = 'dev.flutter.pigeon.zulip.NotificationHostApi.getNotificationDataFromLaunch$pigeonVar_messageChannelSuffix';
+    final BasicMessageChannel<Object?> pigeonVar_channel = BasicMessageChannel<Object?>(
+      pigeonVar_channelName,
+      pigeonChannelCodec,
+      binaryMessenger: pigeonVar_binaryMessenger,
+    );
+    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(null);
+    final List<Object?>? pigeonVar_replyList =
+        await pigeonVar_sendFuture as List<Object?>?;
+    if (pigeonVar_replyList == null) {
+      throw _createConnectionError(pigeonVar_channelName);
+    } else if (pigeonVar_replyList.length > 1) {
+      throw PlatformException(
+        code: pigeonVar_replyList[0]! as String,
+        message: pigeonVar_replyList[1] as String?,
+        details: pigeonVar_replyList[2],
+      );
+    } else {
+      return (pigeonVar_replyList[0] as NotificationDataFromLaunch?);
+    }
+  }
+}
diff --git a/lib/model/binding.dart b/lib/model/binding.dart
index fb3add46da..7f9b0f6fd1 100644
--- a/lib/model/binding.dart
+++ b/lib/model/binding.dart
@@ -11,6 +11,7 @@ import 'package:url_launcher/url_launcher.dart' as url_launcher;
 import 'package:wakelock_plus/wakelock_plus.dart' as wakelock_plus;
 
 import '../host/android_notifications.dart';
+import '../host/notifications.dart' as notif_pigeon;
 import '../log.dart';
 import '../widgets/store.dart';
 import 'store.dart';
@@ -180,6 +181,9 @@ abstract class ZulipBinding {
   /// Wraps the [AndroidNotificationHostApi] constructor.
   AndroidNotificationHostApi get androidNotificationHost;
 
+  /// Wraps the [notif_pigeon.NotificationHostApi] class.
+  NotificationPigeonApi get notificationPigeonApi;
+
   /// Pick files from the media library, via package:file_picker.
   ///
   /// This wraps [file_picker.pickFiles].
@@ -324,6 +328,13 @@ class PackageInfo {
   });
 }
 
+class NotificationPigeonApi {
+  final _hostApi = notif_pigeon.NotificationHostApi();
+
+  Future<notif_pigeon.NotificationDataFromLaunch?> getNotificationDataFromLaunch() =>
+    _hostApi.getNotificationDataFromLaunch();
+}
+
 /// A concrete binding for use in the live application.
 ///
 /// The global store returned by [getGlobalStore], and consequently by
@@ -469,6 +480,9 @@ class LiveZulipBinding extends ZulipBinding {
   @override
   AndroidNotificationHostApi get androidNotificationHost => AndroidNotificationHostApi();
 
+  @override
+  NotificationPigeonApi get notificationPigeonApi => NotificationPigeonApi();
+
   @override
   Future<file_picker.FilePickerResult?> pickFiles({
     bool allowMultiple = false,
diff --git a/lib/notifications/open.dart b/lib/notifications/open.dart
index f47caaacb9..365bdf4c92 100644
--- a/lib/notifications/open.dart
+++ b/lib/notifications/open.dart
@@ -1,4 +1,5 @@
 import 'dart:async';
+import 'dart:convert';
 
 import 'package:collection/collection.dart';
 import 'package:flutter/foundation.dart';
@@ -6,7 +7,9 @@ import 'package:flutter/widgets.dart';
 
 import '../api/model/model.dart';
 import '../generated/l10n/zulip_localizations.dart';
+import '../host/notifications.dart';
 import '../log.dart';
+import '../model/binding.dart';
 import '../model/narrow.dart';
 import '../widgets/app.dart';
 import '../widgets/dialog.dart';
@@ -14,8 +17,75 @@ import '../widgets/message_list.dart';
 import '../widgets/page.dart';
 import '../widgets/store.dart';
 
+NotificationPigeonApi get _notifPigeonApi => ZulipBinding.instance.notificationPigeonApi;
+
 /// Responds to the user opening a notification.
 class NotificationOpenService {
+  static NotificationOpenService get instance => (_instance ??= NotificationOpenService._());
+  static NotificationOpenService? _instance;
+
+  NotificationOpenService._();
+
+  /// Reset the state of the [NotificationNavigationService], for testing.
+  static void debugReset() {
+    _instance = null;
+  }
+
+  NotificationDataFromLaunch? _notifDataFromLaunch;
+
+  /// A [Future] that completes to signal that the initialization of
+  /// [NotificationNavigationService] has completed
+  /// (with either success or failure).
+  ///
+  /// Null if [start] hasn't been called.
+  Future<void>? get initialized => _initializedSignal?.future;
+
+  Completer<void>? _initializedSignal;
+
+  Future<void> start() async {
+    assert(_initializedSignal == null);
+    _initializedSignal = Completer<void>();
+    try {
+      switch (defaultTargetPlatform) {
+        case TargetPlatform.iOS:
+          _notifDataFromLaunch = await _notifPigeonApi.getNotificationDataFromLaunch();
+
+        case TargetPlatform.android:
+          // Do nothing; we do notification routing differently on Android.
+          // TODO migrate Android to use the new Pigeon API.
+          break;
+
+        case TargetPlatform.fuchsia:
+        case TargetPlatform.linux:
+        case TargetPlatform.macOS:
+        case TargetPlatform.windows:
+          // Do nothing; we don't offer notifications on these platforms.
+          break;
+      }
+    } finally {
+      _initializedSignal!.complete();
+    }
+  }
+
+  /// Provides the route to open if the app was launched through a tap on
+  /// a notification.
+  ///
+  /// Returns null if app launch wasn't triggered by a notification, or if
+  /// an error occurs while determining the route for the notification.
+  /// In the latter case an error dialog is also shown.
+  ///
+  /// The context argument should be a descendant of the app's main [Navigator].
+  AccountRoute<void>? routeForNotificationFromLaunch({required BuildContext context}) {
+    assert(defaultTargetPlatform == TargetPlatform.iOS);
+    final data = _notifDataFromLaunch;
+    if (data == null) return null;
+    assert(debugLog('opened notif: ${jsonEncode(data.payload)}'));
+
+    final notifNavData = _tryParseIosApnsPayload(context, data.payload);
+    if (notifNavData == null) return null; // TODO(log)
+
+    return routeForNotification(context: context, data: notifNavData);
+  }
 
   /// Provides the route to open by parsing the notification payload.
   ///
@@ -27,8 +97,6 @@ class NotificationOpenService {
     required BuildContext context,
     required NotificationOpenPayload data,
   }) {
-    assert(defaultTargetPlatform == TargetPlatform.android);
-
     final globalStore = GlobalStoreWidget.of(context);
 
     final account = globalStore.accounts.firstWhereOrNull(
@@ -71,6 +139,21 @@ class NotificationOpenService {
     unawaited(navigator.push(route));
   }
 
+  static NotificationOpenPayload? _tryParseIosApnsPayload(
+    BuildContext context,
+    Map<Object?, Object?> payload,
+  ) {
+    try {
+      return NotificationOpenPayload.parseIosApnsPayload(payload);
+    } on FormatException catch (e, st) {
+      assert(debugLog('$e\n$st'));
+      final zulipLocalizations = ZulipLocalizations.of(context);
+      showErrorDialog(context: context,
+        title: zulipLocalizations.errorNotificationOpenTitle);
+      return null;
+    }
+  }
+
   static NotificationOpenPayload? tryParseAndroidNotificationUrl({
     required BuildContext context,
     required Uri url,
diff --git a/lib/notifications/receive.dart b/lib/notifications/receive.dart
index d60469ff30..212b0f5f0d 100644
--- a/lib/notifications/receive.dart
+++ b/lib/notifications/receive.dart
@@ -8,6 +8,7 @@ import '../firebase_options.dart';
 import '../log.dart';
 import '../model/binding.dart';
 import 'display.dart';
+import 'open.dart';
 
 @pragma('vm:entry-point')
 class NotificationService {
@@ -24,6 +25,7 @@ class NotificationService {
     instance.token.dispose();
     _instance = null;
     assert(debugBackgroundIsolateIsLive = true);
+    NotificationOpenService.debugReset();
   }
 
   /// Whether a background isolate should initialize [LiveZulipBinding].
@@ -77,6 +79,8 @@ class NotificationService {
         await _getFcmToken();
 
       case TargetPlatform.iOS: // TODO(#324): defer requesting notif permission
+        await NotificationOpenService.instance.start();
+
         await ZulipBinding.instance.firebaseInitializeApp(
           options: kFirebaseOptionsIos);
 
diff --git a/lib/widgets/app.dart b/lib/widgets/app.dart
index 96c546bd3f..b1aa763ac8 100644
--- a/lib/widgets/app.dart
+++ b/lib/widgets/app.dart
@@ -168,6 +168,12 @@ class _ZulipAppState extends State<ZulipApp> with WidgetsBindingObserver {
     super.dispose();
   }
 
+  AccountRoute<void>? _initialRouteIos(BuildContext context) {
+    return NotificationOpenService.instance
+        .routeForNotificationFromLaunch(context: context);
+  }
+
+  // TODO migrate Android's notification navigation to use the new Pigeon API.
   AccountRoute<void>? _initialRouteAndroid(
     BuildContext context,
     String initialRoute,
@@ -190,10 +196,12 @@ class _ZulipAppState extends State<ZulipApp> with WidgetsBindingObserver {
   List<Route<dynamic>> _handleGenerateInitialRoutes(String initialRoute) {
     // The `_ZulipAppState.context` lacks the required ancestors. Instead
     // we use the Navigator which should be available when this callback is
-    // called and it's context should have the required ancestors.
+    // called and its context should have the required ancestors.
     final context = ZulipApp.navigatorKey.currentContext!;
 
-    final route = _initialRouteAndroid(context, initialRoute);
+    final route = defaultTargetPlatform == TargetPlatform.iOS
+        ? _initialRouteIos(context)
+        : _initialRouteAndroid(context, initialRoute);
     if (route != null) {
       return [
         HomePage.buildRoute(accountId: route.accountId),
@@ -228,6 +236,7 @@ class _ZulipAppState extends State<ZulipApp> with WidgetsBindingObserver {
   @override
   Widget build(BuildContext context) {
     return GlobalStoreWidget(
+      blockingFuture: NotificationOpenService.instance.initialized,
       child: Builder(builder: (context) {
         return MaterialApp(
           onGenerateTitle: (BuildContext context) {
diff --git a/pigeon/notifications.dart b/pigeon/notifications.dart
new file mode 100644
index 0000000000..efea52d9a6
--- /dev/null
+++ b/pigeon/notifications.dart
@@ -0,0 +1,30 @@
+import 'package:pigeon/pigeon.dart';
+
+// To rebuild this pigeon's output after editing this file,
+// run `tools/check pigeon --fix`.
+@ConfigurePigeon(PigeonOptions(
+  dartOut: 'lib/host/notifications.g.dart',
+  swiftOut: 'ios/Runner/Notifications.g.swift',
+))
+
+class NotificationDataFromLaunch {
+  const NotificationDataFromLaunch({required this.payload});
+
+  /// The raw payload that is attached to the notification,
+  /// holding the information required to carry out the navigation.
+  ///
+  /// See [NotificationHostApi.getNotificationDataFromLaunch].
+  final Map<Object?, Object?> payload;
+}
+
+@HostApi()
+abstract class NotificationHostApi {
+  /// Retrieves notification data if the app was launched by tapping on a notification.
+  ///
+  /// Returns `launchOptions.remoteNotification`,
+  /// which is the raw APNs data dictionary
+  /// if the app launch was opened by a notification tap,
+  /// else null. See Apple doc:
+  ///   https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/remotenotification
+  NotificationDataFromLaunch? getNotificationDataFromLaunch();
+}
diff --git a/test/model/binding.dart b/test/model/binding.dart
index 6b4de26608..afeed2f266 100644
--- a/test/model/binding.dart
+++ b/test/model/binding.dart
@@ -8,6 +8,7 @@ import 'package:flutter/services.dart';
 import 'package:test/fake.dart';
 import 'package:url_launcher/url_launcher.dart' as url_launcher;
 import 'package:zulip/host/android_notifications.dart';
+import 'package:zulip/host/notifications.dart';
 import 'package:zulip/model/binding.dart';
 import 'package:zulip/model/store.dart';
 import 'package:zulip/widgets/app.dart';
@@ -311,6 +312,7 @@ class TestZulipBinding extends ZulipBinding {
 
   void _resetNotifications() {
     _androidNotificationHostApi = null;
+    _notificationPigeonApi = null;
   }
 
   @override
@@ -318,6 +320,11 @@ class TestZulipBinding extends ZulipBinding {
     (_androidNotificationHostApi ??= FakeAndroidNotificationHostApi());
   FakeAndroidNotificationHostApi? _androidNotificationHostApi;
 
+  @override
+  FakeNotificationPigeonApi get notificationPigeonApi =>
+    (_notificationPigeonApi ??= FakeNotificationPigeonApi());
+  FakeNotificationPigeonApi? _notificationPigeonApi;
+
   /// The value that `ZulipBinding.instance.pickFiles()` should return.
   ///
   /// See also [takePickFilesCalls].
@@ -754,6 +761,20 @@ class FakeAndroidNotificationHostApi implements AndroidNotificationHostApi {
   }
 }
 
+class FakeNotificationPigeonApi implements NotificationPigeonApi {
+  NotificationDataFromLaunch? _notificationDataFromLaunch;
+
+  /// Populates the notification data for launch to be returned
+  /// by [getNotificationDataFromLaunch].
+  void setNotificationDataFromLaunch(NotificationDataFromLaunch? data) {
+    _notificationDataFromLaunch = data;
+  }
+
+  @override
+  Future<NotificationDataFromLaunch?> getNotificationDataFromLaunch() async =>
+    _notificationDataFromLaunch;
+}
+
 typedef AndroidNotificationHostApiNotifyCall = ({
   String? tag,
   int id,
diff --git a/test/model/store_test.dart b/test/model/store_test.dart
index 0b303b53e2..c3aadb1171 100644
--- a/test/model/store_test.dart
+++ b/test/model/store_test.dart
@@ -1293,8 +1293,8 @@ void main() {
       // (This is probably the common case.)
       addTearDown(testBinding.reset);
       testBinding.firebaseMessagingInitialToken = '012abc';
-      addTearDown(NotificationService.debugReset);
       testBinding.packageInfoResult = eg.packageInfo(packageName: 'com.zulip.flutter');
+      addTearDown(NotificationService.debugReset);
       await NotificationService.instance.start();
 
       // On store startup, send the token.
@@ -1321,8 +1321,8 @@ void main() {
       // request for the token is still pending.
       addTearDown(testBinding.reset);
       testBinding.firebaseMessagingInitialToken = '012abc';
-      addTearDown(NotificationService.debugReset);
       testBinding.packageInfoResult = eg.packageInfo(packageName: 'com.zulip.flutter');
+      addTearDown(NotificationService.debugReset);
       final startFuture = NotificationService.instance.start();
 
       // TODO this test is a bit brittle in its interaction with asynchrony;
diff --git a/test/notifications/open_test.dart b/test/notifications/open_test.dart
index 46f7a45b5a..db86c71abc 100644
--- a/test/notifications/open_test.dart
+++ b/test/notifications/open_test.dart
@@ -1,10 +1,12 @@
 import 'dart:async';
 
 import 'package:checks/checks.dart';
+import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_test/flutter_test.dart';
 import 'package:zulip/api/model/model.dart';
 import 'package:zulip/api/notifications.dart';
+import 'package:zulip/host/notifications.dart';
 import 'package:zulip/model/database.dart';
 import 'package:zulip/model/localizations.dart';
 import 'package:zulip/model/narrow.dart';
@@ -133,18 +135,37 @@ void main() {
     }
 
     Future<void> openNotification(WidgetTester tester, Account account, Message message) async {
-      final intentDataUrl = androidNotificationUrlForMessage(account, message);
-      unawaited(
-        WidgetsBinding.instance.handlePushRoute(intentDataUrl.toString()));
-      await tester.idle(); // let navigateForNotification find navigator
+      switch (defaultTargetPlatform) {
+        case TargetPlatform.android:
+          final intentDataUrl = androidNotificationUrlForMessage(account, message);
+          unawaited(
+            WidgetsBinding.instance.handlePushRoute(intentDataUrl.toString()));
+          await tester.idle(); // let navigateForNotification find navigator
+
+        default:
+          throw UnsupportedError('Unsupported target platform: "$defaultTargetPlatform"');
+      }
     }
 
     void setupNotificationDataForLaunch(WidgetTester tester, Account account, Message message) {
-      // Set up a value for `PlatformDispatcher.defaultRouteName` to return,
-      // for determining the initial route.
-      final intentDataUrl = androidNotificationUrlForMessage(account, message);
-      addTearDown(tester.binding.platformDispatcher.clearDefaultRouteNameTestValue);
-      tester.binding.platformDispatcher.defaultRouteNameTestValue = intentDataUrl.toString();
+      switch (defaultTargetPlatform) {
+        case TargetPlatform.android:
+          // Set up a value for `PlatformDispatcher.defaultRouteName` to return,
+          // for determining the initial route.
+          final intentDataUrl = androidNotificationUrlForMessage(account, message);
+          addTearDown(tester.binding.platformDispatcher.clearDefaultRouteNameTestValue);
+          tester.binding.platformDispatcher.defaultRouteNameTestValue = intentDataUrl.toString();
+
+        case TargetPlatform.iOS:
+          // Set up a value to return for
+          // `notificationPigeonApi.getNotificationDataFromLaunch`.
+          final payload = messageApnsPayload(message, account: account);
+          testBinding.notificationPigeonApi.setNotificationDataFromLaunch(
+            NotificationDataFromLaunch(payload: payload));
+
+        default:
+          throw UnsupportedError('Unsupported target platform: "$defaultTargetPlatform"');
+      }
     }
 
     void matchesNavigation(Subject<Route<void>> route, Account account, Message message) {
@@ -166,7 +187,7 @@ void main() {
       await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
       await prepare(tester);
       await checkOpenNotification(tester, eg.selfAccount, eg.streamMessage());
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('direct message', (tester) async {
       addTearDown(testBinding.reset);
@@ -174,7 +195,7 @@ void main() {
       await prepare(tester);
       await checkOpenNotification(tester, eg.selfAccount,
         eg.dmMessage(from: eg.otherUser, to: [eg.selfUser]));
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('account queried by realmUrl origin component', (tester) async {
       addTearDown(testBinding.reset);
@@ -189,7 +210,7 @@ void main() {
       await checkOpenNotification(tester,
         eg.selfAccount.copyWith(realmUrl: Uri.parse('http://chat.example')),
         eg.streamMessage());
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('no accounts', (tester) async {
       await prepare(tester, withAccount: false);
@@ -199,7 +220,7 @@ void main() {
       await tester.tap(find.byWidget(checkErrorDialog(tester,
         expectedTitle: zulipLocalizations.errorNotificationOpenTitle,
         expectedMessage: zulipLocalizations.errorNotificationOpenAccountNotFound)));
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('mismatching account', (tester) async {
       addTearDown(testBinding.reset);
@@ -211,7 +232,7 @@ void main() {
       await tester.tap(find.byWidget(checkErrorDialog(tester,
         expectedTitle: zulipLocalizations.errorNotificationOpenTitle,
         expectedMessage: zulipLocalizations.errorNotificationOpenAccountNotFound)));
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('find account among several', (tester) async {
       addTearDown(testBinding.reset);
@@ -234,7 +255,7 @@ void main() {
       await checkOpenNotification(tester, accounts[1], eg.streamMessage());
       await checkOpenNotification(tester, accounts[2], eg.streamMessage());
       await checkOpenNotification(tester, accounts[3], eg.streamMessage());
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('wait for app to become ready', (tester) async {
       addTearDown(testBinding.reset);
@@ -254,7 +275,7 @@ void main() {
       takeStartingRoutes();
       // â€¦ and then the one the notification leads to.
       matchesNavigation(check(pushedRoutes).single, eg.selfAccount, message);
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android}));
 
     testWidgets('at app launch', (tester) async {
       addTearDown(testBinding.reset);
@@ -271,7 +292,7 @@ void main() {
       await tester.pump();
       takeStartingRoutes();
       matchesNavigation(check(pushedRoutes).single, account, message);
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android, TargetPlatform.iOS}));
 
     testWidgets('uses associated account as initial account; if initial route', (tester) async {
       addTearDown(testBinding.reset);
@@ -289,7 +310,7 @@ void main() {
       await tester.pump();
       takeStartingRoutes(account: accountB);
       matchesNavigation(check(pushedRoutes).single, accountB, message);
-    });
+    }, variant: const TargetPlatformVariant({TargetPlatform.android, TargetPlatform.iOS}));
   });
 
   group('NotificationOpenPayload', () {
