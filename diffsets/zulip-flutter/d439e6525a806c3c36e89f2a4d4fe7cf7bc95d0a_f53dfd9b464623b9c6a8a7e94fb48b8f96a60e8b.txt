diff --git a/test/widgets/actions_test.dart b/test/widgets/actions_test.dart
new file mode 100644
index 0000000000..759cfa4218
--- /dev/null
+++ b/test/widgets/actions_test.dart
@@ -0,0 +1,284 @@
+import 'dart:convert';
+
+import 'package:checks/checks.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_gen/gen_l10n/zulip_localizations.dart';
+import 'package:flutter_test/flutter_test.dart';
+import 'package:http/http.dart' as http;
+import 'package:zulip/api/model/initial_snapshot.dart';
+import 'package:zulip/api/model/narrow.dart';
+import 'package:zulip/api/route/messages.dart';
+import 'package:zulip/model/localizations.dart';
+import 'package:zulip/model/narrow.dart';
+import 'package:zulip/model/store.dart';
+import 'package:zulip/widgets/actions.dart';
+import 'package:zulip/widgets/store.dart';
+import 'package:zulip/widgets/theme.dart';
+
+import '../api/fake_api.dart';
+import '../example_data.dart' as eg;
+import '../model/binding.dart';
+import '../model/unreads_checks.dart';
+import '../stdlib_checks.dart';
+import 'dialog_checks.dart';
+
+void main() {
+  TestZulipBinding.ensureInitialized();
+
+  group('markNarrowAsRead', () {
+    late PerAccountStore store;
+    late FakeApiConnection connection;
+    late BuildContext context;
+
+    Future<void> prepare(WidgetTester tester, {
+      UnreadMessagesSnapshot? unreadMsgs,
+    }) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot(
+        unreadMsgs: unreadMsgs));
+      store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+      connection = store.connection as FakeApiConnection;
+
+      await tester.pumpWidget(Builder(builder: (context) =>
+        MaterialApp(
+          theme: zulipThemeData(context),
+          localizationsDelegates: ZulipLocalizations.localizationsDelegates,
+          supportedLocales: ZulipLocalizations.supportedLocales,
+          home: GlobalStoreWidget(
+            child: PerAccountStoreWidget(
+              accountId: eg.selfAccount.id,
+              child: const Scaffold(
+                body: Placeholder()))))));
+      await tester.pumpAndSettle();
+      context = tester.element(find.byType(Placeholder));
+    }
+
+    testWidgets('smoke test on modern server', (tester) async {
+      final narrow = TopicNarrow.ofMessage(eg.streamMessage());
+      await prepare(tester);
+      connection.prepare(json: UpdateMessageFlagsForNarrowResult(
+        processedCount: 11, updatedCount: 3,
+        firstProcessedId: null, lastProcessedId: null,
+        foundOldest: true, foundNewest: true).toJson());
+      markNarrowAsRead(context, narrow, false);
+      await tester.pump(Duration.zero);
+      final apiNarrow = narrow.apiEncode()..add(ApiNarrowIsUnread());
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages/flags/narrow')
+        ..bodyFields.deepEquals({
+            'anchor': 'oldest',
+            'include_anchor': 'false',
+            'num_before': '0',
+            'num_after': '1000',
+            'narrow': jsonEncode(apiNarrow),
+            'op': 'add',
+            'flag': 'read',
+          });
+    });
+
+
+    testWidgets('use is:unread optimization', (WidgetTester tester) async {
+      const narrow = CombinedFeedNarrow();
+      await prepare(tester);
+      connection.prepare(json: UpdateMessageFlagsForNarrowResult(
+        processedCount: 11, updatedCount: 3,
+        firstProcessedId: null, lastProcessedId: null,
+        foundOldest: true, foundNewest: true).toJson());
+      markNarrowAsRead(context, narrow, false);
+      await tester.pump(Duration.zero);
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages/flags/narrow')
+        ..bodyFields.deepEquals({
+            'anchor': 'oldest',
+            'include_anchor': 'false',
+            'num_before': '0',
+            'num_after': '1000',
+            'narrow': json.encode([{'operator': 'is', 'operand': 'unread'}]),
+            'op': 'add',
+            'flag': 'read',
+          });
+    });
+
+    testWidgets('pagination', (WidgetTester tester) async {
+      // Check that `lastProcessedId` returned from an initial
+      // response is used as `anchorId` for the subsequent request.
+      final narrow = TopicNarrow.ofMessage(eg.streamMessage());
+      await prepare(tester);
+
+      connection.prepare(json: UpdateMessageFlagsForNarrowResult(
+        processedCount: 1000, updatedCount: 890,
+        firstProcessedId: 1, lastProcessedId: 1989,
+        foundOldest: true, foundNewest: false).toJson());
+      markNarrowAsRead(context, narrow, false);
+      final apiNarrow = narrow.apiEncode()..add(ApiNarrowIsUnread());
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages/flags/narrow')
+        ..bodyFields.deepEquals({
+            'anchor': 'oldest',
+            'include_anchor': 'false',
+            'num_before': '0',
+            'num_after': '1000',
+            'narrow': jsonEncode(apiNarrow),
+            'op': 'add',
+            'flag': 'read',
+          });
+
+      connection.prepare(json: UpdateMessageFlagsForNarrowResult(
+        processedCount: 20, updatedCount: 10,
+        firstProcessedId: 2000, lastProcessedId: 2023,
+        foundOldest: false, foundNewest: true).toJson());
+      await tester.pumpAndSettle();
+      check(find.bySubtype<SnackBar>().evaluate()).length.equals(1);
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages/flags/narrow')
+        ..bodyFields.deepEquals({
+            'anchor': '1989',
+            'include_anchor': 'false',
+            'num_before': '0',
+            'num_after': '1000',
+            'narrow': jsonEncode(apiNarrow),
+            'op': 'add',
+            'flag': 'read',
+          });
+    });
+
+    testWidgets('on mark-all-as-read when Unreads.oldUnreadsMissing: true', (tester) async {
+      const narrow = CombinedFeedNarrow();
+      await prepare(tester);
+      store.unreads.oldUnreadsMissing = true;
+
+      connection.prepare(json: UpdateMessageFlagsForNarrowResult(
+        processedCount: 11, updatedCount: 3,
+        firstProcessedId: null, lastProcessedId: null,
+        foundOldest: true, foundNewest: true).toJson());
+      markNarrowAsRead(context, narrow, false);
+      await tester.pump(Duration.zero);
+      await tester.pumpAndSettle();
+      check(store.unreads.oldUnreadsMissing).isFalse();
+    }, skip: true, // TODO move this functionality inside markNarrowAsRead
+    );
+
+    testWidgets('on invalid response', (WidgetTester tester) async {
+      final zulipLocalizations = GlobalLocalizations.zulipLocalizations;
+      final narrow = TopicNarrow.ofMessage(eg.streamMessage());
+      await prepare(tester);
+      connection.prepare(json: UpdateMessageFlagsForNarrowResult(
+        processedCount: 1000, updatedCount: 0,
+        firstProcessedId: null, lastProcessedId: null,
+        foundOldest: true, foundNewest: false).toJson());
+      markNarrowAsRead(context, narrow, false);
+      await tester.pump(Duration.zero);
+      final apiNarrow = narrow.apiEncode()..add(ApiNarrowIsUnread());
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages/flags/narrow')
+        ..bodyFields.deepEquals({
+            'anchor': 'oldest',
+            'include_anchor': 'false',
+            'num_before': '0',
+            'num_after': '1000',
+            'narrow': jsonEncode(apiNarrow),
+            'op': 'add',
+            'flag': 'read',
+          });
+
+      await tester.pumpAndSettle();
+      checkErrorDialog(tester,
+        expectedTitle: zulipLocalizations.errorMarkAsReadFailedTitle,
+        expectedMessage: zulipLocalizations.errorInvalidResponse);
+    });
+
+    testWidgets('CombinedFeedNarrow on legacy server', (WidgetTester tester) async {
+      const narrow = CombinedFeedNarrow();
+      await prepare(tester);
+      // Might as well test with oldUnreadsMissing: true.
+      store.unreads.oldUnreadsMissing = true;
+
+      connection.zulipFeatureLevel = 154;
+      connection.prepare(json: {});
+      markNarrowAsRead(context, narrow, true); // TODO move legacy-server check inside markNarrowAsRead
+      await tester.pump(Duration.zero);
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/mark_all_as_read')
+        ..bodyFields.deepEquals({});
+
+      // Check that [Unreads.handleAllMessagesReadSuccess] wasn't called;
+      // in the legacy protocol, that'd be redundant with the mark-read event.
+      check(store.unreads).oldUnreadsMissing.isTrue();
+    });
+
+    testWidgets('StreamNarrow on legacy server', (WidgetTester tester) async {
+      final stream = eg.stream();
+      final narrow = StreamNarrow(stream.streamId);
+      await prepare(tester);
+      connection.zulipFeatureLevel = 154;
+      connection.prepare(json: {});
+      markNarrowAsRead(context, narrow, true); // TODO move legacy-server check inside markNarrowAsRead
+      await tester.pump(Duration.zero);
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/mark_stream_as_read')
+        ..bodyFields.deepEquals({
+            'stream_id': stream.streamId.toString(),
+          });
+    });
+
+    testWidgets('TopicNarrow on legacy server', (WidgetTester tester) async {
+      final narrow = TopicNarrow.ofMessage(eg.streamMessage());
+      await prepare(tester);
+      connection.zulipFeatureLevel = 154;
+      connection.prepare(json: {});
+      markNarrowAsRead(context, narrow, true); // TODO move legacy-server check inside markNarrowAsRead
+      await tester.pump(Duration.zero);
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/mark_topic_as_read')
+        ..bodyFields.deepEquals({
+            'stream_id': narrow.streamId.toString(),
+            'topic_name': narrow.topic,
+          });
+    });
+
+    testWidgets('DmNarrow on legacy server', (WidgetTester tester) async {
+      final message = eg.dmMessage(from: eg.otherUser, to: [eg.selfUser]);
+      final narrow = DmNarrow.ofMessage(message, selfUserId: eg.selfUser.userId);
+      final unreadMsgs = eg.unreadMsgs(dms: [
+        UnreadDmSnapshot(otherUserId: eg.otherUser.userId,
+          unreadMessageIds: [message.id]),
+      ]);
+      await prepare(tester, unreadMsgs: unreadMsgs);
+      connection.zulipFeatureLevel = 154;
+      connection.prepare(json:
+        UpdateMessageFlagsResult(messages: [message.id]).toJson());
+      markNarrowAsRead(context, narrow, true); // TODO move legacy-server check inside markNarrowAsRead
+      await tester.pump(Duration.zero);
+      check(connection.lastRequest).isA<http.Request>()
+        ..method.equals('POST')
+        ..url.path.equals('/api/v1/messages/flags')
+        ..bodyFields.deepEquals({
+            'messages': jsonEncode([message.id]),
+            'op': 'add',
+            'flag': 'read',
+          });
+    });
+
+    testWidgets('catch-all api errors', (WidgetTester tester) async {
+      final zulipLocalizations = GlobalLocalizations.zulipLocalizations;
+      const narrow = CombinedFeedNarrow();
+      await prepare(tester);
+      connection.prepare(exception: http.ClientException('Oops'));
+      markNarrowAsRead(context, narrow, false);
+      await tester.pump(Duration.zero);
+      await tester.pumpAndSettle();
+      checkErrorDialog(tester,
+        expectedTitle: zulipLocalizations.errorMarkAsReadFailedTitle,
+        expectedMessage: 'NetworkException: Oops (ClientException: Oops)');
+    }, skip: true, // TODO move this functionality inside markNarrowAsRead
+    );
+  });
+}
diff --git a/test/widgets/message_list_test.dart b/test/widgets/message_list_test.dart
index 0e944d97a6..c804b02af1 100644
--- a/test/widgets/message_list_test.dart
+++ b/test/widgets/message_list_test.dart
@@ -30,7 +30,6 @@ import '../model/content_test.dart';
 import '../model/message_list_test.dart';
 import '../model/test_store.dart';
 import '../flutter_checks.dart';
-import '../model/unreads_checks.dart';
 import '../stdlib_checks.dart';
 import '../test_images.dart';
 import 'content_checks.dart';
@@ -882,6 +881,10 @@ void main() {
     });
 
     group('onPressed behavior', () {
+      // The markNarrowAsRead function has detailed unit tests of its own.
+      // These tests cover functionality that's outside that function,
+      // and a couple of smoke tests showing this button is wired up to it.
+
       final message = eg.streamMessage(flags: []);
       final unreadMsgs = eg.unreadMsgs(streams: [
         UnreadStreamSnapshot(streamId: message.streamId, topic: message.topic,
@@ -916,34 +919,7 @@ void main() {
         await tester.pumpAndSettle(); // process pending timers
       });
 
-      testWidgets('markNarrowAsRead uses is:unread optimization', (WidgetTester tester) async {
-        const narrow = CombinedFeedNarrow();
-        await setupMessageListPage(tester,
-          narrow: narrow, messages: [message], unreadMsgs: unreadMsgs);
-        check(isMarkAsReadButtonVisible(tester)).isTrue();
-
-        connection.prepare(json: UpdateMessageFlagsForNarrowResult(
-          processedCount: 11, updatedCount: 3,
-          firstProcessedId: null, lastProcessedId: null,
-          foundOldest: true, foundNewest: true).toJson());
-        await tester.tap(find.byType(MarkAsReadWidget));
-        check(connection.lastRequest).isA<http.Request>()
-          ..method.equals('POST')
-          ..url.path.equals('/api/v1/messages/flags/narrow')
-          ..bodyFields.deepEquals({
-              'anchor': 'oldest',
-              'include_anchor': 'false',
-              'num_before': '0',
-              'num_after': '1000',
-              'narrow': json.encode([{'operator': 'is', 'operand': 'unread'}]),
-              'op': 'add',
-              'flag': 'read',
-            });
-
-        await tester.pumpAndSettle(); // process pending timers
-      });
-
-      testWidgets('markNarrowAsRead pagination', (WidgetTester tester) async {
+      testWidgets('pagination', (WidgetTester tester) async {
         // Check that `lastProcessedId` returned from an initial
         // response is used as `anchorId` for the subsequent request.
         final narrow = TopicNarrow.ofMessage(message);
@@ -956,19 +932,10 @@ void main() {
           firstProcessedId: 1, lastProcessedId: 1989,
           foundOldest: true, foundNewest: false).toJson());
         await tester.tap(find.byType(MarkAsReadWidget));
-        final apiNarrow = narrow.apiEncode()..add(ApiNarrowIsUnread());
         check(connection.lastRequest).isA<http.Request>()
           ..method.equals('POST')
           ..url.path.equals('/api/v1/messages/flags/narrow')
-          ..bodyFields.deepEquals({
-              'anchor': 'oldest',
-              'include_anchor': 'false',
-              'num_before': '0',
-              'num_after': '1000',
-              'narrow': jsonEncode(apiNarrow),
-              'op': 'add',
-              'flag': 'read',
-            });
+          ..bodyFields['anchor'].equals('oldest');
 
         connection.prepare(json: UpdateMessageFlagsForNarrowResult(
           processedCount: 20, updatedCount: 10,
@@ -979,15 +946,7 @@ void main() {
         check(connection.lastRequest).isA<http.Request>()
           ..method.equals('POST')
           ..url.path.equals('/api/v1/messages/flags/narrow')
-          ..bodyFields.deepEquals({
-              'anchor': '1989',
-              'include_anchor': 'false',
-              'num_before': '0',
-              'num_after': '1000',
-              'narrow': jsonEncode(apiNarrow),
-              'op': 'add',
-              'flag': 'read',
-            });
+          ..bodyFields['anchor'].equals('1989');
       });
 
       testWidgets('markNarrowAsRead on mark-all-as-read when Unreads.oldUnreadsMissing: true', (tester) async {
@@ -1006,128 +965,6 @@ void main() {
         check(store.unreads.oldUnreadsMissing).isFalse();
       });
 
-      testWidgets('markNarrowAsRead on invalid response', (WidgetTester tester) async {
-        final zulipLocalizations = GlobalLocalizations.zulipLocalizations;
-        final narrow = TopicNarrow.ofMessage(message);
-        await setupMessageListPage(tester,
-          narrow: narrow, messages: [message], unreadMsgs: unreadMsgs);
-        check(isMarkAsReadButtonVisible(tester)).isTrue();
-
-        connection.prepare(json: UpdateMessageFlagsForNarrowResult(
-          processedCount: 1000, updatedCount: 0,
-          firstProcessedId: null, lastProcessedId: null,
-          foundOldest: true, foundNewest: false).toJson());
-        await tester.tap(find.byType(MarkAsReadWidget));
-        final apiNarrow = narrow.apiEncode()..add(ApiNarrowIsUnread());
-        check(connection.lastRequest).isA<http.Request>()
-          ..method.equals('POST')
-          ..url.path.equals('/api/v1/messages/flags/narrow')
-          ..bodyFields.deepEquals({
-              'anchor': 'oldest',
-              'include_anchor': 'false',
-              'num_before': '0',
-              'num_after': '1000',
-              'narrow': jsonEncode(apiNarrow),
-              'op': 'add',
-              'flag': 'read',
-            });
-
-        await tester.pumpAndSettle();
-        checkErrorDialog(tester,
-          expectedTitle: zulipLocalizations.errorMarkAsReadFailedTitle,
-          expectedMessage: zulipLocalizations.errorInvalidResponse);
-      });
-
-      testWidgets('CombinedFeedNarrow on legacy server', (WidgetTester tester) async {
-        const narrow = CombinedFeedNarrow();
-        await setupMessageListPage(tester,
-          narrow: narrow, messages: [message], unreadMsgs: unreadMsgs);
-        check(isMarkAsReadButtonVisible(tester)).isTrue();
-
-        // Might as well test with oldUnreadsMissing: true.
-        store.unreads.oldUnreadsMissing = true;
-
-        connection.zulipFeatureLevel = 154;
-        connection.prepare(json: {});
-        await tester.tap(find.byType(MarkAsReadWidget));
-        check(connection.lastRequest).isA<http.Request>()
-          ..method.equals('POST')
-          ..url.path.equals('/api/v1/mark_all_as_read')
-          ..bodyFields.deepEquals({});
-
-        await tester.pumpAndSettle(); // process pending timers
-
-        // Check that [Unreads.handleAllMessagesReadSuccess] wasn't called;
-        // in the legacy protocol, that'd be redundant with the mark-read event.
-        check(store.unreads).oldUnreadsMissing.isTrue();
-      });
-
-      testWidgets('StreamNarrow on legacy server', (WidgetTester tester) async {
-        final narrow = StreamNarrow(message.streamId);
-        await setupMessageListPage(tester,
-          narrow: narrow, messages: [message], unreadMsgs: unreadMsgs);
-        check(isMarkAsReadButtonVisible(tester)).isTrue();
-
-        connection.zulipFeatureLevel = 154;
-        connection.prepare(json: {});
-        await tester.tap(find.byType(MarkAsReadWidget));
-        check(connection.lastRequest).isA<http.Request>()
-          ..method.equals('POST')
-          ..url.path.equals('/api/v1/mark_stream_as_read')
-          ..bodyFields.deepEquals({
-              'stream_id': message.streamId.toString(),
-            });
-
-        await tester.pumpAndSettle(); // process pending timers
-      });
-
-      testWidgets('TopicNarrow on legacy server', (WidgetTester tester) async {
-        final narrow = TopicNarrow.ofMessage(message);
-        await setupMessageListPage(tester,
-          narrow: narrow, messages: [message], unreadMsgs: unreadMsgs);
-        check(isMarkAsReadButtonVisible(tester)).isTrue();
-
-        connection.zulipFeatureLevel = 154;
-        connection.prepare(json: {});
-        await tester.tap(find.byType(MarkAsReadWidget));
-        check(connection.lastRequest).isA<http.Request>()
-          ..method.equals('POST')
-          ..url.path.equals('/api/v1/mark_topic_as_read')
-          ..bodyFields.deepEquals({
-              'stream_id': narrow.streamId.toString(),
-              'topic_name': narrow.topic,
-            });
-
-        await tester.pumpAndSettle(); // process pending timers
-      });
-
-      testWidgets('DmNarrow on legacy server', (WidgetTester tester) async {
-        final message = eg.dmMessage(from: eg.otherUser, to: [eg.selfUser]);
-        final narrow = DmNarrow.ofMessage(message, selfUserId: eg.selfUser.userId);
-        final unreadMsgs = eg.unreadMsgs(dms: [
-          UnreadDmSnapshot(otherUserId: eg.otherUser.userId,
-            unreadMessageIds: [message.id]),
-        ]);
-        await setupMessageListPage(tester,
-          narrow: narrow, messages: [message], unreadMsgs: unreadMsgs);
-        check(isMarkAsReadButtonVisible(tester)).isTrue();
-
-        connection.zulipFeatureLevel = 154;
-        connection.prepare(json:
-          UpdateMessageFlagsResult(messages: [message.id]).toJson());
-        await tester.tap(find.byType(MarkAsReadWidget));
-        check(connection.lastRequest).isA<http.Request>()
-          ..method.equals('POST')
-          ..url.path.equals('/api/v1/messages/flags')
-          ..bodyFields.deepEquals({
-              'messages': jsonEncode([message.id]),
-              'op': 'add',
-              'flag': 'read',
-            });
-
-        await tester.pumpAndSettle(); // process pending timers
-      });
-
       testWidgets('catch-all api errors', (WidgetTester tester) async {
         final zulipLocalizations = GlobalLocalizations.zulipLocalizations;
         const narrow = CombinedFeedNarrow();
