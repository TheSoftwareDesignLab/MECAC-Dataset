diff --git a/lib/model/store.dart b/lib/model/store.dart
index f31591ec93..5d77f4ca9c 100644
--- a/lib/model/store.dart
+++ b/lib/model/store.dart
@@ -13,6 +13,50 @@ import '../api/route/messages.dart';
 import '../credential_fixture.dart' as credentials;
 import 'message_list.dart';
 
+/// Store for the user's cross-account data.
+///
+/// This includes data that is independent of the account, like some settings.
+/// It also includes a small amount of data for each account: enough to
+/// authenticate as the active account, if there is one.
+class GlobalStore extends ChangeNotifier {
+  GlobalStore._({required Map<int, Account> accounts})
+      : _accounts = accounts;
+
+  // For convenience, a number we won't use as an ID in the database table.
+  static const fixtureAccountId = -1;
+
+  // We keep the API simple and synchronous for the bulk of the app's code
+  // by doing this loading up front before constructing a [GlobalStore].
+  static Future<GlobalStore> load() async {
+    const accounts = {fixtureAccountId: _fixtureAccount};
+    return GlobalStore._(accounts: accounts);
+  }
+
+  final Map<int, Account> _accounts;
+
+  // TODO settings (those that are per-device rather than per-account)
+  // TODO push token, and other data corresponding to GlobalSessionState
+
+  // Just an Iterable, not the actual Map, to avoid clients mutating the map.
+  // Mutations should go through the setters/mutators below.
+  Iterable<Account> get accounts => _accounts.values;
+
+  Account? getAccount(int id) => _accounts[id];
+
+  // TODO add setters/mutators; will want to write to database
+  // Future<void> insertAccount...
+  // Future<void> updateAccount...
+
+  // TODO add a registry of [PerAccountStore]s, like the latter's of [MessageListView]
+  //   That will allow us to have many [PerAccountRoot] widgets for a given
+  //   account, e.g. at the top of each page; and to access server data from
+  //   outside any [PerAccountRoot], e.g. for handling a notification.
+}
+
+/// Store for the user's data for a given Zulip account.
+///
+/// This should always have a consistent snapshot of the state on the server,
+/// as maintained by the Zulip event system.
 class PerAccountStore extends ChangeNotifier {
   PerAccountStore._({
     required this.account,
@@ -23,9 +67,10 @@ class PerAccountStore extends ChangeNotifier {
     required this.subscriptions,
   });
 
-  // Load the user's data from storage.  (Once we have such a thing.)
-  static Future<PerAccountStore> load() async {
-    const account = _fixtureAccount;
+  /// Load the user's data from the server, and start an event queue going.
+  ///
+  /// In the future this might load an old snapshot from local storage first.
+  static Future<PerAccountStore> load(Account account) async {
     final connection = ApiConnection(auth: account);
 
     final stopwatch = Stopwatch()..start();
@@ -124,6 +169,7 @@ const Account _fixtureAccount = Account(
   apiKey: credentials.api_key,
 );
 
+@immutable
 class Account implements Auth {
   const Account(
       {required this.realmUrl, required this.email, required this.apiKey});
diff --git a/lib/widgets/app.dart b/lib/widgets/app.dart
index 0e1f6b9306..17336cffbe 100644
--- a/lib/widgets/app.dart
+++ b/lib/widgets/app.dart
@@ -1,5 +1,6 @@
 import 'package:flutter/material.dart';
 
+import '../model/store.dart';
 import 'compose_box.dart';
 import 'message_list.dart';
 import 'store.dart';
@@ -19,12 +20,14 @@ class ZulipApp extends StatelessWidget {
         // Or try this tool to see the whole palette:
         //   https://m3.material.io/theme-builder#/custom
         colorScheme: ColorScheme.fromSeed(seedColor: kZulipBrandColor));
-    // Just one account for now.
-    return PerAccountRoot(
-      child: MaterialApp(
-        title: 'Zulip',
-        theme: theme,
-        home: const HomePage()));
+    return DataRoot(
+      child: PerAccountRoot(
+        // Just one account for now.
+        accountId: GlobalStore.fixtureAccountId,
+        child: MaterialApp(
+          title: 'Zulip',
+          theme: theme,
+          home: const HomePage())));
   }
 }
 
diff --git a/lib/widgets/store.dart b/lib/widgets/store.dart
index 9b5c7765f0..86bb2452a9 100644
--- a/lib/widgets/store.dart
+++ b/lib/widgets/store.dart
@@ -2,9 +2,62 @@ import 'package:flutter/material.dart';
 
 import '../model/store.dart';
 
+class DataRoot extends StatefulWidget {
+  const DataRoot({super.key, required this.child});
+
+  final Widget child;
+
+  @override
+  State<DataRoot> createState() => _DataRootState();
+}
+
+class _DataRootState extends State<DataRoot> {
+  GlobalStore? store;
+
+  @override
+  void initState() {
+    super.initState();
+    (() async {
+      final store = await GlobalStore.load();
+      setState(() {
+        this.store = store;
+      });
+    })();
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final store = this.store;
+    // TODO: factor out the use of LoadingPage to be configured by the widget, like [widget.child] is
+    if (store == null) return const LoadingPage();
+    return GlobalStoreWidget(store: store, child: widget.child);
+  }
+}
+
+class GlobalStoreWidget extends InheritedNotifier<GlobalStore> {
+  const GlobalStoreWidget(
+      {super.key, required GlobalStore store, required super.child})
+      : super(notifier: store);
+
+  GlobalStore get store => notifier!;
+
+  static GlobalStore of(BuildContext context) {
+    final widget =
+        context.dependOnInheritedWidgetOfExactType<GlobalStoreWidget>();
+    assert(widget != null, 'No GlobalStoreWidget ancestor');
+    return widget!.store;
+  }
+
+  @override
+  bool updateShouldNotify(covariant GlobalStoreWidget oldWidget) =>
+      store != oldWidget.store;
+}
+
 class PerAccountRoot extends StatefulWidget {
-  const PerAccountRoot({super.key, required this.child});
+  const PerAccountRoot(
+      {super.key, required this.accountId, required this.child});
 
+  final int accountId;
   final Widget child;
 
   @override
@@ -15,10 +68,22 @@ class _PerAccountRootState extends State<PerAccountRoot> {
   PerAccountStore? store;
 
   @override
-  void initState() {
-    super.initState();
+  void didChangeDependencies() {
+    super.didChangeDependencies();
+    final globalStore = GlobalStoreWidget.of(context);
+    final account = globalStore.getAccount(widget.accountId);
+    assert(account != null, 'Account not found on global store');
+    if (store != null) {
+      // The data we use to auth to the server should be unchanged;
+      // changing those should mean a new account ID in our database.
+      assert(account!.realmUrl == store!.account.realmUrl);
+      assert(account!.email == store!.account.email);
+      assert(account!.apiKey == store!.account.apiKey);
+      // TODO if Account has anything else change, update the PerAccountStore for that
+      return;
+    }
     (() async {
-      final store = await PerAccountStore.load();
+      final store = await PerAccountStore.load(account!);
       setState(() {
         this.store = store;
       });
