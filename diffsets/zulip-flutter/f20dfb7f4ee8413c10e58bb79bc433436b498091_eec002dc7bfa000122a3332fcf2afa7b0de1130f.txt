diff --git a/lib/widgets/scrolling.dart b/lib/widgets/scrolling.dart
index 388cb4671f..d5a1447763 100644
--- a/lib/widgets/scrolling.dart
+++ b/lib/widgets/scrolling.dart
@@ -2,6 +2,7 @@ import 'dart:math' as math;
 
 import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
+import 'package:flutter/physics.dart';
 import 'package:flutter/rendering.dart';
 
 /// A [SingleChildScrollView] that always shows a Material [Scrollbar].
@@ -320,6 +321,9 @@ class MessageListScrollPosition extends ScrollPositionWithSingleContext {
     return applyContentDimensions(effectiveMin, effectiveMax);
   }
 
+  bool _nearEqual(double a, double b) =>
+    nearEqual(a, b, Tolerance.defaultTolerance.distance);
+
   bool _hasEverCompletedLayout = false;
 
   @override
@@ -337,6 +341,13 @@ class MessageListScrollPosition extends ScrollPositionWithSingleContext {
         correctPixels(target);
         changed = true;
       }
+    } else if (_nearEqual(pixels, this.maxScrollExtent)
+        && !_nearEqual(pixels, maxScrollExtent)) {
+      // The list was scrolled to the end before this layout round.
+      // Make sure it stays at the end.
+      // (For example, show the new message that just arrived.)
+      correctPixels(maxScrollExtent);
+      changed = true;
     }
 
     // This step must come after the first-time correction above.
@@ -345,6 +356,11 @@ class MessageListScrollPosition extends ScrollPositionWithSingleContext {
     // then the base implementation of [applyContentDimensions] would
     // bring it in bounds via a scrolling animation, which isn't right when
     // starting from the meaningless initial 0.0 value.
+    //
+    // For the "stays at the end" correction, it's not clear if the order
+    // matters in practice.  But the doc on [applyNewDimensions], called by
+    // the base [applyContentDimensions], says it should come after any
+    // calls to [correctPixels]; so OK, do this after the [correctPixels].
     if (!super.applyContentDimensions(minScrollExtent, maxScrollExtent)) {
       changed = true;
     }
diff --git a/test/widgets/scrolling_test.dart b/test/widgets/scrolling_test.dart
index 74a07b3ce4..9454ef4fe3 100644
--- a/test/widgets/scrolling_test.dart
+++ b/test/widgets/scrolling_test.dart
@@ -243,6 +243,35 @@ void main() {
         .bottom.equals(600);
     });
 
+    testWidgets('stick to end of list when it grows', (tester) async {
+      final controller = MessageListScrollController();
+      await prepare(tester, controller: controller,
+        topHeight: 400, bottomHeight: 400);
+      check(tester.getRect(findBottom))..top.equals(200)..bottom.equals(600);
+
+      // Bottom sliver grows; remain scrolled to (new) bottom.
+      await prepare(tester, controller: controller,
+        topHeight: 400, bottomHeight: 500);
+      check(tester.getRect(findBottom))..top.equals(100)..bottom.equals(600);
+    });
+
+    testWidgets('when not at end, let it grow without following', (tester) async {
+      final controller = MessageListScrollController();
+      await prepare(tester, controller: controller,
+        topHeight: 400, bottomHeight: 400);
+      check(tester.getRect(findBottom))..top.equals(200)..bottom.equals(600);
+
+      // Scroll up (by dragging down) to detach from end of list.
+      await tester.drag(findBottom, Offset(0, 100));
+      await tester.pump();
+      check(tester.getRect(findBottom))..top.equals(300)..bottom.equals(700);
+
+      // Bottom sliver grows; remain at existing position, now farther from end.
+      await prepare(tester, controller: controller,
+        topHeight: 400, bottomHeight: 500);
+      check(tester.getRect(findBottom))..top.equals(300)..bottom.equals(800);
+    });
+
     testWidgets('position preserved when scrollable rebuilds', (tester) async {
       // Tests that [MessageListScrollPosition.absorb] does its job.
       //
