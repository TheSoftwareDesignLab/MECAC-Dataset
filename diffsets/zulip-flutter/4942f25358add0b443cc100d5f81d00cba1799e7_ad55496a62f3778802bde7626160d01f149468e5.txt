diff --git a/lib/widgets/autocomplete.dart b/lib/widgets/autocomplete.dart
index a1e5289b01..e6a64bc909 100644
--- a/lib/widgets/autocomplete.dart
+++ b/lib/widgets/autocomplete.dart
@@ -321,13 +321,8 @@ class TopicAutocomplete extends AutocompleteField<TopicAutocompleteQuery, TopicA
   void _onTapOption(BuildContext context, TopicAutocompleteResult option) {
     final intent = autocompleteIntent();
     if (intent == null) return;
-    final replacementString = option.topic;
-    controller.value = intent.textEditingValue.replaced(
-      TextRange(
-        start: intent.syntaxStart,
-        end: intent.textEditingValue.text.length),
-      replacementString,
-    );
+    assert(intent.syntaxStart == 0);
+    controller.value = TextEditingValue(text: option.topic);
     contentFocusNode.requestFocus();
   }
 
diff --git a/test/flutter_checks.dart b/test/flutter_checks.dart
index 4e4ae7d986..505f5189f2 100644
--- a/test/flutter_checks.dart
+++ b/test/flutter_checks.dart
@@ -66,6 +66,12 @@ extension TextChecks on Subject<Text> {
   Subject<TextStyle?> get style => has((t) => t.style, 'style');
 }
 
+extension TextEditingValueChecks on Subject<TextEditingValue> {
+  Subject<String> get text => has((x) => x.text, 'text');
+  Subject<TextSelection> get selection => has((x) => x.selection, 'selection');
+  Subject<TextRange> get composing => has((x) => x.composing, 'composing');
+}
+
 extension TextEditingControllerChecks on Subject<TextEditingController> {
   Subject<String?> get text => has((t) => t.text, 'text');
 }
diff --git a/test/widgets/autocomplete_test.dart b/test/widgets/autocomplete_test.dart
index 8c6514f5ee..cd22d452f4 100644
--- a/test/widgets/autocomplete_test.dart
+++ b/test/widgets/autocomplete_test.dart
@@ -17,6 +17,7 @@ import 'package:zulip/widgets/message_list.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
+import '../flutter_checks.dart';
 import '../model/binding.dart';
 import '../model/test_store.dart';
 import '../test_images.dart';
@@ -312,5 +313,36 @@ void main() {
       await tester.pumpAndSettle();
       checkTopicShown(topic2, store, expected: true);
     });
+
+    testWidgets('text selection is reset on choosing an option', (tester) async {
+      // TODO test also that composing region gets reset.
+      //   (Just adding it to the updateEditingValue call below doesn't seem
+      //   to suffice to set it up; the controller value after the pump still
+      //   has empty composing region, so there's nothing to check after tap.)
+
+      final topic = eg.getStreamTopicsEntry(name: 'some topic');
+      final topicInputFinder = await setupToTopicInput(tester, topics: [topic]);
+      final controller = tester.widget<TextField>(topicInputFinder).controller!;
+
+      await tester.enterText(topicInputFinder, 'so');
+      await tester.enterText(topicInputFinder, 'some');
+      tester.testTextInput.updateEditingValue(const TextEditingValue(
+        text: 'some',
+        selection: TextSelection(baseOffset: 1, extentOffset: 3)));
+      await tester.pump();
+      check(controller.value)
+        ..text.equals('some')
+        ..selection.equals(
+            const TextSelection(baseOffset: 1, extentOffset: 3));
+
+      await tester.tap(find.text('some topic'));
+      await tester.pump();
+      check(controller.value)
+        ..text.equals('some topic')
+        ..selection.equals(
+            const TextSelection.collapsed(offset: 'some topic'.length));
+
+      await tester.pump(Duration.zero);
+    });
   });
 }
