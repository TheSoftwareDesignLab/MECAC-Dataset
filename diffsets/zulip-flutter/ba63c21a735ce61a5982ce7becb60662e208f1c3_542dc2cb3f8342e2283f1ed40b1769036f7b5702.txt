diff --git a/lib/widgets/scrolling.dart b/lib/widgets/scrolling.dart
index 1867a3eb65..80bb2c5078 100644
--- a/lib/widgets/scrolling.dart
+++ b/lib/widgets/scrolling.dart
@@ -187,6 +187,14 @@ class MessageListScrollPosition extends ScrollPositionWithSingleContext {
       return;
     }
 
+    if (pixels > maxScrollExtent) {
+      // The position is already scrolled past the end.  Let overscroll handle it.
+      // (This situation shouldn't even arise; the UI only offers this option
+      // when `pixels < maxScrollExtent`.)
+      goBallistic(0.0);
+      return;
+    }
+
     /// The top speed to move at, in logical pixels per second.
     ///
     /// This will be the speed whenever the distance to be traveled
diff --git a/test/flutter_checks.dart b/test/flutter_checks.dart
index f2b20fc41f..328bfdd843 100644
--- a/test/flutter_checks.dart
+++ b/test/flutter_checks.dart
@@ -142,6 +142,10 @@ extension TextEditingControllerChecks on Subject<TextEditingController> {
   Subject<String?> get text => has((t) => t.text, 'text');
 }
 
+extension ScrollActivityChecks on Subject<ScrollActivity> {
+  Subject<double> get velocity => has((x) => x.velocity, 'velocity');
+}
+
 extension IconChecks on Subject<Icon> {
   Subject<IconData?> get icon => has((i) => i.icon, 'icon');
   Subject<Color?> get color => has((i) => i.color, 'color');
diff --git a/test/widgets/scrolling_test.dart b/test/widgets/scrolling_test.dart
index b07ba5299d..4601b96349 100644
--- a/test/widgets/scrolling_test.dart
+++ b/test/widgets/scrolling_test.dart
@@ -1,4 +1,5 @@
 import 'package:checks/checks.dart';
+import 'package:flutter/foundation.dart';
 import 'package:flutter/widgets.dart';
 import 'package:flutter_test/flutter_test.dart';
 import 'package:zulip/widgets/scrolling.dart';
@@ -255,6 +256,46 @@ void main() {
         // … without moving any farther.
         check(position.extentAfter).equals(0);
       });
+
+      testWidgets('starting from overscroll, just drift', (tester) async {
+        debugDefaultTargetPlatformOverride = TargetPlatform.iOS;
+        await prepare(tester, topHeight: 400, bottomHeight: 400);
+
+        // Drag into overscroll.
+        await tester.drag(findBottom, Offset(0, -100));
+        await tester.pump();
+        final offset1 = position.pixels - position.maxScrollExtent;
+        check(offset1).isGreaterThan(100 / 2);
+        check(position.activity).isA<BallisticScrollActivity>();
+
+        // Start drifting back into range.
+        await tester.pump(Duration(milliseconds: 10));
+        final offset2 = position.pixels - position.maxScrollExtent;
+        check(offset2)..isGreaterThan(0.0)..isLessThan(offset1);
+        check(position.activity).isA<BallisticScrollActivity>()
+          .velocity.isLessThan(0);
+
+        // Invoke `scrollToEnd`.  The motion should stop…
+        position.scrollToEnd();
+        await tester.pump();
+        check(position.pixels - position.maxScrollExtent).equals(offset2);
+        check(position.activity).isA<BallisticScrollActivity>()
+          .velocity.equals(0);
+
+        // … and resume drifting from there…
+        await tester.pump(Duration(milliseconds: 10));
+        final offset3 = position.pixels - position.maxScrollExtent;
+        check(offset3)..isGreaterThan(0.0)..isLessThan(offset2);
+        check(position.activity).isA<BallisticScrollActivity>()
+          .velocity.isLessThan(0);
+
+        // … to eventually return to being in range.
+        await tester.pump(Duration(seconds: 1));
+        check(position.pixels - position.maxScrollExtent).equals(0);
+        check(position.activity).isA<IdleScrollActivity>();
+
+        debugDefaultTargetPlatformOverride = null;
+      });
     });
   });
 }
