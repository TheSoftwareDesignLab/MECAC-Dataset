diff --git a/assets/l10n/app_en.arb b/assets/l10n/app_en.arb
index 653f956596..c24f23dce9 100644
--- a/assets/l10n/app_en.arb
+++ b/assets/l10n/app_en.arb
@@ -773,6 +773,18 @@
   "@yesterday": {
     "description": "Term to use to reference the previous day."
   },
+  "invisibleMode": "Invisible mode",
+  "@invisibleMode": {
+    "description": "Label for the 'Invisible mode' switch on the profile page."
+  },
+  "turnOnInvisibleModeErrorTitle": "Error turning on invisible mode. Please try again.",
+  "@turnOnInvisibleModeErrorTitle": {
+    "description": "Error title when turning on invisible mode failed."
+  },
+  "turnOffInvisibleModeErrorTitle": "Error turning off invisible mode. Please try again.",
+  "@turnOffInvisibleModeErrorTitle": {
+    "description": "Error title when turning off invisible mode failed."
+  },
   "userRoleOwner": "Owner",
   "@userRoleOwner": {
     "description": "Label for UserRole.owner"
diff --git a/lib/basic.dart b/lib/basic.dart
index e1716cb972..28d27df999 100644
--- a/lib/basic.dart
+++ b/lib/basic.dart
@@ -19,6 +19,12 @@ sealed class Option<T> {
 
   /// The value contained in this option, if any; else the given value.
   T or(T optb);
+
+  /// The value contained in this option, if any;
+  /// else the value returned by [fn].
+  ///
+  /// [fn] is called only if its return value is needed.
+  T orElse(T Function() fn);
 }
 
 class OptionNone<T> extends Option<T> {
@@ -27,6 +33,9 @@ class OptionNone<T> extends Option<T> {
   @override
   T or(T optb) => optb;
 
+  @override
+  T orElse(T Function() fn) => fn();
+
   @override
   bool operator ==(Object other) => other is OptionNone;
 
@@ -45,6 +54,9 @@ class OptionSome<T> extends Option<T> {
   @override
   T or(T optb) => value;
 
+  @override
+  T orElse(T Function() fn) => value;
+
   @override
   bool operator ==(Object other) => other is OptionSome && value == other.value;
 
diff --git a/lib/generated/l10n/zulip_localizations.dart b/lib/generated/l10n/zulip_localizations.dart
index db7bd64173..99b52aced1 100644
--- a/lib/generated/l10n/zulip_localizations.dart
+++ b/lib/generated/l10n/zulip_localizations.dart
@@ -1173,6 +1173,24 @@ abstract class ZulipLocalizations {
   /// **'Yesterday'**
   String get yesterday;
 
+  /// Label for the 'Invisible mode' switch on the profile page.
+  ///
+  /// In en, this message translates to:
+  /// **'Invisible mode'**
+  String get invisibleMode;
+
+  /// Error title when turning on invisible mode failed.
+  ///
+  /// In en, this message translates to:
+  /// **'Error turning on invisible mode. Please try again.'**
+  String get turnOnInvisibleModeErrorTitle;
+
+  /// Error title when turning off invisible mode failed.
+  ///
+  /// In en, this message translates to:
+  /// **'Error turning off invisible mode. Please try again.'**
+  String get turnOffInvisibleModeErrorTitle;
+
   /// Label for UserRole.owner
   ///
   /// In en, this message translates to:
diff --git a/lib/generated/l10n/zulip_localizations_ar.dart b/lib/generated/l10n/zulip_localizations_ar.dart
index e1b7e2cf52..110b0dbe24 100644
--- a/lib/generated/l10n/zulip_localizations_ar.dart
+++ b/lib/generated/l10n/zulip_localizations_ar.dart
@@ -635,6 +635,17 @@ class ZulipLocalizationsAr extends ZulipLocalizations {
   @override
   String get yesterday => 'Yesterday';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Owner';
 
diff --git a/lib/generated/l10n/zulip_localizations_de.dart b/lib/generated/l10n/zulip_localizations_de.dart
index de313355d4..f3b1bdad67 100644
--- a/lib/generated/l10n/zulip_localizations_de.dart
+++ b/lib/generated/l10n/zulip_localizations_de.dart
@@ -656,6 +656,17 @@ class ZulipLocalizationsDe extends ZulipLocalizations {
   @override
   String get yesterday => 'Gestern';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Besitzer';
 
diff --git a/lib/generated/l10n/zulip_localizations_en.dart b/lib/generated/l10n/zulip_localizations_en.dart
index 4a0d148c2b..f99c386087 100644
--- a/lib/generated/l10n/zulip_localizations_en.dart
+++ b/lib/generated/l10n/zulip_localizations_en.dart
@@ -635,6 +635,17 @@ class ZulipLocalizationsEn extends ZulipLocalizations {
   @override
   String get yesterday => 'Yesterday';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Owner';
 
diff --git a/lib/generated/l10n/zulip_localizations_it.dart b/lib/generated/l10n/zulip_localizations_it.dart
index 5bb56b6f41..2d7d35e23e 100644
--- a/lib/generated/l10n/zulip_localizations_it.dart
+++ b/lib/generated/l10n/zulip_localizations_it.dart
@@ -650,6 +650,17 @@ class ZulipLocalizationsIt extends ZulipLocalizations {
   @override
   String get yesterday => 'Ieri';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Proprietario';
 
diff --git a/lib/generated/l10n/zulip_localizations_ja.dart b/lib/generated/l10n/zulip_localizations_ja.dart
index 4c49121785..ff27eaee8b 100644
--- a/lib/generated/l10n/zulip_localizations_ja.dart
+++ b/lib/generated/l10n/zulip_localizations_ja.dart
@@ -635,6 +635,17 @@ class ZulipLocalizationsJa extends ZulipLocalizations {
   @override
   String get yesterday => 'Yesterday';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'オーナー';
 
diff --git a/lib/generated/l10n/zulip_localizations_nb.dart b/lib/generated/l10n/zulip_localizations_nb.dart
index c0353e1789..0568bc0ae7 100644
--- a/lib/generated/l10n/zulip_localizations_nb.dart
+++ b/lib/generated/l10n/zulip_localizations_nb.dart
@@ -635,6 +635,17 @@ class ZulipLocalizationsNb extends ZulipLocalizations {
   @override
   String get yesterday => 'Yesterday';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Owner';
 
diff --git a/lib/generated/l10n/zulip_localizations_pl.dart b/lib/generated/l10n/zulip_localizations_pl.dart
index 92407f9783..45bcc962d3 100644
--- a/lib/generated/l10n/zulip_localizations_pl.dart
+++ b/lib/generated/l10n/zulip_localizations_pl.dart
@@ -646,6 +646,17 @@ class ZulipLocalizationsPl extends ZulipLocalizations {
   @override
   String get yesterday => 'Wczoraj';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Właściciel';
 
diff --git a/lib/generated/l10n/zulip_localizations_ru.dart b/lib/generated/l10n/zulip_localizations_ru.dart
index 8d174186d1..3a8a567b5d 100644
--- a/lib/generated/l10n/zulip_localizations_ru.dart
+++ b/lib/generated/l10n/zulip_localizations_ru.dart
@@ -649,6 +649,17 @@ class ZulipLocalizationsRu extends ZulipLocalizations {
   @override
   String get yesterday => 'Вчера';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Владелец';
 
diff --git a/lib/generated/l10n/zulip_localizations_sk.dart b/lib/generated/l10n/zulip_localizations_sk.dart
index b73d4bee18..33b4465eb6 100644
--- a/lib/generated/l10n/zulip_localizations_sk.dart
+++ b/lib/generated/l10n/zulip_localizations_sk.dart
@@ -637,6 +637,17 @@ class ZulipLocalizationsSk extends ZulipLocalizations {
   @override
   String get yesterday => 'Včera';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Majiteľ';
 
diff --git a/lib/generated/l10n/zulip_localizations_sl.dart b/lib/generated/l10n/zulip_localizations_sl.dart
index 39de9af735..8d587b9085 100644
--- a/lib/generated/l10n/zulip_localizations_sl.dart
+++ b/lib/generated/l10n/zulip_localizations_sl.dart
@@ -661,6 +661,17 @@ class ZulipLocalizationsSl extends ZulipLocalizations {
   @override
   String get yesterday => 'Včeraj';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Lastnik';
 
diff --git a/lib/generated/l10n/zulip_localizations_uk.dart b/lib/generated/l10n/zulip_localizations_uk.dart
index 74edee1d1e..6799942531 100644
--- a/lib/generated/l10n/zulip_localizations_uk.dart
+++ b/lib/generated/l10n/zulip_localizations_uk.dart
@@ -649,6 +649,17 @@ class ZulipLocalizationsUk extends ZulipLocalizations {
   @override
   String get yesterday => 'Учора';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Власник';
 
diff --git a/lib/generated/l10n/zulip_localizations_zh.dart b/lib/generated/l10n/zulip_localizations_zh.dart
index d6b673fae4..b7eaba478f 100644
--- a/lib/generated/l10n/zulip_localizations_zh.dart
+++ b/lib/generated/l10n/zulip_localizations_zh.dart
@@ -635,6 +635,17 @@ class ZulipLocalizationsZh extends ZulipLocalizations {
   @override
   String get yesterday => 'Yesterday';
 
+  @override
+  String get invisibleMode => 'Invisible mode';
+
+  @override
+  String get turnOnInvisibleModeErrorTitle =>
+      'Error turning on invisible mode. Please try again.';
+
+  @override
+  String get turnOffInvisibleModeErrorTitle =>
+      'Error turning off invisible mode. Please try again.';
+
   @override
   String get userRoleOwner => 'Owner';
 
diff --git a/lib/widgets/profile.dart b/lib/widgets/profile.dart
index 27c8486fe8..405d82f38a 100644
--- a/lib/widgets/profile.dart
+++ b/lib/widgets/profile.dart
@@ -3,13 +3,17 @@ import 'dart:convert';
 import 'package:flutter/material.dart';
 
 import '../api/model/model.dart';
+import '../api/route/settings.dart';
 import '../generated/l10n/zulip_localizations.dart';
+import '../log.dart';
 import '../model/content.dart';
 import '../model/narrow.dart';
 import 'app_bar.dart';
+import 'button.dart';
 import 'content.dart';
 import 'message_list.dart';
 import 'page.dart';
+import 'remote_settings.dart';
 import 'store.dart';
 import 'text.dart';
 
@@ -83,6 +87,12 @@ class ProfilePage extends StatelessWidget {
       // TODO(#196) render active status
       // TODO(#292) render user local time
 
+      if (!store.realmPresenceDisabled && userId == store.selfUserId) ...[
+        const SizedBox(height: 16),
+        _InvisibleModeToggle(),
+        const SizedBox(height: 16),
+      ],
+
       _ProfileDataTable(profileData: user.profileData),
       const SizedBox(height: 16),
       FilledButton.icon(
@@ -109,6 +119,34 @@ class ProfilePage extends StatelessWidget {
   }
 }
 
+class _InvisibleModeToggle extends StatelessWidget {
+  const _InvisibleModeToggle();
+
+  @override
+  Widget build(BuildContext context) {
+    final zulipLocalizations = ZulipLocalizations.of(context);
+    final store = PerAccountStoreWidget.of(context);
+
+    return MenuButtonsShape(buttons: [
+      // `value: true` means invisible mode is on,
+      // i.e., that presenceEnabled is false.
+      RemoteSettingBuilder<bool>(
+        findValueInStore: (store) => !store.userSettings.presenceEnabled,
+        sendValueToServer: (value) => updateSettings(store.connection,
+          newSettings: {UserSettingName.presenceEnabled: !value}),
+        // TODO(#741) interpret API errors for user
+        onError: (e, requestedValue) => reportErrorToUserBriefly(
+          requestedValue
+            ? zulipLocalizations.turnOnInvisibleModeErrorTitle
+            : zulipLocalizations.turnOffInvisibleModeErrorTitle),
+        builder: (value, handleRequestNewValue) => MenuButton(
+          label: zulipLocalizations.invisibleMode,
+          onPressed: () => handleRequestNewValue(!value),
+          toggle: Toggle(value: value, onChanged: handleRequestNewValue))),
+    ]);
+  }
+}
+
 class _ProfileErrorPage extends StatelessWidget {
   const _ProfileErrorPage();
 
diff --git a/lib/widgets/remote_settings.dart b/lib/widgets/remote_settings.dart
new file mode 100644
index 0000000000..f2dfdb3ebe
--- /dev/null
+++ b/lib/widgets/remote_settings.dart
@@ -0,0 +1,207 @@
+import 'dart:async';
+
+import 'package:flutter/material.dart';
+
+import '../basic.dart';
+import '../model/store.dart';
+import 'store.dart';
+
+/// A builder function for [RemoteSettingBuilder.builder]
+/// that creates a toggle, or radio buttons, etc.
+///
+/// [value] is the value, whether from [RemoteSettingBuilder.findValueInStore]
+/// or from local echo.
+///
+/// [handleRequestNewValue] calls [RemoteSettingBuilder.sendValueToServer]
+/// and starts or extends a local-echo period.
+/// If extending a local-echo period, it replaces the old local-echo value.
+///
+/// [handleRequestNewValue] may be called any time.
+/// API requests are not debounced,
+/// and the server may handle them out of order.
+/// But the local echo minimizes flickering (see [localEchoMinimum])
+/// while ensuring that the real in-store value is shown soon after the
+/// user finishes interacting, whether the request(s) succeeded or failed.
+typedef RemoteSettingBuilderFn<T> =
+  Widget Function(T value, void Function(T) handleRequestNewValue);
+
+/// A stateful builder widget for toggles/etc.
+/// that control per-account settings on the server,
+/// with time-bounded local echo.
+///
+/// Specify the setting with [findValueInStore] and [sendValueToServer].
+///
+/// [builder] should use its value and change-handler params
+/// instead of calling the store and API directly.
+///
+/// When called, [builder]'s [RemoteSettingBuilderFn.handleRequestNewValue]
+/// starts or extends a local-echo period.
+/// During local echo, [builder] is passed the new value
+/// instead of the value in the store.
+/// Local echo will continue for at least [localEchoMinimum]
+/// after the current call. After that, it may end
+/// - because the [findValueInStore] value changed after this call
+///   (i.e. the event arrived), or
+/// - because [sendValueToServer] failed, or
+/// - because [localEchoIdleTimeout] elapsed and there wasn't another call.
+class RemoteSettingBuilder<T> extends StatefulWidget {
+  const RemoteSettingBuilder({
+    super.key,
+    required this.findValueInStore,
+    required this.sendValueToServer,
+    this.onError,
+    required this.builder,
+  });
+
+  final T Function(PerAccountStore) findValueInStore;
+  final Future<void> Function(T) sendValueToServer;
+  final void Function(Object? e, T requestedValue)? onError;
+  final RemoteSettingBuilderFn<T> builder;
+
+  /// The minimum time to spend in local echo,
+  /// chosen to minimize flickers that are not caused by user input.
+  ///
+  /// The common case is when the API request fails quickly.
+  ///
+  /// (Another case is when spam-tapping a toggle switch,
+  /// if a user wants to do that.
+  /// The timer resets on [RemoteSettingBuilderFn.handleRequestNewValue],
+  /// so until the spam-taps are finished, the switch responds only to the taps,
+  /// not to the event stream.
+  /// Then when the taps stop, it settles to the value from the latest event.)
+  static final Duration localEchoMinimum = Duration(seconds: 1);
+
+  static final Duration localEchoIdleTimeout = Duration(seconds: 3);
+
+  @override
+  State<RemoteSettingBuilder<T>> createState() => _RemoteSettingBuilderState();
+}
+
+class _RemoteSettingBuilderState<T> extends State<RemoteSettingBuilder<T>> with PerAccountStoreAwareStateMixin<RemoteSettingBuilder<T>> {
+  final _LocalEchoNotifier<T> _notifier = _LocalEchoNotifier();
+
+  @override
+  void initState() {
+    super.initState();
+    _notifier.addListener(_notifierChanged);
+  }
+
+  late T? _prevValueFromStore;
+
+  @override
+  void onNewStore() {
+    _prevValueFromStore = widget.findValueInStore(PerAccountStoreWidget.of(context));
+    _notifier.stop();
+  }
+
+  @override
+  void didChangeDependencies() {
+    // On the first call, this sets _prevValueFromStore, via onNewStore.
+    super.didChangeDependencies();
+
+    final value = widget.findValueInStore(PerAccountStoreWidget.of(context));
+    if (value != _prevValueFromStore) {
+      _notifier.stop();
+      _prevValueFromStore = value;
+    }
+  }
+
+  bool _disposed = false;
+
+  @override
+  void dispose() {
+    _notifier.dispose();
+    _disposed = true;
+    super.dispose();
+  }
+
+  void _notifierChanged() {
+    setState(() {
+      // The actual state lives in _notifier.
+    });
+  }
+
+  void _handleRequestNewValue(T value) async {
+    _notifier.startOrExtend(value);
+
+    try {
+      await widget.sendValueToServer(value);
+      if (_disposed) return;
+      // Don't call _notifier.stop(). We do that when the event arrives,
+      // causing the in-store value to change (see didChangeDependencies).
+    } catch (e) { // TODO(log)
+      if (_disposed) return;
+      await _notifier.stop();
+      if (_disposed) return;
+      if (widget.onError != null) {
+        widget.onError!(e, value);
+      }
+    }
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final store = PerAccountStoreWidget.of(context);
+
+    final value = _notifier.value.orElse(() => widget.findValueInStore(store));
+    return widget.builder(value, _handleRequestNewValue);
+  }
+}
+
+/// A [ValueNotifier] for whether local echo is active, and with what value.
+///
+/// The [ValueNotifier.value] is an [Option].
+/// When it is [OptionSome], local echo is active with [OptionSome.value].
+/// When it is [OptionNone], local echo is not active.
+///
+/// Use [startOrExtend] and [stop] to control local echo.
+class _LocalEchoNotifier<T> extends ValueNotifier<Option<T>> {
+  _LocalEchoNotifier() : super(OptionNone());
+
+  Timer? _lowerBoundTimer;
+  Completer<void>? _lowerBoundCompleter;
+  Timer? _upperBoundTimer;
+
+  /// Start a local-echo session or extend the timers of an existing session.
+  void startOrExtend(T newValue) {
+    value = OptionSome(newValue);
+
+    _lowerBoundCompleter ??= Completer();
+    _lowerBoundTimer?.cancel();
+    _lowerBoundTimer = Timer(RemoteSettingBuilder.localEchoMinimum, () {
+      _lowerBoundCompleter!.complete();
+      _lowerBoundCompleter = null;
+    });
+
+    _upperBoundTimer?.cancel();
+    _upperBoundTimer = Timer(RemoteSettingBuilder.localEchoIdleTimeout, () {
+      value = OptionNone();
+    });
+  }
+
+  /// Request that a local-echo session, if any, be stopped as soon as possible.
+  ///
+  /// The session will be stopped either immediately or
+  /// [RemoteSettingBuilder.localEchoMinimum] after the last [startOrExtend] call,
+  /// whichever is later.
+  ///
+  /// The returned [Future] resolves when the session is stopped.
+  Future<void> stop() async {
+    if (_lowerBoundCompleter != null) {
+      await _lowerBoundCompleter!.future;
+      if (_disposed) return;
+    }
+    value = OptionNone();
+  }
+
+  bool _disposed = false;
+
+  @override
+  void dispose() {
+    _lowerBoundCompleter?.complete();
+    _lowerBoundTimer?.cancel();
+    _upperBoundTimer?.cancel();
+    _disposed = true;
+    super.dispose();
+  }
+}
diff --git a/test/basic_test.dart b/test/basic_test.dart
index 77070ffafa..7389ccca75 100644
--- a/test/basic_test.dart
+++ b/test/basic_test.dart
@@ -32,5 +32,17 @@ void main() {
       check(OptionSome<int?>(null).or(4)).equals(null);
       check(OptionNone<int?>().or(4)).equals(4);
     });
+
+    test('orElse', () {
+      check(OptionSome<int>(3).orElse(() => 4)).equals(3);
+      check(OptionSome<int?>(3).orElse(() => 4)).equals(3);
+      check(OptionSome<int?>(null).orElse(() => 4)).equals(null);
+      check(OptionNone<int?>().orElse(() => 4)).equals(4);
+
+      final myError = Error();
+      check(OptionSome<int>(3).orElse(() => throw myError)).equals(3);
+      check(() => OptionNone<int>().orElse(() => throw myError))
+        .throws<Error>().identicalTo(myError);
+    });
   });
 }
diff --git a/test/widgets/profile_test.dart b/test/widgets/profile_test.dart
index bb7488c90d..88128a1c72 100644
--- a/test/widgets/profile_test.dart
+++ b/test/widgets/profile_test.dart
@@ -1,21 +1,29 @@
+import 'dart:io';
+
 import 'package:checks/checks.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_checks/flutter_checks.dart';
 import 'package:flutter_test/flutter_test.dart';
+import 'package:http/http.dart' as http;
 import 'package:url_launcher/url_launcher.dart';
+import 'package:zulip/api/model/events.dart';
 import 'package:zulip/api/model/initial_snapshot.dart';
 import 'package:zulip/api/model/model.dart';
 import 'package:zulip/model/narrow.dart';
 import 'package:zulip/model/store.dart';
+import 'package:zulip/widgets/button.dart';
 import 'package:zulip/widgets/content.dart';
 import 'package:zulip/widgets/icons.dart';
 import 'package:zulip/widgets/message_list.dart';
 import 'package:zulip/widgets/page.dart';
+import 'package:zulip/widgets/remote_settings.dart';
 import 'package:zulip/widgets/profile.dart';
 
+import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
 import '../model/binding.dart';
 import '../model/test_store.dart';
+import '../stdlib_checks.dart';
 import '../test_images.dart';
 import '../test_navigation.dart';
 import 'message_list_checks.dart';
@@ -24,6 +32,7 @@ import 'profile_page_checks.dart';
 import 'test_app.dart';
 
 late PerAccountStore store;
+late FakeApiConnection connection;
 
 Future<void> setupPage(WidgetTester tester, {
   required int pageUserId,
@@ -31,15 +40,18 @@ Future<void> setupPage(WidgetTester tester, {
   List<int>? mutedUserIds,
   List<CustomProfileField>? customProfileFields,
   Map<String, RealmDefaultExternalAccount>? realmDefaultExternalAccounts,
+  bool realmPresenceDisabled = false,
   NavigatorObserver? navigatorObserver,
 }) async {
   addTearDown(testBinding.reset);
 
   final initialSnapshot = eg.initialSnapshot(
     customProfileFields: customProfileFields,
-    realmDefaultExternalAccounts: realmDefaultExternalAccounts);
+    realmDefaultExternalAccounts: realmDefaultExternalAccounts,
+    realmPresenceDisabled: realmPresenceDisabled);
   await testBinding.globalStore.add(eg.selfAccount, initialSnapshot);
   store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+  connection = store.connection as FakeApiConnection;
 
   await store.addUser(eg.selfUser);
   if (users != null) {
@@ -365,4 +377,285 @@ void main() {
       check(find.textContaining(longString).evaluate()).length.equals(7);
     });
   });
+
+  group('invisible mode', () {
+    final findRow = find.widgetWithText(MenuButton, 'Invisible mode');
+    final findToggle = find.descendant(of: findRow, matching: find.byType(Toggle));
+
+    void checkDoesNotAppear(WidgetTester tester) {
+      check(findRow).findsNothing();
+      check(findToggle).findsNothing();
+    }
+
+    void checkAppears(WidgetTester tester) {
+      check(findRow).findsOne();
+      check(findToggle).findsOne();
+    }
+
+    bool getValue(WidgetTester tester) => tester.widget<Toggle>(findToggle).value;
+
+    void checkAppearsActive(WidgetTester tester, bool expected) {
+      check(getValue(tester)).equals(expected);
+
+      check(tester.semantics.find(findRow)).matchesSemantics(
+        label: 'Invisible mode',
+        isFocusable: true,
+        hasEnabledState: true,
+        isEnabled: true,
+        hasTapAction: true,
+        hasFocusAction: true,
+        hasToggledState: true,
+        isToggled: expected);
+    }
+
+    void prepareRequestSuccess([Duration delay = Duration.zero]) {
+      connection.prepare(json: {}, delay: delay);
+    }
+
+    void prepareRequestError([Duration delay = Duration.zero]) {
+      connection.prepare(httpException: SocketException('failed'), delay: delay);
+    }
+
+    void scheduleEventAfter(Duration duration, bool newInvisibleModeValue) async {
+      await Future<void>.delayed(duration);
+      await store.handleEvent(UserSettingsUpdateEvent(id: 1,
+        property: UserSettingName.presenceEnabled, value: !newInvisibleModeValue));
+    }
+
+    void checkRequest(bool requestedInvisibleModeValue) {
+      check(connection.takeRequests()).single.isA<http.Request>()
+        ..method.equals('PATCH')
+        ..url.path.equals('/api/v1/settings')
+        ..bodyFields.deepEquals({
+          'presence_enabled': requestedInvisibleModeValue ? 'false' : 'true',
+        });
+    }
+
+    final toggleInteractionModeVariant = ValueVariant<_InvisibleModeToggleInteractionMode>(
+      _InvisibleModeToggleInteractionMode.values.toSet());
+
+    Future<void> doToggle(WidgetTester tester, _InvisibleModeToggleInteractionMode mode) async {
+      switch (mode) {
+        case _InvisibleModeToggleInteractionMode.tapRow:
+          await tester.tap(findRow);
+        case _InvisibleModeToggleInteractionMode.tapToggle:
+          await tester.tap(findToggle);
+        case _InvisibleModeToggleInteractionMode.dragToggleThumb:
+          final textDirection = Directionality.of(tester.element(findToggle));
+          final dragDx = switch ((getValue(tester), textDirection)) {
+            (true,  TextDirection.ltr) => -40.0,
+            (false, TextDirection.ltr) =>  40.0,
+            (true,  TextDirection.rtl) =>  40.0,
+            (false, TextDirection.rtl) => -40.0,
+          };
+          await tester.drag(findToggle, Offset(dragDx, 0.0));
+      }
+    }
+
+    testWidgets('self-profile: appears', (tester) async {
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      checkAppears(tester);
+    });
+
+    testWidgets('self-profile, but presence disabled in realm: does not appear', (tester) async {
+      await setupPage(tester, pageUserId: eg.selfUser.userId, realmPresenceDisabled: true);
+      checkDoesNotAppear(tester);
+    });
+
+    testWidgets('non-self profile: does not appear', (tester) async {
+      await setupPage(tester, pageUserId: eg.otherUser.userId, users: [eg.otherUser]);
+      checkDoesNotAppear(tester);
+    });
+
+    testWidgets('without recent interaction, event causes immediate update, which sticks', (tester) async {
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      check(store.userSettings.presenceEnabled).isTrue();
+      checkAppearsActive(tester, false);
+
+      await store.handleEvent(UserSettingsUpdateEvent(id: 1,
+        property: UserSettingName.presenceEnabled, value: false));
+      await tester.pump();
+      checkAppearsActive(tester, true);
+
+      await tester.pump(RemoteSettingBuilder.localEchoIdleTimeout * 2);
+      checkAppearsActive(tester, true);
+    });
+
+    testWidgets('smoke, turn on', (tester) async {
+      final toggleInteractionMode = toggleInteractionModeVariant.currentValue!;
+
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      check(store.userSettings.presenceEnabled).isTrue();
+      checkAppearsActive(tester, false);
+
+      // The appearance changes and the request is sent, immediately.
+      prepareRequestSuccess(Duration(milliseconds: 100));
+      scheduleEventAfter(Duration(milliseconds: 150), true);
+      await doToggle(tester, toggleInteractionMode);
+      await tester.pump();
+      await tester.pump();
+      checkAppearsActive(tester, true);
+      checkRequest(true);
+
+      // Wait a while, idly: no change, no extra requests
+      await tester.pump(RemoteSettingBuilder.localEchoIdleTimeout * 2);
+      check(connection.takeRequests()).isEmpty();
+      checkAppearsActive(tester, true);
+    }, variant: toggleInteractionModeVariant);
+
+    testWidgets('smoke, turn off', (tester) async {
+      final toggleInteractionMode = toggleInteractionModeVariant.currentValue!;
+
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      await store.handleEvent(UserSettingsUpdateEvent(id: 1,
+        property: UserSettingName.presenceEnabled, value: false));
+      await tester.pump();
+      checkAppearsActive(tester, true);
+
+      // The appearance changes and the request is sent, immediately.
+      prepareRequestSuccess(Duration(milliseconds: 100));
+      scheduleEventAfter(Duration(milliseconds: 150), false);
+      await doToggle(tester, toggleInteractionMode);
+      await tester.pump();
+      await tester.pump();
+      checkAppearsActive(tester, false);
+      checkRequest(false);
+
+      // Wait a while, idly: no change, no extra requests
+      await tester.pump(RemoteSettingBuilder.localEchoIdleTimeout * 2);
+      check(connection.takeRequests()).isEmpty();
+      checkAppearsActive(tester, false);
+    }, variant: toggleInteractionModeVariant);
+
+    testWidgets('event arrives after local-echo timeout', (tester) async {
+      final toggleInteractionMode = toggleInteractionModeVariant.currentValue!;
+
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      check(store.userSettings.presenceEnabled).isTrue();
+      checkAppearsActive(tester, false);
+
+      // The appearance changes and the request is sent, immediately.
+      prepareRequestSuccess(Duration(milliseconds: 100));
+      scheduleEventAfter(Duration(seconds: 10), true);
+      await doToggle(tester, toggleInteractionMode);
+      await tester.pump();
+      await tester.pump();
+      checkAppearsActive(tester, true);
+      checkRequest(true);
+
+      // Local-echo timeout passes and event hasn't come; change back.
+      await tester.pump(RemoteSettingBuilder.localEchoIdleTimeout);
+      await tester.pump();
+      checkAppearsActive(tester, false);
+
+      // The event comes after a while; update for the new value.
+      await tester.pump(Duration(seconds: 10));
+      check(connection.takeRequests()).isEmpty();
+      checkAppearsActive(tester, true);
+    }, variant: toggleInteractionModeVariant);
+
+    testWidgets('request has an error', (tester) async {
+      final toggleInteractionMode = toggleInteractionModeVariant.currentValue!;
+
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      check(store.userSettings.presenceEnabled).isTrue();
+      checkAppearsActive(tester, false);
+
+      // The appearance changes and the request is sent, immediately.
+      final requestDuration = Duration(milliseconds: 100);
+      prepareRequestError(requestDuration);
+      await doToggle(tester, toggleInteractionMode);
+      await tester.pump();
+      await tester.pump();
+      checkAppearsActive(tester, true);
+      checkRequest(true);
+
+      // The appearance doesn't change as soon as the request errors,
+      // if it errored quickly…
+      await tester.pump(requestDuration);
+      checkAppearsActive(tester, true);
+
+      // Try waiting a bit longer; it still hasn't changed…
+      //   (https://github.com/zulip/zulip-flutter/pull/1631#discussion_r2191301085 )
+      final epsilon = Duration(milliseconds: 50);
+      await tester.pump(epsilon);
+      checkAppearsActive(tester, true);
+
+      // …it changes when [RemoteSettingBuilder.localEchoMinimum]
+      // has passed since the interaction.
+      await tester.pump(
+        RemoteSettingBuilder.localEchoMinimum - requestDuration - epsilon);
+      await tester.pump();
+      checkAppearsActive(tester, false);
+
+      // Wait a while, idly: no change, no extra requests
+      await tester.pump(RemoteSettingBuilder.localEchoIdleTimeout * 2);
+      check(connection.takeRequests()).isEmpty();
+      checkAppearsActive(tester, false);
+    }, variant: toggleInteractionModeVariant);
+
+    testWidgets('spam-tapping', (tester) async {
+      final toggleInteractionMode = toggleInteractionModeVariant.currentValue!;
+
+      await setupPage(tester, pageUserId: eg.selfUser.userId);
+      check(store.userSettings.presenceEnabled).isTrue();
+      checkAppearsActive(tester, false);
+
+      Future<void> doSpamTap({required bool expectedCurrentValue}) async {
+        checkAppearsActive(tester, expectedCurrentValue);
+        final newValue = !expectedCurrentValue;
+        // The appearance changes and the request is sent, immediately.
+        prepareRequestSuccess(Duration(milliseconds: 100));
+        scheduleEventAfter(Duration(milliseconds: 150), newValue);
+        await doToggle(tester, toggleInteractionMode);
+        await tester.pump();
+        await tester.pump();
+        checkAppearsActive(tester, newValue);
+        checkRequest(newValue);
+      }
+
+      // Events will be coming in, but those don't control the switch;
+      // only the user interaction does, until there have been no interactions
+      // for [RemoteSettingBuilder.localEchoMinimum].
+      await doSpamTap(expectedCurrentValue: false);
+      await tester.pump(Duration(milliseconds: 90));
+      await doSpamTap(expectedCurrentValue: true);
+      await tester.pump(Duration(milliseconds: 30));
+      await doSpamTap(expectedCurrentValue: false);
+      await tester.pump(Duration(milliseconds: 60));
+      await doSpamTap(expectedCurrentValue: true);
+      await tester.pump(Duration(milliseconds: 120));
+      await doSpamTap(expectedCurrentValue: false);
+      await tester.pump(Duration(milliseconds: 120));
+      await doSpamTap(expectedCurrentValue: true);
+      await tester.pump(Duration(milliseconds: 120));
+      await doSpamTap(expectedCurrentValue: false);
+      await tester.pump(Duration(milliseconds: 300));
+      await doSpamTap(expectedCurrentValue: true);
+      await tester.pump(Duration(milliseconds: 45));
+      await doSpamTap(expectedCurrentValue: false);
+      await tester.pump(Duration(milliseconds: 600));
+      await doSpamTap(expectedCurrentValue: true);
+      await tester.pump(Duration(milliseconds: 5));
+      await doSpamTap(expectedCurrentValue: false);
+      check(getValue(tester)).equals(true);
+
+      await tester.pump(RemoteSettingBuilder.localEchoMinimum - Duration(milliseconds: 1));
+      check(getValue(tester)).equals(true);
+      await tester.pump(Duration(milliseconds: 2));
+      check(getValue(tester)).equals(true);
+
+      // Wait a while, idly: no change, no extra requests
+      await tester.pump(RemoteSettingBuilder.localEchoIdleTimeout * 2);
+      check(connection.takeRequests()).isEmpty();
+      checkAppearsActive(tester, true);
+    }, variant: toggleInteractionModeVariant);
+  });
+}
+
+enum _InvisibleModeToggleInteractionMode {
+  tapRow,
+  tapToggle,
+  dragToggleThumb,
+  // TODO(a11y) is there something separate to test?
 }
diff --git a/test/widgets/remote_settings_test.dart b/test/widgets/remote_settings_test.dart
new file mode 100644
index 0000000000..11981dab1f
--- /dev/null
+++ b/test/widgets/remote_settings_test.dart
@@ -0,0 +1,12 @@
+import 'package:flutter_test/flutter_test.dart';
+
+import '../model/binding.dart';
+
+void main() {
+  TestZulipBinding.ensureInitialized();
+
+  group('RemoteSettingBuilder', () {
+    // This builder widget is covered in the tests for the "Invisible mode"
+    // toggle switch in test/widgets/profile_test.dart.
+  });
+}
