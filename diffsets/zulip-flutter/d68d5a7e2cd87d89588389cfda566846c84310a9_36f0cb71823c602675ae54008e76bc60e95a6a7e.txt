diff --git a/assets/l10n/app_en.arb b/assets/l10n/app_en.arb
index d11bf43eda..1c0ec3d7e8 100644
--- a/assets/l10n/app_en.arb
+++ b/assets/l10n/app_en.arb
@@ -769,6 +769,10 @@
   "@mainMenuMyProfile": {
     "description": "Label for main-menu button leading to the user's own profile."
   },
+  "topicsButtonLabel": "TOPICS",
+  "@topicsButtonLabel": {
+    "description": "Label for message list button leading to topic-list page. (Use ALL CAPS for cased alphabets: Latin, Greek, Cyrillic, etc.)"
+  },
   "channelFeedButtonTooltip": "Channel feed",
   "@channelFeedButtonTooltip": {
     "description": "Tooltip for button to navigate to a given channel's feed"
diff --git a/lib/generated/l10n/zulip_localizations.dart b/lib/generated/l10n/zulip_localizations.dart
index ecb0eee16a..566ff617ad 100644
--- a/lib/generated/l10n/zulip_localizations.dart
+++ b/lib/generated/l10n/zulip_localizations.dart
@@ -1151,6 +1151,12 @@ abstract class ZulipLocalizations {
   /// **'My profile'**
   String get mainMenuMyProfile;
 
+  /// Label for message list button leading to topic-list page. (Use ALL CAPS for cased alphabets: Latin, Greek, Cyrillic, etc.)
+  ///
+  /// In en, this message translates to:
+  /// **'TOPICS'**
+  String get topicsButtonLabel;
+
   /// Tooltip for button to navigate to a given channel's feed
   ///
   /// In en, this message translates to:
diff --git a/lib/generated/l10n/zulip_localizations_ar.dart b/lib/generated/l10n/zulip_localizations_ar.dart
index 98dd9a7af6..d1025b7151 100644
--- a/lib/generated/l10n/zulip_localizations_ar.dart
+++ b/lib/generated/l10n/zulip_localizations_ar.dart
@@ -629,6 +629,9 @@ class ZulipLocalizationsAr extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'My profile';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Channel feed';
 
diff --git a/lib/generated/l10n/zulip_localizations_de.dart b/lib/generated/l10n/zulip_localizations_de.dart
index 08d09bb3c4..eee1309e1b 100644
--- a/lib/generated/l10n/zulip_localizations_de.dart
+++ b/lib/generated/l10n/zulip_localizations_de.dart
@@ -629,6 +629,9 @@ class ZulipLocalizationsDe extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'My profile';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Channel feed';
 
diff --git a/lib/generated/l10n/zulip_localizations_en.dart b/lib/generated/l10n/zulip_localizations_en.dart
index 105162429b..fbdcea3935 100644
--- a/lib/generated/l10n/zulip_localizations_en.dart
+++ b/lib/generated/l10n/zulip_localizations_en.dart
@@ -629,6 +629,9 @@ class ZulipLocalizationsEn extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'My profile';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Channel feed';
 
diff --git a/lib/generated/l10n/zulip_localizations_ja.dart b/lib/generated/l10n/zulip_localizations_ja.dart
index 74a2d4bedb..a9a2e40dce 100644
--- a/lib/generated/l10n/zulip_localizations_ja.dart
+++ b/lib/generated/l10n/zulip_localizations_ja.dart
@@ -629,6 +629,9 @@ class ZulipLocalizationsJa extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'My profile';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Channel feed';
 
diff --git a/lib/generated/l10n/zulip_localizations_nb.dart b/lib/generated/l10n/zulip_localizations_nb.dart
index 02913278b8..afe3c9794a 100644
--- a/lib/generated/l10n/zulip_localizations_nb.dart
+++ b/lib/generated/l10n/zulip_localizations_nb.dart
@@ -629,6 +629,9 @@ class ZulipLocalizationsNb extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'My profile';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Channel feed';
 
diff --git a/lib/generated/l10n/zulip_localizations_pl.dart b/lib/generated/l10n/zulip_localizations_pl.dart
index 26b4b7e306..7653f8d31d 100644
--- a/lib/generated/l10n/zulip_localizations_pl.dart
+++ b/lib/generated/l10n/zulip_localizations_pl.dart
@@ -638,6 +638,9 @@ class ZulipLocalizationsPl extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'Mój profil';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Strumień kanału';
 
diff --git a/lib/generated/l10n/zulip_localizations_ru.dart b/lib/generated/l10n/zulip_localizations_ru.dart
index 5d8899290d..6ea916c359 100644
--- a/lib/generated/l10n/zulip_localizations_ru.dart
+++ b/lib/generated/l10n/zulip_localizations_ru.dart
@@ -642,6 +642,9 @@ class ZulipLocalizationsRu extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'Мой профиль';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Лента канала';
 
diff --git a/lib/generated/l10n/zulip_localizations_sk.dart b/lib/generated/l10n/zulip_localizations_sk.dart
index 3ff534eca5..5430a885c4 100644
--- a/lib/generated/l10n/zulip_localizations_sk.dart
+++ b/lib/generated/l10n/zulip_localizations_sk.dart
@@ -631,6 +631,9 @@ class ZulipLocalizationsSk extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'Môj profil';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Channel feed';
 
diff --git a/lib/generated/l10n/zulip_localizations_uk.dart b/lib/generated/l10n/zulip_localizations_uk.dart
index 94fee8825a..db213893db 100644
--- a/lib/generated/l10n/zulip_localizations_uk.dart
+++ b/lib/generated/l10n/zulip_localizations_uk.dart
@@ -641,6 +641,9 @@ class ZulipLocalizationsUk extends ZulipLocalizations {
   @override
   String get mainMenuMyProfile => 'Мій профіль';
 
+  @override
+  String get topicsButtonLabel => 'TOPICS';
+
   @override
   String get channelFeedButtonTooltip => 'Стрічка каналу';
 
diff --git a/lib/widgets/message_list.dart b/lib/widgets/message_list.dart
index 44ae56fb1e..0003ae5ed7 100644
--- a/lib/widgets/message_list.dart
+++ b/lib/widgets/message_list.dart
@@ -24,6 +24,7 @@ import 'sticky_header.dart';
 import 'store.dart';
 import 'text.dart';
 import 'theme.dart';
+import 'topic_list.dart';
 
 /// Message-list styles that differ between light and dark themes.
 class MessageListTheme extends ThemeExtension<MessageListTheme> {
@@ -220,14 +221,23 @@ class _MessageListPageState extends State<MessageListPage> implements MessageLis
         removeAppBarBottomBorder = true;
     }
 
-    List<Widget>? actions;
-    if (narrow case TopicNarrow(:final streamId)) {
-      (actions ??= []).add(IconButton(
-        icon: const Icon(ZulipIcons.message_feed),
-        tooltip: zulipLocalizations.channelFeedButtonTooltip,
-        onPressed: () => Navigator.push(context,
-          MessageListPage.buildRoute(context: context,
-            narrow: ChannelNarrow(streamId)))));
+    List<Widget> actions = [];
+    switch (narrow) {
+      case CombinedFeedNarrow():
+      case MentionsNarrow():
+      case StarredMessagesNarrow():
+      case DmNarrow():
+        break;
+      case ChannelNarrow(:final streamId):
+        actions.add(_TopicListButton(streamId: streamId));
+      case TopicNarrow(:final streamId):
+        actions.add(IconButton(
+          icon: const Icon(ZulipIcons.message_feed),
+          tooltip: zulipLocalizations.channelFeedButtonTooltip,
+          onPressed: () => Navigator.push(context,
+            MessageListPage.buildRoute(context: context,
+              narrow: ChannelNarrow(streamId)))));
+        actions.add(_TopicListButton(streamId: streamId));
     }
 
     // Insert a PageRoot here, to provide a context that can be used for
@@ -277,6 +287,35 @@ class _MessageListPageState extends State<MessageListPage> implements MessageLis
   }
 }
 
+class _TopicListButton extends StatelessWidget {
+  const _TopicListButton({required this.streamId});
+
+  final int streamId;
+
+  @override
+  Widget build(BuildContext context) {
+    final zulipLocalizations = ZulipLocalizations.of(context);
+    final designVariables = DesignVariables.of(context);
+    return GestureDetector(
+      onTap: () {
+        Navigator.of(context).push(TopicListPage.buildRoute(
+          context: context, streamId: streamId));
+      },
+      behavior: HitTestBehavior.opaque,
+      child: Padding(
+        padding: EdgeInsetsDirectional.fromSTEB(12, 8, 12, 8),
+        child: Center(child: Text(zulipLocalizations.topicsButtonLabel,
+          style: TextStyle(
+            color: designVariables.icon,
+            fontSize: 18,
+            height: 19 / 18,
+            // This is equivalent to css `all-small-caps`, see:
+            //   https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant-caps#all-small-caps
+            fontFeatures: const [FontFeature.enable('c2sc'), FontFeature.enable('smcp')],
+          ).merge(weightVariableTextStyle(context, wght: 600))))));
+  }
+}
+
 class MessageListAppBarTitle extends StatelessWidget {
   const MessageListAppBarTitle({
     super.key,
diff --git a/lib/widgets/topic_list.dart b/lib/widgets/topic_list.dart
new file mode 100644
index 0000000000..61e16df6ec
--- /dev/null
+++ b/lib/widgets/topic_list.dart
@@ -0,0 +1,347 @@
+import 'package:flutter/material.dart';
+
+import '../api/model/model.dart';
+import '../api/route/channels.dart';
+import '../generated/l10n/zulip_localizations.dart';
+import '../model/narrow.dart';
+import '../model/unreads.dart';
+import 'action_sheet.dart';
+import 'app_bar.dart';
+import 'color.dart';
+import 'icons.dart';
+import 'message_list.dart';
+import 'page.dart';
+import 'store.dart';
+import 'text.dart';
+import 'theme.dart';
+
+class TopicListPage extends StatelessWidget {
+  const TopicListPage({super.key, required this.streamId});
+
+  final int streamId;
+
+  static AccountRoute<void> buildRoute({
+    required BuildContext context,
+    required int streamId,
+  }) {
+    return MaterialAccountWidgetRoute(
+      context: context,
+      page: TopicListPage(streamId: streamId));
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final store = PerAccountStoreWidget.of(context);
+    final zulipLocalizations = ZulipLocalizations.of(context);
+    final appBarBackgroundColor = colorSwatchFor(
+      context, store.subscriptions[streamId]).barBackground;
+
+    return PageRoot(child: Scaffold(
+      appBar: ZulipAppBar(
+        backgroundColor: appBarBackgroundColor,
+        buildTitle: (willCenterTitle) =>
+          _TopicListAppBarTitle(streamId: streamId, willCenterTitle: willCenterTitle),
+        actions: [
+          IconButton(
+            icon: const Icon(ZulipIcons.message_feed),
+            tooltip: zulipLocalizations.channelFeedButtonTooltip,
+            onPressed: () => Navigator.push(context,
+              MessageListPage.buildRoute(context: context,
+                narrow: ChannelNarrow(streamId)))),
+        ]),
+      body: _TopicList(streamId: streamId)));
+  }
+}
+
+// This is adapted from [MessageListAppBarTitle].
+class _TopicListAppBarTitle extends StatelessWidget {
+  const _TopicListAppBarTitle({
+    required this.streamId,
+    required this.willCenterTitle,
+  });
+
+  final int streamId;
+  final bool willCenterTitle;
+
+  Widget _buildStreamRow(BuildContext context) {
+    // TODO(#1039) implement a consistent app bar design here
+    final zulipLocalizations = ZulipLocalizations.of(context);
+    final designVariables = DesignVariables.of(context);
+    final store = PerAccountStoreWidget.of(context);
+    final stream = store.streams[streamId];
+    final channelIconColor = colorSwatchFor(context,
+      store.subscriptions[streamId]).iconOnBarBackground;
+
+    // A null [Icon.icon] makes a blank space.
+    final icon = stream != null ? iconDataForStream(stream) : null;
+    return Row(
+      mainAxisSize: MainAxisSize.min,
+      // TODO(design): The vertical alignment of the stream privacy icon is a bit ad hoc.
+      //   For screenshots of some experiments, see:
+      //     https://github.com/zulip/zulip-flutter/pull/219#discussion_r1281024746
+      crossAxisAlignment: CrossAxisAlignment.center,
+      children: [
+        Padding(padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 6),
+          child: Icon(size: 18, icon, color: channelIconColor)),
+        Flexible(child: Text(
+          stream?.name ?? zulipLocalizations.unknownChannelName,
+          style: TextStyle(
+            fontSize: 20,
+            height: 30 / 20,
+            color: designVariables.title,
+          ).merge(weightVariableTextStyle(context, wght: 600)))),
+      ]);
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    final alignment = willCenterTitle
+      ? Alignment.center
+      : AlignmentDirectional.centerStart;
+    return SizedBox(
+      width: double.infinity,
+      child: GestureDetector(
+        behavior: HitTestBehavior.translucent,
+        onLongPress: () {
+          showChannelActionSheet(context, channelId: streamId);
+        },
+        child: Align(alignment: alignment,
+          child: _buildStreamRow(context))));
+  }
+}
+
+class _TopicList extends StatefulWidget {
+  const _TopicList({required this.streamId});
+
+  final int streamId;
+
+  @override
+  State<_TopicList> createState() => _TopicListState();
+}
+
+class _TopicListState extends State<_TopicList> with PerAccountStoreAwareStateMixin {
+  Unreads? unreadsModel;
+  // TODO(#1499): store the results on [ChannelStore], and keep them
+  //   up-to-date by handling events
+  List<GetStreamTopicsEntry>? lastFetchedTopics;
+
+  @override
+  void onNewStore() {
+    unreadsModel?.removeListener(_modelChanged);
+    final store = PerAccountStoreWidget.of(context);
+    unreadsModel = store.unreads..addListener(_modelChanged);
+    _fetchTopics();
+  }
+
+  @override
+  void dispose() {
+    unreadsModel?.removeListener(_modelChanged);
+    super.dispose();
+  }
+
+  void _modelChanged() {
+    setState(() {
+      // The actual state lives in `unreadsModel`.
+    });
+  }
+
+  void _fetchTopics() async {
+    // Do nothing when the fetch fails; the topic-list will stay on
+    // the loading screen, until the user navigates away and back.
+    // TODO(design) show a nice error message on screen when this fails
+    final store = PerAccountStoreWidget.of(context);
+    final result = await getStreamTopics(store.connection,
+      streamId: widget.streamId,
+      allowEmptyTopicName: true);
+    if (!mounted) return;
+    setState(() {
+      lastFetchedTopics = result.topics;
+    });
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    if (lastFetchedTopics == null) {
+      return const Center(child: CircularProgressIndicator());
+    }
+
+    // TODO(design) handle the rare case when `lastFetchedTopics` is empty
+
+    // This is adapted from parts of the build method on [_InboxPageState].
+    final topicItems = <_TopicItemData>[];
+    for (final GetStreamTopicsEntry(:maxId, name: topic) in lastFetchedTopics!) {
+      final unreadMessageIds =
+        unreadsModel!.streams[widget.streamId]?[topic] ?? <int>[];
+      final countInTopic = unreadMessageIds.length;
+      final hasMention = unreadMessageIds.any((messageId) =>
+        unreadsModel!.mentions.contains(messageId));
+      topicItems.add(_TopicItemData(
+        topic: topic,
+        unreadCount: countInTopic,
+        hasMention: hasMention,
+        // `lastFetchedTopics.maxId` can become outdated when a new message
+        // arrives or when there are message moves, until we re-fetch.
+        // TODO(#1499): track changes to this
+        maxId: maxId,
+      ));
+    }
+    topicItems.sort((a, b) {
+      final aMaxId = a.maxId;
+      final bMaxId = b.maxId;
+      return bMaxId.compareTo(aMaxId);
+    });
+
+    return SafeArea(
+      // Don't pad the bottom here; we want the list content to do that.
+      bottom: false,
+      child: ListView.builder(
+        itemCount: topicItems.length,
+        itemBuilder: (context, index) =>
+          _TopicItem(streamId: widget.streamId, data: topicItems[index])),
+    );
+  }
+}
+
+class _TopicItemData {
+  final TopicName topic;
+  final int unreadCount;
+  final bool hasMention;
+  final int maxId;
+
+  const _TopicItemData({
+    required this.topic,
+    required this.unreadCount,
+    required this.hasMention,
+    required this.maxId,
+  });
+}
+
+// This is adapted from `_TopicItem` in lib/widgets/inbox.dart.
+// TODO(#1527) see if we can reuse this in redesign
+class _TopicItem extends StatelessWidget {
+  const _TopicItem({required this.streamId, required this.data});
+
+  final int streamId;
+  final _TopicItemData data;
+
+  @override
+  Widget build(BuildContext context) {
+    final _TopicItemData(
+      :topic, :unreadCount, :hasMention, :maxId) = data;
+
+    final store = PerAccountStoreWidget.of(context);
+    final designVariables = DesignVariables.of(context);
+
+    final visibilityPolicy = store.topicVisibilityPolicy(streamId, topic);
+    final double opacity;
+    switch (visibilityPolicy) {
+      case UserTopicVisibilityPolicy.muted:
+        opacity = 0.5;
+      case UserTopicVisibilityPolicy.none:
+      case UserTopicVisibilityPolicy.unmuted:
+      case UserTopicVisibilityPolicy.followed:
+        opacity = 1;
+      case UserTopicVisibilityPolicy.unknown:
+        assert(false);
+        opacity = 1;
+    }
+
+    final visibilityIcon = iconDataForTopicVisibilityPolicy(visibilityPolicy);
+
+    return Material(
+      color: designVariables.bgMessageRegular,
+      child: InkWell(
+        onTap: () {
+          final narrow = TopicNarrow(streamId, topic);
+          Navigator.push(context,
+            MessageListPage.buildRoute(context: context, narrow: narrow));
+        },
+        onLongPress: () => showTopicActionSheet(context,
+          channelId: streamId,
+          topic: topic,
+          someMessageIdInTopic: maxId),
+        splashFactory: NoSplash.splashFactory,
+        child: Padding(padding: EdgeInsetsDirectional.fromSTEB(6, 8, 12, 8),
+          child: Row(
+            spacing: 8,
+            // In the Figma design, the text and icons on the topic item row
+            // are aligned to the start on the cross axis
+            // (i.e., `align-items: flex-start`).  The icons are padded down
+            // 2px relative to the start, to visibly sit on the baseline.
+            // To account for scaled text, we align everything on the row
+            // to [CrossAxisAlignment.center] instead ([Row]'s default),
+            // like we do for the topic items on the inbox page.
+            // TODO(#1528): align to baseline (and therefore to first line of
+            //   topic name), but with adjustment for icons
+            // CZO discussion:
+            //   https://chat.zulip.org/#narrow/channel/243-mobile-team/topic/topic.20list.20item.20alignment/near/2173252
+            children: [
+              // A null [Icon.icon] makes a blank space.
+              _IconMarker(icon: topic.isResolved ? ZulipIcons.check : null),
+              Expanded(child: Opacity(
+                opacity: opacity,
+                child: Text(
+                  style: TextStyle(
+                    fontSize: 17,
+                    height: 20 / 17,
+                    fontStyle: topic.displayName == null ? FontStyle.italic : null,
+                    color: designVariables.textMessage,
+                  ),
+                  maxLines: 3,
+                  overflow: TextOverflow.ellipsis,
+                  topic.unresolve().displayName ?? store.realmEmptyTopicDisplayName))),
+              Opacity(opacity: opacity, child: Row(
+                spacing: 4,
+                children: [
+                  if (hasMention) const _IconMarker(icon: ZulipIcons.at_sign),
+                  if (visibilityIcon != null) _IconMarker(icon: visibilityIcon),
+                  if (unreadCount > 0) _UnreadCountBadge(count: unreadCount),
+                ])),
+            ]))));
+  }
+}
+
+class _IconMarker extends StatelessWidget {
+  const _IconMarker({required this.icon});
+
+  final IconData? icon;
+
+  @override
+  Widget build(BuildContext context) {
+    final designVariables = DesignVariables.of(context);
+    final textScaler = MediaQuery.textScalerOf(context);
+    // Since we align the icons to [CrossAxisAlignment.center], the top padding
+    // from the Figma design is omitted.
+    return Icon(icon,
+      size: textScaler.clamp(maxScaleFactor: 1.5).scale(16),
+      color: designVariables.textMessage.withFadedAlpha(0.4));
+  }
+}
+
+// This is adapted from [UnreadCountBadge].
+// TODO(#1406) see if we can reuse this in redesign
+// TODO(#1527) see if we can reuse this in redesign
+class _UnreadCountBadge extends StatelessWidget {
+  const _UnreadCountBadge({required this.count});
+
+  final int count;
+
+  @override
+  Widget build(BuildContext context) {
+    final designVariables = DesignVariables.of(context);
+
+    return DecoratedBox(
+      decoration: BoxDecoration(
+        borderRadius: BorderRadius.circular(5),
+        color: designVariables.bgCounterUnread,
+      ),
+      child: Padding(
+        padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
+        child: Text(count.toString(),
+          style: TextStyle(
+            fontSize: 15,
+            height: 16 / 15,
+            color: designVariables.labelCounterUnread,
+          ).merge(weightVariableTextStyle(context, wght: 500)))));
+  }
+}
diff --git a/test/widgets/message_list_test.dart b/test/widgets/message_list_test.dart
index 9b614b735b..606a01f420 100644
--- a/test/widgets/message_list_test.dart
+++ b/test/widgets/message_list_test.dart
@@ -11,6 +11,7 @@ import 'package:zulip/api/model/events.dart';
 import 'package:zulip/api/model/initial_snapshot.dart';
 import 'package:zulip/api/model/model.dart';
 import 'package:zulip/api/model/narrow.dart';
+import 'package:zulip/api/route/channels.dart';
 import 'package:zulip/api/route/messages.dart';
 import 'package:zulip/model/actions.dart';
 import 'package:zulip/model/localizations.dart';
@@ -28,6 +29,7 @@ import 'package:zulip/widgets/page.dart';
 import 'package:zulip/widgets/store.dart';
 import 'package:zulip/widgets/channel_colors.dart';
 import 'package:zulip/widgets/theme.dart';
+import 'package:zulip/widgets/topic_list.dart';
 
 import '../api/fake_api.dart';
 import '../example_data.dart' as eg;
@@ -229,6 +231,25 @@ void main() {
           .equals(ChannelNarrow(channel.streamId));
     });
 
+    testWidgets('has topic-list action for topic narrows', (tester) async {
+      final channel = eg.stream(name: 'channel foo');
+      await setupMessageListPage(tester,
+        narrow: eg.topicNarrow(channel.streamId, 'topic foo'),
+        streams: [channel],
+        messages: [eg.streamMessage(stream: channel, topic: 'topic foo')]);
+
+      connection.prepare(json: GetStreamTopicsResult(topics: [
+        eg.getStreamTopicsEntry(name: 'topic foo'),
+      ]).toJson());
+      await tester.tap(find.text('TOPICS'));
+      await tester.pump(); // tap the button
+      await tester.pump(Duration.zero); // wait for request
+      check(find.descendant(
+        of: find.byType(TopicListPage),
+        matching: find.text('channel foo')),
+      ).findsOne();
+    });
+
     testWidgets('show topic visibility policy for topic narrows', (tester) async {
       final channel = eg.stream();
       const topic = 'topic';
@@ -244,6 +265,25 @@ void main() {
         of: find.byType(MessageListAppBarTitle),
         matching: find.byIcon(ZulipIcons.mute))).findsOne();
     });
+
+    testWidgets('has topic-list action for channel narrows', (tester) async {
+      final channel = eg.stream(name: 'channel foo');
+      await setupMessageListPage(tester,
+        narrow: ChannelNarrow(channel.streamId),
+        streams: [channel],
+        messages: [eg.streamMessage(stream: channel, topic: 'topic foo')]);
+
+      connection.prepare(json: GetStreamTopicsResult(topics: [
+        eg.getStreamTopicsEntry(name: 'topic foo'),
+      ]).toJson());
+      await tester.tap(find.text('TOPICS'));
+      await tester.pump(); // tap the button
+      await tester.pump(Duration.zero); // wait for request
+      check(find.descendant(
+        of: find.byType(TopicListPage),
+        matching: find.text('channel foo')),
+      ).findsOne();
+    });
   });
 
   group('presents message content appropriately', () {
diff --git a/test/widgets/topic_list_test.dart b/test/widgets/topic_list_test.dart
new file mode 100644
index 0000000000..cf76ff3917
--- /dev/null
+++ b/test/widgets/topic_list_test.dart
@@ -0,0 +1,330 @@
+import 'package:checks/checks.dart';
+import 'package:flutter/material.dart';
+import 'package:flutter_checks/flutter_checks.dart';
+import 'package:flutter_test/flutter_test.dart';
+import 'package:http/http.dart' as http;
+import 'package:zulip/api/model/initial_snapshot.dart';
+import 'package:zulip/api/model/model.dart';
+import 'package:zulip/api/route/channels.dart';
+import 'package:zulip/model/narrow.dart';
+import 'package:zulip/model/store.dart';
+import 'package:zulip/widgets/app_bar.dart';
+import 'package:zulip/widgets/icons.dart';
+import 'package:zulip/widgets/message_list.dart';
+import 'package:zulip/widgets/topic_list.dart';
+
+import '../api/fake_api.dart';
+import '../example_data.dart' as eg;
+import '../model/binding.dart';
+import '../model/test_store.dart';
+import '../stdlib_checks.dart';
+import 'test_app.dart';
+
+void main() {
+  TestZulipBinding.ensureInitialized();
+
+  late PerAccountStore store;
+  late FakeApiConnection connection;
+
+  Future<void> prepare(WidgetTester tester, {
+    ZulipStream? channel,
+    List<GetStreamTopicsEntry>? topics,
+    List<UserTopicItem> userTopics = const [],
+    List<StreamMessage>? messages,
+  }) async {
+    addTearDown(testBinding.reset);
+    await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+    store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+    connection = store.connection as FakeApiConnection;
+
+    await store.addUser(eg.selfUser);
+    channel ??= eg.stream();
+    await store.addStream(channel);
+    await store.addSubscription(eg.subscription(channel));
+    for (final userTopic in userTopics) {
+      await store.addUserTopic(
+        channel, userTopic.topicName.apiName, userTopic.visibilityPolicy);
+    }
+    topics ??= [eg.getStreamTopicsEntry()];
+    messages ??= [eg.streamMessage(stream: channel, topic: topics.first.name.apiName)];
+    await store.addMessages(messages);
+
+    connection.prepare(json: GetStreamTopicsResult(topics: topics).toJson());
+    await tester.pumpWidget(TestZulipApp(
+      accountId: eg.selfAccount.id,
+      child: TopicListPage(streamId: channel.streamId)));
+    await tester.pump();
+    await tester.pump(Duration.zero);
+    check(connection.takeRequests()).single.isA<http.Request>()
+      ..method.equals('GET')
+      ..url.path.equals('/api/v1/users/me/${channel.streamId}/topics')
+      ..url.queryParameters.deepEquals({'allow_empty_topic_name': 'true'});
+  }
+
+  group('app bar', () {
+    testWidgets('unknown channel name', (tester) async {
+      addTearDown(testBinding.reset);
+      await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+      final store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+      final channel = eg.stream();
+
+      (store.connection as FakeApiConnection).prepare(
+        json: GetStreamTopicsResult(topics: []).toJson());
+      await tester.pumpWidget(TestZulipApp(
+        accountId: eg.selfAccount.id,
+        child: TopicListPage(streamId: channel.streamId)));
+      await tester.pump();
+      await tester.pump(Duration.zero);
+      check(find.widgetWithText(ZulipAppBar, '(unknown channel)')).findsOne();
+    });
+
+    testWidgets('navigate to channel feed', (tester) async {
+      final channel = eg.stream(name: 'channel foo');
+      await prepare(tester, channel: channel);
+
+      connection.prepare(json: eg.newestGetMessagesResult(
+        foundOldest: true, messages: [eg.streamMessage(stream: channel)]).toJson());
+      await tester.tap(find.byIcon(ZulipIcons.message_feed));
+      await tester.pump();
+      await tester.pump(Duration.zero);
+      check(find.descendant(
+        of: find.byType(MessageListPage),
+        matching: find.text('channel foo')),
+      ).findsOne();
+    });
+
+    testWidgets('show channel action sheet', (tester) async {
+      final channel = eg.stream(name: 'channel foo');
+      await prepare(tester, channel: channel,
+        messages: [eg.streamMessage(stream: channel)]);
+
+      await tester.longPress(find.text('channel foo'));
+      await tester.pump(Duration(milliseconds: 100)); // bottom-sheet animation
+      check(find.text('Mark channel as read')).findsOne();
+    });
+  });
+
+  testWidgets('show loading indicator', (tester) async {
+    addTearDown(testBinding.reset);
+    await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+    final store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+    final channel = eg.stream();
+
+    (store.connection as FakeApiConnection).prepare(
+      json: GetStreamTopicsResult(topics: []).toJson(),
+      delay: Duration(seconds: 1),
+    );
+    await tester.pumpWidget(TestZulipApp(
+      accountId: eg.selfAccount.id,
+      child: TopicListPage(streamId: channel.streamId)));
+    await tester.pump();
+    check(find.byType(CircularProgressIndicator)).findsOne();
+
+    await tester.pump(Duration(seconds: 1));
+    check(find.byType(CircularProgressIndicator)).findsNothing();
+  });
+
+  testWidgets('fetch again when navigating away and back', (tester) async {
+    addTearDown(testBinding.reset);
+    await testBinding.globalStore.add(eg.selfAccount, eg.initialSnapshot());
+    final store = await testBinding.globalStore.perAccount(eg.selfAccount.id);
+    final connection = store.connection as FakeApiConnection;
+    final channel = eg.stream();
+
+    // Start from a message list page in a channel narrow.
+    connection.prepare(json: eg.newestGetMessagesResult(
+      foundOldest: true, messages: []).toJson());
+    await tester.pumpWidget(TestZulipApp(
+      accountId: eg.selfAccount.id,
+      child: MessageListPage(initNarrow: ChannelNarrow(channel.streamId))));
+    await tester.pump();
+
+    // Tap "TOPICS" button navigating to the topic-list page…
+    connection.prepare(json: GetStreamTopicsResult(
+      topics: [eg.getStreamTopicsEntry(name: 'topic A')]).toJson());
+    await tester.tap(find.text('TOPICS'));
+    await tester.pump();
+    await tester.pump(Duration.zero);
+    check(find.text('topic A')).findsOne();
+
+    // … go back to the message list page…
+    await tester.pageBack();
+    await tester.pump();
+
+    // … then back to the topic-list page, expecting to fetch again.
+    connection.prepare(json: GetStreamTopicsResult(
+      topics: [eg.getStreamTopicsEntry(name: 'topic B')]).toJson());
+    await tester.tap(find.text('TOPICS'));
+    await tester.pump();
+    await tester.pump(Duration.zero);
+    check(find.text('topic A')).findsNothing();
+    check(find.text('topic B')).findsOne();
+  });
+
+  Finder topicItemFinder = find.descendant(
+    of: find.byType(ListView),
+    matching: find.byType(Material));
+
+  Finder findInTopicItemAt(int index, Finder finder) => find.descendant(
+    of: topicItemFinder.at(index),
+    matching: finder);
+
+  testWidgets('show topic action sheet', (tester) async {
+    final channel = eg.stream();
+    await prepare(tester, channel: channel,
+      topics: [eg.getStreamTopicsEntry(name: 'topic foo')]);
+    await tester.longPress(topicItemFinder);
+    await tester.pump(Duration(milliseconds: 150)); // bottom-sheet animation
+
+    connection.prepare(json: {});
+    await tester.tap(find.text('Mute topic'));
+    await tester.pump();
+    await tester.pump(Duration.zero);
+    check(connection.takeRequests()).single.isA<http.Request>()
+      ..method.equals('POST')
+      ..url.path.equals('/api/v1/user_topics')
+      ..bodyFields.deepEquals({
+        'stream_id': channel.streamId.toString(),
+        'topic': 'topic foo',
+        'visibility_policy': UserTopicVisibilityPolicy.muted.apiValue.toString(),
+      });
+  });
+
+  testWidgets('sort topics by maxId', (tester) async {
+    await prepare(tester, topics: [
+      eg.getStreamTopicsEntry(name: 'A', maxId: 3),
+      eg.getStreamTopicsEntry(name: 'B', maxId: 2),
+      eg.getStreamTopicsEntry(name: 'C', maxId: 4),
+    ]);
+
+    check(findInTopicItemAt(0, find.text('C'))).findsOne();
+    check(findInTopicItemAt(1, find.text('A'))).findsOne();
+    check(findInTopicItemAt(2, find.text('B'))).findsOne();
+  });
+
+  testWidgets('resolved and unresolved topics', (tester) async {
+    final resolvedTopic = TopicName('resolved').resolve();
+    final unresolvedTopic = TopicName('unresolved');
+    await prepare(tester, topics: [
+      eg.getStreamTopicsEntry(maxId: 2, name: resolvedTopic.apiName),
+      eg.getStreamTopicsEntry(maxId: 1, name: unresolvedTopic.apiName),
+    ]);
+
+    assert(resolvedTopic.displayName == '✔ resolved', resolvedTopic.displayName);
+    check(findInTopicItemAt(0, find.text('✔ resolved'))).findsNothing();
+
+    check(findInTopicItemAt(0, find.text('resolved'))).findsOne();
+    check(findInTopicItemAt(0, find.byIcon(ZulipIcons.check).hitTestable()))
+      .findsOne();
+
+    check(findInTopicItemAt(1, find.text('unresolved'))).findsOne();
+    check(findInTopicItemAt(1, find.byType(Icon)).hitTestable())
+      .findsNothing();
+  });
+
+  testWidgets('handle empty topics', (tester) async {
+    await prepare(tester, topics: [
+      eg.getStreamTopicsEntry(name: ''),
+    ]);
+    check(findInTopicItemAt(0,
+      find.text(eg.defaultRealmEmptyTopicDisplayName))).findsOne();
+  });
+
+  group('unreads', () {
+    testWidgets('muted and non-muted topics', (tester) async {
+      final channel = eg.stream();
+      await prepare(tester, channel: channel,
+        topics: [
+          eg.getStreamTopicsEntry(maxId: 2, name: 'muted'),
+          eg.getStreamTopicsEntry(maxId: 1, name: 'non-muted'),
+        ],
+        userTopics: [
+          eg.userTopicItem(channel, 'muted', UserTopicVisibilityPolicy.muted),
+        ],
+        messages: [
+          eg.streamMessage(stream: channel, topic: 'muted'),
+          eg.streamMessage(stream: channel, topic: 'non-muted'),
+          eg.streamMessage(stream: channel, topic: 'non-muted'),
+        ]);
+
+      check(findInTopicItemAt(0, find.text('1'))).findsOne();
+      check(findInTopicItemAt(0, find.text('muted'))).findsOne();
+      check(findInTopicItemAt(0, find.byIcon(ZulipIcons.mute).hitTestable()))
+        .findsOne();
+
+      check(findInTopicItemAt(1, find.text('2'))).findsOne();
+      check(findInTopicItemAt(1, find.text('non-muted'))).findsOne();
+      check(findInTopicItemAt(1, find.byType(Icon).hitTestable()))
+        .findsNothing();
+    });
+
+    testWidgets('with and without unread mentions', (tester) async {
+      final channel = eg.stream();
+      await prepare(tester, channel: channel,
+        topics: [
+          eg.getStreamTopicsEntry(maxId: 2, name: 'not mentioned'),
+          eg.getStreamTopicsEntry(maxId: 1, name: 'mentioned'),
+        ],
+        messages: [
+          eg.streamMessage(stream: channel, topic: 'not mentioned'),
+          eg.streamMessage(stream: channel, topic: 'not mentioned'),
+          eg.streamMessage(stream: channel, topic: 'not mentioned',
+            flags: [MessageFlag.mentioned, MessageFlag.read]),
+          eg.streamMessage(stream: channel, topic: 'mentioned',
+            flags: [MessageFlag.mentioned]),
+        ]);
+
+      check(findInTopicItemAt(0, find.text('2'))).findsOne();
+      check(findInTopicItemAt(0, find.text('not mentioned'))).findsOne();
+      check(findInTopicItemAt(0, find.byType(Icons))).findsNothing();
+
+      check(findInTopicItemAt(1, find.text('1'))).findsOne();
+      check(findInTopicItemAt(1, find.text('mentioned'))).findsOne();
+      check(findInTopicItemAt(1, find.byIcon(ZulipIcons.at_sign))).findsOne();
+    });
+  });
+
+  group('topic visibility', () {
+    testWidgets('default', (tester) async {
+      final channel = eg.stream();
+      await prepare(tester, channel: channel,
+        topics: [eg.getStreamTopicsEntry(name: 'topic')]);
+
+      check(find.descendant(of: topicItemFinder,
+        matching: find.byType(Icons))).findsNothing();
+    });
+
+    testWidgets('muted', (tester) async {
+      final channel = eg.stream();
+      await prepare(tester, channel: channel,
+        topics: [eg.getStreamTopicsEntry(name: 'topic')],
+        userTopics: [
+          eg.userTopicItem(channel, 'topic', UserTopicVisibilityPolicy.muted),
+        ]);
+      check(find.descendant(of: topicItemFinder,
+        matching: find.byIcon(ZulipIcons.mute))).findsOne();
+    });
+
+    testWidgets('unmuted', (tester) async {
+      final channel = eg.stream();
+      await prepare(tester, channel: channel,
+        topics: [eg.getStreamTopicsEntry(name: 'topic')],
+        userTopics: [
+          eg.userTopicItem(channel, 'topic', UserTopicVisibilityPolicy.unmuted),
+        ]);
+      check(find.descendant(of: topicItemFinder,
+        matching: find.byIcon(ZulipIcons.unmute))).findsOne();
+    });
+
+    testWidgets('followed', (tester) async {
+      final channel = eg.stream();
+      await prepare(tester, channel: channel,
+        topics: [eg.getStreamTopicsEntry(name: 'topic')],
+        userTopics: [
+          eg.userTopicItem(channel, 'topic', UserTopicVisibilityPolicy.followed),
+        ]);
+      check(find.descendant(of: topicItemFinder,
+        matching: find.byIcon(ZulipIcons.follow))).findsOne();
+    });
+  });
+}
