diff --git a/lib/model/content.dart b/lib/model/content.dart
index 4a0c999002..9c37ef5b5e 100644
--- a/lib/model/content.dart
+++ b/lib/model/content.dart
@@ -6,6 +6,7 @@ import 'package:html/parser.dart';
 import '../api/model/model.dart';
 import '../api/model/submessage.dart';
 import 'code_block.dart';
+import 'katex.dart';
 
 /// A node in a parse tree for Zulip message-style content.
 ///
@@ -341,22 +342,59 @@ class CodeBlockSpanNode extends ContentNode {
 }
 
 class MathBlockNode extends BlockContentNode {
-  const MathBlockNode({super.debugHtmlNode, required this.texSource});
+  const MathBlockNode({
+    super.debugHtmlNode,
+    required this.texSource,
+    required this.nodes,
+  });
 
   final String texSource;
 
+  /// Parsed KaTeX node tree to be used for rendering the KaTeX content.
+  ///
+  /// It will be null if the parser encounters an unsupported HTML element or
+  /// CSS style, indicating that the widget should render the [texSource] as a
+  /// fallback instead.
+  final List<KatexNode>? nodes;
+
   @override
-  bool operator ==(Object other) {
-    return other is MathBlockNode && other.texSource == texSource;
+  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
+    super.debugFillProperties(properties);
+    properties.add(StringProperty('texSource', texSource));
   }
 
   @override
-  int get hashCode => Object.hash('MathBlockNode', texSource);
+  List<DiagnosticsNode> debugDescribeChildren() {
+    return nodes?.map((node) => node.toDiagnosticsNode()).toList() ?? const [];
+  }
+}
+
+class KatexNode extends ContentNode {
+  const KatexNode({
+    required this.text,
+    required this.nodes,
+    super.debugHtmlNode,
+  }) : assert((text != null) ^ (nodes != null));
+
+  /// The text this KaTeX node contains.
+  ///
+  /// It will be null if [nodes] is non-null.
+  final String? text;
+
+  /// The child nodes of this node in the KaTeX HTML tree.
+  ///
+  /// It will be null if [text] is non-null.
+  final List<KatexNode>? nodes;
 
   @override
   void debugFillProperties(DiagnosticPropertiesBuilder properties) {
     super.debugFillProperties(properties);
-    properties.add(StringProperty('texSource', texSource));
+    properties.add(StringProperty('text', text));
+  }
+
+  @override
+  List<DiagnosticsNode> debugDescribeChildren() {
+    return nodes?.map((node) => node.toDiagnosticsNode()).toList() ?? const [];
   }
 }
 
@@ -822,23 +860,25 @@ class ImageEmojiNode extends EmojiNode {
 }
 
 class MathInlineNode extends InlineContentNode {
-  const MathInlineNode({super.debugHtmlNode, required this.texSource});
+  const MathInlineNode({
+    super.debugHtmlNode,
+    required this.texSource,
+    required this.nodes,
+  });
 
   final String texSource;
-
-  @override
-  bool operator ==(Object other) {
-    return other is MathInlineNode && other.texSource == texSource;
-  }
-
-  @override
-  int get hashCode => Object.hash('MathInlineNode', texSource);
+  final List<KatexNode>? nodes;
 
   @override
   void debugFillProperties(DiagnosticPropertiesBuilder properties) {
     super.debugFillProperties(properties);
     properties.add(StringProperty('texSource', texSource));
   }
+
+  @override
+  List<DiagnosticsNode> debugDescribeChildren() {
+    return nodes?.map((node) => node.toDiagnosticsNode()).toList() ?? const [];
+  }
 }
 
 class GlobalTimeNode extends InlineContentNode {
@@ -864,59 +904,6 @@ class GlobalTimeNode extends InlineContentNode {
 
 ////////////////////////////////////////////////////////////////
 
-String? _parseMath(dom.Element element, {required bool block}) {
-  final dom.Element katexElement;
-  if (!block) {
-    assert(element.localName == 'span' && element.className == 'katex');
-
-    katexElement = element;
-  } else {
-    assert(element.localName == 'span' && element.className == 'katex-display');
-
-    if (element.nodes case [
-      dom.Element(localName: 'span', className: 'katex') && final child,
-    ]) {
-      katexElement = child;
-    } else {
-      return null;
-    }
-  }
-
-  // Expect two children span.katex-mathml, span.katex-html .
-  // For now we only care about the .katex-mathml .
-  if (katexElement.nodes case [
-    dom.Element(localName: 'span', className: 'katex-mathml', nodes: [
-      dom.Element(
-        localName: 'math',
-        namespaceUri: 'http://www.w3.org/1998/Math/MathML')
-          && final mathElement,
-    ]),
-    ...
-  ]) {
-    if (mathElement.attributes['display'] != (block ? 'block' : null)) {
-      return null;
-    }
-
-    final String texSource;
-    if (mathElement.nodes case [
-      dom.Element(localName: 'semantics', nodes: [
-        ...,
-        dom.Element(
-          localName: 'annotation',
-          attributes: {'encoding': 'application/x-tex'},
-          :final text),
-      ]),
-    ]) {
-      texSource = text.trim();
-    } else {
-      return null;
-    }
-    return texSource;
-  } else {
-    return null;
-  }
-}
-
 /// Parser for the inline-content subtrees within Zulip content HTML.
 ///
 /// The only entry point to this class is [parseBlockInline].
@@ -927,9 +914,12 @@ String? _parseMath(dom.Element element, {required bool block}) {
 class _ZulipInlineContentParser {
   InlineContentNode? parseInlineMath(dom.Element element) {
     final debugHtmlNode = kDebugMode ? element : null;
-    final texSource = _parseMath(element, block: false);
-    if (texSource == null) return null;
-    return MathInlineNode(texSource: texSource, debugHtmlNode: debugHtmlNode);
+    final parsed = parseMath(element, block: false);
+    if (parsed == null) return null;
+    return MathInlineNode(
+      texSource: parsed.texSource,
+      nodes: parsed.nodes,
+      debugHtmlNode: debugHtmlNode);
   }
 
   UserMentionNode? parseUserMention(dom.Element element) {
@@ -1631,10 +1621,11 @@ class _ZulipContentParser {
     })());
 
     final firstChild = nodes.first as dom.Element;
-    final texSource = _parseMath(firstChild, block: true);
-    if (texSource != null) {
+    final parsed = parseMath(firstChild, block: true);
+    if (parsed != null) {
       result.add(MathBlockNode(
-        texSource: texSource,
+        texSource: parsed.texSource,
+        nodes: parsed.nodes,
         debugHtmlNode: kDebugMode ? firstChild : null));
     } else {
       result.add(UnimplementedBlockContentNode(htmlNode: firstChild));
@@ -1666,10 +1657,11 @@ class _ZulipContentParser {
       if (child case dom.Text(text: '\n\n')) continue;
 
       if (child case dom.Element(localName: 'span', className: 'katex-display')) {
-        final texSource = _parseMath(child, block: true);
-        if (texSource != null) {
+        final parsed = parseMath(child, block: true);
+        if (parsed != null) {
           result.add(MathBlockNode(
-            texSource: texSource,
+            texSource: parsed.texSource,
+            nodes: parsed.nodes,
             debugHtmlNode: debugHtmlNode));
           continue;
         }
diff --git a/lib/model/katex.dart b/lib/model/katex.dart
new file mode 100644
index 0000000000..a1932c281a
--- /dev/null
+++ b/lib/model/katex.dart
@@ -0,0 +1,144 @@
+import 'package:html/dom.dart' as dom;
+
+import '../log.dart';
+import 'binding.dart';
+import 'content.dart';
+import 'settings.dart';
+
+class MathParserResult {
+  const MathParserResult({
+    required this.texSource,
+    required this.nodes,
+  });
+
+  final String texSource;
+
+  /// Parsed KaTeX node tree to be used for rendering the KaTeX content.
+  ///
+  /// It will be null if the parser encounters an unsupported HTML element or
+  /// CSS style, indicating that the widget should render the [texSource] as a
+  /// fallback instead.
+  final List<KatexNode>? nodes;
+}
+
+/// Parses the HTML spans containing KaTeX HTML tree.
+///
+/// The element should be either `<span class="katex">` if parsing
+/// inline content, otherwise `<span class="katex-display">` when
+/// parsing block content.
+///
+/// Returns null if it encounters an unexpected root KaTeX HTML element.
+MathParserResult? parseMath(dom.Element element, { required bool block }) {
+  final dom.Element katexElement;
+  if (!block) {
+    assert(element.localName == 'span' && element.className == 'katex');
+
+    katexElement = element;
+  } else {
+    assert(element.localName == 'span' && element.className == 'katex-display');
+
+    if (element.nodes case [
+      dom.Element(localName: 'span', className: 'katex') && final child,
+    ]) {
+      katexElement = child;
+    } else {
+      return null;
+    }
+  }
+
+  if (katexElement.nodes case [
+    dom.Element(localName: 'span', className: 'katex-mathml', nodes: [
+      dom.Element(
+        localName: 'math',
+        namespaceUri: 'http://www.w3.org/1998/Math/MathML')
+          && final mathElement,
+    ]),
+    dom.Element(localName: 'span', className: 'katex-html', nodes: [...])
+      && final katexHtmlElement,
+  ]) {
+    if (mathElement.attributes['display'] != (block ? 'block' : null)) {
+      return null;
+    }
+
+    final String texSource;
+    if (mathElement.nodes case [
+      dom.Element(localName: 'semantics', nodes: [
+        ...,
+        dom.Element(
+          localName: 'annotation',
+          attributes: {'encoding': 'application/x-tex'},
+          :final text),
+      ]),
+    ]) {
+      texSource = text.trim();
+    } else {
+      return null;
+    }
+
+    // The GlobalStore should be ready well before we reach the
+    // content parsing stage here, thus the `!` here.
+    final globalStore = ZulipBinding.instance.getGlobalStoreSync()!;
+    final globalSettings = globalStore.settings;
+    final flagRenderKatex =
+      globalSettings.getBool(BoolGlobalSetting.renderKatex);
+
+    List<KatexNode>? nodes;
+    if (flagRenderKatex) {
+      try {
+        nodes = _KatexParser().parseKatexHtml(katexHtmlElement);
+      } on KatexHtmlParseError catch (e, st) {
+        assert(debugLog('$e\n$st'));
+      }
+    }
+
+    return MathParserResult(nodes: nodes, texSource: texSource);
+  } else {
+    return null;
+  }
+}
+
+class _KatexParser {
+  List<KatexNode> parseKatexHtml(dom.Element element) {
+    assert(element.localName == 'span');
+    assert(element.className == 'katex-html');
+    return _parseChildSpans(element);
+  }
+
+  List<KatexNode> _parseChildSpans(dom.Element element) {
+    return List.unmodifiable(element.nodes.map((node) {
+      if (node case dom.Element(localName: 'span')) {
+        return _parseSpan(node);
+      } else {
+        throw KatexHtmlParseError();
+      }
+    }));
+  }
+
+  KatexNode _parseSpan(dom.Element element) {
+    String? text;
+    List<KatexNode>? spans;
+    if (element.nodes case [dom.Text(:final data)]) {
+      text = data;
+    } else {
+      spans = _parseChildSpans(element);
+    }
+    if (text == null && spans == null) throw KatexHtmlParseError();
+
+    return KatexNode(
+      text: text,
+      nodes: spans);
+  }
+}
+
+class KatexHtmlParseError extends Error {
+  final String? message;
+  KatexHtmlParseError([this.message]);
+
+  @override
+  String toString() {
+    if (message != null) {
+      return 'Katex HTML parse error: $message';
+    }
+    return 'Katex HTML parse error';
+  }
+}
diff --git a/lib/model/settings.dart b/lib/model/settings.dart
index dc1bdc524a..072fb8d7e3 100644
--- a/lib/model/settings.dart
+++ b/lib/model/settings.dart
@@ -110,6 +110,9 @@ enum BoolGlobalSetting {
   /// (Having one stable value in this enum is also handy for tests.)
   placeholderIgnore(GlobalSettingType.placeholder, false),
 
+  /// An experimental flag to toggle rendering KaTeX content in messages.
+  renderKatex(GlobalSettingType.experimentalFeatureFlag, false),
+
   // Former settings which might exist in the database,
   // whose names should therefore not be reused:
   // (this list is empty so far)
diff --git a/lib/widgets/content.dart b/lib/widgets/content.dart
index 873e3b3124..2bebce042d 100644
--- a/lib/widgets/content.dart
+++ b/lib/widgets/content.dart
@@ -804,11 +804,82 @@ class MathBlock extends StatelessWidget {
   @override
   Widget build(BuildContext context) {
     final contentTheme = ContentTheme.of(context);
-    return _CodeBlockContainer(
-      borderColor: contentTheme.colorMathBlockBorder,
-      child: Text.rich(TextSpan(
-        style: contentTheme.codeBlockTextStyles.plain,
-        children: [TextSpan(text: node.texSource)])));
+
+    final nodes = node.nodes;
+    if (nodes == null) {
+      return _CodeBlockContainer(
+        borderColor: contentTheme.colorMathBlockBorder,
+        child: Text.rich(TextSpan(
+          style: contentTheme.codeBlockTextStyles.plain,
+          children: [TextSpan(text: node.texSource)])));
+    }
+
+    return _Katex(inline: false, nodes: nodes);
+  }
+}
+
+class _Katex extends StatelessWidget {
+  const _Katex({
+    required this.inline,
+    required this.nodes,
+  });
+
+  final bool inline;
+  final List<KatexNode> nodes;
+
+  // Base text style from .katex class in katex.scss :
+  //   https://github.com/KaTeX/KaTeX/blob/613c3da8/src/styles/katex.scss#L13-L15
+  static const _baseKatexTextStyle = TextStyle(
+    fontSize: kBaseFontSize * 1.21,
+    fontFamily: 'KaTeX_Main',
+    height: 1.2);
+
+  @override
+  Widget build(BuildContext context) {
+    Widget widget = Text.rich(TextSpan(
+      children: List.unmodifiable(nodes.map((e) {
+        return WidgetSpan(
+          alignment: PlaceholderAlignment.baseline,
+          baseline: TextBaseline.alphabetic,
+          child: _KatexSpan(e));
+      }))));
+
+    if (!inline) {
+      widget = Center(
+        child: SingleChildScrollViewWithScrollbar(
+          scrollDirection: Axis.horizontal,
+          child: widget));
+    }
+
+    return Directionality(
+      textDirection: TextDirection.ltr,
+      child: DefaultTextStyle(
+        style: _baseKatexTextStyle.copyWith(
+          color: ContentTheme.of(context).textStylePlainParagraph.color),
+        child: widget));
+  }
+}
+
+class _KatexSpan extends StatelessWidget {
+  const _KatexSpan(this.span);
+
+  final KatexNode span;
+
+  @override
+  Widget build(BuildContext context) {
+    Widget widget = const SizedBox.shrink();
+    if (span.text != null) {
+      widget = Text(span.text!);
+    } else if (span.nodes != null && span.nodes!.isNotEmpty) {
+      widget = Text.rich(TextSpan(
+        children: List.unmodifiable(span.nodes!.map((e) {
+          return WidgetSpan(
+            alignment: PlaceholderAlignment.baseline,
+            baseline: TextBaseline.alphabetic,
+            child: _KatexSpan(e));
+        }))));
+    }
+    return widget;
   }
 }
 
@@ -1120,11 +1191,17 @@ class _InlineContentBuilder {
           child: MessageImageEmoji(node: node));
 
       case MathInlineNode():
-        return TextSpan(
-          style: widget.style
-            .merge(ContentTheme.of(_context!).textStyleInlineMath)
-            .apply(fontSizeFactor: kInlineCodeFontSizeFactor),
-          children: [TextSpan(text: node.texSource)]);
+        final nodes = node.nodes;
+        return nodes == null
+          ? TextSpan(
+              style: widget.style
+                .merge(ContentTheme.of(_context!).textStyleInlineMath)
+                .apply(fontSizeFactor: kInlineCodeFontSizeFactor),
+              children: [TextSpan(text: node.texSource)])
+          : WidgetSpan(
+              alignment: PlaceholderAlignment.baseline,
+              baseline: TextBaseline.alphabetic,
+              child: _Katex(inline: true, nodes: nodes));
 
       case GlobalTimeNode():
         return WidgetSpan(alignment: PlaceholderAlignment.middle,
diff --git a/test/model/content_test.dart b/test/model/content_test.dart
index 5a6a55698e..8fa30fefcc 100644
--- a/test/model/content_test.dart
+++ b/test/model/content_test.dart
@@ -6,7 +6,9 @@ import 'package:stack_trace/stack_trace.dart';
 import 'package:test/scaffolding.dart';
 import 'package:zulip/model/code_block.dart';
 import 'package:zulip/model/content.dart';
+import 'package:zulip/model/settings.dart';
 
+import 'binding.dart';
 import 'content_checks.dart';
 
 /// An example of Zulip content for test cases.
@@ -514,7 +516,12 @@ class ContentExample {
       '<span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow>'
         '<annotation encoding="application/x-tex"> \\lambda </annotation></semantics></math></span>'
       '<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></p>',
-    const MathInlineNode(texSource: r'\lambda'));
+    const MathInlineNode(texSource: r'\lambda', nodes: [
+      KatexNode(text: null, nodes: [
+        KatexNode(text: null, nodes: []),
+        KatexNode(text: 'λ', nodes: null),
+      ]),
+    ]));
 
   static const mathBlock = ContentExample(
     'math block',
@@ -524,7 +531,12 @@ class ContentExample {
       '<span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>λ</mi></mrow>'
         '<annotation encoding="application/x-tex">\\lambda</annotation></semantics></math></span>'
       '<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></span></p>',
-    [MathBlockNode(texSource: r'\lambda')]);
+    [MathBlockNode(texSource: r'\lambda', nodes: [
+      KatexNode(text: null, nodes: [
+        KatexNode(text: null, nodes: []),
+        KatexNode(text: 'λ', nodes: null),
+      ]),
+    ])]);
 
   static const mathBlocksMultipleInParagraph = ContentExample(
     'math blocks, multiple in paragraph',
@@ -539,8 +551,18 @@ class ContentExample {
         '<span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi></mrow>'
           '<annotation encoding="application/x-tex">b</annotation></semantics></math></span>'
         '<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>', [
-      MathBlockNode(texSource: 'a'),
-      MathBlockNode(texSource: 'b'),
+      MathBlockNode(texSource: 'a', nodes: [
+        KatexNode(text: null, nodes: [
+          KatexNode(text: null, nodes: []),
+          KatexNode(text: 'a', nodes: null),
+        ]),
+      ]),
+      MathBlockNode(texSource: 'b', nodes: [
+        KatexNode(text: null, nodes: [
+          KatexNode(text: null, nodes: []),
+          KatexNode(text: 'b', nodes: null),
+        ]),
+      ]),
     ]);
 
   static const mathBlockInQuote = ContentExample(
@@ -557,7 +579,14 @@ class ContentExample {
           '<annotation encoding="application/x-tex">\\lambda</annotation></semantics></math></span>'
         '<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">λ</span></span></span></span></span>'
       '<br>\n</p>\n</blockquote>',
-    [QuotationNode([MathBlockNode(texSource: r'\lambda')])]);
+    [QuotationNode([
+      MathBlockNode(texSource: r'\lambda', nodes: [
+        KatexNode(text: null, nodes: [
+          KatexNode(text: null, nodes: []),
+          KatexNode(text: 'λ', nodes: null),
+        ]),
+      ]),
+    ])]);
 
   static const mathBlocksMultipleInQuote = ContentExample(
     'math blocks, multiple in quote',
@@ -575,8 +604,18 @@ class ContentExample {
         '<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span>'
       '<br>\n</p>\n</blockquote>',
     [QuotationNode([
-      MathBlockNode(texSource: 'a'),
-      MathBlockNode(texSource: 'b'),
+      MathBlockNode(texSource: 'a', nodes: [
+        KatexNode(text: null, nodes: [
+          KatexNode(text: null, nodes: []),
+          KatexNode(text: 'a', nodes: null),
+        ]),
+      ]),
+      MathBlockNode(texSource: 'b', nodes: [
+        KatexNode(text: null, nodes: [
+          KatexNode(text: null, nodes: []),
+          KatexNode(text: 'b', nodes: null),
+        ]),
+      ]),
     ])]);
 
   static const mathBlockBetweenImages = ContentExample(
@@ -604,7 +643,12 @@ class ContentExample {
           originalWidth: null,
           originalHeight: null),
       ]),
-      MathBlockNode(texSource: 'a'),
+      MathBlockNode(texSource: 'a', nodes: [
+        KatexNode(text: null, nodes: [
+          KatexNode(text: null, nodes: []),
+          KatexNode(text: 'a', nodes: null),
+        ]),
+      ]),
       ImageNodeList([
         ImageNode(
           srcUrl: '/external_content/58b0ef9a06d7bb24faec2b11df2f57f476e6f6bb/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f372f37312f5a616164706c75697a656e5f76616e5f65656e5f436c656d617469735f746578656e7369735f2532375072696e636573735f4469616e612532372e5f31382d30372d323032335f2532386163746d2e2532395f30322e6a70672f3132383070782d5a616164706c75697a656e5f76616e5f65656e5f436c656d617469735f746578656e7369735f2532375072696e636573735f4469616e612532372e5f31382d30372d323032335f2532386163746d2e2532395f30322e6a7067',
@@ -1375,7 +1419,7 @@ void testParseExample(ContentExample example) {
   testParse('parse ${example.description}', example.html, example.expectedNodes);
 }
 
-void main() {
+void main() async {
   // When writing test cases in this file:
   //
   //  * Prefer to add a [ContentExample] static and use [testParseExample].
@@ -1384,6 +1428,12 @@ void main() {
   //
   //  * To write the example, see comment at top of [ContentExample].
 
+  TestZulipBinding.ensureInitialized();
+
+  // We need this to be able to test the currently experimental KaTeX code.
+  await testBinding.globalStore.settings.setBool(
+    BoolGlobalSetting.renderKatex, true);
+
   //
   // Inline content.
   //
diff --git a/test/widgets/content_test.dart b/test/widgets/content_test.dart
index f7941bc6df..3bfbe26d63 100644
--- a/test/widgets/content_test.dart
+++ b/test/widgets/content_test.dart
@@ -22,6 +22,7 @@ import '../example_data.dart' as eg;
 import '../flutter_checks.dart';
 import '../model/binding.dart';
 import '../model/content_test.dart';
+import '../model/store_checks.dart';
 import '../model/test_store.dart';
 import '../stdlib_checks.dart';
 import '../test_images.dart';
@@ -553,7 +554,24 @@ void main() {
       styleFinder: (tester) => mergedStyleOf(tester, 'A')!);
   });
 
-  testContentSmoke(ContentExample.mathBlock);
+  group('MathBlock', () {
+    testContentSmoke(ContentExample.mathBlock);
+
+    testWidgets('displays KaTeX source; experimental flag default', (tester) async {
+      await prepareContent(tester, plainContent(ContentExample.mathBlock.html));
+      tester.widget(find.text(r'\lambda', findRichText: true));
+    });
+
+    testWidgets('displays KaTeX content; experimental flag enabled', (tester) async {
+      addTearDown(testBinding.reset);
+      final globalSettings = testBinding.globalStore.settings;
+      await globalSettings.setBool(BoolGlobalSetting.renderKatex, true);
+      check(globalSettings).getBool(BoolGlobalSetting.renderKatex).isTrue();
+
+      await prepareContent(tester, plainContent(ContentExample.mathBlock.html));
+      tester.widget(find.text('λ', findRichText: true));
+    });
+  });
 
   /// Make a [TargetFontSizeFinder] to pass to [checkFontSizeRatio],
   /// from a target [Pattern] (such as a string).
@@ -969,6 +987,21 @@ void main() {
         targetHtml: html,
         targetFontSizeFinder: mkTargetFontSizeFinderFromPattern(r'\lambda'));
     });
+
+    testWidgets('displays KaTeX source; experimental flag default', (tester) async {
+      await prepareContent(tester, plainContent(ContentExample.mathInline.html));
+      tester.widget(find.text(r'\lambda', findRichText: true));
+    });
+
+    testWidgets('displays KaTeX content; experimental flag enabled', (tester) async {
+      addTearDown(testBinding.reset);
+      final globalSettings = testBinding.globalStore.settings;
+      await globalSettings.setBool(BoolGlobalSetting.renderKatex, true);
+      check(globalSettings.getBool(BoolGlobalSetting.renderKatex)).isTrue();
+
+      await prepareContent(tester, plainContent(ContentExample.mathInline.html));
+      tester.widget(find.text('λ', findRichText: true));
+    });
   });
 
   group('GlobalTime', () {
diff --git a/tools/content/unimplemented_features_test.dart b/tools/content/unimplemented_features_test.dart
index 5ef4a7493b..446cb962dd 100644
--- a/tools/content/unimplemented_features_test.dart
+++ b/tools/content/unimplemented_features_test.dart
@@ -12,6 +12,7 @@ import 'package:flutter/foundation.dart';
 import 'package:flutter_test/flutter_test.dart';
 import 'package:zulip/model/content.dart';
 
+import '../../test/model/binding.dart';
 import 'model.dart';
 
 /// Check if there are unimplemented features from the given corpora of HTML
@@ -33,6 +34,11 @@ import 'model.dart';
 /// * lib/model/content.dart, which implements of the content parser.
 /// * tools/content/fetch_messages.dart, which produces the corpora.
 void main() async {
+  // Parsing the HTML content depends on `ZulipBinding` being initialized,
+  // specifically KaTeX content parser retrieves the `GlobalSettings` to
+  // for the experimental flag.
+  TestZulipBinding.ensureInitialized();
+
   Future<void> checkForUnimplementedFeaturesInFile(File file) async {
     final messageIdsByFeature = <String, Set<int>>{};
     final contentsByFeature = <String, List<String>>{};
