diff --git a/packages/smooth_app/lib/background/background_task.dart b/packages/smooth_app/lib/background/background_task.dart
index beea2fc1ab6d..cccbe597bec6 100644
--- a/packages/smooth_app/lib/background/background_task.dart
+++ b/packages/smooth_app/lib/background/background_task.dart
@@ -109,7 +109,7 @@ abstract class BackgroundTask {
     final State<StatefulWidget>? widget,
     final bool showSnackBar = true,
   }) async {
-    await BackgroundTaskManager(localDatabase).add(this);
+    await BackgroundTaskManager.getInstance(localDatabase).add(this);
     if (widget == null || !widget.mounted) {
       return;
     }
@@ -144,4 +144,10 @@ abstract class BackgroundTask {
   /// successfully completing the upload task, the transient file - that is just
   /// a static variable - won't be there at app restart. Unless you recover.
   Future<void> recover(final LocalDatabase localDatabase) async {}
+
+  /// Returns true if the task ends calling another task for immediate exec.
+  ///
+  /// We return true only in rare cases. Typically, when we split an task in
+  /// subtasks that call the next one at the end.
+  bool get hasImmediateNextTask => false;
 }
diff --git a/packages/smooth_app/lib/background/background_task_crop.dart b/packages/smooth_app/lib/background/background_task_crop.dart
index 91071dd91cb6..e5be1c95cf40 100644
--- a/packages/smooth_app/lib/background/background_task_crop.dart
+++ b/packages/smooth_app/lib/background/background_task_crop.dart
@@ -8,7 +8,7 @@ import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task_barcode.dart';
 import 'package:smooth_app/background/background_task_refresh_later.dart';
 import 'package:smooth_app/background/background_task_upload.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/query/product_query.dart';
 
@@ -66,7 +66,7 @@ class BackgroundTaskCrop extends BackgroundTaskUpload {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      barcode,
+      barcode: barcode,
     );
     final BackgroundTaskBarcode task = _getNewTask(
       language,
diff --git a/packages/smooth_app/lib/background/background_task_details.dart b/packages/smooth_app/lib/background/background_task_details.dart
index 397a17ddeb05..81aeb7d995cd 100644
--- a/packages/smooth_app/lib/background/background_task_details.dart
+++ b/packages/smooth_app/lib/background/background_task_details.dart
@@ -5,7 +5,7 @@ import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task_barcode.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/query/product_query.dart';
 
@@ -76,7 +76,7 @@ class BackgroundTaskDetails extends BackgroundTaskBarcode {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      minimalistProduct.barcode!,
+      barcode: minimalistProduct.barcode,
     );
     final BackgroundTaskBarcode task = _getNewTask(
       minimalistProduct,
diff --git a/packages/smooth_app/lib/background/background_task_download_products.dart b/packages/smooth_app/lib/background/background_task_download_products.dart
new file mode 100644
index 000000000000..3fb43710eb1e
--- /dev/null
+++ b/packages/smooth_app/lib/background/background_task_download_products.dart
@@ -0,0 +1,176 @@
+import 'dart:convert';
+
+import 'package:flutter_gen/gen_l10n/app_localizations.dart';
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:smooth_app/background/background_task.dart';
+import 'package:smooth_app/background/background_task_progressing.dart';
+import 'package:smooth_app/background/operation_type.dart';
+import 'package:smooth_app/database/dao_product.dart';
+import 'package:smooth_app/database/dao_work_barcode.dart';
+import 'package:smooth_app/database/local_database.dart';
+import 'package:smooth_app/query/product_query.dart';
+
+/// Background progressing task about downloading products.
+class BackgroundTaskDownloadProducts extends BackgroundTaskProgressing {
+  BackgroundTaskDownloadProducts._({
+    required super.processName,
+    required super.uniqueId,
+    required super.languageCode,
+    required super.user,
+    required super.country,
+    required super.stamp,
+    required super.work,
+    required super.pageSize,
+    required super.totalSize,
+    required this.downloadFlag,
+  });
+
+  BackgroundTaskDownloadProducts.fromJson(Map<String, dynamic> json)
+      : downloadFlag = json[_jsonTagDownloadFlag] as int,
+        super.fromJson(json);
+
+  /// Download flag. Normal case: 0, meaning all fields are downloaded.
+  final int downloadFlag;
+
+  /// Download flag mask: exclude the Knowledge Panels field from the download.
+  static const int flagMaskExcludeKP = 1;
+
+  static const String _jsonTagDownloadFlag = 'download_flag';
+
+  @override
+  Map<String, dynamic> toJson() {
+    final Map<String, dynamic> result = super.toJson();
+    result[_jsonTagDownloadFlag] = downloadFlag;
+    return result;
+  }
+
+  static const OperationType _operationType = OperationType.offlineProducts;
+
+  static Future<void> addTask({
+    required final LocalDatabase localDatabase,
+    required final String work,
+    required final int pageSize,
+    required final int totalSize,
+    required final int soFarSize,
+    required final int downloadFlag,
+  }) async {
+    final String uniqueId = await _operationType.getNewKey(
+      localDatabase,
+      soFarSize: soFarSize,
+      totalSize: totalSize,
+      work: work,
+    );
+    final BackgroundTask task = _getNewTask(
+      uniqueId,
+      work,
+      pageSize,
+      totalSize,
+      downloadFlag,
+    );
+    await task.addToManager(localDatabase);
+  }
+
+  @override
+  String? getSnackBarMessage(final AppLocalizations appLocalizations) => null;
+
+  static BackgroundTask _getNewTask(
+    final String uniqueId,
+    final String work,
+    final int pageSize,
+    final int totalSize,
+    final int downloadFlag,
+  ) =>
+      BackgroundTaskDownloadProducts._(
+        processName: _operationType.processName,
+        uniqueId: uniqueId,
+        languageCode: ProductQuery.getLanguage().offTag,
+        user: jsonEncode(ProductQuery.getUser().toJson()),
+        country: ProductQuery.getCountry()!.offTag,
+        stamp: ';offlineProducts;$work',
+        work: work,
+        pageSize: pageSize,
+        totalSize: totalSize,
+        downloadFlag: downloadFlag,
+      );
+
+  @override
+  Future<void> preExecute(final LocalDatabase localDatabase) async {}
+
+  @override
+  bool hasImmediateNextTask = false;
+
+  @override
+  Future<void> execute(final LocalDatabase localDatabase) async {
+    final DaoWorkBarcode daoWorkBarcode = DaoWorkBarcode(localDatabase);
+    final List<String> barcodes = await daoWorkBarcode.getNextPage(
+      work,
+      pageSize,
+    );
+    if (barcodes.isEmpty) {
+      // we're done!
+      return;
+    }
+    final List<ProductField> fields = List<ProductField>.from(
+      ProductQuery.fields,
+      growable: true,
+    );
+    if (downloadFlag & flagMaskExcludeKP != 0) {
+      fields.remove(ProductField.KNOWLEDGE_PANELS);
+    }
+    final SearchResult searchResult = await OpenFoodAPIClient.searchProducts(
+      ProductQuery.getUser(),
+      ProductSearchQueryConfiguration(
+        fields: fields,
+        parametersList: <Parameter>[
+          PageSize(size: pageSize),
+          const PageNumber(page: 1),
+          BarcodeParameter.list(barcodes),
+        ],
+        language: ProductQuery.getLanguage(),
+        country: ProductQuery.getCountry(),
+        version: ProductQuery.productQueryVersion,
+      ),
+    );
+    final List<Product>? downloadedProducts = searchResult.products;
+    if (downloadedProducts == null) {
+      throw Exception('Something bad happened downloading products');
+    }
+    final DaoProduct daoProduct = DaoProduct(localDatabase);
+    for (final Product product in downloadedProducts) {
+      if (await _shouldBeUpdated(daoProduct, product.barcode!)) {
+        await daoProduct.put(product);
+      }
+    }
+    final int deleted = await daoWorkBarcode.deleteBarcodes(work, barcodes);
+    if (deleted == 0) {
+      // for some reason, it's already been taken care of.
+      return;
+    }
+    final int remaining = await daoWorkBarcode.getCount(work);
+    if (remaining > 0) {
+      hasImmediateNextTask = true;
+      await addTask(
+        localDatabase: localDatabase,
+        work: work,
+        pageSize: pageSize,
+        totalSize: totalSize,
+        soFarSize: totalSize - remaining,
+        downloadFlag: downloadFlag,
+      );
+    }
+  }
+
+  /// Returns true if we should save the downloaded data into the local db.
+  ///
+  /// That happens in two cases:
+  /// * we don't have a corresponding local product yet
+  /// * the product we already have locally does not have populated knowledge
+  /// panel fields (therefore we won't "erase" any local Knowledge Panels data)
+  static Future<bool> _shouldBeUpdated(
+    final DaoProduct daoProduct,
+    final String barcode,
+  ) async {
+    final Product? product = await daoProduct.get(barcode);
+    return product == null || product.knowledgePanels == null;
+  }
+}
diff --git a/packages/smooth_app/lib/background/background_task_full_refresh.dart b/packages/smooth_app/lib/background/background_task_full_refresh.dart
index ec2ecd5e35f1..3ffc0cd91a8d 100644
--- a/packages/smooth_app/lib/background/background_task_full_refresh.dart
+++ b/packages/smooth_app/lib/background/background_task_full_refresh.dart
@@ -5,14 +5,17 @@ import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/background_task_download_products.dart';
+import 'package:smooth_app/background/background_task_paged.dart';
+import 'package:smooth_app/background/background_task_progressing.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/dao_product.dart';
+import 'package:smooth_app/database/dao_work_barcode.dart';
 import 'package:smooth_app/database/local_database.dart';
-import 'package:smooth_app/pages/product/common/product_refresher.dart';
 import 'package:smooth_app/query/product_query.dart';
 
 /// Background task about refreshing all the already downloaded products.
-class BackgroundTaskFullRefresh extends BackgroundTask {
+class BackgroundTaskFullRefresh extends BackgroundTaskPaged {
   BackgroundTaskFullRefresh._({
     required super.processName,
     required super.uniqueId,
@@ -20,6 +23,7 @@ class BackgroundTaskFullRefresh extends BackgroundTask {
     required super.user,
     required super.country,
     required super.stamp,
+    required super.pageSize,
   });
 
   BackgroundTaskFullRefresh.fromJson(Map<String, dynamic> json)
@@ -27,28 +31,28 @@ class BackgroundTaskFullRefresh extends BackgroundTask {
 
   static const OperationType _operationType = OperationType.fullRefresh;
 
-  static const String noBarcode = 'NO_BARCODE';
-
   static Future<void> addTask({
     required final State<StatefulWidget> widget,
+    required final int pageSize,
   }) async {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      noBarcode,
     );
     final BackgroundTask task = _getNewTask(
       uniqueId,
+      pageSize,
     );
     await task.addToManager(localDatabase, widget: widget);
   }
 
   @override
   String? getSnackBarMessage(final AppLocalizations appLocalizations) =>
-      'Starting the refresh of all the products locally stored'; // TODO(monsieurtanuki): localize
+      appLocalizations.background_task_title_full_refresh;
 
   static BackgroundTaskFullRefresh _getNewTask(
     final String uniqueId,
+    final int pageSize,
   ) =>
       BackgroundTaskFullRefresh._(
         processName: _operationType.processName,
@@ -57,11 +61,17 @@ class BackgroundTaskFullRefresh extends BackgroundTask {
         user: jsonEncode(ProductQuery.getUser().toJson()),
         country: ProductQuery.getCountry()!.offTag,
         stamp: ';fullRefresh',
+        pageSize: pageSize,
       );
 
   @override
   Future<void> execute(final LocalDatabase localDatabase) async {
     final DaoProduct daoProduct = DaoProduct(localDatabase);
+    final DaoWorkBarcode daoWorkBarcode = DaoWorkBarcode(localDatabase);
+
+    await daoWorkBarcode
+        .deleteWork(BackgroundTaskProgressing.workFreshWithoutKP);
+    await daoWorkBarcode.deleteWork(BackgroundTaskProgressing.workFreshWithKP);
 
     // We separate the products into two lists, products with or without
     // knowledge panels
@@ -75,32 +85,26 @@ class BackgroundTaskFullRefresh extends BackgroundTask {
         productsWithKP.add(barcode);
       }
     }
-    if (productsWithoutKP.isNotEmpty) {
-      final List<ProductField> fieldsWithoutKP = List<ProductField>.from(
-        ProductQuery.fields,
-        growable: true,
-      );
-      fieldsWithoutKP.remove(ProductField.KNOWLEDGE_PANELS);
-
-      await _loadProducts(
-        barcodes: productsWithoutKP,
-        fields: fieldsWithoutKP,
-        daoProduct: daoProduct,
-      );
-    }
-
-    if (productsWithKP.isNotEmpty) {
-      await _loadProducts(
-        barcodes: productsWithKP,
-        fields: ProductQuery.fields,
-        daoProduct: daoProduct,
-      );
-    }
+    await _startDownloadTask(
+      barcodes: productsWithoutKP,
+      work: BackgroundTaskProgressing.workFreshWithoutKP,
+      localDatabase: localDatabase,
+      downloadFlag: BackgroundTaskDownloadProducts.flagMaskExcludeKP,
+    );
+    await _startDownloadTask(
+      barcodes: productsWithKP,
+      work: BackgroundTaskProgressing.workFreshWithKP,
+      localDatabase: localDatabase,
+      downloadFlag: 0,
+    );
   }
 
   @override
   Future<void> preExecute(final LocalDatabase localDatabase) async {}
 
+  @override
+  bool hasImmediateNextTask = false;
+
   /// Returns true if we should download data without KP.
   ///
   /// That happens in one case:
@@ -114,22 +118,25 @@ class BackgroundTaskFullRefresh extends BackgroundTask {
     return product != null && product.knowledgePanels == null;
   }
 
-  // TODO(monsieurtanuki): split (by 100 barcodes?) and loop
-  Future<void> _loadProducts({
+  Future<void> _startDownloadTask({
     required final List<String> barcodes,
-    required final List<ProductField> fields,
-    required final DaoProduct daoProduct,
+    required final String work,
+    required final LocalDatabase localDatabase,
+    required final int downloadFlag,
   }) async {
-    final SearchResult result = await OpenFoodAPIClient.searchProducts(
-      ProductQuery.getUser(),
-      ProductRefresher().getBarcodeListQueryConfiguration(
-        barcodes,
-        fields: fields,
-      ),
-    );
-    final List<Product>? downloadedProducts = result.products;
-    if (downloadedProducts?.isNotEmpty == true) {
-      await daoProduct.putAll(downloadedProducts!);
+    if (barcodes.isEmpty) {
+      return;
     }
+    hasImmediateNextTask = true;
+    final DaoWorkBarcode daoWorkBarcode = DaoWorkBarcode(localDatabase);
+    await daoWorkBarcode.putAll(work, barcodes);
+    await BackgroundTaskDownloadProducts.addTask(
+      localDatabase: localDatabase,
+      work: work,
+      pageSize: pageSize,
+      totalSize: barcodes.length,
+      soFarSize: 0,
+      downloadFlag: downloadFlag,
+    );
   }
 }
diff --git a/packages/smooth_app/lib/background/background_task_hunger_games.dart b/packages/smooth_app/lib/background/background_task_hunger_games.dart
index 5b44aa3118cf..1df6e128f996 100644
--- a/packages/smooth_app/lib/background/background_task_hunger_games.dart
+++ b/packages/smooth_app/lib/background/background_task_hunger_games.dart
@@ -5,7 +5,7 @@ import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task_barcode.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/helpers/robotoff_insight_helper.dart';
 import 'package:smooth_app/query/product_query.dart';
@@ -55,7 +55,7 @@ class BackgroundTaskHungerGames extends BackgroundTaskBarcode {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      barcode,
+      barcode: barcode,
     );
     final BackgroundTaskBarcode task = _getNewTask(
       barcode,
diff --git a/packages/smooth_app/lib/background/background_task_image.dart b/packages/smooth_app/lib/background/background_task_image.dart
index 0aca280a0f76..f72be4164f88 100644
--- a/packages/smooth_app/lib/background/background_task_image.dart
+++ b/packages/smooth_app/lib/background/background_task_image.dart
@@ -12,7 +12,7 @@ import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task_barcode.dart';
 import 'package:smooth_app/background/background_task_refresh_later.dart';
 import 'package:smooth_app/background/background_task_upload.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/data_models/up_to_date_changes.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/helpers/image_compute_container.dart';
@@ -72,7 +72,7 @@ class BackgroundTaskImage extends BackgroundTaskUpload {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      barcode,
+      barcode: barcode,
     );
     final BackgroundTaskBarcode task = _getNewTask(
       language,
diff --git a/packages/smooth_app/lib/background/background_task_manager.dart b/packages/smooth_app/lib/background/background_task_manager.dart
index f81413198253..78ce376b53d3 100644
--- a/packages/smooth_app/lib/background/background_task_manager.dart
+++ b/packages/smooth_app/lib/background/background_task_manager.dart
@@ -5,7 +5,7 @@ import 'package:flutter/rendering.dart';
 import 'package:smooth_app/background/background_task.dart';
 import 'package:smooth_app/background/background_task_image.dart';
 import 'package:smooth_app/background/background_task_refresh_later.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/dao_instant_string.dart';
 import 'package:smooth_app/database/dao_int.dart';
 import 'package:smooth_app/database/dao_string_list.dart';
@@ -14,10 +14,15 @@ import 'package:smooth_app/services/smooth_services.dart';
 
 /// Management of background tasks: single thread, block, restart, display.
 class BackgroundTaskManager {
-  BackgroundTaskManager(this.localDatabase);
+  BackgroundTaskManager._(this.localDatabase);
 
   final LocalDatabase localDatabase;
 
+  static BackgroundTaskManager? _instance;
+
+  static BackgroundTaskManager getInstance(final LocalDatabase localDatabase) =>
+      _instance ??= BackgroundTaskManager._(localDatabase);
+
   /// Returns [DaoInstantString] key for tasks.
   static String _taskIdToDaoInstantStringKey(final String taskId) =>
       'task:$taskId';
@@ -95,28 +100,32 @@ class BackgroundTaskManager {
   /// Minimum duration in millis between each run.
   static const int _minimumDurationBetweenRuns = 5 * 1000;
 
-  /// Returns true if we can run now.
-  ///
-  /// Will also set the "latest start timestamp".
-  /// With this, we can detect a run that went wrong.
-  /// Like, still running 1 hour later.
-  Future<bool> _canStartNow() async {
+  /// Returns the "now" timestamp if we can run now, or `null`.
+  int? _canStartNow() {
     final DaoInt daoInt = DaoInt(localDatabase);
     final int now = LocalDatabase.nowInMillis();
     final int? latestRunStart = daoInt.get(_lastStartTimestampKey);
     final int? latestRunStop = daoInt.get(_lastStopTimestampKey);
+    if (_running) {
+      // if pretending to be running but started a very very long time ago
+      if (latestRunStart != null &&
+          latestRunStart + _aLongEnoughTimeInMilliseconds < now) {
+        // we assume we can run now.
+        return now;
+      }
+      return null;
+    }
     // if the last run stopped correctly or was started a long time ago.
     if (latestRunStart == null ||
         latestRunStart + _aLongEnoughTimeInMilliseconds < now) {
       // if the last run stopped not enough time ago.
       if (latestRunStop != null &&
           latestRunStop + _minimumDurationBetweenRuns >= now) {
-        return false;
+        return null;
       }
-      await daoInt.put(_lastStartTimestampKey, now);
-      return true;
+      return now;
     }
-    return false;
+    return null;
   }
 
   /// Signals we've just finished working and that we're ready for a new run.
@@ -128,6 +137,8 @@ class BackgroundTaskManager {
     );
   }
 
+  bool _running = false;
+
   /// Runs all the pending tasks, and then smoothly ends.
   ///
   /// If a task fails, we continue with the other tasks: and we'll retry the
@@ -136,32 +147,49 @@ class BackgroundTaskManager {
   /// we can remove the failed task from the list: it would have been
   /// overwritten anyway.
   Future<void> run() async {
-    if (!await _canStartNow()) {
+    final int? now = _canStartNow();
+    if (now == null) {
       return;
     }
-    final List<BackgroundTask> tasks = await _getAllTasks();
-    for (final BackgroundTask task in tasks) {
-      await task.recover(localDatabase);
-    }
-    for (final BackgroundTask task in tasks) {
-      final String taskId = task.uniqueId;
-      try {
-        await _setTaskErrorStatus(taskId, taskStatusStarted);
-        await task.execute(localDatabase);
-        await _finishTask(taskId, success: true);
-      } catch (e) {
-        // Most likely, no internet, no reason to go on.
-        if (e.toString().startsWith('Failed host lookup: ')) {
-          await _setTaskErrorStatus(taskId, taskStatusNoInternet);
-          await _justFinished();
-          return;
+    _running = true;
+
+    ///
+    /// Will also set the "latest start timestamp".
+    /// With this, we can detect a run that went wrong.
+    /// Like, still running 1 hour later.
+    final DaoInt daoInt = DaoInt(localDatabase);
+    await daoInt.put(_lastStartTimestampKey, now);
+    bool runAgain = true;
+    while (runAgain) {
+      runAgain = false;
+      final List<BackgroundTask> tasks = await _getAllTasks();
+      for (final BackgroundTask task in tasks) {
+        await task.recover(localDatabase);
+      }
+      for (final BackgroundTask task in tasks) {
+        final String taskId = task.uniqueId;
+        try {
+          await _setTaskErrorStatus(taskId, taskStatusStarted);
+          await task.execute(localDatabase);
+          await _finishTask(taskId, success: true);
+          if (task.hasImmediateNextTask) {
+            runAgain = true;
+          }
+        } catch (e) {
+          // Most likely, no internet, no reason to go on.
+          if (e.toString().startsWith('Failed host lookup: ')) {
+            await _setTaskErrorStatus(taskId, taskStatusNoInternet);
+            await _justFinished();
+            return;
+          }
+          debugPrint('Background task error ($e)');
+          Logs.e('Background task error', ex: e);
+          await _setTaskErrorStatus(taskId, '$e');
         }
-        debugPrint('Background task error ($e)');
-        Logs.e('Background task error', ex: e);
-        await _setTaskErrorStatus(taskId, '$e');
       }
+      await _justFinished();
     }
-    await _justFinished();
+    _running = false;
   }
 
   Future<void> _setTaskErrorStatus(
diff --git a/packages/smooth_app/lib/background/background_task_offline.dart b/packages/smooth_app/lib/background/background_task_offline.dart
index 9c66e6ad1e18..20cf4f73bd15 100644
--- a/packages/smooth_app/lib/background/background_task_offline.dart
+++ b/packages/smooth_app/lib/background/background_task_offline.dart
@@ -2,20 +2,17 @@ import 'dart:convert';
 
 import 'package:flutter/material.dart';
 import 'package:flutter_gen/gen_l10n/app_localizations.dart';
-import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task.dart';
-import 'package:smooth_app/background/background_task_full_refresh.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
-import 'package:smooth_app/database/dao_product.dart';
+import 'package:smooth_app/background/background_task_progressing.dart';
+import 'package:smooth_app/background/background_task_top_barcodes.dart';
+import 'package:smooth_app/background/operation_type.dart';
+import 'package:smooth_app/database/dao_work_barcode.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/query/product_query.dart';
 
-/// Background task about pre-downloading top n products for offline usage.
-///
-/// For space reasons, we don't download the full products: we remove the
-/// knowledge panel fields.
-class BackgroundTaskOffline extends BackgroundTask {
+/// Main background task about pre-downloading top n products for offline usage.
+class BackgroundTaskOffline extends BackgroundTaskProgressing {
   BackgroundTaskOffline._({
     required super.processName,
     required super.uniqueId,
@@ -23,6 +20,9 @@ class BackgroundTaskOffline extends BackgroundTask {
     required super.user,
     required super.country,
     required super.stamp,
+    required super.work,
+    required super.pageSize,
+    required super.totalSize,
   });
 
   BackgroundTaskOffline.fromJson(Map<String, dynamic> json)
@@ -32,24 +32,33 @@ class BackgroundTaskOffline extends BackgroundTask {
 
   static Future<void> addTask({
     required final State<StatefulWidget> widget,
+    required final int pageSize,
+    required final int totalSize,
   }) async {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      BackgroundTaskFullRefresh.noBarcode,
+      totalSize: totalSize,
+      soFarSize: 0,
     );
     final BackgroundTask task = _getNewTask(
       uniqueId,
+      BackgroundTaskProgressing.workOffline,
+      pageSize,
+      totalSize,
     );
     await task.addToManager(localDatabase, widget: widget);
   }
 
   @override
   String? getSnackBarMessage(final AppLocalizations appLocalizations) =>
-      'Starting the download of the most popular products'; // TODO(monsieurtanuki): localize
+      appLocalizations.background_task_title_top_n;
 
   static BackgroundTaskOffline _getNewTask(
     final String uniqueId,
+    final String work,
+    final int pageSize,
+    final int totalSize,
   ) =>
       BackgroundTaskOffline._(
         processName: _operationType.processName,
@@ -58,59 +67,27 @@ class BackgroundTaskOffline extends BackgroundTask {
         user: jsonEncode(ProductQuery.getUser().toJson()),
         country: ProductQuery.getCountry()!.offTag,
         stamp: ';offline',
+        work: work,
+        pageSize: pageSize,
+        totalSize: totalSize,
       );
 
   @override
   Future<void> preExecute(final LocalDatabase localDatabase) async {}
 
+  @override
+  bool get hasImmediateNextTask => true;
+
   @override
   Future<void> execute(final LocalDatabase localDatabase) async {
-    final List<ProductField> fields = List<ProductField>.from(
-      ProductQuery.fields,
-      growable: true,
-    );
-    fields.remove(ProductField.KNOWLEDGE_PANELS);
-    // TODO(monsieurtanuki): first only the barcodes, then split (by 100 barcodes?) and loop
-    final ProductSearchQueryConfiguration queryConfig =
-        ProductSearchQueryConfiguration(
-      fields: fields,
-      parametersList: <Parameter>[
-        const PageSize(size: 1000),
-        const PageNumber(page: 1),
-        const SortBy(option: SortOption.POPULARITY),
-      ],
-      language: ProductQuery.getLanguage(),
-      country: ProductQuery.getCountry(),
-      version: ProductQuery.productQueryVersion,
-      // https://fr.openfoodfacts.org/api/v2/search?page_size=1000&fields=code
+    final DaoWorkBarcode daoWorkBarcode = DaoWorkBarcode(localDatabase);
+    await daoWorkBarcode.deleteWork(work);
+    await BackgroundTaskTopBarcodes.addTask(
+      localDatabase: localDatabase,
+      work: work,
+      pageSize: pageSize,
+      totalSize: totalSize,
+      soFarSize: 0,
     );
-    final SearchResult searchResult = await OpenFoodAPIClient.searchProducts(
-      ProductQuery.getUser(),
-      queryConfig,
-    );
-    final List<Product>? downloadedProducts = searchResult.products;
-    if (downloadedProducts == null) {
-      return;
-    }
-    final DaoProduct daoProduct = DaoProduct(localDatabase);
-    for (final Product product in downloadedProducts) {
-      if (await _shouldBeUpdated(daoProduct, product.barcode!)) {
-        await daoProduct.put(product);
-      }
-    }
-  }
-
-  /// Returns true if we should save the downloaded data into the local db.
-  ///
-  /// That happens in two cases:
-  /// * we don't have a corresponding local product yet
-  /// * the product we already have locally does not have populated knowledge
-  /// panel fields (therefore we won't "erase" any local KP data)
-  static Future<bool> _shouldBeUpdated(
-    final DaoProduct daoProduct,
-    final String barcode,
-  ) async {
-    final Product? product = await daoProduct.get(barcode);
-    return product == null || product.knowledgePanels == null;
   }
 }
diff --git a/packages/smooth_app/lib/background/background_task_paged.dart b/packages/smooth_app/lib/background/background_task_paged.dart
new file mode 100644
index 000000000000..df71ec98e51a
--- /dev/null
+++ b/packages/smooth_app/lib/background/background_task_paged.dart
@@ -0,0 +1,29 @@
+import 'package:smooth_app/background/background_task.dart';
+
+/// Abstract background task with paged actions.
+abstract class BackgroundTaskPaged extends BackgroundTask {
+  const BackgroundTaskPaged({
+    required super.processName,
+    required super.uniqueId,
+    required super.languageCode,
+    required super.user,
+    required super.country,
+    required super.stamp,
+    required this.pageSize,
+  });
+
+  BackgroundTaskPaged.fromJson(Map<String, dynamic> json)
+      : pageSize = json[_jsonTagPageSize] as int,
+        super.fromJson(json);
+
+  final int pageSize;
+
+  static const String _jsonTagPageSize = 'pageSize';
+
+  @override
+  Map<String, dynamic> toJson() {
+    final Map<String, dynamic> result = super.toJson();
+    result[_jsonTagPageSize] = pageSize;
+    return result;
+  }
+}
diff --git a/packages/smooth_app/lib/background/background_task_progressing.dart b/packages/smooth_app/lib/background/background_task_progressing.dart
new file mode 100644
index 000000000000..796984608846
--- /dev/null
+++ b/packages/smooth_app/lib/background/background_task_progressing.dart
@@ -0,0 +1,46 @@
+import 'package:smooth_app/background/background_task_paged.dart';
+
+/// Abstract background task with work in progress actions.
+abstract class BackgroundTaskProgressing extends BackgroundTaskPaged {
+  const BackgroundTaskProgressing({
+    required super.processName,
+    required super.uniqueId,
+    required super.languageCode,
+    required super.user,
+    required super.country,
+    required super.stamp,
+    required super.pageSize,
+    required this.work,
+    required this.totalSize,
+  });
+
+  BackgroundTaskProgressing.fromJson(Map<String, dynamic> json)
+      : work = json[_jsonTagWork] as String,
+        totalSize = json[_jsonTagTotalSize] as int,
+        super.fromJson(json);
+
+  final String work;
+  final int totalSize;
+
+  static const String _jsonTagWork = 'work';
+  static const String _jsonTagTotalSize = 'totalSize';
+
+  @override
+  Map<String, dynamic> toJson() {
+    final Map<String, dynamic> result = super.toJson();
+    result[_jsonTagWork] = work;
+    result[_jsonTagTotalSize] = totalSize;
+    return result;
+  }
+
+  static const String noBarcode = 'NO_BARCODE';
+
+  /// Work about downloading top products.
+  static const String workOffline = 'O';
+
+  /// Work about downloading fresh products with Knowledge Panels.
+  static const String workFreshWithKP = 'K';
+
+  /// Work about downloading fresh products without Knowledge Panels.
+  static const String workFreshWithoutKP = 'w';
+}
diff --git a/packages/smooth_app/lib/background/background_task_refresh_later.dart b/packages/smooth_app/lib/background/background_task_refresh_later.dart
index b5e5f0a23253..0b796e745791 100644
--- a/packages/smooth_app/lib/background/background_task_refresh_later.dart
+++ b/packages/smooth_app/lib/background/background_task_refresh_later.dart
@@ -2,7 +2,7 @@ import 'dart:convert';
 import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:smooth_app/background/background_task_barcode.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/query/product_query.dart';
 
@@ -57,7 +57,7 @@ class BackgroundTaskRefreshLater extends BackgroundTaskBarcode {
   }) async {
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      barcode,
+      barcode: barcode,
     );
     final BackgroundTaskBarcode task = _getNewTask(barcode, uniqueId);
     await task.addToManager(localDatabase);
diff --git a/packages/smooth_app/lib/background/background_task_top_barcodes.dart b/packages/smooth_app/lib/background/background_task_top_barcodes.dart
new file mode 100644
index 000000000000..b8c497835724
--- /dev/null
+++ b/packages/smooth_app/lib/background/background_task_top_barcodes.dart
@@ -0,0 +1,150 @@
+import 'dart:convert';
+
+import 'package:flutter_gen/gen_l10n/app_localizations.dart';
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:smooth_app/background/background_task.dart';
+import 'package:smooth_app/background/background_task_download_products.dart';
+import 'package:smooth_app/background/background_task_progressing.dart';
+import 'package:smooth_app/background/operation_type.dart';
+import 'package:smooth_app/database/dao_work_barcode.dart';
+import 'package:smooth_app/database/local_database.dart';
+import 'package:smooth_app/query/product_query.dart';
+
+/// Background progressing task about downloading top n barcodes.
+class BackgroundTaskTopBarcodes extends BackgroundTaskProgressing {
+  BackgroundTaskTopBarcodes._({
+    required super.processName,
+    required super.uniqueId,
+    required super.languageCode,
+    required super.user,
+    required super.country,
+    required super.stamp,
+    required super.work,
+    required super.pageSize,
+    required super.totalSize,
+  });
+
+  BackgroundTaskTopBarcodes.fromJson(Map<String, dynamic> json)
+      : super.fromJson(json);
+
+  static const OperationType _operationType = OperationType.offlineBarcodes;
+
+  static Future<void> addTask({
+    required final LocalDatabase localDatabase,
+    required final String work,
+    required final int pageSize,
+    required final int totalSize,
+    required final int soFarSize,
+  }) async {
+    final String uniqueId = await _operationType.getNewKey(
+      localDatabase,
+      totalSize: totalSize,
+      soFarSize: soFarSize,
+    );
+    final BackgroundTask task = _getNewTask(
+      uniqueId,
+      work,
+      pageSize,
+      totalSize,
+    );
+    await task.addToManager(localDatabase);
+  }
+
+  @override
+  String? getSnackBarMessage(final AppLocalizations appLocalizations) => null;
+
+  static BackgroundTask _getNewTask(
+    final String uniqueId,
+    final String work,
+    final int pageSize,
+    final int totalSize,
+  ) =>
+      BackgroundTaskTopBarcodes._(
+        processName: _operationType.processName,
+        uniqueId: uniqueId,
+        languageCode: ProductQuery.getLanguage().offTag,
+        user: jsonEncode(ProductQuery.getUser().toJson()),
+        country: ProductQuery.getCountry()!.offTag,
+        stamp: ';offlineBarcodes;$work',
+        work: work,
+        pageSize: pageSize,
+        totalSize: totalSize,
+      );
+
+  @override
+  Future<void> preExecute(final LocalDatabase localDatabase) async {}
+
+  @override
+  bool get hasImmediateNextTask => true;
+
+  @override
+  Future<void> execute(final LocalDatabase localDatabase) async {
+    final DaoWorkBarcode daoWorkBarcode = DaoWorkBarcode(localDatabase);
+    final int soFarBefore = await daoWorkBarcode.getCount(work);
+    if (soFarBefore >= totalSize) {
+      // not likely
+      return;
+    }
+    final bool ok = await _getBarcodes(localDatabase);
+    if (!ok) {
+      // something failed, let's get out of here.
+      return;
+    }
+    final int soFarAfter = await daoWorkBarcode.getCount(work);
+    if (soFarAfter < totalSize) {
+      await addTask(
+        localDatabase: localDatabase,
+        work: work,
+        pageSize: pageSize,
+        totalSize: totalSize,
+        soFarSize: soFarAfter,
+      );
+    } else {
+      await BackgroundTaskDownloadProducts.addTask(
+        localDatabase: localDatabase,
+        work: work,
+        pageSize: pageSize,
+        totalSize: totalSize,
+        soFarSize: 0,
+        downloadFlag: BackgroundTaskDownloadProducts.flagMaskExcludeKP,
+      );
+    }
+  }
+
+  /// Returns true if somehow we can go on with the process.
+  Future<bool> _getBarcodes(final LocalDatabase localDatabase) async {
+    final DaoWorkBarcode daoWorkBarcode = DaoWorkBarcode(localDatabase);
+    final int soFar = await daoWorkBarcode.getCount(work);
+    if (soFar >= totalSize) {
+      // we're done!
+      return true;
+    }
+    final int pageNumber = (soFar ~/ pageSize) + 1;
+    final ProductSearchQueryConfiguration queryConfig =
+        ProductSearchQueryConfiguration(
+      fields: <ProductField>[ProductField.BARCODE],
+      parametersList: <Parameter>[
+        PageSize(size: pageSize),
+        PageNumber(page: pageNumber),
+        const SortBy(option: SortOption.POPULARITY),
+      ],
+      language: ProductQuery.getLanguage(),
+      country: ProductQuery.getCountry(),
+      version: ProductQuery.productQueryVersion,
+    );
+    final SearchResult searchResult = await OpenFoodAPIClient.searchProducts(
+      ProductQuery.getUser(),
+      queryConfig,
+    );
+    if (searchResult.products == null) {
+      // not expected
+      return false;
+    }
+    final List<String> barcodes = <String>[];
+    for (final Product product in searchResult.products!) {
+      barcodes.add(product.barcode!);
+    }
+    await daoWorkBarcode.putAll(work, barcodes);
+    return true;
+  }
+}
diff --git a/packages/smooth_app/lib/background/background_task_unselect.dart b/packages/smooth_app/lib/background/background_task_unselect.dart
index 020140804449..716faaf3396c 100644
--- a/packages/smooth_app/lib/background/background_task_unselect.dart
+++ b/packages/smooth_app/lib/background/background_task_unselect.dart
@@ -7,7 +7,7 @@ import 'package:provider/provider.dart';
 import 'package:smooth_app/background/background_task_barcode.dart';
 import 'package:smooth_app/background/background_task_refresh_later.dart';
 import 'package:smooth_app/background/background_task_upload.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/database/transient_file.dart';
 import 'package:smooth_app/helpers/image_field_extension.dart';
@@ -53,7 +53,7 @@ class BackgroundTaskUnselect extends BackgroundTaskBarcode {
     final LocalDatabase localDatabase = widget.context.read<LocalDatabase>();
     final String uniqueId = await _operationType.getNewKey(
       localDatabase,
-      barcode,
+      barcode: barcode,
     );
     final BackgroundTaskBarcode task = _getNewTask(
       barcode,
diff --git a/packages/smooth_app/lib/background/background_task_upload.dart b/packages/smooth_app/lib/background/background_task_upload.dart
index 4cf07a200e55..ccdcc78189f5 100644
--- a/packages/smooth_app/lib/background/background_task_upload.dart
+++ b/packages/smooth_app/lib/background/background_task_upload.dart
@@ -26,13 +26,13 @@ abstract class BackgroundTaskUpload extends BackgroundTaskBarcode {
   });
 
   BackgroundTaskUpload.fromJson(Map<String, dynamic> json)
-      : imageField = json['imageField'] as String,
-        croppedPath = json['croppedPath'] as String,
-        rotationDegrees = json['rotation'] as int? ?? 0,
-        cropX1 = json['x1'] as int? ?? 0,
-        cropY1 = json['y1'] as int? ?? 0,
-        cropX2 = json['x2'] as int? ?? 0,
-        cropY2 = json['y2'] as int? ?? 0,
+      : imageField = json[_jsonTagImageField] as String,
+        croppedPath = json[_jsonTagCroppedPath] as String,
+        rotationDegrees = json[_jsonTagRotation] as int? ?? 0,
+        cropX1 = json[_jsonTagX1] as int? ?? 0,
+        cropY1 = json[_jsonTagY1] as int? ?? 0,
+        cropX2 = json[_jsonTagX2] as int? ?? 0,
+        cropY2 = json[_jsonTagY2] as int? ?? 0,
         super.fromJson(json);
 
   final String imageField;
diff --git a/packages/smooth_app/lib/data_models/operation_type.dart b/packages/smooth_app/lib/background/operation_type.dart
similarity index 72%
rename from packages/smooth_app/lib/data_models/operation_type.dart
rename to packages/smooth_app/lib/background/operation_type.dart
index 219443c034e6..51ee554bee43 100644
--- a/packages/smooth_app/lib/data_models/operation_type.dart
+++ b/packages/smooth_app/lib/background/operation_type.dart
@@ -2,11 +2,14 @@ import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:smooth_app/background/background_task.dart';
 import 'package:smooth_app/background/background_task_crop.dart';
 import 'package:smooth_app/background/background_task_details.dart';
+import 'package:smooth_app/background/background_task_download_products.dart';
 import 'package:smooth_app/background/background_task_full_refresh.dart';
 import 'package:smooth_app/background/background_task_hunger_games.dart';
 import 'package:smooth_app/background/background_task_image.dart';
 import 'package:smooth_app/background/background_task_offline.dart';
+import 'package:smooth_app/background/background_task_progressing.dart';
 import 'package:smooth_app/background/background_task_refresh_later.dart';
+import 'package:smooth_app/background/background_task_top_barcodes.dart';
 import 'package:smooth_app/background/background_task_unselect.dart';
 import 'package:smooth_app/database/dao_int.dart';
 import 'package:smooth_app/database/dao_transient_operation.dart';
@@ -27,6 +30,8 @@ enum OperationType {
   hungerGames('H', 'HUNGER_GAMES'),
   refreshLater('R', 'PRODUCT_REFRESH_LATER'),
   offline('O', 'OFFLINE_PREDOWNLOAD'),
+  offlineBarcodes('B', 'OFFLINE_BARCODES'),
+  offlineProducts('P', 'OFFLINE_PRODUCTS'),
   fullRefresh('F', 'FULL_REFRESH'),
   details('D', 'PRODUCT_EDIT');
 
@@ -42,14 +47,20 @@ enum OperationType {
   static const String _uniqueSequenceKey = 'OperationType';
 
   Future<String> getNewKey(
-    final LocalDatabase localDatabase,
-    final String barcode,
-  ) async {
+    final LocalDatabase localDatabase, {
+    final String? barcode = BackgroundTaskProgressing.noBarcode,
+    final int? totalSize,
+    final int? soFarSize,
+    final String? work,
+  }) async {
     final int sequentialId =
         await getNextSequenceNumber(DaoInt(localDatabase), _uniqueSequenceKey);
     return '$header'
         '$_transientHeaderSeparator$sequentialId'
-        '$_transientHeaderSeparator$barcode';
+        '$_transientHeaderSeparator$barcode'
+        '$_transientHeaderSeparator${totalSize == null ? '' : totalSize.toString()}'
+        '$_transientHeaderSeparator${soFarSize == null ? '' : soFarSize.toString()}'
+        '$_transientHeaderSeparator${work ?? ''}';
   }
 
   BackgroundTask fromJson(Map<String, dynamic> map) {
@@ -68,6 +79,10 @@ enum OperationType {
         return BackgroundTaskUnselect.fromJson(map);
       case offline:
         return BackgroundTaskOffline.fromJson(map);
+      case offlineBarcodes:
+        return BackgroundTaskTopBarcodes.fromJson(map);
+      case offlineProducts:
+        return BackgroundTaskDownloadProducts.fromJson(map);
       case fullRefresh:
         return BackgroundTaskFullRefresh.fromJson(map);
     }
@@ -92,6 +107,10 @@ enum OperationType {
         return 'Waiting 10 min before refreshing product to get all automatic edits';
       case OperationType.offline:
         return 'Downloading top n products for offline usage';
+      case OperationType.offlineBarcodes:
+        return 'Downloading top n barcodes';
+      case OperationType.offlineProducts:
+        return 'Downloading products';
       case OperationType.fullRefresh:
         return 'Refreshing the full local database';
     }
@@ -108,6 +127,30 @@ enum OperationType {
     return keyItems[2];
   }
 
+  static int? getTotalSize(final String key) {
+    final List<String> keyItems = key.split(_transientHeaderSeparator);
+    if (keyItems.length <= 3) {
+      return null;
+    }
+    return int.tryParse(keyItems[3]);
+  }
+
+  static int? getSoFarSize(final String key) {
+    final List<String> keyItems = key.split(_transientHeaderSeparator);
+    if (keyItems.length <= 4) {
+      return null;
+    }
+    return int.tryParse(keyItems[4]);
+  }
+
+  static String? getWork(final String key) {
+    final List<String> keyItems = key.split(_transientHeaderSeparator);
+    if (keyItems.length <= 5) {
+      return null;
+    }
+    return keyItems[5];
+  }
+
   static OperationType? getOperationType(final String key) {
     final List<String> keyItems = key.split(_transientHeaderSeparator);
     final String find = keyItems[0];
diff --git a/packages/smooth_app/lib/data_models/up_to_date_changes.dart b/packages/smooth_app/lib/data_models/up_to_date_changes.dart
index 7fcd80efa792..d46cf4df2f7d 100644
--- a/packages/smooth_app/lib/data_models/up_to_date_changes.dart
+++ b/packages/smooth_app/lib/data_models/up_to_date_changes.dart
@@ -1,5 +1,5 @@
 import 'package:openfoodfacts/openfoodfacts.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/dao_transient_operation.dart';
 import 'package:smooth_app/database/local_database.dart';
 
diff --git a/packages/smooth_app/lib/database/dao_work_barcode.dart b/packages/smooth_app/lib/database/dao_work_barcode.dart
new file mode 100644
index 000000000000..cde4b8fd200c
--- /dev/null
+++ b/packages/smooth_app/lib/database/dao_work_barcode.dart
@@ -0,0 +1,178 @@
+import 'dart:async';
+
+import 'package:smooth_app/database/abstract_sql_dao.dart';
+import 'package:smooth_app/database/bulk_manager.dart';
+import 'package:sqflite/sqflite.dart';
+
+/// Work table that contains barcodes.
+///
+/// The typical use case is for bulk product downloads.
+/// The first step would be to populate this table with the barcodes you're
+/// interested in, e.g. all the local barcodes or the top 1k barcodes.
+/// The second step would be to download the products referenced in that table.
+class DaoWorkBarcode extends AbstractSqlDao {
+  DaoWorkBarcode(super.localDatabase);
+
+  static const String _table = 'work_barcode';
+  static const String _columnWork = 'work';
+  static const String _columnBarcode = 'barcode';
+
+  static const List<String> _columns = <String>[
+    _columnWork,
+    _columnBarcode,
+  ];
+
+  static FutureOr<void> onUpgrade(
+    final Database db,
+    final int oldVersion,
+    final int newVersion,
+  ) async {
+    if (oldVersion < 3) {
+      await db.execute('create table $_table('
+          '$_columnWork TEXT NOT NULL'
+          ',$_columnBarcode TEXT NOT NULL'
+          // cf. https://www.sqlite.org/lang_conflict.html
+          ',PRIMARY KEY($_columnWork,$_columnBarcode) on conflict replace'
+          ')');
+    }
+  }
+
+  /// Returns the number of barcodes for that work.
+  Future<int> getCount(final String work) async {
+    final List<Map<String, dynamic>> queryResults =
+        await localDatabase.database.query(
+      _table,
+      columns: <String>['count(1) as my_count'],
+      where: '$_columnWork = ?',
+      whereArgs: <String>[work],
+    );
+    for (final Map<String, dynamic> row in queryResults) {
+      return row['my_count'] as int;
+    }
+    throw Exception('Cannot count table $_table for work $work');
+  }
+
+  /// Returns the next barcodes for that work.
+  Future<List<String>> getNextPage(
+    final String work,
+    final int pageSize,
+  ) async {
+    final List<String> result = <String>[];
+    final List<Map<String, dynamic>> queryResults =
+        await localDatabase.database.query(
+      _table,
+      columns: <String>[_columnBarcode],
+      where: '$_columnWork = ?',
+      whereArgs: <String>[work],
+      limit: pageSize,
+    );
+    for (final Map<String, dynamic> row in queryResults) {
+      result.add(row[_columnBarcode] as String);
+    }
+    return result;
+  }
+
+  /// Returns the number of inserted rows.
+  Future<int> putAll(
+    final String work,
+    final Iterable<String> barcodes,
+  ) async =>
+      localDatabase.database.transaction(
+        (final Transaction transaction) async =>
+            _bulkInsert(transaction, work, barcodes),
+      );
+
+  /// Returns the number of inserted rows by optimized bulk insert.
+  Future<int> _bulkInsert(
+    final DatabaseExecutor databaseExecutor,
+    final String work,
+    final Iterable<String> barcodes,
+  ) async {
+    if (barcodes.isEmpty) {
+      return 0;
+    }
+    final List<String> parameters = <String>[];
+    int count = 0;
+
+    Future<void> rawInsert() async {
+      final int inserted = await databaseExecutor.rawInsert(
+        'insert into $_table(${_columns.join(',')}) '
+        'values(?,?)${',(?,?)' * (parameters.length ~/ 2 - 1)}',
+        parameters,
+      );
+      count += inserted;
+    }
+
+    for (final String barcode in barcodes) {
+      parameters.add(work);
+      parameters.add(barcode);
+      if (parameters.length + 2 >= BulkManager.SQLITE_MAX_VARIABLE_NUMBER) {
+        await rawInsert();
+        parameters.clear();
+      }
+    }
+    if (parameters.isNotEmpty) {
+      await rawInsert();
+    }
+    return count;
+  }
+
+  /// Deletes all barcodes for a given work.
+  ///
+  /// Returns the number of rows deleted.
+  Future<int> deleteWork(final String work) async =>
+      localDatabase.database.delete(
+        _table,
+        where: '$_columnWork = ?',
+        whereArgs: <String>[work],
+      );
+
+  /// Deletes all barcodes for a given work.
+  ///
+  /// Returns the number of rows deleted.
+  Future<int> deleteBarcodes(
+    final String work,
+    final Iterable<String> barcodes,
+  ) async =>
+      localDatabase.database.transaction(
+        (final Transaction transaction) async =>
+            _bulkDelete(transaction, work, barcodes),
+      );
+
+  /// Returns the number of deleted rows by optimized bulk delete.
+  Future<int> _bulkDelete(
+    final DatabaseExecutor databaseExecutor,
+    final String work,
+    final Iterable<String> barcodes,
+  ) async {
+    if (barcodes.isEmpty) {
+      return 0;
+    }
+    final List<String> parameters = <String>[];
+    int count = 0;
+
+    Future<void> rawDelete() async {
+      final int deleted = await databaseExecutor.delete(
+        _table,
+        where: '$_columnWork = ? '
+            'and $_columnBarcode in(?${',?' * (parameters.length - 2)})',
+        whereArgs: parameters,
+      );
+      count += deleted;
+    }
+
+    parameters.add(work);
+    for (final String barcode in barcodes) {
+      parameters.add(barcode);
+      if (parameters.length + 1 >= BulkManager.SQLITE_MAX_VARIABLE_NUMBER) {
+        await rawDelete();
+        parameters.clear();
+        parameters.add(work);
+      }
+    }
+    if (parameters.isNotEmpty) {
+      await rawDelete();
+    }
+    return count;
+  }
+}
diff --git a/packages/smooth_app/lib/database/local_database.dart b/packages/smooth_app/lib/database/local_database.dart
index 841edfc428a6..cab27cba19bb 100644
--- a/packages/smooth_app/lib/database/local_database.dart
+++ b/packages/smooth_app/lib/database/local_database.dart
@@ -19,6 +19,7 @@ import 'package:smooth_app/database/dao_string_list.dart';
 import 'package:smooth_app/database/dao_string_list_map.dart';
 import 'package:smooth_app/database/dao_transient_operation.dart';
 import 'package:smooth_app/database/dao_unzipped_product.dart';
+import 'package:smooth_app/database/dao_work_barcode.dart';
 import 'package:sqflite/sqflite.dart';
 
 class LocalDatabase extends ChangeNotifier {
@@ -35,7 +36,7 @@ class LocalDatabase extends ChangeNotifier {
 
   @override
   void notifyListeners() {
-    BackgroundTaskManager(this).run(); // no await
+    BackgroundTaskManager.getInstance(this).run(); // no await
     super.notifyListeners();
   }
 
@@ -58,7 +59,7 @@ class LocalDatabase extends ChangeNotifier {
     final String databasePath = join(databasesRootPath, 'smoothie.db');
     final Database database = await openDatabase(
       databasePath,
-      version: 2,
+      version: 3,
       singleInstance: true,
       onUpgrade: _onUpgrade,
     );
@@ -108,5 +109,6 @@ class LocalDatabase extends ChangeNotifier {
   ) async {
     await DaoUnzippedProduct.onUpgrade(db, oldVersion, newVersion);
     await DaoProduct.onUpgrade(db, oldVersion, newVersion);
+    await DaoWorkBarcode.onUpgrade(db, oldVersion, newVersion);
   }
 }
diff --git a/packages/smooth_app/lib/l10n/app_en.arb b/packages/smooth_app/lib/l10n/app_en.arb
index 84c8833f478e..c8a8ae966977 100644
--- a/packages/smooth_app/lib/l10n/app_en.arb
+++ b/packages/smooth_app/lib/l10n/app_en.arb
@@ -1826,6 +1826,14 @@
     "@image_upload_queued": {
         "description": "Message when a photo is queued for upload"
     },
+    "background_task_title_full_refresh": "Starting the refresh of all the products locally stored",
+    "@background_task_title_full_refresh": {
+        "description": "Snackbar message when a full refresh is started"
+    },
+    "background_task_title_top_n": "Starting the download of the most popular products",
+    "@background_task_title_top_n": {
+        "description": "Snackbar message when a download of the most popular products is started"
+    },
     "expand_nutrition_facts": "Expand nutrition facts table",
     "@expand_nutrition_facts": {
         "description": "Label for expanding nutrition facts table in application setting"
@@ -2171,6 +2179,14 @@
     "@download_top_products": {
         "description": "Download the top 1000 products in your country for instant scanning"
     },
+    "download_top_n_products": "Download the top {count,plural,  other{{count} products}} in your country for instant scanning",
+    "@download_top_n_products": {
+        "placeholders": {
+            "count": {
+                "type": "int"
+            }
+        }
+    },
     "download_in_progress": "Downloading data\nThis may take a while",
     "@download_in_progress": {
         "description": "Download in progress"
diff --git a/packages/smooth_app/lib/pages/offline_data_page.dart b/packages/smooth_app/lib/pages/offline_data_page.dart
index f8c0a9a8ec14..6aa8572c6c6d 100644
--- a/packages/smooth_app/lib/pages/offline_data_page.dart
+++ b/packages/smooth_app/lib/pages/offline_data_page.dart
@@ -20,6 +20,12 @@ class OfflineDataPage extends StatefulWidget {
 }
 
 class _OfflineDataPageState extends State<OfflineDataPage> {
+  /// Number of Top N products to download.
+  static const int _topNSize = 10000;
+
+  /// Page size for download operations.
+  static const int _pageSize = 100;
+
   @override
   Widget build(BuildContext context) {
     // TODO(ashaman999): replaace the header asset with a custom one for this page
@@ -53,9 +59,11 @@ class _OfflineDataPageState extends State<OfflineDataPage> {
             ),
             _OfflinePageListTile(
               title: appLocalizations.download_data,
-              subtitle: appLocalizations.download_top_products,
+              subtitle: appLocalizations.download_top_n_products(_topNSize),
               onTap: () async => BackgroundTaskOffline.addTask(
                 widget: this,
+                pageSize: _pageSize,
+                totalSize: _topNSize,
               ),
               trailing: const Icon(Icons.download),
             ),
@@ -65,6 +73,7 @@ class _OfflineDataPageState extends State<OfflineDataPage> {
               trailing: const Icon(Icons.refresh),
               onTap: () async => BackgroundTaskFullRefresh.addTask(
                 widget: this,
+                pageSize: _pageSize,
               ),
             ),
             _OfflinePageListTile(
diff --git a/packages/smooth_app/lib/pages/offline_tasks_page.dart b/packages/smooth_app/lib/pages/offline_tasks_page.dart
index b9b4c5414100..70766a36c426 100644
--- a/packages/smooth_app/lib/pages/offline_tasks_page.dart
+++ b/packages/smooth_app/lib/pages/offline_tasks_page.dart
@@ -1,9 +1,9 @@
 import 'package:flutter/material.dart';
 import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:provider/provider.dart';
-import 'package:smooth_app/background/background_task_full_refresh.dart';
 import 'package:smooth_app/background/background_task_manager.dart';
-import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/background/background_task_progressing.dart';
+import 'package:smooth_app/background/operation_type.dart';
 import 'package:smooth_app/database/dao_instant_string.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/generic_lib/dialogs/smooth_alert_dialog.dart';
@@ -32,7 +32,7 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
         actions: <Widget>[
           IconButton(
             onPressed: () => // no await
-                BackgroundTaskManager(localDatabase).run(),
+                BackgroundTaskManager.getInstance(localDatabase).run(),
             icon: const Icon(Icons.refresh),
           ),
         ],
@@ -50,9 +50,18 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
                     taskId,
                   ),
                 );
-                String barcode = OperationType.getBarcode(taskId);
-                if (barcode == BackgroundTaskFullRefresh.noBarcode) {
-                  barcode = '';
+                final String barcode = OperationType.getBarcode(taskId);
+                final int? totalSize = OperationType.getTotalSize(taskId);
+                final int? soFarSize = OperationType.getSoFarSize(taskId);
+                final String? workText = _getWorkText(taskId);
+                final String info;
+                if (barcode != BackgroundTaskProgressing.noBarcode) {
+                  info = '$barcode ';
+                } else if (totalSize != null && soFarSize != null) {
+                  info =
+                      '${(100 * soFarSize) ~/ totalSize}% ${workText == null ? '' : '- $workText '}';
+                } else {
+                  info = '';
                 }
                 return ListTile(
                   onTap: () async {
@@ -73,13 +82,13 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
                       ),
                     );
                     if (stopTask == true) {
-                      await BackgroundTaskManager(localDatabase)
+                      await BackgroundTaskManager.getInstance(localDatabase)
                           .removeTaskAsap(taskId);
                     }
                   },
                   title: Text(
-                    '$barcode'
-                    ' (${OperationType.getOperationType(taskId)?.getLabel(
+                    '$info'
+                    '(${OperationType.getOperationType(taskId)?.getLabel(
                           appLocalizations,
                         ) ?? appLocalizations.background_task_operation_unknown})',
                   ),
@@ -107,4 +116,20 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
     }
     return status;
   }
+
+  String? _getWorkText(final String taskId) {
+    final String? work = OperationType.getWork(taskId);
+    switch (work) {
+      case null:
+      case '':
+        return null;
+      case BackgroundTaskProgressing.workOffline:
+        return 'Top products';
+      case BackgroundTaskProgressing.workFreshWithoutKP:
+        return 'Refresh products without KP';
+      case BackgroundTaskProgressing.workFreshWithKP:
+        return 'Refresh products with KP';
+    }
+    return 'Unknown work ($work)!';
+  }
 }
diff --git a/packages/smooth_app/lib/pages/product/edit_product_page.dart b/packages/smooth_app/lib/pages/product/edit_product_page.dart
index 0079821c013b..cd804f67063a 100644
--- a/packages/smooth_app/lib/pages/product/edit_product_page.dart
+++ b/packages/smooth_app/lib/pages/product/edit_product_page.dart
@@ -58,7 +58,7 @@ class _EditProductPageState extends State<EditProductPage> {
 
   @override
   Widget build(BuildContext context) {
-    BackgroundTaskManager(_localDatabase).run(); // no await
+    BackgroundTaskManager.getInstance(_localDatabase).run(); // no await
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
     context.watch<LocalDatabase>();
     _product = _localDatabase.upToDate.getLocalUpToDate(_initialProduct);
diff --git a/packages/smooth_app/lib/pages/product/new_product_page.dart b/packages/smooth_app/lib/pages/product/new_product_page.dart
index be5d3051265a..a4f47e153584 100644
--- a/packages/smooth_app/lib/pages/product/new_product_page.dart
+++ b/packages/smooth_app/lib/pages/product/new_product_page.dart
@@ -89,7 +89,7 @@ class _ProductPageState extends State<ProductPage> with TraceableClientMixin {
 
   @override
   Widget build(BuildContext context) {
-    BackgroundTaskManager(_localDatabase).run(); // no await
+    BackgroundTaskManager.getInstance(_localDatabase).run(); // no await
     final InheritedDataManagerState inheritedDataManager =
         InheritedDataManager.of(context);
     inheritedDataManager.setCurrentBarcode(_barcode);
diff --git a/packages/smooth_app/lib/pages/product/product_image_gallery_view.dart b/packages/smooth_app/lib/pages/product/product_image_gallery_view.dart
index 01064249cc84..2df6d2771ab6 100644
--- a/packages/smooth_app/lib/pages/product/product_image_gallery_view.dart
+++ b/packages/smooth_app/lib/pages/product/product_image_gallery_view.dart
@@ -54,7 +54,7 @@ class _ProductImageGalleryViewState extends State<ProductImageGalleryView> {
 
   @override
   Widget build(BuildContext context) {
-    BackgroundTaskManager(_localDatabase).run(); // no await
+    BackgroundTaskManager.getInstance(_localDatabase).run(); // no await
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
     final ThemeData theme = Theme.of(context);
     context.watch<LocalDatabase>();
