diff --git a/packages/smooth_app/lib/cards/product_cards/product_list_preview.dart b/packages/smooth_app/lib/cards/product_cards/product_list_preview.dart
index d1cc0123c02d..1e57bc2aded1 100644
--- a/packages/smooth_app/lib/cards/product_cards/product_list_preview.dart
+++ b/packages/smooth_app/lib/cards/product_cards/product_list_preview.dart
@@ -19,20 +19,17 @@ class ProductListPreview extends StatelessWidget {
     @required this.daoProductList,
     @required this.productList,
     @required this.nbInPreview,
+    this.andThen,
   });
 
   final DaoProductList daoProductList;
   final ProductList productList;
   final int nbInPreview;
+  final Function andThen;
 
   @override
   Widget build(BuildContext context) => FutureBuilder<List<Product>>(
-        future: daoProductList.getFirstProducts(
-          productList,
-          nbInPreview,
-          true,
-          true,
-        ),
+        future: daoProductList.getFirstProducts(productList, nbInPreview),
         builder: (
           final BuildContext context,
           final AsyncSnapshot<List<Product>> snapshot,
@@ -60,6 +57,9 @@ class ProductListPreview extends StatelessWidget {
                               ProductListPage(productList),
                         ),
                       );
+                      if (andThen != null) {
+                        andThen();
+                      }
                     },
                     leading: productList.getIcon(
                       Theme.of(context).colorScheme,
diff --git a/packages/smooth_app/lib/data_models/product_list.dart b/packages/smooth_app/lib/data_models/product_list.dart
index 8b72476c616f..79d3478cf0e1 100644
--- a/packages/smooth_app/lib/data_models/product_list.dart
+++ b/packages/smooth_app/lib/data_models/product_list.dart
@@ -9,7 +9,6 @@ class ProductList {
     @required this.listType,
     @required this.parameters,
     this.databaseTimestamp,
-    this.databaseCount,
     this.databaseCountDistinct,
   });
 
@@ -89,7 +88,6 @@ class ProductList {
   final String listType;
   final String parameters;
   final int databaseTimestamp;
-  final int databaseCount;
   final int databaseCountDistinct;
   Map<String, String> extraTags;
 
@@ -126,11 +124,6 @@ class ProductList {
 
   bool isEmpty() => _barcodes.isEmpty;
 
-  void clear() {
-    _barcodes.clear();
-    _products.clear();
-  }
-
   Product getProduct(final String barcode) => _products[barcode];
 
   bool isSameAs(final ProductList other) =>
@@ -192,42 +185,93 @@ class ProductList {
     _products[barcode] = product;
   }
 
-  void add(final Product product) {
+  /// Adds a product to the end of a list if not there already, or does nothing
+  ///
+  /// Returns false if already in the list
+  /// Don't forget to update the database afterwards
+  bool add(final Product product) {
     refresh(product);
+    if (_barcodes.contains(product.barcode)) {
+      return false;
+    }
     _barcodes.add(product.barcode);
+    int index = 1; // default value
+    // looking for the highest index so far
+    for (final String barcode in _barcodes.reversed) {
+      if (barcode == product.barcode) {
+        continue;
+      }
+      final ProductExtra last = _productExtras[barcode];
+      index = last.intValue;
+      break;
+    }
+    _productExtras[product.barcode] = _computeProductExtra(index);
+    return true;
+  }
+
+  /// Removes a barcode from the list
+  ///
+  /// Returns false if not already in the list
+  /// Don't forget to update the database afterwards
+  bool remove(final String barcode) {
+    if (!_barcodes.contains(barcode)) {
+      return false;
+    }
+    _barcodes.remove(barcode);
+    _products[barcode] = null;
+    _productExtras[barcode] = null;
+    return true;
   }
 
-  void addAll(final List<Product> products) => products.forEach(add);
+  /// Sets all products with the same order as the input list
+  void setAll(final List<Product> products) {
+    int i = 0;
+    final List<String> barcodes = <String>[];
+    final Map<String, Product> productMap = <String, Product>{};
+    final Map<String, ProductExtra> productExtras = <String, ProductExtra>{};
+    for (final Product product in products) {
+      final String barcode = product.barcode;
+      barcodes.add(barcode);
+      productMap[barcode] = product;
+      productExtras[barcode] = _computeProductExtra(i++);
+    }
+    set(barcodes, productMap, productExtras);
+  }
 
   void set(
     final List<String> barcodes,
-    final Map<String, Product> products, {
+    final Map<String, Product> products,
     final Map<String, ProductExtra> productExtras,
-  }) {
-    clear();
+  ) {
+    _barcodes.clear();
+    _products.clear();
     _barcodes.addAll(barcodes);
     _products.addAll(products);
-    if (productExtras != null) {
-      _productExtras.addAll(productExtras);
-    }
+    _productExtras.clear();
+    _productExtras.addAll(productExtras);
   }
 
-  List<Product> getList() {
-    final List<Product> result = <Product>[];
-    for (final String barcode in _barcodes) {
-      final Product product = _products[barcode];
-      if (product == null) {
-        throw Exception('no product for barcode $barcode');
-      }
-      result.add(product);
+  ProductExtra _computeProductExtra(final int index) => ProductExtra(index, '');
+
+  void reorder(final int oldIndex, int newIndex) {
+    final List<String> order = _barcodes;
+    if (oldIndex < newIndex) {
+      newIndex -= 1;
     }
-    return result;
+    final String item = order.removeAt(oldIndex);
+    order.insert(newIndex, item);
+
+    int i = 0;
+    final Map<String, ProductExtra> productExtras = <String, ProductExtra>{};
+    for (final String barcode in order) {
+      productExtras[barcode] = _computeProductExtra(i++);
+    }
+    _productExtras.addAll(productExtras);
   }
 
-  List<Product> getUniqueList() {
+  List<Product> getList() {
     final List<Product> result = <Product>[];
-    final List<String> orderedBarcodes = getOrderedBarcodes();
-    for (final String barcode in orderedBarcodes) {
+    for (final String barcode in _barcodes) {
       final Product product = _products[barcode];
       if (product == null) {
         throw Exception('no product for barcode $barcode');
@@ -236,15 +280,4 @@ class ProductList {
     }
     return result;
   }
-
-  List<String> getOrderedBarcodes() {
-    final List<String> result = <String>[];
-    for (final String barcode in barcodes) {
-      if (result.contains(barcode)) {
-        continue;
-      }
-      result.add(barcode);
-    }
-    return result;
-  }
 }
diff --git a/packages/smooth_app/lib/data_models/query_product_list_supplier.dart b/packages/smooth_app/lib/data_models/query_product_list_supplier.dart
index 2ec1ae384c1c..0185e396a215 100644
--- a/packages/smooth_app/lib/data_models/query_product_list_supplier.dart
+++ b/packages/smooth_app/lib/data_models/query_product_list_supplier.dart
@@ -17,7 +17,7 @@ class QueryProductListSupplier extends ProductListSupplier {
     try {
       final SearchResult searchResult = await productQuery.getSearchResult();
       productList = productQuery.getProductList();
-      productList.addAll(searchResult.products);
+      productList.setAll(searchResult.products);
       await DaoProduct(localDatabase).put(productList.getList());
       await DaoProductList(localDatabase).put(productList);
       return null;
diff --git a/packages/smooth_app/lib/data_models/smooth_it_model.dart b/packages/smooth_app/lib/data_models/smooth_it_model.dart
index 8be4fa544ab1..7817fcdf6671 100644
--- a/packages/smooth_app/lib/data_models/smooth_it_model.dart
+++ b/packages/smooth_app/lib/data_models/smooth_it_model.dart
@@ -25,7 +25,7 @@ class SmoothItModel {
       _nextRefreshIsJustChangingTabs = false;
       return;
     }
-    final List<Product> unprocessedProducts = productList.getUniqueList();
+    final List<Product> unprocessedProducts = productList.getList();
     _allProducts = MatchedProduct.sort(unprocessedProducts, productPreferences);
     _categorizedProducts.clear();
     for (final MatchedProduct matchededProduct in _allProducts) {
diff --git a/packages/smooth_app/lib/database/abstract_dao.dart b/packages/smooth_app/lib/database/abstract_dao.dart
index 4deca925b598..0dd241281130 100644
--- a/packages/smooth_app/lib/database/abstract_dao.dart
+++ b/packages/smooth_app/lib/database/abstract_dao.dart
@@ -1,6 +1,3 @@
-import 'dart:async';
-import 'package:flutter/material.dart';
-import 'package:sqflite/sqflite.dart';
 import 'package:smooth_app/database/local_database.dart';
 
 /// DAO abstraction
@@ -8,75 +5,4 @@ abstract class AbstractDao {
   AbstractDao(this.localDatabase);
 
   final LocalDatabase localDatabase;
-
-  /// Max number of parameters in a SQFlite query
-  ///
-  /// cf. SQLITE_MAX_VARIABLE_NUMBER, "which defaults to 999"
-  // TODO(monsieurtanuki): find a way to retrieve this number from SQFlite system tables, cf. https://github.com/tekartik/sqflite/issues/663
-  static const int SQLITE_MAX_VARIABLE_NUMBER = 999;
-
-  /// Optimized bulk insert
-  @protected
-  Future<void> bulkInsert(
-    final List<dynamic> parameters,
-    final DatabaseExecutor databaseExecutor,
-  ) async {
-    final String tableName = getTableName();
-    final List<String> columnNames = getBulkInsertColumns();
-    final int numCols = columnNames.length;
-    if (parameters.isEmpty) {
-      return;
-    }
-    if (columnNames.isEmpty) {
-      throw Exception('There must be at least one column!');
-    }
-    final String variables = '?${',?' * (columnNames.length - 1)}';
-    if (parameters.length % numCols != 0) {
-      throw Exception(
-          'Parameter list size (${parameters.length}) cannot be divided by $numCols');
-    }
-    final int additionalRecordsNumber = -1 + parameters.length ~/ numCols;
-    await databaseExecutor.rawInsert(
-        'insert into $tableName(${columnNames.join(',')}) '
-        'values($variables)${',($variables)' * additionalRecordsNumber}',
-        parameters);
-  }
-
-  /// Optimized bulk upsert
-  ///
-  /// In tests it looked 33% faster to use delete/insert rather than upsert
-  @protected
-  Future<void> bulkUpsert({
-    @required final List<dynamic> insertParameters,
-    @required final String deleteWhere,
-    @required final List<String> deleteParameters,
-    @required final DatabaseExecutor databaseExecutor,
-  }) async {
-    final String tableName = getTableName();
-    final List<String> insertColumns = getBulkInsertColumns();
-    if (insertParameters.isEmpty) {
-      return;
-    }
-    final int numCols = insertColumns.length;
-    if (insertParameters.length % numCols != 0) {
-      throw Exception(
-          'Parameter list size (${insertParameters.length}) cannot be divided by $numCols');
-    }
-    await databaseExecutor.delete(
-      tableName,
-      where: deleteWhere,
-      whereArgs: deleteParameters,
-    );
-    await bulkInsert(insertParameters, databaseExecutor);
-  }
-
-  /// Insert columns for bulk mode
-  List<String> getBulkInsertColumns();
-
-  /// Table name
-  String getTableName();
-
-  /// Max number of records to be inserted in bulk mode
-  int getBulkMaxRecordNumber() =>
-      SQLITE_MAX_VARIABLE_NUMBER ~/ getBulkInsertColumns().length;
 }
diff --git a/packages/smooth_app/lib/database/bulk_deletable.dart b/packages/smooth_app/lib/database/bulk_deletable.dart
new file mode 100644
index 000000000000..3107f1249c87
--- /dev/null
+++ b/packages/smooth_app/lib/database/bulk_deletable.dart
@@ -0,0 +1,9 @@
+import 'package:smooth_app/database/bulk_insertable.dart';
+
+/// Interface for bulk database deletes
+///
+/// cf. [BulkManager], [BulkInsertable]
+abstract class BulkDeletable implements BulkInsertable {
+  /// "where" clause for delete in bulk mode
+  String getDeleteWhere(final List<dynamic> deleteWhereArgs);
+}
diff --git a/packages/smooth_app/lib/database/bulk_insertable.dart b/packages/smooth_app/lib/database/bulk_insertable.dart
new file mode 100644
index 000000000000..762c6ec6f239
--- /dev/null
+++ b/packages/smooth_app/lib/database/bulk_insertable.dart
@@ -0,0 +1,12 @@
+import 'package:smooth_app/database/bulk_manager.dart';
+
+/// Interface for bulk database inserts
+///
+/// cf. [BulkManager]
+abstract class BulkInsertable {
+  /// Insert columns for bulk mode
+  List<String> getInsertColumns();
+
+  /// Table name
+  String getTableName();
+}
diff --git a/packages/smooth_app/lib/database/bulk_manager.dart b/packages/smooth_app/lib/database/bulk_manager.dart
new file mode 100644
index 000000000000..74b1b761dcf0
--- /dev/null
+++ b/packages/smooth_app/lib/database/bulk_manager.dart
@@ -0,0 +1,80 @@
+import 'dart:async';
+import 'dart:math';
+import 'package:flutter/material.dart';
+import 'package:smooth_app/database/bulk_insertable.dart';
+import 'package:smooth_app/database/bulk_deletable.dart';
+import 'package:sqflite/sqflite.dart';
+
+/// Manager for bulk database inserts and deletes
+///
+/// In tests it looked 33% faster to use delete/insert rather than upsert
+/// And of course it's much faster to perform bulk actions
+/// rather than numerous single actions
+/// cf. [BulkInsertable], [BulkDeletable]
+class BulkManager {
+  /// Max number of parameters in a SQFlite query
+  ///
+  /// cf. SQLITE_MAX_VARIABLE_NUMBER, "which defaults to 999"
+  // TODO(monsieurtanuki): find a way to retrieve this number from SQFlite system tables, cf. https://github.com/tekartik/sqflite/issues/663
+  static const int _SQLITE_MAX_VARIABLE_NUMBER = 999;
+
+  /// Optimized bulk insert
+  Future<void> insert({
+    @required final BulkInsertable bulkInsertable,
+    @required final List<dynamic> parameters,
+    @required final DatabaseExecutor databaseExecutor,
+  }) async {
+    final String tableName = bulkInsertable.getTableName();
+    final List<String> columnNames = bulkInsertable.getInsertColumns();
+    final int numCols = columnNames.length;
+    if (parameters.isEmpty) {
+      return;
+    }
+    if (columnNames.isEmpty) {
+      throw Exception('There must be at least one column!');
+    }
+    if (parameters.length % numCols != 0) {
+      throw Exception(
+          'Parameter list size (${parameters.length}) cannot be divided by $numCols');
+    }
+    final String variables = '?${',?' * (columnNames.length - 1)}';
+    final int maxSlice = _SQLITE_MAX_VARIABLE_NUMBER ~/ numCols;
+    for (int start = 0; start < parameters.length; start += maxSlice) {
+      final int size = min(parameters.length - start, maxSlice);
+      final int additionalRecordsNumber = -1 + size ~/ numCols;
+      await databaseExecutor.rawInsert(
+        'insert into $tableName(${columnNames.join(',')}) '
+        'values($variables)${',($variables)' * additionalRecordsNumber}',
+        parameters.sublist(start, start + size),
+      );
+    }
+  }
+
+  /// Optimized bulk delete
+  Future<void> delete({
+    @required final BulkDeletable bulkDeletable,
+    @required final List<dynamic> parameters,
+    @required final DatabaseExecutor databaseExecutor,
+    final List<dynamic> additionalParameters,
+  }) async {
+    final String tableName = bulkDeletable.getTableName();
+    if (parameters.isEmpty) {
+      return;
+    }
+    final int maxSlice =
+        _SQLITE_MAX_VARIABLE_NUMBER - (additionalParameters?.length ?? 0);
+    for (int start = 0; start < parameters.length; start += maxSlice) {
+      final int size = min(parameters.length - start, maxSlice);
+      final List<dynamic> currentParameters = <dynamic>[];
+      if (additionalParameters != null && additionalParameters.isNotEmpty) {
+        currentParameters.addAll(additionalParameters);
+      }
+      currentParameters.addAll(parameters.sublist(start, start + size));
+      await databaseExecutor.delete(
+        tableName,
+        where: bulkDeletable.getDeleteWhere(currentParameters),
+        whereArgs: currentParameters,
+      );
+    }
+  }
+}
diff --git a/packages/smooth_app/lib/database/dao_product.dart b/packages/smooth_app/lib/database/dao_product.dart
index 0672f32e4d9e..01a07e5feb1e 100644
--- a/packages/smooth_app/lib/database/dao_product.dart
+++ b/packages/smooth_app/lib/database/dao_product.dart
@@ -2,11 +2,13 @@ import 'dart:async';
 import 'dart:convert';
 import 'package:openfoodfacts/model/Product.dart';
 import 'package:smooth_app/database/abstract_dao.dart';
+import 'package:smooth_app/database/bulk_manager.dart';
+import 'package:smooth_app/database/bulk_deletable.dart';
 import 'package:smooth_app/database/dao_product_extra.dart';
 import 'package:sqflite/sqflite.dart';
 import 'package:smooth_app/database/local_database.dart';
 
-class DaoProduct extends AbstractDao {
+class DaoProduct extends AbstractDao implements BulkDeletable {
   DaoProduct(final LocalDatabase localDatabase) : super(localDatabase);
 
   static const String TABLE_PRODUCT = 'product';
@@ -150,57 +152,40 @@ class DaoProduct extends AbstractDao {
     final List<Product> products,
     final int timestamp,
   ) async {
-    final int maxRecordNumber = getBulkMaxRecordNumber();
+    final BulkManager bulkManager = BulkManager();
     final List<dynamic> insertParameters = <dynamic>[];
-    final List<String> deleteParameters = <String>[];
-    int counter = 0;
+    final List<dynamic> deleteParameters = <dynamic>[];
     for (final Product product in products) {
       deleteParameters.add(product.barcode);
       insertParameters.add(product.barcode);
       insertParameters.add(json.encode(product.toJson()));
       insertParameters.add(timestamp);
-      counter++;
-      if (counter == maxRecordNumber) {
-        await _bulkUpsert(
-          insertParameters,
-          deleteParameters,
-          databaseExecutor,
-        );
-        counter = 0;
-        deleteParameters.clear();
-        insertParameters.clear();
-      }
     }
-    await _bulkUpsert(
-      insertParameters,
-      deleteParameters,
-      databaseExecutor,
+    await bulkManager.delete(
+      bulkDeletable: this,
+      parameters: deleteParameters,
+      databaseExecutor: databaseExecutor,
+    );
+    await bulkManager.insert(
+      bulkInsertable: this,
+      parameters: insertParameters,
+      databaseExecutor: databaseExecutor,
     );
   }
 
   @override
-  List<String> getBulkInsertColumns() => <String>[
+  List<String> getInsertColumns() => <String>[
         TABLE_PRODUCT_COLUMN_BARCODE,
         _TABLE_PRODUCT_COLUMN_JSON,
         LocalDatabase.COLUMN_TIMESTAMP,
       ];
 
   @override
-  String getTableName() => TABLE_PRODUCT;
+  String getDeleteWhere(final List<dynamic> deleteWhereArgs) =>
+      '$TABLE_PRODUCT_COLUMN_BARCODE in (?${',?' * (deleteWhereArgs.length - 1)})';
 
-  /// Bulk upsert of products
-  Future<void> _bulkUpsert(
-    final List<dynamic> insertParameters,
-    final List<String> deleteParameters,
-    final DatabaseExecutor databaseExecutor,
-  ) async =>
-      await bulkUpsert(
-        insertParameters: insertParameters,
-        deleteParameters: deleteParameters,
-        deleteWhere:
-            '$TABLE_PRODUCT_COLUMN_BARCODE in (?${',?' * (deleteParameters.length - 1)})',
-        databaseExecutor: databaseExecutor,
-      );
+  @override
+  String getTableName() => TABLE_PRODUCT;
 
   Product _getProductFromQueryResult(final Map<String, dynamic> row) {
     final String encodedJson = row[_TABLE_PRODUCT_COLUMN_JSON] as String;
diff --git a/packages/smooth_app/lib/database/dao_product_extra.dart b/packages/smooth_app/lib/database/dao_product_extra.dart
index 0ee67ec9c1ec..3faa37ca9ffa 100644
--- a/packages/smooth_app/lib/database/dao_product_extra.dart
+++ b/packages/smooth_app/lib/database/dao_product_extra.dart
@@ -4,6 +4,8 @@ import 'dart:convert';
 import 'package:flutter/material.dart';
 import 'package:openfoodfacts/model/Product.dart';
 import 'package:smooth_app/database/abstract_dao.dart';
+import 'package:smooth_app/database/bulk_manager.dart';
+import 'package:smooth_app/database/bulk_deletable.dart';
 import 'package:smooth_app/database/dao_product.dart';
 import 'package:sqflite/sqflite.dart';
 import 'package:smooth_app/database/local_database.dart';
@@ -20,7 +22,7 @@ import 'package:smooth_app/data_models/product_list.dart';
 /// A typical use case is for timestamps history (e.g. scan, view or refresh).
 /// In that case the integer value contains the latest timestamp,
 /// and the string value contains a list of timestamps encoded as json.
-class DaoProductExtra extends AbstractDao {
+class DaoProductExtra extends AbstractDao implements BulkDeletable {
   DaoProductExtra(final LocalDatabase localDatabase) : super(localDatabase);
 
   static const String _TABLE_PRODUCT_EXTRA = 'product_extra';
@@ -131,11 +133,10 @@ class DaoProductExtra extends AbstractDao {
     final int timestamp,
   ) async {
     const String KEY = _EXTRA_ID_SIMPLIFIED_TEXT;
-    final int maxRecordNumber = getBulkMaxRecordNumber();
+    final BulkManager bulkManager = BulkManager();
     final List<dynamic> insertParameters = <dynamic>[];
-    final List<String> deleteParameters = <String>[KEY];
+    final List<dynamic> deleteParameters = <dynamic>[];
 
-    int counter = 0;
     for (final Product product in products) {
       deleteParameters.add(product.barcode);
       insertParameters.add(product.barcode);
@@ -143,28 +144,30 @@ class DaoProductExtra extends AbstractDao {
       insertParameters.add(_getSimplifiedTextForProduct(product));
       insertParameters.add(0);
       insertParameters.add(timestamp);
-      counter++;
-      if (counter == maxRecordNumber) {
-        await _bulkUpsert(insertParameters, deleteParameters, databaseExecutor);
-        counter = 0;
-        deleteParameters.clear();
-        deleteParameters.add(KEY);
-        insertParameters.clear();
-      }
     }
-    await _bulkUpsert(insertParameters, deleteParameters, databaseExecutor);
+    await bulkManager.delete(
+      bulkDeletable: this,
+      parameters: deleteParameters,
+      databaseExecutor: databaseExecutor,
+      additionalParameters: <dynamic>[KEY],
+    );
+    await bulkManager.insert(
+      bulkInsertable: this,
+      parameters: insertParameters,
+      databaseExecutor: databaseExecutor,
+    );
   }
 
-  /// Upserts the "last time I did whatever with this product" in bulk mode
+  /// Upserts the "last time I did whatever with those products" in bulk mode
   Future<void> bulkUpsertLoopLast(
     final DatabaseExecutor databaseExecutor,
     final List<Product> products,
     final int timestamp,
     final String extraKey,
   ) async {
-    final int maxRecordNumber = getBulkMaxRecordNumber();
+    final BulkManager bulkManager = BulkManager();
     final List<dynamic> insertParameters = <dynamic>[];
-    final List<String> deleteParameters = <String>[extraKey];
+    final List<dynamic> deleteParameters = <dynamic>[];
 
     final List<String> barcodes = <String>[];
     for (final Product product in products) {
@@ -176,7 +179,6 @@ class DaoProductExtra extends AbstractDao {
       databaseExecutor: databaseExecutor,
     );
 
-    int counter = 0;
     for (final Product product in products) {
       final ProductExtra productExtra = map[product.barcode];
       List<int> timestamps;
@@ -193,20 +195,49 @@ class DaoProductExtra extends AbstractDao {
       insertParameters.add(jsonEncode(timestamps)); // string value
       insertParameters.add(timestamp); // int value
       insertParameters.add(timestamp);
-      counter++;
-      if (counter == maxRecordNumber) {
-        await _bulkUpsert(insertParameters, deleteParameters, databaseExecutor);
-        counter = 0;
-        deleteParameters.clear();
-        deleteParameters.add(extraKey);
-        insertParameters.clear();
-      }
     }
-    await _bulkUpsert(insertParameters, deleteParameters, databaseExecutor);
+    await bulkManager.delete(
+      bulkDeletable: this,
+      parameters: deleteParameters,
+      databaseExecutor: databaseExecutor,
+      additionalParameters: <dynamic>[extraKey],
+    );
+    await bulkManager.insert(
+      bulkInsertable: this,
+      parameters: insertParameters,
+      databaseExecutor: databaseExecutor,
+    );
+  }
+
+  /// Deletes all then inserts a simple product list in bulk mode
+  Future<void> bulkInsertExtra({
+    @required final DatabaseExecutor databaseExecutor,
+    @required final ProductList productList,
+    @required final int productListId,
+  }) async {
+    final BulkManager bulkManager = BulkManager();
+    final int timestamp = LocalDatabase.nowInMillis();
+    final List<dynamic> insertParameters = <dynamic>[];
+    final String extraKey = _getExtraKey(productList, productListId);
+
+    for (final String barcode in productList.barcodes) {
+      final ProductExtra productExtra = productList.productExtras[barcode];
+      insertParameters.add(barcode);
+      insertParameters.add(extraKey);
+      insertParameters.add(productExtra.stringValue);
+      insertParameters.add(productExtra.intValue);
+      insertParameters.add(timestamp);
+    }
+    await clearList(productList, productListId, databaseExecutor);
+    await bulkManager.insert(
+      bulkInsertable: this,
+      parameters: insertParameters,
+      databaseExecutor: databaseExecutor,
+    );
   }
 
   @override
-  List<String> getBulkInsertColumns() => <String>[
+  List<String> getInsertColumns() => <String>[
         DaoProduct.TABLE_PRODUCT_COLUMN_BARCODE,
         _TABLE_PRODUCT_EXTRA_COLUMN_KEY,
         _TABLE_PRODUCT_EXTRA_COLUMN_VALUE,
@@ -215,21 +246,13 @@ class DaoProductExtra extends AbstractDao {
       ];
 
   @override
-  String getTableName() => _TABLE_PRODUCT_EXTRA;
+  String getDeleteWhere(final List<dynamic> deleteWhereArgs) =>
+      '$_TABLE_PRODUCT_EXTRA_COLUMN_KEY = ? '
+      'and ${DaoProduct.TABLE_PRODUCT_COLUMN_BARCODE} '
+      '  in (?${',?' * (deleteWhereArgs.length - 2)})';
 
-  /// Bulk upsert of product extra
-  Future<void> _bulkUpsert(
-    final List<dynamic> insertParameters,
-    final List<String> deleteParameters,
-    final DatabaseExecutor databaseExecutor,
-  ) async =>
-      await bulkUpsert(
-        insertParameters: insertParameters,
-        deleteParameters: deleteParameters,
-        deleteWhere: '$_TABLE_PRODUCT_EXTRA_COLUMN_KEY = ? '
-            'and ${DaoProduct.TABLE_PRODUCT_COLUMN_BARCODE} in (?${',?' * (deleteParameters.length - 2)})',
-        databaseExecutor: databaseExecutor,
-      );
+  @override
+  String getTableName() => _TABLE_PRODUCT_EXTRA;
 
   /// Returns a lowercase not accented version of the text, for comparisons
   static String _getSimplifiedText(final String text) {
@@ -349,50 +372,54 @@ class DaoProductExtra extends AbstractDao {
     return map[barcode];
   }
 
-  String _getExtraKey(final ProductList productList) {
+  String _getExtraKey(final ProductList productList, final int id) {
     switch (productList.listType) {
       case ProductList.LIST_TYPE_HISTORY:
         return EXTRA_ID_LAST_SEEN;
       case ProductList.LIST_TYPE_SCAN:
         return EXTRA_ID_LAST_SCAN;
     }
-    return null;
+    if (id == null) {
+      throw Exception('Unknown product list of type ${productList.listType}');
+    }
+    return 'list/$id';
   }
 
-  bool _getExtraReverse(final ProductList productList) {
+  bool _getExtraReverse(final ProductList productList, final int id) {
     switch (productList.listType) {
       case ProductList.LIST_TYPE_HISTORY:
         return true;
       case ProductList.LIST_TYPE_SCAN:
         return false;
     }
-    return null;
+    if (id == null) {
+      throw Exception('Unknown product list of type ${productList.listType}');
+    }
+    return false;
   }
 
-  Future<bool> getList(final ProductList productList) async {
-    final String extraKey = _getExtraKey(productList);
-    final bool extraReverse = _getExtraReverse(productList);
-    if (extraKey == null || extraReverse == null) {
-      return false;
-    }
+  Future<bool> getList(final ProductList productList, final int id) async {
+    final String extraKey = _getExtraKey(productList, id);
+    final bool extraReverse = _getExtraReverse(productList, id);
     final LinkedHashMap<String, ProductExtra> extras =
-        await getOrderedProductExtras(key: extraKey, reverse: extraReverse);
+        await getOrderedProductExtras(
+      key: extraKey,
+      reverse: extraReverse,
+    );
     final List<String> barcodes = List<String>.from(extras.keys);
     final Map<String, Product> products =
         await DaoProduct(localDatabase).getAllWithExtras(extraKey);
-    productList.set(barcodes, products, productExtras: extras);
+    productList.set(barcodes, products, extras);
     return true;
   }
 
   Future<List<String>> getFirstBarcodes(
     final ProductList productList,
+    final int id,
     final int limit,
   ) async {
-    final String extraKey = _getExtraKey(productList);
-    final bool extraReverse = _getExtraReverse(productList);
-    if (extraKey == null || extraReverse == null) {
-      return null;
-    }
+    final String extraKey = _getExtraKey(productList, id);
+    final bool extraReverse = _getExtraReverse(productList, id);
     final LinkedHashMap<String, ProductExtra> extras =
         await getOrderedProductExtras(
       key: extraKey,
@@ -402,4 +429,37 @@ class DaoProductExtra extends AbstractDao {
     final List<String> barcodes = List<String>.from(extras.keys);
     return barcodes;
   }
+
+  Future<void> clearList(
+    final ProductList productList,
+    final int id,
+    final DatabaseExecutor databaseExecutor,
+  ) async =>
+      await databaseExecutor.delete(
+        _TABLE_PRODUCT_EXTRA,
+        where: '$_TABLE_PRODUCT_EXTRA_COLUMN_KEY = ?',
+        whereArgs: <String>[_getExtraKey(productList, id)],
+      );
+
+  /// Returns the number of products of each product list
+  Future<Map<String, int>> getStats() async {
+    final Map<String, int> result = <String, int>{};
+    const String COLUMN_NAME_COUNT = 'my_count';
+    final List<Map<String, dynamic>> countResult =
+        await localDatabase.database.rawQuery(
+      'select '
+      '  $_TABLE_PRODUCT_EXTRA_COLUMN_KEY '
+      ', count(1) as $COLUMN_NAME_COUNT '
+      'from'
+      '  $_TABLE_PRODUCT_EXTRA '
+      'group by '
+      '  $_TABLE_PRODUCT_EXTRA_COLUMN_KEY',
+    );
+    for (final Map<String, dynamic> row in countResult) {
+      final String extraKey = row[_TABLE_PRODUCT_EXTRA_COLUMN_KEY] as String;
+      final int count = row[COLUMN_NAME_COUNT] as int;
+      result[extraKey] = count;
+    }
+    return result;
+  }
 }
diff --git a/packages/smooth_app/lib/database/dao_product_list.dart b/packages/smooth_app/lib/database/dao_product_list.dart
index 42375389ed16..a21093995723 100644
--- a/packages/smooth_app/lib/database/dao_product_list.dart
+++ b/packages/smooth_app/lib/database/dao_product_list.dart
@@ -15,11 +15,6 @@ class DaoProductList extends AbstractDao {
   static const String _TABLE_PRODUCT_LIST_COLUMN_TYPE = 'list_type';
   static const String _TABLE_PRODUCT_LIST_COLUMN_PARAMETERS = 'parameters';
 
-  static const String _TABLE_PRODUCT_LIST_ITEM = 'product_list_item';
-  static const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_ID = '_id';
-  static const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID = 'list_id';
-  static const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE = 'barcode';
-
   static const String _TABLE_PRODUCT_LIST_EXTRA = 'product_list_extra';
   static const String _TABLE_PRODUCT_LIST_EXTRA_COLUMN_LIST_ID = 'list_id';
   static const String _TABLE_PRODUCT_LIST_EXTRA_COLUMN_KEY = 'extra_key';
@@ -30,6 +25,11 @@ class DaoProductList extends AbstractDao {
     final int oldVersion,
     final int newVersion,
   ) async {
+    const String _TABLE_PRODUCT_LIST_ITEM = 'product_list_item';
+    const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_ID = '_id';
+    const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID = 'list_id';
+    const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE = 'barcode';
+
     if (oldVersion < 2) {
       await db.execute('create table $_TABLE_PRODUCT_LIST('
           '$_TABLE_PRODUCT_LIST_COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,'
@@ -44,7 +44,8 @@ class DaoProductList extends AbstractDao {
           '$_TABLE_PRODUCT_LIST_COLUMN_PARAMETERS'
           ')');
 
-      await db.execute('create table $_TABLE_PRODUCT_LIST_ITEM('
+      await db.execute(
+          'create table $_TABLE_PRODUCT_LIST_ITEM(' // to be dropped
           '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_ID INTEGER PRIMARY KEY AUTOINCREMENT,'
           '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID INT NOT NULL,'
           '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE TEXT NOT NULL,'
@@ -97,18 +98,37 @@ class DaoProductList extends AbstractDao {
       await db.execute(
           'alter table $TMP_TABLE_NAME rename to $_TABLE_PRODUCT_LIST_ITEM');
     }
+    if (oldVersion < 8) {
+      // moving from product list item to product_extra
+      // and dropping table product list item
+      await db.transaction(
+        (final Transaction transaction) async {
+          await _upgradeToVersion8(transaction);
+          await transaction.execute('drop table $_TABLE_PRODUCT_LIST_ITEM');
+        },
+      );
+    }
   }
 
   Future<int> getTimestamp(final ProductList productList) async {
-    final Map<String, dynamic> record = await _getRecord(productList);
+    final Map<String, dynamic> record = await _getRecord(
+      productList,
+      localDatabase.database,
+    );
     if (record == null) {
       return null;
     }
     return record[LocalDatabase.COLUMN_TIMESTAMP] as int;
   }
 
-  Future<int> _getId(final ProductList productList) async {
-    final Map<String, dynamic> record = await _getRecord(productList);
+  Future<int> _getId(
+    final ProductList productList,
+    final DatabaseExecutor databaseExecutor,
+  ) async {
+    final Map<String, dynamic> record = await _getRecord(
+      productList,
+      databaseExecutor,
+    );
     if (record == null) {
       return null;
     }
@@ -123,14 +143,15 @@ class DaoProductList extends AbstractDao {
           final ProductList productList) =>
       <String>[productList.listType, productList.parameters];
 
-  Future<Map<String, dynamic>> _getRecord(final ProductList productList) async {
+  Future<Map<String, dynamic>> _getRecord(
+    final ProductList productList,
+    final DatabaseExecutor databaseExecutor,
+  ) async {
     if (productList.listType == ProductList.LIST_TYPE_HISTORY ||
         productList.listType == ProductList.LIST_TYPE_SCAN) {
-      throw Exception(
-          'Some lists are "different", and you should use this method!');
+      return null;
     }
-    final List<Map<String, dynamic>> queryResult =
-        await localDatabase.database.query(
+    final List<Map<String, dynamic>> queryResult = await databaseExecutor.query(
       _TABLE_PRODUCT_LIST,
       columns: <String>[
         _TABLE_PRODUCT_LIST_COLUMN_ID,
@@ -150,6 +171,120 @@ class DaoProductList extends AbstractDao {
     return queryResult.first;
   }
 
+  // TODO(monsieurtanuki): remove when this code is never called anymore
+  static Future<void> _upgradeToVersion8(
+      final DatabaseExecutor databaseExecutor) async {
+    const String _TABLE_PRODUCT_LIST_ITEM = 'product_list_item';
+    const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_ID = '_id';
+    const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID = 'list_id';
+    const String _TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE = 'barcode';
+
+    // listing the product lists that are not concerned
+    final Set<int> toBeIgnoredLists = <int>{};
+    final List<Map<String, dynamic>> queryResultsPre =
+        await databaseExecutor.query(
+      _TABLE_PRODUCT_LIST,
+      columns: <String>[_TABLE_PRODUCT_LIST_COLUMN_ID],
+      where: '$_TABLE_PRODUCT_LIST_COLUMN_TYPE in (?, ?)',
+      whereArgs: <String>[
+        ProductList.LIST_TYPE_HISTORY,
+        ProductList.LIST_TYPE_SCAN,
+      ],
+    );
+    for (final Map<String, dynamic> row in queryResultsPre) {
+      final int id = row[_TABLE_PRODUCT_LIST_COLUMN_ID] as int;
+      toBeIgnoredLists.add(id);
+    }
+
+    final List<Map<String, dynamic>> queryResults =
+        await databaseExecutor.query(
+      _TABLE_PRODUCT_LIST_ITEM,
+      columns: <String>[
+        _TABLE_PRODUCT_LIST_ITEM_COLUMN_ID,
+        _TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID,
+        _TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE,
+        LocalDatabase.COLUMN_TIMESTAMP,
+      ],
+      orderBy: '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_ID DESC', // most recent wins
+    );
+    final Map<int, List<dynamic>> map = <int, List<dynamic>>{};
+    for (final Map<String, dynamic> row in queryResults) {
+      final int listId = row[_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID] as int;
+      if (toBeIgnoredLists.contains(listId)) {
+        continue;
+      }
+      final String barcode =
+          row[_TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE] as String;
+      final int timestamp = row[LocalDatabase.COLUMN_TIMESTAMP] as int;
+      List<dynamic> item = map[listId];
+      if (item == null) {
+        map[listId] = item = <dynamic>[];
+      }
+      item.add(barcode);
+      item.add(timestamp);
+    }
+    for (final int listId in map.keys) {
+      final String extraKey = 'list/$listId';
+      const String STRING_PARAMETER = '';
+      const List<String> COLUMN_NAMES = <String>[
+        DaoProduct.TABLE_PRODUCT_COLUMN_BARCODE,
+        'extra_key',
+        'extra_value',
+        'extra_int_value',
+        LocalDatabase.COLUMN_TIMESTAMP,
+      ];
+      final String variables = '?${',?' * (COLUMN_NAMES.length - 1)}';
+      final int numCols = COLUMN_NAMES.length;
+
+      await databaseExecutor.delete(
+        'product_extra',
+        where: 'extra_key = ?',
+        whereArgs: <String>[extraKey],
+      );
+
+      final List<dynamic> insertParameters = <dynamic>[];
+      final List<dynamic> parameters = map[listId];
+      final int max = parameters.length ~/ 2;
+      final Map<String, int> timestamps = <String, int>{};
+      for (int i = 0; i < parameters.length; i += 2) {
+        final int index = max - (i ~/ 2);
+        final String barcode = parameters[i] as String;
+        final int timestamp = parameters[i + 1] as int;
+        final int previous = timestamps[barcode];
+        if (previous != null) {
+          continue;
+        }
+        timestamps[barcode] = timestamp;
+        insertParameters.addAll(<dynamic>[
+          barcode,
+          extraKey,
+          STRING_PARAMETER,
+          index,
+          timestamp,
+        ]);
+
+        if (insertParameters.length > 500) {
+          final int additionalRecordsNumber =
+              -1 + insertParameters.length ~/ numCols;
+          await databaseExecutor.rawInsert(
+              'insert into product_extra(${COLUMN_NAMES.join(',')}) '
+              'values($variables)${',($variables)' * additionalRecordsNumber}',
+              insertParameters);
+          insertParameters.clear();
+        }
+      }
+      if (insertParameters.isNotEmpty) {
+        final int additionalRecordsNumber =
+            -1 + insertParameters.length ~/ numCols;
+        await databaseExecutor.rawInsert(
+            'insert into product_extra(${COLUMN_NAMES.join(',')}) '
+            'values($variables)${',($variables)' * additionalRecordsNumber}',
+            insertParameters);
+        insertParameters.clear();
+      }
+    }
+  }
+
   Future<bool> rename(
     final ProductList productList,
     final String newName,
@@ -171,64 +306,33 @@ class DaoProductList extends AbstractDao {
   }
 
   Future<void> put(final ProductList productList) async =>
-      await _refreshListItems(
-        productList,
-        await _upsertProductList(productList),
+      await localDatabase.database.transaction(
+        (final Transaction transaction) async =>
+            await DaoProductExtra(localDatabase).bulkInsertExtra(
+          databaseExecutor: transaction,
+          productList: productList,
+          productListId: await _getId(productList, transaction),
+        ),
       );
 
-  Future<bool> get(final ProductList productList) async {
-    if (await DaoProductExtra(localDatabase).getList(productList)) {
-      return true;
-    }
-    final int id = await _getId(productList);
-    if (id == null) {
-      return false;
-    }
-    final List<String> barcodes = await _getBarcodes(id);
-    final Map<String, Product> products =
-        await DaoProduct(localDatabase).getAll(barcodes);
-    productList.set(barcodes, products);
-    return true;
-  }
+  Future<int> create(final ProductList productList) async =>
+      await _upsertProductList(productList, localDatabase.database);
 
-  Future<List<String>> getFirstBarcodes(
-    final ProductList productList,
-    final int limit,
-    final bool reverse,
-    final bool unique,
-  ) async {
-    final List<String> result =
-        await DaoProductExtra(localDatabase).getFirstBarcodes(
-      productList,
-      limit,
-    );
-    if (result != null) {
-      return result;
-    }
-    final Map<String, dynamic> record = await _getRecord(productList);
-    if (record == null) {
-      return null;
-    }
-    final int id = record[_TABLE_PRODUCT_LIST_COLUMN_ID] as int;
-    return await _getBarcodes(
-      id,
-      limit: limit,
-      reverse: reverse,
-      unique: unique,
-    );
-  }
+  Future<bool> get(final ProductList productList) async =>
+      await DaoProductExtra(localDatabase).getList(
+        productList,
+        await _getId(productList, localDatabase.database),
+      );
 
   Future<List<Product>> getFirstProducts(
     final ProductList productList,
     final int limit,
-    final bool reverse,
-    final bool unique,
   ) async {
-    final List<String> barcodes = await getFirstBarcodes(
+    final List<String> barcodes =
+        await DaoProductExtra(localDatabase).getFirstBarcodes(
       productList,
+      await _getId(productList, localDatabase.database),
       limit,
-      reverse,
-      unique,
     );
     final Map<String, Product> products =
         await DaoProduct(localDatabase).getAll(barcodes);
@@ -242,55 +346,26 @@ class DaoProductList extends AbstractDao {
     return result;
   }
 
-  Future<int> removeBarcode(
-    final ProductList productList,
-    final String barcode,
-  ) async =>
-      _addOrRemoveBarcode(productList, barcode, false);
-
-  Future<int> addBarcode(
-    final ProductList productList,
-    final String barcode,
-  ) async =>
-      _addOrRemoveBarcode(productList, barcode, true);
-
-  Future<int> _addOrRemoveBarcode(
-    final ProductList productList,
-    final String barcode,
-    final bool addOrRemove,
-  ) async {
-    final int id = await _upsertProductList(productList);
-    if (addOrRemove) {
-      productList.barcodes.add(barcode);
-      await _insertListItems(id, <String>[barcode]);
-      return 1;
-    }
-    productList.barcodes.removeWhere((String element) => element == barcode);
-    return await localDatabase.database.delete(
-      _TABLE_PRODUCT_LIST_ITEM,
-      where: '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID = ? '
-          'and $_TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE = ?',
-      whereArgs: <dynamic>[id, barcode],
+  Future<void> delete(final ProductList productList) async {
+    await localDatabase.database.transaction(
+      (final Transaction transaction) async {
+        final int id = await _getId(productList, transaction);
+        if (id != null) {
+          await transaction.delete(
+            _TABLE_PRODUCT_LIST,
+            where: _getProductListUKWhere(),
+            whereArgs: _getProductListUKWhereArgs(productList),
+          );
+        }
+        await DaoProductExtra(localDatabase).clearList(
+          productList,
+          id,
+          transaction,
+        );
+      },
     );
   }
 
-  Future<int> delete(final ProductList productList) async =>
-      await localDatabase.database.delete(
-        _TABLE_PRODUCT_LIST,
-        where: _getProductListUKWhere(),
-        whereArgs: _getProductListUKWhereArgs(productList),
-      );
-
-  Future<int> clear(final ProductList productList) async {
-    // TODO(monsieurtanuki): create a version for history and scan, if needed
-    final int id = await _getId(productList);
-    if (id == null) {
-      return null;
-    }
-    productList.barcodes.clear();
-    return _clearListItems(id);
-  }
-
   Future<Map<int, Map<String, String>>> _getExtras({final int listId}) async {
     final Map<int, Map<String, String>> result = <int, Map<String, String>>{};
     final List<Map<String, dynamic>> queryResult =
@@ -326,28 +401,9 @@ class DaoProductList extends AbstractDao {
     final bool reverse = true,
     final int limit,
   }) async {
-    final Map<int, int> counts = <int, int>{};
-    final Map<int, int> countDistincts = <int, int>{};
-
-    if (withStats) {
-      const String COLUMN_NAME_COUNT = 'my_count';
-      const String COLUMN_NAME_COUNT_DISTINCT = 'my_count_distinct';
-      final List<Map<String, dynamic>> countResult =
-          await localDatabase.database.rawQuery(
-        'select '
-        '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID,'
-        'count($_TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE) as $COLUMN_NAME_COUNT,'
-        'count(distinct $_TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE) as $COLUMN_NAME_COUNT_DISTINCT '
-        'from $_TABLE_PRODUCT_LIST_ITEM '
-        'group by $_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID',
-      );
-      for (final Map<String, dynamic> row in countResult) {
-        final int productListId =
-            row[_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID] as int;
-        counts[productListId] = row[COLUMN_NAME_COUNT] as int;
-        countDistincts[productListId] = row[COLUMN_NAME_COUNT_DISTINCT] as int;
-      }
-    }
+    final Map<String, int> counts = withStats
+        ? await DaoProductExtra(localDatabase).getStats()
+        : <String, int>{};
 
     final Map<int, Map<String, String>> extras = await _getExtras();
     final List<ProductList> result = <ProductList>[];
@@ -373,72 +429,22 @@ class DaoProductList extends AbstractDao {
         listType: row[_TABLE_PRODUCT_LIST_COLUMN_TYPE] as String,
         parameters: row[_TABLE_PRODUCT_LIST_COLUMN_PARAMETERS] as String,
         databaseTimestamp: row[LocalDatabase.COLUMN_TIMESTAMP] as int,
-        databaseCount: counts[productListId],
-        databaseCountDistinct: countDistincts[productListId],
+        databaseCountDistinct: counts[productListId],
       )..extraTags = extras[productListId];
       result.add(item);
     }
     return result;
   }
 
-  Future<List<ProductList>> getAllWithBarcode(final String barcode) async {
-    final List<ProductList> result = <ProductList>[];
-    final List<Map<String, dynamic>> queryResult =
-        await localDatabase.database.rawQuery(
-      'select '
-      '$_TABLE_PRODUCT_LIST_COLUMN_TYPE,'
-      '$_TABLE_PRODUCT_LIST_COLUMN_PARAMETERS '
-      'from $_TABLE_PRODUCT_LIST L '
-      'where '
-      'exists('
-      'select null from $_TABLE_PRODUCT_LIST_ITEM I '
-      'where L.$_TABLE_PRODUCT_LIST_COLUMN_ID = I.$_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID '
-      'and I.$_TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE = ?)',
-      <String>[barcode],
-    );
-    for (final Map<String, dynamic> row in queryResult) {
-      final ProductList item = ProductList(
-        listType: row[_TABLE_PRODUCT_LIST_COLUMN_TYPE] as String,
-        parameters: row[_TABLE_PRODUCT_LIST_COLUMN_PARAMETERS] as String,
-      );
-      result.add(item);
-    }
-    return result;
-  }
-
-  Future<List<String>> _getBarcodes(
-    final int id, {
-    final int limit,
-    final bool reverse = false,
-    final bool unique = false,
-  }) async {
-    const String BARCODE_COLUMN_NAME = _TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE;
-    final List<Map<String, dynamic>> query = await localDatabase.database.query(
-      _TABLE_PRODUCT_LIST_ITEM,
-      where: '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID = ?',
-      whereArgs: <dynamic>[id],
-      columns: <String>[BARCODE_COLUMN_NAME],
-      orderBy:
-          '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_ID ${reverse ? 'DESC' : 'ASC'}',
-      limit: unique ? null : limit,
-    );
-    final List<String> result = <String>[];
-    for (final Map<String, dynamic> row in query) {
-      final String barcode = row[BARCODE_COLUMN_NAME] as String;
-      if ((!unique) || !result.contains(barcode)) {
-        result.add(barcode);
-        if (limit != null && result.length >= limit) {
-          break;
-        }
-      }
-    }
-    return result;
-  }
-
-  Future<int> _upsertProductList(final ProductList productList) async {
-    int id = await _getId(productList);
+  /// Returns the database primary key id of the [ProductList] for user lists
+  /// or null for predetermined lists like "history"
+  Future<int> _upsertProductList(
+    final ProductList productList,
+    final DatabaseExecutor databaseExecutor,
+  ) async {
+    int id = await _getId(productList, databaseExecutor);
     if (id == null) {
-      id = await localDatabase.database.insert(
+      id = await databaseExecutor.insert(
         _TABLE_PRODUCT_LIST,
         <String, dynamic>{
           _TABLE_PRODUCT_LIST_COLUMN_TYPE: productList.listType,
@@ -448,7 +454,7 @@ class DaoProductList extends AbstractDao {
         conflictAlgorithm: ConflictAlgorithm.fail,
       );
     } else {
-      await localDatabase.database.update(
+      await databaseExecutor.update(
         _TABLE_PRODUCT_LIST,
         <String, dynamic>{
           LocalDatabase.COLUMN_TIMESTAMP: LocalDatabase.nowInMillis(),
@@ -458,24 +464,25 @@ class DaoProductList extends AbstractDao {
         conflictAlgorithm: ConflictAlgorithm.fail,
       );
     }
-    _upsertProductListExtra(productList.extraTags, id);
+    _upsertProductListExtra(productList.extraTags, id, databaseExecutor);
     return id;
   }
 
-  Future<void> _upsertProductListExtra(
+  static Future<void> _upsertProductListExtra(
     final Map<String, String> extraTags,
     final int productListId,
+    final DatabaseExecutor databaseExecutor,
   ) async {
-    await localDatabase.database.delete(
+    await databaseExecutor.delete(
       _TABLE_PRODUCT_LIST_EXTRA,
       where: '$_TABLE_PRODUCT_LIST_EXTRA_COLUMN_LIST_ID = ?',
       whereArgs: <dynamic>[productListId],
     );
-    if (extraTags == null) {
+    if (extraTags == null || extraTags.isEmpty) {
       return;
     }
     for (final MapEntry<String, String> entry in extraTags.entries) {
-      await localDatabase.database.insert(
+      await databaseExecutor.insert(
         _TABLE_PRODUCT_LIST_EXTRA,
         <String, dynamic>{
           _TABLE_PRODUCT_LIST_EXTRA_COLUMN_LIST_ID: productListId,
@@ -486,55 +493,4 @@ class DaoProductList extends AbstractDao {
       );
     }
   }
-
-  Future<void> _refreshListItems(
-      final ProductList productList, final int id) async {
-    await _clearListItems(id);
-    await _insertListItems(id, productList.barcodes);
-  }
-
-  Future<int> _clearListItems(final int id) async =>
-      await localDatabase.database.delete(
-        _TABLE_PRODUCT_LIST_ITEM,
-        where: '$_TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID = ?',
-        whereArgs: <dynamic>[id],
-      );
-
-  @override
-  List<String> getBulkInsertColumns() => <String>[
-        _TABLE_PRODUCT_LIST_ITEM_COLUMN_BARCODE,
-        _TABLE_PRODUCT_LIST_ITEM_COLUMN_LIST_ID,
-        LocalDatabase.COLUMN_TIMESTAMP
-      ];
-
-  @override
-  String getTableName() => _TABLE_PRODUCT_LIST_ITEM;
-
-  /// Optimized bulk insert of product list items
-  ///
-  /// Stats for 500 records on my smartphone:
-  /// - 7 seconds for MAX_RECORD_NUMBER = 1 (one by one)
-  /// - 150 milliseconds for MAX_RECORD_NUMBER = 300
-  Future<int> _insertListItems(
-    final int id,
-    final List<String> barcodes,
-  ) async {
-    final int maxRecordNumber = getBulkMaxRecordNumber();
-    final int timestamp = LocalDatabase.nowInMillis();
-    final List<dynamic> parameters = <dynamic>[];
-    int counter = 0;
-    for (final String barcode in barcodes) {
-      parameters.add(barcode);
-      parameters.add(id);
-      parameters.add(timestamp);
-      counter++;
-      if (counter == maxRecordNumber) {
-        await bulkInsert(parameters, localDatabase.database);
-        counter = 0;
-        parameters.clear();
-      }
-    }
-    await bulkInsert(parameters, localDatabase.database);
-    return barcodes.length;
-  }
 }
diff --git a/packages/smooth_app/lib/database/local_database.dart b/packages/smooth_app/lib/database/local_database.dart
index 18bdf09cd3a0..2e7db85bf9a0 100644
--- a/packages/smooth_app/lib/database/local_database.dart
+++ b/packages/smooth_app/lib/database/local_database.dart
@@ -29,7 +29,7 @@ class LocalDatabase extends ChangeNotifier {
 
     final Database database = await openDatabase(
       databasePath,
-      version: 7,
+      version: 8,
       singleInstance: true,
       onUpgrade: _onUpgrade,
     );
diff --git a/packages/smooth_app/lib/pages/home_page.dart b/packages/smooth_app/lib/pages/home_page.dart
index 3bcae480a1f0..86e510d26ea9 100644
--- a/packages/smooth_app/lib/pages/home_page.dart
+++ b/packages/smooth_app/lib/pages/home_page.dart
@@ -145,6 +145,7 @@ class _HomePageState extends State<HomePage> {
               parameters: '',
             ),
             nbInPreview: 5,
+            andThen: () => setState(() {}),
           ),
           GestureDetector(
             child: SmoothCard(
diff --git a/packages/smooth_app/lib/pages/list_page.dart b/packages/smooth_app/lib/pages/list_page.dart
index 81fd18df1fc9..e1b3eadb29d7 100644
--- a/packages/smooth_app/lib/pages/list_page.dart
+++ b/packages/smooth_app/lib/pages/list_page.dart
@@ -69,6 +69,7 @@ class _ListPageState extends State<ListPage> {
                       daoProductList: daoProductList,
                       productList: item,
                       nbInPreview: 5,
+                      andThen: () => setState(() {}),
                     );
                   },
                 );
diff --git a/packages/smooth_app/lib/pages/multi_select_product_page.dart b/packages/smooth_app/lib/pages/multi_select_product_page.dart
index df0ff3e0b317..83502dd8fc36 100644
--- a/packages/smooth_app/lib/pages/multi_select_product_page.dart
+++ b/packages/smooth_app/lib/pages/multi_select_product_page.dart
@@ -54,7 +54,7 @@ class _MultiSelectProductPageState extends State<MultiSelectProductPage> {
     super.initState();
     _selectedBarcodes.add(widget.barcode);
     if (widget.productList != null) {
-      _orderedBarcodes = widget.productList.getOrderedBarcodes();
+      _orderedBarcodes = widget.productList.barcodes;
     } else {
       _orderedBarcodes = widget.pantry.getOrderedBarcodes();
     }
@@ -63,7 +63,7 @@ class _MultiSelectProductPageState extends State<MultiSelectProductPage> {
   void _removeBarcode(final String barcode) {
     _orderedBarcodes.remove(barcode);
     if (widget.productList != null) {
-      widget.productList.barcodes.remove(barcode);
+      widget.productList.remove(barcode);
     } else {
       widget.pantry.removeBarcode(barcode);
     }
diff --git a/packages/smooth_app/lib/pages/product/common/product_list_dialog_helper.dart b/packages/smooth_app/lib/pages/product/common/product_list_dialog_helper.dart
index 10b5f59d7529..ece054f40ddd 100644
--- a/packages/smooth_app/lib/pages/product/common/product_list_dialog_helper.dart
+++ b/packages/smooth_app/lib/pages/product/common/product_list_dialog_helper.dart
@@ -91,10 +91,7 @@ class ProductListDialogHelper {
               if (!formKey.currentState.validate()) {
                 return;
               }
-              if (await daoProductList.get(newProductList)) {
-                // TODO(monsieurtanuki): unexpected, but do something!
-                return;
-              }
+              await daoProductList.create(newProductList);
               await daoProductList.put(newProductList);
               Navigator.pop(context, newProductList);
             },
diff --git a/packages/smooth_app/lib/pages/product/common/product_list_page.dart b/packages/smooth_app/lib/pages/product/common/product_list_page.dart
index 341f1d1eb6df..cfea2aafa425 100644
--- a/packages/smooth_app/lib/pages/product/common/product_list_page.dart
+++ b/packages/smooth_app/lib/pages/product/common/product_list_page.dart
@@ -33,7 +33,7 @@ class _ProductListPageState extends State<ProductListPage> {
     final ColorScheme colorScheme = Theme.of(context).colorScheme;
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
     productList ??= widget.productList;
-    final List<Product> products = productList.getUniqueList();
+    final List<Product> products = productList.getList();
     final Map<String, ProductExtra> productExtras = productList.productExtras;
     final List<_Meta> metas = <_Meta>[];
     if (productList.listType == ProductList.LIST_TYPE_HISTORY ||
@@ -58,11 +58,15 @@ class _ProductListPageState extends State<ProductListPage> {
     }
     bool renamable = false;
     bool deletable = false;
+    bool dismissible = false;
+    bool reorderable = false;
     switch (productList.listType) {
       case ProductList.LIST_TYPE_USER_DEFINED:
         // TODO(monsieurtanuki): clear the preference when the product list is deleted
         deletable = true;
         renamable = true;
+        reorderable = true;
+        dismissible = true;
         break;
       case ProductList.LIST_TYPE_HTTP_SEARCH_KEYWORDS:
       case ProductList.LIST_TYPE_HTTP_SEARCH_CATEGORY:
@@ -71,6 +75,10 @@ class _ProductListPageState extends State<ProductListPage> {
         break;
       case ProductList.LIST_TYPE_SCAN:
       case ProductList.LIST_TYPE_HISTORY:
+        dismissible = true;
+        break;
+      default:
+        throw Exception('unknown list type ${productList.listType}');
     }
     return Scaffold(
       appBar: AppBar(
@@ -178,12 +186,20 @@ class _ProductListPageState extends State<ProductListPage> {
               child: Text(appLocalizations.no_prodcut_in_list,
                   style: Theme.of(context).textTheme.subtitle1),
             )
-          : ListView.builder(
+          : ReorderableListView.builder(
+              onReorder: (final int oldIndex, final int newIndex) async {
+                productList.reorder(oldIndex, newIndex);
+                daoProductList
+                    .put(productList); // careful: if "await", flickering
+                setState(() {});
+              },
+              buildDefaultDragHandles: false,
               itemCount: metas.length,
               itemBuilder: (BuildContext context, int index) {
                 final _Meta meta = metas[index];
                 if (!meta.isProduct()) {
                   return ListTile(
+                    key: Key(meta.daysAgoLabel),
                     leading: const Icon(Icons.history),
                     title: Text(meta.daysAgoLabel),
                   );
@@ -200,6 +216,12 @@ class _ProductListPageState extends State<ProductListPage> {
                       await daoProductList.get(productList);
                       setState(() {});
                     },
+                    handle: !reorderable
+                        ? null
+                        : ReorderableDragStartListener(
+                            index: index,
+                            child: const Icon(Icons.drag_handle),
+                          ),
                     onLongPress: () async {
                       await Navigator.push<Widget>(
                         context,
@@ -215,14 +237,32 @@ class _ProductListPageState extends State<ProductListPage> {
                     },
                   ),
                 );
-                return Dismissible(
-                  background: Container(color: colorScheme.background),
-                  key: Key(barcode),
-                  onDismissed: (final DismissDirection direction) async {
-                    await daoProductList.removeBarcode(productList, barcode);
-                    setState(() => metas.removeAt(index));
-                    // TODO(monsieurtanuki): add a snackbar ("put back the food")
-                  },
+                if (dismissible) {
+                  return Dismissible(
+                    background: Container(color: colorScheme.background),
+                    key: Key(meta.product.barcode),
+                    onDismissed: (final DismissDirection direction) async {
+                      final bool removed =
+                          productList.remove(meta.product.barcode);
+                      if (removed) {
+                        await daoProductList.put(productList);
+                        setState(() => metas.removeAt(index));
+                      }
+                      ScaffoldMessenger.of(context).showSnackBar(
+                        SnackBar(
+                          content: Text(removed
+                              ? 'Product removed'
+                              : 'Could not remove product'),
+                          duration: const Duration(seconds: 3),
+                        ),
+                      );
+                      // TODO(monsieurtanuki): add a snackbar ("put back the food")
+                    },
+                    child: child,
+                  );
+                }
+                return Container(
+                  key: Key(meta.product.barcode),
                   child: child,
                 );
               },
diff --git a/packages/smooth_app/lib/pages/product/product_page.dart b/packages/smooth_app/lib/pages/product/product_page.dart
index 5c1999417471..febd8b514bcf 100644
--- a/packages/smooth_app/lib/pages/product/product_page.dart
+++ b/packages/smooth_app/lib/pages/product/product_page.dart
@@ -557,7 +557,7 @@ class _ProductPageState extends State<ProductPage> {
       return;
     }
     final List<Product> products = <Product>[widget.product];
-    productCopyHelper.copy(
+    await productCopyHelper.copy(
       context: context,
       target: target,
       allPantries: allPantries,
diff --git a/packages/smooth_app/lib/pages/product_copy_helper.dart b/packages/smooth_app/lib/pages/product_copy_helper.dart
index a62c45333f16..f9c589803fc9 100644
--- a/packages/smooth_app/lib/pages/product_copy_helper.dart
+++ b/packages/smooth_app/lib/pages/product_copy_helper.dart
@@ -170,10 +170,7 @@ class ProductCopyHelper {
     await daoProductList.get(target);
     int count = 0;
     for (final Product product in products) {
-      if (target.barcodes.contains(product.barcode)) {
-        // do nothing?
-      } else {
-        target.add(product);
+      if (target.add(product)) {
         count++;
       }
     }
