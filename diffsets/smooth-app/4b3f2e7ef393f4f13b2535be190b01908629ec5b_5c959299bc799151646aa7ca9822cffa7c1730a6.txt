diff --git a/packages/smooth_app/lib/pages/hunger_games/congrats.dart b/packages/smooth_app/lib/pages/hunger_games/congrats.dart
index c18f4b921218..1859aa464a80 100644
--- a/packages/smooth_app/lib/pages/hunger_games/congrats.dart
+++ b/packages/smooth_app/lib/pages/hunger_games/congrats.dart
@@ -27,6 +27,9 @@ class CongratsWidget extends StatelessWidget {
     final UserManagementProvider userManagementProvider =
         context.watch<UserManagementProvider>();
 
+    final Brightness brightness = Theme.of(context).brightness;
+    final bool isDarkMode = brightness == Brightness.dark;
+
     return Center(
       child: Column(
         mainAxisAlignment: MainAxisAlignment.center,
@@ -34,7 +37,7 @@ class CongratsWidget extends StatelessWidget {
           const Icon(
             Icons.grade,
             color: Colors.amber,
-            size: 100,
+            size: 70,
           ),
           Padding(
             padding: const EdgeInsets.symmetric(vertical: MEDIUM_SPACE),
@@ -65,7 +68,12 @@ class CongratsWidget extends StatelessWidget {
           else
             EMPTY_WIDGET,
           TextButton(
-            child: Text(appLocalizations.close),
+            child: Text(
+              appLocalizations.close,
+              style: Theme.of(context).textTheme.bodyLarge!.apply(
+                    color: isDarkMode ? Colors.white : Colors.black,
+                  ),
+            ),
             onPressed: () => Navigator.maybePop<Widget>(context),
           ),
         ],
diff --git a/packages/smooth_app/lib/pages/hunger_games/question_answers_options.dart b/packages/smooth_app/lib/pages/hunger_games/question_answers_options.dart
old mode 100644
new mode 100755
diff --git a/packages/smooth_app/lib/pages/hunger_games/question_card.dart b/packages/smooth_app/lib/pages/hunger_games/question_card.dart
old mode 100644
new mode 100755
diff --git a/packages/smooth_app/lib/pages/hunger_games/question_page.dart b/packages/smooth_app/lib/pages/hunger_games/question_page.dart
old mode 100644
new mode 100755
diff --git a/packages/smooth_app/lib/pages/product/product_question_answers_options.dart b/packages/smooth_app/lib/pages/product/product_question_answers_options.dart
new file mode 100644
index 000000000000..bd708b337da7
--- /dev/null
+++ b/packages/smooth_app/lib/pages/product/product_question_answers_options.dart
@@ -0,0 +1,103 @@
+import 'package:flutter/material.dart';
+import 'package:flutter_gen/gen_l10n/app_localizations.dart';
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:smooth_app/generic_lib/design_constants.dart';
+
+/// Display of the typical Yes / No / Maybe options for Robotoff
+class ProductQuestionAnswersOptions extends StatelessWidget {
+  const ProductQuestionAnswersOptions(
+    this.question, {
+    Key? key,
+    required this.onAnswer,
+  }) : super(key: key);
+
+  final RobotoffQuestion question;
+  final Function(InsightAnnotation) onAnswer;
+
+  @override
+  Widget build(BuildContext context) {
+    const Color yesBackground = Colors.green;
+    const Color noBackground = Colors.red;
+    const Color maybeBackground = Colors.white;
+    const Color yesNoTextColor = Colors.white;
+    final Color maybeTextColor = Colors.grey.shade700;
+
+    final double yesNoHeight = MediaQuery.of(context).size.width / (6);
+
+    return Row(
+      mainAxisAlignment: MainAxisAlignment.spaceBetween,
+      children: <Widget>[
+        Expanded(
+          child: SizedBox(
+            height: yesNoHeight,
+            child: _buildAnswerButton(
+              context,
+              insightAnnotation: InsightAnnotation.NO,
+              backgroundColor: noBackground,
+              contentColor: yesNoTextColor,
+            ),
+          ),
+        ),
+        Expanded(
+          child: SizedBox(
+            height: yesNoHeight,
+            child: _buildAnswerButton(
+              context,
+              insightAnnotation: InsightAnnotation.MAYBE,
+              backgroundColor: maybeBackground,
+              contentColor: maybeTextColor,
+            ),
+          ),
+        ),
+        Expanded(
+          child: SizedBox(
+            height: yesNoHeight,
+            child: _buildAnswerButton(
+              context,
+              insightAnnotation: InsightAnnotation.YES,
+              backgroundColor: yesBackground,
+              contentColor: yesNoTextColor,
+            ),
+          ),
+        ),
+      ],
+    );
+  }
+
+  Widget _buildAnswerButton(
+    BuildContext context, {
+    required InsightAnnotation insightAnnotation,
+    required Color backgroundColor,
+    required Color contentColor,
+    EdgeInsets padding = const EdgeInsets.all(SMALL_SPACE),
+  }) {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+    final ThemeData theme = Theme.of(context);
+
+    String buttonText;
+    switch (insightAnnotation) {
+      case InsightAnnotation.YES:
+        buttonText = appLocalizations.yes;
+        break;
+      case InsightAnnotation.NO:
+        buttonText = appLocalizations.no;
+        break;
+      case InsightAnnotation.MAYBE:
+        buttonText = appLocalizations.skip;
+    }
+
+    return Padding(
+      padding: padding,
+      child: TextButton(
+        onPressed: () => onAnswer(insightAnnotation),
+        style: ButtonStyle(
+          backgroundColor: MaterialStateProperty.all(backgroundColor),
+        ),
+        child: Text(
+          buttonText,
+          style: theme.textTheme.displaySmall!.apply(color: contentColor),
+        ),
+      ),
+    );
+  }
+}
diff --git a/packages/smooth_app/lib/pages/product/product_question_card.dart b/packages/smooth_app/lib/pages/product/product_question_card.dart
new file mode 100644
index 000000000000..212913a8ff41
--- /dev/null
+++ b/packages/smooth_app/lib/pages/product/product_question_card.dart
@@ -0,0 +1,81 @@
+import 'package:flutter/material.dart';
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:provider/provider.dart';
+import 'package:shimmer/shimmer.dart';
+import 'package:smooth_app/database/local_database.dart';
+import 'package:smooth_app/generic_lib/design_constants.dart';
+import 'package:smooth_app/pages/product/common/product_refresher.dart';
+
+/// Display of a Robotoff question text.
+class ProductQuestionCard extends StatelessWidget {
+  const ProductQuestionCard(
+    this.question, {
+    Key? key,
+  }) : super(key: key);
+
+  final RobotoffQuestion question;
+
+  static const Color robotoffBackground = Color(0xFFFFEFB7);
+
+  @override
+  Widget build(BuildContext context) {
+    final Future<Product?> productFuture =
+        ProductRefresher().silentFetchAndRefresh(
+      barcode: question.barcode!,
+      localDatabase: context.read<LocalDatabase>(),
+    );
+
+    return FutureBuilder<Product?>(
+        future: productFuture,
+        builder: (BuildContext context, AsyncSnapshot<Product?> snapshot) {
+          if (!snapshot.hasData) {
+            return _buildQuestionShimmer();
+          }
+          return _buildQuestionText(context, question);
+        });
+  }
+
+  Widget _buildQuestionText(BuildContext context, RobotoffQuestion question) {
+    final ThemeData theme = Theme.of(context);
+    final bool isDarkMode = theme.brightness == Brightness.dark;
+    return Padding(
+      padding: const EdgeInsets.only(left: SMALL_SPACE),
+      child: Column(
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: <Widget>[
+          Padding(
+            padding: const EdgeInsetsDirectional.only(bottom: VERY_SMALL_SPACE),
+            child: Text(
+              question.question!,
+              style: theme.textTheme.headlineMedium!.apply(
+                color: isDarkMode ? Colors.white : theme.cardTheme.color,
+              ),
+            ),
+          ),
+          Padding(
+            padding: const EdgeInsetsDirectional.only(bottom: VERY_SMALL_SPACE),
+            child: Text(
+              question.value!,
+              style: theme.textTheme.headlineMedium?.apply(
+                  color: isDarkMode ? Colors.white : theme.cardTheme.color),
+            ),
+          ),
+        ],
+      ),
+    );
+  }
+
+  Widget _buildQuestionShimmer() => Shimmer.fromColors(
+        baseColor: robotoffBackground,
+        highlightColor: Colors.white,
+        child: Card(
+          clipBehavior: Clip.antiAlias,
+          shape: const RoundedRectangleBorder(
+            borderRadius: ROUNDED_BORDER_RADIUS,
+          ),
+          child: Container(
+            height: LARGE_SPACE * 4,
+          ),
+        ),
+      );
+}
diff --git a/packages/smooth_app/lib/pages/product/product_question_page.dart b/packages/smooth_app/lib/pages/product/product_question_page.dart
new file mode 100644
index 000000000000..dbcd0bd48bd4
--- /dev/null
+++ b/packages/smooth_app/lib/pages/product/product_question_page.dart
@@ -0,0 +1,253 @@
+import 'package:flutter/material.dart';
+import 'package:flutter_gen/gen_l10n/app_localizations.dart';
+import 'package:matomo_tracker/matomo_tracker.dart';
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:provider/provider.dart';
+import 'package:smooth_app/database/local_database.dart';
+import 'package:smooth_app/generic_lib/design_constants.dart';
+import 'package:smooth_app/generic_lib/duration_constants.dart';
+import 'package:smooth_app/generic_lib/loading_dialog.dart';
+import 'package:smooth_app/helpers/robotoff_insight_helper.dart';
+import 'package:smooth_app/pages/hunger_games/congrats.dart';
+
+import 'package:smooth_app/pages/product/product_question_answers_options.dart';
+import 'package:smooth_app/pages/product/product_question_card.dart';
+import 'package:smooth_app/query/product_questions_query.dart';
+import 'package:smooth_app/query/questions_query.dart';
+
+class ProductQuestionPage extends StatefulWidget {
+  const ProductQuestionPage({
+    this.product,
+    this.questions,
+    this.updateProductUponAnswers,
+    this.insightTypes,
+  });
+
+  final List<InsightType>? insightTypes;
+  final Product? product;
+  final List<RobotoffQuestion>? questions;
+  final Function()? updateProductUponAnswers;
+  bool get shouldDisplayContinueButton => product == null;
+
+  @override
+  State<ProductQuestionPage> createState() => _ProductQuestionPageState();
+}
+
+class _ProductQuestionPageState extends State<ProductQuestionPage>
+    with SingleTickerProviderStateMixin, TraceableClientMixin {
+  final Map<String, InsightAnnotation> _anonymousAnnotationList =
+      <String, InsightAnnotation>{};
+  InsightAnnotation? _lastAnswer;
+
+  late Future<List<RobotoffQuestion>> questions;
+  int _currentQuestionIndex = 0;
+
+  @override
+  void initState() {
+    super.initState();
+
+    final List<RobotoffQuestion>? widgetQuestions = widget.questions;
+
+    if (widgetQuestions != null) {
+      questions = Future<List<RobotoffQuestion>>.value(widgetQuestions);
+    } else {
+      questions = _getQuestions(widget.product);
+    }
+  }
+
+  void _reloadQuestions() {
+    setState(() {
+      questions = _getQuestions(widget.product);
+      _currentQuestionIndex = 0;
+    });
+  }
+
+  @override
+  String get traceTitle => 'robotoff_question_page';
+
+  @override
+  String get traceName => 'Opened robotoff_question_page';
+
+  @override
+  Widget build(BuildContext context) => WillPopScope(
+        onWillPop: () async {
+          final Function()? callback = widget.updateProductUponAnswers;
+          if (_lastAnswer != null && callback != null) {
+            await callback();
+          }
+          return true;
+        },
+        child: _buildAnimationSwitcher(),
+      );
+
+  AnimatedSwitcher _buildAnimationSwitcher() => AnimatedSwitcher(
+        duration: SmoothAnimationsDuration.medium,
+        transitionBuilder: (Widget child, Animation<double> animation) {
+          final Offset animationStartOffset = _getAnimationStartOffset();
+          final Animation<Offset> inAnimation = Tween<Offset>(
+            begin: animationStartOffset,
+            end: Offset.zero,
+          ).animate(animation);
+          final Animation<Offset> outAnimation = Tween<Offset>(
+            begin: animationStartOffset.scale(-1, -1),
+            end: Offset.zero,
+          ).animate(animation);
+
+          if (child.key == ValueKey<int>(_currentQuestionIndex)) {
+            // Animate in the new question card.
+            return ClipRect(
+              child: SlideTransition(
+                position: inAnimation,
+                child: Padding(
+                  padding: const EdgeInsets.all(SMALL_SPACE),
+                  child: child,
+                ),
+              ),
+            );
+          } else {
+            // Animate out the old question card.
+            return ClipRect(
+              child: SlideTransition(
+                position: outAnimation,
+                child: Padding(
+                  padding: const EdgeInsets.all(SMALL_SPACE),
+                  child: child,
+                ),
+              ),
+            );
+          }
+        },
+        child: Container(
+          key: ValueKey<int>(_currentQuestionIndex),
+          child: FutureBuilder<List<RobotoffQuestion>>(
+            future: questions,
+            builder: (
+              BuildContext context,
+              AsyncSnapshot<List<RobotoffQuestion>> snapshot,
+            ) =>
+                snapshot.hasData
+                    ? _buildWidget(
+                        context,
+                        questions: snapshot.data!,
+                        questionIndex: _currentQuestionIndex,
+                      )
+                    : const Center(child: CircularProgressIndicator()),
+          ),
+        ),
+      );
+
+  Offset _getAnimationStartOffset() {
+    switch (_lastAnswer) {
+      case InsightAnnotation.YES:
+        // For [InsightAnnotation.YES]: Animation starts from left side and goes right.
+        return const Offset(-1.0, 0);
+      case InsightAnnotation.NO:
+        // For [InsightAnnotation.NO]: Animation starts from right side and goes left.
+        return const Offset(1.0, 0);
+      case InsightAnnotation.MAYBE:
+      case null:
+        // For [InsightAnnotation.MAYBE]: Animation starts from bottom and goes up.
+        return const Offset(0, 1);
+    }
+  }
+
+  Widget _buildWidget(
+    BuildContext context, {
+    required List<RobotoffQuestion> questions,
+    required int questionIndex,
+  }) {
+    if (questions.length == questionIndex) {
+      return CongratsWidget(
+        shouldDisplayContinueButton: widget.shouldDisplayContinueButton,
+        anonymousAnnotationList: _anonymousAnnotationList,
+        onContinue: _reloadQuestions,
+      );
+    }
+
+    final RobotoffQuestion question = questions[questionIndex];
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+
+    return Column(
+      crossAxisAlignment: CrossAxisAlignment.start,
+      children: <Widget>[
+        ProductQuestionCard(question),
+        ProductQuestionAnswersOptions(
+          question,
+          onAnswer: (InsightAnnotation answer) => trySave(
+            question,
+            answer,
+            appLocalizations,
+          ),
+        )
+      ],
+    );
+  }
+
+  Future<void> trySave(
+    RobotoffQuestion question,
+    InsightAnnotation insightAnnotation,
+    AppLocalizations appLocalizations,
+  ) async {
+    try {
+      await _saveAnswer(
+        barcode: question.barcode,
+        insightId: question.insightId,
+        insightAnnotation: insightAnnotation,
+      );
+    } catch (e) {
+      await LoadingDialog.error(
+        context: context,
+        title: appLocalizations.error_occurred,
+      );
+      if (!mounted) {
+        return;
+      }
+      Navigator.of(context).maybePop();
+      return;
+    }
+    setState(() {
+      _lastAnswer = insightAnnotation;
+      _currentQuestionIndex++;
+    });
+  }
+
+  Future<void> _saveAnswer({
+    required String? barcode,
+    required String? insightId,
+    required InsightAnnotation insightAnnotation,
+  }) async {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+
+    if (OpenFoodAPIConfiguration.globalUser == null && insightId != null) {
+      _anonymousAnnotationList.putIfAbsent(insightId, () => insightAnnotation);
+    }
+    await LoadingDialog.run<Status>(
+      context: context,
+      title: appLocalizations.saving_answer,
+      // TODO(monsieurtanuki): remove that line when fixed in [off-dart #451](https://github.com/openfoodfacts/openfoodfacts-dart/pull/451)
+      future: OpenFoodAPIClient.postInsightAnnotation(
+        insightId,
+        insightAnnotation,
+        deviceId: OpenFoodAPIConfiguration.uuid,
+        user: OpenFoodAPIConfiguration.globalUser,
+      ),
+    );
+    if (barcode != null && insightId != null) {
+      if (!mounted) {
+        return;
+      }
+      final LocalDatabase localDatabase = context.read<LocalDatabase>();
+      final RobotoffInsightHelper robotoffInsightHelper =
+          RobotoffInsightHelper(localDatabase);
+      await robotoffInsightHelper.cacheInsightAnnotationVoted(
+        barcode,
+        insightId,
+      );
+    }
+  }
+
+  Future<List<RobotoffQuestion>> _getQuestions(Product? product) async =>
+      product != null
+          ? ProductQuestionsQuery(product.barcode!).getQuestions()
+          : QuestionsQuery().getQuestions();
+}
