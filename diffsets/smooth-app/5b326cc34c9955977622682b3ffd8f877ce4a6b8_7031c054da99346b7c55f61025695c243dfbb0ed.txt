diff --git a/packages/smooth_app/lib/background/abstract_background_task.dart b/packages/smooth_app/lib/background/abstract_background_task.dart
index 028eb5613d78..6d93cbc3a5dd 100644
--- a/packages/smooth_app/lib/background/abstract_background_task.dart
+++ b/packages/smooth_app/lib/background/abstract_background_task.dart
@@ -60,8 +60,17 @@ abstract class AbstractBackgroundTask {
   /// is not even started.
   Future<void> preExecute(final LocalDatabase localDatabase);
 
-  /// Cleans the temporary data changes performed in [preExecute].
-  Future<void> postExecute(final LocalDatabase localDatabase);
+  /// To be executed _after_ the actual run.
+  ///
+  /// Mostly, cleans the temporary data changes performed in [preExecute].
+  /// [success] indicates (if `true`) that so far the operation was a success.
+  /// With that `bool` we're able to deal with 2 cases:
+  /// 1. everything is fine and we may have to do something more than cleaning
+  /// 2. something bad happened and we just need to clear the task
+  Future<void> postExecute(
+    final LocalDatabase localDatabase,
+    final bool success,
+  );
 
   /// Uploads data changes.
   @protected
diff --git a/packages/smooth_app/lib/background/background_task_details.dart b/packages/smooth_app/lib/background/background_task_details.dart
index dc082dd37fc5..e8f628e7e515 100644
--- a/packages/smooth_app/lib/background/background_task_details.dart
+++ b/packages/smooth_app/lib/background/background_task_details.dart
@@ -100,7 +100,10 @@ class BackgroundTaskDetails extends AbstractBackgroundTask {
       localDatabase.upToDate.addChange(uniqueId, _product);
 
   @override
-  Future<void> postExecute(final LocalDatabase localDatabase) async =>
+  Future<void> postExecute(
+    final LocalDatabase localDatabase,
+    final bool success,
+  ) async =>
       localDatabase.upToDate.terminate(uniqueId);
 
   /// Adds the background task about changing a product.
diff --git a/packages/smooth_app/lib/background/background_task_image.dart b/packages/smooth_app/lib/background/background_task_image.dart
index e811fcd30bf6..ff99008380f9 100644
--- a/packages/smooth_app/lib/background/background_task_image.dart
+++ b/packages/smooth_app/lib/background/background_task_image.dart
@@ -152,7 +152,10 @@ class BackgroundTaskImage extends AbstractBackgroundTask {
 
   // TODO(monsieurtanuki): we may also need to remove old files that were not removed from some reason
   @override
-  Future<void> postExecute(final LocalDatabase localDatabase) async {
+  Future<void> postExecute(
+    final LocalDatabase localDatabase,
+    final bool success,
+  ) async {
     try {
       File(imagePath).deleteSync();
     } catch (e) {
@@ -164,10 +167,12 @@ class BackgroundTaskImage extends AbstractBackgroundTask {
       localDatabase,
     );
     localDatabase.notifyListeners();
-    await BackgroundTaskRefreshLater.addTask(
-      barcode,
-      localDatabase: localDatabase,
-    );
+    if (success) {
+      await BackgroundTaskRefreshLater.addTask(
+        barcode,
+        localDatabase: localDatabase,
+      );
+    }
   }
 
   /// Uploads the product image.
diff --git a/packages/smooth_app/lib/background/background_task_manager.dart b/packages/smooth_app/lib/background/background_task_manager.dart
index 58752243d5d9..b053849aa755 100644
--- a/packages/smooth_app/lib/background/background_task_manager.dart
+++ b/packages/smooth_app/lib/background/background_task_manager.dart
@@ -37,8 +37,21 @@ class BackgroundTaskManager {
     run(); // no await
   }
 
-  /// Removes a task from the pending task list
-  Future<void> _remove(final String taskId) async {
+  /// Finishes a task cleanly.
+  ///
+  /// That includes:
+  /// * running the task's `postExecute` method.
+  /// * removing a task from the task lists.
+  /// Most of the time this method is used for garbage collecting, that's why
+  /// the [success] parameter is set to `false` by default.
+  Future<void> _finishTask(
+    final String taskId, {
+    final bool success = false,
+  }) async {
+    final AbstractBackgroundTask? task = _get(taskId);
+    if (task != null) {
+      await task.postExecute(localDatabase, success);
+    }
     await DaoStringList(localDatabase).remove(DaoStringList.keyTasks, taskId);
     await DaoInstantString(localDatabase)
         .put(_taskIdToDaoInstantStringKey(taskId), null);
@@ -110,19 +123,13 @@ class BackgroundTaskManager {
   }
 
   /// Runs all the pending tasks, and then smoothly ends.
-  Future<void> run() async {
-    await _run();
-    await _justFinished();
-  }
-
-  /// Runs all the pending tasks.
   ///
   /// If a task fails, we continue with the other tasks: and we'll retry the
   /// failed tasks later.
   /// If a task fails and another task with the same stamp comes after,
   /// we can remove the failed task from the list: it would have been
   /// overwritten anyway.
-  Future<void> _run() async {
+  Future<void> run() async {
     if (!await _canStartNow()) {
       return;
     }
@@ -138,49 +145,68 @@ class BackgroundTaskManager {
         // not only will we spare a to-be-overwritten call, but we avoid the
         // "save latest change" and then "save initial change" dilemma.
         _debugPrint('removing failed task $previousFailedTaskId');
-        await _remove(previousFailedTaskId);
+        await _finishTask(previousFailedTaskId);
         failedTaskFromStamps.remove(stamp);
       }
       try {
-        await _runTask(task);
+        await _setTaskErrorStatus(taskId, taskStatusStarted);
+        await task.execute(localDatabase);
+        await _finishTask(taskId, success: true);
       } catch (e) {
         // Most likely, no internet, no reason to go on.
         if (e.toString().startsWith('Failed host lookup: ')) {
-          await DaoInstantString(localDatabase).put(
-            taskIdToErrorDaoInstantStringKey(taskId),
-            taskStatusNoInternet,
-          );
-          localDatabase.notifyListeners();
+          await _setTaskErrorStatus(taskId, taskStatusNoInternet);
           return;
         }
         debugPrint('Background task error ($e)');
         Logs.e('Background task error', ex: e);
-        await DaoInstantString(localDatabase)
-            .put(taskIdToErrorDaoInstantStringKey(taskId), '$e');
         failedTaskFromStamps[stamp] = taskId;
-        localDatabase.notifyListeners();
+        await _setTaskErrorStatus(taskId, '$e');
       }
     }
+    await _justFinished();
   }
 
+  Future<void> _setTaskErrorStatus(
+    final String taskId,
+    final String status,
+  ) async {
+    _debugPrint('setStatus - $taskId: $status');
+    final String key = taskIdToErrorDaoInstantStringKey(taskId);
+    if (DaoInstantString(localDatabase).get(key) == taskStatusStopAsap) {
+      // the task is supposed to be stopped asap and it's a good moment for that
+      await _finishTask(taskId);
+      return;
+    }
+    await DaoInstantString(localDatabase).put(key, status);
+    localDatabase.notifyListeners();
+  }
+
+  /// Removes a task ASAP.
+  ///
+  /// Returns true if managed to remove the task immediately.
+  /// Returns false if the task will be removed next time it's possible.
+  Future<bool> removeTaskAsap(final String taskId) async {
+    final String? status = DaoInstantString(localDatabase)
+        .get(taskIdToErrorDaoInstantStringKey(taskId));
+    if (status == taskStatusStarted) {
+      // that value will be detected later
+      await _setTaskErrorStatus(taskId, taskStatusStopAsap);
+      return false;
+    }
+    await _finishTask(taskId);
+    return true;
+  }
+
+  /// Forged task status: "Stop that task ASAP!".
+  static const String taskStatusStopAsap = '!';
+
   /// Forged task status: "Just started!".
   static const String taskStatusStarted = '*';
 
   /// Forged task status: "No internet, try later!".
   static const String taskStatusNoInternet = 'X';
 
-  /// Runs a single task. Possible exception.
-  Future<void> _runTask(final AbstractBackgroundTask task) async {
-    await DaoInstantString(localDatabase).put(
-      taskIdToErrorDaoInstantStringKey(task.uniqueId),
-      taskStatusStarted,
-    );
-    localDatabase.notifyListeners();
-    await task.execute(localDatabase);
-    await task.postExecute(localDatabase);
-    await _remove(task.uniqueId);
-  }
-
   // TODO(monsieurtanuki): get rid of this once we're relaxed about the tasks.
   void _debugPrint(final String message) {
     // debugPrint('${LocalDatabase.nowInMillis()} $message');
@@ -203,7 +229,7 @@ class BackgroundTaskManager {
       final AbstractBackgroundTask? task = _get(taskId);
       if (task == null) {
         // unexpected, but let's remove that null task anyway.
-        await _remove(taskId);
+        await _finishTask(taskId);
         continue;
       }
       if (!task.mayRunNow()) {
@@ -236,7 +262,7 @@ class BackgroundTaskManager {
       result.add(task);
     }
     for (final String taskId in duplicateTaskIds) {
-      await _remove(taskId);
+      await _finishTask(taskId);
     }
     _debugPrint('get all tasks returned (begin)');
     int i = 0;
diff --git a/packages/smooth_app/lib/background/background_task_refresh_later.dart b/packages/smooth_app/lib/background/background_task_refresh_later.dart
index ce4e85e6d136..7635757f7c63 100644
--- a/packages/smooth_app/lib/background/background_task_refresh_later.dart
+++ b/packages/smooth_app/lib/background/background_task_refresh_later.dart
@@ -83,7 +83,10 @@ class BackgroundTaskRefreshLater extends AbstractBackgroundTask {
 
   /// Here we change nothing, therefore we do nothing.
   @override
-  Future<void> postExecute(final LocalDatabase localDatabase) async {}
+  Future<void> postExecute(
+    final LocalDatabase localDatabase,
+    final bool success,
+  ) async {}
 
   /// Adds the background task about refreshing the product later.
   static Future<void> addTask(
diff --git a/packages/smooth_app/lib/l10n/app_en.arb b/packages/smooth_app/lib/l10n/app_en.arb
index 384e295ce2de..b4f6bc0aee91 100644
--- a/packages/smooth_app/lib/l10n/app_en.arb
+++ b/packages/smooth_app/lib/l10n/app_en.arb
@@ -1837,5 +1837,7 @@
     "background_task_operation_refresh": "refresh delayed after photo upload",
     "background_task_run_started": "started",
     "background_task_run_not_started": "not started yet",
+    "background_task_run_to_be_deleted": "to be deleted",
+    "background_task_question_stop": "Do you want to stop that task ASAP?",
     "feed_back": "Feedback"
 }
\ No newline at end of file
diff --git a/packages/smooth_app/lib/pages/offline_tasks_page.dart b/packages/smooth_app/lib/pages/offline_tasks_page.dart
index 449a296cc848..027199c1b81a 100644
--- a/packages/smooth_app/lib/pages/offline_tasks_page.dart
+++ b/packages/smooth_app/lib/pages/offline_tasks_page.dart
@@ -5,6 +5,7 @@ import 'package:smooth_app/background/background_task_manager.dart';
 import 'package:smooth_app/data_models/operation_type.dart';
 import 'package:smooth_app/database/dao_instant_string.dart';
 import 'package:smooth_app/database/local_database.dart';
+import 'package:smooth_app/generic_lib/dialogs/smooth_alert_dialog.dart';
 
 class OfflineTaskPage extends StatefulWidget {
   const OfflineTaskPage();
@@ -38,6 +39,28 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
                   ),
                 );
                 return ListTile(
+                  onTap: () async {
+                    final bool? stopTask = await showDialog<bool>(
+                      context: context,
+                      builder: (final BuildContext context) =>
+                          SmoothAlertDialog(
+                        body: Text(
+                            appLocalizations.background_task_question_stop),
+                        negativeAction: SmoothActionButton(
+                          text: appLocalizations.no,
+                          onPressed: () => Navigator.of(context).pop(false),
+                        ),
+                        positiveAction: SmoothActionButton(
+                          text: appLocalizations.yes,
+                          onPressed: () => Navigator.of(context).pop(true),
+                        ),
+                      ),
+                    );
+                    if (stopTask == true) {
+                      await BackgroundTaskManager(localDatabase)
+                          .removeTaskAsap(taskId);
+                    }
+                  },
                   title: Text(
                     '${OperationType.getBarcode(taskId)}'
                     ' (${_getOperationLabel(
@@ -46,6 +69,7 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
                     )})',
                   ),
                   subtitle: Text(_getMessage(status, appLocalizations)),
+                  trailing: const Icon(Icons.clear),
                 );
               },
             ),
@@ -79,6 +103,8 @@ class _OfflineTaskState extends State<OfflineTaskPage> {
         return appLocalizations.background_task_run_started;
       case BackgroundTaskManager.taskStatusNoInternet:
         return appLocalizations.background_task_error_no_internet;
+      case BackgroundTaskManager.taskStatusStopAsap:
+        return appLocalizations.background_task_run_to_be_deleted;
     }
     return status!;
   }
