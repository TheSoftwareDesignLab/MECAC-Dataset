diff --git a/packages/smooth_app/lib/tmp_crop_image/crop_grid.dart b/packages/smooth_app/lib/tmp_crop_image/crop_grid.dart
index 2781ce167f1b..b5f1c4e219f7 100644
--- a/packages/smooth_app/lib/tmp_crop_image/crop_grid.dart
+++ b/packages/smooth_app/lib/tmp_crop_image/crop_grid.dart
@@ -2,6 +2,11 @@ import 'dart:ui';
 
 import 'package:flutter/material.dart';
 
+/// Crop Grid with invisible border, for better touch detection.
+///
+/// For the record, the border and the corner "triangle" both have the same
+/// "horizontal/vertical" size: [cornerSize]. And it's probably a good practice
+/// to make the touch area the double of that size.
 class CropGrid extends StatelessWidget {
   const CropGrid({
     Key? key,
@@ -13,7 +18,6 @@ class CropGrid extends StatelessWidget {
     required this.scrimColor,
     required this.alwaysShowThirdLines,
     required this.isMoving,
-    required this.onSize,
   }) : super(key: key);
 
   final Rect crop;
@@ -24,7 +28,6 @@ class CropGrid extends StatelessWidget {
   final Color scrimColor;
   final bool alwaysShowThirdLines;
   final bool isMoving;
-  final ValueChanged<Size> onSize;
 
   @override
   Widget build(BuildContext context) => RepaintBoundary(
@@ -39,14 +42,17 @@ class _CropGridPainter extends CustomPainter {
 
   @override
   void paint(Canvas canvas, Size size) {
-    final Rect full = Offset.zero & size;
+    final Rect full = Offset(grid.cornerSize, grid.cornerSize) &
+        Size(
+          size.width - 2 * grid.cornerSize,
+          size.height - 2 * grid.cornerSize,
+        );
     final Rect bounds = Rect.fromLTRB(
       grid.crop.left * full.width,
       grid.crop.top * full.height,
       grid.crop.right * full.width,
       grid.crop.bottom * full.height,
-    );
-    grid.onSize(size);
+    ).translate(grid.cornerSize, grid.cornerSize);
 
     canvas.save();
     canvas.clipRect(bounds, clipOp: ClipOp.difference);
diff --git a/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart b/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart
index ccf715bd5d5c..2745220fc0d3 100644
--- a/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart
+++ b/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart
@@ -133,13 +133,14 @@ class _CropPageState extends State<CropPage> {
                     ],
                   ),
                   Expanded(
-                    child: Padding(
-                      padding: const EdgeInsets.all(MINIMUM_TOUCH_SIZE / 2),
-                      child: RotatedCropImage(
-                        controller: _controller,
-                        image: _image,
-                        minimumImageSize: 1,
-                      ),
+                    child: RotatedCropImage(
+                      controller: _controller,
+                      image: _image,
+                      minimumImageSize:
+                          MINIMUM_TOUCH_SIZE, // decent visual minimum size
+                      gridCornerSize: MINIMUM_TOUCH_SIZE *
+                          .75, // touch size will be this x 2
+                      alwaysMove: true,
                     ),
                   ),
                   Wrap(
diff --git a/packages/smooth_app/lib/tmp_crop_image/rotated_crop_image.dart b/packages/smooth_app/lib/tmp_crop_image/rotated_crop_image.dart
index 0e75c9bf1420..968d39f23af5 100644
--- a/packages/smooth_app/lib/tmp_crop_image/rotated_crop_image.dart
+++ b/packages/smooth_app/lib/tmp_crop_image/rotated_crop_image.dart
@@ -24,6 +24,7 @@ class RotatedCropImage extends StatefulWidget {
     this.alwaysShowThirdLines = false,
     this.onCrop,
     this.minimumImageSize = 100,
+    this.alwaysMove = false,
   })  : assert(gridCornerSize > 0, 'gridCornerSize cannot be zero'),
         assert(gridThinWidth > 0, 'gridThinWidth cannot be zero'),
         assert(gridThickWidth > 0, 'gridThickWidth cannot be zero'),
@@ -85,6 +86,11 @@ class RotatedCropImage extends StatefulWidget {
   /// Defaults to 100.
   final double minimumImageSize;
 
+  /// When `true`, moves when panning beyond corners, even beyond the crop rect.
+  ///
+  /// When `false`, moves when panning beyond corners but inside the crop rect.
+  final bool alwaysMove;
+
   @override
   State<RotatedCropImage> createState() => _RotatedCropImageState();
 
@@ -118,18 +124,25 @@ enum _CornerTypes { UpperLeft, UpperRight, LowerRight, LowerLeft, None, Move }
 class _RotatedCropImageState extends State<RotatedCropImage> {
   late RotatedCropController controller;
   Rect currentCrop = Rect.zero;
+
+  /// Image size. Smaller than crop tool size, by gridCornerSize on each side.
   Size size = Size.zero;
   _TouchPoint? panStart;
 
+  /// Corners as displayed.
   Map<_CornerTypes, Offset> get gridCorners => <_CornerTypes, Offset>{
-        _CornerTypes.UpperLeft:
-            controller.crop.topLeft.scale(size.width, size.height),
-        _CornerTypes.UpperRight:
-            controller.crop.topRight.scale(size.width, size.height),
-        _CornerTypes.LowerRight:
-            controller.crop.bottomRight.scale(size.width, size.height),
-        _CornerTypes.LowerLeft:
-            controller.crop.bottomLeft.scale(size.width, size.height),
+        _CornerTypes.UpperLeft: controller.crop.topLeft
+            .scale(size.width, size.height)
+            .translate(widget.gridCornerSize, widget.gridCornerSize),
+        _CornerTypes.UpperRight: controller.crop.topRight
+            .scale(size.width, size.height)
+            .translate(widget.gridCornerSize, widget.gridCornerSize),
+        _CornerTypes.LowerRight: controller.crop.bottomRight
+            .scale(size.width, size.height)
+            .translate(widget.gridCornerSize, widget.gridCornerSize),
+        _CornerTypes.LowerLeft: controller.crop.bottomLeft
+            .scale(size.width, size.height)
+            .translate(widget.gridCornerSize, widget.gridCornerSize),
       };
 
   @override
@@ -190,11 +203,16 @@ class _RotatedCropImageState extends State<RotatedCropImage> {
   Widget build(BuildContext context) => Center(
         child: LayoutBuilder(
           builder: (BuildContext context, BoxConstraints constraints) {
-            final double maxWidth = constraints.maxWidth;
-            final double maxHeight = constraints.maxHeight;
+            // we remove the borders
+            final double maxWidth =
+                constraints.maxWidth - 2 * widget.gridCornerSize;
+            final double maxHeight =
+                constraints.maxHeight - 2 * widget.gridCornerSize;
             final double width = _getWidth(maxWidth, maxHeight);
             final double height = _getHeight(maxWidth, maxHeight);
+            size = Size(width, height);
             return Stack(
+              alignment: Alignment.center,
               children: <Widget>[
                 SizedBox(
                   width: width,
@@ -207,8 +225,8 @@ class _RotatedCropImageState extends State<RotatedCropImage> {
                   ),
                 ),
                 SizedBox(
-                  width: width,
-                  height: height,
+                  width: width + 2 * widget.gridCornerSize,
+                  height: height + 2 * widget.gridCornerSize,
                   child: GestureDetector(
                     onPanStart: onPanStart,
                     onPanUpdate: onPanUpdate,
@@ -222,7 +240,6 @@ class _RotatedCropImageState extends State<RotatedCropImage> {
                       scrimColor: widget.scrimColor,
                       alwaysShowThirdLines: widget.alwaysShowThirdLines,
                       isMoving: panStart != null,
-                      onSize: (final Size size) => this.size = size,
                     ),
                   ),
                 ),
@@ -233,58 +250,63 @@ class _RotatedCropImageState extends State<RotatedCropImage> {
       );
 
   void onPanStart(DragStartDetails details) {
-    if (panStart == null) {
-      final _CornerTypes type = hitTest(details.localPosition);
-      if (type != _CornerTypes.None) {
-        final Offset basePoint = gridCorners[
-            (type == _CornerTypes.Move) ? _CornerTypes.UpperLeft : type]!;
-        setState(() {
-          panStart = _TouchPoint(type, details.localPosition - basePoint);
-        });
-      }
+    if (panStart != null) {
+      return;
     }
+    final _CornerTypes type = hitTest(details.localPosition);
+    if (type == _CornerTypes.None) {
+      return;
+    }
+    final Offset basePoint =
+        gridCorners[type == _CornerTypes.Move ? _CornerTypes.UpperLeft : type]!;
+    final Offset offset = details.localPosition - basePoint;
+    setState(() => panStart = _TouchPoint(type, offset));
   }
 
   void onPanUpdate(DragUpdateDetails details) {
-    if (panStart != null) {
-      if (panStart!.type == _CornerTypes.Move) {
-        moveArea(details.localPosition - panStart!.offset);
-      } else {
-        moveCorner(panStart!.type, details.localPosition - panStart!.offset);
-      }
-      widget.onCrop?.call(controller.crop);
+    if (panStart == null) {
+      return;
     }
+    final Offset offset = details.localPosition -
+        panStart!.offset -
+        Offset(widget.gridCornerSize, widget.gridCornerSize);
+    if (panStart!.type == _CornerTypes.Move) {
+      moveArea(offset);
+    } else {
+      moveCorner(panStart!.type, offset);
+    }
+    widget.onCrop?.call(controller.crop);
   }
 
-  void onPanEnd(DragEndDetails details) {
-    setState(() {
-      panStart = null;
-    });
-  }
+  void onPanEnd(DragEndDetails details) => setState(() => panStart = null);
 
-  void onChange() {
-    setState(() {
-      currentCrop = controller.crop;
-    });
-  }
+  void onChange() => setState(() => currentCrop = controller.crop);
 
   _CornerTypes hitTest(Offset point) {
     for (final MapEntry<_CornerTypes, Offset> gridCorner
         in gridCorners.entries) {
       final Rect area = Rect.fromCenter(
-          center: gridCorner.value,
-          width: 2 * widget.gridCornerSize,
-          height: 2 * widget.gridCornerSize);
+        center: gridCorner.value,
+        width: 2 * widget.gridCornerSize,
+        height: 2 * widget.gridCornerSize,
+      );
       if (area.contains(point)) {
         return gridCorner.key;
       }
     }
 
-    final Rect area = Rect.fromPoints(gridCorners[_CornerTypes.UpperLeft]!,
-        gridCorners[_CornerTypes.LowerRight]!);
+    if (widget.alwaysMove) {
+      return _CornerTypes.Move;
+    }
+
+    final Rect area = Rect.fromPoints(
+      gridCorners[_CornerTypes.UpperLeft]!,
+      gridCorners[_CornerTypes.LowerRight]!,
+    );
     return area.contains(point) ? _CornerTypes.Move : _CornerTypes.None;
   }
 
+  /// [point] as in a Rect.fromLTWH(0,0,size.width,size.height).
   void moveArea(Offset point) {
     final Rect crop = controller.crop.multiply(size);
     controller.crop = Rect.fromLTWH(
@@ -295,6 +317,7 @@ class _RotatedCropImageState extends State<RotatedCropImage> {
     ).divide(size);
   }
 
+  /// [point] as in a Rect.fromLTWH(0,0,size.width,size.height).
   void moveCorner(_CornerTypes type, Offset point) {
     final Rect crop = controller.crop.multiply(size);
     double left = crop.left;
@@ -302,7 +325,6 @@ class _RotatedCropImageState extends State<RotatedCropImage> {
     double right = crop.right;
     double bottom = crop.bottom;
 
-    // TODO(monsieurtanuki): problematic as it sends exception when the clamp window is impossible (e.g left > right). Suggestion: catch exception and ignore movement
     switch (type) {
       case _CornerTypes.UpperLeft:
         left = point.dx.clamp(0, right - widget.minimumImageSize);
