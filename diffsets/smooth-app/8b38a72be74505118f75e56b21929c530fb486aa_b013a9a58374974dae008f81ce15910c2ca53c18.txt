diff --git a/packages/smooth_app/lib/background/background_task_crop.dart b/packages/smooth_app/lib/background/background_task_crop.dart
index cceaa2c9bee7..3eadfdb385dc 100644
--- a/packages/smooth_app/lib/background/background_task_crop.dart
+++ b/packages/smooth_app/lib/background/background_task_crop.dart
@@ -171,12 +171,36 @@ class BackgroundTaskCrop extends AbstractBackgroundTask {
       );
 
   @override
-  Future<void> preExecute(final LocalDatabase localDatabase) async =>
-      TransientFile.putImage(
-        ImageField.fromOffTag(imageField)!,
-        barcode,
-        localDatabase,
-        File(croppedPath),
+  Future<void> preExecute(final LocalDatabase localDatabase) async {
+    await localDatabase.upToDate.addChange(
+      uniqueId,
+      Product(
+        barcode: barcode,
+        images: <ProductImage>[_getProductImage()],
+      ),
+    );
+    TransientFile.putImage(
+      ImageField.fromOffTag(imageField)!,
+      barcode,
+      localDatabase,
+      File(croppedPath),
+    );
+  }
+
+  /// Returns the actual crop parameters.
+  ///
+  /// cf. [UpToDateChanges._overwrite] regarding `images` field.
+  ProductImage _getProductImage() => ProductImage(
+        field: ImageField.fromOffTag(imageField)!,
+        language: getLanguage(),
+        size: ImageSize.ORIGINAL,
+        angle: ImageAngleExtension.fromInt(rotationDegrees),
+        imgid: '$imageId',
+        x1: cropX1,
+        y1: cropY1,
+        x2: cropX2,
+        y2: cropY2,
+        coordinatesImageSize: ImageSize.ORIGINAL.number,
       );
 
   @override
@@ -184,6 +208,7 @@ class BackgroundTaskCrop extends AbstractBackgroundTask {
     final LocalDatabase localDatabase,
     final bool success,
   ) async {
+    localDatabase.upToDate.terminate(uniqueId);
     try {
       File(croppedPath).deleteSync();
     } catch (e) {
@@ -206,20 +231,18 @@ class BackgroundTaskCrop extends AbstractBackgroundTask {
   /// Uploads the product image.
   @override
   Future<void> upload() async {
-    final ImageField imageField = ImageField.fromOffTag(this.imageField)!;
-    final OpenFoodFactsLanguage language = getLanguage();
-    final User user = getUser();
+    final ProductImage productImage = _getProductImage();
     final String? imageUrl = await OpenFoodAPIClient.setProductImageCrop(
       barcode: barcode,
-      imageField: imageField,
-      language: language,
-      imgid: '$imageId',
-      angle: ImageAngleExtension.fromInt(rotationDegrees)!,
-      x1: cropX1,
-      y1: cropY1,
-      x2: cropX2,
-      y2: cropY2,
-      user: user,
+      imageField: productImage.field,
+      language: getLanguage(),
+      imgid: productImage.imgid!,
+      angle: productImage.angle!,
+      x1: productImage.x1!,
+      y1: productImage.y1!,
+      x2: productImage.x2!,
+      y2: productImage.y2!,
+      user: getUser(),
     );
     if (imageUrl == null) {
       throw Exception('Could not select picture');
diff --git a/packages/smooth_app/lib/background/background_task_image.dart b/packages/smooth_app/lib/background/background_task_image.dart
index e1f75b9fa878..218b35dda853 100644
--- a/packages/smooth_app/lib/background/background_task_image.dart
+++ b/packages/smooth_app/lib/background/background_task_image.dart
@@ -8,6 +8,7 @@ import 'package:provider/provider.dart';
 import 'package:smooth_app/background/abstract_background_task.dart';
 import 'package:smooth_app/background/background_task_refresh_later.dart';
 import 'package:smooth_app/data_models/operation_type.dart';
+import 'package:smooth_app/data_models/up_to_date_changes.dart';
 import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/database/transient_file.dart';
 import 'package:smooth_app/query/product_query.dart';
@@ -192,12 +193,32 @@ class BackgroundTaskImage extends AbstractBackgroundTask {
       stamp.contains(';image;${ImageField.OTHER.offTag};');
 
   @override
-  Future<void> preExecute(final LocalDatabase localDatabase) async =>
-      TransientFile.putImage(
-        ImageField.fromOffTag(imageField)!,
-        barcode,
-        localDatabase,
-        File(croppedPath),
+  Future<void> preExecute(final LocalDatabase localDatabase) async {
+    await localDatabase.upToDate.addChange(
+      uniqueId,
+      Product(
+        barcode: barcode,
+        images: <ProductImage>[_getProductImage()],
+      ),
+    );
+    TransientFile.putImage(
+      ImageField.fromOffTag(imageField)!,
+      barcode,
+      localDatabase,
+      File(croppedPath),
+    );
+  }
+
+  /// Returns a fake value that means: "remove the previous value when merging".
+  ///
+  /// If we use this task, it means that we took a brand new picture. Therefore,
+  /// all previous crop parameters are attached to a different imageid, and
+  /// to avoid confusion we need to clear them.
+  /// cf. [UpToDateChanges._overwrite] regarding `images` field.
+  ProductImage _getProductImage() => ProductImage(
+        field: ImageField.fromOffTag(imageField)!,
+        language: getLanguage(),
+        size: ImageSize.ORIGINAL,
       );
 
   // TODO(monsieurtanuki): we may also need to remove old files that were not removed from some reason
@@ -206,6 +227,7 @@ class BackgroundTaskImage extends AbstractBackgroundTask {
     final LocalDatabase localDatabase,
     final bool success,
   ) async {
+    localDatabase.upToDate.terminate(uniqueId);
     try {
       File(fullPath).deleteSync();
     } catch (e) {
diff --git a/packages/smooth_app/lib/data_models/up_to_date_changes.dart b/packages/smooth_app/lib/data_models/up_to_date_changes.dart
index 5cd72eb08a11..667ba71f343a 100644
--- a/packages/smooth_app/lib/data_models/up_to_date_changes.dart
+++ b/packages/smooth_app/lib/data_models/up_to_date_changes.dart
@@ -16,13 +16,7 @@ class UpToDateChanges {
   /// Returns all the actions related to a barcode, sorted by id.
   Iterable<TransientOperation> getSortedOperations(final String barcode) {
     final List<TransientOperation> result = <TransientOperation>[];
-    for (final TransientOperation transientProduct
-        in _daoTransientProduct.getAll(barcode)) {
-      if (OperationType.details.matches(transientProduct) ||
-          OperationType.unselect.matches(transientProduct)) {
-        result.add(transientProduct);
-      }
-    }
+    result.addAll(_daoTransientProduct.getAll(barcode));
     result.sort(OperationType.sort);
     return result;
   }
@@ -160,6 +154,31 @@ class UpToDateChanges {
         change.imagePackagingSmallUrl!,
       );
     }
+    if (change.images != null && change.images!.isNotEmpty) {
+      initial.images ??= <ProductImage>[];
+      // let's remove similar entries first
+      final Set<int> removeIndices = <int>{};
+      for (final ProductImage changeProductImage in change.images!) {
+        int i = 0;
+        for (final ProductImage initialProductImage in initial.images!) {
+          if (changeProductImage.field == initialProductImage.field &&
+              changeProductImage.size == initialProductImage.size &&
+              changeProductImage.language == initialProductImage.language) {
+            removeIndices.add(i);
+          }
+          i++;
+        }
+      }
+      final List<int> sorted = List<int>.from(removeIndices);
+      sorted.reversed.forEach(initial.images!.removeAt);
+      // then add the correct new entries
+      for (final ProductImage changeProductImage in change.images!) {
+        // null imgid means just deletion, no adding
+        if (changeProductImage.imgid != null) {
+          initial.images!.add(changeProductImage);
+        }
+      }
+    }
     if (change.website != null) {
       initial.website = change.website;
     }
diff --git a/packages/smooth_app/lib/l10n/app_en.arb b/packages/smooth_app/lib/l10n/app_en.arb
index a9e85704e022..4d381a43e4aa 100644
--- a/packages/smooth_app/lib/l10n/app_en.arb
+++ b/packages/smooth_app/lib/l10n/app_en.arb
@@ -478,6 +478,7 @@
         "description": "Button clicking on which confirms the picture of the front of product that user just took."
     },
     "confirm_button_label": "Confirm",
+    "send_image_button_label": "Send image",
     "front_packaging_photo_title": "Front Packaging Photo",
     "ingredients_photo_title": "Ingredients Photo",
     "nutritional_facts_photo_title": "Nutrition Facts Photo",
diff --git a/packages/smooth_app/lib/pages/product/product_image_viewer.dart b/packages/smooth_app/lib/pages/product/product_image_viewer.dart
index ecbff0d36a28..07f083c0a6b5 100644
--- a/packages/smooth_app/lib/pages/product/product_image_viewer.dart
+++ b/packages/smooth_app/lib/pages/product/product_image_viewer.dart
@@ -20,6 +20,7 @@ import 'package:smooth_app/pages/image_crop_page.dart';
 import 'package:smooth_app/pages/product/edit_image_button.dart';
 import 'package:smooth_app/query/product_query.dart';
 import 'package:smooth_app/tmp_crop_image/new_crop_page.dart';
+import 'package:smooth_app/tmp_crop_image/rotation.dart';
 import 'package:smooth_app/widgets/smooth_scaffold.dart';
 
 /// Displays a full-screen image with an "edit" floating button.
@@ -97,155 +98,260 @@ class _ProductImageViewerState extends State<ProductImageViewer> {
             crossAxisAlignment: CrossAxisAlignment.center,
             mainAxisSize: MainAxisSize.max,
             children: <Widget>[
-              Expanded(child: Container()), // would be "take another picture"
               Expanded(
                 child: Padding(
                   padding: const EdgeInsets.symmetric(horizontal: SMALL_SPACE),
-                  child: EditImageButton(
-                    iconData: Icons.image_search,
-                    label: appLocalizations
-                        .edit_photo_select_existing_button_label,
-                    onPressed: () async {
-                      final List<int>? result =
-                          await LoadingDialog.run<List<int>>(
-                        future: OpenFoodAPIClient.getProductImageIds(
-                          _barcode,
-                          user: ProductQuery.getUser(),
-                        ),
-                        context: context,
-                        title: appLocalizations
-                            .edit_photo_select_existing_download_label,
-                      );
-                      if (result == null) {
-                        return;
-                      }
-                      if (!mounted) {
-                        return;
-                      }
-                      if (result.isEmpty) {
-                        await showDialog<void>(
-                          context: context,
-                          builder: (BuildContext context) => SmoothAlertDialog(
-                            body: Text(appLocalizations
-                                .edit_photo_select_existing_downloaded_none),
-                            actionsAxis: Axis.vertical,
-                            positiveAction: SmoothActionButton(
-                              text: appLocalizations.okay,
-                              onPressed: () => Navigator.of(context).pop(),
-                            ),
-                          ),
-                        );
-                        return;
-                      }
-                      await Navigator.push<void>(
-                        context,
-                        MaterialPageRoute<void>(
-                          builder: (BuildContext context) =>
-                              UploadedImageGallery(
-                            barcode: _barcode,
-                            imageIds: result,
-                            imageField: widget.imageField,
-                          ),
-                        ),
-                      );
-                    },
-                  ),
-                ),
-              ),
-            ],
-          ),
-          Row(
-            mainAxisAlignment: MainAxisAlignment.spaceBetween,
-            crossAxisAlignment: CrossAxisAlignment.center,
-            mainAxisSize: MainAxisSize.max,
-            children: <Widget>[
-              Expanded(
-                child: Padding(
-                  padding: const EdgeInsets.symmetric(horizontal: SMALL_SPACE),
-                  child: (imageProvider == null)
-                      ? Container()
-                      : EditImageButton(
-                          iconData: Icons.do_disturb_on,
-                          label:
-                              appLocalizations.edit_photo_unselect_button_label,
-                          onPressed: () async {
-                            final NavigatorState navigatorState =
-                                Navigator.of(context);
-                            await BackgroundTaskUnselect.addTask(
-                              _barcode,
-                              imageField: widget.imageField,
-                              widget: this,
-                            );
-                            _localDatabase.notifyListeners();
-                            navigatorState.pop();
-                          },
-                        ),
+                  child: _getGalleryButton(appLocalizations),
                 ),
               ),
               Expanded(
                 child: Padding(
                   padding: const EdgeInsets.symmetric(horizontal: SMALL_SPACE),
-                  child: EditImageButton(
-                    iconData: imageProvider == null ? Icons.add : Icons.edit,
-                    label: imageProvider == null
-                        ? appLocalizations.add
-                        : appLocalizations.edit_photo_button_label,
-                    onPressed: () async => _editImage(),
+                  child: _getCameraImageButton(
+                    appLocalizations,
+                    imageProvider == null,
                   ),
                 ),
               ),
             ],
           ),
+          if (imageProvider != null)
+            Row(
+              mainAxisAlignment: MainAxisAlignment.spaceBetween,
+              crossAxisAlignment: CrossAxisAlignment.center,
+              mainAxisSize: MainAxisSize.max,
+              children: <Widget>[
+                Expanded(
+                  child: Padding(
+                    padding:
+                        const EdgeInsets.symmetric(horizontal: SMALL_SPACE),
+                    child: _getUnselectImageButton(appLocalizations),
+                  ),
+                ),
+                Expanded(
+                  child: Padding(
+                    padding:
+                        const EdgeInsets.symmetric(horizontal: SMALL_SPACE),
+                    child: _getEditImageButton(appLocalizations),
+                  ),
+                ),
+              ],
+            ),
         ],
       ),
     );
   }
 
-  Future<void> _editImage() async {
-    // we have no image at all here: we need to create one.
-    if (!TransientFile.isImageAvailable(_imageData, _barcode)) {
-      await confirmAndUploadNewPicture(
+  Widget _getEditImageButton(final AppLocalizations appLocalizations) =>
+      EditImageButton(
+        iconData: Icons.edit,
+        label: appLocalizations.edit_photo_button_label,
+        onPressed: _actionEditImage,
+      );
+
+  Widget _getCameraImageButton(
+    final AppLocalizations appLocalizations,
+    final bool firstPhoto,
+  ) =>
+      EditImageButton(
+        iconData: firstPhoto ? Icons.add : Icons.add_a_photo,
+        label: firstPhoto ? appLocalizations.add : appLocalizations.capture,
+        onPressed: _actionNewImage,
+      );
+
+  Widget _getUnselectImageButton(final AppLocalizations appLocalizations) =>
+      EditImageButton(
+        iconData: Icons.do_disturb_on,
+        label: appLocalizations.edit_photo_unselect_button_label,
+        onPressed: _actionUnselect,
+      );
+
+  Widget _getGalleryButton(final AppLocalizations appLocalizations) =>
+      EditImageButton(
+        iconData: Icons.image_search,
+        label: appLocalizations.edit_photo_select_existing_button_label,
+        onPressed: _actionGallery,
+      );
+
+  // TODO(monsieurtanuki): we should also suggest the existing image gallery
+  Future<File?> _actionNewImage() async => confirmAndUploadNewPicture(
         this,
         imageField: _imageData.imageField,
         barcode: _barcode,
       );
+
+  Future<void> _actionGallery() async {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+    final List<int>? result = await LoadingDialog.run<List<int>>(
+      future: OpenFoodAPIClient.getProductImageIds(
+        _barcode,
+        user: ProductQuery.getUser(),
+      ),
+      context: context,
+      title: appLocalizations.edit_photo_select_existing_download_label,
+    );
+    if (result == null) {
+      return;
+    }
+    if (!mounted) {
+      return;
+    }
+    if (result.isEmpty) {
+      await showDialog<void>(
+        context: context,
+        builder: (BuildContext context) => SmoothAlertDialog(
+          body:
+              Text(appLocalizations.edit_photo_select_existing_downloaded_none),
+          actionsAxis: Axis.vertical,
+          positiveAction: SmoothActionButton(
+            text: appLocalizations.okay,
+            onPressed: () => Navigator.of(context).pop(),
+          ),
+        ),
+      );
       return;
     }
+    await Navigator.push<void>(
+      context,
+      MaterialPageRoute<void>(
+        builder: (BuildContext context) => UploadedImageGallery(
+          barcode: _barcode,
+          imageIds: result,
+          imageField: widget.imageField,
+        ),
+      ),
+    );
+  }
+
+  Future<File?> _actionEditImage() async {
+    final NavigatorState navigatorState = Navigator.of(context);
+
+    // best possibility: with the crop parameters
+    // TODO(monsieurtanuki): maybe we should keep the big image locally, in order to avoid the server call?
+    final ProductImage? productImage = _getBestProductImage();
+    if (productImage != null) {
+      final int? imageId = int.tryParse(productImage.imgid!);
+      if (imageId != null) {
+        return _openEditCroppedImage(imageId, productImage);
+      }
+    }
 
-    // best option: use the transient file.
+    // alternate option: use the transient file.
     File? imageFile = TransientFile.getImage(
       _imageData.imageField,
       _barcode,
     );
+    if (imageFile != null) {
+      return _openCropPage(navigatorState, imageFile);
+    }
 
     // but if not possible, get the best picture from the server.
-    if (imageFile == null) {
-      final String? imageUrl = _imageData.getImageUrl(ImageSize.ORIGINAL);
-      imageFile = await downloadImageUrl(
-        context,
-        imageUrl,
-        DaoInt(_localDatabase),
-      );
-      if (imageFile == null) {
-        return;
-      }
+    final String? imageUrl = _imageData.getImageUrl(ImageSize.ORIGINAL);
+    imageFile = await downloadImageUrl(
+      context,
+      imageUrl,
+      DaoInt(_localDatabase),
+    );
+    if (imageFile != null) {
+      return _openCropPage(navigatorState, imageFile);
     }
 
-    if (!mounted) {
-      return;
-    }
+    return null;
+  }
 
-    await Navigator.push<File>(
-      context,
-      MaterialPageRoute<File>(
-        builder: (BuildContext context) => CropPage(
-          barcode: _barcode,
-          imageField: _imageData.imageField,
-          inputFile: imageFile!,
-          brandNewPicture: false,
+  Future<void> _actionUnselect() async {
+    final NavigatorState navigatorState = Navigator.of(context);
+    await BackgroundTaskUnselect.addTask(
+      _barcode,
+      imageField: widget.imageField,
+      widget: this,
+    );
+    _localDatabase.notifyListeners();
+    navigatorState.pop();
+  }
+
+  Future<File?> _openCropPage(
+    final NavigatorState navigatorState,
+    final File imageFile, {
+    final int? imageId,
+    final Rect? initialCropRect,
+    final Rotation? initialRotation,
+  }) async =>
+      navigatorState.push<File>(
+        MaterialPageRoute<File>(
+          builder: (BuildContext context) => CropPage(
+            barcode: _product.barcode!,
+            imageField: _imageData.imageField,
+            inputFile: imageFile,
+            imageId: imageId,
+            brandNewPicture: false,
+            initialCropRect: initialCropRect,
+            initialRotation: initialRotation,
+          ),
+          fullscreenDialog: true,
         ),
-        fullscreenDialog: true,
+      );
+
+  Future<File?> _openEditCroppedImage(
+    final int imageId,
+    final ProductImage productImage,
+  ) async {
+    final NavigatorState navigatorState = Navigator.of(context);
+    final LocalDatabase localDatabase = context.read<LocalDatabase>();
+    final File? imageFile = await downloadImageUrl(
+      context,
+      ImageHelper.getUploadedImageUrl(
+        _product.barcode!,
+        imageId,
+        ImageSize.ORIGINAL,
+      ),
+      DaoInt(localDatabase),
+    );
+    if (imageFile == null) {
+      return null;
+    }
+    return _openCropPage(
+      navigatorState,
+      imageFile,
+      imageId: imageId,
+      initialCropRect: _getCropRect(productImage),
+      initialRotation: RotationExtension.fromDegrees(
+        productImage.angle?.degree ?? 0,
       ),
     );
   }
+
+  ProductImage? _getBestProductImage() {
+    if (_product.images == null) {
+      return null;
+    }
+    for (final ProductImage productImage in _product.images!) {
+      if (productImage.field != _imageData.imageField) {
+        continue;
+      }
+      if (productImage.language != ProductQuery.getLanguage()) {
+        continue;
+      }
+      if (productImage.size == ImageSize.ORIGINAL) {
+        if (productImage.imgid != null) {
+          return productImage;
+        }
+      }
+    }
+    return null;
+  }
+
+  /// Returns a crop rect, to be compared with the full image dimensions.
+  Rect? _getCropRect(final ProductImage productImage) =>
+      productImage.x1 == null ||
+              productImage.y1 == null ||
+              productImage.x2 == null ||
+              productImage.y2 == null
+          ? null
+          : Rect.fromLTRB(
+              productImage.x1!.toDouble(),
+              productImage.y1!.toDouble(),
+              productImage.x2!.toDouble(),
+              productImage.y2!.toDouble(),
+            );
 }
diff --git a/packages/smooth_app/lib/query/product_query.dart b/packages/smooth_app/lib/query/product_query.dart
index 4c6b0ad488bf..b9546128ac48 100644
--- a/packages/smooth_app/lib/query/product_query.dart
+++ b/packages/smooth_app/lib/query/product_query.dart
@@ -134,6 +134,7 @@ abstract class ProductQuery {
         ProductField.IMAGE_INGREDIENTS_URL,
         ProductField.IMAGE_NUTRITION_URL,
         ProductField.IMAGE_PACKAGING_URL,
+        ProductField.IMAGES,
         ProductField.SELECTED_IMAGE,
         ProductField.QUANTITY,
         ProductField.SERVING_SIZE,
diff --git a/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart b/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart
index 93f04723f115..5bbb41a51040 100644
--- a/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart
+++ b/packages/smooth_app/lib/tmp_crop_image/new_crop_page.dart
@@ -9,7 +9,6 @@ import 'package:image/image.dart' as image2;
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:path_provider/path_provider.dart';
 import 'package:provider/provider.dart';
-import 'package:scanner_shared/scanner_shared.dart';
 import 'package:smooth_app/background/background_task_crop.dart';
 import 'package:smooth_app/background/background_task_image.dart';
 import 'package:smooth_app/data_models/continuous_scan_model.dart';
@@ -19,7 +18,6 @@ import 'package:smooth_app/generic_lib/design_constants.dart';
 import 'package:smooth_app/generic_lib/loading_dialog.dart';
 import 'package:smooth_app/helpers/database_helper.dart';
 import 'package:smooth_app/helpers/product_cards_helper.dart';
-import 'package:smooth_app/pages/image_crop_page.dart';
 import 'package:smooth_app/pages/product/edit_image_button.dart';
 import 'package:smooth_app/pages/product/may_exit_page_helper.dart';
 import 'package:smooth_app/tmp_crop_image/rotated_crop_controller.dart';
@@ -35,6 +33,8 @@ class CropPage extends StatefulWidget {
     required this.imageField,
     required this.brandNewPicture,
     this.imageId,
+    this.initialCropRect,
+    this.initialRotation,
   });
 
   /// The initial input file we start with.
@@ -49,6 +49,10 @@ class CropPage extends StatefulWidget {
   /// Only makes sense when we deal with an "already existing" image.
   final int? imageId;
 
+  final Rect? initialCropRect;
+
+  final Rotation? initialRotation;
+
   @override
   State<CropPage> createState() => _CropPageState();
 }
@@ -68,10 +72,8 @@ class _CropPageState extends State<CropPage> {
   /// Are we currently processing data (for action buttons hiding).
   bool _processing = true;
 
-  /// Latest picked picture (from Gallery or Camera).
-  XFile? _pickedPicture;
-
-  static const Rect _initialRect = Rect.fromLTRB(0, 0, 1, 1);
+  late Rect _initialCrop;
+  late Rotation _initialRotation;
 
   Future<ui.Image> _loadUiImage(final Uint8List list) async {
     final Completer<ui.Image> completer = Completer<ui.Image>();
@@ -82,7 +84,12 @@ class _CropPageState extends State<CropPage> {
   Future<void> _load(final Uint8List list) async {
     setState(() => _processing = true);
     _image = await _loadUiImage(list);
-    _controller = RotatedCropController(defaultCrop: _initialRect);
+    _initialCrop = _getInitialRect();
+    _initialRotation = widget.initialRotation ?? Rotation.noon;
+    _controller = RotatedCropController(
+      defaultCrop: _initialCrop,
+      rotation: _initialRotation,
+    );
     _processing = false;
     if (!mounted) {
       return;
@@ -90,6 +97,48 @@ class _CropPageState extends State<CropPage> {
     setState(() {});
   }
 
+  Rect _getInitialRect() {
+    if (widget.initialCropRect == null) {
+      return const Rect.fromLTRB(0, 0, 1, 1);
+    }
+    // sometimes the server returns those crop values, meaning full photo.
+    if (widget.initialCropRect!.left == -1 ||
+        widget.initialCropRect!.top == -1 ||
+        widget.initialCropRect!.right == -1 ||
+        widget.initialCropRect!.bottom == -1) {
+      return const Rect.fromLTRB(0, 0, 1, 1);
+    }
+    final Rect result;
+    final Rotation rotation = widget.initialRotation ?? Rotation.noon;
+    switch (rotation) {
+      case Rotation.noon:
+      case Rotation.sixOClock:
+        result = Rect.fromLTRB(
+          widget.initialCropRect!.left / _image.width,
+          widget.initialCropRect!.top / _image.height,
+          widget.initialCropRect!.right / _image.width,
+          widget.initialCropRect!.bottom / _image.height,
+        );
+        break;
+      case Rotation.threeOClock:
+      case Rotation.nineOClock:
+        result = Rect.fromLTRB(
+          widget.initialCropRect!.left / _image.height,
+          widget.initialCropRect!.top / _image.width,
+          widget.initialCropRect!.right / _image.height,
+          widget.initialCropRect!.bottom / _image.width,
+        );
+        break;
+    }
+    // we clamp in order to avoid controller crash.
+    return Rect.fromLTRB(
+      result.left.clamp(0, 1),
+      result.top.clamp(0, 1),
+      result.right.clamp(0, 1),
+      result.bottom.clamp(0, 1),
+    );
+  }
+
   @override
   void initState() {
     super.initState();
@@ -148,21 +197,12 @@ class _CropPageState extends State<CropPage> {
                       alwaysMove: true,
                     ),
                   ),
-                  Wrap(
-                    spacing: MEDIUM_SPACE,
-                    alignment: WrapAlignment.center,
-                    children: <Widget>[
-                      EditImageButton(
-                        iconData: Icons.camera_alt,
-                        label: appLocalizations.capture,
-                        onPressed: () async => _capture(),
-                      ),
-                      EditImageButton(
-                        iconData: Icons.check,
-                        label: appLocalizations.confirm_button_label,
-                        onPressed: () async => _mayExitPage(saving: true),
-                      ),
-                    ],
+                  Center(
+                    child: EditImageButton(
+                      iconData: Icons.send,
+                      label: appLocalizations.send_image_button_label,
+                      onPressed: () async => _mayExitPage(saving: true),
+                    ),
                   ),
                 ],
               ),
@@ -180,13 +220,7 @@ class _CropPageState extends State<CropPage> {
   ) async {
     final File result;
     final String fullPath = '${directory.path}/full_image_$sequenceNumber.jpeg';
-    if (_pickedPicture == null) {
-      result = widget.inputFile.copySync(fullPath);
-    } else {
-      result = File(fullPath);
-      final Uint8List list = await _pickedPicture!.readAsBytes();
-      await result.writeAsBytes(list);
-    }
+    result = widget.inputFile.copySync(fullPath);
     return result;
   }
 
@@ -301,9 +335,8 @@ class _CropPageState extends State<CropPage> {
   /// Parameter [saving] tells about the context: are we leaving the page,
   /// or have we clicked on the "save" button?
   Future<bool> _mayExitPage({required final bool saving}) async {
-    if (_controller.value.rotation == Rotation.noon &&
-        _controller.value.crop == _initialRect &&
-        _pickedPicture == null &&
+    if (_controller.value.rotation == _initialRotation &&
+        _controller.value.crop == _initialCrop &&
         !widget.brandNewPicture) {
       // nothing has changed, let's leave
       if (saving) {
@@ -340,21 +373,6 @@ class _CropPageState extends State<CropPage> {
       return false;
     }
   }
-
-  Future<void> _capture() async {
-    setState(() => _processing = true);
-    final XFile? pickedXFile = await pickImageFile(this);
-    if (pickedXFile == null) {
-      return;
-    }
-    _pickedPicture = pickedXFile;
-    await _load(await pickedXFile.readAsBytes());
-    _processing = false;
-    if (!mounted) {
-      return;
-    }
-    setState(() {});
-  }
 }
 
 /// Standard icon button for this page.
diff --git a/packages/smooth_app/lib/tmp_crop_image/rotation.dart b/packages/smooth_app/lib/tmp_crop_image/rotation.dart
index c8bb087255ca..03effb8c2202 100644
--- a/packages/smooth_app/lib/tmp_crop_image/rotation.dart
+++ b/packages/smooth_app/lib/tmp_crop_image/rotation.dart
@@ -38,6 +38,15 @@ extension RotationExtension on Rotation {
     }
   }
 
+  static Rotation? fromDegrees(final int degrees) {
+    for (final Rotation rotation in Rotation.values) {
+      if (rotation.degrees == degrees) {
+        return rotation;
+      }
+    }
+    return null;
+  }
+
   /// Returns the rotation rotated 90 degrees to the right.
   Rotation get rotateRight {
     switch (this) {
diff --git a/packages/smooth_app/pubspec.lock b/packages/smooth_app/pubspec.lock
index 3df17efb458b..96410a42e9aa 100644
--- a/packages/smooth_app/pubspec.lock
+++ b/packages/smooth_app/pubspec.lock
@@ -811,7 +811,7 @@ packages:
       name: openfoodfacts
       url: "https://pub.dartlang.org"
     source: hosted
-    version: "2.2.0"
+    version: "2.2.1"
   openfoodfacts_flutter_lints:
     dependency: "direct dev"
     description:
diff --git a/packages/smooth_app/pubspec.yaml b/packages/smooth_app/pubspec.yaml
index 6a5fb45ec064..5d2c993a054c 100644
--- a/packages/smooth_app/pubspec.yaml
+++ b/packages/smooth_app/pubspec.yaml
@@ -31,7 +31,7 @@ dependencies:
   latlong2: 0.8.1
   matomo_tracker: 1.5.0
   modal_bottom_sheet: 2.1.2
-  openfoodfacts: 2.2.0
+  openfoodfacts: 2.2.1
   # openfoodfacts:
   #   path: ../../../openfoodfacts-dart
   package_info_plus: 1.4.3+1
