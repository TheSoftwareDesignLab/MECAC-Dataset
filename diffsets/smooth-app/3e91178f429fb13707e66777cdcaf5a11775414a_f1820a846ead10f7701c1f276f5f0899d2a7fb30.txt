diff --git a/packages/smooth_app/lib/l10n/app_en.arb b/packages/smooth_app/lib/l10n/app_en.arb
index 0c821ed9d922..ea8bed959de5 100644
--- a/packages/smooth_app/lib/l10n/app_en.arb
+++ b/packages/smooth_app/lib/l10n/app_en.arb
@@ -4378,5 +4378,47 @@
   "product_edit_robotoff_expand_proof": "Expand proof",
   "@product_edit_robotoff_expand_proof": {
     "description": "Button to open in fullscreen the proof"
+  },
+   "page_indicator_with_total": "Page {current} / {total}",
+  "@page_indicator_with_total": {
+    "description": "Page indicator showing current page and total pages",
+    "placeholders": {
+      "current": {"type": "int", "description": "Current page number"},
+      "total": {"type": "int", "description": "Total number of pages"}
+    }
+  },
+  "page_indicator": "Page {current}",
+  "@page_indicator": {
+    "description": "Page indicator showing only current page when total is unknown",
+    "placeholders": {
+      "current": {"type": "int", "description": "Current page number"}
+    }
+  },
+  "item_count_with_total": "{count} of {total} items",
+  "@item_count_with_total": {
+    "description": "Item count showing current number of items and total items",
+    "placeholders": {
+      "count": {"type": "int", "description": "Current number of items loaded"},
+      "total": {"type": "int", "description": "Total number of items available"}
+    }
+  },
+  "item_count": "{count} items",
+  "@item_count": {
+    "description": "Item count showing only current number of items when total is unknown",
+    "placeholders": {
+      "count": {"type": "int", "description": "Current number of items loaded"}
+    }
+  },
+  "prices_no_result": "No price statistics found.",
+  "@prices_no_result": {
+    "description": "Message shown when there are no price statistics available to display"
+  },
+  "prices_error_loading_more_items": "Error loading more items",
+  "@prices_error_loading_more_items": {
+    "description": "Error message shown when additional items fail to load"
+  },
+  "prices_proof_error": "Authentication failed, unable to fetch proofs",
+  "@prices_proof_error": {
+    "description": "Error message shown when unable to fetch proofs"
   }
 }
\ No newline at end of file
diff --git a/packages/smooth_app/lib/pages/prices/infinite_scroll_list.dart b/packages/smooth_app/lib/pages/prices/infinite_scroll_list.dart
new file mode 100644
index 000000000000..e5f7b2ab0729
--- /dev/null
+++ b/packages/smooth_app/lib/pages/prices/infinite_scroll_list.dart
@@ -0,0 +1,167 @@
+import 'dart:async';
+import 'package:flutter/material.dart';
+import 'package:flutter_gen/gen_l10n/app_localizations.dart';
+import 'package:smooth_app/generic_lib/design_constants.dart';
+import 'package:smooth_app/generic_lib/widgets/smooth_card.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_manager.dart';
+
+/// A generic stateful widget for infinite scrolling lists that works with InfiniteScrollManager.
+class InfiniteScrollList<T> extends StatefulWidget {
+  const InfiniteScrollList({
+    required this.manager,
+  });
+
+  /// Manager for handling the infinite scroll behavior
+  final InfiniteScrollManager<T> manager;
+
+  @override
+  State<InfiniteScrollList<T>> createState() => _InfiniteScrollListState<T>();
+}
+
+class _InfiniteScrollListState<T> extends State<InfiniteScrollList<T>> {
+  static const double _loadMoreTriggerOffset = 200.0;
+
+  late final ScrollController _scrollController;
+  Object? _error;
+  bool _isInitialLoading = false;
+
+  @override
+  void initState() {
+    super.initState();
+    _scrollController = ScrollController();
+    _scrollController.addListener(_scrollListener);
+    unawaited(_initialLoad());
+  }
+
+  @override
+  void dispose() {
+    _scrollController.removeListener(_scrollListener);
+    _scrollController.dispose();
+    super.dispose();
+  }
+
+  Future<void> _initialLoad() async {
+    setState(() {
+      _isInitialLoading = true;
+      _error = null;
+    });
+
+    try {
+      await widget.manager.loadInitiallyIfNeeded(context);
+    } catch (e) {
+      _error = e;
+    } finally {
+      if (mounted) {
+        setState(() {
+          _isInitialLoading = false;
+        });
+      }
+    }
+  }
+
+  void _scrollListener() {
+    if (!widget.manager.canLoadMore()) {
+      return;
+    }
+
+    final double maxScroll = _scrollController.position.maxScrollExtent;
+    final double currentScroll = _scrollController.position.pixels;
+
+    if (currentScroll > maxScroll - _loadMoreTriggerOffset) {
+      unawaited(_loadMoreItems());
+    }
+  }
+
+  Future<void> _loadMoreItems() async {
+    if (mounted) {
+      setState(() {});
+      await widget.manager.loadMore(context);
+      if (mounted) {
+        setState(() {});
+      }
+    }
+  }
+
+  Widget _buildLoadingState(BuildContext context) {
+    return const Center(child: CircularProgressIndicator());
+  }
+
+  Widget _buildErrorState(BuildContext context, dynamic error) {
+    return Text(error.toString());
+  }
+
+  Widget _buildEmptyState(BuildContext context) {
+    return Text(AppLocalizations.of(context).prices_no_result);
+  }
+
+  Widget _buildLoadingMoreIndicator(BuildContext context) {
+    return const Padding(
+      padding: EdgeInsets.symmetric(vertical: 16.0),
+      child: Center(child: CircularProgressIndicator()),
+    );
+  }
+
+  Widget _buildFooter(BuildContext context) {
+    return const SizedBox(height: MINIMUM_TOUCH_SIZE * 2);
+  }
+
+  Widget _buildHeader(BuildContext context) {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+    String title;
+    final int totalPages = widget.manager.totalPages ?? 1;
+    final int currentPage = widget.manager.currentPage;
+    final int itemsCount = widget.manager.items.length;
+    final int totalItems = widget.manager.totalItems ?? itemsCount;
+
+    if (totalPages > 1) {
+      title = appLocalizations.prices_list_length_many_pages(
+        itemsCount,
+        totalItems,
+      );
+      title = '$title ($currentPage / $totalPages)';
+    } else {
+      title = appLocalizations.prices_list_length_one_page(
+        itemsCount,
+      );
+    }
+
+    return SmoothCard(child: ListTile(title: Text(title)));
+  }
+
+  @override
+  Widget build(BuildContext context) {
+    if (_isInitialLoading) {
+      return _buildLoadingState(context);
+    }
+
+    if (_error != null) {
+      return _buildErrorState(context, _error);
+    }
+
+    if (widget.manager.items.isEmpty) {
+      return _buildEmptyState(context);
+    }
+
+    final List<Widget> children = <Widget>[];
+
+    children.add(_buildHeader(context));
+
+    for (final T item in widget.manager.items) {
+      children.add(widget.manager.getItemWidget(
+        context: context,
+        item: item,
+      ));
+    }
+
+    if (widget.manager.isLoading) {
+      children.add(_buildLoadingMoreIndicator(context));
+    }
+
+    children.add(_buildFooter(context));
+
+    return ListView(
+      controller: _scrollController,
+      children: children,
+    );
+  }
+}
diff --git a/packages/smooth_app/lib/pages/prices/infinite_scroll_manager.dart b/packages/smooth_app/lib/pages/prices/infinite_scroll_manager.dart
new file mode 100644
index 000000000000..0a63f56e07da
--- /dev/null
+++ b/packages/smooth_app/lib/pages/prices/infinite_scroll_manager.dart
@@ -0,0 +1,149 @@
+import 'package:flutter/material.dart';
+import 'package:flutter_gen/gen_l10n/app_localizations.dart';
+
+/// A generic abstract class for handling infinite scrolling in lists.
+/// [T] is the type of items being displayed.
+abstract class InfiniteScrollManager<T> {
+  /// Creates an instance of [InfiniteScrollManager] with optional initial items.
+  InfiniteScrollManager({
+    List<T>? initialItems,
+  })  : _items = initialItems ?? <T>[],
+        _currentPage =
+            initialItems != null && initialItems.isNotEmpty ? _initialPage : 0;
+
+  static const int _initialPage = 1;
+
+  /// Current items in the list
+  final List<T> _items;
+
+  /// Current page being fetched
+  int _currentPage;
+
+  /// Whether currently loading more items
+  bool _isLoading = false;
+
+  /// Additional pagination information
+  int? _totalItems;
+  int? _totalPages;
+
+  /// Getter for items
+  List<T> get items => _items;
+
+  /// Getter for current page
+  int get currentPage => _currentPage;
+
+  /// Getter for loading state
+  bool get isLoading => _isLoading;
+
+  /// Getter for total items
+  int? get totalItems => _totalItems;
+
+  /// Getter for total pages
+  int? get totalPages => _totalPages;
+
+  @protected
+  Future<void> fetchInit() async {}
+
+  /// Fetches data for a specific page
+  @protected
+  Future<void> fetchData(int pageNumber);
+
+  /// Displays an item.
+  @protected
+  Widget buildItem({
+    required BuildContext context,
+    required T item,
+  });
+
+  Widget getItemWidget({required BuildContext context, required T item}) {
+    return buildItem(context: context, item: item);
+  }
+
+  /// Update the list with new items and pagination info
+  @protected
+  void updateItems({
+    required List<T>? newItems,
+    required int? pageNumber,
+    required int? totalItems,
+    required int? totalPages,
+  }) {
+    if (newItems == null && pageNumber == null) {
+      return;
+    }
+    if (newItems != null) {
+      _items.addAll(newItems);
+    }
+    if (pageNumber != null) {
+      _currentPage = pageNumber;
+    }
+    _totalItems = totalItems ?? _totalItems;
+    _totalPages = totalPages ?? _totalPages;
+  }
+
+  /// Load initial data only if the list is empty
+  Future<void> loadInitiallyIfNeeded(BuildContext context) async {
+    await fetchInit();
+    if (_items.isNotEmpty) {
+      return;
+    }
+    if (context.mounted) {
+      await _load(context: context, pageNumber: _initialPage);
+    }
+  }
+
+  bool canLoadMore() {
+    return !_isLoading && (totalPages == null || currentPage < totalPages!);
+  }
+
+  /// Load more items (next page)
+  Future<void> loadMore(BuildContext context) async {
+    if (_totalPages != null && _currentPage >= _totalPages!) {
+      return;
+    }
+    await _load(context: context, pageNumber: _currentPage + 1);
+  }
+
+  /// Internal method to handle loading with error handling
+  Future<void> _load({
+    required BuildContext context,
+    required int pageNumber,
+  }) async {
+    if (_isLoading) {
+      return;
+    }
+
+    _isLoading = true;
+
+    try {
+      await fetchData(pageNumber);
+    } catch (e) {
+      if (context.mounted) {
+        ScaffoldMessenger.of(context).showSnackBar(
+          SnackBar(
+            content: Text(
+              AppLocalizations.of(context).prices_error_loading_more_items,
+            ),
+          ),
+        );
+      }
+    } finally {
+      _isLoading = false;
+    }
+  }
+
+  /// Returns a formatted page indicator (e.g., "Page 1 / 5")
+  String formattedPageIndicator(BuildContext context) {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+    return _totalPages != null
+        ? appLocalizations.page_indicator_with_total(_currentPage, _totalPages!)
+        : appLocalizations.page_indicator(_currentPage);
+  }
+
+  /// Returns a formatted item count (e.g., "25 of 100 items")
+  String formattedItemCount(BuildContext context) {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+    return _totalItems != null
+        ? appLocalizations.item_count_with_total(_items.length, _totalItems!)
+        : appLocalizations.item_count(_items.length);
+  }
+}
diff --git a/packages/smooth_app/lib/pages/prices/prices_locations_page.dart b/packages/smooth_app/lib/pages/prices/prices_locations_page.dart
index ae5ce783884e..525a02e0e3a7 100644
--- a/packages/smooth_app/lib/pages/prices/prices_locations_page.dart
+++ b/packages/smooth_app/lib/pages/prices/prices_locations_page.dart
@@ -6,6 +6,8 @@ import 'package:smooth_app/generic_lib/design_constants.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_back_button.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_card.dart';
 import 'package:smooth_app/helpers/launch_url_helper.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_list.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_manager.dart';
 import 'package:smooth_app/pages/prices/price_button.dart';
 import 'package:smooth_app/pages/prices/price_count_widget.dart';
 import 'package:smooth_app/pages/prices/price_location_widget.dart';
@@ -13,7 +15,7 @@ import 'package:smooth_app/query/product_query.dart';
 import 'package:smooth_app/widgets/smooth_app_bar.dart';
 import 'package:smooth_app/widgets/smooth_scaffold.dart';
 
-/// Page that displays the top prices locations.
+/// Page that displays the top prices locations with infinite scrolling.
 class PricesLocationsPage extends StatefulWidget {
   const PricesLocationsPage();
 
@@ -23,16 +25,13 @@ class PricesLocationsPage extends StatefulWidget {
 
 class _PricesLocationsPageState extends State<PricesLocationsPage>
     with TraceableClientMixin {
-  late final Future<MaybeError<GetLocationsResult>> _locations =
-      _showTopLocations();
-
-  // In this specific page, let's never try to go beyond the top 10.
-  // cf. https://github.com/openfoodfacts/smooth-app/pull/5383#issuecomment-2171117141
-  static const int _pageSize = 10;
+  final _InfiniteScrollLocationManager _locationManager =
+      _InfiniteScrollLocationManager();
 
   @override
   Widget build(BuildContext context) {
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
+
     return SmoothScaffold(
       appBar: SmoothAppBar(
         centerTitle: false,
@@ -53,117 +52,87 @@ class _PricesLocationsPageState extends State<PricesLocationsPage>
           ),
         ],
       ),
-      body: FutureBuilder<MaybeError<GetLocationsResult>>(
-        future: _locations,
-        builder: (
-          final BuildContext context,
-          final AsyncSnapshot<MaybeError<GetLocationsResult>> snapshot,
-        ) {
-          if (snapshot.connectionState != ConnectionState.done) {
-            return const Center(child: CircularProgressIndicator());
-          }
-          if (snapshot.hasError) {
-            return Text(snapshot.error!.toString());
-          }
-          // highly improbable
-          if (!snapshot.hasData) {
-            return const Text('no data');
-          }
-          if (snapshot.data!.isError) {
-            return Text(snapshot.data!.error!);
-          }
-          final GetLocationsResult result = snapshot.data!.value;
-          // highly improbable
-          if (result.items == null) {
-            return const Text('empty list');
-          }
-          final List<Widget> children = <Widget>[];
-          final AppLocalizations appLocalizations =
-              AppLocalizations.of(context);
-
-          for (final Location item in result.items!) {
-            final int priceCount = item.priceCount ?? 0;
-            children.add(
-              SmoothCard(
-                child: Wrap(
-                  spacing: VERY_SMALL_SPACE,
-                  children: <Widget>[
-                    PriceLocationWidget(item),
-                    PriceCountWidget(
-                      count: priceCount,
-                      onPressed: () async =>
-                          PriceLocationWidget.showLocationPrices(
-                        locationId: item.locationId,
-                        context: context,
-                      ),
-                    ),
-                    PriceButton(
-                      onPressed: () {},
-                      title: '${item.userCount}',
-                      iconData: PriceButton.userIconData,
-                      tooltip: item.userCount == null
-                          ? null
-                          : appLocalizations.prices_button_count_user(
-                              item.userCount!,
-                            ),
-                    ),
-                    PriceButton(
-                      onPressed: () {},
-                      title: '${item.productCount}',
-                      iconData: PriceButton.productIconData,
-                      tooltip: item.productCount == null
-                          ? null
-                          : appLocalizations.prices_button_count_product(
-                              item.productCount!,
-                            ),
-                    ),
-                    PriceButton(
-                      onPressed: () {},
-                      title: '${item.proofCount}',
-                      iconData: PriceButton.proofIconData,
-                      tooltip: item.proofCount == null
-                          ? null
-                          : appLocalizations.prices_button_count_proof(
-                              item.proofCount!,
-                            ),
-                    ),
-                  ],
-                ),
-              ),
-            );
-          }
-          final String title =
-              appLocalizations.prices_locations_list_length_many_pages(
-            _pageSize,
-            result.total!,
-          );
-          children.insert(
-            0,
-            SmoothCard(child: ListTile(title: Text(title))),
-          );
-          // so that the last content gets not hidden by the FAB
-          children.add(
-            const SizedBox(height: 2 * MINIMUM_TOUCH_SIZE),
-          );
-          return ListView(
-            children: children,
-          );
-        },
+      body: InfiniteScrollList<Location>(
+        manager: _locationManager,
       ),
     );
   }
+}
+
+/// A manager for handling location data with infinite scrolling
+class _InfiniteScrollLocationManager extends InfiniteScrollManager<Location> {
+  @override
+  Future<void> fetchData(final int pageNumber) async {
+    final MaybeError<GetLocationsResult> result =
+        await OpenPricesAPIClient.getLocations(
+      GetLocationsParameters()
+        ..pageNumber = pageNumber
+        ..pageSize = 10,
+    );
+    if (result.isError) {
+      throw result.detailError;
+    }
+    final GetLocationsResult value = result.value;
+    updateItems(
+      newItems: value.items,
+      pageNumber: value.pageNumber,
+      totalItems: value.total,
+      totalPages: value.numberOfPages,
+    );
+  }
+
+  @override
+  Widget buildItem({
+    required BuildContext context,
+    required Location item,
+  }) {
+    final AppLocalizations appLocalizations = AppLocalizations.of(context);
+    final int priceCount = item.priceCount ?? 0;
 
-  static Future<MaybeError<GetLocationsResult>> _showTopLocations() async =>
-      OpenPricesAPIClient.getLocations(
-        GetLocationsParameters()
-          ..orderBy = <OrderBy<GetLocationsOrderField>>[
-            const OrderBy<GetLocationsOrderField>(
-              field: GetLocationsOrderField.priceCount,
-              ascending: false,
+    return SmoothCard(
+      child: Wrap(
+        spacing: VERY_SMALL_SPACE,
+        children: <Widget>[
+          PriceLocationWidget(item),
+          PriceCountWidget(
+            count: priceCount,
+            onPressed: () async => PriceLocationWidget.showLocationPrices(
+              locationId: item.locationId,
+              context: context,
             ),
-          ]
-          ..pageSize = _pageSize
-          ..pageNumber = 1,
-        uriHelper: ProductQuery.uriPricesHelper,
-      );
+          ),
+          PriceButton(
+            onPressed: () {},
+            title: '${item.userCount}',
+            iconData: PriceButton.userIconData,
+            tooltip: item.userCount == null
+                ? null
+                : appLocalizations.prices_button_count_user(
+                    item.userCount!,
+                  ),
+          ),
+          PriceButton(
+            onPressed: () {},
+            title: '${item.productCount}',
+            iconData: PriceButton.productIconData,
+            tooltip: item.productCount == null
+                ? null
+                : appLocalizations.prices_button_count_product(
+                    item.productCount!,
+                  ),
+          ),
+          PriceButton(
+            onPressed: () {},
+            title: '${item.proofCount}',
+            iconData: PriceButton.proofIconData,
+            tooltip: item.proofCount == null
+                ? null
+                : appLocalizations.prices_button_count_proof(
+                    item.proofCount!,
+                  ),
+          ),
+        ],
+      ),
+    );
+  }
 }
diff --git a/packages/smooth_app/lib/pages/prices/prices_products_page.dart b/packages/smooth_app/lib/pages/prices/prices_products_page.dart
index b29f0fc41130..50a963192dc5 100644
--- a/packages/smooth_app/lib/pages/prices/prices_products_page.dart
+++ b/packages/smooth_app/lib/pages/prices/prices_products_page.dart
@@ -2,16 +2,17 @@ import 'package:flutter/material.dart';
 import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:matomo_tracker/matomo_tracker.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
-import 'package:smooth_app/generic_lib/design_constants.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_back_button.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_card.dart';
 import 'package:smooth_app/helpers/launch_url_helper.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_list.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_manager.dart';
 import 'package:smooth_app/pages/prices/price_product_widget.dart';
 import 'package:smooth_app/query/product_query.dart';
 import 'package:smooth_app/widgets/smooth_app_bar.dart';
 import 'package:smooth_app/widgets/smooth_scaffold.dart';
 
-/// Page that displays the top prices products.
+/// Page that displays the top prices products with infinite scrolling.
 class PricesProductsPage extends StatefulWidget {
   const PricesProductsPage();
 
@@ -21,16 +22,13 @@ class PricesProductsPage extends StatefulWidget {
 
 class _PricesProductsPageState extends State<PricesProductsPage>
     with TraceableClientMixin {
-  late final Future<MaybeError<GetPriceProductsResult>> _products =
-      _showTopProducts();
-
-  // In this specific page, let's never try to go beyond the top 10.
-  // cf. https://github.com/openfoodfacts/smooth-app/pull/5383#issuecomment-2171117141
-  static const int _pageSize = 10;
+  final _InfiniteScrollProductManager _productManager =
+      _InfiniteScrollProductManager();
 
   @override
-  Widget build(BuildContext context) {
+  Widget build(final BuildContext context) {
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
+
     return SmoothScaffold(
       appBar: SmoothAppBar(
         centerTitle: false,
@@ -51,76 +49,60 @@ class _PricesProductsPageState extends State<PricesProductsPage>
           ),
         ],
       ),
-      body: FutureBuilder<MaybeError<GetPriceProductsResult>>(
-        future: _products,
-        builder: (
-          final BuildContext context,
-          final AsyncSnapshot<MaybeError<GetPriceProductsResult>> snapshot,
-        ) {
-          if (snapshot.connectionState != ConnectionState.done) {
-            return const Center(child: CircularProgressIndicator());
-          }
-          if (snapshot.hasError) {
-            return Text(snapshot.error!.toString());
-          }
-          // highly improbable
-          if (!snapshot.hasData) {
-            return const Text('no data');
-          }
-          if (snapshot.data!.isError) {
-            return Text(snapshot.data!.error!);
-          }
-          final GetPriceProductsResult result = snapshot.data!.value;
-          // highly improbable
-          if (result.items == null) {
-            return const Text('empty list');
-          }
-          final List<Widget> children = <Widget>[];
-
-          for (final PriceProduct item in result.items!) {
-            children.add(
-              SmoothCard(
-                child: PriceProductWidget(
-                  item,
-                  enableCountButton: true,
-                ),
-              ),
-            );
-          }
-          final AppLocalizations appLocalizations =
-              AppLocalizations.of(context);
-          final String title =
-              appLocalizations.prices_products_list_length_many_pages(
-            _pageSize,
-            result.total!,
-          );
-          children.insert(
-            0,
-            SmoothCard(child: ListTile(title: Text(title))),
-          );
-          // so that the last content gets not hidden by the FAB
-          children.add(
-            const SizedBox(height: 2 * MINIMUM_TOUCH_SIZE),
-          );
-          return ListView(
-            children: children,
-          );
-        },
+      body: InfiniteScrollList<PriceProduct>(
+        manager: _productManager,
       ),
     );
   }
+}
 
-  static Future<MaybeError<GetPriceProductsResult>> _showTopProducts() async =>
-      OpenPricesAPIClient.getPriceProducts(
-        GetPriceProductsParameters()
-          ..orderBy = <OrderBy<GetPriceProductsOrderField>>[
-            const OrderBy<GetPriceProductsOrderField>(
-              field: GetPriceProductsOrderField.priceCount,
-              ascending: false,
-            ),
-          ]
-          ..pageSize = _pageSize
-          ..pageNumber = 1,
-        uriHelper: ProductQuery.uriPricesHelper,
-      );
+/// A manager for handling product data with infinite scrolling
+class _InfiniteScrollProductManager
+    extends InfiniteScrollManager<PriceProduct> {
+  static const int _pageSize = 10;
+
+  static const List<OrderBy<GetPriceProductsOrderField>> _orderBy =
+      <OrderBy<GetPriceProductsOrderField>>[
+    OrderBy<GetPriceProductsOrderField>(
+      field: GetPriceProductsOrderField.priceCount,
+      ascending: false,
+    ),
+  ];
+
+  @override
+  Future<void> fetchData(final int pageNumber) async {
+    final MaybeError<GetPriceProductsResult> result =
+        await OpenPricesAPIClient.getPriceProducts(
+      GetPriceProductsParameters()
+        ..pageNumber = pageNumber
+        ..pageSize = _pageSize
+        ..orderBy = _orderBy,
+      uriHelper: ProductQuery.uriPricesHelper,
+    );
+
+    if (result.isError) {
+      throw result.detailError;
+    }
+
+    final GetPriceProductsResult value = result.value;
+    updateItems(
+      newItems: value.items,
+      pageNumber: value.pageNumber,
+      totalItems: value.total,
+      totalPages: value.numberOfPages,
+    );
+  }
+
+  @override
+  Widget buildItem({
+    required BuildContext context,
+    required PriceProduct item,
+  }) {
+    return SmoothCard(
+      child: PriceProductWidget(
+        item,
+        enableCountButton: true,
+      ),
+    );
+  }
 }
diff --git a/packages/smooth_app/lib/pages/prices/prices_proofs_page.dart b/packages/smooth_app/lib/pages/prices/prices_proofs_page.dart
index a6686ec89df2..940ec92fa327 100644
--- a/packages/smooth_app/lib/pages/prices/prices_proofs_page.dart
+++ b/packages/smooth_app/lib/pages/prices/prices_proofs_page.dart
@@ -1,4 +1,3 @@
-import 'package:auto_size_text/auto_size_text.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:intl/intl.dart';
@@ -9,6 +8,8 @@ import 'package:smooth_app/generic_lib/widgets/images/smooth_image.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_back_button.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_card.dart';
 import 'package:smooth_app/helpers/launch_url_helper.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_list.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_manager.dart';
 import 'package:smooth_app/pages/prices/price_proof_page.dart';
 import 'package:smooth_app/query/product_query.dart';
 import 'package:smooth_app/widgets/smooth_app_bar.dart';
@@ -29,11 +30,16 @@ class PricesProofsPage extends StatefulWidget {
 
 class _PricesProofsPageState extends State<PricesProofsPage>
     with TraceableClientMixin {
-  late final Future<MaybeError<GetProofsResult>> _results = _download();
+  late final _InfiniteScrollProofManager _proofManager =
+      _InfiniteScrollProofManager(
+    selectProof: widget.selectProof,
+  );
 
-  static const int _columns = 3;
-  static const int _rows = 5;
-  static const int _pageSize = _columns * _rows;
+  @override
+  void dispose() {
+    _proofManager.dispose();
+    super.dispose();
+  }
 
   @override
   Widget build(BuildContext context) {
@@ -58,106 +64,25 @@ class _PricesProofsPageState extends State<PricesProofsPage>
           ),
         ],
       ),
-      body: FutureBuilder<MaybeError<GetProofsResult>>(
-        future: _results,
-        builder: (
-          final BuildContext context,
-          final AsyncSnapshot<MaybeError<GetProofsResult>> snapshot,
-        ) {
-          if (snapshot.connectionState != ConnectionState.done) {
-            return const Center(child: CircularProgressIndicator());
-          }
-          if (snapshot.hasError) {
-            return Text(snapshot.error!.toString());
-          }
-          // highly improbable
-          if (!snapshot.hasData) {
-            return const Text('no data');
-          }
-          if (snapshot.data!.isError) {
-            return Text(snapshot.data!.error!);
-          }
-          final GetProofsResult result = snapshot.data!.value;
-          // highly improbable
-          if (result.items == null) {
-            return const Text('empty list');
-          }
-          final double squareSize = MediaQuery.sizeOf(context).width / _columns;
-
-          final AppLocalizations appLocalizations =
-              AppLocalizations.of(context);
-          final String title = result.numberOfPages == 1
-              ? appLocalizations.prices_proofs_list_length_one_page(
-                  result.items!.length,
-                )
-              : appLocalizations.prices_proofs_list_length_many_pages(
-                  _pageSize,
-                  result.total!,
-                );
-          return Column(
-            children: <Widget>[
-              SmoothCard(
-                child: ListTile(
-                  title: Text(title),
-                ),
-              ),
-              if (result.items!.isNotEmpty)
-                Expanded(
-                  child: CustomScrollView(
-                    slivers: <Widget>[
-                      SliverGrid(
-                        gridDelegate:
-                            const SliverGridDelegateWithFixedCrossAxisCount(
-                          crossAxisCount: _columns,
-                        ),
-                        delegate: SliverChildBuilderDelegate(
-                          (
-                            final BuildContext context,
-                            final int index,
-                          ) {
-                            final Proof proof = result.items![index];
-                            if (proof.filePath == null) {
-                              // highly improbable
-                              return SizedBox(
-                                width: squareSize,
-                                height: squareSize,
-                              );
-                            }
-                            return InkWell(
-                              onTap: () async {
-                                if (widget.selectProof) {
-                                  Navigator.of(context).pop(proof);
-                                  return;
-                                }
-                                return Navigator.push<void>(
-                                  context,
-                                  MaterialPageRoute<void>(
-                                    builder: (BuildContext context) =>
-                                        PriceProofPage(
-                                      proof,
-                                    ),
-                                  ),
-                                );
-                              }, // PriceProofPage
-                              child: _PriceProofImage(proof,
-                                  squareSize: squareSize),
-                            );
-                          },
-                          addAutomaticKeepAlives: false,
-                          childCount: result.items!.length,
-                        ),
-                      ),
-                    ],
-                  ),
-                ),
-            ],
-          );
-        },
+      body: InfiniteScrollList<Proof>(
+        manager: _proofManager,
       ),
     );
   }
+}
+
+/// A manager for handling proof data with infinite scrolling
+class _InfiniteScrollProofManager extends InfiniteScrollManager<Proof> {
+  _InfiniteScrollProofManager({
+    required this.selectProof,
+  });
+
+  static const int _pageSize = 10;
+  final bool selectProof;
+  String? _bearerToken;
 
-  static Future<MaybeError<GetProofsResult>> _download() async {
+  @override
+  Future<void> fetchInit() async {
     final User user = ProductQuery.getWriteUser();
     final MaybeError<String> token =
         await OpenPricesAPIClient.getAuthenticationToken(
@@ -167,14 +92,19 @@ class _PricesProofsPageState extends State<PricesProofsPage>
     );
 
     if (token.isError) {
-      return MaybeError<GetProofsResult>.error(
-        error: token.error ?? 'Could not authenticate with the server',
-        statusCode: token.statusCode ?? 500,
-      );
+      throw Exception(token.error ?? 'Could not authenticate with the server');
     }
 
-    final String bearerToken = token.value;
+    _bearerToken = token.value;
+  }
+
+  @override
+  Future<void> fetchData(final int pageNumber) async {
+    if (_bearerToken == null) {
+      await fetchInit();
+    }
 
+    final User user = ProductQuery.getWriteUser();
     final MaybeError<GetProofsResult> result =
         await OpenPricesAPIClient.getProofs(
       GetProofsParameters()
@@ -186,71 +116,106 @@ class _PricesProofsPageState extends State<PricesProofsPage>
         ]
         ..owner = user.userId
         ..pageSize = _pageSize
-        ..pageNumber = 1,
+        ..pageNumber = pageNumber,
       uriHelper: ProductQuery.uriPricesHelper,
-      bearerToken: bearerToken,
+      bearerToken: _bearerToken!,
     );
 
-    await OpenPricesAPIClient.deleteUserSession(
-      uriHelper: ProductQuery.uriPricesHelper,
-      bearerToken: bearerToken,
+    if (result.isError) {
+      throw Exception(result.error ?? 'Failed to fetch proofs');
+    }
+
+    final GetProofsResult value = result.value;
+    updateItems(
+      newItems: value.items,
+      pageNumber: value.pageNumber,
+      totalItems: value.total,
+      totalPages: value.numberOfPages,
     );
+  }
+
+  /// Properly dispose of the session when the manager is no longer needed
+  void dispose() {
+    if (_bearerToken != null) {
+      OpenPricesAPIClient.deleteUserSession(
+        uriHelper: ProductQuery.uriPricesHelper,
+        bearerToken: _bearerToken!,
+      );
+    }
+  }
+
+  @override
+  Widget buildItem({
+    required BuildContext context,
+    required Proof item,
+  }) {
+    if (item.filePath == null) {
+      return const SizedBox.shrink();
+    }
 
-    return result;
+    return SmoothCard(
+      child: InkWell(
+        onTap: () async {
+          if (selectProof) {
+            Navigator.of(context).pop(item);
+            return;
+          }
+          return Navigator.push<void>(
+            context,
+            MaterialPageRoute<void>(
+              builder: (BuildContext context) => PriceProofPage(item),
+            ),
+          );
+        },
+        child: _PriceProofListItem(item),
+      ),
+    );
   }
 }
 
-// TODO(monsieurtanuki): reuse whatever will be coded in https://github.com/openfoodfacts/smooth-app/pull/5366
-class _PriceProofImage extends StatelessWidget {
-  const _PriceProofImage(
-    this.proof, {
-    required this.squareSize,
-  });
+class _PriceProofListItem extends StatelessWidget {
+  const _PriceProofListItem(this.proof);
 
   final Proof proof;
-  final double squareSize;
 
   @override
   Widget build(BuildContext context) {
     final DateFormat dateFormat =
         DateFormat.yMd(ProductQuery.getLocaleString());
-    final String date = dateFormat.format(proof.created);
-    return Stack(
-      children: <Widget>[
-        SmoothImage(
-          width: squareSize,
-          height: squareSize,
-          imageProvider: NetworkImage(
-            proof
-                .getFileUrl(
-                  uriProductHelper: ProductQuery.uriPricesHelper,
-                  isThumbnail: true,
-                )
-                .toString(),
+    final String date = dateFormat.format(proof.date ?? proof.created);
+
+    final double screenWidth = MediaQuery.of(context).size.width;
+    final double imageSize = screenWidth * 0.3;
+
+    return Padding(
+      padding: const EdgeInsets.all(SMALL_SPACE),
+      child: Row(
+        children: <Widget>[
+          SmoothImage(
+            width: imageSize,
+            height: imageSize,
+            imageProvider: NetworkImage(
+              proof
+                  .getFileUrl(
+                    uriProductHelper: ProductQuery.uriPricesHelper,
+                    isThumbnail: true,
+                  )
+                  .toString(),
+            ),
+            rounded: false,
           ),
-          rounded: false,
-        ),
-        SizedBox(
-          width: squareSize,
-          height: squareSize,
-          child: Align(
-            alignment: Alignment.bottomCenter,
-            child: Padding(
-              padding: const EdgeInsets.all(SMALL_SPACE),
-              child: Container(
-                height: VERY_LARGE_SPACE,
-                color: Colors.white.withAlpha(128),
-                child: Center(
-                  child: AutoSizeText(
-                    date,
-                    maxLines: 1,
-                  ),
+          const SizedBox(width: MEDIUM_SPACE),
+          Expanded(
+            child: Column(
+              children: <Widget>[
+                Text(
+                  date,
                 ),
-              ),
+              ],
             ),
           ),
-        ),
-      ],
+        ],
+      ),
     );
   }
 }
diff --git a/packages/smooth_app/lib/pages/prices/prices_users_page.dart b/packages/smooth_app/lib/pages/prices/prices_users_page.dart
index f8b87590461c..3f586159c04e 100644
--- a/packages/smooth_app/lib/pages/prices/prices_users_page.dart
+++ b/packages/smooth_app/lib/pages/prices/prices_users_page.dart
@@ -6,13 +6,15 @@ import 'package:smooth_app/generic_lib/design_constants.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_back_button.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_card.dart';
 import 'package:smooth_app/helpers/launch_url_helper.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_list.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_manager.dart';
 import 'package:smooth_app/pages/prices/price_count_widget.dart';
 import 'package:smooth_app/pages/prices/price_user_button.dart';
 import 'package:smooth_app/query/product_query.dart';
 import 'package:smooth_app/widgets/smooth_app_bar.dart';
 import 'package:smooth_app/widgets/smooth_scaffold.dart';
 
-/// Page that displays the top prices users.
+/// Page that displays the top prices users with infinite scrolling.
 class PricesUsersPage extends StatefulWidget {
   const PricesUsersPage();
 
@@ -22,15 +24,12 @@ class PricesUsersPage extends StatefulWidget {
 
 class _PricesUsersPageState extends State<PricesUsersPage>
     with TraceableClientMixin {
-  late final Future<MaybeError<GetUsersResult>> _users = _showTopUsers();
-
-  // In this specific page, let's never try to go beyond the top 10.
-  // cf. https://github.com/openfoodfacts/smooth-app/pull/5383#issuecomment-2171117141
-  static const int _pageSize = 10;
+  final _InfiniteScrollUserManager _userManager = _InfiniteScrollUserManager();
 
   @override
   Widget build(BuildContext context) {
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
+
     return SmoothScaffold(
       appBar: SmoothAppBar(
         centerTitle: false,
@@ -51,86 +50,68 @@ class _PricesUsersPageState extends State<PricesUsersPage>
           ),
         ],
       ),
-      body: FutureBuilder<MaybeError<GetUsersResult>>(
-        future: _users,
-        builder: (
-          final BuildContext context,
-          final AsyncSnapshot<MaybeError<GetUsersResult>> snapshot,
-        ) {
-          if (snapshot.connectionState != ConnectionState.done) {
-            return const Center(child: CircularProgressIndicator());
-          }
-          if (snapshot.hasError) {
-            return Text(snapshot.error!.toString());
-          }
-          // highly improbable
-          if (!snapshot.hasData) {
-            return const Text('no data');
-          }
-          if (snapshot.data!.isError) {
-            return Text(snapshot.data!.error!);
-          }
-          final GetUsersResult result = snapshot.data!.value;
-          // highly improbable
-          if (result.items == null) {
-            return const Text('empty list');
-          }
-          final List<Widget> children = <Widget>[];
-
-          for (final PriceUser item in result.items!) {
-            final int priceCount = item.priceCount ?? 0;
-            children.add(
-              SmoothCard(
-                child: Wrap(
-                  spacing: VERY_SMALL_SPACE,
-                  children: <Widget>[
-                    PriceUserButton(item.userId),
-                    PriceCountWidget(
-                      count: priceCount,
-                      onPressed: () async => PriceUserButton.showUserPrices(
-                        user: item.userId,
-                        context: context,
-                      ),
-                    ),
-                  ],
-                ),
-              ),
-            );
-          }
-          final AppLocalizations appLocalizations =
-              AppLocalizations.of(context);
-          final String title =
-              appLocalizations.prices_users_list_length_many_pages(
-            _pageSize,
-            result.total!,
-          );
-          children.insert(
-            0,
-            SmoothCard(child: ListTile(title: Text(title))),
-          );
-          // so that the last content gets not hidden by the FAB
-          children.add(
-            const SizedBox(height: 2 * MINIMUM_TOUCH_SIZE),
-          );
-          return ListView(
-            children: children,
-          );
-        },
+      body: InfiniteScrollList<PriceUser>(
+        manager: _userManager,
       ),
     );
   }
+}
+
+/// A manager for handling user data with infinite scrolling
+class _InfiniteScrollUserManager extends InfiniteScrollManager<PriceUser> {
+  static const int _pageSize = 10;
+
+  @override
+  Future<void> fetchData(final int pageNumber) async {
+    final GetUsersParameters parameters = GetUsersParameters()
+      ..orderBy = <OrderBy<GetUsersOrderField>>[
+        const OrderBy<GetUsersOrderField>(
+          field: GetUsersOrderField.priceCount,
+          ascending: false,
+        ),
+      ]
+      ..pageSize = _pageSize
+      ..pageNumber = pageNumber;
+
+    final MaybeError<GetUsersResult> result =
+        await OpenPricesAPIClient.getUsers(
+      parameters,
+      uriHelper: ProductQuery.uriPricesHelper,
+    );
+
+    if (result.isError) {
+      throw result.detailError;
+    }
+
+    final GetUsersResult value = result.value;
+    updateItems(
+      newItems: value.items,
+      pageNumber: value.pageNumber,
+      totalItems: value.total,
+      totalPages: value.numberOfPages,
+    );
+  }
 
-  static Future<MaybeError<GetUsersResult>> _showTopUsers() async =>
-      OpenPricesAPIClient.getUsers(
-        GetUsersParameters()
-          ..orderBy = <OrderBy<GetUsersOrderField>>[
-            const OrderBy<GetUsersOrderField>(
-              field: GetUsersOrderField.priceCount,
-              ascending: false,
+  @override
+  Widget buildItem({
+    required BuildContext context,
+    required PriceUser item,
+  }) {
+    final int priceCount = item.priceCount ?? 0;
+    return SmoothCard(
+      child: Wrap(
+        spacing: VERY_SMALL_SPACE,
+        children: <Widget>[
+          PriceUserButton(item.userId),
+          PriceCountWidget(
+            count: priceCount,
+            onPressed: () async => PriceUserButton.showUserPrices(
+              user: item.userId,
+              context: context,
             ),
-          ]
-          ..pageSize = _pageSize
-          ..pageNumber = 1,
-        uriHelper: ProductQuery.uriPricesHelper,
-      );
+          ),
+        ],
+      ),
+    );
+  }
 }
diff --git a/packages/smooth_app/lib/pages/prices/product_prices_list.dart b/packages/smooth_app/lib/pages/prices/product_prices_list.dart
index 36dba79bf6e8..0650f9c38eb6 100644
--- a/packages/smooth_app/lib/pages/prices/product_prices_list.dart
+++ b/packages/smooth_app/lib/pages/prices/product_prices_list.dart
@@ -1,20 +1,17 @@
 import 'dart:async';
 
 import 'package:flutter/material.dart';
-import 'package:flutter_gen/gen_l10n/app_localizations.dart';
 import 'package:matomo_tracker/matomo_tracker.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
-import 'package:smooth_app/data_models/preferences/user_preferences.dart';
 import 'package:smooth_app/database/local_database.dart';
-import 'package:smooth_app/generic_lib/design_constants.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_card.dart';
 import 'package:smooth_app/pages/prices/get_prices_model.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_list.dart';
+import 'package:smooth_app/pages/prices/infinite_scroll_manager.dart';
 import 'package:smooth_app/pages/prices/price_data_widget.dart';
-import 'package:smooth_app/pages/prices/price_location_widget.dart';
 import 'package:smooth_app/pages/prices/price_product_widget.dart';
-import 'package:smooth_app/pages/prices/product_price_refresher.dart';
-import 'package:smooth_app/pages/product/common/loading_status.dart';
+import 'package:smooth_app/query/product_query.dart';
 
 /// List of the latest prices for a given model.
 class ProductPricesList extends StatefulWidget {
@@ -32,140 +29,80 @@ class ProductPricesList extends StatefulWidget {
 
 class _ProductPricesListState extends State<ProductPricesList>
     with TraceableClientMixin {
-  late final ProductPriceRefresher _productPriceRefresher;
+  late final _InfiniteScrollPriceManager _priceManager;
 
   @override
   void initState() {
     super.initState();
-    _productPriceRefresher = ProductPriceRefresher(
-      model: widget.model,
-      userPreferences: context.read<UserPreferences>(),
+    _priceManager = _InfiniteScrollPriceManager(
       pricesResult: widget.pricesResult,
-      refreshDisplay: () {
-        if (mounted) {
-          setState(() {});
-        }
-      },
+      model: widget.model,
     );
   }
 
-  // TODO(monsieurtanuki): add a refresh gesture
-  // TODO(monsieurtanuki): add a "download the next 10" items
   @override
   Widget build(BuildContext context) {
     context.watch<LocalDatabase>();
-    unawaited(_productPriceRefresher.runIfNeeded());
-
-    switch (_productPriceRefresher.loadingStatus) {
-      case null:
-      case LoadingStatus.LOADING:
-        return const Center(child: CircularProgressIndicator());
-      case LoadingStatus.ERROR:
-        return Text(_productPriceRefresher.loadingError.toString());
-      case LoadingStatus.LOADED:
-        break;
-    }
-    // highly improbable
-    if (_productPriceRefresher.pricesResult!.items == null) {
-      return const Text('empty list');
-    }
-
-    return _ActualList(
-      model: widget.model,
-      result: _productPriceRefresher.pricesResult!,
+    return InfiniteScrollList<Price>(
+      manager: _priceManager,
     );
   }
 }
 
-class _ActualList extends StatelessWidget {
-  const _ActualList({
+/// A manager for handling price data with infinite scrolling
+class _InfiniteScrollPriceManager extends InfiniteScrollManager<Price> {
+  _InfiniteScrollPriceManager({
+    GetPricesResult? pricesResult,
     required this.model,
-    required this.result,
-  });
+  }) : super(initialItems: pricesResult?.items);
 
+  /// The model containing price query parameters
   final GetPricesModel model;
-  final GetPricesResult result;
 
   @override
-  Widget build(BuildContext context) {
-    final List<Widget> children = <Widget>[];
+  Future<void> fetchData(int pageNumber) async {
+    final GetPricesParameters parameters = model.parameters;
+    parameters.pageNumber = pageNumber;
+
+    final MaybeError<GetPricesResult> result =
+        await OpenPricesAPIClient.getPrices(parameters,
+            uriHelper: ProductQuery.uriPricesHelper);
+
+    if (result.isError) {
+      throw result.detailError;
+    }
 
-    if (!model.displayEachProduct) {
-      // in that case we display the product only once, if possible.
-      for (final Price price in result.items!) {
-        final PriceProduct? priceProduct = price.product;
-        if (priceProduct == null) {
-          continue;
-        }
-        children.add(
-          SmoothCard(
-            child: PriceProductWidget(
+    final GetPricesResult value = result.value;
+    updateItems(
+      newItems: value.items,
+      pageNumber: value.pageNumber,
+      totalItems: value.total,
+      totalPages: value.numberOfPages,
+    );
+  }
+
+  @override
+  Widget buildItem({
+    required BuildContext context,
+    required Price item,
+  }) {
+    final PriceProduct? priceProduct = item.product;
+    return SmoothCard(
+      child: Column(
+        mainAxisAlignment: MainAxisAlignment.start,
+        crossAxisAlignment: CrossAxisAlignment.start,
+        children: <Widget>[
+          if (model.displayEachProduct && priceProduct != null)
+            PriceProductWidget(
               priceProduct,
               enableCountButton: model.enableCountButton,
             ),
+          PriceDataWidget(
+            item,
+            model: model,
           ),
-        );
-        break;
-      }
-    }
-    if (!model.displayEachLocation) {
-      // in that case we display the location only once, if possible.
-      for (final Price price in result.items!) {
-        final Location? location = price.location;
-        if (location == null) {
-          continue;
-        }
-        children.add(
-          SmoothCard(
-            child: PriceLocationWidget(location),
-          ),
-        );
-        break;
-      }
-    }
-
-    for (final Price price in result.items!) {
-      final PriceProduct? priceProduct = price.product;
-      children.add(
-        SmoothCard(
-          child: Column(
-            mainAxisAlignment: MainAxisAlignment.start,
-            crossAxisAlignment: CrossAxisAlignment.start,
-            children: <Widget>[
-              if (model.displayEachProduct && priceProduct != null)
-                PriceProductWidget(
-                  priceProduct,
-                  enableCountButton: model.enableCountButton,
-                ),
-              PriceDataWidget(
-                price,
-                model: model,
-              ),
-            ],
-          ),
-        ),
-      );
-    }
-    final AppLocalizations appLocalizations = AppLocalizations.of(context);
-    final String title =
-        result.numberOfPages != null && result.numberOfPages! <= 1
-            ? appLocalizations.prices_list_length_one_page(
-                result.items!.length,
-              )
-            : appLocalizations.prices_list_length_many_pages(
-                model.parameters.pageSize!,
-                result.total!,
-              );
-    children.insert(
-      0,
-      SmoothCard(child: ListTile(title: Text(title))),
-    );
-    // so that the last content gets not hidden by the FAB
-    children.add(
-      const SizedBox(height: 2 * MINIMUM_TOUCH_SIZE),
-    );
-    return ListView(
-      children: children,
+        ],
+      ),
     );
   }
 }
