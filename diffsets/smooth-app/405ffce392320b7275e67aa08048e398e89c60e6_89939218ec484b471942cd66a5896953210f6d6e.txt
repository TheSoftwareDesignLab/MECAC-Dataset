diff --git a/packages/smooth_app/lib/background/operation_type.dart b/packages/smooth_app/lib/background/operation_type.dart
index 7829ea8e24c9..f1ca47b1c99d 100644
--- a/packages/smooth_app/lib/background/operation_type.dart
+++ b/packages/smooth_app/lib/background/operation_type.dart
@@ -40,7 +40,8 @@ enum OperationType {
   languageRefresh('L', 'LANGUAGE_REFRESH'),
   addPrice('A', 'ADD_PRICE'),
   addOtherPrice('E', 'ADD_OTHER_PRICE'),
-  details('D', 'PRODUCT_EDIT');
+  details('D', 'PRODUCT_EDIT'),
+  folksonomy('X', 'UPDATE_PRODUCT_TAG');
 
   const OperationType(this.header, this.processName);
 
@@ -88,6 +89,9 @@ enum OperationType {
     offlineProducts => BackgroundTaskDownloadProducts.fromJson(map),
     fullRefresh => BackgroundTaskFullRefresh.fromJson(map),
     languageRefresh => BackgroundTaskLanguageRefresh.fromJson(map),
+    folksonomy => throw Exception(
+      'Not implemented yet',
+    ), // FIXME: Implement correct background task process for folksonomy.
   };
 
   bool matches(final TransientOperation action) =>
@@ -109,6 +113,7 @@ enum OperationType {
     OperationType.fullRefresh => 'Refreshing the full local database',
     OperationType.languageRefresh =>
       'Refreshing the local database to a new language',
+    OperationType.folksonomy => 'Updating folksonomy product tags',
   };
 
   static int getSequentialId(final TransientOperation operation) {
diff --git a/packages/smooth_app/lib/database/dao_transient_folksonomy.dart b/packages/smooth_app/lib/database/dao_transient_folksonomy.dart
new file mode 100644
index 000000000000..e4980d78e21e
--- /dev/null
+++ b/packages/smooth_app/lib/database/dao_transient_folksonomy.dart
@@ -0,0 +1,54 @@
+import 'dart:convert';
+
+import 'package:hive/hive.dart';
+import 'package:smooth_app/database/abstract_dao.dart';
+import 'package:smooth_app/pages/folksonomy/folksonomy_operation.dart';
+
+class DaoTransientFolksonomy extends AbstractDao {
+  DaoTransientFolksonomy(super.localDatabase);
+
+  static const String _hiveBoxName = 'transientFolksonomyOperations';
+
+  @override
+  Future<void> init() async => Hive.openBox<String>(_hiveBoxName);
+
+  @override
+  void registerAdapter() {}
+
+  Box<String> _getBox() => Hive.box<String>(_hiveBoxName);
+
+  List<FolksonomyOperation>? get(final String barcode) {
+    final String? value = _getBox().get(barcode);
+    if (value == null) {
+      return null;
+    }
+    return _getFolksonomyOperationsFromJson(value);
+  }
+
+  List<String> getAllBarcodes() =>
+      _getBox().keys.map((dynamic barcode) => barcode.toString()).toList();
+
+  Future<void> put(
+    final String barcode,
+    final List<FolksonomyOperation> operations,
+  ) => _getBox().put(barcode, _writeFolksonomyOperationsToJson(operations));
+
+  Future<void> delete(final String barcode) async => _getBox().delete(barcode);
+
+  List<FolksonomyOperation> _getFolksonomyOperationsFromJson(
+    final String operations,
+  ) => (jsonDecode(operations) as List<dynamic>)
+      .map(
+        (dynamic json) =>
+            FolksonomyOperation.fromJson(json as Map<String, dynamic>),
+      )
+      .toList();
+
+  String _writeFolksonomyOperationsToJson(
+    final List<FolksonomyOperation> operations,
+  ) => jsonEncode(
+    operations
+        .map((FolksonomyOperation operation) => operation.toJson())
+        .toList(),
+  );
+}
diff --git a/packages/smooth_app/lib/database/local_database.dart b/packages/smooth_app/lib/database/local_database.dart
index 88489e89c9ae..1faa40865e67 100644
--- a/packages/smooth_app/lib/database/local_database.dart
+++ b/packages/smooth_app/lib/database/local_database.dart
@@ -20,6 +20,7 @@ import 'package:smooth_app/database/dao_product_list.dart';
 import 'package:smooth_app/database/dao_string.dart';
 import 'package:smooth_app/database/dao_string_list.dart';
 import 'package:smooth_app/database/dao_string_list_map.dart';
+import 'package:smooth_app/database/dao_transient_folksonomy.dart';
 import 'package:smooth_app/database/dao_transient_operation.dart';
 import 'package:smooth_app/database/dao_work_barcode.dart';
 import 'package:sqflite_common_ffi/sqflite_ffi.dart';
@@ -95,6 +96,7 @@ class LocalDatabase extends ChangeNotifier {
       DaoInt(localDatabase),
       DaoStringListMap(localDatabase),
       DaoTransientOperation(localDatabase),
+      DaoTransientFolksonomy(localDatabase),
     ];
     for (final AbstractDao dao in daos) {
       dao.registerAdapter();
diff --git a/packages/smooth_app/lib/pages/folksonomy/folksonomy_card.dart b/packages/smooth_app/lib/pages/folksonomy/folksonomy_card.dart
index 797474bec0d3..868e6a452933 100644
--- a/packages/smooth_app/lib/pages/folksonomy/folksonomy_card.dart
+++ b/packages/smooth_app/lib/pages/folksonomy/folksonomy_card.dart
@@ -1,3 +1,5 @@
+import 'dart:async';
+
 import 'package:flutter/material.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
@@ -18,7 +20,7 @@ class FolksonomyCard extends StatelessWidget {
   @override
   Widget build(BuildContext context) {
     return ChangeNotifierProvider<FolksonomyProvider>(
-      create: (_) =>
+      create: (BuildContext context) =>
           FolksonomyProvider(product.barcode!, context.read<LocalDatabase>()),
       child: Provider<Product>.value(
         value: product,
@@ -84,14 +86,6 @@ class _FolksonomyCard extends StatelessWidget {
                           tags: final List<ProductTag> tags,
                         ) =>
                           getIcon(tags),
-                        FolksonomyStateAddedItem(
-                          tags: final List<ProductTag> tags,
-                        ) =>
-                          getIcon(tags),
-                        FolksonomyStateRemovedItem(
-                          tags: final List<ProductTag> tags,
-                        ) =>
-                          getIcon(tags),
                         _ => EMPTY_WIDGET,
                       };
                     },
@@ -117,10 +111,7 @@ class _FolksonomyCard extends StatelessWidget {
   ) async {
     await Navigator.of(context).push(
       MaterialPageRoute<void>(
-        builder: (BuildContext lContext) => FolksonomyPage(
-          product: product,
-          provider: context.read<FolksonomyProvider>(),
-        ),
+        builder: (BuildContext lContext) => FolksonomyPage(product: product),
       ),
     );
     if (context.mounted) {
diff --git a/packages/smooth_app/lib/pages/folksonomy/folksonomy_manager.dart b/packages/smooth_app/lib/pages/folksonomy/folksonomy_manager.dart
new file mode 100644
index 000000000000..e93451e9945a
--- /dev/null
+++ b/packages/smooth_app/lib/pages/folksonomy/folksonomy_manager.dart
@@ -0,0 +1,217 @@
+import 'dart:async';
+
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:smooth_app/database/dao_folksonomy.dart';
+import 'package:smooth_app/database/dao_transient_folksonomy.dart';
+import 'package:smooth_app/database/local_database.dart';
+import 'package:smooth_app/pages/folksonomy/folksonomy_operation.dart';
+import 'package:smooth_app/pages/folksonomy/folksonomy_provider.dart';
+import 'package:smooth_app/query/product_query.dart';
+
+/// Writer class around Folksonomy, temporary until we implement BackgroundTasks
+class FolksonomyManager {
+  FolksonomyManager(this._localDatabase)
+    : _daoFolksonomy = DaoFolksonomy(_localDatabase),
+      _daoTransientFolksonomy = DaoTransientFolksonomy(_localDatabase);
+
+  final LocalDatabase _localDatabase;
+  final DaoFolksonomy _daoFolksonomy;
+  final DaoTransientFolksonomy _daoTransientFolksonomy;
+
+  String? _bearerToken;
+
+  Future<void> addTag(String barcode, String key, String value) async {
+    final ProductTag newProductTag = ProductTag(
+      barcode: barcode,
+      key: key,
+      value: value,
+      owner: '',
+      version: 1,
+      editor: '',
+      lastEdit: DateTime.now(),
+      comment: '',
+    );
+
+    await _daoTransientFolksonomy.put(barcode, <FolksonomyOperation>[
+      ...getPendingOperations(barcode) ?? <FolksonomyOperation>[],
+      FolksonomyOperation(type: FolksonomyAction.add, tag: newProductTag),
+    ]);
+    unawaited(serverPerformActions(barcode));
+  }
+
+  Future<void> editTag(
+    String barcode,
+    String key,
+    String newValue,
+    int newVersion,
+  ) async {
+    final ProductTag editedProductTag = ProductTag(
+      barcode: barcode,
+      key: key,
+      value: newValue,
+      owner: '',
+      version: newVersion,
+      editor: '',
+      lastEdit: DateTime.now(),
+      comment: '',
+    );
+
+    await _daoTransientFolksonomy.put(barcode, <FolksonomyOperation>[
+      ...getPendingOperations(barcode) ?? <FolksonomyOperation>[],
+      FolksonomyOperation(type: FolksonomyAction.edit, tag: editedProductTag),
+    ]);
+    unawaited(serverPerformActions(barcode));
+  }
+
+  Future<void> deleteTag(String barcode, String key, int version) async {
+    final ProductTag tagToDelete = ProductTag(
+      barcode: barcode,
+      key: key,
+      value: '',
+      owner: '',
+      version: version,
+      editor: '',
+      lastEdit: DateTime.now(),
+      comment: '',
+    );
+
+    await _daoTransientFolksonomy.put(barcode, <FolksonomyOperation>[
+      ...getPendingOperations(barcode) ?? <FolksonomyOperation>[],
+      FolksonomyOperation(type: FolksonomyAction.remove, tag: tagToDelete),
+    ]);
+    unawaited(serverPerformActions(barcode));
+  }
+
+  Future<void> serverPerformAllActions() async {
+    final List<String> barcodes = _daoTransientFolksonomy.getAllBarcodes();
+    for (final String barcode in barcodes) {
+      await serverPerformActions(barcode);
+    }
+  }
+
+  Future<void> serverPerformActions(String barcode) async {
+    while (true) {
+      final FolksonomyOperation? operation = getPendingOperations(
+        barcode,
+      )?.firstOrNull;
+      if (operation == null) {
+        return;
+      }
+
+      try {
+        if (operation.type == FolksonomyAction.add) {
+          await _serverAdd(operation.tag);
+        } else if (operation.type == FolksonomyAction.edit) {
+          await _serverEdit(operation.tag);
+        } else if (operation.type == FolksonomyAction.remove) {
+          await _serverDelete(operation.tag);
+        }
+
+        await serverRefresh(barcode);
+
+        final List<FolksonomyOperation> pendingOperations =
+            getPendingOperations(barcode) ?? <FolksonomyOperation>[];
+        if (pendingOperations.isNotEmpty) {
+          pendingOperations.removeAt(0);
+          if (pendingOperations.isEmpty) {
+            await _daoTransientFolksonomy.delete(barcode);
+          } else {
+            await _daoTransientFolksonomy.put(barcode, pendingOperations);
+          }
+        }
+      } catch (e) {
+        return;
+      }
+    }
+  }
+
+  Future<void> _serverAdd(ProductTag tag) async {
+    final String bearerToken = await _getBearerToken();
+
+    // FIXME: The addProduct tag method does not yet have a way to add a comment.
+    final MaybeError<bool> result = await FolksonomyAPIClient.addProductTag(
+      barcode: tag.barcode,
+      key: tag.key,
+      value: tag.value,
+      bearerToken: bearerToken,
+      uriHelper: ProductQuery.uriFolksonomyHelper,
+    );
+    if (result.isError) {
+      throw Exception('Cannot add product tag: ${result.error}');
+    }
+  }
+
+  Future<void> _serverEdit(ProductTag tag) async {
+    final String bearerToken = await _getBearerToken();
+
+    final MaybeError<bool> result = await FolksonomyAPIClient.updateProductTag(
+      barcode: tag.barcode,
+      key: tag.key,
+      value: tag.value,
+      version: tag.version,
+      bearerToken: bearerToken,
+      uriHelper: ProductQuery.uriFolksonomyHelper,
+    );
+    if (result.isError) {
+      throw Exception('Cannot edit product tag: ${result.error}');
+    }
+  }
+
+  Future<void> _serverDelete(ProductTag tag) async {
+    final String bearerToken = await _getBearerToken();
+
+    final MaybeError<bool> result = await FolksonomyAPIClient.deleteProductTag(
+      barcode: tag.barcode,
+      key: tag.key,
+      version: tag.version,
+      bearerToken: bearerToken,
+      uriHelper: ProductQuery.uriFolksonomyHelper,
+    );
+    if (result.isError) {
+      throw Exception('Cannot delete product tag: ${result.error}');
+    }
+  }
+
+  Future<void> serverRefresh(String barcode) async {
+    final Map<String, ProductTag> tags =
+        await FolksonomyAPIClient.getProductTags(
+          barcode: barcode,
+          uriHelper: ProductQuery.uriFolksonomyHelper,
+        );
+    await _daoFolksonomy.put(barcode, tags.values.toList());
+
+    _localDatabase.notifyListeners();
+  }
+
+  Future<String> _getBearerToken() async {
+    if (_bearerToken != null) {
+      return _bearerToken!;
+    }
+
+    final User? user = OpenFoodAPIConfiguration.globalUser;
+    if (user == null) {
+      throw Exception('No user found');
+    }
+
+    final MaybeError<String> token =
+        await FolksonomyAPIClient.getAuthenticationToken(
+          username: user.userId,
+          password: user.password,
+          uriHelper: ProductQuery.uriFolksonomyHelper,
+        );
+
+    if (token.isError) {
+      throw Exception('Could not get token: ${token.error}');
+    }
+
+    if (token.value.isEmpty) {
+      throw Exception('Unexpected empty token');
+    }
+
+    _bearerToken = token.value;
+    return token.value;
+  }
+
+  List<FolksonomyOperation>? getPendingOperations(final String barcode) =>
+      _daoTransientFolksonomy.get(barcode);
+}
diff --git a/packages/smooth_app/lib/pages/folksonomy/folksonomy_operation.dart b/packages/smooth_app/lib/pages/folksonomy/folksonomy_operation.dart
new file mode 100644
index 000000000000..241295b4b2a5
--- /dev/null
+++ b/packages/smooth_app/lib/pages/folksonomy/folksonomy_operation.dart
@@ -0,0 +1,20 @@
+import 'package:openfoodfacts/openfoodfacts.dart';
+import 'package:smooth_app/pages/folksonomy/folksonomy_provider.dart';
+
+class FolksonomyOperation {
+  FolksonomyOperation({required this.type, required this.tag});
+
+  final FolksonomyAction type;
+  final ProductTag tag;
+
+  Map<String, dynamic> toJson() => <String, dynamic>{
+    'type': type.name,
+    'tag': tag.toJson(),
+  };
+
+  static FolksonomyOperation fromJson(Map<String, dynamic> json) =>
+      FolksonomyOperation(
+        type: FolksonomyAction.values.byName(json['type'] as String),
+        tag: ProductTag.fromJson(json['tag'] as Map<String, dynamic>),
+      );
+}
diff --git a/packages/smooth_app/lib/pages/folksonomy/folksonomy_page.dart b/packages/smooth_app/lib/pages/folksonomy/folksonomy_page.dart
index 6d8aabb3eddd..463edf7cc3bf 100644
--- a/packages/smooth_app/lib/pages/folksonomy/folksonomy_page.dart
+++ b/packages/smooth_app/lib/pages/folksonomy/folksonomy_page.dart
@@ -3,12 +3,11 @@ import 'dart:async';
 import 'package:flutter/material.dart' hide Listener;
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
+import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/generic_lib/bottom_sheets/smooth_bottom_sheet.dart';
 import 'package:smooth_app/generic_lib/design_constants.dart';
 import 'package:smooth_app/generic_lib/widgets/smooth_snackbar.dart';
 import 'package:smooth_app/helpers/product_cards_helper.dart';
-import 'package:smooth_app/helpers/provider_helper.dart';
-import 'package:smooth_app/helpers/ui_helpers.dart';
 import 'package:smooth_app/l10n/app_localizations.dart';
 import 'package:smooth_app/pages/folksonomy/folksonomy_create_edit_modal.dart';
 import 'package:smooth_app/pages/folksonomy/folksonomy_empty_page.dart';
@@ -22,15 +21,15 @@ import 'package:smooth_app/widgets/smooth_menu_button.dart';
 import 'package:smooth_app/widgets/smooth_scaffold.dart';
 
 class FolksonomyPage extends StatelessWidget {
-  const FolksonomyPage({required this.product, required this.provider});
+  const FolksonomyPage({required this.product});
 
   final Product product;
-  final FolksonomyProvider provider;
 
   @override
   Widget build(BuildContext context) {
-    return ChangeNotifierProvider<FolksonomyProvider>.value(
-      value: provider,
+    return ChangeNotifierProvider<FolksonomyProvider>(
+      create: (BuildContext context) =>
+          FolksonomyProvider(product.barcode!, context.read<LocalDatabase>()),
       child: _FolksonomyContent(product),
     );
   }
@@ -49,73 +48,41 @@ class _FolksonomyContentState extends State<_FolksonomyContent> {
   final ScrollController _scrollController = ScrollController();
   final GlobalKey<AnimatedListState> _listKey = GlobalKey<AnimatedListState>();
   final ProductRefresher _productRefresher = ProductRefresher();
+  final List<ProductTag> _tags = <ProductTag>[];
 
   @override
   Widget build(BuildContext context) {
     final AppLocalizations appLocalizations = AppLocalizations.of(context);
-    final FolksonomyProvider provider = context.watch<FolksonomyProvider>();
 
-    return SmoothScaffold(
-      appBar: SmoothAppBar(
-        title: Text(appLocalizations.product_tags_title),
-        subTitle: Text(
-          getProductNameAndBrands(widget.product, AppLocalizations.of(context)),
+    return Consumer<FolksonomyProvider>(
+      builder:
+          (BuildContext context, FolksonomyProvider provider, Widget? child) {
+            _onStateChanged(provider.value);
+            return child!;
+          },
+      child: SmoothScaffold(
+        appBar: SmoothAppBar(
+          title: Text(appLocalizations.product_tags_title),
+          subTitle: Text(
+            getProductNameAndBrands(widget.product, appLocalizations),
+          ),
         ),
-      ),
-      body: Listener<FolksonomyProvider>(
-        listener: _onProviderChanged,
-        child: Consumer<FolksonomyProvider>(
-          builder: (BuildContext context, FolksonomyProvider provider, _) {
-            if (provider.value is FolksonomyStateLoading ||
-                provider.value is FolksonomyStateError &&
-                    (provider.value as FolksonomyStateError).action == null) {
-              return const Center(child: CircularProgressIndicator.adaptive());
-            } else if (provider.value.tags?.isNotEmpty != true) {
-              return const FolksonomyEmptyPage();
+        body: _buildBody(),
+        floatingActionButton: SmoothExpandableFloatingActionButton(
+          scrollController: _scrollController,
+          onPressed: () async {
+            if (!await _checkIfLoggedIn()) {
+              return;
             }
-
-            return AnimatedList.separated(
-              key: _listKey,
-              controller: _scrollController,
-              initialItemCount: provider.value.tags!.length,
-              itemBuilder:
-                  (
-                    BuildContext context,
-                    int index,
-                    Animation<double> animation,
-                  ) {
-                    final ProductTag entry = provider.value.tags![index];
-                    return _buildItem(context, entry, animation);
-                  },
-              separatorBuilder: (_, _, Animation<double> animation) =>
-                  SizeTransition(sizeFactor: animation, child: const Divider()),
-              removedSeparatorBuilder:
-                  (
-                    BuildContext context,
-                    int index,
-                    Animation<double> animation,
-                  ) => SizeTransition(
-                    sizeFactor: animation,
-                    child: const Divider(),
-                  ),
+            await _showEditDialog(
+              action: FolksonomyAction.add,
+              existingKeys: _tags.map((ProductTag tag) => tag.key).toList(),
             );
           },
+          label: Text(appLocalizations.add_tag),
+          icon: const icons.AddProperty.alt(),
         ),
       ),
-      floatingActionButton: SmoothExpandableFloatingActionButton(
-        scrollController: _scrollController,
-        onPressed: () async {
-          if (!await _checkIfLoggedIn()) {
-            return;
-          }
-          await _showEditDialog(
-            action: FolksonomyAction.add,
-            existingKeys: _getExistingKeys(provider),
-          );
-        },
-        label: Text(appLocalizations.add_tag),
-        icon: const icons.AddProperty.alt(),
-      ),
     );
   }
 
@@ -215,11 +182,14 @@ class _FolksonomyContentState extends State<_FolksonomyContent> {
                 value: entry.value,
               );
             } else if (value == FolksonomyAction.remove) {
+              if (!await _checkIfLoggedIn()) {
+                return;
+              }
+              if (!context.mounted) {
+                return;
+              }
               unawaited(
-                context.read<FolksonomyProvider>().deleteTag(
-                  context,
-                  entry.key,
-                ),
+                context.read<FolksonomyProvider>().deleteTag(entry.key),
               );
             }
           },
@@ -229,9 +199,7 @@ class _FolksonomyContentState extends State<_FolksonomyContent> {
   }
 
   List<String> _getExistingKeys(FolksonomyProvider provider) {
-    return provider.value.tags!
-        .map((ProductTag tag) => tag.key)
-        .toList(growable: false);
+    return _tags.map((ProductTag tag) => tag.key).toList(growable: false);
   }
 
   Future<void> _showEditDialog({
@@ -265,20 +233,12 @@ class _FolksonomyContentState extends State<_FolksonomyContent> {
     if (res != null && mounted) {
       if (action == FolksonomyAction.edit) {
         unawaited(
-          context.read<FolksonomyProvider>().editTag(
-            context,
-            res.key,
-            res.value,
-          ),
+          context.read<FolksonomyProvider>().editTag(res.key, res.value),
         );
       } else if (action == FolksonomyAction.add) {
         try {
           unawaited(
-            context.read<FolksonomyProvider>().addTag(
-              context,
-              res.key,
-              res.value,
-            ),
+            context.read<FolksonomyProvider>().addTag(res.key, res.value),
           );
         } catch (e) {
           if (!mounted) {
@@ -295,32 +255,90 @@ class _FolksonomyContentState extends State<_FolksonomyContent> {
     }
   }
 
-  void _onProviderChanged(
-    BuildContext context,
-    _,
-    FolksonomyProvider provider,
-  ) {
-    if (provider.value is FolksonomyStateAddedItem) {
-      final FolksonomyStateAddedItem state =
-          provider.value as FolksonomyStateAddedItem;
-      _listKey.currentState?.insertItem(state.addedPosition);
+  void _onStateChanged(FolksonomyState newState) {
+    if (_listKey.currentState == null) {
+      return;
+    }
 
-      onNextFrame(() => provider.markAsConsumed());
-    } else if (provider.value is FolksonomyStateRemovedItem) {
-      final FolksonomyStateRemovedItem state =
-          provider.value as FolksonomyStateRemovedItem;
-      _listKey.currentState?.removeItem(state.removedPosition, (
-        BuildContext context,
-        Animation<double> animation,
-      ) {
-        return FadeTransition(
-          opacity: animation,
-          child: _buildItem(context, state.item, animation),
+    if (newState is! FolksonomyStateLoaded) {
+      if (_tags.isNotEmpty) {
+        for (int i = _tags.length - 1; i >= 0; i--) {
+          final ProductTag tag = _tags[i];
+          _listKey.currentState?.removeItem(
+            i,
+            (BuildContext context, Animation<double> animation) =>
+                _buildItem(context, tag, animation),
+          );
+        }
+        _tags.clear();
+      }
+      return;
+    }
+
+    final List<ProductTag> newTags = newState.tags!;
+
+    // Delete tags that are not in the new list.
+    for (int i = _tags.length - 1; i >= 0; i--) {
+      final ProductTag tag = _tags[i];
+      if (!newTags.any((ProductTag newTag) => newTag.key == tag.key)) {
+        _tags.removeAt(i);
+        _listKey.currentState?.removeItem(
+          i,
+          (BuildContext context, Animation<double> animation) =>
+              _buildItem(context, tag, animation),
         );
-      });
+      }
+    }
 
-      onNextFrame(() => provider.markAsConsumed());
+    // Add tags that are new.
+    for (int i = 0; i < newTags.length; i++) {
+      final ProductTag tag = newTags[i];
+      if (!_tags.any((ProductTag oldTag) => oldTag.key == tag.key)) {
+        _tags.insert(i, tag);
+        _listKey.currentState?.insertItem(i);
+      }
     }
+
+    // Edit tags that have changed.
+    for (int i = 0; i < newTags.length; i++) {
+      if (i < _tags.length &&
+          newTags[i].key == _tags[i].key &&
+          newTags[i].value != _tags[i].value) {
+        _tags[i] = newTags[i];
+      }
+    }
+  }
+
+  Widget _buildBody() {
+    final FolksonomyState state = context.watch<FolksonomyProvider>().value;
+
+    if (state is FolksonomyStateLoaded && _tags.isEmpty) {
+      _tags.addAll(state.tags!);
+    }
+
+    if (state is FolksonomyStateLoading && _tags.isEmpty) {
+      return const Center(child: CircularProgressIndicator.adaptive());
+    } else if (state is FolksonomyStateLoaded && state.tags!.isEmpty) {
+      return const FolksonomyEmptyPage();
+    } else if (state is FolksonomyStateError && state.action == null) {
+      return const FolksonomyEmptyPage();
+    }
+
+    return AnimatedList.separated(
+      key: _listKey,
+      controller: _scrollController,
+      initialItemCount: _tags.length,
+      itemBuilder:
+          (BuildContext context, int index, Animation<double> animation) {
+            final ProductTag entry = _tags[index];
+            return _buildItem(context, entry, animation);
+          },
+      separatorBuilder: (_, _, Animation<double> animation) =>
+          SizeTransition(sizeFactor: animation, child: const Divider()),
+      removedSeparatorBuilder:
+          (BuildContext context, int index, Animation<double> animation) =>
+              SizeTransition(sizeFactor: animation, child: const Divider()),
+    );
   }
 
   Future<bool> _checkIfLoggedIn() {
diff --git a/packages/smooth_app/lib/pages/folksonomy/folksonomy_provider.dart b/packages/smooth_app/lib/pages/folksonomy/folksonomy_provider.dart
index b36d94911649..18858ef7fdf5 100644
--- a/packages/smooth_app/lib/pages/folksonomy/folksonomy_provider.dart
+++ b/packages/smooth_app/lib/pages/folksonomy/folksonomy_provider.dart
@@ -5,63 +5,21 @@ import 'package:flutter/material.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:smooth_app/database/dao_folksonomy.dart';
 import 'package:smooth_app/database/local_database.dart';
-import 'package:smooth_app/pages/product/common/product_refresher.dart';
-import 'package:smooth_app/query/product_query.dart';
+import 'package:smooth_app/pages/folksonomy/folksonomy_manager.dart';
+import 'package:smooth_app/pages/folksonomy/folksonomy_operation.dart';
 
 class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
-  FolksonomyProvider(this.barcode, this.localDatabase)
-    : super(const FolksonomyStateLoading()) {
-    fetchProductTags();
+  FolksonomyProvider(this.barcode, LocalDatabase localDatabase)
+    : _daoFolksonomy = DaoFolksonomy(localDatabase),
+      _folksonomyManager = FolksonomyManager(localDatabase),
+      super(const FolksonomyStateLoading()) {
+    unawaited(_init());
   }
 
   final String barcode;
-  final LocalDatabase localDatabase;
-  String? _bearerToken;
+  final DaoFolksonomy _daoFolksonomy;
+  final FolksonomyManager _folksonomyManager;
   final List<ProductTag> _tags = <ProductTag>[];
-  final ProductRefresher _productRefresher = ProductRefresher();
-
-  Future<String?> _getBearerToken(BuildContext context) async {
-    if (_bearerToken != null) {
-      return _bearerToken!;
-    }
-
-    final bool isLoggedIn = await _productRefresher.checkIfLoggedIn(
-      context,
-      isLoggedInMandatory: true,
-    );
-
-    if (!isLoggedIn) {
-      return null;
-    }
-
-    final User? user = OpenFoodAPIConfiguration.globalUser;
-
-    if (user == null) {
-      throw Exception('No user found');
-    }
-
-    try {
-      final MaybeError<String> token =
-          await FolksonomyAPIClient.getAuthenticationToken(
-            username: user.userId,
-            password: user.password,
-            uriHelper: ProductQuery.uriFolksonomyHelper,
-          );
-
-      if (token.isError) {
-        throw Exception('Could not get token: ${token.error}');
-      }
-
-      if (token.value.isEmpty) {
-        throw Exception('Unexpected empty token');
-      }
-
-      _bearerToken = token.value;
-      return token.value;
-    } catch (err) {
-      throw Exception('Could not get token');
-    }
-  }
 
   // Display tags from local database first (to see it offline), then update from API.
   Future<void> fetchProductTags() async {
@@ -69,22 +27,10 @@ class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
       value = const FolksonomyStateLoading();
     }
 
-    try {
-      final DaoFolksonomy daoFolksonomy = DaoFolksonomy(localDatabase);
-      final List<ProductTag>? localTags = await daoFolksonomy.get(barcode);
-      if (localTags != null) {
-        _updateTags(localTags);
-      }
-
-      final Map<String, ProductTag> tags =
-          await FolksonomyAPIClient.getProductTags(
-            barcode: barcode,
-            uriHelper: ProductQuery.uriFolksonomyHelper,
-          );
-      final List<ProductTag> remoteTags = tags.values.toList();
+    unawaited(_refreshDisplayableTags());
 
-      await daoFolksonomy.put(barcode, remoteTags);
-      _updateTags(remoteTags);
+    try {
+      await _folksonomyManager.serverRefresh(barcode);
     } catch (e) {
       if (_tags.isEmpty) {
         value = FolksonomyStateError(error: e);
@@ -92,46 +38,10 @@ class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
     }
   }
 
-  Future<void> addTag(BuildContext context, String key, String value) async {
+  Future<void> addTag(String key, String value) async {
     try {
-      final String? bearerToken = await _getBearerToken(context);
-      if (bearerToken == null) {
-        return;
-      }
-
-      final ProductTag? tag = _getTag(key);
-      if (tag != null) {
-        throw Exception('This tag already exists!');
-      }
-
-      // to-do: The addProduct tag method does not yet have a way to add a comment.
-      await FolksonomyAPIClient.addProductTag(
-        barcode: barcode,
-        key: key,
-        value: value,
-        bearerToken: bearerToken,
-        uriHelper: ProductQuery.uriFolksonomyHelper,
-      );
-
-      final ProductTag newProductTag = ProductTag(
-        barcode: barcode,
-        key: key,
-        value: value,
-        owner: '',
-        version: 1,
-        editor: '',
-        lastEdit: DateTime.now(),
-        comment: '',
-      );
-
-      _tags.add(newProductTag);
-      _sortTags();
-
-      this.value = FolksonomyStateAddedItem(
-        tags: _tags,
-        addedPosition: _getPosition(key),
-        item: newProductTag,
-      );
+      await _folksonomyManager.addTag(barcode, key, value);
+      unawaited(_refreshDisplayableTags());
     } catch (e) {
       this.value = FolksonomyStateError(
         error: e,
@@ -141,49 +51,15 @@ class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
     }
   }
 
-  Future<void> editTag(
-    BuildContext context,
-    String key,
-    String newValue,
-  ) async {
+  Future<void> editTag(String key, String newValue) async {
     try {
-      final String? bearerToken = await _getBearerToken(context);
-      if (bearerToken == null) {
-        return;
-      }
-
-      final ProductTag? tag = _getTag(key);
-      if (tag == null) {
-        throw Exception('Tag not found');
-      }
-
-      await FolksonomyAPIClient.updateProductTag(
-        barcode: barcode,
-        key: key,
-        value: newValue,
-        version: tag.version + 1,
-        bearerToken: bearerToken,
-        uriHelper: ProductQuery.uriFolksonomyHelper,
-      );
-
-      final ProductTag editedProductTag = ProductTag(
-        barcode: barcode,
-        key: key,
-        value: newValue,
-        owner: '',
-        version: tag.version + 1,
-        editor: '',
-        lastEdit: DateTime.now(),
-        comment: '',
-      );
-
-      final int position = _getPosition(key);
-      _tags[position] = editedProductTag;
-      value = FolksonomyStateEditedItem(
-        tags: _tags,
-        item: editedProductTag,
-        position: position,
+      await _folksonomyManager.editTag(
+        barcode,
+        key,
+        newValue,
+        _getCurrentTagVersion(key) + 1,
       );
+      unawaited(_refreshDisplayableTags());
     } catch (e) {
       value = FolksonomyStateError(
         error: e,
@@ -193,34 +69,14 @@ class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
     }
   }
 
-  Future<void> deleteTag(BuildContext context, String key) async {
+  Future<void> deleteTag(String key) async {
     try {
-      final String? bearerToken = await _getBearerToken(context);
-      if (bearerToken == null) {
-        return;
-      }
-
-      final ProductTag? tag = _getTag(key);
-      if (tag == null) {
-        throw Exception('Tag not found');
-      }
-
-      await FolksonomyAPIClient.deleteProductTag(
-        barcode: barcode,
-        key: key,
-        version: tag.version,
-        bearerToken: bearerToken,
-        uriHelper: ProductQuery.uriFolksonomyHelper,
-      );
-
-      final int position = _getPosition(key);
-      _tags.removeAt(position);
-
-      value = FolksonomyStateRemovedItem(
-        tags: _tags,
-        removedPosition: position,
-        item: tag,
+      await _folksonomyManager.deleteTag(
+        barcode,
+        key,
+        _getCurrentTagVersion(key),
       );
+      unawaited(_refreshDisplayableTags());
     } catch (e) {
       value = FolksonomyStateError(
         error: e,
@@ -230,34 +86,9 @@ class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
     }
   }
 
-  void markAsConsumed() {
-    value = FolksonomyStateLoaded(tags: _tags);
-  }
-
-  Future<void> fetchKeys({String? query}) async {
-    try {
-      value = const FolksonomyStateLoading();
-
-      final Map<String, KeyStats> keyStats = await FolksonomyAPIClient.getKeys(
-        query: query,
-        uriHelper: ProductQuery.uriFolksonomyHelper,
-      );
-
-      value = FolksonomyStateKeysLoaded(keys: keyStats, tags: _tags);
-    } catch (e) {
-      value = FolksonomyStateError(error: e);
-    }
-  }
-
-  int _getPosition(String key) =>
-      _tags.indexWhere((ProductTag tag) => tag.key == key);
-
-  ProductTag? _getTag(String key) =>
-      _tags.firstWhereOrNull((ProductTag tag) => tag.key == key);
-
-  void _updateTags(final List<ProductTag> tags) {
+  void _updateDisplayableTags(final List<ProductTag> tags) {
     if (_equals(tags)) {
-      if (value is FolksonomyStateLoading) {
+      if (value is! FolksonomyStateLoaded) {
         value = FolksonomyStateLoaded(tags: _tags);
       }
       return;
@@ -278,6 +109,54 @@ class FolksonomyProvider extends ValueNotifier<FolksonomyState> {
     final List<ProductTag> toSort = tags ?? _tags;
     toSort.sort((ProductTag a, ProductTag b) => a.key.compareTo(b.key));
   }
+
+  Future<void> _init() async {
+    await fetchProductTags();
+    unawaited(
+      _folksonomyManager.serverPerformActions(barcode),
+    ); // TODO(darshanhtailor): Do we refresh for all barcodes here?
+  }
+
+  Future<void> _refreshDisplayableTags() async {
+    final List<ProductTag> localTags =
+        await _daoFolksonomy.get(barcode) ?? <ProductTag>[];
+    final List<FolksonomyOperation> pendingOperations =
+        _folksonomyManager.getPendingOperations(barcode) ??
+        <FolksonomyOperation>[];
+
+    for (final FolksonomyOperation operation in pendingOperations) {
+      final FolksonomyAction type = operation.type;
+      final ProductTag tag = operation.tag;
+      final int index = localTags.indexWhere(
+        (ProductTag t) => t.key == tag.key,
+      );
+
+      switch (type) {
+        case FolksonomyAction.add:
+          if (index == -1) {
+            localTags.add(tag);
+          }
+          break;
+        case FolksonomyAction.edit:
+          if (index != -1) {
+            localTags[index] = tag;
+          }
+          break;
+        case FolksonomyAction.remove:
+          if (index != -1) {
+            localTags.removeAt(index);
+          }
+          break;
+        case FolksonomyAction.visitUrl:
+          break;
+      }
+    }
+
+    _updateDisplayableTags(localTags);
+  }
+
+  int _getCurrentTagVersion(String key) =>
+      _tags.firstWhere((ProductTag tag) => tag.key == key).version;
 }
 
 sealed class FolksonomyState {
@@ -297,57 +176,6 @@ class FolksonomyStateLoaded extends FolksonomyState {
   List<ProductTag>? get tags => super.tags!;
 }
 
-class FolksonomyStateAddedItem extends FolksonomyState {
-  FolksonomyStateAddedItem({
-    required List<ProductTag> tags,
-    required this.addedPosition,
-    required this.item,
-  }) : super(tags: tags);
-
-  final int addedPosition;
-  final ProductTag item;
-
-  @override
-  List<ProductTag>? get tags => super.tags!;
-}
-
-class FolksonomyStateRemovedItem extends FolksonomyState {
-  FolksonomyStateRemovedItem({
-    required List<ProductTag> tags,
-    required this.removedPosition,
-    required this.item,
-  }) : super(tags: tags);
-
-  final int removedPosition;
-  final ProductTag item;
-
-  @override
-  List<ProductTag>? get tags => super.tags!;
-}
-
-class FolksonomyStateEditedItem extends FolksonomyState {
-  FolksonomyStateEditedItem({
-    required List<ProductTag> tags,
-    required this.position,
-    required this.item,
-  }) : super(tags: tags);
-
-  final int position;
-  final ProductTag item;
-
-  @override
-  List<ProductTag>? get tags => super.tags!;
-}
-
-class FolksonomyStateKeysLoaded extends FolksonomyState {
-  FolksonomyStateKeysLoaded({
-    required this.keys,
-    required List<ProductTag> tags,
-  }) : super(tags: tags);
-
-  final Map<String, KeyStats> keys;
-}
-
 class FolksonomyStateError extends FolksonomyState {
   FolksonomyStateError({required this.error, this.action, super.tags});
 
diff --git a/packages/smooth_app/lib/pages/product/edit_product/edit_product_page.dart b/packages/smooth_app/lib/pages/product/edit_product/edit_product_page.dart
index 5aa14d061486..dfe8d6d6b02e 100644
--- a/packages/smooth_app/lib/pages/product/edit_product/edit_product_page.dart
+++ b/packages/smooth_app/lib/pages/product/edit_product/edit_product_page.dart
@@ -11,7 +11,6 @@ import 'package:smooth_app/helpers/analytics_helper.dart';
 import 'package:smooth_app/helpers/product_cards_helper.dart';
 import 'package:smooth_app/l10n/app_localizations.dart';
 import 'package:smooth_app/pages/folksonomy/folksonomy_page.dart';
-import 'package:smooth_app/pages/folksonomy/folksonomy_provider.dart';
 import 'package:smooth_app/pages/onboarding/currency_selector_helper.dart';
 import 'package:smooth_app/pages/prices/price_meta_product.dart';
 import 'package:smooth_app/pages/prices/product_price_add_page.dart';
@@ -258,13 +257,8 @@ class _EditProductPageState extends State<EditProductPage> with UpToDateMixin {
                 leading: const Icon(Icons.edit),
                 onTap: () async => Navigator.of(context).push(
                   MaterialPageRoute<void>(
-                    builder: (BuildContext lContext) => FolksonomyPage(
-                      product: upToDateProduct,
-                      provider: FolksonomyProvider(
-                        upToDateProduct.barcode!,
-                        localDatabase,
-                      ),
-                    ),
+                    builder: (BuildContext lContext) =>
+                        FolksonomyPage(product: upToDateProduct),
                   ),
                 ),
               ),
diff --git a/packages/smooth_app/lib/pages/product/product_page/footer/new_product_footer_add_product_properties.dart b/packages/smooth_app/lib/pages/product/product_page/footer/new_product_footer_add_product_properties.dart
index fa277a400d7c..7e0c80adc8a4 100644
--- a/packages/smooth_app/lib/pages/product/product_page/footer/new_product_footer_add_product_properties.dart
+++ b/packages/smooth_app/lib/pages/product/product_page/footer/new_product_footer_add_product_properties.dart
@@ -1,10 +1,8 @@
 import 'package:flutter/material.dart';
 import 'package:openfoodfacts/openfoodfacts.dart';
 import 'package:provider/provider.dart';
-import 'package:smooth_app/database/local_database.dart';
 import 'package:smooth_app/l10n/app_localizations.dart';
 import 'package:smooth_app/pages/folksonomy/folksonomy_page.dart';
-import 'package:smooth_app/pages/folksonomy/folksonomy_provider.dart';
 import 'package:smooth_app/pages/product/common/product_refresher.dart';
 import 'package:smooth_app/pages/product/product_page/footer/new_product_footer.dart';
 import 'package:smooth_app/resources/app_icons.dart' as icons;
@@ -37,20 +35,10 @@ class ProductFooterAddPropertyButton extends StatelessWidget {
       return;
     }
 
-    final FolksonomyProvider provider = FolksonomyProvider(
-      product.barcode!,
-      context.read<LocalDatabase>(),
-    );
-
     await Navigator.of(context).push(
       MaterialPageRoute<void>(
-        builder: (BuildContext context) =>
-            FolksonomyPage(product: product, provider: provider),
+        builder: (BuildContext context) => FolksonomyPage(product: product),
       ),
     );
-
-    if (context.mounted) {
-      await provider.fetchProductTags();
-    }
   }
 }
