diff --git a/lib/ui/rich_editor/cupertino/text_selection.dart b/lib/ui/rich_editor/cupertino/text_selection.dart
deleted file mode 100644
index d39e70ec..00000000
--- a/lib/ui/rich_editor/cupertino/text_selection.dart
+++ /dev/null
@@ -1,305 +0,0 @@
-// Copyright 2017 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:math' as math;
-
-import 'package:flutter/cupertino.dart'
-    hide TextSelectionControls, TextSelectionDelegate, TextSelectionHandleType;
-import 'package:flutter/rendering.dart';
-import 'package:flutter/widgets.dart'
-    hide TextSelectionControls, TextSelectionDelegate, TextSelectionHandleType;
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/text_input.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/text_selection.dart';
-
-// Padding around the line at the edge of the text selection that has 0 width and
-// the height of the text font.
-const double _kHandlesPadding = 18.0;
-// Minimal padding from all edges of the selection toolbar to all edges of the
-// viewport.
-const double _kToolbarScreenPadding = 8.0;
-const double _kToolbarHeight = 36.0;
-
-const Color _kToolbarBackgroundColor = const Color(0xFF2E2E2E);
-const Color _kToolbarDividerColor = const Color(0xFFB9B9B9);
-const Color _kHandlesColor = const Color(0xFF146DDE);
-
-// This offset is used to determine the center of the selection during a drag.
-// It's slightly below the center of the text so the finger isn't entirely
-// covering the text being selected.
-const Size _kSelectionOffset = const Size(20.0, 30.0);
-const Size _kToolbarTriangleSize = const Size(18.0, 9.0);
-const EdgeInsets _kToolbarButtonPadding =
-    const EdgeInsets.symmetric(vertical: 10.0, horizontal: 21.0);
-const BorderRadius _kToolbarBorderRadius =
-    const BorderRadius.all(const Radius.circular(7.5));
-
-const TextStyle _kToolbarButtonFontStyle = const TextStyle(
-  fontSize: 14.0,
-  letterSpacing: -0.11,
-  fontWeight: FontWeight.w300,
-);
-
-/// Paints a triangle below the toolbar.
-class _TextSelectionToolbarNotchPainter extends CustomPainter {
-  @override
-  void paint(Canvas canvas, Size size) {
-    final Paint paint = new Paint()
-      ..color = _kToolbarBackgroundColor
-      ..style = PaintingStyle.fill;
-    final Path triangle = new Path()
-      ..lineTo(_kToolbarTriangleSize.width / 2, 0.0)
-      ..lineTo(0.0, _kToolbarTriangleSize.height)
-      ..lineTo(-(_kToolbarTriangleSize.width / 2), 0.0)
-      ..close();
-    canvas.drawPath(triangle, paint);
-  }
-
-  @override
-  bool shouldRepaint(_TextSelectionToolbarNotchPainter oldPainter) => false;
-}
-
-/// Manages a copy/paste text selection toolbar.
-class _TextSelectionToolbar extends StatelessWidget {
-  const _TextSelectionToolbar({
-    Key key,
-    this.delegate,
-    this.handleCut,
-    this.handleCopy,
-    this.handlePaste,
-    this.handleSelectAll,
-  })
-      : super(key: key);
-
-  final TextSelectionDelegate delegate;
-
-  AbstractTextEditingValue get editingValue => delegate.textEditingValue;
-
-  final VoidCallback handleCut;
-  final VoidCallback handleCopy;
-  final VoidCallback handlePaste;
-  final VoidCallback handleSelectAll;
-
-  @override
-  Widget build(BuildContext context) {
-    final List<Widget> items = <Widget>[];
-    final Widget onePhysicalPixelVerticalDivider =
-        new SizedBox(width: 1.0 / MediaQuery.of(context).devicePixelRatio);
-
-    if (!editingValue.selection.isCollapsed) {
-      items.add(_buildToolbarButton('Cut', handleCut));
-      items.add(onePhysicalPixelVerticalDivider);
-      items.add(_buildToolbarButton('Copy', handleCopy));
-    }
-
-    // TODO(https://github.com/flutter/flutter/issues/11254):
-    // This should probably be grayed-out if there is nothing to paste.
-    if (items.isNotEmpty) items.add(onePhysicalPixelVerticalDivider);
-    items.add(_buildToolbarButton('Paste', handlePaste));
-
-    if (editingValue.isNotEmpty && editingValue.selection.isCollapsed) {
-      items.add(onePhysicalPixelVerticalDivider);
-      items.add(_buildToolbarButton('Select All', handleSelectAll));
-    }
-
-    final Widget triangle = new SizedBox.fromSize(
-        size: _kToolbarTriangleSize,
-        child: new CustomPaint(
-          painter: new _TextSelectionToolbarNotchPainter(),
-        ));
-
-    return new Column(
-      mainAxisSize: MainAxisSize.min,
-      children: <Widget>[
-        new ClipRRect(
-          borderRadius: _kToolbarBorderRadius,
-          child: new DecoratedBox(
-            decoration: const BoxDecoration(
-              color: _kToolbarDividerColor,
-            ),
-            child: new Row(mainAxisSize: MainAxisSize.min, children: items),
-          ),
-        ),
-        // TODO(https://github.com/flutter/flutter/issues/11274):
-        // Position the triangle based on the layout delegate.
-        // And avoid letting the triangle line up with any dividers.
-        triangle,
-      ],
-    );
-  }
-
-  /// Builds a themed [CupertinoButton] for the toolbar.
-  CupertinoButton _buildToolbarButton(String text, VoidCallback onPressed) {
-    return new CupertinoButton(
-      child: new Text(text, style: _kToolbarButtonFontStyle),
-      color: _kToolbarBackgroundColor,
-      minSize: _kToolbarHeight,
-      padding: _kToolbarButtonPadding,
-      borderRadius: null,
-      pressedOpacity: 0.7,
-      onPressed: onPressed,
-    );
-  }
-}
-
-/// Centers the toolbar around the given position, ensuring that it remains on
-/// screen.
-class _TextSelectionToolbarLayout extends SingleChildLayoutDelegate {
-  _TextSelectionToolbarLayout(
-      this.screenSize, this.globalEditableRegion, this.position);
-
-  /// The size of the screen at the time that the toolbar was last laid out.
-  final Size screenSize;
-
-  /// Size and position of the editing region at the time the toolbar was last
-  /// laid out, in global coordinates.
-  final Rect globalEditableRegion;
-
-  /// Anchor position of the toolbar, relative to the top left of the
-  /// [globalEditableRegion].
-  final Offset position;
-
-  @override
-  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
-    return constraints.loosen();
-  }
-
-  @override
-  Offset getPositionForChild(Size size, Size childSize) {
-    final Offset globalPosition = globalEditableRegion.topLeft + position;
-
-    double x = globalPosition.dx - childSize.width / 2.0;
-    double y = globalPosition.dy - childSize.height;
-
-    if (x < _kToolbarScreenPadding)
-      x = _kToolbarScreenPadding;
-    else if (x + childSize.width > screenSize.width - _kToolbarScreenPadding)
-      x = screenSize.width - childSize.width - _kToolbarScreenPadding;
-
-    if (y < _kToolbarScreenPadding)
-      y = _kToolbarScreenPadding;
-    else if (y + childSize.height > screenSize.height - _kToolbarScreenPadding)
-      y = screenSize.height - childSize.height - _kToolbarScreenPadding;
-
-    return new Offset(x, y);
-  }
-
-  @override
-  bool shouldRelayout(_TextSelectionToolbarLayout oldDelegate) {
-    return screenSize != oldDelegate.screenSize ||
-        globalEditableRegion != oldDelegate.globalEditableRegion ||
-        position != oldDelegate.position;
-  }
-}
-
-/// Draws a single text selection handle with a bar and a ball.
-///
-/// Draws from a point of origin somewhere inside the size of the painter
-/// such that the ball is below the point of origin and the bar is above the
-/// point of origin.
-class _TextSelectionHandlePainter extends CustomPainter {
-  _TextSelectionHandlePainter({this.origin});
-
-  final Offset origin;
-
-  @override
-  void paint(Canvas canvas, Size size) {
-    final Paint paint = new Paint()
-      ..color = _kHandlesColor
-      ..strokeWidth = 2.0;
-    // Draw circle below the origin that slightly overlaps the bar.
-    canvas.drawCircle(origin.translate(0.0, 4.0), 5.5, paint);
-    // Draw up from origin leaving 10 pixels of margin on top.
-    canvas.drawLine(
-      origin,
-      origin.translate(
-        0.0,
-        -(size.height - 2.0 * _kHandlesPadding),
-      ),
-      paint,
-    );
-  }
-
-  @override
-  bool shouldRepaint(_TextSelectionHandlePainter oldPainter) =>
-      origin != oldPainter.origin;
-}
-
-class _CupertinoTextSelectionControls extends TextSelectionControls {
-  @override
-  Size handleSize = _kSelectionOffset; // Used for drag selection offset.
-
-  /// Builder for iOS-style copy/paste text selection toolbar.
-  @override
-  Widget buildToolbar(BuildContext context, Rect globalEditableRegion,
-      Offset position, TextSelectionDelegate delegate) {
-    assert(debugCheckHasMediaQuery(context));
-    return new ConstrainedBox(
-        constraints: new BoxConstraints.tight(globalEditableRegion.size),
-        child: new CustomSingleChildLayout(
-          delegate: new _TextSelectionToolbarLayout(
-            MediaQuery.of(context).size,
-            globalEditableRegion,
-            position,
-          ),
-          child: new _TextSelectionToolbar(
-            delegate: delegate,
-            handleCut: () => handleCut(delegate),
-            handleCopy: () => handleCopy(delegate),
-            handlePaste: () => handlePaste(delegate),
-            handleSelectAll: () => handleSelectAll(delegate),
-          ),
-        ));
-  }
-
-  /// Builder for iOS text selection edges.
-  @override
-  Widget buildHandle(BuildContext context, TextSelectionHandleType type,
-      double textLineHeight) {
-    // We want a size that's a vertical line the height of the text plus a 18.0
-    // padding in every direction that will constitute the selection drag area.
-    final Size desiredSize = new Size(
-        2.0 * _kHandlesPadding, textLineHeight + 2.0 * _kHandlesPadding);
-
-    final Widget handle = new SizedBox.fromSize(
-      size: desiredSize,
-      child: new CustomPaint(
-        painter: new _TextSelectionHandlePainter(
-          // We give the painter a point of origin that's at the bottom baseline
-          // of the selection cursor position.
-          //
-          // We give it in the form of an offset from the top left of the
-          // SizedBox.
-          origin:
-              new Offset(_kHandlesPadding, textLineHeight + _kHandlesPadding),
-        ),
-      ),
-    );
-
-    // [buildHandle]'s widget is positioned at the selection cursor's bottom
-    // baseline. We transform the handle such that the SizedBox is superimposed
-    // on top of the text selection endpoints.
-    switch (type) {
-      case TextSelectionHandleType
-          .left: // The left handle is upside down on iOS.
-        return new Transform(
-            transform: new Matrix4.rotationZ(math.pi)
-              ..translate(-_kHandlesPadding, -_kHandlesPadding),
-            child: handle);
-      case TextSelectionHandleType.right:
-        return new Transform(
-            transform: new Matrix4.translationValues(
-                -_kHandlesPadding, -(textLineHeight + _kHandlesPadding), 0.0),
-            child: handle);
-      case TextSelectionHandleType
-          .collapsed: // iOS doesn't draw anything for collapsed selections.
-        return new Container();
-    }
-    assert(type != null);
-    return null;
-  }
-}
-
-/// Text selection controls that follows iOS design conventions.
-final TextSelectionControls cupertinoTextSelectionControls =
-    new _CupertinoTextSelectionControls();
diff --git a/lib/ui/rich_editor/extensions.dart b/lib/ui/rich_editor/extensions.dart
deleted file mode 100644
index 0525789f..00000000
--- a/lib/ui/rich_editor/extensions.dart
+++ /dev/null
@@ -1,217 +0,0 @@
-import 'package:flutter/foundation.dart';
-import 'package:flutter/gestures.dart';
-import 'package:flutter/material.dart';
-
-class Extensions {
-  static bool isEmpty(TextSpan textSpan) {
-    assert(textSpan.debugAssertIsValid());
-    bool isEmpty = true;
-    textSpan.visitTextSpan((TextSpan span) {
-      if (span.text.isNotEmpty) {
-        isEmpty = false;
-        return false;
-      } else
-        return true;
-    });
-    return isEmpty;
-  }
-
-  static bool isNotEmpty(TextSpan textSpan) => !isEmpty(textSpan);
-
-  /// Return the length of the text contained in this [TextSpan] tree.
-  static int length(TextSpan textSpan) {
-    assert(textSpan.debugAssertIsValid());
-    int length = 0;
-    textSpan.visitTextSpan((TextSpan span) {
-      length += span.text.length;
-      return true;
-    });
-    return length;
-  }
-
-  /// Returns the text span that contains the given position in the text.
-  static TextSpan getSpanForPosition(TextSpan parent, int targetOffset) {
-    assert(parent.debugAssertIsValid());
-    int offset = 0;
-    TextSpan result;
-    parent.visitTextSpan((TextSpan span) {
-      assert(result == null);
-      final int endOffset = offset + span.text.length;
-      if (targetOffset >= offset && targetOffset <= endOffset) {
-        result = span;
-        return false;
-      }
-      offset = endOffset;
-      return true;
-    });
-    return result;
-  }
-
-  /// Return the offset of this child in plain text or -1 if the children list
-  /// is null or this [TextSpan] is not contained in this children list.
-  static int getOffsetInParent(TextSpan parent, TextSpan span) {
-    assert(parent.debugAssertIsValid());
-    if (parent.children == null || !parent.children.contains(span)) return -1;
-
-    int length = 0;
-    parent.visitTextSpan((TextSpan sibling) {
-      if (span != sibling) {
-        length += sibling.text.length;
-        return true;
-      } else
-        return false;
-    });
-    return length;
-  }
-
-  /// Return the max fontSize from a given [TextSpan] tree.
-  static double maxFontSize(TextSpan textSpan) {
-    textSpan.debugAssertIsValid();
-    double size = 0.0;
-    textSpan.visitTextSpan((TextSpan span) {
-      var currentSize = span.style?.fontSize ?? -1.0;
-      if (currentSize > size) size = currentSize;
-      return true;
-    });
-    return size;
-  }
-
-  /// Creates a copy of this [TextSpan] but with the given fields replaced with the new values.
-  static TextSpan copySpanWith(
-      {@required TextSpan base,
-      TextStyle style,
-      String text,
-      List<TextSpan> children,
-      GestureRecognizer recognizer}) {
-    return new TextSpan(
-        style: style ?? base.style,
-        text: text ?? base.text,
-        children: children ?? base.children,
-        recognizer: recognizer ?? base.recognizer);
-  }
-
-  static TextStyle copyStyleWith({
-    @required TextStyle base,
-    color,
-    String fontFamily,
-    fontSize,
-    fontWeight,
-    fontStyle,
-    letterSpacing,
-    wordSpacing,
-    textBaseline,
-    height,
-    decoration,
-    decorationColor,
-    decorationStyle,
-    package,
-  }) {
-    return new TextStyle(
-      color: color ?? base.color,
-      fontFamily: fontFamily ?? base.fontFamily,
-      fontSize: fontSize ?? base.fontSize,
-      fontWeight: fontWeight ?? base.fontWeight,
-      fontStyle: fontStyle ?? base.fontStyle,
-      letterSpacing: letterSpacing ?? base.letterSpacing,
-      wordSpacing: wordSpacing ?? base.wordSpacing,
-      textBaseline: textBaseline ?? base.textBaseline,
-      height: height ?? base.height,
-      decoration: decoration ?? base.decoration,
-      decorationColor: decorationColor ?? base.decorationColor,
-      decorationStyle: decorationStyle ?? base.decorationStyle,
-      package: package,
-    );
-  }
-
-  /// Returns a new text style that matches this text style but with some values
-  /// replaced by the non-null parameters of the given text style. This merge
-  /// take into consideration the [TextDecoration] values and combines them. If
-  /// the given text style is null, simply returns this text style.
-  ///
-  /// When [other] decoration is [TextDecoration.none], it overrides the base
-  /// decoration fully.
-  static TextStyle deepMerge(TextStyle base, TextStyle other) {
-    if (other == null) return base;
-    assert(other.inherit);
-
-    TextDecoration decoration;
-
-    if (other.decoration == null)
-      decoration = base.decoration;
-    else if (base.decoration == null || other.decoration == TextDecoration.none)
-      decoration = other.decoration;
-    else {
-      if (_getDecorationList(base.decoration).length >
-          _getDecorationList(other.decoration).length) {
-        decoration = other.decoration;
-      } else {
-        decoration = new TextDecoration.combine(
-            <TextDecoration>[base.decoration, other.decoration]);
-      }
-    }
-
-    return new TextStyle(
-      color: other.color ?? base.color,
-      fontFamily: other.fontFamily ?? base.fontFamily,
-      fontSize: other.fontSize ?? base.fontSize,
-      fontWeight: other.fontWeight ?? base.fontWeight,
-      fontStyle: other.fontStyle ?? base.fontStyle,
-      letterSpacing: other.letterSpacing ?? base.letterSpacing,
-      wordSpacing: other.wordSpacing ?? base.wordSpacing,
-      textBaseline: other.textBaseline ?? base.textBaseline,
-      height: other.height ?? base.height,
-      decoration: decoration,
-      decorationColor: other.decorationColor ?? base.decorationColor,
-      decorationStyle: other.decorationStyle ?? base.decorationStyle,
-    );
-  }
-
-  /// Return a List with all the decoration contained by the [TextDecoration].
-  static List<TextDecoration> _getDecorationList(TextDecoration decoration) {
-    final List<TextDecoration> decorationList = <TextDecoration>[];
-
-    if (decoration == null) {} else if (decoration == TextDecoration.none) {
-      decorationList.add(TextDecoration.none);
-    } else {
-      if (decoration.contains(TextDecoration.underline))
-        decorationList.add(TextDecoration.underline);
-      if (decoration.contains(TextDecoration.overline))
-        decorationList.add(TextDecoration.overline);
-      if (decoration.contains(TextDecoration.lineThrough))
-        decorationList.add(TextDecoration.lineThrough);
-    }
-
-    return decorationList;
-  }
-
-  /// Return a new TextStyle with the differences between the base style and the
-  /// provided style.
-  static TextStyle getDifferenceStyle(TextStyle base, TextStyle style) {
-    return new TextStyle(
-        color: base.color != style.color ? style.color : null,
-        fontFamily:
-            base.fontFamily != style.fontFamily ? style.fontFamily : null,
-        fontSize: base.fontSize != style.fontSize ? style.fontSize : null,
-        fontWeight:
-            base.fontWeight != style.fontWeight ? style.fontWeight : null,
-        fontStyle: base.fontStyle != style.fontStyle ? style.fontStyle : null,
-        letterSpacing: base.letterSpacing != style.letterSpacing
-            ? style.letterSpacing
-            : null,
-        wordSpacing:
-            base.wordSpacing != style.wordSpacing ? style.wordSpacing : null,
-        textBaseline:
-            base.textBaseline != style.textBaseline ? style.textBaseline : null,
-        height: base.height != style.height ? style.height : null,
-        decoration:
-            base.decoration != style.decoration ? style.decoration : null,
-        decorationColor: base.decorationColor != style.decorationColor
-            ? style.decorationColor
-            : null,
-        decorationStyle: base.decorationStyle != style.decorationStyle
-            ? style.decorationStyle
-            : null);
-  }
-
-  static TextStyle emptyStyle = const TextStyle();
-}
diff --git a/lib/ui/rich_editor/material/dropdown.dart b/lib/ui/rich_editor/material/dropdown.dart
deleted file mode 100644
index 51aad393..00000000
--- a/lib/ui/rich_editor/material/dropdown.dart
+++ /dev/null
@@ -1,666 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:math' as math;
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/widgets.dart';
-
-const Duration _kDropdownMenuDuration = const Duration(milliseconds: 300);
-const double _kMenuItemHeight = 48.0;
-const double _kDenseButtonHeight = 24.0;
-const EdgeInsets _kMenuHorizontalPadding =
-    const EdgeInsets.symmetric(horizontal: 16.0);
-
-class _DropdownMenuPainter extends CustomPainter {
-  _DropdownMenuPainter({
-    this.color,
-    this.elevation,
-    this.selectedIndex,
-    this.resize,
-  })
-      : _painter = new BoxDecoration(
-                // If you add an image here, you must provide a real
-                // configuration in the paint() function and you must provide some sort
-                // of onChanged callback here.
-                color: color,
-                borderRadius: new BorderRadius.circular(2.0),
-                boxShadow: kElevationToShadow[elevation])
-            .createBoxPainter(),
-        super(repaint: resize);
-
-  final Color color;
-  final int elevation;
-  final int selectedIndex;
-  final Animation<double> resize;
-
-  final BoxPainter _painter;
-
-  @override
-  void paint(Canvas canvas, Size size) {
-    final double selectedItemOffset =
-        selectedIndex * _kMenuItemHeight + kMaterialListPadding.top;
-    final Tween<double> top = new Tween<double>(
-      begin: selectedItemOffset.clamp(0.0, size.height - _kMenuItemHeight),
-      end: 0.0,
-    );
-
-    final Tween<double> bottom = new Tween<double>(
-      begin:
-          (top.begin + _kMenuItemHeight).clamp(_kMenuItemHeight, size.height),
-      end: size.height,
-    );
-
-    final Rect rect = new Rect.fromLTRB(
-        0.0, top.evaluate(resize), size.width, bottom.evaluate(resize));
-
-    _painter.paint(
-        canvas, rect.topLeft, new ImageConfiguration(size: rect.size));
-  }
-
-  @override
-  bool shouldRepaint(_DropdownMenuPainter oldPainter) {
-    return oldPainter.color != color ||
-        oldPainter.elevation != elevation ||
-        oldPainter.selectedIndex != selectedIndex ||
-        oldPainter.resize != resize;
-  }
-}
-
-// Do not use the platform-specific default scroll configuration.
-// Dropdown menus should never overscroll or display an overscroll indicator.
-class _DropdownScrollBehavior extends ScrollBehavior {
-  const _DropdownScrollBehavior();
-
-  @override
-  TargetPlatform getPlatform(BuildContext context) =>
-      Theme.of(context).platform;
-
-  @override
-  Widget buildViewportChrome(
-          BuildContext context, Widget child, AxisDirection axisDirection) =>
-      child;
-
-  @override
-  ScrollPhysics getScrollPhysics(BuildContext context) =>
-      const ClampingScrollPhysics();
-}
-
-class _DropdownMenu<T> extends StatefulWidget {
-  const _DropdownMenu({
-    Key key,
-    this.route,
-  })
-      : super(key: key);
-
-  final _DropdownRoute<T> route;
-
-  @override
-  _DropdownMenuState<T> createState() => new _DropdownMenuState<T>();
-}
-
-class _DropdownMenuState<T> extends State<_DropdownMenu<T>> {
-  CurvedAnimation _fadeOpacity;
-  CurvedAnimation _resize;
-
-  @override
-  void initState() {
-    super.initState();
-    // We need to hold these animations as state because of their curve
-    // direction. When the route's animation reverses, if we were to recreate
-    // the CurvedAnimation objects in build, we'd lose
-    // CurvedAnimation._curveDirection.
-    _fadeOpacity = new CurvedAnimation(
-      parent: widget.route.animation,
-      curve: const Interval(0.0, 0.25),
-      reverseCurve: const Interval(0.75, 1.0),
-    );
-    _resize = new CurvedAnimation(
-      parent: widget.route.animation,
-      curve: const Interval(0.25, 0.5),
-      reverseCurve: const Threshold(0.0),
-    );
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    // The menu is shown in three stages (unit timing in brackets):
-    // [0s - 0.25s] - Fade in a rect-sized menu container with the selected item.
-    // [0.25s - 0.5s] - Grow the otherwise empty menu container from the center
-    //   until it's big enough for as many items as we're going to show.
-    // [0.5s - 1.0s] Fade in the remaining visible items from top to bottom.
-    //
-    // When the menu is dismissed we just fade the entire thing out
-    // in the first 0.25s.
-    final _DropdownRoute<T> route = widget.route;
-    final double unit = 0.5 / (route.items.length + 1.5);
-    final List<Widget> children = <Widget>[];
-    for (int itemIndex = 0; itemIndex < route.items.length; ++itemIndex) {
-      CurvedAnimation opacity;
-      if (itemIndex == route.selectedIndex) {
-        opacity = new CurvedAnimation(
-            parent: route.animation, curve: const Threshold(0.0));
-      } else {
-        final double start = (0.5 + (itemIndex + 1) * unit).clamp(0.0, 1.0);
-        final double end = (start + 1.5 * unit).clamp(0.0, 1.0);
-        opacity = new CurvedAnimation(
-            parent: route.animation, curve: new Interval(start, end));
-      }
-      children.add(new FadeTransition(
-        opacity: opacity,
-        child: new InkWell(
-          child: new Container(
-            padding: _kMenuHorizontalPadding,
-            child: route.items[itemIndex],
-          ),
-          onTap: () => Navigator.pop(
-                context,
-                new _DropdownRouteResult<T>(route.items[itemIndex].value),
-              ),
-        ),
-      ));
-    }
-
-    return new FadeTransition(
-      opacity: _fadeOpacity,
-      child: new CustomPaint(
-        painter: new _DropdownMenuPainter(
-          color: Theme.of(context).canvasColor,
-          elevation: route.elevation,
-          selectedIndex: route.selectedIndex,
-          resize: _resize,
-        ),
-        child: new Material(
-          type: MaterialType.transparency,
-          textStyle: route.style,
-          child: new ScrollConfiguration(
-            behavior: const _DropdownScrollBehavior(),
-            child: new Scrollbar(
-              child: new ListView(
-                controller: widget.route.scrollController,
-                padding: kMaterialListPadding,
-                itemExtent: _kMenuItemHeight,
-                shrinkWrap: true,
-                children: children,
-              ),
-            ),
-          ),
-        ),
-      ),
-    );
-  }
-}
-
-class _DropdownMenuRouteLayout<T> extends SingleChildLayoutDelegate {
-  _DropdownMenuRouteLayout({this.buttonRect, this.menuTop, this.menuHeight});
-
-  final Rect buttonRect;
-  final double menuTop;
-  final double menuHeight;
-
-  @override
-  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
-    // The maximum height of a simple menu should be one or more rows less than
-    // the view height. This ensures a tappable area outside of the simple menu
-    // with which to dismiss the menu.
-    //   -- https://material.google.com/components/menus.html#menus-simple-menus
-    final double maxHeight =
-        math.max(0.0, constraints.maxHeight - 2 * _kMenuItemHeight);
-    // The width of a menu should be at most the view width. This ensures that
-    // the menu does not extend past the left and right edges of the screen.
-    final double width = math.min(constraints.maxWidth, buttonRect.width + 8.0);
-    return new BoxConstraints(
-      minWidth: width,
-      maxWidth: width,
-      minHeight: 0.0,
-      maxHeight: maxHeight,
-    );
-  }
-
-  @override
-  Offset getPositionForChild(Size size, Size childSize) {
-    assert(() {
-      final Rect container = Offset.zero & size;
-      if (container.intersect(buttonRect) == buttonRect) {
-        // If the button was entirely on-screen, then verify
-        // that the menu is also on-screen.
-        // If the button was a bit off-screen, then, oh well.
-        assert(menuTop >= 0.0);
-        assert(menuTop + menuHeight <= size.height);
-      }
-      return true;
-    }());
-    return new Offset(
-        buttonRect.left.clamp(0.0, size.width - childSize.width), menuTop);
-  }
-
-  @override
-  bool shouldRelayout(_DropdownMenuRouteLayout<T> oldDelegate) {
-    return buttonRect != oldDelegate.buttonRect ||
-        menuTop != oldDelegate.menuTop ||
-        menuHeight != oldDelegate.menuHeight;
-  }
-}
-
-// We box the return value so that the return value can be null. Otherwise,
-// canceling the route (which returns null) would get confused with actually
-// returning a real null value.
-class _DropdownRouteResult<T> {
-  const _DropdownRouteResult(this.result);
-
-  final T result;
-
-  @override
-  bool operator ==(dynamic other) {
-    if (other is! _DropdownRouteResult<T>) return false;
-    final _DropdownRouteResult<T> typedOther = other;
-    return result == typedOther.result;
-  }
-
-  @override
-  int get hashCode => result.hashCode;
-}
-
-class _DropdownRoute<T> extends PopupRoute<_DropdownRouteResult<T>> {
-  _DropdownRoute({
-    this.items,
-    this.buttonRect,
-    this.selectedIndex,
-    this.elevation: 8,
-    this.theme,
-    @required this.style,
-    this.barrierLabel,
-  })
-      : assert(style != null);
-
-  final List<DropdownMenuItem<T>> items;
-  final Rect buttonRect;
-  final int selectedIndex;
-  final int elevation;
-  final ThemeData theme;
-  final TextStyle style;
-
-  ScrollController scrollController;
-
-  @override
-  Duration get transitionDuration => _kDropdownMenuDuration;
-
-  @override
-  bool get barrierDismissible => true;
-
-  @override
-  Color get barrierColor => null;
-
-  @override
-  final String barrierLabel;
-
-  @override
-  Widget buildPage(BuildContext context, Animation<double> animation,
-      Animation<double> secondaryAnimation) {
-    final double screenHeight = MediaQuery.of(context).size.height;
-    final double maxMenuHeight = screenHeight - 2.0 * _kMenuItemHeight;
-    final double preferredMenuHeight =
-        (items.length * _kMenuItemHeight) + kMaterialListPadding.vertical;
-    final double menuHeight = math.min(maxMenuHeight, preferredMenuHeight);
-
-    final double buttonTop = buttonRect.top;
-    final double selectedItemOffset =
-        selectedIndex * _kMenuItemHeight + kMaterialListPadding.top;
-    double menuTop = (buttonTop - selectedItemOffset) -
-        (_kMenuItemHeight - buttonRect.height) / 2.0;
-    final double topPreferredLimit = _kMenuItemHeight;
-    if (menuTop < topPreferredLimit)
-      menuTop = math.min(buttonTop, topPreferredLimit);
-    double bottom = menuTop + menuHeight;
-    final double bottomPreferredLimit = screenHeight - _kMenuItemHeight;
-    if (bottom > bottomPreferredLimit) {
-      bottom = math.max(buttonTop + _kMenuItemHeight, bottomPreferredLimit);
-      menuTop = bottom - menuHeight;
-    }
-
-    if (scrollController == null) {
-      double scrollOffset = 0.0;
-      if (preferredMenuHeight > maxMenuHeight)
-        scrollOffset = selectedItemOffset - (buttonTop - menuTop);
-      scrollController =
-          new ScrollController(initialScrollOffset: scrollOffset);
-    }
-
-    Widget menu = new _DropdownMenu<T>(route: this);
-    if (theme != null) menu = new Theme(data: theme, child: menu);
-
-    return new CustomSingleChildLayout(
-      delegate: new _DropdownMenuRouteLayout<T>(
-        buttonRect: buttonRect,
-        menuTop: menuTop,
-        menuHeight: menuHeight,
-      ),
-      child: menu,
-    );
-  }
-
-  void _dismiss() {
-    navigator?.removeRoute(this);
-  }
-}
-
-/// An item in a menu created by a [DropdownButton].
-///
-/// The type `T` is the type of the value the entry represents. All the entries
-/// in a given menu must represent values with consistent types.
-class DropdownMenuItem<T> extends StatelessWidget {
-  /// Creates an item for a dropdown menu.
-  ///
-  /// The [child] argument is required.
-  const DropdownMenuItem({
-    Key key,
-    this.value,
-    @required this.child,
-  })
-      : assert(child != null),
-        super(key: key);
-
-  /// The widget below this widget in the tree.
-  ///
-  /// Typically a [Text] widget.
-  final Widget child;
-
-  /// The value to return if the user selects this menu item.
-  ///
-  /// Eventually returned in a call to [DropdownButton.onChanged].
-  final T value;
-
-  @override
-  Widget build(BuildContext context) {
-    return new Container(
-      height: _kMenuItemHeight,
-      alignment: Alignment.centerLeft,
-      child: child,
-    );
-  }
-}
-
-/// An inherited widget that causes any descendant [DropdownButton]
-/// widgets to not include their regular underline.
-///
-/// This is used by [DataTable] to remove the underline from any
-/// [DropdownButton] widgets placed within material data tables, as
-/// required by the material design specification.
-class DropdownButtonHideUnderline extends InheritedWidget {
-  /// Creates a [DropdownButtonHideUnderline]. A non-null [child] must
-  /// be given.
-  const DropdownButtonHideUnderline({
-    Key key,
-    @required Widget child,
-  })
-      : assert(child != null),
-        super(key: key, child: child);
-
-  /// Returns whether the underline of [DropdownButton] widgets should
-  /// be hidden.
-  static bool at(BuildContext context) {
-    return context.inheritFromWidgetOfExactType(DropdownButtonHideUnderline) !=
-        null;
-  }
-
-  @override
-  bool updateShouldNotify(DropdownButtonHideUnderline old) => false;
-}
-
-/// A material design button for selecting from a list of items.
-///
-/// A dropdown button lets the user select from a number of items. The button
-/// shows the currently selected item as well as an arrow that opens a menu for
-/// selecting another item.
-///
-/// The type `T` is the type of the values the dropdown menu represents. All the
-/// entries in a given menu must represent values with consistent types.
-/// Typically, an enum is used. Each [DropdownMenuItem] in [items] must be
-/// specialized with that same type argument.
-///
-/// Requires one of its ancestors to be a [Material] widget.
-///
-/// See also:
-///
-///  * [DropdownMenuItem], the class used to represent the [items].
-///  * [DropdownButtonHideUnderline], which prevents its descendant dropdown buttons
-///    from displaying their underlines.
-///  * [RaisedButton], [FlatButton], ordinary buttons that trigger a single action.
-///  * <https://material.google.com/components/buttons.html#buttons-dropdown-buttons>
-class DropdownButton<T> extends StatefulWidget {
-  /// Creates a dropdown button.
-  ///
-  /// The [items] must have distinct values and if [value] isn't null it must be among them.
-  ///
-  /// The [elevation] and [iconSize] arguments must not be null (they both have
-  /// defaults, so do not need to be specified).
-  DropdownButton({
-    Key key,
-    @required this.items,
-    this.value,
-    this.hint,
-    @required this.onChanged,
-    this.onTap,
-    this.elevation: 8,
-    this.style,
-    this.iconSize: 24.0,
-    this.isDense: false,
-  })
-      : assert(items != null),
-        assert(value == null ||
-            items
-                    .where((DropdownMenuItem<T> item) => item.value == value)
-                    .length ==
-                1),
-        super(key: key);
-
-  /// The list of possible items to select among.
-  final List<DropdownMenuItem<T>> items;
-
-  /// The currently selected item, or null if no item has been selected. If
-  /// value is null then the menu is popped up as if the first item was
-  /// selected.
-  final T value;
-
-  /// Displayed if [value] is null.
-  final Widget hint;
-
-  /// Called when the user selects an item.
-  final ValueChanged<T> onChanged;
-
-  /// Called when the user start and finishes the interaction with the menu.
-  final ValueChanged<OnTapState> onTap;
-
-  /// The z-coordinate at which to place the menu when open.
-  ///
-  /// The following elevations have defined shadows: 1, 2, 3, 4, 6, 8, 9, 12, 16, 24
-  ///
-  /// Defaults to 8, the appropriate elevation for dropdown buttons.
-  final int elevation;
-
-  /// The text style to use for text in the dropdown button and the dropdown
-  /// menu that appears when you tap the button.
-  ///
-  /// Defaults to the [TextTheme.subhead] value of the current
-  /// [ThemeData.textTheme] of the current [Theme].
-  final TextStyle style;
-
-  /// The size to use for the drop-down button's down arrow icon button.
-  ///
-  /// Defaults to 24.0.
-  final double iconSize;
-
-  /// Reduce the button's height.
-  ///
-  /// By default this button's height is the same as its menu items' heights.
-  /// If isDense is true, the button's height is reduced by about half. This
-  /// can be useful when the button is embedded in a container that adds
-  /// its own decorations, like [InputDecorator].
-  final bool isDense;
-
-  @override
-  _DropdownButtonState<T> createState() => new _DropdownButtonState<T>();
-}
-
-class _DropdownButtonState<T> extends State<DropdownButton<T>>
-    with WidgetsBindingObserver {
-  int _selectedIndex;
-  _DropdownRoute<T> _dropdownRoute;
-
-  @override
-  void initState() {
-    super.initState();
-    _updateSelectedIndex();
-    WidgetsBinding.instance.addObserver(this);
-  }
-
-  @override
-  void dispose() {
-    WidgetsBinding.instance.removeObserver(this);
-    _removeDropdownRoute();
-    super.dispose();
-  }
-
-  // Typically called because the device's orientation has changed.
-  // Defined by WidgetsBindingObserver
-  @override
-  void didChangeMetrics() {
-    _removeDropdownRoute();
-  }
-
-  void _removeDropdownRoute() {
-    _dropdownRoute?._dismiss();
-    _dropdownRoute = null;
-  }
-
-  @override
-  void didUpdateWidget(DropdownButton<T> oldWidget) {
-    super.didUpdateWidget(oldWidget);
-    _updateSelectedIndex();
-  }
-
-  void _updateSelectedIndex() {
-    assert(widget.value == null ||
-        widget.items
-                .where((DropdownMenuItem<T> item) => item.value == widget.value)
-                .length ==
-            1);
-    _selectedIndex = null;
-    for (int itemIndex = 0; itemIndex < widget.items.length; itemIndex++) {
-      if (widget.items[itemIndex].value == widget.value) {
-        _selectedIndex = itemIndex;
-        return;
-      }
-    }
-  }
-
-  TextStyle get _textStyle =>
-      widget.style ?? Theme.of(context).textTheme.subhead;
-
-  void _handleTap() {
-    if (widget.onTap != null) widget.onTap(OnTapState.START);
-    final RenderBox itemBox = context.findRenderObject();
-    final Rect itemRect = itemBox.localToGlobal(Offset.zero) & itemBox.size;
-
-    assert(_dropdownRoute == null);
-    _dropdownRoute = new _DropdownRoute<T>(
-      items: widget.items,
-      buttonRect: _kMenuHorizontalPadding.inflateRect(itemRect),
-      selectedIndex: _selectedIndex ?? 0,
-      elevation: widget.elevation,
-      theme: Theme.of(context, shadowThemeOnly: true),
-      style: _textStyle,
-    );
-
-    Navigator
-        .push(context, _dropdownRoute)
-        .then<Null>((_DropdownRouteResult<T> newValue) {
-      _dropdownRoute = null;
-      if (!mounted || newValue == null) return null;
-      if (widget.onTap != null) widget.onTap(OnTapState.END);
-      if (widget.onChanged != null) widget.onChanged(newValue.result);
-    });
-  }
-
-  // When isDense is true, reduce the height of this button from _kMenuItemHeight to
-  // _kDenseButtonHeight, but don't make it smaller than the text that it contains.
-  // Similarly, we don't reduce the height of the button so much that its icon
-  // would be clipped.
-  double get _denseButtonHeight {
-    return math.max(
-        _textStyle.fontSize, math.max(widget.iconSize, _kDenseButtonHeight));
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    assert(debugCheckHasMaterial(context));
-
-    // The width of the button and the menu are defined by the widest
-    // item and the width of the hint.
-    final List<Widget> items = new List<Widget>.from(widget.items);
-    int hintIndex;
-    if (widget.hint != null) {
-      hintIndex = items.length;
-      items.add(new DefaultTextStyle(
-        style: _textStyle.copyWith(color: Theme.of(context).hintColor),
-        child: new IgnorePointer(
-          child: widget.hint,
-        ),
-      ));
-    }
-
-    Widget result = new DefaultTextStyle(
-      style: _textStyle,
-      child: new SizedBox(
-        height: widget.isDense ? _denseButtonHeight : null,
-        child: new Row(
-          mainAxisAlignment: MainAxisAlignment.spaceBetween,
-          mainAxisSize: MainAxisSize.min,
-          children: <Widget>[
-            // If value is null (then _selectedIndex is null) then we display
-            // the hint or nothing at all.
-            new IndexedStack(
-              index: _selectedIndex ?? hintIndex,
-              alignment: Alignment.centerLeft,
-              children: items,
-            ),
-            new Icon(Icons.arrow_drop_down,
-                size: widget.iconSize,
-                // These colors are not defined in the Material Design spec.
-                color: Theme.of(context).brightness == Brightness.light
-                    ? Colors.grey.shade700
-                    : Colors.white70),
-          ],
-        ),
-      ),
-    );
-
-    if (!DropdownButtonHideUnderline.at(context)) {
-      final double bottom = widget.isDense ? 0.0 : 8.0;
-      result = new Stack(
-        children: <Widget>[
-          result,
-          new Positioned(
-            left: 0.0,
-            right: 0.0,
-            bottom: bottom,
-            child: new Container(
-              height: 1.0,
-              decoration: const BoxDecoration(
-                  border: const Border(
-                      bottom: const BorderSide(
-                          color: const Color(0xFFBDBDBD), width: 0.0))),
-            ),
-          ),
-        ],
-      );
-    }
-
-    return new GestureDetector(
-        onTap: _handleTap, behavior: HitTestBehavior.opaque, child: result);
-  }
-}
-
-enum OnTapState { START, END }
diff --git a/lib/ui/rich_editor/material/rich_text_field.dart b/lib/ui/rich_editor/material/rich_text_field.dart
deleted file mode 100644
index bc848691..00000000
--- a/lib/ui/rich_editor/material/rich_text_field.dart
+++ /dev/null
@@ -1,311 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'package:flutter/cupertino.dart' hide cupertinoTextSelectionControls;
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart' hide materialTextSelectionControls;
-import 'package:flutter/services.dart';
-import 'package:flutter/widgets.dart';
-import 'package:kalium_wallet_flutter/colors.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/cupertino/text_selection.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/material/text_selection.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/rich_editable_text.dart';
-
-export 'package:flutter/services.dart' show TextInputType;
-
-const Duration _kTransitionDuration = const Duration(milliseconds: 200);
-const Curve _kTransitionCurve = Curves.fastOutSlowIn;
-
-/// A material design text field.
-///
-/// A text field lets the user enter text, either with hardware keyboard or with
-/// an onscreen keyboard.
-///
-/// The text field calls the [onChanged] callback whenever the user changes the
-/// text in the field. If the user indicates that they are done typing in the
-/// field (e.g., by pressing a button on the soft keyboard), the text field
-/// calls the [onSubmitted] callback.
-///
-/// To control the text that is displayed in the text field, use the
-/// [controller]. For example, to set the initial value of the text field, use
-/// a [controller] that already contains some text. The [controller] can also
-/// control the selection and composing region (and to observe changes to the
-/// text, selection, and composing region).
-///
-/// By default, a text field has a [decoration] that draws a divider below the
-/// text field. You can use the [decoration] property to control the decoration,
-/// for example by adding a label or an icon. If you set the [decoration]
-/// property to null, the decoration will be removed entirely, including the
-/// extra padding introduced by the decoration to save space for the labels.
-///
-/// If [decoration] is non-null (which is the default), the text field requires
-/// one of its ancestors to be a [Material] widget.
-///
-/// To integrate the [RichTextField] into a [Form] with other [FormField] widgets,
-/// consider using [TextFormField].
-///
-/// See also:
-///
-///  * <https://material.google.com/components/text-fields.html>
-///  * [TextFormField], which integrates with the [Form] widget.
-///  * [InputDecorator], which shows the labels and other visual elements that
-///    surround the actual text editing widget.
-///  * [EditableText], which is the raw text editing control at the heart of a
-///    [TextField]. (The [EditableText] widget is rarely used directly unless
-///    you are implementing an entirely different design language, such as
-///    Cupertino.)
-class RichTextField extends StatefulWidget {
-  /// Creates a Material Design text field.
-  ///
-  /// If [decoration] is non-null (which is the default), the text field requires
-  /// one of its ancestors to be a [Material] widget.
-  ///
-  /// To remove the decoration entirely (including the extra padding introduced
-  /// by the decoration to save space for the labels), set the [decoration] to
-  /// null.
-  ///
-  /// The [maxLines] property can be set to null to remove the restriction on
-  /// the number of lines. By default, it is one, meaning this is a single-line
-  /// text field. [maxLines] must not be zero. If [maxLines] is not one, then
-  /// [keyboardType] is ignored, and the [TextInputType.multiline] keyboard type
-  /// is used.
-  ///
-  /// The [keyboardType], [textAlign], [autofocus], and
-  /// [autocorrect] arguments must not be null.
-  const RichTextField({
-    Key key,
-    this.controller,
-    this.styleController,
-    this.focusNode,
-    this.decoration: const InputDecoration(),
-    TextInputType keyboardType: TextInputType.text,
-    this.style,
-    this.textAlign: TextAlign.start,
-    this.autofocus: false,
-    this.autocorrect: true,
-    this.maxLines: 1,
-    this.onChanged,
-    this.onSubmitted,
-  })
-      : assert(keyboardType != null),
-        assert(textAlign != null),
-        assert(autofocus != null),
-        assert(autocorrect != null),
-        assert(maxLines == null || maxLines > 0),
-        keyboardType = maxLines == 1 ? keyboardType : TextInputType.multiline,
-        super(key: key);
-
-  /// Controls the text being edited.
-  ///
-  /// If null, this widget will create its own [TextEditingController].
-  final RichTextEditingController controller;
-
-  /// Control the style of the [RichTextField] as the user types.
-  ///
-  /// If null the [RichTextField] will act as a normal [TextField].
-  final StyleController styleController;
-
-  /// Controls whether this widget has keyboard focus.
-  ///
-  /// If null, this widget will create its own [FocusNode].
-  final FocusNode focusNode;
-
-  /// The decoration to show around the text field.
-  ///
-  /// By default, draws a horizontal line under the text field but can be
-  /// configured to show an icon, label, hint text, and error text.
-  ///
-  /// Set this field to null to remove the decoration entirely (including the
-  /// extra padding introduced by the decoration to save space for the labels).
-  final InputDecoration decoration;
-
-  /// The type of keyboard to use for editing the text.
-  ///
-  /// Defaults to [TextInputType.text]. Must not be null. If
-  /// [maxLines] is not one, then [keyboardType] is ignored, and the
-  /// [TextInputType.multiline] keyboard type is used.
-  final TextInputType keyboardType;
-
-  /// The style to use for the text being edited.
-  ///
-  /// This text style is also used as the base style for the [decoration].
-  ///
-  /// If null, defaults to a text style from the current [Theme].
-  final TextStyle style;
-
-  /// How the text being edited should be aligned horizontally.
-  ///
-  /// Defaults to [TextAlign.start].
-  final TextAlign textAlign;
-
-  /// Whether this text field should focus itself if nothing else is already
-  /// focused.
-  ///
-  /// If true, the keyboard will open as soon as this text field obtains focus.
-  /// Otherwise, the keyboard is only shown after the user taps the text field.
-  ///
-  /// Defaults to false. Cannot be null.
-  // See https://github.com/flutter/flutter/issues/7035 for the rationale for this
-  // keyboard behavior.
-  final bool autofocus;
-
-  /// Whether to enable autocorrection.
-  ///
-  /// Defaults to true. Cannot be null.
-  final bool autocorrect;
-
-  /// The maximum number of lines for the text to span, wrapping if necessary.
-  ///
-  /// If this is 1 (the default), the text will not wrap, but will scroll
-  /// horizontally instead.
-  ///
-  /// If this is null, there is no limit to the number of lines. If it is not
-  /// null, the value must be greater than zero.
-  final int maxLines;
-
-  /// Called when the text being edited changes.
-  final ValueChanged<String> onChanged;
-
-  /// Called when the user indicates that they are done editing the text in the
-  /// field.
-  final ValueChanged<String> onSubmitted;
-
-  void setNewStyle(TextStyle textStyle) {}
-
-  @override
-  RichTextFieldState createState() => new RichTextFieldState();
-
-  @override
-  void debugFillProperties(DiagnosticPropertiesBuilder description) {
-    super.debugFillProperties(description);
-    description.add(new DiagnosticsProperty<RichTextEditingController>(
-        'controller', controller,
-        defaultValue: null));
-    description.add(new DiagnosticsProperty<FocusNode>('focusNode', focusNode,
-        defaultValue: null));
-    description.add(
-        new DiagnosticsProperty<InputDecoration>('decoration', decoration));
-    description.add(new EnumProperty<TextInputType>(
-        'keyboardType', keyboardType,
-        defaultValue: TextInputType.text));
-    description.add(
-        new DiagnosticsProperty<TextStyle>('style', style, defaultValue: null));
-    description.add(new DiagnosticsProperty<bool>('autofocus', autofocus,
-        defaultValue: false));
-    description.add(new DiagnosticsProperty<bool>('autocorrect', autocorrect,
-        defaultValue: false));
-    description.add(new IntProperty('maxLines', maxLines, defaultValue: 1));
-  }
-}
-
-class RichTextFieldState extends State<RichTextField> {
-  final GlobalKey<RichEditableTextState> _editableTextKey =
-      new GlobalKey<RichEditableTextState>();
-
-  RichTextEditingController _controller;
-
-  RichTextEditingController get _effectiveController =>
-      widget.controller ?? _controller;
-
-  FocusNode _focusNode;
-
-  FocusNode get _effectiveFocusNode =>
-      widget.focusNode ?? (_focusNode ??= new FocusNode());
-
-  @override
-  void initState() {
-    super.initState();
-    if (widget.controller == null)
-      _controller = new RichTextEditingController();
-  }
-
-  @override
-  void didUpdateWidget(RichTextField oldWidget) {
-    super.didUpdateWidget(oldWidget);
-    if (widget.controller == null && oldWidget.controller != null)
-      _controller =
-          new RichTextEditingController.fromValue(oldWidget.controller.value);
-    else if (widget.controller != null && oldWidget.controller == null)
-      _controller = null;
-  }
-
-  @override
-  void dispose() {
-    _focusNode?.dispose();
-    super.dispose();
-  }
-
-  void _requestKeyboard() {
-    _editableTextKey.currentState?.requestKeyboard();
-  }
-
-  void prepareForFocusLoss({bool closeKeyboardIfNeeded = false}) {
-    _editableTextKey.currentState?.saveValueBeforeFocusLoss = true;
-    _editableTextKey.currentState?.closeKeyboardIfNeeded = closeKeyboardIfNeeded;
-  }
-
-  void restoreFocus() {
-    _editableTextKey.currentState?.requestFocus();
-  }
-
-  void _onSelectionChanged(
-      BuildContext context, TextSelection selection, bool longPress) {
-    if (longPress) Feedback.forLongPress(context);
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final ThemeData themeData = Theme.of(context);
-    final TextStyle style = widget.style ?? themeData.textTheme.body1;
-    final RichTextEditingController controller = _effectiveController;
-    final FocusNode focusNode = _effectiveFocusNode;
-
-    Widget child = new RepaintBoundary(
-      child: new RichEditableText(
-          key: _editableTextKey,
-          controller: controller,
-          styleController: widget.styleController,
-          focusNode: focusNode,
-          keyboardType: widget.keyboardType,
-          style: style,
-          textAlign: widget.textAlign,
-          autofocus: widget.autofocus,
-          autocorrect: widget.autocorrect,
-          maxLines: widget.maxLines,
-          cursorColor: KaliumColors.primary,
-          selectionColor: themeData.textSelectionColor,
-          selectionControls: themeData.platform == TargetPlatform.iOS
-              ? cupertinoTextSelectionControls
-              : materialTextSelectionControls,
-          onChanged: widget.onChanged,
-          onSubmitted: widget.onSubmitted,
-          onSelectionChanged: (TextSelection selection, bool longPress) =>
-              _onSelectionChanged(context, selection, longPress)),
-    );
-
-    if (widget.decoration != null) {
-      child = new AnimatedBuilder(
-        animation: new Listenable.merge(<Listenable>[focusNode, controller]),
-        builder: (BuildContext context, Widget child) {
-          return new InputDecorator(
-            decoration: widget.decoration,
-            baseStyle: widget.style,
-            textAlign: widget.textAlign,
-            isFocused: focusNode.hasFocus,
-            isEmpty: Extensions.isEmpty(controller.value.value),
-            child: child,
-          );
-        },
-        child: child,
-      );
-    }
-
-    return new GestureDetector(
-      behavior: HitTestBehavior.opaque,
-      onTap: _requestKeyboard,
-      child: child,
-    );
-  }
-}
diff --git a/lib/ui/rich_editor/material/text_selection.dart b/lib/ui/rich_editor/material/text_selection.dart
deleted file mode 100644
index f5e61457..00000000
--- a/lib/ui/rich_editor/material/text_selection.dart
+++ /dev/null
@@ -1,202 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:math' as math;
-
-import 'package:flutter/material.dart'
-    hide TextSelectionDelegate, TextSelectionControls, TextSelectionHandleType;
-import 'package:flutter/rendering.dart';
-import 'package:flutter/widgets.dart'
-    hide TextSelectionDelegate, TextSelectionControls, TextSelectionHandleType;
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/text_input.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/text_selection.dart';
-
-const double _kHandleSize = 22.0;
-// Minimal padding from all edges of the selection toolbar to all edges of the
-// viewport.
-const double _kToolbarScreenPadding = 8.0;
-
-/// Manages a copy/paste text selection toolbar.
-class _TextSelectionToolbar extends StatelessWidget {
-  const _TextSelectionToolbar({
-    Key key,
-    this.delegate,
-    this.handleCut,
-    this.handleCopy,
-    this.handlePaste,
-    this.handleSelectAll,
-  })
-      : super(key: key);
-
-  final TextSelectionDelegate delegate;
-
-  AbstractTextEditingValue get value => delegate.textEditingValue;
-
-  final VoidCallback handleCut;
-  final VoidCallback handleCopy;
-  final VoidCallback handlePaste;
-  final VoidCallback handleSelectAll;
-
-  @override
-  Widget build(BuildContext context) {
-    final List<Widget> items = <Widget>[];
-    final MaterialLocalizations localizations =
-        MaterialLocalizations.of(context);
-
-    if (!value.selection.isCollapsed) {
-      items.add(new FlatButton(
-          child: new Text(localizations.cutButtonLabel), onPressed: handleCut));
-      items.add(new FlatButton(
-          child: new Text(localizations.copyButtonLabel),
-          onPressed: handleCopy));
-    }
-    items.add(new FlatButton(
-      child: new Text(localizations.pasteButtonLabel),
-      // TODO(https://github.com/flutter/flutter/issues/11254):
-      // This should probably be grayed-out if there is nothing to paste.
-      onPressed: handlePaste,
-    ));
-    if (value.isNotEmpty) {
-      if (value.selection.isCollapsed)
-        items.add(new FlatButton(
-            child: new Text(localizations.selectAllButtonLabel),
-            onPressed: handleSelectAll));
-    }
-
-    return new Material(
-        elevation: 1.0,
-        child: new Container(
-            height: 44.0,
-            child: new Row(mainAxisSize: MainAxisSize.min, children: items)));
-  }
-}
-
-/// Centers the toolbar around the given position, ensuring that it remains on
-/// screen.
-class _TextSelectionToolbarLayout extends SingleChildLayoutDelegate {
-  _TextSelectionToolbarLayout(
-      this.screenSize, this.globalEditableRegion, this.position);
-
-  /// The size of the screen at the time that the toolbar was last laid out.
-  final Size screenSize;
-
-  /// Size and position of the editing region at the time the toolbar was last
-  /// laid out, in global coordinates.
-  final Rect globalEditableRegion;
-
-  /// Anchor position of the toolbar, relative to the top left of the
-  /// [globalEditableRegion].
-  final Offset position;
-
-  @override
-  BoxConstraints getConstraintsForChild(BoxConstraints constraints) {
-    return constraints.loosen();
-  }
-
-  @override
-  Offset getPositionForChild(Size size, Size childSize) {
-    final Offset globalPosition = globalEditableRegion.topLeft + position;
-
-    double x = globalPosition.dx - childSize.width / 2.0;
-    double y = globalPosition.dy - childSize.height;
-
-    if (x < _kToolbarScreenPadding)
-      x = _kToolbarScreenPadding;
-    else if (x + childSize.width > screenSize.width - _kToolbarScreenPadding)
-      x = screenSize.width - childSize.width - _kToolbarScreenPadding;
-
-    if (y < _kToolbarScreenPadding)
-      y = _kToolbarScreenPadding;
-    else if (y + childSize.height > screenSize.height - _kToolbarScreenPadding)
-      y = screenSize.height - childSize.height - _kToolbarScreenPadding;
-
-    return new Offset(x, y);
-  }
-
-  @override
-  bool shouldRelayout(_TextSelectionToolbarLayout oldDelegate) {
-    return position != oldDelegate.position;
-  }
-}
-
-/// Draws a single text selection handle. The [type] determines where the handle
-/// points (e.g. the [left] handle points up and to the right).
-class _TextSelectionHandlePainter extends CustomPainter {
-  _TextSelectionHandlePainter({this.color});
-
-  final Color color;
-
-  @override
-  void paint(Canvas canvas, Size size) {
-    final Paint paint = new Paint()..color = color;
-    final double radius = size.width / 2.0;
-    canvas.drawCircle(new Offset(radius, radius), radius, paint);
-    canvas.drawRect(new Rect.fromLTWH(0.0, 0.0, radius, radius), paint);
-  }
-
-  @override
-  bool shouldRepaint(_TextSelectionHandlePainter oldPainter) {
-    return color != oldPainter.color;
-  }
-}
-
-class _MaterialTextSelectionControls extends TextSelectionControls {
-  @override
-  Size handleSize = const Size(_kHandleSize, _kHandleSize);
-
-  /// Builder for material-style copy/paste text selection toolbar.
-  @override
-  Widget buildToolbar(BuildContext context, Rect globalEditableRegion,
-      Offset position, TextSelectionDelegate delegate) {
-    assert(debugCheckHasMediaQuery(context));
-    return new ConstrainedBox(
-        constraints: new BoxConstraints.tight(globalEditableRegion.size),
-        child: new CustomSingleChildLayout(
-          delegate: new _TextSelectionToolbarLayout(
-            MediaQuery.of(context).size,
-            globalEditableRegion,
-            position,
-          ),
-          child: new _TextSelectionToolbar(
-            delegate: delegate,
-            handleCut: () => handleCut(delegate),
-            handleCopy: () => handleCopy(delegate),
-            handlePaste: () => handlePaste(delegate),
-            handleSelectAll: () => handleSelectAll(delegate),
-          ),
-        ));
-  }
-
-  /// Builder for material-style text selection handles.
-  @override
-  Widget buildHandle(
-      BuildContext context, TextSelectionHandleType type, double textHeight) {
-    final Widget handle = new SizedBox(
-        width: _kHandleSize,
-        height: _kHandleSize,
-        child: new CustomPaint(
-            painter: new _TextSelectionHandlePainter(
-                color: Theme.of(context).textSelectionHandleColor)));
-
-    // [handle] is a circle, with a rectangle in the top left quadrant of that
-    // circle (an onion pointing to 10:30). We rotate [handle] to point
-    // straight up or up-right depending on the handle type.
-    switch (type) {
-      case TextSelectionHandleType.left: // points up-right
-        return new Transform(
-            transform: new Matrix4.rotationZ(math.pi / 2.0), child: handle);
-      case TextSelectionHandleType.right: // points up-left
-        return handle;
-      case TextSelectionHandleType.collapsed: // points up
-        return new Transform(
-            transform: new Matrix4.rotationZ(math.pi / 4.0), child: handle);
-    }
-    assert(type != null);
-    return null;
-  }
-}
-
-/// Text selection controls that follow the Material Design specification.
-final TextSelectionControls materialTextSelectionControls =
-    new _MaterialTextSelectionControls();
diff --git a/lib/ui/rich_editor/rendering/rich_editable.dart b/lib/ui/rich_editor/rendering/rich_editable.dart
deleted file mode 100644
index ec691aa1..00000000
--- a/lib/ui/rich_editor/rendering/rich_editable.dart
+++ /dev/null
@@ -1,657 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:math' as math;
-import 'dart:ui' as ui show TextBox;
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/gestures.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/rendering.dart';
-import 'package:flutter/services.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-
-const double _kCaretGap = 1.0; // pixels
-const double _kCaretHeightOffset = 2.0; // pixels
-const double _kCaretWidth = 1.0; // pixels
-
-final String _kZeroWidthSpace = new String.fromCharCode(0x200B);
-
-/// Signature for the callback that reports when the user changes the selection
-/// (including the cursor location).
-///
-/// Used by [RenderRichEditable.onSelectionChanged].
-typedef void SelectionChangedHandler(
-    TextSelection selection, RenderRichEditable renderObject, bool longPress);
-
-/// Signature for the callback that reports when the caret location changes.
-///
-/// Used by [RenderRichEditable.onCaretChanged].
-typedef void CaretChangedHandler(Rect caretRect);
-
-/// Represents the coordinates of the point in a selection, and the text
-/// direction at that point, relative to top left of the [RenderRichEditable] that
-/// holds the selection.
-@immutable
-class TextSelectionPoint {
-  /// Creates a description of a point in a text selection.
-  ///
-  /// The [point] argument must not be null.
-  const TextSelectionPoint(this.point, this.direction) : assert(point != null);
-
-  /// Coordinates of the lower left or lower right corner of the selection,
-  /// relative to the top left of the [RenderRichEditable] object.
-  final Offset point;
-
-  /// Direction of the text at this edge of the selection.
-  final TextDirection direction;
-
-  @override
-  String toString() {
-    switch (direction) {
-      case TextDirection.ltr:
-        return '$point-ltr';
-      case TextDirection.rtl:
-        return '$point-rtl';
-    }
-    return '$point';
-  }
-}
-
-/// Displays some text in a scrollable container with a potentially blinking
-/// cursor and with gesture recognizers.
-///
-/// This is the renderer for an editable text field. It does not directly
-/// provide affordances for editing the text, but it does handle text selection
-/// and manipulation of the text cursor.
-///
-/// The [text] is displayed, scrolled by the given [offset], aligned according
-/// to [textAlign]. The [maxLines] property controls whether the text displays
-/// on one line or many. The [selection], if it is not collapsed, is painted in
-/// the [selectionColor]. If it _is_ collapsed, then it represents the cursor
-/// position. The cursor is shown while [showCursor] is true. It is painted in
-/// the [cursorColor].
-///
-/// If, when the render object paints, the caret is found to have changed
-/// location, [onCaretChanged] is called.
-///
-/// The user may interact with the render object by tapping or long-pressing.
-/// When the user does so, the selection is updated, and [onSelectionChanged] is
-/// called.
-///
-/// Keyboard handling, IME handling, scrolling, toggling the [showCursor] value
-/// to actually blink the cursor, and other features not mentioned above are the
-/// responsibility of higher layers and not handled by this object.
-class RenderRichEditable extends RenderBox {
-  /// Creates a render object that implements the visual aspects of a text field.
-  ///
-  /// The [textAlign] argument must not be null. It defaults to [TextAlign.start].
-  ///
-  /// The [textDirection] argument must not be null.
-  ///
-  /// If [showCursor] is not specified, then it defaults to hiding the cursor.
-  ///
-  /// The [maxLines] property can be set to null to remove the restriction on
-  /// the number of lines. By default, it is 1, meaning this is a single-line
-  /// text field. If it is not null, it must be greater than zero.
-  ///
-  /// The [offset] is required and must not be null. You can use [new
-  /// ViewportOffset.zero] if you have no need for scrolling.
-  RenderRichEditable({
-    TextSpan text,
-    TextStyle currentStyle,
-    @required TextDirection textDirection,
-    TextAlign textAlign: TextAlign.start,
-    Color cursorColor,
-    ValueNotifier<bool> showCursor,
-    int maxLines: 1,
-    Color selectionColor,
-    double textScaleFactor: 1.0,
-    TextSelection selection,
-    @required ViewportOffset offset,
-    this.onSelectionChanged,
-    this.onCaretChanged,
-  })
-      : assert(textAlign != null),
-        assert(textDirection != null,
-            'RenderEditable created without a textDirection.'),
-        assert(maxLines == null || maxLines > 0),
-        assert(textScaleFactor != null),
-        assert(offset != null),
-        _textPainter = new TextPainter(
-          text: text,
-          textAlign: textAlign,
-          textDirection: textDirection,
-          textScaleFactor: textScaleFactor,
-        ),
-        _cursorColor = cursorColor,
-        _showCursor = showCursor ?? new ValueNotifier<bool>(false),
-        _maxLines = maxLines,
-        _selection = selection,
-        _offset = offset {
-    assert(_showCursor != null);
-    assert(!_showCursor.value || cursorColor != null);
-    _tap = new TapGestureRecognizer(debugOwner: this)
-      ..onTapDown = _handleTapDown
-      ..onTap = _handleTap
-      ..onTapCancel = _handleTapCancel;
-    _longPress = new LongPressGestureRecognizer(debugOwner: this)
-      ..onLongPress = _handleLongPress;
-  }
-
-  /// Called when the selection changes.
-  SelectionChangedHandler onSelectionChanged;
-
-  double _textLayoutLastWidth;
-
-  /// Called during the paint phase when the caret location changes.
-  CaretChangedHandler onCaretChanged;
-
-  Rect _lastCaretRect;
-
-  /// Marks the render object as needing to be laid out again and have its text
-  /// metrics recomputed.
-  ///
-  /// Implies [markNeedsLayout].
-  @protected
-  void markNeedsTextLayout() {
-    _textLayoutLastWidth = null;
-    markNeedsLayout();
-  }
-
-  /// The text to display.
-  TextSpan get text => _textPainter.text;
-  final TextPainter _textPainter;
-
-  set text(TextSpan value) {
-    if (_textPainter.text == value) return;
-    _textPainter.text = value;
-    markNeedsTextLayout();
-  }
-
-  TextStyle currentStyle;
-
-  /// How the text should be aligned horizontally.
-  ///
-  /// This must not be null.
-  TextAlign get textAlign => _textPainter.textAlign;
-
-  set textAlign(TextAlign value) {
-    assert(value != null);
-    if (_textPainter.textAlign == value) return;
-    _textPainter.textAlign = value;
-    markNeedsPaint();
-  }
-
-  /// The directionality of the text.
-  ///
-  /// This decides how the [TextAlign.start], [TextAlign.end], and
-  /// [TextAlign.justify] values of [textAlign] are interpreted.
-  ///
-  /// This is also used to disambiguate how to render bidirectional text. For
-  /// example, if the [text] is an English phrase followed by a Hebrew phrase,
-  /// in a [TextDirection.ltr] context the English phrase will be on the left
-  /// and the Hebrew phrase to its right, while in a [TextDirection.rtl]
-  /// context, the English phrase will be on the right and the Hebrow phrase on
-  /// its left.
-  ///
-  /// This must not be null.
-  TextDirection get textDirection => _textPainter.textDirection;
-
-  set textDirection(TextDirection value) {
-    assert(value != null);
-    if (_textPainter.textDirection == value) return;
-    _textPainter.textDirection = value;
-    markNeedsTextLayout();
-  }
-
-  /// The color to use when painting the cursor.
-  Color get cursorColor => _cursorColor;
-  Color _cursorColor;
-
-  set cursorColor(Color value) {
-    if (_cursorColor == value) return;
-    _cursorColor = value;
-    markNeedsPaint();
-  }
-
-  /// Whether to paint the cursor.
-  ValueNotifier<bool> get showCursor => _showCursor;
-  ValueNotifier<bool> _showCursor;
-
-  set showCursor(ValueNotifier<bool> value) {
-    assert(value != null);
-    if (_showCursor == value) return;
-    if (attached) _showCursor.removeListener(markNeedsPaint);
-    _showCursor = value;
-    if (attached) _showCursor.addListener(markNeedsPaint);
-    markNeedsPaint();
-  }
-
-  /// The maximum number of lines for the text to span, wrapping if necessary.
-  ///
-  /// If this is 1 (the default), the text will not wrap, but will extend
-  /// indefinitely instead.
-  ///
-  /// If this is null, there is no limit to the number of lines.
-  ///
-  /// When this is not null, the intrinsic height of the render object is the
-  /// height of one line of text multiplied by this value. In other words, this
-  /// also controls the height of the actual editing widget.
-  int get maxLines => _maxLines;
-  int _maxLines;
-
-  /// The value may be null. If it is not null, then it must be greater than zero.
-  set maxLines(int value) {
-    assert(value == null || value > 0);
-    if (maxLines == value) return;
-    _maxLines = value;
-    markNeedsTextLayout();
-  }
-
-  /// The color to use when painting the selection.
-  Color get selectionColor => _selectionColor;
-  Color _selectionColor;
-
-  set selectionColor(Color value) {
-    if (_selectionColor == value) return;
-    _selectionColor = value;
-    markNeedsPaint();
-  }
-
-  /// The number of font pixels for each logical pixel.
-  ///
-  /// For example, if the text scale factor is 1.5, text will be 50% larger than
-  /// the specified font size.
-  double get textScaleFactor => _textPainter.textScaleFactor;
-
-  set textScaleFactor(double value) {
-    assert(value != null);
-    if (_textPainter.textScaleFactor == value) return;
-    _textPainter.textScaleFactor = value;
-    markNeedsTextLayout();
-  }
-
-  List<ui.TextBox> _selectionRects;
-
-  /// The region of text that is selected, if any.
-  TextSelection get selection => _selection;
-  TextSelection _selection;
-
-  set selection(TextSelection value) {
-    if (_selection == value) return;
-    _selection = value;
-    _selectionRects = null;
-
-    setCaretPrototype();
-
-    markNeedsPaint();
-  }
-
-  /// The offset at which the text should be painted.
-  ///
-  /// If the text content is larger than the editable line itself, the editable
-  /// line clips the text. This property controls which part of the text is
-  /// visible by shifting the text by the given offset before clipping.
-  ViewportOffset get offset => _offset;
-  ViewportOffset _offset;
-
-  set offset(ViewportOffset value) {
-    assert(value != null);
-    if (_offset == value) return;
-    if (attached) _offset.removeListener(markNeedsPaint);
-    _offset = value;
-    if (attached) _offset.addListener(markNeedsPaint);
-    markNeedsLayout();
-  }
-
-  @override
-  void attach(PipelineOwner owner) {
-    super.attach(owner);
-    _offset.addListener(markNeedsPaint);
-    _showCursor.addListener(markNeedsPaint);
-  }
-
-  @override
-  void detach() {
-    _offset.removeListener(markNeedsPaint);
-    _showCursor.removeListener(markNeedsPaint);
-    super.detach();
-  }
-
-  bool get _isMultiline => maxLines != 1;
-
-  Axis get _viewportAxis => _isMultiline ? Axis.vertical : Axis.horizontal;
-
-  Offset get _paintOffset {
-    switch (_viewportAxis) {
-      case Axis.horizontal:
-        return new Offset(-offset.pixels, 0.0);
-      case Axis.vertical:
-        return new Offset(0.0, -offset.pixels);
-    }
-    return null;
-  }
-
-  double get _viewportExtent {
-    assert(hasSize);
-    switch (_viewportAxis) {
-      case Axis.horizontal:
-        return size.width;
-      case Axis.vertical:
-        return size.height;
-    }
-    return null;
-  }
-
-  double _getMaxScrollExtent(Size contentSize) {
-    assert(hasSize);
-    switch (_viewportAxis) {
-      case Axis.horizontal:
-        return math.max(0.0, contentSize.width - size.width);
-      case Axis.vertical:
-        return math.max(0.0, contentSize.height - size.height);
-    }
-    return null;
-  }
-
-  bool _hasVisualOverflow = false;
-
-  /// Returns the local coordinates of the endpoints of the given selection.
-  ///
-  /// If the selection is collapsed (and therefore occupies a single point), the
-  /// returned list is of length one. Otherwise, the selection is not collapsed
-  /// and the returned list is of length two. In this case, however, the two
-  /// points might actually be co-located (e.g., because of a bidirectional
-  /// selection that contains some text but whose ends meet in the middle).
-  List<TextSelectionPoint> getEndpointsForSelection(TextSelection selection) {
-    assert(constraints != null);
-    _layoutText(constraints.maxWidth);
-
-    final Offset paintOffset = _paintOffset;
-
-    if (selection.isCollapsed) {
-      // TODO(mpcomplete): This doesn't work well at an RTL/LTR boundary.
-      final Offset caretOffset =
-          _textPainter.getOffsetForCaret(selection.extent, _caretPrototype);
-      final Offset start =
-          new Offset(0.0, _preferredLineHeight) + caretOffset + paintOffset;
-      return <TextSelectionPoint>[new TextSelectionPoint(start, null)];
-    } else {
-      final List<ui.TextBox> boxes =
-          _textPainter.getBoxesForSelection(selection);
-      final Offset start =
-          new Offset(boxes.first.start, boxes.first.bottom) + paintOffset;
-      final Offset end =
-          new Offset(boxes.last.end, boxes.last.bottom) + paintOffset;
-      return <TextSelectionPoint>[
-        new TextSelectionPoint(start, boxes.first.direction),
-        new TextSelectionPoint(end, boxes.last.direction),
-      ];
-    }
-  }
-
-  /// Returns the position in the text for the given global coordinate.
-  TextPosition getPositionForPoint(Offset globalPosition) {
-    _layoutText(constraints.maxWidth);
-    globalPosition += -_paintOffset;
-    return _textPainter.getPositionForOffset(globalToLocal(globalPosition));
-  }
-
-  /// Returns the Rect in local coordinates for the caret at the given text
-  /// position.
-  Rect getLocalRectForCaret(TextPosition caretPosition) {
-    _layoutText(constraints.maxWidth);
-    final Offset caretOffset =
-        _textPainter.getOffsetForCaret(caretPosition, _caretPrototype);
-
-    // This rect is the same as _caretPrototype but without the vertical padding.
-    var size = Extensions.maxFontSize(text);
-    return new Rect.fromLTWH(0.0, 0.0, _kCaretWidth, size)
-        .shift(caretOffset + _paintOffset);
-  }
-
-  @override
-  double computeMinIntrinsicWidth(double height) {
-    _layoutText(double.infinity);
-    return _textPainter.minIntrinsicWidth;
-  }
-
-  @override
-  double computeMaxIntrinsicWidth(double height) {
-    _layoutText(double.infinity);
-    return _textPainter.maxIntrinsicWidth;
-  }
-
-  // This does not required the layout to be updated.
-  double get _preferredLineHeight => _textPainter.preferredLineHeight;
-
-  double _preferredHeight(double width) {
-    if (maxLines != null) return _preferredLineHeight * maxLines;
-    if (width == double.infinity) {
-      final String text = _textPainter.text.toPlainText();
-      int lines = 1;
-      for (int index = 0; index < text.length; index += 1) {
-        if (text.codeUnitAt(index) == 0x0A) // count explicit line breaks
-          lines += 1;
-      }
-      return _preferredLineHeight * lines;
-    }
-    _layoutText(width);
-    return math.max(_preferredLineHeight, _textPainter.height);
-  }
-
-  @override
-  double computeMinIntrinsicHeight(double width) {
-    return _preferredHeight(width);
-  }
-
-  @override
-  double computeMaxIntrinsicHeight(double width) {
-    return _preferredHeight(width);
-  }
-
-  @override
-  bool hitTestSelf(Offset position) => true;
-
-  TapGestureRecognizer _tap;
-  LongPressGestureRecognizer _longPress;
-
-  @override
-  void handleEvent(PointerEvent event, BoxHitTestEntry entry) {
-    assert(debugHandleEvent(event, entry));
-    if (event is PointerDownEvent && onSelectionChanged != null) {
-      _tap.addPointer(event);
-      _longPress.addPointer(event);
-    }
-  }
-
-  Offset _lastTapDownPosition;
-  Offset _longPressPosition;
-
-  void _handleTapDown(TapDownDetails details) {
-    _lastTapDownPosition = details.globalPosition + -_paintOffset;
-  }
-
-  void _handleTap() {
-    _layoutText(constraints.maxWidth);
-    assert(_lastTapDownPosition != null);
-    final Offset globalPosition = _lastTapDownPosition;
-    _lastTapDownPosition = null;
-    if (onSelectionChanged != null) {
-      try {
-      final TextPosition position =
-          _textPainter.getPositionForOffset(globalToLocal(globalPosition));
-      onSelectionChanged(new TextSelection.fromPosition(position), this, false);
-      } catch (e) {}
-    }
-  }
-
-  void _handleTapCancel() {
-    // longPress arrives after tapCancel, so remember the tap position.
-    _longPressPosition = _lastTapDownPosition;
-    _lastTapDownPosition = null;
-  }
-
-  void _handleLongPress() {
-    _layoutText(constraints.maxWidth);
-    final Offset globalPosition = _longPressPosition;
-    _longPressPosition = null;
-
-    if (onSelectionChanged != null) {
-      try {
-      final TextPosition position =
-          _textPainter.getPositionForOffset(globalToLocal(globalPosition));
-      onSelectionChanged(_selectWordAtOffset(position), this, true);
-      } catch (e) {}
-    }
-  }
-
-  TextSelection _selectWordAtOffset(TextPosition position) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    final TextRange word = _textPainter.getWordBoundary(position);
-    // When long-pressing past the end of the text, we want a collapsed cursor.
-    if (position.offset >= word.end)
-      return new TextSelection.fromPosition(position);
-    return new TextSelection(baseOffset: word.start, extentOffset: word.end);
-  }
-
-  void _layoutText(double constraintWidth) {
-    assert(constraintWidth != null);
-    if (_textLayoutLastWidth == constraintWidth) return;
-    final double caretMargin = _kCaretGap + _kCaretWidth;
-    final double availableWidth = math.max(0.0, constraintWidth - caretMargin);
-    final double maxWidth = _isMultiline ? availableWidth : double.infinity;
-    _textPainter.layout(minWidth: availableWidth, maxWidth: maxWidth);
-    _textLayoutLastWidth = constraintWidth;
-  }
-
-  Rect _caretPrototype;
-
-  setCaretPrototype() {
-    var fontSize = Extensions
-            .getSpanForPosition(text, selection.start + 1)
-            ?.style
-            ?.fontSize ??
-        16.0;
-
-    var max = findMax([fontSize, currentStyle?.fontSize]);
-
-    _caretPrototype = new Rect.fromLTWH(0.0, _kCaretHeightOffset, _kCaretWidth,
-        max ?? _preferredLineHeight - 2.0 * _kCaretHeightOffset);
-  }
-
-  double findMax(List vals) {
-    double max = double.negativeInfinity;
-
-    for (double d in vals) {
-      if (d == null) continue;
-      if (d > max) max = d;
-    }
-
-    return max;
-  }
-
-  @override
-  void performLayout() {
-    _layoutText(constraints.maxWidth);
-    setCaretPrototype();
-
-    _selectionRects = null;
-    // We grab _textPainter.size here because assigning to `size` on the next
-    // line will trigger us to validate our intrinsic sizes, which will change
-    // _textPainter's layout because the intrinsic size calculations are
-    // destructive, which would mean we would get different results if we later
-    // used properties on _textPainter in this method.
-    // Other _textPainter state like didExceedMaxLines will also be affected,
-    // though we currently don't use those here.
-    // See also RenderParagraph which has a similar issue.
-    final Size textPainterSize = _textPainter.size;
-    size = new Size(constraints.maxWidth,
-        constraints.constrainHeight(_preferredHeight(constraints.maxWidth)));
-    final Size contentSize = new Size(
-        textPainterSize.width + _kCaretGap + _kCaretWidth,
-        textPainterSize.height);
-    final double _maxScrollExtent = _getMaxScrollExtent(contentSize);
-    _hasVisualOverflow = _maxScrollExtent > 0.0;
-    offset.applyViewportDimension(_viewportExtent);
-    offset.applyContentDimensions(0.0, _maxScrollExtent);
-  }
-
-  void _paintCaret(Canvas canvas, Offset effectiveOffset) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    final Offset caretOffset =
-        _textPainter.getOffsetForCaret(_selection.extent, _caretPrototype);
-    final Paint paint = new Paint()..color = _cursorColor;
-    final Rect caretRect = _caretPrototype.shift(caretOffset + effectiveOffset);
-    canvas.drawRect(caretRect, paint);
-    if (caretRect != _lastCaretRect) {
-      _lastCaretRect = caretRect;
-      if (onCaretChanged != null) onCaretChanged(caretRect);
-    }
-  }
-
-  void _paintSelection(Canvas canvas, Offset effectiveOffset) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    assert(_selectionRects != null);
-    final Paint paint = new Paint()..color = _selectionColor;
-    for (ui.TextBox box in _selectionRects)
-      canvas.drawRect(box.toRect().shift(effectiveOffset), paint);
-  }
-
-  void _paintContents(PaintingContext context, Offset offset) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    final Offset effectiveOffset = offset + _paintOffset;
-
-    if (_selection != null) {
-      if (_selection.isCollapsed && _showCursor.value && cursorColor != null) {
-        _paintCaret(context.canvas, effectiveOffset);
-      } else if (!_selection.isCollapsed && _selectionColor != null) {
-        _selectionRects ??= _textPainter.getBoxesForSelection(_selection);
-        _paintSelection(context.canvas, effectiveOffset);
-      }
-    }
-
-    _textPainter.paint(context.canvas, effectiveOffset);
-  }
-
-  @override
-  void paint(PaintingContext context, Offset offset) {
-    _layoutText(constraints.maxWidth);
-    if (_hasVisualOverflow)
-      context.pushClipRect(
-          needsCompositing, offset, Offset.zero & size, _paintContents);
-    else
-      _paintContents(context, offset);
-  }
-
-  @override
-  Rect describeApproximatePaintClip(RenderObject child) =>
-      _hasVisualOverflow ? Offset.zero & size : null;
-
-  @override
-  void debugFillProperties(DiagnosticPropertiesBuilder description) {
-    super.debugFillProperties(description);
-    description.add(new DiagnosticsProperty<Color>('cursorColor', cursorColor));
-    description.add(
-        new DiagnosticsProperty<ValueNotifier<bool>>('showCursor', showCursor));
-    description.add(new IntProperty('maxLines', maxLines));
-    description
-        .add(new DiagnosticsProperty<Color>('selectionColor', selectionColor));
-    description.add(new DoubleProperty('textScaleFactor', textScaleFactor));
-    description
-        .add(new DiagnosticsProperty<TextSelection>('selection', selection));
-    description.add(new DiagnosticsProperty<ViewportOffset>('offset', offset));
-  }
-
-  @override
-  List<DiagnosticsNode> debugDescribeChildren() {
-    return <DiagnosticsNode>[
-      text.toDiagnosticsNode(
-        name: 'text',
-        style: DiagnosticsTreeStyle.transition,
-      ),
-    ];
-  }
-}
diff --git a/lib/ui/rich_editor/rich_editable.dart b/lib/ui/rich_editor/rich_editable.dart
deleted file mode 100644
index d54194d6..00000000
--- a/lib/ui/rich_editor/rich_editable.dart
+++ /dev/null
@@ -1,653 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:math' as math;
-import 'dart:ui' as ui show TextBox;
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/gestures.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/rendering.dart';
-import 'package:flutter/services.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-
-const double _kCaretGap = 1.0; // pixels
-const double _kCaretHeightOffset = 2.0; // pixels
-const double _kCaretWidth = 1.0; // pixels
-
-final String _kZeroWidthSpace = new String.fromCharCode(0x200B);
-
-/// Signature for the callback that reports when the user changes the selection
-/// (including the cursor location).
-///
-/// Used by [RenderRichEditable.onSelectionChanged].
-typedef void SelectionChangedHandler(
-    TextSelection selection, RenderRichEditable renderObject, bool longPress);
-
-/// Signature for the callback that reports when the caret location changes.
-///
-/// Used by [RenderRichEditable.onCaretChanged].
-typedef void CaretChangedHandler(Rect caretRect);
-
-/// Represents the coordinates of the point in a selection, and the text
-/// direction at that point, relative to top left of the [RenderRichEditable] that
-/// holds the selection.
-@immutable
-class TextSelectionPoint {
-  /// Creates a description of a point in a text selection.
-  ///
-  /// The [point] argument must not be null.
-  const TextSelectionPoint(this.point, this.direction) : assert(point != null);
-
-  /// Coordinates of the lower left or lower right corner of the selection,
-  /// relative to the top left of the [RenderRichEditable] object.
-  final Offset point;
-
-  /// Direction of the text at this edge of the selection.
-  final TextDirection direction;
-
-  @override
-  String toString() {
-    switch (direction) {
-      case TextDirection.ltr:
-        return '$point-ltr';
-      case TextDirection.rtl:
-        return '$point-rtl';
-    }
-    return '$point';
-  }
-}
-
-/// Displays some text in a scrollable container with a potentially blinking
-/// cursor and with gesture recognizers.
-///
-/// This is the renderer for an editable text field. It does not directly
-/// provide affordances for editing the text, but it does handle text selection
-/// and manipulation of the text cursor.
-///
-/// The [text] is displayed, scrolled by the given [offset], aligned according
-/// to [textAlign]. The [maxLines] property controls whether the text displays
-/// on one line or many. The [selection], if it is not collapsed, is painted in
-/// the [selectionColor]. If it _is_ collapsed, then it represents the cursor
-/// position. The cursor is shown while [showCursor] is true. It is painted in
-/// the [cursorColor].
-///
-/// If, when the render object paints, the caret is found to have changed
-/// location, [onCaretChanged] is called.
-///
-/// The user may interact with the render object by tapping or long-pressing.
-/// When the user does so, the selection is updated, and [onSelectionChanged] is
-/// called.
-///
-/// Keyboard handling, IME handling, scrolling, toggling the [showCursor] value
-/// to actually blink the cursor, and other features not mentioned above are the
-/// responsibility of higher layers and not handled by this object.
-class RenderRichEditable extends RenderBox {
-  /// Creates a render object that implements the visual aspects of a text field.
-  ///
-  /// The [textAlign] argument must not be null. It defaults to [TextAlign.start].
-  ///
-  /// The [textDirection] argument must not be null.
-  ///
-  /// If [showCursor] is not specified, then it defaults to hiding the cursor.
-  ///
-  /// The [maxLines] property can be set to null to remove the restriction on
-  /// the number of lines. By default, it is 1, meaning this is a single-line
-  /// text field. If it is not null, it must be greater than zero.
-  ///
-  /// The [offset] is required and must not be null. You can use [new
-  /// ViewportOffset.zero] if you have no need for scrolling.
-  RenderRichEditable({
-    TextSpan text,
-    TextStyle currentStyle,
-    @required TextDirection textDirection,
-    TextAlign textAlign: TextAlign.start,
-    Color cursorColor,
-    ValueNotifier<bool> showCursor,
-    int maxLines: 1,
-    Color selectionColor,
-    double textScaleFactor: 1.0,
-    TextSelection selection,
-    @required ViewportOffset offset,
-    this.onSelectionChanged,
-    this.onCaretChanged,
-  })
-      : assert(textAlign != null),
-        assert(textDirection != null,
-            'RenderEditable created without a textDirection.'),
-        assert(maxLines == null || maxLines > 0),
-        assert(textScaleFactor != null),
-        assert(offset != null),
-        _textPainter = new TextPainter(
-          text: text,
-          textAlign: textAlign,
-          textDirection: textDirection,
-          textScaleFactor: textScaleFactor,
-        ),
-        _cursorColor = cursorColor,
-        _showCursor = showCursor ?? new ValueNotifier<bool>(false),
-        _maxLines = maxLines,
-        _selection = selection,
-        _offset = offset {
-    assert(_showCursor != null);
-    assert(!_showCursor.value || cursorColor != null);
-    _tap = new TapGestureRecognizer(debugOwner: this)
-      ..onTapDown = _handleTapDown
-      ..onTap = _handleTap
-      ..onTapCancel = _handleTapCancel;
-    _longPress = new LongPressGestureRecognizer(debugOwner: this)
-      ..onLongPress = _handleLongPress;
-  }
-
-  /// Called when the selection changes.
-  SelectionChangedHandler onSelectionChanged;
-
-  double _textLayoutLastWidth;
-
-  /// Called during the paint phase when the caret location changes.
-  CaretChangedHandler onCaretChanged;
-
-  Rect _lastCaretRect;
-
-  /// Marks the render object as needing to be laid out again and have its text
-  /// metrics recomputed.
-  ///
-  /// Implies [markNeedsLayout].
-  @protected
-  void markNeedsTextLayout() {
-    _textLayoutLastWidth = null;
-    markNeedsLayout();
-  }
-
-  /// The text to display.
-  TextSpan get text => _textPainter.text;
-  final TextPainter _textPainter;
-
-  set text(TextSpan value) {
-    if (_textPainter.text == value) return;
-    _textPainter.text = value;
-    markNeedsTextLayout();
-  }
-
-  TextStyle currentStyle;
-
-  /// How the text should be aligned horizontally.
-  ///
-  /// This must not be null.
-  TextAlign get textAlign => _textPainter.textAlign;
-
-  set textAlign(TextAlign value) {
-    assert(value != null);
-    if (_textPainter.textAlign == value) return;
-    _textPainter.textAlign = value;
-    markNeedsPaint();
-  }
-
-  /// The directionality of the text.
-  ///
-  /// This decides how the [TextAlign.start], [TextAlign.end], and
-  /// [TextAlign.justify] values of [textAlign] are interpreted.
-  ///
-  /// This is also used to disambiguate how to render bidirectional text. For
-  /// example, if the [text] is an English phrase followed by a Hebrew phrase,
-  /// in a [TextDirection.ltr] context the English phrase will be on the left
-  /// and the Hebrew phrase to its right, while in a [TextDirection.rtl]
-  /// context, the English phrase will be on the right and the Hebrow phrase on
-  /// its left.
-  ///
-  /// This must not be null.
-  TextDirection get textDirection => _textPainter.textDirection;
-
-  set textDirection(TextDirection value) {
-    assert(value != null);
-    if (_textPainter.textDirection == value) return;
-    _textPainter.textDirection = value;
-    markNeedsTextLayout();
-  }
-
-  /// The color to use when painting the cursor.
-  Color get cursorColor => _cursorColor;
-  Color _cursorColor;
-
-  set cursorColor(Color value) {
-    if (_cursorColor == value) return;
-    _cursorColor = value;
-    markNeedsPaint();
-  }
-
-  /// Whether to paint the cursor.
-  ValueNotifier<bool> get showCursor => _showCursor;
-  ValueNotifier<bool> _showCursor;
-
-  set showCursor(ValueNotifier<bool> value) {
-    assert(value != null);
-    if (_showCursor == value) return;
-    if (attached) _showCursor.removeListener(markNeedsPaint);
-    _showCursor = value;
-    if (attached) _showCursor.addListener(markNeedsPaint);
-    markNeedsPaint();
-  }
-
-  /// The maximum number of lines for the text to span, wrapping if necessary.
-  ///
-  /// If this is 1 (the default), the text will not wrap, but will extend
-  /// indefinitely instead.
-  ///
-  /// If this is null, there is no limit to the number of lines.
-  ///
-  /// When this is not null, the intrinsic height of the render object is the
-  /// height of one line of text multiplied by this value. In other words, this
-  /// also controls the height of the actual editing widget.
-  int get maxLines => _maxLines;
-  int _maxLines;
-
-  /// The value may be null. If it is not null, then it must be greater than zero.
-  set maxLines(int value) {
-    assert(value == null || value > 0);
-    if (maxLines == value) return;
-    _maxLines = value;
-    markNeedsTextLayout();
-  }
-
-  /// The color to use when painting the selection.
-  Color get selectionColor => _selectionColor;
-  Color _selectionColor;
-
-  set selectionColor(Color value) {
-    if (_selectionColor == value) return;
-    _selectionColor = value;
-    markNeedsPaint();
-  }
-
-  /// The number of font pixels for each logical pixel.
-  ///
-  /// For example, if the text scale factor is 1.5, text will be 50% larger than
-  /// the specified font size.
-  double get textScaleFactor => _textPainter.textScaleFactor;
-
-  set textScaleFactor(double value) {
-    assert(value != null);
-    if (_textPainter.textScaleFactor == value) return;
-    _textPainter.textScaleFactor = value;
-    markNeedsTextLayout();
-  }
-
-  List<ui.TextBox> _selectionRects;
-
-  /// The region of text that is selected, if any.
-  TextSelection get selection => _selection;
-  TextSelection _selection;
-
-  set selection(TextSelection value) {
-    if (_selection == value) return;
-    _selection = value;
-    _selectionRects = null;
-
-    setCaretPrototype();
-
-    markNeedsPaint();
-  }
-
-  /// The offset at which the text should be painted.
-  ///
-  /// If the text content is larger than the editable line itself, the editable
-  /// line clips the text. This property controls which part of the text is
-  /// visible by shifting the text by the given offset before clipping.
-  ViewportOffset get offset => _offset;
-  ViewportOffset _offset;
-
-  set offset(ViewportOffset value) {
-    assert(value != null);
-    if (_offset == value) return;
-    if (attached) _offset.removeListener(markNeedsPaint);
-    _offset = value;
-    if (attached) _offset.addListener(markNeedsPaint);
-    markNeedsLayout();
-  }
-
-  @override
-  void attach(PipelineOwner owner) {
-    super.attach(owner);
-    _offset.addListener(markNeedsPaint);
-    _showCursor.addListener(markNeedsPaint);
-  }
-
-  @override
-  void detach() {
-    _offset.removeListener(markNeedsPaint);
-    _showCursor.removeListener(markNeedsPaint);
-    super.detach();
-  }
-
-  bool get _isMultiline => maxLines != 1;
-
-  Axis get _viewportAxis => _isMultiline ? Axis.vertical : Axis.horizontal;
-
-  Offset get _paintOffset {
-    switch (_viewportAxis) {
-      case Axis.horizontal:
-        return new Offset(-offset.pixels, 0.0);
-      case Axis.vertical:
-        return new Offset(0.0, -offset.pixels);
-    }
-    return null;
-  }
-
-  double get _viewportExtent {
-    assert(hasSize);
-    switch (_viewportAxis) {
-      case Axis.horizontal:
-        return size.width;
-      case Axis.vertical:
-        return size.height;
-    }
-    return null;
-  }
-
-  double _getMaxScrollExtent(Size contentSize) {
-    assert(hasSize);
-    switch (_viewportAxis) {
-      case Axis.horizontal:
-        return math.max(0.0, contentSize.width - size.width);
-      case Axis.vertical:
-        return math.max(0.0, contentSize.height - size.height);
-    }
-    return null;
-  }
-
-  bool _hasVisualOverflow = false;
-
-  /// Returns the local coordinates of the endpoints of the given selection.
-  ///
-  /// If the selection is collapsed (and therefore occupies a single point), the
-  /// returned list is of length one. Otherwise, the selection is not collapsed
-  /// and the returned list is of length two. In this case, however, the two
-  /// points might actually be co-located (e.g., because of a bidirectional
-  /// selection that contains some text but whose ends meet in the middle).
-  List<TextSelectionPoint> getEndpointsForSelection(TextSelection selection) {
-    assert(constraints != null);
-    _layoutText(constraints.maxWidth);
-
-    final Offset paintOffset = _paintOffset;
-
-    if (selection.isCollapsed) {
-      // TODO(mpcomplete): This doesn't work well at an RTL/LTR boundary.
-      final Offset caretOffset =
-          _textPainter.getOffsetForCaret(selection.extent, _caretPrototype);
-      final Offset start =
-          new Offset(0.0, _preferredLineHeight) + caretOffset + paintOffset;
-      return <TextSelectionPoint>[new TextSelectionPoint(start, null)];
-    } else {
-      final List<ui.TextBox> boxes =
-          _textPainter.getBoxesForSelection(selection);
-      final Offset start =
-          new Offset(boxes.first.start, boxes.first.bottom) + paintOffset;
-      final Offset end =
-          new Offset(boxes.last.end, boxes.last.bottom) + paintOffset;
-      return <TextSelectionPoint>[
-        new TextSelectionPoint(start, boxes.first.direction),
-        new TextSelectionPoint(end, boxes.last.direction),
-      ];
-    }
-  }
-
-  /// Returns the position in the text for the given global coordinate.
-  TextPosition getPositionForPoint(Offset globalPosition) {
-    _layoutText(constraints.maxWidth);
-    globalPosition += -_paintOffset;
-    return _textPainter.getPositionForOffset(globalToLocal(globalPosition));
-  }
-
-  /// Returns the Rect in local coordinates for the caret at the given text
-  /// position.
-  Rect getLocalRectForCaret(TextPosition caretPosition) {
-    _layoutText(constraints.maxWidth);
-    final Offset caretOffset =
-        _textPainter.getOffsetForCaret(caretPosition, _caretPrototype);
-
-    // This rect is the same as _caretPrototype but without the vertical padding.
-    var size = Extensions.maxFontSize(text);
-    return new Rect.fromLTWH(0.0, 0.0, _kCaretWidth, size)
-        .shift(caretOffset + _paintOffset);
-  }
-
-  @override
-  double computeMinIntrinsicWidth(double height) {
-    _layoutText(double.infinity);
-    return _textPainter.minIntrinsicWidth;
-  }
-
-  @override
-  double computeMaxIntrinsicWidth(double height) {
-    _layoutText(double.infinity);
-    return _textPainter.maxIntrinsicWidth;
-  }
-
-  // This does not required the layout to be updated.
-  double get _preferredLineHeight => _textPainter.preferredLineHeight;
-
-  double _preferredHeight(double width) {
-    if (maxLines != null) return _preferredLineHeight * maxLines;
-    if (width == double.infinity) {
-      final String text = _textPainter.text.toPlainText();
-      int lines = 1;
-      for (int index = 0; index < text.length; index += 1) {
-        if (text.codeUnitAt(index) == 0x0A) // count explicit line breaks
-          lines += 1;
-      }
-      return _preferredLineHeight * lines;
-    }
-    _layoutText(width);
-    return math.max(_preferredLineHeight, _textPainter.height);
-  }
-
-  @override
-  double computeMinIntrinsicHeight(double width) {
-    return _preferredHeight(width);
-  }
-
-  @override
-  double computeMaxIntrinsicHeight(double width) {
-    return _preferredHeight(width);
-  }
-
-  @override
-  bool hitTestSelf(Offset position) => true;
-
-  TapGestureRecognizer _tap;
-  LongPressGestureRecognizer _longPress;
-
-  @override
-  void handleEvent(PointerEvent event, BoxHitTestEntry entry) {
-    assert(debugHandleEvent(event, entry));
-    if (event is PointerDownEvent && onSelectionChanged != null) {
-      _tap.addPointer(event);
-      _longPress.addPointer(event);
-    }
-  }
-
-  Offset _lastTapDownPosition;
-  Offset _longPressPosition;
-
-  void _handleTapDown(TapDownDetails details) {
-    _lastTapDownPosition = details.globalPosition + -_paintOffset;
-  }
-
-  void _handleTap() {
-    _layoutText(constraints.maxWidth);
-    assert(_lastTapDownPosition != null);
-    final Offset globalPosition = _lastTapDownPosition;
-    _lastTapDownPosition = null;
-    if (onSelectionChanged != null) {
-      final TextPosition position =
-          _textPainter.getPositionForOffset(globalToLocal(globalPosition));
-      onSelectionChanged(new TextSelection.fromPosition(position), this, false);
-    }
-  }
-
-  void _handleTapCancel() {
-    // longPress arrives after tapCancel, so remember the tap position.
-    _longPressPosition = _lastTapDownPosition;
-    _lastTapDownPosition = null;
-  }
-
-  void _handleLongPress() {
-    _layoutText(constraints.maxWidth);
-    final Offset globalPosition = _longPressPosition;
-    _longPressPosition = null;
-
-    if (onSelectionChanged != null) {
-      final TextPosition position =
-          _textPainter.getPositionForOffset(globalToLocal(globalPosition));
-      onSelectionChanged(_selectWordAtOffset(position), this, true);
-    }
-  }
-
-  TextSelection _selectWordAtOffset(TextPosition position) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    final TextRange word = _textPainter.getWordBoundary(position);
-    // When long-pressing past the end of the text, we want a collapsed cursor.
-    if (position.offset >= word.end)
-      return new TextSelection.fromPosition(position);
-    return new TextSelection(baseOffset: word.start, extentOffset: word.end);
-  }
-
-  void _layoutText(double constraintWidth) {
-    assert(constraintWidth != null);
-    if (_textLayoutLastWidth == constraintWidth) return;
-    final double caretMargin = _kCaretGap + _kCaretWidth;
-    final double availableWidth = math.max(0.0, constraintWidth - caretMargin);
-    final double maxWidth = _isMultiline ? availableWidth : double.infinity;
-    _textPainter.layout(minWidth: availableWidth, maxWidth: maxWidth);
-    _textLayoutLastWidth = constraintWidth;
-  }
-
-  Rect _caretPrototype;
-
-  setCaretPrototype() {
-    var fontSize = Extensions
-            .getSpanForPosition(text, selection.start + 1)
-            ?.style
-            ?.fontSize ??
-        16.0;
-
-    var max = findMax([fontSize, currentStyle?.fontSize]);
-
-    _caretPrototype = new Rect.fromLTWH(0.0, _kCaretHeightOffset, _kCaretWidth,
-        max ?? _preferredLineHeight - 2.0 * _kCaretHeightOffset);
-  }
-
-  double findMax(List vals) {
-    double max = double.negativeInfinity;
-
-    for (double d in vals) {
-      if (d == null) continue;
-      if (d > max) max = d;
-    }
-
-    return max;
-  }
-
-  @override
-  void performLayout() {
-    _layoutText(constraints.maxWidth);
-    setCaretPrototype();
-
-    _selectionRects = null;
-    // We grab _textPainter.size here because assigning to `size` on the next
-    // line will trigger us to validate our intrinsic sizes, which will change
-    // _textPainter's layout because the intrinsic size calculations are
-    // destructive, which would mean we would get different results if we later
-    // used properties on _textPainter in this method.
-    // Other _textPainter state like didExceedMaxLines will also be affected,
-    // though we currently don't use those here.
-    // See also RenderParagraph which has a similar issue.
-    final Size textPainterSize = _textPainter.size;
-    size = new Size(constraints.maxWidth,
-        constraints.constrainHeight(_preferredHeight(constraints.maxWidth)));
-    final Size contentSize = new Size(
-        textPainterSize.width + _kCaretGap + _kCaretWidth,
-        textPainterSize.height);
-    final double _maxScrollExtent = _getMaxScrollExtent(contentSize);
-    _hasVisualOverflow = _maxScrollExtent > 0.0;
-    offset.applyViewportDimension(_viewportExtent);
-    offset.applyContentDimensions(0.0, _maxScrollExtent);
-  }
-
-  void _paintCaret(Canvas canvas, Offset effectiveOffset) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    final Offset caretOffset =
-        _textPainter.getOffsetForCaret(_selection.extent, _caretPrototype);
-    final Paint paint = new Paint()..color = _cursorColor;
-    final Rect caretRect = _caretPrototype.shift(caretOffset + effectiveOffset);
-    canvas.drawRect(caretRect, paint);
-    if (caretRect != _lastCaretRect) {
-      _lastCaretRect = caretRect;
-      if (onCaretChanged != null) onCaretChanged(caretRect);
-    }
-  }
-
-  void _paintSelection(Canvas canvas, Offset effectiveOffset) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    assert(_selectionRects != null);
-    final Paint paint = new Paint()..color = _selectionColor;
-    for (ui.TextBox box in _selectionRects)
-      canvas.drawRect(box.toRect().shift(effectiveOffset), paint);
-  }
-
-  void _paintContents(PaintingContext context, Offset offset) {
-    assert(_textLayoutLastWidth == constraints.maxWidth);
-    final Offset effectiveOffset = offset + _paintOffset;
-
-    if (_selection != null) {
-      if (_selection.isCollapsed && _showCursor.value && cursorColor != null) {
-        _paintCaret(context.canvas, effectiveOffset);
-      } else if (!_selection.isCollapsed && _selectionColor != null) {
-        _selectionRects ??= _textPainter.getBoxesForSelection(_selection);
-        _paintSelection(context.canvas, effectiveOffset);
-      }
-    }
-
-    _textPainter.paint(context.canvas, effectiveOffset);
-  }
-
-  @override
-  void paint(PaintingContext context, Offset offset) {
-    _layoutText(constraints.maxWidth);
-    if (_hasVisualOverflow)
-      context.pushClipRect(
-          needsCompositing, offset, Offset.zero & size, _paintContents);
-    else
-      _paintContents(context, offset);
-  }
-
-  @override
-  Rect describeApproximatePaintClip(RenderObject child) =>
-      _hasVisualOverflow ? Offset.zero & size : null;
-
-  @override
-  void debugFillProperties(DiagnosticPropertiesBuilder description) {
-    super.debugFillProperties(description);
-    description.add(new DiagnosticsProperty<Color>('cursorColor', cursorColor));
-    description.add(
-        new DiagnosticsProperty<ValueNotifier<bool>>('showCursor', showCursor));
-    description.add(new IntProperty('maxLines', maxLines));
-    description
-        .add(new DiagnosticsProperty<Color>('selectionColor', selectionColor));
-    description.add(new DoubleProperty('textScaleFactor', textScaleFactor));
-    description
-        .add(new DiagnosticsProperty<TextSelection>('selection', selection));
-    description.add(new DiagnosticsProperty<ViewportOffset>('offset', offset));
-  }
-
-  @override
-  List<DiagnosticsNode> debugDescribeChildren() {
-    return <DiagnosticsNode>[
-      text.toDiagnosticsNode(
-        name: 'text',
-        style: DiagnosticsTreeStyle.transition,
-      ),
-    ];
-  }
-}
\ No newline at end of file
diff --git a/lib/ui/rich_editor/rich_editor.dart b/lib/ui/rich_editor/rich_editor.dart
deleted file mode 100644
index 6453ea3d..00000000
--- a/lib/ui/rich_editor/rich_editor.dart
+++ /dev/null
@@ -1,5 +0,0 @@
-library rich_editor;
-
-export 'package:kalium_wallet_flutter/ui/rich_editor/material/rich_text_field.dart';
-export 'package:kalium_wallet_flutter/ui/rich_editor/widgets/rich_editable_text.dart';
-export 'package:kalium_wallet_flutter/ui/rich_editor/widgets/format_toolbar.dart';
\ No newline at end of file
diff --git a/lib/ui/rich_editor/rich_text_parser.dart b/lib/ui/rich_editor/rich_text_parser.dart
deleted file mode 100644
index cad6e2fd..00000000
--- a/lib/ui/rich_editor/rich_text_parser.dart
+++ /dev/null
@@ -1,953 +0,0 @@
-import 'dart:math';
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter/widgets.dart';
-import 'package:kalium_wallet_flutter/styles.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/text_input.dart';
-
-class Log {
-  Log(String something);
-
-  void d(var s) {
-    return;
-  }
-
-  void w(var s) { }
-
-  void e(var s) { }
-}
-
-class RichTextEditingValueParser {
-  static final Log log = new Log("RichTextEditingValueParser");
-
-  static RichTextEditingValue parse(
-      {@required RichTextEditingValue oldValue,
-      @required RichTextEditingValue newValue,
-      @required TextStyle style}) {
-    if (_equalTextValue(oldValue, newValue)) {
-      log.d(
-          "Same text value and same selection and composing. We are not changing anything.");
-      return oldValue;
-    } else if (_sameTextDiffSelection(oldValue, newValue)) {
-      log.d(
-          "Same text, but different selection or composing. Update only that.");
-      return newValue.copyWith(value: oldValue.value);
-    }
-
-    // If text different and children exist, reset to default style
-    if (newValue.text != oldValue.text && oldValue.value.children != null) {
-      oldValue = new RichTextEditingValue(value: TextSpan(text: oldValue.text, style: KaliumStyles.TextStyleAddressText60));
-      newValue = new RichTextEditingValue(value: TextSpan(text: newValue.text, style: KaliumStyles.TextStyleAddressText60));
-    }
-
-    TextSpan currentSpan = oldValue.value;
-    TextSelection currentSelection = oldValue.selection;
-    TextSelection newSelection = newValue.selection;
-
-    log.d("Current span has children: ${currentSpan.children != null}");
-
-    /// If the root [TextSpan] doesn't have any children we can simply set the
-    /// root text to the new value.
-    ///
-    /// Otherwise we look to the span that changed.
-    if (currentSpan.children == null) {
-      log.d("The style is the same: ${currentSpan.style == style}");
-
-      /// If the user didn't changed the default [TextStyle] we update the root
-      /// text value with the new value. Also if the user DID changed the
-      /// [style] but is deleting, we just set the new value.
-      ///
-      /// Otherwise we create a new [TextSpan] with the added text
-      if (currentSpan.style == style // no change in style, no need to update
-              ||
-              currentSelection.baseOffset >
-                  newSelection.baseOffset // text was deleted, no need to update
-          ) {
-        log.d("The user did change the default style or has deleted text.");
-      } else {
-        var text = newValue.text
-            .substring(currentSelection.baseOffset, newSelection.baseOffset);
-
-        /// If the insert position, indicated by [currentSelection.baseOffset]
-        /// is contained in the text of the root [TextSpan], we recreate the
-        /// root with the first part of the root text, and the below children:
-        ///
-        /// [1]: a new [TextSpan] with the text added by the user and the
-        /// [style];
-        ///
-        /// [2]: another [TextSpan] with the last part of root text, but keeping
-        /// the  same style as the root.
-        if (currentSpan.text.length > currentSelection.baseOffset) {
-          var textBefore = currentSelection.textBefore(currentSpan.text);
-          var textAfter = currentSelection.textAfter(currentSpan.text);
-
-          log.d("A new child was added at ${textBefore.isEmpty
-              ? "start"
-              : "middle"}.");
-
-          if (textBefore.isEmpty) {
-            newValue = newValue.copyWith(
-              value: new TextSpan(
-                text: "",
-                style: currentSpan.style,
-                children: [
-                  new TextSpan(
-                    text: text,
-                    style: style,
-                  ),
-                  new TextSpan(
-                    text: textAfter,
-                    style: currentSpan.style,
-                  ),
-                ],
-              ),
-            );
-          } else {
-            newValue = newValue.copyWith(
-              value: new TextSpan(
-                text: textBefore,
-                style: currentSpan.style,
-                children: [
-                  new TextSpan(
-                    text: text,
-                    style: style,
-                  ),
-                  new TextSpan(
-                    text: textAfter,
-                    style: currentSpan.style,
-                  ),
-                ],
-              ),
-            );
-          }
-        } else {
-          log.d("A new child was added at end.");
-          newValue = newValue.copyWith(
-            value: new TextSpan(
-              style: currentSpan.style,
-              text: currentSpan.text,
-              children: [
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-              ],
-            ),
-          );
-        }
-      }
-    } else {
-      /// Something was added
-      if (currentSelection.baseOffset < newSelection.baseOffset) {
-        log.d("The user added some text.");
-
-        String oldPlainText = currentSpan.toPlainText();
-
-        /// If the insert position, indicated by [currentSelection.start] is
-        /// contained in the [text] of the root [TextSpan], just update the text
-        /// of the root element.
-        if (currentSpan.text.length >= currentSelection.start) {
-          log.d(
-              "----------------------------------------------ADD TO ROOT TEXT");
-          var text = newValue.text
-              .substring(currentSelection.start, newSelection.start);
-
-          var textBefore = currentSelection.textBefore(currentSpan.text);
-          var textAfter = currentSelection.textAfter(currentSpan.text);
-
-          if (currentSpan.style == style) {
-            log.d("same style");
-
-            newValue = newValue.copyWith(
-              value: Extensions.copySpanWith(
-                base: currentSpan,
-                text: textBefore + text + textAfter,
-              ),
-            );
-          } else {
-            log.d("different style");
-
-            if (textBefore.isEmpty) {
-              log.d("start");
-              List<TextSpan> children = [
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-                new TextSpan(
-                  text: currentSpan.text,
-                  style: currentSpan.style,
-                ),
-              ];
-
-              children.addAll(currentSpan.children);
-
-              newValue = newValue.copyWith(
-                value: new TextSpan(
-                  text: "",
-                  style: currentSpan.style,
-                  children: children,
-                ),
-              );
-            } else if (textAfter.isEmpty) {
-              log.d("end");
-
-              List<TextSpan> children = currentSpan.children.toList();
-              children.insert(
-                0,
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-              );
-
-              newValue = newValue.copyWith(
-                  value: Extensions.copySpanWith(
-                      base: currentSpan, children: children));
-            } else {
-              log.d("middle");
-
-              List<TextSpan> children = [
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-                new TextSpan(
-                  text: textAfter,
-                  style: currentSpan.style,
-                ),
-              ];
-
-              children.addAll(currentSpan.children);
-
-              newValue = newValue.copyWith(
-                value: new TextSpan(
-                  text: textBefore,
-                  style: currentSpan.style,
-                  children: children,
-                ),
-              );
-            }
-          }
-        }
-
-        /// If the insert position is in one of the children then we retrieve
-        /// that child and find its start and end position in the parent. Then
-        /// we update the text of that [TextSpan] with the new value.
-        else if (oldPlainText.length >= currentSelection.start) {
-          log.d(
-              "-----------------------------------------------ADD TO CHILDREN");
-          var text = newValue.text
-              .substring(currentSelection.start, newSelection.start);
-          List<TextSpan> children = currentSpan.children.toList();
-          TextSpan affectedSpan = Extensions.getSpanForPosition(
-              currentSpan, currentSelection.baseOffset);
-
-          log.d(affectedSpan);
-          var index = children.indexOf(affectedSpan);
-
-          TextSpan root;
-          //last span
-          if (index == children.length - 1) {
-            var index = children.indexOf(affectedSpan);
-            children.removeAt(index);
-
-            var affectedSpanStart =
-                Extensions.getOffsetInParent(currentSpan, affectedSpan);
-
-            String textBefore = oldPlainText.substring(
-                affectedSpanStart, currentSelection.base.offset);
-
-            String textAfter =
-                oldPlainText.substring(currentSelection.base.offset);
-
-            if (affectedSpan.style == style) {
-              log.d(
-                  "----------------------------------------------------SAME STYLE");
-              affectedSpan = Extensions.copySpanWith(
-                  base: affectedSpan, text: textBefore + text + textAfter);
-
-              children.add(affectedSpan);
-            } else {
-              log.d(
-                  "-----------------------------------------------DIFFERENT STYLE");
-              if (textBefore.isEmpty) {
-                log.d("start");
-                children.add(new TextSpan(
-                  text: text,
-                  style: style,
-                ));
-                children.add(affectedSpan);
-              } else if (textAfter.isEmpty) {
-                log.d("end");
-                children.add(affectedSpan);
-                children.add(new TextSpan(
-                  text: text,
-                  style: style,
-                ));
-              } else {
-                log.d("middle");
-                children.add(new TextSpan(
-                  text: textBefore,
-                  style: affectedSpan.style,
-                ));
-                children.add(new TextSpan(
-                  text: text,
-                  style: style,
-                ));
-                children.add(new TextSpan(
-                  text: textAfter,
-                  style: affectedSpan.style,
-                ));
-              }
-            }
-
-            root = Extensions.copySpanWith(
-              base: currentSpan,
-              children: children,
-            );
-          } else {
-            var index = children.indexOf(affectedSpan);
-            children.removeAt(index);
-
-            var affectedSpanStart =
-                Extensions.getOffsetInParent(currentSpan, affectedSpan);
-
-            var affectedSpanEnd = affectedSpanStart + affectedSpan.text.length;
-
-            String textBefore = oldPlainText.substring(
-                affectedSpanStart, currentSelection.base.offset);
-
-            String textAfter = oldPlainText.substring(
-                currentSelection.base.offset, affectedSpanEnd);
-
-            if (affectedSpan.style == style) {
-              log.d(
-                  "----------------------------------------------------SAME STYLE");
-              affectedSpan = Extensions.copySpanWith(
-                  base: affectedSpan, text: textBefore + text + textAfter);
-
-              children.insert(index, affectedSpan);
-            } else {
-              log.d(
-                  "-----------------------------------------------DIFFERENT STYLE");
-              if (textBefore.isEmpty) {
-                assert(false);
-                log.d("start");
-                children.insert(
-                    index,
-                    new TextSpan(
-                      text: text,
-                      style: style,
-                    ));
-                children.insert(index + 1, affectedSpan);
-              } else if (textAfter.isEmpty) {
-                log.d("end");
-                children.insert(index, affectedSpan);
-
-                TextSpan nextSpan = children[index + 1];
-
-                if (nextSpan.style == style) {
-                  log.d(
-                      "----------------------------------------------------SAME STYLE");
-                  children.removeAt(index + 1);
-                  children.insert(
-                      index + 1,
-                      Extensions.copySpanWith(
-                        base: nextSpan,
-                        text: text + nextSpan.text,
-                      ));
-                } else {
-                  log.d(
-                      "-----------------------------------------------DIFFERENT STYLE");
-                  children.removeAt(index + 1);
-
-                  var nextSpanStart =
-                      Extensions.getOffsetInParent(currentSpan, nextSpan);
-
-                  var nextSpanEnd = nextSpanStart + nextSpan.text.length;
-
-                  String textBefore = oldPlainText.substring(
-                      nextSpanStart, currentSelection.base.offset);
-
-                  String textAfter = oldPlainText.substring(
-                      currentSelection.base.offset, nextSpanEnd);
-
-                  if (textBefore.isEmpty) {
-                    log.d("start");
-                    children.insert(
-                        index + 1,
-                        new TextSpan(
-                          text: text,
-                          style: style,
-                        ));
-                    children.insert(index + 2, nextSpan);
-                  } else if (textAfter.isEmpty) {
-                    log.d("end");
-                    children.insert(index + 1, nextSpan);
-                    children.insert(
-                        index + 2,
-                        new TextSpan(
-                          text: text,
-                          style: style,
-                        ));
-                  } else {
-                    log.d("middle");
-                    children.insert(
-                        index + 1,
-                        new TextSpan(
-                          text: textBefore,
-                          style: nextSpan.style,
-                        ));
-                    children.insert(
-                        index + 2,
-                        new TextSpan(
-                          text: text,
-                          style: style,
-                        ));
-                    children.insert(
-                        index + 3,
-                        new TextSpan(
-                          text: textAfter,
-                          style: nextSpan.style,
-                        ));
-                  }
-                }
-              } else {
-                log.d("middle");
-                children.insert(
-                    index,
-                    new TextSpan(
-                      text: textBefore,
-                      style: affectedSpan.style,
-                    ));
-                children.insert(
-                    index + 1,
-                    new TextSpan(
-                      text: text,
-                      style: style,
-                    ));
-                children.insert(
-                    index + 2,
-                    new TextSpan(
-                      text: textAfter,
-                      style: affectedSpan.style,
-                    ));
-              }
-            }
-
-            root = Extensions.copySpanWith(
-              base: currentSpan,
-              children: children,
-            );
-          }
-
-          newValue = newValue.copyWith(value: root);
-        }
-      }
-
-      /// Something was deleted
-      else {
-        if (currentSpan.text.length >= currentSelection.start &&
-            currentSelection.isCollapsed) {
-          log.d(
-              "-----------------------------------------DELETE FROM ROOT TEXT");
-          var text = currentSpan.text.substring(0, newSelection.extentOffset) +
-              currentSpan.text.substring(oldValue.selection.extentOffset);
-
-          newValue = newValue.copyWith(
-            value: Extensions.copySpanWith(
-              base: currentSpan,
-              text: text,
-            ),
-          );
-        } else {
-          log.d(
-              "------------------------------------------DELETE FROM CHILDREN");
-          List<TextSpan> children = currentSpan.children.toList();
-
-          var isCollapsed = currentSelection.start - newSelection.start == 1 &&
-              currentSelection.isCollapsed;
-          var rootText = currentSpan.text;
-
-          if (isCollapsed) {
-            log.d("------------------------------------------IS COLAPSED");
-            // This is the text.
-            // This is th text.
-
-            // This is the text.
-            // This is te text.
-
-            TextSpan affectedSpan = Extensions.getSpanForPosition(
-                currentSpan, currentSelection.start);
-
-            int index = children.indexOf(affectedSpan);
-            children.removeAt(index);
-
-            if (affectedSpan.text.length == 1) {
-              affectedSpan = null;
-            } else {
-              var start = currentSelection.start -
-                  Extensions.getOffsetInParent(currentSpan, affectedSpan);
-
-              var textBefore = affectedSpan.text.substring(0, start - 1);
-              var textAfter = affectedSpan.text.substring(start);
-
-              affectedSpan = Extensions.copySpanWith(
-                base: affectedSpan,
-                text: textBefore + textAfter,
-              );
-            }
-
-            if (affectedSpan != null) children.insert(index, affectedSpan);
-          } else {
-            log.d("------------------------------------------IS NOT COLAPSED");
-            //
-            // This is the text.
-            // This is  text.                        => fast delete by keyboard
-
-            // This is the text.
-            // This is text.
-
-            var selection = currentSelection;
-            if (currentSelection.start - newSelection.start != 1) {
-              //fast delete by keyboard
-              selection = new TextSelection(
-                baseOffset: newSelection.start,
-                extentOffset: currentSelection.end,
-                affinity: currentSelection.affinity,
-              );
-            }
-
-            TextSpan startSpan =
-                Extensions.getSpanForPosition(currentSpan, selection.start);
-            TextSpan endSpan =
-                Extensions.getSpanForPosition(currentSpan, selection.end);
-
-            if (startSpan == currentSpan) {
-              //delete from root too
-              rootText = rootText.substring(0, newSelection.start);
-              int index = children.indexOf(endSpan);
-              children.removeRange(0, index + 1);
-
-              var span = _deleteSelectionRange(
-                  parent: currentSpan, span: endSpan, selection: selection);
-
-              if (span != null) children.insert(0, span);
-            } else if (startSpan == endSpan) {
-              int index = children.indexOf(startSpan);
-              children.removeAt(index);
-
-              var span = _deleteSelectionRange(
-                  parent: currentSpan, span: startSpan, selection: selection);
-
-              if (span != null) children.insert(index, span);
-            } else {
-              int startIndex = children.indexOf(startSpan);
-              int endIndex = children.indexOf(endSpan);
-              children.removeRange(startIndex, endIndex + 1);
-
-              startSpan = _deleteSelectionRange(
-                  parent: currentSpan, span: startSpan, selection: selection);
-
-              endSpan = _deleteSelectionRange(
-                  parent: currentSpan, span: endSpan, selection: selection);
-
-              if (startSpan != null && endSpan != null) {
-                children.insert(startIndex, startSpan);
-                children.insert(startIndex + 1, endSpan);
-              } else
-                children.insert(
-                    startIndex, startSpan == null ? endSpan : startSpan);
-            }
-          }
-
-          if (children.isEmpty) children = null;
-
-          newValue = newValue.copyWith(
-            value: new TextSpan(
-              text: rootText,
-              style: currentSpan.style,
-              recognizer: currentSpan.recognizer,
-              children: children,
-            ),
-          );
-        }
-      }
-    }
-
-    newValue = newValue.copyWith(
-      value: Extensions.copySpanWith(
-        base: newValue.value,
-        children: optimiseChildren(newValue.value.children),
-      ),
-    );
-
-    log.d(newValue.value.toPlainText());
-    return newValue;
-  }
-
-  static TextSpan _deleteSelectionRange({
-    @required TextSpan parent,
-    @required TextSpan span,
-    @required TextSelection selection,
-  }) {
-    try {
-      if (span.text.length == 1)
-        return null;
-      else {
-        int offsetInParent = Extensions.getOffsetInParent(parent, span);
-        int spanLength = span.text.length;
-
-        String text;
-
-        if (selection.start - offsetInParent < 0) {
-          int start = selection.end - offsetInParent;
-          text = span.text.substring(start);
-        } else {
-          int start = selection.start - offsetInParent;
-          int end = min(selection.end - offsetInParent, spanLength);
-
-          String textBefore = span.text.substring(0, start);
-          String textAfter = span.text.substring(end);
-
-          text = textBefore + textAfter;
-        }
-
-        return Extensions.copySpanWith(
-          base: span,
-          text: text,
-        );
-      }
-    } catch (e) {
-      log.e(e);
-      log.d(span);
-      return null;
-    }
-  }
-
-  static TextSpan updateSpansWithStyle(TextSpan span, TextSelection selection,
-      TextStyle currentStyle, TextStyle newStyle) {
-    if (newStyle == Extensions.emptyStyle) {
-      log.w("The new style is empty. We are not touching anything!");
-      return span;
-    }
-
-    List<TextSpan> children = [];
-
-    if (span.children != null) {
-      /// We need a copy of the children list to avoid changing the
-      /// [oldValue] content. <b>Remove this and see what happens. :D</b>
-      span.children.forEach((it) => children.add(it));
-    }
-
-    var newSpan = span;
-    var rootTextLength = span.text.length;
-    TextStyle diffStyle = Extensions.getDifferenceStyle(currentStyle, newStyle);
-
-    /// The selection include the root text.
-    if (rootTextLength > selection.baseOffset) {
-      log.d("----------------------------------------------START: ROOT TEXT");
-
-      /// The selection ends in the root text.
-      if (rootTextLength >= selection.extentOffset) {
-        log.d("-----------------------------------------END: ROOT TEXT");
-
-        var beforeText = selection.textBefore(span.text);
-        var insideText = selection.textInside(span.text);
-
-        children.insert(
-            0,
-            new TextSpan(
-                text: insideText,
-                style: Extensions.deepMerge(span.style, diffStyle)));
-
-        if (rootTextLength != selection.extentOffset) {
-          var afterText = selection.textAfter(span.text);
-          children.insert(1, new TextSpan(text: afterText, style: span.style));
-        }
-
-        newSpan = Extensions.copySpanWith(
-            base: span, text: beforeText, children: children);
-      }
-
-      /// The selection ends in one of the children.
-      else {
-        assert(children.isNotEmpty);
-
-        //handle root text
-        var rootTextBeforeSelection = selection.textBefore(span.text);
-        var rootTextInSelection = span.text.substring(selection.baseOffset);
-
-        //handle children
-        var startSpan = span.getSpanForPosition(new TextPosition(
-            offset: span.text.length, affinity: selection.affinity));
-
-        var endSpan = span.getSpanForPosition(selection.extent);
-
-        var startIndex = children.indexOf(startSpan); //must be 0
-        var endIndex = children.indexOf(endSpan);
-
-        /// The selection ends in the first child.
-        if (startIndex == endIndex) {
-          log.d(
-              "-------------------------------------------------END: CHILDREN: startIndex == endIndex");
-
-          var startSpanText = startSpan.text;
-
-          var beforeText = startSpanText.substring(
-              0, selection.extentOffset - span.text.length);
-          var afterText = startSpanText.substring(beforeText.length);
-
-          children.remove(startSpan);
-          children.insert(
-              0,
-              Extensions.copySpanWith(
-                  base: startSpan,
-                  text: beforeText,
-                  style: Extensions.deepMerge(startSpan.style, diffStyle)));
-
-          if (afterText.isNotEmpty) {
-            children.insert(
-                1, Extensions.copySpanWith(base: startSpan, text: afterText));
-          }
-        }
-
-        /// The selection ends in the second child.
-        else if (endIndex - startIndex == 1) {
-          log.d(
-              "-------------------------------------------------END: CHILDREN: endIndex - startIndex == 1");
-          var endSpanText = endSpan.text;
-
-          var beforeText = endSpanText.substring(
-              0,
-              selection.extentOffset -
-                  Extensions.getOffsetInParent(span, endSpan));
-          var afterText = endSpanText.substring(beforeText.length);
-
-          children.remove(startSpan);
-          children.remove(endSpan);
-
-          children.insert(
-              0,
-              Extensions.copySpanWith(
-                  base: startSpan,
-                  style: Extensions.deepMerge(startSpan.style, diffStyle)));
-          children.insert(
-              1,
-              Extensions.copySpanWith(
-                  base: endSpan,
-                  text: beforeText,
-                  style: Extensions.deepMerge(endSpan.style, diffStyle)));
-
-          if (afterText.isNotEmpty) {
-            children.insert(
-                2, Extensions.copySpanWith(base: endSpan, text: afterText));
-          }
-        }
-
-        /// The selection ends in another child
-        else {
-          log.d(
-              "-------------------------------------------------END: CHILDREN: else");
-          var endSpanText = endSpan.text;
-
-          var beforeEndText = endSpanText.substring(
-              0,
-              selection.extentOffset -
-                  Extensions.getOffsetInParent(span, endSpan));
-          assert(beforeEndText.isNotEmpty);
-
-          var afterEndText = endSpanText.substring(beforeEndText.length);
-
-          var newChildren = [];
-          children.getRange(0, endIndex).forEach((span) => newChildren.add(
-              Extensions.copySpanWith(
-                  base: span,
-                  style: Extensions.deepMerge(span.style, diffStyle))));
-          newChildren.add(Extensions.copySpanWith(
-              base: endSpan,
-              text: beforeEndText,
-              style: Extensions.deepMerge(endSpan.style, diffStyle)));
-
-          if (afterEndText.isNotEmpty)
-            newChildren.add(
-                Extensions.copySpanWith(base: endSpan, text: afterEndText));
-
-          newChildren.addAll(children.getRange(endIndex + 1, children.length));
-
-          children = newChildren;
-        }
-
-        children.insert(
-            0,
-            new TextSpan(
-                text: rootTextInSelection,
-                style: Extensions.deepMerge(span.style, diffStyle)));
-
-        children = optimiseChildren(children);
-        newSpan = Extensions.copySpanWith(
-            base: span, text: rootTextBeforeSelection, children: children);
-      }
-    }
-
-    /// The selection is only in children.
-    else {
-      log.d("--------------------------------START: CHILDREN <> END: CHILDREN");
-
-      var startSpan = span.getSpanForPosition(selection.base);
-      var endSpan = span.getSpanForPosition(new TextPosition(
-          offset: selection.end - 1, affinity: selection.affinity));
-
-      var startIndex = children.indexOf(startSpan);
-      var endIndex = children.indexOf(endSpan);
-
-      /// Get the children before the selection if there are any.
-      var beforeChildren = [];
-      if (startIndex != 0) {
-        //
-        children
-            .getRange(0, startIndex)
-            .forEach((span) => beforeChildren.add(span));
-      }
-
-      /// Get the children after the selection if there are any.
-      var afterChildren = [];
-      if (endIndex != children.length - 1) {
-        children
-            .getRange(endIndex + 1, children.length)
-            .forEach((span) => afterChildren.add(span));
-      }
-
-      /// The selection is starts and ends in the same span.
-      if (startIndex == endIndex) {
-        log.d(
-            "-------------------------------------------------startIndex == endIndex");
-        var startSpanText = startSpan.text;
-
-        var beforeText = startSpanText.substring(
-            0,
-            selection.baseOffset -
-                Extensions.getOffsetInParent(span, startSpan));
-
-        var insideText = startSpanText.substring(beforeText.length,
-            beforeText.length + selection.extentOffset - selection.baseOffset);
-
-        var afterText =
-            startSpanText.substring(beforeText.length + insideText.length);
-
-        if (beforeText.isNotEmpty) {
-          beforeChildren
-              .add(Extensions.copySpanWith(base: startSpan, text: beforeText));
-        }
-
-        if (insideText.isNotEmpty) {
-          beforeChildren.add(Extensions.copySpanWith(
-              base: startSpan,
-              text: insideText,
-              style: Extensions.deepMerge(startSpan.style, diffStyle)));
-        }
-
-        if (afterText.isNotEmpty) {
-          beforeChildren
-              .add(Extensions.copySpanWith(base: startSpan, text: afterText));
-        }
-      }
-
-      /// The selection start in on span and ends in another one.
-      else {
-        log.d(
-            "-------------------------------------------------endIndex - startIndex == 1");
-        //start span
-        var startSpanText = startSpan.text;
-        var beforeStartText = startSpanText.substring(
-            0,
-            selection.baseOffset -
-                Extensions.getOffsetInParent(span, startSpan));
-        var afterStartText = startSpanText.substring(beforeStartText.length);
-
-        //end span
-        var endSpanText = endSpan.text;
-        var beforeEndText = endSpanText.substring(
-            0,
-            selection.extentOffset -
-                Extensions.getOffsetInParent(span, endSpan));
-        var afterEndText = endSpanText.substring(beforeEndText.length);
-
-        if (beforeStartText.isNotEmpty) {
-          beforeChildren.add(
-              Extensions.copySpanWith(base: startSpan, text: beforeStartText));
-        }
-
-        beforeChildren.add(Extensions.copySpanWith(
-            base: startSpan,
-            text: afterStartText,
-            style: Extensions.deepMerge(startSpan.style, diffStyle)));
-
-        if (endIndex - startIndex > 1) {
-          children.getRange(startIndex + 1, endIndex).forEach((span) =>
-              beforeChildren.add(Extensions.copySpanWith(
-                  base: span,
-                  style: Extensions.deepMerge(span.style, diffStyle))));
-        }
-
-        beforeChildren.add(Extensions.copySpanWith(
-            base: endSpan,
-            text: beforeEndText,
-            style: Extensions.deepMerge(endSpan.style, diffStyle)));
-        if (afterEndText.isNotEmpty) {
-          beforeChildren
-              .add(Extensions.copySpanWith(base: endSpan, text: afterEndText));
-        }
-      }
-
-      beforeChildren.addAll(afterChildren);
-      beforeChildren = optimiseChildren(beforeChildren);
-      newSpan = Extensions.copySpanWith(base: span, children: beforeChildren);
-    }
-
-    return newSpan;
-  }
-
-  /// Return an optimized list of children where [TextSpan]s that are next to
-  /// each other and have the same [TextStyle] are merged.
-  static List<TextSpan> optimiseChildren(List<TextSpan> children) {
-    if (children == null || children.isEmpty) return children;
-    var newChildren = [];
-
-    for (int i = 0; i < children.length; i++) {
-      var span = children[i];
-      if (i == 0) {
-        newChildren.add(span);
-        continue;
-      }
-
-      var previousSpan = children[i - 1];
-
-      if (span.style == previousSpan.style) {
-        TextSpan lastSpanInNewChildren = newChildren.last;
-        newChildren[newChildren.length - 1] = Extensions.copySpanWith(
-          base: previousSpan,
-          text: lastSpanInNewChildren.text + span.text,
-        );
-      } else
-        newChildren.add(span);
-    }
-
-    return newChildren;
-  }
-
-  static bool _equalTextValue(RichTextEditingValue a, RichTextEditingValue b) {
-    return a.value.toPlainText() == b.value.toPlainText() &&
-        a.selection == b.selection &&
-        a.composing == b.composing;
-  }
-
-  static bool _sameTextDiffSelection(
-      RichTextEditingValue a, RichTextEditingValue b) {
-    return a.value.toPlainText() == b.value.toPlainText() &&
-        (a.selection != b.selection || a.composing != b.composing);
-  }
-}
\ No newline at end of file
diff --git a/lib/ui/rich_editor/services/rich_text_parser.dart b/lib/ui/rich_editor/services/rich_text_parser.dart
deleted file mode 100644
index d9e18859..00000000
--- a/lib/ui/rich_editor/services/rich_text_parser.dart
+++ /dev/null
@@ -1,950 +0,0 @@
-import 'dart:math';
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/services.dart';
-import 'package:flutter/widgets.dart';
-import 'package:kalium_wallet_flutter/styles.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/text_input.dart';
-
-class Log {
-  Log(String something);
-
-  void d(var s) {
-    return;
-  }
-
-  void w(var s) { }
-
-  void e(var s) { }
-}
-
-class RichTextEditingValueParser {
-  static final Log log = new Log("RichTextEditingValueParser");
-
-  static RichTextEditingValue parse(
-      {@required RichTextEditingValue oldValue,
-      @required RichTextEditingValue newValue,
-      @required TextStyle style}) {
-    if (_equalTextValue(oldValue, newValue)) {
-      log.d(
-          "Same text value and same selection and composing. We are not changing anything.");
-      return oldValue;
-    } else if (_sameTextDiffSelection(oldValue, newValue)) {
-      log.d(
-          "Same text, but different selection or composing. Update only that.");
-      return newValue.copyWith(value: oldValue.value);
-    }
-
-    TextSpan currentSpan = oldValue.value;
-    final TextSelection currentSelection = oldValue.selection;
-    final TextSelection newSelection = newValue.selection;
-
-    // Remove children from currentSpan for our purposes
-    currentSpan = TextSpan(text: oldValue.text, style: KaliumStyles.TextStyleAddressText60);
-
-    log.d("Current span has children: ${currentSpan.children != null}");
-
-    /// If the root [TextSpan] doesn't have any children we can simply set the
-    /// root text to the new value.
-    ///
-    /// Otherwise we look to the span that changed.
-    if (currentSpan.children == null) {
-      log.d("The style is the same: ${currentSpan.style == style}");
-
-      /// If the user didn't changed the default [TextStyle] we update the root
-      /// text value with the new value. Also if the user DID changed the
-      /// [style] but is deleting, we just set the new value.
-      ///
-      /// Otherwise we create a new [TextSpan] with the added text
-      if (currentSpan.style == style // no change in style, no need to update
-              ||
-              currentSelection.baseOffset >
-                  newSelection.baseOffset // text was deleted, no need to update
-          ) {
-        log.d("The user did change the default style or has deleted text.");
-      } else {
-        var text = newValue.text
-            .substring(currentSelection.baseOffset, newSelection.baseOffset);
-
-        /// If the insert position, indicated by [currentSelection.baseOffset]
-        /// is contained in the text of the root [TextSpan], we recreate the
-        /// root with the first part of the root text, and the below children:
-        ///
-        /// [1]: a new [TextSpan] with the text added by the user and the
-        /// [style];
-        ///
-        /// [2]: another [TextSpan] with the last part of root text, but keeping
-        /// the  same style as the root.
-        if (currentSpan.text.length > currentSelection.baseOffset) {
-          var textBefore = currentSelection.textBefore(currentSpan.text);
-          var textAfter = currentSelection.textAfter(currentSpan.text);
-
-          log.d("A new child was added at ${textBefore.isEmpty
-              ? "start"
-              : "middle"}.");
-
-          if (textBefore.isEmpty) {
-            newValue = newValue.copyWith(
-              value: new TextSpan(
-                text: "",
-                style: currentSpan.style,
-                children: [
-                  new TextSpan(
-                    text: text,
-                    style: style,
-                  ),
-                  new TextSpan(
-                    text: textAfter,
-                    style: currentSpan.style,
-                  ),
-                ],
-              ),
-            );
-          } else {
-            newValue = newValue.copyWith(
-              value: new TextSpan(
-                text: textBefore,
-                style: currentSpan.style,
-                children: [
-                  new TextSpan(
-                    text: text,
-                    style: style,
-                  ),
-                  new TextSpan(
-                    text: textAfter,
-                    style: currentSpan.style,
-                  ),
-                ],
-              ),
-            );
-          }
-        } else {
-          log.d("A new child was added at end.");
-          newValue = newValue.copyWith(
-            value: new TextSpan(
-              style: currentSpan.style,
-              text: currentSpan.text,
-              children: [
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-              ],
-            ),
-          );
-        }
-      }
-    } else {
-      /// Something was added
-      if (currentSelection.baseOffset < newSelection.baseOffset) {
-        log.d("The user added some text.");
-
-        String oldPlainText = currentSpan.toPlainText();
-
-        /// If the insert position, indicated by [currentSelection.start] is
-        /// contained in the [text] of the root [TextSpan], just update the text
-        /// of the root element.
-        if (currentSpan.text.length >= currentSelection.start) {
-          log.d(
-              "----------------------------------------------ADD TO ROOT TEXT");
-          var text = newValue.text
-              .substring(currentSelection.start, newSelection.start);
-
-          var textBefore = currentSelection.textBefore(currentSpan.text);
-          var textAfter = currentSelection.textAfter(currentSpan.text);
-
-          if (currentSpan.style == style) {
-            log.d("same style");
-
-            newValue = newValue.copyWith(
-              value: Extensions.copySpanWith(
-                base: currentSpan,
-                text: textBefore + text + textAfter,
-              ),
-            );
-          } else {
-            log.d("different style");
-
-            if (textBefore.isEmpty) {
-              log.d("start");
-              List<TextSpan> children = [
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-                new TextSpan(
-                  text: currentSpan.text,
-                  style: currentSpan.style,
-                ),
-              ];
-
-              children.addAll(currentSpan.children);
-
-              newValue = newValue.copyWith(
-                value: new TextSpan(
-                  text: "",
-                  style: currentSpan.style,
-                  children: children,
-                ),
-              );
-            } else if (textAfter.isEmpty) {
-              log.d("end");
-
-              List<TextSpan> children = currentSpan.children.toList();
-              children.insert(
-                0,
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-              );
-
-              newValue = newValue.copyWith(
-                  value: Extensions.copySpanWith(
-                      base: currentSpan, children: children));
-            } else {
-              log.d("middle");
-
-              List<TextSpan> children = [
-                new TextSpan(
-                  text: text,
-                  style: style,
-                ),
-                new TextSpan(
-                  text: textAfter,
-                  style: currentSpan.style,
-                ),
-              ];
-
-              children.addAll(currentSpan.children);
-
-              newValue = newValue.copyWith(
-                value: new TextSpan(
-                  text: textBefore,
-                  style: currentSpan.style,
-                  children: children,
-                ),
-              );
-            }
-          }
-        }
-
-        /// If the insert position is in one of the children then we retrieve
-        /// that child and find its start and end position in the parent. Then
-        /// we update the text of that [TextSpan] with the new value.
-        else if (oldPlainText.length >= currentSelection.start) {
-          log.d(
-              "-----------------------------------------------ADD TO CHILDREN");
-          var text = newValue.text
-              .substring(currentSelection.start, newSelection.start);
-          List<TextSpan> children = currentSpan.children.toList();
-          TextSpan affectedSpan = Extensions.getSpanForPosition(
-              currentSpan, currentSelection.baseOffset);
-
-          log.d(affectedSpan);
-          var index = children.indexOf(affectedSpan);
-
-          TextSpan root;
-          //last span
-          if (index == children.length - 1) {
-            var index = children.indexOf(affectedSpan);
-            children.removeAt(index);
-
-            var affectedSpanStart =
-                Extensions.getOffsetInParent(currentSpan, affectedSpan);
-
-            String textBefore = oldPlainText.substring(
-                affectedSpanStart, currentSelection.base.offset);
-
-            String textAfter =
-                oldPlainText.substring(currentSelection.base.offset);
-
-            if (affectedSpan.style == style) {
-              log.d(
-                  "----------------------------------------------------SAME STYLE");
-              affectedSpan = Extensions.copySpanWith(
-                  base: affectedSpan, text: textBefore + text + textAfter);
-
-              children.add(affectedSpan);
-            } else {
-              log.d(
-                  "-----------------------------------------------DIFFERENT STYLE");
-              if (textBefore.isEmpty) {
-                log.d("start");
-                children.add(new TextSpan(
-                  text: text,
-                  style: style,
-                ));
-                children.add(affectedSpan);
-              } else if (textAfter.isEmpty) {
-                log.d("end");
-                children.add(affectedSpan);
-                children.add(new TextSpan(
-                  text: text,
-                  style: style,
-                ));
-              } else {
-                log.d("middle");
-                children.add(new TextSpan(
-                  text: textBefore,
-                  style: affectedSpan.style,
-                ));
-                children.add(new TextSpan(
-                  text: text,
-                  style: style,
-                ));
-                children.add(new TextSpan(
-                  text: textAfter,
-                  style: affectedSpan.style,
-                ));
-              }
-            }
-
-            root = Extensions.copySpanWith(
-              base: currentSpan,
-              children: children,
-            );
-          } else {
-            var index = children.indexOf(affectedSpan);
-            children.removeAt(index);
-
-            var affectedSpanStart =
-                Extensions.getOffsetInParent(currentSpan, affectedSpan);
-
-            var affectedSpanEnd = affectedSpanStart + affectedSpan.text.length;
-
-            String textBefore = oldPlainText.substring(
-                affectedSpanStart, currentSelection.base.offset);
-
-            String textAfter = oldPlainText.substring(
-                currentSelection.base.offset, affectedSpanEnd);
-
-            if (affectedSpan.style == style) {
-              log.d(
-                  "----------------------------------------------------SAME STYLE");
-              affectedSpan = Extensions.copySpanWith(
-                  base: affectedSpan, text: textBefore + text + textAfter);
-
-              children.insert(index, affectedSpan);
-            } else {
-              log.d(
-                  "-----------------------------------------------DIFFERENT STYLE");
-              if (textBefore.isEmpty) {
-                assert(false);
-                log.d("start");
-                children.insert(
-                    index,
-                    new TextSpan(
-                      text: text,
-                      style: style,
-                    ));
-                children.insert(index + 1, affectedSpan);
-              } else if (textAfter.isEmpty) {
-                log.d("end");
-                children.insert(index, affectedSpan);
-
-                TextSpan nextSpan = children[index + 1];
-
-                if (nextSpan.style == style) {
-                  log.d(
-                      "----------------------------------------------------SAME STYLE");
-                  children.removeAt(index + 1);
-                  children.insert(
-                      index + 1,
-                      Extensions.copySpanWith(
-                        base: nextSpan,
-                        text: text + nextSpan.text,
-                      ));
-                } else {
-                  log.d(
-                      "-----------------------------------------------DIFFERENT STYLE");
-                  children.removeAt(index + 1);
-
-                  var nextSpanStart =
-                      Extensions.getOffsetInParent(currentSpan, nextSpan);
-
-                  var nextSpanEnd = nextSpanStart + nextSpan.text.length;
-
-                  String textBefore = oldPlainText.substring(
-                      nextSpanStart, currentSelection.base.offset);
-
-                  String textAfter = oldPlainText.substring(
-                      currentSelection.base.offset, nextSpanEnd);
-
-                  if (textBefore.isEmpty) {
-                    log.d("start");
-                    children.insert(
-                        index + 1,
-                        new TextSpan(
-                          text: text,
-                          style: style,
-                        ));
-                    children.insert(index + 2, nextSpan);
-                  } else if (textAfter.isEmpty) {
-                    log.d("end");
-                    children.insert(index + 1, nextSpan);
-                    children.insert(
-                        index + 2,
-                        new TextSpan(
-                          text: text,
-                          style: style,
-                        ));
-                  } else {
-                    log.d("middle");
-                    children.insert(
-                        index + 1,
-                        new TextSpan(
-                          text: textBefore,
-                          style: nextSpan.style,
-                        ));
-                    children.insert(
-                        index + 2,
-                        new TextSpan(
-                          text: text,
-                          style: style,
-                        ));
-                    children.insert(
-                        index + 3,
-                        new TextSpan(
-                          text: textAfter,
-                          style: nextSpan.style,
-                        ));
-                  }
-                }
-              } else {
-                log.d("middle");
-                children.insert(
-                    index,
-                    new TextSpan(
-                      text: textBefore,
-                      style: affectedSpan.style,
-                    ));
-                children.insert(
-                    index + 1,
-                    new TextSpan(
-                      text: text,
-                      style: style,
-                    ));
-                children.insert(
-                    index + 2,
-                    new TextSpan(
-                      text: textAfter,
-                      style: affectedSpan.style,
-                    ));
-              }
-            }
-
-            root = Extensions.copySpanWith(
-              base: currentSpan,
-              children: children,
-            );
-          }
-
-          newValue = newValue.copyWith(value: root);
-        }
-      }
-
-      /// Something was deleted
-      else {
-        if (currentSpan.text.length >= currentSelection.start &&
-            currentSelection.isCollapsed) {
-          log.d(
-              "-----------------------------------------DELETE FROM ROOT TEXT");
-          var text = currentSpan.text.substring(0, newSelection.extentOffset) +
-              currentSpan.text.substring(oldValue.selection.extentOffset);
-
-          newValue = newValue.copyWith(
-            value: Extensions.copySpanWith(
-              base: currentSpan,
-              text: text,
-            ),
-          );
-        } else {
-          log.d(
-              "------------------------------------------DELETE FROM CHILDREN");
-          List<TextSpan> children = currentSpan.children.toList();
-
-          var isCollapsed = currentSelection.start - newSelection.start == 1 &&
-              currentSelection.isCollapsed;
-          var rootText = currentSpan.text;
-
-          if (isCollapsed) {
-            log.d("------------------------------------------IS COLAPSED");
-            // This is the text.
-            // This is th text.
-
-            // This is the text.
-            // This is te text.
-
-            TextSpan affectedSpan = Extensions.getSpanForPosition(
-                currentSpan, currentSelection.start);
-
-            int index = children.indexOf(affectedSpan);
-            children.removeAt(index);
-
-            if (affectedSpan.text.length == 1) {
-              affectedSpan = null;
-            } else {
-              var start = currentSelection.start -
-                  Extensions.getOffsetInParent(currentSpan, affectedSpan);
-
-              var textBefore = affectedSpan.text.substring(0, start - 1);
-              var textAfter = affectedSpan.text.substring(start);
-
-              affectedSpan = Extensions.copySpanWith(
-                base: affectedSpan,
-                text: textBefore + textAfter,
-              );
-            }
-
-            if (affectedSpan != null) children.insert(index, affectedSpan);
-          } else {
-            log.d("------------------------------------------IS NOT COLAPSED");
-            //
-            // This is the text.
-            // This is  text.                        => fast delete by keyboard
-
-            // This is the text.
-            // This is text.
-
-            var selection = currentSelection;
-            if (currentSelection.start - newSelection.start != 1) {
-              //fast delete by keyboard
-              selection = new TextSelection(
-                baseOffset: newSelection.start,
-                extentOffset: currentSelection.end,
-                affinity: currentSelection.affinity,
-              );
-            }
-
-            TextSpan startSpan =
-                Extensions.getSpanForPosition(currentSpan, selection.start);
-            TextSpan endSpan =
-                Extensions.getSpanForPosition(currentSpan, selection.end);
-
-            if (startSpan == currentSpan) {
-              //delete from root too
-              rootText = rootText.substring(0, newSelection.start);
-              int index = children.indexOf(endSpan);
-              children.removeRange(0, index + 1);
-
-              var span = _deleteSelectionRange(
-                  parent: currentSpan, span: endSpan, selection: selection);
-
-              if (span != null) children.insert(0, span);
-            } else if (startSpan == endSpan) {
-              int index = children.indexOf(startSpan);
-              children.removeAt(index);
-
-              var span = _deleteSelectionRange(
-                  parent: currentSpan, span: startSpan, selection: selection);
-
-              if (span != null) children.insert(index, span);
-            } else {
-              int startIndex = children.indexOf(startSpan);
-              int endIndex = children.indexOf(endSpan);
-              children.removeRange(startIndex, endIndex + 1);
-
-              startSpan = _deleteSelectionRange(
-                  parent: currentSpan, span: startSpan, selection: selection);
-
-              endSpan = _deleteSelectionRange(
-                  parent: currentSpan, span: endSpan, selection: selection);
-
-              if (startSpan != null && endSpan != null) {
-                children.insert(startIndex, startSpan);
-                children.insert(startIndex + 1, endSpan);
-              } else
-                children.insert(
-                    startIndex, startSpan == null ? endSpan : startSpan);
-            }
-          }
-
-          if (children.isEmpty) children = null;
-
-          newValue = newValue.copyWith(
-            value: new TextSpan(
-              text: rootText,
-              style: currentSpan.style,
-              recognizer: currentSpan.recognizer,
-              children: children,
-            ),
-          );
-        }
-      }
-    }
-
-    newValue = newValue.copyWith(
-      value: Extensions.copySpanWith(
-        base: newValue.value,
-        children: optimiseChildren(newValue.value.children),
-      ),
-    );
-
-    log.d(newValue.value.toPlainText());
-    return newValue;
-  }
-
-  static TextSpan _deleteSelectionRange({
-    @required TextSpan parent,
-    @required TextSpan span,
-    @required TextSelection selection,
-  }) {
-    try {
-      if (span.text.length == 1)
-        return null;
-      else {
-        int offsetInParent = Extensions.getOffsetInParent(parent, span);
-        int spanLength = span.text.length;
-
-        String text;
-
-        if (selection.start - offsetInParent < 0) {
-          int start = selection.end - offsetInParent;
-          text = span.text.substring(start);
-        } else {
-          int start = selection.start - offsetInParent;
-          int end = min(selection.end - offsetInParent, spanLength);
-
-          String textBefore = span.text.substring(0, start);
-          String textAfter = span.text.substring(end);
-
-          text = textBefore + textAfter;
-        }
-
-        return Extensions.copySpanWith(
-          base: span,
-          text: text,
-        );
-      }
-    } catch (e) {
-      log.e(e);
-      log.d(span);
-      return null;
-    }
-  }
-
-  static TextSpan updateSpansWithStyle(TextSpan span, TextSelection selection,
-      TextStyle currentStyle, TextStyle newStyle) {
-    if (newStyle == Extensions.emptyStyle) {
-      log.w("The new style is empty. We are not touching anything!");
-      return span;
-    }
-
-    List<TextSpan> children = [];
-
-    if (span.children != null) {
-      /// We need a copy of the children list to avoid changing the
-      /// [oldValue] content. <b>Remove this and see what happens. :D</b>
-      span.children.forEach((it) => children.add(it));
-    }
-
-    var newSpan = span;
-    var rootTextLength = span.text.length;
-    TextStyle diffStyle = Extensions.getDifferenceStyle(currentStyle, newStyle);
-
-    /// The selection include the root text.
-    if (rootTextLength > selection.baseOffset) {
-      log.d("----------------------------------------------START: ROOT TEXT");
-
-      /// The selection ends in the root text.
-      if (rootTextLength >= selection.extentOffset) {
-        log.d("-----------------------------------------END: ROOT TEXT");
-
-        var beforeText = selection.textBefore(span.text);
-        var insideText = selection.textInside(span.text);
-
-        children.insert(
-            0,
-            new TextSpan(
-                text: insideText,
-                style: Extensions.deepMerge(span.style, diffStyle)));
-
-        if (rootTextLength != selection.extentOffset) {
-          var afterText = selection.textAfter(span.text);
-          children.insert(1, new TextSpan(text: afterText, style: span.style));
-        }
-
-        newSpan = Extensions.copySpanWith(
-            base: span, text: beforeText, children: children);
-      }
-
-      /// The selection ends in one of the children.
-      else {
-        assert(children.isNotEmpty);
-
-        //handle root text
-        var rootTextBeforeSelection = selection.textBefore(span.text);
-        var rootTextInSelection = span.text.substring(selection.baseOffset);
-
-        //handle children
-        var startSpan = span.getSpanForPosition(new TextPosition(
-            offset: span.text.length, affinity: selection.affinity));
-
-        var endSpan = span.getSpanForPosition(selection.extent);
-
-        var startIndex = children.indexOf(startSpan); //must be 0
-        var endIndex = children.indexOf(endSpan);
-
-        /// The selection ends in the first child.
-        if (startIndex == endIndex) {
-          log.d(
-              "-------------------------------------------------END: CHILDREN: startIndex == endIndex");
-
-          var startSpanText = startSpan.text;
-
-          var beforeText = startSpanText.substring(
-              0, selection.extentOffset - span.text.length);
-          var afterText = startSpanText.substring(beforeText.length);
-
-          children.remove(startSpan);
-          children.insert(
-              0,
-              Extensions.copySpanWith(
-                  base: startSpan,
-                  text: beforeText,
-                  style: Extensions.deepMerge(startSpan.style, diffStyle)));
-
-          if (afterText.isNotEmpty) {
-            children.insert(
-                1, Extensions.copySpanWith(base: startSpan, text: afterText));
-          }
-        }
-
-        /// The selection ends in the second child.
-        else if (endIndex - startIndex == 1) {
-          log.d(
-              "-------------------------------------------------END: CHILDREN: endIndex - startIndex == 1");
-          var endSpanText = endSpan.text;
-
-          var beforeText = endSpanText.substring(
-              0,
-              selection.extentOffset -
-                  Extensions.getOffsetInParent(span, endSpan));
-          var afterText = endSpanText.substring(beforeText.length);
-
-          children.remove(startSpan);
-          children.remove(endSpan);
-
-          children.insert(
-              0,
-              Extensions.copySpanWith(
-                  base: startSpan,
-                  style: Extensions.deepMerge(startSpan.style, diffStyle)));
-          children.insert(
-              1,
-              Extensions.copySpanWith(
-                  base: endSpan,
-                  text: beforeText,
-                  style: Extensions.deepMerge(endSpan.style, diffStyle)));
-
-          if (afterText.isNotEmpty) {
-            children.insert(
-                2, Extensions.copySpanWith(base: endSpan, text: afterText));
-          }
-        }
-
-        /// The selection ends in another child
-        else {
-          log.d(
-              "-------------------------------------------------END: CHILDREN: else");
-          var endSpanText = endSpan.text;
-
-          var beforeEndText = endSpanText.substring(
-              0,
-              selection.extentOffset -
-                  Extensions.getOffsetInParent(span, endSpan));
-          assert(beforeEndText.isNotEmpty);
-
-          var afterEndText = endSpanText.substring(beforeEndText.length);
-
-          var newChildren = [];
-          children.getRange(0, endIndex).forEach((span) => newChildren.add(
-              Extensions.copySpanWith(
-                  base: span,
-                  style: Extensions.deepMerge(span.style, diffStyle))));
-          newChildren.add(Extensions.copySpanWith(
-              base: endSpan,
-              text: beforeEndText,
-              style: Extensions.deepMerge(endSpan.style, diffStyle)));
-
-          if (afterEndText.isNotEmpty)
-            newChildren.add(
-                Extensions.copySpanWith(base: endSpan, text: afterEndText));
-
-          newChildren.addAll(children.getRange(endIndex + 1, children.length));
-
-          children = newChildren;
-        }
-
-        children.insert(
-            0,
-            new TextSpan(
-                text: rootTextInSelection,
-                style: Extensions.deepMerge(span.style, diffStyle)));
-
-        children = optimiseChildren(children);
-        newSpan = Extensions.copySpanWith(
-            base: span, text: rootTextBeforeSelection, children: children);
-      }
-    }
-
-    /// The selection is only in children.
-    else {
-      log.d("--------------------------------START: CHILDREN <> END: CHILDREN");
-
-      var startSpan = span.getSpanForPosition(selection.base);
-      var endSpan = span.getSpanForPosition(new TextPosition(
-          offset: selection.end - 1, affinity: selection.affinity));
-
-      var startIndex = children.indexOf(startSpan);
-      var endIndex = children.indexOf(endSpan);
-
-      /// Get the children before the selection if there are any.
-      var beforeChildren = [];
-      if (startIndex != 0) {
-        //
-        children
-            .getRange(0, startIndex)
-            .forEach((span) => beforeChildren.add(span));
-      }
-
-      /// Get the children after the selection if there are any.
-      var afterChildren = [];
-      if (endIndex != children.length - 1) {
-        children
-            .getRange(endIndex + 1, children.length)
-            .forEach((span) => afterChildren.add(span));
-      }
-
-      /// The selection is starts and ends in the same span.
-      if (startIndex == endIndex) {
-        log.d(
-            "-------------------------------------------------startIndex == endIndex");
-        var startSpanText = startSpan.text;
-
-        var beforeText = startSpanText.substring(
-            0,
-            selection.baseOffset -
-                Extensions.getOffsetInParent(span, startSpan));
-
-        var insideText = startSpanText.substring(beforeText.length,
-            beforeText.length + selection.extentOffset - selection.baseOffset);
-
-        var afterText =
-            startSpanText.substring(beforeText.length + insideText.length);
-
-        if (beforeText.isNotEmpty) {
-          beforeChildren
-              .add(Extensions.copySpanWith(base: startSpan, text: beforeText));
-        }
-
-        if (insideText.isNotEmpty) {
-          beforeChildren.add(Extensions.copySpanWith(
-              base: startSpan,
-              text: insideText,
-              style: Extensions.deepMerge(startSpan.style, diffStyle)));
-        }
-
-        if (afterText.isNotEmpty) {
-          beforeChildren
-              .add(Extensions.copySpanWith(base: startSpan, text: afterText));
-        }
-      }
-
-      /// The selection start in on span and ends in another one.
-      else {
-        log.d(
-            "-------------------------------------------------endIndex - startIndex == 1");
-        //start span
-        var startSpanText = startSpan.text;
-        var beforeStartText = startSpanText.substring(
-            0,
-            selection.baseOffset -
-                Extensions.getOffsetInParent(span, startSpan));
-        var afterStartText = startSpanText.substring(beforeStartText.length);
-
-        //end span
-        var endSpanText = endSpan.text;
-        var beforeEndText = endSpanText.substring(
-            0,
-            selection.extentOffset -
-                Extensions.getOffsetInParent(span, endSpan));
-        var afterEndText = endSpanText.substring(beforeEndText.length);
-
-        if (beforeStartText.isNotEmpty) {
-          beforeChildren.add(
-              Extensions.copySpanWith(base: startSpan, text: beforeStartText));
-        }
-
-        beforeChildren.add(Extensions.copySpanWith(
-            base: startSpan,
-            text: afterStartText,
-            style: Extensions.deepMerge(startSpan.style, diffStyle)));
-
-        if (endIndex - startIndex > 1) {
-          children.getRange(startIndex + 1, endIndex).forEach((span) =>
-              beforeChildren.add(Extensions.copySpanWith(
-                  base: span,
-                  style: Extensions.deepMerge(span.style, diffStyle))));
-        }
-
-        beforeChildren.add(Extensions.copySpanWith(
-            base: endSpan,
-            text: beforeEndText,
-            style: Extensions.deepMerge(endSpan.style, diffStyle)));
-        if (afterEndText.isNotEmpty) {
-          beforeChildren
-              .add(Extensions.copySpanWith(base: endSpan, text: afterEndText));
-        }
-      }
-
-      beforeChildren.addAll(afterChildren);
-      beforeChildren = optimiseChildren(beforeChildren);
-      newSpan = Extensions.copySpanWith(base: span, children: beforeChildren);
-    }
-
-    return newSpan;
-  }
-
-  /// Return an optimized list of children where [TextSpan]s that are next to
-  /// each other and have the same [TextStyle] are merged.
-  static List<TextSpan> optimiseChildren(List<TextSpan> children) {
-    if (children == null || children.isEmpty) return children;
-    var newChildren = [];
-
-    for (int i = 0; i < children.length; i++) {
-      var span = children[i];
-      if (i == 0) {
-        newChildren.add(span);
-        continue;
-      }
-
-      var previousSpan = children[i - 1];
-
-      if (span.style == previousSpan.style) {
-        TextSpan lastSpanInNewChildren = newChildren.last;
-        newChildren[newChildren.length - 1] = Extensions.copySpanWith(
-          base: previousSpan,
-          text: lastSpanInNewChildren.text + span.text,
-        );
-      } else
-        newChildren.add(span);
-    }
-
-    return newChildren;
-  }
-
-  static bool _equalTextValue(RichTextEditingValue a, RichTextEditingValue b) {
-    return a.value.toPlainText() == b.value.toPlainText() &&
-        a.selection == b.selection &&
-        a.composing == b.composing;
-  }
-
-  static bool _sameTextDiffSelection(
-      RichTextEditingValue a, RichTextEditingValue b) {
-    return a.value.toPlainText() == b.value.toPlainText() &&
-        (a.selection != b.selection || a.composing != b.composing);
-  }
-}
diff --git a/lib/ui/rich_editor/services/text_input.dart b/lib/ui/rich_editor/services/text_input.dart
deleted file mode 100644
index d791e4ef..00000000
--- a/lib/ui/rich_editor/services/text_input.dart
+++ /dev/null
@@ -1,361 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:async';
-import 'dart:ui' show TextAffinity, hashValues;
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/painting.dart';
-import 'package:flutter/services.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/rich_text_parser.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/rich_editable_text.dart';
-
-export 'dart:ui' show TextAffinity;
-
-TextAffinity _toTextAffinity(String affinity) {
-  switch (affinity) {
-    case 'TextAffinity.downstream':
-      return TextAffinity.downstream;
-    case 'TextAffinity.upstream':
-      return TextAffinity.upstream;
-  }
-  return null;
-}
-
-/// The current text, selection, and composing state for editing a run of text.
-@immutable
-class RichTextEditingValue extends AbstractTextEditingValue<TextSpan> {
-  /// Creates information for editing a run of text.
-  ///
-  /// The selection and composing range must be within the text.
-  ///
-  /// The [value], [selection], and [composing] arguments must not be null but
-  /// each have default values.
-  const RichTextEditingValue(
-      {this.value: const TextSpan(text: "", style: StyleController.material),
-      this.selection: const TextSelection.collapsed(offset: -1),
-      this.composing: TextRange.empty})
-      : assert(value != null),
-        assert(selection != null),
-        assert(composing != null);
-
-  /// Creates an instance of this class from a JSON object.
-  factory RichTextEditingValue.fromJSON(
-      Map<String, dynamic> encoded, TextStyle style) {
-    return new RichTextEditingValue(
-      value: new TextSpan(text: encoded['text'], style: style),
-      selection: new TextSelection(
-        baseOffset: encoded['selectionBase'] ?? -1,
-        extentOffset: encoded['selectionExtent'] ?? -1,
-        affinity: _toTextAffinity(encoded['selectionAffinity']) ??
-            TextAffinity.downstream,
-        isDirectional: encoded['selectionIsDirectional'] ?? false,
-      ),
-      composing: new TextRange(
-        start: encoded['composingBase'] ?? -1,
-        end: encoded['composingExtent'] ?? -1,
-      ),
-    );
-  }
-
-  /// The current text being edited.
-  final TextSpan value;
-
-  /// The range of text that is currently selected.
-  final TextSelection selection;
-
-  /// The range of text that is still being composed.
-  final TextRange composing;
-
-  /// A value that corresponds to the empty string with no selection and no composing range.
-  static const RichTextEditingValue empty = const RichTextEditingValue();
-
-  /// Creates a copy of this value but with the given fields replaced with the new values.
-  @override
-  AbstractTextEditingValue copyWith(
-      {TextSpan value, TextSelection selection, TextRange composing}) {
-    return new RichTextEditingValue(
-        value: value ?? this.value,
-        selection: selection ?? this.selection,
-        composing: composing ?? this.composing);
-  }
-
-  @override
-  String getSelectedText() => selection.textInside(value.toPlainText());
-
-  @override
-  TextSpan getUnselectedText() {
-    String plainText = value.toPlainText();
-
-    String newText =
-        selection.textBefore(plainText) + selection.textAfter(plainText);
-
-    return RichTextEditingValueParser
-        .parse(
-          oldValue: this,
-          newValue: copyWith(value: new TextSpan(text: newText)),
-          style: null,
-        )
-        .value;
-  }
-
-  @override
-  AbstractTextEditingValue insert(String text) {
-    String plainText = value.toPlainText();
-
-    String newText =
-        selection.textBefore(plainText) + text + selection.textAfter(plainText);
-
-    print(newText);
-    return RichTextEditingValueParser.parse(
-      oldValue: this,
-      newValue: copyWith(value: new TextSpan(text: newText)),
-      style: null,
-    );
-  }
-
-  @override
-  int get length => Extensions.length(value);
-
-  @override
-  bool get isNotEmpty => Extensions.isNotEmpty(value);
-
-  @override
-  String get text => value.toPlainText();
-
-  @override
-  String toString() =>
-      '$runtimeType(textSpan: \u2524$value\u251C, selection: $selection, composing: $composing)';
-
-  @override
-  bool operator ==(dynamic other) {
-    if (identical(this, other)) return true;
-    if (other is! RichTextEditingValue) return false;
-    final RichTextEditingValue typedOther = other;
-    return typedOther.value == value &&
-        typedOther.selection == selection &&
-        typedOther.composing == composing;
-  }
-
-  @override
-  int get hashCode =>
-      hashValues(value.hashCode, selection.hashCode, composing.hashCode);
-}
-
-abstract class AbstractTextEditingValue<Value> {
-  const AbstractTextEditingValue({this.value, this.selection, this.composing});
-
-  /// Creates a copy of this value but with the given fields replaced with the new values.
-  AbstractTextEditingValue copyWith(
-      {Value value, TextSelection selection, TextRange composing});
-
-  /// Returns a representation of this object as a JSON object.
-  Map<String, dynamic> toJSON() {
-    return <String, dynamic>{
-      'text': text,
-      'selectionBase': selection.baseOffset,
-      'selectionExtent': selection.extentOffset,
-      'selectionAffinity': selection.affinity.toString(),
-      'selectionIsDirectional': selection.isDirectional,
-      'composingBase': composing.start,
-      'composingExtent': composing.end,
-    };
-  }
-
-  /// The current text being edited.
-  final Value value;
-
-  /// The range of text that is currently selected.
-  final TextSelection selection;
-
-  /// The range of text that is still being composed.
-  final TextRange composing;
-
-  String getSelectedText();
-
-  Value getUnselectedText();
-
-  AbstractTextEditingValue insert(String text);
-
-  int get length;
-
-  bool get isNotEmpty;
-
-  String get text;
-
-  @override
-  String toString() =>
-      '$runtimeType(value: \u2524$value\u251C, selection: $selection, composing: $composing)';
-
-  @override
-  bool operator ==(dynamic other) {
-    if (identical(this, other)) return true;
-    if (other is! Value) return false;
-    final AbstractTextEditingValue typedOther = other;
-    return typedOther.value == value &&
-        typedOther.selection == selection &&
-        typedOther.composing == composing;
-  }
-
-  @override
-  int get hashCode =>
-      hashValues(value.hashCode, selection.hashCode, composing.hashCode);
-}
-
-/// An interface to receive information from [TextInput].
-///
-/// See also:
-///
-///  * [TextInput.attach]
-abstract class TextInputClient<T extends AbstractTextEditingValue> {
-  /// Abstract const constructor. This constructor enables subclasses to provide
-  /// const constructors so that they can be used in const expressions.
-  const TextInputClient();
-
-  /// Requests that this client update its editing state to the given value.
-  void updateEditingValue(T value);
-
-  /// Requests that this client perform the given action.
-  void performAction(TextInputAction action);
-
-  /// Return the concert implementation of this clients value/
-  T getValue(Map<String, dynamic> encoded);
-}
-
-/// A interface for interacting with a text input control.
-///
-/// See also:
-///
-///  * [TextInput.attach]
-class TextInputConnection {
-  final Log log = new Log("TextInputConnection");
-
-  TextInputConnection._(this._client)
-      : assert(_client != null),
-        _id = _nextId++;
-
-  static int _nextId = 1;
-  final int _id;
-
-  final TextInputClient _client;
-
-  /// Whether this connection is currently interacting with the text input control.
-  bool get attached => _clientHandler._currentConnection == this;
-
-  /// Requests that the text input control become visible.
-  void show() {
-    assert(attached);
-    SystemChannels.textInput.invokeMethod('TextInput.show');
-  }
-
-  /// Requests that the text input control change its internal state to match the given state.
-  void setEditingState(AbstractTextEditingValue value) {
-    log.d("setEditingState: ${value.toJSON()}");
-    assert(attached);
-    SystemChannels.textInput.invokeMethod(
-      'TextInput.setEditingState',
-      value.toJSON(),
-    );
-  }
-
-  /// Stop interacting with the text input control.
-  ///
-  /// After calling this method, the text input control might disappear if no
-  /// other client attaches to it within this animation frame.
-  void close() {
-    if (attached) {
-      SystemChannels.textInput.invokeMethod('TextInput.clearClient');
-      _clientHandler
-        .._currentConnection = null
-        .._scheduleHide();
-    }
-    assert(!attached);
-  }
-}
-
-TextInputAction _toTextInputAction(String action) {
-  switch (action) {
-    case 'TextInputAction.done':
-      return TextInputAction.done;
-    case 'TextInputAction.newline':
-      return TextInputAction.newline;
-  }
-  throw new FlutterError('Unknown text input action: $action');
-}
-
-class _TextInputClientHandler {
-  _TextInputClientHandler() {
-    SystemChannels.textInput.setMethodCallHandler(_handleTextInputInvocation);
-  }
-
-  TextInputConnection _currentConnection;
-
-  Future<dynamic> _handleTextInputInvocation(MethodCall methodCall) async {
-    if (_currentConnection == null) return;
-    final String method = methodCall.method;
-    final List<dynamic> args = methodCall.arguments;
-    final int client = args[0];
-    // The incoming message was for a different client.
-    if (client != _currentConnection._id) return;
-    switch (method) {
-      case 'TextInputClient.updateEditingState':
-        var value = _currentConnection._client.getValue(args[1]);
-        _currentConnection._client.updateEditingValue(value);
-        break;
-      case 'TextInputClient.performAction':
-        _currentConnection._client.performAction(_toTextInputAction(args[1]));
-        break;
-      default:
-        throw new MissingPluginException();
-    }
-  }
-
-  bool _hidePending = false;
-
-  void _scheduleHide() {
-    if (_hidePending) return;
-    _hidePending = true;
-
-    // Schedule a deferred task that hides the text input.  If someone else
-    // shows the keyboard during this update cycle, then the task will do
-    // nothing.
-    scheduleMicrotask(() {
-      _hidePending = false;
-      if (_currentConnection == null)
-        SystemChannels.textInput.invokeMethod('TextInput.hide');
-    });
-  }
-}
-
-final _TextInputClientHandler _clientHandler = new _TextInputClientHandler();
-
-/// An interface to the system's text input control.
-class TextInput {
-  TextInput._();
-
-  /// Begin interacting with the text input control.
-  ///
-  /// Calling this function helps multiple clients coordinate about which one is
-  /// currently interacting with the text input control. The returned
-  /// [TextInputConnection] provides an interface for actually interacting with
-  /// the text input control.
-  ///
-  /// A client that no longer wishes to interact with the text input control
-  /// should call [TextInputConnection.close] on the returned
-  /// [TextInputConnection].
-  static TextInputConnection attach(
-      TextInputClient client, TextInputConfiguration configuration) {
-    assert(client != null);
-    assert(configuration != null);
-    final TextInputConnection connection = new TextInputConnection._(client);
-    _clientHandler._currentConnection = connection;
-    SystemChannels.textInput.invokeMethod(
-      'TextInput.setClient',
-      <dynamic>[connection._id, configuration.toJson()],
-    );
-    return connection;
-  }
-}
diff --git a/lib/ui/rich_editor/text_input.dart b/lib/ui/rich_editor/text_input.dart
deleted file mode 100644
index ae40a878..00000000
--- a/lib/ui/rich_editor/text_input.dart
+++ /dev/null
@@ -1,361 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:async';
-import 'dart:ui' show TextAffinity, hashValues;
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/painting.dart';
-import 'package:flutter/services.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/rich_text_parser.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/rich_editable_text.dart';
-
-export 'dart:ui' show TextAffinity;
-
-TextAffinity _toTextAffinity(String affinity) {
-  switch (affinity) {
-    case 'TextAffinity.downstream':
-      return TextAffinity.downstream;
-    case 'TextAffinity.upstream':
-      return TextAffinity.upstream;
-  }
-  return null;
-}
-
-/// The current text, selection, and composing state for editing a run of text.
-@immutable
-class RichTextEditingValue extends AbstractTextEditingValue<TextSpan> {
-  /// Creates information for editing a run of text.
-  ///
-  /// The selection and composing range must be within the text.
-  ///
-  /// The [value], [selection], and [composing] arguments must not be null but
-  /// each have default values.
-  const RichTextEditingValue(
-      {this.value: const TextSpan(text: "", style: StyleController.material),
-      this.selection: const TextSelection.collapsed(offset: -1),
-      this.composing: TextRange.empty})
-      : assert(value != null),
-        assert(selection != null),
-        assert(composing != null);
-
-  /// Creates an instance of this class from a JSON object.
-  factory RichTextEditingValue.fromJSON(
-      Map<String, dynamic> encoded, TextStyle style) {
-    return new RichTextEditingValue(
-      value: new TextSpan(text: encoded['text'], style: style),
-      selection: new TextSelection(
-        baseOffset: encoded['selectionBase'] ?? -1,
-        extentOffset: encoded['selectionExtent'] ?? -1,
-        affinity: _toTextAffinity(encoded['selectionAffinity']) ??
-            TextAffinity.downstream,
-        isDirectional: encoded['selectionIsDirectional'] ?? false,
-      ),
-      composing: new TextRange(
-        start: encoded['composingBase'] ?? -1,
-        end: encoded['composingExtent'] ?? -1,
-      ),
-    );
-  }
-
-  /// The current text being edited.
-  final TextSpan value;
-
-  /// The range of text that is currently selected.
-  final TextSelection selection;
-
-  /// The range of text that is still being composed.
-  final TextRange composing;
-
-  /// A value that corresponds to the empty string with no selection and no composing range.
-  static const RichTextEditingValue empty = const RichTextEditingValue();
-
-  /// Creates a copy of this value but with the given fields replaced with the new values.
-  @override
-  AbstractTextEditingValue copyWith(
-      {TextSpan value, TextSelection selection, TextRange composing}) {
-    return new RichTextEditingValue(
-        value: value ?? this.value,
-        selection: selection ?? this.selection,
-        composing: composing ?? this.composing);
-  }
-
-  @override
-  String getSelectedText() => selection.textInside(value.toPlainText());
-
-  @override
-  TextSpan getUnselectedText() {
-    String plainText = value.toPlainText();
-
-    String newText =
-        selection.textBefore(plainText) + selection.textAfter(plainText);
-
-    return RichTextEditingValueParser
-        .parse(
-          oldValue: this,
-          newValue: copyWith(value: new TextSpan(text: newText)),
-          style: null,
-        )
-        .value;
-  }
-
-  @override
-  AbstractTextEditingValue insert(String text) {
-    String plainText = value.toPlainText();
-
-    String newText =
-        selection.textBefore(plainText) + text + selection.textAfter(plainText);
-
-    print(newText);
-    return RichTextEditingValueParser.parse(
-      oldValue: this,
-      newValue: copyWith(value: new TextSpan(text: newText)),
-      style: null,
-    );
-  }
-
-  @override
-  int get length => Extensions.length(value);
-
-  @override
-  bool get isNotEmpty => Extensions.isNotEmpty(value);
-
-  @override
-  String get text => value.toPlainText();
-
-  @override
-  String toString() =>
-      '$runtimeType(textSpan: \u2524$value\u251C, selection: $selection, composing: $composing)';
-
-  @override
-  bool operator ==(dynamic other) {
-    if (identical(this, other)) return true;
-    if (other is! RichTextEditingValue) return false;
-    final RichTextEditingValue typedOther = other;
-    return typedOther.value == value &&
-        typedOther.selection == selection &&
-        typedOther.composing == composing;
-  }
-
-  @override
-  int get hashCode =>
-      hashValues(value.hashCode, selection.hashCode, composing.hashCode);
-}
-
-abstract class AbstractTextEditingValue<Value> {
-  const AbstractTextEditingValue({this.value, this.selection, this.composing});
-
-  /// Creates a copy of this value but with the given fields replaced with the new values.
-  AbstractTextEditingValue copyWith(
-      {Value value, TextSelection selection, TextRange composing});
-
-  /// Returns a representation of this object as a JSON object.
-  Map<String, dynamic> toJSON() {
-    return <String, dynamic>{
-      'text': text,
-      'selectionBase': selection.baseOffset,
-      'selectionExtent': selection.extentOffset,
-      'selectionAffinity': selection.affinity.toString(),
-      'selectionIsDirectional': selection.isDirectional,
-      'composingBase': composing.start,
-      'composingExtent': composing.end,
-    };
-  }
-
-  /// The current text being edited.
-  final Value value;
-
-  /// The range of text that is currently selected.
-  final TextSelection selection;
-
-  /// The range of text that is still being composed.
-  final TextRange composing;
-
-  String getSelectedText();
-
-  Value getUnselectedText();
-
-  AbstractTextEditingValue insert(String text);
-
-  int get length;
-
-  bool get isNotEmpty;
-
-  String get text;
-
-  @override
-  String toString() =>
-      '$runtimeType(value: \u2524$value\u251C, selection: $selection, composing: $composing)';
-
-  @override
-  bool operator ==(dynamic other) {
-    if (identical(this, other)) return true;
-    if (other is! Value) return false;
-    final AbstractTextEditingValue typedOther = other;
-    return typedOther.value == value &&
-        typedOther.selection == selection &&
-        typedOther.composing == composing;
-  }
-
-  @override
-  int get hashCode =>
-      hashValues(value.hashCode, selection.hashCode, composing.hashCode);
-}
-
-/// An interface to receive information from [TextInput].
-///
-/// See also:
-///
-///  * [TextInput.attach]
-abstract class TextInputClient<T extends AbstractTextEditingValue> {
-  /// Abstract const constructor. This constructor enables subclasses to provide
-  /// const constructors so that they can be used in const expressions.
-  const TextInputClient();
-
-  /// Requests that this client update its editing state to the given value.
-  void updateEditingValue(T value);
-
-  /// Requests that this client perform the given action.
-  void performAction(TextInputAction action);
-
-  /// Return the concert implementation of this clients value/
-  T getValue(Map<String, dynamic> encoded);
-}
-
-/// A interface for interacting with a text input control.
-///
-/// See also:
-///
-///  * [TextInput.attach]
-class TextInputConnection {
-  final Log log = new Log("TextInputConnection");
-
-  TextInputConnection._(this._client)
-      : assert(_client != null),
-        _id = _nextId++;
-
-  static int _nextId = 1;
-  final int _id;
-
-  final TextInputClient _client;
-
-  /// Whether this connection is currently interacting with the text input control.
-  bool get attached => _clientHandler._currentConnection == this;
-
-  /// Requests that the text input control become visible.
-  void show() {
-    assert(attached);
-    SystemChannels.textInput.invokeMethod('TextInput.show');
-  }
-
-  /// Requests that the text input control change its internal state to match the given state.
-  void setEditingState(AbstractTextEditingValue value) {
-    log.d("setEditingState: ${value.toJSON()}");
-    assert(attached);
-    SystemChannels.textInput.invokeMethod(
-      'TextInput.setEditingState',
-      value.toJSON(),
-    );
-  }
-
-  /// Stop interacting with the text input control.
-  ///
-  /// After calling this method, the text input control might disappear if no
-  /// other client attaches to it within this animation frame.
-  void close() {
-    if (attached) {
-      SystemChannels.textInput.invokeMethod('TextInput.clearClient');
-      _clientHandler
-        .._currentConnection = null
-        .._scheduleHide();
-    }
-    assert(!attached);
-  }
-}
-
-TextInputAction _toTextInputAction(String action) {
-  switch (action) {
-    case 'TextInputAction.done':
-      return TextInputAction.done;
-    case 'TextInputAction.newline':
-      return TextInputAction.newline;
-  }
-  throw new FlutterError('Unknown text input action: $action');
-}
-
-class _TextInputClientHandler {
-  _TextInputClientHandler() {
-    SystemChannels.textInput.setMethodCallHandler(_handleTextInputInvocation);
-  }
-
-  TextInputConnection _currentConnection;
-
-  Future<dynamic> _handleTextInputInvocation(MethodCall methodCall) async {
-    if (_currentConnection == null) return;
-    final String method = methodCall.method;
-    final List<dynamic> args = methodCall.arguments;
-    final int client = args[0];
-    // The incoming message was for a different client.
-    if (client != _currentConnection._id) return;
-    switch (method) {
-      case 'TextInputClient.updateEditingState':
-        var value = _currentConnection._client.getValue(args[1]);
-        _currentConnection._client.updateEditingValue(value);
-        break;
-      case 'TextInputClient.performAction':
-        _currentConnection._client.performAction(_toTextInputAction(args[1]));
-        break;
-      default:
-        throw new MissingPluginException();
-    }
-  }
-
-  bool _hidePending = false;
-
-  void _scheduleHide() {
-    if (_hidePending) return;
-    _hidePending = true;
-
-    // Schedule a deferred task that hides the text input.  If someone else
-    // shows the keyboard during this update cycle, then the task will do
-    // nothing.
-    scheduleMicrotask(() {
-      _hidePending = false;
-      if (_currentConnection == null)
-        SystemChannels.textInput.invokeMethod('TextInput.hide');
-    });
-  }
-}
-
-final _TextInputClientHandler _clientHandler = new _TextInputClientHandler();
-
-/// An interface to the system's text input control.
-class TextInput {
-  TextInput._();
-
-  /// Begin interacting with the text input control.
-  ///
-  /// Calling this function helps multiple clients coordinate about which one is
-  /// currently interacting with the text input control. The returned
-  /// [TextInputConnection] provides an interface for actually interacting with
-  /// the text input control.
-  ///
-  /// A client that no longer wishes to interact with the text input control
-  /// should call [TextInputConnection.close] on the returned
-  /// [TextInputConnection].
-  static TextInputConnection attach(
-      TextInputClient client, TextInputConfiguration configuration) {
-    assert(client != null);
-    assert(configuration != null);
-    final TextInputConnection connection = new TextInputConnection._(client);
-    _clientHandler._currentConnection = connection;
-    SystemChannels.textInput.invokeMethod(
-      'TextInput.setClient',
-      <dynamic>[connection._id, configuration.toJson()],
-    );
-    return connection;
-  }
-}
\ No newline at end of file
diff --git a/lib/ui/rich_editor/widgets/format_toolbar.dart b/lib/ui/rich_editor/widgets/format_toolbar.dart
deleted file mode 100644
index be3ce993..00000000
--- a/lib/ui/rich_editor/widgets/format_toolbar.dart
+++ /dev/null
@@ -1,586 +0,0 @@
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart' hide DropdownButton, DropdownMenuItem;
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/material/dropdown.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/material/rich_text_field.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/rich_editable_text.dart';
-
-const double _defaultFontSize = 16.0;
-const FontItem _defaultFont = const FontItem(
-  name: "Roboto",
-  weights: const <int>[100, 200, 300, 400, 500, 600, 700, 800, 900],
-);
-const Color _defaultColor = Colors.black87;
-
-class FormatToolbar extends StatefulWidget {
-  FormatToolbar({
-    @required StyleController styleController,
-    @required GlobalKey<RichTextFieldState> richTextFieldState,
-  })
-      : _styleController = styleController,
-        _richTextFieldState = richTextFieldState;
-
-  final StyleController _styleController;
-  final GlobalKey<RichTextFieldState> _richTextFieldState;
-
-  @override
-  State<StatefulWidget> createState() => new _FormatToolbarState();
-}
-
-class _FormatToolbarState extends State<FormatToolbar> {
-  final GlobalKey<_FontSizeWidgetState> _fontSizeState =
-      new GlobalKey<_FontSizeWidgetState>();
-
-  StyleController _styleController;
-  TextStyle _lastKnownStyle;
-
-  bool _bold = false;
-  bool _italic = false;
-  bool _underline = false;
-  bool _lineThrough = false;
-  bool _overline = false;
-  double _size = _defaultFontSize;
-  String _fontName = "Roboto";
-  Color _textColor = _defaultColor;
-
-  @override
-  void initState() {
-    super.initState();
-    _styleController = widget._styleController;
-    _styleController.addListener(_onStyleChanged);
-
-    _lastKnownStyle = _styleController.value;
-    _size = widget._styleController.value.fontSize;
-  }
-
-  @override
-  void didUpdateWidget(FormatToolbar oldWidget) {
-    super.didUpdateWidget(oldWidget);
-    if (widget._styleController != oldWidget._styleController) {
-      oldWidget._styleController.removeListener(_onStyleChanged);
-      widget._styleController.addListener(_onStyleChanged);
-    }
-  }
-
-  @override
-  void dispose() {
-    super.dispose();
-    _styleController.removeListener(_onStyleChanged);
-  }
-
-  void _setFont(FontItem value) {
-    _styleController.value = Extensions.copyStyleWith(
-      base: _styleController.value,
-      fontFamily: value.name,
-      package: "rich_editor",
-    );
-    setState(() => _fontName = value.name);
-  }
-
-  _setTextColor(Color color) {
-    widget._richTextFieldState.currentState.restoreFocus();
-    if (color == null) return;
-
-    _styleController.value = _styleController.value.copyWith(color: color);
-    setState(() => _textColor = color);
-  }
-
-  void _setFontSize(double size) {
-    _styleController.value = _styleController.value.copyWith(fontSize: size);
-    setState(() => _size = size);
-  }
-
-  void _setBold() {
-    var fontWeight = _lastKnownStyle.fontWeight == FontWeight.bold
-        ? FontWeight.normal
-        : FontWeight.bold;
-
-    _styleController.value =
-        _styleController.value.copyWith(fontWeight: fontWeight);
-
-    setState(() {
-      _bold = fontWeight == FontWeight.bold;
-    });
-  }
-
-  void _setItalic() {
-    var fontStyle = _lastKnownStyle.fontStyle == FontStyle.italic
-        ? FontStyle.normal
-        : FontStyle.italic;
-
-    _styleController.value =
-        _styleController.value.copyWith(fontStyle: fontStyle);
-
-    setState(() {
-      _italic = fontStyle == FontStyle.italic;
-    });
-  }
-
-  void _setUnderlined() {
-    var underlineDecoration;
-    var lineThroughDecoration;
-    var overlineDecoration;
-
-    if (_lastKnownStyle.decoration != null) {
-      underlineDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.underline)
-              ? TextDecoration.none
-              : TextDecoration.underline;
-
-      lineThroughDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.lineThrough)
-              ? TextDecoration.lineThrough
-              : TextDecoration.none;
-
-      overlineDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.overline)
-              ? TextDecoration.overline
-              : TextDecoration.none;
-    } else {
-      underlineDecoration = TextDecoration.underline;
-      lineThroughDecoration = TextDecoration.none;
-      overlineDecoration = TextDecoration.none;
-    }
-
-    var textDecoration = new TextDecoration.combine(
-      [underlineDecoration, lineThroughDecoration, overlineDecoration],
-    );
-
-    _styleController.value =
-        _styleController.value.copyWith(decoration: textDecoration);
-
-    setState(() {
-      _underline = textDecoration.contains(TextDecoration.underline);
-    });
-  }
-
-  void _setLineThrough() {
-    var underlineDecoration;
-    var lineThroughDecoration;
-    var overlineDecoration;
-
-    if (_lastKnownStyle.decoration != null) {
-      underlineDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.underline)
-              ? TextDecoration.underline
-              : TextDecoration.none;
-
-      lineThroughDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.lineThrough)
-              ? TextDecoration.none
-              : TextDecoration.lineThrough;
-
-      overlineDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.overline)
-              ? TextDecoration.overline
-              : TextDecoration.none;
-    } else {
-      underlineDecoration = TextDecoration.none;
-      lineThroughDecoration = TextDecoration.lineThrough;
-      overlineDecoration = TextDecoration.none;
-    }
-
-    var textDecoration = new TextDecoration.combine(
-      [underlineDecoration, lineThroughDecoration, overlineDecoration],
-    );
-
-    _styleController.value =
-        _styleController.value.copyWith(decoration: textDecoration);
-
-    setState(() {
-      _lineThrough = textDecoration.contains(TextDecoration.lineThrough);
-    });
-  }
-
-  void _setOverline() {
-    var underlineDecoration;
-    var lineThroughDecoration;
-    var overlineDecoration;
-
-    if (_lastKnownStyle.decoration != null) {
-      underlineDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.underline)
-              ? TextDecoration.underline
-              : TextDecoration.none;
-
-      lineThroughDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.lineThrough)
-              ? TextDecoration.lineThrough
-              : TextDecoration.none;
-
-      overlineDecoration =
-          _lastKnownStyle.decoration.contains(TextDecoration.overline)
-              ? TextDecoration.none
-              : TextDecoration.overline;
-    } else {
-      underlineDecoration = TextDecoration.none;
-      lineThroughDecoration = TextDecoration.none;
-      overlineDecoration = TextDecoration.overline;
-    }
-
-    var textDecoration = new TextDecoration.combine(
-      [underlineDecoration, lineThroughDecoration, overlineDecoration],
-    );
-
-    _styleController.value =
-        _styleController.value.copyWith(decoration: textDecoration);
-
-    setState(() {
-      _overline = textDecoration.contains(TextDecoration.overline);
-    });
-  }
-
-  void _onDropdownEvent(OnTapState value) {
-    switch (value) {
-      case OnTapState.START:
-        widget._richTextFieldState.currentState.prepareForFocusLoss();
-        break;
-
-      case OnTapState.END:
-        widget._richTextFieldState.currentState.restoreFocus();
-        break;
-    }
-  }
-
-  void _onStyleChanged() {
-    _lastKnownStyle = _styleController.value;
-
-    setState(() {
-      _bold = _isBold();
-      _italic = _isItalic();
-      _underline = _isUnderlined();
-      _lineThrough = _isLineThrough();
-      _overline = _isOverlined();
-      _size = _lastKnownStyle.fontSize;
-      _fontSizeState.currentState.setSize(_lastKnownStyle.fontSize);
-      _fontName = () {
-        // fontFamily come in this form > packages/rich_editor/Berkshire Swash
-        var font = _lastKnownStyle.fontFamily;
-        var index = font?.lastIndexOf("/");
-        if (index != -1)
-          return font?.substring(index + 1);
-        else
-          return font;
-      }();
-      _textColor = _lastKnownStyle.color;
-    });
-  }
-
-  bool _isBold() {
-    if (_lastKnownStyle.fontWeight == FontWeight.bold)
-      return true;
-    else
-      return false;
-  }
-
-  bool _isItalic() {
-    if (_lastKnownStyle.fontStyle == FontStyle.italic)
-      return true;
-    else
-      return false;
-  }
-
-  bool _isUnderlined() {
-    if (_lastKnownStyle.decoration == null) return false;
-    if (_lastKnownStyle.decoration.contains(TextDecoration.underline))
-      return true;
-    else
-      return false;
-  }
-
-  bool _isLineThrough() {
-    if (_lastKnownStyle.decoration == null) return false;
-    if (_lastKnownStyle.decoration.contains(TextDecoration.lineThrough))
-      return true;
-    else
-      return false;
-  }
-
-  bool _isOverlined() {
-    if (_lastKnownStyle.decoration == null) return false;
-    if (_lastKnownStyle.decoration.contains(TextDecoration.overline))
-      return true;
-    else
-      return false;
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    List<Widget> childrenList = <Widget>[
-      new FontSizeWidget(
-        key: _fontSizeState,
-        size: _size,
-        onChange: _setFontSize,
-      ),
-      new DropdownButton(
-        items: fonts,
-        onTap: _onDropdownEvent,
-        onChanged: _setFont,
-        value: fontsMap[_fontName],
-      ),
-      new IconButton(
-        onPressed: _setBold,
-        icon: new Icon(
-          Icons.format_bold,
-        ),
-        color: _bold ? Theme.of(context).primaryColor : null,
-      ),
-      new IconButton(
-        onPressed: _setItalic,
-        icon: new Icon(
-          Icons.format_italic,
-        ),
-        color: _italic ? Theme.of(context).primaryColor : null,
-      ),
-      new IconButton(
-        onPressed: _setUnderlined,
-        icon: new Icon(
-          Icons.format_underlined,
-        ),
-        color: _underline ? Theme.of(context).primaryColor : null,
-      ),
-      new IconButton(
-        onPressed: _setLineThrough,
-        icon: new Icon(
-          Icons.format_strikethrough,
-        ),
-        color: _lineThrough ? Theme.of(context).primaryColor : null,
-      ),
-      new IconButton(
-        onPressed: _setOverline,
-        icon: new ImageIcon(new AssetImage("res/images/format_overline.png",
-            package: "rich_editor")),
-        color: _overline ? Theme.of(context).primaryColor : null,
-      ),
-    ];
-
-    return new Container(
-      alignment: Alignment.bottomCenter,
-      height: 48.0,
-      decoration: new BoxDecoration(
-        color: new Color(0xFFE8E8E8),
-      ),
-      child: new ListView(
-        scrollDirection: Axis.horizontal,
-        children: childrenList,
-      ),
-    );
-  }
-}
-
-const List<DropdownMenuItem<FontItem>> fonts =
-    const <DropdownMenuItem<FontItem>>[
-  const DropdownMenuItem(
-    child: const Text(
-      "Roboto",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Roboto",
-      ),
-    ),
-    value: _defaultFont,
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Berkshire Swash",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Berkshire Swash",
-        package: "rich_editor",
-      ),
-    ),
-    value: const FontItem(
-      name: "Berkshire Swash",
-      weights: const <int>[400],
-    ),
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Cinzel Decorative",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Cinzel Decorative",
-        package: "rich_editor",
-      ),
-    ),
-    value: const FontItem(
-      name: "Cinzel Decorative",
-      weights: const <int>[400, 700, 900],
-    ),
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Comfortaa",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Comfortaa",
-        package: "rich_editor",
-      ),
-    ),
-    value: const FontItem(
-      name: "Comfortaa",
-      weights: const <int>[300, 400, 700],
-    ),
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Indie Flower",
-      style: const TextStyle(
-          color: Colors.black,
-          fontFamily: "Indie Flower",
-          package: "rich_editor",
-          fontSize: 18.0),
-    ),
-    value: const FontItem(
-      name: "Indie Flower",
-      weights: const <int>[400],
-    ),
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Lobster",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Lobster",
-        package: "rich_editor",
-      ),
-    ),
-    value: const FontItem(
-      name: "Lobster",
-      weights: const <int>[400],
-    ),
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Satisfy",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Satisfy",
-        package: "rich_editor",
-      ),
-    ),
-    value: const FontItem(
-      name: "Satisfy",
-      weights: const <int>[400],
-    ),
-  ),
-  const DropdownMenuItem(
-    child: const Text(
-      "Tangerine",
-      style: const TextStyle(
-        color: Colors.black,
-        fontFamily: "Tangerine",
-        package: "rich_editor",
-        fontSize: 26.0,
-        fontWeight: FontWeight.w700,
-      ),
-    ),
-    value: const FontItem(
-      name: "Tangerine",
-      weights: const <int>[400, 700],
-    ),
-  ),
-];
-
-const Map<String, FontItem> fontsMap = const <String, FontItem>{
-  "Roboto": _defaultFont,
-  "Berkshire Swash": const FontItem(
-    name: "Berkshire Swash",
-    weights: const <int>[400],
-  ),
-  "Cinzel Decorative": const FontItem(
-    name: "Cinzel Decorative",
-    weights: const <int>[400, 700, 900],
-  ),
-  "Comfortaa": const FontItem(
-    name: "Comfortaa",
-    weights: const <int>[300, 400, 700],
-  ),
-  "Indie Flower": const FontItem(
-    name: "Indie Flower",
-    weights: const <int>[400],
-  ),
-  "Lobster": const FontItem(
-    name: "Lobster",
-    weights: const <int>[400],
-  ),
-  "Satisfy": const FontItem(
-    name: "Satisfy",
-    weights: const <int>[400],
-  ),
-  "Tangerine": const FontItem(
-    name: "Tangerine",
-    weights: const <int>[400, 700],
-  ),
-};
-
-class FontItem {
-  const FontItem({@required this.name, @required this.weights});
-
-  final String name;
-  final List<int> weights;
-
-  @override
-  String toString() => "FontItem {name: \"$name\", weights: \"$weights\"}";
-}
-
-class FontSizeWidget extends StatefulWidget {
-  const FontSizeWidget({Key key, this.size, this.onChange}) : super(key: key);
-
-  final double size;
-
-  final ValueChanged<double> onChange;
-
-  @override
-  _FontSizeWidgetState createState() => new _FontSizeWidgetState();
-}
-
-class _FontSizeWidgetState extends State<FontSizeWidget> {
-  double _size;
-
-  @override
-  void initState() {
-    super.initState();
-    _size = widget.size ?? _defaultFontSize;
-  }
-
-  void setSize(double size) {
-    setState(() => _size = size ?? _defaultFontSize);
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    return new Row(
-      mainAxisAlignment: MainAxisAlignment.center,
-      children: <Widget>[
-        new IconButton(
-          onPressed: () {
-            setState(() {
-              if (_size != 8.0) {
-                _size--;
-                widget.onChange(_size);
-              }
-            });
-          },
-          icon: new Icon(
-            Icons.keyboard_arrow_down,
-          ),
-        ),
-        new Text(_size.toInt().toString()),
-        new IconButton(
-          onPressed: () {
-            setState(() {
-              if (_size != 96.0) {
-                _size++;
-                widget.onChange(_size);
-              }
-            });
-          },
-          icon: new Icon(
-            Icons.keyboard_arrow_up,
-          ),
-        ),
-      ],
-    );
-  }
-}
diff --git a/lib/ui/rich_editor/widgets/rich_editable_text.dart b/lib/ui/rich_editor/widgets/rich_editable_text.dart
deleted file mode 100644
index 7c824b76..00000000
--- a/lib/ui/rich_editor/widgets/rich_editable_text.dart
+++ /dev/null
@@ -1,890 +0,0 @@
-// Copyright 2015 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:async';
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart'
-    hide TextSelectionControls, TextSelectionOverlay;
-import 'package:flutter/rendering.dart' show ViewportOffset;
-import 'package:flutter/services.dart'
-    show TextRange, TextInputAction, TextInputConfiguration;
-import 'package:kalium_wallet_flutter/ui/rich_editor/extensions.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/rendering/rich_editable.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/rich_text_parser.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/text_input.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/widgets/text_selection.dart';
-
-/// Signature for the callback that reports when the user changes the selection
-/// (including the cursor location).
-typedef void SelectionChangedCallback(TextSelection selection, bool longPress);
-
-const Duration _kCursorBlinkHalfPeriod = const Duration(milliseconds: 500);
-
-class StyleController extends ValueNotifier<TextStyle> {
-  StyleController({TextStyle style}) : super(style ?? material);
-
-  static const TextStyle material = const TextStyle(
-      fontFamily: 'Roboto',
-      inherit: true,
-      color: Colors.black87,
-      fontSize: 16.0,
-      fontWeight: FontWeight.w400,
-      textBaseline: TextBaseline.alphabetic);
-
-  void setState(RichEditableTextState state) {}
-
-  void removeState() {}
-}
-
-/// A controller for an editable text field.
-///
-/// Whenever the user modifies a text field with an associated
-/// [RichTextEditingController], the text field updates [value] and the controller
-/// notifies its listeners. Listeners can then read the [text] and [selection]
-/// properties to learn what the user has typed or how the selection has been
-/// updated.
-///
-/// Similarly, if you modify the [text] or [selection] properties, the text
-/// field will be notified and will update itself appropriately.
-///
-/// A [RichTextEditingController] can also be used to provide an initial value for a
-/// text field. If you build a text field with a controller that already has
-/// [text], the text field will use that text as its initial value.
-///
-/// See also:
-///
-///  * [TextField], which is a Material Design text field that can be controlled
-///    with a [TextEditingController].
-///  * [RichEditableText], which is a raw region of editable text that can be
-///    controlled with a [TextEditingController].
-class RichTextEditingController extends ValueNotifier<RichTextEditingValue> {
-  /// Creates a controller for an editable text field.
-  ///
-  /// This constructor treats a null [textSpan] argument as if it were the empty
-  /// string.
-  RichTextEditingController({TextSpan textSpan})
-      : super(textSpan == null
-            ? RichTextEditingValue.empty
-            : new RichTextEditingValue(value: textSpan));
-
-  /// Creates a controller for an editiable text field from an initial [RichTextEditingValue].
-  ///
-  /// This constructor treats a null [value] argument as if it were
-  /// [RichTextEditingValue.empty].
-  RichTextEditingController.fromValue(RichTextEditingValue value)
-      : super(value ?? RichTextEditingValue.empty);
-
-  /// The current [TextSpan] the user is editing.
-  TextSpan get textSpan => value.value;
-
-  /// Setting this will notify all the listeners of this [RichTextEditingController]
-  /// that they need to update (it calls [notifyListeners]). For this reason,
-  /// this value should only be set between frames, e.g. in response to user
-  /// actions, not during the build, layout, or paint phases.
-  set text(TextSpan newTextSpan) {
-    value = value.copyWith(
-        value: newTextSpan,
-        selection: const TextSelection.collapsed(offset: -1),
-        composing: TextRange.empty);
-  }
-
-  /// The currently selected [text].
-  ///
-  /// If the selection is collapsed, then this property gives the offset of the
-  /// cursor within the text.
-  TextSelection get selection => value.selection;
-
-  /// Setting this will notify all the listeners of this [RichTextEditingController]
-  /// that they need to update (it calls [notifyListeners]). For this reason,
-  /// this value should only be set between frames, e.g. in response to user
-  /// actions, not during the build, layout, or paint phases.
-  set selection(TextSelection newSelection) {
-    if (newSelection.start > Extensions.length(textSpan) ||
-        newSelection.end > Extensions.length(textSpan))
-      throw new FlutterError('invalid text selection: $newSelection');
-    value = value.copyWith(selection: newSelection, composing: TextRange.empty);
-  }
-
-  /// Set the [value] to empty.
-  ///
-  /// After calling this function, [text] will be the empty string and the
-  /// selection will be invalid.
-  ///
-  /// Calling this will notify all the listeners of this [RichTextEditingController]
-  /// that they need to update (it calls [notifyListeners]). For this reason,
-  /// this method should only be called between frames, e.g. in response to user
-  /// actions, not during the build, layout, or paint phases.
-  void clear() {
-    value = RichTextEditingValue.empty;
-  }
-
-  /// Set the composing region to an empty range.
-  ///
-  /// The composing region is the range of text that is still being composed.
-  /// Calling this function indicates that the user is done composing that
-  /// region.
-  ///
-  /// Calling this will notify all the listeners of this [RichTextEditingController]
-  /// that they need to update (it calls [notifyListeners]). For this reason,
-  /// this method should only be called between frames, e.g. in response to user
-  /// actions, not during the build, layout, or paint phases.
-  void clearComposing() {
-    value = value.copyWith(composing: TextRange.empty);
-  }
-}
-
-/// A basic text input field.
-///
-/// This widget interacts with the [TextInput] service to let the user edit the
-/// text it contains. It also provides scrolling, selection, and cursor
-/// movement. This widget does not provide any focus management (e.g.,
-/// tap-to-focus).
-///
-/// Rather than using this widget directly, consider using [TextField], which
-/// is a full-featured, material-design text input field with placeholder text,
-/// labels, and [Form] integration.
-///
-/// See also:
-///
-///  * [TextField], which is a full-featured, material-design text input field
-///    with placeholder text, labels, and [Form] integration.
-class RichEditableText extends StatefulWidget {
-  /// Creates a basic text input control.
-  ///
-  /// The [maxLines] property can be set to null to remove the restriction on
-  /// the number of lines. By default, it is one, meaning this is a single-line
-  /// text field. [maxLines] must be null or greater than zero.
-  ///
-  /// If [keyboardType] is not set or is null, it will default to
-  /// [TextInputType.text] unless [maxLines] is greater than one, when it will
-  /// default to [TextInputType.multiline].
-  ///
-  /// The [controller], [focusNode], [style], [cursorColor], and [textAlign]
-  /// arguments must not be null.
-  RichEditableText({
-    Key key,
-    @required this.controller,
-    @required this.styleController,
-    @required this.focusNode,
-    this.autocorrect: true,
-    @required this.style,
-    @required this.cursorColor,
-    this.textAlign: TextAlign.start,
-    this.textDirection,
-    this.textScaleFactor,
-    this.maxLines: 1,
-    this.autofocus: false,
-    this.selectionColor,
-    this.selectionControls,
-    TextInputType keyboardType,
-    this.onChanged,
-    this.onSubmitted,
-    this.onSelectionChanged,
-  })
-      : assert(controller != null),
-        assert(focusNode != null),
-        assert(autocorrect != null),
-        assert(style != null),
-        assert(cursorColor != null),
-        assert(textAlign != null),
-        assert(maxLines == null || maxLines > 0),
-        assert(autofocus != null),
-        keyboardType = keyboardType ??
-            (maxLines == 1 ? TextInputType.text : TextInputType.multiline),
-        super(key: key);
-
-  /// Controls the text being edited.
-  final RichTextEditingController controller;
-
-  final StyleController styleController;
-
-  /// Controls whether this widget has keyboard focus.
-  final FocusNode focusNode;
-
-  /// Whether to enable autocorrection.
-  ///
-  /// Defaults to true.
-  final bool autocorrect;
-
-  /// The text style to use for the editable text.
-  final TextStyle style;
-
-  /// How the text should be aligned horizontally.
-  ///
-  /// Defaults to [TextAlign.start].
-  final TextAlign textAlign;
-
-  /// The directionality of the text.
-  ///
-  /// This decides how [textAlign] values like [TextAlign.start] and
-  /// [TextAlign.end] are interpreted.
-  ///
-  /// This is also used to disambiguate how to render bidirectional text. For
-  /// example, if the text is an English phrase followed by a Hebrew phrase,
-  /// in a [TextDirection.ltr] context the English phrase will be on the left
-  /// and the Hebrew phrase to its right, while in a [TextDirection.rtl]
-  /// context, the English phrase will be on the right and the Hebrow phrase on
-  /// its left.
-  ///
-  /// Defaults to the ambient [Directionality], if any.
-  final TextDirection textDirection;
-
-  /// The number of font pixels for each logical pixel.
-  ///
-  /// For example, if the text scale factor is 1.5, text will be 50% larger than
-  /// the specified font size.
-  ///
-  /// Defaults to the [MediaQueryData.textScaleFactor] obtained from the ambient
-  /// [MediaQuery], or 1.0 if there is no [MediaQuery] in scope.
-  final double textScaleFactor;
-
-  /// The color to use when painting the cursor.
-  final Color cursorColor;
-
-  /// The maximum number of lines for the text to span, wrapping if necessary.
-  ///
-  /// If this is 1 (the default), the text will not wrap, but will scroll
-  /// horizontally instead.
-  ///
-  /// If this is null, there is no limit to the number of lines. If it is not
-  /// null, the value must be greater than zero.
-  final int maxLines;
-
-  /// Whether this input field should focus itself if nothing else is already focused.
-  /// If true, the keyboard will open as soon as this input obtains focus. Otherwise,
-  /// the keyboard is only shown after the user taps the text field.
-  ///
-  /// Defaults to false.
-  final bool autofocus;
-
-  /// The color to use when painting the selection.
-  final Color selectionColor;
-
-  /// Optional delegate for building the text selection handles and toolbar.
-  final TextSelectionControls selectionControls;
-
-  /// The type of keyboard to use for editing the text.
-  final TextInputType keyboardType;
-
-  /// Called when the text being edited changes.
-  final ValueChanged<String> onChanged;
-
-  /// Called when the user indicates that they are done editing the text in the field.
-  final ValueChanged<String> onSubmitted;
-
-  /// Called when the user changes the selection of text (including the cursor
-  /// location).
-  final SelectionChangedCallback onSelectionChanged;
-
-  @override
-  RichEditableTextState createState() => new RichEditableTextState();
-
-  @override
-  void debugFillProperties(DiagnosticPropertiesBuilder description) {
-    super.debugFillProperties(description);
-    description.add(new DiagnosticsProperty<RichTextEditingController>(
-        'controller', controller));
-    description.add(new DiagnosticsProperty<FocusNode>('focusNode', focusNode));
-    description.add(new DiagnosticsProperty<bool>('autocorrect', autocorrect,
-        defaultValue: true));
-    style?.debugFillProperties(description);
-    description.add(new EnumProperty<TextAlign>('textAlign', textAlign,
-        defaultValue: null));
-    description.add(new EnumProperty<TextDirection>(
-        'textDirection', textDirection,
-        defaultValue: null));
-    description.add(new DoubleProperty('textScaleFactor', textScaleFactor,
-        defaultValue: null));
-    description.add(new IntProperty('maxLines', maxLines, defaultValue: 1));
-    description.add(new DiagnosticsProperty<bool>('autofocus', autofocus,
-        defaultValue: false));
-    description.add(new EnumProperty<TextInputType>(
-        'keyboardType', keyboardType,
-        defaultValue: null));
-  }
-}
-
-/// State for a [RichEditableText].
-class RichEditableTextState extends State<RichEditableText>
-    with AutomaticKeepAliveClientMixin
-    implements TextInputClient<RichTextEditingValue> {
-  final Log log = new Log("RichEditableTextState");
-
-  Timer _cursorTimer;
-  final ValueNotifier<bool> _showCursor = new ValueNotifier<bool>(false);
-
-  TextInputConnection _textInputConnection;
-  TextSelectionOverlay _selectionOverlay;
-
-  final ScrollController _scrollController = new ScrollController();
-  final LayerLink _layerLink = new LayerLink();
-  bool _didAutoFocus = false;
-
-  /// Don't dispose the selection and the selection overlay if the focus is lost
-  /// because of toolbar event.
-  bool saveValueBeforeFocusLoss = false;
-
-  bool closeKeyboardIfNeeded = true;
-
-  /// Restore the keyboard when the focus is regained, after being lost by an
-  /// toolbar event.
-  bool restoreKeyboard = false;
-
-  @override
-  bool get wantKeepAlive => widget.focusNode.hasFocus;
-
-  TextStyle _currentSelectedStyle;
-  StyleController _styleController;
-
-  // State lifecycle:
-  @override
-  void initState() {
-    super.initState();
-    log.d(
-        "--------------------------------------------------------------initState");
-    widget.controller.addListener(_didChangeTextEditingValue);
-    widget.focusNode.addListener(_handleFocusChanged);
-    _scrollController.addListener(() {
-      _selectionOverlay?.updateForScroll();
-    });
-
-    if (widget.styleController == null)
-      _styleController = new StyleController(
-          style: widget.style ?? Theme.of(context).textTheme.subhead);
-    else {
-      _styleController = widget.styleController;
-      assert(_styleController.value ==
-          (widget.style ?? Theme.of(context).textTheme.subhead));
-    }
-    _styleController.addListener(_styleChangedListener);
-    _styleController.setState(this);
-    _currentSelectedStyle = _styleController.value;
-
-    _editingValue = _editingValue.copyWith(
-        value: Extensions.copySpanWith(
-            base: _editingValue.value, style: _styleController.value));
-  }
-
-  @override
-  void didChangeDependencies() {
-    super.didChangeDependencies();
-    log.d(
-        "--------------------------------------------------didChangeDependencies");
-    if (!_didAutoFocus && widget.autofocus) {
-      FocusScope.of(context).autofocus(widget.focusNode);
-      _didAutoFocus = true;
-    }
-  }
-
-  @override
-  void didUpdateWidget(RichEditableText oldWidget) {
-    super.didUpdateWidget(oldWidget);
-    log.d(
-        "--------------------------------------------------------didUpdateWidget");
-    if (widget.controller != oldWidget.controller) {
-      oldWidget.controller.removeListener(_didChangeTextEditingValue);
-      widget.controller.addListener(_didChangeTextEditingValue);
-      _updateRemoteEditingValueIfNeeded();
-    }
-    if (widget.focusNode != oldWidget.focusNode) {
-      oldWidget.focusNode.removeListener(_handleFocusChanged);
-      widget.focusNode.addListener(_handleFocusChanged);
-      updateKeepAlive();
-    }
-
-    if (widget.styleController != oldWidget.styleController) {
-      oldWidget.styleController.removeListener(_styleChangedListener);
-      oldWidget.styleController.removeState();
-      widget.styleController.addListener(_styleChangedListener);
-      widget.styleController.setState(this);
-
-      _currentSelectedStyle = widget.styleController.value;
-    }
-  }
-
-  @override
-  void dispose() {
-    log.d(
-        "----------------------------------------------------------------dispose");
-    widget.styleController.removeListener(_styleChangedListener);
-    widget.styleController.removeState();
-
-    widget.controller.removeListener(_didChangeTextEditingValue);
-    _closeInputConnectionIfNeeded();
-    assert(!_hasInputConnection);
-    _stopCursorTimer();
-    assert(_cursorTimer == null);
-    _selectionOverlay?.dispose();
-    _selectionOverlay = null;
-    widget.focusNode.removeListener(_handleFocusChanged);
-
-    super.dispose();
-  }
-
-  void _styleChangedListener() {
-    var currentSpan = _editingValue.value;
-    var currentSelection = _editingValue.selection;
-
-    if (currentSelection.baseOffset != currentSelection.extentOffset) {
-      var newSpan = RichTextEditingValueParser.updateSpansWithStyle(currentSpan,
-          currentSelection, _currentSelectedStyle, _styleController.value);
-
-      _editingValue = _editingValue.copyWith(value: newSpan);
-    }
-
-    _currentSelectedStyle = _styleController.value;
-  }
-
-  // TextInputClient implementation:
-  RichTextEditingValue _lastKnownRemoteTextEditingValue;
-
-  @override
-  void updateEditingValue(RichTextEditingValue value) {
-    bool textChanged = value.value != _editingValue.value;
-    if (textChanged) _hideSelectionOverlayIfNeeded();
-
-    _lastKnownRemoteTextEditingValue = value;
-    _formatAndSetValue(value, textChanged);
-  }
-
-  @override
-  void performAction(TextInputAction action) {
-    switch (action) {
-      case TextInputAction.done:
-        widget.controller.clearComposing();
-        widget.focusNode.unfocus();
-        if (widget.onSubmitted != null)
-          widget.onSubmitted(_editingValue.value.toPlainText());
-        break;
-      case TextInputAction.newline:
-      default:
-        // Do nothing for a "newline" action: the newline is already inserted.
-        break;
-    }
-  }
-
-  @override
-  RichTextEditingValue getValue(Map<String, dynamic> encoded) =>
-      RichTextEditingValueParser.parse(
-          oldValue: _editingValue.copyWith(),
-          newValue: new RichTextEditingValue.fromJSON(
-              encoded, widget.style ?? Theme.of(context).textTheme.subhead),
-          style: _currentSelectedStyle.copyWith());
-
-  void _updateRemoteEditingValueIfNeeded() {
-    log.d("_updateRemoteEditingValueIfNeeded");
-    if (!_hasInputConnection) return;
-    final RichTextEditingValue localValue = _editingValue;
-    if (localValue == _lastKnownRemoteTextEditingValue) return;
-    _lastKnownRemoteTextEditingValue = localValue;
-
-    log.d(
-        "_updateRemoteEditingValueIfNeeded ${localValue.value.toPlainText()}");
-    _textInputConnection.setEditingState(localValue);
-  }
-
-  RichTextEditingValue get _editingValue => widget.controller.value;
-
-  set _editingValue(RichTextEditingValue value) {
-    widget.controller.value = value;
-  }
-
-  bool get _hasFocus => widget.focusNode.hasFocus;
-
-  bool get _isMultiline => widget.maxLines != 1;
-
-  // Calculate the new scroll offset so the cursor remains visible.
-  double _getScrollOffsetForCaret(Rect caretRect) {
-    final double caretStart = _isMultiline ? caretRect.top : caretRect.left;
-    final double caretEnd = _isMultiline ? caretRect.bottom : caretRect.right;
-    double scrollOffset = _scrollController.offset;
-    final double viewportExtent = _scrollController.position.viewportDimension;
-    if (caretStart < 0.0) // cursor before start of bounds
-      scrollOffset += caretStart;
-    else if (caretEnd >= viewportExtent) // cursor after end of bounds
-      scrollOffset += caretEnd - viewportExtent;
-    return scrollOffset;
-  }
-
-  bool get _hasInputConnection =>
-      _textInputConnection != null && _textInputConnection.attached;
-
-  void _openInputConnection() {
-    if (!_hasInputConnection) {
-      final RichTextEditingValue localValue = _editingValue;
-      _lastKnownRemoteTextEditingValue = localValue;
-      _textInputConnection = TextInput.attach(
-          this,
-          new TextInputConfiguration(
-              inputType: widget.keyboardType,
-              autocorrect: widget.autocorrect,
-              inputAction: widget.keyboardType == TextInputType.multiline
-                  ? TextInputAction.newline
-                  : TextInputAction.done))
-        ..setEditingState(localValue);
-    }
-    _textInputConnection.show();
-  }
-
-  void _closeInputConnectionIfNeeded() {
-    if (_hasInputConnection) {
-      _textInputConnection.close();
-      _textInputConnection = null;
-      _lastKnownRemoteTextEditingValue = null;
-    }
-  }
-
-  void _openOrCloseInputConnectionIfNeeded() {
-    if (_hasFocus && widget.focusNode.consumeKeyboardToken()) {
-      _openInputConnection();
-    } else if (!_hasFocus) {
-      _closeInputConnectionIfNeeded();
-      widget.controller.clearComposing();
-    }
-  }
-
-  /// Express interest in interacting with the keyboard.
-  ///
-  /// If this control is already attached to the keyboard, this function will
-  /// request that the keyboard become visible. Otherwise, this function will
-  /// ask the focus system that it become focused. If successful in acquiring
-  /// focus, the control will then attach to the keyboard and request that the
-  /// keyboard become visible.
-  void requestKeyboard() {
-    if (_hasFocus)
-      _openInputConnection();
-    else
-      FocusScope.of(context).requestFocus(widget.focusNode);
-  }
-
-  void _hideSelectionOverlayIfNeeded() {
-    _selectionOverlay?.hide();
-    _selectionOverlay = null;
-  }
-
-  void _updateOrDisposeSelectionOverlayIfNeeded() {
-    if (_selectionOverlay != null) {
-      if (_hasFocus) {
-        _selectionOverlay.update(_editingValue);
-      } else {
-        _selectionOverlay.dispose();
-        _selectionOverlay = null;
-      }
-    }
-  }
-
-  void _handleSelectionChanged(TextSelection selection,
-      RenderRichEditable renderObject, bool longPress) {
-    widget.controller.selection = selection;
-
-    // Update style when user taps on a specific location.
-    _updateStyleForPosition(selection);
-
-    // This will show the keyboard for all selection changes on the
-    // EditableWidget, not just changes triggered by user gestures.
-    requestKeyboard();
-
-    _hideSelectionOverlayIfNeeded();
-
-    if (widget.selectionControls != null) {
-      _selectionOverlay = new TextSelectionOverlay(
-        context: context,
-        value: _editingValue,
-        debugRequiredFor: widget,
-        layerLink: _layerLink,
-        renderObject: renderObject,
-        onSelectionOverlayChanged: _handleSelectionOverlayChanged,
-        selectionControls: widget.selectionControls,
-      );
-      if (Extensions.isEmpty(_editingValue.value) || longPress)
-        _selectionOverlay.showHandles();
-      if (longPress) _selectionOverlay.showToolbar();
-
-      if (widget.onSelectionChanged != null)
-        widget.onSelectionChanged(selection, longPress);
-    }
-  }
-
-  void _handleSelectionOverlayChanged(
-      RichTextEditingValue value, Rect caretRect) {
-    assert(!value
-        .composing.isValid); // composing range must be empty while selecting.
-    _formatAndSetValue(value, false);
-    // Update style when the user drags the handler to a specific location.
-    _updateStyleForPosition(value.selection);
-
-    _scrollController.jumpTo(_getScrollOffsetForCaret(caretRect));
-
-    log.d("_handleSelectionOverlayChanged");
-    if (widget.onSelectionChanged != null)
-      widget.onSelectionChanged(value.selection, false);
-  }
-
-  /// Update the style for this position.
-  void _updateStyleForPosition(TextSelection selection) {
-    log.d("_updateStyleForPosition: $selection");
-
-    if (selection.baseOffset == selection.extentOffset) {
-      _styleController.value =
-          _editingValue.value.getSpanForPosition(selection.base).style;
-    } else {
-      _styleController.value = Extensions.emptyStyle;
-    }
-  }
-
-  bool _textChangedSinceLastCaretUpdate = false;
-
-  void _handleCaretChanged(Rect caretRect) {
-    // If the caret location has changed due to an update to the text or
-    // selection, then scroll the caret into view.
-    if (_textChangedSinceLastCaretUpdate) {
-      _textChangedSinceLastCaretUpdate = false;
-      scheduleMicrotask(() {
-        _scrollController.animateTo(
-          _getScrollOffsetForCaret(caretRect),
-          curve: Curves.fastOutSlowIn,
-          duration: const Duration(milliseconds: 50),
-        );
-      });
-    }
-  }
-
-  void _formatAndSetValue(RichTextEditingValue value, bool textChanged) {
-    log.d("textChanged: $textChanged");
-
-    _editingValue = value;
-    if (textChanged && widget.onChanged != null)
-      widget.onChanged(value.value.toPlainText());
-  }
-
-  /// Whether the blinking cursor is actually visible at this precise moment
-  /// (it's hidden half the time, since it blinks).
-  @visibleForTesting
-  bool get cursorCurrentlyVisible => _showCursor.value;
-
-  /// The cursor blink interval (the amount of time the cursor is in the "on"
-  /// state or the "off" state). A complete cursor blink period is twice this
-  /// value (half on, half off).
-  @visibleForTesting
-  Duration get cursorBlinkInterval => _kCursorBlinkHalfPeriod;
-
-  int _obscureShowCharTicksPending = 0;
-  int _obscureLatestCharIndex;
-
-  void _cursorTick(Timer timer) {
-    _showCursor.value = !_showCursor.value;
-    if (_obscureShowCharTicksPending > 0) {
-      setState(() {
-        _obscureShowCharTicksPending--;
-      });
-    }
-  }
-
-  void _startCursorTimer() {
-    _showCursor.value = true;
-    _cursorTimer = new Timer.periodic(_kCursorBlinkHalfPeriod, _cursorTick);
-  }
-
-  void _stopCursorTimer() {
-    _cursorTimer?.cancel();
-    _cursorTimer = null;
-    _showCursor.value = false;
-    _obscureShowCharTicksPending = 0;
-  }
-
-  void _startOrStopCursorTimerIfNeeded() {
-    if (_cursorTimer == null &&
-        _hasFocus &&
-        _editingValue.selection.isCollapsed)
-      _startCursorTimer();
-    else if (_cursorTimer != null &&
-        (!_hasFocus || !_editingValue.selection.isCollapsed))
-      _stopCursorTimer();
-  }
-
-  void _didChangeTextEditingValue() {
-    _updateRemoteEditingValueIfNeeded();
-    _startOrStopCursorTimerIfNeeded();
-    _updateOrDisposeSelectionOverlayIfNeeded();
-    _textChangedSinceLastCaretUpdate = true;
-    // TODO(abarth): Teach RenderEditable about ValueNotifier<TextEditingValue>
-    // to avoid this setState().
-    setState(() {
-      /* We use widget.controller.value in build(). */
-    });
-  }
-
-  void requestFocus() {
-    FocusScope.of(context).requestFocus(widget.focusNode);
-    restoreKeyboard = true;
-  }
-
-  void _handleFocusChanged() {
-    log.d("_handleFocusChanged hasFocus: $_hasFocus $_hasInputConnection");
-
-    if (closeKeyboardIfNeeded) {
-      _openOrCloseInputConnectionIfNeeded();
-      _startOrStopCursorTimerIfNeeded();
-    }
-
-    if (restoreKeyboard && _hasFocus) {
-      restoreKeyboard = false;
-      closeKeyboardIfNeeded = true;
-      _openInputConnection();
-    }
-
-    if (!saveValueBeforeFocusLoss) {
-      saveValueBeforeFocusLoss = false;
-      _updateOrDisposeSelectionOverlayIfNeeded();
-      if (!_hasFocus) {
-        // Clear the selection and composition state if this widget lost focus.
-        _editingValue = _editingValue.copyWith(value: _editingValue.value);
-      }
-    }
-
-    updateKeepAlive();
-  }
-
-  TextDirection get _textDirection {
-    final TextDirection result =
-        widget.textDirection ?? Directionality.of(context);
-    assert(result != null,
-        '$runtimeType created without a textDirection and with no ambient Directionality.');
-    return result;
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    log.d(
-        "----------------------------------------------------------------------------------------------------------------------BUILD");
-    FocusScope.of(context).reparentIfNeeded(widget.focusNode);
-    super.build(context); // See AutomaticKeepAliveClientMixin.
-    return new Scrollable(
-      axisDirection: _isMultiline ? AxisDirection.down : AxisDirection.right,
-      controller: _scrollController,
-      physics: const ClampingScrollPhysics(),
-      viewportBuilder: (BuildContext context, ViewportOffset offset) {
-        return new CompositedTransformTarget(
-          link: _layerLink,
-          child: new _RichEditable(
-            editingValue: _editingValue,
-            style: widget.style,
-            currentStyle: _styleController.value,
-            cursorColor: widget.cursorColor,
-            showCursor: _showCursor,
-            maxLines: widget.maxLines,
-            selectionColor: widget.selectionColor,
-            textScaleFactor: widget.textScaleFactor ??
-                MediaQuery.of(context, nullOk: true)?.textScaleFactor ??
-                1.0,
-            textAlign: widget.textAlign,
-            textDirection: _textDirection,
-            obscureShowCharacterAtIndex: _obscureShowCharTicksPending > 0
-                ? _obscureLatestCharIndex
-                : null,
-            autocorrect: widget.autocorrect,
-            offset: offset,
-            onSelectionChanged: _handleSelectionChanged,
-            onCaretChanged: _handleCaretChanged,
-          ),
-        );
-      },
-    );
-  }
-}
-
-class _RichEditable extends LeafRenderObjectWidget {
-  const _RichEditable({
-    Key key,
-    this.editingValue,
-    this.style,
-    this.currentStyle,
-    this.cursorColor,
-    this.showCursor,
-    this.maxLines,
-    this.selectionColor,
-    this.textScaleFactor,
-    this.textAlign,
-    @required this.textDirection,
-    this.obscureText,
-    this.obscureShowCharacterAtIndex,
-    this.autocorrect,
-    this.offset,
-    this.onSelectionChanged,
-    this.onCaretChanged,
-  })
-      : assert(textDirection != null),
-        super(key: key);
-
-  final RichTextEditingValue editingValue;
-  final TextStyle style;
-  final TextStyle currentStyle;
-  final Color cursorColor;
-  final ValueNotifier<bool> showCursor;
-  final int maxLines;
-  final Color selectionColor;
-  final double textScaleFactor;
-  final TextAlign textAlign;
-  final TextDirection textDirection;
-  final bool obscureText;
-  final int obscureShowCharacterAtIndex;
-  final bool autocorrect;
-  final ViewportOffset offset;
-  final SelectionChangedHandler onSelectionChanged;
-  final CaretChangedHandler onCaretChanged;
-
-  @override
-  RenderRichEditable createRenderObject(BuildContext context) {
-    return new RenderRichEditable(
-      text: _styledTextSpan,
-      cursorColor: cursorColor,
-      showCursor: showCursor,
-      maxLines: maxLines,
-      selectionColor: selectionColor,
-      textScaleFactor: textScaleFactor,
-      textAlign: textAlign,
-      textDirection: textDirection,
-      selection: editingValue.selection,
-      offset: offset,
-      onSelectionChanged: onSelectionChanged,
-      onCaretChanged: onCaretChanged,
-    );
-  }
-
-  @override
-  void updateRenderObject(
-      BuildContext context, RenderRichEditable renderObject) {
-    renderObject
-      ..text = _styledTextSpan
-      ..cursorColor = cursorColor
-      ..showCursor = showCursor
-      ..maxLines = maxLines
-      ..selectionColor = selectionColor
-      ..textScaleFactor = textScaleFactor
-      ..textAlign = textAlign
-      ..textDirection = textDirection
-      ..selection = editingValue.selection
-      ..offset = offset
-      ..onSelectionChanged = onSelectionChanged
-      ..onCaretChanged = onCaretChanged;
-
-    renderObject.setCaretPrototype();
-  }
-
-  TextSpan get _styledTextSpan {
-    if (editingValue.composing.isValid) {
-      return RichTextEditingValueParser.updateSpansWithStyle(
-          editingValue.value,
-          new TextSelection(
-            baseOffset: editingValue.composing.start,
-            extentOffset: editingValue.composing.end,
-          ),
-          currentStyle,
-          const TextStyle(decoration: TextDecoration.underline));
-    }
-
-    return editingValue.value;
-  }
-}
diff --git a/lib/ui/rich_editor/widgets/text_selection.dart b/lib/ui/rich_editor/widgets/text_selection.dart
deleted file mode 100644
index 22235475..00000000
--- a/lib/ui/rich_editor/widgets/text_selection.dart
+++ /dev/null
@@ -1,539 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-import 'dart:async';
-
-import 'package:flutter/foundation.dart';
-import 'package:flutter/material.dart';
-import 'package:flutter/scheduler.dart';
-import 'package:flutter/services.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/rendering/rich_editable.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/services/text_input.dart';
-
-/// Which type of selection handle to be displayed.
-///
-/// With mixed-direction text, both handles may be the same type. Examples:
-///
-/// * LTR text: 'the <quick brown> fox':
-///   The '<' is drawn with the [left] type, the '>' with the [right]
-///
-/// * RTL text: 'xof <nworb kciuq> eht':
-///   Same as above.
-///
-/// * mixed text: '<the nwor<b quick fox'
-///   Here 'the b' is selected, but 'brown' is RTL. Both are drawn with the
-///   [left] type.
-enum TextSelectionHandleType {
-  /// The selection handle is to the left of the selection end point.
-  left,
-
-  /// The selection handle is to the right of the selection end point.
-  right,
-
-  /// The start and end of the selection are co-incident at this point.
-  collapsed,
-}
-
-/// The text position that a give selection handle manipulates. Dragging the
-/// [start] handle always moves the [start]/[baseOffset] of the selection.
-enum _TextSelectionHandlePosition { start, end }
-
-/// Signature for reporting changes to the selection component of a
-/// [RichTextEditingValue] for the purposes of a [TextSelectionOverlay]. The
-/// [caretRect] argument gives the location of the caret in the coordinate space
-/// of the [RenderBox] given by the [TextSelectionOverlay.renderObject].
-///
-/// Used by [TextSelectionOverlay.onSelectionOverlayChanged].
-typedef void TextSelectionOverlayChanged(
-    AbstractTextEditingValue value, Rect caretRect);
-
-/// An interface for manipulating the selection, to be used by the implementor
-/// of the toolbar widget.
-abstract class TextSelectionDelegate {
-  /// Gets the current text input.
-  AbstractTextEditingValue get textEditingValue;
-
-  /// Sets the current text input (replaces the whole line).
-  set textEditingValue(AbstractTextEditingValue value);
-
-  /// Hides the text selection toolbar.
-  void hideToolbar();
-}
-
-/// An interface for building the selection UI, to be provided by the
-/// implementor of the toolbar widget.
-///
-/// Override text operations such as [handleCut] if needed.
-abstract class TextSelectionControls {
-  /// Builds a selection handle of the given type.
-  ///
-  /// The top left corner of this widget is positioned at the bottom of the
-  /// selection position.
-  Widget buildHandle(BuildContext context, TextSelectionHandleType type,
-      double textLineHeight);
-
-  /// Builds a toolbar near a text selection.
-  ///
-  /// Typically displays buttons for copying and pasting text.
-  Widget buildToolbar(BuildContext context, Rect globalEditableRegion,
-      Offset position, TextSelectionDelegate delegate);
-
-  /// Returns the size of the selection handle.
-  Size get handleSize;
-
-  /// Copy the current selection of the text field managed by the given
-  /// `delegate` to the [Clipboard]. Then, remove the selected text from the
-  /// text field and hide the toolbar.
-  ///
-  /// This is called by subclasses when their cut affordance is activated by
-  /// the user.
-  void handleCut(TextSelectionDelegate delegate) {
-    final AbstractTextEditingValue value = delegate.textEditingValue;
-    Clipboard.setData(new ClipboardData(
-      text: value.getSelectedText(),
-    ));
-    delegate.textEditingValue = value.copyWith(
-        value: value.getUnselectedText(),
-        selection: new TextSelection.collapsed(offset: value.selection.start));
-    delegate.hideToolbar();
-  }
-
-  /// Copy the current selection of the text field managed by the given
-  /// `delegate` to the [Clipboard]. Then, move the cursor to the end of the
-  /// text (collapsing the selection in the process), and hide the toolbar.
-  ///
-  /// This is called by subclasses when their copy affordance is activated by
-  /// the user.
-  void handleCopy(TextSelectionDelegate delegate) {
-    final AbstractTextEditingValue value = delegate.textEditingValue;
-    Clipboard.setData(new ClipboardData(
-      text: value.getSelectedText(),
-    ));
-    delegate.textEditingValue = value.copyWith(
-        selection: new TextSelection.collapsed(offset: value.selection.end));
-    delegate.hideToolbar();
-  }
-
-  /// Paste the current clipboard selection (obtained from [Clipboard]) into
-  /// the text field managed by the given `delegate`, replacing its current
-  /// selection, if any. Then, hide the toolbar.
-  ///
-  /// This is called by subclasses when their paste affordance is activated by
-  /// the user.
-  ///
-  /// This function is asynchronous since interacting with the clipboard is
-  /// asynchronous. Race conditions may exist with this API as currently
-  /// implemented.
-  // TODO(ianh): https://github.com/flutter/flutter/issues/11427
-  Future<Null> handlePaste(TextSelectionDelegate delegate) async {
-    // Snapshot the input before using `await`.
-    final AbstractTextEditingValue value = delegate.textEditingValue;
-
-    final ClipboardData data = await Clipboard.getData(Clipboard.kTextPlain);
-    if (data != null) {
-      delegate.textEditingValue = value.insert(data.text);
-    }
-    delegate.hideToolbar();
-  }
-
-  /// Adjust the selection of the text field managed by the given `delegate` so
-  /// that everything is selected.
-  ///
-  /// Does not hide the toolbar.
-  ///
-  /// This is called by subclasses when their select-all affordance is activated
-  /// by the user.
-  void handleSelectAll(TextSelectionDelegate delegate) {
-    final AbstractTextEditingValue value = delegate.textEditingValue;
-    delegate.textEditingValue = value.copyWith(
-        selection:
-            new TextSelection(baseOffset: 0, extentOffset: value.length));
-  }
-}
-
-/// An object that manages a pair of text selection handles.
-///
-/// The selection handles are displayed in the [Overlay] that most closely
-/// encloses the given [BuildContext].
-class TextSelectionOverlay implements TextSelectionDelegate {
-  /// Creates an object that manages overly entries for selection handles.
-  ///
-  /// The [context] must not be null and must have an [Overlay] as an ancestor.
-  TextSelectionOverlay({
-    @required AbstractTextEditingValue value,
-    @required this.context,
-    this.debugRequiredFor,
-    @required this.layerLink,
-    @required this.renderObject,
-    this.onSelectionOverlayChanged,
-    this.selectionControls,
-  })
-      : assert(value != null),
-        assert(context != null),
-        _value = value {
-    final OverlayState overlay = Overlay.of(context);
-    assert(overlay != null);
-    _handleController =
-        new AnimationController(duration: _kFadeDuration, vsync: overlay);
-    _toolbarController =
-        new AnimationController(duration: _kFadeDuration, vsync: overlay);
-  }
-
-  /// The context in which the selection handles should appear.
-  ///
-  /// This context must have an [Overlay] as an ancestor because this object
-  /// will display the text selection handles in that [Overlay].
-  final BuildContext context;
-
-  /// Debugging information for explaining why the [Overlay] is required.
-  final Widget debugRequiredFor;
-
-  /// The object supplied to the [CompositedTransformTarget] that wraps the text
-  /// field.
-  final LayerLink layerLink;
-
-  // TODO(mpcomplete): what if the renderObject is removed or replaced, or
-  // moves? Not sure what cases I need to handle, or how to handle them.
-  /// The editable line in which the selected text is being displayed.
-  final RenderRichEditable renderObject;
-
-  /// Called when the the selection changes.
-  ///
-  /// For example, if the use drags one of the selection handles, this function
-  /// will be called with a new input value with an updated selection.
-  final TextSelectionOverlayChanged onSelectionOverlayChanged;
-
-  /// Builds text selection handles and toolbar.
-  final TextSelectionControls selectionControls;
-
-  /// Controls the fade-in animations.
-  static const Duration _kFadeDuration = const Duration(milliseconds: 150);
-  AnimationController _handleController;
-  AnimationController _toolbarController;
-
-  Animation<double> get _handleOpacity => _handleController.view;
-
-  Animation<double> get _toolbarOpacity => _toolbarController.view;
-
-  AbstractTextEditingValue _value;
-
-  /// A pair of handles. If this is non-null, there are always 2, though the
-  /// second is hidden when the selection is collapsed.
-  List<OverlayEntry> _handles;
-
-  /// A copy/paste toolbar.
-  OverlayEntry _toolbar;
-
-  TextSelection get _selection => _value.selection;
-
-  /// Shows the handles by inserting them into the [context]'s overlay.
-  void showHandles() {
-    assert(_handles == null);
-    _handles = <OverlayEntry>[
-      new OverlayEntry(
-          builder: (BuildContext context) =>
-              _buildHandle(context, _TextSelectionHandlePosition.start)),
-      new OverlayEntry(
-          builder: (BuildContext context) =>
-              _buildHandle(context, _TextSelectionHandlePosition.end)),
-    ];
-    Overlay.of(context, debugRequiredFor: debugRequiredFor).insertAll(_handles);
-    _handleController.forward(from: 0.0);
-  }
-
-  /// Shows the toolbar by inserting it into the [context]'s overlay.
-  void showToolbar() {
-    assert(_toolbar == null);
-    _toolbar = new OverlayEntry(builder: _buildToolbar);
-    Overlay.of(context, debugRequiredFor: debugRequiredFor).insert(_toolbar);
-    _toolbarController.forward(from: 0.0);
-  }
-
-  /// Updates the overlay after the selection has changed.
-  ///
-  /// If this method is called while the [SchedulerBinding.schedulerPhase] is
-  /// [SchedulerPhase.persistentCallbacks], i.e. during the build, layout, or
-  /// paint phases (see [WidgetsBinding.drawFrame]), then the update is delayed
-  /// until the post-frame callbacks phase. Otherwise the update is done
-  /// synchronously. This means that it is safe to call during builds, but also
-  /// that if you do call this during a build, the UI will not update until the
-  /// next frame (i.e. many milliseconds later).
-  void update(AbstractTextEditingValue newValue) {
-    if (_value == newValue) return;
-    _value = newValue;
-    if (SchedulerBinding.instance.schedulerPhase ==
-        SchedulerPhase.persistentCallbacks) {
-      SchedulerBinding.instance.addPostFrameCallback(_markNeedsBuild);
-    } else {
-      _markNeedsBuild();
-    }
-  }
-
-  /// Causes the overlay to update its rendering.
-  ///
-  /// This is intended to be called when the [renderObject] may have changed its
-  /// text metrics (e.g. because the text was scrolled).
-  void updateForScroll() {
-    _markNeedsBuild();
-  }
-
-  void _markNeedsBuild([Duration duration]) {
-    if (_handles != null) {
-      _handles[0].markNeedsBuild();
-      _handles[1].markNeedsBuild();
-    }
-    _toolbar?.markNeedsBuild();
-  }
-
-  /// Hides the overlay.
-  void hide() {
-    if (_handles != null) {
-      _handles[0].remove();
-      _handles[1].remove();
-      _handles = null;
-    }
-    _toolbar?.remove();
-    _toolbar = null;
-
-    _handleController.stop();
-    _toolbarController.stop();
-  }
-
-  /// Final cleanup.
-  void dispose() {
-    hide();
-    _handleController.dispose();
-    _toolbarController.dispose();
-  }
-
-  Widget _buildHandle(
-      BuildContext context, _TextSelectionHandlePosition position) {
-    if ((_selection.isCollapsed &&
-            position == _TextSelectionHandlePosition.end) ||
-        selectionControls == null)
-      return new Container(); // hide the second handle when collapsed
-
-    return new FadeTransition(
-        opacity: _handleOpacity,
-        child: new _TextSelectionHandleOverlay(
-          onSelectionHandleChanged: (TextSelection newSelection) {
-            _handleSelectionHandleChanged(newSelection, position);
-          },
-          onSelectionHandleTapped: _handleSelectionHandleTapped,
-          layerLink: layerLink,
-          renderObject: renderObject,
-          selection: _selection,
-          selectionControls: selectionControls,
-          position: position,
-        ));
-  }
-
-  Widget _buildToolbar(BuildContext context) {
-    if (selectionControls == null) return new Container();
-
-    // Find the horizontal midpoint, just above the selected text.
-    final List<TextSelectionPoint> endpoints =
-        renderObject.getEndpointsForSelection(_selection);
-    final Offset midpoint = new Offset(
-      (endpoints.length == 1)
-          ? endpoints[0].point.dx
-          : (endpoints[0].point.dx + endpoints[1].point.dx) / 2.0,
-      endpoints[0].point.dy - renderObject.size.height,
-    );
-
-    final Rect editingRegion = new Rect.fromPoints(
-      renderObject.localToGlobal(Offset.zero),
-      renderObject.localToGlobal(renderObject.size.bottomRight(Offset.zero)),
-    );
-
-    return new FadeTransition(
-      opacity: _toolbarOpacity,
-      child: new CompositedTransformFollower(
-        link: layerLink,
-        showWhenUnlinked: false,
-        offset: -editingRegion.topLeft,
-        child: selectionControls.buildToolbar(
-            context, editingRegion, midpoint, this),
-      ),
-    );
-  }
-
-  void _handleSelectionHandleChanged(
-      TextSelection newSelection, _TextSelectionHandlePosition position) {
-    Rect caretRect;
-    switch (position) {
-      case _TextSelectionHandlePosition.start:
-        caretRect = renderObject.getLocalRectForCaret(newSelection.base);
-        break;
-      case _TextSelectionHandlePosition.end:
-        caretRect = renderObject.getLocalRectForCaret(newSelection.extent);
-        break;
-    }
-    update(
-        _value.copyWith(selection: newSelection, composing: TextRange.empty));
-    if (onSelectionOverlayChanged != null)
-      onSelectionOverlayChanged(_value, caretRect);
-  }
-
-  void _handleSelectionHandleTapped() {
-    if (_value.selection.isCollapsed) {
-      if (_toolbar != null) {
-        _toolbar?.remove();
-        _toolbar = null;
-      } else {
-        showToolbar();
-      }
-    }
-  }
-
-  @override
-  AbstractTextEditingValue get textEditingValue => _value;
-
-  @override
-  set textEditingValue(AbstractTextEditingValue newValue) {
-    update(newValue);
-    if (onSelectionOverlayChanged != null) {
-      final Rect caretRect =
-          renderObject.getLocalRectForCaret(newValue.selection.extent);
-      onSelectionOverlayChanged(newValue, caretRect);
-    }
-  }
-
-  @override
-  void hideToolbar() {
-    hide();
-  }
-}
-
-/// This widget represents a single draggable text selection handle.
-class _TextSelectionHandleOverlay extends StatefulWidget {
-  const _TextSelectionHandleOverlay(
-      {Key key,
-      @required this.selection,
-      @required this.position,
-      @required this.layerLink,
-      @required this.renderObject,
-      @required this.onSelectionHandleChanged,
-      @required this.onSelectionHandleTapped,
-      @required this.selectionControls})
-      : super(key: key);
-
-  final TextSelection selection;
-  final _TextSelectionHandlePosition position;
-  final LayerLink layerLink;
-  final RenderRichEditable renderObject;
-  final ValueChanged<TextSelection> onSelectionHandleChanged;
-  final VoidCallback onSelectionHandleTapped;
-  final TextSelectionControls selectionControls;
-
-  @override
-  _TextSelectionHandleOverlayState createState() =>
-      new _TextSelectionHandleOverlayState();
-}
-
-class _TextSelectionHandleOverlayState
-    extends State<_TextSelectionHandleOverlay> {
-  Offset _dragPosition;
-
-  void _handleDragStart(DragStartDetails details) {
-    _dragPosition = details.globalPosition +
-        new Offset(0.0, -widget.selectionControls.handleSize.height);
-  }
-
-  void _handleDragUpdate(DragUpdateDetails details) {
-    _dragPosition += details.delta;
-    final TextPosition position =
-        widget.renderObject.getPositionForPoint(_dragPosition);
-
-    if (widget.selection.isCollapsed) {
-      widget.onSelectionHandleChanged(new TextSelection.fromPosition(position));
-      return;
-    }
-
-    TextSelection newSelection;
-    switch (widget.position) {
-      case _TextSelectionHandlePosition.start:
-        newSelection = new TextSelection(
-            baseOffset: position.offset,
-            extentOffset: widget.selection.extentOffset);
-        break;
-      case _TextSelectionHandlePosition.end:
-        newSelection = new TextSelection(
-            baseOffset: widget.selection.baseOffset,
-            extentOffset: position.offset);
-        break;
-    }
-
-    if (newSelection.baseOffset >= newSelection.extentOffset)
-      return; // don't allow order swapping.
-
-    widget.onSelectionHandleChanged(newSelection);
-  }
-
-  void _handleTap() {
-    widget.onSelectionHandleTapped();
-  }
-
-  @override
-  Widget build(BuildContext context) {
-    final List<TextSelectionPoint> endpoints =
-        widget.renderObject.getEndpointsForSelection(widget.selection);
-    Offset point;
-    TextSelectionHandleType type;
-
-    switch (widget.position) {
-      case _TextSelectionHandlePosition.start:
-        point = endpoints[0].point;
-        type = _chooseType(endpoints[0], TextSelectionHandleType.left,
-            TextSelectionHandleType.right);
-        break;
-      case _TextSelectionHandlePosition.end:
-        // [endpoints] will only contain 1 point for collapsed selections, in
-        // which case we shouldn't be building the [end] handle.
-        assert(endpoints.length == 2);
-        point = endpoints[1].point;
-        type = _chooseType(endpoints[1], TextSelectionHandleType.right,
-            TextSelectionHandleType.left);
-        break;
-    }
-
-    return new CompositedTransformFollower(
-      link: widget.layerLink,
-      showWhenUnlinked: false,
-      child: new GestureDetector(
-        onPanStart: _handleDragStart,
-        onPanUpdate: _handleDragUpdate,
-        onTap: _handleTap,
-        child: new Stack(
-          children: <Widget>[
-            new Positioned(
-              left: point.dx,
-              top: point.dy,
-              child: widget.selectionControls.buildHandle(
-                context,
-                type,
-                widget.renderObject.size.height /
-                    (widget.renderObject.maxLines ?? 0.0),
-              ),
-            ),
-          ],
-        ),
-      ),
-    );
-  }
-
-  TextSelectionHandleType _chooseType(TextSelectionPoint endpoint,
-      TextSelectionHandleType ltrType, TextSelectionHandleType rtlType) {
-    if (widget.selection.isCollapsed) return TextSelectionHandleType.collapsed;
-
-    assert(endpoint.direction != null);
-    switch (endpoint.direction) {
-      case TextDirection.ltr:
-        return ltrType;
-      case TextDirection.rtl:
-        return rtlType;
-    }
-    return null;
-  }
-}
diff --git a/lib/ui/send/send_sheet.dart b/lib/ui/send/send_sheet.dart
index cca4c8fe..b2217d88 100644
--- a/lib/ui/send/send_sheet.dart
+++ b/lib/ui/send/send_sheet.dart
@@ -15,18 +15,14 @@ import 'package:kalium_wallet_flutter/ui/widgets/buttons.dart';
 import 'package:kalium_wallet_flutter/ui/widgets/sheets.dart';
 import 'package:kalium_wallet_flutter/ui/util/formatters.dart';
 import 'package:kalium_wallet_flutter/ui/util/ui_util.dart';
-import 'package:kalium_wallet_flutter/ui/rich_editor/rich_editor.dart';
 import 'package:kalium_wallet_flutter/util/numberutil.dart';
 
 // TODO - We want to implement a max send, this can't just be balance
 // because there may be some off raw in the account. We want 0 as the balance_after_send
 
 class KaliumSendSheet {
-  GlobalKey<RichTextFieldState> _richTextFieldState =
-      new GlobalKey<RichTextFieldState>();
-
   FocusNode _sendAddressFocusNode;
-  RichTextEditingController _sendAddressController;
+  TextEditingController _sendAddressController;
   FocusNode _sendAmountFocusNode;
   TextEditingController _sendAmountController;
 
@@ -38,11 +34,11 @@ class KaliumSendSheet {
   static const String _amountRequiredText = "Please Enter an Amount";
   static const String _amountInsufficientText = "Insufficient Balance";
   // States
+  var _sendAddressStyle;
   var _amountHint = _amountHintText;
   var _addressHint = _addressHintText;
   var _amountValidationText = "";
   var _addressValidationText = "";
-  bool _addressColorized = false;
   // Buttons States (Used because we hide the buttons under certain conditions)
   bool _pasteButtonVisible = true;
 
@@ -50,7 +46,8 @@ class KaliumSendSheet {
     _sendAmountFocusNode = new FocusNode();
     _sendAddressFocusNode = new FocusNode();
     _sendAmountController = new TextEditingController();
-    _sendAddressController = new RichTextEditingController();
+    _sendAddressController = new TextEditingController();
+    _sendAddressStyle = KaliumStyles.TextStyleAddressText60;
   }
 
   mainBottomSheet(BuildContext context) {
@@ -234,7 +231,6 @@ class KaliumSendSheet {
                                   CurrencyInputFormatter()
                                 ],
                                 onChanged: (text) {
-                                                                    print("amount_change: ${text}");
                                   // Always reset the error message to be less annoying
                                   setState(() {
                                     _amountValidationText = "";
@@ -327,12 +323,16 @@ class KaliumSendSheet {
                                 borderRadius: BorderRadius.circular(25),
                               ),
                               // Enter Address Text field
-                              child: RichTextField(
-                                style: KaliumStyles.TextStyleAddressText60,
-                                key: _richTextFieldState,
+                              child: TextField(
                                 textAlign: TextAlign.center,
                                 focusNode: _sendAddressFocusNode,
                                 controller: _sendAddressController,
+                                cursorColor: KaliumColors.primary,
+                                keyboardAppearance: Brightness.dark,
+                                inputFormatters: [
+                                  LengthLimitingTextInputFormatter(64),
+                                ],
+                                textInputAction: TextInputAction.done,
                                 maxLines: null,
                                 autocorrect: false,
                                 decoration: InputDecoration(
@@ -385,11 +385,12 @@ class KaliumSendSheet {
                                                     address.address)) {
                                                   setState(() {
                                                     _addressValidationText = "";
+                                                    _sendAddressStyle = KaliumStyles
+                                                        .TextStyleAddressText90;
                                                     _pasteButtonVisible = false;
-                                                    _addressColorized = true;
-                                                    _sendAddressController.text =
-                                                        UIUtil.addressToColorizedTextspan(address.address);
                                                   });
+                                                  _sendAddressController.text =
+                                                      address.address;
                                                 }
                                               });
                                             },
@@ -404,8 +405,8 @@ class KaliumSendSheet {
                                         )
                                       : SizedBox(),
                                 ),
+                                style: _sendAddressStyle,
                                 onChanged: (text) {
-                                  print("text_change: ${text}");
                                   // Always reset the error message to be less annoying
                                   setState(() {
                                     _addressValidationText = "";
@@ -414,17 +415,15 @@ class KaliumSendSheet {
                                       NanoAccountType.BANANO, text)) {
                                     _sendAddressFocusNode.unfocus();
                                     setState(() {
-                                      _addressColorized = true;
-                                      _sendAddressController.text = UIUtil.addressToColorizedTextspan(text);
+                                      _sendAddressStyle =
+                                          KaliumStyles.TextStyleAddressText90;
                                       _addressValidationText = "";
                                       _pasteButtonVisible = false;
                                     });
                                   } else {
                                     setState(() {
-                                      if (_addressColorized) {
-                                        _addressColorized = false;
-                                        _sendAddressController.text = TextSpan(text: text, style: KaliumStyles.TextStyleAddressText60);
-                                      }
+                                      _sendAddressStyle =
+                                          KaliumStyles.TextStyleAddressText60;
                                       _pasteButtonVisible = true;
                                     });
                                   }
@@ -462,7 +461,7 @@ class KaliumSendSheet {
                               Dimens.BUTTON_TOP_DIMENS, onPressed: () {
                             if (_validateRequest(context, setState)) {
                               KaliumSendConfirmSheet(_sendAmountController.text,
-                                      _sendAddressController.value.toString())
+                                      _sendAddressController.text)
                                   .mainBottomSheet(context);
                             }
                           }),
@@ -484,9 +483,10 @@ class KaliumSendSheet {
                                   // Not a valid code
                                 } else {
                                   setState(() {
-                                    _addressColorized = true;
-                                    _sendAddressController.text = UIUtil.addressToColorizedTextspan(account);
+                                    _sendAddressController.text = account;
                                     _addressValidationText = "";
+                                    _sendAddressStyle =
+                                        KaliumStyles.TextStyleAddressText90;
                                     _pasteButtonVisible = false;
                                   });
                                 }
@@ -539,14 +539,14 @@ class KaliumSendSheet {
       }
     }
     // Validate address
-    if (_sendAddressController.value.toString().trim().isEmpty) {
+    if (_sendAddressController.text.trim().isEmpty) {
       isValid = false;
       setState(() {
         _addressValidationText = _addressRequiredText;
         _pasteButtonVisible = true;
       });
     } else if (!NanoAccounts.isValid(
-        NanoAccountType.BANANO, _sendAddressController.value.toString())) {
+        NanoAccountType.BANANO, _sendAddressController.text)) {
       isValid = false;
       setState(() {
         _addressValidationText = _addressInvalidText;
diff --git a/lib/ui/util/ui_util.dart b/lib/ui/util/ui_util.dart
index cd7aa4fa..2e7a5626 100644
--- a/lib/ui/util/ui_util.dart
+++ b/lib/ui/util/ui_util.dart
@@ -10,25 +10,6 @@ enum ThreeLineAddressTextType { PRIMARY60, PRIMARY, SUCCESS, SUCCESS_FULL }
 enum OneLineAddressTextType { PRIMARY60, PRIMARY, SUCCESS }
 
 class UIUtil {
-  static TextSpan addressToColorizedTextspan(String address) {
-    return TextSpan(
-      text: '',
-      children: [
-        TextSpan(
-          text: address.substring(0, 11),
-          style: KaliumStyles.TextStyleAddressPrimary,
-        ),
-        TextSpan(
-          text: address.substring(11, 58),
-          style: KaliumStyles.TextStyleAddressText90,
-        ),
-        TextSpan(
-          text: address.substring(58),
-          style: KaliumStyles.TextStyleAddressPrimary,
-        ),
-      ]);
-  }
-
   static Widget threeLineAddressText(String address, { ThreeLineAddressTextType type = ThreeLineAddressTextType.PRIMARY }) {
     String stringPartOne = address.substring(0, 11);
     String stringPartTwo = address.substring(11, 22);
