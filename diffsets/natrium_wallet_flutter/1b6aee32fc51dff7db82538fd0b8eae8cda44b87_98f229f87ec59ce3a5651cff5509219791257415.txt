diff --git a/lib/appstate_container.dart b/lib/appstate_container.dart
index ffb3b0b6..f3f63d0b 100644
--- a/lib/appstate_container.dart
+++ b/lib/appstate_container.dart
@@ -10,6 +10,7 @@ import 'package:event_taxi/event_taxi.dart';
 import 'package:flutter/foundation.dart';
 import 'package:flutter/material.dart';
 import 'package:firebase_messaging/firebase_messaging.dart';
+import 'package:natrium_wallet_flutter/network/model/response/accounts_balances_response.dart';
 import 'package:uni_links/uni_links.dart';
 import 'package:natrium_wallet_flutter/themes.dart';
 import 'package:natrium_wallet_flutter/service_locator.dart';
@@ -25,12 +26,10 @@ import 'package:natrium_wallet_flutter/util/ninja/api.dart';
 import 'package:natrium_wallet_flutter/util/ninja/ninja_node.dart';
 import 'package:natrium_wallet_flutter/network/model/block_types.dart';
 import 'package:natrium_wallet_flutter/network/model/request_item.dart';
-import 'package:natrium_wallet_flutter/network/model/request/accounts_balances_request.dart';
 import 'package:natrium_wallet_flutter/network/model/request/account_history_request.dart';
 import 'package:natrium_wallet_flutter/network/model/request/fcm_update_request.dart';
 import 'package:natrium_wallet_flutter/network/model/request/subscribe_request.dart';
 import 'package:natrium_wallet_flutter/network/model/request/block_info_request.dart';
-import 'package:natrium_wallet_flutter/network/model/request/pending_request.dart';
 import 'package:natrium_wallet_flutter/network/model/request/process_request.dart';
 import 'package:natrium_wallet_flutter/network/model/response/account_history_response.dart';
 import 'package:natrium_wallet_flutter/network/model/response/account_history_response_item.dart';
@@ -114,15 +113,8 @@ class StateContainerState extends State<StateContainer> {
   // Deep link changes
   StreamSubscription _deepLinkSub;
 
-  // This map stashes pending process requests, this is because we need to update these requests
-  // after a blocks_info with the balance after send, and sign the block
-  Map<String, StateBlock> previousPendingMap = Map();
-
-  // Maps previous block requested to next block
-  Map<String, StateBlock> pendingResponseBlockMap = Map();
-
-  // Maps all pending receives to previous blocks
-  Map<String, StateBlock> pendingBlockMap = Map();
+  List<String> pendingRequests = [];
+  List<String> alreadyReceived = [];
 
   // List of Verified Nano Ninja Nodes
   bool nanoNinjaUpdated = false;
@@ -189,15 +181,10 @@ class StateContainerState extends State<StateContainer> {
   // Subscriptions
   StreamSubscription<ConnStatusEvent> _connStatusSub;
   StreamSubscription<SubscribeEvent> _subscribeEventSub;
-  StreamSubscription<HistoryEvent> _historyEventSub;
   StreamSubscription<PriceEvent> _priceEventSub;
-  StreamSubscription<BlocksInfoEvent> _blocksInfoEventSub;
-  StreamSubscription<PendingEvent> _pendingSub;
-  StreamSubscription<ProcessEvent> _processSub;
   StreamSubscription<CallbackEvent> _callbackSub;
   StreamSubscription<ErrorEvent> _errorSub;
   StreamSubscription<FcmUpdateEvent> _fcmUpdateSub;
-  StreamSubscription<AccountsBalancesEvent> _balancesSub;
   StreamSubscription<AccountModifiedEvent> _accountModifiedSub;
 
   // Register RX event listenerss
@@ -205,46 +192,6 @@ class StateContainerState extends State<StateContainer> {
     _subscribeEventSub = EventTaxiImpl.singleton().registerTo<SubscribeEvent>().listen((event) {
       handleSubscribeResponse(event.response);
     });
-    _historyEventSub = EventTaxiImpl.singleton().registerTo<HistoryEvent>().listen((event) {
-      AccountHistoryResponse historyResponse = event.response;
-      // Special handling if from transfer
-      RequestItem topItem = sl.get<AccountService>().peek();
-      if (topItem != null && topItem.fromTransfer) {
-        AccountHistoryRequest origRequest = sl.get<AccountService>().pop().request;
-        historyResponse.account = origRequest.account;
-        EventTaxiImpl.singleton().fire(TransferAccountHistoryEvent(response: historyResponse));
-        return;
-      }
-
-      // Update seconday account balances
-      _requestBalances();
-      bool postedToHome = false;
-      // Iterate list in reverse (oldest to newest block)
-      for (AccountHistoryResponseItem item in historyResponse.history) {
-        // If current list doesn't contain this item, insert it and the rest of the items in list and exit loop
-        if (!wallet.history.contains(item)) {
-          int startIndex = 0; // Index to start inserting into the list
-          int lastIndex = historyResponse.history.indexWhere((item) => wallet.history.contains(item)); // Last index of historyResponse to insert to (first index where item exists in wallet history)
-          lastIndex = lastIndex <= 0 ? historyResponse.history.length : lastIndex;
-          setState(() {
-            wallet.history.insertAll(0, historyResponse.history.getRange(startIndex, lastIndex));            
-            // Send list to home screen
-            EventTaxiImpl.singleton().fire(HistoryHomeEvent(items: wallet.history));
-          });
-          postedToHome = true;
-          break;
-        }        
-      }
-      setState(() {
-        wallet.historyLoading = false;
-      });
-      if (!postedToHome) {
-        EventTaxiImpl.singleton().fire(HistoryHomeEvent(items: wallet.history));
-      }
-      sl.get<AccountService>().pop();
-      sl.get<AccountService>().processQueue();
-      requestPending();
-    });
     _priceEventSub = EventTaxiImpl.singleton().registerTo<PriceEvent>().listen((event) {
       // PriceResponse's get pushed periodically, it wasn't a request we made so don't pop the queue
       setState(() {
@@ -252,9 +199,6 @@ class StateContainerState extends State<StateContainer> {
         wallet.localCurrencyPrice = event.response.price.toString();
       });
     });
-    _blocksInfoEventSub = EventTaxiImpl.singleton().registerTo<BlocksInfoEvent>().listen((event) {
-      handleBlockInfoResponse(event.response);
-    });
     _connStatusSub = EventTaxiImpl.singleton().registerTo<ConnStatusEvent>().listen((event) {
       if (event.status == ConnectionStatus.CONNECTED) {
         requestUpdate();
@@ -265,12 +209,6 @@ class StateContainerState extends State<StateContainer> {
     _callbackSub = EventTaxiImpl.singleton().registerTo<CallbackEvent>().listen((event) {
       handleCallbackResponse(event.response);
     });
-    _processSub = EventTaxiImpl.singleton().registerTo<ProcessEvent>().listen((event) {
-      handleProcessResponse(event.response);
-    });
-    _pendingSub = EventTaxiImpl.singleton().registerTo<PendingEvent>().listen((event) {
-      handlePendingResponse(event.response);
-    });
     _errorSub = EventTaxiImpl.singleton().registerTo<ErrorEvent>().listen((event) {
       handleErrorResponse(event.response);
     });
@@ -281,25 +219,6 @@ class StateContainerState extends State<StateContainer> {
         });
       }
     });
-    // Balances for our accounts
-    _balancesSub = EventTaxiImpl.singleton().registerTo<AccountsBalancesEvent>().listen((event) {
-      if (event.transfer) {
-        return;
-      }
-      getSeed().then((seed) {
-        sl.get<DBHelper>().getAccounts(seed).then((accounts) {
-          accounts.forEach((account) {
-            event.response.balances.forEach((address, balance) {
-              address = address.replaceAll("xrb_", "nano_");
-              String combinedBalance = (BigInt.tryParse(balance.balance) + BigInt.tryParse(balance.pending)).toString();
-              if (address == account.address && combinedBalance != account.balance) {
-                sl.get<DBHelper>().updateAccountBalance(account, combinedBalance);
-              }
-            });
-          });
-        });
-      });
-    });
     // Account has been deleted or name changed
     _accountModifiedSub = EventTaxiImpl.singleton().registerTo<AccountModifiedEvent>().listen((event) {
       if (!event.deleted) {
@@ -361,21 +280,9 @@ class StateContainerState extends State<StateContainer> {
     if (_subscribeEventSub != null) {
       _subscribeEventSub.cancel();
     }
-    if (_historyEventSub != null) {
-      _historyEventSub.cancel();
-    }
     if (_priceEventSub != null) {
       _priceEventSub.cancel();
     }
-    if (_blocksInfoEventSub != null) {
-      _blocksInfoEventSub.cancel();
-    }
-    if (_pendingSub != null) {
-      _pendingSub.cancel();
-    }
-    if (_processSub != null) {
-      _processSub.cancel();
-    }
     if (_callbackSub != null) {
       _callbackSub.cancel();
     }
@@ -385,9 +292,6 @@ class StateContainerState extends State<StateContainer> {
     if (_fcmUpdateSub != null) {
       _fcmUpdateSub.cancel();
     }
-    if (_balancesSub != null) {
-      _balancesSub.cancel();
-    }
     if (_accountModifiedSub != null) {
       _accountModifiedSub.cancel();
     }
@@ -481,116 +385,8 @@ class StateContainerState extends State<StateContainer> {
   /// When an error is returned from server
   /// 
   Future<void> handleErrorResponse(ErrorResponse errorResponse) async {
-    RequestItem prevRequest = sl.get<AccountService>().pop();
     sl.get<AccountService>().processQueue();
     if (errorResponse.error == null) { return; }
-    // 1) Unreceivable error, due to already having received the block typically
-    // This is a no-op for now
-
-    // 2) Process/work errors
-    if (errorResponse.error.toLowerCase().contains("process") || errorResponse.error.toLowerCase().contains("work")) {
-      if (prevRequest != null && prevRequest.request is ProcessRequest) {
-        ProcessRequest origRequest = prevRequest.request;
-        if (origRequest.subType == BlockTypes.SEND) {
-          // Send send failed event
-          EventTaxiImpl.singleton().fire(SendFailedEvent(response: errorResponse));
-        }
-        pendingBlockMap.clear();
-        pendingResponseBlockMap.clear();
-        previousPendingMap.clear();
-        requestUpdate();
-      }
-    }
-    // 3) Error from transfer request
-    if (prevRequest != null && prevRequest.fromTransfer) {
-      EventTaxiImpl.singleton().fire(TransferErrorEvent(response: errorResponse));
-    }
-  }
-
-  ///
-  /// When a STATE block comes back successfully with a hash
-  ///
-  /// @param processResponse Process Response
-  ///
-  Future<void> handleProcessResponse(ProcessResponse processResponse) async {
-    // see what type of request sent this response
-    bool doUpdate = true;
-    RequestItem lastRequest = sl.get<AccountService>().pop();
-    // We always store the block we send for processing in a Map, get the entire block using hash
-    StateBlock previous = pendingResponseBlockMap.remove(processResponse.hash);
-    // Standard process response handling (not from seed sweep/transfer)
-    if (previous != null && !lastRequest.fromTransfer) {
-      // Update the frontier on process responses to avoid forks
-      // We use wallet.blockCount in history requests, to attempt to only request TXs we don't have, so update that too
-      if (previous.subType == BlockTypes.OPEN) {
-        setState(() {
-          wallet.frontier = processResponse.hash;
-          wallet.blockCount = 1;
-        });
-      } else {
-        setState(() {
-          wallet.frontier = processResponse.hash;
-          wallet.blockCount = wallet.blockCount + 1;
-        });
-        if (previous.subType == BlockTypes.SEND) {
-          // Prevent callback race condition when sending to yourself
-          if (previous.link == selectedAccount.address) {
-            doUpdate = false;
-          }
-          // post send event to let UI know send was successful
-          EventTaxiImpl.singleton().fire(SendCompleteEvent(previous: previous));
-        } else if (previous.subType == BlockTypes.RECEIVE) {
-          // Routine to handle multiple pending receives
-          // Handle next receive if there is one, we store these in a Map also
-          StateBlock frontier = pendingBlockMap.remove(processResponse.hash);
-          if (frontier != null && pendingBlockMap.length > 0) {
-            StateBlock nextBlock = pendingBlockMap.remove(pendingBlockMap.keys.first);
-            nextBlock.previous = frontier.hash;
-            nextBlock.representative = frontier.representative;
-            nextBlock.setBalance(frontier.balance);
-            doUpdate = false;
-            await nextBlock.sign(await _getPrivKey());
-            pendingBlockMap.putIfAbsent(nextBlock.hash, () => nextBlock);
-            pendingResponseBlockMap.putIfAbsent(nextBlock.hash, () => nextBlock);
-            sl.get<AccountService>().queueRequest(ProcessRequest(block: json.encode(nextBlock.toJson()), subType: nextBlock.subType));
-            sl.get<AccountService>().processQueue();
-          }
-        } else if (previous.subType == BlockTypes.CHANGE) {
-          // Tell UI change rep was successful
-          EventTaxiImpl.singleton().fire(RepChangedEvent(previous: previous));
-        }
-      }
-    } else {
-      // From seed sweep, UI gets a different response
-      doUpdate = false;
-      EventTaxiImpl.singleton().fire(TransferProcessEvent(account: previous.account, hash: processResponse.hash, balance: previous.balance));
-    }
-    if (doUpdate) {
-      requestUpdate();
-    } else {
-      sl.get<AccountService>().processQueue();
-    }
-  }
-
-  // Handle pending response
-  Future<void> handlePendingResponse(PendingResponse response) async {
-    RequestItem prevRequest = sl.get<AccountService>().pop();
-    if (prevRequest != null && prevRequest.fromTransfer) {
-      // Transfer/sweep pending requests get different handling
-      PendingRequest pendingRequest = prevRequest.request;
-      response.account = pendingRequest.account;
-      EventTaxiImpl.singleton().fire(TransferPendingEvent(response: response));
-    } else {
-      // Initiate receive/open request for each pending
-      response.blocks.forEach((hash, pendingResponseItem) {
-        PendingResponseItem pendingResponseItemN = pendingResponseItem;
-        pendingResponseItemN.hash = hash;
-        handlePendingItem(pendingResponseItemN);
-      });
-      if (response.blocks.length == 0) {
-        sl.get<AccountService>().processQueue();
-      }
-    }
   }
 
   /// Handle account_subscribe response
@@ -600,23 +396,6 @@ class StateContainerState extends State<StateContainer> {
       // Bump min receive to 0.05 NANO
       receiveThreshold = BigInt.from(5).pow(28).toString();
     }
-    // Check next request to update block count
-    if (response.blockCount != null && !wallet.historyLoading) {
-      // Choose correct blockCount to minimize bandwidth
-      // This is can still be improved because history excludes change/open, blockCount doesn't
-
-      // Get largest count we have + 5 (just a safe-buffer)
-      int count = max(995, max(response.blockCount, wallet.history.length)) + 5;
-      // Subtract by what we already have to get amount we want to request
-      count -= wallet.history.length;
-      // Minimum of 10 to request
-      count = count <= 0 ? 10 : count;
-      sl.get<AccountService>().requestQueue.forEach((requestItem) {
-        if (requestItem.request is AccountHistoryRequest) {
-          requestItem.request.count = count;
-        }
-      });
-    }
     // Set currency locale here for the UI to access
     sl.get<SharedPrefsUtil>().getCurrency(deviceLocale).then((currency) {
       setState(() {
@@ -647,88 +426,80 @@ class StateContainerState extends State<StateContainer> {
     });
   }
  
-  /// Handle blocks_info response
-  /// Typically, this preceeds a process request. And we want to update
-  /// that request with data from the previous block (which is what we got from this request)
-  Future<void> handleBlockInfoResponse(BlockInfoItem resp) async {
-    RequestItem lastRequest = sl.get<AccountService>().pop();
-    if (lastRequest == null || !(lastRequest.request is BlockInfoRequest)) {
-      sl.get<AccountService>().processQueue();
-      return;
-    }
-    String hash = lastRequest.request.hash;
-    StateBlock previousBlock =  await compute(stateBlockFromJson, resp.contents);
-    StateBlock nextBlock = previousPendingMap.remove(hash);
-    if (nextBlock == null) {
-      return;
-    }
-
-    // Update data on our next pending request
-    nextBlock.previous = hash;
-    if (nextBlock.subType != BlockTypes.CHANGE) {
-      nextBlock.representative = previousBlock.representative;
-    }
-    nextBlock.setBalance(previousBlock.balance);
-    if (nextBlock.subType == BlockTypes.SEND && nextBlock.balance == "0") {
-      // In case of a max send, go back and update sendAmount with the balance
-      nextBlock.sendAmount = wallet.accountBalance.toString();      
-    }
-    if (lastRequest.fromTransfer) {
-      await nextBlock.sign(nextBlock.privKey);
-    } else {
-      await nextBlock.sign(await _getPrivKey());
-    }
-    pendingResponseBlockMap.putIfAbsent(nextBlock.hash, () => nextBlock);
-    // If this is of type RECEIVE, update its data in our pending map
-    if (nextBlock.subType == BlockTypes.RECEIVE && !lastRequest.fromTransfer) {
-      StateBlock prevReceive = pendingBlockMap.remove(nextBlock.link);
-      if (prevReceive != null) {
-        pendingBlockMap.putIfAbsent(nextBlock.hash, () => nextBlock);
-      }
-    }
-    sl.get<AccountService>().queueRequest(ProcessRequest(block: json.encode(nextBlock.toJson()), subType: nextBlock.subType), fromTransfer: lastRequest.fromTransfer);
-    sl.get<AccountService>().processQueue();
-  }
-
   /// Handle callback response
   /// Typically this means we need to pocket transactions
   Future<void> handleCallbackResponse(CallbackResponse resp) async {
-    if (_locked) { return; }
+    if (_locked) {
+      return;
+    }
     log.d("Received callback ${json.encode(resp.toJson())}");
     if (resp.isSend != "true") {
-      log.d("Is not send");
       sl.get<AccountService>().processQueue();
       return;
     }
-    PendingResponseItem pendingItem = PendingResponseItem(hash: resp.hash, source: resp.account, amount: resp.amount);
-    handlePendingItem(pendingItem);
+    PendingResponseItem pendingItem = PendingResponseItem(
+        hash: resp.hash, source: resp.account, amount: resp.amount);
+    String receivedHash = await handlePendingItem(pendingItem);
+    if (receivedHash != null) {
+      AccountHistoryResponseItem histItem = AccountHistoryResponseItem(
+        type: BlockTypes.RECEIVE,
+        account: resp.account,
+        amount: resp.amount,
+        hash: receivedHash
+      );
+      if (!wallet.history.contains(histItem)) {
+        setState(() {
+          wallet.history.insert(0, histItem);
+          // Send list to home screen
+          EventTaxiImpl.singleton()
+              .fire(HistoryHomeEvent(items: wallet.history));
+        });
+      }
+    }
   }
 
-  Future<void> handlePendingItem(PendingResponseItem item) async {
+  Future<String> handlePendingItem(PendingResponseItem item) async {
+    if (pendingRequests.contains(item.hash)) {
+      return null;
+    }
+    pendingRequests.add(item.hash);
     BigInt amountBigInt = BigInt.tryParse(item.amount);
+    sl.get<Logger>().d("Handling ${item.hash} pending");
     if (amountBigInt != null) {
       if (amountBigInt < BigInt.parse(receiveThreshold)) {
-        return;
+        pendingRequests.remove(item.hash);
+        return null;
       }
     }
-    if (!sl.get<AccountService>().queueContainsRequestWithHash(item.hash) && !pendingBlockMap.containsKey(item.hash)) {
-      if (wallet.openBlock == null && !sl.get<AccountService>().queueContainsOpenBlock()) {
-        await requestOpen("0", item.hash, item.amount);
-      } else if (pendingBlockMap.length == 0) {
-        await requestReceive(wallet.frontier, item.hash, item.amount);
-      } else {
-        pendingBlockMap.putIfAbsent(item.hash, () {
-          return StateBlock(
-            subtype:BlockTypes.RECEIVE,
-            previous: wallet.frontier,
-            representative: wallet.representative,
-            balance:item.amount,
-            link:item.hash,
-            account:wallet.address
-          );
-        });
+    if (wallet.openBlock == null) {
+      // Publish open
+      sl.get<Logger>().d("Handling ${item.hash} as open");
+      try {
+        ProcessResponse resp = await sl.get<AccountService>().requestOpen(item.amount, item.hash, wallet.address, await _getPrivKey());
+        wallet.openBlock = resp.hash;
+        wallet.frontier = resp.hash;
+        pendingRequests.remove(item.hash);
+        alreadyReceived.add(item.hash);
+        return resp.hash;
+      } catch (e) {
+        pendingRequests.remove(item.hash);
+        sl.get<Logger>().e("Error creating open", e);
       }
-    }
+    } else {
+      // Publish receive
+      sl.get<Logger>().d("Handling ${item.hash} as receive");
+      try {
+        ProcessResponse resp = await sl.get<AccountService>().requestReceive(wallet.representative, wallet.frontier, item.amount, item.hash, wallet.address, await _getPrivKey());
+        wallet.frontier = resp.hash;
+        pendingRequests.remove(item.hash);
+        alreadyReceived.add(item.hash);        
+        return resp.hash;
+      } catch (e) {
+        pendingRequests.remove(item.hash);
+        sl.get<Logger>().e("Error creating receive", e);
+      }     
+    }
+    return null;
   }
 
   /// Request balances for accounts in our database
@@ -740,21 +511,109 @@ class StateContainerState extends State<StateContainer> {
         addressToRequest.add(account.address);
       }
     });
-    requestAccountsBalances(addressToRequest);
+    AccountsBalancesResponse resp = await sl.get<AccountService>().requestAccountsBalances(addressToRequest);
+    sl.get<DBHelper>().getAccounts(await getSeed()).then((accounts) {
+      accounts.forEach((account) {
+        resp.balances.forEach((address, balance) {
+          String combinedBalance = (BigInt.tryParse(balance.balance) + BigInt.tryParse(balance.pending)).toString();
+          if (address == account.address && combinedBalance != account.balance) {
+            sl.get<DBHelper>().updateAccountBalance(account, combinedBalance);
+          }
+        });
+      });
+    });
   }
 
-  Future<void> requestUpdate() async {
-    if (wallet != null && wallet.address != null && Address(wallet.address).isValid()) {
+  Future<void> requestUpdate({bool pending = true}) async {
+    if (wallet != null &&
+        wallet.address != null &&
+        Address(wallet.address).isValid()) {
       String uuid = await sl.get<SharedPrefsUtil>().getUuid();
       String fcmToken = await FirebaseMessaging().getToken();
-      bool notificationsEnabled = await sl.get<SharedPrefsUtil>().getNotificationsOn();
+      bool notificationsEnabled =
+          await sl.get<SharedPrefsUtil>().getNotificationsOn();
       sl.get<AccountService>().clearQueue();
-      pendingBlockMap.clear();
-      pendingResponseBlockMap.clear();
-      previousPendingMap.clear();
-      sl.get<AccountService>().queueRequest(SubscribeRequest(account:wallet.address, currency:curCurrency.getIso4217Code(), uuid:uuid, fcmToken: fcmToken, notificationEnabled: notificationsEnabled));
-      sl.get<AccountService>().queueRequest(AccountHistoryRequest(account: wallet.address));
+      sl.get<AccountService>().queueRequest(SubscribeRequest(
+          account: wallet.address,
+          currency: curCurrency.getIso4217Code(),
+          uuid: uuid,
+          fcmToken: fcmToken,
+          notificationEnabled: notificationsEnabled));
+      sl.get<AccountService>().queueRequest(
+          AccountHistoryRequest(account: wallet.address));
       sl.get<AccountService>().processQueue();
+      // Request account history
+
+      // Choose correct blockCount to minimize bandwidth
+      // This is can still be improved because history excludes change/open, blockCount doesn't
+      // Get largest count we have + 5 (just a safe-buffer)
+      int count = 500;
+      if (wallet.history != null && wallet.history.length > 1) {
+        count = 50;
+      }
+      try {
+        AccountHistoryResponse resp = await sl.get<AccountService>().requestAccountHistory(wallet.address, count: count);
+        _requestBalances();
+        bool postedToHome = false;
+        // Iterate list in reverse (oldest to newest block)
+        for (AccountHistoryResponseItem item in resp.history) {
+          // If current list doesn't contain this item, insert it and the rest of the items in list and exit loop
+          if (!wallet.history.contains(item)) {
+            int startIndex = 0; // Index to start inserting into the list
+            int lastIndex = resp.history.indexWhere((item) =>
+                wallet.history.contains(
+                    item)); // Last index of historyResponse to insert to (first index where item exists in wallet history)
+            lastIndex =
+                lastIndex <= 0 ? resp.history.length : lastIndex;
+            setState(() {
+              wallet.history.insertAll(
+                  0, resp.history.getRange(startIndex, lastIndex));
+              // Send list to home screen
+              EventTaxiImpl.singleton()
+                  .fire(HistoryHomeEvent(items: wallet.history));
+            });
+            postedToHome = true;
+            break;
+          }
+        }
+        setState(() {
+          wallet.historyLoading = false;
+        });
+        if (!postedToHome) {
+          EventTaxiImpl.singleton().fire(HistoryHomeEvent(items: wallet.history));
+        }
+        sl.get<AccountService>().pop();
+        sl.get<AccountService>().processQueue();
+        // Receive pendings
+        if (pending) {
+          PendingResponse pendingResp = await sl.get<AccountService>().getPending(wallet.address, max(wallet.blockCount ?? 0, 10), threshold: receiveThreshold);
+          // Initiate receive/open request for each pending
+          for (String hash in pendingResp.blocks.keys) {
+            PendingResponseItem pendingResponseItem = pendingResp.blocks[hash];
+            pendingResponseItem.hash = hash;
+            String receivedHash = await handlePendingItem(pendingResponseItem);
+            if (receivedHash != null) {
+              AccountHistoryResponseItem histItem = AccountHistoryResponseItem(
+                type: BlockTypes.RECEIVE,
+                account: pendingResponseItem.source,
+                amount: pendingResponseItem.amount,
+                hash: receivedHash
+              );
+              if (!wallet.history.contains(histItem)) {
+                setState(() {
+                  wallet.history.insert(0, histItem);
+                  // Send list to home screen
+                  EventTaxiImpl.singleton()
+                      .fire(HistoryHomeEvent(items: wallet.history));
+                });
+              }
+            }
+          }
+        }
+      } catch (e) {
+        // TODO handle account history error
+        sl.get<Logger>().e("account_history e", e);
+      }
     }
   }
 
@@ -769,148 +628,6 @@ class StateContainerState extends State<StateContainer> {
     }
   }
 
-  ///
-  /// Request accounts_balances
-  /// 
-  void requestAccountsBalances(List<String> accounts, {bool fromTransfer = false}) {
-    if (accounts != null && accounts.isNotEmpty) {
-      sl.get<AccountService>().queueRequest(AccountsBalancesRequest(accounts: accounts), fromTransfer: fromTransfer);
-      sl.get<AccountService>().processQueue();
-    }
-  }
-
-  ///
-  /// Request account history
-  ///
-  void requestAccountHistory(String account) {
-    sl.get<AccountService>().queueRequest(AccountHistoryRequest(account: account, count: 1), fromTransfer: true);
-    sl.get<AccountService>().processQueue();
-  }
-
-  ///
-  /// Request pending blocks
-  /// 
-  void requestPending({String account}) {
-    if (wallet.address != null && account == null) {
-      sl.get<AccountService>().queueRequest(PendingRequest(account: wallet.address, count: max(wallet.blockCount ?? 0, 10), threshold: receiveThreshold));
-      sl.get<AccountService>().processQueue();
-    } else {
-      sl.get<AccountService>().queueRequest(PendingRequest(account:account, count: 20, threshold: receiveThreshold), fromTransfer: true);
-      sl.get<AccountService>().processQueue(); 
-    }
-  }
-
-  ///
-  /// Create a state block send request
-  /// 
-  /// @param previous - Previous Hash
-  /// @param destination - Destination address
-  /// @param amount - Amount to send in RAW
-  /// 
-  Future<void> requestSend(String previous, String destination, String amount, {String privKey,String account,String localCurrencyAmount, PaymentRequestMessage paymentRequest}) async {
-    String representative = wallet.representative;
-    bool fromTransfer = privKey == null && account == null ? false: true;
-
-    StateBlock sendBlock = StateBlock(
-      subtype:BlockTypes.SEND,
-      previous: previous,
-      representative: representative,
-      balance:amount,
-      link:destination,
-      account: !fromTransfer ? wallet.address : account,
-      privKey: privKey,
-      localCurrencyValue: localCurrencyAmount,
-      paymentRequest: paymentRequest
-    );
-    previousPendingMap.putIfAbsent(previous, () => sendBlock);
-
-    sl.get<AccountService>().queueRequest(BlockInfoRequest(hash: previous), fromTransfer: fromTransfer);
-    sl.get<AccountService>().processQueue();
-  }
-
-  ///
-  /// Create a state block receive request
-  /// 
-  /// @param previous - Previous Hash
-  /// @param source - source address
-  /// @param balance - balance in RAW
-  /// @param privKey - private key (optional, used for transfer)
-  /// 
-  Future<void> requestReceive(String previous, String source, String balance, {String privKey, String account}) async {
-    String representative = wallet.representative;
-    bool fromTransfer = privKey == null && account == null ? false : true;
-
-    StateBlock receiveBlock = StateBlock(
-      subtype:BlockTypes.RECEIVE,
-      previous: previous,
-      representative: representative,
-      balance:balance,
-      link:source,
-      account: !fromTransfer ? wallet.address: account,
-      privKey: privKey
-    );
-    previousPendingMap.putIfAbsent(previous, () => receiveBlock);
-    if (!fromTransfer) {
-      pendingBlockMap.putIfAbsent(source, () => receiveBlock);
-    }
-
-    sl.get<AccountService>().queueRequest(BlockInfoRequest(hash: previous), fromTransfer: fromTransfer);
-    sl.get<AccountService>().processQueue();
-  }
-
-  ///
-  /// Create a state block open request
-  /// 
-  /// @param previous - Previous Hash
-  /// @param source - source address
-  /// @param balance - balance in RAW
-  /// @param privKey - optional private key to use to sign block wen from transfer
-  /// 
-  Future<void> requestOpen(String previous, String source, String balance, {String privKey, String account}) async {
-    String representative = wallet.representative;
-    bool fromTransfer = privKey == null && account == null ? false : true;
-
-    StateBlock openBlock = StateBlock(
-      subtype:BlockTypes.OPEN,
-      previous: previous,
-      representative: representative,
-      balance:balance,
-      link:source,
-      account: !fromTransfer ? wallet.address : account
-    );
-    if (!fromTransfer) {
-      await openBlock.sign(await _getPrivKey());
-    } else {
-      await openBlock.sign(privKey);
-    }
-    pendingResponseBlockMap.putIfAbsent(openBlock.hash, () => openBlock);
-
-    sl.get<AccountService>().queueRequest(ProcessRequest(block: json.encode(openBlock.toJson()), subType: BlockTypes.OPEN), fromTransfer: fromTransfer);
-    sl.get<AccountService>().processQueue();
-  }
-
-  ///
-  /// Create a state block change request
-  /// 
-  /// @param previous - Previous Hash
-  /// @param balance - Current balance
-  /// @param representative - representative
-  /// 
-  Future<void> requestChange(String previous, String balance, String representative) async {
-    StateBlock changeBlock = StateBlock(
-      subtype:BlockTypes.CHANGE,
-      previous: previous,
-      representative: representative,
-      balance:balance,
-      link:"0000000000000000000000000000000000000000000000000000000000000000",
-      account:wallet.address
-    );
-    previousPendingMap.putIfAbsent(previous, () => changeBlock);
-
-    sl.get<AccountService>().queueRequest(BlockInfoRequest(hash: previous), fromTransfer: false);
-    sl.get<AccountService>().processQueue();
-  }
-
   void logOut() {
     setState(() {
       wallet = AppWallet();
diff --git a/lib/bus/accounts_balances_event.dart b/lib/bus/accounts_balances_event.dart
deleted file mode 100644
index 865d868a..00000000
--- a/lib/bus/accounts_balances_event.dart
+++ /dev/null
@@ -1,9 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/accounts_balances_response.dart';
-
-class AccountsBalancesEvent implements Event {
-  final AccountsBalancesResponse response;
-  final bool transfer;
-
-  AccountsBalancesEvent({this.response, this.transfer});
-}
\ No newline at end of file
diff --git a/lib/bus/blocks_info_event.dart b/lib/bus/blocks_info_event.dart
deleted file mode 100644
index 223577a7..00000000
--- a/lib/bus/blocks_info_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/block_info_item.dart';
-
-class BlocksInfoEvent implements Event {
-  final BlockInfoItem response;
-
-  BlocksInfoEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/events.dart b/lib/bus/events.dart
index 66c3a3a9..1edd2e02 100644
--- a/lib/bus/events.dart
+++ b/lib/bus/events.dart
@@ -1,28 +1,15 @@
 export 'conn_status_event.dart';
 export 'subscribe_event.dart';
-export 'history_event.dart';
 export 'history_home_event.dart';
 export 'price_event.dart';
-export 'blocks_info_event.dart';
-export 'process_event.dart';
 export 'callback_event.dart';
 export 'disable_lock_timeout_event.dart';
 export 'error_response_event.dart';
 export 'fcm_update_event.dart';
-export 'pending_response_event.dart';
-export 'rep_change_event.dart';
-export 'send_complete_event.dart';
-export 'send_failed_event.dart';
 export 'contact_added_event.dart';
 export 'contact_modified_event.dart';
 export 'contact_removed_event.dart';
-export 'accounts_balances_event.dart';
-export 'transfer_account_history_response_event.dart';
 export 'transfer_complete_event.dart';
 export 'transfer_confirm_event.dart';
-export 'transfer_error_event.dart';
-export 'transfer_pending_event.dart';
-export 'transfer_process_response_event.dart';
-export 'unlock_callback_event.dart';
 export 'account_changed_event.dart';
 export 'account_modified_event.dart';
\ No newline at end of file
diff --git a/lib/bus/history_event.dart b/lib/bus/history_event.dart
deleted file mode 100644
index a1deabf6..00000000
--- a/lib/bus/history_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/account_history_response.dart';
-
-class HistoryEvent implements Event {
-  final AccountHistoryResponse response;
-
-  HistoryEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/pending_response_event.dart b/lib/bus/pending_response_event.dart
deleted file mode 100644
index 1de2eb0f..00000000
--- a/lib/bus/pending_response_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/pending_response.dart';
-
-class PendingEvent implements Event {
-  final PendingResponse response;
-
-  PendingEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/process_event.dart b/lib/bus/process_event.dart
deleted file mode 100644
index 1ef6df43..00000000
--- a/lib/bus/process_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/process_response.dart';
-
-class ProcessEvent implements Event {
-  final ProcessResponse response;
-
-  ProcessEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/rep_change_event.dart b/lib/bus/rep_change_event.dart
deleted file mode 100644
index 35c67573..00000000
--- a/lib/bus/rep_change_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/model/state_block.dart';
-
-class RepChangedEvent implements Event {
-  final StateBlock previous;
-
-  RepChangedEvent({this.previous});
-}
\ No newline at end of file
diff --git a/lib/bus/send_complete_event.dart b/lib/bus/send_complete_event.dart
deleted file mode 100644
index d0c6736b..00000000
--- a/lib/bus/send_complete_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/model/state_block.dart';
-
-class SendCompleteEvent implements Event {
-  final StateBlock previous;
-
-  SendCompleteEvent({this.previous});
-}
\ No newline at end of file
diff --git a/lib/bus/send_failed_event.dart b/lib/bus/send_failed_event.dart
deleted file mode 100644
index d028b933..00000000
--- a/lib/bus/send_failed_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/error_response.dart';
-
-class SendFailedEvent implements Event {
-  final ErrorResponse response;
-
-  SendFailedEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/transfer_account_history_response_event.dart b/lib/bus/transfer_account_history_response_event.dart
deleted file mode 100644
index 678850d8..00000000
--- a/lib/bus/transfer_account_history_response_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/account_history_response.dart';
-
-class TransferAccountHistoryEvent implements Event {
-  final AccountHistoryResponse response;
-
-  TransferAccountHistoryEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/transfer_error_event.dart b/lib/bus/transfer_error_event.dart
deleted file mode 100644
index ad783346..00000000
--- a/lib/bus/transfer_error_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/error_response.dart';
-
-class TransferErrorEvent implements Event {
-  final ErrorResponse response;
-
-  TransferErrorEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/transfer_pending_event.dart b/lib/bus/transfer_pending_event.dart
deleted file mode 100644
index 311c337e..00000000
--- a/lib/bus/transfer_pending_event.dart
+++ /dev/null
@@ -1,8 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-import 'package:natrium_wallet_flutter/network/model/response/pending_response.dart';
-
-class TransferPendingEvent implements Event {
-  final PendingResponse response;
-
-  TransferPendingEvent({this.response});
-}
\ No newline at end of file
diff --git a/lib/bus/transfer_process_response_event.dart b/lib/bus/transfer_process_response_event.dart
deleted file mode 100644
index 6ddafcca..00000000
--- a/lib/bus/transfer_process_response_event.dart
+++ /dev/null
@@ -1,9 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-
-class TransferProcessEvent implements Event {
-  final String account;
-  final String hash;
-  final String balance;
-
-  TransferProcessEvent({this.account, this.hash, this.balance});
-}
\ No newline at end of file
diff --git a/lib/bus/unlock_callback_event.dart b/lib/bus/unlock_callback_event.dart
deleted file mode 100644
index 3703cc14..00000000
--- a/lib/bus/unlock_callback_event.dart
+++ /dev/null
@@ -1,5 +0,0 @@
-import 'package:event_taxi/event_taxi.dart';
-
-class UnlockCallbackEvent implements Event {
-
-}
\ No newline at end of file
diff --git a/lib/network/account_service.dart b/lib/network/account_service.dart
index 520f3776..19c7dafc 100644
--- a/lib/network/account_service.dart
+++ b/lib/network/account_service.dart
@@ -3,6 +3,7 @@ import 'dart:collection';
 import 'dart:convert';
 
 import 'package:flutter/foundation.dart';
+import 'package:natrium_wallet_flutter/util/sharedprefsutil.dart';
 import 'package:logger/logger.dart';
 import 'package:natrium_wallet_flutter/model/wallet.dart';
 import 'package:natrium_wallet_flutter/network/model/block_types.dart';
@@ -205,55 +206,12 @@ class AccountService {
         // Price info sent from server
         PriceResponse resp = PriceResponse.fromJson(msg);
         EventTaxiImpl.singleton().fire(PriceEvent(response: resp));
-      } else if (msg.containsKey("history")) {
-        // Account history response
-        if (msg['history'] == "") {
-          msg['history'] = new List<AccountHistoryResponseItem>();
-        }
-        AccountHistoryResponse resp = await compute(accountHistoryresponseFromJson, msg);
-        EventTaxiImpl.singleton().fire(HistoryEvent(response: resp));
-      } else if (msg.containsKey("blocks")) {
-        // This is a 'pending' response
-        if (msg['blocks'] is Map && msg['blocks'].length > 0) {
-          Map<String, dynamic> blockMap = msg['blocks'];
-          if (blockMap != null && blockMap.length > 0) {
-            PendingResponse resp = await compute(pendingResponseFromJson, msg);
-            EventTaxiImpl.singleton().fire(PendingEvent(response: resp));
-          }
-        } else {
-          // Possibly a response when there is no pendings
-          pop();
-          processQueue();
-        }
-      } else if (msg.containsKey("block_account") && msg.containsKey("contents") && msg.containsKey("amount") && msg.containsKey("balance")) {
-        // Block Info Response
-        BlockInfoItem resp = await compute(blockInfoItemFromJson, msg);
-        EventTaxiImpl.singleton().fire(BlocksInfoEvent(response: resp));
       } else if (msg.containsKey("block") && msg.containsKey("hash") && msg.containsKey("account")) {
         CallbackResponse resp = await compute(callbackResponseFromJson, msg);
         EventTaxiImpl.singleton().fire(CallbackEvent(response: resp));
-      } else if (msg.containsKey("hash")) {
-        // process response
-        ProcessResponse resp = ProcessResponse.fromJson(msg);
-        EventTaxiImpl.singleton().fire(ProcessEvent(response: resp));
       } else if (msg.containsKey("error")) {
         ErrorResponse resp = ErrorResponse.fromJson(msg);
         EventTaxiImpl.singleton().fire(ErrorEvent(response: resp));
-      } else if (msg.containsKey("balances")) {
-        // accounts_balances response
-        if (msg['balances'] is Map && msg['balances'].length > 0) {
-          Map<String, dynamic> balancesMap = msg['balances'];
-          if (balancesMap != null && balancesMap.length > 0) {
-            if (balancesMap[balancesMap.keys.first].containsKey('pending')) {
-              RequestItem<dynamic> lastRequest = pop();
-              if (lastRequest != null) {
-                AccountsBalancesResponse resp = await compute(accountsBalancesResponseFromJson, msg);
-                EventTaxiImpl.singleton().fire(AccountsBalancesEvent(response: resp, transfer: lastRequest.fromTransfer));
-              }
-              processQueue();
-            }
-          }
-        }
       }
       return;
     });
@@ -409,8 +367,8 @@ class AccountService {
     return infoResponse;
   }
 
-  Future<PendingResponse> getPending(String account, int count, {bool includeActive = false}) async {
-    String threshold = BigInt.from(10).pow(24).toString();
+  Future<PendingResponse> getPending(String account, int count, {String threshold, bool includeActive = false}) async {
+    threshold = threshold ?? BigInt.from(10).pow(24).toString();
     PendingRequest request = PendingRequest(
       account: account,
       count: count,
@@ -444,6 +402,29 @@ class AccountService {
     return item;
   }
 
+  Future<AccountHistoryResponse> requestAccountHistory(String account, { int count = 1}) async {
+    AccountHistoryRequest request = AccountHistoryRequest(
+      account: account,
+      count: count
+    );
+    dynamic response = await makeHttpRequest(request);
+    if (response is ErrorResponse) {
+      throw Exception("Received error ${response.error}");
+    }
+    return AccountHistoryResponse.fromJson(response);
+  }
+
+  Future<AccountsBalancesResponse> requestAccountsBalances(List<String> accounts) async {
+    AccountsBalancesRequest request = AccountsBalancesRequest(
+      accounts: accounts
+    );
+    dynamic response = await makeHttpRequest(request);
+    if (response is ErrorResponse) {
+      throw Exception("Received error ${response.error}");
+    }
+    return AccountsBalancesResponse.fromJson(response);
+  }
+
   Future<ProcessResponse> requestProcess(ProcessRequest request) async {
     dynamic response = await makeHttpRequest(request);
     if (response is ErrorResponse) {
@@ -510,7 +491,7 @@ class AccountService {
   }
 
   Future<ProcessResponse> requestOpen(String balance, String link, String account, String privKey, {String representative}) async {
-    representative = representative ?? AppWallet.defaultRepresentative;
+    representative = representative ?? await sl.get<SharedPrefsUtil>().getRepresentative();
     StateBlock openBlock = StateBlock(
       subtype:BlockTypes.OPEN,
       previous: "0",
@@ -532,5 +513,33 @@ class AccountService {
 
     return await requestProcess(processRequest);   
   }
+
+  Future<ProcessResponse> requestChange(String account, String representative, String previous, String balance, String privKey) async {
+    StateBlock chgBlock = StateBlock(
+      subtype:BlockTypes.CHANGE,
+      previous: previous,
+      representative: representative,
+      balance: balance,
+      link:"0000000000000000000000000000000000000000000000000000000000000000",
+      account: account,
+      privKey: privKey
+    );
+
+    BlockInfoItem previousInfo = await requestBlockInfo(previous);
+    StateBlock previousBlock = StateBlock.fromJson(json.decode(previousInfo.contents));
+
+    // Update data on our next pending request
+    chgBlock.representative = previousBlock.representative;
+    chgBlock.setBalance(previousBlock.balance);
+    await chgBlock.sign(privKey);
+
+    // Process
+    ProcessRequest processRequest = ProcessRequest(
+      block: json.encode(chgBlock.toJson()),
+      subType: BlockTypes.CHANGE
+    );
+
+    return await requestProcess(processRequest);   
+  }
 }
 
diff --git a/lib/ui/accounts/accounts_sheet.dart b/lib/ui/accounts/accounts_sheet.dart
index b875e27a..84a759eb 100644
--- a/lib/ui/accounts/accounts_sheet.dart
+++ b/lib/ui/accounts/accounts_sheet.dart
@@ -9,6 +9,8 @@ import 'package:natrium_wallet_flutter/app_icons.dart';
 import 'package:natrium_wallet_flutter/localization.dart';
 import 'package:natrium_wallet_flutter/appstate_container.dart';
 import 'package:natrium_wallet_flutter/dimens.dart';
+import 'package:natrium_wallet_flutter/network/account_service.dart';
+import 'package:natrium_wallet_flutter/network/model/response/accounts_balances_response.dart';
 import 'package:natrium_wallet_flutter/service_locator.dart';
 import 'package:natrium_wallet_flutter/model/db/appdb.dart';
 import 'package:natrium_wallet_flutter/model/db/account.dart';
@@ -19,6 +21,7 @@ import 'package:natrium_wallet_flutter/ui/widgets/dialog.dart';
 import 'package:natrium_wallet_flutter/styles.dart';
 import 'package:natrium_wallet_flutter/util/caseconverter.dart';
 import 'package:natrium_wallet_flutter/util/numberutil.dart';
+import 'package:logger/logger.dart';
 
 class AppAccountsSheet {
   List<Account> accounts;
@@ -50,14 +53,10 @@ class _AppAccountsWidgetState extends State<AppAccountsWidget> {
   bool _addingAccount;
   ScrollController _scrollController = new ScrollController();
 
-  StreamSubscription<AccountsBalancesEvent> _balancesSub;
   StreamSubscription<AccountModifiedEvent> _accountModifiedSub;
   bool _accountIsChanging;
 
   Future<bool> _onWillPop() async {
-    if (_balancesSub != null) {
-      _balancesSub.cancel();
-    }
     if (_accountModifiedSub != null) {
       _accountModifiedSub.cancel();
     }
@@ -76,14 +75,10 @@ class _AppAccountsWidgetState extends State<AppAccountsWidget> {
     super.dispose();
   }
 
-  Future<void> _handleAccountsBalancesResponse(
-      AccountsBalancesEvent event, StateSetter setState) async {
-    if (event.transfer) {
-      return;
-    }
+  Future<void> _handleAccountsBalancesResponse(AccountsBalancesResponse resp) async {
     // Handle balances event
     widget.accounts.forEach((account) {
-      event.response.balances.forEach((address, balance) {
+      resp.balances.forEach((address, balance) {
         address = address.replaceAll("xrb_", "nano_");
         String combinedBalance = (BigInt.tryParse(balance.balance) +
                 BigInt.tryParse(balance.pending))
@@ -99,11 +94,6 @@ class _AppAccountsWidgetState extends State<AppAccountsWidget> {
   }
 
   void _registerBus() {
-    _balancesSub = EventTaxiImpl.singleton()
-        .registerTo<AccountsBalancesEvent>()
-        .listen((event) {
-      _handleAccountsBalancesResponse(event, setState);
-    });
     _accountModifiedSub = EventTaxiImpl.singleton()
         .registerTo<AccountModifiedEvent>()
         .listen((event) {
@@ -140,9 +130,6 @@ class _AppAccountsWidgetState extends State<AppAccountsWidget> {
   }
 
   void _destroyBus() {
-    if (_balancesSub != null) {
-      _balancesSub.cancel();
-    }
     if (_accountModifiedSub != null) {
       _accountModifiedSub.cancel();
     }
@@ -156,8 +143,13 @@ class _AppAccountsWidgetState extends State<AppAccountsWidget> {
         addresses.add(account.address);
       }
     });
-    StateContainer.of(context).requestAccountsBalances(addresses);
-  }
+    try {
+      AccountsBalancesResponse resp = await sl.get<AccountService>().requestAccountsBalances(addresses);
+      await _handleAccountsBalancesResponse(resp);
+    } catch (e) {
+      sl.get<Logger>().e("Error", e);
+    }
+}
 
 
   Future<void> _changeAccount(Account account, StateSetter setState) async {
diff --git a/lib/ui/home_page.dart b/lib/ui/home_page.dart
index 3bb62b92..8e8f8efa 100755
--- a/lib/ui/home_page.dart
+++ b/lib/ui/home_page.dart
@@ -303,7 +303,6 @@ class _AppHomePageState extends State<AppHomePage>
 
   StreamSubscription<HistoryHomeEvent> _historySub;
   StreamSubscription<ContactModifiedEvent> _contactModifiedSub;
-  StreamSubscription<SendCompleteEvent> _sendCompleteSub;
   StreamSubscription<DisableLockTimeoutEvent> _disableLockSub;
   StreamSubscription<AccountChangedEvent> _switchAccountSub;
 
@@ -320,31 +319,6 @@ class _AppHomePageState extends State<AppHomePage>
         StateContainer.of(context).initialDeepLink = null;
       }
     });
-    _sendCompleteSub = EventTaxiImpl.singleton()
-        .registerTo<SendCompleteEvent>()
-        .listen((event) {
-      // Route to send complete if received process response for send block
-      if (event.previous != null) {
-        // Route to send complete
-        sl
-            .get<DBHelper>()
-            .getContactWithAddress(event.previous.link)
-            .then((contact) {
-          String contactName = contact == null ? null : contact.name;
-          Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
-          Sheets.showAppHeightNineSheet(
-              context: context,
-              closeOnTap: true,
-              removeUntilHome: true,
-              widget: SendCompleteSheet(
-                  amountRaw: event.previous.sendAmount,
-                  destination: event.previous.link,
-                  contactName: contactName,
-                  localAmount: event.previous.localCurrencyValue,
-                  paymentRequest: event.previous.paymentRequest));
-        });
-      }
-    });
     _contactModifiedSub = EventTaxiImpl.singleton()
         .registerTo<ContactModifiedEvent>()
         .listen((event) {
@@ -395,9 +369,6 @@ class _AppHomePageState extends State<AppHomePage>
     if (_contactModifiedSub != null) {
       _contactModifiedSub.cancel();
     }
-    if (_sendCompleteSub != null) {
-      _sendCompleteSub.cancel();
-    }
     if (_disableLockSub != null) {
       _disableLockSub.cancel();
     }
diff --git a/lib/ui/send/send_confirm_sheet.dart b/lib/ui/send/send_confirm_sheet.dart
index 0877cc8f..86196f96 100755
--- a/lib/ui/send/send_confirm_sheet.dart
+++ b/lib/ui/send/send_confirm_sheet.dart
@@ -2,20 +2,26 @@ import 'dart:async';
 
 import 'package:auto_size_text/auto_size_text.dart';
 import 'package:flutter/material.dart';
-import 'package:event_taxi/event_taxi.dart';
 import 'package:manta_dart/manta_wallet.dart';
 import 'package:manta_dart/messages.dart';
 import 'package:natrium_wallet_flutter/app_icons.dart';
 
 import 'package:natrium_wallet_flutter/appstate_container.dart';
 import 'package:natrium_wallet_flutter/dimens.dart';
+import 'package:natrium_wallet_flutter/model/db/appdb.dart';
+import 'package:natrium_wallet_flutter/model/db/contact.dart';
+import 'package:natrium_wallet_flutter/network/account_service.dart';
+import 'package:natrium_wallet_flutter/network/model/response/process_response.dart';
 import 'package:natrium_wallet_flutter/styles.dart';
 import 'package:natrium_wallet_flutter/localization.dart';
 import 'package:natrium_wallet_flutter/service_locator.dart';
-import 'package:natrium_wallet_flutter/bus/events.dart';
+import 'package:natrium_wallet_flutter/ui/send/send_complete_sheet.dart';
+import 'package:natrium_wallet_flutter/ui/util/routes.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/buttons.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/dialog.dart';
 import 'package:natrium_wallet_flutter/ui/util/ui_util.dart';
+import 'package:natrium_wallet_flutter/ui/widgets/sheet_util.dart';
+import 'package:natrium_wallet_flutter/util/nanoutil.dart';
 import 'package:natrium_wallet_flutter/util/numberutil.dart';
 import 'package:natrium_wallet_flutter/util/sharedprefsutil.dart';
 import 'package:natrium_wallet_flutter/util/biometrics.dart';
@@ -57,7 +63,6 @@ class _SendConfirmSheetState extends State<SendConfirmSheet> {
   @override
   void initState() {
     super.initState();
-    _registerBus();
     this.animationOpen = false;
     this.sent = false;
     this.isMantaTransaction = widget.manta != null && widget.paymentRequest != null;
@@ -76,45 +81,6 @@ class _SendConfirmSheetState extends State<SendConfirmSheet> {
     destinationAltered = widget.destination.replaceAll("xrb_", "nano_");
   }
 
-  @override
-  void dispose() {
-    _destroyBus();
-    super.dispose();
-  }
-
-  // Event bus
-  StreamSubscription<SendFailedEvent> _sendEventFailedSub;
-  StreamSubscription<ProcessEvent> _processEventSub;
-
-  void _registerBus() {
-    _sendEventFailedSub =
-        EventTaxiImpl.singleton().registerTo<SendFailedEvent>().listen((event) {
-      // Send failed
-      if (animationOpen) {
-        Navigator.of(context).pop();
-      }
-      UIUtil.showSnackbar(AppLocalization.of(context).sendError, context);
-      Navigator.of(context).pop();
-    });
-    _processEventSub =
-        EventTaxiImpl.singleton().registerTo<ProcessEvent>().listen((event) {
-      if (!sent && widget.manta != null) {
-        widget.manta.sendPayment(
-            transactionHash: event.response.hash, cryptoCurrency: "NANO");
-      }
-      sent = true;
-    });
-  }
-
-  void _destroyBus() {
-    if (_sendEventFailedSub != null) {
-      _sendEventFailedSub.cancel();
-    }
-    if (_processEventSub != null) {
-      _processEventSub.cancel();
-    }
-  }
-
   void _showSendingAnimation(BuildContext context) {
     animationOpen = true;
     Navigator.of(context).push(AnimationLoadingOverlay(
@@ -342,15 +308,7 @@ class _SendConfirmSheetState extends State<SendConfirmSheet> {
                                 if (authenticated) {
                                   sl.get<HapticUtil>().fingerprintSucess();
                                   _showSendingAnimation(context);
-                                  StateContainer.of(context).requestSend(
-                                      StateContainer.of(context)
-                                          .wallet
-                                          .frontier,
-                                      destinationAltered,
-                                      widget.maxSend ? "0" : widget.amountRaw,
-                                      localCurrencyAmount:
-                                          widget.localCurrency,
-                                      paymentRequest: widget.paymentRequest);
+                                  await _doSend();
                                 }
                               } catch (e) {
                                 await authenticateWithPin();
@@ -383,6 +341,44 @@ class _SendConfirmSheetState extends State<SendConfirmSheet> {
         ));
   }
 
+  Future<void> _doSend() async {
+    try {
+      ProcessResponse resp = await sl.get<AccountService>().requestSend(
+        StateContainer.of(context).wallet.representative,
+        StateContainer.of(context).wallet.frontier,
+        widget.amountRaw,
+        destinationAltered,
+        StateContainer.of(context).wallet.address,
+        NanoUtil.seedToPrivate(await StateContainer.of(context).getSeed(), StateContainer.of(context).selectedAccount.index),
+        max: widget.maxSend
+      );
+      StateContainer.of(context).wallet.frontier = resp.hash;
+      StateContainer.of(context).wallet.accountBalance += BigInt.parse(widget.amountRaw);
+      // Show complete
+      Contact contact = await sl.get<DBHelper>().getContactWithAddress(widget.destination);
+      String contactName = contact == null ? null : contact.name;
+      Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
+      StateContainer.of(context).requestUpdate();
+      Sheets.showAppHeightNineSheet(
+          context: context,
+          closeOnTap: true,
+          removeUntilHome: true,
+          widget: SendCompleteSheet(
+              amountRaw: widget.amountRaw,
+              destination: destinationAltered,
+              contactName: contactName,
+              localAmount: widget.localCurrency,
+              paymentRequest: widget.paymentRequest));
+    } catch (e) {
+      // Send failed
+      if (animationOpen) {
+        Navigator.of(context).pop();
+      }
+      UIUtil.showSnackbar(AppLocalization.of(context).sendError, context);
+      Navigator.of(context).pop();
+    }
+  }
+
   Future<void> authenticateWithPin() async {
     // PIN Authentication
     sl.get<Vault>().getPin().then((expectedPin) {
@@ -390,18 +386,10 @@ class _SendConfirmSheetState extends State<SendConfirmSheet> {
           builder: (BuildContext context) {
         return new PinScreen(
           PinOverlayType.ENTER_PIN,
-          (pin) {
+          (pin) async {
             Navigator.of(context).pop();
             _showSendingAnimation(context);
-            StateContainer.of(context).requestSend(
-                StateContainer.of(context)
-                    .wallet
-                    .frontier,
-                destinationAltered,
-                widget.maxSend ? "0" : widget.amountRaw,
-                localCurrencyAmount:
-                    widget.localCurrency,
-                paymentRequest: widget.paymentRequest);
+            await _doSend();
           },
           expectedPin: expectedPin,
           description: AppLocalization.of(context)
diff --git a/lib/ui/settings/changerepresentative_sheet.dart b/lib/ui/settings/changerepresentative_sheet.dart
index 0d3709ac..96789893 100755
--- a/lib/ui/settings/changerepresentative_sheet.dart
+++ b/lib/ui/settings/changerepresentative_sheet.dart
@@ -3,14 +3,15 @@ import 'package:auto_size_text/auto_size_text.dart';
 import 'package:flutter/material.dart';
 import 'package:flutter/services.dart';
 
-import 'package:event_taxi/event_taxi.dart';
 import 'package:flutter_nano_ffi/flutter_nano_ffi.dart';
+import 'package:logger/logger.dart';
+import 'package:natrium_wallet_flutter/network/account_service.dart';
+import 'package:natrium_wallet_flutter/network/model/response/process_response.dart';
 
 import 'package:natrium_wallet_flutter/service_locator.dart';
 import 'package:natrium_wallet_flutter/appstate_container.dart';
 import 'package:natrium_wallet_flutter/localization.dart';
 import 'package:natrium_wallet_flutter/dimens.dart';
-import 'package:natrium_wallet_flutter/bus/events.dart';
 import 'package:natrium_wallet_flutter/ui/util/ui_util.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/app_simpledialog.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/sheets.dart';
@@ -20,6 +21,7 @@ import 'package:natrium_wallet_flutter/ui/widgets/security.dart';
 import 'package:natrium_wallet_flutter/ui/util/routes.dart';
 import 'package:natrium_wallet_flutter/styles.dart';
 import 'package:natrium_wallet_flutter/app_icons.dart';
+import 'package:natrium_wallet_flutter/util/nanoutil.dart';
 import 'package:natrium_wallet_flutter/util/ninja/ninja_node.dart';
 import 'package:natrium_wallet_flutter/util/sharedprefsutil.dart';
 import 'package:natrium_wallet_flutter/util/biometrics.dart';
@@ -27,7 +29,6 @@ import 'package:natrium_wallet_flutter/util/numberutil.dart';
 import 'package:natrium_wallet_flutter/util/hapticutil.dart';
 import 'package:natrium_wallet_flutter/util/caseconverter.dart';
 import 'package:natrium_wallet_flutter/model/authentication_method.dart';
-import 'package:natrium_wallet_flutter/model/state_block.dart';
 import 'package:natrium_wallet_flutter/model/vault.dart';
 
 import 'changerepresentativemanualentry_sheet.dart';
@@ -38,12 +39,7 @@ class AppChangeRepresentativeSheet {
   // Timer reference so we can cancel repeated events
   Timer _addressCopiedTimer;
 
-  StreamSubscription<RepChangedEvent> _repChangeSub;
-
   Future<bool> _onWillPop() async {
-    if (_repChangeSub != null) {
-      _repChangeSub.cancel();
-    }
     return true;
   }
 
@@ -81,6 +77,8 @@ class AppChangeRepresentativeSheet {
     return '';
   }
 
+  bool _animationOpen = false;
+
   _buildSingleRepresentative(NinjaNode rep, BuildContext context) {
     return Container(
       child: Column(
@@ -96,73 +94,114 @@ class AppChangeRepresentativeSheet {
               if (!NanoAccounts.isValid(NanoAccountType.NANO, rep.account)) {
                   return;
               }
+              // Authenticate
               AuthenticationMethod authMethod = await sl.get<SharedPrefsUtil>().getAuthMethod();
               bool hasBiometrics = await sl.get<BiometricUtil>().hasBiometrics();
-              if (authMethod.method ==
-                      AuthMethod.BIOMETRICS &&
-                  hasBiometrics) {
-                try {
-                  bool authenticated = await sl.get<BiometricUtil>()
-                          .authenticateWithBiometrics(
-                              context,
-                              AppLocalization.of(context)
-                                  .changeRepAuthenticate);
-                  if (authenticated) {
-                    sl
-                        .get<HapticUtil>()
-                        .fingerprintSucess();
-                    Navigator.of(context).push(
-                        AnimationLoadingOverlay(
-                            AnimationType.GENERIC,
-                            StateContainer.of(
-                                    context)
-                                .curTheme
-                                .animationOverlayStrong,
-                            StateContainer.of(
-                                    context)
-                                .curTheme
-                                .animationOverlayMedium));
+              if (authMethod.method == AuthMethod.BIOMETRICS && hasBiometrics) {
+                bool authenticated = await sl.get<BiometricUtil>()
+                            .authenticateWithBiometrics(
+                                context,
+                                AppLocalization.of(
+                                        context)
+                                    .changeRepAuthenticate);
+                if (authenticated) {
+                  sl.get<HapticUtil>().fingerprintSucess();
+                  _animationOpen = true;
+                  Navigator.of(context).push(
+                      AnimationLoadingOverlay(
+                          AnimationType.GENERIC,
+                          StateContainer.of(context)
+                              .curTheme
+                              .animationOverlayStrong,
+                          StateContainer.of(context)
+                              .curTheme
+                              .animationOverlayMedium,
+                          onPoppedCallback: () =>
+                              _animationOpen =
+                                  false));
                     // If account isnt open, just store the account in sharedprefs
-                    if (StateContainer.of(context)
-                            .wallet
-                            .openBlock ==
-                        null) {
-                      sl
-                          .get<SharedPrefsUtil>()
-                          .setRepresentative(
-                              rep.account)
-                          .then((result) {
-                        EventTaxiImpl.singleton()
-                            .fire(RepChangedEvent(
-                                previous: StateBlock(
-                                    representative:
-                                        rep.account,
-                                    previous: "",
-                                    link: "",
-                                    balance: "",
-                                    account: "")));
-                      });
+                    if (StateContainer.of(context).wallet.openBlock == null) {
+                      await sl.get<SharedPrefsUtil>().setRepresentative(rep.account);
+                      StateContainer.of(context).wallet.representative = rep.account;
+                      UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                      Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
                     } else {
-                      StateContainer.of(context)
-                          .requestChange(
-                              StateContainer.of(
-                                      context)
-                                  .wallet
-                                  .frontier,
-                              StateContainer.of(
-                                      context)
-                                  .wallet
-                                  .accountBalance
-                                  .toString(),
-                              rep.account);
+                      try {
+                        ProcessResponse resp = await sl.get<AccountService>().requestChange(
+                          StateContainer.of(context).wallet.address,
+                          rep.account,
+                          StateContainer.of(context).wallet.frontier,
+                          StateContainer.of(context).wallet.accountBalance.toString(),
+                          NanoUtil.seedToPrivate(await StateContainer.of(context).getSeed(), StateContainer.of(context).selectedAccount.index)
+                        );
+                        StateContainer.of(context).wallet.representative = rep.account;
+                        StateContainer.of(context).wallet.frontier = resp.hash;
+                        UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                        Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));                                              
+                      } catch (e) {
+                        sl.get<Logger>().e("Failed to change", e);
+                        if (_animationOpen) {
+                          Navigator.of(context).pop();
+                        }
+                        UIUtil.showSnackbar(AppLocalization.of(context).sendError, context);
+                      }
                     }
-                  }
-                } catch (e) {
-                  await authenticateWithPin(context, rep);
                 }
               } else {
-                await authenticateWithPin(context, rep);
-              }
+                // PIN Authentication
+                String expectedPin = await sl.get<Vault>().getPin();
+                Navigator.of(context).push(
+                    MaterialPageRoute(builder:
+                        (BuildContext context) {
+                  return new PinScreen(
+                    PinOverlayType.ENTER_PIN,
+                    (pin) async {
+                      Navigator.of(context).pop();
+                      Navigator.of(context).push(
+                          AnimationLoadingOverlay(
+                        AnimationType.GENERIC,
+                        StateContainer.of(context)
+                            .curTheme
+                            .animationOverlayStrong,
+                        StateContainer.of(context)
+                            .curTheme
+                            .animationOverlayMedium,
+                      ));
+                      // If account isnt open, just store the account in sharedprefs
+                      if (StateContainer.of(context).wallet.openBlock == null) {
+                        await sl.get<SharedPrefsUtil>().setRepresentative(rep.account);
+                        StateContainer.of(context).wallet.representative = rep.account;
+                        UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                        Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
+                      } else {
+                        try {
+                          ProcessResponse resp = await sl.get<AccountService>().requestChange(
+                            StateContainer.of(context).wallet.address,
+                            rep.account,
+                            StateContainer.of(context).wallet.frontier,
+                            StateContainer.of(context).wallet.accountBalance.toString(),
+                            NanoUtil.seedToPrivate(await StateContainer.of(context).getSeed(), StateContainer.of(context).selectedAccount.index)
+                          );
+                          StateContainer.of(context).wallet.representative = rep.account;
+                          StateContainer.of(context).wallet.frontier = resp.hash;
+                          UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                          Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));                                              
+                        } catch (e) {
+                          sl.get<Logger>().e("Failed to change", e);
+                          if (_animationOpen) {
+                            Navigator.of(context).pop();
+                          }
+                          UIUtil.showSnackbar(AppLocalization.of(context).sendError, context);
+                        }
+                      }                                                
+                    },
+                    expectedPin: expectedPin,
+                    description:
+                        AppLocalization.of(context)
+                            .pinRepChange,
+                  );
+                }));
+              }    
             },
             padding: EdgeInsets.all(0),
             child: Container(
@@ -312,17 +351,6 @@ class AppChangeRepresentativeSheet {
   }
 
   mainBottomSheet(BuildContext context) {
-    _repChangeSub =
-        EventTaxiImpl.singleton().registerTo<RepChangedEvent>().listen((event) {
-      if (event.previous != null) {
-        StateContainer.of(context).wallet.representative =
-            event.previous.representative;
-        UIUtil.showSnackbar(
-            AppLocalization.of(context).changeRepSucces, context);
-        Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
-      }
-    });
-
     AppSheets.showAppHeightEightSheet(
         context: context,
         builder: (BuildContext context) {
@@ -571,77 +599,4 @@ class AppChangeRepresentativeSheet {
           });
         });
   }
-
-  Future<void> authenticateWithPin(BuildContext context, NinjaNode rep) async {
-    // PIN Authentication
-    sl
-        .get<Vault>()
-        .getPin()
-        .then((expectedPin) {
-      Navigator.of(context).push(
-          MaterialPageRoute(builder:
-              (BuildContext context) {
-        return new PinScreen(
-          PinOverlayType.ENTER_PIN,
-          (pin) {
-            Navigator.of(context).pop();
-            Navigator.of(context).push(
-                AnimationLoadingOverlay(
-              AnimationType.GENERIC,
-              StateContainer.of(context)
-                  .curTheme
-                  .animationOverlayStrong,
-              StateContainer.of(context)
-                  .curTheme
-                  .animationOverlayMedium,
-            ));
-            // If account isnt open, just store the account in sharedprefs
-            if (StateContainer.of(
-                        context)
-                    .wallet
-                    .openBlock ==
-                null) {
-              sl
-                  .get<
-                      SharedPrefsUtil>()
-                  .setRepresentative(
-                      rep.account)
-                  .then((result) {
-                EventTaxiImpl
-                        .singleton()
-                    .fire(RepChangedEvent(
-                        previous: StateBlock(
-                            representative:
-                                rep.account,
-                            previous:
-                                "",
-                            link: "",
-                            balance: "",
-                            account:
-                                "")));
-              });
-            } else {
-              StateContainer.of(context)
-                  .requestChange(
-                      StateContainer.of(
-                              context)
-                          .wallet
-                          .frontier,
-                      StateContainer.of(
-                              context)
-                          .wallet
-                          .accountBalance
-                          .toString(),
-                        rep.account);
-            }
-          },
-          expectedPin: expectedPin,
-          description:
-              AppLocalization.of(
-                      context)
-                  .pinRepChange,
-        );
-      }));
-    });
-  }    
 }
diff --git a/lib/ui/settings/changerepresentativemanualentry_sheet.dart b/lib/ui/settings/changerepresentativemanualentry_sheet.dart
index eb4fefaa..e923ed77 100755
--- a/lib/ui/settings/changerepresentativemanualentry_sheet.dart
+++ b/lib/ui/settings/changerepresentativemanualentry_sheet.dart
@@ -7,12 +7,14 @@ import 'package:keyboard_avoider/keyboard_avoider.dart';
 import 'package:flutter_nano_ffi/flutter_nano_ffi.dart';
 import 'package:barcode_scan/barcode_scan.dart';
 import 'package:event_taxi/event_taxi.dart';
+import 'package:logger/logger.dart';
 
 import 'package:natrium_wallet_flutter/appstate_container.dart';
 import 'package:natrium_wallet_flutter/localization.dart';
 import 'package:natrium_wallet_flutter/dimens.dart';
+import 'package:natrium_wallet_flutter/network/account_service.dart';
+import 'package:natrium_wallet_flutter/network/model/response/process_response.dart';
 import 'package:natrium_wallet_flutter/service_locator.dart';
-import 'package:natrium_wallet_flutter/bus/events.dart';
 import 'package:natrium_wallet_flutter/ui/util/ui_util.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/app_text_field.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/sheets.dart';
@@ -23,13 +25,13 @@ import 'package:natrium_wallet_flutter/ui/util/routes.dart';
 import 'package:natrium_wallet_flutter/styles.dart';
 import 'package:natrium_wallet_flutter/app_icons.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/tap_outside_unfocus.dart';
+import 'package:natrium_wallet_flutter/util/nanoutil.dart';
 import 'package:natrium_wallet_flutter/util/sharedprefsutil.dart';
 import 'package:natrium_wallet_flutter/util/biometrics.dart';
 import 'package:natrium_wallet_flutter/util/hapticutil.dart';
 import 'package:natrium_wallet_flutter/util/caseconverter.dart';
 import 'package:natrium_wallet_flutter/model/address.dart';
 import 'package:natrium_wallet_flutter/model/authentication_method.dart';
-import 'package:natrium_wallet_flutter/model/state_block.dart';
 import 'package:natrium_wallet_flutter/model/vault.dart';
 
 // TODO - add validations
@@ -49,28 +51,13 @@ class AppChangeRepresentativeManualEntrySheet {
     _repController = new TextEditingController();
   }
 
-  StreamSubscription<RepChangedEvent> _repChangeSub;
-
   Future<bool> _onWillPop() async {
-    if (_repChangeSub != null) {
-      _repChangeSub.cancel();
-    }
     return true;
   }
 
   mainBottomSheet(BuildContext context) {
     _changeRepHint = AppLocalization.of(context).changeRepHint;
     _repAddressStyle = AppStyles.textStyleAddressText60(context);
-    _repChangeSub =
-        EventTaxiImpl.singleton().registerTo<RepChangedEvent>().listen((event) {
-      if (event.previous != null) {
-        StateContainer.of(context).wallet.representative =
-            event.previous.representative;
-        UIUtil.showSnackbar(
-            AppLocalization.of(context).changeRepSucces, context);
-        Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
-      }
-    });
 
     AppSheets.showAppHeightEightSheet(
         context: context,
@@ -322,77 +309,111 @@ class AppChangeRepresentativeManualEntrySheet {
                                       // Authenticate
                                       AuthenticationMethod authMethod = await sl.get<SharedPrefsUtil>().getAuthMethod();
                                       bool hasBiometrics = await sl.get<BiometricUtil>().hasBiometrics();
-                                      if (authMethod.method ==
-                                              AuthMethod.BIOMETRICS &&
-                                          hasBiometrics) {
-                                        try {
-                                          bool authenticated = await sl
-                                                  .get<BiometricUtil>()
-                                                  .authenticateWithBiometrics(
-                                                      context,
-                                                      AppLocalization.of(context)
-                                                          .changeRepAuthenticate);
-                                          if (authenticated) {
-                                            sl
-                                                .get<HapticUtil>()
-                                                .fingerprintSucess();
-                                            _animationOpen = true;
-                                            Navigator.of(context).push(
-                                                AnimationLoadingOverlay(
-                                                    AnimationType.GENERIC,
-                                                    StateContainer.of(
-                                                            context)
-                                                        .curTheme
-                                                        .animationOverlayStrong,
-                                                    StateContainer.of(
-                                                            context)
-                                                        .curTheme
-                                                        .animationOverlayMedium,
-                                                    onPoppedCallback: () =>
-                                                        _animationOpen =
-                                                            false));
+                                      if (authMethod.method == AuthMethod.BIOMETRICS && hasBiometrics) {
+                                        bool authenticated = await sl.get<BiometricUtil>()
+                                                    .authenticateWithBiometrics(
+                                                        context,
+                                                        AppLocalization.of(
+                                                                context)
+                                                            .changeRepAuthenticate);
+                                        if (authenticated) {
+                                          sl.get<HapticUtil>().fingerprintSucess();
+                                          _animationOpen = true;
+                                          Navigator.of(context).push(
+                                              AnimationLoadingOverlay(
+                                                  AnimationType.GENERIC,
+                                                  StateContainer.of(context)
+                                                      .curTheme
+                                                      .animationOverlayStrong,
+                                                  StateContainer.of(context)
+                                                      .curTheme
+                                                      .animationOverlayMedium,
+                                                  onPoppedCallback: () =>
+                                                      _animationOpen =
+                                                          false));
                                             // If account isnt open, just store the account in sharedprefs
-                                            if (StateContainer.of(context)
-                                                    .wallet
-                                                    .openBlock ==
-                                                null) {
-                                              sl
-                                                  .get<SharedPrefsUtil>()
-                                                  .setRepresentative(
-                                                      _repController.text)
-                                                  .then((result) {
-                                                EventTaxiImpl.singleton()
-                                                    .fire(RepChangedEvent(
-                                                        previous: StateBlock(
-                                                            representative:
-                                                                _repController
-                                                                    .text,
-                                                            previous: "",
-                                                            link: "",
-                                                            balance: "",
-                                                            account: "")));
-                                              });
+                                            if (StateContainer.of(context).wallet.openBlock == null) {
+                                              await sl.get<SharedPrefsUtil>().setRepresentative(_repController.text);
+                                              StateContainer.of(context).wallet.representative = _repController.text;
+                                              UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                                              Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
                                             } else {
-                                              StateContainer.of(context)
-                                                  .requestChange(
-                                                      StateContainer.of(
-                                                              context)
-                                                          .wallet
-                                                          .frontier,
-                                                      StateContainer.of(
-                                                              context)
-                                                          .wallet
-                                                          .accountBalance
-                                                          .toString(),
-                                                      _repController.text);
+                                              try {
+                                                ProcessResponse resp = await sl.get<AccountService>().requestChange(
+                                                  StateContainer.of(context).wallet.address,
+                                                  _repController.text,
+                                                  StateContainer.of(context).wallet.frontier,
+                                                  StateContainer.of(context).wallet.accountBalance.toString(),
+                                                  NanoUtil.seedToPrivate(await sl.get<Vault>().getSeed(), StateContainer.of(context).selectedAccount.index)
+                                                );
+                                                StateContainer.of(context).wallet.representative = _repController.text;
+                                                StateContainer.of(context).wallet.frontier = resp.hash;
+                                                UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                                                Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));                                              
+                                              } catch (e) {
+                                                sl.get<Logger>().e("Failed to change", e);
+                                                if (_animationOpen) {
+                                                  Navigator.of(context).pop();
+                                                }
+                                                UIUtil.showSnackbar(AppLocalization.of(context).sendError, context);
+                                              }
                                             }
-                                          }
-                                        } catch (e) {
-                                          await authenticateWithPin(context);
                                         }
                                       } else {
-                                        await authenticateWithPin(context);
-                                      }
+                                        // PIN Authentication
+                                        String expectedPin = await sl.get<Vault>().getPin();
+                                        Navigator.of(context).push(
+                                            MaterialPageRoute(builder:
+                                                (BuildContext context) {
+                                          return new PinScreen(
+                                            PinOverlayType.ENTER_PIN,
+                                            (pin) async {
+                                              Navigator.of(context).pop();
+                                              Navigator.of(context).push(
+                                                  AnimationLoadingOverlay(
+                                                AnimationType.GENERIC,
+                                                StateContainer.of(context)
+                                                    .curTheme
+                                                    .animationOverlayStrong,
+                                                StateContainer.of(context)
+                                                    .curTheme
+                                                    .animationOverlayMedium,
+                                              ));
+                                              // If account isnt open, just store the account in sharedprefs
+                                              if (StateContainer.of(context).wallet.openBlock == null) {
+                                                await sl.get<SharedPrefsUtil>().setRepresentative(_repController.text);
+                                                StateContainer.of(context).wallet.representative = _repController.text;
+                                                UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                                                Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));
+                                              } else {
+                                                try {
+                                                  ProcessResponse resp = await sl.get<AccountService>().requestChange(
+                                                    StateContainer.of(context).wallet.address,
+                                                    _repController.text,
+                                                    StateContainer.of(context).wallet.frontier,
+                                                    StateContainer.of(context).wallet.accountBalance.toString(),
+                                                    NanoUtil.seedToPrivate(await sl.get<Vault>().getSeed(), StateContainer.of(context).selectedAccount.index)
+                                                  );
+                                                  StateContainer.of(context).wallet.representative = _repController.text;
+                                                  StateContainer.of(context).wallet.frontier = resp.hash;
+                                                  UIUtil.showSnackbar(AppLocalization.of(context).changeRepSucces, context);
+                                                  Navigator.of(context).popUntil(RouteUtils.withNameLike('/home'));                                              
+                                                } catch (e) {
+                                                  sl.get<Logger>().e("Failed to change", e);
+                                                  if (_animationOpen) {
+                                                    Navigator.of(context).pop();
+                                                  }
+                                                  UIUtil.showSnackbar(AppLocalization.of(context).sendError, context);
+                                                }
+                                              }                                                
+                                            },
+                                            expectedPin: expectedPin,
+                                            description:
+                                                AppLocalization.of(context)
+                                                    .pinRepChange,
+                                          );
+                                        }));
+                                      }                        
                                     },
                                   ),
                                 ],
@@ -423,80 +444,4 @@ class AppChangeRepresentativeManualEntrySheet {
           });
         });
   }
-
-  Future<void> authenticateWithPin(BuildContext context) async {
-    // PIN Authentication
-    sl
-        .get<Vault>()
-        .getPin()
-        .then((expectedPin) {
-      Navigator.of(context).push(
-          MaterialPageRoute(builder:
-              (BuildContext context) {
-        return new PinScreen(
-          PinOverlayType.ENTER_PIN,
-          (pin) {
-            Navigator.of(context).pop();
-            Navigator.of(context).push(
-                AnimationLoadingOverlay(
-              AnimationType.GENERIC,
-              StateContainer.of(context)
-                  .curTheme
-                  .animationOverlayStrong,
-              StateContainer.of(context)
-                  .curTheme
-                  .animationOverlayMedium,
-            ));
-            // If account isnt open, just store the account in sharedprefs
-            if (StateContainer.of(
-                        context)
-                    .wallet
-                    .openBlock ==
-                null) {
-              sl
-                  .get<
-                      SharedPrefsUtil>()
-                  .setRepresentative(
-                      _repController
-                          .text)
-                  .then((result) {
-                EventTaxiImpl
-                        .singleton()
-                    .fire(RepChangedEvent(
-                        previous: StateBlock(
-                            representative:
-                                _repController
-                                    .text,
-                            previous:
-                                "",
-                            link: "",
-                            balance: "",
-                            account:
-                                "")));
-              });
-            } else {
-              StateContainer.of(context)
-                  .requestChange(
-                      StateContainer.of(
-                              context)
-                          .wallet
-                          .frontier,
-                      StateContainer.of(
-                              context)
-                          .wallet
-                          .accountBalance
-                          .toString(),
-                      _repController
-                          .text);
-            }
-          },
-          expectedPin: expectedPin,
-          description:
-              AppLocalization.of(
-                      context)
-                  .pinRepChange,
-        );
-      }));
-    });    
-  }
 }
diff --git a/lib/ui/settings/settings_drawer.dart b/lib/ui/settings/settings_drawer.dart
index 13106ae3..158c8f33 100755
--- a/lib/ui/settings/settings_drawer.dart
+++ b/lib/ui/settings/settings_drawer.dart
@@ -154,7 +154,6 @@ class _SettingsSheetState extends State<SettingsSheet>
 
   StreamSubscription<TransferConfirmEvent> _transferConfirmSub;
   StreamSubscription<TransferCompleteEvent> _transferCompleteSub;
-  StreamSubscription<UnlockCallbackEvent> _callbackUnlockSub;
 
   void _registerBus() {
     // Ready to go to transfer confirm
@@ -178,12 +177,6 @@ class _SettingsSheetState extends State<SettingsSheet>
               NumberUtil.getRawAsUsableString(event.amount.toString()))
           .mainBottomSheet(context);
     });
-    // Unlock callback
-    _callbackUnlockSub = EventTaxiImpl.singleton()
-        .registerTo<UnlockCallbackEvent>()
-        .listen((event) {
-      StateContainer.of(context).unlockCallback();
-    });
   }
 
   void _destroyBus() {
@@ -193,9 +186,6 @@ class _SettingsSheetState extends State<SettingsSheet>
     if (_transferCompleteSub != null) {
       _transferCompleteSub.cancel();
     }
-    if (_callbackUnlockSub != null) {
-      _callbackUnlockSub.cancel();
-    }
   }
 
   @override
diff --git a/lib/ui/transfer/transfer_confirm_sheet.dart b/lib/ui/transfer/transfer_confirm_sheet.dart
index 9677ba37..ccbbe940 100755
--- a/lib/ui/transfer/transfer_confirm_sheet.dart
+++ b/lib/ui/transfer/transfer_confirm_sheet.dart
@@ -203,6 +203,7 @@ class _AppTransferConfirmSheetState extends State<AppTransferConfirmSheet> {
   Future<void> processWallets() async {
     BigInt totalTransferred = BigInt.zero;
     try {
+      state.lockCallback();
       for (String account in widget.privKeyBalanceMap.keys) {
         AccountBalanceItem  balanceItem = widget.privKeyBalanceMap[account];
         // Get frontiers first
@@ -265,8 +266,11 @@ class _AppTransferConfirmSheetState extends State<AppTransferConfirmSheet> {
       widget.errorCallback();
       sl.get<Logger>().e("Error processing wallet", e);
       return;
+    } finally {
+      state.unlockCallback();
     }
     try {
+      state.lockCallback();
       // Receive all new blocks to our own account
       PendingResponse pr = await sl.get<AccountService>().getPending(state.wallet.address, 20, includeActive: true);
       Map<String, PendingResponseItem> pendingBlocks = pr.blocks;
@@ -302,6 +306,8 @@ class _AppTransferConfirmSheetState extends State<AppTransferConfirmSheet> {
     } catch (e) {
       // Less-important error
       sl.get<Logger>().e("Error processing wallet", e);
+    } finally {
+      state.unlockCallback();
     }
     EventTaxiImpl.singleton()
         .fire(TransferCompleteEvent(amount: totalTransferred));
diff --git a/lib/ui/transfer/transfer_overview_sheet.dart b/lib/ui/transfer/transfer_overview_sheet.dart
index 45018abf..a73ad820 100755
--- a/lib/ui/transfer/transfer_overview_sheet.dart
+++ b/lib/ui/transfer/transfer_overview_sheet.dart
@@ -9,7 +9,10 @@ import 'package:natrium_wallet_flutter/localization.dart';
 import 'package:natrium_wallet_flutter/dimens.dart';
 import 'package:natrium_wallet_flutter/appstate_container.dart';
 import 'package:natrium_wallet_flutter/bus/events.dart';
+import 'package:natrium_wallet_flutter/network/account_service.dart';
 import 'package:natrium_wallet_flutter/network/model/response/account_balance_item.dart';
+import 'package:natrium_wallet_flutter/network/model/response/accounts_balances_response.dart';
+import 'package:natrium_wallet_flutter/service_locator.dart';
 import 'package:natrium_wallet_flutter/ui/transfer/transfer_manual_entry_sheet.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/sheet_util.dart';
 import 'package:natrium_wallet_flutter/ui/widgets/sheets.dart';
@@ -19,6 +22,7 @@ import 'package:natrium_wallet_flutter/ui/util/ui_util.dart';
 import 'package:natrium_wallet_flutter/styles.dart';
 import 'package:natrium_wallet_flutter/util/caseconverter.dart';
 import 'package:natrium_wallet_flutter/util/nanoutil.dart';
+import 'package:logger/logger.dart';
 
 class AppTransferOverviewSheet {
   static const int NUM_SWEEP = 15; // Number of accounts to sweep from a seed
@@ -30,12 +34,7 @@ class AppTransferOverviewSheet {
 
   bool _animationOpen = false;
 
-  StreamSubscription<AccountsBalancesEvent> _balancesSub;
-
   Future<bool> _onWillPop() async {
-    if (_balancesSub != null) {
-      _balancesSub.cancel();
-    }
     return true;
   }
 
@@ -44,43 +43,6 @@ class AppTransferOverviewSheet {
   }
 
   mainBottomSheet(BuildContext context) {
-    // Handle accounts balances response
-    _balancesSub = EventTaxiImpl.singleton()
-        .registerTo<AccountsBalancesEvent>()
-        .listen((event) {
-      if (event.transfer) {
-        if (_animationOpen) {
-          Navigator.of(context).pop();
-        }
-        List<String> accountsToRemove = List();
-        event.response.balances
-            .forEach((String account, AccountBalanceItem balItem) {
-          account = account.replaceAll("xrb_", "nano_");
-          BigInt balance = BigInt.parse(balItem.balance);
-          BigInt pending = BigInt.parse(balItem.pending);
-          if (balance + pending == BigInt.zero) {
-            accountsToRemove.add(account);
-          } else {
-            // Update balance of this item
-            privKeyBalanceMap[account].balance = balItem.balance;
-            privKeyBalanceMap[account].pending = balItem.pending;
-          }
-        });
-        accountsToRemove.forEach((String account) {
-          privKeyBalanceMap.remove(account);
-        });
-        if (privKeyBalanceMap.length == 0) {
-          UIUtil.showSnackbar(
-              AppLocalization.of(context).transferNoFunds, context);
-          return;
-        }
-        // Go to confirmation screen
-        EventTaxiImpl.singleton()
-            .fire(TransferConfirmEvent(balMap: privKeyBalanceMap));
-        Navigator.of(context).pop();
-      }
-    });
-
     void manualEntryCallback(String seed) {
       Navigator.of(context).pop();
       startTransfer(context, seed, manualEntry: true);
@@ -262,8 +224,8 @@ class AppTransferOverviewSheet {
         });
   }
 
-  void startTransfer(BuildContext context, String seed,
-      {bool manualEntry = false}) {
+  Future<void> startTransfer(BuildContext context, String seed,
+      {bool manualEntry = false}) async {
     // Show loading overlay
     _animationOpen = true;
     AnimationType animation = manualEntry
@@ -277,11 +239,46 @@ class AppTransferOverviewSheet {
       _animationOpen = false;
     }));
     // Get accounts from seed
-    getAccountsFromSeed(context, seed).then((accountsToRequest) {
-      // Make balances request
-      StateContainer.of(context)
-          .requestAccountsBalances(accountsToRequest, fromTransfer: true);
-    });
+    List<String> accounts = await getAccountsFromSeed(context, seed);
+    try {
+      AccountsBalancesResponse resp = await sl.get<AccountService>().requestAccountsBalances(accounts);
+      if (_animationOpen) {
+        Navigator.of(context).pop();
+      }
+      List<String> accountsToRemove = List();
+      resp.balances
+          .forEach((String account, AccountBalanceItem balItem) {
+        BigInt balance = BigInt.parse(balItem.balance);
+        BigInt pending = BigInt.parse(balItem.pending);
+        if (balance + pending == BigInt.zero) {
+          accountsToRemove.add(account);
+        } else {
+          // Update balance of this item
+          privKeyBalanceMap[account].balance = balItem.balance;
+          privKeyBalanceMap[account].pending = balItem.pending;
+        }
+      });
+      accountsToRemove.forEach((String account) {
+        privKeyBalanceMap.remove(account);
+      });
+      if (privKeyBalanceMap.length == 0) {
+        UIUtil.showSnackbar(
+            AppLocalization.of(context).transferNoFunds, context);
+        return;
+      }
+      // Go to confirmation screen
+      EventTaxiImpl.singleton()
+          .fire(TransferConfirmEvent(balMap: privKeyBalanceMap));
+      Navigator.of(context).pop();
+    } catch (e) {
+      sl.get<Logger>().e("error", e);
+      if (_animationOpen) {
+        Navigator.of(context).pop();
+      }
+      UIUtil.showSnackbar(
+        AppLocalization.of(context).sendError,
+        context);
+    }
   }
 
   /// Get NUM_SWEEP accounts from seed to request balances for
