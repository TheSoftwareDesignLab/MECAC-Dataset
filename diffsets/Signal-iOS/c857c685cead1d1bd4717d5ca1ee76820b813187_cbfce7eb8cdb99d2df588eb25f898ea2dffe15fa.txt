diff --git a/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupMessageAttachmentArchiver.swift b/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupMessageAttachmentArchiver.swift
index a8035639d95..e6931f0aeea 100644
--- a/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupMessageAttachmentArchiver.swift
+++ b/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupMessageAttachmentArchiver.swift
@@ -37,6 +37,18 @@ internal class MessageBackupMessageAttachmentArchiver: MessageBackupProtoArchive
         return .success([])
     }
 
+    public func archiveOversizeTextAttachment(
+        messageRowId: Int64,
+        messageId: MessageBackup.InteractionUniqueId,
+        context: MessageBackup.ArchivingContext
+    ) -> MessageBackup.ArchiveInteractionResult<BackupProto_FilePointer?> {
+        return self.archiveSingleAttachment(
+            ownerType: .oversizeText,
+            messageRowId: messageRowId,
+            context: context
+        )
+    }
+
     // MARK: Restoring
 
     public func restoreBodyAttachments(
@@ -241,6 +253,8 @@ internal class MessageBackupMessageAttachmentArchiver: MessageBackupProtoArchive
         )
     }
 
+    // MARK: - Private
+
     internal static func uploadEra() throws -> String {
         // TODO: [Backups] use actual subscription id. For now use a fixed,
         // arbitrary id, so that it never changes.
@@ -254,6 +268,28 @@ internal class MessageBackupMessageAttachmentArchiver: MessageBackupProtoArchive
         return false
     }
 
+    // MARK: Archiving
+
+    private func archiveSingleAttachment(
+        ownerType: AttachmentReference.MessageOwnerTypeRaw,
+        messageRowId: Int64,
+        context: MessageBackup.ArchivingContext
+    ) -> MessageBackup.ArchiveInteractionResult<BackupProto_FilePointer?> {
+        guard
+            let referencedAttachment = attachmentStore.fetchFirstReferencedAttachment(
+                for: ownerType.with(messageRowId: messageRowId),
+                tx: context.tx
+            )
+        else {
+            return .success(nil)
+        }
+
+        let isFreeTierBackup = Self.isFreeTierBackup()
+        return .success(referencedAttachment.asBackupFilePointer(isFreeTierBackup: isFreeTierBackup))
+    }
+
+    // MARK: Restoring
+
     private func restoreAttachments(
         _ attachments: [OwnedAttachmentBackupPointerProto],
         chatItemId: MessageBackup.ChatItemId,
diff --git a/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupTSMessageContentsArchiver.swift b/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupTSMessageContentsArchiver.swift
index 094dce20350..801724485ca 100644
--- a/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupTSMessageContentsArchiver.swift
+++ b/SignalServiceKit/MessageBackup/Archivers/ChatItem/MessageBackupTSMessageContentsArchiver.swift
@@ -268,6 +268,19 @@ class MessageBackupTSMessageContentsArchiver: MessageBackupProtoArchiver {
         }
         standardMessage.text = text
 
+        // Returns nil if no oversize text; this is both how we check and how we archive.
+        let oversizeTextResult = attachmentsArchiver.archiveOversizeTextAttachment(
+            messageRowId: messageRowId,
+            messageId: message.uniqueInteractionId,
+            context: context
+        )
+        switch oversizeTextResult.bubbleUp(ChatItemType.self, partialErrors: &partialErrors) {
+        case .continue(let oversizeTextAttachmentProto):
+            oversizeTextAttachmentProto.map { standardMessage.longText = $0 }
+        case .bubbleUpError(let errorResult):
+            return errorResult
+        }
+
         if let quotedMessage = message.quotedMessage {
             let quote: BackupProto_Quote
             let quoteResult = archiveQuote(
