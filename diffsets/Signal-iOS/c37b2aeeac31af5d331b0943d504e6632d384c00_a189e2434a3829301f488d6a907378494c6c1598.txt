diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift
index 742b0cb594e..47d56ba9171 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift	
@@ -251,8 +251,8 @@ extension ChatListViewController: DatabaseChangeDelegate {
             updateUnreadPaymentNotificationsCountWithSneakyTransaction()
         }
 
-        if !databaseChanges.threadUniqueIds.isEmpty {
-            self.loadCoordinator.scheduleLoad(updatedThreadIds: databaseChanges.threadUniqueIds)
+        if !databaseChanges.threadUniqueIdsForChatListUpdate.isEmpty {
+            self.loadCoordinator.scheduleLoad(updatedThreadIds: databaseChanges.threadUniqueIdsForChatListUpdate)
         }
     }
 
diff --git a/SignalServiceKit/src/Contacts/TSThread.m b/SignalServiceKit/src/Contacts/TSThread.m
index 4d23f3ce014..46d62c987b2 100644
--- a/SignalServiceKit/src/Contacts/TSThread.m
+++ b/SignalServiceKit/src/Contacts/TSThread.m
@@ -407,7 +407,7 @@ - (void)updateWithMessage:(TSInteraction *)message
                             transaction:transaction];
         if (needsToMarkAsVisible) {
             // Non-visible threads don't get indexed, so if we're becoming visible for the first time...
-            [SDSDatabaseStorage.shared touchThread:self shouldReindex:true transaction:transaction];
+            [SDSDatabaseStorage.shared touchThread:self shouldReindex:YES transaction:transaction];
         }
         if (needsToClearLastVisibleSortId) {
             [self clearLastVisibleInteractionWithTransaction:transaction];
diff --git a/SignalServiceKit/src/Contacts/Threads/TSGroupThread.h b/SignalServiceKit/src/Contacts/Threads/TSGroupThread.h
index 4f3e6da9ece..06709d12b5d 100644
--- a/SignalServiceKit/src/Contacts/Threads/TSGroupThread.h
+++ b/SignalServiceKit/src/Contacts/Threads/TSGroupThread.h
@@ -92,6 +92,16 @@ NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:conversationColorNa
 // This method should only be called by GroupManager.
 - (void)updateWithGroupModel:(TSGroupModel *)groupModel transaction:(SDSAnyWriteTransaction *)transaction;
 
+/// The `shouldUpdateChatListUi` parameter denotes whether the update of
+/// this group thread should trigger an update of the chat list UI (which
+/// is expensive; we don't want to do it unless we have to). In practice,
+/// `shouldUpdateChatListUi` should be true when the changes are user-facing.
+/// Multiple collapsed updates have `shouldUpdateChatListUi` if it is true
+/// for any of them.
+- (void)updateWithGroupModel:(TSGroupModel *)groupModel
+      shouldUpdateChatListUi:(BOOL)shouldUpdateChatListUi
+                 transaction:(SDSAnyWriteTransaction *)transaction;
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Contacts/Threads/TSGroupThread.m b/SignalServiceKit/src/Contacts/Threads/TSGroupThread.m
index 7d48acd015e..4bd6d3d0e25 100644
--- a/SignalServiceKit/src/Contacts/Threads/TSGroupThread.m
+++ b/SignalServiceKit/src/Contacts/Threads/TSGroupThread.m
@@ -140,7 +140,14 @@ + (NSString *)defaultGroupName
     return OWSLocalizedString(@"NEW_GROUP_DEFAULT_TITLE", @"");
 }
 
-- (void)updateWithGroupModel:(TSGroupModel *)newGroupModel transaction:(SDSAnyWriteTransaction *)transaction
+- (void)updateWithGroupModel:(TSGroupModel *)groupModel transaction:(SDSAnyWriteTransaction *)transaction
+{
+    [self updateWithGroupModel:groupModel shouldUpdateChatListUi:YES transaction:transaction];
+}
+
+- (void)updateWithGroupModel:(TSGroupModel *)newGroupModel
+      shouldUpdateChatListUi:(BOOL)shouldUpdateChatListUi
+                 transaction:(SDSAnyWriteTransaction *)transaction
 {
     OWSAssertDebug(newGroupModel);
     OWSAssertDebug(transaction);
@@ -177,7 +184,10 @@ - (void)updateWithGroupModel:(TSGroupModel *)newGroupModel transaction:(SDSAnyWr
     [self updateGroupMemberRecordsWithTransaction:transaction];
 
     // We only need to re-index the group if the group name changed.
-    [SDSDatabaseStorage.shared touchThread:self shouldReindex:didNameChange transaction:transaction];
+    [SDSDatabaseStorage.shared touchThread:self
+                             shouldReindex:didNameChange
+                    shouldUpdateChatListUi:shouldUpdateChatListUi
+                               transaction:transaction];
 
     if (didAvatarChange) {
         [transaction addAsyncCompletionOnMain:^{ [self fireAvatarChangedNotification]; }];
diff --git a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage/SDSDatabaseStorage.swift b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage/SDSDatabaseStorage.swift
index 88ca30c412d..cc297f47e15 100644
--- a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage/SDSDatabaseStorage.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage/SDSDatabaseStorage.swift
@@ -312,13 +312,14 @@ public class SDSDatabaseStorage: SDSTransactable {
         }
     }
 
-    @objc(touchThread:shouldReindex:transaction:)
-    public func touch(thread: TSThread, shouldReindex: Bool, transaction: SDSAnyWriteTransaction) {
+    /// See note on `shouldUpdateChatListUi` parameter in docs for ``TSGroupThread.updateWithGroupModel:shouldUpdateChatListUi:transaction``.
+    @objc(touchThread:shouldReindex:shouldUpdateChatListUi:transaction:)
+    public func touch(thread: TSThread, shouldReindex: Bool, shouldUpdateChatListUi: Bool, transaction: SDSAnyWriteTransaction) {
         switch transaction.writeTransaction {
         case .grdbWrite(let grdb):
             DatabaseChangeObserver.serializedSync {
                 if let databaseChangeObserver = grdbStorage.databaseChangeObserver {
-                    databaseChangeObserver.didTouch(thread: thread, transaction: grdb)
+                    databaseChangeObserver.didTouch(thread: thread, shouldUpdateChatListUi: shouldUpdateChatListUi, transaction: grdb)
                 } else if AppReadiness.isAppReady {
                     // This can race with observation setup when app becomes ready.
                     Logger.warn("databaseChangeObserver was unexpectedly nil")
@@ -330,6 +331,11 @@ public class SDSDatabaseStorage: SDSTransactable {
         }
     }
 
+    @objc(touchThread:shouldReindex:transaction:)
+    public func touch(thread: TSThread, shouldReindex: Bool, transaction: SDSAnyWriteTransaction) {
+        touch(thread: thread, shouldReindex: shouldReindex, shouldUpdateChatListUi: true, transaction: transaction)
+    }
+
     @objc(touchStoryMessage:transaction:)
     public func touch(storyMessage: StoryMessage, transaction: SDSAnyWriteTransaction) {
         switch transaction.writeTransaction {
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift b/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift
index d8d7862b5bf..667c5085b32 100644
--- a/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift
@@ -325,14 +325,16 @@ extension DatabaseChangeObserver: TransactionObserver {
         didModifyPendingChanges()
     }
 
-    // internal - should only be called by DatabaseStorage
-    func didTouch(thread: TSThread, transaction: GRDBWriteTransaction) {
+    /// internal - should only be called by DatabaseStorage
+    ///
+    /// See note on `shouldUpdateChatListUi` parameter in docs for ``TSGroupThread.updateWithGroupModel:shouldUpdateChatListUi:transaction``.
+    func didTouch(thread: TSThread, shouldUpdateChatListUi: Bool = true, transaction: GRDBWriteTransaction) {
         // Note: We don't actually use the `transaction` param, but touching must happen within
-        // a write transaction in order for the touch machinery to notify it's observers
+        // a write transaction in order for the touch machinery to notify its observers
         // in the expected way.
         AssertHasDatabaseChangeObserverLock()
 
-        pendingChanges.append(thread: thread)
+        pendingChanges.append(thread: thread, shouldUpdateChatListUi: shouldUpdateChatListUi)
         pendingChanges.append(tableName: TSThread.table.tableName)
 
         didModifyPendingChanges()
@@ -417,6 +419,7 @@ extension DatabaseChangeObserver: TransactionObserver {
 
                 let interactionUniqueIds = pendingChangesToCommit.interactionUniqueIds
                 let threadUniqueIds = pendingChangesToCommit.threadUniqueIds
+                let uniqueIdToShouldUpdateChatListUiDict = pendingChangesToCommit.uniqueIdToShouldUpdateChatListUiDict
                 let storyMessageUniqueIds = pendingChangesToCommit.storyMessageUniqueIds
                 let storyMessageRowIds = pendingChangesToCommit.storyMessageRowIds
                 let interactionDeletedUniqueIds = pendingChangesToCommit.interactionDeletedUniqueIds
@@ -426,7 +429,7 @@ extension DatabaseChangeObserver: TransactionObserver {
 
                 Self.committedChangesLock.withLock {
                     self.committedChanges.append(interactionUniqueIds: interactionUniqueIds)
-                    self.committedChanges.append(threadUniqueIds: threadUniqueIds)
+                    self.committedChanges.append(threadUniqueIds: threadUniqueIds, shouldUpdateChatListUiDictParam: uniqueIdToShouldUpdateChatListUiDict)
                     self.committedChanges.append(storyMessageUniqueIds: storyMessageUniqueIds)
                     self.committedChanges.append(storyMessageRowIds: storyMessageRowIds)
                     self.committedChanges.append(interactionDeletedUniqueIds: interactionDeletedUniqueIds)
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift b/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift
index cbd9324f825..ca9ef5ef751 100644
--- a/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift
@@ -12,6 +12,12 @@ public protocol DatabaseChanges: AnyObject {
     typealias RowId = Int64
 
     var threadUniqueIds: Set<UniqueId> { get }
+    /// Unique ids for threads that have been changed in a user-facing way
+    /// that should affect the chat list UI.
+    var threadUniqueIdsForChatListUpdate: Set<UniqueId> { get }
+    /// Dictionary mapping thread uniqueIds to whether their corresponding
+    /// UI in the chat list should be updated.
+    var uniqueIdToShouldUpdateChatListUiDict: [String: Bool] { get }
     var interactionUniqueIds: Set<UniqueId> { get }
     var storyMessageUniqueIds: Set<UniqueId> { get }
     var storyMessageRowIds: Set<RowId> { get }
@@ -128,29 +134,42 @@ class ObservedDatabaseChanges: NSObject {
     // MARK: - Threads
 
     private var threads = ObservedModelChanges()
+    private var uniqueIdToShouldUpdateChatListUi = [String: Bool]()
 
-    func append(thread: TSThread) {
-        #if TESTABLE_BUILD
-        checkConcurrency()
-        #endif
-
-        threads.append(model: thread)
+    var threadUniqueIdsForChatListUpdate: Set<UniqueId> {
+        return threadUniqueIds.filter {
+            uniqueIdToShouldUpdateChatListUi[$0] == true
+        }
     }
 
-    func append(threadUniqueId: UniqueId) {
+    func append(thread: TSThread, shouldUpdateChatListUi: Bool = true) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        threads.append(uniqueId: threadUniqueId)
+        threads.append(model: thread)
+        // If `shouldUpdateChatListUi` is false, it is important that we set the value
+        // in the dictionary to false, rather than leaving it as nil. The code in
+        // `self.mapRowIdsToUniqueIds` relies on this.
+        uniqueIdToShouldUpdateChatListUi[thread.uniqueId] = (uniqueIdToShouldUpdateChatListUi[thread.uniqueId] ?? false) || shouldUpdateChatListUi
     }
 
-    func append(threadUniqueIds: Set<UniqueId>) {
+    func append(
+        threadUniqueIds: Set<UniqueId>,
+        shouldUpdateChatListUiDictParam: [String: Bool]
+    ) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
         threads.append(uniqueIds: threadUniqueIds)
+        for (key, value) in shouldUpdateChatListUiDictParam {
+            // In practice, `uniqueIdToShouldUpdateChatListUi` should always be empty to start
+            // with because this method is only called on a fresh `ObservedDatabaseChanges`
+            // object. However, we do this OR defensively.
+            let oldShouldUpdateChatListUi = uniqueIdToShouldUpdateChatListUi[key] ?? false
+            uniqueIdToShouldUpdateChatListUi[key] = oldShouldUpdateChatListUi || value
+        }
     }
 
     func append(threadRowId: RowId) {
@@ -161,14 +180,6 @@ class ObservedDatabaseChanges: NSObject {
         threads.append(rowId: threadRowId)
     }
 
-    func append(threadRowIds: Set<RowId>) {
-        #if TESTABLE_BUILD
-        checkConcurrency()
-        #endif
-
-        threads.append(rowIds: threadRowIds)
-    }
-
     // MARK: - Interactions
 
     private var interactions = ObservedModelChanges()
@@ -388,6 +399,14 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         return threads.uniqueIds
     }
 
+    var uniqueIdToShouldUpdateChatListUiDict: [String: Bool] {
+        #if TESTABLE_BUILD
+        checkConcurrency()
+        #endif
+
+        return uniqueIdToShouldUpdateChatListUi
+    }
+
     var interactionUniqueIds: Set<UniqueId> {
         #if TESTABLE_BUILD
         checkConcurrency()
@@ -491,7 +510,8 @@ extension ObservedDatabaseChanges: DatabaseChanges {
                                                            uniqueIds: threads.uniqueIds,
                                                            rowIdToUniqueIdMap: threads.rowIdToUniqueIdMap,
                                                            tableName: "\(ThreadRecord.databaseTableName)",
-                                                           uniqueIdColumnName: "\(threadColumn: .uniqueId)"))
+                                                           uniqueIdColumnName: "\(threadColumn: .uniqueId)",
+                                                           isMappingForThreads: true))
 
         // We need to convert all interaction "row ids" to "unique ids".
         interactions.append(uniqueIds: try mapRowIdsToUniqueIds(db: db,
@@ -518,7 +538,8 @@ extension ObservedDatabaseChanges: DatabaseChanges {
                                       uniqueIds: Set<UniqueId>,
                                       rowIdToUniqueIdMap: [RowId: UniqueId],
                                       tableName: String,
-                                      uniqueIdColumnName: String) throws -> Set<String> {
+                                      uniqueIdColumnName: String,
+                                      isMappingForThreads: Bool = false) throws -> Set<String> {
         AssertHasDatabaseChangeObserverLock()
 
         // We try to avoid the query below by leveraging the
@@ -532,6 +553,13 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         for rowId in rowIds {
             if let uniqueId = rowIdToUniqueIdMap[rowId] {
                 allUniqueIds.insert(uniqueId)
+                if isMappingForThreads, uniqueIdToShouldUpdateChatListUi[uniqueId] == nil {
+                    /// When we aren't sure whether a changed thread should trigger a
+                    /// chat list UI update, we want to do so to be safe. If there is
+                    /// already a value for this uniqueId in `uniqueIdToShouldUpdateChatListUi`,
+                    /// we can trust that this is correct and do not want to override it.
+                    uniqueIdToShouldUpdateChatListUi[uniqueId] = true
+                }
             } else {
                 unresolvedRowIds.append(rowId)
             }
@@ -556,6 +584,17 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         WHERE rowid IN \(rowIdsSQL)
         """
         let fetchedUniqueIds = try String.fetchAll(db, sql: mappingSql)
+        if isMappingForThreads {
+            for id in fetchedUniqueIds {
+                if uniqueIdToShouldUpdateChatListUi[id] == nil {
+                    /// When we aren't sure whether a changed thread should trigger a
+                    /// chat list UI update, we want to do so to be safe. If there is
+                    /// already a value for this uniqueId in `uniqueIdToShouldUpdateChatListUi`,
+                    /// we can trust that this is correct and do not want to override it.
+                    uniqueIdToShouldUpdateChatListUi[id] = true
+                }
+            }
+        }
         allUniqueIds.formUnion(fetchedUniqueIds)
 
         guard allUniqueIds.count < DatabaseChangeObserver.kMaxIncrementalRowChanges else {
diff --git a/SignalServiceKit/src/groups/GroupManager.swift b/SignalServiceKit/src/groups/GroupManager.swift
index cc2ad405729..00d1bc18ccb 100644
--- a/SignalServiceKit/src/groups/GroupManager.swift
+++ b/SignalServiceKit/src/groups/GroupManager.swift
@@ -1269,7 +1269,7 @@ public class GroupManager: NSObject {
 
             TSGroupThread.ensureGroupIdMapping(forGroupId: newGroupModel.groupId, transaction: transaction)
 
-            groupThread.update(with: newGroupModel, transaction: transaction)
+            groupThread.update(with: newGroupModel, shouldUpdateChatListUi: hasUserFacingChange, transaction: transaction)
 
             let action: UpsertGroupResult.Action = (hasUserFacingChange
                                                         ? .updatedWithUserFacingChanges
