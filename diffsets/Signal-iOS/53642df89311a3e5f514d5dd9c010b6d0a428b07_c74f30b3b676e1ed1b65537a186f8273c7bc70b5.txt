diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 09c88669d2f..0ee77319f6e 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -1264,6 +1264,8 @@
 		F95427E6286E042200314EDA /* BadgeGiftingThanksSheet.swift in Sources */ = {isa = PBXBuildFile; fileRef = F95427E5286E042200314EDA /* BadgeGiftingThanksSheet.swift */; };
 		F963164B291AE06C00218FB7 /* OWSScrubbingLogFormatterTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F963164A291AE06C00218FB7 /* OWSScrubbingLogFormatterTest.swift */; };
 		F963F816292D1B5B007DBBBD /* UIButton+SignalUI.swift in Sources */ = {isa = PBXBuildFile; fileRef = F963F815292D1B5B007DBBBD /* UIButton+SignalUI.swift */; };
+		F963F818292D7E53007DBBBD /* FormattedNumberField.swift in Sources */ = {isa = PBXBuildFile; fileRef = F963F817292D7E53007DBBBD /* FormattedNumberField.swift */; };
+		F963F81A292DA8E2007DBBBD /* FormattedNumberFieldTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F963F819292DA8E2007DBBBD /* FormattedNumberFieldTest.swift */; };
 		F969C2CF2922DD6F00E19786 /* OWSDisappearingMessageFinderTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F969C2CE2922DD6F00E19786 /* OWSDisappearingMessageFinderTest.swift */; };
 		F96A534328A1AE7C003262D4 /* OutgoingGroupUpdateMessage.swift in Sources */ = {isa = PBXBuildFile; fileRef = F96A534228A1AE7B003262D4 /* OutgoingGroupUpdateMessage.swift */; };
 		F96B66A92912B88B004FFFAA /* DonateViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F96B66A02912B88A004FFFAA /* DonateViewController.swift */; };
@@ -3636,6 +3638,8 @@
 		F95427E5286E042200314EDA /* BadgeGiftingThanksSheet.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeGiftingThanksSheet.swift; sourceTree = "<group>"; };
 		F963164A291AE06C00218FB7 /* OWSScrubbingLogFormatterTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSScrubbingLogFormatterTest.swift; sourceTree = "<group>"; };
 		F963F815292D1B5B007DBBBD /* UIButton+SignalUI.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "UIButton+SignalUI.swift"; sourceTree = "<group>"; };
+		F963F817292D7E53007DBBBD /* FormattedNumberField.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FormattedNumberField.swift; sourceTree = "<group>"; };
+		F963F819292DA8E2007DBBBD /* FormattedNumberFieldTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FormattedNumberFieldTest.swift; sourceTree = "<group>"; };
 		F965C5B87BFDF8F86556C04C /* Pods-SignalNSE.profiling.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalNSE.profiling.xcconfig"; path = "Pods/Target Support Files/Pods-SignalNSE/Pods-SignalNSE.profiling.xcconfig"; sourceTree = "<group>"; };
 		F969C2CE2922DD6F00E19786 /* OWSDisappearingMessageFinderTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSDisappearingMessageFinderTest.swift; sourceTree = "<group>"; };
 		F96A534228A1AE7B003262D4 /* OutgoingGroupUpdateMessage.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OutgoingGroupUpdateMessage.swift; sourceTree = "<group>"; };
@@ -5160,6 +5164,7 @@
 		34A954B7271A471300B05242 /* SignalUITests */ = {
 			isa = PBXGroup;
 			children = (
+				F963F819292DA8E2007DBBBD /* FormattedNumberFieldTest.swift */,
 				34BB78B8272C51E800DA0D04 /* MobileCoinHelperTests.swift */,
 				509913BD2913274100F34F8E /* PhoneNumberFinderTests.swift */,
 			);
@@ -5217,6 +5222,7 @@
 				34A955B1271B53F600B05242 /* BlockListUIUtils.h */,
 				34A955B0271B53F600B05242 /* BlockListUIUtils.m */,
 				34A95506271B510400B05242 /* ConversationStyle.swift */,
+				F963F817292D7E53007DBBBD /* FormattedNumberField.swift */,
 				34A955AD271B532F00B05242 /* FullTextSearcher.swift */,
 				34A955AF271B53F500B05242 /* GroupManager+GroupInvites.swift */,
 				34A95507271B510400B05242 /* GroupViewUtils.swift */,
@@ -9793,6 +9799,7 @@
 				3402AA56271D9DCD0084CBAE /* FindByPhoneNumberViewController.swift in Sources */,
 				88B98704288089C200F8C74D /* FingerprintViewController.m in Sources */,
 				88B98703288089C200F8C74D /* FingerprintViewScanController.m in Sources */,
+				F963F818292D7E53007DBBBD /* FormattedNumberField.swift in Sources */,
 				34A955AE271B533000B05242 /* FullTextSearcher.swift in Sources */,
 				3402AA91271D9E180084CBAE /* GalleryRailView.swift in Sources */,
 				3402AAA9271D9E180084CBAE /* GradientView.swift in Sources */,
@@ -9953,6 +9960,7 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				F963F81A292DA8E2007DBBBD /* FormattedNumberFieldTest.swift in Sources */,
 				34BB78B9272C51E800DA0D04 /* MobileCoinHelperTests.swift in Sources */,
 				509913BE2913274100F34F8E /* PhoneNumberFinderTests.swift in Sources */,
 			);
diff --git a/Signal/src/ViewControllers/Donations/CreditOrDebitCardDonationViewController.swift b/Signal/src/ViewControllers/Donations/CreditOrDebitCardDonationViewController.swift
index 6684489458e..f15ed89fdb0 100644
--- a/Signal/src/ViewControllers/Donations/CreditOrDebitCardDonationViewController.swift
+++ b/Signal/src/ViewControllers/Donations/CreditOrDebitCardDonationViewController.swift
@@ -45,11 +45,6 @@ class CreditOrDebitCardDonationViewController: OWSTableViewController2 {
 
     // MARK: - Events
 
-    @objc
-    private func didTextFieldChange() {
-        render()
-    }
-
     private func didSubmit() {
         switch formState {
         case .invalid, .potentiallyValid:
@@ -172,9 +167,7 @@ class CreditOrDebitCardDonationViewController: OWSTableViewController2 {
         result.spellCheckingType = .no
         result.keyboardType = .numberPad
         result.textContentType = .creditCardNumber
-
         result.delegate = self
-        result.addTarget(self, action: #selector(didTextFieldChange), for: .allEditingEvents)
 
         return result
     }
@@ -190,6 +183,26 @@ class CreditOrDebitCardDonationViewController: OWSTableViewController2 {
 
     // MARK: Card number
 
+    static func formatCardNumber(unformatted: String) -> String {
+        var gaps: Set<Int>
+        switch CreditAndDebitCards.cardType(ofNumber: unformatted) {
+        case .americanExpress: gaps = [4, 10]
+        case .unionPay, .other: gaps = [4, 8, 12]
+        }
+
+        var result = [Character]()
+        for (i, character) in unformatted.enumerated() {
+            if gaps.contains(i) {
+                result.append(" ")
+            }
+            result.append(character)
+        }
+        if gaps.contains(unformatted.count) {
+            result.append(" ")
+        }
+        return String(result)
+    }
+
     private lazy var cardNumberTextField: UITextField = {
         let result = textField()
         result.returnKeyType = .next
@@ -225,6 +238,32 @@ class CreditOrDebitCardDonationViewController: OWSTableViewController2 {
 
     // MARK: Expiration date
 
+    static func formatExpirationDate(unformatted: String) -> String {
+        switch unformatted.count {
+        case 0:
+            return unformatted
+        case 1:
+            let firstDigit = unformatted.first!
+            switch firstDigit {
+            case "0", "1": return unformatted
+            default: return unformatted + "/"
+            }
+        case 2:
+            if (UInt8(unformatted) ?? 0).isValidAsMonth {
+                return unformatted + "/"
+            } else {
+                return "\(unformatted.prefix(1))/\(unformatted.suffix(1))"
+            }
+        default:
+            let firstTwo = unformatted.prefix(2)
+            let firstTwoAsMonth = UInt8(String(firstTwo)) ?? 0
+            let monthCount = firstTwoAsMonth.isValidAsMonth ? 2 : 1
+            let month = unformatted.prefix(monthCount)
+            let year = unformatted.suffix(unformatted.count - monthCount)
+            return "\(month)/\(year)"
+        }
+    }
+
     private lazy var expirationDateTextField: UITextField = {
         let result = textField()
         result.returnKeyType = .next
@@ -338,11 +377,41 @@ class CreditOrDebitCardDonationViewController: OWSTableViewController2 {
 // MARK: - UITextViewDelegate
 
 extension CreditOrDebitCardDonationViewController: UITextFieldDelegate {
-    func textView(
-        _ textView: UITextView,
-        shouldChangeTextIn range: NSRange,
-        replacementText text: String
+    func textField(
+        _ textField: UITextField,
+        shouldChangeCharactersIn range: NSRange,
+        replacementString: String
     ) -> Bool {
-        text.isAsciiDigitsOnly
+        let maxDigits: Int
+        let format: (String) -> String
+        switch textField {
+        case cardNumberTextField:
+            maxDigits = 19
+            format = Self.formatCardNumber
+        case expirationDateTextField:
+            maxDigits = 4
+            format = Self.formatExpirationDate
+        case cvvTextField:
+            maxDigits = 4
+            format = { $0 }
+        default:
+            owsFail("Unexpected text field")
+        }
+
+        let result = FormattedNumberField.textField(
+            textField,
+            shouldChangeCharactersIn: range,
+            replacementString: replacementString,
+            maxDigits: maxDigits,
+            format: format
+        )
+
+        render()
+
+        return result
     }
 }
+
+fileprivate extension UInt8 {
+    var isValidAsMonth: Bool { self >= 1 && self <= 12 }
+}
diff --git a/Signal/test/ViewControllers/CreditOrDebitCardDonationViewControllerTest.swift b/Signal/test/ViewControllers/CreditOrDebitCardDonationViewControllerTest.swift
index 81247cd199d..35a6e5bf42e 100644
--- a/Signal/test/ViewControllers/CreditOrDebitCardDonationViewControllerTest.swift
+++ b/Signal/test/ViewControllers/CreditOrDebitCardDonationViewControllerTest.swift
@@ -7,6 +7,82 @@ import XCTest
 @testable import Signal
 
 final class CreditOrDebitCardDonationViewControllerTest: XCTestCase {
+    // MARK: - Formatting tests
+
+    func testFormatCardNumber() {
+        // We test this by "round-tripping".
+        let testCases: [String] = [
+            "",
+            // American Express
+            "37",
+            "3782 ",
+            "3782 822463 ",
+            "3782 822463 10005",
+            "3782 822463 100051234",
+            // UnionPay
+            "6200 ",
+            "6200 0",
+            "6200 0000 00",
+            "6200 0000 0000 000",
+            "6200 0000 0000 0000",
+            "6200 0000 0000 0000000",
+            // Other types
+            "42",
+            "4242 4242 ",
+            "4242 4242 4242 4242",
+            "4242 4242 4242 4242424"
+        ]
+
+        for testCase in testCases {
+            let reformatted = CreditOrDebitCardDonationViewController.formatCardNumber(
+                unformatted: testCase.asciiDigitsOnly
+            )
+            XCTAssertEqual(reformatted, testCase)
+        }
+    }
+
+    func testFormatExpirationDate() {
+        // We test this by "round-tripping".
+        let testCases: [String] = [
+            "",
+            "0",
+            "1",
+            "2/",
+            "9/",
+            "01/",
+            "02/",
+            "10/",
+            "11/",
+            "12/",
+            "1/3",
+            "1/9",
+            "2/3",
+            "2/00",
+            "2/34",
+            "01/00",
+            "01/23",
+            "02/00",
+            "02/34",
+            "10/98",
+            "12/34",
+            // These cases aren't that important because they're invalid.
+            // If these tests fail, that's probably fine.
+            // We mostly want to ensure they don't crash.
+            "1/345",
+            "0/0",
+            "0/000"
+        ]
+
+        for testCase in testCases {
+            let reformatted = CreditOrDebitCardDonationViewController.formatExpirationDate(
+                unformatted: testCase.asciiDigitsOnly
+            )
+            XCTAssertEqual(reformatted, testCase)
+        }
+    }
+
+    // MARK: - Form state tests
+
     // Field validity is largely tested elsewhere
     // (for example, the specifics of CVV validation).
 
diff --git a/SignalUI/Utils/FormattedNumberField.swift b/SignalUI/Utils/FormattedNumberField.swift
new file mode 100644
index 00000000000..e7c6470ca6c
--- /dev/null
+++ b/SignalUI/Utils/FormattedNumberField.swift
@@ -0,0 +1,335 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+import UIKit
+import SignalServiceKit
+
+/// Attach this to a ``UITextField`` to auto-format it and restrict input to
+/// ASCII digits.
+///
+/// For example, this can be used to format credit card numbers.
+///
+/// This could be made more generic (for example, supporting non-numbers or more
+/// powerful formatting), but it works well enough for us.
+///
+/// You may wish to see the tests, which demonstrate how this behaves.
+public enum FormattedNumberField {
+    struct OperationResult {
+        let formattedString: String
+        let cursorPosition: Int
+    }
+
+    enum SingleDeletionDirection {
+        case backward
+        case forward
+    }
+
+    /// Call this from your [`UITextFieldDelgate#textField`][0] method.
+    /// This will restrict inputs and format the text.
+    ///
+    /// - Parameter textField:
+    /// The text field. Pass the value from your delegate method.
+    /// - Parameter shouldChangeCharactersIn:
+    /// The range to be replaced. Pass the value from your delegate method.
+    /// - Parameter replacementString:
+    /// The replacement string. Pass the value from your delegate method.
+    /// - Parameter maxDigits:
+    /// The maximum number of digits allowed. Trying to type more digits than
+    /// this won't be allowed, but it's possible for the field to be longer
+    /// than this if you set the value programatically or change this value.
+    /// - Parameter format:
+    /// A function that turns an unformatted string (such as "42424242") into
+    /// a formatted one (such as "4242 4242"). Must only include printable ASCII
+    /// characters, and no numbers should be added, removed, or moved during
+    /// formatting. (Printable ASCII characters are required because
+    /// `UITextField` deals with UTF-16 code points and we don't want to handle
+    /// any trickiness with conversion to UTF-8.)
+    /// - Returns:
+    /// `false`, which is what the caller should return.
+    ///
+    /// [0]: https://developer.apple.com/documentation/uikit/uitextfielddelegate/1619599-textfield
+    public static func textField(
+        _ textField: UITextField,
+        shouldChangeCharactersIn range: NSRange,
+        replacementString: String,
+        maxDigits: Int,
+        format: (String) -> String
+    ) -> Bool {
+        let operationResult: OperationResult? = {
+            let oldFormattedString = textField.text ?? ""
+            let isSingleDeletion = range.length == 1 && replacementString.isEmpty
+            if isSingleDeletion {
+                let cursorPosition = textField.offset(
+                    from: textField.beginningOfDocument,
+                    to: textField.selectedTextRange?.start ?? textField.beginningOfDocument
+                )
+                return singleDelete(
+                    formattedString: oldFormattedString,
+                    cursorPosition: cursorPosition,
+                    direction: cursorPosition == range.location ? .forward : .backward,
+                    format: format
+                )
+            } else {
+                return insertOrReplace(
+                    formattedString: oldFormattedString,
+                    selectionStart: range.location,
+                    selectionEnd: range.upperBound,
+                    rawInsertion: replacementString,
+                    maxDigits: maxDigits,
+                    format: format
+                )
+            }
+        }()
+
+        if let operationResult {
+            textField.text = operationResult.formattedString
+            let newCursorPosition = textField.position(
+                from: textField.beginningOfDocument,
+                offset: operationResult.cursorPosition
+            )
+            guard let newCursorPosition else {
+                owsFail("Could not get cursor position after formatting")
+            }
+            textField.selectedTextRange = textField.textRange(from: newCursorPosition, to: newCursorPosition)
+        }
+
+        return false
+    }
+
+    // MARK: - Abstract operation logic
+
+    /// Turn a position inside a formatted string into the position in an
+    /// unformatted version of the string.
+    ///
+    /// For example, imagine the formatter inserts a space between every pair
+    /// of digits, so `1234567` becomes `12 34 56 7`, and that your cursor is
+    /// just before the 7 (represented by the `|`):
+    ///
+    ///     12 34 56 |7
+    ///
+    /// The position in the unformatted string is also just before the 7, but
+    /// numerically lower:
+    ///
+    ///     123456|7
+    ///
+    /// - Precondition:
+    /// The position is actually in the string.
+    /// - Parameter formattedString:
+    /// The formatted string (`12 34 56 7` in the example above).
+    /// - Parameter positionInFormattedString:
+    /// The position in the formatted string (`9` in the example above).
+    /// - Returns:
+    /// The position in the unformatted string (`6` in the example above).
+    private static func unformattedPosition(
+        formattedString: String,
+        positionInFormattedString: Int
+    ) -> Int {
+        formattedString
+            .prefix(positionInFormattedString)
+            .reduce(0) { $0 + ($1.isNumber ? 1 : 0) }
+    }
+
+    /// Turn the cursor position inside an unformatted string into the cursor
+    /// position in a formatted version of the string.
+    ///
+    /// For example, imagine the formatter inserts a space between every pair
+    /// of digits, so `1234567` becomes `12 34 56 7`, and that your cursor is
+    /// just before the 7 (represented by the `|`):
+    ///
+    ///     123456|7
+    ///
+    /// The position in the formatted string is between the 6 and the 7. It
+    /// could be in either of these two spots:
+    ///
+    ///     12 34 56| 7
+    ///     12 34 56 |7
+    ///
+    /// Because it's ambiguous, we return the upper and lower bounds.
+    ///
+    /// - Precondition:
+    /// The position is actually in the string.
+    /// - Parameter formattedString:
+    /// The formatted string (`12 34 56 7` in the example above).
+    /// - Parameter unformattedString:
+    /// The formatted string (`1234567` in the example above).
+    /// - Parameter positionInUnformattedString:
+    /// The position in the unformatted string (`6` in the example above).
+    /// - Returns:
+    /// The upper and lower bounds of the position in the formatted string
+    /// (`8` or `9` in the example above). May be the same if the result can
+    /// be determined unambiguously.
+    private static func formattedPosition(
+        unformattedString: String,
+        positionInUnformattedString: Int,
+        formattedString: String
+    ) -> (lower: Int, upper: Int) {
+        var lower: Int?
+        var upper: Int?
+
+        for i in (0...formattedString.count) {
+            let unformattedCursorPosition = unformattedPosition(
+                formattedString: formattedString,
+                positionInFormattedString: i
+            )
+            if unformattedCursorPosition == positionInUnformattedString {
+                lower = lower ?? i
+                upper = i
+            }
+        }
+
+        if let lower, let upper {
+            return (lower: lower, upper: upper)
+        } else {
+            let end = formattedString.count
+            return (lower: end, upper: end)
+        }
+    }
+
+    /// Delete a single character (e.g., with Backspace).
+    ///
+    /// Most notably handles deletions across boundaries. For example, imagine
+    /// the formatter inserts a space between every pair of digits, so `1234`
+    /// becomes `12 34`. If your cursor is on either side of the space, the `2`
+    /// should be removed if you delete backwards, and `3` if you delete
+    /// forwards.
+    ///
+    /// - Parameter formattedString:
+    /// The formatted string (`12 34` in the example above).
+    /// - Parameter cursorPosition:
+    /// The current cursor position (`2` or `3` in the example above).
+    /// - Parameter direction:
+    /// The direction to delete: forward or backward.
+    /// - Parameter format:
+    /// A function to format the string. See earlier comments for details.
+    /// - Returns:
+    /// The new formatted string and the new cursor position. If this deletion
+    /// makes no change, `nil` is returned.
+    static func singleDelete(
+        formattedString: String,
+        cursorPosition: Int,
+        direction: SingleDeletionDirection,
+        format: (String) -> String
+    ) -> OperationResult? {
+        let oldUnformattedString = formattedString.asciiDigitsOnly
+        if oldUnformattedString.isEmpty {
+            return nil
+        }
+
+        let cursorPositionInOldUnformattedString = Self.unformattedPosition(
+            formattedString: formattedString,
+            positionInFormattedString: cursorPosition
+        )
+
+        let cursorOffset: Int
+        switch direction {
+        case .backward: cursorOffset = -1
+        case .forward: cursorOffset = 0
+        }
+
+        let offsetToRemove = cursorPositionInOldUnformattedString + cursorOffset
+        guard (0..<oldUnformattedString.count).contains(offsetToRemove) else {
+            return nil
+        }
+
+        var newUnformattedString = oldUnformattedString
+        let indexToRemove = newUnformattedString.index(
+            newUnformattedString.startIndex,
+            offsetBy: offsetToRemove
+        )
+        newUnformattedString.remove(at: indexToRemove)
+
+        let newFormattedString = format(newUnformattedString)
+
+        let cursorPositionInNewFormattedString = Self.formattedPosition(
+            unformattedString: newUnformattedString,
+            positionInUnformattedString: cursorPositionInOldUnformattedString + cursorOffset,
+            formattedString: newFormattedString
+        ).lower
+
+        return .init(
+            formattedString: newFormattedString,
+            cursorPosition: cursorPositionInNewFormattedString
+        )
+    }
+
+    /// Insert a string, possibly an empty one, inside a selection.
+    ///
+    /// For example, imagine the formatter inserts a space between every pair of
+    /// digits, so `1234` becomes `12 34`. If your cursor is at the end and you
+    /// type a `5`, the new value should be `12 34 5`.
+    ///
+    /// - Parameter formattedString:
+    /// The formatted string (`12 34` in the example above).
+    /// - Parameter selectionStart:
+    /// The start of the current selection.
+    /// - Parameter selectionEnd:
+    /// The end of the current selection. May be the same as `selectionStart`.
+    /// - Parameter rawInsertion:
+    /// The string to be inserted, possibly empty. Non-numbers are filtered.
+    /// - Parameter maxDigits:
+    /// The maximum number of digits. See earlier comments for details.
+    /// - Parameter format:
+    /// A function to format the string. See earlier comments for details.
+    /// - Returns:
+    /// The new formatted string and the new cursor position. If this action
+    /// makes no change, `nil` is returned.
+    static func insertOrReplace(
+        formattedString: String,
+        selectionStart: Int,
+        selectionEnd: Int,
+        rawInsertion: String,
+        maxDigits: Int,
+        format: (String) -> String
+    ) -> OperationResult? {
+        let insertion = rawInsertion.asciiDigitsOnly
+
+        let selectionStartInOldUnformattedString = Self.unformattedPosition(
+            formattedString: formattedString,
+            positionInFormattedString: selectionStart
+        )
+        let selectionEndInOldUnformattedString = Self.unformattedPosition(
+            formattedString: formattedString,
+            positionInFormattedString: selectionEnd
+        )
+        let oldUnformattedString = formattedString.asciiDigitsOnly
+
+        let newUnformattedString: String = {
+            let prefix = oldUnformattedString.prefix(selectionStartInOldUnformattedString)
+
+            let selectionEndIndex = oldUnformattedString.index(
+                oldUnformattedString.startIndex,
+                offsetBy: selectionEndInOldUnformattedString
+            )
+            let suffix = oldUnformattedString[selectionEndIndex...]
+
+            return "\(prefix)\(insertion)\(suffix)"
+        }()
+
+        if oldUnformattedString == newUnformattedString {
+            return nil
+        }
+
+        // The digit count can exceed the maximum under expected conditions.
+        // This could happen if the field's text is programatically changed or
+        // if the maximum digit count is changed dynamically. Therefore, we only
+        // prevent input if the change causes us to *further* exceed the limit.
+        if newUnformattedString.count > oldUnformattedString.count, newUnformattedString.count > maxDigits {
+            return nil
+        }
+
+        let newFormattedString = format(newUnformattedString)
+        let cursorPositionInNewFormattedString = Self.formattedPosition(
+            unformattedString: newUnformattedString,
+            positionInUnformattedString: selectionStartInOldUnformattedString + insertion.count,
+            formattedString: newFormattedString
+        ).upper
+
+        return .init(
+            formattedString: newFormattedString,
+            cursorPosition: cursorPositionInNewFormattedString
+        )
+    }
+}
diff --git a/SignalUITests/FormattedNumberFieldTest.swift b/SignalUITests/FormattedNumberFieldTest.swift
new file mode 100644
index 00000000000..a1f0e5b3797
--- /dev/null
+++ b/SignalUITests/FormattedNumberFieldTest.swift
@@ -0,0 +1,191 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import XCTest
+@testable import SignalUI
+
+final class FormattedNumberFieldTest: XCTestCase {
+    /// A helper that makes it easy to express test cases with concise strings.
+    struct TestState: Equatable, ExpressibleByStringLiteral, CustomDebugStringConvertible {
+        public let formattedString: String
+        public let selectionStart: Int
+        public let selectionEnd: Int
+
+        public var debugDescription: String {
+            if selectionStart == selectionEnd {
+                return formattedString.inserted("|", at: selectionStart)
+            } else {
+                return formattedString.inserted("]", at: selectionEnd).inserted("[", at: selectionStart)
+            }
+        }
+
+        public init(formattedString: String, selectionStart: Int, selectionEnd: Int) {
+            self.formattedString = formattedString
+            self.selectionStart = selectionStart
+            self.selectionEnd = selectionEnd
+        }
+
+        public init(stringLiteral string: String) {
+            self.formattedString = string
+                .replacingOccurrences(of: "|", with: "")
+                .replacingOccurrences(of: "[", with: "")
+                .replacingOccurrences(of: "]", with: "")
+
+            if let pipeIndex = string.firstIndex(of: "|") {
+                let pipeDistance = string.distance(to: pipeIndex)
+                self.selectionStart = pipeDistance
+                self.selectionEnd = pipeDistance
+            } else if let startIndex = string.firstIndex(of: "["), let endIndex = string.lastIndex(of: "]") {
+                self.selectionStart = string.distance(to: startIndex)
+                self.selectionEnd = string.distance(to: endIndex) - 1
+            } else {
+                fatalError("Test was not set up correctly. String was badly formatted: \(string)")
+            }
+        }
+    }
+
+    private func testFormat(_ str: String) -> String {
+        var result = [Character]()
+        var charactersInGroup: UInt8 = 0
+        for character in str {
+            result.append(character)
+            charactersInGroup += 1
+            if charactersInGroup == 4 {
+                result.append(" ")
+                charactersInGroup = 0
+            }
+        }
+        return String(result)
+    }
+
+    func testSingleDelete() {
+        let noopCases: [(TestState, FormattedNumberField.SingleDeletionDirection)] = [
+            ("|", .backward),
+            ("|123", .backward),
+            ("|1234 ", .backward),
+            ("|", .forward),
+            ("123|", .forward),
+            ("1234| ", .forward),
+            ("1234 |", .forward)
+        ]
+        for (inputState, deletionDirection) in noopCases {
+            let result = FormattedNumberField.singleDelete(
+                formattedString: inputState.formattedString,
+                cursorPosition: inputState.selectionStart,
+                direction: deletionDirection,
+                format: testFormat
+            )
+            XCTAssertNil(result, "\(inputState) \(deletionDirection)")
+        }
+
+        let deletionCases: [(TestState, FormattedNumberField.SingleDeletionDirection, TestState)] = [
+            ("1|", .backward, "|"),
+            ("1234| ", .backward, "123|"),
+            ("1234 |", .backward, "123|"),
+            ("12|34 567", .backward, "1|345 67"),
+            ("1234| 567", .backward, "123|5 67"),
+            ("1234 |567", .backward, "123|5 67"),
+            ("12|39 9999 9999 9999 9999 ", .backward, "1|399 9999 9999 9999 999"),
+            ("|1", .forward, "|"),
+            ("12|34 567", .forward, "12|45 67"),
+            ("1234| 56", .forward, "1234| 6"),
+            ("1234 |56", .forward, "1234| 6"),
+            ("12|39 9999 9999 9999 9999 ", .forward, "12|99 9999 9999 9999 999")
+        ]
+        for (inputState, deletionDirection, expectedOutputState) in deletionCases {
+            let result = FormattedNumberField.singleDelete(
+                formattedString: inputState.formattedString,
+                cursorPosition: inputState.selectionStart,
+                direction: deletionDirection,
+                format: testFormat
+            )
+            XCTAssertEqual(result?.asTestState, expectedOutputState, "\(inputState) \(deletionDirection)")
+        }
+    }
+
+    func testInsert() {
+        let noopCases: [(TestState, String)] = [
+          ("|", ""),
+          ("|", "x"),
+          ("123|", "x"),
+          ("1234567890|", "1"),
+          ("1234|567890", "1"),
+          ("123456789|", "123")
+        ]
+        for (inputState, insertion) in noopCases {
+            let result = FormattedNumberField.insertOrReplace(
+                formattedString: inputState.formattedString,
+                selectionStart: inputState.selectionStart,
+                selectionEnd: inputState.selectionEnd,
+                rawInsertion: insertion,
+                maxDigits: 10,
+                format: testFormat
+            )
+            XCTAssertNil(result, "\(inputState) \(insertion)")
+        }
+
+        let testCases: [(TestState, String, TestState)] = [
+          ("|", "1", "1|"),
+          ("|", "123", "123|"),
+          ("|", "123x", "123|"),
+
+          ("|", "1234", "1234 |"),
+          ("123|", "4", "1234 |"),
+
+          ("12|3", "9", "129|3 "),
+          ("12|34 ", "9", "129|3 4"),
+          ("1234| ", "5", "1234 5|"),
+          ("1234 |", "5", "1234 5|"),
+
+          ("[123]", "9", "9|"),
+          ("[1234] ", "9", "9|"),
+          ("[1234] 5678 ", "9", "9|567 8"),
+          ("[1234] 5678 ", "9", "9|567 8"),
+          ("12[34 56]78 ", "9", "129|7 8"),
+          ("12[34 56]78 ", "000", "1200 0|78"),
+          ("12[34 56]78 ", "0000", "1200 00|78 "),
+          ("12[34 56]78 ", "", "12|78 "),
+          ("12[34 56]78 ", "x", "12|78 "),
+
+          ("[1234 5678 9012 34]", "", "|"),
+          ("[1234 5678 9012 34]", "987", "987|"),
+          ("1234 5678 9012 3[4]", "", "1234 5678 9012 3|")
+        ]
+
+        for (inputState, insertion, expectedOutputState) in testCases {
+            let result = FormattedNumberField.insertOrReplace(
+                formattedString: inputState.formattedString,
+                selectionStart: inputState.selectionStart,
+                selectionEnd: inputState.selectionEnd,
+                rawInsertion: insertion,
+                maxDigits: 10,
+                format: testFormat
+            )
+            XCTAssertEqual(result?.asTestState, expectedOutputState, "\(inputState) \(insertion)")
+        }
+    }
+}
+
+fileprivate extension String {
+    func inserted(_ newElement: Character, at offset: Int) -> String {
+        var result = self
+        result.insert(newElement, at: index(result.startIndex, offsetBy: offset))
+        return result
+    }
+
+    func distance(to end: String.Index) -> Int {
+        distance(from: startIndex, to: end)
+    }
+}
+
+fileprivate extension FormattedNumberField.OperationResult {
+    var asTestState: FormattedNumberFieldTest.TestState {
+        .init(
+            formattedString: formattedString,
+            selectionStart: cursorPosition,
+            selectionEnd: cursorPosition
+        )
+    }
+}
