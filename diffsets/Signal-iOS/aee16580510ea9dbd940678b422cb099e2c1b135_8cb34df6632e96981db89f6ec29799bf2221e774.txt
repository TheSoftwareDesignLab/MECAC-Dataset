diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 04c1194d493..9d16ce4271d 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -142,6 +142,7 @@
 		34546F502649989D007C4958 /* ChatColorViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34546F4F2649989C007C4958 /* ChatColorViewController.swift */; };
 		3456A73223D63EBE00947219 /* GroupsV2Protos.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3456A73123D63EBE00947219 /* GroupsV2Protos.swift */; };
 		345772B6257E4E01001D7D44 /* CVViewStateSnapshot.swift in Sources */ = {isa = PBXBuildFile; fileRef = 345772B5257E4E01001D7D44 /* CVViewStateSnapshot.swift */; };
+		3457794326828A9A00732869 /* ConversationCollectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3457794226828A9A00732869 /* ConversationCollectionView.swift */; };
 		3457811B23EB56B300CE01C3 /* ConversationViewController+MessageRequest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3457811A23EB56B300CE01C3 /* ConversationViewController+MessageRequest.swift */; };
 		345AE2B62317048300DB6225 /* GRDBFinderTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 345AE2B52317048200DB6225 /* GRDBFinderTest.swift */; };
 		345DE96023ED9AA500A8E6E3 /* GroupsV2ProfileKeyUpdater.swift in Sources */ = {isa = PBXBuildFile; fileRef = 345DE95F23ED9AA500A8E6E3 /* GroupsV2ProfileKeyUpdater.swift */; };
@@ -1179,6 +1180,7 @@
 		34546F4F2649989C007C4958 /* ChatColorViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ChatColorViewController.swift; sourceTree = "<group>"; };
 		3456A73123D63EBE00947219 /* GroupsV2Protos.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GroupsV2Protos.swift; sourceTree = "<group>"; };
 		345772B5257E4E01001D7D44 /* CVViewStateSnapshot.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVViewStateSnapshot.swift; sourceTree = "<group>"; };
+		3457794226828A9A00732869 /* ConversationCollectionView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ConversationCollectionView.swift; sourceTree = "<group>"; };
 		3457811A23EB56B300CE01C3 /* ConversationViewController+MessageRequest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "ConversationViewController+MessageRequest.swift"; sourceTree = "<group>"; };
 		345AE2B52317048200DB6225 /* GRDBFinderTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GRDBFinderTest.swift; sourceTree = "<group>"; };
 		345DE95F23ED9AA500A8E6E3 /* GroupsV2ProfileKeyUpdater.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GroupsV2ProfileKeyUpdater.swift; sourceTree = "<group>"; };
@@ -2519,6 +2521,7 @@
 				34D1F0951F867BFC0066283D /* Cells */,
 				34D1F0B21F86D31D0066283D /* ConversationCollectionView.h */,
 				34D1F0B31F86D31D0066283D /* ConversationCollectionView.m */,
+				3457794226828A9A00732869 /* ConversationCollectionView.swift */,
 				45DDA6232090CEB500DE97F8 /* ConversationHeaderView.swift */,
 				8851DB4224CCF0EB001EACD2 /* ConversationInputTextView.swift */,
 				34D1F0691F8678AA0066283D /* ConversationInputToolbar.h */,
@@ -5793,6 +5796,7 @@
 				347C3842252CE6C900F3D941 /* CVComponentMessage.swift in Sources */,
 				88D23D2C23CEC17400B0E74B /* CallAudioService.swift in Sources */,
 				344A761124B366F4009D69A5 /* FlagsViewController.swift in Sources */,
+				3457794326828A9A00732869 /* ConversationCollectionView.swift in Sources */,
 				887889A52476E999001B5FCF /* OWSPinConfirmationViewController.swift in Sources */,
 				347030C625F66C24006C3BF5 /* PaymentsDeactivateViewController.swift in Sources */,
 				346594802434D49F00E5C510 /* NewGroupState.swift in Sources */,
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index efd647e5f9e..9f77c9fced5 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -8,8 +8,6 @@ import PromiseKit
 protocol CVLoadCoordinatorDelegate: UIScrollViewDelegate {
     var viewState: CVViewState { get }
 
-    func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint
-
     func willUpdateWithNewRenderState(_ renderState: CVRenderState) -> CVUpdateToken
 
     func updateWithNewRenderState(update: CVUpdate,
@@ -26,15 +24,11 @@ protocol CVLoadCoordinatorDelegate: UIScrollViewDelegate {
 
     var isScrollNearBottomOfLoadWindow: Bool { get }
 
-    var isUserScrolling: Bool { get }
-
-    var hasScrollingAnimation: Bool { get }
-
-    var scrollContinuity: ScrollContinuity { get }
-
     var isLayoutApplyingUpdate: Bool { get }
 
     var areCellsAnimating: Bool { get }
+
+    var conversationViewController: ConversationViewController? { get }
 }
 
 // MARK: -
@@ -45,6 +39,7 @@ struct CVUpdateToken {
     let isScrolledToBottom: Bool
     let lastMessageForInboxSortId: UInt64?
     let scrollContinuityToken: CVScrollContinuityToken
+    let lastKnownDistanceFromBottom: CGFloat?
 }
 
 @objc
@@ -457,6 +452,10 @@ public class CVLoadCoordinator: NSObject {
         // make sure we don't show it again.
         hasClearedUnreadMessagesIndicator = true
 
+        guard nil != messageMapping.oldestUnreadInteraction else {
+            return
+        }
+
         loadRequestBuilder.clearOldestUnreadInteraction()
         loadIfNecessary()
     }
@@ -855,36 +854,12 @@ extension CVLoadCoordinator: ConversationViewLayoutDelegate {
         showLoadNewerHeader ? LoadMoreMessagesView.fixedHeight : 0
     }
 
-    public func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
-        guard let delegate = self.delegate else {
-            owsFailDebug("Missing delegate.")
-            return proposedContentOffset
-        }
-        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
-    }
-
-    public var isUserScrolling: Bool {
-        guard let delegate = self.delegate else {
-            owsFailDebug("Missing delegate.")
-            return false
-        }
-        return delegate.isUserScrolling
-    }
-
-    public var hasScrollingAnimation: Bool {
-        guard let delegate = self.delegate else {
-            owsFailDebug("Missing delegate.")
-            return false
-        }
-        return delegate.hasScrollingAnimation
-    }
-
-    public var scrollContinuity: ScrollContinuity {
+    public var conversationViewController: ConversationViewController? {
         guard let delegate = self.delegate else {
             owsFailDebug("Missing delegate.")
-            return .bottom
+            return nil
         }
-        return delegate.scrollContinuity
+        return delegate.conversationViewController
     }
 }
 
diff --git a/Signal/src/ViewControllers/ConversationView/CVViewState.swift b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
index b9831f060a7..963880920c2 100644
--- a/Signal/src/ViewControllers/ConversationView/CVViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
@@ -70,8 +70,6 @@ public class CVViewState: NSObject {
 
         return scrollingAnimationCompletionTimer != nil
     }
-    @objc
-    public var scrollContinuity: ScrollContinuity = .bottom
     public var scrollActionForSizeTransition: CVScrollAction?
     public var scrollActionForUpdate: CVScrollAction?
     public var lastKnownDistanceFromBottom: CGFloat?
@@ -272,11 +270,6 @@ public extension ConversationViewController {
 
     var hasScrollingAnimation: Bool { viewState.hasScrollingAnimation }
 
-    var scrollContinuity: ScrollContinuity {
-        get { viewState.scrollContinuity }
-        set { viewState.scrollContinuity = newValue }
-    }
-
     var uiMode: ConversationUIMode {
         get { viewState.uiMode }
         set {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h
index 4d6ca75105b..410e0d5ed6d 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h
+++ b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h
@@ -4,9 +4,6 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-@class CVScrollContinuityToken;
-@class ConversationViewController;
-
 @protocol ConversationCollectionViewDelegate <NSObject>
 
 - (void)collectionViewWillChangeSizeFrom:(CGSize)oldSize to:(CGSize)newSize;
@@ -17,27 +14,10 @@ NS_ASSUME_NONNULL_BEGIN
 
 #pragma mark -
 
-typedef void (^CVCPerformBatchUpdatesBlock)(void);
-typedef void (^CVCPerformBatchUpdatesCompletion)(BOOL);
-typedef void (^CVCPerformBatchUpdatesFailure)(void);
-
 @interface ConversationCollectionView : UICollectionView
 
 @property (weak, nonatomic) id<ConversationCollectionViewDelegate> layoutDelegate;
 
-- (void)reloadData NS_UNAVAILABLE;
-- (void)cvc_reloadDataWithAnimated:(BOOL)animated
-                               cvc:(ConversationViewController *)cvc NS_SWIFT_NAME(cvc_reloadData(animated:cvc:));
-
-- (void)performBatchUpdates:(void(NS_NOESCAPE ^ _Nullable)(void))updates
-                 completion:(void (^_Nullable)(BOOL finished))completion NS_UNAVAILABLE;
-- (void)cvc_performBatchUpdates:(CVCPerformBatchUpdatesBlock)batchUpdates
-                     completion:(CVCPerformBatchUpdatesCompletion)completion
-                        failure:(CVCPerformBatchUpdatesFailure)failure
-                       animated:(BOOL)animated
-          scrollContinuityToken:(nullable CVScrollContinuityToken *)scrollContinuityToken
-                            cvc:(ConversationViewController *)cvc NS_SWIFT_NAME(cvc_performBatchUpdates(_:completion:failure:animated:scrollContinuityToken:cvc:));
-
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
index 109feeba424..5e5613e86da 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
@@ -13,6 +13,8 @@ @implementation ConversationCollectionView
 
 - (void)setFrame:(CGRect)frame
 {
+    OWSAssertIsOnMainThread();
+
     if (frame.size.width == 0 || frame.size.height == 0) {
         // Ignore iOS Auto Layout's tendency to temporarily zero out the
         // frame of this view during the layout process.
@@ -39,6 +41,8 @@ - (void)setFrame:(CGRect)frame
 
 - (void)setBounds:(CGRect)bounds
 {
+    OWSAssertIsOnMainThread();
+
     if (bounds.size.width == 0 || bounds.size.height == 0) {
         // Ignore iOS Auto Layout's tendency to temporarily zero out the
         // frame of this view during the layout process.
@@ -65,6 +69,8 @@ - (void)setBounds:(CGRect)bounds
 
 - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated
 {
+    OWSAssertIsOnMainThread();
+
     if (animated) {
         [self.layoutDelegate collectionViewWillAnimate];
     }
@@ -74,6 +80,8 @@ - (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated
 
 - (void)setContentOffset:(CGPoint)contentOffset
 {
+    OWSAssertIsOnMainThread();
+
     if (self.contentSize.height < 1 && contentOffset.y <= 0) {
         // [UIScrollView _adjustContentOffsetIfNecessary] resets the content
         // offset to zero under a number of undocumented conditions.  We don't
@@ -104,85 +112,6 @@ - (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated
     [super scrollRectToVisible:rect animated:animated];
 }
 
-- (void)cvc_reloadDataWithAnimated:(BOOL)animated cvc:(ConversationViewController *)cvc
-{
-    @try {
-        if (animated) {
-            [cvc.layout willReloadData];
-            [UIView performWithoutAnimation:^{ [super reloadData]; }];
-            [cvc.layout invalidateLayout];
-            [cvc.layout didReloadData];
-        } else {
-            [cvc.layout willReloadData];
-            [super reloadData];
-            [cvc.layout invalidateLayout];
-            [cvc.layout didReloadData];
-        }
-    } @catch (NSException *exception) {
-        OWSLogWarn(@"currentRenderStateDebugDescription: %@", cvc.currentRenderStateDebugDescription);
-        OWSCFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
-            exception.description,
-            exception.name,
-            exception.reason,
-            exception.userInfo);
-        @throw exception;
-    }
-}
-
-- (void)cvc_performBatchUpdates:(CVCPerformBatchUpdatesBlock)batchUpdates
-                     completion:(CVCPerformBatchUpdatesCompletion)completion
-                        failure:(CVCPerformBatchUpdatesFailure)failure
-                       animated:(BOOL)animated
-          scrollContinuityToken:(nullable CVScrollContinuityToken *)scrollContinuityToken
-                            cvc:(ConversationViewController *)cvc
-{
-    @try {
-        void (^updateBlock)(void) = ^{
-            ConversationViewLayout *layout = cvc.layout;
-            [layout willPerformBatchUpdatesWithScrollContinuityToken:scrollContinuityToken];
-            [cvc.collectionView
-                performBatchUpdates:^{ batchUpdates(); }
-                completion:^(BOOL finished) {
-                    [layout didCompleteBatchUpdates];
-
-                    completion(finished);
-                }];
-            [layout didPerformBatchUpdatesWithScrollContinuityToken:scrollContinuityToken];
-
-            [BenchManager completeEventWithEventId:@"message-send"];
-        };
-
-        if (animated) {
-            updateBlock();
-        } else {
-            // HACK: We use `UIView.animateWithDuration:0` rather than `UIView.performWithAnimation` to work around a
-            // UIKit Crash like:
-            //
-            //     *** Assertion failure in -[ConversationViewLayout prepareForCollectionViewUpdates:],
-            //     /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3600.7.47/UICollectionViewLayout.m:760
-            //     *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'While
-            //     preparing update a visible view at <NSIndexPath: 0xc000000011c00016> {length = 2, path = 0 - 142}
-            //     wasn't found in the current data model and was not in an update animation. This is an internal
-            //     error.'
-            //
-            // I'm unclear if this is a bug in UIKit, or if we're doing something crazy in
-            // ConversationViewLayout#prepareLayout. To reproduce, rapidily insert and delete items into the
-            // conversation. See `DebugUIMessages#thrashCellsInThread:`
-            [UIView animateWithDuration:0.0 animations:updateBlock];
-        }
-    } @catch (NSException *exception) {
-        OWSCFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
-            exception.description,
-            exception.name,
-            exception.reason,
-            exception.userInfo);
-
-        failure();
-
-        @throw exception;
-    }
-}
-
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.swift b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.swift
new file mode 100644
index 00000000000..943c2793ebc
--- /dev/null
+++ b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.swift
@@ -0,0 +1,72 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public extension ConversationCollectionView {
+
+    typealias CVCPerformBatchUpdatesBlock = () -> Void
+    typealias CVCPerformBatchUpdatesCompletion = (Bool) -> Void
+    typealias CVCPerformBatchUpdatesFailure = () -> Void
+
+    func cvc_reloadData(animated: Bool, cvc: ConversationViewController) {
+        AssertIsOnMainThread()
+
+        cvc.layout.willReloadData()
+        if animated {
+            super.reloadData()
+        } else {
+            UIView.performWithoutAnimation {
+                super.reloadData()
+            }
+        }
+        cvc.layout.invalidateLayout()
+        cvc.layout.didReloadData()
+    }
+
+    func cvc_performBatchUpdates(_ batchUpdates: @escaping CVCPerformBatchUpdatesBlock,
+                                 completion: @escaping CVCPerformBatchUpdatesCompletion,
+                                 failure: @escaping CVCPerformBatchUpdatesFailure,
+                                 animated: Bool,
+                                 scrollContinuity: ScrollContinuity,
+                                 lastKnownDistanceFromBottom: CGFloat?,
+                                 cvc: ConversationViewController) {
+        AssertIsOnMainThread()
+
+        let updateBlock = {
+            let layout = cvc.layout
+            layout.willPerformBatchUpdates(scrollContinuity: scrollContinuity,
+                                           lastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
+            super.performBatchUpdates(batchUpdates) { (finished: Bool) in
+                AssertIsOnMainThread()
+
+                layout.didCompleteBatchUpdates()
+
+                completion(finished)
+            }
+            layout.didPerformBatchUpdates()
+
+            BenchManager.completeEvent(eventId: "message-send")
+        }
+
+        if animated {
+            updateBlock()
+        } else {
+            // HACK: We use `UIView.animateWithDuration:0` rather than `UIView.performWithAnimation` to work around a
+            // UIKit Crash like:
+            //
+            //     *** Assertion failure in -[ConversationViewLayout prepareForCollectionViewUpdates:],
+            //     /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3600.7.47/UICollectionViewLayout.m:760
+            //     *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'While
+            //     preparing update a visible view at <NSIndexPath: 0xc000000011c00016> {length = 2, path = 0 - 142}
+            //     wasn't found in the current data model and was not in an update animation. This is an internal
+            //     error.'
+            //
+            // I'm unclear if this is a bug in UIKit, or if we're doing something crazy in
+            // ConversationViewLayout#prepareLayout. To reproduce, rapidily insert and delete items into the
+            // conversation. See `DebugUIMessages#thrashCellsInThread:`
+            UIView.animate(withDuration: 0, animations: updateBlock)
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index 970e721acbf..4bc025c7326 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -82,6 +82,11 @@ extension ConversationViewController {
 // MARK: -
 
 extension ConversationViewController: CVLoadCoordinatorDelegate {
+
+    public var conversationViewController: ConversationViewController? {
+        self
+    }
+
     func chatColorDidChange() {
         updateConversationStyle()
     }
@@ -107,11 +112,12 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         // CVC will often use this state to ensure scroll continuity
         // when landing loads, so ensure the value is updated before
         // landing loads.
-        self.updateLastKnownDistanceFromBottom()
+        let lastKnownDistanceFromBottom = self.updateLastKnownDistanceFromBottom()
 
         return CVUpdateToken(isScrolledToBottom: self.isScrolledToBottom,
                              lastMessageForInboxSortId: threadViewModel.lastMessageForInbox?.sortId,
-                             scrollContinuityToken: scrollContinuityToken)
+                             scrollContinuityToken: scrollContinuityToken,
+                             lastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
     }
 
     func updateWithNewRenderState(update: CVUpdate,
@@ -229,7 +235,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         let benchSteps = BenchSteps()
 
-        self.scrollContinuity = .bottom
         self.updateLastKnownDistanceFromBottom()
         self.updateInputToolbarLayout()
         self.ensureSelectionViewState()
@@ -447,8 +452,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
     private func resetViewStateAfterError() {
         Logger.verbose("")
 
-        scrollContinuity = .bottom
-
         reloadCollectionViewForReset()
 
         // Try to update the lastKnownDistanceFromBottom; the content size may have changed.
@@ -512,7 +515,8 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                         // Whenever we send an outgoing message from the local device,
                         // auto-scroll to the bottom of the conversation, regardless
                         // of scroll state.
-                        scrollAction = CVScrollAction(action: .bottomOfLoadWindow, isAnimated: true)
+                        scrollAction = CVScrollAction(action: .bottomOfLoadWindow,
+                                                      isAnimated: !updateToken.isScrolledToBottom)
                         break
                     } else if isAutoScrollInteraction,
                               isScrolledToBottom {
@@ -528,25 +532,52 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             }
         }
 
-        scrollContinuity = isScrolledToBottom ? .bottom : .top
-        var isLoadAdjacent = false
-        if let loadType = renderState.loadType {
+        if .loadOlder == renderState.loadType {
+            scrollAction = .none
+        }
+
+        viewState.scrollActionForUpdate = scrollAction
+
+        // We have two scroll continuity mechanisms:
+        //
+        // * The first is in the targetContentOffset(forProposedContentOffset:) method in CVC+Scroll.swift.
+        //   This handles scroll continuity in most cases.
+        // * The second is in ConversationViewLayout.willPerformBatchUpdates().
+        //   We manipulate the content offset using
+        //   UICollectionViewLayoutInvalidationContext.contentOffsetAdjustment.
+        //   We (currently) only apply the second mechanism when landing "adjacent"
+        //   loads during a scroll gesture or animation.
+        let scrollContinuity: ScrollContinuity = {
+            guard let loadType = renderState.loadType else {
+                owsFailDebug("Missing loadType.")
+                return .delegateScrollContinuity
+            }
+
+            // TODO: We could extend the layout's invalidation-based approach
+            // to scroll continuity to support more of these cases.
+            if shouldUseDelegateScrollContinuity {
+                return .delegateScrollContinuity
+            }
+
+            let scrollContinuityToken = updateToken.scrollContinuityToken
+
             switch loadType {
+            case .loadInitialMapping:
+                return .none
+            case .loadSameLocation:
+                return .contentRelativeToViewport(token: scrollContinuityToken,
+                                                  isRelativeToTop: false)
             case .loadOlder:
-                scrollContinuity = .bottom
-                scrollAction = .none
-                isLoadAdjacent = true
+                return .contentRelativeToViewport(token: scrollContinuityToken,
+                                                  isRelativeToTop: true)
             case .loadNewer, .loadNewest:
-                scrollContinuity = .top
-                isLoadAdjacent = true
-            default:
-                break
+                return .contentRelativeToViewport(token: scrollContinuityToken,
+                                                  isRelativeToTop: false)
+            case .loadPageAroundInteraction:
+                return .contentRelativeToViewport(token: scrollContinuityToken,
+                                                  isRelativeToTop: false)
             }
-        } else {
-            owsFailDebug("Missing loadType.")
-        }
-
-        viewState.scrollActionForUpdate = scrollAction
+        }()
 
         let batchUpdatesBlock = {
             AssertIsOnMainThread()
@@ -629,30 +660,13 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             }
         }
 
-        // We have two scroll continuity mechanisms.
-        // One is the targetContentOffset(forProposedContentOffset:) method in CVC+Scroll.swift.
-        // To work correctly, it often needs a valid "last known distance from bottom" value. We didn't always have one. This method ensures that a valid value is always prepared before we land the load.
-
-        // We have two scroll continuity mechanisms:
-        //
-        // * The first is in the targetContentOffset(forProposedContentOffset:) method in CVC+Scroll.swift.
-        //   This handles scroll continuity in most cases.
-        // * The second is in ConversationViewLayout.willPerformBatchUpdates().
-        //   We manipulate the content offset using
-        //   UICollectionViewLayoutInvalidationContext.contentOffsetAdjustment.
-        //   We (currently) only apply the second mechanism when landing "adjacent"
-        //   loads during a scroll gesture or animation. 
-        var scrollContinuityToken: CVScrollContinuityToken?
-        if isLoadAdjacent && (hasScrollingAnimation || isUserScrolling) {
-            scrollContinuityToken = updateToken.scrollContinuityToken
-        }
-
         // We use an obj-c free function so that we can handle NSException.
         self.collectionView.cvc_performBatchUpdates(batchUpdatesBlock,
                                                     completion: completion,
                                                     failure: logFailureBlock,
                                                     animated: shouldAnimateUpdate,
-                                                    scrollContinuityToken: scrollContinuityToken,
+                                                    scrollContinuity: scrollContinuity,
+                                                    lastKnownDistanceFromBottom: updateToken.lastKnownDistanceFromBottom,
                                                     cvc: self)
     }
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift
index af55a1afa48..52ef91fb173 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift
@@ -408,8 +408,6 @@ extension ConversationViewController: InputAccessoryViewPlaceholderDelegate {
             return
         }
 
-        self.scrollContinuity = .bottom
-
         if shouldAnimateKeyboardChanges, animationDuration > 0 {
             if hasViewDidAppearEverCompleted {
                 // Make note of when the keyboard animation will block
@@ -422,7 +420,6 @@ extension ConversationViewController: InputAccessoryViewPlaceholderDelegate {
                 if viewState.lastKeyboardAnimationDate == nil ||
                     viewState.lastKeyboardAnimationDate?.isBefore(lastKeyboardAnimationDate) == true {
                     viewState.lastKeyboardAnimationDate = animationCompletionDate
-                    self.scrollContinuity = .bottom
                 }
             }
 
@@ -515,7 +512,5 @@ extension ConversationViewController {
         AssertIsOnMainThread()
 
         updateConversationStyle()
-
-        self.scrollContinuity = .bottom
     }
 }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift
index 1002258dac1..4d30e39de28 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift
@@ -88,8 +88,6 @@ extension ConversationViewController: MessageActionsDelegate {
     }
 
     func messageActionsStartedSelect(initialItem itemViewModel: CVItemViewModelImpl) {
-        self.scrollContinuity = .bottom
-
         uiMode = .selection
 
         self.addToSelection(itemViewModel.interaction.uniqueId)
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index eb840b2a4fe..3f1fb11a289 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -30,25 +30,6 @@ public enum ScrollAlignment: Int {
 
 // MARK: -
 
-@objc
-public enum ScrollContinuity: Int, CustomStringConvertible {
-    case top
-    case bottom
-
-    // MARK: - CustomStringConvertible
-
-    public var description: String {
-        switch self {
-        case .top:
-            return "top"
-        case .bottom:
-            return "bottom"
-        }
-    }
-}
-
-// MARK: -
-
 // TODO: Do we need to specify the load alignment (top, bottom, center)
 // or that implicit in the value?
 public struct CVScrollAction: Equatable, CustomStringConvertible {
@@ -432,18 +413,22 @@ extension ConversationViewController {
         }
     }
 
-    @objc
-    func updateLastKnownDistanceFromBottom() {
+    @discardableResult
+    func updateLastKnownDistanceFromBottom() -> CGFloat? {
         guard hasAppearedAndHasAppliedFirstLoad else {
-            return
+            Logger.verbose("---- !hasAppearedAndHasAppliedFirstLoad")
+            return nil
         }
 
         // Never update the lastKnownDistanceFromBottom,
         // if we're presenting the message actions which
         // temporarily meddles with the content insets.
-        if !isPresentingMessageActions {
-            self.lastKnownDistanceFromBottom = self.safeDistanceFromBottom
+        guard !isPresentingMessageActions else {
+            return nil
         }
+        let lastKnownDistanceFromBottom = self.safeDistanceFromBottom
+        self.lastKnownDistanceFromBottom = lastKnownDistanceFromBottom
+        return lastKnownDistanceFromBottom
     }
 
     // We use this hook to ensure scroll state continuity.  As the collection
@@ -513,8 +498,8 @@ extension ConversationViewController {
 
     // We use this hook to ensure scroll state continuity.  As the collection
     // view's content size changes, we want to keep the same cells in view.
-    @objc
-    public func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
+    public func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint,
+                                    lastKnownDistanceFromBottom: CGFloat?) -> CGPoint {
 
         // TODO: Remove logging in this method once scroll continuity
         // issues are resolved.
@@ -530,6 +515,8 @@ extension ConversationViewController {
             return contentOffset
         }
 
+        // TODO: Consider handling these transitions using a scroll
+        // continuity token.
         if let contentOffset = targetContentOffsetForSizeTransition() {
             if !DebugFlags.reduceLogChatter {
                 Logger.verbose("---- targetContentOffsetForSizeTransition: \(contentOffset)")
@@ -537,6 +524,8 @@ extension ConversationViewController {
             return contentOffset
         }
 
+        // TODO: Consider handling these transitions using a scroll
+        // continuity token.
         if let contentOffset = targetContentOffsetForUpdate() {
             if !DebugFlags.reduceLogChatter {
                 Logger.verbose("---- targetContentOffsetForUpdate: \(contentOffset)")
@@ -544,8 +533,8 @@ extension ConversationViewController {
             return contentOffset
         }
 
-        if scrollContinuity == .bottom,
-           let contentOffset = targetContentOffsetForBottom() {
+        // TODO: Can we improve this case?
+        if let contentOffset = targetContentOffsetForBottom(lastKnownDistanceFromBottom: lastKnownDistanceFromBottom) {
             if !DebugFlags.reduceLogChatter {
                 Logger.verbose("---- forLastKnownDistanceFromBottom: \(contentOffset)")
             }
@@ -558,28 +547,37 @@ extension ConversationViewController {
         return proposedContentOffset
     }
 
-    private func targetContentOffsetForBottom() -> CGPoint? {
+    var shouldUseDelegateScrollContinuity: Bool {
+        if isPresentingMessageActions {
+            return true
+        }
+        if let scrollAction = viewState.scrollActionForSizeTransition,
+           scrollAction != .none {
+            return true
+        }
+        if let scrollAction = viewState.scrollActionForUpdate,
+           !scrollAction.isAnimated {
+            switch scrollAction.action {
+            case .bottomOfLoadWindow, .scrollTo:
+                return true
+            default:
+                break
+            }
+        }
+        return false
+    }
+
+    private func targetContentOffsetForBottom(lastKnownDistanceFromBottom: CGFloat?) -> CGPoint? {
         guard let lastKnownDistanceFromBottom = self.lastKnownDistanceFromBottom else {
+            Logger.verbose("---- lastKnownDistanceFromBottom: unknown")
             return nil
         }
+        Logger.verbose("---- lastKnownDistanceFromBottom: \(lastKnownDistanceFromBottom)")
 
         let contentOffset = self.contentOffset(forLastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
         return contentOffset
     }
 
-    private func canInteractionBeUsedForScrollContinuity(_ interaction: TSInteraction) -> Bool {
-        guard !interaction.isDynamicInteraction() else {
-            return false
-        }
-
-        switch interaction.interactionType() {
-        case .unknown, .unreadIndicator, .dateHeader, .typingIndicator:
-            return false
-        case .incomingMessage, .outgoingMessage, .error, .call, .info, .threadDetails, .unknownThreadWarning, .defaultDisappearingMessageTimer:
-            return true
-        }
-    }
-
     private func targetContentOffsetForSizeTransition() -> CGPoint? {
         guard let scrollAction = viewState.scrollActionForSizeTransition else {
             return nil
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift
index cad6f3c0895..4b8b3deb8b6 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift
@@ -535,8 +535,6 @@ public class ConversationViewController: OWSViewController {
         dismissMessageActions(animated: false)
         dismissReactionsDetailSheet(animated: false)
 
-        self.scrollContinuity = .bottom
-
         guard hasAppearedAndHasAppliedFirstLoad else {
             return
         }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index b94500cf752..aa7993da155 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -4,6 +4,48 @@
 
 import Foundation
 
+public enum ScrollContinuity: CustomStringConvertible {
+    // Do not try to maintain scroll continuity.
+    case none
+
+    // Try to maintain scroll continuity by invalidating
+    // the layout with a contentOffsetAdjustment.
+    //
+    // If isRelativeToTop is true, the top-most visible interaction
+    // in the chat history should remain the same distance from the
+    // top of the chat history (assuming content didn't change,
+    // interactions didn't expire, etc.).
+    //
+    // If isRelativeToTop is false, the bottom-most visible interaction
+    // in the chat history above the keyboard should remain the same
+    // distance from the top of the keyboard (again, everything else
+    // being equal).
+    case contentRelativeToViewport(token: CVScrollContinuityToken, isRelativeToTop: Bool)
+
+    // Try to maintain scroll continuity using the delegate method:
+    //
+    // CVC.targetContentOffset(forProposedContentOffset().
+    //
+    // This delegate method handles cases like view size transitions,
+    // orientation changes, message actions, etc.
+    case delegateScrollContinuity
+
+    // MARK: - CustomStringConvertible
+
+    public var description: String {
+        switch self {
+        case .none:
+            return "none"
+        case .contentRelativeToViewport(_, let isRelativeToTop):
+            return "contentRelativeToViewport(isRelativeToTop: \(isRelativeToTop))"
+        case .delegateScrollContinuity:
+            return "delegateScrollContinuity"
+        }
+    }
+}
+
+// MARK: -
+
 @objc
 public protocol ConversationViewLayoutItem {
 
@@ -16,8 +58,7 @@ public protocol ConversationViewLayoutItem {
 
 // MARK: -
 
-@objc
-public protocol ConversationViewLayoutDelegate {
+public protocol ConversationViewLayoutDelegate: AnyObject {
 
     var layoutItems: [ConversationViewLayoutItem] { get }
     var renderStateId: UInt { get }
@@ -25,11 +66,7 @@ public protocol ConversationViewLayoutDelegate {
     var layoutHeaderHeight: CGFloat { get }
     var layoutFooterHeight: CGFloat { get }
 
-    func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint
-
-    var isUserScrolling: Bool { get }
-    var hasScrollingAnimation: Bool { get }
-    var scrollContinuity: ScrollContinuity { get }
+    var conversationViewController: ConversationViewController? { get }
 }
 
 // MARK: -
@@ -37,7 +74,6 @@ public protocol ConversationViewLayoutDelegate {
 @objc
 public class ConversationViewLayout: UICollectionViewLayout {
 
-    @objc
     public weak var delegate: ConversationViewLayoutDelegate?
 
     private var conversationStyle: ConversationStyle
@@ -407,7 +443,12 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     // Flag set before performBatchUpdates() and cleared after it _returns_.
     private var isPerformingBatchUpdates = false
-    private var isPerformingBatchUpdatesWithInvalidation = false
+
+    private enum DelegateScrollContinuityMode: Equatable {
+        case disabled
+        case enabled(lastKnownDistanceFromBottom: CGFloat?)
+    }
+    private var delegateScrollContinuityMode: DelegateScrollContinuityMode = .disabled
 
     // Returns true during performBatchUpdates() or reloadData().
     // Unlike isPerformBatchUpdatesOrReloadDataBeingAppliedOrSettling, this
@@ -428,65 +469,82 @@ public class ConversationViewLayout: UICollectionViewLayout {
         updateCompletionCounter.get() > 0
     }
 
-    @objc
-    public func willPerformBatchUpdates(scrollContinuityToken: CVScrollContinuityToken?) {
+    public func willPerformBatchUpdates(scrollContinuity: ScrollContinuity,
+                                        lastKnownDistanceFromBottom: CGFloat?) {
         AssertIsOnMainThread()
-        owsAssertDebug(currentLayoutInfo != nil)
         owsAssertDebug(!isReloadingData)
         owsAssertDebug(!isPerformingBatchUpdates)
-        owsAssertDebug(!isPerformingBatchUpdatesWithInvalidation)
+        owsAssertDebug(delegateScrollContinuityMode == .none)
 
         isPerformingBatchUpdates = true
         updateCompletionCounter.increment()
+        delegateScrollContinuityMode = .disabled
+
+        switch scrollContinuity {
+        case .none:
+            break
+        case .contentRelativeToViewport(let token, let isRelativeToTop):
+            if !applyContentOffsetAdjustmentIfNecessary(scrollContinuityToken: token,
+                                                        isRelativeToTop: isRelativeToTop) {
+                delegateScrollContinuityMode = .enabled(lastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
+            }
+        case .delegateScrollContinuity:
+            delegateScrollContinuityMode = .enabled(lastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
+        }
+    }
+
+    private func applyContentOffsetAdjustmentIfNecessary(scrollContinuityToken: CVScrollContinuityToken,
+                                                         isRelativeToTop: Bool) -> Bool {
 
         // When landing some CVC loads, we maintain scroll continuity by setting a
         // `contentOffsetAdjustment` on the UICollectionViewLayoutInvalidationContext
         // pass to invalidateLayout().  The timing of this adjustment to the
         // `contentOffset` is delicate.  It must be done just before
         // UICollectionView.performBatchUpdates().
-        if let delegate = self.delegate,
-           let scrollContinuityToken = scrollContinuityToken {
-            ensureState()
-            let layoutInfoBeforeUpdate = scrollContinuityToken.layoutInfo
-            let layoutInfoAfterUpdate = ensureCurrentLayoutInfo()
-
-            if let contentOffsetAdjustment = Self.invalidationContentOffsetAdjustment(delegate: delegate,
-                                                                                      layoutInfoBeforeUpdate: layoutInfoBeforeUpdate,
-                                                                                      layoutInfoAfterUpdate: layoutInfoAfterUpdate),
-               contentOffsetAdjustment != .zero {
-
-                self.isPerformingBatchUpdatesWithInvalidation = true
-
-                let context = UICollectionViewLayoutInvalidationContext()
-                context.contentOffsetAdjustment = contentOffsetAdjustment
-                self.invalidateLayout(with: context)
-            }
+        ensureState()
+
+        let layoutInfoAfterUpdate = ensureCurrentLayoutInfo()
+
+        // TODO: Capture a CVScrollContinuityToken before view transition,
+        // orientation changes, etc.
+        guard let contentOffsetAdjustment = Self.invalidationContentOffsetAdjustment(scrollContinuityToken: scrollContinuityToken,
+                                                                                     layoutInfoAfterUpdate: layoutInfoAfterUpdate,
+                                                                                     isRelativeToTop: isRelativeToTop) else {
+            return false
         }
+        guard contentOffsetAdjustment != .zero else {
+            // If no adjustment is necessary, consider that success but
+            // do not bother calling invalidateLayout().
+            return true
+        }
+
+        let context = UICollectionViewLayoutInvalidationContext()
+        context.contentOffsetAdjustment = contentOffsetAdjustment
+        self.invalidateLayout(with: context)
+        return true
     }
 
     // Try to determine the correct adjustment to `content offset` that will
     // ensure scroll continuity.
-    private static func invalidationContentOffsetAdjustment(delegate: ConversationViewLayoutDelegate,
-                                                            layoutInfoBeforeUpdate: LayoutInfo,
-                                                            layoutInfoAfterUpdate: LayoutInfo) -> CGPoint? {
+    private static func invalidationContentOffsetAdjustment(scrollContinuityToken: CVScrollContinuityToken,
+                                                            layoutInfoAfterUpdate: LayoutInfo,
+                                                            isRelativeToTop: Bool) -> CGPoint? {
+
+        let layoutInfoBeforeUpdate = scrollContinuityToken.layoutInfo
 
-        var beforeItemLayoutMap = [String: ItemLayout]()
-        for itemLayout in layoutInfoBeforeUpdate.itemLayouts {
-            beforeItemLayoutMap[itemLayout.interactionUniqueId] = itemLayout
+        func buildItemLayoutMap(layoutInfo: LayoutInfo) -> [String: ItemLayout] {
+            var result = [String: ItemLayout]()
+            for itemLayout in layoutInfo.itemLayouts {
+                result[itemLayout.interactionUniqueId] = itemLayout
+            }
+            return result
         }
 
-        // Honor the scroll continuity bias.
-        //
-        // If we prefer continuity with regard to the bottom
-        // of the conversation, start with the last items.
-        let afterItemLayouts = (delegate.scrollContinuity == .bottom
-                                    ? layoutInfoAfterUpdate.itemLayouts.reversed()
-                                    : layoutInfoAfterUpdate.itemLayouts)
+        let beforeItemLayoutMap = buildItemLayoutMap(layoutInfo: layoutInfoBeforeUpdate)
+        let afterItemLayoutMap = buildItemLayoutMap(layoutInfo: layoutInfoAfterUpdate)
 
-        for afterItemLayout in afterItemLayouts {
-            guard let beforeItemLayout = beforeItemLayoutMap[afterItemLayout.interactionUniqueId] else {
-                continue
-            }
+        func calculateAdjustment(beforeItemLayout: ItemLayout,
+                                 afterItemLayout: ItemLayout) -> CGPoint {
             let frameBeforeUpdate = beforeItemLayout.layoutAttributes.frame
             let frameAfterUpdate = afterItemLayout.layoutAttributes.frame
             let offset = frameAfterUpdate.origin - frameBeforeUpdate.origin
@@ -494,17 +552,47 @@ public class ConversationViewLayout: UICollectionViewLayout {
             return contentOffsetAdjustment
         }
 
+        // Prefer to maintain continuity with visible interactions.
+        //
+        // Honor the scroll continuity bias. If we prefer continuity with regard
+        // to the bottom of the viewport, start with the last items.
+        let visibleUniqueIds = (isRelativeToTop
+                                    ? scrollContinuityToken.visibleUniqueIds
+                                    : scrollContinuityToken.visibleUniqueIds.reversed())
+        for visibleUniqueId in visibleUniqueIds {
+            guard let beforeItemLayout = beforeItemLayoutMap[visibleUniqueId],
+                  let afterItemLayout = afterItemLayoutMap[visibleUniqueId] else {
+                continue
+            }
+            return calculateAdjustment(beforeItemLayout: beforeItemLayout,
+                                       afterItemLayout: afterItemLayout)
+        }
+
+        // Fail over to trying to use any interaction in the before & after
+        // load windows.  Again, honor the scroll continuity bias.
+        let afterItemLayouts = (isRelativeToTop
+                                    ? layoutInfoAfterUpdate.itemLayouts
+                                    : layoutInfoAfterUpdate.itemLayouts.reversed())
+
+        for afterItemLayout in afterItemLayouts {
+            guard let beforeItemLayout = beforeItemLayoutMap[afterItemLayout.interactionUniqueId] else {
+                continue
+            }
+            return calculateAdjustment(beforeItemLayout: beforeItemLayout,
+                                       afterItemLayout: afterItemLayout)
+        }
+
         return nil
     }
 
     @objc
-    public func didPerformBatchUpdates(scrollContinuityToken: CVScrollContinuityToken?) {
+    public func didPerformBatchUpdates() {
         AssertIsOnMainThread()
         owsAssertDebug(!isReloadingData)
         owsAssertDebug(isPerformingBatchUpdates)
 
         isPerformingBatchUpdates = false
-        isPerformingBatchUpdatesWithInvalidation = false
+        delegateScrollContinuityMode = .disabled
     }
 
     @objc
@@ -519,10 +607,14 @@ public class ConversationViewLayout: UICollectionViewLayout {
         AssertIsOnMainThread()
         owsAssertDebug(!isReloadingData)
         owsAssertDebug(!isPerformingBatchUpdates)
-        owsAssertDebug(!isPerformingBatchUpdatesWithInvalidation)
+        owsAssertDebug(delegateScrollContinuityMode == .none)
 
         isReloadingData = true
         updateCompletionCounter.increment()
+        // TODO: We _could_ use the invalidation context for scroll
+        // continuity here.
+        let lastKnownDistanceFromBottom = delegate?.conversationViewController?.lastKnownDistanceFromBottom ?? 0
+        delegateScrollContinuityMode = .enabled(lastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
     }
 
     @objc
@@ -530,17 +622,50 @@ public class ConversationViewLayout: UICollectionViewLayout {
         AssertIsOnMainThread()
         owsAssertDebug(isReloadingData)
         owsAssertDebug(!isPerformingBatchUpdates)
-        owsAssertDebug(!isPerformingBatchUpdatesWithInvalidation)
 
         isReloadingData = false
         updateCompletionCounter.decrementOrZero()
+        delegateScrollContinuityMode = .disabled
     }
 
     public func buildScrollContinuityToken() -> CVScrollContinuityToken {
         AssertIsOnMainThread()
 
         let layoutInfo = ensureCurrentLayoutInfo()
-        return CVScrollContinuityToken(layoutInfo: layoutInfo)
+        let contentOffset = collectionView?.contentOffset ?? .zero
+        let visibleUniqueIds: [String] = {
+            guard let collectionView = self.collectionView,
+                  let conversationViewController = delegate?.conversationViewController else {
+                Logger.warn("Missing conversationViewController.")
+                return []
+            }
+            let visibleIndexPaths = collectionView.indexPathsForVisibleItems
+            return visibleIndexPaths.compactMap { indexPath -> String? in
+                guard let interaction = conversationViewController.interaction(forIndexPath: indexPath),
+                      Self.canInteractionBeUsedForScrollContinuity(interaction) else {
+                    return nil
+                }
+                return interaction.uniqueId
+            }
+        }()
+        return CVScrollContinuityToken(layoutInfo: layoutInfo,
+                                       contentOffset: contentOffset,
+                                       visibleUniqueIds: visibleUniqueIds)
+    }
+
+    // Some interactions shift around and cannot be reliably used as
+    // references for scroll continuity.
+    private static func canInteractionBeUsedForScrollContinuity(_ interaction: TSInteraction) -> Bool {
+        guard !interaction.isDynamicInteraction() else {
+            return false
+        }
+
+        switch interaction.interactionType() {
+        case .unknown, .unreadIndicator, .dateHeader, .typingIndicator:
+            return false
+        case .incomingMessage, .outgoingMessage, .error, .call, .info, .threadDetails, .unknownThreadWarning, .defaultDisappearingMessageTimer:
+            return true
+        }
     }
 
     // This method is called when there is an update with deletes/inserts to the collection view.
@@ -570,12 +695,20 @@ public class ConversationViewLayout: UICollectionViewLayout {
         super.finalizeAnimatedBoundsChange()
     }
 
+    private var isUserScrolling: Bool {
+        delegate?.conversationViewController?.isUserScrolling ?? false
+    }
+
+    private var hasScrollingAnimation: Bool {
+        delegate?.conversationViewController?.hasScrollingAnimation ?? false
+    }
+
     private var debugInfo: String {
-        guard let delegate = delegate else {
-            owsFailDebug("Missing delegate.")
-            return "Missing delegate"
-        }
-        return "isUserScrolling: \(delegate.isUserScrolling), hasScrollingAnimation: \(delegate.hasScrollingAnimation), scrollContinuity: \(delegate.scrollContinuity), isPerformingBatchUpdates: \(isPerformingBatchUpdates), isReloadingData: \(isReloadingData)"
+        "isUserScrolling: \(isUserScrolling), hasScrollingAnimation: \(hasScrollingAnimation), " +
+            "isPerformingBatchUpdates: \(isPerformingBatchUpdates), " +
+            "isReloadingData: \(isReloadingData), " +
+            "isPerformBatchUpdatesOrReloadDataBeingApplied: \(isPerformBatchUpdatesOrReloadDataBeingApplied), " +
+            "isPerformBatchUpdatesOrReloadDataBeingAppliedOrSettling: \(isPerformBatchUpdatesOrReloadDataBeingAppliedOrSettling), "
     }
 
     // MARK: -
@@ -614,13 +747,18 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
         // While applying reloadData() and performBatchUpdates(), allow CVC
         // to maintain scroll continuity.
-        if isPerformBatchUpdatesOrReloadDataBeingApplied,
-           !isPerformingBatchUpdatesWithInvalidation {
-            let targetContentOffset = delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
-            return targetContentOffset
-        } else {
-            return proposedContentOffset
+        switch delegateScrollContinuityMode {
+        case .disabled:
+            break
+        case .enabled(let lastKnownDistanceFromBottom):
+            if let conversationViewController = delegate.conversationViewController {
+                let targetContentOffset = conversationViewController.targetContentOffset(forProposedContentOffset: proposedContentOffset,
+                                                                                         lastKnownDistanceFromBottom: lastKnownDistanceFromBottom)
+                return targetContentOffset
+            }
         }
+
+        return proposedContentOffset
     }
 
     @objc
@@ -635,8 +773,14 @@ public class ConversationViewLayout: UICollectionViewLayout {
 @objc
 public class CVScrollContinuityToken: NSObject {
     fileprivate let layoutInfo: ConversationViewLayout.LayoutInfo
+    fileprivate let contentOffset: CGPoint
+    fileprivate let visibleUniqueIds: [String]
 
-    fileprivate init(layoutInfo: ConversationViewLayout.LayoutInfo) {
+    fileprivate init(layoutInfo: ConversationViewLayout.LayoutInfo,
+                     contentOffset: CGPoint,
+                     visibleUniqueIds: [String]) {
         self.layoutInfo = layoutInfo
+        self.contentOffset = contentOffset
+        self.visibleUniqueIds = visibleUniqueIds
     }
 }
