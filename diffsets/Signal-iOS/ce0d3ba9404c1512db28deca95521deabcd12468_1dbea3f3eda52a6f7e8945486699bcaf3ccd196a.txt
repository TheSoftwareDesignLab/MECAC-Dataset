diff --git a/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift b/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift
index 84d824ea769..481cae6dee7 100644
--- a/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift
+++ b/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift
@@ -139,6 +139,21 @@ class MediaPageViewController: UIPageViewController, UIPageViewControllerDataSou
     // MARK: UIViewController overrides
 
     override var preferredStatusBarStyle: UIStatusBarStyle {
+        let useDarkContentStatusBar: Bool
+        if mediaInteractiveDismiss.interactionInProgress {
+            useDarkContentStatusBar = true
+        } else if isBeingDismissed, let transitionCoordinator {
+            useDarkContentStatusBar = !transitionCoordinator.isCancelled
+        } else {
+            useDarkContentStatusBar = false
+        }
+
+        if useDarkContentStatusBar {
+            if #available(iOS 13, *) {
+                return .darkContent
+            }
+            return .default
+        }
         return .lightContent
     }
 
diff --git a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift
index 9790d695dc2..88d75c707cc 100644
--- a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift
+++ b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift
@@ -13,7 +13,7 @@ class MediaDismissAnimationController: NSObject {
 
     var transitionView: UIView?
     var fromMediaFrame: CGRect?
-    var pendingCompletion: (() -> Void)?
+    var pendingCompletion: ((CGVector?) -> Void)?
 
     init(galleryItem: MediaGalleryItem, interactionController: MediaInteractiveDismiss? = nil) {
         self.item = .gallery(galleryItem)
@@ -168,7 +168,7 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
         let duration = transitionDuration(using: transitionContext)
         let isTransitionInteractive = transitionContext.isInteractive
 
-        let completion = {
+        let completion: (CGVector?) -> Void = { velocity in
             let destinationFrame: CGRect
             let destinationRoundedCorners: RoundedCorners
             if transitionContext.transitionWasCancelled {
@@ -186,7 +186,12 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
                 destinationRoundedCorners = fromMediaContext.roundedCorners
             }
 
-            let animator = UIViewPropertyAnimator(duration: duration, springDamping: 0.77, springResponse: 0.3)
+            let animator = UIViewPropertyAnimator(
+                duration: duration,
+                springDamping: 0.77,
+                springResponse: 0.3,
+                initialVelocity: velocity ?? .zero
+            )
             animator.addAnimations {
                 if !transitionContext.transitionWasCancelled {
                     fromTransitionalOverlayView?.alpha = 0
@@ -258,12 +263,12 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
 
                     Logger.verbose("ran pendingCompletion after fadeout")
                     self.pendingCompletion = nil
-                    pendingCompletion()
+                    pendingCompletion(nil)
                 }
             )
         } else {
             Logger.verbose("ran completion simultaneously for non-interactive transition")
-            completion()
+            completion(nil)
         }
     }
 }
@@ -290,11 +295,12 @@ extension MediaDismissAnimationController: InteractiveDismissDelegate {
         transitionView.center = fromMediaFrame.offsetBy(dx: offset.x, dy: offset.y).center
     }
 
-    func interactiveDismissDidFinish(_ interactiveDismiss: UIPercentDrivenInteractiveTransition) {
+    func interactiveDismiss(_ interactiveDismiss: UIPercentDrivenInteractiveTransition,
+                            didFinishWithVelocity velocity: CGVector?) {
         if let pendingCompletion {
             Logger.verbose("interactive gesture started pendingCompletion during fadeout")
             self.pendingCompletion = nil
-            pendingCompletion()
+            pendingCompletion(velocity)
         }
     }
 
diff --git a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaInteractiveDismiss.swift b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaInteractiveDismiss.swift
index e67b3eff4d2..26d2f0e2b0c 100644
--- a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaInteractiveDismiss.swift
+++ b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaInteractiveDismiss.swift
@@ -16,7 +16,8 @@ protocol InteractiveDismissDelegate: AnyObject {
     func interactiveDismiss(_ interactiveDismiss: UIPercentDrivenInteractiveTransition,
                             didChangeProgress: CGFloat,
                             touchOffset: CGPoint)
-    func interactiveDismissDidFinish(_ interactiveDismiss: UIPercentDrivenInteractiveTransition)
+    func interactiveDismiss(_ interactiveDismiss: UIPercentDrivenInteractiveTransition,
+                            didFinishWithVelocity: CGVector?)
     func interactiveDismissDidCancel(_ interactiveDismiss: UIPercentDrivenInteractiveTransition)
 }
 
@@ -28,9 +29,8 @@ extension InteractiveDismissDelegate {
                             didChangeProgress: CGFloat,
                             touchOffset: CGPoint
     ) { }
-    func interactiveDismissDidFinish(_ interactiveDismiss: UIPercentDrivenInteractiveTransition) {
-
-    }
+    func interactiveDismiss(_ interactiveDismiss: UIPercentDrivenInteractiveTransition,
+                            didFinishWithVelocity: CGVector?) { }
     func interactiveDismissDidCancel(_ interactiveDismiss: UIPercentDrivenInteractiveTransition) {
 
     }
@@ -58,21 +58,20 @@ class MediaInteractiveDismiss: UIPercentDrivenInteractiveTransition {
 
     // MARK: - Private
 
-    private var fastEnoughToCompleteTransition = false
-    private var farEnoughToCompleteTransition = false
+    private static let distanceToCompletion: CGFloat = 88
 
-    private var shouldCompleteTransition: Bool {
-        if farEnoughToCompleteTransition {
-            Logger.verbose("farEnoughToCompleteTransition")
-            return true
+    // Copy-pasted from SDK documentation.
+    private func initialAnimationVelocity(for gestureVelocity: CGPoint, from currentPosition: CGPoint, to finalPosition: CGPoint) -> CGVector {
+        var animationVelocity = CGVector.zero
+        let xDistance = finalPosition.x - currentPosition.x
+        let yDistance = finalPosition.y - currentPosition.y
+        if xDistance != 0 {
+            animationVelocity.dx = gestureVelocity.x / xDistance
         }
-
-        if fastEnoughToCompleteTransition {
-            Logger.verbose("fastEnoughToCompleteTransition")
-            return true
+        if yDistance != 0 {
+            animationVelocity.dy = gestureVelocity.y / yDistance
         }
-
-        return false
+        return animationVelocity
     }
 
     @objc
@@ -86,49 +85,55 @@ class MediaInteractiveDismiss: UIPercentDrivenInteractiveTransition {
             gestureRecognizer.setTranslation(.zero, in: coordinateSpace)
         }
 
-        let distanceToCompletion: CGFloat = 88
-        let velocityThreshold: CGFloat = 500
-
         switch gestureRecognizer.state {
         case .began:
             interactionInProgress = true
             targetViewController?.performInteractiveDismissal(animated: true)
 
         case .changed:
-            let velocity = abs(gestureRecognizer.velocity(in: coordinateSpace).y)
-            if velocity > velocityThreshold {
-                fastEnoughToCompleteTransition = true
-            }
-
             let offset = gestureRecognizer.translation(in: coordinateSpace)
-            let progress = CGFloatClamp01(offset.length / distanceToCompletion)
-            // `farEnoughToCompleteTransition` is cancelable if the user reverses direction
-            farEnoughToCompleteTransition = progress == 1
-
+            let progress = CGFloatClamp01(offset.length / Self.distanceToCompletion)
             update(progress)
 
             interactiveDismissDelegate?.interactiveDismiss(self, didChangeProgress: progress, touchOffset: offset)
 
         case .cancelled:
-            interactiveDismissDelegate?.interactiveDismissDidFinish(self)
             cancel()
+            interactiveDismissDelegate?.interactiveDismissDidCancel(self)
 
             interactionInProgress = false
-            farEnoughToCompleteTransition = false
-            fastEnoughToCompleteTransition = false
+
+            targetViewController?.setNeedsStatusBarAppearanceUpdate()
 
         case .ended:
-            if shouldCompleteTransition {
+            let finishTransition = percentComplete == 1
+            if finishTransition {
                 finish()
             } else {
                 cancel()
             }
 
-            interactiveDismissDelegate?.interactiveDismissDidFinish(self)
+            let gestureVelocity = gestureRecognizer.velocity(in: coordinateSpace)
+            let animationVelocity = initialAnimationVelocity(
+                for: gestureVelocity,
+                from: .zero,
+                to: gestureRecognizer.translation(in: coordinateSpace)
+            )
+            // Call `interactiveDismiss(_:, didFinishWithVelocity:) even when transition is canceled
+            // to restore initial state with a proper spring animation.
+            interactiveDismissDelegate?.interactiveDismiss(self, didFinishWithVelocity: animationVelocity)
+
+            // This logic is necessary to ensure correct status bar state
+            // both when transition is finished or canceled.
+            if finishTransition {
+                targetViewController?.setNeedsStatusBarAppearanceUpdate()
+            }
 
             interactionInProgress = false
-            farEnoughToCompleteTransition = false
-            fastEnoughToCompleteTransition = false
+
+            if !finishTransition {
+                targetViewController?.setNeedsStatusBarAppearanceUpdate()
+            }
 
         default:
             break
diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureDismiss.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureDismiss.swift
index 80784ca6713..13e47fce2ca 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureDismiss.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureDismiss.swift
@@ -83,7 +83,7 @@ class PhotoCaptureInteractiveDismiss: UIPercentDrivenInteractiveTransition {
         case .ended:
             if shouldCompleteTransition {
                 finish()
-                interactiveDismissDelegate?.interactiveDismissDidFinish(self)
+                interactiveDismissDelegate?.interactiveDismiss(self, didFinishWithVelocity: nil)
             } else {
                 cancel()
                 interactiveDismissDelegate?.interactiveDismissDidCancel(self)
diff --git a/SignalUI/Categories/UIKit+SignalUI.swift b/SignalUI/Categories/UIKit+SignalUI.swift
index 80cd98dcad1..e879ab94265 100644
--- a/SignalUI/Categories/UIKit+SignalUI.swift
+++ b/SignalUI/Categories/UIKit+SignalUI.swift
@@ -10,7 +10,8 @@ public extension UIViewPropertyAnimator {
     convenience init (
         duration: TimeInterval,
         springDamping: CGFloat,
-        springResponse: CGFloat
+        springResponse: CGFloat,
+        initialVelocity velocity: CGVector = .zero
     ) {
         let stiffness = pow(2 * .pi / springResponse, 2)
         let damping = 4 * .pi * springDamping / springResponse
@@ -18,7 +19,7 @@ public extension UIViewPropertyAnimator {
             mass: 1,
             stiffness: stiffness,
             damping: damping,
-            initialVelocity: .zero
+            initialVelocity: velocity
         )
         self.init(duration: duration, timingParameters: timingParameters)
         isUserInteractionEnabled = true
