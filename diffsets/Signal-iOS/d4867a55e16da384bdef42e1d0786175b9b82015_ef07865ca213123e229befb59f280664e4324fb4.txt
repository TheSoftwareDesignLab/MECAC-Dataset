diff --git a/Signal/Backups/BackupSettingsViewController.swift b/Signal/Backups/BackupSettingsViewController.swift
index 7354856994..fc629d426e 100644
--- a/Signal/Backups/BackupSettingsViewController.swift
+++ b/Signal/Backups/BackupSettingsViewController.swift
@@ -687,22 +687,37 @@ class BackupSettingsViewController:
         switch currentBackupPlan {
         case .free:
             return .free
-        case .disabling, .disabled, .paid, .paidExpiringSoon, .paidAsTester:
+        case .paidAsTester:
+            return .paidButFreeForTesters
+        case .disabling, .disabled, .paid, .paidExpiringSoon:
             break
         }
 
-        let endOfCurrentPeriod = backupSubscription.endOfCurrentPeriod
-        if backupSubscription.cancelAtEndOfPeriod {
-            if endOfCurrentPeriod.isAfterNow {
-                return .paidButExpiring(expirationDate: endOfCurrentPeriod)
+        switch backupSubscription.status {
+        case .canceled, .unrecognized:
+            owsFailDebug("Unexpected subscription status for IAP subscription! \(backupSubscription.status)")
+            fallthrough
+        case .active:
+            let endOfCurrentPeriod = backupSubscription.endOfCurrentPeriod
+            if backupSubscription.cancelAtEndOfPeriod {
+                if endOfCurrentPeriod.isAfterNow {
+                    return .paidButExpiring(expirationDate: endOfCurrentPeriod)
+                } else {
+                    return .paidButExpired(expirationDate: endOfCurrentPeriod)
+                }
             } else {
-                return .paidButExpired(expirationDate: endOfCurrentPeriod)
+                return .paid(
+                    price: backupSubscription.amount,
+                    renewalDate: endOfCurrentPeriod
+                )
             }
-        } else {
-            return .paid(
-                price: backupSubscription.amount,
-                renewalDate: endOfCurrentPeriod
-            )
+        case .pastDue:
+            // The .pastDue status is returned if we're in the IAP "billing
+            // retry", period, which indicates something has gone wrong with a
+            // subscription renewal.
+            //
+            // SeeAlso: BackupSubscriptionManager
+            return .paidButFailedToRenew
         }
     }
 
@@ -1185,6 +1200,7 @@ private class BackupSettingsViewModel: ObservableObject {
             case paid(price: FiatMoney, renewalDate: Date)
             case paidButExpiring(expirationDate: Date)
             case paidButExpired(expirationDate: Date)
+            case paidButFailedToRenew
         }
 
         case loading
@@ -1685,7 +1701,7 @@ struct BackupSettingsView: View {
         case .loaded(.paidButFreeForTesters):
             // Let them reenable with anything; there was no purchase.
             implicitPlanSelection = nil
-        case .loaded(.free), .loaded(.paidButExpired), .genericError:
+        case .loaded(.free), .loaded(.paidButExpired), .loaded(.paidButFailedToRenew), .genericError:
             // Let them reenable with anything.
             implicitPlanSelection = nil
         case .loaded(.paid), .loaded(.paidButExpiring):
@@ -2274,7 +2290,7 @@ private struct BackupSubscriptionView: View {
                             ),
                             backupSubscriptionConfiguration.freeTierMediaDays,
                         ))
-                    case .paid, .paidButExpiring, .paidButExpired, .paidButFreeForTesters:
+                    case .paidButFreeForTesters, .paid, .paidButExpiring, .paidButExpired, .paidButFailedToRenew:
                         Text(OWSLocalizedString(
                             "BACKUP_SETTINGS_BACKUP_PLAN_PAID_HEADER",
                             comment: "Header describing what the paid backup plan includes."
@@ -2292,6 +2308,11 @@ private struct BackupSubscriptionView: View {
                         "BACKUP_SETTINGS_BACKUP_PLAN_FREE_DESCRIPTION",
                         comment: "Text describing the user's free backup plan."
                     ))
+                case .paidButFreeForTesters:
+                    Text(OWSLocalizedString(
+                        "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FREE_FOR_TESTERS_DESCRIPTION",
+                        comment: "Text describing that the user's backup plan is paid, but free for them as a tester."
+                    ))
                 case .paid(let price, let renewalDate):
                     let renewalStringFormat = OWSLocalizedString(
                         "BACKUP_SETTINGS_BACKUP_PLAN_PAID_RENEWAL_FORMAT",
@@ -2312,7 +2333,7 @@ private struct BackupSubscriptionView: View {
                     ))
                 case .paidButExpiring(let expirationDate), .paidButExpired(let expirationDate):
                     let expirationDateFormatString = switch loadedBackupSubscription {
-                    case .free, .paid, .paidButFreeForTesters:
+                    case .free, .paidButFreeForTesters, .paid, .paidButFailedToRenew:
                         owsFail("Not possible")
                     case .paidButExpiring:
                         OWSLocalizedString(
@@ -2330,15 +2351,24 @@ private struct BackupSubscriptionView: View {
                         "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_DESCRIPTION",
                         comment: "Text describing that the user's paid backup plan has been canceled."
                     ))
+                    .font(.subheadline)
+                    .fontWeight(.semibold)
                     .foregroundStyle(Color.Signal.red)
                     Text(String(
                         format: expirationDateFormatString,
                         DateFormatter.localizedString(from: expirationDate, dateStyle: .medium, timeStyle: .none)
                     ))
-                case .paidButFreeForTesters:
+                case .paidButFailedToRenew:
                     Text(OWSLocalizedString(
-                        "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FREE_FOR_TESTERS_DESCRIPTION",
-                        comment: "Text describing that the user's backup plan is paid, but free for them as a tester."
+                        "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FAILED_TO_RENEW_DESCRIPTION_1",
+                        comment: "Text describing that the user's paid backup plan has been canceled."
+                    ))
+                    .font(.subheadline)
+                    .fontWeight(.semibold)
+                    .foregroundStyle(Color.Signal.red)
+                    Text(OWSLocalizedString(
+                        "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FAILED_TO_RENEW_DESCRIPTION_2",
+                        comment: "Text describing that the user's paid backup plan has been canceled."
                     ))
                 }
 
@@ -2348,10 +2378,10 @@ private struct BackupSubscriptionView: View {
                     switch loadedBackupSubscription {
                     case .free:
                         viewModel.upgradeFromFreeToPaidPlan()
-                    case .paid, .paidButExpiring, .paidButExpired:
-                        viewModel.manageOrCancelPaidPlan()
                     case .paidButFreeForTesters:
                         viewModel.managePaidPlanAsTester()
+                    case .paid, .paidButExpiring, .paidButExpired, .paidButFailedToRenew:
+                        viewModel.manageOrCancelPaidPlan()
                     }
                 } label: {
                     switch loadedBackupSubscription {
@@ -2360,6 +2390,11 @@ private struct BackupSubscriptionView: View {
                             "BACKUP_SETTINGS_BACKUP_PLAN_FREE_ACTION_BUTTON_TITLE",
                             comment: "Title for a button allowing users to upgrade from a free to paid backup plan."
                         ))
+                    case .paidButFreeForTesters:
+                        Text(OWSLocalizedString(
+                            "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FREE_FOR_TESTERS_ACTION_BUTTON_TITLE",
+                            comment: "Title for a button allowing users to manage their backup plan as a tester."
+                        ))
                     case .paid:
                         Text(OWSLocalizedString(
                             "BACKUP_SETTINGS_BACKUP_PLAN_PAID_ACTION_BUTTON_TITLE",
@@ -2370,10 +2405,10 @@ private struct BackupSubscriptionView: View {
                             "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_ACTION_BUTTON_TITLE",
                             comment: "Title for a button allowing users to reenable a paid backup plan that has been canceled."
                         ))
-                    case .paidButFreeForTesters:
+                    case .paidButFailedToRenew:
                         Text(OWSLocalizedString(
-                            "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FREE_FOR_TESTERS_ACTION_BUTTON_TITLE",
-                            comment: "Title for a button allowing users to manage their backup plan as a tester."
+                            "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FAILED_TO_RENEW_ACTION_BUTTON_TITLE",
+                            comment: "Title for a button allowing users to manage a paid backup plan that failed to renew."
                         ))
                     }
                 }
@@ -2570,16 +2605,6 @@ private extension BackupSettingsViewModel {
     }
 }
 
-#Preview("Plan: Paid") {
-    BackupSettingsView(viewModel: .forPreview(
-        backupPlan: .paid(optimizeLocalStorage: false),
-        backupSubscriptionLoadingState: .loaded(.paid(
-            price: FiatMoney(currencyCode: "USD", value: 1.99),
-            renewalDate: Date().addingTimeInterval(.week)
-        )),
-    ))
-}
-
 #Preview("Plan: Free") {
     BackupSettingsView(viewModel: .forPreview(
         backupPlan: .free,
@@ -2594,6 +2619,16 @@ private extension BackupSettingsViewModel {
     ))
 }
 
+#Preview("Plan: Paid") {
+    BackupSettingsView(viewModel: .forPreview(
+        backupPlan: .paid(optimizeLocalStorage: false),
+        backupSubscriptionLoadingState: .loaded(.paid(
+            price: FiatMoney(currencyCode: "USD", value: 1.99),
+            renewalDate: Date().addingTimeInterval(.week)
+        )),
+    ))
+}
+
 #Preview("Plan: Expiring") {
     BackupSettingsView(viewModel: .forPreview(
         backupPlan: .paidExpiringSoon(optimizeLocalStorage: false),
@@ -2612,6 +2647,13 @@ private extension BackupSettingsViewModel {
     ))
 }
 
+#Preview("Plan: Failed to Renew") {
+    BackupSettingsView(viewModel: .forPreview(
+        backupPlan: .paidExpiringSoon(optimizeLocalStorage: false),
+        backupSubscriptionLoadingState: .loaded(.paidButFailedToRenew)
+    ))
+}
+
 #Preview("Plan: Network Error") {
     BackupSettingsView(viewModel: .forPreview(
         backupPlan: .paid(optimizeLocalStorage: false),
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListFYISheetCoordinator.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListFYISheetCoordinator.swift
index 4d9e1aa608..c8288b0acd 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListFYISheetCoordinator.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListFYISheetCoordinator.swift	
@@ -36,10 +36,13 @@ class ChatListFYISheetCoordinator {
             let subscriptionType: SubscriptionType
         }
 
+        struct BackupSubscriptionFailedToRenew {}
+
         case badgeThanks(BadgeThanks)
         case badgeIssue(BadgeIssue)
         case badgeExpiration(BadgeExpiration)
         case backupSubscriptionExpired(BackupSubscriptionExpired)
+        case backupSubscriptionFailedToRenew(BackupSubscriptionFailedToRenew)
     }
 
     private let backupExportJobRunner: BackupExportJobRunner
@@ -111,6 +114,8 @@ class ChatListFYISheetCoordinator {
             return .backupSubscriptionExpired(FYISheet.BackupSubscriptionExpired(subscriptionType: .iap))
         } else if backupSubscriptionIssueStore.shouldWarnTestFlightSubscriptionExpired(tx: tx) {
             return .backupSubscriptionExpired(FYISheet.BackupSubscriptionExpired(subscriptionType: .testFlight))
+        } else if backupSubscriptionIssueStore.shouldWarnIAPSubscriptionFailedToRenew(tx: tx) {
+            return .backupSubscriptionFailedToRenew(FYISheet.BackupSubscriptionFailedToRenew())
         } else {
             return nil
         }
@@ -223,6 +228,8 @@ class ChatListFYISheetCoordinator {
             await _present(badgeExpiration: badgeExpiration, from: chatListViewController)
         case .backupSubscriptionExpired(let backupSubscriptionExpired):
             await _present(backupSubscriptionExpired: backupSubscriptionExpired, from: chatListViewController)
+        case .backupSubscriptionFailedToRenew(let backupSubscriptionFailedToRenew):
+            await _present(backupSubscriptionFailedToRenew: backupSubscriptionFailedToRenew, from: chatListViewController)
         }
     }
 
@@ -415,6 +422,25 @@ class ChatListFYISheetCoordinator {
             }
         }
     }
+
+    private func _present(
+        backupSubscriptionFailedToRenew: FYISheet.BackupSubscriptionFailedToRenew,
+        from chatListViewController: ChatListViewController,
+    ) async {
+        let logger = PrefixedLogger(prefix: "[Backups]")
+        logger.info("Showing BackupSubscriptionFailedToRenew FYI sheet.")
+
+        let sheet = BackupSubscriptionFailedToRenewHeroSheet(
+            onManageSubscription: {
+                SignalApp.shared.showAppSettings(mode: .backups)
+            }
+        )
+        chatListViewController.present(sheet, animated: true) { [self] in
+            db.write { tx in
+                backupSubscriptionIssueStore.setDidWarnIAPSubscriptionFailedToRenew(tx: tx)
+            }
+        }
+    }
 }
 
 // MARK: - ChatListViewController: BadgeIssueSheetDelegate
@@ -475,3 +501,38 @@ private class BackupSubscriptionExpiredHeroSheet: HeroSheetViewController {
         )
     }
 }
+
+// MARK: -
+
+private class BackupSubscriptionFailedToRenewHeroSheet: HeroSheetViewController {
+    init(
+        onManageSubscription: @escaping () -> Void,
+    ) {
+        super.init(
+            hero: .image(.backupsError),
+            title: OWSLocalizedString(
+                "BACKUP_SUBSCRIPTION_FAILED_TO_RENEW_SHEET_TITLE",
+                comment: "Title for a sheet shown when your Backup subscription fails to renew.",
+            ),
+            body: OWSLocalizedString(
+                "BACKUP_SUBSCRIPTION_FAILED_TO_RENEW_SHEET_MESSAGE",
+                comment: "Message for a sheet shown when your Backup subscription fails to renew.",
+            ),
+            primaryButton: HeroSheetViewController.Button(
+                title: OWSLocalizedString(
+                    "BACKUP_SUBSCRIPTION_FAILED_TO_RENEW_SHEET_PRIMARY_BUTTON",
+                    comment: "Primary button for a sheet shown when your Backup subscription fails to renew.",
+                ),
+                action: { sheet in
+                    sheet.dismiss(animated: true) {
+                        onManageSubscription()
+                    }
+                },
+            ),
+            secondaryButton: .dismissing(
+                title: CommonStrings.notNowButton,
+                style: .secondary,
+            ),
+        )
+    }
+}
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 4a5311db34..1b997b0465 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -700,6 +700,15 @@
 /* Text explaining that a user's paid plan, which has been canceled, expired on a past date. Embeds {{ the formatted expiration date }}. */
 "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_PAST_EXPIRATION_FORMAT" = "Expired %1$@";
 
+/* Title for a button allowing users to manage a paid backup plan that failed to renew. */
+"BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FAILED_TO_RENEW_ACTION_BUTTON_TITLE" = "Manage Subscription";
+
+/* Text describing that the user's paid backup plan has been canceled. */
+"BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FAILED_TO_RENEW_DESCRIPTION_1" = "Payment method declined";
+
+/* Text describing that the user's paid backup plan has been canceled. */
+"BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FAILED_TO_RENEW_DESCRIPTION_2" = "Check to make sure your payment method is up to date";
+
 /* Title for a button allowing users to manage their backup plan as a tester. */
 "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_FREE_FOR_TESTERS_ACTION_BUTTON_TITLE" = "Manage Plan";
 
@@ -928,6 +937,15 @@
 /* Title for a sheet shown after the user enables backups. */
 "BACKUP_SETTINGS_WELCOME_TO_BACKUPS_SHEET_TITLE" = "Welcome to Signal Secure Backups. Start your backup now.";
 
+/* Message for a sheet shown when your Backup subscription fails to renew. */
+"BACKUP_SUBSCRIPTION_FAILED_TO_RENEW_SHEET_MESSAGE" = "Check to make sure your payment method is up to date. Tap Manage Subscription > Signal > Update Payment Method.";
+
+/* Primary button for a sheet shown when your Backup subscription fails to renew. */
+"BACKUP_SUBSCRIPTION_FAILED_TO_RENEW_SHEET_PRIMARY_BUTTON" = "Manage Subscription";
+
+/* Title for a sheet shown when your Backup subscription fails to renew. */
+"BACKUP_SUBSCRIPTION_FAILED_TO_RENEW_SHEET_TITLE" = "Your Backups Subscription Failed to Renew";
+
 /* Body for system notification when we detect paid backup media uploads have encountered a problem */
 "BACKUPS_MEDIA_UPLOAD_FAILURE_NOTIFICATION_BODY" = "Please send us debug logs to help resolve the issue!";
 
diff --git a/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionIssueStore.swift b/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionIssueStore.swift
index c7a587ef1c..6795810888 100644
--- a/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionIssueStore.swift
+++ b/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionIssueStore.swift
@@ -5,6 +5,9 @@
 
 public struct BackupSubscriptionIssueStore {
     private enum Keys {
+        static let shouldWarnIAPSubscriptionFailedToRenew = "shouldWarnIAPSubscriptionFailedToRenew"
+        static let lastWarnedIAPSubscriptionFailedToRenewEndOfCurrentPeriod = "lastWarnedIAPSubscriptionFailedToRenewEndOfCurrentPeriod"
+
         static let shouldWarnIAPSubscriptionExpired = "shouldWarnIAPSubscriptionExpired"
         static let shouldWarnTestFlightSubscriptionExpired = "shouldWarnTestFlightSubscriptionExpired"
     }
@@ -17,6 +20,40 @@ public struct BackupSubscriptionIssueStore {
 
     // MARK: -
 
+    public func shouldWarnIAPSubscriptionFailedToRenew(tx: DBReadTransaction) -> Bool {
+        return kvStore.fetchValue(
+            Bool.self,
+            forKey: Keys.shouldWarnIAPSubscriptionFailedToRenew,
+            tx: tx,
+        ) ?? false
+    }
+
+    public func setShouldWarnIAPSubscriptionFailedToRenew(
+        endOfCurrentPeriod: Date,
+        tx: DBWriteTransaction,
+    ) {
+        if
+            let lastWarnedEndOfCurrentPeriod = kvStore.fetchValue(
+                Date.self,
+                forKey: Keys.lastWarnedIAPSubscriptionFailedToRenewEndOfCurrentPeriod,
+                tx: tx,
+            ),
+            endOfCurrentPeriod == lastWarnedEndOfCurrentPeriod
+        {
+            // Only save a single warning per period-that-failed-to-renew.
+            return
+        }
+
+        kvStore.writeValue(true, forKey: Keys.shouldWarnIAPSubscriptionFailedToRenew, tx: tx)
+        kvStore.writeValue(endOfCurrentPeriod, forKey: Keys.lastWarnedIAPSubscriptionFailedToRenewEndOfCurrentPeriod, tx: tx)
+    }
+
+    public func setDidWarnIAPSubscriptionFailedToRenew(tx: DBWriteTransaction) {
+        kvStore.writeValue(false, forKey: Keys.shouldWarnIAPSubscriptionFailedToRenew, tx: tx)
+    }
+
+    // MARK: -
+
     public func shouldWarnIAPSubscriptionExpired(tx: DBReadTransaction) -> Bool {
         return kvStore.fetchValue(
             Bool.self,
diff --git a/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift b/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift
index 96b9369a13..004f4d9a90 100644
--- a/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift
+++ b/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift
@@ -323,14 +323,45 @@ final class BackupSubscriptionManagerImpl: BackupSubscriptionManager {
         let subscription = try await subscriptionFetcher.fetch(subscriberID: subscriberID)
         let backupEntitlement = try await whoAmIManager.makeWhoAmIRequest().entitlements.backup
 
-        try await downgradeBackupPlanIfNecessary(
-            fetchedSubscription: subscription,
-            backupEntitlement: backupEntitlement,
-        )
+        try await db.awaitableWriteWithRollbackIfThrows { tx in
+            warnSubscriptionFailedToRenewIfNecessary(
+                fetchedSubscription: subscription,
+                tx: tx,
+            )
+
+            try downgradeBackupPlanIfNecessary(
+                fetchedSubscription: subscription,
+                backupEntitlement: backupEntitlement,
+                tx: tx,
+            )
+        }
 
         return subscription
     }
 
+    /// Warn the user if their subscription has failed to renew.
+    private func warnSubscriptionFailedToRenewIfNecessary(
+        fetchedSubscription subscription: Subscription?,
+        tx: DBWriteTransaction,
+    ) {
+        guard let subscription else { return }
+
+        switch subscription.status {
+        case .active:
+            break
+        case .canceled, .unrecognized:
+            owsFailDebug("Unexpected subscription status for IAP subscription! \(subscription.status)")
+        case .pastDue:
+            // The .pastDue status is returned if we're in the IAP "billing
+            // retry", period, which indicates something has gone wrong with a
+            // subscription renewal.
+            backupSubscriptionIssueStore.setShouldWarnIAPSubscriptionFailedToRenew(
+                endOfCurrentPeriod: subscription.endOfCurrentPeriod,
+                tx: tx,
+            )
+        }
+    }
+
     /// While we store locally a `BackupPlan`, the ultimate source of truth as
     /// to the state our our Backup subscription/plan is remote. Any time we
     /// fetch that remote state could be the moment we learn that something
@@ -347,95 +378,94 @@ final class BackupSubscriptionManagerImpl: BackupSubscriptionManager {
     private func downgradeBackupPlanIfNecessary(
         fetchedSubscription subscription: Subscription?,
         backupEntitlement: WhoAmIRequestFactory.Responses.WhoAmI.Entitlements.BackupEntitlement?,
-    ) async throws {
-        try await db.awaitableWriteWithRollbackIfThrows { tx in
-            let currentBackupPlan = backupPlanManager.backupPlan(tx: tx)
+        tx: DBWriteTransaction,
+    ) throws {
+        let currentBackupPlan = backupPlanManager.backupPlan(tx: tx)
 
-            enum Downgrade {
-                case toFreeTier
-                case toPaidExpiringSoon(optimizeLocalStorage: Bool)
+        enum Downgrade {
+            case toFreeTier
+            case toPaidExpiringSoon(optimizeLocalStorage: Bool)
+        }
+        let downgrade: Downgrade? = {
+            /// The value of optimizeLocalStorage, if the current BackupPlan
+            /// is .paid. nil otherwise.
+            let paidTierOptimizeLocalStorage: Bool?
+            switch currentBackupPlan {
+            case .paidAsTester:
+                // Handled by `BackupTestFlightEntitlementManager`.
+                return nil
+            case .disabled, .disabling, .free:
+                // Nothing to downgrade.
+                return nil
+            case .paid(let optimizeLocalStorage):
+                paidTierOptimizeLocalStorage = optimizeLocalStorage
+            case .paidExpiringSoon:
+                paidTierOptimizeLocalStorage = nil
             }
-            let downgrade: Downgrade? = {
-                /// The value of optimizeLocalStorage, if the current BackupPlan
-                /// is .paid. nil otherwise.
-                let paidTierOptimizeLocalStorage: Bool?
-                switch currentBackupPlan {
-                case .paidAsTester:
-                    // Handled by `BackupTestFlightEntitlementManager`.
-                    return nil
-                case .disabled, .disabling, .free:
-                    // Nothing to downgrade.
-                    return nil
-                case .paid(let optimizeLocalStorage):
-                    paidTierOptimizeLocalStorage = optimizeLocalStorage
-                case .paidExpiringSoon:
-                    paidTierOptimizeLocalStorage = nil
-                }
 
-                guard let subscription else {
-                    // The subscription will be missing if it's "expired", which
-                    // is the trigger for Chat Service to wipe its knowledge of
-                    // the subscriber ID.
-                    //
-                    // This happens in two ways:
-                    // - The user manually canceled, and their last-subscribed
-                    //   period has now elapsed.
-                    // - A renewal failed, and Apple's given up trying to get
-                    //   the user to resolve the issue. (Note that Apple will
-                    //   try for 60d, so our Backup entitlement will have
-                    //   generally have expired before this happens.)
-                    //
-                    // If the subscription is expired, downgrade to free.
-                    return .toFreeTier
-                }
+            guard let subscription else {
+                // The subscription will be missing if it's "expired", which
+                // is the trigger for Chat Service to wipe its knowledge of
+                // the subscriber ID.
+                //
+                // This happens in two ways:
+                // - The user manually canceled, and their last-subscribed
+                //   period has now elapsed.
+                // - A renewal failed, and Apple's given up trying to get
+                //   the user to resolve the issue. (Note that Apple will
+                //   try for 60d, so our Backup entitlement will have
+                //   generally have expired before this happens.)
+                //
+                // If the subscription is expired, downgrade to free.
+                return .toFreeTier
+            }
 
-                guard
-                    let backupEntitlement,
-                    Date(timeIntervalSince1970: backupEntitlement.expirationSeconds) > dateProvider()
-                else {
-                    // Our entitlement has expired, so we must downgrade to the
-                    // free tier. (Paid-tier operations will no longer work!)
-                    //
-                    // This likely means the subscription failed to renew, and
-                    // the "grace period" during which the entitlement persists
-                    // after the subscription period ends has now elapsed
-                    // without the user fixing the renewal issue.
-                    return .toFreeTier
-                }
+            guard
+                let backupEntitlement,
+                Date(timeIntervalSince1970: backupEntitlement.expirationSeconds) > dateProvider()
+            else {
+                // Our entitlement has expired, so we must downgrade to the
+                // free tier. (Paid-tier operations will no longer work!)
+                //
+                // This likely means the subscription failed to renew, and
+                // the "grace period" during which the entitlement persists
+                // after the subscription period ends has now elapsed
+                // without the user fixing the renewal issue.
+                return .toFreeTier
+            }
 
-                // At this point we have a subscription, and we have a Backup
-                // entitlement, so things are generally good.
+            // At this point we have a subscription, and we have a Backup
+            // entitlement, so things are generally good.
 
-                if
-                    let paidTierOptimizeLocalStorage,
-                    subscription.cancelAtEndOfPeriod
-                {
-                    // We're on the paid tier, but our subscription won't renew.
-                    return .toPaidExpiringSoon(optimizeLocalStorage: paidTierOptimizeLocalStorage)
-                }
+            if
+                let paidTierOptimizeLocalStorage,
+                subscription.cancelAtEndOfPeriod
+            {
+                // We're on the paid tier, but our subscription won't renew.
+                return .toPaidExpiringSoon(optimizeLocalStorage: paidTierOptimizeLocalStorage)
+            }
 
-                return nil
-            }()
+            return nil
+        }()
 
-            if let downgrade {
-                let downgradedBackupPlan: BackupPlan = switch downgrade {
-                case .toFreeTier: .free
-                case .toPaidExpiringSoon(let optimizeLocalStorage): .paidExpiringSoon(optimizeLocalStorage: optimizeLocalStorage)
-                }
+        if let downgrade {
+            let downgradedBackupPlan: BackupPlan = switch downgrade {
+            case .toFreeTier: .free
+            case .toPaidExpiringSoon(let optimizeLocalStorage): .paidExpiringSoon(optimizeLocalStorage: optimizeLocalStorage)
+            }
 
-                do {
-                    try backupPlanManager.setBackupPlan(downgradedBackupPlan, tx: tx)
+            do {
+                try backupPlanManager.setBackupPlan(downgradedBackupPlan, tx: tx)
 
-                    switch downgrade {
-                    case .toFreeTier:
-                        backupSubscriptionIssueStore.setShouldWarnIAPSubscriptionExpired(true, tx: tx)
-                    case .toPaidExpiringSoon:
-                        break
-                    }
-                } catch {
-                    owsFailDebug("Failed to downgrade BackupPlan: \(currentBackupPlan) -> \(downgradedBackupPlan)! \(error)")
-                    throw error
+                switch downgrade {
+                case .toFreeTier:
+                    backupSubscriptionIssueStore.setShouldWarnIAPSubscriptionExpired(true, tx: tx)
+                case .toPaidExpiringSoon:
+                    break
                 }
+            } catch {
+                owsFailDebug("Failed to downgrade BackupPlan: \(currentBackupPlan) -> \(downgradedBackupPlan)! \(error)")
+                throw error
             }
         }
     }
