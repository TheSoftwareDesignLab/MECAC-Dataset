diff --git a/Podfile b/Podfile
index 47b1f0c9218..91ffd9889f2 100644
--- a/Podfile
+++ b/Podfile
@@ -8,3 +8,4 @@ pod 'MMDrawerController',     '~> 0.5.0'
 pod 'libPhoneNumber-iOS',     '~> 0.7'
 pod 'PastelogKit',            '~> 1.1'
 pod 'AFNetworking',           '~> 2.3.1'
+pod 'TwistedOakCollapsingFutures'
diff --git a/Podfile.lock b/Podfile.lock
index bcef4da4308..9fd391b6656 100644
--- a/Podfile.lock
+++ b/Podfile.lock
@@ -41,7 +41,10 @@ PODS:
   - OpenSSL (1.0.109)
   - PastelogKit (1.1):
     - CocoaLumberjack (~> 1.9)
+  - TwistedOakCollapsingFutures (1.0.0):
+    - UnionFind (~> 1.0)
   - UICKeyChainStore (1.0.7)
+  - UnionFind (1.0.1)
 
 DEPENDENCIES:
   - AFNetworking (~> 2.3.1)
@@ -49,6 +52,7 @@ DEPENDENCIES:
   - MMDrawerController (~> 0.5.0)
   - OpenSSL (~> 1.0.109)
   - PastelogKit (~> 1.1)
+  - TwistedOakCollapsingFutures
   - UICKeyChainStore (from `Podspecs/UICKeyChainStore.podspec`)
 
 EXTERNAL SOURCES:
@@ -62,6 +66,8 @@ SPEC CHECKSUMS:
   MMDrawerController: 4bae84535ca7a5f4cb55a66a001e6035c3571677
   OpenSSL: 4810adf5c99b0e2cd20670a11a987c805e8a521c
   PastelogKit: 32836ec27e587a8876326abeaf9a1b5e2bc484ea
+  TwistedOakCollapsingFutures: 07aab84fd3958dc94d55ef705b12857d9fbe61d1
   UICKeyChainStore: eef407137f0397e95a3df32cdf05f7e2ddd99647
+  UnionFind: 45777a8b6878d3a602af3654cc3a09b87389d356
 
 COCOAPODS: 0.33.1
diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 63b9366f7ec..c0bba106b27 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -58,24 +58,10 @@
 		76D713EB182D3E5100C9C9C8 /* PreferenceListTableViewCell.xib in Resources */ = {isa = PBXBuildFile; fileRef = 76D713E9182D3E5100C9C9C8 /* PreferenceListTableViewCell.xib */; };
 		76EB054018170B33006006FC /* AppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C318170B33006006FC /* AppDelegate.m */; };
 		76EB054118170B33006006FC /* AppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C318170B33006006FC /* AppDelegate.m */; };
-		76EB054218170B33006006FC /* AsyncUtil.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C618170B33006006FC /* AsyncUtil.m */; };
-		76EB054318170B33006006FC /* AsyncUtil.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C618170B33006006FC /* AsyncUtil.m */; };
-		76EB054418170B33006006FC /* AsyncUtilHelperRacingOperation.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C818170B33006006FC /* AsyncUtilHelperRacingOperation.m */; };
-		76EB054518170B33006006FC /* AsyncUtilHelperRacingOperation.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C818170B33006006FC /* AsyncUtilHelperRacingOperation.m */; };
-		76EB054618170B33006006FC /* CancelledToken.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03CA18170B33006006FC /* CancelledToken.m */; };
-		76EB054718170B33006006FC /* CancelledToken.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03CA18170B33006006FC /* CancelledToken.m */; };
-		76EB054818170B33006006FC /* CancelTokenSource.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03CC18170B33006006FC /* CancelTokenSource.m */; };
-		76EB054918170B33006006FC /* CancelTokenSource.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03CC18170B33006006FC /* CancelTokenSource.m */; };
-		76EB054A18170B33006006FC /* Future.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03CE18170B33006006FC /* Future.m */; };
-		76EB054B18170B33006006FC /* Future.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03CE18170B33006006FC /* Future.m */; };
-		76EB054C18170B33006006FC /* FutureSource.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D018170B33006006FC /* FutureSource.m */; };
-		76EB054D18170B33006006FC /* FutureSource.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D018170B33006006FC /* FutureSource.m */; };
 		76EB054E18170B33006006FC /* FutureUtil.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D218170B33006006FC /* FutureUtil.m */; };
 		76EB054F18170B33006006FC /* FutureUtil.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D218170B33006006FC /* FutureUtil.m */; };
 		76EB055018170B33006006FC /* ObservableValue.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D418170B33006006FC /* ObservableValue.m */; };
 		76EB055118170B33006006FC /* ObservableValue.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D418170B33006006FC /* ObservableValue.m */; };
-		76EB055218170B33006006FC /* TimeoutFailure.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D818170B33006006FC /* TimeoutFailure.m */; };
-		76EB055318170B33006006FC /* TimeoutFailure.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03D818170B33006006FC /* TimeoutFailure.m */; };
 		76EB057218170B33006006FC /* RecentCall.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB040018170B33006006FC /* RecentCall.m */; };
 		76EB057318170B33006006FC /* RecentCall.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB040018170B33006006FC /* RecentCall.m */; };
 		76EB057418170B33006006FC /* RecentCallManager.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB040218170B33006006FC /* RecentCallManager.m */; };
@@ -327,9 +313,6 @@
 		A10FDF79184FB4BB007FF963 /* MediaPlayer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 76C87F18181EFCE600C4ACAB /* MediaPlayer.framework */; };
 		A11CD70D17FA230600A2D1B1 /* QuartzCore.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = A11CD70C17FA230600A2D1B1 /* QuartzCore.framework */; };
 		A123C14916F902EE000AE905 /* Security.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = A163E8AA16F3F6A90094D68B /* Security.framework */; };
-		A157075417F0CD6D007C2BD6 /* AsyncUtilTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A15706ED17F0CD6D007C2BD6 /* AsyncUtilTest.m */; };
-		A157075517F0CD6D007C2BD6 /* FutureSourceTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A15706EF17F0CD6D007C2BD6 /* FutureSourceTest.m */; };
-		A157075617F0CD6D007C2BD6 /* ObservableTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A15706F117F0CD6D007C2BD6 /* ObservableTest.m */; };
 		A157075717F0CD6D007C2BD6 /* AudioFrameTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A15706F417F0CD6D007C2BD6 /* AudioFrameTest.m */; };
 		A157075817F0CD6D007C2BD6 /* AudioRemoteIOTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A15706F617F0CD6D007C2BD6 /* AudioRemoteIOTest.m */; };
 		A157075917F0CD6D007C2BD6 /* AudioStretcherTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A15706F817F0CD6D007C2BD6 /* AudioStretcherTest.m */; };
@@ -358,7 +341,6 @@
 		A157077217F0CD6D007C2BD6 /* EventWindowTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A157073817F0CD6D007C2BD6 /* EventWindowTest.m */; };
 		A157077417F0CD6D007C2BD6 /* TestUtil.m in Sources */ = {isa = PBXBuildFile; fileRef = A157073C17F0CD6D007C2BD6 /* TestUtil.m */; };
 		A157077517F0CD6D007C2BD6 /* BloomFilterTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A157073F17F0CD6D007C2BD6 /* BloomFilterTest.m */; };
-		A157077617F0CD6D007C2BD6 /* CancelTokenTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A157074117F0CD6D007C2BD6 /* CancelTokenTest.m */; };
 		A157077717F0CD6D007C2BD6 /* ConversionsTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A157074317F0CD6D007C2BD6 /* ConversionsTest.m */; };
 		A157077817F0CD6D007C2BD6 /* Crc32Test.m in Sources */ = {isa = PBXBuildFile; fileRef = A157074517F0CD6D007C2BD6 /* Crc32Test.m */; };
 		A157077917F0CD6D007C2BD6 /* CryptoToolsTest.m in Sources */ = {isa = PBXBuildFile; fileRef = A157074717F0CD6D007C2BD6 /* CryptoToolsTest.m */; };
@@ -450,6 +432,8 @@
 		B9EB5AC61884D370007CBB57 /* UnseenWhisperUserCell.m in Sources */ = {isa = PBXBuildFile; fileRef = B9EB5AC51884D370007CBB57 /* UnseenWhisperUserCell.m */; };
 		B9EB5AC71884D370007CBB57 /* UnseenWhisperUserCell.m in Sources */ = {isa = PBXBuildFile; fileRef = B9EB5AC51884D370007CBB57 /* UnseenWhisperUserCell.m */; };
 		B9EB5ACA1884D387007CBB57 /* UnseenWhisperUserCell.xib in Resources */ = {isa = PBXBuildFile; fileRef = B9EB5AC81884D387007CBB57 /* UnseenWhisperUserCell.xib */; };
+		BFB074C119A4BCA400F2947C /* FutureUtilTest.m in Sources */ = {isa = PBXBuildFile; fileRef = BFB074BF19A4BCA400F2947C /* FutureUtilTest.m */; };
+		BFB074C219A4BCA400F2947C /* ObservableTest.m in Sources */ = {isa = PBXBuildFile; fileRef = BFB074C019A4BCA400F2947C /* ObservableTest.m */; };
 		D202868116DBE0E7009068E9 /* CFNetwork.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D2AEACDB16C426DA00C364C0 /* CFNetwork.framework */; };
 		D202868216DBE0F4009068E9 /* SystemConfiguration.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D2179CFD16BB0B480006F3AB /* SystemConfiguration.framework */; };
 		D202868316DBE0FC009068E9 /* CoreTelephony.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D2179CFB16BB0B3A0006F3AB /* CoreTelephony.framework */; };
@@ -659,27 +643,6 @@
 			remoteGlobalIDString = A1FDCBF916DBC57D00868894;
 			remoteInfo = speex;
 		};
-		B6913FF419773C5000AE2BF5 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = D221A080169C9E5E00537ABF /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = D221A088169C9E5E00537ABF;
-			remoteInfo = Signal;
-		};
-		B6913FF619773C5100AE2BF5 /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = D221A080169C9E5E00537ABF /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = D221A088169C9E5E00537ABF;
-			remoteInfo = Signal;
-		};
-		D221A0AF169C9E5F00537ABF /* PBXContainerItemProxy */ = {
-			isa = PBXContainerItemProxy;
-			containerPortal = D221A080169C9E5E00537ABF /* Project object */;
-			proxyType = 1;
-			remoteGlobalIDString = D221A088169C9E5E00537ABF;
-			remoteInfo = RedPhone;
-		};
 /* End PBXContainerItemProxy section */
 
 /* Begin PBXFileReference section */
@@ -767,25 +730,10 @@
 		76D713E9182D3E5100C9C9C8 /* PreferenceListTableViewCell.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; name = PreferenceListTableViewCell.xib; path = ../PreferenceListTableViewCell.xib; sourceTree = "<group>"; };
 		76EB03C218170B33006006FC /* AppDelegate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AppDelegate.h; sourceTree = "<group>"; };
 		76EB03C318170B33006006FC /* AppDelegate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AppDelegate.m; sourceTree = "<group>"; };
-		76EB03C518170B33006006FC /* AsyncUtil.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AsyncUtil.h; sourceTree = "<group>"; };
-		76EB03C618170B33006006FC /* AsyncUtil.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AsyncUtil.m; sourceTree = "<group>"; };
-		76EB03C718170B33006006FC /* AsyncUtilHelperRacingOperation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AsyncUtilHelperRacingOperation.h; sourceTree = "<group>"; };
-		76EB03C818170B33006006FC /* AsyncUtilHelperRacingOperation.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AsyncUtilHelperRacingOperation.m; sourceTree = "<group>"; };
-		76EB03C918170B33006006FC /* CancelledToken.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CancelledToken.h; sourceTree = "<group>"; };
-		76EB03CA18170B33006006FC /* CancelledToken.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CancelledToken.m; sourceTree = "<group>"; };
-		76EB03CB18170B33006006FC /* CancelTokenSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CancelTokenSource.h; sourceTree = "<group>"; };
-		76EB03CC18170B33006006FC /* CancelTokenSource.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CancelTokenSource.m; sourceTree = "<group>"; };
-		76EB03CD18170B33006006FC /* Future.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Future.h; sourceTree = "<group>"; };
-		76EB03CE18170B33006006FC /* Future.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Future.m; sourceTree = "<group>"; };
-		76EB03CF18170B33006006FC /* FutureSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FutureSource.h; sourceTree = "<group>"; };
-		76EB03D018170B33006006FC /* FutureSource.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = FutureSource.m; sourceTree = "<group>"; };
 		76EB03D118170B33006006FC /* FutureUtil.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FutureUtil.h; sourceTree = "<group>"; };
 		76EB03D218170B33006006FC /* FutureUtil.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = FutureUtil.m; sourceTree = "<group>"; };
 		76EB03D318170B33006006FC /* ObservableValue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ObservableValue.h; sourceTree = "<group>"; };
 		76EB03D418170B33006006FC /* ObservableValue.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ObservableValue.m; sourceTree = "<group>"; };
-		76EB03D618170B33006006FC /* CancelToken.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CancelToken.h; sourceTree = "<group>"; };
-		76EB03D718170B33006006FC /* TimeoutFailure.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TimeoutFailure.h; sourceTree = "<group>"; };
-		76EB03D818170B33006006FC /* TimeoutFailure.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TimeoutFailure.m; sourceTree = "<group>"; };
 		76EB03FF18170B33006006FC /* RecentCall.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RecentCall.h; sourceTree = "<group>"; };
 		76EB040018170B33006006FC /* RecentCall.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = RecentCall.m; sourceTree = "<group>"; };
 		76EB040118170B33006006FC /* RecentCallManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RecentCallManager.h; sourceTree = "<group>"; };
@@ -1048,9 +996,6 @@
 		76EB053F18170B33006006FC /* CallLogTableViewCell.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; path = CallLogTableViewCell.xib; sourceTree = "<group>"; };
 		8313AE91B4954215858A5662 /* libPods.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libPods.a; sourceTree = BUILT_PRODUCTS_DIR; };
 		A11CD70C17FA230600A2D1B1 /* QuartzCore.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QuartzCore.framework; path = System/Library/Frameworks/QuartzCore.framework; sourceTree = SDKROOT; };
-		A15706ED17F0CD6D007C2BD6 /* AsyncUtilTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AsyncUtilTest.m; sourceTree = "<group>"; };
-		A15706EF17F0CD6D007C2BD6 /* FutureSourceTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = FutureSourceTest.m; sourceTree = "<group>"; };
-		A15706F117F0CD6D007C2BD6 /* ObservableTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ObservableTest.m; sourceTree = "<group>"; };
 		A15706F417F0CD6D007C2BD6 /* AudioFrameTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AudioFrameTest.m; sourceTree = "<group>"; };
 		A15706F617F0CD6D007C2BD6 /* AudioRemoteIOTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AudioRemoteIOTest.m; sourceTree = "<group>"; };
 		A15706F817F0CD6D007C2BD6 /* AudioStretcherTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AudioStretcherTest.m; sourceTree = "<group>"; };
@@ -1084,8 +1029,6 @@
 		A157073C17F0CD6D007C2BD6 /* TestUtil.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TestUtil.m; sourceTree = "<group>"; };
 		A157073E17F0CD6D007C2BD6 /* BloomFilterTest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BloomFilterTest.h; sourceTree = "<group>"; };
 		A157073F17F0CD6D007C2BD6 /* BloomFilterTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = BloomFilterTest.m; sourceTree = "<group>"; };
-		A157074017F0CD6D007C2BD6 /* CancelTokenTest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CancelTokenTest.h; sourceTree = "<group>"; };
-		A157074117F0CD6D007C2BD6 /* CancelTokenTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = CancelTokenTest.m; sourceTree = "<group>"; };
 		A157074217F0CD6D007C2BD6 /* ConversionsTest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConversionsTest.h; sourceTree = "<group>"; };
 		A157074317F0CD6D007C2BD6 /* ConversionsTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ConversionsTest.m; sourceTree = "<group>"; };
 		A157074417F0CD6D007C2BD6 /* Crc32Test.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Crc32Test.h; sourceTree = "<group>"; };
@@ -1187,6 +1130,8 @@
 		B9EB5AC41884D370007CBB57 /* UnseenWhisperUserCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UnseenWhisperUserCell.h; sourceTree = "<group>"; };
 		B9EB5AC51884D370007CBB57 /* UnseenWhisperUserCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = UnseenWhisperUserCell.m; sourceTree = "<group>"; };
 		B9EB5AC81884D387007CBB57 /* UnseenWhisperUserCell.xib */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.xib; path = UnseenWhisperUserCell.xib; sourceTree = "<group>"; };
+		BFB074BF19A4BCA400F2947C /* FutureUtilTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = FutureUtilTest.m; sourceTree = "<group>"; };
+		BFB074C019A4BCA400F2947C /* ObservableTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ObservableTest.m; sourceTree = "<group>"; };
 		C71793B33D9C45079F74487E /* Pods.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = Pods.xcconfig; path = Pods/Pods.xcconfig; sourceTree = "<group>"; };
 		D2179CFB16BB0B3A0006F3AB /* CoreTelephony.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreTelephony.framework; path = System/Library/Frameworks/CoreTelephony.framework; sourceTree = SDKROOT; };
 		D2179CFD16BB0B480006F3AB /* SystemConfiguration.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = SystemConfiguration.framework; path = System/Library/Frameworks/SystemConfiguration.framework; sourceTree = SDKROOT; };
@@ -1646,37 +1591,14 @@
 		76EB03C418170B33006006FC /* async */ = {
 			isa = PBXGroup;
 			children = (
-				76EB03C518170B33006006FC /* AsyncUtil.h */,
-				76EB03C618170B33006006FC /* AsyncUtil.m */,
-				76EB03C718170B33006006FC /* AsyncUtilHelperRacingOperation.h */,
-				76EB03C818170B33006006FC /* AsyncUtilHelperRacingOperation.m */,
-				76EB03C918170B33006006FC /* CancelledToken.h */,
-				76EB03CA18170B33006006FC /* CancelledToken.m */,
-				76EB03CB18170B33006006FC /* CancelTokenSource.h */,
-				76EB03CC18170B33006006FC /* CancelTokenSource.m */,
-				76EB03CD18170B33006006FC /* Future.h */,
-				76EB03CE18170B33006006FC /* Future.m */,
-				76EB03CF18170B33006006FC /* FutureSource.h */,
-				76EB03D018170B33006006FC /* FutureSource.m */,
 				76EB03D118170B33006006FC /* FutureUtil.h */,
 				76EB03D218170B33006006FC /* FutureUtil.m */,
 				76EB03D318170B33006006FC /* ObservableValue.h */,
 				76EB03D418170B33006006FC /* ObservableValue.m */,
-				76EB03D518170B33006006FC /* protocols */,
-				76EB03D718170B33006006FC /* TimeoutFailure.h */,
-				76EB03D818170B33006006FC /* TimeoutFailure.m */,
 			);
 			path = async;
 			sourceTree = "<group>";
 		};
-		76EB03D518170B33006006FC /* protocols */ = {
-			isa = PBXGroup;
-			children = (
-				76EB03D618170B33006006FC /* CancelToken.h */,
-			);
-			path = protocols;
-			sourceTree = "<group>";
-		};
 		76EB03D918170B33006006FC /* audio */ = {
 			isa = PBXGroup;
 			children = (
@@ -2269,7 +2191,6 @@
 			isa = PBXGroup;
 			children = (
 				76919BF51805D169008C664A /* contact */,
-				A15706EB17F0CD6D007C2BD6 /* async */,
 				A15706F217F0CD6D007C2BD6 /* audio */,
 				A157070017F0CD6D007C2BD6 /* network */,
 				A157072E17F0CD6D007C2BD6 /* phone */,
@@ -2282,16 +2203,6 @@
 			path = test;
 			sourceTree = "<group>";
 		};
-		A15706EB17F0CD6D007C2BD6 /* async */ = {
-			isa = PBXGroup;
-			children = (
-				A15706ED17F0CD6D007C2BD6 /* AsyncUtilTest.m */,
-				A15706EF17F0CD6D007C2BD6 /* FutureSourceTest.m */,
-				A15706F117F0CD6D007C2BD6 /* ObservableTest.m */,
-			);
-			path = async;
-			sourceTree = "<group>";
-		};
 		A15706F217F0CD6D007C2BD6 /* audio */ = {
 			isa = PBXGroup;
 			children = (
@@ -2443,8 +2354,6 @@
 			children = (
 				A157073E17F0CD6D007C2BD6 /* BloomFilterTest.h */,
 				A157073F17F0CD6D007C2BD6 /* BloomFilterTest.m */,
-				A157074017F0CD6D007C2BD6 /* CancelTokenTest.h */,
-				A157074117F0CD6D007C2BD6 /* CancelTokenTest.m */,
 				A157074217F0CD6D007C2BD6 /* ConversionsTest.h */,
 				A157074317F0CD6D007C2BD6 /* ConversionsTest.m */,
 				A157074417F0CD6D007C2BD6 /* Crc32Test.h */,
@@ -2456,6 +2365,8 @@
 				A157074B17F0CD6D007C2BD6 /* ExceptionsTest.m */,
 				A157074C17F0CD6D007C2BD6 /* FunctionalUtilTest.h */,
 				A157074D17F0CD6D007C2BD6 /* FunctionalUtilTest.m */,
+				BFB074BF19A4BCA400F2947C /* FutureUtilTest.m */,
+				BFB074C019A4BCA400F2947C /* ObservableTest.m */,
 				A157074E17F0CD6D007C2BD6 /* PriorityQueueTest.h */,
 				A157074F17F0CD6D007C2BD6 /* PriorityQueueTest.m */,
 				A157075017F0CD6D007C2BD6 /* QueueTest.h */,
@@ -3079,9 +2990,6 @@
 			buildRules = (
 			);
 			dependencies = (
-				D221A0B0169C9E5F00537ABF /* PBXTargetDependency */,
-				B6913FF519773C5000AE2BF5 /* PBXTargetDependency */,
-				B6913FF719773C5100AE2BF5 /* PBXTargetDependency */,
 			);
 			name = SignalTests;
 			productName = RedPhoneTests;
@@ -3518,7 +3426,6 @@
 				76EB061A18170B33006006FC /* DiscardingLog.m in Sources */,
 				76EB068418170B34006006FC /* ContactDetailTableViewCell.m in Sources */,
 				76EB066218170B34006006FC /* SettingsViewController.m in Sources */,
-				76EB054818170B33006006FC /* CancelTokenSource.m in Sources */,
 				76EB05AC18170B33006006FC /* SrtpSocket.m in Sources */,
 				B60C16651988999D00E97A6C /* VersionMigrations.m in Sources */,
 				76EB062A18170B33006006FC /* BadState.m in Sources */,
@@ -3587,8 +3494,6 @@
 				E197B61E18BBEC6D00F073E5 /* AudioRouter.m in Sources */,
 				E197B60D18BBEC1A00F073E5 /* AudioSocket.m in Sources */,
 				76EB061418170B33006006FC /* AnonymousConditionLogger.m in Sources */,
-				76EB054218170B33006006FC /* AsyncUtil.m in Sources */,
-				76EB054A18170B33006006FC /* Future.m in Sources */,
 				76EB05C018170B33006006FC /* DhPacket.m in Sources */,
 				765052A1182945EF008313E1 /* LocalizableCustomFontLabel.m in Sources */,
 				7038632818F70C0700D4A43F /* EvpSymetricUtil.m in Sources */,
@@ -3599,7 +3504,6 @@
 				B9A578B1183D60EE00C17105 /* FavouriteTableViewCell.m in Sources */,
 				76EB057618170B33006006FC /* Contact.m in Sources */,
 				70B80111190C55660042E3F0 /* ExtendableMessage.m in Sources */,
-				76EB054618170B33006006FC /* CancelledToken.m in Sources */,
 				E197B61118BBEC1A00F073E5 /* AudioProcessor.m in Sources */,
 				76EB065818170B34006006FC /* LeftSideMenuViewController.m in Sources */,
 				76EB05EA18170B33006006FC /* CallProgress.m in Sources */,
@@ -3630,7 +3534,6 @@
 				76EB061C18170B33006006FC /* ArrayUtil.m in Sources */,
 				76EB05C418170B33006006FC /* HandshakePacket.m in Sources */,
 				76EB05AA18170B33006006FC /* SequenceCounter.m in Sources */,
-				76EB055218170B33006006FC /* TimeoutFailure.m in Sources */,
 				7038632718F70C0700D4A43F /* CryptoTools.m in Sources */,
 				76EB058C18170B33006006FC /* DnsManager.m in Sources */,
 				76EB059018170B33006006FC /* IgnoredPacketFailure.m in Sources */,
@@ -3656,7 +3559,6 @@
 				E197B62118BBF12700F073E5 /* AppAudioManager.m in Sources */,
 				76EB068C18170B34006006FC /* InboxFeedTableViewCell.m in Sources */,
 				76EB062018170B33006006FC /* BloomFilter.m in Sources */,
-				76EB054C18170B33006006FC /* FutureSource.m in Sources */,
 				76EB063818170B33006006FC /* DictionaryUtil.m in Sources */,
 				B9B89C54185A2B5F00A24465 /* LeftSideMenuCell.m in Sources */,
 				76EB068E18170B34006006FC /* CallLogTableViewCell.m in Sources */,
@@ -3672,7 +3574,6 @@
 				76EB05C818170B33006006FC /* HelloPacket.m in Sources */,
 				76EB059A18170B33006006FC /* HttpRequestUtil.m in Sources */,
 				76EB057218170B33006006FC /* RecentCall.m in Sources */,
-				76EB054418170B33006006FC /* AsyncUtilHelperRacingOperation.m in Sources */,
 				76EB060418170B33006006FC /* PhoneNumberDirectoryFilter.m in Sources */,
 				B97CBFA818860EA3008E0DE9 /* CountryCodeViewController.m in Sources */,
 				B6B1013C196D213F007E3930 /* SGNKeychainUtil.m in Sources */,
@@ -3719,7 +3620,6 @@
 				76EB05BD18170B33006006FC /* ConfirmAckPacket.m in Sources */,
 				76EB05DB18170B33006006FC /* LowLatencyConnector.m in Sources */,
 				76EB060F18170B33006006FC /* DecayingSampleEstimator.m in Sources */,
-				76EB055318170B33006006FC /* TimeoutFailure.m in Sources */,
 				76EB057718170B33006006FC /* Contact.m in Sources */,
 				B9EB5AC71884D370007CBB57 /* UnseenWhisperUserCell.m in Sources */,
 				76EB05FB18170B33006006FC /* CallConnectUtil_Responder.m in Sources */,
@@ -3732,15 +3632,12 @@
 				B9B89C55185A2B5F00A24465 /* LeftSideMenuCell.m in Sources */,
 				76EB05FD18170B33006006FC /* CallConnectUtil_Server.m in Sources */,
 				76EB058B18170B33006006FC /* Release.m in Sources */,
-				A157075417F0CD6D007C2BD6 /* AsyncUtilTest.m in Sources */,
-				A157075517F0CD6D007C2BD6 /* FutureSourceTest.m in Sources */,
 				76D713E8182D3E3F00C9C9C8 /* PreferenceListTableViewCell.m in Sources */,
 				76EB05D318170B33006006FC /* ZrtpInitiator.m in Sources */,
 				B9A578B2183D60EE00C17105 /* FavouriteTableViewCell.m in Sources */,
 				76EB061518170B33006006FC /* AnonymousConditionLogger.m in Sources */,
 				76EB060718170B33006006FC /* PhoneNumberDirectoryFilterManager.m in Sources */,
 				76EB05A118170B33006006FC /* IpAddress.m in Sources */,
-				A157075617F0CD6D007C2BD6 /* ObservableTest.m in Sources */,
 				762D9DD018281C7400A5E418 /* SettingsTableHeaderView.m in Sources */,
 				76EB05CD18170B33006006FC /* ShortAuthenticationStringGenerator.m in Sources */,
 				76EB05B718170B33006006FC /* MasterSecret.m in Sources */,
@@ -3749,7 +3646,6 @@
 				A157075717F0CD6D007C2BD6 /* AudioFrameTest.m in Sources */,
 				76EB063F18170B33006006FC /* Operation.m in Sources */,
 				76EB05AB18170B33006006FC /* SequenceCounter.m in Sources */,
-				76EB054B18170B33006006FC /* Future.m in Sources */,
 				76EB061D18170B33006006FC /* ArrayUtil.m in Sources */,
 				76EB064D18170B34006006FC /* ContactBrowseViewController.m in Sources */,
 				76EB05E318170B33006006FC /* SecureEndPoint.m in Sources */,
@@ -3773,11 +3669,11 @@
 				76EB05D118170B33006006FC /* ZrtpHandshakeSocket.m in Sources */,
 				A157075F17F0CD6D007C2BD6 /* IpAddressTest.m in Sources */,
 				76EB05F518170B33006006FC /* CallConnectResult.m in Sources */,
+				BFB074C219A4BCA400F2947C /* ObservableTest.m in Sources */,
 				A157076017F0CD6D007C2BD6 /* IpEndPointTest.m in Sources */,
 				765052A2182945EF008313E1 /* LocalizableCustomFontLabel.m in Sources */,
 				A157076117F0CD6D007C2BD6 /* RtpPacketTests.m in Sources */,
 				76EB05C518170B33006006FC /* HandshakePacket.m in Sources */,
-				76EB054D18170B33006006FC /* FutureSource.m in Sources */,
 				76EB058F18170B33006006FC /* HostNameEndPoint.m in Sources */,
 				76EB062118170B33006006FC /* BloomFilter.m in Sources */,
 				76EB064518170B33006006FC /* ThreadManager.m in Sources */,
@@ -3787,7 +3683,6 @@
 				A157076317F0CD6D007C2BD6 /* SequenceCounterTest.m in Sources */,
 				76EB062318170B33006006FC /* CyclicalBuffer.m in Sources */,
 				A157076517F0CD6D007C2BD6 /* HandshakePacketTest.m in Sources */,
-				76EB054918170B33006006FC /* CancelTokenSource.m in Sources */,
 				76EB066518170B34006006FC /* TabBarParentViewController.m in Sources */,
 				A157076617F0CD6D007C2BD6 /* HashChainTest.m in Sources */,
 				76EB063118170B33006006FC /* Conversions.m in Sources */,
@@ -3796,7 +3691,6 @@
 				76EB059B18170B33006006FC /* HttpRequestUtil.m in Sources */,
 				76EB05CF18170B33006006FC /* ZrtpHandshakeResult.m in Sources */,
 				76EB060518170B33006006FC /* PhoneNumberDirectoryFilter.m in Sources */,
-				76EB054718170B33006006FC /* CancelledToken.m in Sources */,
 				76EB065D18170B34006006FC /* CallLogViewController.m in Sources */,
 				A157076817F0CD6D007C2BD6 /* ShortAuthenticationStringGeneratorTest.m in Sources */,
 				76EB065718170B34006006FC /* InCallViewController.m in Sources */,
@@ -3808,7 +3702,6 @@
 				76EB05F118170B33006006FC /* PhoneManager.m in Sources */,
 				76EB05F718170B33006006FC /* CallConnectUtil.m in Sources */,
 				76EB066318170B34006006FC /* SettingsViewController.m in Sources */,
-				76EB054518170B33006006FC /* AsyncUtilHelperRacingOperation.m in Sources */,
 				76EB063318170B33006006FC /* Crc32.m in Sources */,
 				76EB054F18170B33006006FC /* FutureUtil.m in Sources */,
 				76EB062718170B33006006FC /* Queue.m in Sources */,
@@ -3836,7 +3729,6 @@
 				A157077517F0CD6D007C2BD6 /* BloomFilterTest.m in Sources */,
 				76EB05E918170B33006006FC /* CallFailedServerMessage.m in Sources */,
 				76EB058718170B33006006FC /* PreferencesUtil.m in Sources */,
-				A157077617F0CD6D007C2BD6 /* CancelTokenTest.m in Sources */,
 				76EB064118170B33006006FC /* AnonymousTerminator.m in Sources */,
 				A157077717F0CD6D007C2BD6 /* ConversionsTest.m in Sources */,
 				76EB058318170B33006006FC /* Environment.m in Sources */,
@@ -3849,6 +3741,7 @@
 				A157077917F0CD6D007C2BD6 /* CryptoToolsTest.m in Sources */,
 				76EB066118170B34006006FC /* RegisterViewController.m in Sources */,
 				76EB068D18170B34006006FC /* InboxFeedTableViewCell.m in Sources */,
+				BFB074C119A4BCA400F2947C /* FutureUtilTest.m in Sources */,
 				76EB05A918170B33006006FC /* RtpSocket.m in Sources */,
 				765052B0182AC9B5008313E1 /* DialerButtonView.m in Sources */,
 				76EB062B18170B33006006FC /* BadState.m in Sources */,
@@ -3874,7 +3767,6 @@
 				76EB057318170B33006006FC /* RecentCall.m in Sources */,
 				76EB058518170B33006006FC /* LocalizableText.m in Sources */,
 				76EB061918170B33006006FC /* AnonymousValueLogger.m in Sources */,
-				76EB054318170B33006006FC /* AsyncUtil.m in Sources */,
 				B942EB0F183A9633000887BB /* SearchBarTitleView.m in Sources */,
 				76EB058918170B33006006FC /* PropertyListPreferences.m in Sources */,
 				76EB063D18170B33006006FC /* NumberUtil.m in Sources */,
@@ -3907,21 +3799,6 @@
 			name = speex;
 			targetProxy = 70B800AD190C54870042E3F0 /* PBXContainerItemProxy */;
 		};
-		B6913FF519773C5000AE2BF5 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = D221A088169C9E5E00537ABF /* Signal */;
-			targetProxy = B6913FF419773C5000AE2BF5 /* PBXContainerItemProxy */;
-		};
-		B6913FF719773C5100AE2BF5 /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = D221A088169C9E5E00537ABF /* Signal */;
-			targetProxy = B6913FF619773C5100AE2BF5 /* PBXContainerItemProxy */;
-		};
-		D221A0B0169C9E5F00537ABF /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = D221A088169C9E5E00537ABF /* Signal */;
-			targetProxy = D221A0AF169C9E5F00537ABF /* PBXContainerItemProxy */;
-		};
 /* End PBXTargetDependency section */
 
 /* Begin PBXVariantGroup section */
diff --git a/Signal.xcodeproj/xcshareddata/xcschemes/Signal.xcscheme b/Signal.xcodeproj/xcshareddata/xcschemes/Signal.xcscheme
index 81ff2345178..66b6d11049f 100644
--- a/Signal.xcodeproj/xcshareddata/xcschemes/Signal.xcscheme
+++ b/Signal.xcodeproj/xcshareddata/xcschemes/Signal.xcscheme
@@ -25,7 +25,7 @@
    <TestAction
       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
       selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
-      shouldUseLaunchSchemeArgsEnv = "YES"
+      shouldUseLaunchSchemeArgsEnv = "NO"
       buildConfiguration = "Debug">
       <Testables>
          <TestableReference
@@ -48,6 +48,13 @@
             ReferencedContainer = "container:Signal.xcodeproj">
          </BuildableReference>
       </MacroExpansion>
+      <EnvironmentVariables>
+         <EnvironmentVariable
+            key = "runningTests_dontStartApp"
+            value = "YES"
+            isEnabled = "YES">
+         </EnvironmentVariable>
+      </EnvironmentVariables>
    </TestAction>
    <LaunchAction
       selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
diff --git a/Signal/src/AppDelegate.h b/Signal/src/AppDelegate.h
index dd17a2be2a8..8561612f136 100644
--- a/Signal/src/AppDelegate.h
+++ b/Signal/src/AppDelegate.h
@@ -1,5 +1,4 @@
 #import <UIKit/UIKit.h>
-#import "FutureSource.h"
 
 @interface AppDelegate : UIResponder <UIApplicationDelegate> 
 
diff --git a/Signal/src/AppDelegate.m b/Signal/src/AppDelegate.m
index 6fa0a3899e0..d95b17e57d2 100644
--- a/Signal/src/AppDelegate.m
+++ b/Signal/src/AppDelegate.m
@@ -101,6 +101,12 @@ - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(
     BOOL loggingIsEnabled;
 
 #ifdef DEBUG
+    // Specified at Product -> Scheme -> Edit Scheme -> Test -> Arguments -> Environment to avoid things like
+    // the phone directory being looked up during tests.
+    if (getenv("runningTests_dontStartApp")) {
+        return YES;
+    }
+    
     loggingIsEnabled = TRUE;
     [DebugLogger.sharedInstance enableTTYLogging];
     
diff --git a/Signal/src/async/AsyncUtil.h b/Signal/src/async/AsyncUtil.h
deleted file mode 100644
index 576bf9d13fb..00000000000
--- a/Signal/src/async/AsyncUtil.h
+++ /dev/null
@@ -1,39 +0,0 @@
-#import <Foundation/Foundation.h>
-#import "Future.h"
-#import "CancelToken.h"
-#import "Terminable.h"
-#import "TimeoutFailure.h"
-
-/**
- *
- * A CancellableOperationStarter launches an operation when called.
- * The asynchronous result of the operation is returned as a Future.
- *
- * The operation should be cancelled when the token passed into the starter is cancelled.
- * If the operation has not completed, cancelling the token should fail the returned future right away.
- * If the operation has completed, cancelling the token should terminate the successful result.
- *
- **/
-typedef Future* (^CancellableOperationStarter)(id<CancelToken> untilCancelledToken);
-
-/**
- *
- * AsyncUtil contains utitility methods used for aggregating and otherwise dealing with asynchronous operations.
- *
- */
-@interface AsyncUtil : NSObject
-
-+(Future*) raceCancellableOperations:(NSArray*)cancellableOperationStarters
-                      untilCancelled:(id<CancelToken>)untilCancelledToken;
-
-+(Future*) raceCancellableOperation:(CancellableOperationStarter)operation
-                     againstTimeout:(NSTimeInterval)timeoutPeriod
-                     untilCancelled:(id<CancelToken>)untilCancelledToken;
-
-+(Future*) asyncTry:(CancellableOperationStarter)operation
-         upToNTimes:(NSUInteger)maxTryCount
-    withBaseTimeout:(NSTimeInterval)baseTimeout
-     andRetryFactor:(NSTimeInterval)timeoutRetryFactor
-     untilCancelled:(id<CancelToken>)untilCancelledToken;
-
-@end
diff --git a/Signal/src/async/AsyncUtil.m b/Signal/src/async/AsyncUtil.m
deleted file mode 100644
index 5dd9d4ec466..00000000000
--- a/Signal/src/async/AsyncUtil.m
+++ /dev/null
@@ -1,102 +0,0 @@
-#import "AsyncUtil.h"
-#import "Environment.h"
-#import "Constraints.h"
-#import "FutureSource.h"
-#import "FunctionalUtil.h"
-#import "CancelTokenSource.h"
-#import "TimeUtil.h"
-#import "FutureUtil.h"
-#import "ThreadManager.h"
-#import "AsyncUtilHelperRacingOperation.h"
-
-@implementation AsyncUtil
-
-+(Future*) raceCancellableOperations:(NSArray*)cancellableOperationStarters
-                      untilCancelled:(id<CancelToken>)untilCancelledToken {
-    
-    require(cancellableOperationStarters != nil);
-    if (cancellableOperationStarters.count == 0) return [Future failed:@[]];
-    
-    NSArray* racingOperations = [AsyncUtilHelperRacingOperation racingOperationsFromCancellableOperationStarters:cancellableOperationStarters
-                                                                                                  untilCancelled:untilCancelledToken];
-    
-    Future* futureWinner = [AsyncUtilHelperRacingOperation asyncWinnerFromRacingOperations:racingOperations];
-    
-    // cancel and terminate losers
-    [futureWinner thenDo:^(AsyncUtilHelperRacingOperation* winner) {
-        for (AsyncUtilHelperRacingOperation* contender in racingOperations) {
-            if (contender != winner) {
-                [contender cancelAndTerminate];
-            }
-        }
-    }];
-    
-    return [futureWinner then:^(AsyncUtilHelperRacingOperation* winner) {
-        return [winner futureResult];
-    }];
-}
-
-+(Future*) raceCancellableOperation:(CancellableOperationStarter)operation
-                     againstTimeout:(NSTimeInterval)timeoutPeriod
-                     untilCancelled:(id<CancelToken>)untilCancelledToken {
-    require(operation != nil);
-    require(timeoutPeriod >= 0);
-    
-    FutureSource* futureResultSource = [FutureSource new];
-    
-    AsyncUtilHelperRacingOperation* racer = [AsyncUtilHelperRacingOperation racingOperationFromCancellableOperationStarter:operation
-                                                                                                            untilCancelled:untilCancelledToken];
-    [[racer futureResult] finallyDo:^(Future *completed) {
-        [futureResultSource trySetResult:completed];
-    }];
-    
-    void(^tryFail)(id failure) = ^(id failure){
-        if ([futureResultSource trySetFailure:failure]) {
-            [racer cancelAndTerminate];
-        }
-    };
-    
-    [TimeUtil scheduleRun:^{ tryFail([TimeoutFailure new]); }
-               afterDelay:timeoutPeriod
-                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-          unlessCancelled:[futureResultSource completionAsCancelToken]];
-    
-    [untilCancelledToken whenCancelled:^{ tryFail(untilCancelledToken); }];
-    
-    return futureResultSource;
-}
-
-
-+(Future*) asyncTry:(CancellableOperationStarter)operation
-         upToNTimes:(NSUInteger)maxTryCount
-    withBaseTimeout:(NSTimeInterval)baseTimeout
-     andRetryFactor:(NSTimeInterval)timeoutRetryFactor
-     untilCancelled:(id<CancelToken>)untilCancelledToken {
-    
-    require(operation != nil);
-    require(maxTryCount >= 0);
-    require(baseTimeout >= 0);
-    require(timeoutRetryFactor >= 0);
-    
-    if (maxTryCount == 0) return [Future failed:[TimeoutFailure new]];
-    
-    Future* futureResult = [AsyncUtil raceCancellableOperation:operation
-                                                againstTimeout:baseTimeout
-                                                untilCancelled:untilCancelledToken];
-    
-    return [futureResult catch:^(id error) {
-        bool operationCancelled = untilCancelledToken.isAlreadyCancelled;
-        bool operationDidNotTimeout = ![error isKindOfClass:[TimeoutFailure class]];
-        if (operationCancelled || operationDidNotTimeout) {
-            return [Future failed:error];
-        }
-        
-        return [self asyncTry:operation
-                   upToNTimes:maxTryCount - 1
-              withBaseTimeout:baseTimeout * timeoutRetryFactor
-               andRetryFactor:timeoutRetryFactor
-               untilCancelled:untilCancelledToken];
-    }];
-}
-
-@end
diff --git a/Signal/src/async/AsyncUtilHelperRacingOperation.h b/Signal/src/async/AsyncUtilHelperRacingOperation.h
deleted file mode 100644
index 059864f9190..00000000000
--- a/Signal/src/async/AsyncUtilHelperRacingOperation.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#import <Foundation/Foundation.h>
-#import "Future.h"
-#import "CancelTokenSource.h"
-#import "AsyncUtil.h"
-
-@interface AsyncUtilHelperRacingOperation : NSObject
-
-@property (readonly,nonatomic) Future* futureResult;
-@property (readonly,nonatomic) CancelTokenSource* cancelSource;
-
-+(AsyncUtilHelperRacingOperation*) racingOperationFromCancellableOperationStarter:(CancellableOperationStarter)cancellableOperationStarter
-                                                                   untilCancelled:(id<CancelToken>)untilCancelledToken;
-
-+(NSArray*) racingOperationsFromCancellableOperationStarters:(NSArray*)cancellableOperationStarters
-                                              untilCancelled:(id<CancelToken>)untilCancelledToken;
-
-+(Future*) asyncWinnerFromRacingOperations:(NSArray*)racingOperations;
-
--(void) cancelAndTerminate;
-
-@end
diff --git a/Signal/src/async/AsyncUtilHelperRacingOperation.m b/Signal/src/async/AsyncUtilHelperRacingOperation.m
deleted file mode 100644
index 8670daf95ae..00000000000
--- a/Signal/src/async/AsyncUtilHelperRacingOperation.m
+++ /dev/null
@@ -1,76 +0,0 @@
-#import "AsyncUtilHelperRacingOperation.h"
-#import "FutureSource.h"
-#import "Util.h"
-
-@implementation AsyncUtilHelperRacingOperation
-
-@synthesize cancelSource, futureResult;
-
-+(AsyncUtilHelperRacingOperation *)racingOperationFromCancellableOperationStarter:(CancellableOperationStarter)cancellableOperationStarter
-                                                                   untilCancelled:(id<CancelToken>)untilCancelledToken {
-    require(cancellableOperationStarter != nil);
-    
-    AsyncUtilHelperRacingOperation* instance = [AsyncUtilHelperRacingOperation new];
-    
-    instance->cancelSource = [CancelTokenSource cancelTokenSource];
-    [untilCancelledToken whenCancelled:^{
-        [instance.cancelSource cancel];
-    }];
-    
-    @try {
-        instance->futureResult = cancellableOperationStarter([instance.cancelSource getToken]);
-    } @catch (OperationFailed* ex) {
-        instance->futureResult = [Future failed:ex];
-    }
-    
-    return instance;
-}
-
-+(NSArray*) racingOperationsFromCancellableOperationStarters:(NSArray*)cancellableOperationStarters
-                                              untilCancelled:(id<CancelToken>)untilCancelledToken {
-    return [cancellableOperationStarters map:^(CancellableOperationStarter cancellableOperationStarter) {
-        return [AsyncUtilHelperRacingOperation racingOperationFromCancellableOperationStarter:cancellableOperationStarter
-                                                                               untilCancelled:untilCancelledToken];
-    }];
-}
-
-+(Future*) asyncWinnerFromRacingOperations:(NSArray*)racingOperations {
-    require(racingOperations != nil);
-    
-    FutureSource* futureWinner = [FutureSource new];
-    
-    NSUInteger totalCount = racingOperations.count;
-    NSMutableArray* failures = [NSMutableArray array];
-    void(^failIfAllFailed)(id) = ^(id failure) {
-        @synchronized(failures) {
-            [failures addObject:failure];
-            if (failures.count < totalCount) return;
-        }
-        
-        [futureWinner trySetFailure:failures];
-    };
-    
-    for (AsyncUtilHelperRacingOperation* contender in racingOperations) {
-        Future* futureResult = [contender futureResult];
-        [futureResult thenDo:^(id result) {
-            [futureWinner trySetResult:contender];
-        }];
-        
-        [futureResult catchDo:failIfAllFailed];
-    }
-    
-    return futureWinner;
-}
-
--(void) cancelAndTerminate {
-    [cancelSource cancel];
-    
-    // in case cancellation is too late, terminate any eventual result
-    [futureResult thenDo:^(id result) {
-        if ([result conformsToProtocol:@protocol(Terminable)]) {
-            [result terminate];
-        }
-    }];
-}
-
-@end
diff --git a/Signal/src/async/CancelTokenSource.h b/Signal/src/async/CancelTokenSource.h
deleted file mode 100644
index cab5e721e94..00000000000
--- a/Signal/src/async/CancelTokenSource.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#import <Foundation/Foundation.h>
-#import "CancelToken.h"
-
-@class CancelTokenSourceToken;
-
-/**
- *
- * CancelTokenSource is used to create and manage cancel tokens.
- *
- */
-@interface CancelTokenSource : NSObject {
-@private CancelTokenSourceToken* token;
-}
-
-+(CancelTokenSource*) cancelTokenSource;
--(void) cancel;
--(id<CancelToken>) getToken;
-
-@end
diff --git a/Signal/src/async/CancelTokenSource.m b/Signal/src/async/CancelTokenSource.m
deleted file mode 100644
index 51ac0f12f93..00000000000
--- a/Signal/src/async/CancelTokenSource.m
+++ /dev/null
@@ -1,114 +0,0 @@
-#import "CancelTokenSource.h"
-#import "Constraints.h"
-#import "FutureSource.h"
-#import "Terminable.h"
-
-@interface CancelTokenSourceToken : NSObject<CancelToken> {
-@private NSMutableArray* callbacks;
-@private bool isImmortal;
-@private bool isCancelled;
-}
-
-+(CancelTokenSourceToken*) cancelTokenSourceToken;
--(void) cancel;
--(void) tryMakeImmortal;
-
-@end
-
-@implementation CancelTokenSource
-
-+(CancelTokenSource*) cancelTokenSource {
-    CancelTokenSource* c = [CancelTokenSource new];
-    c->token = [CancelTokenSourceToken cancelTokenSourceToken];
-    return c;
-}
-
--(void) cancel {
-    [token cancel];
-}
-
--(NSString*) description {
-    return [[self getToken] description];
-}
-
--(void) dealloc {
-    [token tryMakeImmortal];
-}
--(id<CancelToken>) getToken {
-    return token;
-}
-
-@end
-
-@implementation CancelTokenSourceToken
-
-+(CancelTokenSourceToken*) cancelTokenSourceToken {
-    CancelTokenSourceToken* c = [CancelTokenSourceToken new];
-    c->callbacks = [NSMutableArray array];
-    return c;
-}
-
--(void) whenCancelled:(void (^)())callback {
-    @synchronized(self) {
-        if (isImmortal) return;
-        if (!isCancelled) {
-            [callbacks addObject:[callback copy]];
-            return;
-        }
-    }
-    callback();
-}
--(void) whenCancelledTryCancel:(FutureSource*)futureSource {
-    require(futureSource != nil);
-    [self whenCancelled:^{
-        [futureSource trySetFailure:self];
-    }];
-}
--(void) whenCancelledTerminate:(id<Terminable>)terminable {
-    require(terminable != nil);
-    [self whenCancelled:^{
-        [terminable terminate];
-    }];
-}
-
--(void) cancel {
-    NSArray* callbacksToRun;
-    @synchronized(self) {
-        requireState(!isImmortal);
-        if (isCancelled) return;
-        isCancelled = true;
-        callbacksToRun = callbacks;
-        callbacks = nil;
-    }
-    for (void (^callback)() in callbacksToRun) {
-        callback();
-    }
-}
--(void) tryMakeImmortal {
-    @synchronized(self) {
-        if (isCancelled) return;
-        callbacks = nil;
-        isImmortal = true;
-    }
-}
--(bool) isAlreadyCancelled {
-    @synchronized(self) {
-        return isCancelled;
-    }
-}
-
--(NSString*) description {
-    if (self.isAlreadyCancelled) return @"Cancelled";
-    if (isImmortal) return @"Immortal";
-    return @"Not Cancelled Yet";
-}
--(Future*)asCancelledFuture {
-    FutureSource* result = [FutureSource new];
-    __unsafe_unretained id weakSelf = self;
-    [self whenCancelled:^{
-        [result trySetFailure:weakSelf];
-    }];
-    return result;
-}
-
-@end
diff --git a/Signal/src/async/CancelledToken.h b/Signal/src/async/CancelledToken.h
deleted file mode 100644
index 6018244607f..00000000000
--- a/Signal/src/async/CancelledToken.h
+++ /dev/null
@@ -1,11 +0,0 @@
-#import <Foundation/Foundation.h>
-#import "CancelToken.h"
-
-/**
- *
- * A cancel token that has already been cancelled.
- *
- */
-@interface CancelledToken : NSObject<CancelToken>
-+(CancelledToken*) cancelledToken;
-@end
diff --git a/Signal/src/async/CancelledToken.m b/Signal/src/async/CancelledToken.m
deleted file mode 100644
index 1591c9dc601..00000000000
--- a/Signal/src/async/CancelledToken.m
+++ /dev/null
@@ -1,29 +0,0 @@
-#import "CancelledToken.h"
-#import "FutureSource.h"
-#import "Util.h"
-
-@implementation CancelledToken
-
-+(CancelledToken*) cancelledToken {
-    return [CancelledToken new];
-}
--(bool) isAlreadyCancelled {
-    return true;
-}
--(void) whenCancelled:(void (^)())callback {
-    require(callback != nil);
-    callback();
-}
--(void) whenCancelledTryCancel:(FutureSource*)futureSource {
-    require(futureSource != nil);
-    [futureSource trySetFailure:self];
-}
--(void) whenCancelledTerminate:(id<Terminable>)terminable {
-    require(terminable != nil);
-    [terminable terminate];
-}
--(Future*)asCancelledFuture {
-    return [Future failed:self];
-}
-
-@end
diff --git a/Signal/src/async/Future.h b/Signal/src/async/Future.h
deleted file mode 100644
index 149eb1c32a5..00000000000
--- a/Signal/src/async/Future.h
+++ /dev/null
@@ -1,48 +0,0 @@
-#import <Foundation/Foundation.h>
-
-@protocol CancelToken;
-
-/**
- *
- * Future is used to represent asynchronous results that will eventually be available or fail.
- * 
- * If the future has already completed, the has/forceGet methods can be used to access it.
- * To register a callback to run on completion (or right away if completed), use the then/catch methods.
- *
- * Note that, whenever a future would have ended with a result that is itself a Future, it instead unwraps the result.
- * That is to say, the eventual result/failure of top-level future will be the same as the bottom-level future.
- * e.g. Future(Future(1)) == Future(1)
- *
- * You can get an already-completed future via the finished/failed static methods.
- * You can manage a manually-completed future via the FutureSource class.
- *
- */
-
-@interface Future : NSObject {
-    bool isWiredToComplete;
-    
-    bool hasResult;
-    id result;
-    
-    bool hasFailure;
-    id failure;
-    
-    NSMutableArray* callbacks;
-}
-
-+(Future*) finished:(id)result;
-+(Future*) failed:(id)value;
-+(Future*) delayed:(id)value untilAfter:(Future*)future;
-
--(void) finallyDo:(void(^)(Future* completed))callback;
-
--(bool) isIncomplete;
--(bool) hasSucceeded;
--(bool) hasFailed;
-
--(id) forceGetResult;
--(id) forceGetFailure;
-
--(id<CancelToken>) completionAsCancelToken;
-
-@end
diff --git a/Signal/src/async/Future.m b/Signal/src/async/Future.m
deleted file mode 100644
index 03239f4cda5..00000000000
--- a/Signal/src/async/Future.m
+++ /dev/null
@@ -1,77 +0,0 @@
-#import "Future.h"
-#import "FutureSource.h"
-#import "Util.h"
-#import "CancelTokenSource.h"
-
-@implementation Future
-
-+(Future*) finished:(id)value {
-    FutureSource* v = [FutureSource new];
-    [v trySetResult:value];
-    return v;
-}
-+(Future*) failed:(id)value {
-    DDLogVerbose(@"Future failed: %@", value);
-    FutureSource* v = [FutureSource new];
-    [v trySetFailure:value];
-    return v;
-}
-+(Future*) delayed:(id)value untilAfter:(Future*)future {
-    require(future != nil);
-    return [future then:^(id _) {
-        return value;
-    }];
-}
-
--(void) finallyDo:(void(^)(Future* completed))callback {
-    require(callback != nil);
-    @synchronized(self) {
-        if (self.isIncomplete) {
-            [callbacks addObject:[callback copy]];
-            return;
-        }
-    }
-    callback(self);
-}
-
--(bool) isIncomplete {
-    @synchronized(self) {
-        return callbacks != nil;
-    }
-}
-
--(bool) hasSucceeded {
-    @synchronized(self) {
-        return hasResult;
-    }
-}
-
--(bool) hasFailed {
-    @synchronized(self) {
-        return hasFailure;
-    }
-}
-
--(id) forceGetResult {
-    @synchronized(self) {
-        requireState(self.hasSucceeded);
-    }
-    return result;
-}
-
--(id) forceGetFailure {
-    @synchronized(self) {
-        requireState(self.hasFailed);
-    }
-    return failure;
-}
-
--(id<CancelToken>)completionAsCancelToken {
-    CancelTokenSource* cancelTokenSource = [CancelTokenSource cancelTokenSource];
-    [self finallyDo:^(Future*_) {
-        [cancelTokenSource cancel];
-    }];
-    return [cancelTokenSource getToken];
-}
-
-@end
diff --git a/Signal/src/async/FutureSource.h b/Signal/src/async/FutureSource.h
deleted file mode 100644
index b953975879a..00000000000
--- a/Signal/src/async/FutureSource.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#import <Foundation/Foundation.h>
-#import "Future.h"
-
-/**
- *
- * FutureSource is a future that can be manually completed/failed.
- *
- * You can cause the exposed future to complete via the trySet/Wire methods.
- *
- */
-
-@interface FutureSource : Future
-
-+(FutureSource*) finished:(id)value;
-+(FutureSource*) failed:(id)value;
-
--(bool) trySetResult:(id)finalResult;
--(bool) trySetFailure:(id)failure;
--(bool) isCompletedOrWiredToComplete;
-
-@end
diff --git a/Signal/src/async/FutureSource.m b/Signal/src/async/FutureSource.m
deleted file mode 100644
index 45536ce9a1e..00000000000
--- a/Signal/src/async/FutureSource.m
+++ /dev/null
@@ -1,103 +0,0 @@
-#import "FutureSource.h"
-#import "Constraints.h"
-#import "Util.h"
-
-@implementation FutureSource
-
-+(FutureSource*) finished:(id)value {
-    FutureSource* v = [FutureSource new];
-    [v trySetResult:value];
-    return v;
-}
-+(FutureSource*) failed:(id)value {
-    FutureSource* v = [FutureSource new];
-    [v trySetFailure:value];
-    return v;
-}
-
--(id) init {
-    if (self = [super init]) {
-        self->callbacks = [NSMutableArray array];
-    }
-    return self;
-}
-
--(bool) isCompletedOrWiredToComplete {
-    @synchronized(self) {
-        return callbacks == nil || isWiredToComplete;
-    }
-}
--(bool) canBeCompleted {
-    @synchronized(self) {
-        return callbacks != nil && !isWiredToComplete;
-    }
-}
-
--(bool) trySet:(id)value failed:(bool)failed isUnwiring:(bool)unwiring {
-    NSArray* oldCallbacks;
-    @synchronized(self) {
-        if (!unwiring && ![self canBeCompleted]) return false;
-        
-        oldCallbacks = callbacks;
-        callbacks = nil;
-        hasResult = !failed;
-        hasFailure = failed;
-        isWiredToComplete = false;
-        result = hasResult ? value : nil;
-        failure = hasFailure ? value : nil;
-    }
-    
-    for (void (^callback)(Future* completed) in oldCallbacks) {
-        callback(self);
-    }
-    return true;
-}
--(bool) trySetResult:(id)value {
-    if ([value isKindOfClass:[Future class]]) {
-        return [self tryWireForFutureCompletion:value];
-    }
-    
-    return [self trySet:value
-                 failed:false
-             isUnwiring:false];
-}
--(bool) trySetFailure:(id)value {
-    require(![value isKindOfClass:[Future class]]);
-    return [self trySet:value
-                 failed:true
-             isUnwiring:false];
-}
-
--(bool) tryWireForFutureCompletion:(Future*)futureResult {
-    require(futureResult != nil);
-    
-    @synchronized(self) {
-        if (![self canBeCompleted]) return false;
-        isWiredToComplete = true;
-    }
-    
-    [futureResult finallyDo:^(Future* completed) {
-        if (completed.hasSucceeded) {
-            [self trySet:[completed forceGetResult]
-                  failed:false
-              isUnwiring:true];
-        } else {
-            [self trySet:[completed forceGetFailure]
-                  failed:true
-              isUnwiring:true];
-        }
-    }];
-    
-    return true;
-}
-
--(NSString*) description {
-    @synchronized(self) {
-        if (isWiredToComplete) return @"Incomplete Future [Wired to Complete]";
-        if (self.isIncomplete) return @"Incomplete Future";
-        if (self.hasSucceeded) return [NSString stringWithFormat:@"Completed: %@", result];
-        return [NSString stringWithFormat:@"Failed: %@", failure];
-    }
-}
-
-@end
diff --git a/Signal/src/async/FutureUtil.h b/Signal/src/async/FutureUtil.h
index 9b81281c82a..a9082214370 100644
--- a/Signal/src/async/FutureUtil.h
+++ b/Signal/src/async/FutureUtil.h
@@ -1,15 +1,58 @@
 #import <Foundation/Foundation.h>
-#import "Future.h"
+#import "CollapsingFutures.h"
+#import "Terminable.h"
 
-@interface Future (FutureUtil)
+@interface TOCCancelToken (FutureUtil)
 
--(void) thenDo:(void(^)(id result))callback;
--(void) catchDo:(void(^)(id error))catcher;
+-(void) whenCancelledTerminate:(id<Terminable>)terminable;
 
--(Future*) finally:(id(^)(Future* completed))callback;
--(Future*) then:(id(^)(id value))projection;
--(Future*) catch:(id(^)(id error))catcher;
+@end
+
+@interface TOCFuture (FutureUtil)
+
+/*!
+ * Wraps an asynchronous operation in a try-catch block, so it returns a failed future instead of propagating an exception.
+ */
++(TOCUntilOperation) operationTry:(TOCUntilOperation)operation;
+
+/*!
+ * Returns a future that completes after the receiving future completes, but replaces its result if it didn't fail.
+ */
+-(TOCFuture*) thenValue:(id)value;
+
+/*!
+ * A variant of `-finally` that wraps a try-catch statement around the continuation.
+ *
+ * @discussion Registers a continuation to run when the receiving future completes with a result or fails.
+ * Exposes the result of the continuation as a future.
+ * If the continuation throwns an exception, it is caught and the returned future will fail with the caught exception as its failure.
+ */
+-(TOCFuture*) finallyTry:(TOCFutureFinallyContinuation)callback;
+
+/*!
+ * A variant of `-then` that wraps a try-catch statement around the continuation.
+ *
+ * @discussion Registers a continuation to run when the receiving future completes with a result.
+ * Exposes the result of the continuation as a future.
+ * If the receiving future fails, the returned future is given the same failure and the continuation is not run.
+ * If the continuation throwns an exception, it is caught and the returned future will fail with the caught exception as its failure.
+ */
+-(TOCFuture*) thenTry:(TOCFutureThenContinuation) projection;
+
+/*!
+ * A variant of `-catch` that wraps a try-catch statement around the continuation.
+ *
+ * @discussion Registers a continuation to run when the receiving future fails.
+ * Exposes the result of the continuation as a future.
+ * If the receiving future completes with a result, the returned future is given the same result and the continuation is not run.
+ * If the continuation throwns an exception, it is caught and the returned future will fail with the caught exception as its failure.
+ */
+-(TOCFuture*) catchTry:(TOCFutureCatchContinuation)catcher;
 
--(Future*) thenCompleteOnMainThread;
++(TOCFuture*) retry:(TOCUntilOperation)operation
+         upToNTimes:(NSUInteger)maxTryCount
+    withBaseTimeout:(NSTimeInterval)baseTimeout
+     andRetryFactor:(NSTimeInterval)timeoutRetryFactor
+     untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 @end
diff --git a/Signal/src/async/FutureUtil.m b/Signal/src/async/FutureUtil.m
index 04f98316b83..cdb176a5681 100644
--- a/Signal/src/async/FutureUtil.m
+++ b/Signal/src/async/FutureUtil.m
@@ -1,75 +1,99 @@
-#import "FutureUtil.h"
-#import "FutureSource.h"
 #import "Constraints.h"
+#import "FutureUtil.h"
 #import "Operation.h"
 
-@implementation Future (FutureUtil)
+@implementation TOCCancelToken (FutureUtil)
 
--(void) thenDo:(void(^)(id result))callback {
-    require(callback != nil);
-    void(^callbackCopy)(id result) = [callback copy];
-    
-    [self finallyDo:^(Future* completed){
-        if (completed.hasSucceeded) {
-            callbackCopy([completed forceGetResult]);
+-(void) whenCancelledTerminate:(id<Terminable>)terminable {
+    require(terminable != nil);
+    [self whenCancelledDo:^{ [terminable terminate]; }];
+}
+
+@end
+
+@implementation TOCFuture (FutureUtil)
+
++(TOCUntilOperation) operationTry:(TOCUntilOperation)operation {
+    require(operation != nil);
+    return ^(TOCCancelToken* until) {
+        @try {
+            return operation(until);
+        } @catch (id ex) {
+            return [TOCFuture futureWithFailure:ex];
         }
-    }];
+    };
+}
+
+-(TOCFuture*) thenValue:(id)value {
+    return [self then:^(id _) { return value; }];
 }
--(void) catchDo:(void(^)(id error))catcher {
-    require(catcher != nil);
-    void(^callbackCopy)(id result) = [catcher copy];
+
+-(TOCFuture*) finallyTry:(TOCFutureFinallyContinuation)completionContinuation {
+    require(completionContinuation != nil);
     
-    [self finallyDo:^(Future* completed){
-        if (completed.hasFailed) {
-            callbackCopy([completed forceGetFailure]);
+    return [self finally:^id(TOCFuture* completed){
+        @try {
+            return completionContinuation(completed);
+        } @catch (id ex) {
+            return [TOCFuture futureWithFailure:ex];
         }
     }];
 }
 
--(Future*) finally:(id(^)(Future* completed))callback {
-    require(callback != nil);
-    id(^callbackCopy)(Future* completed) = [callback copy];
-    FutureSource* thenResult = [FutureSource new];
-    
-    [self finallyDo:^(Future* completed){
+-(TOCFuture*) thenTry:(TOCFutureThenContinuation)resultContinuation {
+    require(resultContinuation != nil);
+
+    return [self then:^id(id result){
         @try {
-            [thenResult trySetResult:callbackCopy(completed)];
+            return resultContinuation(result);
         } @catch (id ex) {
-            [thenResult trySetFailure:ex];
+            return [TOCFuture futureWithFailure:ex];
         }
     }];
-    
-    return thenResult;
 }
--(Future*) then:(id(^)(id value))projection {
-    require(projection != nil);
-    id(^callbackCopy)(id value) = [projection copy];
+
+-(TOCFuture*) catchTry:(TOCFutureCatchContinuation)failureContinuation {
+    require(failureContinuation != nil);
     
-    return [self finally:^id(Future* completed){
-        if (completed.hasFailed) return completed;
-        
-        return callbackCopy([completed forceGetResult]);
+    return [self catch:^id(id failure){
+        @try {
+            return failureContinuation(failure);
+        } @catch (id ex) {
+            return [TOCFuture futureWithFailure:ex];
+        }
     }];
 }
--(Future*) catch:(id(^)(id error))catcher {
-    require(catcher != nil);
-    id(^callbackCopy)(id value) = [catcher copy];
+
++(TOCFuture*) retry:(TOCUntilOperation)operation
+         upToNTimes:(NSUInteger)maxTryCount
+    withBaseTimeout:(NSTimeInterval)baseTimeout
+     andRetryFactor:(NSTimeInterval)timeoutRetryFactor
+     untilCancelled:(TOCCancelToken*)untilCancelledToken {
+    
+    require(operation != nil);
+    require(maxTryCount >= 0);
+    require(baseTimeout >= 0);
+    require(timeoutRetryFactor >= 0);
+    
+    if (maxTryCount == 0) return TOCFuture.futureWithTimeoutFailure;
+    
+    TOCFuture* futureResult = [TOCFuture futureFromUntilOperation:operation
+                                             withOperationTimeout:baseTimeout
+                                                            until:untilCancelledToken];
     
-    return [self finally:^id(Future* completed){
-        if (completed.hasSucceeded) return completed;
+    return [futureResult catchTry:^(id error) {
+        bool operationCancelled = untilCancelledToken.isAlreadyCancelled;
+        bool operationDidNotTimeout = !futureResult.hasFailedWithTimeout;
+        if (operationCancelled || operationDidNotTimeout) {
+            return [TOCFuture futureWithFailure:error];
+        }
         
-        return callbackCopy([completed forceGetFailure]);
-    }];
-}
-
--(Future*) thenCompleteOnMainThread {
-    FutureSource* onMainThreadResult = [FutureSource new];
-    [self finallyDo:^(Future *completed) {
-        [Operation asyncRun:^{
-            [onMainThreadResult trySetResult:completed];
-        } onThread:[NSThread mainThread]];
+        return [self retry:operation
+                upToNTimes:maxTryCount - 1
+           withBaseTimeout:baseTimeout * timeoutRetryFactor
+            andRetryFactor:timeoutRetryFactor
+            untilCancelled:untilCancelledToken];
     }];
-    return onMainThreadResult;
 }
 
 @end
diff --git a/Signal/src/async/ObservableValue.h b/Signal/src/async/ObservableValue.h
index ba09b0787b0..921d73739d6 100644
--- a/Signal/src/async/ObservableValue.h
+++ b/Signal/src/async/ObservableValue.h
@@ -1,5 +1,5 @@
 #import <Foundation/Foundation.h>
-#import "CancelToken.h"
+#import "CollapsingFutures.h"
 #import "Queue.h"
 
 typedef void (^LatestValueCallback)(id latestValue);
@@ -19,11 +19,11 @@ typedef void (^LatestValueCallback)(id latestValue);
 @property (readonly,atomic) id currentValue;
 
 -(void) watchLatestValueOnArbitraryThread:(LatestValueCallback)callback
-                           untilCancelled:(id<CancelToken>)untilCancelledToken;
+                           untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 -(void) watchLatestValue:(LatestValueCallback)callback
                 onThread:(NSThread*)thread
-          untilCancelled:(id<CancelToken>)untilCancelledToken;
+          untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 @end
 
diff --git a/Signal/src/async/ObservableValue.m b/Signal/src/async/ObservableValue.m
index f5a7e6d19d7..de2e191b618 100644
--- a/Signal/src/async/ObservableValue.m
+++ b/Signal/src/async/ObservableValue.m
@@ -14,7 +14,7 @@ -(ObservableValue*) initWithValue:(id)value {
 }
 
 -(void) watchLatestValueOnArbitraryThread:(LatestValueCallback)callback
-                           untilCancelled:(id<CancelToken>)untilCancelledToken {
+                           untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(callback != nil);
     if (untilCancelledToken.isAlreadyCancelled) return;
@@ -24,7 +24,7 @@ -(void) watchLatestValueOnArbitraryThread:(LatestValueCallback)callback
         callbackCopy(self.currentValue);
         [callbacks addObject:callbackCopy];
     }];
-    [untilCancelledToken whenCancelled:^{
+    [untilCancelledToken whenCancelledDo:^{
         [self queueRun:^{
             [callbacks removeObject:callbackCopy];
         }];
@@ -32,7 +32,7 @@ -(void) watchLatestValueOnArbitraryThread:(LatestValueCallback)callback
 }
 -(void) watchLatestValue:(LatestValueCallback)callback
                 onThread:(NSThread*)thread
-          untilCancelled:(id<CancelToken>)untilCancelledToken {
+          untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(callback != nil);
     require(thread != nil);
diff --git a/Signal/src/async/TimeoutFailure.h b/Signal/src/async/TimeoutFailure.h
deleted file mode 100644
index b8ccc4fad82..00000000000
--- a/Signal/src/async/TimeoutFailure.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#import <Foundation/Foundation.h>
-
-/**
- *
- * Instances of TimeoutFailure are used as the failure stored in Futures that fail due to a timeout.
- *
- */
-@interface TimeoutFailure : NSObject
-
-@end
diff --git a/Signal/src/async/TimeoutFailure.m b/Signal/src/async/TimeoutFailure.m
deleted file mode 100644
index 798f16c1ce6..00000000000
--- a/Signal/src/async/TimeoutFailure.m
+++ /dev/null
@@ -1,8 +0,0 @@
-#import "TimeoutFailure.h"
-
-@implementation TimeoutFailure
-
--(NSString *)description {
-    return @"Timeout";
-}
-@end
diff --git a/Signal/src/async/protocols/CancelToken.h b/Signal/src/async/protocols/CancelToken.h
deleted file mode 100644
index 72442d4344c..00000000000
--- a/Signal/src/async/protocols/CancelToken.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#import <Foundation/Foundation.h>
-
-@class Future;
-@class FutureSource;
-@protocol Terminable;
-
-/**
- *
- * CancelToken is used to cancel registered operations and terminate registered objects.
- *
- * A cancellable method should take a cancel token as an argument.
- * The method may initially check isAlreadyCancelled to see if it can quickly finish.
- * The method should use whenCancelled to register a callback to be run when the token is cancelled.
- * When the callback runs, the method should release all resources and stop any dependent operations.
- * If the method has a result of type Future, cancelling should transition the Future from incomplete to failed (with the cancel token as a value).
- *
- * A cancellable object works the same way: take a cancel token in the constructor, register for termination.
- *
- * Idioms:
- *   unlessCancelled:cancelToken  //operation will complete normally unless the token is cancelled BEFORE completion
- *    untilCancelled:cancelToken  //object or effect will last until the token is cancelled
- *
- */
-
-@protocol CancelToken <NSObject>
-
--(void) whenCancelled:(void(^)())callback;
--(void) whenCancelledTryCancel:(FutureSource*)futureSource;
--(void) whenCancelledTerminate:(id<Terminable>)terminable;
--(bool) isAlreadyCancelled;
--(Future*) asCancelledFuture;
-
-@end
diff --git a/Signal/src/audio/incall_audio/AudioSocket.h b/Signal/src/audio/incall_audio/AudioSocket.h
index c26c13c0f14..efd0a6b036b 100644
--- a/Signal/src/audio/incall_audio/AudioSocket.h
+++ b/Signal/src/audio/incall_audio/AudioSocket.h
@@ -14,7 +14,7 @@
 }
 
 +(AudioSocket*) audioSocketOver:(SrtpSocket*)srtpSocket;
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken;
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken;
 -(void) send:(EncodedAudioPacket*)audioPacket;
 
 @end
diff --git a/Signal/src/audio/incall_audio/AudioSocket.m b/Signal/src/audio/incall_audio/AudioSocket.m
index e634cff26a8..e8c4e964377 100644
--- a/Signal/src/audio/incall_audio/AudioSocket.m
+++ b/Signal/src/audio/incall_audio/AudioSocket.m
@@ -11,7 +11,7 @@ +(AudioSocket*) audioSocketOver:(SrtpSocket*)srtpSocket {
     return p;
 }
 
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken {
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(handler != nil);
     requireState(!started);
     started = true;
diff --git a/Signal/src/audio/incall_audio/CallAudioManager.h b/Signal/src/audio/incall_audio/CallAudioManager.h
index bdb08268848..28290bbb12a 100644
--- a/Signal/src/audio/incall_audio/CallAudioManager.h
+++ b/Signal/src/audio/incall_audio/CallAudioManager.h
@@ -23,6 +23,6 @@
 
 +(CallAudioManager*) callAudioManagerStartedWithAudioSocket:(AudioSocket*)audioSocket
                                             andErrorHandler:(ErrorHandlerBlock)errorHandler
-                                             untilCancelled:(id<CancelToken>)untilCancelledToken;
+                                             untilCancelled:(TOCCancelToken*)untilCancelledToken;
 -(BOOL) toggleMute;
 @end
diff --git a/Signal/src/audio/incall_audio/CallAudioManager.m b/Signal/src/audio/incall_audio/CallAudioManager.m
index 4fa9c1ec35f..451fffe34c5 100644
--- a/Signal/src/audio/incall_audio/CallAudioManager.m
+++ b/Signal/src/audio/incall_audio/CallAudioManager.m
@@ -10,7 +10,7 @@ @implementation CallAudioManager
 
 +(CallAudioManager*) callAudioManagerStartedWithAudioSocket:(AudioSocket*)audioSocket
                                             andErrorHandler:(ErrorHandlerBlock)errorHandler
-                                             untilCancelled:(id<CancelToken>)untilCancelledToken {
+                                             untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(audioSocket != nil);
     
     AudioProcessor* processor = [AudioProcessor audioProcessor];
@@ -24,7 +24,7 @@ +(CallAudioManager*) callAudioManagerStartedWithAudioSocket:(AudioSocket*)audioS
     return newCallAudioManagerInstance;
 }
 
--(void) startWithErrorHandler:(ErrorHandlerBlock)errorHandler untilCancelled:(id<CancelToken>)untilCancelledToken {
+-(void) startWithErrorHandler:(ErrorHandlerBlock)errorHandler untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(errorHandler != nil);
     require(untilCancelledToken != nil);
     @synchronized(self) {
diff --git a/Signal/src/audio/incall_audio/RemoteIOAudio.h b/Signal/src/audio/incall_audio/RemoteIOAudio.h
index 7f4f130a9c0..2ed807f3dd6 100644
--- a/Signal/src/audio/incall_audio/RemoteIOAudio.h
+++ b/Signal/src/audio/incall_audio/RemoteIOAudio.h
@@ -45,7 +45,7 @@ enum State {
 @property (strong) CyclicalBuffer*        playbackQueue;
 @property (assign) AudioUnit              rioAudioUnit;
 
-+(RemoteIOAudio*) remoteIOInterfaceStartedWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(id<CancelToken>)untilCancelledToken;
++(RemoteIOAudio*) remoteIOInterfaceStartedWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(TOCCancelToken*)untilCancelledToken;
 -(void) populatePlaybackQueueWithData:(NSData*)data;
 -(NSUInteger)getSampleRateInHertz;
 -(BOOL) toggleMute;
diff --git a/Signal/src/audio/incall_audio/RemoteIOAudio.m b/Signal/src/audio/incall_audio/RemoteIOAudio.m
index 50d18bcc6d7..4c39ccf6360 100644
--- a/Signal/src/audio/incall_audio/RemoteIOAudio.m
+++ b/Signal/src/audio/incall_audio/RemoteIOAudio.m
@@ -21,7 +21,7 @@ @implementation RemoteIOAudio
 
 static bool doesActiveInstanceExist;
 
-+(RemoteIOAudio*) remoteIOInterfaceStartedWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(id<CancelToken>)untilCancelledToken {
++(RemoteIOAudio*) remoteIOInterfaceStartedWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     checkOperationDescribe(!doesActiveInstanceExist, @"Only one RemoteIOInterfance instance can exist at a time. Adding more will break previous instances.");
     doesActiveInstanceExist = true;
@@ -162,7 +162,7 @@ -(void) returnUsedBuffer:(RemoteIOBufferListWrapper*)buffer {
     [unusedBuffers addObject:buffer];
 }
 
--(void) startWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(id<CancelToken>)untilCancelledToken {
+-(void) startWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(delegateIn != nil);
     @synchronized(self){
         requireState(state == NOT_STARTED);
@@ -172,7 +172,7 @@ -(void) startWithDelegate:(id<AudioCallbackHandler>)delegateIn untilCancelled:(i
         state = STARTED;
     }
 
-    [untilCancelledToken whenCancelled:^{
+    [untilCancelledToken whenCancelledDo:^{
         @synchronized(self) {
             state = TERMINATED;
             doesActiveInstanceExist = false;
diff --git a/Signal/src/call/RecentCallManager.h b/Signal/src/call/RecentCallManager.h
index f73834fe4ad..0bd1196458c 100644
--- a/Signal/src/call/RecentCallManager.h
+++ b/Signal/src/call/RecentCallManager.h
@@ -16,9 +16,9 @@
 
 - (ObservableValue *)getObservableRecentCalls;
 - (void)watchForCallsThrough:(PhoneManager*)phoneManager
-			  untilCancelled:(id<CancelToken>)untilCancelledToken;
+			  untilCancelled:(TOCCancelToken*)untilCancelledToken;
 - (void)watchForContactUpdatesFrom:(ContactsManager*) contactManager
-                   untillCancelled:(id<CancelToken>) cancelToken;
+                   untillCancelled:(TOCCancelToken*) cancelToken;
 
 - (void)addRecentCall:(RecentCall *)recentCall;
 - (void)removeRecentCall:(RecentCall *)recentCall;
diff --git a/Signal/src/call/RecentCallManager.m b/Signal/src/call/RecentCallManager.m
index 3e292cf47e0..9628c496d9b 100644
--- a/Signal/src/call/RecentCallManager.m
+++ b/Signal/src/call/RecentCallManager.m
@@ -33,7 +33,7 @@ - (ObservableValue *)getObservableRecentCalls {
     return observableRecentsController;
 }
 
--(void) watchForContactUpdatesFrom:(ContactsManager*) contactManager untillCancelled:(id<CancelToken>) cancelToken{
+-(void) watchForContactUpdatesFrom:(ContactsManager*) contactManager untillCancelled:(TOCCancelToken*) cancelToken{
     [[contactManager getObservableWhisperUsers] watchLatestValue:^(NSArray* latestUsers) {
         for (RecentCall* recentCall in _allRecents) {
             if (![contactManager latestContactWithRecordId:recentCall.contactRecordID]) {
@@ -47,7 +47,7 @@ -(void) watchForContactUpdatesFrom:(ContactsManager*) contactManager untillCance
 }
 
 -(void) watchForCallsThrough:(PhoneManager*)phoneManager
-              untilCancelled:(id<CancelToken>)untilCancelledToken {
+              untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(phoneManager != nil);
 
     [[phoneManager currentCallObservable] watchLatestValue:^(CallState* latestCall) {
@@ -60,7 +60,7 @@ -(void) watchForCallsThrough:(PhoneManager*)phoneManager
 -(void) addCall:(CallState*)call {
     require(call != nil);
     
-    [call.futureCallLocallyAcceptedOrRejected finallyDo:^(Future* interactionCompletion) {
+    [call.futureCallLocallyAcceptedOrRejected finallyDo:^(TOCFuture* interactionCompletion) {
         bool isOutgoingCall = call.initiatedLocally;
         bool isMissedCall = interactionCompletion.hasFailed;
         Contact* contact = [self tryGetContactForCall:call];
diff --git a/Signal/src/contact/ContactsManager.h b/Signal/src/contact/ContactsManager.h
index 87550d60894..41ffb71540b 100644
--- a/Signal/src/contact/ContactsManager.h
+++ b/Signal/src/contact/ContactsManager.h
@@ -1,8 +1,7 @@
 #import <Foundation/Foundation.h>
+#import "CollapsingFutures.h"
 #import "Contact.h"
-#import "Future.h"
 #import "ObservableValue.h"
-#import "CancelTokenSource.h"
 
 /**
  *
@@ -18,11 +17,11 @@ typedef void(^ABAccessRequestCompletionBlock)(BOOL hasAccess);
 typedef void(^ABReloadRequestCompletionBlock)(NSArray *contacts);
 
 @interface ContactsManager : NSObject {
-@private Future* futureAddressBook;
+@private TOCFuture* futureAddressBook;
 @private ObservableValueController* observableContactsController;
 @private ObservableValueController* observableWhisperUsersController;
 @private ObservableValueController* observableFavouritesController;
-@private CancelTokenSource* life;
+@private TOCCancelTokenSource* life;
 @private NSDictionary *latestContactsById;
 @private NSDictionary *latestWhisperUsersById;
 }
diff --git a/Signal/src/contact/ContactsManager.m b/Signal/src/contact/ContactsManager.m
index 1d591cb7945..e32d0128322 100644
--- a/Signal/src/contact/ContactsManager.m
+++ b/Signal/src/contact/ContactsManager.m
@@ -1,9 +1,6 @@
 #import "ContactsManager.h"
-#import "FutureSource.h"
-#import "FutureUtil.h"
 #import <AddressBook/AddressBook.h>
 #import <libPhoneNumber-iOS/NBPhoneNumber.h>
-#import "Constraints.h"
 #import "Environment.h"
 #import "NotificationManifest.h"
 #import "PhoneNumberDirectoryFilter.h"
@@ -36,7 +33,7 @@ - (id)init {
         newUserNotificationsEnabled = [self knownUserStoreInitialized];
         _favouriteContactIds = [self loadFavouriteIds];
         _knownWhisperUserIds = [self loadKnownWhisperUsers];
-        life = [CancelTokenSource cancelTokenSource];
+        life = [TOCCancelTokenSource new];
         observableContactsController = [ObservableValueController observableValueControllerWithInitialValue:nil];
         observableWhisperUsersController = [ObservableValueController observableValueControllerWithInitialValue:nil];
         [self registerNotificationHandlers];
@@ -49,13 +46,13 @@ -(void) doAfterEnvironmentInitSetup {
         @synchronized(self) {
             [self setupLatestContacts:latestContacts];
         }
-    } untilCancelled:[life getToken]];
+    } untilCancelled:life.token];
     
     [observableWhisperUsersController watchLatestValueOnArbitraryThread:^(NSArray *latestUsers) {
         @synchronized(self) {
             [self setupLatestWhisperUsers:latestUsers];
         }
-    } untilCancelled:[life getToken]];
+    } untilCancelled:life.token];
 }
 
 -(void)dealloc {
@@ -147,15 +144,15 @@ -(ObservableValue *) getObservableFavourites {
 
 #pragma mark - Address Book utils
 
-+(Future*) asyncGetAddressBook {
++(TOCFuture*) asyncGetAddressBook {
     CFErrorRef creationError = nil;
     ABAddressBookRef addressBookRef = ABAddressBookCreateWithOptions(NULL, &creationError);
     assert((addressBookRef == nil) == (creationError != nil));
     if (creationError != nil) {
-        return [Future failed:(__bridge_transfer id)creationError];
+        return [TOCFuture futureWithFailure:(__bridge_transfer id)creationError];
     }
 
-    FutureSource *futureAddressBookSource = [FutureSource new];
+    TOCFutureSource *futureAddressBookSource = [TOCFutureSource new];
 
     id addressBook = (__bridge_transfer id)addressBookRef;
     ABAddressBookRequestAccessWithCompletion(addressBookRef, ^(bool granted, CFErrorRef requestAccessError) {
@@ -168,7 +165,7 @@ +(Future*) asyncGetAddressBook {
         }
     });
 
-    return futureAddressBookSource;
+    return futureAddressBookSource.future;
 }
 
 -(NSArray*) getContactsFromAddressBook:(ABAddressBookRef)addressBook {
diff --git a/Signal/src/environment/Environment.m b/Signal/src/environment/Environment.m
index ff42ae9be63..636ae4751f6 100644
--- a/Signal/src/environment/Environment.m
+++ b/Signal/src/environment/Environment.m
@@ -140,6 +140,10 @@ +(PhoneManager*) phoneManager {
     return [[Environment getCurrent] phoneManager];
 }
 +(id<Logging>) logging {
+    // Many tests create objects that rely on Environment only for logging.
+    // So we bypass the nil check in getCurrent and silently don't log during unit testing, instead of failing hard.
+    if (environment == nil) return nil;
+    
     return [[Environment getCurrent] logging];
 }
 
diff --git a/Signal/src/network/IpEndPoint.m b/Signal/src/network/IpEndPoint.m
index b7d85f19082..db13d573d21 100644
--- a/Signal/src/network/IpEndPoint.m
+++ b/Signal/src/network/IpEndPoint.m
@@ -1,9 +1,7 @@
 #import "IpEndPoint.h"
-#import "Util.h"
-#import "Constraints.h"
-#import "IpAddress.h"
-#import "FutureSource.h"
+
 #import "DnsManager.h"
+#import "Util.h"
 
 @implementation IpEndPoint
 
@@ -78,8 +76,8 @@ -(NSString*) description {
 -(void) handleStreamsOpened:(StreamPair *)streamPair {
     // no work needed
 }
--(Future*) asyncHandleStreamsConnected:(StreamPair *)streamPair {
-    return [Future finished:@YES];
+-(TOCFuture*) asyncHandleStreamsConnected:(StreamPair *)streamPair {
+    return [TOCFuture futureWithResult:@YES];
 }
 
 -(StreamPair*)createStreamPair {
@@ -90,8 +88,8 @@ -(StreamPair*)createStreamPair {
                                  andOutput:(__bridge_transfer NSOutputStream*)writeStream];
 }
 
--(Future*) asyncResolveToSpecificEndPointsUnlessCancelled:(id<CancelToken>)unlessCancelledToken {
-    return [Future finished:@[self]];
+-(TOCFuture*) asyncResolveToSpecificEndPointsUnlessCancelled:(TOCCancelToken*)unlessCancelledToken {
+    return [TOCFuture futureWithResult:@[self]];
 }
 
 @end
diff --git a/Signal/src/network/NetworkEndPoint.h b/Signal/src/network/NetworkEndPoint.h
index 06e6337a896..4991d966894 100644
--- a/Signal/src/network/NetworkEndPoint.h
+++ b/Signal/src/network/NetworkEndPoint.h
@@ -1,7 +1,6 @@
 #import <Foundation/Foundation.h>
-#import "CancelToken.h"
+#import "CollapsingFutures.h"
 #import "StreamPair.h"
-#import "Future.h"
 
 /// Describes a location to which you can connect and communicate.
 @protocol NetworkEndPoint <NSObject>
@@ -15,11 +14,11 @@
 
 /// Invoked when a stream pair is ready for read/write.
 /// (The time to authenticate certificates of a completed SSL connection.)
--(Future*) asyncHandleStreamsConnected:(StreamPair*)streamPair;
+-(TOCFuture*) asyncHandleStreamsConnected:(StreamPair*)streamPair;
 
 /// Resolves this general end point into underlying associated specific end points.
 /// For example, a hostname+port end point resolves into one or more ip+port end points.
 /// The asynchronous result has type Future(Array(NetworkEndPoint)).
--(Future*) asyncResolveToSpecificEndPointsUnlessCancelled:(id<CancelToken>)unlessCancelledToken;
+-(TOCFuture*) asyncResolveToSpecificEndPointsUnlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 @end
diff --git a/Signal/src/network/dns/DnsManager.h b/Signal/src/network/dns/DnsManager.h
index 9861513617f..1c9e1fba04c 100644
--- a/Signal/src/network/dns/DnsManager.h
+++ b/Signal/src/network/dns/DnsManager.h
@@ -1,6 +1,5 @@
 #import <Foundation/Foundation.h>
-#import "FutureSource.h"
-#import "CancelToken.h"
+#import "CollapsingFutures.h"
 #import "IpAddress.h"
 
 /**
@@ -11,11 +10,11 @@
 
 @interface DnsManager : NSObject {
 @private CFStreamError error;
-@public FutureSource* futureResultSource;
+@public TOCFutureSource* futureResultSource;
 }
 
 /// Result has type Future(Array(IpAddress))
-+(Future*) asyncQueryAddressesForDomainName:(NSString*)domainName
-                            unlessCancelled:(id<CancelToken>)unlessCancelledToken;
++(TOCFuture*) asyncQueryAddressesForDomainName:(NSString*)domainName
+                               unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 @end
diff --git a/Signal/src/network/dns/DnsManager.m b/Signal/src/network/dns/DnsManager.m
index c567fa10669..0834d8336b0 100644
--- a/Signal/src/network/dns/DnsManager.m
+++ b/Signal/src/network/dns/DnsManager.m
@@ -1,12 +1,11 @@
-#import "CancelTokenSource.h"
-#import "Constraints.h"
 #import "DnsManager.h"
+
+#import <netdb.h>
 #import "HttpResponse.h"
 #import "IpEndPoint.h"
+#import "ThreadManager.h"
 #import "UdpSocket.h"
 #import "Util.h"
-#import <netdb.h>
-#import "ThreadManager.h"
 
 #define STRING_POINTER_FLAG 0xc0
 
@@ -42,15 +41,15 @@ void handleDnsCompleted(CFHostRef hostRef, CFHostInfoType typeInfo, const CFStre
     }
 }
 
-+(Future*) asyncQueryAddressesForDomainName:(NSString*)domainName
-                            unlessCancelled:(id<CancelToken>)unlessCancelledToken {
++(TOCFuture*) asyncQueryAddressesForDomainName:(NSString*)domainName
+                            unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     require(domainName != nil);
     
     CFHostRef hostRef = CFHostCreateWithName(kCFAllocatorDefault, (__bridge CFStringRef)domainName);
     checkOperation(hostRef != nil);
 
     DnsManager* d = [DnsManager new];
-    d->futureResultSource = [FutureSource new];
+    d->futureResultSource = [TOCFutureSource futureSourceUntil:unlessCancelledToken];
     
     CFHostClientContext c;
     c.version = 0;
@@ -70,9 +69,8 @@ +(Future*) asyncQueryAddressesForDomainName:(NSString*)domainName
         [d->futureResultSource trySetFailure:[OperationFailed new:[NSString stringWithFormat:@"DNS query failed to start. Error code: %d",
                                                                    (int)d->error.error]]];
     }
-    [unlessCancelledToken whenCancelledTryCancel:d->futureResultSource];
     
-    return d->futureResultSource;
+    return d->futureResultSource.future;
 }
 
 @end
diff --git a/Signal/src/network/dns/HostNameEndPoint.m b/Signal/src/network/dns/HostNameEndPoint.m
index 06cbe6001b6..6b8dc47405e 100644
--- a/Signal/src/network/dns/HostNameEndPoint.m
+++ b/Signal/src/network/dns/HostNameEndPoint.m
@@ -21,8 +21,8 @@ +(HostNameEndPoint*) hostNameEndPointWithHostName:(NSString*)hostname
 -(void) handleStreamsOpened:(StreamPair *)streamPair {
     // no work needed
 }
--(Future *)asyncHandleStreamsConnected:(StreamPair *)streamPair {
-    return [Future finished:@YES];
+-(TOCFuture*)asyncHandleStreamsConnected:(StreamPair *)streamPair {
+    return [TOCFuture futureWithResult:@YES];
 }
 
 -(StreamPair*)createStreamPair {
@@ -33,10 +33,10 @@ -(StreamPair*)createStreamPair {
                                  andOutput:(__bridge_transfer NSOutputStream*)writeStream];
 }
 
--(Future*) asyncResolveToSpecificEndPointsUnlessCancelled:(id<CancelToken>)unlessCancelledToken {
-    Future* futureDnsResult = [DnsManager asyncQueryAddressesForDomainName:hostname
-                                                           unlessCancelled:unlessCancelledToken];
-    return [futureDnsResult then:^(NSArray* ipAddresses) {
+-(TOCFuture*) asyncResolveToSpecificEndPointsUnlessCancelled:(TOCCancelToken*)unlessCancelledToken {
+    TOCFuture* futureDnsResult = [DnsManager asyncQueryAddressesForDomainName:hostname
+                                                              unlessCancelled:unlessCancelledToken];
+    return [futureDnsResult thenTry:^(NSArray* ipAddresses) {
         return [ipAddresses map:^(IpAddress* address) {
             return [IpEndPoint ipEndPointAtAddress:address onPort:port];
         }];
diff --git a/Signal/src/network/http/HttpManager.h b/Signal/src/network/http/HttpManager.h
index 7958fd0fa20..cf256d40059 100644
--- a/Signal/src/network/http/HttpManager.h
+++ b/Signal/src/network/http/HttpManager.h
@@ -1,12 +1,9 @@
 #import <Foundation/Foundation.h>
-#import "CancelTokenSource.h"
 #import "NetworkEndPoint.h"
 #import "Logging.h"
-#import "Future.h"
 #import "HttpRequestOrResponse.h"
 #import "Terminable.h"
 #import "Queue.h"
-#import "CancelToken.h"
 #import "PacketHandler.h"
 #import "HttpSocket.h"
 
@@ -19,32 +16,32 @@
 @private HttpSocket* httpChannel;
 @private Queue* eventualResponseQueue;
 @private bool isStarted;
-@private CancelTokenSource* lifetime;
+@private TOCCancelTokenSource* lifetime;
 }
 
 +(HttpManager*) httpManagerFor:(HttpSocket*)httpSocket
-                untilCancelled:(id<CancelToken>)untilCancelledToken;
+                untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 +(HttpManager*) startWithEndPoint:(id<NetworkEndPoint>)endPoint
-                   untilCancelled:(id<CancelToken>)untilCancelledToken;
+                   untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
--(Future*) asyncResponseForRequest:(HttpRequest*)request
-                   unlessCancelled:(id<CancelToken>)unlessCancelledToken;
+-(TOCFuture*) asyncResponseForRequest:(HttpRequest*)request
+                      unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
--(Future*) asyncOkResponseForRequest:(HttpRequest*)request
-                     unlessCancelled:(id<CancelToken>)unlessCancelledToken;
+-(TOCFuture*) asyncOkResponseForRequest:(HttpRequest*)request
+                        unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 -(void) startWithRejectingRequestHandlerAndErrorHandler:(ErrorHandlerBlock)errorHandler
-                                         untilCancelled:(id<CancelToken>)untilCancelledToken;
+                                         untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 -(void) startWithRequestHandler:(HttpResponse*(^)(HttpRequest* remoteRequest))requestHandler
                 andErrorHandler:(ErrorHandlerBlock)errorHandler
-                 untilCancelled:(id<CancelToken>)untilCancelledToken;
+                 untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 -(void) terminateWhenDoneCurrentWork;
 
-+(Future*) asyncOkResponseFromMasterServer:(HttpRequest*)request
-                           unlessCancelled:(id<CancelToken>)unlessCancelledToken
-                           andErrorHandler:(ErrorHandlerBlock)errorHandler;
++(TOCFuture*) asyncOkResponseFromMasterServer:(HttpRequest*)request
+                              unlessCancelled:(TOCCancelToken*)unlessCancelledToken
+                              andErrorHandler:(ErrorHandlerBlock)errorHandler;
 
 @end
diff --git a/Signal/src/network/http/HttpManager.m b/Signal/src/network/http/HttpManager.m
index 3fbeddd289f..ce6c4fdfa84 100644
--- a/Signal/src/network/http/HttpManager.m
+++ b/Signal/src/network/http/HttpManager.m
@@ -1,5 +1,4 @@
 #import "HttpManager.h"
-#import "FutureSource.h"
 #import "NetworkStream.h"
 #import "HttpSocket.h"
 #import "Util.h"
@@ -7,18 +6,18 @@
 @implementation HttpManager
 
 +(HttpManager*) httpManagerFor:(HttpSocket*)httpSocket
-                untilCancelled:(id<CancelToken>)untilCancelledToken {
+                untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(httpSocket != nil);
     
     HttpManager* m = [HttpManager new];
     m->httpChannel = httpSocket;
     m->eventualResponseQueue = [Queue new];
-    m->lifetime = [CancelTokenSource cancelTokenSource];
+    m->lifetime = [TOCCancelTokenSource new];
     [untilCancelledToken whenCancelledTerminate:m];
     return m;
 }
 +(HttpManager*) startWithEndPoint:(id<NetworkEndPoint>)endPoint
-                   untilCancelled:(id<CancelToken>)untilCancelledToken {
+                   untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(endPoint != nil);
     
     NetworkStream* dataChannel = [NetworkStream networkStreamToEndPoint:endPoint];
@@ -28,30 +27,29 @@ +(HttpManager*) startWithEndPoint:(id<NetworkEndPoint>)endPoint
     return [HttpManager httpManagerFor:httpChannel
                         untilCancelled:untilCancelledToken];
 }
--(Future*) asyncResponseForRequest:(HttpRequest*)request
-                   unlessCancelled:(id<CancelToken>)unlessCancelledToken {
+-(TOCFuture*) asyncResponseForRequest:(HttpRequest*)request
+                      unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     
     require(request != nil);
     requireState(isStarted);
     
     @try {
-        FutureSource* ev = [FutureSource new];
-        [unlessCancelledToken whenCancelledTryCancel:ev];
+        TOCFutureSource* ev = [TOCFutureSource futureSourceUntil:unlessCancelledToken];
         @synchronized (self) {
-            if ([[lifetime getToken] isAlreadyCancelled]) {
-                return [Future failed:@"terminated"];
+            if ([lifetime.token isAlreadyCancelled]) {
+                return [TOCFuture futureWithFailure:@"terminated"];
             }
             [eventualResponseQueue enqueue:ev];
         }
         [httpChannel send:[HttpRequestOrResponse httpRequestOrResponse:request]];
-        return ev;
+        return ev.future;
     } @catch (OperationFailed* ex) {
-        return [Future failed:ex];
+        return [TOCFuture futureWithFailure:ex];
     }
 }
-+(Future*) asyncOkResponseFromMasterServer:(HttpRequest*)request
-                           unlessCancelled:(id<CancelToken>)unlessCancelledToken
-                           andErrorHandler:(ErrorHandlerBlock)errorHandler {
++(TOCFuture*) asyncOkResponseFromMasterServer:(HttpRequest*)request
+                              unlessCancelled:(TOCCancelToken*)unlessCancelledToken
+                              andErrorHandler:(ErrorHandlerBlock)errorHandler {
     require(request != nil);
     require(errorHandler != nil);
     
@@ -61,28 +59,28 @@ +(Future*) asyncOkResponseFromMasterServer:(HttpRequest*)request
     [manager startWithRejectingRequestHandlerAndErrorHandler:errorHandler
                                               untilCancelled:nil];
     
-    Future* result = [manager asyncOkResponseForRequest:request
+    TOCFuture* result = [manager asyncOkResponseForRequest:request
                                         unlessCancelled:unlessCancelledToken];
     
     [manager terminateWhenDoneCurrentWork];
     
     return result;
 }
--(Future*) asyncOkResponseForRequest:(HttpRequest*)request
-                     unlessCancelled:(id<CancelToken>)unlessCancelledToken {
+-(TOCFuture*) asyncOkResponseForRequest:(HttpRequest*)request
+                        unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     
     require(request != nil);
     
-    Future* futureResponse = [self asyncResponseForRequest:request
+    TOCFuture* futureResponse = [self asyncResponseForRequest:request
                                            unlessCancelled:unlessCancelledToken];
     
-    return [futureResponse then:^(HttpResponse* response) {
-        if (!response.isOkResponse) return [Future failed:response];
-        return [Future finished:response];
+    return [futureResponse then:^id(HttpResponse* response) {
+        if (!response.isOkResponse) return [TOCFuture futureWithFailure:response];
+        return response;
     }];
 }
 -(void) startWithRejectingRequestHandlerAndErrorHandler:(ErrorHandlerBlock)errorHandler
-                                         untilCancelled:(id<CancelToken>)untilCancelledToken {
+                                         untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(errorHandler != nil);
     
     HttpResponse*(^requestHandler)(HttpRequest* remoteRequest) = ^(HttpRequest* remoteRequest) {
@@ -97,7 +95,7 @@ -(void) startWithRejectingRequestHandlerAndErrorHandler:(ErrorHandlerBlock)error
 
 -(void) startWithRequestHandler:(HttpResponse*(^)(HttpRequest* remoteRequest))requestHandler
                 andErrorHandler:(ErrorHandlerBlock)errorHandler
-                 untilCancelled:(id<CancelToken>)untilCancelledToken {
+                 untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(requestHandler != nil);
     require(errorHandler != nil);
@@ -123,15 +121,15 @@ -(void) startWithRequestHandler:(HttpResponse*(^)(HttpRequest* remoteRequest))re
             } else if (eventualResponseQueue.count == 0) {
                 errorHandler(@"Response when no requests queued", [requestOrResponse response], false);
             } else {
-                FutureSource* ev = [eventualResponseQueue dequeue];
-                [ev trySetResult:[requestOrResponse response]];
+                TOCFutureSource* ev = [eventualResponseQueue dequeue];
+                [ev trySetResult:requestOrResponse.response];
             }
         }
     };
     
     [httpChannel startWithHandler:[PacketHandler packetHandler:httpHandler
                                               withErrorHandler:clearOnSeriousError]
-                   untilCancelled:[lifetime getToken]];
+                   untilCancelled:lifetime.token];
     
     [untilCancelledToken whenCancelledTerminate:self];
 }
@@ -147,10 +145,8 @@ -(void) terminateWhenDoneCurrentWork {
         if (eventualResponseQueue.count == 0) {
             [self terminate];
         } else {
-            FutureSource* v = [eventualResponseQueue peekAt:eventualResponseQueue.count-1];
-            [v finallyDo:^(id _) {
-                [self terminate];
-            }];
+            TOCFutureSource* v = [eventualResponseQueue peekAt:eventualResponseQueue.count-1];
+            [v.future.cancelledOnCompletionToken whenCancelledTerminate:self];
         }
     }
 }
diff --git a/Signal/src/network/http/HttpSocket.h b/Signal/src/network/http/HttpSocket.h
index b80cf515bc8..2e0ffdbc588 100644
--- a/Signal/src/network/http/HttpSocket.h
+++ b/Signal/src/network/http/HttpSocket.h
@@ -27,6 +27,6 @@
 -(void) sendHttpResponse:(HttpResponse*)response;
 -(void) send:(HttpRequestOrResponse*)packet;
 -(void) startWithHandler:(PacketHandler*)handler
-          untilCancelled:(id<CancelToken>)untilCancelledToken;
+          untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 @end
diff --git a/Signal/src/network/http/HttpSocket.m b/Signal/src/network/http/HttpSocket.m
index 9f11388c3fa..daa10093317 100644
--- a/Signal/src/network/http/HttpSocket.m
+++ b/Signal/src/network/http/HttpSocket.m
@@ -1,9 +1,7 @@
-#import "HttpSocket.h"
-#import "Constraints.h"
 #import "HttpRequest.h"
-#import "Util.h"
 #import "HttpResponse.h"
-#import "CancelTokenSource.h"
+#import "HttpSocket.h"
+#import "Util.h"
 
 @implementation HttpSocket
 
@@ -52,16 +50,13 @@ -(void) send:(HttpRequestOrResponse*)packet {
     [self sendHttpRequestOrResponse:packet];
 }
 -(void) startWithHandler:(PacketHandler*)handler
-          untilCancelled:(id<CancelToken>)untilCancelledToken {
+          untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(handler != nil);
     requireState(httpSignalResponseHandler == nil);
     httpSignalResponseHandler = handler;
     
-    CancelTokenSource* lifetime = [CancelTokenSource cancelTokenSource];
-    [untilCancelledToken whenCancelled:^{
-        [lifetime cancel];
-    }];
+    TOCCancelTokenSource* lifetime = [TOCCancelTokenSource cancelTokenSourceUntil:untilCancelledToken];
     
     PacketHandler* packetHandler = [PacketHandler packetHandler:^(id packet) {
         require(packet != nil);
@@ -91,10 +86,10 @@ -(void) startWithHandler:(PacketHandler*)handler
     
     if (rawDataChannelTcp != nil) {
         [rawDataChannelTcp startWithHandler:packetHandler];
-        [[lifetime getToken] whenCancelledTerminate:rawDataChannelTcp];
+        [lifetime.token whenCancelledTerminate:rawDataChannelTcp];
     } else {
         [rawDataChannelUdp startWithHandler:packetHandler
-                             untilCancelled:[lifetime getToken]];
+                             untilCancelled:lifetime.token];
     }
 }
 
diff --git a/Signal/src/network/rtp/RtpSocket.h b/Signal/src/network/rtp/RtpSocket.h
index 1c34240c450..7f343a86f27 100644
--- a/Signal/src/network/rtp/RtpSocket.h
+++ b/Signal/src/network/rtp/RtpSocket.h
@@ -23,6 +23,6 @@
 
 +(RtpSocket*) rtpSocketOverUdp:(UdpSocket*)udpSocket interopOptions:(NSArray*)interopOptions;
 -(void) send:(RtpPacket*)packet;
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken;
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 @end
diff --git a/Signal/src/network/rtp/RtpSocket.m b/Signal/src/network/rtp/RtpSocket.m
index f226a76b321..dd47eacbbe4 100644
--- a/Signal/src/network/rtp/RtpSocket.m
+++ b/Signal/src/network/rtp/RtpSocket.m
@@ -14,7 +14,7 @@ +(RtpSocket*) rtpSocketOverUdp:(UdpSocket*)udpSocket interopOptions:(NSArray*)in
     return s;
 }
 
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken {
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(handler != nil);
     @synchronized(self) {
         bool isFirstTime = currentHandler == nil;
diff --git a/Signal/src/network/rtp/srtp/SrtpSocket.h b/Signal/src/network/rtp/srtp/SrtpSocket.h
index 83c26bf07f9..9d7a48c1660 100644
--- a/Signal/src/network/rtp/srtp/SrtpSocket.h
+++ b/Signal/src/network/rtp/srtp/SrtpSocket.h
@@ -27,5 +27,5 @@
                andOutgoingMacKey:(NSData*)outgoingMacKey
                  andOutgoingSalt:(NSData*)outgoingSalt;
 -(void) secureAndSendRtpPacket:(RtpPacket *)packet;
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken;
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken;
 @end
diff --git a/Signal/src/network/rtp/srtp/SrtpSocket.m b/Signal/src/network/rtp/srtp/SrtpSocket.m
index ed668f89131..749cfe25aa1 100644
--- a/Signal/src/network/rtp/srtp/SrtpSocket.m
+++ b/Signal/src/network/rtp/srtp/SrtpSocket.m
@@ -36,7 +36,7 @@ -(RtpPacket*) encryptAndAuthenticateToSend:(RtpPacket*)normalRtpPacket {
     return [outgoingContext encryptAndAuthenticateNormalRtpPacket:normalRtpPacket];
 }
 
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken {
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(handler != nil);
     requireState(!hasBeenStarted);
     hasBeenStarted = true;
diff --git a/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.h b/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.h
index 73d900eafb9..8e1352b17c7 100644
--- a/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.h
+++ b/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.h
@@ -19,5 +19,5 @@
 }
 +(ZrtpHandshakeSocket*) zrtpHandshakeSocketOverRtp:(RtpSocket*)rtpSocket;
 -(void) send:(HandshakePacket*)packet;
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken;
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken;
 @end
diff --git a/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.m b/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.m
index c845d38b266..3b366ad7516 100644
--- a/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.m
+++ b/Signal/src/network/rtp/zrtp/ZrtpHandshakeSocket.m
@@ -19,7 +19,7 @@ -(void) send:(HandshakePacket*)packet {
     [rtpSocket send:[packet embeddedIntoRtpPacketWithSequenceNumber:sequenceNumber
                                                 usingInteropOptions:rtpSocket->interopOptions]];
 }
--(void) startWithHandler:(PacketHandler*)handler untilCancelled:(id<CancelToken>)untilCancelledToken {
+-(void) startWithHandler:(PacketHandler*)handler untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(handler != nil);
     requireState(handshakePacketHandler == nil);
     
diff --git a/Signal/src/network/rtp/zrtp/ZrtpManager.h b/Signal/src/network/rtp/zrtp/ZrtpManager.h
index 22c3ff0fea9..6940fadb2b5 100644
--- a/Signal/src/network/rtp/zrtp/ZrtpManager.h
+++ b/Signal/src/network/rtp/zrtp/ZrtpManager.h
@@ -1,8 +1,6 @@
 #import <Foundation/Foundation.h>
 
 #import "CallController.h"
-#import "CancelTokenSource.h"
-#import "FutureSource.h"
 #import "HandshakePacket.h"
 #import "Logging.h"
 #import "NegotiationFailed.h"
@@ -23,13 +21,13 @@
 @private bool handshakeCompletedSuccesfully;
 @private bool done;
     
-@private CancelTokenSource* cancelTokenSource;
-@private CancelTokenSource* currentRetransmit;
+@private TOCCancelTokenSource* cancelTokenSource;
+@private TOCCancelTokenSource* currentRetransmit;
 @private RtpSocket* rtpSocketToSecure;
 @private ZrtpHandshakeSocket* handshakeSocket;
 @private HandshakePacket* currentPacketToRetransmit;
 @private id<ZrtpRole> zrtpRole;
-@private FutureSource* futureHandshakeResultSource;
+@private TOCFutureSource* futureHandshakeResultSource;
 @private CallController* callController;
 }
 
@@ -50,7 +48,7 @@
 /// @param callController
 /// Used to notify the outside about the progress of termination of the handshake.
 /// If callController's cancel token is cancelled before or while the handshake is running, the handshake will be promptly aborted.
-+(Future*) asyncPerformHandshakeOver:(RtpSocket*)rtpSocket
-                   andCallController:(CallController*)callController;
++(TOCFuture*) asyncPerformHandshakeOver:(RtpSocket*)rtpSocket
+                      andCallController:(CallController*)callController;
 
 @end
diff --git a/Signal/src/network/rtp/zrtp/ZrtpManager.m b/Signal/src/network/rtp/zrtp/ZrtpManager.m
index 3ea62455779..afac3da217f 100644
--- a/Signal/src/network/rtp/zrtp/ZrtpManager.m
+++ b/Signal/src/network/rtp/zrtp/ZrtpManager.m
@@ -15,7 +15,7 @@
 
 @implementation ZrtpManager
 
-+(Future*) asyncPerformHandshakeOver:(RtpSocket*)rtpSocket
++(TOCFuture*) asyncPerformHandshakeOver:(RtpSocket*)rtpSocket
                    andCallController:(CallController*)callController {
     
     require(rtpSocket != nil);
@@ -49,13 +49,13 @@ +(ZrtpManager*) zrtpManagerWithHandshakeSocket:(ZrtpHandshakeSocket*)handshakeSo
     
     manager->callController                 = callController;
     manager->zrtpRole                       = zrtpRole;
-    manager->futureHandshakeResultSource    = [FutureSource new];
+    manager->futureHandshakeResultSource    = [TOCFutureSource new];
     manager->rtpSocketToSecure              = rtpSocket;
     manager->handshakeSocket                = handshakeSocket;
-    manager->cancelTokenSource              = [CancelTokenSource cancelTokenSource];
+    manager->cancelTokenSource              = [TOCCancelTokenSource new];
     [[callController untilCancelledToken] whenCancelledTerminate:manager];
     
-    [manager->futureHandshakeResultSource catchDo:^(id error) {
+    [manager->futureHandshakeResultSource.future catchDo:^(id error) {
         [callController terminateWithReason:CallTerminationType_HandshakeFailed
                             withFailureInfo:error
                              andRelatedInfo:nil];
@@ -64,7 +64,7 @@ +(ZrtpManager*) zrtpManagerWithHandshakeSocket:(ZrtpHandshakeSocket*)handshakeSo
     return manager;
 }
 
--(Future*) asyncPerformHandshake {    
+-(TOCFuture*) asyncPerformHandshake {    
     PacketHandlerBlock packetHandler = ^(id packet) {
         require(packet != nil);
         require([packet isKindOfClass:[HandshakePacket class]]);
@@ -87,7 +87,7 @@ -(Future*) asyncPerformHandshake {
     };
     
     [handshakeSocket startWithHandler:[PacketHandler packetHandler:packetHandler withErrorHandler:errorHandler]
-                       untilCancelled:[cancelTokenSource getToken]];
+                       untilCancelled:cancelTokenSource.token];
     
     HandshakePacket* initialPacket = [zrtpRole initialPacket];
     if (initialPacket == nil) {
@@ -96,7 +96,7 @@ -(Future*) asyncPerformHandshake {
         [self setAndSendPacketToTransmit:initialPacket];
     }
     
-    return futureHandshakeResultSource;
+    return futureHandshakeResultSource.future;
 }
 
 -(void) setAndSendPacketToTransmit:(HandshakePacket*)packet {
@@ -119,12 +119,12 @@ -(void) scheduleRetransmit {
     currentPacketTransmitCount += 1;
     
     [currentRetransmit cancel];
-    currentRetransmit = [CancelTokenSource cancelTokenSource];
+    currentRetransmit = [TOCCancelTokenSource new];
     
     [TimeUtil scheduleRun:^{[self handleRetransmit];}
                afterDelay:delay
                 onRunLoop:[ThreadManager lowLatencyThreadRunLoop]
-          unlessCancelled:[currentRetransmit getToken]];    
+          unlessCancelled:currentRetransmit.token];    
 }
 
 -(void) handleRetransmit {
@@ -152,11 +152,11 @@ -(void) scheduleTimeoutIfNoHello {
         [futureHandshakeResultSource trySetFailure:[RecipientUnavailable recipientUnavailable]];
     };
     
-    currentRetransmit = [CancelTokenSource cancelTokenSource];
+    currentRetransmit = [TOCCancelTokenSource new];
     [TimeUtil scheduleRun:timeoutFail
                afterDelay:MAX_WAIT_FOR_RESPONDER_HELLO_SECONDS
                 onRunLoop:[ThreadManager lowLatencyThreadRunLoop]
-          unlessCancelled:[currentRetransmit getToken]];
+          unlessCancelled:currentRetransmit.token];
 }
 
 -(void) terminate {
diff --git a/Signal/src/network/tcp/LowLatencyCandidate.h b/Signal/src/network/tcp/LowLatencyCandidate.h
index 1daf48e40c2..93c4771aa4c 100644
--- a/Signal/src/network/tcp/LowLatencyCandidate.h
+++ b/Signal/src/network/tcp/LowLatencyCandidate.h
@@ -1,7 +1,7 @@
 #import <Foundation/Foundation.h>
+#import "CollapsingFutures.h"
 #import "IpEndPoint.h"
 #import "NetworkStream.h"
-#import "AsyncUtil.h"
 
 @interface LowLatencyCandidate : NSObject<Terminable>
 
@@ -12,8 +12,8 @@
 
 -(void) preStart;
 
--(CancellableOperationStarter) tcpHandshakeCompleter;
+-(TOCUntilOperation) tcpHandshakeCompleter;
 
--(Future*) delayedUntilAuthenticated;
+-(TOCFuture*) delayedUntilAuthenticated;
 
 @end
diff --git a/Signal/src/network/tcp/LowLatencyCandidate.m b/Signal/src/network/tcp/LowLatencyCandidate.m
index cccf6c6b5cf..dcb0e6fcbe1 100644
--- a/Signal/src/network/tcp/LowLatencyCandidate.m
+++ b/Signal/src/network/tcp/LowLatencyCandidate.m
@@ -23,24 +23,22 @@ -(void) preStart {
     [networkStream startProcessingStreamEventsEvenWithoutHandler];
 }
 
--(CancellableOperationStarter) tcpHandshakeCompleter {
-    return ^(id<CancelToken> untilCancelledToken) {
+-(TOCUntilOperation) tcpHandshakeCompleter {
+    return ^(TOCCancelToken* untilCancelledToken) {
         return [self completer:untilCancelledToken];
     };
 }
 
--(Future*) completer:(id<CancelToken>)untilCancelledToken {
-    Future* tcpHandshakeCompleted = [networkStream asyncTcpHandshakeCompleted];
+-(TOCFuture*) completer:(TOCCancelToken*)untilCancelledToken {
+    TOCFuture* tcpHandshakeCompleted = [networkStream asyncTcpHandshakeCompleted];
     
     [untilCancelledToken whenCancelledTerminate:self];
     
-    return [Future delayed:self
-                untilAfter:tcpHandshakeCompleted];
+    return [tcpHandshakeCompleted thenValue:self];
 }
 
--(Future*) delayedUntilAuthenticated {
-    return [Future delayed:self
-                untilAfter:[networkStream asyncConnectionCompleted]];
+-(TOCFuture*) delayedUntilAuthenticated {
+    return [networkStream.asyncConnectionCompleted thenValue:self];
 }
 
 @end
diff --git a/Signal/src/network/tcp/LowLatencyConnector.h b/Signal/src/network/tcp/LowLatencyConnector.h
index be6fcee1154..3636aae88d0 100644
--- a/Signal/src/network/tcp/LowLatencyConnector.h
+++ b/Signal/src/network/tcp/LowLatencyConnector.h
@@ -1,8 +1,7 @@
 #import <Foundation/Foundation.h>
+#import "CollapsingFutures.h"
 #import "IpEndPoint.h"
-#import "FutureSource.h"
 #import "NetworkStream.h"
-#import "CancelToken.h"
 #import "LowLatencyCandidate.h"
 
 /**
@@ -15,7 +14,7 @@
 @interface LowLatencyConnector : NSObject <NSStreamDelegate>
 
 /// Result has type Future(LowLatencyCandidate).
-+(Future*) asyncLowLatencyConnectToEndPoint:(id<NetworkEndPoint>)endPoint
-                             untilCancelled:(id<CancelToken>)untilCancelledToken;
++(TOCFuture*) asyncLowLatencyConnectToEndPoint:(id<NetworkEndPoint>)endPoint
+                                untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 @end
diff --git a/Signal/src/network/tcp/LowLatencyConnector.m b/Signal/src/network/tcp/LowLatencyConnector.m
index bd52da2b66d..64bf2d2532b 100644
--- a/Signal/src/network/tcp/LowLatencyConnector.m
+++ b/Signal/src/network/tcp/LowLatencyConnector.m
@@ -1,34 +1,31 @@
 #import "LowLatencyConnector.h"
+
 #import "Constraints.h"
-#import "Util.h"
 #import "DnsManager.h"
 #import "IpAddress.h"
-#import "CancelToken.h"
-#import "FunctionalUtil.h"
-#import "AsyncUtil.h"
 #import "NetworkStream.h"
+#import "Util.h"
 
 @implementation LowLatencyConnector
 
-+(Future*) asyncLowLatencyConnectToEndPoint:(id<NetworkEndPoint>)endPoint
-                             untilCancelled:(id<CancelToken>)untilCancelledToken {
++(TOCFuture*) asyncLowLatencyConnectToEndPoint:(id<NetworkEndPoint>)endPoint
+                             untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(endPoint != nil);
     
-    Future* futureSpecificEndPoints = [endPoint asyncResolveToSpecificEndPointsUnlessCancelled:untilCancelledToken];
+    TOCFuture* futureSpecificEndPoints = [endPoint asyncResolveToSpecificEndPointsUnlessCancelled:untilCancelledToken];
     
-    return [futureSpecificEndPoints then:^(NSArray* specificEndPoints) {
+    return [futureSpecificEndPoints thenTry:^(NSArray* specificEndPoints) {
         return [LowLatencyConnector startConnectingToAll:specificEndPoints
                                           untilCancelled:untilCancelledToken];
     }];
 }
 
-+(Future*) startConnectingToAll:(NSArray*)specificEndPoints
-                 untilCancelled:(id<CancelToken>)untilCancelledToken {
++(TOCFuture*) startConnectingToAll:(NSArray*)specificEndPoints
+                 untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(specificEndPoints != nil);
     
-    
     NSArray* candidates = [specificEndPoints map:^id(id<NetworkEndPoint> endPoint) {
         return [LowLatencyCandidate lowLatencyCandidateToRemoteEndPoint:endPoint];
     }];
@@ -41,10 +38,9 @@ +(Future*) startConnectingToAll:(NSArray*)specificEndPoints
         return [candidate tcpHandshakeCompleter];
     }];
 
-    Future* futureFastestCandidate = [AsyncUtil raceCancellableOperations:candidateCompleters
-                                                           untilCancelled:untilCancelledToken];
+    TOCFuture* futureFastestCandidate = [candidateCompleters toc_raceForWinnerLastingUntil:untilCancelledToken];
     
-    return [futureFastestCandidate then:^(LowLatencyCandidate* fastestCandidate) {
+    return [futureFastestCandidate thenTry:^(LowLatencyCandidate* fastestCandidate) {
         return [fastestCandidate delayedUntilAuthenticated];
     }];
 }
diff --git a/Signal/src/network/tcp/tls/NetworkStream.h b/Signal/src/network/tcp/tls/NetworkStream.h
index 02683d5480c..cb97ac43da2 100644
--- a/Signal/src/network/tcp/tls/NetworkStream.h
+++ b/Signal/src/network/tcp/tls/NetworkStream.h
@@ -1,7 +1,7 @@
 #import <Foundation/Foundation.h>
-#import "PacketHandler.h"
+#import "CollapsingFutures.h"
 #import "CyclicalBuffer.h"
-#import "FutureSource.h"
+#import "PacketHandler.h"
 #import "NetworkEndPoint.h"
 #import "Terminable.h"
 
@@ -23,8 +23,8 @@
 @private PacketHandler* rawDataHandler;
 @private bool closedLocally;
 @private CyclicalBuffer* writeBuffer;
-@private FutureSource* futureConnectedAndWritableSource;
-@private FutureSource* futureOpenedSource;
+@private TOCFutureSource* futureConnectedAndWritableSource;
+@private TOCFutureSource* futureOpenedSource;
 @private id<NetworkEndPoint> remoteEndPoint;
 @private NSRunLoop* runLoop;
 @private bool started;
@@ -32,9 +32,9 @@
 
 +(NetworkStream*) networkStreamToEndPoint:(id<NetworkEndPoint>)remoteEndPoint;
 
--(Future*) asyncConnectionCompleted;
+-(TOCFuture*) asyncConnectionCompleted;
 
--(Future*) asyncTcpHandshakeCompleted;
+-(TOCFuture*) asyncTcpHandshakeCompleted;
 
 -(void) send:(NSData*)data;
 
diff --git a/Signal/src/network/tcp/tls/NetworkStream.m b/Signal/src/network/tcp/tls/NetworkStream.m
index d333a2e3a34..381ba37cf2d 100644
--- a/Signal/src/network/tcp/tls/NetworkStream.m
+++ b/Signal/src/network/tcp/tls/NetworkStream.m
@@ -28,13 +28,13 @@ +(NetworkStream*) networkStreamToEndPoint:(id<NetworkEndPoint>)remoteEndPoint {
     s->outputStream = [streams outputStream];
     s->writeBuffer = [CyclicalBuffer new];
     s->remoteEndPoint = remoteEndPoint;
-    s->futureOpenedSource = [FutureSource new];
-    s->futureConnectedAndWritableSource = [FutureSource new];
+    s->futureOpenedSource = [TOCFutureSource new];
+    s->futureConnectedAndWritableSource = [TOCFutureSource new];
     s->runLoop = [ThreadManager normalLatencyThreadRunLoop];
     [s->inputStream scheduleInRunLoop:s->runLoop forMode:NSDefaultRunLoopMode];
     [s->outputStream scheduleInRunLoop:s->runLoop forMode:NSDefaultRunLoopMode];
     
-    [s->futureConnectedAndWritableSource catchDo:^(id error) {
+    [s->futureConnectedAndWritableSource.future catchDo:^(id error) {
         @synchronized(self) {
             [s onNetworkFailure:error];
         }
@@ -47,8 +47,8 @@ +(NetworkStream*) networkStreamToEndPoint:(id<NetworkEndPoint>)remoteEndPoint {
     return s;
 }
 
--(Future*) asyncConnectionCompleted { return futureConnectedAndWritableSource; }
--(Future*) asyncTcpHandshakeCompleted { return futureOpenedSource; }
+-(TOCFuture*) asyncConnectionCompleted { return futureConnectedAndWritableSource.future; }
+-(TOCFuture*) asyncTcpHandshakeCompleted { return futureOpenedSource.future; }
 
 -(void) terminate {
     @synchronized(self) {
@@ -69,8 +69,8 @@ -(void) send:(NSData*)data {
     }
 }
 -(void) tryWriteBufferedData {
-    if (!futureConnectedAndWritableSource.hasSucceeded) return;
-    if (![[futureConnectedAndWritableSource forceGetResult] isEqual:@YES]) return;
+    if (!futureConnectedAndWritableSource.future.hasResult) return;
+    if (![[futureConnectedAndWritableSource.future forceGetResult] isEqual:@YES]) return;
     NSStreamStatus status = [outputStream streamStatus];
     if (status < NSStreamStatusOpen) return;
     if (status >= NSStreamStatusAtEnd) {
@@ -143,17 +143,17 @@ -(void) onOpenCompleted {
 -(void) onSpaceAvailableToWrite {
     [self tryWriteBufferedData];
     
-    if (futureConnectedAndWritableSource.isCompletedOrWiredToComplete) return;
+    if (futureConnectedAndWritableSource.future.state != TOCFutureState_AbleToBeSet) return;
     
-    Future* checked = [remoteEndPoint asyncHandleStreamsConnected:[StreamPair streamPairWithInput:inputStream
-                                                                                        andOutput:outputStream]];
+    TOCFuture* checked = [remoteEndPoint asyncHandleStreamsConnected:[StreamPair streamPairWithInput:inputStream
+                                                                                           andOutput:outputStream]];
     [futureConnectedAndWritableSource trySetResult:checked];
-    [futureConnectedAndWritableSource thenDo:^(id result) {
+    [futureConnectedAndWritableSource.future thenDo:^(id result) {
         @synchronized(self) {
             [self onSpaceAvailableToWrite];
         }
     }];
-    [futureConnectedAndWritableSource catchDo:^(id error) {
+    [futureConnectedAndWritableSource.future catchDo:^(id error) {
         @synchronized(self) {
             [self onNetworkFailure:error];
         }
@@ -180,8 +180,8 @@ -(void) onErrorOccurred:(id)fallbackError {
 
 -(void) onBytesAvailableToRead {
     if (rawDataHandler == nil) return;
-    if (!futureConnectedAndWritableSource.hasSucceeded) return;
-    if (![[futureConnectedAndWritableSource forceGetResult] isEqual:@YES]) return;
+    if (!futureConnectedAndWritableSource.future.hasResult) return;
+    if (![futureConnectedAndWritableSource.future.forceGetResult isEqual:@YES]) return;
     
     while (inputStream.hasBytesAvailable) {
         NSInteger numRead = [inputStream read:[readBuffer mutableBytes] maxLength:readBuffer.length];
@@ -240,10 +240,10 @@ -(void)stream:(NSStream*)aStream handleEvent:(NSStreamEvent)event {
 -(NSString *)description {
     NSString* status = @"Not Started";
     if (started) status = @"Connecting";
-    if (futureOpenedSource.hasSucceeded) status = @"Connecting (TCP Handshake Completed)";
-    if (futureConnectedAndWritableSource.hasSucceeded) status = @"Connected";
+    if (futureOpenedSource.future.hasResult) status = @"Connecting (TCP Handshake Completed)";
+    if (futureConnectedAndWritableSource.future.hasResult) status = @"Connected";
     if (closedLocally) status = @"Closed";
-    if (futureConnectedAndWritableSource.hasFailed) status = @"Failed";
+    if (futureConnectedAndWritableSource.future.hasFailed) status = @"Failed";
     
     return [NSString stringWithFormat:@"Status: %@, RemoteEndPoint: %@",
             status,
diff --git a/Signal/src/network/tcp/tls/SecureEndPoint.m b/Signal/src/network/tcp/tls/SecureEndPoint.m
index bf75261b372..eae011b307f 100644
--- a/Signal/src/network/tcp/tls/SecureEndPoint.m
+++ b/Signal/src/network/tcp/tls/SecureEndPoint.m
@@ -74,21 +74,21 @@ -(void) authenticateSslStream:(StreamPair*)streamPair {
                            ([NSString stringWithFormat:@"NetworkStream: SecTrustEvaluate returned bad result: %u.", trustResult]));
 }
 
--(Future *)asyncHandleStreamsConnected:(StreamPair *)streamPair {
+-(TOCFuture*)asyncHandleStreamsConnected:(StreamPair *)streamPair {
     require(streamPair != nil);
     
     @try {
         [self authenticateSslStream:streamPair];
-        return [Future finished:@YES];
+        return [TOCFuture futureWithResult:@YES];
     } @catch (OperationFailed* ex) {
-        return [Future failed:ex];
+        return [TOCFuture futureWithFailure:ex];
     }
 }
 
--(Future*) asyncResolveToSpecificEndPointsUnlessCancelled:(id<CancelToken>)unlessCancelledToken {
-    Future* futureResolvedLocations = [hostNameEndPoint asyncResolveToSpecificEndPointsUnlessCancelled:unlessCancelledToken];
+-(TOCFuture*) asyncResolveToSpecificEndPointsUnlessCancelled:(TOCCancelToken*)unlessCancelledToken {
+    TOCFuture* futureResolvedLocations = [hostNameEndPoint asyncResolveToSpecificEndPointsUnlessCancelled:unlessCancelledToken];
     
-    return [futureResolvedLocations then:^(NSArray* specificEndPoints) {
+    return [futureResolvedLocations thenTry:^(NSArray* specificEndPoints) {
         return [specificEndPoints map:^(id<NetworkEndPoint> specificEndPoint) {
             return [SecureEndPoint secureEndPointForHost:hostNameEndPoint
                                  identifiedByCertificate:certificate
diff --git a/Signal/src/network/udp/UdpSocket.h b/Signal/src/network/udp/UdpSocket.h
index f75340dc4cd..f6a465ea799 100644
--- a/Signal/src/network/udp/UdpSocket.h
+++ b/Signal/src/network/udp/UdpSocket.h
@@ -38,6 +38,6 @@
 -(void) send:(NSData*)packet;
 
 -(void) startWithHandler:(PacketHandler*)handler
-          untilCancelled:(id<CancelToken>)untilCancelledToken;
+          untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 @end
diff --git a/Signal/src/network/udp/UdpSocket.m b/Signal/src/network/udp/UdpSocket.m
index f8ec82f15fd..d95f8a36c8e 100644
--- a/Signal/src/network/udp/UdpSocket.m
+++ b/Signal/src/network/udp/UdpSocket.m
@@ -154,7 +154,7 @@ -(void) setupRemoteEndPoint {
 }
 
 -(void) startWithHandler:(PacketHandler*)handler
-          untilCancelled:(id<CancelToken>)untilCancelledToken {
+          untilCancelled:(TOCCancelToken*)untilCancelledToken {
     
     require(handler != nil);
     
@@ -183,7 +183,7 @@ -(void) startWithHandler:(PacketHandler*)handler
         NSRunLoop* runLoop = [ThreadManager lowLatencyThreadRunLoop];
         CFRunLoopAddSource([runLoop getCFRunLoop], CFSocketCreateRunLoopSource(NULL, socket, 0), kCFRunLoopCommonModes);
         
-        [untilCancelledToken whenCancelled:^{
+        [untilCancelledToken whenCancelledDo:^{
             @synchronized(self) {
                 currentHandler = nil;
                 CFSocketInvalidate(socket);
diff --git a/Signal/src/phone/PhoneManager.h b/Signal/src/phone/PhoneManager.h
index d2ed4f0c6a8..70d1188fa26 100644
--- a/Signal/src/phone/PhoneManager.h
+++ b/Signal/src/phone/PhoneManager.h
@@ -1,7 +1,6 @@
 #import <Foundation/Foundation.h>
 #import "PhoneNumber.h"
 #import "InitiatorSessionDescriptor.h"
-#import "CancelTokenSource.h"
 #import "Environment.h"
 #import "Terminable.h"
 #import "Logging.h"
diff --git a/Signal/src/phone/PhoneManager.m b/Signal/src/phone/PhoneManager.m
index 45b180e58ad..da2d4f10a46 100644
--- a/Signal/src/phone/PhoneManager.m
+++ b/Signal/src/phone/PhoneManager.m
@@ -57,12 +57,12 @@ -(void) initiateOutgoingCallToRemoteNumber:(PhoneNumber*)remoteNumber withOption
                                                                          remote:remoteNumber
                                                                 optionalContact:contact];
     [callController acceptCall]; // initiator implicitly accepts call
-    id<CancelToken> lifetime = [callController untilCancelledToken];
+    TOCCancelToken* lifetime = [callController untilCancelledToken];
         
-    Future* futureConnected = [CallConnectUtil asyncInitiateCallToRemoteNumber:remoteNumber
-                                                         andCallController:callController];
+    TOCFuture* futureConnected = [CallConnectUtil asyncInitiateCallToRemoteNumber:remoteNumber
+                                                                andCallController:callController];
     
-    Future* futureCalling = [futureConnected then:^id(CallConnectResult* connectResult) {
+    TOCFuture* futureCalling = [futureConnected thenTry:^id(CallConnectResult* connectResult) {
         [callController advanceCallProgressToConversingWithShortAuthenticationString:connectResult.shortAuthenticationString];
         CallAudioManager *cam = [CallAudioManager callAudioManagerStartedWithAudioSocket:connectResult.audioSocket
                                                  andErrorHandler:[callController errorHandler]
@@ -101,12 +101,12 @@ -(void) incomingCallWithSession:(ResponderSessionDescriptor*)session {
                                                                          remote:session.initiatorNumber
                                                                 optionalContact:callingContact];
 
-    id<CancelToken> lifetime = [callController untilCancelledToken];
+    TOCCancelToken* lifetime = [callController untilCancelledToken];
     
-    Future* futureConnected = [CallConnectUtil asyncRespondToCallWithSessionDescriptor:session
-                                                                     andCallController:callController];
+    TOCFuture* futureConnected = [CallConnectUtil asyncRespondToCallWithSessionDescriptor:session
+                                                                        andCallController:callController];
     
-    Future* futureStarted = [futureConnected then:^id(CallConnectResult* connectResult) {
+    TOCFuture* futureStarted = [futureConnected thenTry:^id(CallConnectResult* connectResult) {
         [callController advanceCallProgressToConversingWithShortAuthenticationString:connectResult.shortAuthenticationString];
         CallAudioManager* cam = [CallAudioManager callAudioManagerStartedWithAudioSocket:connectResult.audioSocket
                                                  andErrorHandler:[callController errorHandler]
diff --git a/Signal/src/phone/callstate/CallController.h b/Signal/src/phone/callstate/CallController.h
index 6fe54a75396..f01c9188ca5 100644
--- a/Signal/src/phone/callstate/CallController.h
+++ b/Signal/src/phone/callstate/CallController.h
@@ -3,8 +3,6 @@
 #import "CallState.h"
 #import "CallProgress.h"
 #import "CallTermination.h"
-#import "CancelTokenSource.h"
-#import "FutureSource.h"
 #import "PacketHandler.h"
 
 /**
@@ -20,10 +18,10 @@
  */
 @interface CallController : NSObject {
 @private ObservableValueController* progress;
-@private FutureSource* termination;
-@private FutureSource* shortAuthenticationString;
-@private CancelTokenSource* canceller;
-@private FutureSource* interactiveCallAcceptedOrDenied;
+@private TOCFutureSource* termination;
+@private TOCFutureSource* shortAuthenticationString;
+@private TOCCancelTokenSource* canceller;
+@private TOCFutureSource* interactiveCallAcceptedOrDenied;
 @private bool initiatedLocally;
 @private PhoneNumber* remoteNumber;
 @private CallState* exposedCallState;
@@ -46,9 +44,9 @@
 -(void)terminateWithRejectionOrRemoteHangupAndFailureInfo:(id)failureInfo andRelatedInfo:(id)relatedInfo;
 -(BOOL)toggleMute;
 -(bool) isInitiator;
--(Future*)interactiveCallAccepted;
+-(TOCFuture*)interactiveCallAccepted;
 -(ErrorHandlerBlock)errorHandler;
--(id<CancelToken>)untilCancelledToken;
+-(TOCCancelToken*)untilCancelledToken;
 -(CallState*)callState;
 
 @end
diff --git a/Signal/src/phone/callstate/CallController.m b/Signal/src/phone/callstate/CallController.m
index fb899afb9ae..640530ffaec 100644
--- a/Signal/src/phone/callstate/CallController.m
+++ b/Signal/src/phone/callstate/CallController.m
@@ -15,20 +15,20 @@ +(CallController*) callControllerForCallInitiatedLocally:(bool)initiatedLocally
     CallController* instance = [CallController new];
     CallProgress* initialProgress = [CallProgress callProgressWithType:CallProgressType_Connecting];
     instance->progress = [ObservableValueController observableValueControllerWithInitialValue:initialProgress];
-    instance->termination = [FutureSource new];
-    instance->shortAuthenticationString = [FutureSource new];
-    instance->canceller = [CancelTokenSource cancelTokenSource];
-    instance->interactiveCallAcceptedOrDenied = [FutureSource new];
+    instance->termination = [TOCFutureSource new];
+    instance->shortAuthenticationString = [TOCFutureSource new];
+    instance->canceller = [TOCCancelTokenSource new];
+    instance->interactiveCallAcceptedOrDenied = [TOCFutureSource new];
     instance->initiatedLocally = initiatedLocally;
     instance->remoteNumber = remoteNumber;
     instance->potentiallySpecifiedContact = contact;
     instance->exposedCallState = [CallState callStateWithObservableProgress:instance->progress
-                                                       andFutureTermination:instance->termination
-                                                               andFutureSas:instance->shortAuthenticationString
+                                                       andFutureTermination:instance->termination.future
+                                                               andFutureSas:instance->shortAuthenticationString.future
                                                             andRemoteNumber:instance->remoteNumber
                                                         andInitiatedLocally:instance->initiatedLocally
                                              andPotentiallySpecifiedContact:instance->potentiallySpecifiedContact
-                                                          andFutureAccepted:instance->interactiveCallAcceptedOrDenied];
+                                                          andFutureAccepted:instance->interactiveCallAcceptedOrDenied.future];
     
     return instance;
 }
@@ -59,20 +59,20 @@ -(ErrorHandlerBlock) errorHandler {
         [Environment errorNoter](error, relatedInfo, causedTermination);
     };
 }
--(id<CancelToken>) untilCancelledToken {
-    return [canceller getToken];
+-(TOCCancelToken*) untilCancelledToken {
+    return canceller.token;
 }
--(Future *)interactiveCallAccepted {
-    return [interactiveCallAcceptedOrDenied then:^id(NSNumber* accepted) {
+-(TOCFuture*)interactiveCallAccepted {
+    return [interactiveCallAcceptedOrDenied.future thenTry:^id(NSNumber* accepted) {
         if ([accepted boolValue]) return accepted;
         
-        return [Future failed:[CallTermination callTerminationOfType:CallTerminationType_RejectedLocal
+        return [TOCFuture futureWithFailure:[CallTermination callTerminationOfType:CallTerminationType_RejectedLocal
                                                          withFailure:accepted
                                                       andMessageInfo:nil]];
     }];
 }
--(Future *)interactiveCallAcceptedOrDenied {
-    return interactiveCallAcceptedOrDenied;
+-(TOCFuture*)interactiveCallAcceptedOrDenied {
+    return interactiveCallAcceptedOrDenied.future;
 }
 -(CallState*) callState {
     return exposedCallState;
@@ -150,6 +150,6 @@ -(void) enableBackground {
         }else if(CallProgressType_Terminated == latestProgress.type){
             [UIApplication.sharedApplication endBackgroundTask:backgroundtask];
         }
-    } untilCancelled:canceller.getToken];
+    } untilCancelled:canceller.token];
 }
 @end
diff --git a/Signal/src/phone/callstate/CallState.h b/Signal/src/phone/callstate/CallState.h
index d8d340d1fe9..a8adb3d390f 100644
--- a/Signal/src/phone/callstate/CallState.h
+++ b/Signal/src/phone/callstate/CallState.h
@@ -19,19 +19,19 @@
 @interface CallState : NSObject
 
 @property (nonatomic, readonly) ObservableValue* observableProgress;
-@property (nonatomic, readonly) Future* futureTermination;
-@property (nonatomic, readonly) Future* futureShortAuthenticationString;
+@property (nonatomic, readonly) TOCFuture* futureTermination;
+@property (nonatomic, readonly) TOCFuture* futureShortAuthenticationString;
 @property (nonatomic, readonly) PhoneNumber* remoteNumber;
 @property (nonatomic, readonly) bool initiatedLocally;
 @property (nonatomic, readonly) Contact* potentiallySpecifiedContact;
-@property (nonatomic, readonly) Future* futureCallLocallyAcceptedOrRejected;
+@property (nonatomic, readonly) TOCFuture* futureCallLocallyAcceptedOrRejected;
 
 +(CallState*) callStateWithObservableProgress:(ObservableValue*)observableProgress
-                         andFutureTermination:(Future*)futureTermination
-                                 andFutureSas:(Future*)futureSas
+                         andFutureTermination:(TOCFuture*)futureTermination
+                                 andFutureSas:(TOCFuture*)futureSas
                               andRemoteNumber:(PhoneNumber*)remoteNumber
                           andInitiatedLocally:(bool)initiatedLocally
                andPotentiallySpecifiedContact:(Contact*)contact
-                            andFutureAccepted:(Future*)futureCallLocallyAcceptedOrRejected;
+                            andFutureAccepted:(TOCFuture*)futureCallLocallyAcceptedOrRejected;
 
 @end
diff --git a/Signal/src/phone/callstate/CallState.m b/Signal/src/phone/callstate/CallState.m
index 43e1b50b910..2e0ca7c1766 100644
--- a/Signal/src/phone/callstate/CallState.m
+++ b/Signal/src/phone/callstate/CallState.m
@@ -12,12 +12,12 @@ @implementation CallState
 @synthesize futureCallLocallyAcceptedOrRejected;
 
 +(CallState*) callStateWithObservableProgress:(ObservableValue*)observableProgress
-                         andFutureTermination:(Future*)futureTermination
-                                 andFutureSas:(Future*)futureSas
+                         andFutureTermination:(TOCFuture*)futureTermination
+                                 andFutureSas:(TOCFuture*)futureSas
                               andRemoteNumber:(PhoneNumber*)remoteNumber
                           andInitiatedLocally:(bool)initiatedLocally
                andPotentiallySpecifiedContact:(Contact*)contact
-                            andFutureAccepted:(Future*)futureCallLocallyAcceptedOrRejected {
+                            andFutureAccepted:(TOCFuture*)futureCallLocallyAcceptedOrRejected {
 
     require(observableProgress != nil);
     require(futureTermination != nil);
@@ -27,8 +27,8 @@ +(CallState*) callStateWithObservableProgress:(ObservableValue*)observableProgre
     
     CallState* call = [CallState new];
     call->observableProgress = observableProgress;
-    call->futureTermination = [futureTermination thenCompleteOnMainThread];
-    call->futureShortAuthenticationString = [futureSas thenCompleteOnMainThread];
+    call->futureTermination = futureTermination;
+    call->futureShortAuthenticationString = futureSas;
     call->remoteNumber = remoteNumber;
     call->initiatedLocally = initiatedLocally;
     call->potentiallySpecifiedContact = contact;
diff --git a/Signal/src/phone/signaling/CallConnectUtil.h b/Signal/src/phone/signaling/CallConnectUtil.h
index 868c5b8d843..94705ffd256 100644
--- a/Signal/src/phone/signaling/CallConnectUtil.h
+++ b/Signal/src/phone/signaling/CallConnectUtil.h
@@ -16,14 +16,14 @@
 @interface CallConnectUtil : NSObject
 
 /// Result has type Future(CallConnectResult)
-+(Future*) asyncInitiateCallToRemoteNumber:(PhoneNumber*)remoteNumber
-                         andCallController:(CallController*)callController;
++(TOCFuture*) asyncInitiateCallToRemoteNumber:(PhoneNumber*)remoteNumber
+                            andCallController:(CallController*)callController;
 
 /// Result has type Future(CallConnectResult)
-+(Future*) asyncRespondToCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
-                                 andCallController:(CallController*)callController;
++(TOCFuture*) asyncRespondToCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
+                                    andCallController:(CallController*)callController;
 
 /// Result has type Future(HttpResponse)
-+(Future*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor;
++(TOCFuture*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor;
 
 @end
diff --git a/Signal/src/phone/signaling/CallConnectUtil.m b/Signal/src/phone/signaling/CallConnectUtil.m
index b056a6588e2..9d184afcae9 100644
--- a/Signal/src/phone/signaling/CallConnectUtil.m
+++ b/Signal/src/phone/signaling/CallConnectUtil.m
@@ -6,23 +6,23 @@
 
 @implementation CallConnectUtil
 
-+(Future*) asyncInitiateCallToRemoteNumber:(PhoneNumber *)remoteNumber
-                         andCallController:(CallController*)callController {
++(TOCFuture*) asyncInitiateCallToRemoteNumber:(PhoneNumber *)remoteNumber
+                            andCallController:(CallController*)callController {
     require(remoteNumber != nil);
     require(callController != nil);
     return [CallConnectUtil_Initiator asyncConnectCallToRemoteNumber:remoteNumber
                                                   withCallController:callController];
 }
 
-+(Future*) asyncRespondToCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
-                                 andCallController:(CallController*)callController {
++(TOCFuture*) asyncRespondToCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
+                                    andCallController:(CallController*)callController {
     require(sessionDescriptor != nil);
     require(callController != nil);
     return [CallConnectUtil_Responder asyncConnectToIncomingCallWithSessionDescriptor:sessionDescriptor
                                                                   andCallController:callController];
 }
 
-+(Future*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor {
++(TOCFuture*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor {
     require(sessionDescriptor != nil);
     return [CallConnectUtil_Responder asyncSignalTooBusyToAnswerCallWithSessionDescriptor:sessionDescriptor];
 }
diff --git a/Signal/src/phone/signaling/CallConnectUtil_Initiator.h b/Signal/src/phone/signaling/CallConnectUtil_Initiator.h
index e74da2932de..6ab855cc327 100644
--- a/Signal/src/phone/signaling/CallConnectUtil_Initiator.h
+++ b/Signal/src/phone/signaling/CallConnectUtil_Initiator.h
@@ -17,8 +17,8 @@
 @interface CallConnectUtil_Initiator : NSObject
 
 /// Result has type Future*(CallConnectResult)
-+(Future*) asyncConnectCallToRemoteNumber:(PhoneNumber*)remoteNumber
-                       withCallController:(CallController*)callController;
++(TOCFuture*) asyncConnectCallToRemoteNumber:(PhoneNumber*)remoteNumber
+                          withCallController:(CallController*)callController;
 
 @end
 
diff --git a/Signal/src/phone/signaling/CallConnectUtil_Initiator.m b/Signal/src/phone/signaling/CallConnectUtil_Initiator.m
index d77ddea0854..e4f0c255008 100644
--- a/Signal/src/phone/signaling/CallConnectUtil_Initiator.m
+++ b/Signal/src/phone/signaling/CallConnectUtil_Initiator.m
@@ -10,35 +10,35 @@
 
 @implementation CallConnectUtil_Initiator
 
-+(Future*) asyncConnectCallToRemoteNumber:(PhoneNumber*)remoteNumber
++(TOCFuture*) asyncConnectCallToRemoteNumber:(PhoneNumber*)remoteNumber
                        withCallController:(CallController*)callController {
     
     require(remoteNumber != nil);
     require(callController != nil);
     require(callController.isInitiator);
     
-    Future* futureInitiatorSessionDescriptor = [self asyncConnectToSignalServerAndGetInitiatorSessionDescriptorWithCallController:callController];
+    TOCFuture* futureInitiatorSessionDescriptor = [self asyncConnectToSignalServerAndGetInitiatorSessionDescriptorWithCallController:callController];
     
-    return [futureInitiatorSessionDescriptor then:^(InitiatorSessionDescriptor* session) {
+    return [futureInitiatorSessionDescriptor thenTry:^(InitiatorSessionDescriptor* session) {
         return [CallConnectUtil_Server asyncConnectCallOverRelayDescribedInInitiatorSessionDescriptor:session
                                                                                    withCallController:callController
                                                                                     andInteropOptions:@[]];
     }];
 }
 
-+(Future*) asyncConnectToSignalServerAndGetInitiatorSessionDescriptorWithCallController:(CallController*)callController {
++(TOCFuture*) asyncConnectToSignalServerAndGetInitiatorSessionDescriptorWithCallController:(CallController*)callController {
     require(callController != nil);
     
-    Future* futureSignalConnection = [CallConnectUtil_Server asyncConnectToDefaultSignalingServerUntilCancelled:[callController untilCancelledToken]];
+    TOCFuture* futureSignalConnection = [CallConnectUtil_Server asyncConnectToDefaultSignalingServerUntilCancelled:callController.untilCancelledToken];
     
-    return [futureSignalConnection then:^(HttpManager* httpManager) {
+    return [futureSignalConnection thenTry:^(HttpManager* httpManager) {
         requireState([httpManager isKindOfClass:[HttpManager class]]);
         
-        FutureSource* predeclaredFutureSession = [FutureSource new];
+        TOCFutureSource* predeclaredFutureSession = [TOCFutureSource new];
         
         HttpResponse*(^serverRequestHandler)(HttpRequest*) = ^(HttpRequest* remoteRequest) {
             return [self respondToServerRequest:remoteRequest
-                        usingEventualDescriptor:predeclaredFutureSession
+                        usingEventualDescriptor:predeclaredFutureSession.future
                               andCallController:callController];
         };
         
@@ -47,19 +47,19 @@ +(Future*) asyncConnectToSignalServerAndGetInitiatorSessionDescriptorWithCallCon
                               untilCancelled:[callController untilCancelledToken]];
         
         HttpRequest* initiateRequest = [HttpRequest httpRequestToInitiateToRemoteNumber:[callController callState].remoteNumber];
-        Future* futureResponseToInitiate = [httpManager asyncOkResponseForRequest:initiateRequest
-                                                                  unlessCancelled:[callController untilCancelledToken]];
-        Future* futureResponseToInitiateWithInterpretedFailures = [futureResponseToInitiate catch:^(id error) {
+        TOCFuture* futureResponseToInitiate = [httpManager asyncOkResponseForRequest:initiateRequest
+                                                                     unlessCancelled:[callController untilCancelledToken]];
+        TOCFuture* futureResponseToInitiateWithInterpretedFailures = [futureResponseToInitiate catchTry:^(id error) {
             if ([error isKindOfClass:[HttpResponse class]]) {
                 HttpResponse* badResponse = error;
-                return [Future failed:[self callTerminationForBadResponse:badResponse
-                                                        toInitiateRequest:initiateRequest]];
+                return [TOCFuture futureWithFailure:[self callTerminationForBadResponse:badResponse
+                                                                      toInitiateRequest:initiateRequest]];
             }
             
-            return [Future failed:error];
+            return [TOCFuture futureWithFailure:error];
         }];
         
-        Future* futureSession = [futureResponseToInitiateWithInterpretedFailures then:^(HttpResponse* response) {
+        TOCFuture* futureSession = [futureResponseToInitiateWithInterpretedFailures thenTry:^(HttpResponse* response) {
             return [InitiatorSessionDescriptor initiatorSessionDescriptorFromJson:[response getOptionalBodyText]];
         }];
         [predeclaredFutureSession trySetResult:futureSession];
@@ -94,7 +94,7 @@ +(CallTermination*) callTerminationForBadResponse:(HttpResponse*)badResponse
 }
 
 +(HttpResponse*) respondToServerRequest:(HttpRequest*)request
-                usingEventualDescriptor:(Future*)futureInitiatorSessionDescriptor
+                usingEventualDescriptor:(TOCFuture*)futureInitiatorSessionDescriptor
                       andCallController:(CallController*)callController {
     require(request != nil);
     require(futureInitiatorSessionDescriptor != nil);
@@ -106,7 +106,7 @@ +(HttpResponse*) respondToServerRequest:(HttpRequest*)request
     }
     
     // too soon?
-    if (!futureInitiatorSessionDescriptor.hasSucceeded) {
+    if (!futureInitiatorSessionDescriptor.hasResult) {
         [callController terminateWithReason:CallTerminationType_BadInteractionWithServer
                             withFailureInfo:[IgnoredPacketFailure new:@"Didn't receive session id from signaling server. Not able to understand request."]
                              andRelatedInfo:request];
diff --git a/Signal/src/phone/signaling/CallConnectUtil_Responder.h b/Signal/src/phone/signaling/CallConnectUtil_Responder.h
index 96c2861c4ac..d087c97acb7 100644
--- a/Signal/src/phone/signaling/CallConnectUtil_Responder.h
+++ b/Signal/src/phone/signaling/CallConnectUtil_Responder.h
@@ -17,10 +17,10 @@
 @interface CallConnectUtil_Responder : NSObject
 
 /// Result has type Future(CallConnectResult)
-+(Future*) asyncConnectToIncomingCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
-                                         andCallController:(CallController*)callController;
++(TOCFuture*) asyncConnectToIncomingCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
+                                            andCallController:(CallController*)callController;
 
 /// Result has type Future(HttpResponse)
-+(Future*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor;
++(TOCFuture*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor;
 
 @end
diff --git a/Signal/src/phone/signaling/CallConnectUtil_Responder.m b/Signal/src/phone/signaling/CallConnectUtil_Responder.m
index 8e72ca4260e..c2511408c8e 100644
--- a/Signal/src/phone/signaling/CallConnectUtil_Responder.m
+++ b/Signal/src/phone/signaling/CallConnectUtil_Responder.m
@@ -9,37 +9,37 @@
 
 @implementation CallConnectUtil_Responder
 
-+(Future*) asyncConnectToIncomingCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
-                                         andCallController:(CallController*)callController {
++(TOCFuture*) asyncConnectToIncomingCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor
+                                            andCallController:(CallController*)callController {
     
     require(sessionDescriptor != nil);
     require(callController != nil);
     require(!callController.isInitiator);
     
-    Future* futureSignalsAreGo = [self asyncConnectToSignalServerDescribedBy:sessionDescriptor
-                                                          withCallController:callController];
+    TOCFuture* futureSignalsAreGo = [self asyncConnectToSignalServerDescribedBy:sessionDescriptor
+                                                             withCallController:callController];
     
-    Future* futureSignalsAreGoAndCallAccepted = [futureSignalsAreGo then:^(id _) {
+    TOCFuture* futureSignalsAreGoAndCallAccepted = [futureSignalsAreGo thenTry:^(id _) {
         [callController advanceCallProgressTo:CallProgressType_Ringing];
         
         return [callController interactiveCallAccepted];
     }];
     
-    return [futureSignalsAreGoAndCallAccepted then:^(id _) {
+    return [futureSignalsAreGoAndCallAccepted thenTry:^(id _) {
         return [CallConnectUtil_Server asyncConnectCallOverRelayDescribedInResponderSessionDescriptor:sessionDescriptor
                                                                                    withCallController:callController];
     }];
 }
 
-+(Future*) asyncConnectToSignalServerDescribedBy:(ResponderSessionDescriptor*)sessionDescriptor
++(TOCFuture*) asyncConnectToSignalServerDescribedBy:(ResponderSessionDescriptor*)sessionDescriptor
                               withCallController:(CallController*)callController {
     require(sessionDescriptor != nil);
     require(callController != nil);
     
-    Future* futureSignalConnection = [CallConnectUtil_Server asyncConnectToSignalingServerNamed:sessionDescriptor.relayServerName
-                                                                                 untilCancelled:[callController untilCancelledToken]];
+    TOCFuture* futureSignalConnection = [CallConnectUtil_Server asyncConnectToSignalingServerNamed:sessionDescriptor.relayServerName
+                                                                                    untilCancelled:[callController untilCancelledToken]];
     
-    return [futureSignalConnection then:^id(HttpManager* httpManager) {
+    return [futureSignalConnection thenTry:^id(HttpManager* httpManager) {
         require([httpManager isKindOfClass:[httpManager class]]);
         
         HttpResponse*(^serverRequestHandler)(HttpRequest*) = ^(HttpRequest* remoteRequest) {
@@ -53,21 +53,19 @@ +(Future*) asyncConnectToSignalServerDescribedBy:(ResponderSessionDescriptor*)se
                               untilCancelled:[callController untilCancelledToken]];
         
         HttpRequest* ringRequest = [HttpRequest httpRequestToRingWithSessionId:sessionDescriptor.sessionId];
-        Future* futureResponseToRing = [httpManager asyncOkResponseForRequest:ringRequest
+        TOCFuture* futureResponseToRing = [httpManager asyncOkResponseForRequest:ringRequest
                                                               unlessCancelled:[callController untilCancelledToken]];
-        Future* futureResponseToRingWithInterpretedFailures = [futureResponseToRing catch:^(id error) {
+        TOCFuture* futureResponseToRingWithInterpretedFailures = [futureResponseToRing catchTry:^(id error) {
             if ([error isKindOfClass:[HttpResponse class]]) {
                 HttpResponse* badResponse = error;
-                return [Future failed:[self callTerminationForBadResponse:badResponse
-                                                            toRingRequest:ringRequest]];
+                return [TOCFuture futureWithFailure:[self callTerminationForBadResponse:badResponse
+                                                                          toRingRequest:ringRequest]];
             }
             
-            return [Future failed:error];
+            return [TOCFuture futureWithFailure:error];
         }];
         
-        return [futureResponseToRingWithInterpretedFailures then:^(id _) {
-            return @YES;
-        }];
+        return [futureResponseToRingWithInterpretedFailures thenValue:@YES];
     }];
 }
 
@@ -118,7 +116,7 @@ +(HttpResponse*) respondToServerRequest:(HttpRequest*)request
     return [HttpResponse httpResponse501NotImplemented];
 }
 
-+(Future*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor {
++(TOCFuture*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSessionDescriptor*)sessionDescriptor {
     require(sessionDescriptor != nil);
     
     HttpRequest* busyRequest = [HttpRequest httpRequestToSignalBusyWithSessionId:sessionDescriptor.sessionId];
@@ -129,9 +127,9 @@ +(Future*) asyncSignalTooBusyToAnswerCallWithSessionDescriptor:(ResponderSession
                     andErrorHandler:[Environment errorNoter]];
 }
 
-+(Future*) asyncOkResponseFor:(HttpRequest*)request
++(TOCFuture*) asyncOkResponseFor:(HttpRequest*)request
      fromSignalingServerNamed:(NSString*)name
-              unlessCancelled:(id<CancelToken>)unlessCancelledToken
+              unlessCancelled:(TOCCancelToken*)unlessCancelledToken
               andErrorHandler:(ErrorHandlerBlock)errorHandler {
     require(request != nil);
     require(errorHandler != nil);
@@ -143,8 +141,8 @@ +(Future*) asyncOkResponseFor:(HttpRequest*)request
     [manager startWithRejectingRequestHandlerAndErrorHandler:errorHandler
                                               untilCancelled:nil];
     
-    Future* result = [manager asyncOkResponseForRequest:request
-                                        unlessCancelled:unlessCancelledToken];
+    TOCFuture* result = [manager asyncOkResponseForRequest:request
+                                           unlessCancelled:unlessCancelledToken];
     
     [manager terminateWhenDoneCurrentWork];
     
diff --git a/Signal/src/phone/signaling/CallConnectUtil_Server.h b/Signal/src/phone/signaling/CallConnectUtil_Server.h
index f277af6bb66..2db721c506c 100644
--- a/Signal/src/phone/signaling/CallConnectUtil_Server.h
+++ b/Signal/src/phone/signaling/CallConnectUtil_Server.h
@@ -11,19 +11,19 @@
 @interface CallConnectUtil_Server : NSObject
 
 /// Result has type Future(HttpManager)
-+(Future*) asyncConnectToDefaultSignalingServerUntilCancelled:(id<CancelToken>)untilCancelledToken;
++(TOCFuture*) asyncConnectToDefaultSignalingServerUntilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 /// Result has type Future(HttpManager)
-+(Future*) asyncConnectToSignalingServerNamed:(NSString*)name
-                               untilCancelled:(id<CancelToken>)untilCancelledToken;
++(TOCFuture*) asyncConnectToSignalingServerNamed:(NSString*)name
+                                  untilCancelled:(TOCCancelToken*)untilCancelledToken;
 
 /// Result has type Future(CallConnectResult)
-+(Future*) asyncConnectCallOverRelayDescribedInResponderSessionDescriptor:(ResponderSessionDescriptor*)session
-                                                       withCallController:(CallController*)callController;
++(TOCFuture*) asyncConnectCallOverRelayDescribedInResponderSessionDescriptor:(ResponderSessionDescriptor*)session
+                                                          withCallController:(CallController*)callController;
 
 /// Result has type Future(CallConnectResult)
-+(Future*) asyncConnectCallOverRelayDescribedInInitiatorSessionDescriptor:(InitiatorSessionDescriptor*)session
-                                                       withCallController:(CallController*)callController
-                                                        andInteropOptions:(NSArray*)interopOptions;
++(TOCFuture*) asyncConnectCallOverRelayDescribedInInitiatorSessionDescriptor:(InitiatorSessionDescriptor*)session
+                                                          withCallController:(CallController*)callController
+                                                           andInteropOptions:(NSArray*)interopOptions;
 
 @end
diff --git a/Signal/src/phone/signaling/CallConnectUtil_Server.m b/Signal/src/phone/signaling/CallConnectUtil_Server.m
index 7ae291b6d78..9cac35769c8 100644
--- a/Signal/src/phone/signaling/CallConnectUtil_Server.m
+++ b/Signal/src/phone/signaling/CallConnectUtil_Server.m
@@ -16,26 +16,26 @@
 
 @implementation CallConnectUtil_Server
 
-+(Future*) asyncConnectToDefaultSignalingServerUntilCancelled:(id<CancelToken>)untilCancelledToken {
++(TOCFuture*) asyncConnectToDefaultSignalingServerUntilCancelled:(TOCCancelToken*)untilCancelledToken {
     return [self asyncConnectToSignalingServerAt:[Environment getSecureEndPointToDefaultRelayServer]
                                   untilCancelled:untilCancelledToken];
 }
 
-+(Future*) asyncConnectToSignalingServerNamed:(NSString*)name
-                               untilCancelled:(id<CancelToken>)untilCancelledToken {
++(TOCFuture*) asyncConnectToSignalingServerNamed:(NSString*)name
+                               untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(name != nil);
     return [self asyncConnectToSignalingServerAt:[Environment getSecureEndPointToSignalingServerNamed:name]
                                   untilCancelled:untilCancelledToken];
 }
 
-+(Future*) asyncConnectToSignalingServerAt:(SecureEndPoint*)location
-                            untilCancelled:(id<CancelToken>)untilCancelledToken {
++(TOCFuture*) asyncConnectToSignalingServerAt:(SecureEndPoint*)location
+                            untilCancelled:(TOCCancelToken*)untilCancelledToken {
     require(location != nil);
     
-    Future* futureConnection = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:location
-                                                                      untilCancelled:untilCancelledToken];
+    TOCFuture* futureConnection = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:location
+                                                                         untilCancelled:untilCancelledToken];
     
-    return [futureConnection then:^(LowLatencyCandidate* result) {
+    return [futureConnection thenTry:^(LowLatencyCandidate* result) {
         HttpSocket* httpSocket = [HttpSocket httpSocketOver:[result networkStream]];
         return [HttpManager httpManagerFor:httpSocket
                             untilCancelled:untilCancelledToken];
@@ -43,7 +43,7 @@ +(Future*) asyncConnectToSignalingServerAt:(SecureEndPoint*)location
 }
 
 
-+(Future*) asyncConnectCallOverRelayDescribedInResponderSessionDescriptor:(ResponderSessionDescriptor*)session
++(TOCFuture*) asyncConnectCallOverRelayDescribedInResponderSessionDescriptor:(ResponderSessionDescriptor*)session
                                                        withCallController:(CallController*)callController {
     require(session != nil);
     require(callController != nil);
@@ -62,21 +62,21 @@ +(Future*) asyncConnectCallOverRelayDescribedInResponderSessionDescriptor:(Respo
                                                               andInteropOptions:interopOptions];
 }
 
-+(Future*) asyncConnectCallOverRelayDescribedInInitiatorSessionDescriptor:(InitiatorSessionDescriptor*)session
++(TOCFuture*) asyncConnectCallOverRelayDescribedInInitiatorSessionDescriptor:(InitiatorSessionDescriptor*)session
                                                        withCallController:(CallController*)callController
                                                         andInteropOptions:(NSArray*)interopOptions {
     require(session != nil);
     require(callController != nil);
     
-    Future* futureUdpSocket = [self asyncRepeatedlyAttemptConnectToUdpRelayDescribedBy:session
-                                                                    withCallController:callController];
+    TOCFuture* futureUdpSocket = [self asyncRepeatedlyAttemptConnectToUdpRelayDescribedBy:session
+                                                                       withCallController:callController];
     
-    Future* futureZrtpHandshakeResult = [futureUdpSocket then:^(UdpSocket* udpSocket) {
+    TOCFuture* futureZrtpHandshakeResult = [futureUdpSocket thenTry:^(UdpSocket* udpSocket) {
         return [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:udpSocket interopOptions:interopOptions]
                                     andCallController:callController];
     }];
     
-    return [futureZrtpHandshakeResult then:^(ZrtpHandshakeResult* zrtpResult) {
+    return [futureZrtpHandshakeResult thenTry:^(ZrtpHandshakeResult* zrtpResult) {
         AudioSocket* audioSocket = [AudioSocket audioSocketOver:[zrtpResult secureRtpSocket]];
         
         NSString* sas = [[zrtpResult masterSecret] shortAuthenticationString];
@@ -86,44 +86,44 @@ +(Future*) asyncConnectCallOverRelayDescribedInInitiatorSessionDescriptor:(Initi
     }];
 }
 
-+(Future*) asyncRepeatedlyAttemptConnectToUdpRelayDescribedBy:(InitiatorSessionDescriptor*)sessionDescriptor
++(TOCFuture*) asyncRepeatedlyAttemptConnectToUdpRelayDescribedBy:(InitiatorSessionDescriptor*)sessionDescriptor
                                            withCallController:(CallController*)callController {
     
     require(sessionDescriptor != nil);
     require(callController != nil);
     
-    CancellableOperationStarter operation = ^(id<CancelToken> internalUntilCancelledToken) {
+    TOCUntilOperation operation = ^(TOCCancelToken* internalUntilCancelledToken) {
         return [self asyncAttemptResolveThenConnectToUdpRelayDescribedBy:sessionDescriptor
                                                           untilCancelled:internalUntilCancelledToken
                                                         withErrorHandler:[callController errorHandler]];
     };
     
-    Future* futureRelayedUdpSocket = [AsyncUtil asyncTry:operation
+    TOCFuture* futureRelayedUdpSocket = [TOCFuture retry:[TOCFuture operationTry:operation]
                                               upToNTimes:MAX_TRY_COUNT
                                          withBaseTimeout:BASE_TIMEOUT_SECONDS
                                           andRetryFactor:RETRY_TIMEOUT_FACTOR
                                           untilCancelled:[callController untilCancelledToken]];
     
-    return [futureRelayedUdpSocket catch:^(id error) {
-        return [Future failed:[CallTermination callTerminationOfType:CallTerminationType_BadInteractionWithServer
-                                                         withFailure:error
-                                                      andMessageInfo:@"Timed out on all attempts to contact relay."]];
+    return [futureRelayedUdpSocket catchTry:^(id error) {
+        return [TOCFuture futureWithFailure:[CallTermination callTerminationOfType:CallTerminationType_BadInteractionWithServer
+                                                                       withFailure:error
+                                                                    andMessageInfo:@"Timed out on all attempts to contact relay."]];
     }];
 }
 
-+(Future*) asyncAttemptResolveThenConnectToUdpRelayDescribedBy:(InitiatorSessionDescriptor*)sessionDescriptor
-                                                untilCancelled:(id<CancelToken>)untilCancelledToken
-                                              withErrorHandler:(ErrorHandlerBlock)errorHandler {
++(TOCFuture*) asyncAttemptResolveThenConnectToUdpRelayDescribedBy:(InitiatorSessionDescriptor*)sessionDescriptor
+                                                   untilCancelled:(TOCCancelToken*)untilCancelledToken
+                                                 withErrorHandler:(ErrorHandlerBlock)errorHandler {
     
     require(sessionDescriptor != nil);
     require(errorHandler != nil);
     
     NSString* domain = [Environment relayServerNameToHostName:[sessionDescriptor relayServerName]];
     
-    Future* futureDnsResult = [DnsManager asyncQueryAddressesForDomainName:domain
-                                                           unlessCancelled:untilCancelledToken];
+    TOCFuture* futureDnsResult = [DnsManager asyncQueryAddressesForDomainName:domain
+                                                              unlessCancelled:untilCancelledToken];
     
-    Future* futureEndPoint = [futureDnsResult then:^(NSArray* ipAddresses) {
+    TOCFuture* futureEndPoint = [futureDnsResult thenTry:^(NSArray* ipAddresses) {
         require(ipAddresses.count > 0);
         
         IpAddress* address = ipAddresses[arc4random_uniform((unsigned int)ipAddresses.count)];
@@ -131,17 +131,17 @@ +(Future*) asyncAttemptResolveThenConnectToUdpRelayDescribedBy:(InitiatorSession
                                         onPort:sessionDescriptor.relayUdpPort];
     }];
     
-    return [futureEndPoint then:^(IpEndPoint* remote) {
+    return [futureEndPoint thenTry:^(IpEndPoint* remote) {
         return [self asyncAttemptConnectToUdpRelayDescribedBy:remote
-                                                 withSessionId:sessionDescriptor.sessionId
+                                                withSessionId:sessionDescriptor.sessionId
                                                untilCancelled:untilCancelledToken
                                              withErrorHandler:errorHandler];
     }];
 }
 
-+(Future*) asyncAttemptConnectToUdpRelayDescribedBy:(IpEndPoint*)remoteEndPoint
++(TOCFuture*) asyncAttemptConnectToUdpRelayDescribedBy:(IpEndPoint*)remoteEndPoint
                                       withSessionId:(int64_t)sessionId
-                                     untilCancelled:(id<CancelToken>)untilCancelledToken
+                                     untilCancelled:(TOCCancelToken*)untilCancelledToken
                                    withErrorHandler:(ErrorHandlerBlock)errorHandler {
     
     require(remoteEndPoint != nil);
@@ -151,14 +151,14 @@ +(Future*) asyncAttemptConnectToUdpRelayDescribedBy:(IpEndPoint*)remoteEndPoint
     
     id<OccurrenceLogger> logger = [[Environment logging] getOccurrenceLoggerForSender:self withKey:@"relay setup"];
     
-    Future* futureFirstResponseData = [self asyncFirstPacketReceivedAfterStartingSocket:udpSocket
-                                                                         untilCancelled:untilCancelledToken
-                                                                       withErrorHandler:errorHandler];
+    TOCFuture* futureFirstResponseData = [self asyncFirstPacketReceivedAfterStartingSocket:udpSocket
+                                                                            untilCancelled:untilCancelledToken
+                                                                          withErrorHandler:errorHandler];
     
-    Future* futureRelaySocket = [futureFirstResponseData then:^id(NSData* openPortResponseData) {
+    TOCFuture* futureRelaySocket = [futureFirstResponseData thenTry:^id(NSData* openPortResponseData) {
         HttpResponse* openPortResponse = [HttpResponse httpResponseFromData:openPortResponseData];
         [logger markOccurrence:openPortResponse];
-        if (!openPortResponse.isOkResponse) return [Future failed:openPortResponse];
+        if (!openPortResponse.isOkResponse) return [TOCFuture futureWithFailure:openPortResponse];
         
         return udpSocket;
     }];
@@ -170,16 +170,14 @@ +(Future*) asyncAttemptConnectToUdpRelayDescribedBy:(IpEndPoint*)remoteEndPoint
     return futureRelaySocket;
 }
 
-+(Future*) asyncFirstPacketReceivedAfterStartingSocket:(UdpSocket*)udpSocket
-                                        untilCancelled:(id<CancelToken>)untilCancelledToken
++(TOCFuture*) asyncFirstPacketReceivedAfterStartingSocket:(UdpSocket*)udpSocket
+                                        untilCancelled:(TOCCancelToken*)untilCancelledToken
                                       withErrorHandler:(ErrorHandlerBlock)errorHandler {
     
     require(udpSocket != nil);
     require(errorHandler != nil);
     
-    FutureSource* futureResultSource = [FutureSource new];
-    
-    [untilCancelledToken whenCancelledTryCancel:futureResultSource];
+    TOCFutureSource* futureResultSource = [TOCFutureSource futureSourceUntil:untilCancelledToken];
     
     PacketHandlerBlock packetHandler = ^(id packet) {
         if (![futureResultSource trySetResult:packet]) {;
@@ -196,7 +194,7 @@ +(Future*) asyncFirstPacketReceivedAfterStartingSocket:(UdpSocket*)udpSocket
                                             withErrorHandler:socketErrorHandler]
                  untilCancelled:untilCancelledToken];
     
-    return futureResultSource;
+    return futureResultSource.future;
 }
 
 @end
diff --git a/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.h b/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.h
index fdf3d47a0d2..06a146a3654 100644
--- a/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.h	
+++ b/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.h	
@@ -1,6 +1,6 @@
 #import <Foundation/Foundation.h>
-#import "SignalUtil.h"
-#import "CancelToken.h"
+#import "CollapsingFutures.h"
+#import "PhoneNumberDirectoryFilter.h"
 
 /**
  *
@@ -10,11 +10,11 @@
  */
 @interface PhoneNumberDirectoryFilterManager : NSObject {
 @private PhoneNumberDirectoryFilter* phoneNumberDirectoryFilter;
-@private id<CancelToken> lifetimeToken;
+@private TOCCancelToken* lifetimeToken;
 }
 
 -(void) forceUpdate;
--(void) startUntilCancelled:(id<CancelToken>)cancelToken;
+-(void) startUntilCancelled:(TOCCancelToken*)cancelToken;
 -(PhoneNumberDirectoryFilter*) getCurrentFilter;
 
 @end
diff --git a/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.m b/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.m
index 7cf2821fafa..e38d941b921 100644
--- a/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.m	
+++ b/Signal/src/phone/signaling/number directory/PhoneNumberDirectoryFilterManager.m	
@@ -1,9 +1,11 @@
 #import "PhoneNumberDirectoryFilterManager.h"
+
 #import "Environment.h"
+#import "NotificationManifest.h"
 #import "PreferencesUtil.h"
+#import "SignalUtil.h"
 #import "ThreadManager.h"
 #import "Util.h"
-#import "NotificationManifest.h"
 
 #define MINUTE (60.0)
 #define HOUR (MINUTE*60.0)
@@ -12,7 +14,7 @@
 #define DIRECTORY_UPDATE_RETRY_PERIOD (1.0*HOUR)
 
 @implementation PhoneNumberDirectoryFilterManager {
-@private CancelTokenSource* currentUpdateLifetime;
+@private TOCCancelTokenSource* currentUpdateLifetime;
 }
 
 -(id) init {
@@ -21,7 +23,7 @@ -(id) init {
 	}
 	return self;
 }
--(void) startUntilCancelled:(id<CancelToken>)cancelToken {
+-(void) startUntilCancelled:(TOCCancelToken*)cancelToken {
     lifetimeToken = cancelToken;
     
     phoneNumberDirectoryFilter = [[Environment preferences] tryGetSavedPhoneNumberDirectory];
@@ -49,30 +51,30 @@ -(void) scheduleUpdateAt:(NSDate*)date {
     };
     
     [currentUpdateLifetime cancel];
-    currentUpdateLifetime = [CancelTokenSource cancelTokenSource];
-    [lifetimeToken whenCancelled:^{ [currentUpdateLifetime cancel]; }];
+    currentUpdateLifetime = [TOCCancelTokenSource new];
+    [lifetimeToken whenCancelledDo:^{ [currentUpdateLifetime cancel]; }];
     [TimeUtil scheduleRun:doUpdate
                        at:date
                 onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-          unlessCancelled:currentUpdateLifetime.getToken];
+          unlessCancelled:currentUpdateLifetime.token];
 }
 
--(Future*) asyncQueryCurrentDirectory {
-    CancellableOperationStarter startAwaitDirectoryOperation = ^(id<CancelToken> untilCancelledToken) {
+-(TOCFuture*) asyncQueryCurrentDirectory {
+    TOCUntilOperation startAwaitDirectoryOperation = ^(TOCCancelToken* untilCancelledToken) {
 		HttpRequest* directoryRequest = [HttpRequest httpRequestForPhoneNumberDirectoryFilter];
 
-        Future* futureDirectoryResponse = [HttpManager asyncOkResponseFromMasterServer:directoryRequest
-                                                                       unlessCancelled:untilCancelledToken
-                                                                       andErrorHandler:[Environment errorNoter]];
+        TOCFuture* futureDirectoryResponse = [HttpManager asyncOkResponseFromMasterServer:directoryRequest
+                                                                          unlessCancelled:untilCancelledToken
+                                                                          andErrorHandler:[Environment errorNoter]];
         
-        return [futureDirectoryResponse then:^(HttpResponse* response) {
+        return [futureDirectoryResponse thenTry:^(HttpResponse* response) {
 			return [PhoneNumberDirectoryFilter phoneNumberDirectoryFilterFromHttpResponse:response];
 		}];
     };
     
-    return [AsyncUtil raceCancellableOperation:startAwaitDirectoryOperation
-                                againstTimeout:DIRECTORY_UPDATE_TIMEOUT_PERIOD
-                                untilCancelled:lifetimeToken];
+    return [TOCFuture futureFromUntilOperation:[TOCFuture operationTry:startAwaitDirectoryOperation]
+                          withOperationTimeout:DIRECTORY_UPDATE_TIMEOUT_PERIOD
+                                         until:lifetimeToken];
 }
 
 -(PhoneNumberDirectoryFilter*) sameDirectoryWithRetryTimeout {
@@ -87,17 +89,17 @@ -(void) signalDirectoryQueryFailed:(id)failure {
                       DIRECTORY_UPDATE_RETRY_PERIOD/HOUR];
     [Environment errorNoter](desc, failure, false);
 }
--(Future*) asyncQueryCurrentDirectoryWithDefaultOnFail {
-    Future* futureDirectory = [self asyncQueryCurrentDirectory];
+-(TOCFuture*) asyncQueryCurrentDirectoryWithDefaultOnFail {
+    TOCFuture* futureDirectory = [self asyncQueryCurrentDirectory];
     
-    return [futureDirectory catch:^PhoneNumberDirectoryFilter*(id error) {
+    return [futureDirectory catchTry:^PhoneNumberDirectoryFilter*(id error) {
         [self signalDirectoryQueryFailed:error];
         return [self sameDirectoryWithRetryTimeout];
     }];
 }
 
 -(void) update {
-    Future* eventualDirectory = [self asyncQueryCurrentDirectoryWithDefaultOnFail];
+    TOCFuture* eventualDirectory = [self asyncQueryCurrentDirectoryWithDefaultOnFail];
     
     [eventualDirectory thenDo:^(PhoneNumberDirectoryFilter* directory) {
         @synchronized(self) {
diff --git a/Signal/src/util/Operation.h b/Signal/src/util/Operation.h
index 1ecba4f723f..b3a64c08994 100644
--- a/Signal/src/util/Operation.h
+++ b/Signal/src/util/Operation.h
@@ -3,7 +3,6 @@
 #import "StringUtil.h"
 #import "DictionaryUtil.h"
 #import "ArrayUtil.h"
-#import "Future.h"
 
 typedef void(^Action)(void);
 typedef id(^Function)(void);
@@ -20,11 +19,6 @@ typedef id(^Function)(void);
 +(void) asyncRunAndWaitUntilDone:(Action)action
                         onThread:(NSThread*)thread;
 
-+(Future*) asyncEvaluate:(Function)function
-                   onThread:(NSThread*)thread;
-
-+(Future*) asyncEvaluateOnNewThread:(Function)function;
-
 +(void) asyncRunOnNewThread:(Action)action;
 
 -(void)run;
diff --git a/Signal/src/util/Operation.m b/Signal/src/util/Operation.m
index df4585f3f4b..1d2b2d47841 100644
--- a/Signal/src/util/Operation.m
+++ b/Signal/src/util/Operation.m
@@ -1,6 +1,5 @@
 #import "Util.h"
 #import "Constraints.h"
-#import "FutureSource.h"
 
 @implementation Operation
 
@@ -20,20 +19,6 @@ +(void) asyncRun:(Action)action
     [[Operation operation:action] performOnThread:thread];
 }
 
-+(Future*) asyncEvaluate:(Function)function
-                   onThread:(NSThread*)thread {
-    
-    require(function != nil);
-    require(thread != nil);
-    
-    FutureSource* result = [FutureSource new];
-    Action evaler = ^() {
-        [result trySetResult:function()];
-    };
-    [[Operation operation:evaler] performOnThread:thread];
-    return result;
-}
-
 +(void) asyncRunAndWaitUntilDone:(Action)action
                         onThread:(NSThread*)thread {
     
@@ -48,18 +33,6 @@ +(void) asyncRunOnNewThread:(Action)action {
     [[Operation operation:action] performOnNewThread];
 }
 
-+(Future*) asyncEvaluateOnNewThread:(Function)function {
-    
-    require(function != nil);
-    
-    FutureSource* result = [FutureSource new];
-    Action evaler = ^() {
-        [result trySetResult:function()];
-    };
-    [[Operation operation:evaler] performOnNewThread];
-    return result;
-}
-
 -(SEL) selectorToRun {
     return @selector(run);
 }
diff --git a/Signal/src/util/ThreadManager.h b/Signal/src/util/ThreadManager.h
index 4d4af578b0b..a4c1d34da53 100644
--- a/Signal/src/util/ThreadManager.h
+++ b/Signal/src/util/ThreadManager.h
@@ -1,5 +1,4 @@
 #import <Foundation/Foundation.h>
-#import "CancelToken.h"
 
 @interface RunningThreadRunLoopPair : NSObject
 
diff --git a/Signal/src/util/TimeUtil.h b/Signal/src/util/TimeUtil.h
index 6d091e51eaa..039284e6ed1 100644
--- a/Signal/src/util/TimeUtil.h
+++ b/Signal/src/util/TimeUtil.h
@@ -1,7 +1,6 @@
 #import <Foundation/Foundation.h>
 #import "Terminable.h"
-#import "CancelToken.h"
-#import "Future.h"
+#import "CollapsingFutures.h"
 #import "Operation.h"
 
 @interface TimeUtil : NSObject
@@ -9,31 +8,31 @@
 +(NSTimeInterval) time;
 
 /// Result has type Future(TypeOfValueReturnedByFunction)
-+(Future*) scheduleEvaluate:(Function)function
-                 afterDelay:(NSTimeInterval)delay
-                  onRunLoop:(NSRunLoop*)runLoop
-            unlessCancelled:(id<CancelToken>)unlessCancelledToken;
++(TOCFuture*) scheduleEvaluate:(Function)function
+                    afterDelay:(NSTimeInterval)delay
+                     onRunLoop:(NSRunLoop*)runLoop
+               unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 /// Result has type Future(TypeOfValueReturnedByFunction)
-+(Future*) scheduleEvaluate:(Function)function
-                         at:(NSDate*)date
-                  onRunLoop:(NSRunLoop*)runLoop
-            unlessCancelled:(id<CancelToken>)unlessCancelledToken;
++(TOCFuture*) scheduleEvaluate:(Function)function
+                            at:(NSDate*)date
+                     onRunLoop:(NSRunLoop*)runLoop
+               unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 +(void) scheduleRun:(Action)action
          afterDelay:(NSTimeInterval)delay
           onRunLoop:(NSRunLoop*)runLoop
-    unlessCancelled:(id<CancelToken>)unlessCancelledToken;
+    unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 +(void) scheduleRun:(Action)action
                  at:(NSDate*)date
           onRunLoop:(NSRunLoop*)runLoop
-    unlessCancelled:(id<CancelToken>)unlessCancelledToken;
+    unlessCancelled:(TOCCancelToken*)unlessCancelledToken;
 
 +(void) scheduleRun:(Action)action
        periodically:(NSTimeInterval)interval
           onRunLoop:(NSRunLoop*)runLoop
-     untilCancelled:(id<CancelToken>)untilCancelledToken
+     untilCancelled:(TOCCancelToken*)untilCancelledToken
   andRunImmediately:(BOOL)shouldRunImmediately;
 
 @end
diff --git a/Signal/src/util/TimeUtil.m b/Signal/src/util/TimeUtil.m
index e7c79571302..31c714d5453 100644
--- a/Signal/src/util/TimeUtil.m
+++ b/Signal/src/util/TimeUtil.m
@@ -2,7 +2,6 @@
 #import "Util.h"
 #import "AnonymousTerminator.h"
 #import "Constraints.h"
-#import "FutureSource.h"
 
 @implementation TimeUtil
 
@@ -10,16 +9,16 @@ +(NSTimeInterval) time {
     return [[NSProcessInfo processInfo] systemUptime];
 }
 
-+(Future*) scheduleEvaluate:(Function)function
-                 afterDelay:(NSTimeInterval)delay
-                  onRunLoop:(NSRunLoop*)runLoop
-            unlessCancelled:(id<CancelToken>)unlessCancelledToken {
++(TOCFuture*) scheduleEvaluate:(Function)function
+                    afterDelay:(NSTimeInterval)delay
+                     onRunLoop:(NSRunLoop*)runLoop
+               unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     
     require(function != NULL);
     require(runLoop != nil);
     require(delay >= 0);
     
-    FutureSource* result = [FutureSource new];
+    TOCFutureSource* result = [TOCFutureSource futureSourceUntil:unlessCancelledToken];
     Action evaler = ^{
         [result trySetResult:function()];
     };
@@ -30,14 +29,13 @@ +(Future*) scheduleEvaluate:(Function)function
           untilCancelled:unlessCancelledToken
        andRunImmediately:NO];
     
-    [unlessCancelledToken whenCancelledTryCancel:result];
-    return result;
+    return result.future;
 }
 
-+(Future*) scheduleEvaluate:(Function)function
-                         at:(NSDate*)date
-                  onRunLoop:(NSRunLoop*)runLoop
-            unlessCancelled:(id<CancelToken>)unlessCancelledToken {
++(TOCFuture*) scheduleEvaluate:(Function)function
+                            at:(NSDate*)date
+                     onRunLoop:(NSRunLoop*)runLoop
+               unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     
     require(function != NULL);
     require(runLoop != nil);
@@ -53,7 +51,7 @@ +(Future*) scheduleEvaluate:(Function)function
 +(void) scheduleRun:(Action)action
          afterDelay:(NSTimeInterval)delay
           onRunLoop:(NSRunLoop*)runLoop
-    unlessCancelled:(id<CancelToken>)unlessCancelledToken {
+    unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     
     require(action != NULL);
     require(runLoop != nil);
@@ -71,7 +69,7 @@ +(void) scheduleRun:(Action)action
 +(void) scheduleRun:(Action)action
                  at:(NSDate*)date
           onRunLoop:(NSRunLoop*)runLoop
-    unlessCancelled:(id<CancelToken>)unlessCancelledToken {
+    unlessCancelled:(TOCCancelToken*)unlessCancelledToken {
     
     require(action != NULL);
     require(runLoop != nil);
@@ -87,7 +85,7 @@ +(void) scheduleRun:(Action)action
 +(void) scheduleRun:(Action)action
        periodically:(NSTimeInterval)interval
           onRunLoop:(NSRunLoop*)runLoop
-     untilCancelled:(id<CancelToken>)untilCancelledToken
+     untilCancelled:(TOCCancelToken*)untilCancelledToken
   andRunImmediately:(BOOL)shouldRunImmediately{
     
     require(action != NULL);
@@ -106,7 +104,7 @@ +(void) scheduleHelper:(Action)callback
             withPeriod:(NSTimeInterval)interval
              onRunLoop:(NSRunLoop*)runLoop
              repeating:(bool)repeats
-        untilCancelled:(id<CancelToken>)untilCancelledToken
+        untilCancelled:(TOCCancelToken*)untilCancelledToken
      andRunImmediately:(BOOL)shouldRunImmediately{
     
     require(callback != NULL);
@@ -143,7 +141,7 @@ +(void) scheduleHelper:(Action)callback
                                             repeats:repeats];
     [runLoop addTimer:timer forMode:NSDefaultRunLoopMode];
     
-    [untilCancelledToken whenCancelled:^{
+    [untilCancelledToken whenCancelledDo:^{
         @synchronized(cancelLock) {
             hasBeenCancelled = true;
             [timer invalidate];
diff --git a/Signal/src/util/Util.h b/Signal/src/util/Util.h
index cd2d817dde7..5a1cfe8a5db 100644
--- a/Signal/src/util/Util.h
+++ b/Signal/src/util/Util.h
@@ -1,6 +1,5 @@
 #import <Foundation/Foundation.h>
 #import "ArrayUtil.h"
-#import "AsyncUtil.h"
 #import "Constraints.h"
 #import "Crc32.h"
 #import "DataUtil.h"
diff --git a/Signal/src/view controllers/LeftSideMenuViewController.h b/Signal/src/view controllers/LeftSideMenuViewController.h
index 1c12cdca29d..db98992c6f6 100644
--- a/Signal/src/view controllers/LeftSideMenuViewController.h	
+++ b/Signal/src/view controllers/LeftSideMenuViewController.h	
@@ -2,7 +2,6 @@
 
 #import "ContactBrowseViewController.h"
 #import "ContactsManager.h"
-#import "FutureSource.h"
 #import "TabBarParentViewController.h"
 
 /**
diff --git a/Signal/src/view controllers/RegisterViewController.h b/Signal/src/view controllers/RegisterViewController.h
index c2f7abf113a..873d6819eed 100644
--- a/Signal/src/view controllers/RegisterViewController.h	
+++ b/Signal/src/view controllers/RegisterViewController.h	
@@ -1,13 +1,12 @@
 #import <UIKit/UIKit.h>
 
-#import "CancelTokenSource.h"
+#import "CollapsingFutures.h"
 #import "CountryCodeViewController.h"
-#import "FutureSource.h"
 
 @interface RegisterViewController : UIViewController <CountryCodeViewControllerDelegate, UITextFieldDelegate> {
-@private FutureSource* registered;
-@private FutureSource* futureChallengeAcceptedSource;
-@private CancelTokenSource* life;
+@private TOCFutureSource* registered;
+@private TOCFutureSource* futureChallengeAcceptedSource;
+@private TOCCancelTokenSource* life;
 }
 
 @property (nonatomic, strong) IBOutlet UIButton *registerButton;
diff --git a/Signal/src/view controllers/RegisterViewController.m b/Signal/src/view controllers/RegisterViewController.m
index 9f6c98d15b6..8d4893e4884 100644
--- a/Signal/src/view controllers/RegisterViewController.m	
+++ b/Signal/src/view controllers/RegisterViewController.m	
@@ -56,9 +56,8 @@ - (void)viewDidLoad {
 
 + (RegisterViewController*)registerViewController {
     RegisterViewController *viewController = [RegisterViewController new];
-    viewController->registered = [FutureSource new];
-    viewController->life = [CancelTokenSource cancelTokenSource];
-    [[viewController->life getToken] whenCancelledTryCancel:viewController->registered];
+    viewController->life = [TOCCancelTokenSource new];
+    viewController->registered = [TOCFutureSource futureSourceUntil:viewController->life.token];
 
     return viewController;
 }
@@ -117,27 +116,27 @@ - (IBAction)changeCountryCodeTapped {
     [self presentViewController:countryCodeController animated:YES completion:nil];
 }
 
--(Future*) asyncRegister:(PhoneNumber*)phoneNumber untilCancelled:(id<CancelToken>)cancelToken {
+-(TOCFuture*) asyncRegister:(PhoneNumber*)phoneNumber untilCancelled:(TOCCancelToken*)cancelToken {
     [SGNKeychainUtil generateServerAuthPassword];
     [SGNKeychainUtil setLocalNumberTo:phoneNumber];
     
-    CancellableOperationStarter regStarter = ^Future *(id<CancelToken> internalUntilCancelledToken) {
+    TOCUntilOperation regStarter = ^TOCFuture *(TOCCancelToken* internalUntilCancelledToken) {
         HttpRequest *registerRequest = [HttpRequest httpRequestToStartRegistrationOfPhoneNumber];
        
         return [HttpManager asyncOkResponseFromMasterServer:registerRequest
                                             unlessCancelled:internalUntilCancelledToken
                                             andErrorHandler:[Environment errorNoter]];
     };
-    Future *futurePhoneRegistrationStarted = [AsyncUtil raceCancellableOperation:regStarter
-                                                                  againstTimeout:20.0
-                                                                  untilCancelled:cancelToken];
+    TOCFuture *futurePhoneRegistrationStarted = [TOCFuture futureFromUntilOperation:[TOCFuture operationTry:regStarter]
+                                                               withOperationTimeout:SERVER_TIMEOUT_SECONDS
+                                                                              until:cancelToken];
 
-    return [futurePhoneRegistrationStarted then:^(id _) {
+    return [futurePhoneRegistrationStarted thenTry:^(id _) {
         [self showViewNumber:CHALLENGE_VIEW_NUMBER];
         [self.challengeNumberLabel setText:[phoneNumber description]];
         [_registerCancelButton removeFromSuperview];
         [self startVoiceVerificationCountdownTimer];
-        self->futureChallengeAcceptedSource = [FutureSource new];
+        self->futureChallengeAcceptedSource = [TOCFutureSource new];
         return futureChallengeAcceptedSource;
     }];
 
@@ -150,7 +149,7 @@ - (void)registerPhoneNumberTapped {
     
     [_phoneNumberTextField resignFirstResponder];
 
-    Future* futureFinished = [self asyncRegister:localNumber untilCancelled:[life getToken]];
+    TOCFuture* futureFinished = [self asyncRegister:localNumber untilCancelled:life.token];
     [_registerActivityIndicator startAnimating];
     _registerButton.enabled = NO;
     
@@ -177,9 +176,9 @@ - (void)verifyChallengeTapped {
     [_challengeActivityIndicator startAnimating];
     
     HttpRequest *verifyRequest = [HttpRequest httpRequestToVerifyAccessToPhoneNumberWithChallenge:_challengeTextField.text];
-    Future *futureDone = [HttpManager asyncOkResponseFromMasterServer:verifyRequest
-                                                      unlessCancelled:nil
-                                                      andErrorHandler:[Environment errorNoter]];
+    TOCFuture *futureDone = [HttpManager asyncOkResponseFromMasterServer:verifyRequest
+                                                         unlessCancelled:nil
+                                                         andErrorHandler:[Environment errorNoter]];
     
     [futureDone catchDo:^(id error) {
         if ([error isKindOfClass:[HttpResponse class]]) {
@@ -201,7 +200,7 @@ - (void)verifyChallengeTapped {
         [futureChallengeAcceptedSource trySetResult:@YES];
     }];
     
-    [futureChallengeAcceptedSource thenDo:^(id value) {
+    [futureChallengeAcceptedSource.future thenDo:^(id value) {
         [PushManager.sharedManager askForPushRegistrationWithSuccess:^{
             [Environment setRegistered:YES];
             [registered trySetResult:@YES];
@@ -275,7 +274,7 @@ - (void) countdowntimerFired {
 
 - (void) initiateVoiceVerification{
     [self stopVoiceVerificationCountdownTimer];
-    CancellableOperationStarter callStarter = ^Future *(id<CancelToken> internalUntilCancelledToken) {
+    TOCUntilOperation callStarter = ^TOCFuture *(TOCCancelToken* internalUntilCancelledToken) {
         HttpRequest* voiceVerifyReq = [HttpRequest httpRequestToStartRegistrationOfPhoneNumberWithVoice];
         
         [self.voiceChallengeTextLabel setText:@"Calling" ];
@@ -283,15 +282,15 @@ - (void) initiateVoiceVerification{
                                             unlessCancelled:internalUntilCancelledToken
                                             andErrorHandler:[Environment errorNoter]];
     };
-    Future *futureVoiceVerificationStarted = [AsyncUtil raceCancellableOperation:callStarter
-                                                                  againstTimeout:SERVER_TIMEOUT_SECONDS
-                                                                  untilCancelled:[life getToken]];
+    TOCFuture *futureVoiceVerificationStarted = [TOCFuture futureFromUntilOperation:[TOCFuture operationTry:callStarter]
+                                                               withOperationTimeout:SERVER_TIMEOUT_SECONDS
+                                                                              until:life.token];
     [futureVoiceVerificationStarted catchDo:^(id errorId) {
         HttpResponse* error = (HttpResponse*)errorId;
        [self.voiceChallengeTextLabel setText:[error getStatusText]];
     }];
     
-    [futureVoiceVerificationStarted finally:^id(id _id) {
+    [futureVoiceVerificationStarted finallyTry:^(id _id) {
         dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, VOICE_VERIFICATION_COOLDOWN_SECONDS * NSEC_PER_SEC);
         dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
             [self.voiceChallengeTextLabel setText:@"Re-Call"];
diff --git a/Signal/src/view controllers/SettingsViewController.h b/Signal/src/view controllers/SettingsViewController.h
index 304bc522e06..3063c426663 100644
--- a/Signal/src/view controllers/SettingsViewController.h	
+++ b/Signal/src/view controllers/SettingsViewController.h	
@@ -1,6 +1,5 @@
 #import <UIKit/UIKit.h>
 
-#import "FutureSource.h"
 #import "LocalizableCustomFontLabel.h"
 #import "SettingsTableHeaderView.h"
 
diff --git a/Signal/test/TestUtil.m b/Signal/test/TestUtil.m
index 94e4fd4f976..ea6e5c9c35f 100644
--- a/Signal/test/TestUtil.m
+++ b/Signal/test/TestUtil.m
@@ -13,7 +13,7 @@ bool _testChurnHelper(int (^condition)(), NSTimeInterval delay) {
         @synchronized(churnLock()) {
             if (condition()) return true;
         }
-        sleep(1);
+        [NSRunLoop.currentRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:0.01]];
     }
     @synchronized(churnLock()) {
         return condition();
diff --git a/Signal/test/async/AsyncUtilTest.m b/Signal/test/async/AsyncUtilTest.m
deleted file mode 100644
index a58b7832af9..00000000000
--- a/Signal/test/async/AsyncUtilTest.m
+++ /dev/null
@@ -1,273 +0,0 @@
-#import <XCTest/XCTest.h>
-#import "TestUtil.h"
-#import "AsyncUtil.h"
-#import "FutureSource.h"
-#import "CancelTokenSource.h"
-#import "CancelledToken.h"
-#import "ThreadManager.h"
-
-@interface AsyncUtilTest : XCTestCase
-
-@end
-
-@implementation AsyncUtilTest
-
--(void) testRaceCancellableOperations_Winner {
-    __block int f = 0;
-    __block int s = 0;
-    __block int i = 0;
-    CancellableOperationStarter (^makeStarter)(Future*) = ^(Future* future) {
-        return ^(id<CancelToken> c) {
-            [c whenCancelled:^{
-                if (future.hasFailed) f += 1;
-                if (future.hasSucceeded) s += 1;
-                if (future.isIncomplete) i += 1;
-            }];
-            return future;
-        };
-    };
-    
-    FutureSource* v1 = [FutureSource new];
-    FutureSource* v2 = [FutureSource new];
-    FutureSource* v3 = [FutureSource new];
-    
-    Future* r = [AsyncUtil raceCancellableOperations:(@[makeStarter(v1),makeStarter(v2),makeStarter(v3)])
-                                      untilCancelled:nil];
-    
-    [v2 trySetFailure:@1];
-    test(r.isIncomplete);
-    test(f == 0 && s == 0 && i == 0);
-    
-    [v3 trySetResult:@2];
-    test(r.hasSucceeded);
-    test([[r forceGetResult] isEqual:@2]);
-    test(f == 1 && s == 0 && i == 1);
-    
-    [v1 trySetResult:@3];
-    test(f == 1 && s == 0 && i == 1);
-}
--(void) testRaceCancellableOperations_Cancel {
-    __block int i = 0;
-    CancellableOperationStarter (^makeStarter)(FutureSource*) = ^(FutureSource* future) {
-        return ^(id<CancelToken> c) {
-            [c whenCancelled:^{
-                i += 1;
-                [future trySetFailure:c];
-            }];
-            return future;
-        };
-    };
-    
-    Future* r = [AsyncUtil raceCancellableOperations:(@[
-                                                      makeStarter([FutureSource new]),
-                                                      makeStarter([FutureSource new]),
-                                                      makeStarter([FutureSource new])])
-                                      untilCancelled:[CancelledToken cancelledToken]];
-    
-    test(i == 3);
-    test(r.hasFailed);
-    test([(NSArray*)[r forceGetFailure] count] == 3);
-}
--(void) testRaceCancellableOperations_Losers {
-    test([[AsyncUtil raceCancellableOperations:@[]
-                                untilCancelled:nil] hasFailed]);
-    
-    CancellableOperationStarter s = ^(id<CancelToken> c) {
-        return [Future failed:@1];
-    };
-    
-    Future* r = [AsyncUtil raceCancellableOperations:(@[s,s,s])
-                                      untilCancelled:nil];
-    test(r.hasFailed);
-    test([[r forceGetFailure] isEqual:(@[@1,@1,@1])]);
-}
-
--(void) testRaceCancellableOperationAgainstTimeout_WinFail {
-    test([[AsyncUtil raceCancellableOperations:@[]
-                                untilCancelled:nil] hasFailed]);
-    CancelTokenSource* cts = [CancelTokenSource cancelTokenSource];
-    
-    __block int n = 0;
-    CancellableOperationStarter s = ^(id<CancelToken> c) {
-        [c whenCancelled:^{
-            @synchronized(churnLock()) {
-                n += 1;
-            }
-        }];
-        return [Future failed:@1];
-    };
-    
-    Future* f = [AsyncUtil raceCancellableOperation:s
-                                     againstTimeout:1.0
-                                     untilCancelled:[cts getToken]];
-    test(f.hasFailed);
-    test([[f forceGetFailure] isEqual:@1]);
-    test(n == 0);
-}
--(void) testRaceCancellableOperationAgainstTimeout_Win {
-    test([[AsyncUtil raceCancellableOperations:@[]
-                                untilCancelled:nil] hasFailed]);
-    CancelTokenSource* cts = [CancelTokenSource cancelTokenSource];
-    
-    __block int n = 0;
-    CancellableOperationStarter s = ^(id<CancelToken> c) {
-        [c whenCancelled:^{
-            @synchronized(churnLock()) {
-                n += 1;
-            }
-        }];
-        return [Future finished:@1];
-    };
-    
-    Future* f = [AsyncUtil raceCancellableOperation:s
-                                     againstTimeout:1.0
-                                     untilCancelled:[cts getToken]];
-    test(f.hasSucceeded);
-    test([[f forceGetResult] isEqual:@1]);
-    test(n == 0);
-}
--(void) testRaceCancellableOperationAgainstTimeout_Timeout {
-    test([[AsyncUtil raceCancellableOperations:@[]
-                                untilCancelled:nil] hasFailed]);
-    CancelTokenSource* cts = [CancelTokenSource cancelTokenSource];
-    
-    __block int n = 0;
-    CancellableOperationStarter s = ^(id<CancelToken> c) {
-        [c whenCancelled:^{
-            @synchronized(churnLock()) {
-                n += 1;
-            }
-        }];
-        return [FutureSource new];
-    };
-    
-    Future* f = [AsyncUtil raceCancellableOperation:s
-                                     againstTimeout:0.1
-                                     untilCancelled:[cts getToken]];
-    
-    test(n == 0);
-    testChurnUntil(f.hasFailed, 1.0);
-    test(n == 1);
-    test([[f forceGetFailure] isKindOfClass:[TimeoutFailure class]]);
-}
--(void) testRaceCancellableOperationAgainstTimeout_Cancel {
-    test([[AsyncUtil raceCancellableOperations:@[]
-                                untilCancelled:nil] hasFailed]);
-    CancelTokenSource* cts = [CancelTokenSource cancelTokenSource];
-    
-    __block int n = 0;
-    CancellableOperationStarter s = ^(id<CancelToken> c) {
-        [c whenCancelled:^{
-            @synchronized(churnLock()) {
-                n += 1;
-            }
-        }];
-        return [FutureSource new];
-    };
-    
-    Future* f = [AsyncUtil raceCancellableOperation:s
-                                     againstTimeout:1.0
-                                     untilCancelled:[cts getToken]];
-    
-    test(n == 0);
-    [cts cancel];
-    test(n == 1);
-    testChurnUntil(f.hasFailed, 1.0);
-    test([[f forceGetFailure] conformsToProtocol:@protocol(CancelToken)]);
-}
-
--(void) testAsyncTryPass {
-    __block NSUInteger repeat = 0;
-    __block NSUInteger evalCount = 0;
-    CancellableOperationStarter op = ^(id<CancelToken> c) {
-        repeat += 1;
-        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return @YES; }
-                               afterDelay:0.5
-                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-                          unlessCancelled:c];
-    };
-    Future* f = [AsyncUtil asyncTry:op
-                         upToNTimes:4
-                    withBaseTimeout:0.5/8
-                     andRetryFactor:2
-                     untilCancelled:nil];
-    testChurnUntil(!f.isIncomplete, 5.0);
-
-    test(repeat == 3 || repeat == 4);
-    test(evalCount == 1);
-    test(f.hasSucceeded);
-    test([[f forceGetResult] isEqual:@YES]);
-}
--(void) testAsyncTryFail {
-    __block NSUInteger repeat = 0;
-    __block NSUInteger evalCount = 0;
-    CancellableOperationStarter op = ^(id<CancelToken> c) {
-        repeat += 1;
-        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return [Future failed:@13]; }
-                               afterDelay:0.1
-                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-                          unlessCancelled:c];
-    };
-    Future* f = [AsyncUtil asyncTry:op
-                         upToNTimes:4
-                    withBaseTimeout:0.5/8
-                     andRetryFactor:2
-                     untilCancelled:nil];
-    testChurnUntil(!f.isIncomplete, 5.0);
-    
-    test(repeat >= 1);
-    test(evalCount >= 1);
-    test(f.hasFailed);
-    test([[f forceGetFailure] isEqual:@13]);
-}
--(void) testAsyncTryTimeout {
-    __block NSUInteger repeat = 0;
-    __block NSUInteger evalCount = 0;
-    CancellableOperationStarter op = ^(id<CancelToken> c) {
-        repeat += 1;
-        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return @YES; }
-                               afterDelay:0.5
-                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-                          unlessCancelled:c];
-    };
-    Future* f = [AsyncUtil asyncTry:op
-                         upToNTimes:2
-                    withBaseTimeout:0.5/8
-                     andRetryFactor:2
-                     untilCancelled:nil];
-    testChurnUntil(!f.isIncomplete, 5.0);
-    
-    test(repeat == 2);
-    test(evalCount == 0);
-    test(f.hasFailed);
-    test([[f forceGetFailure] isKindOfClass:[TimeoutFailure class]]);
-}
--(void) testAsyncTryCancel {
-    CancelTokenSource* s = [CancelTokenSource cancelTokenSource];
-    __block NSUInteger repeat = 0;
-    __block NSUInteger evalCount = 0;
-    CancellableOperationStarter op = ^(id<CancelToken> c) {
-        repeat += 1;
-        [TimeUtil scheduleRun:^{ [s cancel]; }
-                   afterDelay:0.1
-                    onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-              unlessCancelled:nil];
-        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return @YES; }
-                               afterDelay:0.5
-                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
-                          unlessCancelled:c];
-    };
-    Future* f = [AsyncUtil asyncTry:op
-                         upToNTimes:2
-                    withBaseTimeout:0.5/8
-                     andRetryFactor:2
-                     untilCancelled:[s getToken]];
-    testChurnUntil(!f.isIncomplete, 5.0);
-    
-    test(repeat == 2);
-    test(evalCount == 0);
-    test(f.hasFailed);
-    test([[f forceGetFailure] conformsToProtocol:@protocol(CancelToken)]);
-}
-
-@end
diff --git a/Signal/test/async/FutureSourceTest.m b/Signal/test/async/FutureSourceTest.m
deleted file mode 100644
index c57dc1fd830..00000000000
--- a/Signal/test/async/FutureSourceTest.m
+++ /dev/null
@@ -1,353 +0,0 @@
-#import <XCTest/XCTest.h>
-#import "TestUtil.h"
-#import "FutureSource.h"
-#import "Util.h"
-
-@interface FutureSourceTest:XCTestCase
-
-@end
-
-@implementation FutureSourceTest
-
--(void) testConstructors {
-    FutureSource* inc = [FutureSource new];
-    test(inc.isIncomplete);
-    test(!inc.hasSucceeded);
-    test(!inc.hasFailed);
-    testThrows([inc forceGetResult]);
-    testThrows([inc forceGetFailure]);
-
-    FutureSource* done = [FutureSource finished:@1];
-    test(!done.isIncomplete);
-    test(done.hasSucceeded);
-    test(!done.hasFailed);
-    testDoesNotThrow([done forceGetResult]);
-    testThrows([done forceGetFailure]);
-
-    Future* done2 = [Future finished:@2];
-    test(!done2.isIncomplete);
-    test(done2.hasSucceeded);
-    test(!done2.hasFailed);
-    testDoesNotThrow([done2 forceGetResult]);
-    testThrows([done2 forceGetFailure]);
-
-    FutureSource* fail3 = [FutureSource failed:@3];
-    test(!fail3.isIncomplete);
-    test(!fail3.hasSucceeded);
-    test(fail3.hasFailed);
-    testThrows([fail3 forceGetResult]);
-    testDoesNotThrow([fail3 forceGetFailure]);
-
-    Future* fail4 = [Future failed:@4];
-    test(!fail4.isIncomplete);
-    test(!fail4.hasSucceeded);
-    test(fail4.hasFailed);
-    testThrows([fail4 forceGetResult]);
-    testDoesNotThrow([fail4 forceGetFailure]);    
-}
--(void) testAutoUnwrap {
-    Future* f = [Future finished:[Future finished:[Future failed:@1]]];
-    test(f.hasFailed);
-    test([[f forceGetFailure] isEqual:@1]);
-    
-    Future* f2 = [Future finished:[Future finished:[Future finished:@2]]];
-    test(f2.hasSucceeded);
-    test([[f2 forceGetResult] isEqual:@2]);
-
-    test([[[[Future finished:@1] then:^id(id value) {
-        return [Future finished:@3];
-    }] forceGetResult] isEqual:@3]);
-
-    test([[[[Future failed:@1] catch:^id(id value) {
-        return [Future finished:@3];
-    }] forceGetResult] isEqual:@3]);
-}
--(void) testTrySet {
-    FutureSource* setR = [FutureSource new];
-    FutureSource* setF = [FutureSource new];
-    FutureSource* setWR = [FutureSource new];
-    FutureSource* setWF = [FutureSource new];
-    FutureSource* wr = [FutureSource new];
-    FutureSource* wf = [FutureSource new];
-    
-    // set result
-    test([setR trySetResult:@1]);
-    test(setR.hasSucceeded);
-    test(![setR trySetResult:@0]);
-    test(![setR trySetFailure:@0]);
-    test(![setR trySetResult:wr]);
-    test(![setR trySetResult:wf]);
-    test([[setR forceGetResult] isEqual:@1]);
-
-    // set fail
-    test([setF trySetFailure:@2]);
-    test(setF.hasFailed);
-    test(![setF trySetResult:@0]);
-    test(![setF trySetFailure:@0]);
-    test(![setF trySetResult:wr]);
-    test(![setF trySetResult:wf]);
-    test([[setF forceGetFailure] isEqual:@2]);
-
-    // wire result
-    test([setWR trySetResult:wr]);
-    test(setWR.isIncomplete);
-    test(![setWR trySetResult:@0]);
-    test(![setWR trySetFailure:@0]);
-    test(![setWR trySetResult:wf]);
-    test(![setWR trySetResult:wr]);
-    
-    // wire failure
-    test([setWF trySetResult:wf]);
-    test(setWF.isIncomplete);
-    test(![setWF trySetResult:@0]);
-    test(![setWF trySetFailure:@0]);
-    test(![setWF trySetResult:wf]);
-    test(![setWF trySetResult:wr]);
-
-    // set result via wire
-    test(setWR.isIncomplete);
-    [wr trySetResult:@3];
-    test(setWR.hasSucceeded);
-    test([[setWR forceGetResult] isEqual:@3]);
-
-    // set failure via wire
-    test(setWF.isIncomplete);
-    [wf trySetFailure:@4];
-    test(setWF.hasFailed);
-    test([[setWF forceGetFailure] isEqual:@4]);
-}
-
--(void) testThenDo_OnSuccess {
-    FutureSource* f = [FutureSource new];
-    __block int ready = 0;
-    
-    // before completed, waits to run
-    [f thenDo:^(NSNumber* result) {
-        test(ready == 1);
-        ready = 2;
-        test([result isEqual:@1]);
-    }];
-    test(ready == 0);
-    
-    ready = 1;
-    [f trySetResult:@1];
-    test(ready == 2);
-
-    // after completed, runs inline
-    [f thenDo:^(NSNumber* result) {
-        test(ready == 2);
-        ready = 3;
-        test([result isEqual:@1]);
-    }];
-    test(ready == 3);
-}
--(void) testThenDo_OnFail {
-    FutureSource* f = [FutureSource new];
-    [f thenDo:^(NSNumber* result) {
-        test(false);
-    }];
-    [f trySetFailure:@1];
-    [f thenDo:^(NSNumber* result) {
-        test(false);
-    }];
-}
-
--(void) testCatchDo_OnFail {
-    FutureSource* f = [FutureSource new];
-    __block int ready = 0;
-    
-    // before completed, waits to run
-    [f catchDo:^(NSNumber* result) {
-        test(ready == 1);
-        ready = 2;
-        test([result isEqual:@1]);
-    }];
-    test(ready == 0);
-    
-    ready = 1;
-    [f trySetFailure:@1];
-    test(ready == 2);
-    
-    // after completed, runs inline
-    [f catchDo:^(NSNumber* result) {
-        test(ready == 2);
-        ready = 3;
-        test([result isEqual:@1]);
-    }];
-    test(ready == 3);
-}
--(void) testCatchDo_OnSuccess {
-    FutureSource* f = [FutureSource new];
-    [f catchDo:^(NSNumber* result) {
-        test(false);
-    }];
-    [f trySetResult:@1];
-    [f catchDo:^(NSNumber* result) {
-        test(false);
-    }];
-}
-
--(void) testThenOrCatchDo_OnSuccess {
-    FutureSource* f = [FutureSource new];
-    __block int ready = 0;
-    
-    // before completed, waits to run
-    [f finallyDo:^(Future* completed) {
-        test(ready == 1);
-        ready = 2;
-        test([[completed forceGetResult] isEqual:@1]);
-    }];
-    test(ready == 0);
-    
-    ready = 1;
-    [f trySetResult:@1];
-    test(ready == 2);
-    
-    // after completed, runs inline
-    [f finallyDo:^(Future* completed) {
-        test(ready == 2);
-        ready = 3;
-        test([[completed forceGetResult] isEqual:@1]);
-    }];
-    test(ready == 3);
-}
--(void) testThenOrCatchDo_OnFail {
-    FutureSource* f = [FutureSource new];
-    __block int ready = 0;
-    
-    // before completed, waits to run
-    [f finallyDo:^(Future* completed) {
-        test(ready == 1);
-        ready = 2;
-        test([[completed forceGetResult] isEqual:@1]);
-    }];
-    test(ready == 0);
-    
-    ready = 1;
-    [f trySetResult:@1];
-    test(ready == 2);
-    
-    // after completed, runs inline
-    [f finallyDo:^(Future* completed) {
-        test(ready == 2);
-        ready = 3;
-        test([[completed forceGetResult] isEqual:@1]);
-    }];
-    test(ready == 3);
-}
-
--(void) testThen {
-    // pre-completed
-    bool b = [[[[Future finished:@3] then:^id(id value) {
-        test([value isEqual:@3]);
-        return @4;
-    }] forceGetResult] isEqual:@4];
-    test(b);
-
-    // pre-failed
-    bool b2 = [[[[Future failed:@-1] then:^id(id value) {
-        test(false);
-        return nil;
-    }] forceGetFailure] isEqual:@-1];
-    test(b2);
-
-    // post-completed
-    FutureSource* f = [FutureSource new];
-    Future* f2 = [f then:^id(id value) {
-        test([value isEqual:@1]);
-        return @2;
-    }];
-    test(f2.isIncomplete);
-    [f trySetResult:@1];
-    test([[f2 forceGetResult] isEqual:@2]);
-
-    // exceptional
-    bool b3 = [[[[Future finished:nil] finally:^id(Future* completed) {
-        checkOperation(false);
-        return nil;
-    }] forceGetFailure] isKindOfClass:[OperationFailed class]];
-    test(b3);
-}
-
--(void) testCatch {
-    // pre-failed
-    bool b = [[[[Future failed:@3] catch:^id(id value) {
-        test([value isEqual:@3]);
-        return @4;
-    }] forceGetResult] isEqual:@4];
-    test(b);
-    
-    // pre-completed
-    bool b2 = [[[[Future finished:@-1] catch:^id(id value) {
-        test(false);
-        return nil;
-    }] forceGetResult] isEqual:@-1];
-    test(b2);
-    
-    // post-failed
-    FutureSource* f = [FutureSource new];
-    Future* f2 = [f catch:^id(id value) {
-        test([value isEqual:@1]);
-        return @2;
-    }];
-    test(f2.isIncomplete);
-    [f trySetFailure:@1];
-    test([[f2 forceGetResult] isEqual:@2]);
-    
-    // exceptional
-    bool b3 = [[[[Future failed:nil] finally:^id(Future* completed) {
-        checkOperation(false);
-        return nil;
-    }] forceGetFailure] isKindOfClass:[OperationFailed class]];
-    test(b3);
-}
-
--(void) testThenOrCatch {
-    // pre-completed
-    bool b = [[[[Future finished:@3] finally:^id(Future* completed) {
-        test([[completed forceGetResult] isEqual:@3]);
-        return @4;
-    }] forceGetResult] isEqual:@4];
-    test(b);
-    
-    // pre-failed
-    bool b2 = [[[[Future failed:@-1] finally:^id(Future* completed) {
-        test([[completed forceGetFailure] isEqual:@-1]);
-        return @5;
-    }] forceGetResult] isEqual:@5];
-    test(b2);
-    
-    // post-completed
-    FutureSource* f = [FutureSource new];
-    Future* f2 = [f finally:^id(Future* completed) {
-        test([[completed forceGetResult] isEqual:@1]);
-        return @2;
-    }];
-    test(f2.isIncomplete);
-    [f trySetResult:@1];
-    test([[f2 forceGetResult] isEqual:@2]);
-    
-    // exceptional
-    bool b3 = [[[[Future finished:nil] finally:^id(Future* completed) {
-        checkOperation(false);
-        return nil;
-    }] forceGetFailure] isKindOfClass:[OperationFailed class]];
-    test(b3);
-}
-
--(void) completedAsCancelToken_OnSuccess {
-    FutureSource* f = [FutureSource new];
-    id<CancelToken> c = [f completionAsCancelToken];
-    test(!c.isAlreadyCancelled);
-    [f trySetResult:nil];
-    test(c.isAlreadyCancelled);
-}
--(void) completedAsCancelToken_OnFailure {
-    FutureSource* f = [FutureSource new];
-    id<CancelToken> c = [f completionAsCancelToken];
-    test(!c.isAlreadyCancelled);
-    [f trySetFailure:nil];
-    test(c.isAlreadyCancelled);
-}
-
-@end
diff --git a/Signal/test/audio/AudioRemoteIOTest.m b/Signal/test/audio/AudioRemoteIOTest.m
index a9986fd124c..c1f17ee11b5 100644
--- a/Signal/test/audio/AudioRemoteIOTest.m
+++ b/Signal/test/audio/AudioRemoteIOTest.m
@@ -2,7 +2,6 @@
 #import "RemoteIOAudio.h"
 #import "AnonymousAudioCallbackHandler.h"
 #import "TestUtil.h"
-#import "CancelTokenSource.h"
 
 @interface AudioRemoteIOTest : XCTestCase
 
@@ -36,10 +35,10 @@ -(void)___testPlaysAndRecordsAudio {
         }
     };
     
-    CancelTokenSource* life = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* life = [TOCCancelTokenSource new];
     a = [RemoteIOAudio remoteIOInterfaceStartedWithDelegate:[AnonymousAudioCallbackHandler anonymousAudioInterfaceDelegateWithRecordingCallback:countCalls
                                                                                                                     andPlaybackOccurredCallback:generateWhooOOOoooOOOOooOOOOoooSineWave]
-                                             untilCancelled:[life getToken]];
+                                             untilCancelled:life.token];
     
     // churn the run loop, to allow the audio to play and be recorded
     // YOU SHOULD HEAR A WOOOoooOOOOoooOOO TONE WHILE THIS IS HAPPENING (with the frequency going up and down)
diff --git a/Signal/test/audio/JitterQueueTest.m b/Signal/test/audio/JitterQueueTest.m
index b62983c99bc..1afacba2b84 100644
--- a/Signal/test/audio/JitterQueueTest.m
+++ b/Signal/test/audio/JitterQueueTest.m
@@ -16,7 +16,6 @@
 #define testLoggedResync(q, oldReadHeadSequenceNumber, newReadHeadSequenceNumber) testLogged(q, ([NSString stringWithFormat:@"resync %d to %d", oldReadHeadSequenceNumber,newReadHeadSequenceNumber]))
 
 @interface JitterQueueTest : XCTestCase
-
 @end
 
 @implementation JitterQueueTest
diff --git a/Signal/test/network/dns/DnsManagerTest.m b/Signal/test/network/dns/DnsManagerTest.m
index aa8c992c01f..48d999c5f99 100644
--- a/Signal/test/network/dns/DnsManagerTest.m
+++ b/Signal/test/network/dns/DnsManagerTest.m
@@ -4,7 +4,6 @@
 #import "Util.h"
 #import "IpAddress.h"
 #import "ThreadManager.h"
-#import "CancelTokenSource.h"
 #import <netdb.h>
 
 #define infrastructureTestHostName @"relay.whispersystems.org"
@@ -20,64 +19,64 @@ @interface DnsManagerTest : XCTestCase
 @implementation DnsManagerTest
 
 -(void) testQueryAddresses_Sequential {
-    Future* f1 = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
-                                              unlessCancelled:nil];
-    testChurnUntil(f1.hasSucceeded, 5.0);
-    test([(NSArray*)[f1 forceGetResult] count] > 0);
+    TOCFuture* f1 = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
+                                                 unlessCancelled:nil];
+    testChurnUntil(f1.hasResult, 5.0);
+    test(f1.hasResult && [(NSArray*)[f1 forceGetResult] count] > 0);
 
-    Future* f2 = [DnsManager asyncQueryAddressesForDomainName:invalidHostname
-                                              unlessCancelled:nil];
+    TOCFuture* f2 = [DnsManager asyncQueryAddressesForDomainName:invalidHostname
+                                                 unlessCancelled:nil];
     testChurnUntil(f2.hasFailed, 5.0);
 
-    Future* f3 = [DnsManager asyncQueryAddressesForDomainName:nonExistentHostname
-                                              unlessCancelled:nil];
+    TOCFuture* f3 = [DnsManager asyncQueryAddressesForDomainName:nonExistentHostname
+                                                 unlessCancelled:nil];
     testChurnUntil(f3.hasFailed, 5.0);
 
-    Future* f4 = [DnsManager asyncQueryAddressesForDomainName:infrastructureTestHostName
-                                              unlessCancelled:nil];
-    testChurnUntil(f4.hasSucceeded, 5.0);
-    test(f4.hasSucceeded && [(NSArray*)[f4 forceGetResult] count] > 0);
+    TOCFuture* f4 = [DnsManager asyncQueryAddressesForDomainName:infrastructureTestHostName
+                                                 unlessCancelled:nil];
+    testChurnUntil(f4.hasResult, 5.0);
+    test(f4.hasResult && [(NSArray*)[f4 forceGetResult] count] > 0);
     
 }
 
 -(void) testQueryAddresses_Concurrent {
-    Future* f1 = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
+    TOCFuture* f1 = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
+                                                    unlessCancelled:nil];
+    TOCFuture* f2 = [DnsManager asyncQueryAddressesForDomainName:invalidHostname
+                                                 unlessCancelled:nil];
+    TOCFuture* f3 = [DnsManager asyncQueryAddressesForDomainName:nonExistentHostname
+                                                 unlessCancelled:nil];
+    TOCFuture* f4 = [DnsManager asyncQueryAddressesForDomainName:infrastructureTestHostName
                                                  unlessCancelled:nil];
-    Future* f2 = [DnsManager asyncQueryAddressesForDomainName:invalidHostname
-                                              unlessCancelled:nil];
-    Future* f3 = [DnsManager asyncQueryAddressesForDomainName:nonExistentHostname
-                                              unlessCancelled:nil];
-    Future* f4 = [DnsManager asyncQueryAddressesForDomainName:infrastructureTestHostName
-                                              unlessCancelled:nil];
     
-    testChurnUntil(f1.hasSucceeded && f2.hasFailed && f3.hasFailed && f4.hasSucceeded, 5.0);
-    test(f1.hasSucceeded && [(NSArray*)[f1 forceGetResult] count] > 0);
-    test(f4.hasSucceeded && [(NSArray*)[f4 forceGetResult] count] > 0);
+    testChurnUntil(f1.hasResult && f2.hasFailed && f3.hasFailed && f4.hasResult, 5.0);
+    test(f1.hasResult && [(NSArray*)[f1 forceGetResult] count] > 0);
+    test(f4.hasResult && [(NSArray*)[f4 forceGetResult] count] > 0);
 }
 
 -(void) testQueryAddresses_Cancel {
-    CancelTokenSource* c = [CancelTokenSource cancelTokenSource];
-    Future* f1 = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
-                                              unlessCancelled:[c getToken]];
-    Future* f2 = [DnsManager asyncQueryAddressesForDomainName:invalidHostname
-                                              unlessCancelled:[c getToken]];
-    Future* f3 = [DnsManager asyncQueryAddressesForDomainName:nonExistentHostname
-                                              unlessCancelled:[c getToken]];
-    Future* f4 = [DnsManager asyncQueryAddressesForDomainName:infrastructureTestHostName
-                                              unlessCancelled:[c getToken]];
+    TOCCancelTokenSource* c = [TOCCancelTokenSource new];
+    TOCFuture* f1 = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
+                                                 unlessCancelled:c.token];
+    TOCFuture* f2 = [DnsManager asyncQueryAddressesForDomainName:invalidHostname
+                                                 unlessCancelled:c.token];
+    TOCFuture* f3 = [DnsManager asyncQueryAddressesForDomainName:nonExistentHostname
+                                                 unlessCancelled:c.token];
+    TOCFuture* f4 = [DnsManager asyncQueryAddressesForDomainName:infrastructureTestHostName
+                                                 unlessCancelled:c.token];
     [c cancel];
     
     testChurnUntil(!f1.isIncomplete && f2.hasFailed && f3.hasFailed && !f4.isIncomplete, 5.0);
-    test(f1.hasSucceeded || [[f1 forceGetFailure] conformsToProtocol:@protocol(CancelToken)]);
+    test(f1.hasResult || f1.hasFailedWithCancel);
     test(f2.hasFailed);
     test(f3.hasFailed);
-    test(f4.hasSucceeded || [[f4 forceGetFailure] conformsToProtocol:@protocol(CancelToken)]);
+    test(f4.hasResult || f4.hasFailedWithCancel);
 }
 
 -(void)testQueryAddresses_FastCancel {
-    CancelTokenSource* c = [CancelTokenSource cancelTokenSource];
-    Future* f = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
-                                             unlessCancelled:[c getToken]];
+    TOCCancelTokenSource* c = [TOCCancelTokenSource new];
+    TOCFuture* f = [DnsManager asyncQueryAddressesForDomainName:reliableHostName
+                                                unlessCancelled:c.token];
     [c cancel];
     test(!f.isIncomplete);
 }
diff --git a/Signal/test/network/rtp/zrtp/ZrtpTest.m b/Signal/test/network/rtp/zrtp/ZrtpTest.m
index 345500403d4..947cbee6aae 100644
--- a/Signal/test/network/rtp/zrtp/ZrtpTest.m
+++ b/Signal/test/network/rtp/zrtp/ZrtpTest.m
@@ -35,19 +35,19 @@ -(void) testPerturbedZrtpHandshake {
     CallController* cc1 = [CallController callControllerForCallInitiatedLocally:true
                                                                withRemoteNumber:testPhoneNumber1
                                                   andOptionallySpecifiedContact:nil];
-    Future* f1 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u1 interopOptions:@[]]
-                                      andCallController:cc1];
+    TOCFuture* f1 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u1 interopOptions:@[]]
+                                         andCallController:cc1];
     
     UdpSocket* u2 = [UdpSocket udpSocketTo:receiver];
     CallController* cc2 = [CallController callControllerForCallInitiatedLocally:false
                                                                withRemoteNumber:testPhoneNumber2
                                                   andOptionallySpecifiedContact:nil];
-    Future* f2 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u2 interopOptions:@[]]
-                                      andCallController:cc2];
+    TOCFuture* f2 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u2 interopOptions:@[]]
+                                         andCallController:cc2];
     
     testChurnUntil(!f1.isIncomplete && !f2.isIncomplete, 15.0);
-    test(f1.hasSucceeded);
-    test(f2.hasSucceeded);
+    test(f1.hasResult);
+    test(f2.hasResult);
     
     [cc1 terminateWithReason:CallTerminationType_HangupLocal withFailureInfo:nil andRelatedInfo:nil];
     [cc2 terminateWithReason:CallTerminationType_HangupLocal withFailureInfo:nil andRelatedInfo:nil];
@@ -62,22 +62,22 @@ -(void) testPerturbedZrtpHandshakeWithoutConfAck {
     CallController* cc1 = [CallController callControllerForCallInitiatedLocally:true
                                                                withRemoteNumber:testPhoneNumber1
                                                   andOptionallySpecifiedContact:nil];
-    Future* f1 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u1 interopOptions:@[]]
-                                      andCallController:cc1];
+    TOCFuture* f1 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u1 interopOptions:@[]]
+                                         andCallController:cc1];
     
     UdpSocket* u2 = [UdpSocket udpSocketTo:receiver];
     CallController* cc2 = [CallController callControllerForCallInitiatedLocally:false
                                                                withRemoteNumber:testPhoneNumber2
                                                   andOptionallySpecifiedContact:nil];
-    Future* f2 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u2 interopOptions:@[]]
-                                      andCallController:cc2];
+    TOCFuture* f2 = [ZrtpManager asyncPerformHandshakeOver:[RtpSocket rtpSocketOverUdp:u2 interopOptions:@[]]
+                                         andCallController:cc2];
     
     testChurnUntil(!f2.isIncomplete, 15.0);
-    test(f2.hasSucceeded);
+    test(f2.hasResult);
     test(f1.isIncomplete);
     
     // send authenticated data to signal end of handshake
-    if (f2.hasSucceeded) {
+    if (f2.hasResult) {
         ZrtpHandshakeResult* result = [f2 forceGetResult];
         SrtpSocket* socket = [result secureRtpSocket];
         [socket startWithHandler:[PacketHandler packetHandler:^(id packet) { test(false); }
@@ -88,7 +88,7 @@ -(void) testPerturbedZrtpHandshakeWithoutConfAck {
     
     
     testChurnUntil(!f1.isIncomplete, 5.0);
-    test(f1.hasSucceeded);
+    test(f1.hasResult);
     
     [cc1 terminateWithReason:CallTerminationType_HangupLocal withFailureInfo:nil andRelatedInfo:nil];
     [cc2 terminateWithReason:CallTerminationType_HangupLocal withFailureInfo:nil andRelatedInfo:nil];
diff --git a/Signal/test/network/tcp/LowLatencyConnectorTest.m b/Signal/test/network/tcp/LowLatencyConnectorTest.m
index eb072054dd7..470f65a09ea 100644
--- a/Signal/test/network/tcp/LowLatencyConnectorTest.m
+++ b/Signal/test/network/tcp/LowLatencyConnectorTest.m
@@ -4,12 +4,9 @@
 #import "Util.h"
 #import "HostNameEndPoint.h"
 #import "TestUtil.h"
-#import "Future.h"
-#import "CancelledToken.h"
 #import "ThreadManager.h"
 
 @interface LowLatencyConnectorTest : XCTestCase
-
 @end
 
 @implementation LowLatencyConnectorTest
@@ -23,9 +20,9 @@ -(void) testLowLatencyConnect_example {
 
     NSString* reliableHostName = @"example.com";
     
-    Future* f = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:[HostNameEndPoint hostNameEndPointWithHostName:reliableHostName
-                                                                                                             andPort:80]
-                                                       untilCancelled:nil];
+    TOCFuture* f = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:[HostNameEndPoint hostNameEndPointWithHostName:reliableHostName
+                                                                                                                andPort:80]
+                                                          untilCancelled:nil];
     
     testChurnUntil(!f.isIncomplete, 5.0);
     
@@ -54,9 +51,9 @@ -(void) testLowLatencyConnect_google {
     
     NSString* reliableHostNameKnownToHaveMultipleIps = @"google.com";
     
-    Future* f = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:[HostNameEndPoint hostNameEndPointWithHostName:reliableHostNameKnownToHaveMultipleIps
-                                                                                                             andPort:80]
-                                                       untilCancelled:nil];
+    TOCFuture* f = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:[HostNameEndPoint hostNameEndPointWithHostName:reliableHostNameKnownToHaveMultipleIps
+                                                                                                                andPort:80]
+                                                          untilCancelled:nil];
     
     testChurnUntil(!f.isIncomplete, 5.0);
     
@@ -84,8 +81,8 @@ -(void) testLowLatencyConnect_google {
 -(void) testCancelledLowLatencyConnect {
     NSString* reliableHostName = @"example.com";
     
-    Future* f = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:[HostNameEndPoint hostNameEndPointWithHostName:reliableHostName andPort:80]
-                                                       untilCancelled:[CancelledToken cancelledToken]];
+    TOCFuture* f = [LowLatencyConnector asyncLowLatencyConnectToEndPoint:[HostNameEndPoint hostNameEndPointWithHostName:reliableHostName andPort:80]
+                                                          untilCancelled:TOCCancelToken.cancelledToken];
     
     testChurnUntil(!f.isIncomplete, 5.0);
     
diff --git a/Signal/test/network/tcp/tls/NetworkStreamTest.m b/Signal/test/network/tcp/tls/NetworkStreamTest.m
index 8a836728b87..b70092f59b6 100644
--- a/Signal/test/network/tcp/tls/NetworkStreamTest.m
+++ b/Signal/test/network/tcp/tls/NetworkStreamTest.m
@@ -89,11 +89,11 @@ -(void) testAuthenticationPass {
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         test(false);
     }]];
-    Future* f = [s asyncConnectionCompleted];
+    TOCFuture* f = [s asyncConnectionCompleted];
     
     testChurnUntil(!f.isIncomplete, 5.0);
     
-    test(f.hasSucceeded && [[f forceGetResult] isEqual:@YES]);
+    test(f.hasResult && [[f forceGetResult] isEqual:@YES]);
     
     [s terminate];
 }
diff --git a/Signal/test/network/udp/UdpSocketTest.m b/Signal/test/network/udp/UdpSocketTest.m
index f97448704a6..7c47fb7204b 100644
--- a/Signal/test/network/udp/UdpSocketTest.m
+++ b/Signal/test/network/udp/UdpSocketTest.m
@@ -1,11 +1,10 @@
 #import <XCTest/XCTest.h>
-#import "UdpSocket.h"
-#import "Util.h"
-#import "IpAddress.h"
 #import <CoreFoundation/CFSocket.h>
+#import "IpAddress.h"
 #import "TestUtil.h"
 #import "ThreadManager.h"
-#import "CancelTokenSource.h"
+#import "UdpSocket.h"
+#import "Util.h"
 
 @interface UdpSocketTest : XCTestCase
 
@@ -13,8 +12,8 @@ @interface UdpSocketTest : XCTestCase
 
 @implementation UdpSocketTest
 -(void) testSpecifiedPortLocally {
-    CancelTokenSource* receiverLife = [CancelTokenSource cancelTokenSource];
-    CancelTokenSource* senderLife = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* receiverLife = [TOCCancelTokenSource new];
+    TOCCancelTokenSource* senderLife = [TOCCancelTokenSource new];
     
     __block NSData* received = nil;
     __block bool senderReceivedData = false;
@@ -31,14 +30,14 @@ -(void) testSpecifiedPortLocally {
         received = packet;
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         test(false);
-    }] untilCancelled:[receiverLife getToken]];
+    }] untilCancelled:receiverLife.token];
     __block bool failed = false;
     [sender startWithHandler:[PacketHandler packetHandler:^(NSData* packet) {
         // there's a length check here because when the destination is unreachable the sender sometimes gets a superfluous empty data callback... no idea why.
         senderReceivedData |= packet.length > 0;
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         failed = true;
-    }] untilCancelled:[senderLife getToken]];
+    }] untilCancelled:senderLife.token];
     
     test(receiver.isLocalPortKnown);
     test([receiver localPort] == port1);
@@ -64,8 +63,8 @@ -(void) testSpecifiedPortLocally {
     test(!senderReceivedData);
 }
 -(void) testArbitraryPortLocally {
-    CancelTokenSource* receiverLife = [CancelTokenSource cancelTokenSource];
-    CancelTokenSource* senderLife = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* receiverLife = [TOCCancelTokenSource new];
+    TOCCancelTokenSource* senderLife = [TOCCancelTokenSource new];
     
     __block NSData* received = nil;
     __block bool senderReceivedData = false;
@@ -83,7 +82,7 @@ -(void) testArbitraryPortLocally {
         }
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         test(false);
-    }] untilCancelled:[receiverLife getToken]];
+    }] untilCancelled:receiverLife.token];
     
     __block bool failed = false;
     UdpSocket* sender = [UdpSocket udpSocketFromLocalPort:unusedPort
@@ -94,7 +93,7 @@ -(void) testArbitraryPortLocally {
         senderReceivedData |= packet.length > 0;
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         failed = true;
-    }] untilCancelled:[senderLife getToken]];
+    }] untilCancelled:senderLife.token];
     
     
     testChurnAndConditionMustStayTrue(received == nil, 0.1);
@@ -115,8 +114,8 @@ -(void) testArbitraryPortLocally {
     test(!senderReceivedData);
 }
 -(void) testUdpListen {
-    CancelTokenSource* receiverLife = [CancelTokenSource cancelTokenSource];
-    CancelTokenSource* senderLife = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* receiverLife = [TOCCancelTokenSource new];
+    TOCCancelTokenSource* senderLife = [TOCCancelTokenSource new];
     
     __block NSUInteger listenerReceiveCount = 0;
     __block NSUInteger listenerReceiveLength = 0;
@@ -134,7 +133,7 @@ -(void) testUdpListen {
         listenerReceivedLast = packet;
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         test(false);
-    }] untilCancelled:[receiverLife getToken]];
+    }] untilCancelled:receiverLife.token];
     
     IpEndPoint* e = [IpEndPoint ipEndPointAtAddress:[IpAddress localhost] onPort:port];
     UdpSocket* client = [UdpSocket udpSocketTo:e];
@@ -144,7 +143,7 @@ -(void) testUdpListen {
         clientReceivedLast = packet;
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         test(false);
-    }] untilCancelled:[senderLife getToken]];
+    }] untilCancelled:senderLife.token];
     
     test(!listener.isRemoteEndPointKnown);
     testThrows([listener remoteEndPoint]);
@@ -172,7 +171,7 @@ -(void) testUdpListen {
     [senderLife cancel];
 }
 -(void) testUdpFail {
-    CancelTokenSource* life = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* life = [TOCCancelTokenSource new];
     
     in_port_t unusedPort = 10000 + (in_port_t)arc4random_uniform(30000);
     UdpSocket* udp = [UdpSocket udpSocketTo:[IpEndPoint ipEndPointAtAddress:[IpAddress localhost] onPort:unusedPort]];
@@ -181,7 +180,7 @@ -(void) testUdpFail {
         test(false);
     } withErrorHandler:^(id error, id relatedInfo, bool causedTermination) {
         failed = true;
-    }] untilCancelled:[life getToken]];
+    }] untilCancelled:life.token];
     
     [udp send:increasingData(20)];
     testChurnUntil(failed, 1.0);
diff --git a/Signal/test/util/CancelTokenTest.h b/Signal/test/util/CancelTokenTest.h
deleted file mode 100644
index fb49a5899fb..00000000000
--- a/Signal/test/util/CancelTokenTest.h
+++ /dev/null
@@ -1,5 +0,0 @@
-#import <XCTest/XCTest.h>
-
-@interface CancelTokenTest : XCTestCase
-
-@end
diff --git a/Signal/test/util/CancelTokenTest.m b/Signal/test/util/CancelTokenTest.m
deleted file mode 100644
index ae28d41e2c3..00000000000
--- a/Signal/test/util/CancelTokenTest.m
+++ /dev/null
@@ -1,81 +0,0 @@
-#import "CancelTokenTest.h"
-#import "CancelTokenSource.h"
-#import "CancelledToken.h"
-#import "TestUtil.h"
-#import "Util.h"
-
-@interface OnDealloc : NSObject {
-@private void (^action)();
-}
-+(OnDealloc*) onDealloc:(void(^)())action;
-@end
-@implementation OnDealloc
-+(OnDealloc*) onDealloc:(void(^)())action {
-    OnDealloc* d = [OnDealloc new];
-    d->action = [action copy];
-    return d;
-}
--(void) dealloc {
-    action();
-}
-@end
-
-@implementation CancelTokenTest
-
--(void) testCancelTokenSource {
-    CancelTokenSource* s = [CancelTokenSource cancelTokenSource];
-    id<CancelToken> c = [s getToken];
-    __block int n = 0;
-    [c whenCancelled:^{n += 1;}];
-    [c whenCancelled:^{n += 1;}];
-    test(n == 0);
-    [s cancel];
-    test(n == 2);
-    [c whenCancelled:^{n += 1;}];
-    test(n == 3);
-}
--(void) testCancelledToken {
-    __block int n = 0;
-    [[CancelledToken cancelledToken] whenCancelled:^{n += 1;}];
-    test(n == 1);
-}
--(void) testCallbacksDeallocWhenSourceDeallocs {
-    __block bool dealloced = false;
-    __block id<CancelToken> c = nil;
-    NSObject* lock = [NSObject new];
-    [Operation asyncRunOnNewThread:^{
-        OnDealloc* d = [OnDealloc onDealloc:^{
-            @synchronized(lock) {
-                dealloced = true;
-            }
-        }];
-        CancelTokenSource* s = [CancelTokenSource cancelTokenSource];
-        c = [s getToken];
-        
-        // hold reference to 'd' in callback
-        [c whenCancelled:^{
-            if (d != nil) {
-                @synchronized(lock) {
-                    // should never run
-                    test(false);
-                    dealloced = true;
-                }
-            }
-        }];
-        
-        // s goes out of scope, gets dealloced, cancellation becomes impossible
-        // local reference to d and callback reference should both go away, causing d to be dealloced
-    }];
-    
-    // spin lock
-    while (true) {
-        @synchronized(lock) {
-            if (dealloced) break;
-        }
-    }
-    test(c != nil);
-    test(!c.isAlreadyCancelled);
-    test(dealloced);
-}
-
-@end
diff --git a/Signal/test/util/FutureUtilTest.m b/Signal/test/util/FutureUtilTest.m
new file mode 100644
index 00000000000..cd7e826e722
--- /dev/null
+++ b/Signal/test/util/FutureUtilTest.m
@@ -0,0 +1,142 @@
+#import <XCTest/XCTest.h>
+#import "TestUtil.h"
+#import "ThreadManager.h"
+#import "Util.h"
+
+@interface FutureUtilTest:XCTestCase
+@end
+
+@implementation FutureUtilTest
+
+-(void)testOperationTry {
+    TOCFuture* f = [TOCFuture operationTry:^TOCFuture*(TOCCancelToken *_) { @throw @"Fail"; }](nil);
+    test([f isEqualToFuture:[TOCFuture futureWithFailure:@"Fail"]]);
+}
+
+-(void)testThenValue {
+    test([[[TOCFuture futureWithFailure:@0] thenValue:@""] isEqualToFuture:[TOCFuture futureWithFailure:@0]]);
+    test([[[TOCFuture futureWithResult:@1] thenValue:@""] isEqualToFuture:[TOCFuture futureWithResult:@""]]);
+    test([[TOCFutureSource new].future thenValue:@""].isIncomplete);
+}
+
+-(void)testFinallyTry {
+    test([[[TOCFuture futureWithResult:@1] finallyTry:^(TOCFuture* f) { return @""; }] isEqualToFuture:[TOCFuture futureWithResult:@""]]);
+    test([[[TOCFuture futureWithFailure:@0] finallyTry:^(TOCFuture* f) { return @""; }] isEqualToFuture:[TOCFuture futureWithResult:@""]]);
+    test([[TOCFutureSource new].future finallyTry:^(TOCFuture* f) { return @""; }].isIncomplete);
+    
+    test([[[TOCFuture futureWithResult:@1] finallyTry:^id(TOCFuture* f) { @throw @""; }] isEqualToFuture:[TOCFuture futureWithFailure:@""]]);
+    test([[[TOCFuture futureWithFailure:@0] finallyTry:^id(TOCFuture* f) { @throw @""; }] isEqualToFuture:[TOCFuture futureWithFailure:@""]]);
+    test([[TOCFutureSource new].future finallyTry:^id(TOCFuture* f) { @throw @""; }].isIncomplete);
+}
+-(void)testThenTry {
+    test([[[TOCFuture futureWithResult:@1] thenTry:^(id f) { return @""; }] isEqualToFuture:[TOCFuture futureWithResult:@""]]);
+    test([[[TOCFuture futureWithFailure:@0] thenTry:^(id f) { return @""; }] isEqualToFuture:[TOCFuture futureWithFailure:@0]]);
+    test([[TOCFutureSource new].future thenTry:^(id f) { return @""; }].isIncomplete);
+    
+    test([[[TOCFuture futureWithResult:@1] thenTry:^id(id f) { @throw @""; }] isEqualToFuture:[TOCFuture futureWithFailure:@""]]);
+    test([[[TOCFuture futureWithFailure:@0] thenTry:^id(id f) { @throw @""; }] isEqualToFuture:[TOCFuture futureWithFailure:@0]]);
+    test([[TOCFutureSource new].future thenTry:^id(id f) { @throw @""; }].isIncomplete);
+}
+-(void)testCatchTry {
+    test([[[TOCFuture futureWithResult:@1] catchTry:^(id f) { return @""; }] isEqualToFuture:[TOCFuture futureWithResult:@1]]);
+    test([[[TOCFuture futureWithFailure:@0] catchTry:^(id f) { return @""; }] isEqualToFuture:[TOCFuture futureWithResult:@""]]);
+    test([[TOCFutureSource new].future catchTry:^(id f) { return @""; }].isIncomplete);
+    
+    test([[[TOCFuture futureWithResult:@1] catchTry:^id(id f) { @throw @""; }] isEqualToFuture:[TOCFuture futureWithResult:@1]]);
+    test([[[TOCFuture futureWithFailure:@0] catchTry:^id(id f) { @throw @""; }] isEqualToFuture:[TOCFuture futureWithFailure:@""]]);
+    test([[TOCFutureSource new].future catchTry:^id(id f) { @throw @""; }].isIncomplete);
+}
+
+-(void) testRetry_pass {
+    __block NSUInteger repeat = 0;
+    __block NSUInteger evalCount = 0;
+    TOCUntilOperation op = ^(TOCCancelToken* c) {
+        repeat += 1;
+        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return @YES; }
+                               afterDelay:0.35
+                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
+                          unlessCancelled:c];
+    };
+    TOCFuture* f = [TOCFuture retry:op
+                         upToNTimes:4
+                    withBaseTimeout:0.5/8
+                     andRetryFactor:2
+                     untilCancelled:nil];
+    testChurnUntil(!f.isIncomplete, 500.0);
+    
+    test(repeat == 3 || repeat == 4);
+    test(evalCount == 1);
+    test(f.hasResult);
+    test([[f forceGetResult] isEqual:@YES]);
+}
+-(void) testRetry_fail {
+    __block NSUInteger repeat = 0;
+    __block NSUInteger evalCount = 0;
+    TOCUntilOperation op = ^(TOCCancelToken* c) {
+        repeat += 1;
+        return [TimeUtil scheduleEvaluate:^{ evalCount++; return [TOCFuture futureWithFailure:@13]; }
+                               afterDelay:0.1
+                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
+                          unlessCancelled:c];
+    };
+    TOCFuture* f = [TOCFuture retry:op
+                         upToNTimes:4
+                    withBaseTimeout:0.5/8
+                     andRetryFactor:2
+                     untilCancelled:nil];
+    testChurnUntil(!f.isIncomplete, 5.0);
+    
+    test(repeat >= 1);
+    test(evalCount >= 1);
+    test(f.hasFailed);
+    test([f.forceGetFailure isEqual:@13]);
+}
+-(void) testRetry_timeout {
+    __block NSUInteger repeat = 0;
+    __block NSUInteger evalCount = 0;
+    TOCUntilOperation op = ^(TOCCancelToken* c) {
+        repeat += 1;
+        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return @YES; }
+                               afterDelay:0.5
+                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
+                          unlessCancelled:c];
+    };
+    TOCFuture* f = [TOCFuture retry:op
+                         upToNTimes:2
+                    withBaseTimeout:0.5/8
+                     andRetryFactor:2
+                     untilCancelled:nil];
+    testChurnUntil(!f.isIncomplete, 5.0);
+    
+    test(repeat == 2);
+    test(evalCount == 0);
+    test(f.hasFailedWithTimeout);
+}
+-(void) testRetry_cancel {
+    TOCCancelTokenSource* s = [TOCCancelTokenSource new];
+    __block NSUInteger repeat = 0;
+    __block NSUInteger evalCount = 0;
+    TOCUntilOperation op = ^(TOCCancelToken* c) {
+        repeat += 1;
+        [TimeUtil scheduleRun:^{ [s cancel]; }
+                   afterDelay:0.1
+                    onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
+              unlessCancelled:nil];
+        return [TimeUtil scheduleEvaluate:^id{ evalCount++; return @YES; }
+                               afterDelay:0.5
+                                onRunLoop:[ThreadManager normalLatencyThreadRunLoop]
+                          unlessCancelled:c];
+    };
+    TOCFuture* f = [TOCFuture retry:op
+                         upToNTimes:2
+                    withBaseTimeout:0.5/8
+                     andRetryFactor:2
+                     untilCancelled:s.token];
+    testChurnUntil(!f.isIncomplete, 5.0);
+    
+    test(repeat == 2);
+    test(evalCount == 0);
+    test(f.hasFailedWithCancel);
+}
+
+@end
diff --git a/Signal/test/async/ObservableTest.m b/Signal/test/util/ObservableTest.m
similarity index 86%
rename from Signal/test/async/ObservableTest.m
rename to Signal/test/util/ObservableTest.m
index a0c54c881b8..0542423f9b9 100644
--- a/Signal/test/async/ObservableTest.m
+++ b/Signal/test/util/ObservableTest.m
@@ -1,10 +1,8 @@
 #import <XCTest/XCTest.h>
 #import "ObservableValue.h"
 #import "TestUtil.h"
-#import "CancelTokenSource.h"
 
 @interface ObservableTest : XCTestCase
-
 @end
 
 @implementation ObservableTest
@@ -13,10 +11,10 @@ -(void) testObservableAddRemove {
     ObservableValueController* s = [ObservableValueController observableValueControllerWithInitialValue:@""];
     ObservableValue* t = s;
     NSMutableArray* a = [NSMutableArray array];
-    CancelTokenSource* c = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* c = [TOCCancelTokenSource new];
     
     [t watchLatestValueOnArbitraryThread:^(id value) {[a addObject:value];}
-                          untilCancelled:[c getToken]];
+                          untilCancelled:c.token];
     
     test([a isEqualToArray:@[@""]]);
     [s updateValue:@5];
@@ -31,14 +29,14 @@ -(void) testObservableAddAdd {
     ObservableValueController* s = [ObservableValueController observableValueControllerWithInitialValue:@""];
     ObservableValue* t = s;
     NSMutableArray* a = [NSMutableArray array];
-    CancelTokenSource* c = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* c = [TOCCancelTokenSource new];
     
     [t watchLatestValueOnArbitraryThread:^(id value) {[a addObject:value];}
-                          untilCancelled:[c getToken]];
+                          untilCancelled:c.token];
     [t watchLatestValueOnArbitraryThread:^(id value) {[a addObject:value];}
-                          untilCancelled:[c getToken]];
+                          untilCancelled:c.token];
     [t watchLatestValueOnArbitraryThread:^(id value) {[a addObject:value];}
-                          untilCancelled:[c getToken]];
+                          untilCancelled:c.token];
     
     test([a isEqualToArray:(@[@"", @"", @""])]);
     [s updateValue:@5];
@@ -83,7 +81,7 @@ -(void) testObservableReentrantAdd {
     ObservableValueController* s = [ObservableValueController observableValueControllerWithInitialValue:@""];
     ObservableValue* t = s;
     NSMutableArray* a = [NSMutableArray array];
-    CancelTokenSource* c = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* c = [TOCCancelTokenSource new];
     
     __block void(^registerSelf)() = nil;
     void(^registerSelf_builder)() = ^{
@@ -92,7 +90,7 @@ -(void) testObservableReentrantAdd {
             if (!first) registerSelf();
             first = false;
             [a addObject:value];
-        } untilCancelled:[c getToken]];
+        } untilCancelled:c.token];
     };
     registerSelf = [registerSelf_builder copy];
     registerSelf();
@@ -111,7 +109,7 @@ -(void) testObservableReentrantRemove {
     ObservableValueController* s = [ObservableValueController observableValueControllerWithInitialValue:@""];
     ObservableValue* t = s;
     NSMutableArray* a = [NSMutableArray array];
-    CancelTokenSource* c = [CancelTokenSource cancelTokenSource];
+    TOCCancelTokenSource* c = [TOCCancelTokenSource new];
     
     for (int i = 0; i < 3; i++) {
         __block bool first = true;
@@ -121,7 +119,7 @@ -(void) testObservableReentrantRemove {
                 [a addObject:value];
             }
             first = false;
-        } untilCancelled:[c getToken]];
+        } untilCancelled:c.token];
     }
     
     // removing during a callback counts as removing after the callback
