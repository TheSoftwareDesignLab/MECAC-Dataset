diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index d20c95ee41e..36792262496 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -2020,6 +2020,8 @@
 		F9C612B4284E466B00B2199A /* CGPointExtensionsTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9C612B3284E466B00B2199A /* CGPointExtensionsTest.swift */; };
 		F9CA468828FF0CA600C074F6 /* OneTimeDonationCustomAmountTextField.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9CA468728FF0CA600C074F6 /* OneTimeDonationCustomAmountTextField.swift */; };
 		F9CAC77F29199B9200EEC1DE /* StringTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9CAC77E29199B9200EEC1DE /* StringTest.swift */; };
+		F9CAC7832919B35E00EEC1DE /* PhoneNumberRegions.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9CAC7822919B35E00EEC1DE /* PhoneNumberRegions.swift */; };
+		F9CAC7852919B5A400EEC1DE /* PhoneNumberRegionsTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9CAC7842919B5A400EEC1DE /* PhoneNumberRegionsTest.swift */; };
 		F9D83012282DBB1500399363 /* BadgeGiftingChooseBadgeViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9D83011282DBB1500399363 /* BadgeGiftingChooseBadgeViewController.swift */; };
 		F9DD70B92811AF82000C5960 /* DonationViewsUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9DD70B82811AF82000C5960 /* DonationViewsUtil.swift */; };
 		F9F4DE2A283FDFDA001909ED /* BadgeGiftingConfirmationViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9F4DE29283FDFDA001909ED /* BadgeGiftingConfirmationViewController.swift */; };
@@ -4378,6 +4380,8 @@
 		F9C985D2289459860029F9AD /* SignalServiceKit-Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "SignalServiceKit-Prefix.pch"; sourceTree = "<group>"; };
 		F9CA468728FF0CA600C074F6 /* OneTimeDonationCustomAmountTextField.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OneTimeDonationCustomAmountTextField.swift; sourceTree = "<group>"; };
 		F9CAC77E29199B9200EEC1DE /* StringTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StringTest.swift; sourceTree = "<group>"; };
+		F9CAC7822919B35E00EEC1DE /* PhoneNumberRegions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PhoneNumberRegions.swift; sourceTree = "<group>"; };
+		F9CAC7842919B5A400EEC1DE /* PhoneNumberRegionsTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PhoneNumberRegionsTest.swift; sourceTree = "<group>"; };
 		F9D83011282DBB1500399363 /* BadgeGiftingChooseBadgeViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeGiftingChooseBadgeViewController.swift; sourceTree = "<group>"; };
 		F9DD70B82811AF82000C5960 /* DonationViewsUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationViewsUtil.swift; sourceTree = "<group>"; };
 		F9F4DE29283FDFDA001909ED /* BadgeGiftingConfirmationViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeGiftingConfirmationViewController.swift; sourceTree = "<group>"; };
@@ -7060,6 +7064,7 @@
 				F97217F528DC9A5000113D9F /* OWSFileSystemTest.swift */,
 				F94261EE289B1B5400460798 /* OWSFormatTest.swift */,
 				F94261FB289B1B5400460798 /* OWSOperationTest.swift */,
+				F9CAC7842919B5A400EEC1DE /* PhoneNumberRegionsTest.swift */,
 				F908AA7728CB894400472E68 /* PngChunkerTest.swift */,
 				F94261F0289B1B5400460798 /* RefineryTest.swift */,
 				F94261EC289B1B5400460798 /* RemoteConfigManagerTests.swift */,
@@ -8244,6 +8249,7 @@
 				F9C5CAFE289453B200548EEE /* OWSUserProfile.swift */,
 				F9C5CAFB289453B200548EEE /* ParamParser.swift */,
 				F9C5CB4E289453B200548EEE /* PendingTasks.swift */,
+				F9CAC7822919B35E00EEC1DE /* PhoneNumberRegions.swift */,
 				F9C5CB1D289453B200548EEE /* PinnedThreadManager.swift */,
 				F9C5CB58289453B200548EEE /* Platform.swift */,
 				F908AA7928CB89CC00472E68 /* PngChunker.swift */,
@@ -10991,6 +10997,7 @@
 				F9C5CE20289453B400548EEE /* PendingTasks.swift in Sources */,
 				F9C5CD56289453B300548EEE /* PendingViewedReceiptRecord.swift in Sources */,
 				F9C5CCBC289453B300548EEE /* PhoneNumber.m in Sources */,
+				F9CAC7832919B35E00EEC1DE /* PhoneNumberRegions.swift in Sources */,
 				F9C5CCBB289453B300548EEE /* PhoneNumberUtil.m in Sources */,
 				F9C5CCD6289453B300548EEE /* PhoneNumberUtil.swift in Sources */,
 				F9C5CDEF289453B400548EEE /* PinnedThreadManager.swift in Sources */,
@@ -11275,6 +11282,7 @@
 				F9426244289B1B5500460798 /* OWSRequestFactoryTest.swift in Sources */,
 				F942629F289B1B5600460798 /* OWSUDManagerTest.swift in Sources */,
 				F9426242289B1B5500460798 /* OWSURLBuilderUtilTest.swift in Sources */,
+				F9CAC7852919B5A400EEC1DE /* PhoneNumberRegionsTest.swift in Sources */,
 				F9426280289B1B5600460798 /* PhoneNumberTest.m in Sources */,
 				F9426274289B1B5500460798 /* PhoneNumberTest.swift in Sources */,
 				F9426272289B1B5500460798 /* PhoneNumberUtilTest.m in Sources */,
diff --git a/Signal/src/Experience Upgrades/Upgrade Views/RemoteMegaphone.swift b/Signal/src/Experience Upgrades/Upgrade Views/RemoteMegaphone.swift
index 4e0be89feeb..cf4a65cd441 100644
--- a/Signal/src/Experience Upgrades/Upgrade Views/RemoteMegaphone.swift	
+++ b/Signal/src/Experience Upgrades/Upgrade Views/RemoteMegaphone.swift	
@@ -4,6 +4,7 @@
 //
 
 import Foundation
+import SignalMessaging
 
 class RemoteMegaphone: MegaphoneView {
     private let megaphoneModel: RemoteMegaphoneModel
@@ -83,14 +84,35 @@ class RemoteMegaphone: MegaphoneView {
             markAsCompleteWithSneakyTransaction()
             dismiss()
         case .donate:
-            let navController = OWSNavigationController(rootViewController: DonationSettingsViewController())
-            fromViewController.present(navController, animated: true) { [weak self] in
-                guard let self = self else { return }
-
-                // Snooze regardless of outcome from donation screen.
+            let done = { [weak self] in
+                guard let self else { return }
+                // Snooze regardless of outcome.
                 self.markAsSnoozedWithSneakyTransaction()
                 self.dismiss(animated: false)
             }
+
+            guard DonationUtilities.canDonate(localNumber: Self.tsAccountManager.localNumber) else {
+                done()
+                DonationViewsUtil.openDonateWebsite()
+                return
+            }
+
+            let donateVc = DonateViewController(startingDonationMode: .oneTime) { finishResult in
+                let frontVc = { CurrentAppContext().frontmostViewController() }
+                switch finishResult {
+                case let .completedDonation(donateSheet, thanksSheet):
+                    donateSheet.dismiss(animated: true) {
+                        frontVc()?.present(thanksSheet, animated: true)
+                    }
+                case let .monthlySubscriptionCancelled(donateSheet, toastText):
+                    donateSheet.dismiss(animated: true) {
+                        frontVc()?.presentToast(text: toastText)
+                    }
+                }
+            }
+
+            let navController = OWSNavigationController(rootViewController: donateVc)
+            fromViewController.present(navController, animated: true, completion: done)
         case .unrecognized(let actionId):
             owsFailDebug("Unrecognized action with ID \(actionId) should never have made it into \(buttonDescriptor) button!")
             dismiss()
diff --git a/Signal/src/ViewControllers/AppSettings/Donations/DonationSettingsViewController.swift b/Signal/src/ViewControllers/AppSettings/Donations/DonationSettingsViewController.swift
index e0d89277590..08678d19b98 100644
--- a/Signal/src/ViewControllers/AppSettings/Donations/DonationSettingsViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/Donations/DonationSettingsViewController.swift
@@ -69,6 +69,12 @@ class DonationSettingsViewController: OWSTableViewController2 {
 
     private lazy var statusLabel = LinkingTextView()
 
+    private static var canDonate: Bool {
+        DonationUtilities.canDonate(localNumber: tsAccountManager.localNumber)
+    }
+
+    private static var canSendGiftBadges: Bool { RemoteConfig.canSendGiftBadges && canDonate }
+
     public override func viewDidLoad() {
         super.viewDidLoad()
         setUpAvatarView()
@@ -266,11 +272,11 @@ class DonationSettingsViewController: OWSTableViewController2 {
                 comment: "On the donation settings screen, tapping this button will take the user to a screen where they can donate."
             )
             let button = OWSButton(title: buttonTitle) { [weak self] in
-                guard DonationUtilities.isApplePayAvailable else {
+                if Self.canDonate {
+                    self?.showDonateViewController(startingDonationMode: .oneTime)
+                } else {
                     DonationViewsUtil.openDonateWebsite()
-                    return
                 }
-                self?.showDonateViewController(startingDonationMode: .oneTime)
             }
             button.dimsWhenHighlighted = true
             button.layer.cornerRadius = 8
@@ -365,7 +371,7 @@ class DonationSettingsViewController: OWSTableViewController2 {
     }
 
     private func otherWaysToGiveSection() -> OWSTableSection? {
-        guard DonationUtilities.canSendGiftBadges else { return nil }
+        guard Self.canSendGiftBadges else { return nil }
 
         let title = NSLocalizedString("DONATION_VIEW_OTHER_WAYS_TO_GIVE_TITLE",
                                                          comment: "Title for the 'other ways to give' section on the donation view")
@@ -381,7 +387,7 @@ class DonationSettingsViewController: OWSTableViewController2 {
                 // It's possible (but unlikely) to lose the ability to send gifts while this button is
                 // visible. For example, Apple Pay could be disabled in parental controls after this
                 // screen is opened.
-                guard DonationUtilities.canSendGiftBadges else {
+                guard Self.canSendGiftBadges else {
                     // We might want to show a better UI here, but making the button a no-op is
                     // preferable to launching the view controller.
                     return
diff --git a/Signal/src/ViewControllers/Donations/BadgeDetailsSheet.swift b/Signal/src/ViewControllers/Donations/BadgeDetailsSheet.swift
index dd92afc4065..298e1df5ea8 100644
--- a/Signal/src/ViewControllers/Donations/BadgeDetailsSheet.swift
+++ b/Signal/src/ViewControllers/Donations/BadgeDetailsSheet.swift
@@ -163,7 +163,7 @@ class BadgeDetailsSheet: OWSTableSheetViewController {
     @objc
     private func didTapDonate() {
         dismiss(animated: true) {
-            if DonationUtilities.isApplePayAvailable {
+            if DonationUtilities.canDonate(localNumber: Self.tsAccountManager.localNumber) {
                 let frontVc = { CurrentAppContext().frontmostViewController() }
 
                 let donateVc = DonateViewController(startingDonationMode: .oneTime) { finishResult in
diff --git a/Signal/src/ViewControllers/Donations/BadgeExpirationSheet.swift b/Signal/src/ViewControllers/Donations/BadgeExpirationSheet.swift
index ee26c413b4d..654da6a534d 100644
--- a/Signal/src/ViewControllers/Donations/BadgeExpirationSheet.swift
+++ b/Signal/src/ViewControllers/Donations/BadgeExpirationSheet.swift
@@ -51,10 +51,12 @@ public class BadgeExpirationSheetState {
 
     public let badge: ProfileBadge
     private let mode: Mode
+    private let canDonate: Bool
 
-    public init(badge: ProfileBadge, mode: Mode) {
+    public init(badge: ProfileBadge, mode: Mode, canDonate: Bool) {
         self.badge = badge
         self.mode = mode
+        self.canDonate = canDonate
     }
 
     public lazy var titleText: String = {
@@ -173,6 +175,10 @@ public class BadgeExpirationSheetState {
     public lazy var actionButton: ActionButton = {
         lazy var okayButton = ActionButton(action: .dismiss, text: CommonStrings.okayButton)
 
+        guard canDonate else {
+            return okayButton
+        }
+
         switch mode {
         case .subscriptionExpiredBecauseNotRenewed:
             let text = NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_RENEWAL_BUTTON",
@@ -210,7 +216,11 @@ class BadgeExpirationSheet: OWSTableSheetViewController {
     public weak var delegate: BadgeExpirationSheetDelegate?
 
     public init(badge: ProfileBadge, mode: BadgeExpirationSheetState.Mode) {
-        self.state = BadgeExpirationSheetState(badge: badge, mode: mode)
+        self.state = BadgeExpirationSheetState(
+            badge: badge,
+            mode: mode,
+            canDonate: DonationUtilities.canDonate(localNumber: Self.tsAccountManager.localNumber)
+        )
         owsAssertDebug(state.badge.assets != nil)
 
         super.init()
diff --git a/Signal/src/ViewControllers/Donations/DonateChoosePaymentMethodSheet.swift b/Signal/src/ViewControllers/Donations/DonateChoosePaymentMethodSheet.swift
index f1fd781779c..fbe6c796aed 100644
--- a/Signal/src/ViewControllers/Donations/DonateChoosePaymentMethodSheet.swift
+++ b/Signal/src/ViewControllers/Donations/DonateChoosePaymentMethodSheet.swift
@@ -153,8 +153,7 @@ class DonateChoosePaymentMethodSheet: InteractiveSheetViewController {
         }()
 
         let paymentButtonContainerView: UIView = {
-            // When we add other payment methods, we should hide this button if
-            // Apple Pay is unavailable.
+            // TODO(donations) When we add other payment methods, we should hide this button if Apple Pay is unavailable.
             let applePayButton = ApplePayButton { [weak self] in
                 guard let self = self else { return }
                 self.didChoosePaymentMethod(self)
diff --git a/Signal/src/ViewControllers/Donations/DonateViewController.swift b/Signal/src/ViewControllers/Donations/DonateViewController.swift
index a1d2a014347..114d7c5cc47 100644
--- a/Signal/src/ViewControllers/Donations/DonateViewController.swift
+++ b/Signal/src/ViewControllers/Donations/DonateViewController.swift
@@ -11,6 +11,10 @@ import SignalServiceKit
 import SignalMessaging
 
 class DonateViewController: OWSViewController, OWSNavigationChildController {
+    private static var canMakeNewDonations: Bool {
+        DonationUtilities.canDonate(localNumber: tsAccountManager.localNumber)
+    }
+
     private var backgroundColor: UIColor {
         OWSTableViewController2.tableBackgroundColor(isUsingPresentedStyle: true)
     }
@@ -54,7 +58,11 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
         startingDonationMode: DonationMode,
         onFinished: @escaping (FinishResult) -> Void
     ) {
-        self.state = .init(donationMode: startingDonationMode)
+        if Self.canMakeNewDonations {
+            self.state = .init(donationMode: startingDonationMode)
+        } else {
+            self.state = .init(donationMode: .monthly)
+        }
         self.onFinished = onFinished
 
         super.init()
@@ -252,9 +260,9 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
         }
     }
 
-    private func didTapToContinueMonthlyDonation() {
+    private func didTapToStartNewMonthlyDonation() {
         guard let monthlyPaymentRequest = state.monthly?.paymentRequest else {
-            owsFail("[Donations] Cannot make monthly donation. This should be prevented in the UI")
+            owsFail("[Donations] Cannot start monthly donation. This should be prevented in the UI")
         }
         presentChoosePaymentMethodSheet(
             amount: monthlyPaymentRequest.amount,
@@ -263,6 +271,15 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
         )
     }
 
+    private func didConfirmMonthlyDonationUpdate() {
+        guard let monthlyPaymentRequest = state.monthly?.paymentRequest else {
+            owsFail("[Donations] Cannot update monthly donation. This should be prevented in the UI")
+        }
+
+        // TODO(donations) When we add other payment methods, we don't necessarily want to start Apple Pay in this case.
+        startApplePay(with: monthlyPaymentRequest.amount, donationMode: .monthly)
+    }
+
     private func didTapToUpdateMonthlyDonation() {
         guard let monthlyPaymentRequest = state.monthly?.paymentRequest else {
             owsFail("[Donations] Cannot update monthly donation. This should be prevented in the UI")
@@ -290,7 +307,7 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
             title: CommonStrings.continueButton,
             style: .default,
             handler: { [weak self] _ in
-                self?.didTapToContinueMonthlyDonation()
+                self?.didConfirmMonthlyDonationUpdate()
             }
         ))
         actionSheet.addAction(.init(
@@ -598,7 +615,12 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
             }
         }()
         if !wasLoaded || oldState?.donationMode != state.donationMode {
-            var subviews: [UIView] = [currencyPickerContainerView, donationModePickerView]
+            var subviews: [UIView] = [currencyPickerContainerView]
+
+            if Self.canMakeNewDonations {
+                subviews.append(donationModePickerView)
+            }
+
             switch donationMode {
             case .oneTime:
                 subviews.append(oneTimeView)
@@ -931,11 +953,11 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
         monthlySubscriptionLevelViews = monthly.subscriptionLevels
             .enumerated()
             .map { (index, subscriptionLevel) in
-            MonthlySubscriptionLevelView(
-                subscriptionLevel: subscriptionLevel,
-                animationName: animationNames[safe: index] ?? "boost_fire"
-            )
-        }
+                MonthlySubscriptionLevelView(
+                    subscriptionLevel: subscriptionLevel,
+                    animationName: animationNames[safe: index] ?? "boost_fire"
+                )
+            }
 
         for view in monthlySubscriptionLevelViews {
             let tap = UITapGestureRecognizer(
@@ -966,27 +988,29 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
         var buttons = [OWSButton]()
 
         if let currentSubscription = monthly.currentSubscription {
-            let updateTitle = NSLocalizedString(
-                "DONATE_SCREEN_UPDATE_MONTHLY_SUBSCRIPTION_BUTTON",
-                comment: "On the donation screen, if you already have a subscription, you'll see a button to update your subscription. This is the text on that button."
-            )
-            let updateButton = OWSButton(title: updateTitle) { [weak self] in
-                self?.didTapToUpdateMonthlyDonation()
-            }
-            updateButton.backgroundColor = .ows_accentBlue
-            updateButton.titleLabel?.font = UIFont.ows_dynamicTypeBody.ows_semibold
-            updateButton.isEnabled = {
-                if currentSubscription.amount.currencyCode != monthly.selectedCurrencyCode {
-                    return true
-                }
-                if
-                    let selectedSubscriptionLevel = monthly.selectedSubscriptionLevel,
-                    currentSubscription.level != selectedSubscriptionLevel.level {
-                    return true
+            if Self.canMakeNewDonations {
+                let updateTitle = NSLocalizedString(
+                    "DONATE_SCREEN_UPDATE_MONTHLY_SUBSCRIPTION_BUTTON",
+                    comment: "On the donation screen, if you already have a subscription, you'll see a button to update your subscription. This is the text on that button."
+                )
+                let updateButton = OWSButton(title: updateTitle) { [weak self] in
+                    self?.didTapToUpdateMonthlyDonation()
                 }
-                return false
-            }()
-            buttons.append(updateButton)
+                updateButton.backgroundColor = .ows_accentBlue
+                updateButton.titleLabel?.font = UIFont.ows_dynamicTypeBody.ows_semibold
+                updateButton.isEnabled = {
+                    if currentSubscription.amount.currencyCode != monthly.selectedCurrencyCode {
+                        return true
+                    }
+                    if
+                        let selectedSubscriptionLevel = monthly.selectedSubscriptionLevel,
+                        currentSubscription.level != selectedSubscriptionLevel.level {
+                        return true
+                    }
+                    return false
+                }()
+                buttons.append(updateButton)
+            }
 
             let cancelTitle = NSLocalizedString(
                 "SUSTAINER_VIEW_CANCEL_SUBSCRIPTION",
@@ -1000,7 +1024,7 @@ class DonateViewController: OWSViewController, OWSNavigationChildController {
             buttons.append(cancelButton)
         } else {
             let continueButton = OWSButton(title: CommonStrings.continueButton) { [weak self] in
-                self?.didTapToContinueMonthlyDonation()
+                self?.didTapToStartNewMonthlyDonation()
             }
             continueButton.layer.cornerRadius = 8
             continueButton.backgroundColor = .ows_accentBlue
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift
index 84b4a1f5092..71ef019bae2 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
@@ -485,6 +485,10 @@ public extension ChatListViewController {
             viewControllers += [ profile ]
             completion = { profile.presentAvatarSettingsView() }
         case let .donate(donationMode):
+            guard DonationUtilities.canDonate(localNumber: tsAccountManager.localNumber) else {
+                DonationViewsUtil.openDonateWebsite()
+                return
+            }
             let donate = DonateViewController(startingDonationMode: donationMode) { [weak self] finishResult in
                 switch finishResult {
                 case let .completedDonation(donateSheet, thanksSheet):
diff --git a/Signal/test/Payments/PaymentsTest.swift b/Signal/test/Payments/PaymentsTest.swift
index ef2cebd3b4c..fe5ac99eaa8 100644
--- a/Signal/test/Payments/PaymentsTest.swift
+++ b/Signal/test/Payments/PaymentsTest.swift
@@ -73,16 +73,6 @@ class PaymentsTest: SignalBaseTest {
                                                         signatureData: fakeSignatureData))
     }
 
-    func test_parsePaymentsDisabledRegions() {
-        XCTAssertEqual([], RemoteConfig.parsePaymentsDisabledRegions(valueList: ""))
-        XCTAssertEqual([], RemoteConfig.parsePaymentsDisabledRegions(valueList: "    "))
-        XCTAssertEqual([], RemoteConfig.parsePaymentsDisabledRegions(valueList: "a"))
-
-        XCTAssertEqual(["1"], RemoteConfig.parsePaymentsDisabledRegions(valueList: "1"))
-        XCTAssertEqual(["1"], RemoteConfig.parsePaymentsDisabledRegions(valueList: " 1a "))
-        XCTAssertEqual(["1", "2345", "67", "89"], RemoteConfig.parsePaymentsDisabledRegions(valueList: "1,2 345, +6 7,, ,89"))
-    }
-
     func test_isValidPhoneNumberForPayments_remoteConfigBlocklist() {
         XCTAssertTrue(PaymentsHelperImpl.isValidPhoneNumberForPayments_remoteConfigBlocklist("+523456",
                                                                                              paymentsDisabledRegions: ["1", "234"]))
diff --git a/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift b/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift
index 8db14cf46ab..7860d89a276 100644
--- a/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift
+++ b/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift
@@ -54,35 +54,58 @@ class BadgeExpirationSheetStateTest: XCTestCase {
 
     func testBadge() throws {
         let badge = getSubscriptionBadge()
-        let state = State(badge: badge, mode: .subscriptionExpiredBecauseNotRenewed)
+        let state = State(
+            badge: badge,
+            mode: .subscriptionExpiredBecauseNotRenewed,
+            canDonate: true
+        )
         XCTAssertIdentical(state.badge, badge)
     }
 
     func testTitleText() throws {
         let testCases: [(State, String)] = [
             (
-                State(badge: getSubscriptionBadge(),
-                      mode: .subscriptionExpiredBecauseOfChargeFailure(chargeFailure: Subscription.ChargeFailure(code: "insufficient_funds"))),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .subscriptionExpiredBecauseOfChargeFailure(chargeFailure: Subscription.ChargeFailure(code: "insufficient_funds")),
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_TITLE",
                                   comment: "Title for subscription on the badge expiration sheet.")
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .subscriptionExpiredBecauseNotRenewed),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .subscriptionExpiredBecauseNotRenewed,
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_TITLE",
                                   comment: "Title for subscription on the badge expiration sheet.")
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .boostExpired(hasCurrentSubscription: true)),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .boostExpired(hasCurrentSubscription: true),
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_EXPIRED_BOOST_TITLE",
                                   comment: "Title for boost on the badge expiration sheet.")
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftBadgeExpired(hasCurrentSubscription: true)),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftBadgeExpired(hasCurrentSubscription: true),
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_EXPIRED_GIFT_TITLE",
                                   comment: "Title for gift on the badge expiration sheet.")
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftNotRedeemed(fullName: "")),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftNotRedeemed(fullName: ""),
+                    canDonate: true
+                ),
                 NSLocalizedString("GIFT_NOT_REDEEMED_TITLE",
                                   comment: "Title when trying to redeem a gift that's already expired.")
             )
@@ -144,8 +167,11 @@ class BadgeExpirationSheetStateTest: XCTestCase {
                 } else {
                     chargeFailure = Subscription.ChargeFailure()
                 }
-                let state = State(badge: subscriptionBadge,
-                                  mode: .subscriptionExpiredBecauseOfChargeFailure(chargeFailure: chargeFailure))
+                let state = State(
+                    badge: subscriptionBadge,
+                    mode: .subscriptionExpiredBecauseOfChargeFailure(chargeFailure: chargeFailure),
+                    canDonate: true
+                )
                 let body = state.body
 
                 XCTAssert(body.text.contains(expectedSubstring))
@@ -156,13 +182,21 @@ class BadgeExpirationSheetStateTest: XCTestCase {
 
         let otherTestCases: [(State, String, Bool)] = [
             (
-                State(badge: getSubscriptionBadge(), mode: .subscriptionExpiredBecauseNotRenewed),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .subscriptionExpiredBecauseNotRenewed,
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_INACTIVITY_BODY_FORMAT",
                                   comment: "Body of the sheet shown when your subscription is canceled due to inactivity"),
                 true
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .boostExpired(hasCurrentSubscription: false)),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .boostExpired(hasCurrentSubscription: false),
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_EXPIRED_BOOST_BODY",
                                   comment: "String explaining to the user that their boost badge has expired on the badge expiry sheet.")
                 + "\n\n"
@@ -171,13 +205,21 @@ class BadgeExpirationSheetStateTest: XCTestCase {
                 false
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .boostExpired(hasCurrentSubscription: true)),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .boostExpired(hasCurrentSubscription: true),
+                    canDonate: true
+                ),
                 NSLocalizedString("BADGE_EXPIRED_BOOST_CURRENT_SUSTAINER_BODY",
                                   comment: "String explaining to the user that their boost badge has expired while they are a current subscription sustainer on the badge expiry sheet."),
                 false
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftBadgeExpired(hasCurrentSubscription: false)),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftBadgeExpired(hasCurrentSubscription: false),
+                    canDonate: true
+                ),
                 NSLocalizedString(
                     "BADGE_EXPIRED_GIFT_BODY",
                     comment: "String explaining to the user that their gift badge has expired. Shown on the badge expiration sheet."
@@ -190,7 +232,11 @@ class BadgeExpirationSheetStateTest: XCTestCase {
                 false
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftBadgeExpired(hasCurrentSubscription: true)),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftBadgeExpired(hasCurrentSubscription: true),
+                    canDonate: true
+                ),
                 NSLocalizedString(
                     "BADGE_EXPIRED_GIFT_BODY",
                     comment: "String explaining to the user that their gift badge has expired. Shown on the badge expiration sheet."
@@ -198,7 +244,11 @@ class BadgeExpirationSheetStateTest: XCTestCase {
                 false
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftNotRedeemed(fullName: "John Doe")),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftNotRedeemed(fullName: "John Doe"),
+                    canDonate: true
+                ),
                 NSLocalizedString(
                     "GIFT_NOT_REDEEMED_BODY_FORMAT",
                     comment: "Shown when trying to redeem a gift that's already expired. Embeds {{contact name}}."
@@ -216,44 +266,79 @@ class BadgeExpirationSheetStateTest: XCTestCase {
     func testActionButton() throws {
         let testCases: [(State, State.ActionButton)] = [
             (
-                State(badge: getSubscriptionBadge(),
-                      mode: .subscriptionExpiredBecauseOfChargeFailure(chargeFailure: Subscription.ChargeFailure(code: "insufficient_funds"))),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .subscriptionExpiredBecauseOfChargeFailure(chargeFailure: Subscription.ChargeFailure(code: "insufficient_funds")),
+                    canDonate: true
+                ),
                 State.ActionButton(action: .dismiss, text: CommonStrings.okayButton, hasNotNow: false)
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .subscriptionExpiredBecauseNotRenewed),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .subscriptionExpiredBecauseNotRenewed,
+                    canDonate: true
+                ),
                 State.ActionButton(action: .openMonthlyDonationView,
                                    text: NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_RENEWAL_BUTTON",
                                                            comment: "Button text when a badge expires, asking you to renew your subscription"),
                                    hasNotNow: true)
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .boostExpired(hasCurrentSubscription: false)),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .boostExpired(hasCurrentSubscription: false),
+                    canDonate: true
+                ),
                 State.ActionButton(action: .openOneTimeDonationView,
                                    text: NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON",
                                                            comment: "Button title for boost on the badge expiration sheet, used if the user is not already a sustainer."),
                                    hasNotNow: true)
             ),
             (
-                State(badge: getSubscriptionBadge(), mode: .boostExpired(hasCurrentSubscription: true)),
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .boostExpired(hasCurrentSubscription: true),
+                    canDonate: true
+                ),
                 State.ActionButton(action: .openOneTimeDonationView,
                                    text: NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON_SUSTAINER",
                                                            comment: "Button title for boost on the badge expiration sheet, used if the user is already a sustainer."),
                                    hasNotNow: true)
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftBadgeExpired(hasCurrentSubscription: false)),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftBadgeExpired(hasCurrentSubscription: false),
+                    canDonate: true
+                ),
                 State.ActionButton(action: .openMonthlyDonationView,
                                    text: NSLocalizedString("BADGE_EXPIRED_RENEWAL_MONTHLY",
                                                            comment: "Button title to donate monthly on the badge expiration sheet."),
                                    hasNotNow: true)
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftBadgeExpired(hasCurrentSubscription: true)),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftBadgeExpired(hasCurrentSubscription: true),
+                    canDonate: true
+                ),
                 State.ActionButton(action: .dismiss, text: CommonStrings.okayButton, hasNotNow: false)
             ),
             (
-                State(badge: getGiftBadge(), mode: .giftNotRedeemed(fullName: "")),
+                State(
+                    badge: getGiftBadge(),
+                    mode: .giftNotRedeemed(fullName: ""),
+                    canDonate: true
+                ),
+                State.ActionButton(action: .dismiss, text: CommonStrings.okayButton, hasNotNow: false)
+            ),
+            (
+                State(
+                    badge: getSubscriptionBadge(),
+                    mode: .boostExpired(hasCurrentSubscription: true),
+                    canDonate: false
+                ),
                 State.ActionButton(action: .dismiss, text: CommonStrings.okayButton, hasNotNow: false)
             )
         ]
diff --git a/SignalMessaging/Payments/PaymentsHelperImpl.swift b/SignalMessaging/Payments/PaymentsHelperImpl.swift
index 70edf934186..5ed61918a8d 100644
--- a/SignalMessaging/Payments/PaymentsHelperImpl.swift
+++ b/SignalMessaging/Payments/PaymentsHelperImpl.swift
@@ -22,14 +22,14 @@ public class PaymentsHelperImpl: NSObject, PaymentsHelperSwift, PaymentsHelper {
         }
         let paymentsDisabledRegions = RemoteConfig.paymentsDisabledRegions
         if paymentsDisabledRegions.isEmpty {
-            return Self.isValidPhoneNumberForPayments_fixedWhitelist(localNumber)
+            return Self.isValidPhoneNumberForPayments_fixedAllowlist(localNumber)
         } else {
             return Self.isValidPhoneNumberForPayments_remoteConfigBlocklist(localNumber,
                                                                             paymentsDisabledRegions: paymentsDisabledRegions)
              }
     }
 
-    private static func isValidPhoneNumberForPayments_fixedWhitelist(_ e164: String) -> Bool {
+    private static func isValidPhoneNumberForPayments_fixedAllowlist(_ e164: String) -> Bool {
         guard let phoneNumber = PhoneNumber(fromE164: e164) else {
             owsFailDebug("Could not parse phone number: \(e164).")
             return false
@@ -51,28 +51,15 @@ public class PaymentsHelperImpl: NSObject, PaymentsHelperSwift, PaymentsHelper {
         return validCountryCodes.contains(nsCountryCode.intValue)
     }
 
-    internal static func isValidPhoneNumberForPayments_remoteConfigBlocklist(_ e164: String,
-                                                                             paymentsDisabledRegions: [String]) -> Bool {
-        guard !paymentsDisabledRegions.isEmpty else {
-            owsFailDebug("Missing paymentsDisabledRegions.")
-            return false
-        }
-        let e164Prefix = "+"
-        guard e164.hasPrefix(e164Prefix) else {
-            owsFailDebug("Invalid e164: \(e164).")
-            return false
-        }
-        let e164WithoutPrefix = e164.substring(from: e164Prefix.count)
-        guard !e164WithoutPrefix.isEmpty else {
-            owsFailDebug("Invalid e164: \(e164).")
-            return false
-        }
-        for regionPrefix in paymentsDisabledRegions {
-            if e164WithoutPrefix.hasPrefix(regionPrefix) {
-                return false
-            }
-        }
-        return true
+    internal static func isValidPhoneNumberForPayments_remoteConfigBlocklist(
+        _ e164: String,
+        paymentsDisabledRegions: PhoneNumberRegions
+    ) -> Bool {
+        owsAssertDebug(
+            !paymentsDisabledRegions.isEmpty,
+            "Missing paymentsDisabledRegions. Used the fixed allowlist instead."
+        )
+        return !paymentsDisabledRegions.contains(e164: e164)
     }
 
     public var canEnablePayments: Bool {
diff --git a/SignalMessaging/Subscriptions/DonationUtilities.swift b/SignalMessaging/Subscriptions/DonationUtilities.swift
index f1c01d5d794..883577d3ef7 100644
--- a/SignalMessaging/Subscriptions/DonationUtilities.swift
+++ b/SignalMessaging/Subscriptions/DonationUtilities.swift
@@ -10,12 +10,14 @@ import SignalCoreKit
 public class DonationUtilities: Dependencies {
     public static var sendGiftBadgeJobQueue: SendGiftBadgeJobQueue { smJobQueues.sendGiftBadgeJobQueue }
 
-    public static var isApplePayAvailable: Bool {
-        PKPaymentAuthorizationController.canMakePayments()
-    }
-
-    public static var canSendGiftBadges: Bool {
-        isApplePayAvailable && RemoteConfig.canSendGiftBadges
+    /// Can the user donate to Signal in the app?
+    public static func canDonate(localNumber: String?) -> Bool {
+        guard let localNumber else { return false }
+        let isApplePayAvailable = (
+            PKPaymentAuthorizationController.canMakePayments() &&
+            !RemoteConfig.applePayDisabledRegions.contains(e164: localNumber)
+        )
+        return isApplePayAvailable
     }
 
     public static var supportedNetworks: [PKPaymentNetwork] {
diff --git a/SignalServiceKit/src/Util/PhoneNumberRegions.swift b/SignalServiceKit/src/Util/PhoneNumberRegions.swift
new file mode 100644
index 00000000000..6fc750acde5
--- /dev/null
+++ b/SignalServiceKit/src/Util/PhoneNumberRegions.swift
@@ -0,0 +1,57 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public class PhoneNumberRegions: Equatable, ExpressibleByArrayLiteral, CustomDebugStringConvertible {
+    private let regions: Set<String>
+    private var previousCachedResult: (e164: String, result: Bool)?
+
+    public required init(arrayLiteral: String...) {
+        self.regions = Set(arrayLiteral)
+    }
+
+    init(fromRemoteConfig remoteConfigValue: String) {
+        let regions = remoteConfigValue
+            .components(separatedBy: ",")
+            .lazy
+            .compactMap { $0.asciiDigitsOnly.nilIfEmpty }
+        self.regions = Set(regions)
+    }
+
+    public var isEmpty: Bool { regions.isEmpty }
+
+    public func contains(e164: String) -> Bool {
+        // We usually expect this to be called with the same E164, so we cache
+        // the previous result. We could probably optimize this whole class
+        // further, but this simple solution should be good enough.
+        if let previousCachedResult, previousCachedResult.e164 == e164 {
+            return previousCachedResult.result
+        }
+
+        let e164Prefix = "+"
+        guard e164.hasPrefix(e164Prefix) else {
+            owsFailDebug("Invalid e164: \(e164).")
+            return false
+        }
+        let e164WithoutPrefix = e164.substring(from: e164Prefix.count)
+        if e164WithoutPrefix.isEmpty {
+            owsFailDebug("Invalid e164: \(e164).")
+            return false
+        }
+
+        let result = regions.contains { region in
+            e164WithoutPrefix.hasPrefix(region)
+        }
+        previousCachedResult = (e164, result)
+        return result
+    }
+
+    public static func == (lhs: PhoneNumberRegions, rhs: PhoneNumberRegions) -> Bool {
+        lhs.regions == rhs.regions
+    }
+
+    public var debugDescription: String { regions.debugDescription }
+}
diff --git a/SignalServiceKit/src/Util/RemoteConfigManager.swift b/SignalServiceKit/src/Util/RemoteConfigManager.swift
index ed429c67558..4fa10212794 100644
--- a/SignalServiceKit/src/Util/RemoteConfigManager.swift
+++ b/SignalServiceKit/src/Util/RemoteConfigManager.swift
@@ -14,14 +14,16 @@ public class RemoteConfig: BaseFlags {
     fileprivate let isEnabledFlags: [String: Bool]
     fileprivate let valueFlags: [String: AnyObject]
     private let standardMediaQualityLevel: ImageQualityLevel?
-    private let paymentsDisabledRegions: [String]
+    private let paymentsDisabledRegions: PhoneNumberRegions
+    private let applePayDisabledRegions: PhoneNumberRegions
 
     init(isEnabledFlags: [String: Bool],
          valueFlags: [String: AnyObject]) {
         self.isEnabledFlags = isEnabledFlags
         self.valueFlags = valueFlags
         self.standardMediaQualityLevel = Self.determineStandardMediaQualityLevel(valueFlags: valueFlags)
-        self.paymentsDisabledRegions = Self.parsePaymentsDisabledRegions(valueFlags: valueFlags)
+        self.paymentsDisabledRegions = Self.parsePhoneNumberRegions(valueFlags: valueFlags, flag: .paymentsDisabledRegions)
+        self.applePayDisabledRegions = Self.parsePhoneNumberRegions(valueFlags: valueFlags, flag: .applePayDisabledRegions)
     }
 
     @objc
@@ -121,11 +123,16 @@ public class RemoteConfig: BaseFlags {
         return remoteConfig.standardMediaQualityLevel
     }
 
-    public static var paymentsDisabledRegions: [String] {
+    public static var paymentsDisabledRegions: PhoneNumberRegions {
         guard let remoteConfig = Self.remoteConfigManager.cachedConfig else { return [] }
         return remoteConfig.paymentsDisabledRegions
     }
 
+    public static var applePayDisabledRegions: PhoneNumberRegions {
+        guard let remoteConfig = Self.remoteConfigManager.cachedConfig else { return [] }
+        return remoteConfig.applePayDisabledRegions
+    }
+
     private static func determineStandardMediaQualityLevel(valueFlags: [String: AnyObject]) -> ImageQualityLevel? {
         let rawFlag: String = Flags.SupportedValuesFlags.standardMediaQualityLevel.rawFlag
 
@@ -140,33 +147,12 @@ public class RemoteConfig: BaseFlags {
         return defaultMediaQuality
     }
 
-    static func parsePaymentsDisabledRegions(valueFlags: [String: AnyObject]) -> [String] {
-        let flag: Flags.SupportedValuesFlags = .paymentsDisabledRegions
-        let rawFlag = flag.rawFlag
-        guard let valueList = valueFlags[rawFlag] as? String else { return [] }
-        return parsePaymentsDisabledRegions(valueList: valueList)
-    }
-
-    internal static func parsePaymentsDisabledRegions(valueList: String) -> [String] {
-        // The value should always be a comma-separated list of e164 prefixes
-        // without leading +, e.g.: "1,2 345,2 567,4".
-        // Note that values might have whitespace which needs to be stripped.
-        let disabledPrefixList = valueList
-            .components(separatedBy: ",")
-            .reduce(into: [String]()) { result, value in
-                let validCharacterSet = CharacterSet(charactersIn: "0123456789")
-                let filteredValue = value.components(separatedBy: validCharacterSet.inverted).joined()
-                guard !filteredValue.isEmpty else {
-                    if CurrentAppContext().isRunningTests {
-                        Logger.warn("Invalid value: \(valueList)")
-                    } else {
-                        owsFailDebug("Invalid value: \(valueList)")
-                    }
-                    return
-                }
-                result.append(filteredValue)
-        }
-        return disabledPrefixList
+    fileprivate static func parsePhoneNumberRegions(
+        valueFlags: [String: AnyObject],
+        flag: Flags.SupportedValuesFlags
+    ) -> PhoneNumberRegions {
+        guard let valueList = valueFlags[flag.rawFlag] as? String else { return [] }
+        return PhoneNumberRegions(fromRemoteConfig: valueList)
     }
 
     @objc
@@ -468,6 +454,7 @@ private struct Flags {
         case automaticSessionResetAttemptInterval
         case reactiveProfileKeyAttemptInterval
         case paymentsDisabledRegions
+        case applePayDisabledRegions
         case maxGroupCallRingSize
     }
 
@@ -486,6 +473,7 @@ private struct Flags {
         case replaceableInteractionExpiration
         case messageSendLogEntryLifetime
         case paymentsDisabledRegions
+        case applePayDisabledRegions
         case maxGroupCallRingSize
     }
 }
@@ -507,6 +495,7 @@ private extension FlagType {
         case "groupsV2MaxGroupSizeHardLimit": return "global.groupsv2.groupSizeHardLimit"
         case "cdsSyncInterval": return "cds.syncInterval.seconds"
         case "paymentsDisabledRegions": return "global.payments.disabledRegions"
+        case "applePayDisabledRegions": return "global.donations.apayDisabledRegions"
         case "maxGroupCallRingSize": return "global.calling.maxGroupCallRingSize"
         default: return Flags.prefix + rawValue
         }
diff --git a/SignalServiceKit/src/Util/String+SSK.swift b/SignalServiceKit/src/Util/String+SSK.swift
index 14562c87fcc..a0fb83cc9f9 100644
--- a/SignalServiceKit/src/Util/String+SSK.swift
+++ b/SignalServiceKit/src/Util/String+SSK.swift
@@ -7,10 +7,36 @@ import Foundation
 import NaturalLanguage
 
 public extension String {
+    /// A version of the string that only contains digits.
+    ///
+    /// Handles non-ASCII digits. If you only want ASCII digits, see `asciiDigitsOnly`.
+    ///
+    /// ```
+    /// "1x2x3".digitsOnly
+    /// // => "123"
+    /// "١23".digitsOnly
+    /// // => "١23"
+    /// "1️⃣23".digitsOnly
+    /// // => "123"
+    /// ```
     var digitsOnly: String {
         return (self as NSString).digitsOnly()
     }
 
+    /// A version of the string that only contains ASCII digits.
+    ///
+    /// If you want to include non-ASCII digits, see `digitsOnly`.
+    ///
+    /// ```
+    /// "1x2x3".digitsOnly
+    /// // => "123"
+    /// "1️⃣23".digitsOnly
+    /// // => "23"
+    /// ```
+    var asciiDigitsOnly: String {
+        filter { $0.isASCII && $0.isNumber }
+    }
+
     func substring(from index: Int) -> String {
         return String(self[self.index(self.startIndex, offsetBy: index)...])
     }
diff --git a/SignalServiceKit/tests/Util/PhoneNumberRegionsTest.swift b/SignalServiceKit/tests/Util/PhoneNumberRegionsTest.swift
new file mode 100644
index 00000000000..9f8b95fb90e
--- /dev/null
+++ b/SignalServiceKit/tests/Util/PhoneNumberRegionsTest.swift
@@ -0,0 +1,44 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import XCTest
+@testable import SignalServiceKit
+
+final class PhoneNumberRegionsTest: XCTestCase {
+    func testInitFromRemoteConfig() {
+        let empties = ["", "   ", "a"]
+        for value in empties {
+            XCTAssertTrue(PhoneNumberRegions(fromRemoteConfig: value).isEmpty)
+        }
+
+        let justOne = ["1", " 1a ", "+1,", "1١", "6️⃣1"]
+        for value in justOne {
+            XCTAssertEqual(PhoneNumberRegions(fromRemoteConfig: value), ["1"], value)
+        }
+
+        XCTAssertEqual(
+            PhoneNumberRegions(fromRemoteConfig: "1,2 345, +6 7,, ,89,٦,6️⃣"),
+            ["1", "2345", "67", "89"]
+        )
+    }
+
+    func testIsEmpty() {
+        let empty: PhoneNumberRegions = []
+        XCTAssertTrue(empty.isEmpty)
+
+        let notEmpty: PhoneNumberRegions = ["1", "44"]
+        XCTAssertFalse(notEmpty.isEmpty)
+    }
+
+    func testContains() {
+        let regions: PhoneNumberRegions = ["1", "44"]
+        XCTAssertTrue(regions.contains(e164: "+17345550123"))
+        XCTAssertTrue(regions.contains(e164: "+447700900123"))
+        XCTAssertFalse(regions.contains(e164: "+33639981234"))
+
+        // This tests the caching behavior, which should not affect results.
+        XCTAssertFalse(regions.contains(e164: "+33639981234"))
+    }
+}
diff --git a/SignalServiceKit/tests/Util/StringTest.swift b/SignalServiceKit/tests/Util/StringTest.swift
index 820dbf97712..b8c4736db50 100644
--- a/SignalServiceKit/tests/Util/StringTest.swift
+++ b/SignalServiceKit/tests/Util/StringTest.swift
@@ -7,6 +7,27 @@ import XCTest
 import SignalServiceKit
 
 final class StringTest: XCTestCase {
+    func test_digitsOnly() {
+        XCTAssertEqual("".digitsOnly, "")
+        XCTAssertEqual("abc".digitsOnly, "")
+        XCTAssertEqual("123".digitsOnly, "123")
+        XCTAssertEqual("-1.23".digitsOnly, "123")
+        XCTAssertEqual("1x2 3".digitsOnly, "123")
+        XCTAssertEqual("١23".digitsOnly, "١23")
+        XCTAssertEqual("1️⃣23".digitsOnly, "123")
+    }
+
+    func test_asciiDigitsOnly() {
+        XCTAssertEqual("".asciiDigitsOnly, "")
+        XCTAssertEqual("abc".asciiDigitsOnly, "")
+        XCTAssertEqual("123".asciiDigitsOnly, "123")
+        XCTAssertEqual("-1.23".asciiDigitsOnly, "123")
+        XCTAssertEqual("1x2 3".asciiDigitsOnly, "123")
+        XCTAssertEqual("1١23".asciiDigitsOnly, "123")
+        XCTAssertEqual("19️⃣23".asciiDigitsOnly, "123")
+        XCTAssertEqual("6️⃣123".asciiDigitsOnly, "123")
+    }
+
     func test_caesar() {
         XCTAssertEqual("abc", try! "abc".caesar(shift: 0))
         XCTAssertEqual("abc", try! "abc".caesar(shift: 127))
