diff --git a/Signal/src/ViewControllers/AppSettings/Privacy/BlockListViewController.m b/Signal/src/ViewControllers/AppSettings/Privacy/BlockListViewController.m
index 49fe51753f8..a3917597bad 100644
--- a/Signal/src/ViewControllers/AppSettings/Privacy/BlockListViewController.m
+++ b/Signal/src/ViewControllers/AppSettings/Privacy/BlockListViewController.m
@@ -90,17 +90,15 @@ - (void)updateTableContents
 
     // "Blocklist" section
 
-    NSMutableSet<SignalServiceAddress *> *blockedAddressesSet = [NSMutableSet new];
-    for (NSString *phoneNumber in self.blockingManager.blockedPhoneNumbers) {
-        [blockedAddressesSet addObject:[[SignalServiceAddress alloc] initWithPhoneNumber:phoneNumber]];
-    }
-
-    for (NSString *uuidString in self.blockingManager.blockedUUIDStrings) {
-        [blockedAddressesSet addObject:[[SignalServiceAddress alloc] initWithUuidString:uuidString]];
-    }
+    __block NSSet<SignalServiceAddress *> *blockedAddressSet = nil;
+    __block NSArray<TSGroupModel *> *blockedGroupModels = nil;
+    [self.databaseStorage readWithBlock:^(SDSAnyReadTransaction *readTx) {
+        blockedAddressSet = [self.blockingManager blockedAddressesWithTransaction:readTx];
+        blockedGroupModels = [self.blockingManager blockedGroupModelsWithTransaction:readTx];
+    }];
 
     NSArray<SignalServiceAddress *> *blockedAddresses =
-        [blockedAddressesSet.allObjects sortedArrayUsingSelector:@selector(compare:)];
+        [blockedAddressSet.allObjects sortedArrayUsingSelector:@selector(compare:)];
     if (blockedAddresses.count > 0) {
         OWSTableSection *blockedContactsSection = [OWSTableSection new];
         blockedContactsSection.headerTitle = NSLocalizedString(
@@ -127,13 +125,12 @@ - (void)updateTableContents
         [contents addSection:blockedContactsSection];
     }
 
-    NSArray<TSGroupModel *> *blockedGroups = self.blockingManager.blockedGroupModels;
-    if (blockedGroups.count > 0) {
+    if (blockedGroupModels.count > 0) {
         OWSTableSection *blockedGroupsSection = [OWSTableSection new];
         blockedGroupsSection.headerTitle = NSLocalizedString(
             @"BLOCK_LIST_BLOCKED_GROUPS_SECTION", @"Section header for groups that have been blocked");
 
-        for (TSGroupModel *blockedGroup in blockedGroups) {
+        for (TSGroupModel *blockedGroup in blockedGroupModels) {
             UIImage *_Nullable image = blockedGroup.avatarImage;
             if (!image) {
                 image = [self.avatarBuilder avatarImageForGroupId:blockedGroup.groupId
diff --git a/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift b/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift
index 4b46b46de03..2fe2584798e 100644
--- a/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift	
+++ b/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift	
@@ -261,7 +261,7 @@ extension StorageServiceProtoGroupV1Record: Dependencies {
         var builder = StorageServiceProtoGroupV1Record.builder(id: groupId)
 
         builder.setWhitelisted(profileManager.isGroupId(inProfileWhitelist: groupId, transaction: transaction))
-        builder.setBlocked(blockingManager.isGroupIdBlocked(groupId))
+        builder.setBlocked(blockingManager.isGroupIdBlocked(groupId, transaction: transaction))
 
         let threadId = TSGroupThread.threadId(forGroupId: groupId, transaction: transaction)
         let threadAssociatedData = ThreadAssociatedData.fetchOrDefault(for: threadId,
@@ -306,7 +306,7 @@ extension StorageServiceProtoGroupV1Record: Dependencies {
         // For now, we'd like to avoid that as it adds its own set of problems.
 
         // Gather some local contact state to do comparisons against.
-        let localIsBlocked = blockingManager.isGroupIdBlocked(id)
+        let localIsBlocked = blockingManager.isGroupIdBlocked(id, transaction: transaction)
         let localIsWhitelisted = profileManager.isGroupId(inProfileWhitelist: id, transaction: transaction)
 
         // If our local blocked state differs from the service state, use the service's value.
@@ -371,7 +371,7 @@ extension StorageServiceProtoGroupV2Record: Dependencies {
         var builder = StorageServiceProtoGroupV2Record.builder(masterKey: masterKeyData)
 
         builder.setWhitelisted(profileManager.isGroupId(inProfileWhitelist: groupId, transaction: transaction))
-        builder.setBlocked(blockingManager.isGroupIdBlocked(groupId))
+        builder.setBlocked(blockingManager.isGroupIdBlocked(groupId, transaction: transaction))
 
         let threadId = TSGroupThread.threadId(forGroupId: groupId, transaction: transaction)
         let threadAssociatedData = ThreadAssociatedData.fetchOrDefault(for: threadId,
@@ -453,7 +453,7 @@ extension StorageServiceProtoGroupV2Record: Dependencies {
         }
 
         // Gather some local contact state to do comparisons against.
-        let localIsBlocked = blockingManager.isGroupIdBlocked(groupId)
+        let localIsBlocked = blockingManager.isGroupIdBlocked(groupId, transaction: transaction)
         let localIsWhitelisted = profileManager.isGroupId(inProfileWhitelist: groupId, transaction: transaction)
 
         // If our local blocked state differs from the service state, use the service's value.
diff --git a/SignalMessaging/contacts/OWSGroupSyncProcessingJobQueue.swift b/SignalMessaging/contacts/OWSGroupSyncProcessingJobQueue.swift
index 83ab0dab45d..230a87edcc5 100644
--- a/SignalMessaging/contacts/OWSGroupSyncProcessingJobQueue.swift
+++ b/SignalMessaging/contacts/OWSGroupSyncProcessingJobQueue.swift
@@ -227,13 +227,13 @@ public class IncomingGroupSyncOperation: OWSOperation, DurableOperation {
         }
 
         if groupDetails.isBlocked {
-            if !self.blockingManager.isGroupIdBlocked(groupDetails.groupId) {
+            if !self.blockingManager.isGroupIdBlocked(groupDetails.groupId, transaction: transaction) {
                 self.blockingManager.addBlockedGroup(groupModel: groupModel,
                                                      blockMode: .remote,
                                                      transaction: transaction)
             }
         } else {
-            if self.blockingManager.isGroupIdBlocked(groupDetails.groupId) {
+            if self.blockingManager.isGroupIdBlocked(groupDetails.groupId, transaction: transaction) {
                 self.blockingManager.removeBlockedGroup(groupId: groupDetails.groupId,
                                                         wasLocallyInitiated: false,
                                                         transaction: transaction)
diff --git a/SignalMessaging/groups/GroupV2UpdatesImpl.swift b/SignalMessaging/groups/GroupV2UpdatesImpl.swift
index 8a4ed70b792..27ae7d2d9d8 100644
--- a/SignalMessaging/groups/GroupV2UpdatesImpl.swift
+++ b/SignalMessaging/groups/GroupV2UpdatesImpl.swift
@@ -209,7 +209,8 @@ public class GroupV2UpdatesImpl: NSObject, GroupV2UpdatesSwift {
                                           groupUpdateMode: GroupUpdateMode,
                                           groupModelOptions: TSGroupModelOptions) -> Promise<TSGroupThread> {
 
-        guard !Self.blockingManager.isGroupIdBlocked(groupId) else {
+        let isBlocked = databaseStorage.read { blockingManager.isGroupIdBlocked(groupId, transaction: $0) }
+        guard !isBlocked else {
             return Promise(error: GroupsV2Error.groupBlocked)
         }
         let isThrottled = { () -> Bool in
diff --git a/SignalMessaging/profiles/OWSProfileManager.m b/SignalMessaging/profiles/OWSProfileManager.m
index d43da32f833..d894adc3d57 100644
--- a/SignalMessaging/profiles/OWSProfileManager.m
+++ b/SignalMessaging/profiles/OWSProfileManager.m
@@ -514,18 +514,6 @@ - (NSString *)groupKeyForGroupId:(NSData *)groupId
     return [groupId hexadecimalString];
 }
 
-- (nullable NSData *)groupIdForGroupKey:(NSString *)groupKey {
-    NSData *_Nullable groupId = [NSData dataFromHexString:groupKey];
-    // Make sure that the group id is a valid v1 or v2 group id.
-    if (![GroupManager isValidGroupIdOfAnyKind:groupId]) {
-        OWSFailDebug(@"Parsed group id has unexpected length: %@ (%lu)",
-            groupId.hexadecimalString,
-            (unsigned long)groupId.length);
-        return nil;
-    }
-    return [groupId copy];
-}
-
 - (void)rotateLocalProfileKeyIfNecessary {
     if (CurrentAppContext().isNSE) {
         return;
@@ -550,85 +538,27 @@ - (void)rotateLocalProfileKeyIfNecessaryWithSuccess:(dispatch_block_t)success
     }
 
     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
-        NSMutableSet<NSString *> *whitelistedPhoneNumbers = [NSMutableSet new];
-        NSMutableSet<NSString *> *whitelistedUUIDS = [NSMutableSet new];
-        NSMutableSet<NSData *> *whitelistedGroupIds = [NSMutableSet new];
+        __block NSArray<NSString *> *victimPhoneNumbers = @[];
+        __block NSArray<NSString *> *victimUUIDs = @[];
+        __block NSArray<NSData *> *victimGroupIds = @[];
         [self.databaseStorage readWithBlock:^(SDSAnyReadTransaction *transaction) {
-            [whitelistedPhoneNumbers
-                addObjectsFromArray:[self.whitelistedPhoneNumbersStore allKeysWithTransaction:transaction]];
-            [whitelistedUUIDS addObjectsFromArray:[self.whitelistedUUIDsStore allKeysWithTransaction:transaction]];
-            NSArray<NSString *> *whitelistedGroupKeys =
-                [self.whitelistedGroupsStore allKeysWithTransaction:transaction];
-
-            for (NSString *groupKey in whitelistedGroupKeys) {
-                NSData *_Nullable groupId = [self groupIdForGroupKey:groupKey];
-                if (!groupId) {
-                    OWSFailDebug(@"Couldn't parse group key: %@.", groupKey);
-                    continue;
-                }
-
-                [whitelistedGroupIds addObject:groupId];
-
-                // Note: We don't add the group member's ids to whitelistedUUIDS
-                // and whitelistedPhoneNumbers.
-                //
-                // Whenever we message a contact, be it in a 1:1 thread or in a group thread,
-                // we add them to the contact whitelist, so there's no reason to redundantly
-                // add them here.
-                //
-                // Furthermore, doing so would cause the following problem:
-                //
-                // - Alice is in group Book Club
-                // - Add Book Club to your profile white list
-                // - Message Book Club, which also adds Alice to your profile whitelist.
-                // - Block Alice, but not Book Club
-                //
-                // Now, at this point we'd want to rotate our profile key once, since Alice has
-                // it via BookClub.
-                //
-                // The next time we checked whether we should rotate our profile key, adding all
-                // group members to whitelistedUUIDS and whitelistedPhoneNumbers would
-                // include Alice, and we'd rotate our profile key every time this method is called.
-            }
+            victimPhoneNumbers = [self blockedPhoneNumbersInWhitelistWithTransaction:transaction];
+            victimUUIDs = [self blockedUUIDsInWhitelistWithTransaction:transaction];
+            victimGroupIds = [self blockedGroupIDsInWhitelistWithTransaction:transaction];
         } file:__FILE__ function:__FUNCTION__ line:__LINE__];
 
-        SignalServiceAddress *_Nullable localAddress = [self.tsAccountManager localAddress];
-        NSString *_Nullable localNumber = localAddress.phoneNumber;
-        if (localNumber) {
-            [whitelistedPhoneNumbers removeObject:localNumber];
-        } else {
-            OWSFailDebug(@"Missing localNumber");
-        }
-
-        NSString *_Nullable localUUID = localAddress.uuidString;
-        if (localUUID) {
-            [whitelistedUUIDS removeObject:localUUID];
-        } else {
-            OWSFailDebug(@"Missing localUUID");
-        }
-
-        NSSet<NSString *> *blockedPhoneNumbers = self.blockingManager.blockedPhoneNumbers;
-        NSSet<NSString *> *blockedUUIDs = self.blockingManager.blockedUUIDStrings;
-        NSSet<NSData *> *blockedGroupIds = self.blockingManager.blockedGroupIds;
-
-        // Find the users and groups which are both a) blocked b) may have our current profile key.
-        NSMutableSet<NSString *> *intersectingPhoneNumbers = [blockedPhoneNumbers mutableCopy];
-        [intersectingPhoneNumbers intersectSet:whitelistedPhoneNumbers];
-        NSMutableSet<NSString *> *intersectingUUIDS = [blockedUUIDs mutableCopy];
-        [intersectingUUIDS intersectSet:whitelistedUUIDS];
-        NSMutableSet<NSData *> *intersectingGroupIds = [blockedGroupIds mutableCopy];
-        [intersectingGroupIds intersectSet:whitelistedGroupIds];
-
-        BOOL isProfileKeySharedWithBlocked
-            = (intersectingPhoneNumbers.count > 0 || intersectingUUIDS.count > 0 || intersectingGroupIds.count > 0);
-        if (!isProfileKeySharedWithBlocked) {
+        NSUInteger victimCount = 0;
+        victimCount += victimPhoneNumbers.count;
+        victimCount += victimUUIDs.count;
+        victimCount += victimGroupIds.count;
+        if (victimCount == 0) {
             // No need to rotate the profile key.
             return success();
         }
 
-        [self rotateProfileKeyWithIntersectingPhoneNumbers:intersectingPhoneNumbers
-                                         intersectingUUIDs:intersectingUUIDS
-                                      intersectingGroupIds:intersectingGroupIds]
+        [self rotateProfileKeyWithIntersectingPhoneNumbers:victimPhoneNumbers
+                                         intersectingUUIDs:victimUUIDs
+                                      intersectingGroupIds:victimGroupIds]
             .done(^(id value) { success(); })
             .catch(^(NSError *error) { failure(error); });
     });
@@ -1218,7 +1148,7 @@ - (BOOL)isGroupIdInProfileWhitelist:(NSData *)groupId transaction:(SDSAnyReadTra
     // by ensuring that BlockingManager.warmCaches() is always
     // called first.  I've added asserts within BlockingManager around
     // this.
-    if ([self.blockingManager isGroupIdBlocked:groupId]) {
+    if ([self.blockingManager isGroupIdBlocked:groupId transaction:transaction]) {
         return NO;
     }
 
diff --git a/SignalMessaging/profiles/OWSProfileManager.swift b/SignalMessaging/profiles/OWSProfileManager.swift
index 1e75d75f72a..91ea769f0b6 100644
--- a/SignalMessaging/profiles/OWSProfileManager.swift
+++ b/SignalMessaging/profiles/OWSProfileManager.swift
@@ -119,9 +119,9 @@ public extension OWSProfileManager {
     @objc
     @available(swift, obsoleted: 1.0)
     func rotateProfileKey(
-        intersectingPhoneNumbers: Set<String>,
-        intersectingUUIDs: Set<String>,
-        intersectingGroupIds: Set<Data>
+        intersectingPhoneNumbers: Array<String>,
+        intersectingUUIDs: Array<String>,
+        intersectingGroupIds: Array<Data>
     ) -> AnyPromise {
         return AnyPromise(rotateProfileKey(
             intersectingPhoneNumbers: intersectingPhoneNumbers,
@@ -131,9 +131,9 @@ public extension OWSProfileManager {
     }
 
     func rotateProfileKey(
-        intersectingPhoneNumbers: Set<String>,
-        intersectingUUIDs: Set<String>,
-        intersectingGroupIds: Set<Data>
+        intersectingPhoneNumbers: Array<String>,
+        intersectingUUIDs: Array<String>,
+        intersectingGroupIds: Array<Data>
     ) -> Promise<Void> {
         guard tsAccountManager.isRegisteredPrimaryDevice else {
             return Promise(error: OWSAssertionError("tsAccountManager.isRegistered was unexpectedly false"))
@@ -184,11 +184,11 @@ public extension OWSProfileManager {
                 // in which we persist our new profile key, since storing them is what marks the
                 // profile key rotation as "complete" (removing newly blocked users from the whitelist).
                 self.whitelistedPhoneNumbersStore.removeValues(
-                    forKeys: Array(intersectingPhoneNumbers),
+                    forKeys: intersectingPhoneNumbers,
                     transaction: transaction
                 )
                 self.whitelistedUUIDsStore.removeValues(
-                    forKeys: Array(intersectingUUIDs),
+                    forKeys: intersectingUUIDs,
                     transaction: transaction
                 )
                 self.whitelistedGroupsStore.removeValues(
@@ -204,6 +204,46 @@ public extension OWSProfileManager {
             self.groupsV2.processProfileKeyUpdates()
         }
     }
+
+    @objc
+    func blockedPhoneNumbersInWhitelist(transaction readTx: SDSAnyReadTransaction) -> Array<String> {
+        let allWhitelistedNumbers = whitelistedPhoneNumbersStore.allKeys(transaction: readTx)
+
+        return allWhitelistedNumbers.filter { candidate in
+            let address = SignalServiceAddress(phoneNumber: candidate)
+            return !address.isLocalAddress && blockingManager.isAddressBlocked(address, transaction: readTx)
+        }
+    }
+
+    @objc
+    func blockedUUIDsInWhitelist(transaction readTx: SDSAnyReadTransaction) -> Array<String> {
+        let allWhitelistedUUIDs = whitelistedUUIDsStore.allKeys(transaction: readTx)
+
+        return allWhitelistedUUIDs.filter { candidate in
+            let address = SignalServiceAddress(uuidString: candidate)
+            return !address.isLocalAddress && blockingManager.isAddressBlocked(address, transaction: readTx)
+        }
+    }
+
+    @objc
+    func blockedGroupIDsInWhitelist(transaction readTx: SDSAnyReadTransaction) -> Array<Data> {
+        let allWhitelistedGroupKeys = whitelistedGroupsStore.allKeys(transaction: readTx)
+
+        return allWhitelistedGroupKeys.lazy
+            .compactMap { self.groupIdForGroupKey($0) }
+            .filter { blockingManager.isGroupIdBlocked($0, transaction: readTx) }
+    }
+
+    private func groupIdForGroupKey(_ groupKey: String) -> Data? {
+        guard let groupId = Data.data(fromHex: groupKey) else { return nil }
+
+        if GroupManager.isValidGroupIdOfAnyKind(groupId) {
+            return groupId
+        } else {
+            owsFailDebug("Parsed group id has unexpected length: \(groupId.hexadecimalString) (\(groupId.count))")
+            return nil
+        }
+    }
 }
 
 // MARK: -
diff --git a/SignalServiceKit/src/Devices/ConversationSync/OWSGroupsOutputStream.m b/SignalServiceKit/src/Devices/ConversationSync/OWSGroupsOutputStream.m
index 54970895b51..7b68751ad2b 100644
--- a/SignalServiceKit/src/Devices/ConversationSync/OWSGroupsOutputStream.m
+++ b/SignalServiceKit/src/Devices/ConversationSync/OWSGroupsOutputStream.m
@@ -61,7 +61,7 @@ - (void)writeGroup:(TSGroupThread *)groupThread transaction:(SDSAnyReadTransacti
     [groupBuilder setMembersE164:membersE164];
     [groupBuilder setMembers:members];
 
-    if ([BlockingManager.shared isGroupIdBlocked:group.groupId]) {
+    if ([BlockingManager.shared isGroupIdBlocked:group.groupId transaction:transaction]) {
         [groupBuilder setBlocked:YES];
     }
 
diff --git a/SignalServiceKit/src/Messages/BlockingManager.swift b/SignalServiceKit/src/Messages/BlockingManager.swift
index 9852fb8df83..ec15f869a51 100644
--- a/SignalServiceKit/src/Messages/BlockingManager.swift
+++ b/SignalServiceKit/src/Messages/BlockingManager.swift
@@ -336,7 +336,8 @@ public class BlockingManager: NSObject {
 
     // MARK: - Contact Blocking
 
-    public func blockedAddressSetWithTransaction(_ readTx: SDSAnyReadTransaction) -> Set<SignalServiceAddress> {
+    @objc
+    public func blockedAddresses(transaction readTx: SDSAnyReadTransaction) -> Set<SignalServiceAddress> {
         let state = unfairLock.withLock {
             self.currentState
         }
@@ -453,16 +454,6 @@ public class BlockingManager: NSObject {
                           transaction: transaction)
     }
 
-    @objc
-    public var blockedPhoneNumbers: Set<String> {
-        unfairLock.withLock { self.currentState.blockedPhoneNumbers }
-    }
-
-    @objc
-    public var blockedUUIDStrings: Set<String> {
-        unfairLock.withLock { self.currentState.blockedUUIDStrings }
-    }
-
     @objc
     public func isAddressBlocked(_ address: SignalServiceAddress, transaction: SDSAnyReadTransaction) -> Bool {
         unfairLock.withLock { self.currentState.isBlocked(address: address) }
@@ -471,18 +462,12 @@ public class BlockingManager: NSObject {
     // MARK: - Group Blocking
 
     @objc
-    public var blockedGroupIds: Set<Data> {
-        let blockedGroupIds = unfairLock.withLock { self.currentState.blockedGroupMap.keys }
-        return Set(blockedGroupIds)
-    }
-
-    @objc
-    public var blockedGroupModels: [TSGroupModel] {
+    public func blockedGroupModels(transaction: SDSAnyReadTransaction) -> [TSGroupModel] {
         unfairLock.withLock { Array(self.currentState.blockedGroupMap.values) }
     }
 
     @objc
-    public func isGroupIdBlocked(_ groupId: Data) -> Bool {
+    public func isGroupIdBlocked(_ groupId: Data, transaction: SDSAnyReadTransaction) -> Bool {
         unfairLock.withLock { self.currentState.isBlocked(groupId: groupId) }
     }
 
@@ -627,7 +612,7 @@ public class BlockingManager: NSObject {
         if let contactThread = thread as? TSContactThread {
             return isAddressBlocked(contactThread.contactAddress, transaction: transaction)
         } else if let groupThread = thread as? TSGroupThread {
-            return isGroupIdBlocked(groupThread.groupModel.groupId)
+            return isGroupIdBlocked(groupThread.groupModel.groupId, transaction: transaction)
         } else {
             owsFailDebug("Invalid thread: \(type(of: thread))")
             return false
diff --git a/SignalServiceKit/src/Messages/MessageSender.swift b/SignalServiceKit/src/Messages/MessageSender.swift
index f72ae098c77..43e5e3a0467 100644
--- a/SignalServiceKit/src/Messages/MessageSender.swift
+++ b/SignalServiceKit/src/Messages/MessageSender.swift
@@ -666,10 +666,8 @@ extension MessageSender {
             currentValidRecipients.remove(localAddress)
             recipientAddresses.formIntersection(currentValidRecipients)
 
-            let blockedAddressSet = databaseStorage.read {
-                blockingManager.blockedAddressSetWithTransaction($0)
-            }
-            recipientAddresses.subtract(blockedAddressSet)
+            let blockedAddresses = databaseStorage.read { blockingManager.blockedAddresses(transaction: $0) }
+            recipientAddresses.subtract(blockedAddresses)
 
             if recipientAddresses.contains(localAddress) {
                 owsFailDebug("Message send recipients should not include self.")
@@ -687,11 +685,12 @@ extension MessageSender {
             // you might, for example, have a pending outgoing message when
             // you block them.
             let isBlocked = databaseStorage.read { blockingManager.isAddressBlocked(contactAddress, transaction: $0) }
-            guard !isBlocked else {
+            if isBlocked {
                 Logger.info("Skipping 1:1 send to blocked contact: \(contactAddress).")
                 throw MessageSenderError.blockedContactRecipient
+            } else {
+                return [contactAddress]
             }
-            return [contactAddress]
         } else {
             owsFailDebug("Invalid thread.")
             throw SSKUnretryableError.invalidThread
diff --git a/SignalServiceKit/src/Messages/OWSMessageManager.m b/SignalServiceKit/src/Messages/OWSMessageManager.m
index 140eea15c74..310668fe52d 100644
--- a/SignalServiceKit/src/Messages/OWSMessageManager.m
+++ b/SignalServiceKit/src/Messages/OWSMessageManager.m
@@ -148,7 +148,7 @@ - (BOOL)isDataMessageBlocked:(SSKProtoDataMessage *)dataMessage
 
     NSData *_Nullable groupId = [self groupIdForDataMessage:dataMessage];
     if (groupId != nil) {
-        return [self.blockingManager isGroupIdBlocked:groupId];
+        return [self.blockingManager isGroupIdBlocked:groupId transaction:transaction];
     } else {
         BOOL senderBlocked = [self isEnvelopeSenderBlocked:envelope transaction:transaction];
 
@@ -1155,7 +1155,7 @@ - (void)handleIncomingEnvelope:(SSKProtoEnvelope *)envelope
         OWSLogVerbose(@"Ignoring typing indicators from self or linked device.");
         return;
     } else if ([self.blockingManager isAddressBlocked:envelope.sourceAddress transaction:transaction]
-        || (typingMessage.hasGroupID && [self.blockingManager isGroupIdBlocked:typingMessage.groupID])) {
+        || (typingMessage.hasGroupID && [self.blockingManager isGroupIdBlocked:typingMessage.groupID transaction:transaction])) {
         NSString *logMessage =
             [NSString stringWithFormat:@"Ignoring blocked message from sender: %@", envelope.sourceAddress];
         if (typingMessage.hasGroupID) {
diff --git a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
index 4b37615df5b..870e620bc1f 100644
--- a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
+++ b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
@@ -111,7 +111,7 @@ public final class StoryMessage: NSObject, SDSCodableModel {
             groupId = nil
         }
 
-        if let groupId = groupId, blockingManager.isGroupIdBlocked(groupId) {
+        if let groupId = groupId, blockingManager.isGroupIdBlocked(groupId, transaction: transaction) {
             Logger.warn("Ignoring StoryMessage in blocked group.")
             return nil
         } else if blockingManager.isAddressBlocked(author, transaction: transaction) {
diff --git a/SignalServiceKit/src/Network/Receiving/GroupsV2MessageProcessor.swift b/SignalServiceKit/src/Network/Receiving/GroupsV2MessageProcessor.swift
index 4594122db6b..f08185ba378 100644
--- a/SignalServiceKit/src/Network/Receiving/GroupsV2MessageProcessor.swift
+++ b/SignalServiceKit/src/Network/Receiving/GroupsV2MessageProcessor.swift
@@ -457,7 +457,7 @@ internal class GroupsMessageProcessor: MessageProcessingPipelineStage, Dependenc
             return .discard
         }
         guard !blockingManager.isAddressBlocked(sourceAddress, transaction: transaction) &&
-            !blockingManager.isGroupIdBlocked(groupContextInfo.groupId) else {
+            !blockingManager.isGroupIdBlocked(groupContextInfo.groupId, transaction: transaction) else {
                 Logger.info("Discarding blocked envelope.")
             return .discard
         }
diff --git a/SignalServiceKit/src/groups/GroupManager.swift b/SignalServiceKit/src/groups/GroupManager.swift
index ca7477880f7..388dc31e6e1 100644
--- a/SignalServiceKit/src/groups/GroupManager.swift
+++ b/SignalServiceKit/src/groups/GroupManager.swift
@@ -1862,7 +1862,7 @@ public class GroupManager: NSObject {
         }
         let inProfileWhitelist = profileManager.isThread(inProfileWhitelist: groupThreadV1,
                                                          transaction: transaction)
-        let isBlocked = blockingManager.isGroupIdBlocked(groupIdV1)
+        let isBlocked = blockingManager.isGroupIdBlocked(groupIdV1, transaction: transaction)
 
         // We re-use the same model.
         let groupThreadV2 = groupThreadV1
