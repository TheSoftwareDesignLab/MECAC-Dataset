diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 5c09f4e3e46..5e305ae7b37 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -2595,7 +2595,6 @@ - (void)updateScrollDownButtonLayout
 {
     CGFloat inset = -(self.collectionView.contentInset.bottom + self.bottomLayoutGuide.length);
     self.scrollDownButtonButtomConstraint.constant = inset;
-    [self.scrollDownButton setNeedsLayout];
 }
 
 - (void)setHasUnreadMessages:(BOOL)hasUnreadMessages
@@ -3886,15 +3885,7 @@ - (void)handleKeyboardNotification:(NSNotification *)notification
         // RADAR: #36297652
         [self updateScrollDownButtonLayout];
 
-        // HACK: I've made the assumption that we are already in the context of an animation, in which case the
-        // above should be sufficient to smoothly move the scrollDown button in step with the keyboard presentation
-        // animation. Yet, setting the constraint doesn't animate the movement of the button - it "jumps" to it's final
-        // position. So here we manually lay out the scroll down button frame (seemingly redundantly), which allows it
-        // to be smoothly animated.
-        CGRect newButtonFrame = self.scrollDownButton.frame;
-        newButtonFrame.origin.y = self.scrollDownButton.superview.height
-            - (newInsets.bottom + self.scrollDownButton.height + self.bottomLayoutGuide.length);
-        self.scrollDownButton.frame = newButtonFrame;
+        [self.view layoutSubviews];
 
         // Adjust content offset to prevent the presented keyboard from obscuring content.
         if (!self.viewHasEverAppeared) {
@@ -5164,6 +5155,7 @@ - (void)updateInputToolbarLayout
 
     // Scroll button layout depends on input toolbar size.
     [self updateScrollDownButtonLayout];
+    [self.view setNeedsLayout];
 }
 
 @end
