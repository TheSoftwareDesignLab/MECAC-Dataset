diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 680e48bd926..73a11054cd4 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -85,15 +85,17 @@
 		341F2C0F1F2B8AE700D07D6B /* DebugUIMisc.m in Sources */ = {isa = PBXBuildFile; fileRef = 341F2C0E1F2B8AE700D07D6B /* DebugUIMisc.m */; };
 		3421981C21061D2E00C57195 /* ByteParserTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3421981B21061D2E00C57195 /* ByteParserTest.swift */; };
 		34235F3824213550008C74CB /* ConversationSettingsViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34235F3724213550008C74CB /* ConversationSettingsViewController.swift */; };
+		3425A5992631DC05006D5863 /* LinkPreviewState.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3425A5982631DC05006D5863 /* LinkPreviewState.swift */; };
+		3425A5A02631E051006D5863 /* CVCellMeasurement.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3425A59D2631E051006D5863 /* CVCellMeasurement.swift */; };
+		3425A5A12631E051006D5863 /* CVUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3425A59E2631E051006D5863 /* CVUtils.swift */; };
+		3425A5A22631E051006D5863 /* CVText.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3425A59F2631E051006D5863 /* CVText.swift */; };
 		3426A366255C854B0036407F /* CVItemViewModelImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A365255C854A0036407F /* CVItemViewModelImpl.swift */; };
 		3426A368255D7BCA0036407F /* ConversationViewController+MessageActionsDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A367255D7BCA0036407F /* ConversationViewController+MessageActionsDelegate.swift */; };
 		3426A36A255D9D7C0036407F /* ConversationViewController+Selection.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A369255D9D7C0036407F /* ConversationViewController+Selection.swift */; };
 		3426A36E255EB9F50036407F /* CVItemViewModel.h in Headers */ = {isa = PBXBuildFile; fileRef = 3426A36D255EB9F50036407F /* CVItemViewModel.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		3426A37025631C250036407F /* CVComponentLinkPreview.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A36F25631C220036407F /* CVComponentLinkPreview.swift */; };
-		3426A372256320420036407F /* CVText.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A371256320410036407F /* CVText.swift */; };
 		3426A375256321190036407F /* OWSMessageTextView.m in Sources */ = {isa = PBXBuildFile; fileRef = 3426A373256321190036407F /* OWSMessageTextView.m */; };
 		3426A376256321190036407F /* OWSMessageTextView.h in Headers */ = {isa = PBXBuildFile; fileRef = 3426A374256321190036407F /* OWSMessageTextView.h */; settings = {ATTRIBUTES = (Public, ); }; };
-		3426A378256321C50036407F /* CVUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A377256321C50036407F /* CVUtils.swift */; };
 		3426A37A2563F0EA0036407F /* CVComponentBottomButtons.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3426A3792563F0EA0036407F /* CVComponentBottomButtons.swift */; };
 		34277A5E20751BDC006049F2 /* OWSQuotedMessageView.m in Sources */ = {isa = PBXBuildFile; fileRef = 34277A5C20751BDC006049F2 /* OWSQuotedMessageView.m */; };
 		342950822124C9750000B063 /* OWSTextField.m in Sources */ = {isa = PBXBuildFile; fileRef = 3429507E2124C9740000B063 /* OWSTextField.m */; };
@@ -453,7 +455,6 @@
 		34EB0CEB26289D8800B62DC3 /* MessageTimerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34EB0CEA26289D8800B62DC3 /* MessageTimerView.swift */; };
 		34EB0DF52628D3B300B62DC3 /* ConversationInternalViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34EB0DF42628D3B200B62DC3 /* ConversationInternalViewController.swift */; };
 		34EB0E722629DC2B00B62DC3 /* MessageSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34EB0E712629DC2B00B62DC3 /* MessageSelectionView.swift */; };
-		34EB0E7E2629E00500B62DC3 /* CVHelpers.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34EB0E7D2629E00400B62DC3 /* CVHelpers.swift */; };
 		34ED55A123D0D59700446E39 /* NSItemProvider+Promises.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34ED55A023D0D59700446E39 /* NSItemProvider+Promises.swift */; };
 		34EEECF225E846ED00574F0D /* SendPaymentMemoViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34EEECF125E846EC00574F0D /* SendPaymentMemoViewController.swift */; };
 		34F0566A23DA209300265283 /* GroupsV2IncomingChanges.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34F0566923DA209300265283 /* GroupsV2IncomingChanges.swift */; };
@@ -1095,15 +1096,17 @@
 		341F2C0E1F2B8AE700D07D6B /* DebugUIMisc.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DebugUIMisc.m; sourceTree = "<group>"; };
 		3421981B21061D2E00C57195 /* ByteParserTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ByteParserTest.swift; sourceTree = "<group>"; };
 		34235F3724213550008C74CB /* ConversationSettingsViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ConversationSettingsViewController.swift; sourceTree = "<group>"; };
+		3425A5982631DC05006D5863 /* LinkPreviewState.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = LinkPreviewState.swift; sourceTree = "<group>"; };
+		3425A59D2631E051006D5863 /* CVCellMeasurement.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVCellMeasurement.swift; sourceTree = "<group>"; };
+		3425A59E2631E051006D5863 /* CVUtils.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVUtils.swift; sourceTree = "<group>"; };
+		3425A59F2631E051006D5863 /* CVText.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVText.swift; sourceTree = "<group>"; };
 		3426A365255C854A0036407F /* CVItemViewModelImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVItemViewModelImpl.swift; sourceTree = "<group>"; };
 		3426A367255D7BCA0036407F /* ConversationViewController+MessageActionsDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "ConversationViewController+MessageActionsDelegate.swift"; sourceTree = "<group>"; };
 		3426A369255D9D7C0036407F /* ConversationViewController+Selection.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "ConversationViewController+Selection.swift"; sourceTree = "<group>"; };
 		3426A36D255EB9F50036407F /* CVItemViewModel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CVItemViewModel.h; sourceTree = "<group>"; };
 		3426A36F25631C220036407F /* CVComponentLinkPreview.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVComponentLinkPreview.swift; sourceTree = "<group>"; };
-		3426A371256320410036407F /* CVText.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVText.swift; sourceTree = "<group>"; };
 		3426A373256321190036407F /* OWSMessageTextView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = OWSMessageTextView.m; sourceTree = "<group>"; };
 		3426A374256321190036407F /* OWSMessageTextView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = OWSMessageTextView.h; sourceTree = "<group>"; };
-		3426A377256321C50036407F /* CVUtils.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVUtils.swift; sourceTree = "<group>"; };
 		3426A3792563F0EA0036407F /* CVComponentBottomButtons.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVComponentBottomButtons.swift; sourceTree = "<group>"; };
 		34277A5C20751BDC006049F2 /* OWSQuotedMessageView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = OWSQuotedMessageView.m; sourceTree = "<group>"; };
 		34277A5D20751BDC006049F2 /* OWSQuotedMessageView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = OWSQuotedMessageView.h; sourceTree = "<group>"; };
@@ -1511,7 +1514,6 @@
 		34EB0CEA26289D8800B62DC3 /* MessageTimerView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageTimerView.swift; sourceTree = "<group>"; };
 		34EB0DF42628D3B200B62DC3 /* ConversationInternalViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ConversationInternalViewController.swift; sourceTree = "<group>"; };
 		34EB0E712629DC2B00B62DC3 /* MessageSelectionView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageSelectionView.swift; sourceTree = "<group>"; };
-		34EB0E7D2629E00400B62DC3 /* CVHelpers.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CVHelpers.swift; sourceTree = "<group>"; };
 		34ED55A023D0D59700446E39 /* NSItemProvider+Promises.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "NSItemProvider+Promises.swift"; sourceTree = "<group>"; };
 		34EEECF125E846EC00574F0D /* SendPaymentMemoViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SendPaymentMemoViewController.swift; sourceTree = "<group>"; };
 		34F0566923DA209300265283 /* GroupsV2IncomingChanges.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GroupsV2IncomingChanges.swift; sourceTree = "<group>"; };
@@ -2345,6 +2347,16 @@
 			path = ThreadSettings;
 			sourceTree = "<group>";
 		};
+		3425A59C2631E051006D5863 /* ConversationView */ = {
+			isa = PBXGroup;
+			children = (
+				3425A59D2631E051006D5863 /* CVCellMeasurement.swift */,
+				3425A59F2631E051006D5863 /* CVText.swift */,
+				3425A59E2631E051006D5863 /* CVUtils.swift */,
+			);
+			path = ConversationView;
+			sourceTree = "<group>";
+		};
 		34330A581E7875FB00DF2FB9 /* Fonts */ = {
 			isa = PBXGroup;
 			children = (
@@ -2572,8 +2584,7 @@
 				34AC09FF211B39E700997B47 /* ContactTableViewCell.m */,
 				348D8E71262DF67A0019CAA8 /* ConversationAvatarView.swift */,
 				8809CE8022F534B200D38867 /* CustomKeyboard.swift */,
-				3426A371256320410036407F /* CVText.swift */,
-				3426A377256321C50036407F /* CVUtils.swift */,
+				3425A59C2631E051006D5863 /* ConversationView */,
 				4523149F1F7E9E18003A428C /* DirectionalPanGestureRecognizer.swift */,
 				34AC0A00211B39E700997B47 /* DisappearingTimerConfigurationView.swift */,
 				4CA46F49219C78050038ABDE /* GalleryRailView.swift */,
@@ -2666,7 +2677,6 @@
 				347C3839252CE6C900F3D941 /* CVComponents */,
 				347C381E252CE69400F3D941 /* CVComponentState.swift */,
 				347C3819252CE69400F3D941 /* CVComponentState+GroupLink.swift */,
-				34EB0E7D2629E00400B62DC3 /* CVHelpers.swift */,
 				347C3824252CE69400F3D941 /* CVItemModel.swift */,
 				3426A365255C854A0036407F /* CVItemViewModelImpl.swift */,
 				347C3820252CE69400F3D941 /* CVItemViewState.swift */,
@@ -3523,8 +3533,9 @@
 		8860CC1F2508506F00A4D18E /* Link Preview */ = {
 			isa = PBXGroup;
 			children = (
-				34129B8521EF8779005457A8 /* LinkPreviewView.swift */,
 				8860CC202508507F00A4D18E /* GroupLinkPreview.swift */,
+				3425A5982631DC05006D5863 /* LinkPreviewState.swift */,
+				34129B8521EF8779005457A8 /* LinkPreviewView.swift */,
 			);
 			path = "Link Preview";
 			sourceTree = "<group>";
@@ -4875,6 +4886,7 @@
 				34BBC858220C7ADA00857249 /* ImageEditorContents.swift in Sources */,
 				3461293A1FD1B47300532771 /* OWSPreferences.m in Sources */,
 				3474C56F26111605006723D2 /* PaymentsProcessor.swift in Sources */,
+				3425A5A02631E051006D5863 /* CVCellMeasurement.swift in Sources */,
 				34480B671FD0AA9400BC14EF /* UIFont+OWS.m in Sources */,
 				4C0387532339B3220062D293 /* UIColor+OWS.swift in Sources */,
 				88D5887824846A7F00DC9AB6 /* InputAccessoryViewPlaceholder.swift in Sources */,
@@ -4908,6 +4920,7 @@
 				340872CA2239563500CB25B0 /* AttachmentApprovalViewController.swift in Sources */,
 				346129AD1FD1F34E00532771 /* ImageCache.swift in Sources */,
 				3465948424352FE900E5C510 /* OWSTableViewController.swift in Sources */,
+				3425A5A22631E051006D5863 /* CVText.swift in Sources */,
 				88EFF4F525AD1ACB000FAFBA /* ConversationItem.swift in Sources */,
 				340B870E23DF3E3A00BE0AFC /* GroupV2UpdatesImpl.swift in Sources */,
 				340872D02239787F00CB25B0 /* AttachmentTextToolbar.swift in Sources */,
@@ -4919,7 +4932,6 @@
 				34080F04222858DC0087E99F /* OWSViewController+ImageEditor.swift in Sources */,
 				3474C57326111605006723D2 /* PaymentsImpl.swift in Sources */,
 				34AC0A10211B39EA00997B47 /* TappableView.swift in Sources */,
-				3426A372256320420036407F /* CVText.swift in Sources */,
 				34C2EEAC2270A69400BCA1D0 /* CircleView.swift in Sources */,
 				34AC09E9211B39B100997B47 /* OWSTableViewController.m in Sources */,
 				340872CE2239596100CB25B0 /* AttachmentApprovalToolbar.swift in Sources */,
@@ -4933,8 +4945,8 @@
 				454A965A1FD6017E008D2A0E /* SignalAttachment.swift in Sources */,
 				45BC829D1FD9C4B400011CF3 /* ShareViewDelegate.swift in Sources */,
 				3461295B1FD1D74C00532771 /* Environment.m in Sources */,
-				3426A378256321C50036407F /* CVUtils.swift in Sources */,
 				346129D51FD20ADC00532771 /* UIViewController+OWS.m in Sources */,
+				3425A5A12631E051006D5863 /* CVUtils.swift in Sources */,
 				34BB3C5D23C6644B001651FC /* GroupsV2Utils.swift in Sources */,
 				8860CC212508507F00A4D18E /* GroupLinkPreview.swift in Sources */,
 				34BB3C6023C6644B001651FC /* GroupV2Params.swift in Sources */,
@@ -5012,6 +5024,7 @@
 				34641E182088D7E900E2EDE5 /* OWSScreenLock.swift in Sources */,
 				34BB3C5E23C6644B001651FC /* GroupsV2OutgoingChangesImpl.swift in Sources */,
 				8821334E2304E72700353626 /* NonContactTableViewCell.swift in Sources */,
+				3425A5992631DC05006D5863 /* LinkPreviewState.swift in Sources */,
 				34480B561FD0A7A400BC14EF /* DebugLogger.m in Sources */,
 				886BB3D725BA871B00079781 /* Wallpaper.swift in Sources */,
 				459B775C207BA46C0071D0AB /* OWSQuotedReplyModel.m in Sources */,
@@ -5388,7 +5401,6 @@
 				3470518E254B511B00A19468 /* ConversationViewController+CVC.swift in Sources */,
 				45F32C242057297A00A300D5 /* MessageDetailViewController.swift in Sources */,
 				32ECD09F24C1153000EDDED0 /* SupportRequestTextView.swift in Sources */,
-				34EB0E7E2629E00500B62DC3 /* CVHelpers.swift in Sources */,
 				4C19A0FC227B356F007A0C7F /* DebugUIMessages+OWS.swift in Sources */,
 				3496955C219B605E00DCFE74 /* ImagePickerController.swift in Sources */,
 				34D1F0841F8678AA0066283D /* ConversationInputToolbar.m in Sources */,
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift
index 69e4d18c2c6..6747a388424 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift
@@ -89,108 +89,6 @@ public protocol CVAccessibilityComponent: CVComponent {
 
 // MARK: -
 
-// TODO: There has to be a better way to do this.
-public class CVMeasurementObject: Equatable {
-
-    // MARK: - Equatable
-
-    public static func == (lhs: CVMeasurementObject, rhs: CVMeasurementObject) -> Bool {
-        true
-    }
-}
-
-// CVCellMeasurement captures the measurement state from the load.
-// This lets us pin cell views to their measured sizes.  This is
-// necessary because some UIViews (like UIImageView) set up
-// layout contraints based on their content that we want to override.
-public struct CVCellMeasurement: Equatable {
-
-    public typealias Measurement = ManualStackMeasurement
-    public typealias ObjectType = CVMeasurementObject
-
-    let cellSize: CGSize
-    private let sizes: [String: CGSize]
-    private let values: [String: CGFloat]
-    private let measurements: [String: Measurement]
-    private let objects: [String: ObjectType]
-
-    public class Builder {
-        var cellSize: CGSize = .zero
-        private var sizes = [String: CGSize]()
-        private var values = [String: CGFloat]()
-        private var measurements = [String: Measurement]()
-        private var objects = [String: ObjectType]()
-
-        func build() -> CVCellMeasurement {
-            CVCellMeasurement(cellSize: cellSize,
-                              sizes: sizes,
-                              values: values,
-                              measurements: measurements,
-                              objects: objects)
-        }
-
-        func setSize(key: String, size: CGSize) {
-            owsAssertDebug(sizes[key] == nil)
-
-            sizes[key] = size
-        }
-
-        func setValue(key: String, value: CGFloat) {
-            owsAssertDebug(values[key] == nil)
-
-            values[key] = value
-        }
-
-        func setMeasurement(key: String, value: Measurement) {
-            owsAssertDebug(measurements[key] == nil)
-
-            measurements[key] = value
-        }
-
-        func setObject(key: String, value: ObjectType) {
-            owsAssertDebug(measurements[key] == nil)
-
-            objects[key] = value
-        }
-    }
-
-    func size(key: String) -> CGSize? {
-        sizes[key]
-    }
-
-    func value(key: String) -> CGFloat? {
-        values[key]
-    }
-
-    func measurement(key: String) -> Measurement? {
-        measurements[key]
-    }
-
-    func object<T>(key: String) -> T? {
-        guard let value = objects[key] else {
-            return nil
-        }
-        guard let object = value as? T else {
-            owsFailDebug("Missing object: \(key)")
-            return nil
-        }
-        return object
-    }
-
-    public var debugDescription: String {
-        "[cellSize: \(cellSize), sizes: \(sizes), values: \(values), measurements: \(measurements)]"
-    }
-
-    public func debugLog() {
-        Logger.verbose("cellSize: \(cellSize)")
-        Logger.verbose("sizes: \(sizes)")
-        Logger.verbose("values: \(values)")
-        Logger.verbose("measurements: \(measurements)")
-    }
-}
-
-// MARK: -
-
 @objc
 public class CVComponentBase: NSObject {
     @objc
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVStackView.swift b/Signal/src/ViewControllers/ConversationView/CV/CVStackView.swift
index 51937bd0fbb..8f7ef60231d 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVStackView.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVStackView.swift
@@ -81,43 +81,3 @@ public extension CGRect {
         }
     }
 }
-
-// MARK: -
-
-public extension ManualStackView {
-
-    func configure(config: Config,
-                   cellMeasurement: CVCellMeasurement,
-                   measurementKey: String,
-                   subviews: [UIView]) {
-        guard let measurement = cellMeasurement.measurement(key: measurementKey) else {
-            owsFailDebug("Missing measurement.")
-            return
-        }
-        configure(config: config,
-                  measurement: measurement,
-                  subviews: subviews)
-    }
-
-    func configureForReuse(config: Config,
-                           cellMeasurement: CVCellMeasurement,
-                           measurementKey: String) {
-        guard let measurement = cellMeasurement.measurement(key: measurementKey) else {
-            owsFailDebug("Missing measurement.")
-            return
-        }
-        configureForReuse(config: config, measurement: measurement)
-    }
-
-    static func measure(config: Config,
-                        measurementBuilder: CVCellMeasurement.Builder,
-                        measurementKey: String,
-                        subviewInfos: [ManualStackSubviewInfo],
-                        verboseLogging: Bool = false) -> Measurement {
-        let measurement = Self.measure(config: config,
-                                       subviewInfos: subviewInfos,
-                                       verboseLogging: verboseLogging)
-        measurementBuilder.setMeasurement(key: measurementKey, value: measurement)
-        return measurement
-    }
-}
diff --git a/SignalMessaging/Views/CVUtils.swift b/SignalMessaging/Views/CVUtils.swift
deleted file mode 100644
index 1de4abdd308..00000000000
--- a/SignalMessaging/Views/CVUtils.swift
+++ /dev/null
@@ -1,18 +0,0 @@
-//
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
-//
-
-import Foundation
-
-public class CVUtils {
-
-    @available(*, unavailable, message: "use other init() instead.")
-    private init() {}
-
-    public static let workQueue: DispatchQueue = {
-        // Note that we use the highest qos.
-        DispatchQueue(label: "org.whispersystems.signal.conversationView",
-                             qos: .userInteractive,
-                             autoreleaseFrequency: .workItem)
-    }()
-}
diff --git a/SignalMessaging/Views/ConversationView/CVCellMeasurement.swift b/SignalMessaging/Views/ConversationView/CVCellMeasurement.swift
new file mode 100644
index 00000000000..2a41186c2be
--- /dev/null
+++ b/SignalMessaging/Views/ConversationView/CVCellMeasurement.swift
@@ -0,0 +1,144 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public class CVMeasurementObject: Equatable {
+
+    // MARK: - Equatable
+
+    public static func == (lhs: CVMeasurementObject, rhs: CVMeasurementObject) -> Bool {
+        true
+    }
+}
+
+// CVCellMeasurement captures the measurement state from the load.
+// This lets us pin cell views to their measured sizes.  This is
+// necessary because some UIViews (like UIImageView) set up
+// layout contraints based on their content that we want to override.
+public struct CVCellMeasurement: Equatable {
+
+    public typealias Measurement = ManualStackMeasurement
+    public typealias ObjectType = CVMeasurementObject
+
+    let cellSize: CGSize
+    private let sizes: [String: CGSize]
+    private let values: [String: CGFloat]
+    private let measurements: [String: Measurement]
+    private let objects: [String: ObjectType]
+
+    public class Builder {
+        var cellSize: CGSize = .zero
+        private var sizes = [String: CGSize]()
+        private var values = [String: CGFloat]()
+        private var measurements = [String: Measurement]()
+        private var objects = [String: ObjectType]()
+
+        func build() -> CVCellMeasurement {
+            CVCellMeasurement(cellSize: cellSize,
+                              sizes: sizes,
+                              values: values,
+                              measurements: measurements,
+                              objects: objects)
+        }
+
+        func setSize(key: String, size: CGSize) {
+            owsAssertDebug(sizes[key] == nil)
+
+            sizes[key] = size
+        }
+
+        func setValue(key: String, value: CGFloat) {
+            owsAssertDebug(values[key] == nil)
+
+            values[key] = value
+        }
+
+        func setMeasurement(key: String, value: Measurement) {
+            owsAssertDebug(measurements[key] == nil)
+
+            measurements[key] = value
+        }
+
+        func setObject(key: String, value: ObjectType) {
+            owsAssertDebug(measurements[key] == nil)
+
+            objects[key] = value
+        }
+    }
+
+    func size(key: String) -> CGSize? {
+        sizes[key]
+    }
+
+    func value(key: String) -> CGFloat? {
+        values[key]
+    }
+
+    func measurement(key: String) -> Measurement? {
+        measurements[key]
+    }
+
+    func object<T>(key: String) -> T? {
+        guard let value = objects[key] else {
+            return nil
+        }
+        guard let object = value as? T else {
+            owsFailDebug("Missing object: \(key)")
+            return nil
+        }
+        return object
+    }
+
+    public var debugDescription: String {
+        "[cellSize: \(cellSize), sizes: \(sizes), values: \(values), measurements: \(measurements)]"
+    }
+
+    public func debugLog() {
+        Logger.verbose("cellSize: \(cellSize)")
+        Logger.verbose("sizes: \(sizes)")
+        Logger.verbose("values: \(values)")
+        Logger.verbose("measurements: \(measurements)")
+    }
+}
+
+// MARK: -
+
+public extension ManualStackView {
+
+    func configure(config: Config,
+                   cellMeasurement: CVCellMeasurement,
+                   measurementKey: String,
+                   subviews: [UIView]) {
+        guard let measurement = cellMeasurement.measurement(key: measurementKey) else {
+            owsFailDebug("Missing measurement.")
+            return
+        }
+        configure(config: config,
+                  measurement: measurement,
+                  subviews: subviews)
+    }
+
+    func configureForReuse(config: Config,
+                           cellMeasurement: CVCellMeasurement,
+                           measurementKey: String) {
+        guard let measurement = cellMeasurement.measurement(key: measurementKey) else {
+            owsFailDebug("Missing measurement.")
+            return
+        }
+        configureForReuse(config: config, measurement: measurement)
+    }
+
+    static func measure(config: Config,
+                        measurementBuilder: CVCellMeasurement.Builder,
+                        measurementKey: String,
+                        subviewInfos: [ManualStackSubviewInfo],
+                        verboseLogging: Bool = false) -> Measurement {
+        let measurement = Self.measure(config: config,
+                                       subviewInfos: subviewInfos,
+                                       verboseLogging: verboseLogging)
+        measurementBuilder.setMeasurement(key: measurementKey, value: measurement)
+        return measurement
+    }
+}
diff --git a/SignalMessaging/Views/CVText.swift b/SignalMessaging/Views/ConversationView/CVText.swift
similarity index 99%
rename from SignalMessaging/Views/CVText.swift
rename to SignalMessaging/Views/ConversationView/CVText.swift
index b9ac9b7601b..73a96191f2a 100644
--- a/SignalMessaging/Views/CVText.swift
+++ b/SignalMessaging/Views/ConversationView/CVText.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVHelpers.swift b/SignalMessaging/Views/ConversationView/CVUtils.swift
similarity index 59%
rename from Signal/src/ViewControllers/ConversationView/CV/CVHelpers.swift
rename to SignalMessaging/Views/ConversationView/CVUtils.swift
index 01d85436e9b..5ccd721564c 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVHelpers.swift
+++ b/SignalMessaging/Views/ConversationView/CVUtils.swift
@@ -3,6 +3,22 @@
 //
 
 import Foundation
+import YYImage
+
+public class CVUtils {
+
+    @available(*, unavailable, message: "use other init() instead.")
+    private init() {}
+
+    public static let workQueue: DispatchQueue = {
+        // Note that we use the highest qos.
+        DispatchQueue(label: "org.whispersystems.signal.conversationView",
+                             qos: .userInteractive,
+                             autoreleaseFrequency: .workItem)
+    }()
+}
+
+// MARK: -
 
 @objc
 public class CVLabel: UILabel {
diff --git a/SignalMessaging/Views/Link Preview/LinkPreviewState.swift b/SignalMessaging/Views/Link Preview/LinkPreviewState.swift
new file mode 100644
index 00000000000..cdf54364dfe
--- /dev/null
+++ b/SignalMessaging/Views/Link Preview/LinkPreviewState.swift	
@@ -0,0 +1,326 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import YYImage
+
+@objc
+public enum LinkPreviewImageState: Int {
+    case none
+    case loading
+    case loaded
+    case invalid
+}
+
+// MARK: -
+
+@objc
+public protocol LinkPreviewState {
+    func isLoaded() -> Bool
+    func urlString() -> String?
+    func displayDomain() -> String?
+    func title() -> String?
+    func imageState() -> LinkPreviewImageState
+    func image() -> UIImage?
+    var imagePixelSize: CGSize { get }
+    func previewDescription() -> String?
+    func date() -> Date?
+    var isGroupInviteLink: Bool { get }
+    var activityIndicatorStyle: UIActivityIndicatorView.Style { get }
+    var conversationStyle: ConversationStyle? { get }
+}
+
+// MARK: -
+
+extension LinkPreviewState {
+    var hasLoadedImage: Bool {
+        isLoaded() && imageState() == .loaded
+    }
+}
+
+// MARK: -
+
+@objc
+public enum LinkPreviewLinkType: UInt {
+    case preview
+    case incomingMessage
+    case outgoingMessage
+    case incomingMessageGroupInviteLink
+    case outgoingMessageGroupInviteLink
+}
+
+// MARK: -
+
+@objc
+public class LinkPreviewLoading: NSObject, LinkPreviewState {
+
+    public let linkType: LinkPreviewLinkType
+
+    @objc
+    required init(linkType: LinkPreviewLinkType) {
+        self.linkType = linkType
+    }
+
+    public func isLoaded() -> Bool {
+        return false
+    }
+
+    public func urlString() -> String? {
+        return nil
+    }
+
+    public func displayDomain() -> String? {
+        return nil
+    }
+
+    public func title() -> String? {
+        return nil
+    }
+
+    public func imageState() -> LinkPreviewImageState {
+        return .none
+    }
+
+    public func image() -> UIImage? {
+        return nil
+    }
+
+    public let imagePixelSize: CGSize = .zero
+
+    public func previewDescription() -> String? {
+        return nil
+    }
+
+    public func date() -> Date? {
+        return nil
+    }
+
+    public var isGroupInviteLink: Bool {
+        switch linkType {
+        case .incomingMessageGroupInviteLink,
+             .outgoingMessageGroupInviteLink:
+            return true
+        default:
+            return false
+        }
+    }
+
+    public var activityIndicatorStyle: UIActivityIndicatorView.Style {
+        switch linkType {
+        case .incomingMessageGroupInviteLink:
+            return .gray
+        case .outgoingMessageGroupInviteLink:
+            return .white
+        default:
+            return LinkPreviewView.defaultActivityIndicatorStyle
+        }
+    }
+
+    public let conversationStyle: ConversationStyle? = nil
+}
+
+// MARK: -
+
+@objc
+public class LinkPreviewDraft: NSObject, LinkPreviewState {
+    let linkPreviewDraft: OWSLinkPreviewDraft
+
+    @objc
+    public required init(linkPreviewDraft: OWSLinkPreviewDraft) {
+        self.linkPreviewDraft = linkPreviewDraft
+    }
+
+    public func isLoaded() -> Bool {
+        return true
+    }
+
+    public func urlString() -> String? {
+        return linkPreviewDraft.urlString
+    }
+
+    public func displayDomain() -> String? {
+        guard let displayDomain = linkPreviewDraft.displayDomain() else {
+            owsFailDebug("Missing display domain")
+            return nil
+        }
+        return displayDomain
+    }
+
+    public func title() -> String? {
+        guard let value = linkPreviewDraft.title,
+            value.count > 0 else {
+                return nil
+        }
+        return value
+    }
+
+    public func imageState() -> LinkPreviewImageState {
+        if linkPreviewDraft.imageData != nil {
+            return .loaded
+        } else {
+            return .none
+        }
+    }
+
+    public func image() -> UIImage? {
+        assert(imageState() == .loaded)
+
+        guard let imageData = linkPreviewDraft.imageData else {
+            return nil
+        }
+        guard let image = UIImage(data: imageData) else {
+            owsFailDebug("Could not load image: \(imageData.count)")
+            return nil
+        }
+        return image
+    }
+
+    public var imagePixelSize: CGSize {
+        guard let image = self.image() else {
+            return .zero
+        }
+        return image.pixelSize()
+    }
+
+    public func previewDescription() -> String? {
+        linkPreviewDraft.previewDescription
+    }
+
+    public func date() -> Date? {
+        linkPreviewDraft.date
+    }
+
+    public let isGroupInviteLink = false
+
+    public var activityIndicatorStyle: UIActivityIndicatorView.Style {
+        LinkPreviewView.defaultActivityIndicatorStyle
+    }
+
+    public let conversationStyle: ConversationStyle? = nil
+}
+
+// MARK: -
+
+@objc
+public class LinkPreviewSent: NSObject, LinkPreviewState {
+    private let linkPreview: OWSLinkPreview
+    private let imageAttachment: TSAttachment?
+
+    private let _conversationStyle: ConversationStyle
+    public var conversationStyle: ConversationStyle? {
+        _conversationStyle
+    }
+
+    @objc
+    public required init(linkPreview: OWSLinkPreview,
+                  imageAttachment: TSAttachment?,
+                  conversationStyle: ConversationStyle) {
+        self.linkPreview = linkPreview
+        self.imageAttachment = imageAttachment
+        _conversationStyle = conversationStyle
+    }
+
+    public func isLoaded() -> Bool {
+        return true
+    }
+
+    public func urlString() -> String? {
+        guard let urlString = linkPreview.urlString else {
+            owsFailDebug("Missing url")
+            return nil
+        }
+        return urlString
+    }
+
+    public func displayDomain() -> String? {
+        guard let displayDomain = linkPreview.displayDomain() else {
+            Logger.error("Missing display domain")
+            return nil
+        }
+        return displayDomain
+    }
+
+    public func title() -> String? {
+        guard let value = linkPreview.title?.filterForDisplay,
+            value.count > 0 else {
+                return nil
+        }
+        return value
+    }
+
+    public func imageState() -> LinkPreviewImageState {
+        guard linkPreview.imageAttachmentId != nil else {
+            return .none
+        }
+        guard let imageAttachment = imageAttachment else {
+            Logger.warn("Missing imageAttachment.")
+            return .none
+        }
+        guard let attachmentStream = imageAttachment as? TSAttachmentStream else {
+            return .loading
+        }
+        guard attachmentStream.isImage,
+            attachmentStream.isValidImage else {
+            return .invalid
+        }
+        return .loaded
+    }
+
+    public func image() -> UIImage? {
+        assert(imageState() == .loaded)
+
+        guard let attachmentStream = imageAttachment as? TSAttachmentStream else {
+            owsFailDebug("Could not load image.")
+            return nil
+        }
+        guard attachmentStream.isImage,
+            attachmentStream.isValidImage else {
+            return nil
+        }
+        guard let imageFilepath = attachmentStream.originalFilePath else {
+            owsFailDebug("Attachment is missing file path.")
+            return nil
+        }
+
+        guard NSData.ows_isValidImage(atPath: imageFilepath, mimeType: attachmentStream.contentType) else {
+            owsFailDebug("Invalid image.")
+            return nil
+        }
+
+        let imageClass: UIImage.Type
+        if attachmentStream.contentType == OWSMimeTypeImageWebp {
+            imageClass = YYImage.self
+        } else {
+            imageClass = UIImage.self
+        }
+
+        guard let image = imageClass.init(contentsOfFile: imageFilepath) else {
+            owsFailDebug("Could not load image: \(imageFilepath)")
+            return nil
+        }
+
+        return image
+    }
+
+    @objc
+    public var imagePixelSize: CGSize {
+        guard let attachmentStream = imageAttachment as? TSAttachmentStream else {
+            return CGSize.zero
+        }
+        return attachmentStream.imageSize()
+    }
+
+    public func previewDescription() -> String? {
+        linkPreview.previewDescription
+    }
+
+    public func date() -> Date? {
+        linkPreview.date
+    }
+
+    public let isGroupInviteLink = false
+
+    public var activityIndicatorStyle: UIActivityIndicatorView.Style {
+        LinkPreviewView.defaultActivityIndicatorStyle
+    }
+}
diff --git a/SignalMessaging/Views/Link Preview/LinkPreviewView.swift b/SignalMessaging/Views/Link Preview/LinkPreviewView.swift
index 8201a86883f..8e420c277eb 100644
--- a/SignalMessaging/Views/Link Preview/LinkPreviewView.swift	
+++ b/SignalMessaging/Views/Link Preview/LinkPreviewView.swift	
@@ -4,1266 +4,1145 @@
 
 import YYImage
 
-public extension CGPoint {
-    func offsetBy(dx: CGFloat) -> CGPoint {
-        return CGPoint(x: x + dx, y: y)
-    }
-
-    func offsetBy(dy: CGFloat) -> CGPoint {
-        return CGPoint(x: x, y: y + dy)
-    }
-}
-
-// MARK: -
-
-@objc
-public enum LinkPreviewImageState: Int {
-    case none
-    case loading
-    case loaded
-    case invalid
-}
-
-// MARK: -
-
-@objc
-public protocol LinkPreviewState {
-    func isLoaded() -> Bool
-    func urlString() -> String?
-    func displayDomain() -> String?
-    func title() -> String?
-    func imageState() -> LinkPreviewImageState
-    func image() -> UIImage?
-    var imagePixelSize: CGSize { get }
-    func previewDescription() -> String?
-    func date() -> Date?
-    var isGroupInviteLink: Bool { get }
-    var activityIndicatorStyle: UIActivityIndicatorView.Style { get }
-    var conversationStyle: ConversationStyle? { get }
-}
-
-// MARK: -
-
 @objc
-public enum LinkPreviewLinkType: UInt {
-    case preview
-    case incomingMessage
-    case outgoingMessage
-    case incomingMessageGroupInviteLink
-    case outgoingMessageGroupInviteLink
+public protocol LinkPreviewViewDraftDelegate {
+    func linkPreviewCanCancel() -> Bool
+    func linkPreviewDidCancel()
 }
 
 // MARK: -
 
 @objc
-public class LinkPreviewLoading: NSObject, LinkPreviewState {
+public class LinkPreviewView: ManualStackViewWithLayer {
+    private weak var draftDelegate: LinkPreviewViewDraftDelegate?
 
-    public let linkType: LinkPreviewLinkType
+    static let dateFormatter: DateFormatter = {
+        let formatter = DateFormatter()
+        formatter.dateStyle = .medium
+        formatter.timeStyle = .none
+        return formatter
+    }()
 
-    @objc
-    required init(linkType: LinkPreviewLinkType) {
-        self.linkType = linkType
-    }
+//    @objc
+//    public var state: LinkPreviewState? {
+//        didSet {
+//            AssertIsOnMainThread()
+//            updateContents()
+//        }
+//    }
+//
+//    @objc
+//    public var hasAsymmetricalRounding: Bool = false {
+//        didSet {
+//            AssertIsOnMainThread()
+//            owsAssertDebug(isDraft)
+//
+//            if hasAsymmetricalRounding != oldValue {
+//                updateContents()
+//            }
+//        }
+//    }
 
-    public func isLoaded() -> Bool {
-        return false
+    @available(*, unavailable, message: "use other constructor instead.")
+    required init(coder aDecoder: NSCoder) {
+        notImplemented()
     }
 
-    public func urlString() -> String? {
-        return nil
+    @available(*, unavailable, message: "use other constructor instead.")
+    required init(name: String, arrangedSubviews: [UIView] = []) {
+        notImplemented()
     }
 
-    public func displayDomain() -> String? {
-        return nil
-    }
+//    private var cancelButton: UIButton?
+//    private weak var heroImageView: UIView?
+//    private weak var sentBodyView: UIView?
 
-    public func title() -> String? {
-        return nil
-    }
+    fileprivate let rightStack = ManualStackView(name: "rightStack")
+    fileprivate let textStack = ManualStackView(name: "textStack")
 
-    public func imageState() -> LinkPreviewImageState {
-        return .none
-    }
+    fileprivate let titleLabel = CVLabel()
+    fileprivate let descriptionLabel = CVLabel()
+    fileprivate let displayDomainLabel = CVLabel()
 
-    public func image() -> UIImage? {
-        return nil
-    }
+    @objc
+    public init(draftDelegate: LinkPreviewViewDraftDelegate?) {
+        self.draftDelegate = draftDelegate
 
-    public let imagePixelSize: CGSize = .zero
+        super.init(name: "LinkPreviewView")
 
-    public func previewDescription() -> String? {
-        return nil
+        if let draftDelegate = draftDelegate,
+            draftDelegate.linkPreviewCanCancel() {
+            self.isUserInteractionEnabled = true
+            self.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(wasTapped)))
+        }
     }
 
-    public func date() -> Date? {
-        return nil
+    private var isDraft: Bool {
+        return draftDelegate != nil
     }
 
-    public var isGroupInviteLink: Bool {
-        switch linkType {
-        case .incomingMessageGroupInviteLink,
-             .outgoingMessageGroupInviteLink:
-            return true
-        default:
-            return false
+    // TODO: hasAsymmetricalRounding
+    public func configureForRendering(state: LinkPreviewState,
+                                      hasAsymmetricalRounding: Bool,
+                                      cellMeasurement: CVCellMeasurement) {
+        let adapter = self.adapter(forState: state)
+        adapter.configureForRendering(linkPreviewView: self,
+                                      hasAsymmetricalRounding: hasAsymmetricalRounding,
+                                      cellMeasurement: cellMeasurement)
+
+//        guard state.isLoaded() else {
+//            createDraftLoadingContents(state: state)
+//            return
+//        }
+//        if isDraft {
+//            createDraftContents(state: state)
+//        } else if state.isGroupInviteLink {
+//            createGroupLinkContents()
+//        } else {
+//            createSentContents()
+//        }
+//    }
+//
+//    private func createSentContents() {
+//        guard let state = state else {
+//            owsFailDebug("Invalid state")
+//            return
+//        }
+//        guard let conversationStyle = state.conversationStyle else {
+//            owsFailDebug("Missing conversationStyle.")
+//            return
+//        }
+//
+//        addBackgroundView(withBackgroundColor: Theme.isDarkThemeEnabled ? .ows_gray75 : .ows_gray02)
+//
+//        if let imageView = createImageView(state: state) {
+//            if Self.sentIsHero(state: state) {
+//                createHeroSentContents(state: state,
+//                                       conversationStyle: conversationStyle,
+//                                       imageView: imageView)
+//            } else if state.previewDescription()?.isEmpty == false,
+//                      state.title()?.isEmpty == false {
+//                createNonHeroWithDescriptionSentContents(state: state, imageView: imageView)
+//            } else {
+//                createNonHeroSentContents(state: state, imageView: imageView)
+//            }
+//        } else {
+//            createNonHeroSentContents(state: state, imageView: nil)
+//        }
+    }
+
+    private func adapter(forState state: LinkPreviewState) -> LinkPreviewViewAdapter {
+        if !state.isLoaded() {
+            return LinkPreviewViewAdapterDraftLoading(state: state)
+        } else if isDraft {
+            return LinkPreviewViewAdapterDraft(state: state)
+        } else if state.isGroupInviteLink {
+            return LinkPreviewViewAdapterGroupLink(state: state)
+        } else {
+            if state.hasLoadedImage {
+                if Self.sentIsHero(state: state) {
+                    return LinkPreviewViewAdapterSentHero(state: state)
+                } else if state.previewDescription()?.isEmpty == false,
+                          state.title()?.isEmpty == false {
+                    return LinkPreviewViewAdapterSentWithDescription(state: state)
+                } else {
+                    return LinkPreviewViewAdapterSent(state: state)
+                }
+            } else {
+                return LinkPreviewViewAdapterSent(state: state)
+            }
         }
     }
 
-    public var activityIndicatorStyle: UIActivityIndicatorView.Style {
-        switch linkType {
-        case .incomingMessageGroupInviteLink:
-            return .gray
-        case .outgoingMessageGroupInviteLink:
-            return .white
-        default:
-            return LinkPreviewView.defaultActivityIndicatorStyle
+    private func createGroupLinkContents() {
+        guard let state = state else {
+            owsFailDebug("Invalid state")
+            return
         }
-    }
-
-    public let conversationStyle: ConversationStyle? = nil
-}
 
-// MARK: -
-
-@objc
-public class LinkPreviewDraft: NSObject, LinkPreviewState {
-    let linkPreviewDraft: OWSLinkPreviewDraft
-
-    @objc
-    public required init(linkPreviewDraft: OWSLinkPreviewDraft) {
-        self.linkPreviewDraft = linkPreviewDraft
-    }
-
-    public func isLoaded() -> Bool {
-        return true
-    }
+        self.addBackgroundView(withBackgroundColor: Theme.secondaryBackgroundColor)
 
-    public func urlString() -> String? {
-        return linkPreviewDraft.urlString
-    }
+        self.layoutMargins = .zero
+        self.axis = .horizontal
+        self.isLayoutMarginsRelativeArrangement = true
+        self.layoutMargins = Self.sentNonHeroLayoutMargins
+        self.spacing = Self.sentNonHeroHSpacing
 
-    public func displayDomain() -> String? {
-        guard let displayDomain = linkPreviewDraft.displayDomain() else {
-            owsFailDebug("Missing display domain")
-            return nil
+        if let imageView = createImageView(state: state, rounding: .circular) {
+            imageView.autoSetDimensions(to: CGSize(square: Self.sentNonHeroImageSize))
+            imageView.contentMode = .scaleAspectFill
+            imageView.setContentHuggingHigh()
+            imageView.setCompressionResistanceHigh()
+            imageView.clipsToBounds = true
+            addArrangedSubview(imageView)
         }
-        return displayDomain
-    }
 
-    public func title() -> String? {
-        guard let value = linkPreviewDraft.title,
-            value.count > 0 else {
-                return nil
-        }
-        return value
-    }
+        let textStack = createGroupLinkTextStack(state: state)
+        addArrangedSubview(textStack)
 
-    public func imageState() -> LinkPreviewImageState {
-        if linkPreviewDraft.imageData != nil {
-            return .loaded
-        } else {
-            return .none
-        }
+        sentBodyView = self
     }
 
-    public func image() -> UIImage? {
-        assert(imageState() == .loaded)
+    private func createGroupLinkTextStack(state: LinkPreviewState) -> UIStackView {
+        let textStack = UIStackView()
+        textStack.axis = .vertical
+        textStack.spacing = Self.sentVSpacing
 
-        guard let imageData = linkPreviewDraft.imageData else {
-            return nil
-        }
-        guard let image = UIImage(data: imageData) else {
-            owsFailDebug("Could not load image: \(imageData.count)")
-            return nil
+        if let titleLabel = sentTitleLabel(state: state) {
+            textStack.addArrangedSubview(titleLabel)
         }
-        return image
-    }
-
-    public var imagePixelSize: CGSize {
-        guard let image = self.image() else {
-            return .zero
+        if let descriptionLabel = sentDescriptionLabel(state: state) {
+            textStack.addArrangedSubview(descriptionLabel)
         }
-        return image.pixelSize()
-    }
-
-    public func previewDescription() -> String? {
-        linkPreviewDraft.previewDescription
-    }
 
-    public func date() -> Date? {
-        linkPreviewDraft.date
-    }
-
-    public let isGroupInviteLink = false
-
-    public var activityIndicatorStyle: UIActivityIndicatorView.Style {
-        LinkPreviewView.defaultActivityIndicatorStyle
+        return textStack
     }
 
-    public let conversationStyle: ConversationStyle? = nil
-}
+    private static func sentHeroImageSize(state: LinkPreviewState,
+                                          conversationStyle: ConversationStyle) -> CGSize {
 
-// MARK: -
+        let imageHeightWidthRatio = (state.imagePixelSize.height / state.imagePixelSize.width)
+        let maxMessageWidth = conversationStyle.maxMessageWidth
 
-@objc
-public class LinkPreviewSent: NSObject, LinkPreviewState {
-    private let linkPreview: OWSLinkPreview
-    private let imageAttachment: TSAttachment?
+        let minImageHeight: CGFloat = maxMessageWidth * 0.5
+        let maxImageHeight: CGFloat = maxMessageWidth
+        let rawImageHeight = maxMessageWidth * imageHeightWidthRatio
 
-    private let _conversationStyle: ConversationStyle
-    public var conversationStyle: ConversationStyle? {
-        _conversationStyle
+        let normalizedHeight: CGFloat = min(maxImageHeight, max(minImageHeight, rawImageHeight))
+        return CGSizeCeil(CGSize(width: maxMessageWidth, height: normalizedHeight))
     }
 
-    @objc
-    public required init(linkPreview: OWSLinkPreview,
-                  imageAttachment: TSAttachment?,
-                  conversationStyle: ConversationStyle) {
-        self.linkPreview = linkPreview
-        self.imageAttachment = imageAttachment
-        _conversationStyle = conversationStyle
-    }
+    private func createHeroSentContents(state: LinkPreviewState,
+                                        conversationStyle: ConversationStyle,
+                                        imageView: UIImageView) {
+        self.layoutMargins = .zero
+        self.axis = .vertical
+        self.alignment = .fill
 
-    public func isLoaded() -> Bool {
-        return true
-    }
+        let heroImageSize = Self.sentHeroImageSize(state: state,
+                                                   conversationStyle: conversationStyle)
+        imageView.autoSetDimensions(to: heroImageSize)
+        imageView.contentMode = .scaleAspectFill
+        imageView.setContentHuggingHigh()
+        imageView.setCompressionResistanceHigh()
+        imageView.clipsToBounds = true
+        // TODO: Cropping, stroke.
+        addArrangedSubview(imageView)
 
-    public func urlString() -> String? {
-        guard let urlString = linkPreview.urlString else {
-            owsFailDebug("Missing url")
-            return nil
-        }
-        return urlString
-    }
+        let textStack = createSentTextStack(state: state)
+        textStack.isLayoutMarginsRelativeArrangement = true
+        textStack.layoutMargins = Self.sentHeroLayoutMargins
+        addArrangedSubview(textStack)
 
-    public func displayDomain() -> String? {
-        guard let displayDomain = linkPreview.displayDomain() else {
-            Logger.error("Missing display domain")
-            return nil
-        }
-        return displayDomain
+        heroImageView = imageView
+        sentBodyView = textStack
     }
 
-    public func title() -> String? {
-        guard let value = linkPreview.title?.filterForDisplay,
-            value.count > 0 else {
-                return nil
-        }
-        return value
-    }
+    private func createNonHeroWithDescriptionSentContents(state: LinkPreviewState, imageView: UIImageView?) {
+        self.axis = .vertical
+        self.isLayoutMarginsRelativeArrangement = true
+        self.layoutMargins = Self.sentNonHeroLayoutMargins
+        self.spacing = Self.sentVSpacing
+        self.alignment = .fill
 
-    public func imageState() -> LinkPreviewImageState {
-        guard linkPreview.imageAttachmentId != nil else {
-            return .none
-        }
-        guard let imageAttachment = imageAttachment else {
-            Logger.warn("Missing imageAttachment.")
-            return .none
-        }
-        guard let attachmentStream = imageAttachment as? TSAttachmentStream else {
-            return .loading
-        }
-        guard attachmentStream.isImage,
-            attachmentStream.isValidImage else {
-            return .invalid
-        }
-        return .loaded
-    }
+        let titleStack = UIStackView()
+        titleStack.isLayoutMarginsRelativeArrangement = true
+        titleStack.axis = .horizontal
+        titleStack.spacing = Self.sentNonHeroHSpacing
+        titleStack.layoutMargins = UIEdgeInsets(top: 0, left: 0, bottom: Self.sentVSpacing, right: 0)
+        addArrangedSubview(titleStack)
 
-    public func image() -> UIImage? {
-        assert(imageState() == .loaded)
+        if let imageView = imageView {
+            imageView.autoSetDimensions(to: CGSize(square: Self.sentNonHeroImageSize))
+            imageView.contentMode = .scaleAspectFill
+            imageView.setCompressionResistanceHigh()
+            imageView.clipsToBounds = true
+            // TODO: Cropping, stroke.
 
-        guard let attachmentStream = imageAttachment as? TSAttachmentStream else {
-            owsFailDebug("Could not load image.")
-            return nil
-        }
-        guard attachmentStream.isImage,
-            attachmentStream.isValidImage else {
-            return nil
-        }
-        guard let imageFilepath = attachmentStream.originalFilePath else {
-            owsFailDebug("Attachment is missing file path.")
-            return nil
-        }
+            let containerView = UIView()
+            containerView.addSubview(imageView)
+            containerView.autoSetDimension(.height, toSize: Self.sentNonHeroImageSize, relation: .greaterThanOrEqual)
 
-        guard NSData.ows_isValidImage(atPath: imageFilepath, mimeType: attachmentStream.contentType) else {
-            owsFailDebug("Invalid image.")
-            return nil
+            imageView.autoCenterInSuperview()
+            imageView.autoPinEdge(toSuperviewEdge: .leading)
+            imageView.autoPinEdge(toSuperviewEdge: .trailing)
+            titleStack.addArrangedSubview(containerView)
         }
 
-        let imageClass: UIImage.Type
-        if attachmentStream.contentType == OWSMimeTypeImageWebp {
-            imageClass = YYImage.self
+        if let titleLabel = sentTitleLabel(state: state) {
+            titleStack.addArrangedSubview(titleLabel)
         } else {
-            imageClass = UIImage.self
+            owsFailDebug("Text stack required")
         }
 
-        guard let image = imageClass.init(contentsOfFile: imageFilepath) else {
-            owsFailDebug("Could not load image: \(imageFilepath)")
-            return nil
+        if let descriptionLabel = sentDescriptionLabel(state: state) {
+            addArrangedSubview(descriptionLabel)
+        } else {
+            owsFailDebug("Description label required")
         }
 
-        return image
+        let domainLabel = sentDomainLabel(state: state)
+        addArrangedSubview(domainLabel)
+        sentBodyView = self
     }
 
-    @objc
-    public var imagePixelSize: CGSize {
-        guard let attachmentStream = imageAttachment as? TSAttachmentStream else {
-            return CGSize.zero
+    private func createNonHeroSentContents(state: LinkPreviewState,
+                                           imageView: UIImageView?) {
+        self.layoutMargins = .zero
+        self.axis = .horizontal
+        self.isLayoutMarginsRelativeArrangement = true
+        self.layoutMargins = Self.sentNonHeroLayoutMargins
+        self.spacing = Self.sentNonHeroHSpacing
+
+        if let imageView = imageView {
+            imageView.autoSetDimensions(to: CGSize(square: Self.sentNonHeroImageSize))
+            imageView.contentMode = .scaleAspectFill
+            imageView.setContentHuggingHigh()
+            imageView.setCompressionResistanceHigh()
+            imageView.clipsToBounds = true
+            // TODO: Cropping, stroke.
+            addArrangedSubview(imageView)
         }
-        return attachmentStream.imageSize()
-    }
 
-    public func previewDescription() -> String? {
-        linkPreview.previewDescription
-    }
+        let textStack = createSentTextStack(state: state)
+        addArrangedSubview(textStack)
 
-    public func date() -> Date? {
-        linkPreview.date
+        sentBodyView = self
     }
 
-    public let isGroupInviteLink = false
+    private func createSentTextStack(state: LinkPreviewState) -> UIStackView {
+        let textStack = UIStackView()
+        textStack.axis = .vertical
+        textStack.spacing = Self.sentVSpacing
+
+        if let titleLabel = sentTitleLabel(state: state) {
+            textStack.addArrangedSubview(titleLabel)
+        }
+        if let descriptionLabel = sentDescriptionLabel(state: state) {
+            textStack.addArrangedSubview(descriptionLabel)
+        }
+        let domainLabel = sentDomainLabel(state: state)
+        textStack.addArrangedSubview(domainLabel)
 
-    public var activityIndicatorStyle: UIActivityIndicatorView.Style {
-        LinkPreviewView.defaultActivityIndicatorStyle
+        return textStack
     }
-}
-
-// MARK: -
 
-@objc
-public protocol LinkPreviewViewDraftDelegate {
-    func linkPreviewCanCancel() -> Bool
-    func linkPreviewDidCancel()
-}
-
-// MARK: -
+    private static let sentTitleFontSizePoints: CGFloat = 17
+    private static let sentDomainFontSizePoints: CGFloat = 12
+    private static let sentVSpacing: CGFloat = 4
 
-private class LinkPreviewImageView: UIImageView {
-    fileprivate enum Rounding: UInt {
-        case standard
-        case asymmetrical
-        case circular
+    // The "sent message" mode has two submodes: "hero" and "non-hero".
+    private static let sentNonHeroHMargin: CGFloat = 12
+    private static let sentNonHeroVMargin: CGFloat = 12
+    private static var sentNonHeroLayoutMargins: UIEdgeInsets {
+        UIEdgeInsets(top: sentNonHeroVMargin,
+                     left: sentNonHeroHMargin,
+                     bottom: sentNonHeroVMargin,
+                     right: sentNonHeroHMargin)
     }
 
-    private let rounding: Rounding
-    fileprivate var isHero = false
-
-    // We only need to use a more complicated corner mask if we're
-    // drawing asymmetric corners. This is an exceptional case to match
-    // the input toolbar curve.
-    private let asymmetricCornerMask = CAShapeLayer()
+    private static let sentNonHeroImageSize: CGFloat = 64
+    private static let sentNonHeroHSpacing: CGFloat = 8
 
-    init(rounding: Rounding) {
-        self.rounding = rounding
-        super.init(frame: .zero)
+    private static let sentHeroHMargin: CGFloat = 12
+    private static let sentHeroVMargin: CGFloat = 12
+    private static var sentHeroLayoutMargins: UIEdgeInsets {
+        UIEdgeInsets(top: sentHeroVMargin,
+                     left: sentHeroHMargin,
+                     bottom: sentHeroVMargin,
+                     right: sentHeroHMargin)
+    }
 
-        if rounding == .asymmetrical {
-            layer.mask = asymmetricCornerMask
+    private static func sentIsHero(state: LinkPreviewState) -> Bool {
+        if isSticker(state: state) || state.isGroupInviteLink {
+            return false
+        }
+        guard let heroWidthPoints = state.conversationStyle?.maxMessageWidth else {
+            return false
         }
-    }
 
-    required init?(coder aDecoder: NSCoder) {
-        self.rounding = .standard
-        super.init(coder: aDecoder)
+        // On a 1x device, even tiny images like avatars can satisfy the max message width
+        // On a 3x device, achieving a 3x pixel match on an og:image is rare
+        // By fudging the required scaling a bit towards 2.0, we get more consistency at the
+        // cost of slightly blurrier images on 3x devices.
+        // These are totally made up numbers so feel free to adjust as necessary.
+        let heroScalingFactors: [CGFloat: CGFloat] = [
+            1.0: 2.0,
+            2.0: 2.0,
+            3.0: 2.3333
+        ]
+        let scalingFactor = heroScalingFactors[UIScreen.main.scale] ?? {
+            // Oh neat a new device! Might want to add it.
+            owsFailDebug("Unrecognized device scale")
+            return 2.0
+        }()
+        let minimumHeroWidth = heroWidthPoints * scalingFactor
+        let minimumHeroHeight = minimumHeroWidth * 0.33
+
+        let widthSatisfied = state.imagePixelSize.width >= minimumHeroWidth
+        let heightSatisfied = state.imagePixelSize.height >= minimumHeroHeight
+        return widthSatisfied && heightSatisfied
     }
 
-    override var bounds: CGRect {
-        didSet {
-            updateMaskLayer()
+    private static func isSticker(state: LinkPreviewState) -> Bool {
+        guard let urlString = state.urlString() else {
+            owsFailDebug("Link preview is missing url.")
+            return false
+        }
+        guard let url = URL(string: urlString) else {
+            owsFailDebug("Could not parse URL.")
+            return false
         }
+        return StickerPackInfo.isStickerPackShare(url)
     }
 
-    override var frame: CGRect {
-        didSet {
-            updateMaskLayer()
+    private static let sentTitleLineCount: Int = 2
+    private static let sentDescriptionLineCount: Int = 3
+
+    private func sentTitleLabel(state: LinkPreviewState) -> UILabel? {
+        guard let config = Self.sentTitleLabelConfig(state: state) else {
+            return nil
         }
+        let label = CVLabel()
+        config.applyForRendering(label: label)
+        return label
     }
 
-    override var center: CGPoint {
-        didSet {
-            updateMaskLayer()
+    private static func sentTitleLabelConfig(state: LinkPreviewState) -> CVLabelConfig? {
+        guard let text = state.title() else {
+            return nil
         }
+        return CVLabelConfig(text: text,
+                             font: UIFont.ows_dynamicTypeSubheadline.ows_semibold,
+                             textColor: Theme.primaryTextColor,
+                             numberOfLines: sentTitleLineCount,
+                             lineBreakMode: .byTruncatingTail)
     }
 
-    private func updateMaskLayer() {
-        let layerBounds = self.bounds
-        let bigRounding: CGFloat = 14
-        let smallRounding: CGFloat = 6
-
-        switch rounding {
-        case .standard:
-            layer.cornerRadius = smallRounding
-            layer.maskedCorners = isHero ? .top : .all
-        case .circular:
-            layer.cornerRadius = bounds.size.smallerAxis / 2
-            layer.maskedCorners = .all
-        case .asymmetrical:
-            // This uses a more expensive layer mask to clip corners
-            // with different radii.
-            // This should only be used in the input toolbar so perf is
-            // less of a concern here.
-            owsAssertDebug(!isHero, "Link preview drafts never use hero images")
+    private func sentDescriptionLabel(state: LinkPreviewState) -> UILabel? {
+        guard let config = Self.sentDescriptionLabelConfig(state: state) else {
+            return nil
+        }
+        let label = CVLabel()
+        config.applyForRendering(label: label)
+        return label
+   }
 
-            let upperLeft = CGPoint(x: 0, y: 0)
-            let upperRight = CGPoint(x: layerBounds.size.width, y: 0)
-            let lowerRight = CGPoint(x: layerBounds.size.width, y: layerBounds.size.height)
-            let lowerLeft = CGPoint(x: 0, y: layerBounds.size.height)
+    private static func sentDescriptionLabelConfig(state: LinkPreviewState) -> CVLabelConfig? {
+        guard let text = state.previewDescription() else { return nil }
+        return CVLabelConfig(text: text,
+                             font: UIFont.ows_dynamicTypeSubheadline,
+                             textColor: Theme.primaryTextColor,
+                             numberOfLines: sentDescriptionLineCount,
+                             lineBreakMode: .byTruncatingTail)
+    }
 
-            let upperLeftRounding: CGFloat = CurrentAppContext().isRTL ? smallRounding : bigRounding
-            let upperRightRounding: CGFloat = CurrentAppContext().isRTL ? bigRounding : smallRounding
-            let lowerRightRounding = smallRounding
-            let lowerLeftRounding = smallRounding
+    private func sentDomainLabel(state: LinkPreviewState) -> UILabel {
+        let label = CVLabel()
+        Self.sentDomainLabelConfig(state: state).applyForRendering(label: label)
+        return label
+    }
 
-            let path = UIBezierPath()
+    private static func sentDomainLabelConfig(state: LinkPreviewState) -> CVLabelConfig {
+        var labelText: String
+        if let displayDomain = state.displayDomain(),
+           displayDomain.count > 0 {
+            labelText = displayDomain.lowercased()
+        } else {
+            labelText = NSLocalizedString("LINK_PREVIEW_UNKNOWN_DOMAIN", comment: "Label for link previews with an unknown host.").uppercased()
+        }
+        if let date = state.date() {
+            labelText.append("  \(Self.dateFormatter.string(from: date))")
+        }
+        return CVLabelConfig(text: labelText,
+                             font: UIFont.ows_dynamicTypeCaption1,
+                             textColor: Theme.secondaryTextAndIconColor)
+    }
 
-            // It's sufficient to "draw" the rounded corners and not the edges that connect them.
-            path.addArc(withCenter: upperLeft.offsetBy(dx: +upperLeftRounding).offsetBy(dy: +upperLeftRounding),
-                        radius: upperLeftRounding,
-                        startAngle: CGFloat.pi * 1.0,
-                        endAngle: CGFloat.pi * 1.5,
-                        clockwise: true)
+    private func createImageView(state: LinkPreviewState,
+                                 rounding roundingParam: LinkPreviewImageView.Rounding? = nil) -> UIImageView? {
+        guard state.isLoaded() else {
+            owsFailDebug("State not loaded.")
+            return nil
+        }
 
-            path.addArc(withCenter: upperRight.offsetBy(dx: -upperRightRounding).offsetBy(dy: +upperRightRounding),
-                        radius: upperRightRounding,
-                        startAngle: CGFloat.pi * 1.5,
-                        endAngle: CGFloat.pi * 0.0,
-                        clockwise: true)
+        guard state.imageState() == .loaded else {
+            return nil
+        }
+        guard let image = state.image() else {
+            owsFailDebug("Could not load image.")
+            return nil
+        }
+        let imageView = LinkPreviewImageView(rounding: roundingParam ?? .standard)
+        imageView.image = image
+        imageView.isHero = Self.sentIsHero(state: state)
+        return imageView
+    }
 
-            path.addArc(withCenter: lowerRight.offsetBy(dx: -lowerRightRounding).offsetBy(dy: -lowerRightRounding),
-                        radius: lowerRightRounding,
-                        startAngle: CGFloat.pi * 0.0,
-                        endAngle: CGFloat.pi * 0.5,
-                        clockwise: true)
+    static var defaultActivityIndicatorStyle: UIActivityIndicatorView.Style {
+        Theme.isDarkThemeEnabled
+        ? .white
+        : .gray
+    }
 
-            path.addArc(withCenter: lowerLeft.offsetBy(dx: +lowerLeftRounding).offsetBy(dy: -lowerLeftRounding),
-                        radius: lowerLeftRounding,
-                        startAngle: CGFloat.pi * 0.5,
-                        endAngle: CGFloat.pi * 1.0,
-                        clockwise: true)
+    // MARK: Events
 
-            asymmetricCornerMask.path = path.cgPath
+    @objc func wasTapped(sender: UIGestureRecognizer) {
+        guard sender.state == .recognized else {
+            return
+        }
+        if let cancelButton = cancelButton {
+            // Permissive hot area to make it very easy to cancel the link preview.
+            if cancelButton.containsGestureLocation(sender, hotAreaAdjustment: 20) {
+                self.draftDelegate?.linkPreviewDidCancel()
+                return
+            }
         }
     }
-}
-
-// MARK: -
-
-@objc
-public class LinkPreviewView: UIStackView {
-    private weak var draftDelegate: LinkPreviewViewDraftDelegate?
 
-    static let dateFormatter: DateFormatter = {
-        let formatter = DateFormatter()
-        formatter.dateStyle = .medium
-        formatter.timeStyle = .none
-        return formatter
-    }()
+    // MARK: Measurement
 
     @objc
-    public var state: LinkPreviewState? {
-        didSet {
-            AssertIsOnMainThread()
-            updateContents()
-        }
+    public func measure(maxWidth: CGFloat,
+                        measurementBuilder: CVCellMeasurement.Builder,
+                        state: LinkPreviewState) -> CGSize {
+        let adapter = self.adapter(forState: state)
+        return adapter.measure(maxWidth: maxWidth,
+                               measurementBuilder: measurementBuilder,
+                               state: state)
     }
 
     @objc
-    public var hasAsymmetricalRounding: Bool = false {
-        didSet {
-            AssertIsOnMainThread()
-            owsAssertDebug(isDraft)
-
-            if hasAsymmetricalRounding != oldValue {
-                updateContents()
-            }
+    public static func measure(withState state: LinkPreviewState) -> CGSize {
+        if let sentState = state as? LinkPreviewSent {
+            return self.measure(withSentState: sentState)
+        } else if let groupLinkState = state as? LinkPreviewGroupLink {
+            return self.measure(withGroupLinkState: groupLinkState)
+        } else if let loadingState = state as? LinkPreviewLoading {
+            return self.measure(withLoadingState: loadingState)
+        } else {
+            owsFailDebug("Invalid state.")
+            return .zero
         }
     }
 
-    @available(*, unavailable, message: "use other constructor instead.")
-    required init(coder aDecoder: NSCoder) {
-        notImplemented()
-    }
-
-    @available(*, unavailable, message: "use other constructor instead.")
-    override init(frame: CGRect) {
-        notImplemented()
+    @objc
+    public static func measure(withLoadingState state: LinkPreviewLoading) -> CGSize {
+        let size = Self.draftHeight + Self.draftMarginTop
+        return CGSize(width: size, height: size)
     }
 
-    private var cancelButton: UIButton?
-    private weak var heroImageView: UIView?
-    private weak var sentBodyView: UIView?
-    private var layoutConstraints = [NSLayoutConstraint]()
-
     @objc
-    public init(draftDelegate: LinkPreviewViewDraftDelegate?) {
-        self.draftDelegate = draftDelegate
-
-        super.init(frame: .zero)
+    public static func measure(withGroupLinkState state: LinkPreviewGroupLink) -> CGSize {
 
-        if let draftDelegate = draftDelegate,
-            draftDelegate.linkPreviewCanCancel() {
-            self.isUserInteractionEnabled = true
-            self.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(wasTapped)))
+        guard let conversationStyle = state.conversationStyle else {
+            owsFailDebug("Missing conversationStyle.")
+            return .zero
         }
-    }
 
-    private var isDraft: Bool {
-        return draftDelegate != nil
-    }
+        let hasImage = state.imageState() != .none
 
-    private func resetContents() {
-        for subview in subviews {
-            subview.removeFromSuperview()
-        }
-        self.axis = .horizontal
-        self.alignment = .center
-        self.distribution = .fill
-        self.spacing = 0
-        self.isLayoutMarginsRelativeArrangement = false
-        self.layoutMargins = .zero
+        let maxMessageWidth = conversationStyle.maxMessageWidth
 
-        cancelButton = nil
-        heroImageView = nil
-        sentBodyView = nil
+        var maxTextWidth = maxMessageWidth - 2 * sentNonHeroHMargin
+        if hasImage {
+            maxTextWidth -= (sentNonHeroImageSize + sentNonHeroHSpacing)
+        }
+        let textStackSize = sentTextStackSize(state: state, maxWidth: maxTextWidth, ignoreDomain: true)
 
-        NSLayoutConstraint.deactivate(layoutConstraints)
-        layoutConstraints = []
-    }
+        var result = textStackSize
 
-    private func updateContents() {
-        resetContents()
+        result.width += sentNonHeroImageSize + sentNonHeroHSpacing
+        result.height = max(result.height, sentNonHeroImageSize)
 
-        guard let state = state else {
-            return
-        }
+        result.width += 2 * sentNonHeroHMargin
+        result.height += 2 * sentNonHeroVMargin
 
-        guard state.isLoaded() else {
-            createDraftLoadingContents(state: state)
-            return
-        }
-        if isDraft {
-            createDraftContents(state: state)
-        } else if state.isGroupInviteLink {
-            createGroupLinkContents()
-        } else {
-            createSentContents()
-        }
+        return CGSizeCeil(result)
     }
 
-    private func createSentContents() {
-        guard let state = state else {
-            owsFailDebug("Invalid state")
-            return
-        }
+    @objc
+    public static func measure(withSentState state: LinkPreviewState) -> CGSize {
+
         guard let conversationStyle = state.conversationStyle else {
             owsFailDebug("Missing conversationStyle.")
-            return
+            return .zero
         }
 
-        addBackgroundView(withBackgroundColor: Theme.isDarkThemeEnabled ? .ows_gray75 : .ows_gray02)
-
-        if let imageView = createImageView(state: state) {
-            if Self.sentIsHero(state: state) {
-                createHeroSentContents(state: state,
-                                       conversationStyle: conversationStyle,
-                                       imageView: imageView)
+        switch state.imageState() {
+        case .loaded:
+            if sentIsHero(state: state) {
+                return measureSentHero(state: state, conversationStyle: conversationStyle)
             } else if state.previewDescription()?.isEmpty == false,
                 state.title()?.isEmpty == false {
-                createNonHeroWithDescriptionSentContents(state: state, imageView: imageView)
+                return measureSentNonHeroWithDescription(state: state, conversationStyle: conversationStyle)
             } else {
-                createNonHeroSentContents(state: state, imageView: imageView)
+                return measureSentNonHero(state: state, conversationStyle: conversationStyle, hasImage: true)
             }
-        } else {
-            createNonHeroSentContents(state: state, imageView: nil)
+        default:
+            return measureSentNonHero(state: state, conversationStyle: conversationStyle, hasImage: false)
         }
     }
 
-    private func createGroupLinkContents() {
-        guard let state = state else {
-            owsFailDebug("Invalid state")
-            return
-        }
-
-        self.addBackgroundView(withBackgroundColor: Theme.secondaryBackgroundColor)
-
-        self.layoutMargins = .zero
-        self.axis = .horizontal
-        self.isLayoutMarginsRelativeArrangement = true
-        self.layoutMargins = Self.sentNonHeroLayoutMargins
-        self.spacing = Self.sentNonHeroHSpacing
-
-        if let imageView = createImageView(state: state, rounding: .circular) {
-            imageView.autoSetDimensions(to: CGSize(square: Self.sentNonHeroImageSize))
-            imageView.contentMode = .scaleAspectFill
-            imageView.setContentHuggingHigh()
-            imageView.setCompressionResistanceHigh()
-            imageView.clipsToBounds = true
-            addArrangedSubview(imageView)
-        }
-
-        let textStack = createGroupLinkTextStack(state: state)
-        addArrangedSubview(textStack)
-
-        sentBodyView = self
-    }
+    private static func measureSentHero(state: LinkPreviewState,
+                                 conversationStyle: ConversationStyle) -> CGSize {
+        let maxMessageWidth = conversationStyle.maxMessageWidth
+        var messageHeight: CGFloat  = 0
 
-    private func createGroupLinkTextStack(state: LinkPreviewState) -> UIStackView {
-        let textStack = UIStackView()
-        textStack.axis = .vertical
-        textStack.spacing = Self.sentVSpacing
+        let heroImageSize = sentHeroImageSize(state: state, conversationStyle: conversationStyle)
+        messageHeight += heroImageSize.height
 
-        if let titleLabel = sentTitleLabel(state: state) {
-            textStack.addArrangedSubview(titleLabel)
-        }
-        if let descriptionLabel = sentDescriptionLabel(state: state) {
-            textStack.addArrangedSubview(descriptionLabel)
-        }
+        let textStackSize = sentTextStackSize(state: state,
+                                              maxWidth: maxMessageWidth - 2 * sentHeroHMargin)
+        messageHeight += textStackSize.height + 2 * sentHeroVMargin
 
-        return textStack
+        return CGSizeCeil(CGSize(width: maxMessageWidth, height: messageHeight))
     }
 
-    private static func sentHeroImageSize(state: LinkPreviewState,
-                                          conversationStyle: ConversationStyle) -> CGSize {
-
-        let imageHeightWidthRatio = (state.imagePixelSize.height / state.imagePixelSize.width)
+    private static func measureSentNonHeroWithDescription(state: LinkPreviewState,
+                                                   conversationStyle: ConversationStyle) -> CGSize {
         let maxMessageWidth = conversationStyle.maxMessageWidth
 
-        let minImageHeight: CGFloat = maxMessageWidth * 0.5
-        let maxImageHeight: CGFloat = maxMessageWidth
-        let rawImageHeight = maxMessageWidth * imageHeightWidthRatio
+        let bottomMaxTextWidth = maxMessageWidth - 2 * sentNonHeroHMargin
+        let titleMaxTextWidth = bottomMaxTextWidth - (sentNonHeroImageSize + sentNonHeroHSpacing)
 
-        let normalizedHeight: CGFloat = min(maxImageHeight, max(minImageHeight, rawImageHeight))
-        return CGSizeCeil(CGSize(width: maxMessageWidth, height: normalizedHeight))
-    }
+        let titleLabelSize = sentTitleLabelConfig(state: state)?.measure(maxWidth: titleMaxTextWidth) ?? .zero
+        let descriptionLabelSize = sentDescriptionLabelConfig(state: state)?.measure(maxWidth: bottomMaxTextWidth) ?? .zero
+        let domainLabelSize = sentDomainLabelConfig(state: state).measure(maxWidth: bottomMaxTextWidth)
 
-    private func createHeroSentContents(state: LinkPreviewState,
-                                        conversationStyle: ConversationStyle,
-                                        imageView: UIImageView) {
-        self.layoutMargins = .zero
-        self.axis = .vertical
-        self.alignment = .fill
+        let bindingTitleHeight = max(titleLabelSize.height, sentNonHeroImageSize)
 
-        let heroImageSize = Self.sentHeroImageSize(state: state,
-                                                   conversationStyle: conversationStyle)
-        imageView.autoSetDimensions(to: heroImageSize)
-        imageView.contentMode = .scaleAspectFill
-        imageView.setContentHuggingHigh()
-        imageView.setCompressionResistanceHigh()
-        imageView.clipsToBounds = true
-        // TODO: Cropping, stroke.
-        addArrangedSubview(imageView)
+        var resultSize = CGSize.zero
+        resultSize.height += sentNonHeroVMargin
+        resultSize.height += bindingTitleHeight
+        resultSize.height += sentVSpacing * 2
+        resultSize.height += descriptionLabelSize.height
+        resultSize.height += sentVSpacing
+        resultSize.height += domainLabelSize.height
+        resultSize.height += sentNonHeroVMargin
 
-        let textStack = createSentTextStack(state: state)
-        textStack.isLayoutMarginsRelativeArrangement = true
-        textStack.layoutMargins = Self.sentHeroLayoutMargins
-        addArrangedSubview(textStack)
+        let titleStackWidth = titleLabelSize.width + sentNonHeroHSpacing + sentNonHeroImageSize
+        resultSize.width = [titleStackWidth, descriptionLabelSize.width, domainLabelSize.width].max() ?? 0
+        resultSize.width += (sentNonHeroHMargin * 2)
 
-        heroImageView = imageView
-        sentBodyView = textStack
+        return CGSizeCeil(resultSize)
     }
 
-    private func createNonHeroWithDescriptionSentContents(state: LinkPreviewState, imageView: UIImageView?) {
-        self.axis = .vertical
-        self.isLayoutMarginsRelativeArrangement = true
-        self.layoutMargins = Self.sentNonHeroLayoutMargins
-        self.spacing = Self.sentVSpacing
-        self.alignment = .fill
-
-        let titleStack = UIStackView()
-        titleStack.isLayoutMarginsRelativeArrangement = true
-        titleStack.axis = .horizontal
-        titleStack.spacing = Self.sentNonHeroHSpacing
-        titleStack.layoutMargins = UIEdgeInsets(top: 0, left: 0, bottom: Self.sentVSpacing, right: 0)
-        addArrangedSubview(titleStack)
-
-        if let imageView = imageView {
-            imageView.autoSetDimensions(to: CGSize(square: Self.sentNonHeroImageSize))
-            imageView.contentMode = .scaleAspectFill
-            imageView.setCompressionResistanceHigh()
-            imageView.clipsToBounds = true
-            // TODO: Cropping, stroke.
-
-            let containerView = UIView()
-            containerView.addSubview(imageView)
-            containerView.autoSetDimension(.height, toSize: Self.sentNonHeroImageSize, relation: .greaterThanOrEqual)
-
-            imageView.autoCenterInSuperview()
-            imageView.autoPinEdge(toSuperviewEdge: .leading)
-            imageView.autoPinEdge(toSuperviewEdge: .trailing)
-            titleStack.addArrangedSubview(containerView)
-        }
-
-        if let titleLabel = sentTitleLabel(state: state) {
-            titleStack.addArrangedSubview(titleLabel)
-        } else {
-            owsFailDebug("Text stack required")
-        }
+    private static func measureSentNonHero(state: LinkPreviewState,
+                                    conversationStyle: ConversationStyle,
+                                    hasImage: Bool) -> CGSize {
+        let maxMessageWidth = conversationStyle.maxMessageWidth
 
-        if let descriptionLabel = sentDescriptionLabel(state: state) {
-            addArrangedSubview(descriptionLabel)
-        } else {
-            owsFailDebug("Description label required")
+        var maxTextWidth = maxMessageWidth - 2 * sentNonHeroHMargin
+        if hasImage {
+            maxTextWidth -= (sentNonHeroImageSize + sentNonHeroHSpacing)
         }
+        let textStackSize = sentTextStackSize(state: state, maxWidth: maxTextWidth)
 
-        let domainLabel = sentDomainLabel(state: state)
-        addArrangedSubview(domainLabel)
-        sentBodyView = self
-    }
-
-    private func createNonHeroSentContents(state: LinkPreviewState,
-                                           imageView: UIImageView?) {
-        self.layoutMargins = .zero
-        self.axis = .horizontal
-        self.isLayoutMarginsRelativeArrangement = true
-        self.layoutMargins = Self.sentNonHeroLayoutMargins
-        self.spacing = Self.sentNonHeroHSpacing
-
-        if let imageView = imageView {
-            imageView.autoSetDimensions(to: CGSize(square: Self.sentNonHeroImageSize))
-            imageView.contentMode = .scaleAspectFill
-            imageView.setContentHuggingHigh()
-            imageView.setCompressionResistanceHigh()
-            imageView.clipsToBounds = true
-            // TODO: Cropping, stroke.
-            addArrangedSubview(imageView)
+        var result = textStackSize
+
+        if hasImage {
+            result.width += sentNonHeroImageSize + sentNonHeroHSpacing
+            result.height = max(result.height, sentNonHeroImageSize)
         }
 
-        let textStack = createSentTextStack(state: state)
-        addArrangedSubview(textStack)
+        result.width += 2 * sentNonHeroHMargin
+        result.height += 2 * sentNonHeroVMargin
 
-        sentBodyView = self
+        return CGSizeCeil(result)
     }
 
-    private func createSentTextStack(state: LinkPreviewState) -> UIStackView {
-        let textStack = UIStackView()
-        textStack.axis = .vertical
-        textStack.spacing = Self.sentVSpacing
+    private static func sentLabelSize(label: UILabel, maxWidth: CGFloat) -> CGSize {
+        CGSizeCeil(label.sizeThatFits(CGSize(width: maxWidth, height: CGFloat.greatestFiniteMagnitude)))
+    }
 
-        if let titleLabel = sentTitleLabel(state: state) {
-            textStack.addArrangedSubview(titleLabel)
+    private static func sentTextStackSize(state: LinkPreviewState, maxWidth: CGFloat, ignoreDomain: Bool = false) -> CGSize {
+
+        var labelSizes = [CGSize]()
+
+        if !ignoreDomain {
+            let config = sentDomainLabelConfig(state: state)
+            let domainLabelSize = config.measure(maxWidth: maxWidth)
+            labelSizes.append(domainLabelSize)
         }
-        if let descriptionLabel = sentDescriptionLabel(state: state) {
-            textStack.addArrangedSubview(descriptionLabel)
+        if let config = sentTitleLabelConfig(state: state) {
+            let titleLabelSize = config.measure(maxWidth: maxWidth)
+            labelSizes.append(titleLabelSize)
+        }
+        if let config = sentDescriptionLabelConfig(state: state) {
+            let descriptionLabelSize = config.measure(maxWidth: maxWidth)
+            labelSizes.append(descriptionLabelSize)
         }
-        let domainLabel = sentDomainLabel(state: state)
-        textStack.addArrangedSubview(domainLabel)
 
-        return textStack
+        return measureTextStack(labelSizes: labelSizes)
     }
 
-    private static let sentTitleFontSizePoints: CGFloat = 17
-    private static let sentDomainFontSizePoints: CGFloat = 12
-    private static let sentVSpacing: CGFloat = 4
+    private static func measureTextStack(labelSizes: [CGSize]) -> CGSize {
+        let width = labelSizes.map { $0.width }.reduce(0, max)
+        let height = labelSizes.map { $0.height }.reduce(0, +) + CGFloat(labelSizes.count - 1) * sentVSpacing
+        return CGSize(width: width, height: height)
+    }
 
-    // The "sent message" mode has two submodes: "hero" and "non-hero".
-    private static let sentNonHeroHMargin: CGFloat = 12
-    private static let sentNonHeroVMargin: CGFloat = 12
-    private static var sentNonHeroLayoutMargins: UIEdgeInsets {
-        UIEdgeInsets(top: sentNonHeroVMargin,
-                     left: sentNonHeroHMargin,
-                     bottom: sentNonHeroVMargin,
-                     right: sentNonHeroHMargin)
+    @objc
+    fileprivate func didTapCancel() {
+        draftDelegate?.linkPreviewDidCancel()
     }
 
-    private static let sentNonHeroImageSize: CGFloat = 64
-    private static let sentNonHeroHSpacing: CGFloat = 8
+    public override func reset() {
+        super.reset()
 
-    private static let sentHeroHMargin: CGFloat = 12
-    private static let sentHeroVMargin: CGFloat = 12
-    private static var sentHeroLayoutMargins: UIEdgeInsets {
-        UIEdgeInsets(top: sentHeroVMargin,
-                     left: sentHeroHMargin,
-                     bottom: sentHeroVMargin,
-                     right: sentHeroHMargin)
+        rightStack.reset()
+        textStack.reset()
+
+        titleLabel.text = nil
+        descriptionLabel.text = nil
+        displayDomainLabel.text = nil
+
+//        self.axis = .horizontal
+//        self.alignment = .center
+//        self.distribution = .fill
+//        self.spacing = 0
+//        self.isLayoutMarginsRelativeArrangement = false
+//        self.layoutMargins = .zero
+//
+//        cancelButton = nil
+//        heroImageView = nil
+//        sentBodyView = nil
     }
 
-    private static func sentIsHero(state: LinkPreviewState) -> Bool {
-        if isSticker(state: state) || state.isGroupInviteLink {
-            return false
-        }
-        guard let heroWidthPoints = state.conversationStyle?.maxMessageWidth else {
-            return false
-        }
+    fileprivate static let measurementKey_rootStack = "LinkPreviewView.measurementKey_rootStack"
+    fileprivate static let measurementKey_rightStack = "LinkPreviewView.measurementKey_rightStack"
+    fileprivate static let measurementKey_textStack = "LinkPreviewView.measurementKey_textStack"
+}
 
-        // On a 1x device, even tiny images like avatars can satisfy the max message width
-        // On a 3x device, achieving a 3x pixel match on an og:image is rare
-        // By fudging the required scaling a bit towards 2.0, we get more consistency at the
-        // cost of slightly blurrier images on 3x devices.
-        // These are totally made up numbers so feel free to adjust as necessary.
-        let heroScalingFactors: [CGFloat: CGFloat] = [
-            1.0: 2.0,
-            2.0: 2.0,
-            3.0: 2.3333
-        ]
-        let scalingFactor = heroScalingFactors[UIScreen.main.scale] ?? {
-            // Oh neat a new device! Might want to add it.
-            owsFailDebug("Unrecognized device scale")
-            return 2.0
-        }()
-        let minimumHeroWidth = heroWidthPoints * scalingFactor
-        let minimumHeroHeight = minimumHeroWidth * 0.33
+// MARK: -
 
-        let widthSatisfied = state.imagePixelSize.width >= minimumHeroWidth
-        let heightSatisfied = state.imagePixelSize.height >= minimumHeroHeight
-        return widthSatisfied && heightSatisfied
+private protocol LinkPreviewViewAdapter {
+    func configureForRendering(linkPreviewView: LinkPreviewView,
+                               hasAsymmetricalRounding: Bool,
+                               cellMeasurement: CVCellMeasurement)
+
+    func measure(maxWidth: CGFloat,
+                 measurementBuilder: CVCellMeasurement.Builder,
+                 state: LinkPreviewState) -> CGSize
+}
+
+// MARK: -
+
+private class LinkPreviewViewAdapterDraft: LinkPreviewViewAdapter {
+
+    static let draftHeight: CGFloat = 72
+    static let draftMarginTop: CGFloat = 6
+    var imageSize: CGFloat { Self.draftHeight }
+    var hasImage: Bool { state.hasLoadedImage }
+    let cancelSize: CGFloat = 20
+
+    let state: LinkPreviewState
+
+    init(state: LinkPreviewState) {
+        self.state = state
     }
 
-    private static func isSticker(state: LinkPreviewState) -> Bool {
-        guard let urlString = state.urlString() else {
-            owsFailDebug("Link preview is missing url.")
-            return false
-        }
-        guard let url = URL(string: urlString) else {
-            owsFailDebug("Could not parse URL.")
-            return false
-        }
-        return StickerPackInfo.isStickerPackShare(url)
+    var rootStackConfig: ManualStackView.Config {
+        let hMarginLeading: CGFloat = hasImage ? 6 : 12
+        let hMarginTrailing: CGFloat = 12
+        let layoutMargins = UIEdgeInsets(top: Self.draftMarginTop,
+                                         leading: hMarginLeading,
+                                         bottom: 0,
+                                         trailing: hMarginTrailing)
+        return ManualStackView.Config(axis: .horizontal,
+                                      alignment: .fill,
+                                      spacing: 8,
+                                      layoutMargins: layoutMargins)
     }
 
-    private static let sentTitleLineCount: Int = 2
-    private static let sentDescriptionLineCount: Int = 3
+    var rightStackConfig: ManualStackView.Config {
+        return ManualStackView.Config(axis: .horizontal,
+                                      alignment: .fill,
+                                      spacing: 8,
+                                      layoutMargins: .zero)
+    }
 
-    private func sentTitleLabel(state: LinkPreviewState) -> UILabel? {
-        guard let config = Self.sentTitleLabelConfig(state: state) else {
-            return nil
-        }
-        let label = UILabel()
-        config.applyForRendering(label: label)
-        return label
+    var textStackConfig: ManualStackView.Config {
+        return ManualStackView.Config(axis: .vertical,
+                                      alignment: .leading,
+                                      spacing: 2,
+                                      layoutMargins: .zero)
     }
 
-    private static func sentTitleLabelConfig(state: LinkPreviewState) -> CVLabelConfig? {
-        guard let text = state.title() else {
+    var titleLabelConfig: CVLabelConfig? {
+        guard let text = state.title()?.nilIfEmpty else {
             return nil
         }
         return CVLabelConfig(text: text,
-                             font: UIFont.ows_dynamicTypeSubheadline.ows_semibold,
-                             textColor: Theme.primaryTextColor,
-                             numberOfLines: sentTitleLineCount,
-                             lineBreakMode: .byTruncatingTail)
+                             font: .ows_dynamicTypeBody,
+                             textColor: Theme.primaryTextColor)
     }
 
-    private func sentDescriptionLabel(state: LinkPreviewState) -> UILabel? {
-        guard let config = Self.sentDescriptionLabelConfig(state: state) else {
+    var descriptionLabelConfig: CVLabelConfig? {
+        guard let text = state.previewDescription()?.nilIfEmpty else {
             return nil
         }
-        let label = UILabel()
-        config.applyForRendering(label: label)
-        return label
-   }
-
-    private static func sentDescriptionLabelConfig(state: LinkPreviewState) -> CVLabelConfig? {
-        guard let text = state.previewDescription() else { return nil }
         return CVLabelConfig(text: text,
-                             font: UIFont.ows_dynamicTypeSubheadline,
-                             textColor: Theme.primaryTextColor,
-                             numberOfLines: sentDescriptionLineCount,
-                             lineBreakMode: .byTruncatingTail)
-    }
-
-    private func sentDomainLabel(state: LinkPreviewState) -> UILabel {
-        let label = UILabel()
-        Self.sentDomainLabelConfig(state: state).applyForRendering(label: label)
-        return label
+                             font: .ows_dynamicTypeSubheadline,
+                             textColor: Theme.isDarkThemeEnabled ? .ows_gray05 : .ows_gray90)
     }
 
-    private static func sentDomainLabelConfig(state: LinkPreviewState) -> CVLabelConfig {
-        var labelText: String
-        if let displayDomain = state.displayDomain(),
-           displayDomain.count > 0 {
-            labelText = displayDomain.lowercased()
-        } else {
-            labelText = NSLocalizedString("LINK_PREVIEW_UNKNOWN_DOMAIN", comment: "Label for link previews with an unknown host.").uppercased()
+    var displayDomainLabelConfig: CVLabelConfig? {
+        guard let displayDomain = state.displayDomain()?.nilIfEmpty else {
+            return nil
         }
+        var text = displayDomain.lowercased()
         if let date = state.date() {
-            labelText.append("  \(Self.dateFormatter.string(from: date))")
+            text.append("  \(LinkPreviewView.dateFormatter.string(from: date))")
         }
-        return CVLabelConfig(text: labelText,
-                             font: UIFont.ows_dynamicTypeCaption1,
+        return CVLabelConfig(text: text,
+                             font: .ows_dynamicTypeCaption1,
                              textColor: Theme.secondaryTextAndIconColor)
     }
 
-    private static let draftHeight: CGFloat = 72
-    private static let draftMarginTop: CGFloat = 6
-
-    private func createDraftContents(state: LinkPreviewState) {
-        self.axis = .horizontal
-        self.alignment = .fill
-        self.distribution = .fill
-        self.spacing = 8
-        self.isLayoutMarginsRelativeArrangement = true
+    func configureForRendering(linkPreviewView: LinkPreviewView,
+                               hasAsymmetricalRounding: Bool,
+                               cellMeasurement: CVCellMeasurement) {
 
-        self.layoutConstraints.append(self.autoSetDimension(.height, toSize: Self.draftHeight + Self.draftMarginTop))
+        var rootStackSubviews = [UIView]()
+        var rightStackSubviews = [UIView]()
 
         // Image
 
-        let draftImageView = createDraftImageView(state: state)
-        if let imageView = draftImageView {
-            imageView.contentMode = .scaleAspectFill
-            imageView.autoPinToSquareAspectRatio()
-            let imageSize = Self.draftHeight
-            imageView.autoSetDimensions(to: CGSize(square: imageSize))
-            imageView.setContentHuggingHigh()
-            imageView.setCompressionResistanceHigh()
-            imageView.clipsToBounds = true
-            addArrangedSubview(imageView)
+        if hasImage {
+            if let imageView = buildDraftImageView(hasAsymmetricalRounding: hasAsymmetricalRounding) {
+                imageView.contentMode = .scaleAspectFill
+                imageView.clipsToBounds = true
+                rootStackSubviews.append(imageView)
+            } else {
+                owsFailDebug("Could not load image.")
+                let imageView = UIView.transparentSpacer()
+                rootStackSubviews.append(imageView)
+            }
         }
 
-        let hasImage = draftImageView != nil
-        let hMarginLeading: CGFloat = hasImage ? 6 : 12
-        let hMarginTrailing: CGFloat = 12
-        self.layoutMargins = UIEdgeInsets(top: Self.draftMarginTop,
-                                          leading: hMarginLeading,
-                                          bottom: 0,
-                                          trailing: hMarginTrailing)
-
-        // Right
+        // Text
 
-        let rightStack = UIStackView()
-        rightStack.axis = .horizontal
-        rightStack.alignment = .fill
-        rightStack.distribution = .equalSpacing
-        rightStack.spacing = 8
-        rightStack.setContentHuggingHorizontalLow()
-        rightStack.setCompressionResistanceHorizontalLow()
-        addArrangedSubview(rightStack)
+        var textStackSubviews = [UIView]()
 
-        // Text
+        if let titleLabelConfig = self.titleLabelConfig {
+            let titleLabel = linkPreviewView.titleLabel
+            titleLabelConfig.applyForRendering(label: titleLabel)
+            textStackSubviews.append(titleLabel)
+        }
 
-        let textStack = UIStackView()
-        textStack.axis = .vertical
-        textStack.alignment = .leading
-        textStack.spacing = 2
-        textStack.setContentHuggingHorizontalLow()
-        textStack.setCompressionResistanceHorizontalLow()
-
-        if let title = state.title(),
-            title.count > 0 {
-            let label = UILabel()
-            label.text = title
-            label.textColor = Theme.primaryTextColor
-            label.font = UIFont.ows_dynamicTypeBody
-            textStack.addArrangedSubview(label)
+        if let descriptionLabelConfig = self.descriptionLabelConfig {
+            let descriptionLabel = linkPreviewView.descriptionLabel
+            descriptionLabelConfig.applyForRendering(label: descriptionLabel)
+            textStackSubviews.append(descriptionLabel)
         }
-        if let description = state.previewDescription(), description.count > 0 {
-            let label = UILabel()
-            label.text = description
-            label.textColor = Theme.isDarkThemeEnabled ? UIColor.ows_gray05 : UIColor.ows_gray90
-            label.font = UIFont.ows_dynamicTypeSubheadline
-            textStack.addArrangedSubview(label)
+
+        if let displayDomainLabelConfig = self.displayDomainLabelConfig {
+            let displayDomainLabel = linkPreviewView.displayDomainLabel
+            displayDomainLabelConfig.applyForRendering(label: displayDomainLabel)
+            textStackSubviews.append(displayDomainLabel)
         }
-        if let displayDomain = state.displayDomain(),
-            displayDomain.count > 0 {
-            let label = UILabel()
-            var labelText = displayDomain.lowercased()
-            if let date = state.date() {
-                labelText.append("  \(Self.dateFormatter.string(from: date))")
-            }
-            label.text = labelText
-            label.textColor = Theme.secondaryTextAndIconColor
-            label.font = UIFont.ows_dynamicTypeCaption1
-            textStack.addArrangedSubview(label)
+
+        let textStack = linkPreviewView.textStack
+        textStack.configure(config: textStackConfig,
+                            cellMeasurement: cellMeasurement,
+                            measurementKey: LinkPreviewView.measurementKey_textStack,
+                            subviews: textStackSubviews)
+        guard let textMeasurement = cellMeasurement.measurement(key: LinkPreviewView.measurementKey_textStack) else {
+            owsFailDebug("Missing measurement.")
+            return
         }
+        let textWrapper = ManualLayoutView(name: "textWrapper")
+        textWrapper.addSubviewToCenterOnSuperview(textStack,
+                                                  size: textMeasurement.measuredSize)
+        rightStackSubviews.append(textWrapper)
 
-        let textWrapper = UIStackView(arrangedSubviews: [textStack])
-        textWrapper.axis = .horizontal
-        textWrapper.alignment = .center
-        textWrapper.setContentHuggingHorizontalLow()
-        textWrapper.setCompressionResistanceHorizontalLow()
+        // Right
 
-        rightStack.addArrangedSubview(textWrapper)
+        let rightStack = linkPreviewView.rightStack
+        rightStack.configure(config: rightStackConfig,
+                             cellMeasurement: cellMeasurement,
+                             measurementKey: LinkPreviewView.measurementKey_rightStack,
+                             subviews: rightStackSubviews)
+        rootStackSubviews.append(rightStack)
 
         // Cancel
 
-        let cancelStack = UIStackView()
-        cancelStack.axis = .horizontal
-        cancelStack.alignment = .top
-        cancelStack.setContentHuggingHigh()
-        cancelStack.setCompressionResistanceHigh()
-
-        let cancelImage = UIImage(named: "compose-cancel")?.withRenderingMode(.alwaysTemplate)
-        let cancelButton = UIButton(type: .custom)
-        cancelButton.setImage(cancelImage, for: .normal)
-        cancelButton.addTarget(self, action: #selector(didTapCancel(sender:)), for: .touchUpInside)
-        self.cancelButton = cancelButton
-        cancelButton.tintColor = Theme.secondaryTextAndIconColor
-        cancelButton.setContentHuggingHigh()
-        cancelButton.setCompressionResistanceHigh()
-        cancelStack.addArrangedSubview(cancelButton)
-
-        rightStack.addArrangedSubview(cancelStack)
+        let cancelButton = OWSButton { [weak linkPreviewView] in
+            linkPreviewView?.didTapCancel()
+        }
+        cancelButton.setTemplateImageName("compose-cancel",
+                                          tintColor: Theme.secondaryTextAndIconColor)
+        let cancelSize = self.cancelSize
+        rightStack.addSubview(cancelButton) { view in
+            cancelButton.frame = CGRect(x: 0, y: view.bounds.width - cancelSize, width: cancelSize, height: cancelSize)
+        }
 
         // Stroke
+
         let strokeView = UIView()
         strokeView.backgroundColor = Theme.secondaryTextAndIconColor
-        rightStack.addSubview(strokeView)
-        strokeView.autoPinWidthToSuperview()
-        strokeView.autoPinEdge(toSuperviewEdge: .bottom)
-        strokeView.autoSetDimension(.height, toSize: CGHairlineWidth())
-    }
-
-    private func createImageView(state: LinkPreviewState,
-                                 rounding roundingParam: LinkPreviewImageView.Rounding? = nil) -> UIImageView? {
-        guard state.isLoaded() else {
-            owsFailDebug("State not loaded.")
-            return nil
-        }
+        rightStack.addSubviewAsBottomStroke(strokeView)
 
-        guard state.imageState() == .loaded else {
-            return nil
-        }
-        guard let image = state.image() else {
-            owsFailDebug("Could not load image.")
-            return nil
-        }
-        let imageView = LinkPreviewImageView(rounding: roundingParam ?? .standard)
-        imageView.image = image
-        imageView.isHero = Self.sentIsHero(state: state)
-        return imageView
+        linkPreviewView.configure(config: rootStackConfig,
+                                  cellMeasurement: cellMeasurement,
+                                  measurementKey: LinkPreviewView.measurementKey_rootStack,
+                                  subviews: rootStackSubviews)
     }
 
-    private func createDraftImageView(state: LinkPreviewState) -> UIImageView? {
+    private func buildDraftImageView(hasAsymmetricalRounding: Bool) -> UIImageView? {
         guard state.isLoaded() else {
             owsFailDebug("State not loaded.")
             return nil
         }
-
         guard state.imageState()  == .loaded else {
             return nil
         }
-        guard let image = state.image() else {
-            owsFailDebug("Could not load image.")
-            return nil
-        }
-        let rounding: LinkPreviewImageView.Rounding = hasAsymmetricalRounding ? .asymmetrical : .standard
-        let imageView = LinkPreviewImageView(rounding: rounding)
-        imageView.image = image
-        return imageView
-    }
-
-    private func createDraftLoadingContents(state: LinkPreviewState) {
-        self.axis = .vertical
-        self.alignment = .center
-
-        self.layoutConstraints.append(self.autoSetDimension(.height, toSize: Self.draftHeight + Self.draftMarginTop))
-
-        let activityIndicatorStyle = state.activityIndicatorStyle
-        let activityIndicator = UIActivityIndicatorView(style: activityIndicatorStyle)
-        activityIndicator.startAnimating()
-        addArrangedSubview(activityIndicator)
-        let activityIndicatorSize: CGFloat = 25
-        activityIndicator.autoSetDimensions(to: CGSize(square: activityIndicatorSize))
-
-        // Stroke
-        let strokeView = UIView()
-        strokeView.backgroundColor = Theme.secondaryTextAndIconColor
-        self.addSubview(strokeView)
-        strokeView.autoPinWidthToSuperview(withMargin: 12)
-        strokeView.autoPinEdge(toSuperviewEdge: .bottom)
-        strokeView.autoSetDimension(.height, toSize: CGHairlineWidth())
-    }
-
-    static var defaultActivityIndicatorStyle: UIActivityIndicatorView.Style {
-        Theme.isDarkThemeEnabled
-        ? .white
-        : .gray
-    }
-
-    // MARK: Events
-
-    @objc func wasTapped(sender: UIGestureRecognizer) {
-        guard sender.state == .recognized else {
-            return
-        }
-        if let cancelButton = cancelButton {
-            // Permissive hot area to make it very easy to cancel the link preview.
-            if cancelButton.containsGestureLocation(sender, hotAreaAdjustment: 20) {
-                self.draftDelegate?.linkPreviewDidCancel()
-                return
-            }
-        }
+        guard let image = state.image() else {
+            owsFailDebug("Could not load image.")
+            return nil
+        }
+        let rounding: LinkPreviewImageView.Rounding = hasAsymmetricalRounding ? .asymmetrical : .standard
+        let imageView = LinkPreviewImageView(rounding: rounding)
+        imageView.image = image
+        return imageView
     }
 
-    // MARK: Measurement
-
-    @objc
-    public func measure(withState state: LinkPreviewState) -> CGSize {
-        Self.measure(withState: state)
-    }
+    func measure(maxWidth: CGFloat,
+                 measurementBuilder: CVCellMeasurement.Builder,
+                 state: LinkPreviewState) -> CGSize {
 
-    @objc
-    public static func measure(withState state: LinkPreviewState) -> CGSize {
-        if let sentState = state as? LinkPreviewSent {
-            return self.measure(withSentState: sentState)
-        } else if let groupLinkState = state as? LinkPreviewGroupLink {
-            return self.measure(withGroupLinkState: groupLinkState)
-        } else if let loadingState = state as? LinkPreviewLoading {
-            return self.measure(withLoadingState: loadingState)
-        } else {
-            owsFailDebug("Invalid state.")
-            return .zero
-        }
-    }
+        let activityIndicatorSize = CGSize.square(25)
+        let strokeSize = CGSize(width: 0, height: CGHairlineWidth())
 
-    @objc
-    public static func measure(withLoadingState state: LinkPreviewLoading) -> CGSize {
-        let size = Self.draftHeight + Self.draftMarginTop
-        return CGSize(width: size, height: size)
+        let rootStackMeasurement = ManualStackView.measure(config: rootStackConfig,
+                                                           measurementBuilder: measurementBuilder,
+                                                           measurementKey: LinkPreviewView.measurementKey_rootStack,
+                                                           subviewInfos: [
+                                                            activityIndicatorSize.asManualSubviewInfo(hasFixedSize: true),
+                                                            strokeSize.asManualSubviewInfo(hasFixedHeight: true)
+                                                           ])
+        var rootStackSize = rootStackMeasurement.measuredSize
+        rootStackSize.height = (LinkPreviewViewAdapterDraft.draftHeight +
+                                    LinkPreviewViewAdapterDraft.draftMarginTop)
+        return rootStackSize
     }
+}
 
-    @objc
-    public static func measure(withGroupLinkState state: LinkPreviewGroupLink) -> CGSize {
+// MARK: -
 
-        guard let conversationStyle = state.conversationStyle else {
-            owsFailDebug("Missing conversationStyle.")
-            return .zero
-        }
+private class LinkPreviewViewAdapterDraftLoading: LinkPreviewViewAdapter {
 
-        let hasImage = state.imageState() != .none
+    let activityIndicatorSize = CGSize.square(25)
 
-        let maxMessageWidth = conversationStyle.maxMessageWidth
+    let state: LinkPreviewState
 
-        var maxTextWidth = maxMessageWidth - 2 * sentNonHeroHMargin
-        if hasImage {
-            maxTextWidth -= (sentNonHeroImageSize + sentNonHeroHSpacing)
-        }
-        let textStackSize = sentTextStackSize(state: state, maxWidth: maxTextWidth, ignoreDomain: true)
+    init(state: LinkPreviewState) {
+        self.state = state
+    }
 
-        var result = textStackSize
+    var rootStackConfig: ManualStackView.Config {
+        ManualStackView.Config(axis: .vertical,
+                               alignment: .fill,
+                               spacing: 0,
+                               layoutMargins: .zero)
+    }
 
-        result.width += sentNonHeroImageSize + sentNonHeroHSpacing
-        result.height = max(result.height, sentNonHeroImageSize)
+    func configureForRendering(linkPreviewView: LinkPreviewView,
+                               hasAsymmetricalRounding: Bool,
+                               cellMeasurement: CVCellMeasurement) {
 
-        result.width += 2 * sentNonHeroHMargin
-        result.height += 2 * sentNonHeroVMargin
+        let activityIndicatorStyle = state.activityIndicatorStyle
+        let activityIndicator = UIActivityIndicatorView(style: activityIndicatorStyle)
+        activityIndicator.startAnimating()
+        linkPreviewView.addSubviewToCenterOnSuperview(activityIndicator,
+                                                      size: activityIndicatorSize)
 
-        return CGSizeCeil(result)
+        let strokeView = UIView()
+        strokeView.backgroundColor = Theme.secondaryTextAndIconColor
+        linkPreviewView.addSubviewAsBottomStroke(strokeView,
+                                                 layoutMargins: UIEdgeInsets(hMargin: 12,
+                                                                             vMargin: 0))
+
+        linkPreviewView.configure(config: rootStackConfig,
+                                  cellMeasurement: cellMeasurement,
+                                  measurementKey: LinkPreviewView.measurementKey_rootStack,
+                                  subviews: [
+                                    activityIndicator,
+                                    strokeView
+                                  ])
+    }
+
+    func measure(maxWidth: CGFloat,
+                 measurementBuilder: CVCellMeasurement.Builder,
+                 state: LinkPreviewState) -> CGSize {
+
+        let rootStackMeasurement = ManualStackView.measure(config: rootStackConfig,
+                                                  measurementBuilder: measurementBuilder,
+                                                  measurementKey: LinkPreviewView.measurementKey_rootStack,
+                                                  subviewInfos: [
+                                                  ])
+        var rootStackSize = rootStackMeasurement.measuredSize
+        rootStackSize.height = (LinkPreviewViewAdapterDraft.draftHeight +
+                                    LinkPreviewViewAdapterDraft.draftMarginTop)
+        return rootStackSize
     }
+}
 
-    @objc
-    public static func measure(withSentState state: LinkPreviewState) -> CGSize {
+// MARK: -
 
-        guard let conversationStyle = state.conversationStyle else {
-            owsFailDebug("Missing conversationStyle.")
-            return .zero
-        }
+private class LinkPreviewViewAdapterGroupLink: LinkPreviewViewAdapter {
+}
 
-        switch state.imageState() {
-        case .loaded:
-            if sentIsHero(state: state) {
-                return measureSentHero(state: state, conversationStyle: conversationStyle)
-            } else if state.previewDescription()?.isEmpty == false,
-                state.title()?.isEmpty == false {
-                return measureSentNonHeroWithDescription(state: state, conversationStyle: conversationStyle)
-            } else {
-                return measureSentNonHero(state: state, conversationStyle: conversationStyle, hasImage: true)
-            }
-        default:
-            return measureSentNonHero(state: state, conversationStyle: conversationStyle, hasImage: false)
-        }
-    }
+// MARK: -
 
-    private static func measureSentHero(state: LinkPreviewState,
-                                 conversationStyle: ConversationStyle) -> CGSize {
-        let maxMessageWidth = conversationStyle.maxMessageWidth
-        var messageHeight: CGFloat  = 0
+private class LinkPreviewViewAdapterSentHero: LinkPreviewViewAdapter {
+}
 
-        let heroImageSize = sentHeroImageSize(state: state, conversationStyle: conversationStyle)
-        messageHeight += heroImageSize.height
+// MARK: -
 
-        let textStackSize = sentTextStackSize(state: state,
-                                              maxWidth: maxMessageWidth - 2 * sentHeroHMargin)
-        messageHeight += textStackSize.height + 2 * sentHeroVMargin
+private class LinkPreviewViewAdapterSent: LinkPreviewViewAdapter {
+}
 
-        return CGSizeCeil(CGSize(width: maxMessageWidth, height: messageHeight))
-    }
+// MARK: -
 
-    private static func measureSentNonHeroWithDescription(state: LinkPreviewState,
-                                                   conversationStyle: ConversationStyle) -> CGSize {
-        let maxMessageWidth = conversationStyle.maxMessageWidth
+private class LinkPreviewViewAdapterSentWithDescription: LinkPreviewViewAdapter {
+}
 
-        let bottomMaxTextWidth = maxMessageWidth - 2 * sentNonHeroHMargin
-        let titleMaxTextWidth = bottomMaxTextWidth - (sentNonHeroImageSize + sentNonHeroHSpacing)
+// MARK: -
 
-        let titleLabelSize = sentTitleLabelConfig(state: state)?.measure(maxWidth: titleMaxTextWidth) ?? .zero
-        let descriptionLabelSize = sentDescriptionLabelConfig(state: state)?.measure(maxWidth: bottomMaxTextWidth) ?? .zero
-        let domainLabelSize = sentDomainLabelConfig(state: state).measure(maxWidth: bottomMaxTextWidth)
+private class LinkPreviewImageView: CVImageView {
+    fileprivate enum Rounding: UInt {
+        case standard
+        case asymmetrical
+        case circular
+    }
 
-        let bindingTitleHeight = max(titleLabelSize.height, sentNonHeroImageSize)
+    private let rounding: Rounding
+    fileprivate var isHero = false
 
-        var resultSize = CGSize.zero
-        resultSize.height += sentNonHeroVMargin
-        resultSize.height += bindingTitleHeight
-        resultSize.height += sentVSpacing * 2
-        resultSize.height += descriptionLabelSize.height
-        resultSize.height += sentVSpacing
-        resultSize.height += domainLabelSize.height
-        resultSize.height += sentNonHeroVMargin
+    // We only need to use a more complicated corner mask if we're
+    // drawing asymmetric corners. This is an exceptional case to match
+    // the input toolbar curve.
+    private let asymmetricCornerMask = CAShapeLayer()
 
-        let titleStackWidth = titleLabelSize.width + sentNonHeroHSpacing + sentNonHeroImageSize
-        resultSize.width = [titleStackWidth, descriptionLabelSize.width, domainLabelSize.width].max() ?? 0
-        resultSize.width += (sentNonHeroHMargin * 2)
+    init(rounding: Rounding) {
+        self.rounding = rounding
+        super.init(frame: .zero)
 
-        return CGSizeCeil(resultSize)
+        if rounding == .asymmetrical {
+            layer.mask = asymmetricCornerMask
+        }
     }
 
-    private static func measureSentNonHero(state: LinkPreviewState,
-                                    conversationStyle: ConversationStyle,
-                                    hasImage: Bool) -> CGSize {
-        let maxMessageWidth = conversationStyle.maxMessageWidth
+    required init?(coder aDecoder: NSCoder) {
+        self.rounding = .standard
+        super.init(coder: aDecoder)
+    }
 
-        var maxTextWidth = maxMessageWidth - 2 * sentNonHeroHMargin
-        if hasImage {
-            maxTextWidth -= (sentNonHeroImageSize + sentNonHeroHSpacing)
+    override var bounds: CGRect {
+        didSet {
+            updateMaskLayer()
         }
-        let textStackSize = sentTextStackSize(state: state, maxWidth: maxTextWidth)
+    }
 
-        var result = textStackSize
+    override var frame: CGRect {
+        didSet {
+            updateMaskLayer()
+        }
+    }
 
-        if hasImage {
-            result.width += sentNonHeroImageSize + sentNonHeroHSpacing
-            result.height = max(result.height, sentNonHeroImageSize)
+    override var center: CGPoint {
+        didSet {
+            updateMaskLayer()
         }
+    }
 
-        result.width += 2 * sentNonHeroHMargin
-        result.height += 2 * sentNonHeroVMargin
+    private func updateMaskLayer() {
+        let layerBounds = self.bounds
+        let bigRounding: CGFloat = 14
+        let smallRounding: CGFloat = 6
 
-        return CGSizeCeil(result)
-    }
+        switch rounding {
+        case .standard:
+            layer.cornerRadius = smallRounding
+            layer.maskedCorners = isHero ? .top : .all
+        case .circular:
+            layer.cornerRadius = bounds.size.smallerAxis / 2
+            layer.maskedCorners = .all
+        case .asymmetrical:
+            // This uses a more expensive layer mask to clip corners
+            // with different radii.
+            // This should only be used in the input toolbar so perf is
+            // less of a concern here.
+            owsAssertDebug(!isHero, "Link preview drafts never use hero images")
 
-    private static func sentLabelSize(label: UILabel, maxWidth: CGFloat) -> CGSize {
-        CGSizeCeil(label.sizeThatFits(CGSize(width: maxWidth, height: CGFloat.greatestFiniteMagnitude)))
-    }
+            let upperLeft = CGPoint(x: 0, y: 0)
+            let upperRight = CGPoint(x: layerBounds.size.width, y: 0)
+            let lowerRight = CGPoint(x: layerBounds.size.width, y: layerBounds.size.height)
+            let lowerLeft = CGPoint(x: 0, y: layerBounds.size.height)
 
-    private static func sentTextStackSize(state: LinkPreviewState, maxWidth: CGFloat, ignoreDomain: Bool = false) -> CGSize {
+            let upperLeftRounding: CGFloat = CurrentAppContext().isRTL ? smallRounding : bigRounding
+            let upperRightRounding: CGFloat = CurrentAppContext().isRTL ? bigRounding : smallRounding
+            let lowerRightRounding = smallRounding
+            let lowerLeftRounding = smallRounding
 
-        var labelSizes = [CGSize]()
+            let path = UIBezierPath()
 
-        if !ignoreDomain {
-            let config = sentDomainLabelConfig(state: state)
-            let domainLabelSize = config.measure(maxWidth: maxWidth)
-            labelSizes.append(domainLabelSize)
-        }
-        if let config = sentTitleLabelConfig(state: state) {
-            let titleLabelSize = config.measure(maxWidth: maxWidth)
-            labelSizes.append(titleLabelSize)
-        }
-        if let config = sentDescriptionLabelConfig(state: state) {
-            let descriptionLabelSize = config.measure(maxWidth: maxWidth)
-            labelSizes.append(descriptionLabelSize)
+            // It's sufficient to "draw" the rounded corners and not the edges that connect them.
+            path.addArc(withCenter: upperLeft.offsetBy(dx: +upperLeftRounding).offsetBy(dy: +upperLeftRounding),
+                        radius: upperLeftRounding,
+                        startAngle: CGFloat.pi * 1.0,
+                        endAngle: CGFloat.pi * 1.5,
+                        clockwise: true)
+
+            path.addArc(withCenter: upperRight.offsetBy(dx: -upperRightRounding).offsetBy(dy: +upperRightRounding),
+                        radius: upperRightRounding,
+                        startAngle: CGFloat.pi * 1.5,
+                        endAngle: CGFloat.pi * 0.0,
+                        clockwise: true)
+
+            path.addArc(withCenter: lowerRight.offsetBy(dx: -lowerRightRounding).offsetBy(dy: -lowerRightRounding),
+                        radius: lowerRightRounding,
+                        startAngle: CGFloat.pi * 0.0,
+                        endAngle: CGFloat.pi * 0.5,
+                        clockwise: true)
+
+            path.addArc(withCenter: lowerLeft.offsetBy(dx: +lowerLeftRounding).offsetBy(dy: -lowerLeftRounding),
+                        radius: lowerLeftRounding,
+                        startAngle: CGFloat.pi * 0.5,
+                        endAngle: CGFloat.pi * 1.0,
+                        clockwise: true)
+
+            asymmetricCornerMask.path = path.cgPath
         }
+    }
+}
 
-        return measureTextStack(labelSizes: labelSizes)
+// MARK: -
+
+public extension CGPoint {
+    func offsetBy(dx: CGFloat) -> CGPoint {
+        return CGPoint(x: x + dx, y: y)
     }
 
-    private static func measureTextStack(labelSizes: [CGSize]) -> CGSize {
-        let width = labelSizes.map { $0.width }.reduce(0, max)
-        let height = labelSizes.map { $0.height }.reduce(0, +) + CGFloat(labelSizes.count - 1) * sentVSpacing
-        return CGSize(width: width, height: height)
+    func offsetBy(dy: CGFloat) -> CGPoint {
+        return CGPoint(x: x, y: y + dy)
     }
+}
+
+// MARK: -
 
-    @objc func didTapCancel(sender: UIButton) {
-        self.draftDelegate?.linkPreviewDidCancel()
+public extension ManualLayoutView {
+    func addSubviewAsBottomStroke(_ subview: UIView,
+                                  layoutMargins: UIEdgeInsets = .zero) {
+        addSubview(subview) { view in
+            var subviewFrame = view.bounds.inset(by: layoutMargins)
+            subviewFrame.size.height = CGHairlineWidth()
+            subviewFrame.y = view.bounds.height - (subviewFrame.height +
+                                                    layoutMargins.bottom)
+            subview.frame = subviewFrame
+        }
     }
 }
