diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index cf51209640e..f4b4e6bb3db 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -908,6 +908,7 @@
 		66B8B28028C94C0F005EAFE0 /* DelegatingContextMenuButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */; };
 		66B9437E2A6EFCD900DCF2FF /* SpoilerParticleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66B9437D2A6EFCD900DCF2FF /* SpoilerParticleView.swift */; };
 		66B943812A6F217600DCF2FF /* SpoilerParticleShader.metal in Sources */ = {isa = PBXBuildFile; fileRef = 66B9437F2A6F216D00DCF2FF /* SpoilerParticleShader.metal */; };
+		66BB4D592AD8BF6200A84219 /* MergingDict.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66BB4D582AD8BF6200A84219 /* MergingDict.swift */; };
 		66BE544D28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66BE544C28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift */; };
 		66C2B1312A05D28A008DDE72 /* TSRequest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66C2B1302A05D28A008DDE72 /* TSRequest.swift */; };
 		66C2B1362A0DB02E008DDE72 /* SVRUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66C2B1352A0DB02E008DDE72 /* SVRUtil.swift */; };
@@ -3497,6 +3498,7 @@
 		66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DelegatingContextMenuButton.swift; sourceTree = "<group>"; };
 		66B9437D2A6EFCD900DCF2FF /* SpoilerParticleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SpoilerParticleView.swift; sourceTree = "<group>"; };
 		66B9437F2A6F216D00DCF2FF /* SpoilerParticleShader.metal */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.metal; path = SpoilerParticleShader.metal; sourceTree = "<group>"; };
+		66BB4D582AD8BF6200A84219 /* MergingDict.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MergingDict.swift; sourceTree = "<group>"; };
 		66BE544C28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryContextOnboardingOverlayView.swift; sourceTree = "<group>"; };
 		66C2B1302A05D28A008DDE72 /* TSRequest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TSRequest.swift; sourceTree = "<group>"; };
 		66C2B1352A0DB02E008DDE72 /* SVRUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SVRUtil.swift; sourceTree = "<group>"; };
@@ -9834,6 +9836,7 @@
 				F9C5CB24289453B200548EEE /* LRUCache.swift */,
 				F9C5CB11289453B200548EEE /* MailtoLink.swift */,
 				F9C5CB36289453B200548EEE /* Math+OWS.swift */,
+				66BB4D582AD8BF6200A84219 /* MergingDict.swift */,
 				F9C5CB02289453B200548EEE /* MessageSender+Promise.swift */,
 				F9C5CB2C289453B200548EEE /* MIMETypeUtil.h */,
 				F9C5CB5E289453B200548EEE /* MIMETypeUtil.m */,
@@ -12573,6 +12576,7 @@
 				F9C5CBDF289453B300548EEE /* MentionFinder.swift in Sources */,
 				66FC637629DF7FCC00F00DAC /* MentionHydrator.swift in Sources */,
 				5052AF5E2ACB0E9700D7EE9F /* MergePair.swift in Sources */,
+				66BB4D592AD8BF6200A84219 /* MergingDict.swift in Sources */,
 				F9C5CBC9289453B300548EEE /* MessageBody.swift in Sources */,
 				66FC636F29DF797700F00DAC /* MessageBodyRanges.swift in Sources */,
 				668444802A3289C700DBED7C /* MessageBodyStyle.swift in Sources */,
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift b/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift
index 667c5085b32..f0efa27b170 100644
--- a/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/DatabaseChangeObserver.swift
@@ -290,8 +290,8 @@ extension DatabaseChangeObserver: TransactionObserver {
     func updateIdMapping(thread: TSThread, transaction: GRDBWriteTransaction) {
         AssertHasDatabaseChangeObserverLock()
 
-        pendingChanges.append(thread: thread)
-        pendingChanges.append(tableName: TSThread.table.tableName)
+        pendingChanges.insert(thread: thread)
+        pendingChanges.insert(tableName: TSThread.table.tableName)
 
         didModifyPendingChanges()
     }
@@ -300,8 +300,8 @@ extension DatabaseChangeObserver: TransactionObserver {
     func updateIdMapping(interaction: TSInteraction, transaction: GRDBWriteTransaction) {
         AssertHasDatabaseChangeObserverLock()
 
-        pendingChanges.append(interaction: interaction)
-        pendingChanges.append(tableName: TSInteraction.table.tableName)
+        pendingChanges.insert(interaction: interaction)
+        pendingChanges.insert(tableName: TSInteraction.table.tableName)
 
         didModifyPendingChanges()
     }
@@ -310,8 +310,8 @@ extension DatabaseChangeObserver: TransactionObserver {
     func didTouch(interaction: TSInteraction, transaction: GRDBWriteTransaction) {
         AssertHasDatabaseChangeObserverLock()
 
-        pendingChanges.append(interaction: interaction)
-        pendingChanges.append(tableName: TSInteraction.table.tableName)
+        pendingChanges.insert(interaction: interaction)
+        pendingChanges.insert(tableName: TSInteraction.table.tableName)
 
         if !pendingChanges.threadUniqueIds.contains(interaction.uniqueThreadId) {
             let interactionThread: TSThread? = interaction.thread(tx: transaction.asAnyRead)
@@ -334,8 +334,8 @@ extension DatabaseChangeObserver: TransactionObserver {
         // in the expected way.
         AssertHasDatabaseChangeObserverLock()
 
-        pendingChanges.append(thread: thread, shouldUpdateChatListUi: shouldUpdateChatListUi)
-        pendingChanges.append(tableName: TSThread.table.tableName)
+        pendingChanges.insert(thread: thread, shouldUpdateChatListUi: shouldUpdateChatListUi)
+        pendingChanges.insert(tableName: TSThread.table.tableName)
 
         didModifyPendingChanges()
     }
@@ -347,8 +347,8 @@ extension DatabaseChangeObserver: TransactionObserver {
         // in the expected way.
         AssertHasDatabaseChangeObserverLock()
 
-        pendingChanges.append(storyMessage: storyMessage)
-        pendingChanges.append(tableName: StoryMessage.databaseTableName)
+        pendingChanges.insert(storyMessage: storyMessage)
+        pendingChanges.insert(tableName: StoryMessage.databaseTableName)
 
         didModifyPendingChanges()
     }
@@ -381,19 +381,19 @@ extension DatabaseChangeObserver: TransactionObserver {
 
         DatabaseChangeObserver.serializedSync {
 
-            pendingChanges.append(tableName: event.tableName)
+            pendingChanges.insert(tableName: event.tableName)
 
             if event.tableName == InteractionRecord.databaseTableName {
-                pendingChanges.append(interactionRowId: event.rowID)
+                pendingChanges.insert(interactionRowId: event.rowID)
             } else if event.tableName == ThreadRecord.databaseTableName {
-                pendingChanges.append(threadRowId: event.rowID)
+                pendingChanges.insert(threadRowId: event.rowID)
             } else if event.tableName == StoryMessage.databaseTableName {
-                pendingChanges.append(storyMessageRowId: event.rowID)
+                pendingChanges.insert(storyMessageRowId: event.rowID)
             }
 
             // We record certain deletions.
             if event.kind == .delete && event.tableName == InteractionRecord.databaseTableName {
-                pendingChanges.append(deletedInteractionRowId: event.rowID)
+                pendingChanges.insert(deletedInteractionRowId: event.rowID)
             }
 
             #if TESTABLE_BUILD
@@ -412,36 +412,11 @@ extension DatabaseChangeObserver: TransactionObserver {
             let pendingChangesToCommit = self.pendingChanges
             self.pendingChanges = ObservedDatabaseChanges(concurrencyMode: .databaseChangeObserverSerialQueue)
 
-            do {
-                // finalizePublishedState() finalizes the state we're about to
-                // copy.
-                try pendingChangesToCommit.finalizePublishedState(db: db)
-
-                let interactionUniqueIds = pendingChangesToCommit.interactionUniqueIds
-                let threadUniqueIds = pendingChangesToCommit.threadUniqueIds
-                let uniqueIdToShouldUpdateChatListUiDict = pendingChangesToCommit.uniqueIdToShouldUpdateChatListUiDict
-                let storyMessageUniqueIds = pendingChangesToCommit.storyMessageUniqueIds
-                let storyMessageRowIds = pendingChangesToCommit.storyMessageRowIds
-                let interactionDeletedUniqueIds = pendingChangesToCommit.interactionDeletedUniqueIds
-                let storyMessageDeletedUniqueIds = pendingChangesToCommit.storyMessageDeletedUniqueIds
-                let collections = pendingChangesToCommit.collections
-                let tableNames = pendingChangesToCommit.tableNames
-
-                Self.committedChangesLock.withLock {
-                    self.committedChanges.append(interactionUniqueIds: interactionUniqueIds)
-                    self.committedChanges.append(threadUniqueIds: threadUniqueIds, shouldUpdateChatListUiDictParam: uniqueIdToShouldUpdateChatListUiDict)
-                    self.committedChanges.append(storyMessageUniqueIds: storyMessageUniqueIds)
-                    self.committedChanges.append(storyMessageRowIds: storyMessageRowIds)
-                    self.committedChanges.append(interactionDeletedUniqueIds: interactionDeletedUniqueIds)
-                    self.committedChanges.append(storyMessageDeletedUniqueIds: storyMessageDeletedUniqueIds)
-                    self.committedChanges.append(collections: collections)
-                    self.committedChanges.append(tableNames: tableNames)
-                }
-            } catch {
-                Self.committedChangesLock.withLock {
-                    self.committedChanges.setLastError(error)
-                }
-            }
+            pendingChangesToCommit.finalizePublishedStateAndCopyToCommittedChanges(
+                self.committedChanges,
+                withLock: Self.committedChangesLock,
+                db: db
+            )
 
             #if TESTABLE_BUILD
             for delegate in databaseWriteDelegates {
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift b/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift
index ca9ef5ef751..5b6b8851543 100644
--- a/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/ObservedDatabaseChanges.swift
@@ -15,9 +15,6 @@ public protocol DatabaseChanges: AnyObject {
     /// Unique ids for threads that have been changed in a user-facing way
     /// that should affect the chat list UI.
     var threadUniqueIdsForChatListUpdate: Set<UniqueId> { get }
-    /// Dictionary mapping thread uniqueIds to whether their corresponding
-    /// UI in the chat list should be updated.
-    var uniqueIdToShouldUpdateChatListUiDict: [String: Bool] { get }
     var interactionUniqueIds: Set<UniqueId> { get }
     var storyMessageUniqueIds: Set<UniqueId> { get }
     var storyMessageRowIds: Set<RowId> { get }
@@ -104,11 +101,11 @@ class ObservedDatabaseChanges: NSObject {
 
     private var _collections: Set<String> = Set()
 
-    func append(collection: String) {
-        append(collections: [collection])
+    func insert(collection: String) {
+        formUnion(collections: [collection])
     }
 
-    func append(collections: Set<String>) {
+    func formUnion(collections: Set<String>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
@@ -119,11 +116,11 @@ class ObservedDatabaseChanges: NSObject {
 
     private var _tableNames: Set<String> = Set()
 
-    func append(tableName: String) {
-        append(tableNames: [tableName])
+    func insert(tableName: String) {
+        formUnion(tableNames: [tableName])
     }
 
-    func append(tableNames: Set<String>) {
+    func formUnion(tableNames: Set<String>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
@@ -134,162 +131,138 @@ class ObservedDatabaseChanges: NSObject {
     // MARK: - Threads
 
     private var threads = ObservedModelChanges()
-    private var uniqueIdToShouldUpdateChatListUi = [String: Bool]()
 
-    var threadUniqueIdsForChatListUpdate: Set<UniqueId> {
-        return threadUniqueIds.filter {
-            uniqueIdToShouldUpdateChatListUi[$0] == true
-        }
-    }
-
-    func append(thread: TSThread, shouldUpdateChatListUi: Bool = true) {
+    func insert(thread: TSThread, shouldUpdateChatListUi: Bool = true) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        threads.append(model: thread)
-        // If `shouldUpdateChatListUi` is false, it is important that we set the value
-        // in the dictionary to false, rather than leaving it as nil. The code in
-        // `self.mapRowIdsToUniqueIds` relies on this.
-        uniqueIdToShouldUpdateChatListUi[thread.uniqueId] = (uniqueIdToShouldUpdateChatListUi[thread.uniqueId] ?? false) || shouldUpdateChatListUi
+        threads.insert(
+            model: thread,
+            state: .init(
+                chatListUiUpdateRule: shouldUpdateChatListUi.asChatListUIUpdateRule
+            )
+        )
     }
 
-    func append(
-        threadUniqueIds: Set<UniqueId>,
-        shouldUpdateChatListUiDictParam: [String: Bool]
-    ) {
+    func insert(threadRowId: RowId) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        threads.append(uniqueIds: threadUniqueIds)
-        for (key, value) in shouldUpdateChatListUiDictParam {
-            // In practice, `uniqueIdToShouldUpdateChatListUi` should always be empty to start
-            // with because this method is only called on a fresh `ObservedDatabaseChanges`
-            // object. However, we do this OR defensively.
-            let oldShouldUpdateChatListUi = uniqueIdToShouldUpdateChatListUi[key] ?? false
-            uniqueIdToShouldUpdateChatListUi[key] = oldShouldUpdateChatListUi || value
-        }
-    }
-
-    func append(threadRowId: RowId) {
-        #if TESTABLE_BUILD
-        checkConcurrency()
-        #endif
-
-        threads.append(rowId: threadRowId)
+        threads.insert(rowId: threadRowId)
     }
 
     // MARK: - Interactions
 
     private var interactions = ObservedModelChanges()
 
-    func append(interaction: TSInteraction) {
+    func insert(interaction: TSInteraction) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(model: interaction)
+        interactions.insert(model: interaction, state: .default)
     }
 
-    func append(interactionUniqueId: UniqueId) {
+    func insert(interactionUniqueId: UniqueId) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(uniqueId: interactionUniqueId)
+        interactions.insert(uniqueId: interactionUniqueId, state: .default)
     }
 
-    func append(interactionUniqueIds: Set<UniqueId>) {
+    func formUnion(interactionUniqueIds: Set<UniqueId>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(uniqueIds: interactionUniqueIds)
+        interactions.formUnion(uniqueIds: interactionUniqueIds.asMergingDictWithUniformValue(.default))
     }
 
-    func append(interactionDeletedUniqueIds: Set<UniqueId>) {
+    func formUnion(interactionDeletedUniqueIds: Set<UniqueId>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(deletedUniqueIds: interactionDeletedUniqueIds)
+        interactions.formUnion(deletedUniqueIds: interactionDeletedUniqueIds.asMergingDictWithUniformValue(.default))
     }
 
-    func append(interactionRowId: RowId) {
+    func insert(interactionRowId: RowId) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(rowId: interactionRowId)
+        interactions.insert(rowId: interactionRowId)
     }
 
-    func append(interactionRowIds: Set<RowId>) {
+    func formUnion(interactionRowIds: Set<RowId>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(rowIds: interactionRowIds)
+        interactions.formUnion(rowIds: interactionRowIds)
     }
 
-    func append(deletedInteractionRowId: RowId) {
+    func insert(deletedInteractionRowId: RowId) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        interactions.append(deletedRowId: deletedInteractionRowId)
+        interactions.insert(deletedRowId: deletedInteractionRowId)
     }
 
     // MARK: - Stories
 
     private var storyMessages = ObservedModelChanges()
 
-    func append(storyMessage: StoryMessage) {
+    func insert(storyMessage: StoryMessage) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        storyMessages.append(model: storyMessage)
+        storyMessages.insert(model: storyMessage, state: .default)
     }
 
-    func append(storyMessageUniqueId: UniqueId) {
+    func insert(storyMessageUniqueId: UniqueId) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        storyMessages.append(uniqueId: storyMessageUniqueId)
+        storyMessages.insert(uniqueId: storyMessageUniqueId, state: .default)
     }
 
-    func append(storyMessageUniqueIds: Set<UniqueId>) {
+    func formUnion(storyMessageUniqueIds: Set<UniqueId>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        storyMessages.append(uniqueIds: storyMessageUniqueIds)
+        storyMessages.formUnion(uniqueIds: storyMessageUniqueIds.asMergingDictWithUniformValue(.default))
     }
 
-    func append(storyMessageDeletedUniqueIds: Set<UniqueId>) {
+    func formUnion(storyMessageDeletedUniqueIds: Set<UniqueId>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        storyMessages.append(deletedUniqueIds: storyMessageDeletedUniqueIds)
+        storyMessages.formUnion(deletedUniqueIds: storyMessageDeletedUniqueIds.asMergingDictWithUniformValue(.default))
     }
 
-    func append(storyMessageRowId: RowId) {
+    func insert(storyMessageRowId: RowId) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        storyMessages.append(rowId: storyMessageRowId)
+        storyMessages.insert(rowId: storyMessageRowId)
     }
 
-    func append(storyMessageRowIds: Set<RowId>) {
+    func formUnion(storyMessageRowIds: Set<RowId>) {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        storyMessages.append(rowIds: storyMessageRowIds)
+        storyMessages.formUnion(rowIds: storyMessageRowIds)
     }
 
     // MARK: - Errors
@@ -314,14 +287,80 @@ class ObservedDatabaseChanges: NSObject {
 
 // MARK: -
 
+/// Whether we should update the chat list UI due to a database change.
+/// Merged together when multiple changes to the same identifier are collapsed
+/// together; e.g. two changes happen to the same thread unique id.
+private enum ChatListUIUpdateRule: Mergeable {
+    /// The caller did not specify whether the chat list needs updating
+    /// due to a change with the associated identifier.
+    /// Treated as requiring an update (the default), but when merging,
+    /// prefers an explicit setting. (e.g. undefined + update = update,
+    /// undefined + noUpdate = noUpdate).
+    case undefined
+    /// No UI update required due to the change with the associated identifier.
+    /// When merging multiple changes together, update + noUpdate = update.
+    case noUpdate
+    /// A UI update is explicitly required due to the change with the associated identifier.
+    /// When merging multiple changes together, update + noUpdate = update. 
+    case update
+
+    var shouldUpdate: Bool {
+        switch self {
+        case .undefined, .update:
+            return true
+        case .noUpdate:
+            return false
+        }
+    }
+
+    func merge(_ other: Self) -> Self {
+        switch (self, other) {
+        case (.update, _):
+            return .update
+        case (.undefined, _):
+            return other
+        case (.noUpdate, .update):
+            return .update
+        case (.noUpdate, .noUpdate), (.noUpdate, .undefined):
+            return .noUpdate
+        }
+    }
+}
+
+fileprivate extension Bool {
+    var asChatListUIUpdateRule: ChatListUIUpdateRule {
+        return self ? .update : .noUpdate
+    }
+}
+
+/// Track state related to a single model update, for example
+/// whether this model change should trigger chat list UI to update.
+private struct ObservedModelState: Mergeable {
+    var chatListUiUpdateRule: ChatListUIUpdateRule
+
+    // Add other fields here as new state needs to be tracked.
+
+    static var `default`: Self {
+        return Self.init(chatListUiUpdateRule: .undefined)
+    }
+
+    func merge(_ other: Self) -> Self {
+        return .init(
+            chatListUiUpdateRule: chatListUiUpdateRule.merge(other.chatListUiUpdateRule)
+        )
+    }
+}
+
+// MARK: -
+
 private struct ObservedModelChanges {
     typealias UniqueId = ObservedDatabaseChanges.UniqueId
     typealias RowId = ObservedDatabaseChanges.RowId
 
     private var _rowIds = Set<RowId>()
-    private var _uniqueIds = Set<UniqueId>()
+    private var _uniqueIds = MergingDict<UniqueId, ObservedModelState>()
     private var _deletedRowIds = Set<RowId>()
-    private var _deletedUniqueIds = Set<UniqueId>()
+    private var _deletedUniqueIds = MergingDict<UniqueId, ObservedModelState>()
     fileprivate var rowIdToUniqueIdMap = [RowId: UniqueId]()
 
     public var isEmpty: Bool {
@@ -332,8 +371,18 @@ private struct ObservedModelChanges {
                     rowIdToUniqueIdMap.isEmpty)
     }
 
-    mutating func append(model: SDSIdentifiableModel) {
-        _uniqueIds.insert(model.uniqueId)
+    mutating func merge(_ other: ObservedModelChanges) {
+        _rowIds.formUnion(other._rowIds)
+        _uniqueIds.formUnion(other._uniqueIds)
+        _deletedRowIds.formUnion(other._deletedRowIds)
+        _deletedUniqueIds.formUnion(other._deletedUniqueIds)
+        for (k, v) in other.rowIdToUniqueIdMap {
+            rowIdToUniqueIdMap[k] = v
+        }
+    }
+
+    mutating func insert(model: SDSIdentifiableModel, state: ObservedModelState) {
+        _uniqueIds.insert(model.uniqueId, state)
         guard let grdbId = model.grdbId else {
             owsFailDebug("Missing grdbId")
             return
@@ -343,33 +392,33 @@ private struct ObservedModelChanges {
         rowIdToUniqueIdMap[rowId] = model.uniqueId
     }
 
-    mutating func append(uniqueId: UniqueId) {
-        append(uniqueIds: [uniqueId])
+    mutating func insert(uniqueId: UniqueId, state: ObservedModelState) {
+        _uniqueIds.insert(uniqueId, state)
     }
 
-    mutating func append(uniqueIds: Set<UniqueId>) {
+    mutating func formUnion(uniqueIds: MergingDict<UniqueId, ObservedModelState>) {
         _uniqueIds.formUnion(uniqueIds)
     }
 
-    fileprivate mutating func append(deletedUniqueIds: Set<UniqueId>) {
+    fileprivate mutating func formUnion(deletedUniqueIds: MergingDict<UniqueId, ObservedModelState>) {
         _deletedUniqueIds.formUnion(deletedUniqueIds)
     }
 
-    mutating func append(rowId: RowId) {
+    mutating func insert(rowId: RowId) {
         #if TESTABLE_BUILD
         assert(rowId > 0)
         #endif
-        append(rowIds: [rowId])
+        formUnion(rowIds: [rowId])
     }
 
-    mutating func append(deletedRowId: RowId) {
+    mutating func insert(deletedRowId: RowId) {
         #if TESTABLE_BUILD
         assert(deletedRowId > 0)
         #endif
         _deletedRowIds.insert(deletedRowId)
     }
 
-    mutating func append(rowIds: Set<RowId>) {
+    mutating func formUnion(rowIds: Set<RowId>) {
         #if TESTABLE_BUILD
         for rowId in rowIds {
             assert(rowId > 0)
@@ -382,8 +431,8 @@ private struct ObservedModelChanges {
         assert(_rowIds.count >= _uniqueIds.count)
         return _rowIds
     }
-    var uniqueIds: Set<UniqueId> { _uniqueIds }
-    var deletedUniqueIds: Set<UniqueId> { _deletedUniqueIds }
+    var uniqueIds: MergingDict<UniqueId, ObservedModelState> { _uniqueIds }
+    var deletedUniqueIds: MergingDict<UniqueId, ObservedModelState> { _deletedUniqueIds }
     var deletedRowIds: Set<RowId> { _deletedRowIds }
 }
 
@@ -396,15 +445,15 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         checkConcurrency()
         #endif
 
-        return threads.uniqueIds
+        return threads.uniqueIds.keys
     }
 
-    var uniqueIdToShouldUpdateChatListUiDict: [String: Bool] {
+    var threadUniqueIdsForChatListUpdate: Set<UniqueId> {
         #if TESTABLE_BUILD
         checkConcurrency()
         #endif
 
-        return uniqueIdToShouldUpdateChatListUi
+        return threads.uniqueIds.keys(where: \.chatListUiUpdateRule.shouldUpdate)
     }
 
     var interactionUniqueIds: Set<UniqueId> {
@@ -412,7 +461,7 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         checkConcurrency()
         #endif
 
-        return interactions.uniqueIds
+        return interactions.uniqueIds.keys
     }
 
     var storyMessageUniqueIds: Set<UniqueId> {
@@ -420,7 +469,7 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         checkConcurrency()
         #endif
 
-        return storyMessages.uniqueIds
+        return storyMessages.uniqueIds.keys
     }
 
     var storyMessageRowIds: Set<RowId> {
@@ -436,7 +485,7 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         checkConcurrency()
         #endif
 
-        return interactions.deletedUniqueIds
+        return interactions.deletedUniqueIds.keys
     }
 
     var storyMessageDeletedUniqueIds: Set<UniqueId> {
@@ -444,7 +493,7 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         checkConcurrency()
         #endif
 
-        return storyMessages.deletedUniqueIds
+        return storyMessages.deletedUniqueIds.keys
     }
 
     var tableNames: Set<String> {
@@ -501,45 +550,91 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         threadUniqueIds.contains(thread.uniqueId)
     }
 
-    func finalizePublishedState(db: Database) throws {
+    /// Finalizes the current set of changes, mapping any row Ids to uniqueIds by doing database lookups.
+    /// Then copies over final changes to a "committed" set of changes, using the provided lock to
+    /// guard updates.
+    func finalizePublishedStateAndCopyToCommittedChanges(
+        _ committedChanges: ObservedDatabaseChanges,
+        withLock lock: UnfairLock,
+        db: Database
+    ) {
+        do {
+            // finalizePublishedState() finalizes the state we're about to
+            // copy.
+            try finalizePublishedState(db: db)
+        } catch let error {
+            lock.withLock {
+                committedChanges.setLastError(error)
+            }
+            return
+        }
+
+        let interactions = self.interactions
+        let threads = self.threads
+        let storyMessages = self.storyMessages
+        let collections = self.collections
+        let tableNames = self.tableNames
+
+        lock.withLock {
+            committedChanges.interactions.merge(interactions)
+            committedChanges.threads.merge(threads)
+            committedChanges.storyMessages.merge(storyMessages)
+            committedChanges.formUnion(collections: collections)
+            committedChanges.formUnion(tableNames: tableNames)
+        }
+    }
+
+    private func finalizePublishedState(db: Database) throws {
         // We don't finalize everything, only state the views currently care about.
 
         // We need to convert all thread "row ids" to "unique ids".
-        threads.append(uniqueIds: try mapRowIdsToUniqueIds(db: db,
-                                                           rowIds: threads.rowIds,
-                                                           uniqueIds: threads.uniqueIds,
-                                                           rowIdToUniqueIdMap: threads.rowIdToUniqueIdMap,
-                                                           tableName: "\(ThreadRecord.databaseTableName)",
-                                                           uniqueIdColumnName: "\(threadColumn: .uniqueId)",
-                                                           isMappingForThreads: true))
+        threads.formUnion(
+            uniqueIds: try mapRowIdsToUniqueIds(
+                db: db,
+                rowIds: threads.rowIds,
+                uniqueIds: threads.uniqueIds,
+                rowIdToUniqueIdMap: threads.rowIdToUniqueIdMap,
+                tableName: "\(ThreadRecord.databaseTableName)",
+                uniqueIdColumnName: "\(threadColumn: .uniqueId)"
+            )
+        )
 
         // We need to convert all interaction "row ids" to "unique ids".
-        interactions.append(uniqueIds: try mapRowIdsToUniqueIds(db: db,
-                                                                rowIds: interactions.rowIds,
-                                                                uniqueIds: interactions.uniqueIds,
-                                                                rowIdToUniqueIdMap: interactions.rowIdToUniqueIdMap,
-                                                                tableName: "\(InteractionRecord.databaseTableName)",
-                                                                uniqueIdColumnName: "\(interactionColumn: .uniqueId)"))
+        interactions.formUnion(
+            uniqueIds: try mapRowIdsToUniqueIds(
+                db: db,
+                rowIds: interactions.rowIds,
+                uniqueIds: interactions.uniqueIds,
+                rowIdToUniqueIdMap: interactions.rowIdToUniqueIdMap,
+                tableName: "\(InteractionRecord.databaseTableName)",
+                uniqueIdColumnName: "\(interactionColumn: .uniqueId)"
+            )
+        )
 
         // We need to convert _deleted_ interaction "row ids" to "unique ids".
-        interactions.append(deletedUniqueIds: try mapRowIdsToUniqueIds(db: db,
-                                                                       rowIds: interactions.deletedRowIds,
-                                                                       uniqueIds: interactions.deletedUniqueIds,
-                                                                       rowIdToUniqueIdMap: interactions.rowIdToUniqueIdMap,
-                                                                       tableName: "\(InteractionRecord.databaseTableName)",
-                                                                       uniqueIdColumnName: "\(interactionColumn: .uniqueId)"))
+        interactions.formUnion(
+            deletedUniqueIds: try mapRowIdsToUniqueIds(
+                db: db,
+                rowIds: interactions.deletedRowIds,
+                uniqueIds: interactions.deletedUniqueIds,
+                rowIdToUniqueIdMap: interactions.rowIdToUniqueIdMap,
+                tableName: "\(InteractionRecord.databaseTableName)",
+                uniqueIdColumnName: "\(interactionColumn: .uniqueId)"
+            )
+        )
 
         // We need to convert db table names to "collections."
         mapTableNamesToCollections()
     }
 
-    private func mapRowIdsToUniqueIds(db: Database,
-                                      rowIds: Set<RowId>,
-                                      uniqueIds: Set<UniqueId>,
-                                      rowIdToUniqueIdMap: [RowId: UniqueId],
-                                      tableName: String,
-                                      uniqueIdColumnName: String,
-                                      isMappingForThreads: Bool = false) throws -> Set<String> {
+    private func mapRowIdsToUniqueIds(
+        db: Database,
+        rowIds: Set<RowId>,
+        uniqueIds: MergingDict<UniqueId, ObservedModelState>,
+        rowIdToUniqueIdMap: [RowId: UniqueId],
+        tableName: String,
+        uniqueIdColumnName: String
+    ) throws -> MergingDict<UniqueId, ObservedModelState> {
         AssertHasDatabaseChangeObserverLock()
 
         // We try to avoid the query below by leveraging the
@@ -552,14 +647,7 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         var unresolvedRowIds = [RowId]()
         for rowId in rowIds {
             if let uniqueId = rowIdToUniqueIdMap[rowId] {
-                allUniqueIds.insert(uniqueId)
-                if isMappingForThreads, uniqueIdToShouldUpdateChatListUi[uniqueId] == nil {
-                    /// When we aren't sure whether a changed thread should trigger a
-                    /// chat list UI update, we want to do so to be safe. If there is
-                    /// already a value for this uniqueId in `uniqueIdToShouldUpdateChatListUi`,
-                    /// we can trust that this is correct and do not want to override it.
-                    uniqueIdToShouldUpdateChatListUi[uniqueId] = true
-                }
+                allUniqueIds.insert(uniqueId, .default)
             } else {
                 unresolvedRowIds.append(rowId)
             }
@@ -583,19 +671,8 @@ extension ObservedDatabaseChanges: DatabaseChanges {
         FROM \(tableName)
         WHERE rowid IN \(rowIdsSQL)
         """
-        let fetchedUniqueIds = try String.fetchAll(db, sql: mappingSql)
-        if isMappingForThreads {
-            for id in fetchedUniqueIds {
-                if uniqueIdToShouldUpdateChatListUi[id] == nil {
-                    /// When we aren't sure whether a changed thread should trigger a
-                    /// chat list UI update, we want to do so to be safe. If there is
-                    /// already a value for this uniqueId in `uniqueIdToShouldUpdateChatListUi`,
-                    /// we can trust that this is correct and do not want to override it.
-                    uniqueIdToShouldUpdateChatListUi[id] = true
-                }
-            }
-        }
-        allUniqueIds.formUnion(fetchedUniqueIds)
+        let fetchedUniqueIds = try String.fetchSet(db, sql: mappingSql)
+        allUniqueIds.formUnion(fetchedUniqueIds.asMergingDictWithUniformValue(.default))
 
         guard allUniqueIds.count < DatabaseChangeObserver.kMaxIncrementalRowChanges else {
             throw DatabaseObserverError.changeTooLarge
@@ -636,7 +713,7 @@ extension ObservedDatabaseChanges: DatabaseChanges {
                 owsFailDebug("Unknown table: \(tableName)")
                 continue
             }
-            append(collection: collection)
+            insert(collection: collection)
         }
     }
 }
@@ -645,3 +722,14 @@ public protocol SDSIdentifiableModel {
     var uniqueId: String { get }
     var grdbId: NSNumber? { get }
 }
+
+private extension Set {
+
+    func asMergingDictWithUniformValue<V>(_ value: V) -> MergingDict<Element, V> {
+        var dict = MergingDict<Element, V>()
+        self.forEach {
+            dict.insert($0, value)
+        }
+        return dict
+    }
+}
diff --git a/SignalServiceKit/src/Util/MergingDict.swift b/SignalServiceKit/src/Util/MergingDict.swift
new file mode 100644
index 00000000000..9d6404f4f71
--- /dev/null
+++ b/SignalServiceKit/src/Util/MergingDict.swift
@@ -0,0 +1,63 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public protocol Mergeable {
+    func merge(_ other: Self) -> Self
+}
+
+/// Just a wrapper around a dictionary that handles merging elements
+/// when an overwrite happens.
+public struct MergingDict<K, V> where K: Hashable, V: Mergeable {
+
+    private var dict = [K: V]()
+
+    public init() {}
+
+    public var keys: Set<K> {
+        return Set(dict.keys)
+    }
+
+    public func keys(where fn: (V) -> Bool) -> Set<K> {
+        var set = Set<K>()
+        dict.forEach { k, v in
+            if fn(v) {
+                set.insert(k)
+            }
+        }
+        return set
+    }
+
+    public subscript(_ key: K) -> V? {
+        get {
+            return dict[key]
+        }
+        set {
+            if let newValue {
+                insert(key, newValue)
+            } else {
+                dict[key] = nil
+            }
+        }
+    }
+
+    public var isEmpty: Bool { dict.isEmpty }
+    public var count: Int { dict.count }
+
+    public mutating func insert(_ key: K, _ value: V) {
+        guard let ourValue = dict[key] else {
+            dict[key] = value
+            return
+        }
+        dict[key] = ourValue.merge(value)
+    }
+
+    public mutating func formUnion(_ other: Self) {
+        for (k, v) in other.dict {
+            insert(k, v)
+        }
+    }
+}
