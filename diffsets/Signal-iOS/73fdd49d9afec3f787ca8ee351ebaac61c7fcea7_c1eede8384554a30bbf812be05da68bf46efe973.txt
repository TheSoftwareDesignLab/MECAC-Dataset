diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 4356c0b7dc3..cf0d609acac 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -17,6 +17,7 @@
 		14E4A340278EE999008408FD /* BlurredToolbarContainer.swift in Sources */ = {isa = PBXBuildFile; fileRef = 14E4A33F278EE999008408FD /* BlurredToolbarContainer.swift */; };
 		1700E33928B568200073D949 /* MediaGallerySections.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1700E33828B568200073D949 /* MediaGallerySections.swift */; };
 		1700E33B28B5684C0073D949 /* MediaGallerySectionsTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1700E33A28B5684C0073D949 /* MediaGallerySectionsTest.swift */; };
+		1700E34128BD41150073D949 /* SetAlgebra+SSK.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1700E34028BD41140073D949 /* SetAlgebra+SSK.swift */; };
 		1704690A25D4C326000793D8 /* SignalAttachmentTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1704690925D4C2E6000793D8 /* SignalAttachmentTest.swift */; };
 		1704690C25D4C92B000793D8 /* test-jpg-rotated.jpg in Resources */ = {isa = PBXBuildFile; fileRef = 1704690B25D4C92B000793D8 /* test-jpg-rotated.jpg */; };
 		173878BE256341BB00AD39C7 /* SessionMigrationPerfTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 173878BD256341BB00AD39C7 /* SessionMigrationPerfTest.swift */; };
@@ -2139,6 +2140,7 @@
 		14FD26DD3B40616C54CDBF1A /* Pods-SignalShareExtension.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalShareExtension.debug.xcconfig"; path = "Pods/Target Support Files/Pods-SignalShareExtension/Pods-SignalShareExtension.debug.xcconfig"; sourceTree = "<group>"; };
 		1700E33828B568200073D949 /* MediaGallerySections.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MediaGallerySections.swift; sourceTree = "<group>"; };
 		1700E33A28B5684C0073D949 /* MediaGallerySectionsTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MediaGallerySectionsTest.swift; sourceTree = "<group>"; };
+		1700E34028BD41140073D949 /* SetAlgebra+SSK.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "SetAlgebra+SSK.swift"; sourceTree = "<group>"; };
 		1704690925D4C2E6000793D8 /* SignalAttachmentTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SignalAttachmentTest.swift; sourceTree = "<group>"; };
 		1704690B25D4C92B000793D8 /* test-jpg-rotated.jpg */ = {isa = PBXFileReference; lastKnownFileType = image.jpeg; path = "test-jpg-rotated.jpg"; sourceTree = "<group>"; };
 		173878BD256341BB00AD39C7 /* SessionMigrationPerfTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SessionMigrationPerfTest.swift; sourceTree = "<group>"; };
@@ -8042,6 +8044,7 @@
 				F9C5CB26289453B200548EEE /* ReverseDispatchQueue.swift */,
 				F9C5CB1C289453B200548EEE /* SDS+SSK.swift */,
 				F9C5CB7B289453B200548EEE /* Sequence+OWS.swift */,
+				1700E34028BD41140073D949 /* SetAlgebra+SSK.swift */,
 				F9C5CB71289453B200548EEE /* SSKAsserts.h */,
 				F9C5CB47289453B200548EEE /* SSKPreferences.swift */,
 				F9C5CB12289453B200548EEE /* StorageService.swift */,
@@ -10827,6 +10830,7 @@
 				F9C5CE4C289453B400548EEE /* Sequence+OWS.swift in Sources */,
 				F9C5CC96289453B300548EEE /* SessionRecord.pb.swift in Sources */,
 				F9C5CD35289453B300548EEE /* SessionRecordMigration.swift in Sources */,
+				1700E34128BD41150073D949 /* SetAlgebra+SSK.swift in Sources */,
 				F9C5CCBE289453B300548EEE /* SGXContactDiscoveryOperation.swift in Sources */,
 				F9C5CCC6289453B300548EEE /* SignalAccount+SDS.swift in Sources */,
 				F9C5CCD9289453B300548EEE /* SignalAccount.m in Sources */,
diff --git a/Signal/src/Calls/CallService.swift b/Signal/src/Calls/CallService.swift
index 5e273b7d0c4..f9b70351015 100644
--- a/Signal/src/Calls/CallService.swift
+++ b/Signal/src/Calls/CallService.swift
@@ -561,8 +561,7 @@ public final class CallService: LightweightCallManager {
         // safe to do so.
         if call.groupCall.localDeviceState.joinState == .notJoined { call.groupCall.join() }
 
-        let callKnownToBeInProgress = call.groupCall.peekInfo?.joinedMembers.isEmpty == false
-        if !callKnownToBeInProgress && call.ringMode == .allowed && call.userWantsToRing {
+        if call.ringRestrictions.isEmpty && call.userWantsToRing {
             call.groupCall.ringAll()
         }
     }
diff --git a/Signal/src/Calls/SignalCall.swift b/Signal/src/Calls/SignalCall.swift
index f1e16a7f819..66796e00f22 100644
--- a/Signal/src/Calls/SignalCall.swift
+++ b/Signal/src/Calls/SignalCall.swift
@@ -109,18 +109,24 @@ public class SignalCall: NSObject, CallManagerCallReference {
     @objc
     public let thread: TSThread
 
-    public enum RingMode {
+    internal struct RingRestrictions: OptionSet {
+        var rawValue: UInt8
+
         /// The user does not get to choose whether this kind of call rings.
-        case notApplicable
+        static let notApplicable = Self(rawValue: 1 << 0)
+        /// The user cannot ring because there is already a call in progress.
+        static let callInProgress = Self(rawValue: 1 << 1)
         /// This group is too large to allow ringing.
-        case groupTooLarge
-        /// The user can choose whether to ring or not.
-        case allowed
+        static let groupTooLarge = Self(rawValue: 1 << 2)
     }
 
-    public var ringMode: RingMode {
+    internal var ringRestrictions: RingRestrictions {
         didSet {
             AssertIsOnMainThread()
+            if ringRestrictions != oldValue && groupCall.localDeviceState.joinState == .notJoined {
+                // Use a fake local state change to refresh the call controls.
+                self.groupCall(onLocalDeviceStateChanged: groupCall)
+            }
         }
     }
 
@@ -170,13 +176,25 @@ public class SignalCall: NSObject, CallManagerCallReference {
         )
         thread = groupThread
         if !RemoteConfig.groupRings {
-            ringMode = .notApplicable
-        } else if groupThread.groupModel.groupMembers.count > RemoteConfig.maxGroupCallRingSize {
-            ringMode = .groupTooLarge
+            ringRestrictions = .notApplicable
         } else {
-            ringMode = .allowed
+            ringRestrictions = []
+            if groupThread.groupModel.groupMembers.count > RemoteConfig.maxGroupCallRingSize {
+                ringRestrictions.insert(.groupTooLarge)
+            }
+        }
+
+        // Track the callInProgress restriction regardless; we use that for purposes other than rings.
+        let hasActiveCallMessage = Self.databaseStorage.read { transaction -> Bool in
+            !GRDBInteractionFinder.unendedCallsForGroupThread(groupThread, transaction: transaction).isEmpty
+        }
+        if hasActiveCallMessage {
+            // This info may be out of date, but the first peek will update it.
+            ringRestrictions.insert(.callInProgress)
         }
+
         super.init()
+
         groupCall.delegate = self
         // Watch group membership changes.
         // The object is the group thread ID, which is a string.
@@ -195,7 +213,7 @@ public class SignalCall: NSObject, CallManagerCallReference {
             behavior: .call
         )
         thread = individualCall.thread
-        ringMode = .notApplicable
+        ringRestrictions = .notApplicable
         super.init()
         individualCall.delegate = self
     }
@@ -269,7 +287,8 @@ public class SignalCall: NSObject, CallManagerCallReference {
     private func groupMembershipDidChange(_ notification: Notification) {
         // NotificationCenter dispatches by object identity rather than equality,
         // so we filter based on the thread ID here.
-        guard ringMode != .notApplicable, self.thread.uniqueId == notification.object as? String else {
+        guard !ringRestrictions.contains(.notApplicable),
+              self.thread.uniqueId == notification.object as? String else {
             return
         }
         databaseStorage.read { transaction in
@@ -280,16 +299,8 @@ public class SignalCall: NSObject, CallManagerCallReference {
             return
         }
 
-        let oldRingMode = ringMode
-        if groupModel.groupMembers.count > RemoteConfig.maxGroupCallRingSize {
-            ringMode = .groupTooLarge
-        } else {
-            ringMode = .allowed
-        }
-        if ringMode != oldRingMode && groupCall.localDeviceState.joinState == .notJoined {
-            // Use a fake local state change to refresh the call controls.
-            self.groupCall(onLocalDeviceStateChanged: groupCall)
-        }
+        let isGroupTooLarge = groupModel.groupMembers.count > RemoteConfig.maxGroupCallRingSize
+        ringRestrictions.update(.groupTooLarge, present: isGroupTooLarge)
     }
 
     // MARK: -
@@ -364,6 +375,11 @@ extension SignalCall: GroupCallDelegate {
     }
 
     public func groupCall(onPeekChanged groupCall: GroupCall) {
+        if let peekInfo = groupCall.peekInfo {
+            // Note that we track this regardless of whether ringing is available.
+            // There are other places that use this.
+            ringRestrictions.update(.callInProgress, present: peekInfo.deviceCount > 0)
+        }
         observers.elements.forEach { $0.groupCallPeekChanged(self) }
     }
 
diff --git a/Signal/src/Calls/UserInterface/CallControls.swift b/Signal/src/Calls/UserInterface/CallControls.swift
index d1ad69eecee..32455a0063d 100644
--- a/Signal/src/Calls/UserInterface/CallControls.swift
+++ b/Signal/src/Calls/UserInterface/CallControls.swift
@@ -150,18 +150,17 @@ class CallControls: UIView {
         let hasExternalAudioInputs = callService.audioService.hasExternalInputs
         let isLocalVideoMuted = call.groupCall.isOutgoingVideoMuted
         let joinState = call.groupCall.localDeviceState.joinState
-        let devicesAlreadyInCall = call.groupCall.peekInfo?.deviceCount ?? 0
 
         flipCameraButton.isHidden = isLocalVideoMuted
         videoButton.isSelected = !isLocalVideoMuted
         muteButton.isSelected = call.groupCall.isOutgoingAudioMuted
 
-        ringButton.isHidden = joinState == .joined || devicesAlreadyInCall > 0 || call.ringMode == .notApplicable
+        ringButton.isHidden = joinState == .joined || call.ringRestrictions.intersects([.notApplicable, .callInProgress])
         // Leave the button visible but locked if joining, like the "join call" button.
         ringButton.isUserInteractionEnabled = joinState == .notJoined
-        ringButton.isSelected = call.ringMode == .allowed && call.userWantsToRing
+        ringButton.isSelected = call.ringRestrictions.isEmpty && call.userWantsToRing
         // Leave the button enabled so we can present an explanatory toast, but show it disabled.
-        ringButton.shouldDrawAsDisabled = call.ringMode != .allowed
+        ringButton.shouldDrawAsDisabled = !call.ringRestrictions.isEmpty
 
         hangUpButton.isHidden = joinState != .joined
 
@@ -235,7 +234,8 @@ class CallControls: UIView {
             let startCallText = NSLocalizedString("GROUP_CALL_START_BUTTON", comment: "Button to start a group call")
             let joinCallText = NSLocalizedString("GROUP_CALL_JOIN_BUTTON", comment: "Button to join an ongoing group call")
 
-            joinButton.setTitle(devicesAlreadyInCall == 0 ? startCallText : joinCallText, for: .normal)
+            joinButton.setTitle(call.ringRestrictions.contains(.callInProgress) ? joinCallText : startCallText,
+                                for: .normal)
         }
     }
 
diff --git a/Signal/src/Calls/UserInterface/CallHeader.swift b/Signal/src/Calls/UserInterface/CallHeader.swift
index b7045f91c2f..6cbad48f101 100644
--- a/Signal/src/Calls/UserInterface/CallHeader.swift
+++ b/Signal/src/Calls/UserInterface/CallHeader.swift
@@ -232,9 +232,12 @@ class CallHeader: UIView {
                         tableName: "PluralAware",
                         comment: "Text explaining that there are three or more people in the group call. Embeds {{ %1$@ participantCount-2, %2$@ participant1, %3$@ participant2 }}"))
 
+            } else if call.groupCall.peekInfo == nil && call.ringRestrictions.contains(.callInProgress) {
+                // If we think there might already be a call, don't show anything until we have proper peek info.
+                callStatusText = ""
             } else {
                 let (memberCount, firstTwoNames) = fetchGroupSizeAndMemberNamesWithSneakyTransaction()
-                if call.ringMode == .allowed && call.userWantsToRing {
+                if call.ringRestrictions.isEmpty && call.userWantsToRing {
                     callStatusText = describeMembers(
                         count: memberCount,
                         names: firstTwoNames,
@@ -272,27 +275,29 @@ class CallHeader: UIView {
                     "GROUP_CALL_RECONNECTING",
                     comment: "Text indicating that the user has lost their connection to the call and we are reconnecting.")
 
-            } else if call.groupCall.remoteDeviceStates.isEmpty && call.ringMode == .allowed && call.userWantsToRing {
-                let (memberCount, firstTwoNames) = fetchGroupSizeAndMemberNamesWithSneakyTransaction()
-                callStatusText = describeMembers(
-                    count: memberCount,
-                    names: firstTwoNames,
-                    zeroMemberString: "",
-                    oneMemberFormat: NSLocalizedString(
-                        "GROUP_CALL_IS_RINGING_ONE_PERSON_FORMAT",
-                        comment: "Text shown before the user starts a group call if the user has enabled ringing and there is one other person in the group. Embeds {member name}"),
-                    twoMemberFormat: NSLocalizedString(
-                        "GROUP_CALL_IS_RINGING_TWO_PEOPLE_FORMAT",
-                        comment: "Text shown before the user starts a group call if the user has enabled ringing and there are two other people in the group. Embeds {{ %1$@ participant1, %2$@ participant2 }}"),
-                    manyMemberFormat: NSLocalizedString(
-                        "GROUP_CALL_IS_RINGING_MANY_PEOPLE_%d",
-                        tableName: "PluralAware",
-                        comment: "Text shown before the user starts a group call if the user has enabled ringing and there are three or more other people in the group. Embeds {{ %1$@ participantCount-2, %2$@ participant1, %3$@ participant2 }}"))
-
             } else if call.groupCall.remoteDeviceStates.isEmpty {
-                callStatusText = NSLocalizedString(
-                    "GROUP_CALL_NO_ONE_HERE",
-                    comment: "Text explaining that you are the only person currently in the group call")
+                if call.ringRestrictions.isEmpty && call.userWantsToRing {
+                    let (memberCount, firstTwoNames) = fetchGroupSizeAndMemberNamesWithSneakyTransaction()
+                    callStatusText = describeMembers(
+                        count: memberCount,
+                        names: firstTwoNames,
+                        zeroMemberString: "",
+                        oneMemberFormat: NSLocalizedString(
+                            "GROUP_CALL_IS_RINGING_ONE_PERSON_FORMAT",
+                            comment: "Text shown before the user starts a group call if the user has enabled ringing and there is one other person in the group. Embeds {member name}"),
+                        twoMemberFormat: NSLocalizedString(
+                            "GROUP_CALL_IS_RINGING_TWO_PEOPLE_FORMAT",
+                            comment: "Text shown before the user starts a group call if the user has enabled ringing and there are two other people in the group. Embeds {{ %1$@ participant1, %2$@ participant2 }}"),
+                        manyMemberFormat: NSLocalizedString(
+                            "GROUP_CALL_IS_RINGING_MANY_PEOPLE_%d",
+                            tableName: "PluralAware",
+                            comment: "Text shown before the user starts a group call if the user has enabled ringing and there are three or more other people in the group. Embeds {{ %1$@ participantCount-2, %2$@ participant1, %3$@ participant2 }}"))
+
+                } else {
+                    callStatusText = NSLocalizedString(
+                        "GROUP_CALL_NO_ONE_HERE",
+                        comment: "Text explaining that you are the only person currently in the group call")
+                }
 
             } else {
                 let callDuration = call.connectionDuration()
diff --git a/Signal/src/Calls/UserInterface/Group/GroupCallViewController.swift b/Signal/src/Calls/UserInterface/Group/GroupCallViewController.swift
index 9438d7978dd..4e29e02963c 100644
--- a/Signal/src/Calls/UserInterface/Group/GroupCallViewController.swift
+++ b/Signal/src/Calls/UserInterface/Group/GroupCallViewController.swift
@@ -649,8 +649,7 @@ extension GroupCallViewController: CallViewControllerWindowReference {
         let approveText: String
         let denyText: String
         if localDeviceHasNotJoined {
-            let deviceCount = call.groupCall.peekInfo?.deviceCount ?? 0
-            approveText = deviceCount > 0 ? joinCallString : startCallString
+            approveText = call.ringRestrictions.contains(.callInProgress) ? joinCallString : startCallString
             denyText = cancelString
         } else {
             approveText = continueCallString
@@ -779,13 +778,7 @@ extension GroupCallViewController: CallControlsDelegate {
     }
 
     func didPressRing(sender: UIButton) {
-        switch call.ringMode {
-        case .notApplicable:
-            owsFailDebug("should not show the ring button at all")
-        case .groupTooLarge:
-            let toast = ToastController(text: NSLocalizedString("GROUP_CALL_TOO_LARGE_TO_RING", comment: "Text displayed when trying to turn on ringing when calling a large group."))
-            toast.presentToastView(from: .top, of: view, inset: view.safeAreaInsets.top + 8)
-        case .allowed:
+        if call.ringRestrictions.isEmpty {
             let oldShouldRing = sender.isSelected
             let newShouldRing = !oldShouldRing
             sender.isSelected = newShouldRing
@@ -793,6 +786,15 @@ extension GroupCallViewController: CallControlsDelegate {
 
             // Refresh the call header.
             callHeader.groupCallLocalDeviceStateChanged(call)
+        } else {
+            if call.ringRestrictions.intersects([.notApplicable, .callInProgress]) {
+                owsFailDebug("should not show the ring button at all")
+            } else if call.ringRestrictions.contains(.groupTooLarge) {
+                let toast = ToastController(text: NSLocalizedString("GROUP_CALL_TOO_LARGE_TO_RING", comment: "Text displayed when trying to turn on ringing when calling a large group."))
+                toast.presentToastView(from: .top, of: view, inset: view.safeAreaInsets.top + 8)
+            } else {
+                owsAssertDebug(call.ringRestrictions.isEmpty, "unknown ring restriction")
+            }
         }
     }
 
diff --git a/SignalServiceKit/src/Util/SetAlgebra+SSK.swift b/SignalServiceKit/src/Util/SetAlgebra+SSK.swift
new file mode 100644
index 00000000000..86e67fb845f
--- /dev/null
+++ b/SignalServiceKit/src/Util/SetAlgebra+SSK.swift
@@ -0,0 +1,25 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public extension SetAlgebra {
+    /// Returns `true` if `self` and `other` have any elements in common.
+    @inlinable
+    func intersects(_ other: Self) -> Bool {
+        !self.isDisjoint(with: other)
+    }
+
+    /// Inserts `element` into the set if `present` is `true`; otherwise removes it.
+    ///
+    /// Returns the equivalent element that was previously in the set, if there was one.
+    @discardableResult @inlinable
+    mutating func update(_ element: Element, present: Bool) -> Element? {
+        if present {
+            return self.update(with: element)
+        } else {
+            return self.remove(element)
+        }
+    }
+}
