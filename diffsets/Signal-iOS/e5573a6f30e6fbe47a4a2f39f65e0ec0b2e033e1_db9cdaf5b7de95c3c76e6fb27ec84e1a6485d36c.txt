diff --git a/SignalMessaging/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift b/SignalMessaging/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
index c6a7f477029..181051c4aed 100644
--- a/SignalMessaging/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
+++ b/SignalMessaging/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
@@ -658,9 +658,9 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
             return editedAttachmentPromise(imageEditorModel: imageEditorModel,
                                            attachmentApprovalItem: attachmentApprovalItem)
         }
-        if let videoEditorModel = attachmentApprovalItem.videoEditorModel, videoEditorModel.isTrimmed {
-            return trimmedAttachmentPromise(videoEditorModel: videoEditorModel,
-                                            attachmentApprovalItem: attachmentApprovalItem)
+        if let videoEditorModel = attachmentApprovalItem.videoEditorModel, videoEditorModel.needsRender {
+            return renderedAttachmentPromise(videoEditorModel: videoEditorModel,
+                                             attachmentApprovalItem: attachmentApprovalItem)
         }
         // No editor applies. Use original, un-edited attachment.
         return Promise.value(attachmentApprovalItem.attachment)
@@ -726,33 +726,33 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
     // If any errors occurs in the export process, we fail over to
     // sending the original attachment.  This seems better than trying
     // to involve the user in resolving the issue.
-    func trimmedAttachmentPromise(videoEditorModel: VideoEditorModel,
+    func renderedAttachmentPromise(videoEditorModel: VideoEditorModel,
                                   attachmentApprovalItem: AttachmentApprovalItem) -> Promise<SignalAttachment> {
-        assert(videoEditorModel.isTrimmed)
-        return videoEditorModel.ensureCurrentRender().consumingFilePromise()
-            .map(on: DispatchQueue.global()) { filePath in
-                guard let fileExtension = filePath.fileExtension else {
-                    throw OWSAssertionError("Missing fileExtension.")
-                }
-                guard let dataUTI = MIMETypeUtil.utiType(forFileExtension: fileExtension) else {
-                    throw OWSAssertionError("Missing dataUTI.")
-                }
-                let dataSource = try DataSourcePath.dataSource(withFilePath: filePath, shouldDeleteOnDeallocation: true)
-                // Rewrite the filename's extension to reflect the output file format.
-                var filename: String? = attachmentApprovalItem.attachment.sourceFilename
-                if let sourceFilename = attachmentApprovalItem.attachment.sourceFilename {
-                    filename = (sourceFilename as NSString).deletingPathExtension.appendingFileExtension(fileExtension)
-                }
-                dataSource.sourceFilename = filename
+        assert(videoEditorModel.needsRender)
+        return videoEditorModel.ensureCurrentRender().result.map(on: .sharedUserInitiated) { result in
+            let filePath = try result.consumeResultPath()
+            guard let fileExtension = filePath.fileExtension else {
+                throw OWSAssertionError("Missing fileExtension.")
+            }
+            guard let dataUTI = MIMETypeUtil.utiType(forFileExtension: fileExtension) else {
+                throw OWSAssertionError("Missing dataUTI.")
+            }
+            let dataSource = try DataSourcePath.dataSource(withFilePath: filePath, shouldDeleteOnDeallocation: true)
+            // Rewrite the filename's extension to reflect the output file format.
+            var filename: String? = attachmentApprovalItem.attachment.sourceFilename
+            if let sourceFilename = attachmentApprovalItem.attachment.sourceFilename {
+                filename = (sourceFilename as NSString).deletingPathExtension.appendingFileExtension(fileExtension)
+            }
+            dataSource.sourceFilename = filename
 
-                let dstAttachment = SignalAttachment.attachment(dataSource: dataSource, dataUTI: dataUTI, imageQuality: .original)
-                if let attachmentError = dstAttachment.error {
-                    throw OWSAssertionError("Could not prepare attachment for output: \(attachmentError).")
-                }
-                // Preserve caption text.
-                dstAttachment.captionText = attachmentApprovalItem.captionText
-                dstAttachment.isViewOnceAttachment = attachmentApprovalItem.attachment.isViewOnceAttachment
-                return dstAttachment
+            let dstAttachment = SignalAttachment.attachment(dataSource: dataSource, dataUTI: dataUTI, imageQuality: .original)
+            if let attachmentError = dstAttachment.error {
+                throw OWSAssertionError("Could not prepare attachment for output: \(attachmentError).")
+            }
+            // Preserve caption text.
+            dstAttachment.captionText = attachmentApprovalItem.captionText
+            dstAttachment.isViewOnceAttachment = attachmentApprovalItem.attachment.isViewOnceAttachment
+            return dstAttachment
         }
     }
 
diff --git a/SignalMessaging/Views/VideoEditor/VideoEditorModel.swift b/SignalMessaging/Views/VideoEditor/VideoEditorModel.swift
index c246b548bc8..91bb2494399 100644
--- a/SignalMessaging/Views/VideoEditor/VideoEditorModel.swift
+++ b/SignalMessaging/Views/VideoEditor/VideoEditorModel.swift
@@ -6,10 +6,6 @@ import UIKit
 import AVFoundation
 import PromiseKit
 
-public enum VideoEditorError: Error {
-    case cancelled
-}
-
 @objc
 public protocol VideoEditorModelObserver: class {
     func videoEditorModelDidChange(_ model: VideoEditorModel)
@@ -19,6 +15,7 @@ public protocol VideoEditorModelObserver: class {
 
 @objc
 public class VideoEditorModel: NSObject {
+    private let lock = UnfairLock()
 
     @objc
     public let srcVideoPath: String
@@ -168,6 +165,30 @@ public class VideoEditorModel: NSObject {
 
     // MARK: - Rendering
 
+    public var needsRender: Bool { isTrimmed }
+    fileprivate var currentRender: Render?
+
+    // Whenever the model state changes, we need to discard any ongoing render.
+    private func clearRender() {
+        lock.withLock {
+            currentRender?.cancel()
+            currentRender = nil
+        }
+    }
+
+    // This method can be used to access the rendered output.
+    // It can also be used to eagerly initiate a render (if
+    // necessary) to reduce perceived render time.
+    public func ensureCurrentRender() -> Render {
+        lock.withLock {
+            let render = self.currentRender ?? Render(model: self)
+            self.currentRender = render
+            return render
+        }
+    }
+}
+
+extension VideoEditorModel {
     // Represents an attempt to render the output.
     // Contains a copy of the model state at the
     // time the render is enqueued.
@@ -178,219 +199,148 @@ public class VideoEditorModel: NSObject {
         fileprivate let trimmedDurationSeconds: TimeInterval
         fileprivate let isTrimmed: Bool
 
-        fileprivate let promise: Promise<String>
-        fileprivate let resolver: Resolver<String>
-
-        // This property should only be accessed on VideoEditorModel.serialQueue.
-        private var exportSession: AVAssetExportSession?
-
         // Until the render is consumed, it is the responsibility of this
         // class to clean up its temp files.
-        private let isConsumed = AtomicBool(false)
+        private var lock = UnfairLock()
+        private var exportSession: AVAssetExportSession?
 
-        required init(model: VideoEditorModel) {
-            self.srcVideoPath = model.srcVideoPath
-            self.untrimmedDuration = model.untrimmedDuration
-            self.trimmedStartSeconds = model.trimmedStartSeconds
-            self.trimmedDurationSeconds = model.trimmedDurationSeconds
-            self.isTrimmed = model.isTrimmed
+        class Result {
+            private let lock = UnfairLock()
+            private let path: String
 
-            let (promise, resolver) = Promise<String>.pending()
-            self.promise = promise
-            self.resolver = resolver
-        }
+            /// If `true`, the `Result` is responsible for cleaning up the file at `path` in `deinit`
+            /// If `false`, the `Result` has either relinquished ownership or never had it to begin with. Nothing to do in `deinit`
+            private var isOwned = false
 
-        deinit {
-            guard !isConsumed.get() else {
-                return
+            fileprivate init(path: String, owned: Bool = true) {
+                self.path = path
+                self.isOwned = owned
             }
 
-            _ = promise.done(on: DispatchQueue.global()) { filePath in
+            deinit {
+                guard isOwned else { return }
+
                 do {
-                    try FileManager.default.removeItem(at: URL(fileURLWithPath: filePath))
+                    try FileManager.default.removeItem(at: URL(fileURLWithPath: path))
                 } catch {
                     owsFailDebug("Error: \(error)")
                 }
             }
-        }
 
-        // consumableFilePromise
 
-        // Returns a promise that yields a file path
-        // for the output video file path.  The caller
-        // has responsibility for cleaning up this file.
-        public func consumingFilePromise() -> Promise<String> {
-            if isConsumed.get() {
-                owsFailDebug("File is already consumed.")
+            /// Returns an unowned reference to the render output file. This path is valid as long as the `Result`
+            /// is valid and file has not been consumed by `consumeResultPath()`. Caller should make a copy
+            /// of this file if they'd like the render result to outlive these events.
+            public func getResultPath() -> String {
+                lock.withLock {
+                    // Something else has already taken ownership of this file
+                    // It's probably still valid, but worth flagging as an issue.
+                    owsAssertDebug(isOwned, "Result file externally owned")
+                }
+                return path
             }
-            isConsumed.set(true)
-            return promise
-        }
 
-        // Returns a promise that yields a file path
-        // for the output video file path.  The caller
-        // does not have responsibility for cleaning up this file.
-        public func nonconsumingFilePromise() -> Promise<String> {
-            if isConsumed.get() {
-                owsFailDebug("File is already consumed.")
+            /// Returns a path to the render result. Receiver is responsible for deleting the resulting file
+            /// This should be called once at most
+            public func consumeResultPath() throws -> String {
+                // Since the path is being consumed, we no longer own it.
+                // If we didn't already own it, we should make a copy of the unowned filepath
+                // It's incorrect and worthy of a failDebug, but it's also probably still valid.
+                // In that case, we make a copy so that the receiver can take ownership
+                let shouldCopy: Bool = lock.withLock {
+                    owsAssertDebug(isOwned, "Result file externally owned")
+                    let wasAlreadyOwned = isOwned
+                    isOwned = false
+                    return !wasAlreadyOwned
+                }
+
+                if shouldCopy {
+                    let dstFilePath = OWSFileSystem.temporaryFilePath(fileExtension: "mp4")
+                    try FileManager.default.copyItem(atPath: path, toPath: dstFilePath)
+                    return dstFilePath
+                } else {
+                    return path
+                }
             }
-            return promise
         }
 
-        fileprivate func set(exportSession: AVAssetExportSession) {
-            assertOnQueue(VideoEditorModel.serialQueue)
+        lazy var result: Promise<Result> = {
+            guard isTrimmed else {
+                // This is really just a failsafe. If we're not trimmed, there's no need to render.
+                // If someone accesses the underlying path in the Result, they'll fail debug, but we'll
+                // otherwise try and behave as correct as possible, copying the underlying file as necessary.
+                return .value(Result(path: srcVideoPath, owned: false))
+            }
 
-            self.exportSession = exportSession
-        }
+            return firstly(on: .sharedUserInitiated) { () -> Promise<Result> in
+                let asset = AVURLAsset(url: URL(fileURLWithPath: self.srcVideoPath))
+                let dstFilePath = OWSFileSystem.temporaryFilePath(fileExtension: "mp4")
 
-        // This method should only be accessed on VideoEditorModel.serialQueue.
-        fileprivate func cancel() {
-            assertOnQueue(VideoEditorModel.serialQueue)
+                let session: AVAssetExportSession = try self.lock.withLock {
+                    guard self.exportSession == nil else { throw OWSAssertionError("Duplicate session") }
 
-            guard let exportSession = self.exportSession else {
-                return
-            }
-            exportSession.cancelExport()
-        }
-    }
+                    guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetPassthrough) else {
+                        throw OWSAssertionError("Could not create export session.")
+                    }
 
-    fileprivate static let serialQueue: DispatchQueue = DispatchQueue(label: "VideoEditorModel.serialQueue")
-    // This property should only be accessed on serialQueue.
-    fileprivate var currentRender: Render?
-    // This operation queue ensures that only one render operation is
-    // running at a given time.
-    private static let renderOperationQueue: OperationQueue = {
-        let operationQueue = OperationQueue()
-        operationQueue.name = "VideoEditorModel.renderOperationQueue"
-        operationQueue.maxConcurrentOperationCount = 1
-        return operationQueue
-    }()
+                    self.exportSession = exportSession
+                    return exportSession
+                }
 
-    // Whenever the model state changes, we need to discard any ongoing render.
-    private func clearRender() {
-        VideoEditorModel.serialQueue.sync {
-            guard let render = self.currentRender else {
-                return
+                session.outputURL = URL(fileURLWithPath: dstFilePath)
+                // This will ensure that the MP4 moov atom (movie atom)
+                // is located at the beginning of the file. That may help
+                // recipients validate incoming videos.
+                session.shouldOptimizeForNetworkUse = true
+                session.outputFileType = AVFileType.mp4
+                // Preserve the original timescale.
+                let cmStart: CMTime = CMTime(seconds: self.trimmedStartSeconds, preferredTimescale: self.untrimmedDuration.timescale)
+                let cmDuration: CMTime = CMTime(seconds: self.trimmedDurationSeconds, preferredTimescale: self.untrimmedDuration.timescale)
+                let cmRange: CMTimeRange = CMTimeRange(start: cmStart, duration: cmDuration)
+                session.timeRange = cmRange
+
+                return session.exportPromise().map { path in
+                    Result(path: path, owned: true)
+                }.recover(policy: .allErrorsExceptCancellation) { error -> Promise<Result> in
+                    owsFailDebug("Export failed: \(error)")
+                    throw error
+                }
             }
-            render.cancel()
-            self.currentRender = nil
-        }
-    }
+        }()
 
-    // This method can be used to access the rendered output.
-    // It can also be used to eagerly initiate a render (if
-    // necessary) to reduce perceived render time.
-    public func ensureCurrentRender() -> Render {
-        return VideoEditorModel.serialQueue.sync {
-            if let currentRender = self.currentRender {
-                return currentRender
-            }
-            let render = Render(model: self)
-            self.currentRender = render
+        required init(model: VideoEditorModel) {
+            self.srcVideoPath = model.srcVideoPath
+            self.untrimmedDuration = model.untrimmedDuration
+            self.trimmedStartSeconds = model.trimmedStartSeconds
+            self.trimmedDurationSeconds = model.trimmedDurationSeconds
+            self.isTrimmed = model.isTrimmed
+        }
 
-            // Enqueue an operation to process the render.
-            let operationQueue = VideoEditorModel.renderOperationQueue
-            let operation = TrimVideoOperation(model: self, render: render)
-            operationQueue.addOperation(operation)
+        func beginRender() {
+            _ = result
+        }
 
-            return render
+        func cancel() {
+            lock.withLock {
+                exportSession?.cancelExport()
+            }
         }
     }
 }
 
-// MARK: -
-
-private class TrimVideoOperation: OWSOperation {
-
-    private let model: VideoEditorModel
-    private let render: VideoEditorModel.Render
-
-    fileprivate required init(model: VideoEditorModel,
-                              render: VideoEditorModel.Render) {
-        self.model = model
-        self.render = render
-    }
-
-    public override func run() {
-        Logger.debug("")
-
-        let (promise, resolver) = Promise<String>.pending()
-        DispatchQueue.global().async {
-            let currentRender = VideoEditorModel.serialQueue.sync {
-                return self.model.currentRender
-            }
-            guard self.render === currentRender else {
-                // Renders can take quite a while, so it's important to skip
-                // renders that are no longer necessary.
-                resolver.reject(OWSAssertionError("Skipping stale render."))
-                return
-            }
-            let render = self.render
-            guard render.isTrimmed else {
-                // Video editor has no changes.
-                owsFailDebug("calling no-op render. Instead copy the file.")
-                // When rendering a new file, the caller is given a URL that they "own" - that is the
-                // caller can then `consume` it, and must delete on deallocation if they don't.
-                //
-                // However here we return the existing URL, which violates that contract - two entities
-                // now own the original file. In practice, I think we're no longer hitting this code
-                // path, but I'm leaving this here for resiliency.
-                resolver.fulfill(render.srcVideoPath)
-                return
-            }
-
-            let asset = AVURLAsset(url: URL(fileURLWithPath: render.srcVideoPath))
-            let dstFilePath = OWSFileSystem.temporaryFilePath(fileExtension: "mp4")
-
-            // AVAssetExportPresetPassthrough maintains the source quality.
-            guard let exportSession = AVAssetExportSession(asset: asset, presetName: AVAssetExportPresetPassthrough) else {
-                resolver.reject(OWSAssertionError("Could not create export session."))
-                return
-            }
-            VideoEditorModel.serialQueue.sync {
-                render.set(exportSession: exportSession)
-            }
-
-            exportSession.outputURL = URL(fileURLWithPath: dstFilePath)
-            // This will ensure that the MP4 moov atom (movie atom)
-            // is located at the beginning of the file. That may help
-            // recipients validate incoming videos.
-            exportSession.shouldOptimizeForNetworkUse = true
-            exportSession.outputFileType = AVFileType.mp4
-            // Preserve the original timescale.
-            let cmStart: CMTime = CMTime(seconds: render.trimmedStartSeconds, preferredTimescale: render.untrimmedDuration.timescale)
-            let cmDuration: CMTime = CMTime(seconds: render.trimmedDurationSeconds, preferredTimescale: render.untrimmedDuration.timescale)
-            let cmRange: CMTimeRange = CMTimeRange(start: cmStart, duration: cmDuration)
-            exportSession.timeRange = cmRange
-
-            exportSession.exportAsynchronously {
-                switch exportSession.status {
-                case .completed:
-                    resolver.fulfill(dstFilePath)
-                case .cancelled:
-                    resolver.reject(VideoEditorError.cancelled)
+fileprivate extension AVAssetExportSession {
+    func exportPromise() -> Promise<String> {
+        Promise { resolver in
+            exportAsynchronously {
+                switch (self.status, self.outputURL?.path) {
+                case (.completed, let path?):
+                    resolver.fulfill(path)
+                case (.cancelled, _):
+                    resolver.reject(PMKError.cancelled)
                 default:
-                    resolver.reject(OWSAssertionError("Status: \(exportSession.status)"))
-                }
-            }
-        }
-        promise.done { filePath in
-            self.render.resolver.fulfill(filePath)
-            self.reportSuccess()
-        }.catch { error in
-            if case VideoEditorError.cancelled = error {
-                // operation was cancelled - this is normal.
-            } else {
-                owsFailDebug("Error: \(error)")
-            }
-            self.render.resolver.reject(error)
-            VideoEditorModel.serialQueue.sync {
-                // Discard failed render.
-                if self.model.currentRender === self.render {
-                    self.model.currentRender = nil
+                    resolver.reject(OWSAssertionError("Status \(self.status)"))
                 }
             }
-            self.reportError(withUndefinedRetry: error)
         }
     }
 }
diff --git a/SignalMessaging/Views/VideoEditor/VideoEditorView.swift b/SignalMessaging/Views/VideoEditor/VideoEditorView.swift
index 4e3bc31b74c..5230fd490ea 100644
--- a/SignalMessaging/Views/VideoEditor/VideoEditorView.swift
+++ b/SignalMessaging/Views/VideoEditor/VideoEditorView.swift
@@ -335,30 +335,35 @@ public class VideoEditorView: UIView {
 
     private func saveVideoPromise() -> Promise<Void> {
         return firstly { () -> Promise<String> in
-            if model.isTrimmed {
-                return self.model.ensureCurrentRender().nonconsumingFilePromise()
-            } else {
-                return Promise.value(self.model.srcVideoPath)
-            }
-        }.then(on: .global()) { (videoFilePath: String) -> Promise<Void> in
-            guard let fileExtension = videoFilePath.fileExtension else {
-                return Promise(error: OWSAssertionError("Missing fileExtension."))
+            // Copy the file so it won't be changed between now and the then block
+            // Then block is responsible for deleting the temp file
+            let makeCopy = { (srcPath: String) throws -> String in
+                guard let fileExtension = srcPath.fileExtension else {
+                    throw OWSAssertionError("Missing fileExtension.")
+                }
+                let dstPath = OWSFileSystem.temporaryFilePath(fileExtension: fileExtension)
+                try FileManager.default.copyItem(atPath: srcPath, toPath: dstPath)
+                return dstPath
             }
-            let tempFilePath = OWSFileSystem.temporaryFilePath(fileExtension: fileExtension)
-            do {
-                try FileManager.default.copyItem(atPath: videoFilePath, toPath: tempFilePath)
-            } catch {
-                return Promise(error: error)
+
+            if model.needsRender {
+                return self.model.ensureCurrentRender().result.map { result -> String in
+                    try makeCopy(result.getResultPath())
+                }
+            } else {
+                let copy = try makeCopy(self.model.srcVideoPath)
+                return .value(copy)
             }
 
-            let videoUrl = URL(fileURLWithPath: tempFilePath)
+        }.then(on: .sharedUtility) { (videoFilePath: String) -> Promise<Void> in
+            let videoUrl = URL(fileURLWithPath: videoFilePath)
 
             return Promise<Void> { resolver in
                 PHPhotoLibrary.shared().performChanges({
                     PHAssetCreationRequest.creationRequestForAssetFromVideo(atFileURL: videoUrl)
                 }) { didSucceed, error in
 
-                    OWSFileSystem.deleteFileIfExists(tempFilePath)
+                    OWSFileSystem.deleteFileIfExists(videoFilePath)
 
                     if let error = error {
                         resolver.reject(error)
