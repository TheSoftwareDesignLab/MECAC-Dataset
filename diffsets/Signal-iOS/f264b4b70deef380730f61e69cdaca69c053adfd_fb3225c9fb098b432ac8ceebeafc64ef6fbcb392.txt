diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 3763e0fa757..c8e74463dfb 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -821,7 +821,6 @@
 		763D7DDB27E155ED002EA7E6 /* RoundMediaButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 763D7DDA27E155ED002EA7E6 /* RoundMediaButton.swift */; };
 		763D7DDD27E25DC8002EA7E6 /* AttachmentApprovalTopBar.swift in Sources */ = {isa = PBXBuildFile; fileRef = 763D7DDC27E25DC8002EA7E6 /* AttachmentApprovalTopBar.swift */; };
 		766035A9286CE4CB00F6B71C /* MediaTopBar.swift in Sources */ = {isa = PBXBuildFile; fileRef = 766035A8286CE4CB00F6B71C /* MediaTopBar.swift */; };
-		766035AB286FEC2F00F6B71C /* AttachmentPrepContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 766035AA286FEC2F00F6B71C /* AttachmentPrepContentView.swift */; };
 		7666D54428331E1100A3BDB9 /* ImageEditorViewController+Draw.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7666D54328331E1100A3BDB9 /* ImageEditorViewController+Draw.swift */; };
 		7666D54628331E4800A3BDB9 /* ImageEditorViewController+Blur.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7666D54528331E4800A3BDB9 /* ImageEditorViewController+Blur.swift */; };
 		7666D54828331E6900A3BDB9 /* ImageEditorViewController+Text.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7666D54728331E6900A3BDB9 /* ImageEditorViewController+Text.swift */; };
@@ -3135,7 +3134,6 @@
 		763D7DDA27E155ED002EA7E6 /* RoundMediaButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RoundMediaButton.swift; sourceTree = "<group>"; };
 		763D7DDC27E25DC8002EA7E6 /* AttachmentApprovalTopBar.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttachmentApprovalTopBar.swift; sourceTree = "<group>"; };
 		766035A8286CE4CB00F6B71C /* MediaTopBar.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaTopBar.swift; sourceTree = "<group>"; };
-		766035AA286FEC2F00F6B71C /* AttachmentPrepContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttachmentPrepContentView.swift; sourceTree = "<group>"; };
 		7666D54328331E1100A3BDB9 /* ImageEditorViewController+Draw.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ImageEditorViewController+Draw.swift"; sourceTree = "<group>"; };
 		7666D54528331E4800A3BDB9 /* ImageEditorViewController+Blur.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ImageEditorViewController+Blur.swift"; sourceTree = "<group>"; };
 		7666D54728331E6900A3BDB9 /* ImageEditorViewController+Text.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ImageEditorViewController+Text.swift"; sourceTree = "<group>"; };
@@ -5515,7 +5513,6 @@
 				763D7DDC27E25DC8002EA7E6 /* AttachmentApprovalTopBar.swift */,
 				34A9559C271B510500B05242 /* AttachmentApprovalViewController.swift */,
 				34A95598271B510500B05242 /* AttachmentItemCollection.swift */,
-				766035AA286FEC2F00F6B71C /* AttachmentPrepContentView.swift */,
 				34A95599271B510500B05242 /* AttachmentPrepViewController.swift */,
 				34A9559E271B510500B05242 /* AttachmentTextToolbar.swift */,
 				34A95597271B510500B05242 /* AttachmentTextView.swift */,
@@ -9785,7 +9782,6 @@
 				3402AA4A271D9DCD0084CBAE /* AttachmentApprovalViewController.swift in Sources */,
 				3402AA34271D9DCD0084CBAE /* AttachmentItemCollection.swift in Sources */,
 				3402A9EC271D98440084CBAE /* AttachmentMultisend.swift in Sources */,
-				766035AB286FEC2F00F6B71C /* AttachmentPrepContentView.swift in Sources */,
 				3402AA3D271D9DCD0084CBAE /* AttachmentPrepViewController.swift in Sources */,
 				34A954E7271B4F6A00B05242 /* AttachmentSharing.m in Sources */,
 				3402AA42271D9DCD0084CBAE /* AttachmentTextToolbar.swift in Sources */,
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalToolbar.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalToolbar.swift
index e397ab79050..2388d25ef27 100644
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalToolbar.swift
+++ b/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalToolbar.swift
@@ -255,6 +255,10 @@ class AttachmentApprovalToolbar: UIView {
 
 extension AttachmentApprovalToolbar: AttachmentTextToolbarDelegate {
 
+    func attachmentTextToolbarWillBeginEditing(_ attachmentTextToolbar: AttachmentTextToolbar) {
+        attachmentTextToolbarDelegate?.attachmentTextToolbarWillBeginEditing(attachmentTextToolbar)
+    }
+
     func attachmentTextToolbarDidBeginEditing(_ attachmentTextToolbar: AttachmentTextToolbar) {
         updateContents(animated: true)
         attachmentTextToolbarDelegate?.attachmentTextToolbarDidBeginEditing(attachmentTextToolbar)
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
index f4819c84528..310ef62551b 100644
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
+++ b/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
@@ -114,6 +114,9 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
 
     private var observerToken: NSObjectProtocol?
 
+    private var observingKeyboardNotifications = false
+    private var keyboardHeight: CGFloat = 0
+
     required public init(options: AttachmentApprovalViewControllerOptions,
                          attachmentApprovalItems: [AttachmentApprovalItem]) {
         assert(attachmentApprovalItems.count > 0)
@@ -276,8 +279,8 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
 
         updateContents(animated: false)
 
-        if let currentPageViewController = currentPageViewController {
-            self.updateContentLayoutMargins(for: currentPageViewController)
+        if let currentPageViewController {
+            updateContentLayoutMargins(for: currentPageViewController)
         }
     }
 
@@ -291,13 +294,14 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
         super.viewWillDisappear(animated)
 
         currentPageViewController?.prepareToMoveOffscreen()
+        stopObservingKeyboardNotifications()
     }
 
     public override func viewSafeAreaInsetsDidChange() {
         super.viewSafeAreaInsetsDidChange()
 
-        if let currentPageViewController = currentPageViewController {
-            self.updateContentLayoutMargins(for: currentPageViewController)
+        if let currentPageViewController {
+            updateContentLayoutMargins(for: currentPageViewController)
         }
     }
 
@@ -307,33 +311,32 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
         // does not create any changes to media's size and position.
         // However AttachmentPrepViewController's view is always full screen and is managed by UIPageViewController,
         // which makes it not possible to constrain any of its subviews to the bottom toolbar.
-        // The solution is to allow to set layout margins in AttachmentPrepViewController's view externally,
-        // which is achieved through use of AttachmentPrepContentView.contentLayoutMargins.
+        // The solution is to allow to set layout margins in AttachmentPrepViewController's view externally.
 
         var contentLayoutMargins: UIEdgeInsets = .zero
         // On devices with a screen notch at the top content is constrained to safe area inset so that status bar is visible.
-        // On all other devices content is pinned to the top of the screen (status bar is hidden on those devices).
-        if UIDevice.current.hasIPhoneXNotch {
+        // On older devices content is pinned to the top of the screen and status bar is hidden to allow for more screen room.
+        if UIDevice.current.hasIPhoneXNotch || UIDevice.current.isIPad {
             contentLayoutMargins.top = view.safeAreaInsets.top
         }
 
-        // Generally it is necessary to constrain bottom of the content in the current page to the top
-        // of bottom toolbar in review screen. However, for images we have "edit" mode and we want
-        // the bottom margin to not change when switching to/from "edit" mode, with edit mode toolbar's height
-        // being the one to be used in the review screen.
         if let mediaEditingToolbarHeight = viewController.mediaEditingToolbarHeight {
+            // For images there is an "edit" mode and it is necessary to keep image center the same
+            // when switching to/from "edit" mode. Therefore image is laid out usign bottom inset from "edit" mode screen.
             contentLayoutMargins.bottom = mediaEditingToolbarHeight
         } else {
             // bottomToolView contains UIStackView that doesn't always have a final frame at this point.
             bottomToolView.layoutIfNeeded()
             contentLayoutMargins.bottom = bottomToolView.opaqueAreaHeight
+
+            // For videos there's thumbnail timelinebar embedded into the `bottomToolView`
             if let supplementaryView = viewController.toolbarSupplementaryView {
                 contentLayoutMargins.bottom += supplementaryView.height
             }
         }
         contentLayoutMargins.bottom += view.safeAreaInsets.bottom
 
-        viewController.contentView.contentLayoutMargins = contentLayoutMargins
+        viewController.contentLayoutMargins = contentLayoutMargins
     }
 
     private func updateContents(animated: Bool) {
@@ -467,19 +470,18 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
                                    willTransitionTo pendingViewControllers: [UIViewController]) {
         Logger.debug("")
 
+        owsAssertDebug(pendingViewControllers.count == 1)
+
         // Pause video playback for current page
         currentPageViewController?.prepareToMoveOffscreen()
 
-        assert(pendingViewControllers.count == 1)
+        // Update layout margins for view controllers to become visible.
         pendingViewControllers.forEach { viewController in
             guard let pendingPage = viewController as? AttachmentPrepViewController else {
                 owsFailDebug("unexpected viewController: \(viewController)")
                 return
             }
-
-            // use compact scale when keyboard is popped.
-            let scale: AttachmentPrepViewController.AttachmentViewScale = self.bottomToolView.isEditingMediaMessage ? .compact : .fullsize
-            pendingPage.setAttachmentViewScale(scale, animated: false)
+            updateContentLayoutMargins(for: pendingPage)
         }
     }
 
@@ -583,6 +585,8 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
             return
         }
 
+        let previousPage = currentPageViewController
+
         // Pause video playback for current page
         currentPageViewController?.prepareToMoveOffscreen()
 
@@ -590,7 +594,9 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
         updateContentLayoutMargins(for: page)
 
         Logger.debug("currentItem for attachment: \(item.attachment.debugDescription)")
-        setViewControllers([page], direction: direction, animated: animated)
+        setViewControllers([page], direction: direction, animated: animated) { _ in
+            previousPage?.zoomOut(animated: false)
+        }
 
         // This does make animations smoother.
         DispatchQueue.main.async {
@@ -867,11 +873,6 @@ extension AttachmentApprovalViewController {
 
     @objc
     private func didTapSend() {
-        // Toolbar flickers in and out if there are errors
-        // and remains visible momentarily after share extension is dismissed.
-        // It's easiest to just hide it at this point since we're done with it.
-        currentPageViewController?.shouldAllowAttachmentViewResizing = false
-
         // Generate the attachments once, so that any changes we
         // make below are reflected afterwards.
         ModalActivityIndicatorViewController.present(fromViewController: self, canCancel: false) { modalVC in
@@ -934,7 +935,7 @@ extension AttachmentApprovalViewController: AttachmentTextToolbarDelegate {
         if contentDimmerView.gestureRecognizers?.isEmpty ?? true {
             contentDimmerView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(didTapContentDimmerView(gesture:))))
         }
-   }
+    }
 
     private func hideContentDimmerView() {
         UIView.animate(withDuration: 0.2,
@@ -951,13 +952,15 @@ extension AttachmentApprovalViewController: AttachmentTextToolbarDelegate {
         _ = bottomToolView.resignFirstResponder()
     }
 
+    func attachmentTextToolbarWillBeginEditing(_ attachmentTextToolbar: AttachmentTextToolbar) {
+        startObservingKeyboardNotifications()
+    }
+
     func attachmentTextToolbarDidBeginEditing(_ attachmentTextToolbar: AttachmentTextToolbar) {
-        currentPageViewController?.setAttachmentViewScale(.compact, animated: true)
         showContentDimmerView()
     }
 
     func attachmentTextToolbarDidEndEditing(_ attachmentTextToolbar: AttachmentTextToolbar) {
-        currentPageViewController?.setAttachmentViewScale(.fullsize, animated: true)
         hideContentDimmerView()
     }
 
@@ -966,6 +969,81 @@ extension AttachmentApprovalViewController: AttachmentTextToolbarDelegate {
     }
 
     func attachmentTextToolBarDidChangeHeight(_ attachmentTextToolbar: AttachmentTextToolbar) { }
+
+    private func startObservingKeyboardNotifications() {
+        guard !observingKeyboardNotifications else { return }
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardWillShowNotification,
+            object: nil
+        )
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardWillChangeFrameNotification,
+            object: nil
+        )
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardWillHideNotification,
+            object: nil
+        )
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardDidHideNotification,
+            object: nil
+        )
+        observingKeyboardNotifications = true
+    }
+
+    private func stopObservingKeyboardNotifications() {
+        guard observingKeyboardNotifications else { return }
+
+        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillShowNotification, object: nil)
+        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillChangeFrameNotification, object: nil)
+        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardWillHideNotification, object: nil)
+        NotificationCenter.default.removeObserver(self, name: UIResponder.keyboardDidHideNotification, object: nil)
+        observingKeyboardNotifications = false
+    }
+
+    @objc
+    private func handleKeyboardNotification(_ notification: Notification) {
+        guard
+            let currentPageViewController = currentPageViewController,
+            let userInfo = notification.userInfo,
+            let endFrame = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect else { return }
+
+        var keyboardHeight = endFrame.height
+
+        switch notification.name {
+        case UIResponder.keyboardDidHideNotification, UIResponder.keyboardWillHideNotification:
+            keyboardHeight = 0
+
+        default: break
+        }
+
+        guard self.keyboardHeight != keyboardHeight else { return }
+        self.keyboardHeight = keyboardHeight
+
+        if
+            let animationDuration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? TimeInterval,
+            let rawAnimationCurve = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? Int,
+            let animationCurve = UIView.AnimationCurve(rawValue: rawAnimationCurve)
+        {
+            UIView.beginAnimations("AttachmentResize", context: nil)
+            UIView.setAnimationBeginsFromCurrentState(true)
+            UIView.setAnimationCurve(animationCurve)
+            UIView.setAnimationDuration(animationDuration)
+            currentPageViewController.keyboardHeight = keyboardHeight
+            UIView.commitAnimations()
+        } else {
+            currentPageViewController.keyboardHeight = keyboardHeight
+        }
+    }
 }
 
 // MARK: - Media Quality Selection Sheet
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepContentView.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepContentView.swift
deleted file mode 100644
index 58f93907d4a..00000000000
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepContentView.swift
+++ /dev/null
@@ -1,35 +0,0 @@
-//
-// Copyright 2022 Signal Messenger, LLC
-// SPDX-License-Identifier: AGPL-3.0-only
-//
-
-import UIKit
-
-class AttachmentPrepContentView: UIView {
-
-    // See comments in AttachmentApprovalViewController.updateContentLayoutMargins(for:).
-    let contentLayoutGuide = UILayoutGuide()
-    private lazy var contentLayoutGuideLeading = contentLayoutGuide.leadingAnchor.constraint(equalTo: leadingAnchor, constant: contentLayoutMargins.leading)
-    private lazy var contentLayoutGuideTop = contentLayoutGuide.topAnchor.constraint(equalTo: topAnchor, constant: contentLayoutMargins.top)
-    private lazy var contentLayoutGuideTrailing = contentLayoutGuide.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -contentLayoutMargins.trailing)
-    private lazy var contentLayoutGuideBottom = contentLayoutGuide.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -contentLayoutMargins.bottom)
-    var contentLayoutMargins: UIEdgeInsets = .zero {
-        didSet {
-            contentLayoutGuideLeading.constant = contentLayoutMargins.leading
-            contentLayoutGuideTop.constant = contentLayoutMargins.top
-            contentLayoutGuideTrailing.constant = -contentLayoutMargins.trailing
-            contentLayoutGuideBottom.constant = -contentLayoutMargins.bottom
-        }
-    }
-
-    override init(frame: CGRect) {
-        super.init(frame: frame)
-
-        addLayoutGuide(contentLayoutGuide)
-        addConstraints([ contentLayoutGuideLeading, contentLayoutGuideTop, contentLayoutGuideTrailing, contentLayoutGuideBottom ])
-    }
-
-    required init?(coder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
-}
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepViewController.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepViewController.swift
index 4173719f99d..02b16d94a8b 100644
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepViewController.swift
+++ b/SignalUI/ViewControllers/AttachmentApproval/AttachmentPrepViewController.swift
@@ -17,11 +17,6 @@ protocol AttachmentPrepViewControllerDelegate: AnyObject {
 // MARK: -
 
 public class AttachmentPrepViewController: OWSViewController {
-    // We sometimes shrink the attachment view so that it remains somewhat visible
-    // when the keyboard is presented.
-    public enum AttachmentViewScale {
-        case fullsize, compact
-    }
 
     // MARK: - Properties
 
@@ -34,9 +29,6 @@ public class AttachmentPrepViewController: OWSViewController {
 
     var toolbarSupplementaryView: UIView? { nil }
 
-    private(set) var scrollView: UIScrollView!
-    private(set) var contentContainer: UIView!
-
     // MARK: - Initializers
 
     class func viewController(for attachmentApprovalItem: AttachmentApprovalItem) -> AttachmentPrepViewController? {
@@ -59,7 +51,7 @@ public class AttachmentPrepViewController: OWSViewController {
 
     private lazy var genericContentView = MediaMessageView(attachment: attachment)
 
-    var contentView: AttachmentPrepContentView {
+    var contentView: UIView {
         return genericContentView
     }
 
@@ -85,45 +77,38 @@ public class AttachmentPrepViewController: OWSViewController {
      */
     var mediaEditingToolbarHeight: CGFloat? { nil }
 
-    // MARK: - View Lifecycle
+    // MARK: UIViewController
 
-    override public func loadView() {
-        view = UIView(frame: UIScreen.main.bounds)
+    override public func viewDidLoad() {
         view.backgroundColor = .ows_black
 
-        // Anything that should be shrunk when user pops keyboard lives in the contentContainer.
-        contentContainer = UIView(frame: view.bounds)
-        view.addSubview(contentContainer)
-        contentContainer.autoPinEdgesToSuperviewEdges()
-
-        // Scroll View - used to zoom/pan on images and video
-        scrollView = UIScrollView(frame: contentContainer.bounds)
-        scrollView.delegate = self
-        scrollView.showsHorizontalScrollIndicator = false
-        scrollView.showsVerticalScrollIndicator = false
-        // Panning should stop pretty soon after the user stops scrolling
-        scrollView.decelerationRate = .fast
-        // We want scroll view content up and behind the system status bar content
-        // but we want other content (e.g. bar buttons) to respect the top layout guide.
-        scrollView.contentInsetAdjustmentBehavior = .never
-        contentContainer.addSubview(scrollView)
-        scrollView.autoPinEdgesToSuperviewEdges()
+        // Zoomable scroll view.
+        view.addSubview(scrollView)
+        scrollView.translatesAutoresizingMaskIntoConstraints = false
+        view.addConstraints([ scrollViewLeading, scrollViewTop, scrollViewTrailing, scrollViewBottom ])
 
         // Create full screen container view so the scrollView
         // can compute an appropriate content size in which to center
         // our media view.
         let containerView = UIView.container()
-        containerView.frame = view.bounds
+        containerView.translatesAutoresizingMaskIntoConstraints = false
         scrollView.addSubview(containerView)
-        containerView.autoPinEdgesToSuperviewEdges()
-        containerView.autoMatch(.height, to: .height, of: view)
-        containerView.autoMatch(.width, to: .width, of: view)
+        scrollView.addConstraints([
+            containerView.leadingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.leadingAnchor),
+            containerView.topAnchor.constraint(equalTo: scrollView.contentLayoutGuide.topAnchor),
+            containerView.trailingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.trailingAnchor),
+            containerView.bottomAnchor.constraint(equalTo: scrollView.contentLayoutGuide.bottomAnchor)
+        ])
+        containerView.autoMatch(.height, to: .height, of: scrollView)
+        containerView.autoMatch(.width, to: .width, of: scrollView)
 
         let contentView = contentView
         contentView.frame = containerView.bounds
         prepareContentView()
         containerView.addSubview(contentView)
         contentView.autoPinEdgesToSuperviewEdges()
+
+        updateMinZoomScaleForSize(view.bounds.size)
     }
 
     override public func viewWillAppear(_ animated: Bool) {
@@ -145,65 +130,84 @@ public class AttachmentPrepViewController: OWSViewController {
         super.viewWillTransition(to: size, with: coordinator)
         coordinator.animate { _ in
             self.updateMinZoomScaleForSize(size)
-            self.ensureAttachmentViewScale(animated: false)
         }
     }
 
-    // MARK: - Helpers
+    // MARK: Layout
 
-    func zoomOut(animated: Bool) {
-        if scrollView.zoomScale != scrollView.minimumZoomScale {
-            scrollView.setZoomScale(scrollView.minimumZoomScale, animated: animated)
+    private lazy var scrollView: UIScrollView = {
+        let scrollView = UIScrollView()
+        scrollView.delegate = self
+        scrollView.showsHorizontalScrollIndicator = false
+        scrollView.showsVerticalScrollIndicator = false
+        // Panning should stop pretty soon after the user stops scrolling
+        scrollView.decelerationRate = .fast
+        // We want scroll view content up and behind the system status bar content
+        // but we want other content (e.g. bar buttons) to respect the top layout guide.
+        scrollView.contentInsetAdjustmentBehavior = .never
+        return scrollView
+    }()
+
+    private lazy var scrollViewLeading = scrollView.leadingAnchor.constraint(
+        equalTo: view.leadingAnchor,
+        constant: contentLayoutMargins.leading
+    )
+    private lazy var scrollViewTop = scrollView.topAnchor.constraint(
+        equalTo: view.topAnchor,
+        constant: contentLayoutMargins.top
+    )
+    private lazy var scrollViewTrailing = scrollView.trailingAnchor.constraint(
+        equalTo: view.trailingAnchor,
+        constant: -contentLayoutMargins.trailing
+    )
+    private lazy var scrollViewBottom = scrollView.bottomAnchor.constraint(
+        equalTo: view.bottomAnchor,
+        constant: -contentLayoutMargins.bottom
+    )
+    var contentLayoutMargins: UIEdgeInsets = .zero {
+        didSet {
+            guard oldValue != contentLayoutMargins else { return }
+            scrollViewLeading.constant = contentLayoutMargins.leading
+            scrollViewTop.constant = contentLayoutMargins.top
+            scrollViewTrailing.constant = -contentLayoutMargins.trailing
+            scrollViewBottom.constant = -contentLayoutMargins.bottom
         }
     }
 
-    // When the keyboard is popped, it can obscure the attachment view.
-    // so we sometimes allow resizing the attachment.
-    var shouldAllowAttachmentViewResizing: Bool = true
+    private var zoomAnimationCompletionBlock: (() -> Void)?
+
+    func zoomOut(animated: Bool, completion: (() -> Void)? = nil) {
+        guard scrollView.zoomScale != scrollView.minimumZoomScale else {
+            zoomAnimationCompletionBlock = nil
+            completion?()
+            return
+        }
 
-    var attachmentViewScale: AttachmentViewScale = .fullsize
-    public func setAttachmentViewScale(_ attachmentViewScale: AttachmentViewScale, animated: Bool) {
-        self.attachmentViewScale = attachmentViewScale
-        ensureAttachmentViewScale(animated: animated)
+        zoomAnimationCompletionBlock = completion
+        scrollView.setZoomScale(scrollView.minimumZoomScale, animated: animated)
     }
 
-    func ensureAttachmentViewScale(animated: Bool) {
-        let animationDuration = animated ? 0.2 : 0
-        guard shouldAllowAttachmentViewResizing else {
-            if contentContainer.transform != CGAffineTransform.identity {
-                UIView.animate(withDuration: animationDuration) {
-                    self.contentContainer.transform = CGAffineTransform.identity
-                }
-            }
-            return
+    // Implicitly animatable.
+    var keyboardHeight: CGFloat = 0 {
+        didSet {
+            updateScrollViewTransformForKeyboardHeight()
         }
+    }
 
-        switch attachmentViewScale {
-        case .fullsize:
-            guard contentContainer.transform != .identity else {
-                return
-            }
-            UIView.animate(withDuration: animationDuration) {
-                self.contentContainer.transform = CGAffineTransform.identity
-            }
-        case .compact:
-            guard contentContainer.transform == .identity else {
-                return
-            }
-            UIView.animate(withDuration: animationDuration) {
-                let kScaleFactor: CGFloat = 0.7
-                let scale = CGAffineTransform(scaleX: kScaleFactor, y: kScaleFactor)
+    private func updateScrollViewTransformForKeyboardHeight() {
+        guard keyboardHeight > 0 else {
+            scrollView.transform = .identity
+            return
+        }
 
-                let originalHeight = self.scrollView.bounds.size.height
+        let contentViewSize = contentView.bounds.size
+        let scaledContentViewSize = contentView.bounds.inset(by: .init(margin: 20)).size
+        let scale = min(scaledContentViewSize.width / contentViewSize.width,
+                        scaledContentViewSize.height / contentViewSize.height)
 
-                // Position the new scaled item to be centered with respect
-                // to it's new size.
-                let heightDelta = originalHeight * (1 - kScaleFactor)
-                let translate = CGAffineTransform(translationX: 0, y: -heightDelta / 2)
+        let offsetY = 0.5 * max(0, keyboardHeight - contentLayoutMargins.bottom)
 
-                self.contentContainer.transform = scale.concatenating(translate)
-            }
-        }
+        scrollView.transform = .scale(scale).translate(.init(x: 0, y: -offsetY))
     }
 
     private func presentFullScreen(viewController: UIViewController) {
@@ -213,7 +217,9 @@ public class AttachmentPrepViewController: OWSViewController {
         }
 
         viewController.modalPresentationStyle = .fullScreen
-        presentFullScreen(viewController, animated: false)
+        zoomOut(animated: true) { [weak self] in
+            self?.presentFullScreen(viewController, animated: false)
+        }
     }
 
     final func presentMediaTool(viewController: UIViewController) {
@@ -260,8 +266,7 @@ extension AttachmentPrepViewController: UIScrollViewDelegate {
     // Keep the media view centered within the scroll view as you zoom
     public func scrollViewDidZoom(_ scrollView: UIScrollView) {
         // The scroll view has zoomed, so you need to re-center the contents
-        let scrollViewSize = visibleSize(ofScrollView: scrollView)
-        let scrollViewCenter = center(ofScrollView: scrollView)
+        let scrollViewSize = scrollView.frame.size
 
         // First assume that mediaMessageView center coincides with the contents center
         // This is correct when the mediaMessageView is bigger than scrollView due to zoom
@@ -269,33 +274,24 @@ extension AttachmentPrepViewController: UIScrollViewDelegate {
 
         // if mediaMessageView is smaller than the scrollView visible size - fix the content center accordingly
         if scrollView.contentSize.width < scrollViewSize.width {
-            contentCenter.x = scrollViewCenter.x
+            contentCenter.x = 0.5 * scrollViewSize.width
         }
-
         if scrollView.contentSize.height < scrollViewSize.height {
-            contentCenter.y = scrollViewCenter.y
+            contentCenter.y = 0.5 * scrollViewSize.height
         }
 
         contentView.center = contentCenter
     }
 
+    public func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
+        if let zoomAnimationCompletionBlock {
+            zoomAnimationCompletionBlock()
+            self.zoomAnimationCompletionBlock = nil
+        }
+    }
+
     private var isZoomable: Bool {
         // No zoom for audio or generic attachments.
         return attachment.isImage || attachment.isVideo
     }
-
-    // return the scroll view center
-    private func center(ofScrollView scrollView: UIScrollView) -> CGPoint {
-        let size = visibleSize(ofScrollView: scrollView)
-        return CGPoint(x: (size.width / 2), y: (size.height / 2))
-    }
-
-    // Return scrollview size without the area overlapping with tab and nav bar.
-    private func visibleSize(ofScrollView scrollView: UIScrollView) -> CGSize {
-        let contentInset = scrollView.contentInset
-        let scrollViewSize = scrollView.bounds.standardized.size
-        let width = scrollViewSize.width - (contentInset.left + contentInset.right)
-        let height = scrollViewSize.height - (contentInset.top + contentInset.bottom)
-        return CGSize(width: width, height: height)
-    }
 }
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift
index febb3ebe0f1..2614c0744bf 100644
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift
+++ b/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift
@@ -11,6 +11,7 @@ import SignalMessaging
 let kMaxMessageBodyCharacterCount = 2000
 
 protocol AttachmentTextToolbarDelegate: AnyObject {
+    func attachmentTextToolbarWillBeginEditing(_ attachmentTextToolbar: AttachmentTextToolbar)
     func attachmentTextToolbarDidBeginEditing(_ attachmentTextToolbar: AttachmentTextToolbar)
     func attachmentTextToolbarDidEndEditing(_ attachmentTextToolbar: AttachmentTextToolbar)
     func attachmentTextToolbarDidChange(_ attachmentTextToolbar: AttachmentTextToolbar)
@@ -228,14 +229,13 @@ class AttachmentTextToolbar: UIView {
     }()
 
     private lazy var addMessageButton: UIButton = {
-        let button = OWSButton(title: placeholderText) { [weak self] in
-            guard let self = self else { return }
-            self.didTapAddMessage()
-        }
+        let button = UIButton(type: .custom)
+        button.setTitle(placeholderText, for: .normal)
         button.setTitleColor(.ows_white, for: .normal)
         button.titleLabel?.lineBreakMode = .byTruncatingTail
         button.titleLabel?.textAlignment = .center
         button.titleLabel?.font = .ows_dynamicTypeBodyClamped
+        button.addTarget(self, action: #selector(didTapAddMessage), for: .touchDown)
         return button
     }()
 
@@ -373,6 +373,8 @@ extension AttachmentTextToolbar: UITextViewDelegate {
     }
 
     public func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
+        delegate?.attachmentTextToolbarWillBeginEditing(self)
+
         // Putting these lines in `textViewDidBeginEditing` doesn't work.
         textView.textContainer.lineBreakMode = .byWordWrapping
         textView.textContainer.maximumNumberOfLines = 0
diff --git a/SignalUI/ViewControllers/MediaMessageView.swift b/SignalUI/ViewControllers/MediaMessageView.swift
index c82b5cd84cd..9e46ee944f2 100644
--- a/SignalUI/ViewControllers/MediaMessageView.swift
+++ b/SignalUI/ViewControllers/MediaMessageView.swift
@@ -7,7 +7,7 @@ import SignalMessaging
 import UIKit
 import YYImage
 
-class MediaMessageView: AttachmentPrepContentView, AudioPlayerDelegate {
+class MediaMessageView: UIView, AudioPlayerDelegate {
 
     private let attachment: SignalAttachment
 
@@ -113,11 +113,11 @@ class MediaMessageView: AttachmentPrepContentView, AudioPlayerDelegate {
         let stackView = wrapViewsInVerticalStack(subviews: subviews)
         addSubview(stackView)
 
-        stackView.leadingAnchor.constraint(equalTo: contentLayoutGuide.leadingAnchor).isActive = true
-        stackView.trailingAnchor.constraint(equalTo: contentLayoutGuide.trailingAnchor).isActive = true
-        stackView.centerYAnchor.constraint(equalTo: contentLayoutGuide.centerYAnchor).isActive = true
-        stackView.topAnchor.constraint(greaterThanOrEqualTo: contentLayoutGuide.topAnchor).isActive = true
-        stackView.bottomAnchor.constraint(lessThanOrEqualTo: contentLayoutGuide.bottomAnchor).isActive = true
+        stackView.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true
+        stackView.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true
+        stackView.centerYAnchor.constraint(equalTo: centerYAnchor).isActive = true
+        stackView.topAnchor.constraint(greaterThanOrEqualTo: topAnchor).isActive = true
+        stackView.bottomAnchor.constraint(lessThanOrEqualTo: bottomAnchor).isActive = true
     }
 
     private func createLoopingVideoPreview() {
@@ -161,8 +161,8 @@ class MediaMessageView: AttachmentPrepContentView, AudioPlayerDelegate {
         addSubview(view)
 
         // This emulates the behavior of contentMode = .scaleAspectFit using iOS auto layout constraints.
-        view.centerXAnchor.constraint(equalTo: contentLayoutGuide.centerXAnchor).isActive = true
-        view.centerYAnchor.constraint(equalTo: contentLayoutGuide.centerYAnchor).isActive = true
+        view.centerXAnchor.constraint(equalTo: centerXAnchor).isActive = true
+        view.centerYAnchor.constraint(equalTo: centerYAnchor).isActive = true
         view.autoPin(toAspectRatio: aspectRatio)
         view.autoMatch(.width, to: .width, of: self, withMultiplier: 1.0, relation: .lessThanOrEqual)
         view.autoMatch(.height, to: .height, of: self, withMultiplier: 1.0, relation: .lessThanOrEqual)
@@ -172,8 +172,8 @@ class MediaMessageView: AttachmentPrepContentView, AudioPlayerDelegate {
         addSubview(view)
 
         // This emulates the behavior of contentMode = .scaleAspectFill using iOS auto layout constraints.
-        view.centerXAnchor.constraint(equalTo: contentLayoutGuide.centerXAnchor).isActive = true
-        view.centerYAnchor.constraint(equalTo: contentLayoutGuide.centerYAnchor).isActive = true
+        view.centerXAnchor.constraint(equalTo: centerXAnchor).isActive = true
+        view.centerYAnchor.constraint(equalTo: centerYAnchor).isActive = true
         view.autoPin(toAspectRatio: aspectRatio)
         view.autoMatch(.height, to: .height, of: self, withMultiplier: 1.0, relation: .greaterThanOrEqual)
         view.autoMatch(.width, to: .width, of: self, withMultiplier: 1.0, relation: .greaterThanOrEqual)
@@ -237,11 +237,11 @@ class MediaMessageView: AttachmentPrepContentView, AudioPlayerDelegate {
         let stackView = wrapViewsInVerticalStack(subviews: subviews)
         addSubview(stackView)
 
-        stackView.leadingAnchor.constraint(equalTo: contentLayoutGuide.leadingAnchor).isActive = true
-        stackView.trailingAnchor.constraint(equalTo: contentLayoutGuide.trailingAnchor).isActive = true
-        stackView.centerYAnchor.constraint(equalTo: contentLayoutGuide.centerYAnchor).isActive = true
-        stackView.topAnchor.constraint(greaterThanOrEqualTo: contentLayoutGuide.topAnchor).isActive = true
-        stackView.bottomAnchor.constraint(lessThanOrEqualTo: contentLayoutGuide.bottomAnchor).isActive = true
+        stackView.leadingAnchor.constraint(equalTo: leadingAnchor).isActive = true
+        stackView.trailingAnchor.constraint(equalTo: trailingAnchor).isActive = true
+        stackView.centerYAnchor.constraint(equalTo: centerYAnchor).isActive = true
+        stackView.topAnchor.constraint(greaterThanOrEqualTo: topAnchor).isActive = true
+        stackView.bottomAnchor.constraint(lessThanOrEqualTo: bottomAnchor).isActive = true
     }
 
     private var createHeroViewSize: CGFloat {
diff --git a/SignalUI/Views/ImageEditor/ImageAttachmentPrepViewController.swift b/SignalUI/Views/ImageEditor/ImageAttachmentPrepViewController.swift
index efc07ede664..9b421656034 100644
--- a/SignalUI/Views/ImageEditor/ImageAttachmentPrepViewController.swift
+++ b/SignalUI/Views/ImageEditor/ImageAttachmentPrepViewController.swift
@@ -22,7 +22,7 @@ class ImageAttachmentPrepViewController: AttachmentPrepViewController {
         super.init(attachmentApprovalItem: attachmentApprovalItem)
     }
 
-    override var contentView: AttachmentPrepContentView {
+    override var contentView: UIView {
         editorView
     }
 
diff --git a/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift b/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift
index e0aff179749..26b61210bff 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift
@@ -90,7 +90,7 @@ private class TextFrameLayer: CAShapeLayer {
 // MARK: -
 
 // A view for previewing an image editor model.
-class ImageEditorCanvasView: AttachmentPrepContentView {
+class ImageEditorCanvasView: UIView {
 
     private let model: ImageEditorModel
 
@@ -119,14 +119,6 @@ class ImageEditorCanvasView: AttachmentPrepContentView {
         }
     }
 
-    override var contentLayoutMargins: UIEdgeInsets {
-        didSet {
-            if oldValue != contentLayoutMargins {
-                updateLayout()
-            }
-        }
-    }
-
     // We want blurs to be rendered above the image and behind strokes and text.
     private static let blurLayerZ: CGFloat = +1
     // We want strokes to be rendered above the image and blurs and behind text.
@@ -222,30 +214,26 @@ class ImageEditorCanvasView: AttachmentPrepContentView {
     private func updateLayout() {
         NSLayoutConstraint.deactivate(contentViewConstraints)
         contentViewConstraints = ImageEditorCanvasView.updateContentLayout(transform: model.currentTransform(),
-                                                                           contentView: clipView,
-                                                                           layoutMargins: contentLayoutMargins)
+                                                                           contentView: clipView)
     }
 
     class func updateContentLayout(transform: ImageEditorTransform,
-                                   contentView: UIView,
-                                   layoutMargins: UIEdgeInsets = .zero) -> [NSLayoutConstraint] {
+                                   contentView: UIView) -> [NSLayoutConstraint] {
         guard let superview = contentView.superview else {
             owsFailDebug("Content view has no superview.")
             return []
         }
 
         let aspectRatio = transform.outputSizePixels
-        let centerOffset = CGPoint(x: 0.5 * (layoutMargins.leading - layoutMargins.trailing),
-                                   y: 0.5 * (layoutMargins.top - layoutMargins.bottom))
 
         // This emulates the behavior of contentMode = .scaleAspectFit using iOS auto layout constraints.
         var constraints = [NSLayoutConstraint]()
         NSLayoutConstraint.autoSetPriority(.defaultHigh + 100) {
-            constraints.append(contentView.autoAlignAxis(.vertical, toSameAxisOf: superview, withOffset: centerOffset.x))
-            constraints.append(contentView.autoAlignAxis(.horizontal, toSameAxisOf: superview, withOffset: centerOffset.y))
+            constraints.append(contentView.autoAlignAxis(.vertical, toSameAxisOf: superview))
+            constraints.append(contentView.autoAlignAxis(.horizontal, toSameAxisOf: superview))
         }
-        constraints.append(contentView.autoPinEdge(.top, to: .top, of: superview, withOffset: layoutMargins.top, relation: .greaterThanOrEqual))
-        constraints.append(contentView.autoPinEdge(.bottom, to: .bottom, of: superview, withOffset: -layoutMargins.bottom, relation: .lessThanOrEqual))
+        constraints.append(contentView.autoPinEdge(.top, to: .top, of: superview, withOffset: 0, relation: .greaterThanOrEqual))
+        constraints.append(contentView.autoPinEdge(.bottom, to: .bottom, of: superview, withOffset: 0, relation: .lessThanOrEqual))
         constraints.append(contentView.autoPin(toAspectRatio: aspectRatio.width / aspectRatio.height))
         constraints.append(contentView.autoMatch(.width, to: .width, of: superview, withMultiplier: 1.0, relation: .lessThanOrEqual))
         constraints.append(contentView.autoMatch(.height, to: .height, of: superview, withMultiplier: 1.0, relation: .lessThanOrEqual))
diff --git a/SignalUI/Views/ImageEditor/ImageEditorCropViewController.swift b/SignalUI/Views/ImageEditor/ImageEditorCropViewController.swift
index c4533c52e97..9bca31e9a43 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorCropViewController.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorCropViewController.swift
@@ -174,7 +174,7 @@ class ImageEditorCropViewController: OWSViewController {
         initialStateContentLayoutGuide.identifier = "Content - Initial State"
         view.addLayoutGuide(initialStateContentLayoutGuide)
         let topConstraint: NSLayoutConstraint = {
-            if UIDevice.current.hasIPhoneXNotch {
+            if UIDevice.current.hasIPhoneXNotch || UIDevice.current.isIPad {
                 return initialStateContentLayoutGuide.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
             } else {
                 return initialStateContentLayoutGuide.topAnchor.constraint(equalTo: view.topAnchor)
diff --git a/SignalUI/Views/ImageEditor/ImageEditorView.swift b/SignalUI/Views/ImageEditor/ImageEditorView.swift
index be49eb06cff..557b3832105 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorView.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorView.swift
@@ -22,7 +22,7 @@ protocol ImageEditorViewDelegate: AnyObject {
 
 // A view for editing outgoing image attachments.
 // It can also be used to render the final output.
-class ImageEditorView: AttachmentPrepContentView {
+class ImageEditorView: UIView {
 
     weak var delegate: ImageEditorViewDelegate?
 
@@ -30,12 +30,6 @@ class ImageEditorView: AttachmentPrepContentView {
 
     let canvasView: ImageEditorCanvasView
 
-    override var contentLayoutMargins: UIEdgeInsets {
-        didSet {
-            canvasView.contentLayoutMargins = contentLayoutMargins
-        }
-    }
-
     required init(model: ImageEditorModel, delegate: ImageEditorViewDelegate?) {
         self.model = model
         self.delegate = delegate
diff --git a/SignalUI/Views/ImageEditor/ImageEditorViewController.swift b/SignalUI/Views/ImageEditor/ImageEditorViewController.swift
index f246db12b31..3a0f6f3b0a2 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorViewController.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorViewController.swift
@@ -228,7 +228,7 @@ class ImageEditorViewController: OWSViewController {
         imageEditorView.configureSubviews()
         view.addSubview(imageEditorView)
         imageEditorView.autoPinWidthToSuperview()
-        imageEditorView.autoPinEdge(toSuperviewEdge: .top)
+        imageEditorView.autoPinEdge(toSuperviewSafeArea: .top)
 
         // Top toolbar
         updateTopBar()
@@ -278,11 +278,6 @@ class ImageEditorViewController: OWSViewController {
         }
     }
 
-    override func viewSafeAreaInsetsDidChange() {
-        super.viewSafeAreaInsetsDidChange()
-        updateContentLayoutMargins()
-    }
-
     override func keyboardFrameDidChange(_ newFrame: CGRect, animationDuration: TimeInterval, animationOptions: UIView.AnimationOptions) {
         super.keyboardFrameDidChange(newFrame, animationDuration: animationDuration, animationOptions: animationOptions)
 
@@ -299,17 +294,6 @@ class ImageEditorViewController: OWSViewController {
 
     // MARK: -
 
-    private func updateContentLayoutMargins() {
-        var contentLayoutMargins: UIEdgeInsets = .zero
-        if UIDevice.current.hasIPhoneXNotch {
-            contentLayoutMargins.top = view.safeAreaInsets.top
-        }
-
-        // Unlike code in `AttachmentApprovalViewController` bottom inset is zero
-        // because bottom of ImageEditorView is constrained to the top of toolbar.
-        imageEditorView.contentLayoutMargins = contentLayoutMargins
-    }
-
     private func updateUIForCurrentMode() {
         switch mode {
         case .draw, .blur:
diff --git a/SignalUI/Views/VideoEditor/VideoAttachmentPrepViewController.swift b/SignalUI/Views/VideoEditor/VideoAttachmentPrepViewController.swift
index 621b75beb7f..b85fa1994a1 100644
--- a/SignalUI/Views/VideoEditor/VideoAttachmentPrepViewController.swift
+++ b/SignalUI/Views/VideoEditor/VideoAttachmentPrepViewController.swift
@@ -48,7 +48,7 @@ class VideoAttachmentPrepViewController: AttachmentPrepViewController {
         model.add(observer: self)
     }
 
-    override var contentView: AttachmentPrepContentView {
+    override var contentView: UIView {
         editorView
     }
 
diff --git a/SignalUI/Views/VideoEditor/VideoEditorView.swift b/SignalUI/Views/VideoEditor/VideoEditorView.swift
index fe0db89ae8c..3b869222a10 100644
--- a/SignalUI/Views/VideoEditor/VideoEditorView.swift
+++ b/SignalUI/Views/VideoEditor/VideoEditorView.swift
@@ -17,7 +17,7 @@ protocol VideoEditorViewControllerProviding: AnyObject {
 }
 
 // A view for editing outgoing video attachments.
-class VideoEditorView: AttachmentPrepContentView {
+class VideoEditorView: UIView {
 
     weak var delegate: VideoEditorViewDelegate?
     weak var dataSource: VideoEditorDataSource?
@@ -85,12 +85,12 @@ class VideoEditorView: AttachmentPrepContentView {
         addSubview(view)
         // This emulates the behavior of contentMode = .scaleAspectFit using iOS auto layout constraints.
         addConstraints({
-            let constraints = [ view.centerXAnchor.constraint(equalTo: contentLayoutGuide.centerXAnchor),
-                                view.centerYAnchor.constraint(equalTo: contentLayoutGuide.centerYAnchor) ]
+            let constraints = [ view.centerXAnchor.constraint(equalTo: centerXAnchor),
+                                view.centerYAnchor.constraint(equalTo: centerYAnchor) ]
             constraints.forEach { $0.priority = .defaultHigh - 100 }
             return constraints
         }())
-        addConstraint(view.topAnchor.constraint(greaterThanOrEqualTo: contentLayoutGuide.topAnchor))
+        addConstraint(view.topAnchor.constraint(greaterThanOrEqualTo: topAnchor))
         view.autoPin(toAspectRatio: aspectRatio)
         view.autoMatch(.width, to: .width, of: self, withMultiplier: 1.0, relation: .lessThanOrEqual)
         view.autoMatch(.height, to: .height, of: self, withMultiplier: 1.0, relation: .lessThanOrEqual)
