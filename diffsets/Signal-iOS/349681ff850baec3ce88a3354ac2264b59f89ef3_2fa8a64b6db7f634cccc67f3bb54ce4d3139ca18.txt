diff --git a/Scripts/sds_codegen/sds_generate.py b/Scripts/sds_codegen/sds_generate.py
index 01ad99d6bbd..1389c1880db 100755
--- a/Scripts/sds_codegen/sds_generate.py
+++ b/Scripts/sds_codegen/sds_generate.py
@@ -1264,6 +1264,15 @@ class func fromRecord(_ record: %s) throws -> %s {
     public static var table: SDSTableMetadata {
         %sSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 ''' % ( str(clazz.name), record_name, str(clazz.name), )
 
diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 80768a5a344..c7ba9426cbc 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -1134,6 +1134,7 @@
 		F900F2DD27F25AB400431E09 /* DonationReceiptViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F900F2DC27F25AB300431E09 /* DonationReceiptViewController.swift */; };
 		F903C29B28EC7AE60035B42B /* TSAccountManagerTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F903C29A28EC7AE60035B42B /* TSAccountManagerTest.swift */; };
 		F9066F0727ECE41B008C9530 /* DonationReceiptsViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9066F0627ECE41B008C9530 /* DonationReceiptsViewController.swift */; };
+		F908179628EF107800D31AD5 /* GRDBDatabaseStorageAdapterTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F908179528EF107800D31AD5 /* GRDBDatabaseStorageAdapterTest.swift */; };
 		F908AA7D28CE629700472E68 /* test-apng.png in Resources */ = {isa = PBXBuildFile; fileRef = F908AA7C28CE629700472E68 /* test-apng.png */; };
 		F908AA8028CE7F8D00472E68 /* TSGroupThreadTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F908AA7F28CE7F8D00472E68 /* TSGroupThreadTest.swift */; };
 		F92074762888648A00B7F087 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = F92074752888648A00B7F087 /* AppDelegate.swift */; };
@@ -1231,6 +1232,7 @@
 		F94262A2289B1B5600460798 /* SSKBaseTestSwift.swift in Sources */ = {isa = PBXBuildFile; fileRef = F942623A289B1B5500460798 /* SSKBaseTestSwift.swift */; };
 		F94BFA9528EBB0D800A5F34E /* FakeMessageSender.swift in Sources */ = {isa = PBXBuildFile; fileRef = F94BFA9428EBB0D800A5F34E /* FakeMessageSender.swift */; };
 		F94D12FF28BD0DD900B2C478 /* SpeechManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = F94D12FE28BD0DD900B2C478 /* SpeechManager.swift */; };
+		F94D130628C1667600B2C478 /* DatabaseRecoveryTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F94D130528C1667600B2C478 /* DatabaseRecoveryTest.swift */; };
 		F95427E6286E042200314EDA /* BadgeGiftingThanksSheet.swift in Sources */ = {isa = PBXBuildFile; fileRef = F95427E5286E042200314EDA /* BadgeGiftingThanksSheet.swift */; };
 		F96A534328A1AE7C003262D4 /* OutgoingGroupUpdateMessage.swift in Sources */ = {isa = PBXBuildFile; fileRef = F96A534228A1AE7B003262D4 /* OutgoingGroupUpdateMessage.swift */; };
 		F97217F628DC9A5000113D9F /* OWSFileSystemTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F97217F528DC9A5000113D9F /* OWSFileSystemTest.swift */; };
@@ -1239,6 +1241,7 @@
 		F97217FE28DCBC5100113D9F /* GRDBSchemaMigratorTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F97217FD28DCBC5100113D9F /* GRDBSchemaMigratorTest.swift */; };
 		F972180028DCBD4700113D9F /* DatabaseTestHelpers.swift in Sources */ = {isa = PBXBuildFile; fileRef = F97217FF28DCBD4700113D9F /* DatabaseTestHelpers.swift */; };
 		F972180228DCFDF100113D9F /* TSContactThreadTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F972180128DCFDF100113D9F /* TSContactThreadTest.swift */; };
+		F972180628DE37A200113D9F /* AppVersion.swift in Sources */ = {isa = PBXBuildFile; fileRef = F972180528DE37A200113D9F /* AppVersion.swift */; };
 		F973DFBA0991C967C4934B08 /* Pods_SignalUITests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = BD0D81F9D93CB5BADE6B9709 /* Pods_SignalUITests.framework */; };
 		F97823F328CD0AA1005533BF /* PngChunker.swift in Sources */ = {isa = PBXBuildFile; fileRef = F908AA7928CB89CC00472E68 /* PngChunker.swift */; };
 		F97823F428CD0AC7005533BF /* PngChunkerTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F908AA7728CB894400472E68 /* PngChunkerTest.swift */; };
@@ -1270,9 +1273,12 @@
 		F9B0DC5F28948656004E07B7 /* GTSR4.crt in Resources */ = {isa = PBXBuildFile; fileRef = F9B0DC4D28948656004E07B7 /* GTSR4.crt */; };
 		F9B0DC6028948656004E07B7 /* textsecure.cer in Resources */ = {isa = PBXBuildFile; fileRef = F9B0DC4E28948656004E07B7 /* textsecure.cer */; };
 		F9B652BC28D514E6006914CA /* RecipientPickerViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9B652BB28D514E6006914CA /* RecipientPickerViewController.swift */; };
+		F9B652C128D8CB75006914CA /* DatabaseRecoveryViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9B652C028D8CB75006914CA /* DatabaseRecoveryViewController.swift */; };
+		F9B652C328D8E3DF006914CA /* DatabaseRecovery.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9B652C228D8E3DF006914CA /* DatabaseRecovery.swift */; };
 		F9B93CDC28E1FE3500B3F8A0 /* SignalProxyTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9B93CDB28E1FE3500B3F8A0 /* SignalProxyTest.swift */; };
 		F9B93CE028E246D900B3F8A0 /* AppDelegateTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9B93CDF28E246D900B3F8A0 /* AppDelegateTest.swift */; };
 		F9BC0A2527FB8E730085B23D /* AppSettingsViewsUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9BC0A2427FB8E730085B23D /* AppSettingsViewsUtil.swift */; };
+		F9C57FAD28E5F1E2001D3596 /* MockSSKEnvironment.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9C57FAC28E5F1E2001D3596 /* MockSSKEnvironment.swift */; };
 		F9C5C89F289451B900548EEE /* SignalServiceKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = F9C5C897289451B900548EEE /* SignalServiceKit.framework */; };
 		F9C5C8A7289451B900548EEE /* SignalServiceKit.h in Headers */ = {isa = PBXBuildFile; fileRef = F9C5C899289451B900548EEE /* SignalServiceKit.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		F9C5C8AA289451B900548EEE /* SignalServiceKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = F9C5C897289451B900548EEE /* SignalServiceKit.framework */; };
@@ -3459,6 +3465,7 @@
 		F900F2DC27F25AB300431E09 /* DonationReceiptViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationReceiptViewController.swift; sourceTree = "<group>"; };
 		F903C29A28EC7AE60035B42B /* TSAccountManagerTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TSAccountManagerTest.swift; sourceTree = "<group>"; };
 		F9066F0627ECE41B008C9530 /* DonationReceiptsViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationReceiptsViewController.swift; sourceTree = "<group>"; };
+		F908179528EF107800D31AD5 /* GRDBDatabaseStorageAdapterTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GRDBDatabaseStorageAdapterTest.swift; sourceTree = "<group>"; };
 		F908AA7728CB894400472E68 /* PngChunkerTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PngChunkerTest.swift; sourceTree = "<group>"; };
 		F908AA7928CB89CC00472E68 /* PngChunker.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PngChunker.swift; sourceTree = "<group>"; };
 		F908AA7C28CE629700472E68 /* test-apng.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = "test-apng.png"; sourceTree = "<group>"; };
@@ -3557,6 +3564,7 @@
 		F942623A289B1B5500460798 /* SSKBaseTestSwift.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; name = SSKBaseTestSwift.swift; path = SignalServiceKit/tests/SSKBaseTestSwift.swift; sourceTree = SOURCE_ROOT; };
 		F94BFA9428EBB0D800A5F34E /* FakeMessageSender.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FakeMessageSender.swift; sourceTree = "<group>"; };
 		F94D12FE28BD0DD900B2C478 /* SpeechManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SpeechManager.swift; sourceTree = "<group>"; };
+		F94D130528C1667600B2C478 /* DatabaseRecoveryTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DatabaseRecoveryTest.swift; sourceTree = "<group>"; };
 		F95427E5286E042200314EDA /* BadgeGiftingThanksSheet.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeGiftingThanksSheet.swift; sourceTree = "<group>"; };
 		F965C5B87BFDF8F86556C04C /* Pods-SignalNSE.profiling.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalNSE.profiling.xcconfig"; path = "Pods/Target Support Files/Pods-SignalNSE/Pods-SignalNSE.profiling.xcconfig"; sourceTree = "<group>"; };
 		F96A534228A1AE7B003262D4 /* OutgoingGroupUpdateMessage.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OutgoingGroupUpdateMessage.swift; sourceTree = "<group>"; };
@@ -3566,6 +3574,7 @@
 		F97217FD28DCBC5100113D9F /* GRDBSchemaMigratorTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GRDBSchemaMigratorTest.swift; sourceTree = "<group>"; };
 		F97217FF28DCBD4700113D9F /* DatabaseTestHelpers.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DatabaseTestHelpers.swift; sourceTree = "<group>"; };
 		F972180128DCFDF100113D9F /* TSContactThreadTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TSContactThreadTest.swift; sourceTree = "<group>"; };
+		F972180528DE37A200113D9F /* AppVersion.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppVersion.swift; sourceTree = "<group>"; };
 		F97A2EE828247C1300610669 /* BadgeExpirationSheetStateTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeExpirationSheetStateTest.swift; sourceTree = "<group>"; };
 		F9844C482867936400B16DD4 /* SignalMeTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SignalMeTest.swift; sourceTree = "<group>"; };
 		F988DC12289DC8F2003B4B82 /* OWSOutgoingReactionMessageTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSOutgoingReactionMessageTest.swift; sourceTree = "<group>"; };
@@ -3594,10 +3603,13 @@
 		F9B0DC4D28948656004E07B7 /* GTSR4.crt */ = {isa = PBXFileReference; lastKnownFileType = file; path = GTSR4.crt; sourceTree = "<group>"; };
 		F9B0DC4E28948656004E07B7 /* textsecure.cer */ = {isa = PBXFileReference; lastKnownFileType = file; path = textsecure.cer; sourceTree = "<group>"; };
 		F9B652BB28D514E6006914CA /* RecipientPickerViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RecipientPickerViewController.swift; sourceTree = "<group>"; };
+		F9B652C028D8CB75006914CA /* DatabaseRecoveryViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DatabaseRecoveryViewController.swift; sourceTree = "<group>"; };
+		F9B652C228D8E3DF006914CA /* DatabaseRecovery.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = DatabaseRecovery.swift; sourceTree = "<group>"; };
 		F9B93CDB28E1FE3500B3F8A0 /* SignalProxyTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SignalProxyTest.swift; sourceTree = "<group>"; };
 		F9B93CDF28E246D900B3F8A0 /* AppDelegateTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegateTest.swift; sourceTree = "<group>"; };
 		F9BC0A2427FB8E730085B23D /* AppSettingsViewsUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppSettingsViewsUtil.swift; sourceTree = "<group>"; };
 		F9BC9C6428B7C00A0077D442 /* OutgoingGroupUpdateMessageTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OutgoingGroupUpdateMessageTest.swift; sourceTree = "<group>"; };
+		F9C57FAC28E5F1E2001D3596 /* MockSSKEnvironment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MockSSKEnvironment.swift; sourceTree = "<group>"; };
 		F9C5C897289451B900548EEE /* SignalServiceKit.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = SignalServiceKit.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		F9C5C899289451B900548EEE /* SignalServiceKit.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = SignalServiceKit.h; sourceTree = "<group>"; };
 		F9C5C89E289451B900548EEE /* SignalServiceKitTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = SignalServiceKitTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
@@ -5483,6 +5495,7 @@
 				348BB25C20A0C5530047AEC2 /* ContactShareViewHelper.swift */,
 				34E88D252098C5AE00A608F4 /* ContactViewController.swift */,
 				346B66301F4E29B200E5122F /* CropScaleImageViewController.swift */,
+				F9B652C028D8CB75006914CA /* DatabaseRecoveryViewController.swift */,
 				340E9ABF235F876800FA362C /* ForwardMessageViewController.swift */,
 				327CF66725ACE7DC00DA0A6F /* GetStartedBannerViewController.swift */,
 				340D8FFF24FEE6A9007B5504 /* GroupInviteLinksUI.swift */,
@@ -7042,7 +7055,9 @@
 			isa = PBXGroup;
 			children = (
 				F97217FA28DCA36E00113D9F /* DatabaseCorruptionStateTest.swift */,
+				F94D130528C1667600B2C478 /* DatabaseRecoveryTest.swift */,
 				F97217FF28DCBD4700113D9F /* DatabaseTestHelpers.swift */,
+				F908179528EF107800D31AD5 /* GRDBDatabaseStorageAdapterTest.swift */,
 				F97217FD28DCBC5100113D9F /* GRDBSchemaMigratorTest.swift */,
 			);
 			path = Database;
@@ -7729,6 +7744,7 @@
 				F9C5CA35289453B100548EEE /* Records */,
 				F9C5CA3C289453B100548EEE /* Snapshots */,
 				F97217F728DC9F3700113D9F /* DatabaseCorruptionState.swift */,
+				F9B652C228D8E3DF006914CA /* DatabaseRecovery.swift */,
 				F9C5CA48289453B100548EEE /* DeepCopy.swift */,
 				F9C5CA40289453B100548EEE /* GRDBDatabaseStorageAdapter.swift */,
 				F9C5CA47289453B100548EEE /* GRDBSchemaMigrator.swift */,
@@ -8024,6 +8040,7 @@
 				F9C5CB81289453B200548EEE /* AppReadiness.swift */,
 				F9C5CB34289453B200548EEE /* AppVersion.h */,
 				F9C5CB77289453B200548EEE /* AppVersion.m */,
+				F972180528DE37A200113D9F /* AppVersion.swift */,
 				F9C5CB38289453B200548EEE /* Array+SSK.swift */,
 				F9C5CB25289453B200548EEE /* Atomics.swift */,
 				F9C5CB62289453B200548EEE /* AudioWaveform.swift */,
@@ -8176,6 +8193,7 @@
 				F9C5CB84289453B200548EEE /* FakeStorageServiceManager.swift */,
 				F9C5CB85289453B200548EEE /* MockSSKEnvironment.h */,
 				F9C5CB8D289453B200548EEE /* MockSSKEnvironment.m */,
+				F9C57FAC28E5F1E2001D3596 /* MockSSKEnvironment.swift */,
 				F9C5CB86289453B200548EEE /* MockSubscriptionManager.swift */,
 				F9C5CB92289453B200548EEE /* NoopNotificationsManager.swift */,
 				F9C5CB88289453B200548EEE /* NoopPendingReadReceiptRecorder.swift */,
@@ -10102,6 +10120,7 @@
 				341D392925472F3B00996E7B /* CVViewState.swift in Sources */,
 				345772B6257E4E01001D7D44 /* CVViewStateSnapshot.swift in Sources */,
 				3420CF6F2638A01A00E7DCB0 /* CVWallpaperBlurView.swift in Sources */,
+				F9B652C128D8CB75006914CA /* DatabaseRecoveryViewController.swift in Sources */,
 				346C19DF25ACDF0B00061D3A /* DataSettingsTableViewController.swift in Sources */,
 				88535064240829950011D318 /* DateHeaderInteraction.swift in Sources */,
 				34DC9BD921543E0C00FDDCEC /* DebugContactsUtils.m in Sources */,
@@ -10504,6 +10523,7 @@
 				F9C5CE40289453B400548EEE /* AppExpiry.swift in Sources */,
 				F9C5CE52289453B400548EEE /* AppReadiness.swift in Sources */,
 				F9C5CE48289453B400548EEE /* AppVersion.m in Sources */,
+				F972180628DE37A200113D9F /* AppVersion.swift in Sources */,
 				F9C5CE0A289453B400548EEE /* Array+SSK.swift in Sources */,
 				F9C5CDF7289453B400548EEE /* Atomics.swift in Sources */,
 				F9C5CD16289453B300548EEE /* AttachmentFinder.swift in Sources */,
@@ -10546,6 +10566,7 @@
 				F9C5CDFF289453B400548EEE /* Data+SSK.swift in Sources */,
 				F9C5CD1D289453B300548EEE /* DatabaseChangeObserver.swift in Sources */,
 				F97217F828DC9F3700113D9F /* DatabaseCorruptionState.swift in Sources */,
+				F9B652C328D8E3DF006914CA /* DatabaseRecovery.swift in Sources */,
 				F9C5CDD9289453B400548EEE /* DataSource.m in Sources */,
 				F9C5CE4D289453B400548EEE /* Date+SSK.swift in Sources */,
 				F9C5CDD8289453B400548EEE /* DebouncedEvent.swift in Sources */,
@@ -10650,6 +10671,7 @@
 				F9C5CE30289453B400548EEE /* MIMETypeUtil.m in Sources */,
 				F9C5CD7B289453B300548EEE /* MobileCoinHelper.swift in Sources */,
 				F9C5CE5D289453B400548EEE /* MockSSKEnvironment.m in Sources */,
+				F9C57FAD28E5F1E2001D3596 /* MockSSKEnvironment.swift in Sources */,
 				F9C5CE56289453B400548EEE /* MockSubscriptionManager.swift in Sources */,
 				F9C5CE29289453B400548EEE /* ModelReadCache.swift in Sources */,
 				F9C5CDC4289453B400548EEE /* NetworkInterfaceSet.swift in Sources */,
@@ -11071,12 +11093,14 @@
 				F9426286289B1B5600460798 /* ContactSortingTest.m in Sources */,
 				509BBF7A28CA556700F4D8A0 /* Data+SSKTest.swift in Sources */,
 				F97217FB28DCA36E00113D9F /* DatabaseCorruptionStateTest.swift in Sources */,
+				F94D130628C1667600B2C478 /* DatabaseRecoveryTest.swift in Sources */,
 				F972180028DCBD4700113D9F /* DatabaseTestHelpers.swift in Sources */,
 				F9426265289B1B5500460798 /* Date+SSKTest.swift in Sources */,
 				F942629B289B1B5600460798 /* DeliveryReceiptContextTests.swift in Sources */,
 				F9426263289B1B5500460798 /* DeviceNamesTest.swift in Sources */,
 				F9426267289B1B5500460798 /* DispatchQueue+OWSTest.swift in Sources */,
 				F9426254289B1B5500460798 /* FeatureFlagsTests.swift in Sources */,
+				F908179628EF107800D31AD5 /* GRDBDatabaseStorageAdapterTest.swift in Sources */,
 				F97217FE28DCBC5100113D9F /* GRDBSchemaMigratorTest.swift in Sources */,
 				F9426251289B1B5500460798 /* GroupModelsTest.swift in Sources */,
 				F9426245289B1B5500460798 /* HTMLMetadataTests.swift in Sources */,
diff --git a/Signal/Images.xcassets/database-corrupted.imageset/Contents.json b/Signal/Images.xcassets/database-corrupted.imageset/Contents.json
new file mode 100644
index 00000000000..77914a3decd
--- /dev/null
+++ b/Signal/Images.xcassets/database-corrupted.imageset/Contents.json
@@ -0,0 +1,12 @@
+{
+  "images" : [
+    {
+      "filename" : "database-corrupted.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Signal/Images.xcassets/database-corrupted.imageset/database-corrupted.pdf b/Signal/Images.xcassets/database-corrupted.imageset/database-corrupted.pdf
new file mode 100644
index 00000000000..94880e2e34d
Binary files /dev/null and b/Signal/Images.xcassets/database-corrupted.imageset/database-corrupted.pdf differ
diff --git a/Signal/Images.xcassets/database-recovered.imageset/Contents.json b/Signal/Images.xcassets/database-recovered.imageset/Contents.json
new file mode 100644
index 00000000000..dbeb9df5fc0
--- /dev/null
+++ b/Signal/Images.xcassets/database-recovered.imageset/Contents.json
@@ -0,0 +1,12 @@
+{
+  "images" : [
+    {
+      "filename" : "database-success.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Signal/Images.xcassets/database-recovered.imageset/database-success.pdf b/Signal/Images.xcassets/database-recovered.imageset/database-success.pdf
new file mode 100644
index 00000000000..1c1e1fee769
Binary files /dev/null and b/Signal/Images.xcassets/database-recovered.imageset/database-success.pdf differ
diff --git a/Signal/src/AppDelegate.h b/Signal/src/AppDelegate.h
index 44dc277753f..193af93ff8d 100644
--- a/Signal/src/AppDelegate.h
+++ b/Signal/src/AppDelegate.h
@@ -26,7 +26,8 @@ extern NSString *const kAppLaunchesAttemptedKey;
 @property (nonatomic, readwrite) BOOL shouldKillAppWhenBackgrounded;
 
 - (BOOL)launchToHomeScreenWithLaunchOptions:(NSDictionary *_Nullable)launchOptions
-                       instrumentsMonitorId:(unsigned long long)monitorId;
+                       instrumentsMonitorId:(unsigned long long)monitorId
+                  isEnvironmentAlreadySetUp:(BOOL)isEnvironmentAlreadySetUp;
 
 @end
 
diff --git a/Signal/src/AppDelegate.m b/Signal/src/AppDelegate.m
index a49498b9567..21e209f5fc7 100644
--- a/Signal/src/AppDelegate.m
+++ b/Signal/src/AppDelegate.m
@@ -218,12 +218,15 @@ - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(
         return YES;
     }
 
-    [self launchToHomeScreenWithLaunchOptions:launchOptions instrumentsMonitorId:monitorId];
+    [self launchToHomeScreenWithLaunchOptions:launchOptions
+                         instrumentsMonitorId:monitorId
+                    isEnvironmentAlreadySetUp:NO];
     return YES;
 }
 
 - (BOOL)launchToHomeScreenWithLaunchOptions:(NSDictionary *_Nullable)launchOptions
                        instrumentsMonitorId:(unsigned long long)monitorId
+                  isEnvironmentAlreadySetUp:(BOOL)isEnvironmentAlreadySetUp
 {
     [self setupNSEInteroperation];
 
@@ -237,17 +240,8 @@ - (BOOL)launchToHomeScreenWithLaunchOptions:(NSDictionary *_Nullable)launchOptio
     AppReadinessRunNowOrWhenMainAppDidBecomeReadyAsync(
         ^{ [[CurrentAppContext() appUserDefaults] removeObjectForKey:kAppLaunchesAttemptedKey]; });
 
-    [AppSetup setupEnvironmentWithPaymentsEvents:[PaymentsEventsMainApp new]
-                                mobileCoinHelper:[MobileCoinHelperSDK new]
-                                webSocketFactory:[WebSocketFactoryHybrid new]
-                       appSpecificSingletonBlock:^{
-            // Create SUIEnvironment.
-            [SUIEnvironment.shared setup];
-            // Create AppEnvironment.
-            [AppEnvironment.shared setup];
-            [SignalApp.shared setup];
-        }
-        migrationCompletion:^(NSError *_Nullable error) {
+    if (!isEnvironmentAlreadySetUp) {
+        [AppDelegate setUpMainAppEnvironmentWithCompletion:^(NSError *_Nullable error) {
             OWSAssertIsOnMainThread();
 
             if (error != nil) {
@@ -257,6 +251,7 @@ - (BOOL)launchToHomeScreenWithLaunchOptions:(NSDictionary *_Nullable)launchOptio
                 [self versionMigrationsDidComplete];
             }
         }];
+    }
 
     [UIUtil setupSignalAppearence];
 
diff --git a/Signal/src/AppDelegate.swift b/Signal/src/AppDelegate.swift
index 22a8b799855..aa892aab96e 100644
--- a/Signal/src/AppDelegate.swift
+++ b/Signal/src/AppDelegate.swift
@@ -10,6 +10,7 @@ enum LaunchFailure: UInt, CustomStringConvertible {
     case couldNotLoadDatabase
     case unknownDatabaseVersion
     case couldNotRestoreTransferredData
+    case databaseCorruptedAndMightBeRecoverable
     case databaseUnrecoverablyCorrupted
     case lastAppLaunchCrashed
     case lowStorageSpaceAvailable
@@ -24,6 +25,8 @@ enum LaunchFailure: UInt, CustomStringConvertible {
             return "LaunchFailure_UnknownDatabaseVersion"
         case .couldNotRestoreTransferredData:
             return "LaunchFailure_CouldNotRestoreTransferredData"
+        case .databaseCorruptedAndMightBeRecoverable:
+            return "LaunchFailure_DatabaseCorruptedAndMightBeRecoverable"
         case .databaseUnrecoverablyCorrupted:
             return "LaunchFailure_DatabaseUnrecoverablyCorrupted"
         case .lastAppLaunchCrashed:
@@ -35,6 +38,41 @@ enum LaunchFailure: UInt, CustomStringConvertible {
 }
 
 extension AppDelegate {
+    // MARK: - App launch
+
+    static func setUpMainAppEnvironment() -> Promise<Void> {
+        let (promise, future) = Promise<Void>.pending()
+        AppSetup.setupEnvironment(
+            paymentsEvents: PaymentsEventsMainApp(),
+            mobileCoinHelper: MobileCoinHelperSDK(),
+            webSocketFactory: WebSocketFactoryHybrid(),
+            appSpecificSingletonBlock: {
+                SUIEnvironment.shared.setup()
+                AppEnvironment.shared.setup()
+                SignalApp.shared().setup()
+            },
+            migrationCompletion: { error in
+                if let error = error {
+                    future.reject(error)
+                } else {
+                    future.resolve()
+                }
+            }
+        )
+        return promise
+    }
+
+    @objc(setUpMainAppEnvironmentWithCompletion:)
+    static func setUpMainAppEnvironment(completion: @escaping (Error?) -> Void) {
+        firstly(on: .main) {
+            setUpMainAppEnvironment()
+        }.done(on: .main) {
+            completion(nil)
+        }.catch(on: .main) { error in
+            completion(error)
+        }
+    }
+
     func checkSomeDiskSpaceAvailable() -> Bool {
         let tempDir = URL(fileURLWithPath: NSTemporaryDirectory())
             .appendingPathComponent(UUID().uuidString)
@@ -193,12 +231,20 @@ extension AppDelegate {
 
         let userDefaults = CurrentAppContext().appUserDefaults()
 
-        let databaseCorruptionStatus = DatabaseCorruptionState.databaseCorruptionStatus(userDefaults: userDefaults)
-        switch databaseCorruptionStatus {
+        let databaseCorruptionState = DatabaseCorruptionState(userDefaults: userDefaults)
+        switch databaseCorruptionState.status {
         case .notCorrupted:
             break
-        case .corrupted:
-            return .databaseUnrecoverablyCorrupted
+        case .corrupted, .corruptedButAlreadyDumpedAndRestored:
+            guard !UIDevice.current.isIPad else {
+                // Database recovery theoretically works on iPad,
+                // but we haven't built the UI for it.
+                return .databaseUnrecoverablyCorrupted
+            }
+            guard databaseCorruptionState.count <= 3 else {
+                return .databaseUnrecoverablyCorrupted
+            }
+            return .databaseCorruptedAndMightBeRecoverable
         }
 
         let appVersion = AppVersion.shared()
@@ -244,94 +290,204 @@ extension AppDelegate {
 
         window.makeKeyAndVisible()
 
-        let actionSheet = getActionSheet(for: launchFailure, from: viewController) {
-            switch launchFailure {
-            case .lastAppLaunchCrashed:
-                // Pretend we didn't fail!
-                self.didAppLaunchFail = false
-                self.launchToHomeScreen(launchOptions: nil, instrumentsMonitorId: 0)
-            default:
-                owsFail("exiting after sharing debug logs.")
-            }
-        }
-
-        viewController.presentActionSheet(actionSheet)
-    }
-
-    func getActionSheet(for launchFailure: LaunchFailure,
-                        from viewController: UIViewController,
-                        onContinue: @escaping () -> Void) -> ActionSheetController {
-        let title: String
-        var message: String = NSLocalizedString("APP_LAUNCH_FAILURE_ALERT_MESSAGE",
-                                                comment: "Message for the 'app launch failed' alert.")
         switch launchFailure {
-        case .databaseUnrecoverablyCorrupted, .couldNotLoadDatabase:
-            title = NSLocalizedString("APP_LAUNCH_FAILURE_COULD_NOT_LOAD_DATABASE",
-                                      comment: "Error indicating that the app could not launch because the database could not be loaded.")
+        case .couldNotLoadDatabase, .databaseUnrecoverablyCorrupted:
+            presentLaunchFailureActionSheet(
+                from: viewController,
+                launchFailure: launchFailure,
+                title: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_COULD_NOT_LOAD_DATABASE",
+                    comment: "Error indicating that the app could not launch because the database could not be loaded."
+                ),
+                actions: [.submitDebugLogsWithDatabaseIntegrityCheckAndCrash]
+            )
         case .unknownDatabaseVersion:
-            title = NSLocalizedString("APP_LAUNCH_FAILURE_INVALID_DATABASE_VERSION_TITLE",
-                                      comment: "Error indicating that the app could not launch without reverting unknown database migrations.")
-            message = NSLocalizedString("APP_LAUNCH_FAILURE_INVALID_DATABASE_VERSION_MESSAGE",
-                                        comment: "Error indicating that the app could not launch without reverting unknown database migrations.")
+            presentLaunchFailureActionSheet(
+                from: viewController,
+                launchFailure: launchFailure,
+                title: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_INVALID_DATABASE_VERSION_TITLE",
+                    comment: "Error indicating that the app could not launch without reverting unknown database migrations."
+                ),
+                message: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_INVALID_DATABASE_VERSION_MESSAGE",
+                    comment: "Error indicating that the app could not launch without reverting unknown database migrations."
+                ),
+                actions: [.submitDebugLogs(and: .crash)]
+            )
         case .couldNotRestoreTransferredData:
-            title = NSLocalizedString("APP_LAUNCH_FAILURE_RESTORE_FAILED_TITLE",
-                                      comment: "Error indicating that the app could not restore transferred data.")
-            message = NSLocalizedString("APP_LAUNCH_FAILURE_RESTORE_FAILED_MESSAGE",
-                                        comment: "Error indicating that the app could not restore transferred data.")
+            presentLaunchFailureActionSheet(
+                from: viewController,
+                launchFailure: launchFailure,
+                title: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_RESTORE_FAILED_TITLE",
+                    comment: "Error indicating that the app could not restore transferred data."
+                ),
+                message: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_RESTORE_FAILED_MESSAGE",
+                    comment: "Error indicating that the app could not restore transferred data."
+                ),
+                actions: [.submitDebugLogs(and: .crash)]
+            )
+        case .databaseCorruptedAndMightBeRecoverable:
+            let recoveryViewController = DatabaseRecoveryViewController(
+                setupSskEnvironment: { () -> Promise<Void> in
+                    firstly(on: .main) {
+                        Self.setUpMainAppEnvironment()
+                    }.catch(on: .main) { error in
+                        owsFailDebug("Error: \(error)")
+                        self.showUI(forLaunchFailure: .couldNotLoadDatabase)
+                    }
+                },
+                launchApp: {
+                    // Pretend we didn't fail!
+                    self.didAppLaunchFail = false
+                    self.versionMigrationsDidComplete()
+                    self.launchToHomeScreen(launchOptions: nil, instrumentsMonitorId: 0, isEnvironmentAlreadySetUp: true)
+                }
+            )
+
+            // Prevent dismissal.
+            if #available(iOS 13, *) {
+                recoveryViewController.isModalInPresentation = true
+            } else {
+                // This presents it fullscreen. Not ideal, but only affects old iOS versions, and prevents dismissal.
+                recoveryViewController.modalPresentationStyle = .fullScreen
+            }
+
+            // Show as a half-sheet on iOS 15+. On older versions, the sheet fills the screen, which is okay.
+            if
+                #available(iOS 15, *),
+                let presentationController = recoveryViewController.presentationController as? UISheetPresentationController {
+                presentationController.detents = [.medium()]
+                presentationController.prefersEdgeAttachedInCompactHeight = true
+                presentationController.widthFollowsPreferredContentSizeWhenEdgeAttached = true
+            }
+
+            viewController.present(recoveryViewController, animated: true)
         case .lastAppLaunchCrashed:
-            title = NSLocalizedString("APP_LAUNCH_FAILURE_LAST_LAUNCH_CRASHED_TITLE",
-                                      comment: "Error indicating that the app crashed during the previous launch.")
-            message = NSLocalizedString("APP_LAUNCH_FAILURE_LAST_LAUNCH_CRASHED_MESSAGE",
-                                        comment: "Error indicating that the app crashed during the previous launch.")
+            presentLaunchFailureActionSheet(
+                from: viewController,
+                launchFailure: launchFailure,
+                title: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_LAST_LAUNCH_CRASHED_TITLE",
+                    comment: "Error indicating that the app crashed during the previous launch."
+                ),
+                message: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_LAST_LAUNCH_CRASHED_MESSAGE",
+                    comment: "Error indicating that the app crashed during the previous launch."
+                ),
+                actions: [.submitDebugLogs(and: .launchApp), .launchApp]
+            )
         case .lowStorageSpaceAvailable:
-            title = NSLocalizedString("APP_LAUNCH_FAILURE_LOW_STORAGE_SPACE_AVAILABLE_TITLE",
-                                      comment: "Error title indicating that the app crashed because there was low storage space available on the device.")
-            message = NSLocalizedString("APP_LAUNCH_FAILURE_LOW_STORAGE_SPACE_AVAILABLE_MESSAGE",
-                                        comment: "Error description indicating that the app crashed because there was low storage space available on the device.")
+            presentLaunchFailureActionSheet(
+                from: viewController,
+                launchFailure: launchFailure,
+                title: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_LOW_STORAGE_SPACE_AVAILABLE_TITLE",
+                    comment: "Error title indicating that the app crashed because there was low storage space available on the device."
+                ),
+                message: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_LOW_STORAGE_SPACE_AVAILABLE_MESSAGE",
+                    comment: "Error description indicating that the app crashed because there was low storage space available on the device."
+                ),
+                actions: []
+            )
         case .none:
             owsFailDebug("Unknown launch failure.")
-            title = NSLocalizedString("APP_LAUNCH_FAILURE_ALERT_TITLE", comment: "Title for the 'app launch failed' alert.")
+            presentLaunchFailureActionSheet(
+                from: viewController,
+                launchFailure: launchFailure,
+                title: NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_ALERT_TITLE",
+                    comment: "Title for the 'app launch failed' alert."
+                ),
+                actions: [.submitDebugLogs(and: .crash)]
+            )
+        }
+    }
+
+    private enum LaunchFailureActionSheetAction {
+        enum ActionAfterSubmittingDebugLogs {
+            case crash
+            case launchApp
         }
 
-        let result = ActionSheetController(title: title, message: message)
+        case submitDebugLogs(and: ActionAfterSubmittingDebugLogs)
+        case submitDebugLogsWithDatabaseIntegrityCheckAndCrash
+        case launchApp
+    }
+
+    private func presentLaunchFailureActionSheet(
+        from viewController: UIViewController,
+        launchFailure: LaunchFailure,
+        title: String,
+        message: String = NSLocalizedString(
+            "APP_LAUNCH_FAILURE_ALERT_MESSAGE",
+            comment: "Default message for the 'app launch failed' alert."
+        ),
+        actions: [LaunchFailureActionSheetAction]
+    ) {
+        let actionSheet = ActionSheetController(title: title, message: message)
 
         if DebugFlags.internalSettings {
-            result.addAction(.init(title: "Export Database (internal)") { _ in
+            actionSheet.addAction(.init(title: "Export Database (internal)") { _ in
                 SignalApp.showExportDatabaseUI(from: viewController) { [weak viewController] in
-                    viewController?.presentActionSheet(result)
+                    viewController?.presentActionSheet(actionSheet)
                 }
             })
         }
 
-        if launchFailure != .lowStorageSpaceAvailable {
-            let title = NSLocalizedString("SETTINGS_ADVANCED_SUBMIT_DEBUGLOG", comment: "")
-            result.addAction(.init(title: title) { _ in
-                func submitDebugLogs() {
-                    Pastelog.submitLogs(
-                        withSupportTag: String(describing: launchFailure),
-                        completion: onContinue
-                    )
-                }
-
-                if launchFailure == .databaseUnrecoverablyCorrupted {
-                    SignalApp.showDatabaseIntegrityCheckUI(from: viewController,
-                                                           completion: submitDebugLogs)
-                } else {
-                    submitDebugLogs()
-                }
+        func addSubmitDebugLogsAction(handler: @escaping () -> Void) {
+            let actionTitle = NSLocalizedString("SETTINGS_ADVANCED_SUBMIT_DEBUGLOG", comment: "")
+            actionSheet.addAction(.init(title: actionTitle) { _ in
+                handler()
             })
         }
 
-        if launchFailure == .lastAppLaunchCrashed {
-            // Use a cancel-style button to draw attention.
-            let title = NSLocalizedString("APP_LAUNCH_FAILURE_CONTINUE",
-                                          comment: "Button to try launching the app even though the last launch failed")
-            result.addAction(.init(title: title, style: .cancel) { _ in
-                onContinue()
-            })
+        lazy var supportTag = String(describing: launchFailure)
+
+        func launchApp() {
+            // Pretend we didn't fail!
+            self.didAppLaunchFail = false
+            self.checkIfAppIsReady()
+            self.launchToHomeScreen(launchOptions: nil, instrumentsMonitorId: 0, isEnvironmentAlreadySetUp: false)
         }
 
-        return result
+        for action in actions {
+            switch action {
+            case let .submitDebugLogs(actionAfterSubmitting):
+                addSubmitDebugLogsAction {
+                    Pastelog.submitLogs(withSupportTag: supportTag) {
+                        switch actionAfterSubmitting {
+                        case .crash:
+                            owsFail("Exiting after submitting debug logs")
+                        case .launchApp:
+                            launchApp()
+                        }
+                    }
+                }
+            case .submitDebugLogsWithDatabaseIntegrityCheckAndCrash:
+                addSubmitDebugLogsAction {
+                    SignalApp.showDatabaseIntegrityCheckUI(from: viewController) {
+                        Pastelog.submitLogs(withSupportTag: supportTag) {
+                            owsFail("Exiting after submitting debug logs")
+                        }
+                    }
+                }
+            case .launchApp:
+                // Use a cancel-style button to draw attention.
+                let title = NSLocalizedString(
+                    "APP_LAUNCH_FAILURE_CONTINUE",
+                    comment: "Button to try launching the app even though the last launch failed"
+                )
+                actionSheet.addAction(.init(title: title, style: .cancel) { _ in
+                    launchApp()
+                })
+            }
+        }
+
+        viewController.presentActionSheet(actionSheet)
     }
 
     // MARK: - Remote notifications
diff --git a/Signal/src/ViewControllers/DatabaseRecoveryViewController.swift b/Signal/src/ViewControllers/DatabaseRecoveryViewController.swift
new file mode 100644
index 00000000000..762cbe89a57
--- /dev/null
+++ b/Signal/src/ViewControllers/DatabaseRecoveryViewController.swift
@@ -0,0 +1,552 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import SignalServiceKit
+
+class DatabaseRecoveryViewController: OWSViewController {
+    private let setupSskEnvironment: () -> Promise<Void>
+    private let launchApp: () -> Void
+
+    public init(
+        setupSskEnvironment: @escaping () -> Promise<Void>,
+        launchApp: @escaping () -> Void
+    ) {
+        self.setupSskEnvironment = setupSskEnvironment
+        self.launchApp = launchApp
+    }
+
+    // MARK: - State
+
+    enum State: Equatable {
+        case awaitingUserConfirmation
+        case showingDeviceSpaceWarning
+        case recovering(fractionCompleted: Double)
+        case recoveryFailed
+        case recoverySucceeded
+    }
+
+    private var state: State = .awaitingUserConfirmation {
+        didSet {
+            AssertIsOnMainThread()
+            render()
+        }
+    }
+    private var previouslyRenderedState: State?
+
+    private var databaseFileUrl: URL { GRDBDatabaseStorageAdapter.databaseFileUrl() }
+
+    private var currentDatabaseSize: UInt64 {
+        DatabaseRecovery.databaseFileSize(forDatabaseAt: databaseFileUrl)
+    }
+
+    // MARK: - Views
+
+    private let stackView: UIStackView = {
+        let view = UIStackView()
+        view.axis = .vertical
+        view.distribution = .equalSpacing
+        view.alignment = .center
+        view.layoutMargins = .init(hMargin: 32, vMargin: 46)
+        view.isLayoutMarginsRelativeArrangement = true
+        return view
+    }()
+
+    private let headlineLabel: UILabel = {
+        let label = UILabel()
+        label.font = .ows_dynamicTypeTitle2.ows_semibold
+        label.textColor = Theme.primaryTextColor
+        label.textAlignment = .center
+        label.numberOfLines = 0
+        return label
+    }()
+
+    private let descriptionLabel: UILabel = {
+        let label = UILabel()
+        label.font = .ows_dynamicTypeBody2
+        label.textColor = Theme.secondaryTextAndIconColor
+        label.textAlignment = .center
+        label.numberOfLines = 0
+        return label
+    }()
+
+    private var databaseCorruptedImage: UIImageView {
+        let view = UIImageView()
+        view.image = UIImage(named: "database-corrupted")
+        view.autoSetDimensions(to: .init(width: 62, height: 88))
+        return view
+    }
+
+    private var databaseRecoveredImage: UIImageView {
+        let view = UIImageView()
+        view.image = UIImage(named: "database-recovered")
+        view.autoSetDimensions(to: .init(width: 62, height: 88))
+        return view
+    }
+
+    private lazy var progressStack: UIStackView = {
+        let view = UIStackView(arrangedSubviews: [
+            progressLabel,
+            UIView.spacer(withHeight: 20),
+            progressBar
+        ])
+        view.axis = .vertical
+        view.distribution = .equalSpacing
+        view.alignment = .center
+
+        progressLabel.autoPinWidthToSuperviewMargins()
+        progressBar.autoPinWidthToSuperviewMargins()
+
+        return view
+    }()
+
+    private lazy var progressLabel: UILabel = {
+        let label = UILabel()
+        label.font = .ows_dynamicTypeBody2
+        label.textAlignment = .center
+        label.numberOfLines = 0
+        return label
+    }()
+
+    private lazy var progressBar: UIProgressView = {
+        let bar = UIProgressView()
+        bar.progressTintColor = .ows_accentBlue
+        return bar
+    }()
+
+    // MARK: - View callbacks
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        view.addSubview(stackView)
+        stackView.autoPinEdgesToSuperviewEdges()
+
+        render()
+    }
+
+    // MARK: - Events
+
+    @objc
+    private func didTapContinueToStartRecovery() {
+        switch state {
+        case .awaitingUserConfirmation:
+            if hasApproximatelyEnoughDiskSpace() {
+                attemptRecovery()
+            } else {
+                state = .showingDeviceSpaceWarning
+            }
+        default:
+            owsFailDebug("Continue was tapped on the wrong screen")
+        }
+    }
+
+    @objc
+    private func didTapContinueToBypassStorageWarning() {
+        switch state {
+        case .showingDeviceSpaceWarning:
+            attemptRecovery()
+        default:
+            owsFailDebug("Button was tapped on the wrong screen")
+        }
+    }
+
+    @objc
+    private func didTapToResetSignal() {
+        OWSActionSheets.showConfirmationAlert(
+            title: NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_CONFIRMATION_TITLE",
+                value: "Reset Signal",
+                comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) If they want to delete the app and restart, they will be presented with a confirmation dialog. This is the title of that dialog."
+            ),
+            message: NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_CONFIRMATION_DESCRIPTION",
+                value: "Your account info, profile, and all of your messages will be cleared. The app will close after this process is complete.",
+                comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) If they want to delete the app and restart, they will be presented with a confirmation dialog. This is the description text in that dialog."
+            ),
+            proceedTitle: NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_CONFIRMATION_CONFIRM",
+                value: "Reset",
+                comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) If they want to delete the app and restart, they will be presented with a confirmation dialog. This is the final button they will press before their data is reset."
+            ),
+            proceedStyle: .destructive
+        ) { _ in
+            SignalApp.resetAppDataWithUI()
+        }
+    }
+
+    @objc
+    private func didTapToSubmitDebugLogs() {
+        self.dismiss(animated: true) {
+            let supportTag = String(describing: LaunchFailure.databaseCorruptedAndMightBeRecoverable)
+            Pastelog.submitLogs(withSupportTag: supportTag)
+        }
+    }
+
+    private func attemptRecovery() {
+        switch state {
+        case .recovering:
+            owsFailDebug("Already recovering")
+            return
+        default:
+            break
+        }
+
+        state = .recovering(fractionCompleted: 0)
+
+        let progress = Progress(totalUnitCount: 2)
+        let needsDumpAndRestore: Bool
+
+        switch DatabaseCorruptionState(userDefaults: userDefaults).status {
+        case .notCorrupted:
+            owsFailDebug("Database was not corrupted! Why are we on this screen?")
+            state = .recoverySucceeded
+            return
+        case .corrupted:
+            needsDumpAndRestore = true
+        case .corruptedButAlreadyDumpedAndRestored:
+            needsDumpAndRestore = false
+        }
+
+        let progressObserver = progress.observe(\.fractionCompleted, options: [.new]) { [weak self] _, _ in
+            self?.didFractionCompletedChange(fractionCompleted: progress.fractionCompleted)
+        }
+
+        firstly(on: .sharedUserInitiated) {
+            if needsDumpAndRestore {
+                let dumpAndRestore = DatabaseRecovery.DumpAndRestore(databaseFileUrl: self.databaseFileUrl)
+                progress.addChild(dumpAndRestore.progress, withPendingUnitCount: 1)
+                do {
+                    try dumpAndRestore.run()
+                } catch {
+                    return Promise<Void>(error: error)
+                }
+                DatabaseCorruptionState.flagCorruptedDatabaseAsDumpedAndRestored(userDefaults: self.userDefaults)
+            } else {
+                progress.completedUnitCount += 1
+            }
+            return Promise.value(())
+        }.then(on: .sharedUserInitiated) {
+            self.setupSskEnvironment()
+        }.then(on: .sharedUserInitiated) {
+            let manualRecreation = DatabaseRecovery.ManualRecreation(databaseStorage: SDSDatabaseStorage.shared)
+            progress.addChild(manualRecreation.progress, withPendingUnitCount: 1)
+            manualRecreation.run()
+
+            DatabaseCorruptionState.flagDatabaseAsRecoveredFromCorruption(userDefaults: self.userDefaults)
+
+            return Promise.value(())
+        }.done(on: .main) { [weak self] in
+            guard let self = self else { return }
+            self.state = .recoverySucceeded
+        }.ensure {
+            progressObserver.invalidate()
+        }.catch(on: .main) { [weak self] error in
+            self?.didRecoveryFail(with: error)
+        }
+    }
+
+    private func didFractionCompletedChange(fractionCompleted: Double) {
+        switch state {
+        case .awaitingUserConfirmation, .showingDeviceSpaceWarning:
+            owsFailDebug("Unexpectedly got a progress event")
+            fallthrough
+        case .recovering:
+            DispatchQueue.main.async { [weak self] in
+                guard let self = self else { return }
+                self.state = .recovering(fractionCompleted: fractionCompleted)
+            }
+        case .recoveryFailed, .recoverySucceeded:
+            owsFailDebug("Unexpectedly got a progress event")
+        }
+    }
+
+    private func didRecoveryFail(with error: Error) {
+        DispatchQueue.main.async { [weak self] in
+            guard let self = self else { return }
+            if let error = error as? DatabaseRecoveryError {
+                switch error {
+                case .ranOutOfDiskSpace:
+                    self.state = .showingDeviceSpaceWarning
+                case .unrecoverablyCorrupted:
+                    self.state = .recoveryFailed
+                }
+            } else {
+                owsFailDebug("\(error)")
+                self.state = .recoveryFailed
+            }
+        }
+    }
+
+    @objc
+    private func didTapLaunchApp() {
+        switch state {
+        case .recoverySucceeded:
+            dismiss(animated: true) {
+                self.launchApp()
+            }
+        default:
+            owsFailDebug("Button was tapped on the wrong screen")
+        }
+    }
+
+    // MARK: - Top-level renderers
+
+    private func render() {
+        stackView.backgroundColor = Theme.backgroundColor
+
+        switch state {
+        case .awaitingUserConfirmation:
+            renderAwaitingUserConfirmation()
+        case .showingDeviceSpaceWarning:
+            renderDeviceSpaceWarning()
+        case let .recovering(ratioComplete):
+            renderRecovering(fractionCompleted: ratioComplete)
+        case .recoveryFailed:
+            renderRecoveryFailed()
+        case .recoverySucceeded:
+            renderRecoverySucceeded()
+        }
+
+        previouslyRenderedState = state
+    }
+
+    private func renderAwaitingUserConfirmation() {
+        guard previouslyRenderedState != .awaitingUserConfirmation else { return }
+
+        headlineLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_AWAITING_USER_CONFIRMATION_TITLE",
+            value: "Problem Retrieving Data",
+            comment: "In some cases, the user's message history can become corrupted, and a recovery interface is shown. The user has not been hacked and may be confused by this interface, so try to avoid using terms like \"database\" or \"corrupted\"terms like \"message history\" are better. This is the title on the first screen of this interface, which gives them some information and asks them to continue."
+        )
+
+        descriptionLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_AWAITING_USER_CONFIRMATION_DESCRIPTION",
+            value: "Some of your message history may be corrupted. There has been no impact to the security of your account or messages. Tap Continue to recover your data.",
+            comment: "In some cases, the user's message history can become corrupted, and a recovery interface is shown. The user has not been hacked and may be confused by this interface, so keep that in mind. This is the description on the first screen of this interface, which gives them some information and asks them to continue."
+        )
+
+        let continueButton = button(
+            title: CommonStrings.continueButton,
+            selector: #selector(didTapContinueToStartRecovery)
+        )
+
+        stackView.removeAllSubviews()
+        stackView.addArrangedSubviews([
+            headlineLabel,
+            descriptionLabel,
+            databaseCorruptedImage,
+            continueButton
+        ])
+
+        continueButton.autoPinWidthToSuperviewMargins()
+
+        UIApplication.shared.isIdleTimerDisabled = false
+    }
+
+    private func renderDeviceSpaceWarning() {
+        guard previouslyRenderedState != .showingDeviceSpaceWarning else { return }
+
+        headlineLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_MORE_STORAGE_SPACE_NEEDED_TITLE",
+            value: "More Storage Space Needed",
+            comment: "On the database recovery screen, if the user's device storage is nearly full, Signal will not be able to recover the database. A warning screen, which can be bypassed if the user wishes, will be shown. This is the title of that screen."
+        )
+
+        descriptionLabel.text = {
+            let labelFormat = NSLocalizedString(
+                "DATABASE_RECOVERY_MORE_STORAGE_SPACE_NEEDED_DESCRIPTION",
+                value: "In order to complete data recovery, we recommend you have at least %@ of storage space free on your device.",
+                comment: "On the database recovery screen, if the user's device storage is nearly full, Signal will not be able to recover the database. A warning screen, which can be bypassed if the user wishes, will be shown. This is the line of text on that screen. Embeds an amount like \"2GB\"."
+            )
+            let formattedBytes = ByteCountFormatter().string(for: currentDatabaseSize) ?? {
+                owsFailDebug("Could not format the database size for some reason")
+                return String(currentDatabaseSize)
+            }()
+            return String(format: labelFormat, formattedBytes)
+        }()
+
+        let continueButton = button(
+            title: NSLocalizedString(
+                "DATABASE_RECOVERY_MORE_STORAGE_SPACE_NEEDED_CONTINUE_ANYWAY",
+                value: "Continue Anyway",
+                comment: "On the database recovery screen, if the user's device storage is nearly full, Signal will not be able to recover the database. A warning screen, which can be bypassed if the user wishes, will be shown. This is the text on the button to bypass the warning."
+            ),
+            selector: #selector(didTapContinueToBypassStorageWarning)
+        )
+
+        stackView.removeAllSubviews()
+        stackView.addArrangedSubviews([
+            headlineLabel,
+            descriptionLabel,
+            continueButton
+        ])
+
+        continueButton.autoPinWidthToSuperviewMargins()
+
+        UIApplication.shared.isIdleTimerDisabled = false
+    }
+
+    private func renderRecovering(fractionCompleted: Double) {
+        switch previouslyRenderedState {
+        case .recovering:
+            break
+        default:
+            headlineLabel.text = NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_IN_PROGRESS_TITLE",
+                value: "Recovering Data",
+                comment: "On the database recovery screen, this is the title shown as the user's data is being recovered."
+            )
+
+            descriptionLabel.text = NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_IN_PROGRESS_DESCRIPTION",
+                value: "Keep the app open during the recovery process. It may take several minutes.",
+                comment: "On the database recovery screen, this is the description text shown as the user's data is being recovered."
+            )
+
+            progressBar.setProgress(0, animated: false)
+            progressBar.trackTintColor = Theme.isDarkThemeEnabled ? .ows_gray90 : .ows_gray05
+
+            stackView.removeAllSubviews()
+            stackView.addArrangedSubviews([
+                headlineLabel,
+                descriptionLabel,
+                progressStack
+            ])
+
+            progressStack.autoPinWidthToSuperviewMargins()
+
+            UIApplication.shared.isIdleTimerDisabled = true
+        }
+
+        progressLabel.text = Self.render(fractionCompleted: fractionCompleted)
+
+        progressBar.setProgress(Float(fractionCompleted), animated: false)
+    }
+
+    private func renderRecoveryFailed() {
+        guard previouslyRenderedState != .recoveryFailed else { return }
+
+        headlineLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_RECOVERY_FAILED_TITLE",
+            value: "Data Not Recovered",
+            comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) This is the title on the screen where we show an error message."
+        )
+
+        descriptionLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_RECOVERY_FAILED_DESCRIPTION",
+            value: "Your message history couldnt recover. You can continue to use Signal after resetting. Submit a debug log so we can better understand what went wrong.",
+            comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) This is the description on the screen where we show an error message."
+        )
+
+        let resetSignalButton = self.button(
+            title: NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_BUTTON",
+                value: "Reset Signal",
+                comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) This button lets them delete all of their data."
+            ),
+            selector: #selector(didTapToResetSignal),
+            backgroundColor: .ows_accentRed
+        )
+
+        let submitDebugLogsButton = self.button(
+            title: NSLocalizedString(
+                "DATABASE_RECOVERY_RECOVERY_FAILED_SUBMIT_DEBUG_LOG_BUTTON",
+                value: "Submit Debug Log",
+                comment: "The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) They were asked to submit a debug log. This is the button that submits this log."
+            ),
+            selector: #selector(didTapToSubmitDebugLogs)
+        )
+
+        stackView.removeAllSubviews()
+        stackView.addArrangedSubviews([
+            headlineLabel,
+            descriptionLabel,
+            databaseCorruptedImage,
+            resetSignalButton,
+            submitDebugLogsButton
+        ])
+
+        resetSignalButton.autoPinWidthToSuperviewMargins()
+        submitDebugLogsButton.autoPinWidthToSuperviewMargins()
+
+        UIApplication.shared.isIdleTimerDisabled = false
+    }
+
+    private func renderRecoverySucceeded() {
+        guard previouslyRenderedState != .recoverySucceeded else { return }
+
+        headlineLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_RECOVERY_SUCCEEDED_TITLE",
+            value: "Data Successfully Recovered",
+            comment: "The user has successfully recovered their database after it was lost due to corruption. (They have not been hacked.) This is the title on the screen that tells them things worked."
+        )
+
+        descriptionLabel.text = NSLocalizedString(
+            "DATABASE_RECOVERY_RECOVERY_SUCCEEDED_DESCRIPTION",
+            value: "Recovery was successful, but some messages may not have been recovered.",
+            comment: "The user has successfully recovered their database after it was lost due to corruption. (They have not been hacked.) This is the description on the screen that tells them things worked."
+        )
+
+        let launchAppButton = button(
+            title: CommonStrings.continueButton,
+            selector: #selector(didTapLaunchApp)
+        )
+
+        stackView.removeAllSubviews()
+        stackView.addArrangedSubviews([
+            headlineLabel,
+            descriptionLabel,
+            databaseRecoveredImage,
+            launchAppButton
+        ])
+
+        launchAppButton.autoPinWidthToSuperviewMargins()
+
+        UIApplication.shared.isIdleTimerDisabled = false
+    }
+
+    // MARK: - Utilities
+
+    private var userDefaults: UserDefaults { CurrentAppContext().appUserDefaults() }
+
+    /// Determine whether the user has *approximately* enough space for recovery.
+    ///
+    /// The heuristic: do we have N remaining bytes, where N is the current size of the database?
+    ///
+    /// - Returns: `true` if the user has approximately enough disk space, or if any part of the check fails. `false` if they do not have enough disk space.
+    private func hasApproximatelyEnoughDiskSpace() -> Bool {
+        do {
+            let freeSpace = try OWSFileSystem.freeSpaceInBytes(forPath: databaseFileUrl)
+            return freeSpace >= currentDatabaseSize
+        } catch {
+            owsFailDebug("\(error)")
+            return true
+        }
+    }
+
+    private func button(title: String, selector: Selector, backgroundColor: UIColor = .ows_accentBlue) -> UIView {
+        let button = OWSFlatButton.button(
+            title: title,
+            font: UIFont.ows_dynamicTypeBody.ows_semibold,
+            titleColor: .white,
+            backgroundColor: backgroundColor,
+            target: self,
+            selector: selector
+        )
+        button.autoSetHeightUsingFont()
+        button.cornerRadius = 8
+        return button
+    }
+
+    static func render(fractionCompleted: Double) -> String {
+        let numberFormatter = NumberFormatter()
+        numberFormatter.numberStyle = .percent
+        guard let result = numberFormatter.string(for: fractionCompleted) else {
+            owsFailDebug("Unable to render ratio with number formatter")
+            return ""
+        }
+        return result
+    }
+}
diff --git a/Signal/src/util/Device Transfer/DeviceTransferService+Manifest.swift b/Signal/src/util/Device Transfer/DeviceTransferService+Manifest.swift
index d8972589ab2..edd764f4b0b 100644
--- a/Signal/src/util/Device Transfer/DeviceTransferService+Manifest.swift	
+++ b/Signal/src/util/Device Transfer/DeviceTransferService+Manifest.swift	
@@ -210,8 +210,7 @@ extension DeviceTransferService {
         // Check if there is enough space on disk to receive the transfer
 
         guard let freeSpaceInBytes = try? OWSFileSystem.freeSpaceInBytes(
-            forPath: DeviceTransferService.pendingTransferDirectory.path,
-            fileManager: FileManager.default
+            forPath: DeviceTransferService.pendingTransferDirectory
         ) else {
             return self.failTransfer(.assertion, "failed to calculate available disk space")
         }
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 7a83b3e1b94..c58804325fc 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -121,7 +121,7 @@
 /* notification body */
 "APN_Message" = "You may have new messages";
 
-/* Message for the 'app launch failed' alert. */
+/* Default message for the 'app launch failed' alert. */
 "APP_LAUNCH_FAILURE_ALERT_MESSAGE" = "Signal can't launch. Please send a debug log to support@signal.org so that we can troubleshoot this issue.";
 
 /* Title for the 'app launch failed' alert. */
@@ -1471,6 +1471,54 @@
 /* Title for alert before running a database integrity check */
 "DATABASE_INTEGRITY_CHECK_TITLE" = "Run database diagnostic?";
 
+/* In some cases, the user's message history can become corrupted, and a recovery interface is shown. The user has not been hacked and may be confused by this interface, so keep that in mind. This is the description on the first screen of this interface, which gives them some information and asks them to continue. */
+"DATABASE_RECOVERY_AWAITING_USER_CONFIRMATION_DESCRIPTION" = "Some of your message history may be corrupted. There has been no impact to the security of your account or messages. Tap Continue to recover your data.";
+
+/* In some cases, the user's message history can become corrupted, and a recovery interface is shown. The user has not been hacked and may be confused by this interface, so try to avoid using terms like \"database\" or \"corrupted\"terms like \"message history\" are better. This is the title on the first screen of this interface, which gives them some information and asks them to continue. */
+"DATABASE_RECOVERY_AWAITING_USER_CONFIRMATION_TITLE" = "Problem Retrieving Data";
+
+/* On the database recovery screen, if the user's device storage is nearly full, Signal will not be able to recover the database. A warning screen, which can be bypassed if the user wishes, will be shown. This is the text on the button to bypass the warning. */
+"DATABASE_RECOVERY_MORE_STORAGE_SPACE_NEEDED_CONTINUE_ANYWAY" = "Continue Anyway";
+
+/* On the database recovery screen, if the user's device storage is nearly full, Signal will not be able to recover the database. A warning screen, which can be bypassed if the user wishes, will be shown. This is the line of text on that screen. Embeds an amount like \"2GB\". */
+"DATABASE_RECOVERY_MORE_STORAGE_SPACE_NEEDED_DESCRIPTION" = "In order to complete data recovery, we recommend you have at least %@ of storage space free on your device.";
+
+/* On the database recovery screen, if the user's device storage is nearly full, Signal will not be able to recover the database. A warning screen, which can be bypassed if the user wishes, will be shown. This is the title of that screen. */
+"DATABASE_RECOVERY_MORE_STORAGE_SPACE_NEEDED_TITLE" = "More Storage Space Needed";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) This is the description on the screen where we show an error message. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_DESCRIPTION" = "Your message history couldnt recover. You can continue to use Signal after reinstalling. Submit a debug log so we can better understand what went wrong.";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) This button lets them delete all of their data. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_BUTTON" = "Reset Signal";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) If they want to delete the app and restart, they will be presented with a confirmation dialog. This is the final button they will press before their data is reset. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_CONFIRMATION_CONFIRM" = "Reset";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) If they want to delete the app and restart, they will be presented with a confirmation dialog. This is the description text in that dialog. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_CONFIRMATION_DESCRIPTION" = "Your account info, profile, and all of your messages will be cleared. The app will close after this process is complete.";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) If they want to delete the app and restart, they will be presented with a confirmation dialog. This is the title of that dialog. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_RESET_APP_CONFIRMATION_TITLE" = "Reset Signal";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) They were asked to submit a debug log. This is the button that submits this log. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_SUBMIT_DEBUG_LOG_BUTTON" = "Submit Debug Log";
+
+/* The user has tried to recover their data after it was lost due to corruption. (They have not been hacked.) This is the title on the screen where we show an error message. */
+"DATABASE_RECOVERY_RECOVERY_FAILED_TITLE" = "Data Not Recovered";
+
+/* On the database recovery screen, this is the description text shown as the user's data is being recovered. */
+"DATABASE_RECOVERY_RECOVERY_IN_PROGRESS_DESCRIPTION" = "Keep the app open during the recovery process. It may take several minutes.";
+
+/* On the database recovery screen, this is the title shown as the user's data is being recovered. */
+"DATABASE_RECOVERY_RECOVERY_IN_PROGRESS_TITLE" = "Recovering Data";
+
+/* The user has successfully recovered their database after it was lost due to corruption. (They have not been hacked.) This is the description on the screen that tells them things worked. */
+"DATABASE_RECOVERY_RECOVERY_SUCCEEDED_DESCRIPTION" = "Recovery was successful, but some messages may not have been recovered.";
+
+/* The user has successfully recovered their database after it was lost due to corruption. (They have not been hacked.) This is the title on the screen that tells them things worked. */
+"DATABASE_RECOVERY_RECOVERY_SUCCEEDED_TITLE" = "Data Successfully Recovered";
+
 /* Subtitle shown while the app is updating its database. */
 "DATABASE_VIEW_OVERLAY_SUBTITLE" = "This can take a few minutes.";
 
diff --git a/SignalServiceKit/src/Contacts/OWSDisappearingMessagesConfiguration+SDS.swift b/SignalServiceKit/src/Contacts/OWSDisappearingMessagesConfiguration+SDS.swift
index 083e2a8499d..9794c57de94 100644
--- a/SignalServiceKit/src/Contacts/OWSDisappearingMessagesConfiguration+SDS.swift
+++ b/SignalServiceKit/src/Contacts/OWSDisappearingMessagesConfiguration+SDS.swift
@@ -137,6 +137,15 @@ extension OWSDisappearingMessagesConfiguration: SDSModel {
     public static var table: SDSTableMetadata {
         OWSDisappearingMessagesConfigurationSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Contacts/SignalAccount+SDS.swift b/SignalServiceKit/src/Contacts/SignalAccount+SDS.swift
index 01ad2abf972..a8c817246ad 100644
--- a/SignalServiceKit/src/Contacts/SignalAccount+SDS.swift
+++ b/SignalServiceKit/src/Contacts/SignalAccount+SDS.swift
@@ -158,6 +158,15 @@ extension SignalAccount: SDSModel {
     public static var table: SDSTableMetadata {
         SignalAccountSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Contacts/SignalRecipient+SDS.swift b/SignalServiceKit/src/Contacts/SignalRecipient+SDS.swift
index 4b9ef375e83..e719307ce41 100644
--- a/SignalServiceKit/src/Contacts/SignalRecipient+SDS.swift
+++ b/SignalServiceKit/src/Contacts/SignalRecipient+SDS.swift
@@ -148,6 +148,15 @@ extension SignalRecipient: SDSModel {
     public static var table: SDSTableMetadata {
         SignalRecipientSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Contacts/TSThread+SDS.swift b/SignalServiceKit/src/Contacts/TSThread+SDS.swift
index 81a6e872c5e..e7775db7bdf 100644
--- a/SignalServiceKit/src/Contacts/TSThread+SDS.swift
+++ b/SignalServiceKit/src/Contacts/TSThread+SDS.swift
@@ -371,6 +371,15 @@ extension TSThread: SDSModel {
     public static var table: SDSTableMetadata {
         TSThreadSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Devices/OWSDevice+SDS.swift b/SignalServiceKit/src/Devices/OWSDevice+SDS.swift
index 43e03d316f2..e9753177b64 100644
--- a/SignalServiceKit/src/Devices/OWSDevice+SDS.swift
+++ b/SignalServiceKit/src/Devices/OWSDevice+SDS.swift
@@ -149,6 +149,15 @@ extension OWSDevice: SDSModel {
     public static var table: SDSTableMetadata {
         OWSDeviceSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Messages/Attachments/TSAttachment+SDS.swift b/SignalServiceKit/src/Messages/Attachments/TSAttachment+SDS.swift
index 2a2f73c02f7..ffcd2627e45 100644
--- a/SignalServiceKit/src/Messages/Attachments/TSAttachment+SDS.swift
+++ b/SignalServiceKit/src/Messages/Attachments/TSAttachment+SDS.swift
@@ -344,6 +344,15 @@ extension TSAttachment: SDSModel {
     public static var table: SDSTableMetadata {
         TSAttachmentSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift b/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift
index da7c84b5205..d7347201ff4 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift
+++ b/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift
@@ -1709,6 +1709,15 @@ extension TSInteraction: SDSModel {
     public static var table: SDSTableMetadata {
         TSInteractionSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Messages/OWSMessageContentJob+SDS.swift b/SignalServiceKit/src/Messages/OWSMessageContentJob+SDS.swift
index a5828df3159..c2007db478a 100644
--- a/SignalServiceKit/src/Messages/OWSMessageContentJob+SDS.swift
+++ b/SignalServiceKit/src/Messages/OWSMessageContentJob+SDS.swift
@@ -153,6 +153,15 @@ extension OWSMessageContentJob: SDSModel {
     public static var table: SDSTableMetadata {
         OWSMessageContentJobSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Messages/Stickers/InstalledSticker+SDS.swift b/SignalServiceKit/src/Messages/Stickers/InstalledSticker+SDS.swift
index 0d612acfadf..7a17c96008a 100644
--- a/SignalServiceKit/src/Messages/Stickers/InstalledSticker+SDS.swift
+++ b/SignalServiceKit/src/Messages/Stickers/InstalledSticker+SDS.swift
@@ -143,6 +143,15 @@ extension InstalledSticker: SDSModel {
     public static var table: SDSTableMetadata {
         InstalledStickerSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Messages/Stickers/KnownStickerPack+SDS.swift b/SignalServiceKit/src/Messages/Stickers/KnownStickerPack+SDS.swift
index 172880a556f..013eb0162ec 100644
--- a/SignalServiceKit/src/Messages/Stickers/KnownStickerPack+SDS.swift
+++ b/SignalServiceKit/src/Messages/Stickers/KnownStickerPack+SDS.swift
@@ -144,6 +144,15 @@ extension KnownStickerPack: SDSModel {
     public static var table: SDSTableMetadata {
         KnownStickerPackSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Messages/Stickers/StickerPack+SDS.swift b/SignalServiceKit/src/Messages/Stickers/StickerPack+SDS.swift
index 06829d4fe35..cc003234e5e 100644
--- a/SignalServiceKit/src/Messages/Stickers/StickerPack+SDS.swift
+++ b/SignalServiceKit/src/Messages/Stickers/StickerPack+SDS.swift
@@ -166,6 +166,15 @@ extension StickerPack: SDSModel {
     public static var table: SDSTableMetadata {
         StickerPackSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Network/Receiving/IncomingGroupsV2MessageJob+SDS.swift b/SignalServiceKit/src/Network/Receiving/IncomingGroupsV2MessageJob+SDS.swift
index 0dd06bff994..116ba8f20d4 100644
--- a/SignalServiceKit/src/Network/Receiving/IncomingGroupsV2MessageJob+SDS.swift
+++ b/SignalServiceKit/src/Network/Receiving/IncomingGroupsV2MessageJob+SDS.swift
@@ -158,6 +158,15 @@ extension IncomingGroupsV2MessageJob: SDSModel {
     public static var table: SDSTableMetadata {
         IncomingGroupsV2MessageJobSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Payments/TSPaymentModel+SDS.swift b/SignalServiceKit/src/Payments/TSPaymentModel+SDS.swift
index cbb4414e0b5..fe84fba9bd3 100644
--- a/SignalServiceKit/src/Payments/TSPaymentModel+SDS.swift
+++ b/SignalServiceKit/src/Payments/TSPaymentModel+SDS.swift
@@ -194,6 +194,15 @@ extension TSPaymentModel: SDSModel {
     public static var table: SDSTableMetadata {
         TSPaymentModelSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Payments/TSPaymentRequestModel+SDS.swift b/SignalServiceKit/src/Payments/TSPaymentRequestModel+SDS.swift
index f17e5b3246f..01555e7e100 100644
--- a/SignalServiceKit/src/Payments/TSPaymentRequestModel+SDS.swift
+++ b/SignalServiceKit/src/Payments/TSPaymentRequestModel+SDS.swift
@@ -158,6 +158,15 @@ extension TSPaymentRequestModel: SDSModel {
     public static var table: SDSTableMetadata {
         TSPaymentRequestModelSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Security/OWSRecipientIdentity+SDS.swift b/SignalServiceKit/src/Security/OWSRecipientIdentity+SDS.swift
index fc19f6ca252..2994909a0ff 100644
--- a/SignalServiceKit/src/Security/OWSRecipientIdentity+SDS.swift
+++ b/SignalServiceKit/src/Security/OWSRecipientIdentity+SDS.swift
@@ -153,6 +153,15 @@ extension OWSRecipientIdentity: SDSModel {
     public static var table: SDSTableMetadata {
         OWSRecipientIdentitySerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Storage/Database/DatabaseCorruptionState.swift b/SignalServiceKit/src/Storage/Database/DatabaseCorruptionState.swift
index 3552c34a72e..21416549cc7 100644
--- a/SignalServiceKit/src/Storage/Database/DatabaseCorruptionState.swift
+++ b/SignalServiceKit/src/Storage/Database/DatabaseCorruptionState.swift
@@ -5,17 +5,67 @@
 import Foundation
 import GRDB
 
-// We could hang everything off of the enum, but we intend to add some additional information to this class soon.
-public class DatabaseCorruptionState {
-    public enum DatabaseCorruptionStatus: UInt8 {
-        case notCorrupted
-        case corrupted
+public class DatabaseCorruptionState: Codable, Equatable {
+    public enum DatabaseCorruptionStatus: Int, Codable, CustomStringConvertible {
+        // We used to store these as booleans, so the value is important.
+        case notCorrupted = 0
+        case corrupted = 1
+        case corruptedButAlreadyDumpedAndRestored = 2
+
+        fileprivate var isCorrupted: Bool {
+            switch self {
+            case .notCorrupted: return false
+            case .corrupted, .corruptedButAlreadyDumpedAndRestored: return true
+            }
+        }
+
+        public var description: String {
+            switch self {
+            case .notCorrupted:
+                return "not corrupted"
+            case .corrupted:
+                return "corrupted"
+            case .corruptedButAlreadyDumpedAndRestored:
+                return "corrupted (but already dumped and restored)"
+            }
+        }
     }
 
-    static var hasGrdbDatabaseCorruptionKey: String { "hasGrdbDatabaseCorruption" }
+    public let status: DatabaseCorruptionStatus
+    public let count: UInt
 
-    public static func databaseCorruptionStatus(userDefaults: UserDefaults) -> DatabaseCorruptionStatus {
-        userDefaults.bool(forKey: hasGrdbDatabaseCorruptionKey) ? .corrupted : .notCorrupted
+    required init(status: DatabaseCorruptionStatus, count: UInt) {
+        self.status = status
+        self.count = count
+    }
+
+    public static func == (lhs: DatabaseCorruptionState, rhs: DatabaseCorruptionState) -> Bool {
+        (lhs.status == rhs.status) && (lhs.count == rhs.count)
+    }
+
+    public var description: String {
+        "Database is \(status). Corruption count: \(count)"
+    }
+
+    // MARK: - Reading and writing from `UserDefaults`
+
+    // The value of this key doesn't match the name because that's what we used to store.
+    static var databaseCorruptionStatusKey: String { "hasGrdbDatabaseCorruption" }
+    static var databaseCorruptionCountKey: String { "databaseCorruptionCount" }
+
+    public convenience init(userDefaults: UserDefaults) {
+        let rawStatus = userDefaults.integer(forKey: Self.databaseCorruptionStatusKey)
+        let rawCount = userDefaults.integer(forKey: Self.databaseCorruptionCountKey)
+
+        let status = DatabaseCorruptionStatus(rawValue: rawStatus) ?? .notCorrupted
+        let count: UInt = status.isCorrupted ? max(UInt(rawCount), 1) : UInt(rawCount)
+
+        self.init(status: status, count: count)
+    }
+
+    private func save(to userDefaults: UserDefaults) {
+        userDefaults.set(status.rawValue, forKey: Self.databaseCorruptionStatusKey)
+        userDefaults.set(count, forKey: Self.databaseCorruptionCountKey)
     }
 
     /// If the error is a `SQLITE_CORRUPT` error, set the "has database corruption" flag, log, and crash.
@@ -28,6 +78,38 @@ public class DatabaseCorruptionState {
     }
 
     public static func flagDatabaseAsCorrupted(userDefaults: UserDefaults) {
-        userDefaults.set(true, forKey: hasGrdbDatabaseCorruptionKey)
+        let oldState = DatabaseCorruptionState(userDefaults: userDefaults)
+        switch oldState.status {
+        case .notCorrupted:
+            Self(status: .corrupted, count: oldState.count + 1).save(to: userDefaults)
+        case .corrupted, .corruptedButAlreadyDumpedAndRestored:
+            return
+        }
+    }
+
+    public static func flagCorruptedDatabaseAsDumpedAndRestored(userDefaults: UserDefaults) {
+        let oldState = DatabaseCorruptionState(userDefaults: userDefaults)
+        switch oldState.status {
+        case .corrupted:
+            DatabaseCorruptionState(status: .corruptedButAlreadyDumpedAndRestored, count: oldState.count).save(to: userDefaults)
+        case .notCorrupted, .corruptedButAlreadyDumpedAndRestored:
+            owsFailDebug("Flagging database as partially recovered, but it was not in the right state previously")
+        }
+    }
+
+    public static func flagDatabaseAsRecoveredFromCorruption(userDefaults: UserDefaults) {
+        let oldState = DatabaseCorruptionState(userDefaults: userDefaults)
+        switch oldState.status {
+        case .notCorrupted:
+            owsFailDebug("Flagging database as recovered from corruption, but it wasn't marked corrupted")
+        case .corrupted, .corruptedButAlreadyDumpedAndRestored:
+            Self(status: .notCorrupted, count: oldState.count).save(to: userDefaults)
+        }
+    }
+
+    @objc(stringForLoggingWith:)
+    public static func objcStringForLogging(userDefaults: UserDefaults) -> String {
+        let state = DatabaseCorruptionState(userDefaults: userDefaults)
+        return String(describing: state)
     }
 }
diff --git a/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift b/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift
new file mode 100644
index 00000000000..e682681dfab
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift
@@ -0,0 +1,676 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDB
+import SignalCoreKit
+
+public enum DatabaseRecoveryError: Error {
+    case ranOutOfDiskSpace
+    case unrecoverablyCorrupted
+}
+
+/// Tries to recover corrupted databases.
+///
+/// Database recovery is split into two parts:
+///
+/// 1. "Dump and restore". Before most of the app is set up (i.e., before database connections are
+///    established), we copy some data into a new database and then make that new database the
+///    primary database, clobbering the old one.
+/// 2. "Manual recreation". After the app is mostly set up, we attempt to recover some additional
+///    data, such as full-text search indexes, which can be recomputed.
+///
+/// Why have this split?
+///
+/// - If the process stops after we've clobbered the old database, we can still continue. For
+///   example, imagine that the app crashes after the first step completes, or the user gets
+///   impatient and closes the app.
+/// - As of this writing, the code makes it challenging to do some data restoration, such as
+///   restoring full-text search indexes, without the app being mostly set up.
+///
+/// It's up to the caller to coordinate these two steps, and decide which is necessary.
+public enum DatabaseRecovery {}
+
+// MARK: - Dump and restore
+
+public extension DatabaseRecovery {
+    /// Dump and restore tables.
+    ///
+    /// Remember: this isn't everything you need to do to recover a database! See earlier docs.
+    class DumpAndRestore {
+        private let databaseFileUrl: URL
+
+        private let unitCountForCheckpoint: Int64 = 1
+        private let unitCountForOldDatabaseMigration: Int64 = 1
+        private let unitCountForNewDatabaseCreation: Int64 = 1
+        private let unitCountForBestEffortCopy = Int64(DumpAndRestore.tablesToCopyWithBestEffort.count)
+        private let unitCountForFlawlessCopy = Int64(DumpAndRestore.tablesThatMustBeCopiedFlawlessly.count)
+        private let unitCountForNewDatabasePromotion: Int64 = 3
+
+        public let progress: Progress
+
+        public init(databaseFileUrl: URL) {
+            self.databaseFileUrl = databaseFileUrl
+
+            let totalUnitCount = Int64(
+                unitCountForCheckpoint +
+                unitCountForOldDatabaseMigration +
+                unitCountForNewDatabaseCreation +
+                unitCountForBestEffortCopy +
+                unitCountForFlawlessCopy +
+                unitCountForNewDatabasePromotion
+            )
+            self.progress = Progress(totalUnitCount: totalUnitCount)
+        }
+
+        /// Run the dump and restore process.
+        ///
+        /// Remember: this isn't everything you need to do to recover a database! See earlier docs.
+        ///
+        /// If this completes successfully, you probably want to mark the database as dumped
+        /// and restored.
+        public func run() throws {
+            guard progress.completedUnitCount == 0 else {
+                owsFailDebug("Dump and restore should not be run more than once")
+                return
+            }
+
+            guard Self.allTableNamesAreSafe() else {
+                owsFail("An unsafe table name was found, which could lead to SQL injection. Stopping")
+            }
+
+            Self.logTablesExplicitlySkipped()
+
+            Logger.info("Attempting database dump and restore")
+
+            let oldDatabaseStorage = DatabaseRecovery.databaseStorage(at: databaseFileUrl)
+
+            progress.performAsCurrent(withPendingUnitCount: unitCountForCheckpoint) {
+                Self.attemptToCheckpoint(oldDatabaseStorage: oldDatabaseStorage)
+            }
+
+            progress.performAsCurrent(withPendingUnitCount: unitCountForOldDatabaseMigration) {
+                try? Self.runMigrationsOn(databaseStorage: oldDatabaseStorage, databaseIs: .old)
+            }
+
+            let newTemporaryDatabaseFileUrl = Self.temporaryDatabaseFileUrl()
+            defer {
+                Self.deleteTemporaryDatabase(databaseFileUrl: newTemporaryDatabaseFileUrl)
+            }
+
+            let newDatabaseStorage = try progress.performAsCurrent(
+                withPendingUnitCount: unitCountForNewDatabaseCreation
+            ) {
+                let newDatabaseStorage = DatabaseRecovery.databaseStorage(at: newTemporaryDatabaseFileUrl)
+                do {
+                    try Self.runMigrationsOn(databaseStorage: newDatabaseStorage, databaseIs: .new)
+                } catch {
+                    throw DatabaseRecoveryError.unrecoverablyCorrupted
+                }
+                return newDatabaseStorage
+            }
+
+            let copyTablesWithBestEffort = Self.prepareToCopyTablesWithBestEffort(
+                oldDatabaseStorage: oldDatabaseStorage,
+                newDatabaseStorage: newDatabaseStorage
+            )
+            progress.addChild(
+                copyTablesWithBestEffort.progress,
+                withPendingUnitCount: unitCountForBestEffortCopy
+            )
+            try copyTablesWithBestEffort.run()
+
+            let copyTablesThatMustBeCopiedFlawlessly = Self.prepareToCopyTablesThatMustBeCopiedFlawlessly(
+                oldDatabaseStorage: oldDatabaseStorage,
+                newDatabaseStorage: newDatabaseStorage
+            )
+            progress.addChild(
+                copyTablesThatMustBeCopiedFlawlessly.progress,
+                withPendingUnitCount: unitCountForFlawlessCopy
+            )
+            try copyTablesThatMustBeCopiedFlawlessly.run()
+
+            try progress.performAsCurrent(withPendingUnitCount: unitCountForNewDatabasePromotion) {
+                try Self.promoteNewDatabase(
+                    oldDatabaseStorage: oldDatabaseStorage,
+                    newDatabaseStorage: newDatabaseStorage,
+                    databaseFileUrl: databaseFileUrl,
+                    newTemporaryDatabaseFileUrl: newTemporaryDatabaseFileUrl
+                )
+            }
+
+            Logger.info("Dump and restore complete")
+        }
+
+        // MARK: Checkpoint old database to clear its WAL/SHM files (step 1)
+
+        private static func attemptToCheckpoint(oldDatabaseStorage: SDSDatabaseStorage) {
+            Logger.info("Attempting to checkpoint the old database...")
+            do {
+                try checkpoint(databaseStorage: oldDatabaseStorage)
+                Logger.info("Checkpointed old database.")
+            } catch {
+                Logger.warn("Failed to checkpoint old database with error: \(error). Continuing on")
+            }
+        }
+
+        // MARK: Creating new database (step 2)
+
+        private static func temporaryDatabaseFileUrl() -> URL {
+            Logger.info("Creating temporary database file...")
+            let result = OWSFileSystem.temporaryFileUrl()
+            Logger.info("Created at \(result)")
+            return result
+        }
+
+        private static func deleteTemporaryDatabase(databaseFileUrl: URL) {
+            Logger.info("Attempting to delete temporary database files...")
+            let urls: [URL] = [
+                databaseFileUrl,
+                GRDBDatabaseStorageAdapter.walFileUrl(for: databaseFileUrl),
+                GRDBDatabaseStorageAdapter.shmFileUrl(for: databaseFileUrl)
+            ]
+            for url in urls {
+                do {
+                    try OWSFileSystem.deleteFileIfExists(url: url)
+                    Logger.info("Deleted temporary database file")
+                } catch {
+                    Logger.warn("Failed to delete temporary database file")
+                }
+            }
+        }
+
+        // MARK: Running schema migrations (steps 2 and 3)
+
+        private enum MigrationsMode: CustomStringConvertible {
+            case old
+            case new
+
+            public var description: String {
+                switch self {
+                case .old: return "old"
+                case .new: return "new"
+                }
+            }
+        }
+
+        private static func runMigrationsOn(databaseStorage: SDSDatabaseStorage, databaseIs mode: MigrationsMode) throws {
+            Logger.info("Running migrations on \(mode) database...")
+            do {
+                let didPerformIncrementalMigrations = try GRDBSchemaMigrator.migrateDatabase(
+                    databaseStorage: databaseStorage,
+                    isMainDatabase: false,
+                    runDataMigrations: {
+                        switch mode {
+                            // We skip old data migrations because we suspect data is more likely to be corrupted.
+                        case .old: return false
+                        case .new: return true
+                        }
+                    }()
+                )
+                Logger.info("Ran migrations on \(mode) database. \(didPerformIncrementalMigrations ? "Performed" : "Did not perform") incremental migrations")
+            } catch {
+                Logger.warn("Failed to run migrations on \(mode) database. Error: \(error)")
+                throw error
+            }
+        }
+
+        // MARK: Copy tables with best effort (step 4)
+
+        static let tablesToCopyWithBestEffort: [String] = [
+            // We should try to copy thread data.
+            OWSReaction.databaseTableName,
+            OWSRecipientIdentity.table.tableName,
+            OWSUserProfile.table.tableName,
+            SignalAccount.table.tableName,
+            SignalRecipient.table.tableName,
+            StoryMessage.databaseTableName,
+            TSAttachment.table.tableName,
+            TSInteraction.table.tableName,
+            TSGroupMember.databaseTableName,
+            TSMention.databaseTableName,
+            TSPaymentModel.table.tableName,
+            TSThread.table.tableName,
+            ThreadAssociatedData.databaseTableName,
+            // We'd like to get receipts back, but it's okay if we don't get them all.
+            DonationReceipt.databaseTableName
+        ]
+
+        private static func prepareToCopyTablesWithBestEffort(
+            oldDatabaseStorage: SDSDatabaseStorage,
+            newDatabaseStorage: SDSDatabaseStorage
+        ) -> PreparedOperation {
+            .init(totalUnitCount: Int64(tablesToCopyWithBestEffort.count)) { progress in
+                for tableName in self.tablesToCopyWithBestEffort {
+                    try progress.performAsCurrent(withPendingUnitCount: 1) {
+                        try self.copyWithBestEffort(
+                            tableName: tableName,
+                            oldDatabaseStorage: oldDatabaseStorage,
+                            newDatabaseStorage: newDatabaseStorage
+                        )
+                    }
+                }
+            }
+        }
+
+        private static func copyWithBestEffort(
+            tableName: String,
+            oldDatabaseStorage: SDSDatabaseStorage,
+            newDatabaseStorage: SDSDatabaseStorage
+        ) throws {
+            Logger.info("Attempting to copy \(tableName) (best effort)...")
+            let result = copyTable(
+                tableName: tableName,
+                from: oldDatabaseStorage,
+                to: newDatabaseStorage
+            )
+            switch result {
+            case let .totalFailure(error):
+                Logger.warn("Completely unable to copy \(tableName)")
+                if error.isSqliteFullError {
+                    throw DatabaseRecoveryError.ranOutOfDiskSpace
+                }
+            case let .copiedSomeButHadTrouble(error, rowsCopied):
+                Logger.warn("Finished copying \(tableName). Copied \(rowsCopied) row(s), but there was an error")
+                if error.isSqliteFullError {
+                    throw DatabaseRecoveryError.ranOutOfDiskSpace
+                }
+            case let .wentFlawlessly(rowsCopied):
+                Logger.info("Finished copying \(tableName). Copied \(rowsCopied) row(s)")
+            }
+        }
+
+        // MARK: Copy essential tables (step 5)
+
+        static let tablesThatMustBeCopiedFlawlessly: [String] = [
+            // The app will be too unpredictable with strange key-value stores.
+            SDSKeyValueStore.table.tableName,
+            // If we get a disappearing timer wrong, users might send messages incorrectly.
+            DisappearingMessagesConfigurationRecord.databaseTableName,
+            // We don't want to get our linked devices wrong.
+            // We *could* fetch these from the server. Could be a good followup change.
+            OWSDevice.table.tableName
+        ]
+
+        /// Copy tables that must be copied flawlessly. Operation throws if any tables fail.
+        private static func prepareToCopyTablesThatMustBeCopiedFlawlessly(
+            oldDatabaseStorage: SDSDatabaseStorage,
+            newDatabaseStorage: SDSDatabaseStorage
+        ) -> PreparedOperation {
+            .init(totalUnitCount: Int64(tablesThatMustBeCopiedFlawlessly.count)) { progress in
+                for tableName in self.tablesThatMustBeCopiedFlawlessly {
+                    let result = progress.performAsCurrent(withPendingUnitCount: 1) {
+                        self.copyTableThatMustBeCopiedFlawlessly(
+                            tableName: tableName,
+                            oldDatabaseStorage: oldDatabaseStorage,
+                            newDatabaseStorage: newDatabaseStorage
+                        )
+                    }
+                    switch result {
+                    case let .totalFailure(error), let .copiedSomeButHadTrouble(error, _):
+                        let toThrow: DatabaseRecoveryError = error.isSqliteFullError ? .ranOutOfDiskSpace : .unrecoverablyCorrupted
+                        throw toThrow
+                    case .wentFlawlessly:
+                        break
+                    }
+                }
+            }
+        }
+
+        private static func copyTableThatMustBeCopiedFlawlessly(
+            tableName: String,
+            oldDatabaseStorage: SDSDatabaseStorage,
+            newDatabaseStorage: SDSDatabaseStorage
+        ) -> TableCopyResult {
+            Logger.info("Attempting to copy \(tableName) (with no mistakes)...")
+            let result = copyTable(
+                tableName: tableName,
+                from: oldDatabaseStorage,
+                to: newDatabaseStorage
+            )
+            switch result {
+            case .totalFailure:
+                Logger.warn("Completely unable to copy \(tableName)")
+            case let .copiedSomeButHadTrouble(_, rowsCopied):
+                Logger.warn("Failed copying \(tableName) flawlessly. Copied \(rowsCopied) row(s)")
+            case let .wentFlawlessly(rowsCopied: rowsCopied):
+                Logger.info("Finished copying \(tableName). Copied \(rowsCopied) row(s)")
+            }
+            return result
+        }
+
+        // MARK: Promote the old database (step 6)
+
+        /// "Promotes" the new database and clobbers the old one.
+        ///
+        /// Neither database instance should be used after this.
+        private static func promoteNewDatabase(
+            oldDatabaseStorage: SDSDatabaseStorage,
+            newDatabaseStorage: SDSDatabaseStorage,
+            databaseFileUrl: URL,
+            newTemporaryDatabaseFileUrl: URL
+        ) throws {
+            try checkpointAndClose(databaseStorage: oldDatabaseStorage, logLabel: "old")
+            try checkpointAndClose(databaseStorage: newDatabaseStorage, logLabel: "new")
+
+            Logger.info("Replacing old database with the new one...")
+
+            let newDatabaseFileUrl = try FileManager.default.replaceItemAt(
+                databaseFileUrl,
+                withItemAt: newTemporaryDatabaseFileUrl
+            )
+            owsAssert(databaseFileUrl == newDatabaseFileUrl)
+
+            Logger.info("Out with the old database, in with the new!")
+        }
+
+        private static func checkpointAndClose(
+            databaseStorage: SDSDatabaseStorage,
+            logLabel: String
+        ) throws {
+            Logger.info("Checkpointing \(logLabel) database...")
+            try checkpoint(databaseStorage: databaseStorage)
+
+            Logger.info("Checkpointed \(logLabel) database. Closing...")
+            try databaseStorage.grdbStorage.pool.close()
+
+            Logger.info("Cleaning up WAL and SHM files...")
+            OWSFileSystem.deleteFileIfExists(databaseStorage.grdbStorage.databaseWALFilePath)
+            OWSFileSystem.deleteFileIfExists(databaseStorage.grdbStorage.databaseSHMFilePath)
+
+            Logger.info("\(logLabel.capitalized) database closed.")
+        }
+
+        // MARK: Tables that are explicitly skipped
+
+        static let tablesExplicitlySkipped: [String] = [
+            // We only need these for resend requests. We'd rather not send garbage.
+            MessageSendLog.Message.databaseTableName,
+            MessageSendLog.Payload.databaseTableName,
+            MessageSendLog.Recipient.databaseTableName,
+            // We'd rather not try to resurrect jobs, as they may result in unintended behavior (e.g., a bad message send).
+            JobRecordRecord.databaseTableName,
+            PendingReadReceiptRecord.databaseTableName,
+            PendingViewedReceiptRecord.databaseTableName,
+            OWSMessageContentJob.table.tableName, // also, this one is deprecated
+            // Recovered manually in other steps.
+            MediaGalleryRecord.databaseTableName,
+            // Can be recovered in other ways, after recovery is done.
+            IncomingGroupsV2MessageJob.table.tableName,
+            KnownStickerPack.table.tableName,
+            ProfileBadge.databaseTableName,
+            StickerPack.table.tableName,
+            // Not essential.
+            StoryContextAssociatedData.databaseTableName,
+            ExperienceUpgrade.databaseTableName,
+            InstalledSticker.table.tableName,
+            TestModel.table.tableName
+        ]
+
+        /// Log the tables we're explicitly skipping.
+        ///
+        /// This is a little weird, but helps us be clear: we don't copy all tables.
+        private static func logTablesExplicitlySkipped() {
+            Logger.info("Explicitly skipping tables: \(tablesExplicitlySkipped.joined(separator: ", "))")
+        }
+
+        // MARK: Checkpointing tables
+
+        private static func checkpoint(databaseStorage: SDSDatabaseStorage) throws {
+            try databaseStorage.grdbStorage.pool.writeWithoutTransaction { database -> Void in
+                // It's important that we do a truncating checkpoint so we empty out the WAL.
+                // Alternatively, we could copy it over.
+                try database.checkpoint(.truncate)
+            }
+        }
+
+        // MARK: Copying tables
+
+        enum TableCopyResult {
+            case totalFailure(error: Error)
+            case copiedSomeButHadTrouble(error: Error, rowsCopied: UInt)
+            case wentFlawlessly(rowsCopied: UInt)
+        }
+
+        private static func copyTable(
+            tableName: String,
+            from: SDSDatabaseStorage,
+            to: SDSDatabaseStorage
+        ) -> TableCopyResult {
+            owsAssert(isSafe(sqlName: tableName))
+
+            return from.read { fromTransaction -> TableCopyResult in
+                let fromDb = fromTransaction.unwrapGrdbRead.database
+
+                let columnNames: [String]
+                let cursor: RowCursor
+                do {
+                    columnNames = try getColumnNames(db: fromDb, tableName: tableName)
+                    cursor = try Row.fetchCursor(fromDb, sql: "SELECT * FROM \(tableName)")
+                } catch {
+                    Logger.warn("Could not create cursor for table \(tableName) with error: \(error)")
+                    return .totalFailure(error: error)
+                }
+
+                let insertSql = insertSql(tableName: tableName, columnNames: columnNames)
+
+                return to.write { toTransaction in
+                    let toDb = toTransaction.unwrapGrdbWrite.database
+
+                    let insertStatement: Statement
+                    do {
+                        insertStatement = try toDb.makeStatement(sql: insertSql)
+                    } catch {
+                        Logger.warn("Could not create prepared insert statement. \(error)")
+                        return .totalFailure(error: error)
+                    }
+
+                    var rowsCopied: UInt = 0
+                    var latestError: Error?
+
+                    do {
+                        try cursor.forEach { row in
+                            let statementArguments = StatementArguments(row.asDictionary)
+                            do {
+                                try insertStatement.execute(arguments: statementArguments)
+                                rowsCopied += 1
+                            } catch {
+                                latestError = error
+                            }
+                        }
+                    } catch {
+                        Logger.warn("Error while iterating: \(error)")
+                        latestError = error
+                    }
+
+                    if let latestError = latestError {
+                        return .copiedSomeButHadTrouble(error: latestError, rowsCopied: rowsCopied)
+                    } else {
+                        return .wentFlawlessly(rowsCopied: rowsCopied)
+                    }
+                }
+            }
+        }
+
+        // MARK: Utilities
+
+        /// Determine whether a table name *could* lead to SQL injection.
+        ///
+        /// This is unlikely to happen, and should always return `true`.
+        /// See documentation for `isSafe` for more.
+        private static func allTableNamesAreSafe() -> Bool {
+            (tablesToCopyWithBestEffort + tablesThatMustBeCopiedFlawlessly).allSatisfy {
+                isSafe(sqlName: $0)
+            }
+        }
+
+        /// Determine whether a name *could* lead to SQL injection.
+        ///
+        /// This is unlikely to happen, and should always return `true`.
+        ///
+        /// GRDB (perhaps because of SQLite) doesn't allow table names to be passed as arguments,
+        /// to help us avoid SQL injection. We'd like to do something like this, but can't:
+        ///
+        ///     let sql = "SELECT * FROM ?"
+        ///     try Row.fetchAll(db, sql: sql, arguments: ["my_table_name"])
+        ///
+        /// We have similar issues with column names.
+        ///
+        /// Instead, we just interpolate the name into the raw SQL string. It's unlikely that we'll
+        /// we'll have a table/column name that causes SQL injection, but this method helps ensure
+        /// that. There should also be unit tests that do something similar, further protecting us
+        /// from this unlikely (but costly, if it happens) mistake.
+        private static func isSafe(sqlName: String) -> Bool {
+            return (
+                !sqlName.isEmpty &&
+                sqlName.utf8ByteCount < 1000 &&
+                !sqlName.lowercased().starts(with: "sqlite") &&
+                sqlName.range(of: "^[a-zA-Z][a-zA-Z0-9_]*$", options: .regularExpression) != nil
+            )
+        }
+
+        private static func getColumnNames(db: Database, tableName: String) throws -> [String] {
+            owsAssert(isSafe(sqlName: tableName))
+
+            var result = [String]()
+            let cursor = try Row.fetchCursor(db, sql: "PRAGMA table_info(\(tableName))")
+            try cursor.forEach { row in
+                guard let columnName = row["name"] as? String else {
+                    throw DatabaseRecoveryError.unrecoverablyCorrupted
+                }
+                result.append(columnName)
+            }
+            return result
+        }
+
+        private static func insertSql(tableName: String, columnNames: [String]) -> String {
+            owsAssert(isSafe(sqlName: tableName))
+            for columnName in columnNames {
+                owsAssert(isSafe(sqlName: columnName))
+            }
+
+            let columnNamesSql = columnNames.joined(separator: ", ")
+            let valuesSql = columnNames.map({ ":\($0)" }).joined(separator: ", ")
+            return "INSERT INTO \(tableName) (\(columnNamesSql)) VALUES (\(valuesSql))"
+        }
+    }
+}
+
+// MARK: - Manual recreation
+
+public extension DatabaseRecovery {
+    /// Manually recreate various tables, such as the full-text search indexes.
+    class ManualRecreation {
+        private let databaseStorage: SDSDatabaseStorage
+
+        private let unitCountForMediaGallery: Int64 = 1
+        private let unitCountForFullTextSearch: Int64 = 2
+        public let progress: Progress
+
+        public init(databaseStorage: SDSDatabaseStorage) {
+            self.databaseStorage = databaseStorage
+            self.progress = Progress(totalUnitCount: unitCountForMediaGallery + unitCountForFullTextSearch)
+        }
+
+        public func run() {
+            guard progress.completedUnitCount == 0 else {
+                owsFailDebug("Manual recreation should not be run more than once")
+                return
+            }
+
+            progress.performAsCurrent(withPendingUnitCount: unitCountForMediaGallery) {
+                attemptToRecreateMediaGallery()
+            }
+            progress.performAsCurrent(withPendingUnitCount: unitCountForFullTextSearch) {
+                attemptToRecreateFullTextSearch()
+            }
+        }
+
+        private func attemptToRecreateMediaGallery() {
+            Logger.info("Attempting to recreate media gallery records...")
+            databaseStorage.write { transaction in
+                do {
+                    try createInitialGalleryRecords(transaction: transaction.unwrapGrdbWrite)
+                    Logger.info("Recreated media gallery records.")
+                } catch {
+                    Logger.warn("Failed to recreate media gallery records, but moving on: \(error)")
+                }
+            }
+        }
+
+        private func attemptToRecreateFullTextSearch() {
+            Logger.info("Starting to re-index full text search...")
+
+            databaseStorage.write { transaction in
+                let grdbTransaction = transaction.unwrapGrdbWrite
+
+                func index(_ model: SDSIndexableModel) {
+                    GRDBFullTextSearchFinder.modelWasInserted(
+                        model: model,
+                        transaction: grdbTransaction
+                    )
+                }
+
+                for indexableModelType in GRDBFullTextSearchFinder.indexableModelTypes {
+                    Logger.info("Starting to index \(indexableModelType.collection())")
+                    indexableModelType.anyEnumerateIndexable(transaction: transaction) { model in
+                        index(model)
+                    }
+                }
+            }
+
+            Logger.info("Finished re-indexing full text search")
+        }
+    }
+}
+
+// MARK: - Utilities
+
+extension DatabaseRecovery {
+    private struct PreparedOperation {
+        public let progress: Progress
+        private let fn: (Progress) throws -> Void
+
+        public init(totalUnitCount: Int64, fn: @escaping (Progress) throws -> Void) {
+            self.progress = Progress(totalUnitCount: totalUnitCount)
+            self.fn = fn
+        }
+
+        public func run() throws {
+            try fn(progress)
+        }
+    }
+
+    public static func databaseFileSize(forDatabaseAt url: URL) -> UInt64 {
+        databaseStorage(at: url).databaseCombinedFileSize
+    }
+
+    private class RecovererDatabaseStorageDelegate: SDSDatabaseStorageDelegate {
+        var storageCoordinatorState: StorageCoordinatorState { .GRDB }
+    }
+
+    private static let databaseStorageDelegate = RecovererDatabaseStorageDelegate()
+
+    private static func databaseStorage(at url: URL) -> SDSDatabaseStorage {
+        SDSDatabaseStorage(databaseFileUrl: url, delegate: databaseStorageDelegate)
+    }
+}
+
+extension Error {
+    var isSqliteFullError: Bool {
+        guard let self = self as? DatabaseError else { return false }
+        return self.resultCode == .SQLITE_FULL
+    }
+}
+
+extension Row {
+    public var asDictionary: [String: DatabaseValue] {
+        var result = [String: DatabaseValue]()
+        for rowIndex in stride(from: startIndex, to: endIndex, by: 1) {
+            let (columnName, databaseValue) = self[rowIndex]
+            result[columnName] = databaseValue
+        }
+        return result
+    }
+}
diff --git a/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift b/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift
index 2115ddd1516..5fe469c779a 100644
--- a/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift
+++ b/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift
@@ -1007,17 +1007,41 @@ public struct GRDBKeySpecSource {
 
 // MARK: -
 
+fileprivate extension URL {
+    func appendingPathString(_ string: String) -> URL? {
+        guard var components = URLComponents(url: self, resolvingAgainstBaseURL: false) else {
+            return nil
+        }
+        components.path += string
+        return components.url
+    }
+}
+
 extension GRDBDatabaseStorageAdapter {
+    public static func walFileUrl(for databaseFileUrl: URL) -> URL {
+        guard let result = databaseFileUrl.appendingPathString("-wal") else {
+            owsFail("Could not get WAL URL")
+        }
+        return result
+    }
+
+    public static func shmFileUrl(for databaseFileUrl: URL) -> URL {
+        guard let result = databaseFileUrl.appendingPathString("-shm") else {
+            owsFail("Could not get SHM URL")
+        }
+        return result
+    }
+
     public var databaseFilePath: String {
         return databaseFileUrl.path
     }
 
     public var databaseWALFilePath: String {
-        return databaseFileUrl.path + "-wal"
+        Self.walFileUrl(for: databaseFileUrl).path
     }
 
     public var databaseSHMFilePath: String {
-        return databaseFileUrl.path + "-shm"
+        Self.shmFileUrl(for: databaseFileUrl).path
     }
 
     static func removeAllFiles() {
diff --git a/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift b/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
index 968fc28276c..2fa979689b4 100644
--- a/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
+++ b/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
@@ -14,17 +14,18 @@ public class GRDBSchemaMigrator: NSObject {
     public static let migrationSideEffectsCollectionName = "MigrationSideEffects"
     public static let avatarRepairAttemptCount = "Avatar Repair Attempt Count"
 
-    /// Migrate a database to the latest version.
+    /// Migrate a database to the latest version. Throws if migrations fail.
     ///
     /// - Parameter databaseStorage: The database to migrate.
     /// - Parameter isMainDatabase: A boolean indicating whether this is the main database. If so, some global state will be set.
+    /// - Parameter runDataMigrations: A boolean indicating whether to include data migrations. Typically, you want to omit this value or set it to `true`, but we want to skip them when recovering a corrupted database.
     /// - Returns: `true` if incremental migrations were performed, and `false` otherwise.
     @discardableResult
-    @objc(migrateDatabase:isMainDatabase:)
     public static func migrateDatabase(
         databaseStorage: SDSDatabaseStorage,
-        isMainDatabase: Bool
-    ) -> Bool {
+        isMainDatabase: Bool,
+        runDataMigrations: Bool = true
+    ) throws -> Bool {
         let didPerformIncrementalMigrations: Bool
 
         let grdbStorageAdapter = databaseStorage.grdbStorage
@@ -33,10 +34,12 @@ public class GRDBSchemaMigrator: NSObject {
             do {
                 Logger.info("Using incrementalMigrator.")
                 didPerformIncrementalMigrations = try runIncrementalMigrations(
-                    databaseStorage: databaseStorage
+                    databaseStorage: databaseStorage,
+                    runDataMigrations: runDataMigrations
                 )
             } catch {
-                owsFail("Incremental migrations failed: \(error.grdbErrorForLogging)")
+                owsFailDebug("Incremental migrations failed: \(error.grdbErrorForLogging)")
+                throw error
             }
         } else {
             do {
@@ -44,7 +47,8 @@ public class GRDBSchemaMigrator: NSObject {
                 try newUserMigrator().migrate(grdbStorageAdapter.pool)
                 didPerformIncrementalMigrations = false
             } catch {
-                owsFail("New user migrator failed: \(error.grdbErrorForLogging)")
+                owsFailDebug("New user migrator failed: \(error.grdbErrorForLogging)")
+                throw error
             }
         }
         Logger.info("Migrations complete.")
@@ -57,7 +61,10 @@ public class GRDBSchemaMigrator: NSObject {
         return didPerformIncrementalMigrations
     }
 
-    private static func runIncrementalMigrations(databaseStorage: SDSDatabaseStorage) throws -> Bool {
+    private static func runIncrementalMigrations(
+        databaseStorage: SDSDatabaseStorage,
+        runDataMigrations: Bool
+    ) throws -> Bool {
         let grdbStorageAdapter = databaseStorage.grdbStorage
 
         let previouslyAppliedMigrations = try grdbStorageAdapter.read { transaction in
@@ -70,17 +77,19 @@ public class GRDBSchemaMigrator: NSObject {
         registerSchemaMigrations(migrator: incrementalMigrator)
         try incrementalMigrator.migrate(grdbStorageAdapter.pool)
 
-        // Hack: Load the account state now, so it can be accessed while performing other migrations.
-        // Otherwise one of them might indirectly try to load the account state using a sneaky transaction,
-        // which won't work because migrations use a barrier block to prevent observing database state
-        // before migration.
-        try grdbStorageAdapter.read { transaction in
-            _ = self.tsAccountManager.localAddress(with: transaction.asAnyRead)
-        }
+        if runDataMigrations {
+            // Hack: Load the account state now, so it can be accessed while performing other migrations.
+            // Otherwise one of them might indirectly try to load the account state using a sneaky transaction,
+            // which won't work because migrations use a barrier block to prevent observing database state
+            // before migration.
+            try grdbStorageAdapter.read { transaction in
+                _ = self.tsAccountManager.localAddress(with: transaction.asAnyRead)
+            }
 
-        // Finally, do data migrations.
-        registerDataMigrations(migrator: incrementalMigrator)
-        try incrementalMigrator.migrate(grdbStorageAdapter.pool)
+            // Finally, do data migrations.
+            registerDataMigrations(migrator: incrementalMigrator)
+            try incrementalMigrator.migrate(grdbStorageAdapter.pool)
+        }
 
         let allAppliedMigrations = try grdbStorageAdapter.read { transaction in
             try DatabaseMigrator().appliedIdentifiers(transaction.database)
diff --git a/SignalServiceKit/src/Storage/Database/SDSCodableModel.swift b/SignalServiceKit/src/Storage/Database/SDSCodableModel.swift
index 7df0f76e1c5..3318f561e88 100644
--- a/SignalServiceKit/src/Storage/Database/SDSCodableModel.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSCodableModel.swift
@@ -407,6 +407,15 @@ public extension SDSCodableModel {
         )
     }
 
+    static func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
+
     // Traverses all records' unique ids.
     // Records are not visited in any particular order.
     static func anyEnumerateUniqueIds(
diff --git a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
index 1477e3828b1..cd27d7c6433 100644
--- a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
@@ -100,10 +100,16 @@ public class SDSDatabaseStorage: SDSTransactable {
 
         Logger.info("")
 
-        let didPerformIncrementalMigrations = GRDBSchemaMigrator.migrateDatabase(
-            databaseStorage: self,
-            isMainDatabase: true
-        )
+        let didPerformIncrementalMigrations: Bool = {
+            do {
+                return try GRDBSchemaMigrator.migrateDatabase(
+                    databaseStorage: self,
+                    isMainDatabase: true
+                )
+            } catch {
+                owsFail("Database migration failed. Error: \(error.grdbErrorForLogging)")
+            }
+        }()
 
         Logger.info("didPerformIncrementalMigrations: \(didPerformIncrementalMigrations)")
 
@@ -151,10 +157,14 @@ public class SDSDatabaseStorage: SDSTransactable {
 
         let (promise, future) = Guarantee<Void>.pending()
         reopenGRDBStorage {
-            GRDBSchemaMigrator.migrateDatabase(
-                databaseStorage: self,
-                isMainDatabase: true
-            )
+            do {
+                try GRDBSchemaMigrator.migrateDatabase(
+                    databaseStorage: self,
+                    isMainDatabase: true
+                )
+            } catch {
+                owsFail("Database migration failed. Error: \(error.grdbErrorForLogging)")
+            }
 
             self.grdbStorage.publishUpdatesImmediately()
 
@@ -493,4 +503,8 @@ public extension SDSDatabaseStorage {
     var databaseSHMFileSize: UInt64 {
         grdbStorage.databaseSHMFileSize
     }
+
+    var databaseCombinedFileSize: UInt64 {
+        databaseFileSize + databaseWALFileSize + databaseSHMFileSize
+    }
 }
diff --git a/SignalServiceKit/src/Storage/FullTextSearchFinder.swift b/SignalServiceKit/src/Storage/FullTextSearchFinder.swift
index 8cafe105ef1..4d2c593ba24 100644
--- a/SignalServiceKit/src/Storage/FullTextSearchFinder.swift
+++ b/SignalServiceKit/src/Storage/FullTextSearchFinder.swift
@@ -214,6 +214,14 @@ class GRDBFullTextSearchFinder: NSObject {
     static let ftsContentColumn = "ftsIndexableContent"
     static var matchTag: String { FullTextSearchFinder.matchTag }
 
+    public static let indexableModelTypes: [SDSIndexableModel.Type] = [
+        TSThread.self,
+        TSInteraction.self,
+        TSGroupMember.self,
+        SignalAccount.self,
+        SignalRecipient.self
+    ]
+
     private class func collection(forModel model: SDSIndexableModel) -> String {
         // Note that allModelsWereRemoved(collection: ) makes the same
         // assumption that the FTS collection matches the
@@ -229,7 +237,23 @@ class GRDBFullTextSearchFinder: NSObject {
         return "\(collection).\(uniqueId)"
     }
 
-    private class func shouldIndexModel(_ model: SDSIndexableModel) -> Bool {
+    #if TESTABLE_BUILD
+    private class func `is`(_ value: Any, ofType type: Any.Type) -> Bool {
+        var currentMirror: Mirror? = Mirror(reflecting: value)
+        while let mirror = currentMirror {
+            if mirror.subjectType == type { return true }
+            currentMirror = mirror.superclassMirror
+        }
+        return false
+    }
+    #endif
+
+    fileprivate class func shouldIndexModel(_ model: SDSIndexableModel) -> Bool {
+        #if TESTABLE_BUILD
+        let isIndexable = indexableModelTypes.contains { Self.is(model, ofType: $0) }
+        owsAssert(isIndexable)
+        #endif
+
         if let userProfile = model as? OWSUserProfile,
            OWSUserProfile.isLocalProfileAddress(userProfile.address) {
             // We don't need to index the user profile for the local user.
@@ -637,7 +661,9 @@ class AnySearchIndexer: Dependencies {
         return ""
     }
 
-    class func indexContent(object: Any, transaction: SDSAnyReadTransaction) -> String? {
+    class func indexContent(object: SDSIndexableModel, transaction: SDSAnyReadTransaction) -> String? {
+        owsAssertDebug(GRDBFullTextSearchFinder.shouldIndexModel(object))
+
         if let groupThread = object as? TSGroupThread {
             return self.groupThreadIndexer.index(groupThread, transaction: transaction)
         } else if let groupMember = object as? TSGroupMember {
@@ -661,6 +687,7 @@ class AnySearchIndexer: Dependencies {
         } else if let signalRecipient = object as? SignalRecipient {
             return self.recipientIndexer.index(signalRecipient.address, transaction: transaction)
         } else {
+            // This should be impossible (see assertion above), but we have it here just in case.
             return nil
         }
     }
@@ -670,4 +697,9 @@ public protocol SDSIndexableModel {
     var uniqueId: String { get }
     static var ftsIndexMode: TSFTSIndexMode { get }
     static func collection() -> String
+
+    static func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    )
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift
index 9d0ca5d10c6..7f5e766b5ac 100644
--- a/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift
@@ -485,6 +485,15 @@ extension SSKJobRecord: SDSModel {
     public static var table: SDSTableMetadata {
         SSKJobRecordSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/TestUtils/MockSSKEnvironment.m b/SignalServiceKit/src/TestUtils/MockSSKEnvironment.m
index 413c2b03a5f..a6f7e18757e 100644
--- a/SignalServiceKit/src/TestUtils/MockSSKEnvironment.m
+++ b/SignalServiceKit/src/TestUtils/MockSSKEnvironment.m
@@ -169,14 +169,6 @@ - (void)setContactsManagerForMockEnvironment:(id<ContactsManagerProtocol>)contac
     [super setContactsManagerRef:contactsManager];
 }
 
-- (void)configureGrdb
-{
-    OWSAssertIsOnMainThread();
-
-    SDSDatabaseStorage *mainDatabase = self.databaseStorage;
-    [GRDBSchemaMigrator migrateDatabase:mainDatabase isMainDatabase:true];
-}
-
 @end
 
 #endif
diff --git a/SignalServiceKit/src/TestUtils/MockSSKEnvironment.swift b/SignalServiceKit/src/TestUtils/MockSSKEnvironment.swift
new file mode 100644
index 00000000000..1b739ee08cc
--- /dev/null
+++ b/SignalServiceKit/src/TestUtils/MockSSKEnvironment.swift
@@ -0,0 +1,24 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+#if TESTABLE_BUILD
+
+extension MockSSKEnvironment {
+    @objc
+    func configureGrdb() {
+        do {
+            try GRDBSchemaMigrator.migrateDatabase(
+                databaseStorage: databaseStorage,
+                isMainDatabase: true,
+                runDataMigrations: true
+            )
+        } catch {
+            owsFail("\(error)")
+        }
+    }
+}
+
+#endif
diff --git a/SignalServiceKit/src/Util/AppVersion.m b/SignalServiceKit/src/Util/AppVersion.m
index 95b0de3e90f..b91631f586a 100755
--- a/SignalServiceKit/src/Util/AppVersion.m
+++ b/SignalServiceKit/src/Util/AppVersion.m
@@ -122,6 +122,8 @@ - (void)startupLogging
     OWSLogInfo(@"lastCompletedLaunchSAEAppVersion: %@", self.lastCompletedLaunchSAEAppVersion);
     OWSLogInfo(@"lastCompletedLaunchNSEAppVersion: %@", self.lastCompletedLaunchNSEAppVersion);
 
+    OWSLogInfo(@"Database corruption state: %@", self.databaseCorruptionStateString);
+
     OWSLogInfo(@"iOS Version: %@", [[self class] iOSVersionString]);
 
     NSString *localeIdentifier = [NSLocale.currentLocale objectForKey:NSLocaleIdentifier];
diff --git a/SignalServiceKit/src/Util/AppVersion.swift b/SignalServiceKit/src/Util/AppVersion.swift
new file mode 100644
index 00000000000..04b3313943e
--- /dev/null
+++ b/SignalServiceKit/src/Util/AppVersion.swift
@@ -0,0 +1,17 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+extension AppVersion {
+    /// Get the database corruption state as a string.
+    ///
+    /// We can remove this if we move its callers to Swift; it is only here to ease interopability.
+    @objc
+    public var databaseCorruptionStateString: String {
+        let userDefaults = CurrentAppContext().appUserDefaults()
+        let state = DatabaseCorruptionState(userDefaults: userDefaults)
+        return String(describing: state)
+    }
+}
diff --git a/SignalServiceKit/src/Util/OWSBackupFragment+SDS.swift b/SignalServiceKit/src/Util/OWSBackupFragment+SDS.swift
index 4df3f68f96b..18c9342852d 100644
--- a/SignalServiceKit/src/Util/OWSBackupFragment+SDS.swift
+++ b/SignalServiceKit/src/Util/OWSBackupFragment+SDS.swift
@@ -157,6 +157,15 @@ extension OWSBackupFragment: SDSModel {
     public static var table: SDSTableMetadata {
         OWSBackupFragmentSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Util/OWSFileSystem.swift b/SignalServiceKit/src/Util/OWSFileSystem.swift
index 8d9699fafc5..0bddef1d372 100644
--- a/SignalServiceKit/src/Util/OWSFileSystem.swift
+++ b/SignalServiceKit/src/Util/OWSFileSystem.swift
@@ -4,12 +4,6 @@
 
 import Foundation
 
-public protocol FileManagerProtocol {
-    func attributesOfFileSystem(forPath path: String) throws -> [FileAttributeKey: Any]
-}
-
-extension FileManager: FileManagerProtocol {}
-
 @objc
 public extension OWSFileSystem {
     class func fileOrFolderExists(atPath filePath: String) -> Bool {
@@ -162,14 +156,15 @@ public extension OWSFileSystem {
 
 public extension OWSFileSystem {
     /// Get the remaining free space for a path's volume in bytes.
-    class func freeSpaceInBytes(
-        forPath path: String,
-        fileManager: FileManagerProtocol
-    ) throws -> UInt64 {
-        let fileSystemAttributes = try fileManager.attributesOfFileSystem(forPath: path)
-        guard let result = fileSystemAttributes[.systemFreeSize] as? UInt64 else {
+    ///
+    /// See [Apple's example][0]. It checks "important" storage (versus "opportunistic" storage).
+    ///
+    /// [0]: https://developer.apple.com/documentation/foundation/nsurlresourcekey/checking_volume_storage_capacity
+    class func freeSpaceInBytes(forPath path: URL) throws -> UInt64 {
+        let resourceValues = try path.resourceValues(forKeys: [.volumeAvailableCapacityForImportantUsageKey])
+        guard let result = resourceValues.volumeAvailableCapacityForImportantUsage else {
             throw OWSGenericError("Could not determine remaining disk space")
         }
-        return result
+        return UInt64(result)
     }
 }
diff --git a/SignalServiceKit/src/Util/OWSUserProfile+SDS.swift b/SignalServiceKit/src/Util/OWSUserProfile+SDS.swift
index 4793353856b..ab1c7069421 100644
--- a/SignalServiceKit/src/Util/OWSUserProfile+SDS.swift
+++ b/SignalServiceKit/src/Util/OWSUserProfile+SDS.swift
@@ -206,6 +206,15 @@ extension OWSUserProfile: SDSModel {
     public static var table: SDSTableMetadata {
         OWSUserProfileSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/src/Util/SSKPreferences.swift b/SignalServiceKit/src/Util/SSKPreferences.swift
index d83de067e42..b7ad54ab9f8 100644
--- a/SignalServiceKit/src/Util/SSKPreferences.swift
+++ b/SignalServiceKit/src/Util/SSKPreferences.swift
@@ -266,14 +266,4 @@ public class SSKPreferences: NSObject {
     public static func setShouldKeepMutedChatsArchived(_ newValue: Bool, transaction: SDSAnyWriteTransaction) {
         store.setBool(newValue, key: shouldKeepMutedChatsArchivedKey, transaction: transaction)
     }
-
-    private static var hasGrdbDatabaseCorruptionKey: String { "hasGrdbDatabaseCorruption" }
-    @objc
-    public static func hasGrdbDatabaseCorruption() -> Bool {
-        let appUserDefaults = CurrentAppContext().appUserDefaults()
-        guard let preference = appUserDefaults.object(forKey: hasGrdbDatabaseCorruptionKey) as? NSNumber else {
-            return false
-        }
-        return preference.boolValue
-    }
 }
diff --git a/SignalServiceKit/src/Util/TestModel+SDS.swift b/SignalServiceKit/src/Util/TestModel+SDS.swift
index 6cbc419de5d..98f9434cc37 100644
--- a/SignalServiceKit/src/Util/TestModel+SDS.swift
+++ b/SignalServiceKit/src/Util/TestModel+SDS.swift
@@ -173,6 +173,15 @@ extension TestModel: SDSModel {
     public static var table: SDSTableMetadata {
         TestModelSerializer.table
     }
+
+    public class func anyEnumerateIndexable(
+        transaction: SDSAnyReadTransaction,
+        block: @escaping (SDSIndexableModel) -> Void
+    ) {
+        anyEnumerate(transaction: transaction, batched: false) { model, _ in
+            block(model)
+        }
+    }
 }
 
 // MARK: - DeepCopyable
diff --git a/SignalServiceKit/tests/Storage/Database/DatabaseCorruptionStateTest.swift b/SignalServiceKit/tests/Storage/Database/DatabaseCorruptionStateTest.swift
index 01e5624878b..b7069b49dc7 100644
--- a/SignalServiceKit/tests/Storage/Database/DatabaseCorruptionStateTest.swift
+++ b/SignalServiceKit/tests/Storage/Database/DatabaseCorruptionStateTest.swift
@@ -3,7 +3,7 @@
 //
 
 import XCTest
-import SignalServiceKit
+@testable import SignalServiceKit
 
 class DatabaseCorruptionStateTest: XCTestCase {
     private func userDefaults() -> UserDefaults {
@@ -15,18 +15,61 @@ class DatabaseCorruptionStateTest: XCTestCase {
 
     func testCorruptionChanges() throws {
         let defaults = userDefaults()
+        func fetch() -> DatabaseCorruptionState {
+            DatabaseCorruptionState(userDefaults: defaults)
+        }
+        func expected(
+            _ status: DatabaseCorruptionState.DatabaseCorruptionStatus,
+            count: UInt
+        ) -> DatabaseCorruptionState {
+            DatabaseCorruptionState(status: status, count: count)
+        }
 
         // Initial state
-        XCTAssertEqual(
-            DatabaseCorruptionState.databaseCorruptionStatus(userDefaults: defaults),
-            .notCorrupted
-        )
+        XCTAssertEqual(fetch(), expected(.notCorrupted, count: 0))
 
         // After flagging as corrupted
         DatabaseCorruptionState.flagDatabaseAsCorrupted(userDefaults: defaults)
-        XCTAssertEqual(
-            DatabaseCorruptionState.databaseCorruptionStatus(userDefaults: defaults),
-            .corrupted
-        )
+        XCTAssertEqual(fetch(), expected(.corrupted, count: 1))
+
+        // After partial recovery
+        DatabaseCorruptionState.flagCorruptedDatabaseAsDumpedAndRestored(userDefaults: defaults)
+        XCTAssertEqual(fetch(), expected(.corruptedButAlreadyDumpedAndRestored, count: 1))
+
+        // After full recovery
+        DatabaseCorruptionState.flagDatabaseAsRecoveredFromCorruption(userDefaults: defaults)
+        XCTAssertEqual(fetch(), expected(.notCorrupted, count: 1))
+
+        // After another corruption
+        DatabaseCorruptionState.flagDatabaseAsCorrupted(userDefaults: defaults)
+        XCTAssertEqual(fetch(), expected(.corrupted, count: 2))
+    }
+
+    func testLegacyFalseValueWithoutCount() throws {
+        let defaults = userDefaults()
+        defaults.set(false, forKey: DatabaseCorruptionState.databaseCorruptionStatusKey)
+
+        let expected = DatabaseCorruptionState(status: .notCorrupted, count: 0)
+        let actual = DatabaseCorruptionState(userDefaults: defaults)
+        XCTAssertEqual(actual, expected)
+    }
+
+    func testLegacyTrueValueWithoutCount() throws {
+        let defaults = userDefaults()
+        defaults.set(true, forKey: DatabaseCorruptionState.databaseCorruptionStatusKey)
+
+        let expected = DatabaseCorruptionState(status: .corrupted, count: 1)
+        let actual = DatabaseCorruptionState(userDefaults: defaults)
+        XCTAssertEqual(actual, expected)
+    }
+
+    func testInvalidData() throws {
+        let defaults = userDefaults()
+        defaults.set("garbage", forKey: DatabaseCorruptionState.databaseCorruptionStatusKey)
+        defaults.set("garbage", forKey: DatabaseCorruptionState.databaseCorruptionCountKey)
+
+        let expected = DatabaseCorruptionState(status: .notCorrupted, count: 0)
+        let actual = DatabaseCorruptionState(userDefaults: defaults)
+        XCTAssertEqual(actual, expected)
     }
 }
diff --git a/SignalServiceKit/tests/Storage/Database/DatabaseRecoveryTest.swift b/SignalServiceKit/tests/Storage/Database/DatabaseRecoveryTest.swift
new file mode 100644
index 00000000000..6fae2052879
--- /dev/null
+++ b/SignalServiceKit/tests/Storage/Database/DatabaseRecoveryTest.swift
@@ -0,0 +1,356 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import XCTest
+@testable import SignalServiceKit
+import GRDB
+
+final class DatabaseRecoveryTest: SSKBaseTestSwift {
+    // MARK: - Setup
+
+    override func setUp() {
+        super.setUp()
+        tsAccountManager.registerForTests(withLocalNumber: "+12225550101", uuid: UUID(), pni: UUID())
+    }
+
+    // MARK: - Dump and restore
+
+    func testDumpedTables() throws {
+        let allTableNames = DatabaseRecovery.DumpAndRestore.allTableNames
+        let allTableNamesSet = Set(allTableNames)
+
+        let hasDuplicates = allTableNames.count != allTableNamesSet.count
+        XCTAssertFalse(hasDuplicates)
+
+        for tableName in allTableNames {
+            XCTAssertFalse(tableName.starts(with: "sqlite_"))
+            XCTAssertFalse(tableName.isEmpty)
+            XCTAssertNotNil(tableName.range(of: validTableOrColumnNameRegex, options: .regularExpression))
+        }
+
+        let expectedTableNames: Set<String> = try {
+            let (databaseStorage, _) = database()
+            try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+            return databaseStorage.read { allNormalTableNames(transaction: $0) }
+        }()
+        XCTAssertEqual(allTableNamesSet, expectedTableNames)
+    }
+
+    func testColumnSafety() throws {
+        let (databaseStorage, _) = database()
+        let tableNames: Set<String> = try {
+            try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+            return databaseStorage.read { allNormalTableNames(transaction: $0) }
+        }()
+
+        for tableName in tableNames {
+            let columnNames = try databaseStorage.read { transaction in
+                try Self.columnNames(transaction: transaction, tableName: tableName)
+            }
+            for columnName in columnNames {
+                XCTAssertFalse(columnName.isEmpty)
+                XCTAssertNotNil(columnName.range(of: validTableOrColumnNameRegex, options: .regularExpression))
+            }
+        }
+    }
+
+    func testDumpAndRestoreOfEmptyDatabase() throws {
+        let (databaseStorage, url) = database()
+        try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+        try XCTUnwrap(databaseStorage.grdbStorage.pool.close())
+
+        let dump = DatabaseRecovery.DumpAndRestore(databaseFileUrl: url)
+        try XCTUnwrap(dump.run())
+
+        let finishedDatabaseStorage = SDSDatabaseStorage(
+            databaseFileUrl: url,
+            delegate: DatabaseTestHelpers.TestSDSDatabaseStorageDelegate()
+        )
+        finishedDatabaseStorage.read { transaction in
+            let database = transaction.unwrapGrdbRead.database
+            for tableName in allNormalTableNames(transaction: transaction) {
+                let sql = "SELECT EXISTS (SELECT 1 FROM \(tableName))"
+                guard let anyRowExists = try? XCTUnwrap(Bool.fetchOne(database, sql: sql)) else {
+                    XCTFail("Could not fetch boolean from test query")
+                    return
+                }
+                XCTAssertFalse(anyRowExists, "\(tableName) had at least one row, unexpectedly")
+            }
+        }
+    }
+
+    func testDumpAndRestoreOnHappyDatabase() throws {
+        let (databaseStorage, url) = database()
+        try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+
+        let contactUuid = UUID()
+        let contactAddress = SignalServiceAddress(uuid: contactUuid)
+
+        guard let localAddress = tsAccountManager.localAddress else {
+            XCTFail("No local address. Test is not set up correctly")
+            return
+        }
+
+        try! databaseStorage.write { transaction in
+            // Threads
+            let contactThread = insertContactThread(
+                contactAddress: contactAddress,
+                transaction: transaction
+            )
+            guard let contactThreadId = contactThread.grdbId?.int64Value else {
+                XCTFail("Thread was not inserted properly")
+                return
+            }
+
+            // Message
+            let messageBuilder = TSIncomingMessageBuilder.incomingMessageBuilder(
+                thread: contactThread,
+                messageBody: "test outgoing message"
+            )
+            messageBuilder.timestamp = 1234
+            messageBuilder.authorAddress = contactAddress
+            let message = messageBuilder.build()
+            message.anyInsert(transaction: transaction)
+
+            // Reaction
+            let reaction = OWSReaction(
+                uniqueMessageId: message.uniqueId,
+                emoji: "",
+                reactor: localAddress,
+                sentAtTimestamp: 1234,
+                receivedAtTimestamp: 1234
+            )
+            reaction.anyInsert(transaction: transaction)
+
+            // Pending read receipts (not copied)
+            let pendingReadReceipt = PendingReadReceiptRecord(
+                threadId: contactThreadId,
+                messageTimestamp: Int64(message.timestamp),
+                messageUniqueId: message.uniqueId,
+                authorPhoneNumber: nil,
+                authorUuid: contactUuid.uuidString
+            )
+            try pendingReadReceipt.insert(transaction.unwrapGrdbWrite.database)
+        }
+
+        try XCTUnwrap(databaseStorage.grdbStorage.pool.close())
+
+        let dump = DatabaseRecovery.DumpAndRestore(databaseFileUrl: url)
+        try XCTUnwrap(dump.run())
+
+        let finishedDatabaseStorage = SDSDatabaseStorage(
+            databaseFileUrl: url,
+            delegate: DatabaseTestHelpers.TestSDSDatabaseStorageDelegate()
+        )
+        finishedDatabaseStorage.read { transaction in
+            // Thread
+            let thread = TSContactThread.getWithContactAddress(
+                contactAddress,
+                transaction: transaction
+            )
+            guard let thread = thread else {
+                XCTFail("Contact thread not found in migrated database")
+                return
+            }
+
+            // Message
+            let threadInteractions: [TSInteraction] = {
+                var result = [TSInteraction]()
+                let finder = InteractionFinder(threadUniqueId: thread.uniqueId)
+                try? finder.enumerateRecentInteractions(transaction: transaction) { interaction, _ in
+                    result.append(interaction)
+                }
+                return result
+            }()
+            XCTAssertEqual(threadInteractions.count, 1)
+            guard let interaction = threadInteractions.first as? TSIncomingMessage else {
+                XCTFail("Interaction is not an outgoing message")
+                return
+            }
+            XCTAssertEqual(interaction.body, "test outgoing message")
+
+            // Reaction
+            let reactions: [OWSReaction] = {
+                let finder = ReactionFinder(uniqueMessageId: interaction.uniqueId)
+                return finder.allReactions(transaction: transaction.unwrapGrdbRead)
+            }()
+            XCTAssertEqual(reactions.count, 1)
+            guard let reaction = reactions.first else {
+                XCTFail("Could not get the reaction")
+                return
+            }
+            XCTAssertEqual(reaction.emoji, "")
+
+            // Pending read receipts (not copied)
+            let db = transaction.unwrapGrdbRead.database
+            let pendingReadReceipts: [PendingReadReceiptRecord]
+            do {
+                pendingReadReceipts = try PendingReadReceiptRecord.fetchAll(db)
+            } catch {
+                XCTFail("\(error)")
+                return
+            }
+            XCTAssert(
+                pendingReadReceipts.isEmpty,
+                "Unexpectedly found \(pendingReadReceipts.count) pending read receipt(s)"
+            )
+        }
+    }
+
+    func testDumpAndRestoreWithInvalidEssentialTable() throws {
+        let (databaseStorage, url) = database()
+        try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+        databaseStorage.write { transaction in
+            try! transaction.unwrapGrdbWrite.database.drop(table: SDSKeyValueStore.tableName)
+        }
+        try XCTUnwrap(databaseStorage.grdbStorage.pool.close())
+
+        let dump = DatabaseRecovery.DumpAndRestore(databaseFileUrl: url)
+        XCTAssertThrowsError(try dump.run()) { error in
+            XCTAssertEqual(
+                error as? DatabaseRecoveryError,
+                DatabaseRecoveryError.unrecoverablyCorrupted
+            )
+        }
+    }
+
+    func testDumpAndRestoreWithInvalidNonessentialTable() throws {
+        let (databaseStorage, url) = database()
+        try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+        databaseStorage.write { transaction in
+            try! transaction.unwrapGrdbWrite.database.drop(table: OWSReaction.databaseTableName)
+        }
+        try XCTUnwrap(databaseStorage.grdbStorage.pool.close())
+
+        let dump = DatabaseRecovery.DumpAndRestore(databaseFileUrl: url)
+        try XCTUnwrap(dump.run())
+
+        let finishedDatabaseStorage = SDSDatabaseStorage(
+            databaseFileUrl: url,
+            delegate: DatabaseTestHelpers.TestSDSDatabaseStorageDelegate()
+        )
+        finishedDatabaseStorage.read { transaction in
+            let sql = "SELECT EXISTS (SELECT 1 FROM \(OWSReaction.databaseTableName))"
+            let database = transaction.unwrapGrdbRead.database
+            guard let anyRowExists = try? XCTUnwrap(Bool.fetchOne(database, sql: sql)) else {
+                XCTFail("Could not fetch boolean from test query")
+                return
+            }
+            XCTAssertFalse(anyRowExists, "Unexpectedly found a reaction")
+        }
+    }
+
+    // MARK: - Manual restoration
+
+    func testFullTextSearchRestoration() throws {
+        let (databaseStorage, url) = database()
+        try GRDBSchemaMigrator.migrateDatabase(databaseStorage: databaseStorage, isMainDatabase: false)
+
+        databaseStorage.write { transaction in
+            let contactAddress = SignalServiceAddress(uuid: UUID())
+
+            let contactThread = insertContactThread(
+                contactAddress: contactAddress,
+                transaction: transaction
+            )
+
+            let messageBuilder = TSIncomingMessageBuilder.incomingMessageBuilder(
+                thread: contactThread,
+                messageBody: "foo bar"
+            )
+            messageBuilder.timestamp = 1234
+            messageBuilder.authorAddress = contactAddress
+            let message = messageBuilder.build()
+            message.anyInsert(transaction: transaction)
+        }
+
+        try XCTUnwrap(databaseStorage.grdbStorage.pool.close())
+
+        let dump = DatabaseRecovery.DumpAndRestore(databaseFileUrl: url)
+        try XCTUnwrap(dump.run())
+
+        let finishedDatabaseStorage = SDSDatabaseStorage(
+            databaseFileUrl: url,
+            delegate: DatabaseTestHelpers.TestSDSDatabaseStorageDelegate()
+        )
+
+        let manualRecreation = DatabaseRecovery.ManualRecreation(databaseStorage: finishedDatabaseStorage)
+        manualRecreation.run()
+
+        finishedDatabaseStorage.read { transaction in
+            func searchMessages(for searchText: String) -> [TSMessage] {
+                var result = [TSMessage]()
+                    FullTextSearchFinder().enumerateObjects(
+                    searchText: searchText,
+                    collections: [TSMessage.collection()],
+                    maxResults: 99,
+                    transaction: transaction
+                ) { match, _, _ in
+                    guard let match = match as? TSMessage else { return }
+                    result.append(match)
+                }
+                return result
+            }
+
+            XCTAssertEqual(searchMessages(for: "foo").count, 1)
+            XCTAssertTrue(searchMessages(for: "garbage").isEmpty)
+        }
+    }
+
+    // MARK: - Test helpers
+
+    let validTableOrColumnNameRegex = "^[a-zA-Z][a-zA-Z0-9_]+$"
+
+    func database() -> (databaseStorage: SDSDatabaseStorage, url: URL) {
+        let url = OWSFileSystem.temporaryFileUrl()
+        let databaseStorage = SDSDatabaseStorage(
+            databaseFileUrl: url,
+            delegate: DatabaseTestHelpers.TestSDSDatabaseStorageDelegate()
+        )
+        return (databaseStorage: databaseStorage, url: url)
+    }
+
+    func allNormalTableNames(transaction: SDSAnyReadTransaction) -> Set<String> {
+        let db = transaction.unwrapGrdbRead.database
+        let sql = "SELECT name FROM sqlite_schema WHERE type IS 'table'"
+        let allTableNames = Set((try? String.fetchAll(db, sql: sql)) ?? [])
+        owsAssert(!allTableNames.isEmpty, "No tables were found!")
+
+        let tableNamesToSkip: Set<String> = ["grdb_migrations", "sqlite_sequence"]
+        return allTableNames.filter { tableName in
+            !tableNamesToSkip.contains(tableName) && !tableName.starts(with: "indexable_text")
+        }
+    }
+
+    static func columnNames(transaction: SDSAnyReadTransaction, tableName: String) throws -> [String] {
+        let db = transaction.unwrapGrdbRead.database
+        var result = [String]()
+        let cursor = try Row.fetchCursor(db, sql: "PRAGMA table_info(\(tableName))")
+        try cursor.forEach { row in
+            guard let columnName = row["name"] as? String else {
+                throw OWSGenericError("Column name could not be read. Test is not working correctly")
+            }
+            result.append(columnName)
+        }
+        return result
+    }
+
+    func insertContactThread(
+        contactAddress: SignalServiceAddress,
+        transaction: SDSAnyWriteTransaction
+    ) -> TSContactThread {
+        TSContactThread.getOrCreateThread(
+            withContactAddress: contactAddress,
+            transaction: transaction
+        )
+    }
+}
+
+// MARK: - Test-only extensions
+
+extension DatabaseRecovery.DumpAndRestore {
+    fileprivate static var allTableNames: [String] {
+        tablesToCopyWithBestEffort + tablesThatMustBeCopiedFlawlessly + tablesExplicitlySkipped
+    }
+}
diff --git a/SignalServiceKit/tests/Storage/Database/GRDBDatabaseStorageAdapterTest.swift b/SignalServiceKit/tests/Storage/Database/GRDBDatabaseStorageAdapterTest.swift
new file mode 100644
index 00000000000..2de37867a8f
--- /dev/null
+++ b/SignalServiceKit/tests/Storage/Database/GRDBDatabaseStorageAdapterTest.swift
@@ -0,0 +1,22 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import XCTest
+import SignalServiceKit
+
+final class GRDBDatabaseStorageAdapterTest: XCTestCase {
+    func testWalFileUrl() throws {
+        let input = URL(fileURLWithPath: "/tmp/foo.db")
+        let expected = URL(fileURLWithPath: "/tmp/foo.db-wal")
+        let actual = GRDBDatabaseStorageAdapter.walFileUrl(for: input)
+        XCTAssertEqual(actual, expected)
+    }
+
+    func testShmFileUrl() throws {
+        let input = URL(fileURLWithPath: "/tmp/foo.db")
+        let expected = URL(fileURLWithPath: "/tmp/foo.db-shm")
+        let actual = GRDBDatabaseStorageAdapter.shmFileUrl(for: input)
+        XCTAssertEqual(actual, expected)
+    }
+}
diff --git a/SignalServiceKit/tests/Storage/Database/GRDBSchemaMigratorTest.swift b/SignalServiceKit/tests/Storage/Database/GRDBSchemaMigratorTest.swift
index 04bd2dd7dd4..a2876e8566f 100644
--- a/SignalServiceKit/tests/Storage/Database/GRDBSchemaMigratorTest.swift
+++ b/SignalServiceKit/tests/Storage/Database/GRDBSchemaMigratorTest.swift
@@ -12,7 +12,7 @@ class GRDBSchemaMigratorTest: XCTestCase {
             delegate: DatabaseTestHelpers.TestSDSDatabaseStorageDelegate()
         )
 
-        GRDBSchemaMigrator.migrateDatabase(
+        try GRDBSchemaMigrator.migrateDatabase(
             databaseStorage: databaseStorage,
             isMainDatabase: false
         )
diff --git a/SignalServiceKit/tests/Util/OWSFileSystemTest.swift b/SignalServiceKit/tests/Util/OWSFileSystemTest.swift
index d881705fa99..aa403c8acff 100644
--- a/SignalServiceKit/tests/Util/OWSFileSystemTest.swift
+++ b/SignalServiceKit/tests/Util/OWSFileSystemTest.swift
@@ -6,25 +6,9 @@ import XCTest
 import SignalServiceKit
 
 class OWSFileSystemTest: XCTestCase {
-    private class MockFileManager: FileManagerProtocol {
-        public var attributesOfFileSystemHandler: (String) throws -> [FileAttributeKey: Any] = { _ in
-            [:]
-        }
-        func attributesOfFileSystem(forPath path: String) throws -> [FileAttributeKey: Any] {
-            try attributesOfFileSystemHandler(path)
-        }
-    }
-
     func testFreeSpaceInBytes() throws {
-        let fileManager = MockFileManager()
-        fileManager.attributesOfFileSystemHandler = { _ in
-            [.systemFreeSize: NSNumber(value: 1234)]
-        }
-
-        let result = try XCTUnwrap(
-            OWSFileSystem.freeSpaceInBytes(forPath: "/tmp", fileManager: fileManager)
-        )
-
-        XCTAssertEqual(result, 1234)
+        let path = URL(fileURLWithPath: "/tmp")
+        let result = try XCTUnwrap(OWSFileSystem.freeSpaceInBytes(forPath: path))
+        XCTAssertGreaterThan(result, 1)
     }
 }
