diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
index c373ef2553c..efa3edb355c 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
@@ -14,6 +14,7 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
         let hasTapForMore: Bool
         let shouldUseAttributedText: Bool
         let hasPendingMessageRequest: Bool
+        fileprivate let dataItems: [DataItem]
 
         public var canUseDedicatedCell: Bool {
             if hasTapForMore || searchText != nil {
@@ -71,21 +72,16 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
         componentState.isJumbomojiMessage
     }
 
-    private static func buildDataDetectorWithLinks(shouldAllowLinkification: Bool) -> NSDataDetector? {
-        let uiDataDetectorTypes: UIDataDetectorTypes = (shouldAllowLinkification
-                                                            ? kOWSAllowedDataDetectorTypes
-                                                            : kOWSAllowedDataDetectorTypesExceptLinks)
-        var nsDataDetectorTypes: NSTextCheckingTypes = 0
-        if uiDataDetectorTypes.contains(UIDataDetectorTypes.link) {
-            nsDataDetectorTypes |= NSTextCheckingResult.CheckingType.link.rawValue
+    private static func buildDataDetector(shouldAllowLinkification: Bool) -> NSDataDetector? {
+        var checkingTypes = NSTextCheckingResult.CheckingType()
+        if shouldAllowLinkification {
+            checkingTypes.insert(.link)
         }
-        if uiDataDetectorTypes.contains(UIDataDetectorTypes.address) {
-            nsDataDetectorTypes |= NSTextCheckingResult.CheckingType.address.rawValue
-        }
-        // TODO: There doesn't seem to be an equivalent to UIDataDetectorTypes.calendarEvent.
+        checkingTypes.insert(.address)
+        checkingTypes.insert(.phoneNumber)
 
         do {
-            return try NSDataDetector(types: nsDataDetectorTypes)
+            return try NSDataDetector(types: checkingTypes.rawValue)
         } catch {
             owsFailDebug("Error: \(error)")
             return nil
@@ -93,11 +89,11 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
     }
 
     private static var dataDetectorWithLinks: NSDataDetector? = {
-        buildDataDetectorWithLinks(shouldAllowLinkification: true)
+        buildDataDetector(shouldAllowLinkification: true)
     }()
 
     private static var dataDetectorWithoutLinks: NSDataDetector? = {
-        buildDataDetectorWithLinks(shouldAllowLinkification: false)
+        buildDataDetector(shouldAllowLinkification: false)
     }()
 
     // DataDetectors are expensive to build, so we reuse them.
@@ -107,15 +103,27 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
 
     private static let unfairLock = UnfairLock()
 
-    private static func shouldUseAttributedText(text: String,
-                                                hasPendingMessageRequest: Bool,
-                                                shouldAllowLinkification: Bool) -> Bool {
+    fileprivate struct DataItem: Equatable {
+        enum DataType: Equatable {
+            case link
+            case address
+            case phoneNumber
+        }
+
+        let dataType: DataType
+        let range: NSRange
+        let snippet: String
+    }
+
+    private static func detectDataItems(text: String,
+                                        hasPendingMessageRequest: Bool,
+                                        shouldAllowLinkification: Bool) -> [DataItem] {
         // Use a lock to ensure that measurement on and off the main thread
         // don't conflict.
         unfairLock.withLock {
             guard !hasPendingMessageRequest else {
                 // Do not linkify if there is a pending message request.
-                return false
+                return []
             }
             // NSDataDetector and UIDataDetector behavior should be aligned.
             //
@@ -124,10 +132,68 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             guard let detector = dataDetector(shouldAllowLinkification: shouldAllowLinkification) else {
                 // If the data detectors can't be built, default to using attributed text.
                 owsFailDebug("Could not build dataDetector.")
-                return true
+                return []
             }
-            let hasLinks = !detector.matches(in: text, options: [], range: text.entireRange).isEmpty
-            return hasLinks
+            var dataItems = [DataItem]()
+            for match in detector.matches(in: text, options: [], range: text.entireRange) {
+                guard let snippet = (text as NSString).substring(with: match.range).strippedOrNil else {
+                    owsFailDebug("Invalid snippet.")
+                    continue
+                }
+
+                // NSTextCheckingResult.CheckingType
+                let dataType: DataItem.DataType
+                if match.resultType.contains(.orthography) {
+                    Logger.verbose("orthography")
+                    continue
+                } else if match.resultType.contains(.spelling) {
+                    Logger.verbose("spelling")
+                    continue
+                } else if match.resultType.contains(.grammar) {
+                    Logger.verbose("grammar")
+                    continue
+                } else if match.resultType.contains(.date) {
+                    Logger.verbose("date")
+                    continue
+                } else if match.resultType.contains(.address) {
+                    Logger.verbose("address")
+                    dataType = .address
+                } else if match.resultType.contains(.link) {
+                    Logger.verbose("link")
+                    dataType = .link
+                } else if match.resultType.contains(.quote) {
+                    Logger.verbose("quote")
+                    continue
+                } else if match.resultType.contains(.dash) {
+                    Logger.verbose("dash")
+                    continue
+                } else if match.resultType.contains(.replacement) {
+                    Logger.verbose("replacement")
+                    continue
+                } else if match.resultType.contains(.correction) {
+                    Logger.verbose("correction")
+                    continue
+                } else if match.resultType.contains(.regularExpression) {
+                    Logger.verbose("regularExpression")
+                    continue
+                } else if match.resultType.contains(.phoneNumber) {
+                    Logger.verbose("phoneNumber")
+                    dataType = .phoneNumber
+                } else if match.resultType.contains(.transitInformation) {
+                    Logger.verbose("transitInformation")
+                    continue
+                } else {
+                    let snippet = (text as NSString).substring(with: match.range)
+                    Logger.verbose("snippet: '\(snippet)'")
+                    owsFailDebug("Unknown link type: \(match.resultType.rawValue)")
+                    continue
+                }
+
+                dataItems.append(DataItem(dataType: dataType,
+                                          range: match.range,
+                                          snippet: snippet))
+            }
+            return dataItems
         }
     }
 
@@ -140,11 +206,19 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
         let searchText = viewStateSnapshot.searchText
         let isTextExpanded = textExpansion.isTextExpanded(interactionId: interaction.uniqueId)
 
+        let dataItems: [DataItem]
         var shouldUseAttributedText = false
         if let displayableText = bodyText.displayableText,
            let textValue = bodyText.textValue(isTextExpanded: isTextExpanded) {
+
+            let shouldAllowLinkification = displayableText.shouldAllowLinkification
+
             switch textValue {
             case .text(let text):
+                dataItems = detectDataItems(text: text,
+                                            hasPendingMessageRequest: hasPendingMessageRequest,
+                                            shouldAllowLinkification: shouldAllowLinkification)
+
                 // UILabels are much cheaper than UITextViews, and we can
                 // usually use them for rendering body text.
                 //
@@ -156,14 +230,16 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
                 if searchText != nil {
                     shouldUseAttributedText = true
                 } else {
-                    let shouldAllowLinkification = displayableText.shouldAllowLinkification
-                    shouldUseAttributedText = self.shouldUseAttributedText(text: text,
-                                                                           hasPendingMessageRequest: hasPendingMessageRequest,
-                                                                           shouldAllowLinkification: shouldAllowLinkification)
+                    shouldUseAttributedText = !dataItems.isEmpty
                 }
-            case .attributedText:
+            case .attributedText(let attributedText):
+                dataItems = detectDataItems(text: attributedText.string,
+                                            hasPendingMessageRequest: hasPendingMessageRequest,
+                                            shouldAllowLinkification: shouldAllowLinkification)
                 shouldUseAttributedText = true
             }
+        } else {
+            dataItems = []
         }
 
         return State(bodyText: bodyText,
@@ -171,7 +247,8 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
                      searchText: searchText,
                      hasTapForMore: hasTapForMore,
                      shouldUseAttributedText: shouldUseAttributedText,
-                     hasPendingMessageRequest: hasPendingMessageRequest)
+                     hasPendingMessageRequest: hasPendingMessageRequest,
+                     dataItems: dataItems)
     }
 
     static func buildComponentState(message: TSMessage,
@@ -325,12 +402,8 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             }
             textView.shouldIgnoreEvents = shouldIgnoreEvents
 
-            if hasPendingMessageRequest {
-                // Do not linkify text if there is a pending message request for this conversation.
-                textView.dataDetectorTypes = []
-            } else {
-                textView.ensureShouldLinkifyText(displayableText.shouldAllowLinkification)
-            }
+            // Do not linkify; we linkify manually.
+            textView.dataDetectorTypes = []
 
             textViewConfig.applyForRendering(textView: textView)
 
@@ -411,6 +484,41 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
         }
     }
 
+    private func linkifyData(attributedText: NSMutableAttributedString) {
+        let dataItems = bodyTextState.dataItems.sorted { (left, right) in
+            left.range.location < right.range.location
+        }
+        var lastIndex: Int = 0
+        for dataItem in dataItems {
+            let snippet = dataItem.snippet
+            let range = dataItem.range
+
+            guard range.location >= lastIndex else {
+                owsFailDebug("Overlapping ranges.")
+                continue
+            }
+
+            let link: String
+            switch dataItem.dataType {
+            case .link:
+                link = snippet
+            case .address:
+                // https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/MapLinks/MapLinks.html
+                guard let urlEncodedAddress = snippet.encodeURIComponent else {
+                    owsFailDebug("Could not URL encode address.")
+                    continue
+                }
+                link = "https://maps.apple.com/?q=" + urlEncodedAddress
+            case .phoneNumber:
+                // https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/PhoneLinks/PhoneLinks.html
+                link = "tel:" + snippet
+            }
+            attributedText.addAttribute(.link, value: link, range: range)
+
+            lastIndex = max(lastIndex, range.location + range.length)
+        }
+    }
+
     private func textViewConfig(displayableText: DisplayableText,
                                 attributedText attributedTextParam: NSAttributedString) -> CVTextViewConfig {
 
@@ -436,6 +544,7 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             ],
             range: attributedText.entireRange
         )
+        linkifyData(attributedText: attributedText)
 
         if let searchText = searchText,
            searchText.count >= ConversationSearchController.kMinimumSearchTextLength {
diff --git a/SignalMessaging/Views/OWSTextView.h b/SignalMessaging/Views/OWSTextView.h
index eae7f412ac0..3df50ac7f36 100644
--- a/SignalMessaging/Views/OWSTextView.h
+++ b/SignalMessaging/Views/OWSTextView.h
@@ -1,16 +1,11 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 NS_ASSUME_NONNULL_BEGIN
 
-extern const UIDataDetectorTypes kOWSAllowedDataDetectorTypes;
-extern const UIDataDetectorTypes kOWSAllowedDataDetectorTypesExceptLinks;
-
 @interface OWSTextView : UITextView
 
-- (void)ensureShouldLinkifyText:(BOOL)shouldLinkifyText;
-
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/SignalMessaging/Views/OWSTextView.m b/SignalMessaging/Views/OWSTextView.m
index d06d7403606..fe8718331fa 100644
--- a/SignalMessaging/Views/OWSTextView.m
+++ b/SignalMessaging/Views/OWSTextView.m
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 #import "OWSTextView.h"
@@ -7,12 +7,6 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-const UIDataDetectorTypes kOWSAllowedDataDetectorTypes
-    = UIDataDetectorTypeLink | UIDataDetectorTypeAddress | UIDataDetectorTypeCalendarEvent;
-
-const UIDataDetectorTypes kOWSAllowedDataDetectorTypesExceptLinks
-    = UIDataDetectorTypeAddress | UIDataDetectorTypeCalendarEvent;
-
 @implementation OWSTextView
 
 - (instancetype)initWithFrame:(CGRect)frame textContainer:(nullable NSTextContainer *)textContainer
@@ -21,8 +15,7 @@ - (instancetype)initWithFrame:(CGRect)frame textContainer:(nullable NSTextContai
         [self ows_applyTheme];
     }
 
-    // Setting dataDetectorTypes is expensive.  Do it just once.
-    self.dataDetectorTypes = kOWSAllowedDataDetectorTypes;
+    self.dataDetectorTypes = UIDataDetectorTypeNone;
 
     return self;
 }
@@ -33,7 +26,7 @@ - (nullable instancetype)initWithCoder:(NSCoder *)aDecoder
         [self ows_applyTheme];
     }
 
-    self.dataDetectorTypes = kOWSAllowedDataDetectorTypes;
+    self.dataDetectorTypes = UIDataDetectorTypeNone;
 
     return self;
 }
@@ -43,23 +36,6 @@ - (void)ows_applyTheme
     self.keyboardAppearance = Theme.keyboardAppearance;
 }
 
-// MARK: -
-
-- (void)ensureShouldLinkifyText:(BOOL)shouldLinkifyText
-{
-    if (shouldLinkifyText) {
-        // Setting dataDetectorTypes can be expensive, so we only update it when it's changed.
-        if (self.dataDetectorTypes != kOWSAllowedDataDetectorTypes) {
-            self.dataDetectorTypes = kOWSAllowedDataDetectorTypes;
-        }
-    } else {
-        // Setting dataDetectorTypes can be expensive, so we only update it when it's changed.
-        if (self.dataDetectorTypes != kOWSAllowedDataDetectorTypesExceptLinks) {
-            self.dataDetectorTypes = kOWSAllowedDataDetectorTypesExceptLinks;
-        }
-    }
-}
-
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift b/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift
index 3e5f08e8d67..472247c0333 100644
--- a/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift
+++ b/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift
@@ -292,7 +292,7 @@ public class OWSLinkPreviewManager: NSObject, Dependencies {
         let allMatches = detector.matches(
             in: searchString,
             options: [],
-            range: NSRange(searchString.startIndex..<searchString.endIndex, in: searchString))
+            range: searchString.entireRange)
 
         return allMatches.first(where: {
             guard let parsedUrl = $0.url else { return false }
