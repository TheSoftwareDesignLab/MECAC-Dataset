diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift
index 5dc47971fe5..907e2b16805 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift
@@ -396,10 +396,19 @@ extension ConversationViewController: MediaPresentationContextProvider {
             }
         }
 
+        // Avoid using `variableRoundedCorners` as much as possible because that doesn't work well
+        // with spring animations.
+        let mediaViewShape: MediaViewShape
+        if roundedCorners.isAllCornerRadiiEqual {
+            mediaViewShape = .rectangle(roundedCorners.topLeft)
+        } else {
+            mediaViewShape = .variableRoundedCorners(roundedCorners)
+        }
+
         return MediaPresentationContext(
             mediaView: mediaView,
             presentationFrame: presentationFrame,
-            roundedCorners: roundedCorners,
+            mediaViewShape: mediaViewShape,
             clippingAreaInsets: collectionView.adjustedContentInset
         )
     }
diff --git a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift
index e8c138a5562..c97f50d93ff 100644
--- a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift
+++ b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaDismissAnimationController.swift
@@ -162,7 +162,7 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
         imageView.contentMode = .scaleAspectFill
         imageView.autoresizingMask = [ .flexibleWidth, .flexibleHeight ]
         imageView.layer.masksToBounds = true
-        imageView.roundedCorners = fromMediaContext.roundedCorners
+        imageView.shape = fromMediaContext.mediaViewShape
         imageView.frame = transitionView.bounds
         transitionView.addSubview(imageView)
 
@@ -186,20 +186,20 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
 
         let completion: (CGVector?) -> Void = { velocity in
             let destinationFrame: CGRect
-            let destinationRoundedCorners: RoundedCorners
+            let destinationMediaViewShape: MediaViewShape
             if transitionContext.transitionWasCancelled {
                 destinationFrame = fromMediaContext.presentationFrame
-                destinationRoundedCorners = fromMediaContext.roundedCorners
+                destinationMediaViewShape = fromMediaContext.mediaViewShape
             } else if let toMediaContext {
                 destinationFrame = toMediaContext.presentationFrame
-                destinationRoundedCorners = toMediaContext.roundedCorners
+                destinationMediaViewShape = toMediaContext.mediaViewShape
             } else {
                 // `toMediaContext` can be nil if the target item is scrolled off of the
                 // contextProvider's screen, so we synthesize a context to dismiss the item
                 // off screen
                 let offscreenFrame = fromMediaContext.presentationFrame.offsetBy(dx: 0, dy: fromMediaContext.presentationFrame.height)
                 destinationFrame = offscreenFrame
-                destinationRoundedCorners = fromMediaContext.roundedCorners
+                destinationMediaViewShape = fromMediaContext.mediaViewShape
             }
 
             if let clippingAreaInsets = toMediaContext?.clippingAreaInsets, clippingAreaInsets.isNonEmpty {
@@ -211,7 +211,7 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
 
             let animator = UIViewPropertyAnimator(
                 duration: duration,
-                springDamping: 0.77,
+                springDamping: 1,
                 springResponse: 0.3,
                 initialVelocity: velocity ?? .zero
             )
@@ -222,7 +222,7 @@ extension MediaDismissAnimationController: UIViewControllerAnimatedTransitioning
                     dimmerView?.alpha = 0
                 }
 
-                imageView.roundedCorners = destinationRoundedCorners
+                imageView.shape = destinationMediaViewShape
                 transitionView.transform = .identity
                 transitionView.bounds.size = destinationFrame.size
                 transitionView.center = destinationFrame.center
diff --git a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaPresentationContext.swift b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaPresentationContext.swift
index f5531afdb6b..b500c9e08e7 100644
--- a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaPresentationContext.swift
+++ b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaPresentationContext.swift
@@ -28,28 +28,36 @@ struct RoundedCorners: Equatable {
     var bottomRight: CGFloat
     var bottomLeft: CGFloat
 
-    static var none: RoundedCorners { RoundedCorners.all(0) }
-
     static func all(_ radius: CGFloat) -> RoundedCorners {
         return RoundedCorners(topLeft: radius, topRight: radius, bottomRight: radius, bottomLeft: radius)
     }
+
+    var isAllCornerRadiiEqual: Bool {
+        topLeft == topRight && topLeft == bottomLeft && topLeft == bottomRight
+    }
+}
+
+enum MediaViewShape {
+    case circle
+    case rectangle(CGFloat)
+    case variableRoundedCorners(RoundedCorners)
 }
 
 struct MediaPresentationContext {
     let mediaView: UIView
     let presentationFrame: CGRect
-    let roundedCorners: RoundedCorners
+    let mediaViewShape: MediaViewShape
     let clippingAreaInsets: UIEdgeInsets?
 
     init(
         mediaView: UIView,
         presentationFrame: CGRect,
-        roundedCorners: RoundedCorners = .none,
+        mediaViewShape: MediaViewShape = .rectangle(0),
         clippingAreaInsets: UIEdgeInsets? = nil
     ) {
         self.mediaView = mediaView
         self.presentationFrame = presentationFrame
-        self.roundedCorners = roundedCorners
+        self.mediaViewShape = mediaViewShape
         self.clippingAreaInsets = clippingAreaInsets
     }
 }
diff --git a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaTransitionImageView.swift b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaTransitionImageView.swift
index 8830af1de8e..28fdc81aa32 100644
--- a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaTransitionImageView.swift
+++ b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaTransitionImageView.swift
@@ -3,64 +3,131 @@
 // SPDX-License-Identifier: AGPL-3.0-only
 //
 
+import SignalServiceKit
 import UIKit
 
 class MediaTransitionImageView: UIImageView {
 
-    var roundedCorners: RoundedCorners = .none
+    var shape: MediaViewShape = .rectangle(0) {
+        willSet {
+            guard layer.mask == nil, case .variableRoundedCorners(let roundedCorners) = newValue else { return }
 
-    override var bounds: CGRect {
-        get { super.bounds }
-        set {
-            super.bounds = newValue
+            // Only use masking layer if desired appearance cannot be achieved
+            // by modifying `CALayer.cornerRadius` and `CALayer.maskedCorners`,
+            // ie there is more than one corner radius being used.
+            // Prepare by setting up a masking layer that, once created, will be used exclusively.
+            if roundedCorners.groupedNonZeroCorners().keys.count > 1 {
+                let maskLayer = CAShapeLayer()
+                updateMaskLayer(maskLayer)
+                layer.mask = maskLayer
+            }
+        }
+        didSet {
+            // Layer needs to be updated on bounds/frame change if:
+            // * shape is circle - corner radius is a function of layer's size.
+            // * masking layer is being used.
+            switch shape {
+            case .circle: updateShapeOnBoundsChange = true
+            default: updateShapeOnBoundsChange = layer.mask != nil
+            }
 
-            let maskAnimation: CABasicAnimation?
-            if let animation = layer.animation(forKey: "bounds.size") as? CABasicAnimation {
-                maskAnimation = animation.copy() as? CABasicAnimation
-            } else {
-                maskAnimation = nil
+            if !updateShapeOnBoundsChange {
+                updateShape()
+            }
+        }
+    }
+    private var updateShapeOnBoundsChange = false
+
+    override var bounds: CGRect {
+        didSet {
+            if updateShapeOnBoundsChange {
+                updateShape()
             }
-            updateMask(using: maskAnimation)
         }
     }
 
     override var frame: CGRect {
-        get { super.frame }
-        set {
-            super.frame = newValue
+        didSet {
+            if updateShapeOnBoundsChange {
+                updateShape()
+            }
+        }
+    }
+
+    private func updateShape() {
+        // If there is a masking layer - use that to create shape.
+        // Masking layer would be created in `shape.willSet` for `variableRoundedCorners` case.
+        if let maskLayer = layer.mask as? CAShapeLayer {
+            layer.cornerRadius = 0
+            layer.maskedCorners = .all
 
+            // Unfortunately masking layer's path is not implicitly animatable.
+            // The workaround is to grab animation attached to view's layer,
+            // copy it and use for animating masking path.
             let maskAnimation: CABasicAnimation?
             if let animation = layer.animation(forKey: "bounds.size") as? CABasicAnimation {
                 maskAnimation = animation.copy() as? CABasicAnimation
             } else {
                 maskAnimation = nil
             }
-            updateMask(using: maskAnimation)
+            updateMaskLayer(maskLayer, using: maskAnimation)
+            return
         }
-    }
 
-    private func updateMask(using animation: CABasicAnimation?) {
-        let maskLayer: CAShapeLayer
-        if let existingMaskLayer = layer.mask as? CAShapeLayer {
-            maskLayer = existingMaskLayer
-        } else {
-            maskLayer = CAShapeLayer()
-            layer.mask = maskLayer
+        // No masking layer means simpler cases of corner rounding - use CALayer.cornerRadius.
+        // Note that we don't try and find an attached animation because `CALayer.cornerRadius`
+        // is an implicitly animatable property.
+        switch shape {
+        case .rectangle(let cornerRadius):
+            layer.cornerRadius = cornerRadius
+            if cornerRadius > 0 {
+                // CoreAnimation doesn't properly animate transition from some rounded
+                // corners to all rounded corners - change below would take affect immediately.
+                // Luckily for us media is always animated from some (or all) rounded corners
+                // to no rounded corners (and back) which means `maskedCorners` can stay whatever it was.
+                layer.maskedCorners = .all
+            }
+
+        case .circle:
+            layer.cornerRadius = 0.5 * min(layer.bounds.width, layer.bounds.height)
+            layer.maskedCorners = .all
+
+        case .variableRoundedCorners(let roundedCorners):
+            let roundedCornersGroupedByRadius = roundedCorners.groupedNonZeroCorners()
+            owsAssertBeta(roundedCornersGroupedByRadius.count == 1)
+            guard let cornerInfo = roundedCornersGroupedByRadius.first else { return }
+            layer.cornerRadius = cornerInfo.key
+            layer.maskedCorners = cornerInfo.value
         }
 
+    }
+
+    private func updateMaskLayer(_ maskLayer: CAShapeLayer, using animation: CABasicAnimation? = nil) {
         maskLayer.frame = layer.bounds
 
+        let roundedCorners: RoundedCorners = {
+            switch shape {
+            case .circle:
+                return .all(0.5 * min(maskLayer.bounds.width, maskLayer.bounds.height))
+
+            case .rectangle(let cornerRadius):
+                return .all(cornerRadius)
+
+            case .variableRoundedCorners(let roundedCorners):
+                return roundedCorners
+            }
+        }()
+
         // Note that path must be constructed using the same method even if there are no rounded corners,
         // otherwise animation would be incorrect.
-        let maskPath: UIBezierPath = {
-            return UIBezierPath.roundedRect(
-                maskLayer.bounds,
-                topLeftRounding: roundedCorners.topLeft,
-                topRightRounding: roundedCorners.topRight,
-                bottomRightRounding: roundedCorners.bottomRight,
-                bottomLeftRounding: roundedCorners.bottomLeft
-            )
-        }()
+        let maskPath = UIBezierPath.roundedRect(
+            maskLayer.bounds,
+            topLeftRounding: roundedCorners.topLeft,
+            topRightRounding: roundedCorners.topRight,
+            bottomRightRounding: roundedCorners.bottomRight,
+            bottomLeftRounding: roundedCorners.bottomLeft
+        )
+
         if let animation {
             animation.keyPath = "path"
             animation.fromValue = maskLayer.path
@@ -72,3 +139,24 @@ class MediaTransitionImageView: UIImageView {
         }
     }
 }
+
+private extension RoundedCorners {
+
+    func groupedNonZeroCorners() -> [CGFloat: CACornerMask] {
+        var result = [CGFloat: CACornerMask]()
+        let populateResult: (CGFloat, CACornerMask) -> Void = { cornerRadius, corner in
+            guard cornerRadius > 0 else { return }
+            if var cornerMask = result[cornerRadius] {
+                cornerMask.insert(corner)
+                result[cornerRadius] = cornerMask
+            } else {
+                result[cornerRadius] = [ corner ]
+            }
+        }
+        populateResult(topLeft, .layerMinXMinYCorner)
+        populateResult(topRight, .layerMaxXMinYCorner)
+        populateResult(bottomRight, .layerMaxXMaxYCorner)
+        populateResult(bottomLeft, .layerMinXMaxYCorner)
+        return result
+    }
+}
diff --git a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaZoomAnimationController.swift b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaZoomAnimationController.swift
index d5571ebe261..88e523ee909 100644
--- a/Signal/src/ViewControllers/MediaGallery/Transitions/MediaZoomAnimationController.swift
+++ b/Signal/src/ViewControllers/MediaGallery/Transitions/MediaZoomAnimationController.swift
@@ -117,7 +117,7 @@ extension MediaZoomAnimationController: UIViewControllerAnimatedTransitioning {
         let transitionView = MediaTransitionImageView(image: presentationImage)
         transitionView.contentMode = .scaleAspectFill
         transitionView.layer.masksToBounds = true
-        transitionView.roundedCorners = fromMediaContext.roundedCorners
+        transitionView.shape = fromMediaContext.mediaViewShape
         transitionView.frame = fromMediaContext.presentationFrame
         clippingView.addSubview(transitionView)
 
@@ -156,7 +156,7 @@ extension MediaZoomAnimationController: UIViewControllerAnimatedTransitioning {
             fromTransitionalOverlayView?.alpha = 0.0
             toView.alpha = 1.0
             toTransitionalOverlayView?.alpha = 1.0
-            transitionView.roundedCorners = toMediaContext.roundedCorners
+            transitionView.shape = toMediaContext.mediaViewShape
             transitionView.frame = toMediaContext.presentationFrame
 
             if let clippingAreaInsets = toMediaContext.clippingAreaInsets, clippingAreaInsets.isNonEmpty {
diff --git a/Signal/src/ViewControllers/MessageDetailViewController.swift b/Signal/src/ViewControllers/MessageDetailViewController.swift
index acee0bd92c6..65f08cd10a4 100644
--- a/Signal/src/ViewControllers/MessageDetailViewController.swift
+++ b/Signal/src/ViewControllers/MessageDetailViewController.swift
@@ -715,7 +715,7 @@ extension MessageDetailViewController: MediaPresentationContextProvider {
         return MediaPresentationContext(
             mediaView: mediaView,
             presentationFrame: presentationFrame,
-            roundedCorners: .all(CVComponentMessage.bubbleWideCornerRadius)
+            mediaViewShape: .rectangle(CVComponentMessage.bubbleWideCornerRadius)
         )
     }
 
diff --git a/Signal/src/ViewControllers/Photos/AvatarViewController.swift b/Signal/src/ViewControllers/Photos/AvatarViewController.swift
index 87474621776..ad4747561c6 100644
--- a/Signal/src/ViewControllers/Photos/AvatarViewController.swift
+++ b/Signal/src/ViewControllers/Photos/AvatarViewController.swift
@@ -159,7 +159,7 @@ extension AvatarViewController: MediaPresentationContextProvider {
         return MediaPresentationContext(
             mediaView: circleView,
             presentationFrame: circleView.frame,
-            roundedCorners: .all(circleView.layer.cornerRadius)
+            mediaViewShape: .circle
         )
     }
 
diff --git a/Signal/src/ViewControllers/ThreadSettings/ConversationSettingsViewController.swift b/Signal/src/ViewControllers/ThreadSettings/ConversationSettingsViewController.swift
index 86868c1e1ed..6159cd8c0e1 100644
--- a/Signal/src/ViewControllers/ThreadSettings/ConversationSettingsViewController.swift
+++ b/Signal/src/ViewControllers/ThreadSettings/ConversationSettingsViewController.swift
@@ -1078,19 +1078,19 @@ extension ConversationSettingsViewController: ReplaceAdminViewControllerDelegate
 extension ConversationSettingsViewController: MediaPresentationContextProvider {
     func mediaPresentationContext(item: Media, in coordinateSpace: UICoordinateSpace) -> MediaPresentationContext? {
         let mediaView: UIView
-        let cornerRadius: CGFloat
+        let mediaViewShape: MediaViewShape
         switch item {
         case .gallery(let galleryItem):
             guard let imageView = recentMedia[galleryItem.attachmentStream.uniqueId]?.imageView else { return nil }
             mediaView = imageView
-            cornerRadius = imageView.layer.cornerRadius
+            mediaViewShape = .rectangle(imageView.layer.cornerRadius)
         case .image:
             guard let avatarView = avatarView as? ConversationAvatarView else { return nil }
             mediaView = avatarView
             if case .circular = avatarView.configuration.shape {
-                cornerRadius = 0.5 * CGFloat(avatarView.configuration.sizeClass.diameter)
+                mediaViewShape = .circle
             } else {
-                cornerRadius = 0
+                mediaViewShape = .rectangle(0)
             }
         }
 
@@ -1105,7 +1105,7 @@ extension ConversationSettingsViewController: MediaPresentationContextProvider {
         return MediaPresentationContext(
             mediaView: mediaView,
             presentationFrame: presentationFrame,
-            roundedCorners: .all(cornerRadius),
+            mediaViewShape: mediaViewShape,
             clippingAreaInsets: clippingAreaInsets
         )
     }
diff --git a/Signal/src/ViewControllers/ThreadSettings/MemberActionSheet.swift b/Signal/src/ViewControllers/ThreadSettings/MemberActionSheet.swift
index bd09795e963..6978e98e34c 100644
--- a/Signal/src/ViewControllers/ThreadSettings/MemberActionSheet.swift
+++ b/Signal/src/ViewControllers/ThreadSettings/MemberActionSheet.swift
@@ -332,7 +332,7 @@ extension MemberActionSheet: CNContactViewControllerDelegate {
 extension MemberActionSheet: MediaPresentationContextProvider {
     func mediaPresentationContext(item: Media, in coordinateSpace: UICoordinateSpace) -> MediaPresentationContext? {
         let mediaView: UIView
-        let cornerRadius: CGFloat
+        let mediaViewShape: MediaViewShape
         switch item {
         case .gallery:
             owsFailDebug("Unexpected item")
@@ -341,9 +341,9 @@ extension MemberActionSheet: MediaPresentationContextProvider {
             guard let avatarView = avatarView as? ConversationAvatarView else { return nil }
             mediaView = avatarView
             if case .circular = avatarView.configuration.shape {
-                cornerRadius = 0.5 * CGFloat(avatarView.configuration.sizeClass.diameter)
+                mediaViewShape = .circle
             } else {
-                cornerRadius = 0
+                mediaViewShape = .rectangle(0)
             }
         }
 
@@ -357,7 +357,7 @@ extension MemberActionSheet: MediaPresentationContextProvider {
         return MediaPresentationContext(
             mediaView: mediaView,
             presentationFrame: presentationFrame,
-            roundedCorners: .all(cornerRadius)
+            mediaViewShape: mediaViewShape
         )
     }
 
