diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index cee4769005e..a6c47cc93bb 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -199,6 +199,7 @@
 		3488F9362191CC4000E524CC /* ConversationMediaView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3488F9352191CC4000E524CC /* ConversationMediaView.swift */; };
 		348A9C35234E462D00789068 /* ThreadFinderPerformanceTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 348A9C34234E462D00789068 /* ThreadFinderPerformanceTest.swift */; };
 		348BB25D20A0C5530047AEC2 /* ContactShareViewHelper.swift in Sources */ = {isa = PBXBuildFile; fileRef = 348BB25C20A0C5530047AEC2 /* ContactShareViewHelper.swift */; };
+		348C686D246B0B110039705A /* ThreadUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = 348C686C246B0B100039705A /* ThreadUtil.swift */; };
 		3491D9A121022DB7001EF5A1 /* RemoteAttestationSigningCertificateTest.m in Sources */ = {isa = PBXBuildFile; fileRef = 3491D9A021022DB7001EF5A1 /* RemoteAttestationSigningCertificateTest.m */; };
 		349439D624360C30001045F7 /* AddGroupMembersViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349439D524360C30001045F7 /* AddGroupMembersViewController.swift */; };
 		349439D824360D63001045F7 /* BaseGroupMemberViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349439D724360D63001045F7 /* BaseGroupMemberViewController.swift */; };
@@ -1080,6 +1081,7 @@
 		3488F9352191CC4000E524CC /* ConversationMediaView.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ConversationMediaView.swift; sourceTree = "<group>"; };
 		348A9C34234E462D00789068 /* ThreadFinderPerformanceTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ThreadFinderPerformanceTest.swift; sourceTree = "<group>"; };
 		348BB25C20A0C5530047AEC2 /* ContactShareViewHelper.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ContactShareViewHelper.swift; sourceTree = "<group>"; };
+		348C686C246B0B100039705A /* ThreadUtil.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ThreadUtil.swift; sourceTree = "<group>"; };
 		348F2EAD1F0D21BC00D4ECE0 /* DeviceSleepManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = DeviceSleepManager.swift; sourceTree = "<group>"; };
 		3491D9A021022DB7001EF5A1 /* RemoteAttestationSigningCertificateTest.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = RemoteAttestationSigningCertificateTest.m; sourceTree = "<group>"; };
 		349439D524360C30001045F7 /* AddGroupMembersViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AddGroupMembersViewController.swift; sourceTree = "<group>"; };
@@ -2072,6 +2074,7 @@
 				45360B8C1F9521F800FA666C /* Searcher.swift */,
 				346129BD1FD2068600532771 /* ThreadUtil.h */,
 				346129BE1FD2068600532771 /* ThreadUtil.m */,
+				348C686C246B0B100039705A /* ThreadUtil.swift */,
 				340872BE22393CF900CB25B0 /* UIGestureRecognizer+OWS.swift */,
 				4C858A51212DC5E1001B45D3 /* UIImage+OWS.swift */,
 				B97940251832BD2400BD66CB /* UIUtil.h */,
@@ -4328,6 +4331,7 @@
 				4CBBCA6321714B4500EEB37D /* OWS110SortIdMigration.swift in Sources */,
 				342950832124C9750000B063 /* OWSTextView.m in Sources */,
 				34BBC85D220D19D600857249 /* ImageEditorPanGestureRecognizer.swift in Sources */,
+				348C686D246B0B110039705A /* ThreadUtil.swift in Sources */,
 				342950882124CB0A0000B063 /* OWSSearchBar.m in Sources */,
 				342950822124C9750000B063 /* OWSTextField.m in Sources */,
 				34AC0A13211B39EA00997B47 /* DisappearingTimerConfigurationView.swift in Sources */,
diff --git a/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift b/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift
index 83d828c69ed..9890e8f4d22 100644
--- a/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift
+++ b/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift
@@ -539,8 +539,96 @@ class DebugUIGroupsV2: DebugUIPage {
     }
 
     private func sendInvalidGroupMessages(contactThread: TSContactThread) {
+        let otherUserAddress = contactThread.contactAddress
+        guard let otherUserUuid = otherUserAddress.uuid else {
+            owsFailDebug("Recipient is missing UUID.")
+            return
+        }
+
+        firstly { () -> Promise<TSGroupModelV2> in
+            // Make a real v2 group on the service.
+            // Local user and "other user" are members.
+            return firstly {
+                GroupManager.localCreateNewGroup(members: [otherUserAddress],
+                                                 name: "Real group, both users are in the group",
+                                                 shouldSendMessage: false)
+            }.map(on: .global()) { (groupThread: TSGroupThread) in
+                guard let validGroupModelV2 = groupThread.groupModel as? TSGroupModelV2 else {
+                    throw OWSAssertionError("Invalid groupModel.")
+                }
+                return validGroupModelV2
+            }
+        }.then(on: .global()) { (validGroupModelV2: TSGroupModelV2) -> Promise<(TSGroupModelV2, TSGroupModelV2)> in
+            // Make a real v2 group on the service.
+            // Local user is a member but "other user" is not.
+            return firstly {
+                GroupManager.localCreateNewGroup(members: [],
+                                                 name: "Real group, recipient is not in the group",
+                                                 shouldSendMessage: false)
+            }.map(on: .global()) { (groupThread: TSGroupThread) in
+                guard let missingOtherUserGroupModelV2 = groupThread.groupModel as? TSGroupModelV2 else {
+                    throw OWSAssertionError("Invalid groupModel.")
+                }
+                return (validGroupModelV2, missingOtherUserGroupModelV2)
+            }
+        }.then(on: .global()) { (validGroupModelV2: TSGroupModelV2,
+            missingOtherUserGroupModelV2: TSGroupModelV2)
+            -> Promise<(TSGroupModelV2, TSGroupModelV2, TSGroupModelV2)> in
+            // Make a real v2 group on the service.
+            // "Other user" is a member but local user is not.
+            return firstly { () -> Promise<TSGroupThread> in
+                GroupManager.localCreateNewGroup(members: [otherUserAddress],
+                                                 name: "Real group, sender is not in the group",
+                                                 shouldSendMessage: false)
+            }.then(on: .global()) { (groupThread: TSGroupThread) -> Promise<TSGroupThread> in
+                guard let groupModel = groupThread.groupModel as? TSGroupModelV2 else {
+                    throw OWSAssertionError("Invalid groupModel.")
+                }
+                guard groupModel.groupMembership.isNonPendingMember(otherUserAddress) else {
+                    throw OWSAssertionError("Other user is not a full member.")
+                }
+                // Last admin (local user) can't leave group, so first
+                // make the "other user" an admin.
+                return GroupManager.changeMemberRoleV2(groupModel: groupModel,
+                                                       uuid: otherUserUuid,
+                                                       role: .administrator)
+            }.then(on: .global()) { (groupThread: TSGroupThread) -> Promise<TSGroupThread> in
+                GroupManager.localLeaveGroupOrDeclineInvite(groupThread: groupThread)
+            }.map(on: .global()) { (groupThread: TSGroupThread) in
+                guard let missingLocalUserGroupModelV2 = groupThread.groupModel as? TSGroupModelV2 else {
+                    throw OWSAssertionError("Invalid groupModel.")
+                }
+                return (validGroupModelV2, missingOtherUserGroupModelV2, missingLocalUserGroupModelV2)
+            }
+        }.map(on: .global()) { (validGroupModelV2: TSGroupModelV2,
+            missingOtherUserGroupModelV2: TSGroupModelV2,
+            missingLocalUserGroupModelV2: TSGroupModelV2) in
+            self.sendInvalidGroupMessages(contactThread: contactThread,
+                                          validGroupModelV2: validGroupModelV2,
+                                          missingOtherUserGroupModelV2: missingOtherUserGroupModelV2,
+                                          missingLocalUserGroupModelV2: missingLocalUserGroupModelV2)
+        }.done(on: .global()) { _ in
+            Logger.info("Complete.")
+        }.catch(on: .global()) { error in
+            owsFailDebug("Error: \(error)")
+        }.retainUntilComplete()
+    }
+
+    private func sendInvalidGroupMessages(contactThread: TSContactThread,
+                                          validGroupModelV2: TSGroupModelV2,
+                                          missingOtherUserGroupModelV2: TSGroupModelV2,
+                                          missingLocalUserGroupModelV2: TSGroupModelV2) {
         var messages = [TSOutgoingMessage]()
 
+        let groupContextInfoForGroupModel = { (groupModelV2: TSGroupModelV2) -> GroupV2ContextInfo in
+            let masterKey = try! GroupsV2Protos.masterKeyData(forGroupModel: groupModelV2)
+            return try! self.groupsV2.groupV2ContextInfo(forMasterKeyData: masterKey)
+        }
+
+        let validGroupContextInfo = groupContextInfoForGroupModel(validGroupModelV2)
+        let missingOtherUserGroupContextInfo = groupContextInfoForGroupModel(missingOtherUserGroupModelV2)
+        let missingLocalUserGroupContextInfo = groupContextInfoForGroupModel(missingLocalUserGroupModelV2)
+
         let buildValidGroupContextInfo = { () -> GroupV2ContextInfo in
             let groupsV2 = self.groupsV2
             let groupSecretParamsData = try! groupsV2.generateGroupSecretParamsData()
@@ -548,105 +636,177 @@ class DebugUIGroupsV2: DebugUIPage {
             return try! groupsV2.groupV2ContextInfo(forMasterKeyData: masterKeyData)
         }
 
-        do {
-            messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
-                // Valid-looking group id/master key/secret params, but doesn't
-                // correspond to an actual group on the service.
-                let groupV2ContextInfo: GroupV2ContextInfo = buildValidGroupContextInfo()
-                let revision: UInt32 = 0
-
-                let builder = SSKProtoGroupContextV2.builder()
-                builder.setMasterKey(groupV2ContextInfo.masterKeyData)
-                builder.setRevision(revision)
-
-//                if let changeActionsProtoData = changeActionsProtoData {
-//                    assert(changeActionsProtoData.count > 0)
-//                    builder.setGroupChange(changeActionsProtoData)
-//                }
-
-                let dataBuilder = SSKProtoDataMessage.builder()
-                dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
-                dataBuilder.setRequiredProtocolVersion(0)
-                return try! dataBuilder.buildSerializedData()
-            })
-
-//                }
-//            - (OutgoingGroupProtoResult)addGroupsV2ToDataMessageBuilder:(SSKProtoDataMessageBuilder *)builder
-//            groupThread:(TSGroupThread *)groupThread
-//            transaction:(SDSAnyReadTransaction *)transaction
-//            {
-//                OWSAssertDebug(builder);
-//                OWSAssertDebug(groupThread);
-//                OWSAssertDebug(transaction);
-//
-//                if (![groupThread.groupModel isKindOfClass:[TSGroupModelV2 class]]) {
-//                    OWSFailDebug(@"Invalid group model.");
-//                    return OutgoingGroupProtoResult_Error;
-//                }
-//                TSGroupModelV2 *groupModel = (TSGroupModelV2 *)groupThread.groupModel;
-//
-//                NSError *error;
-//                SSKProtoGroupContextV2 *_Nullable groupContextV2 =
-//                    [self.groupsV2 buildGroupContextV2ProtoWithGroupModel:groupModel
-//                        changeActionsProtoData:self.changeActionsProtoData
-//                        error:&error];
-//                if (groupContextV2 == nil || error != nil) {
-//                    OWSFailDebug(@"Error: %@", error);
-//                    return OutgoingGroupProtoResult_Error;
-//                }
-//                [builder setGroupV2:groupContextV2];
-//                return OutgoingGroupProtoResult_AddedWithoutGroupAvatar;
-//
-
-        }
-
-//        guard let localAddress = tsAccountManager.localAddress else {
-//            return owsFailDebug("Missing localAddress.")
-//        }
-//        
-//        let oldGroupModel = groupThread.groupModel
-//        
-//        let oldGroupMembership = oldGroupModel.groupMembership
-//        var groupMembershipBuilder = oldGroupMembership.asBuilder
-//        for address in oldGroupMembership.allUsers {
-//            if address != localAddress {
-//                groupMembershipBuilder.remove(address)
-//            }
-//        }
-//        let newGroupMembership = groupMembershipBuilder.build()
-//        firstly { () -> Promise<TSGroupThread> in
-//            var groupModelBuilder = oldGroupModel.asBuilder
-//            groupModelBuilder.groupMembership = newGroupMembership
-//            let newGroupModel = try databaseStorage.read { transaction in
-//                try groupModelBuilder.buildAsV2(transaction: transaction)
-//            }
-//            return GroupManager.localUpdateExistingGroup(groupModel: newGroupModel,
-//                                                         dmConfiguration: nil,
-//                                                         groupUpdateSourceAddress: localAddress)
-//        }.done { (_) -> Void in
-//            Logger.info("Success.")
-//        }.catch { error in
-//            owsFailDebug("Error: \(error)")
-//        }.retainUntilComplete()
-
-//        [self.messageSenderJobQueue
-//        messageSenderJobQueue.addMessage(
-
-//        NSUInteger contentLength = arc4random_uniform(32);
-//        return [Cryptography generateRandomBytes:contentLength];
-//        SSKProtoContentBuilder *contentBuilder =
-//            [SSKProtoContent builder];
-//        return [[contentBuilder buildIgnoringErrors]
-//            serializedDataIgnoringErrors];
-//
-//        let message = [[OWSDynamicOutgoingMessage alloc] initWithPlainTextDataBlock:block
-//            thread:thread];
-//
-//        [self sendStressMessage:message];
-        databaseStorage.write { transaction in
-            for message in messages {
-                self.messageSenderJobQueue.add(message: message.asPreparer, transaction: transaction)
-            }
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            // Other user is not in the group.
+            let masterKeyData = missingOtherUserGroupContextInfo.masterKeyData
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            // Local user is not in the group.
+            let masterKeyData = missingLocalUserGroupContextInfo.masterKeyData
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            let masterKeyData = validGroupContextInfo.masterKeyData
+            // Non-existent revision.
+            let revision: UInt32 = 99
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            var masterKeyData = validGroupContextInfo.masterKeyData
+            // Truncate the master key.
+            masterKeyData = masterKeyData.subdata(in: Int(0)..<Int(1))
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            var masterKeyData = validGroupContextInfo.masterKeyData
+            // Append garbage to the master key.
+            masterKeyData = masterKeyData + Randomness.generateRandomBytes(1)
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            var masterKeyData = validGroupContextInfo.masterKeyData
+            // Replace master key with zeroes.
+            masterKeyData = Data(repeating: 0, count: masterKeyData.count)
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            let masterKeyData = validGroupContextInfo.masterKeyData
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            // Don't set revision.
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            // Don't set master key.
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Valid-looking group id/master key/secret params, but doesn't
+            // correspond to an actual group on the service.
+            let groupV2ContextInfo: GroupV2ContextInfo = buildValidGroupContextInfo()
+            let masterKeyData = groupV2ContextInfo.masterKeyData
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        messages.append(OWSDynamicOutgoingMessage(thread: contactThread) { (_: SignalRecipient) -> Data in
+            // Real and valid group id/master key/secret params.
+            let masterKeyData = validGroupContextInfo.masterKeyData
+            // Real revision.
+            let revision: UInt32 = 0
+
+            let builder = SSKProtoGroupContextV2.builder()
+            builder.setMasterKey(masterKeyData)
+            builder.setRevision(revision)
+
+            // Invalid embedded change actions proto data.
+            let changeActionsProtoData = Randomness.generateRandomBytes(256)
+            builder.setGroupChange(changeActionsProtoData)
+
+            let dataBuilder = SSKProtoDataMessage.builder()
+            dataBuilder.setTimestamp(NSDate.ows_millisecondTimeStamp())
+            dataBuilder.setRequiredProtocolVersion(0)
+            return try! dataBuilder.buildSerializedData()
+        })
+
+        for message in messages {
+            ThreadUtil.sendMessageNonDurably(message: message)
         }
     }
 }
diff --git a/SignalMessaging/ViewControllers/SharingThreadPickerViewController.m b/SignalMessaging/ViewControllers/SharingThreadPickerViewController.m
index 53acece6b10..df7dbe98cb6 100644
--- a/SignalMessaging/ViewControllers/SharingThreadPickerViewController.m
+++ b/SignalMessaging/ViewControllers/SharingThreadPickerViewController.m
@@ -381,7 +381,6 @@ - (void)approveContactShare:(ContactShareApprovalViewController *)approvalViewCo
                 __block TSOutgoingMessage *outgoingMessage = nil;
                 outgoingMessage = [ThreadUtil sendMessageNonDurablyWithContactShare:contactShare.dbRecord
                                                                              thread:self.thread
-                                                                      messageSender:self.messageSender
                                                                          completion:^(NSError *_Nullable error) {
                                                                              sendCompletion(error, outgoingMessage);
                                                                          }];
diff --git a/SignalMessaging/utils/ThreadUtil.h b/SignalMessaging/utils/ThreadUtil.h
index d55d16370d2..71ef7ac5f69 100644
--- a/SignalMessaging/utils/ThreadUtil.h
+++ b/SignalMessaging/utils/ThreadUtil.h
@@ -47,9 +47,8 @@ NS_ASSUME_NONNULL_BEGIN
                                                 transaction:(SDSAnyWriteTransaction *)transaction
                                                       error:(NSError **)error;
 
-+ (TSOutgoingMessage *)enqueueMessageWithContactShare:(OWSContact *)contactShare thread:(TSThread *)thread;
-
 + (TSOutgoingMessage *)enqueueMessageWithInstalledSticker:(StickerInfo *)stickerInfo thread:(TSThread *)thread;
+
 + (TSOutgoingMessage *)enqueueMessageWithUninstalledSticker:(StickerInfo *)stickerInfo
                                                 stickerData:(NSData *)stickerData
                                                      thread:(TSThread *)thread;
@@ -73,12 +72,6 @@ NS_ASSUME_NONNULL_BEGIN
                                        messageSender:(OWSMessageSender *)messageSender
                                           completion:(void (^)(NSError *_Nullable error))completion;
 
-// Used by SAE, otherwise we should use the durable `enqueue` counterpart
-+ (TSOutgoingMessage *)sendMessageNonDurablyWithContactShare:(OWSContact *)contactShare
-                                                      thread:(TSThread *)thread
-                                               messageSender:(OWSMessageSender *)messageSender
-                                                  completion:(void (^)(NSError *_Nullable error))completion;
-
 #pragma mark - Profile Whitelist
 
 // This method should be called right _before_ we send a message to a thread,
diff --git a/SignalMessaging/utils/ThreadUtil.m b/SignalMessaging/utils/ThreadUtil.m
index 3c447707889..c053bee15e5 100644
--- a/SignalMessaging/utils/ThreadUtil.m
+++ b/SignalMessaging/utils/ThreadUtil.m
@@ -120,33 +120,6 @@ + (nullable TSOutgoingMessage *)createUnsentMessageWithText:(nullable NSString *
     return [outgoingMessagePreparer prepareMessageWithTransaction:transaction error:error];
 }
 
-+ (TSOutgoingMessage *)enqueueMessageWithContactShare:(OWSContact *)contactShare thread:(TSThread *)thread
-{
-    OWSAssertIsOnMainThread();
-    OWSAssertDebug(contactShare);
-    OWSAssertDebug(contactShare.ows_isValid);
-    OWSAssertDebug(thread);
-
-    __block OWSDisappearingMessagesConfiguration *configuration;
-    [self.databaseStorage readWithBlock:^(SDSAnyReadTransaction *transaction) {
-        configuration = [thread disappearingMessagesConfigurationWithTransaction:transaction];
-    }];
-
-    uint32_t expiresInSeconds = (configuration.isEnabled ? configuration.durationSeconds : 0);
-
-    TSOutgoingMessageBuilder *builder = [TSOutgoingMessageBuilder outgoingMessageBuilderWithThread:thread];
-    builder.expiresInSeconds = expiresInSeconds;
-    builder.contactShare = contactShare;
-    TSOutgoingMessage *message = [builder build];
-
-    [self.databaseStorage asyncWriteWithBlock:^(SDSAnyWriteTransaction *transaction) {
-        [message anyInsertWithTransaction:transaction];
-        [self.messageSenderJobQueue addMessage:message.asPreparer transaction:transaction];
-    }];
-
-    return message;
-}
-
 + (TSOutgoingMessage *)enqueueMessageWithInstalledSticker:(StickerInfo *)stickerInfo thread:(TSThread *)thread
 {
     OWSAssertIsOnMainThread();
@@ -294,46 +267,6 @@ + (TSOutgoingMessage *)sendMessageNonDurablyWithText:(NSString *)fullMessageText
     return outgoingMessagePreparer.unpreparedMessage;
 }
 
-+ (TSOutgoingMessage *)sendMessageNonDurablyWithContactShare:(OWSContact *)contactShare
-                                                      thread:(TSThread *)thread
-                                               messageSender:(OWSMessageSender *)messageSender
-                                                  completion:(void (^)(NSError *_Nullable error))completion
-{
-    OWSAssertIsOnMainThread();
-    OWSAssertDebug(contactShare);
-    OWSAssertDebug(contactShare.ows_isValid);
-    OWSAssertDebug(thread);
-    OWSAssertDebug(messageSender);
-    OWSAssertDebug(completion);
-
-    __block TSOutgoingMessage *message;
-    [self.databaseStorage writeWithBlock:^(SDSAnyWriteTransaction *transaction) {
-        OWSDisappearingMessagesConfiguration *configuration = [thread disappearingMessagesConfigurationWithTransaction:transaction];
-        uint32_t expiresInSeconds = (configuration.isEnabled ? configuration.durationSeconds : 0);
-        TSOutgoingMessageBuilder *builder = [TSOutgoingMessageBuilder outgoingMessageBuilderWithThread:thread];
-        builder.expiresInSeconds = expiresInSeconds;
-        builder.contactShare = contactShare;
-        message = [builder build];
-        [message anyInsertWithTransaction:transaction];
-    }];
-
-    [messageSender sendMessage:message.asPreparer
-        success:^{
-            OWSLogDebug(@"Successfully sent contact share.");
-            dispatch_async(dispatch_get_main_queue(), ^(void) {
-                completion(nil);
-            });
-        }
-        failure:^(NSError *error) {
-            OWSLogError(@"Failed to send contact share with error: %@", error);
-            dispatch_async(dispatch_get_main_queue(), ^(void) {
-                completion(error);
-            });
-        }];
-
-    return message;
-}
-
 + (nullable MessageSticker *)messageStickerForStickerDraft:(MessageStickerDraft *)stickerDraft
                                                transaction:(SDSAnyWriteTransaction *)transaction
 {
diff --git a/SignalMessaging/utils/ThreadUtil.swift b/SignalMessaging/utils/ThreadUtil.swift
new file mode 100644
index 00000000000..b16cff89209
--- /dev/null
+++ b/SignalMessaging/utils/ThreadUtil.swift
@@ -0,0 +1,123 @@
+//
+//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+@objc
+public extension ThreadUtil {
+
+    private class var messageSender: MessageSender {
+        return SSKEnvironment.shared.messageSender
+    }
+
+    // MARK: - Dependencies
+
+    private class var databaseStorage: SDSDatabaseStorage {
+        return SDSDatabaseStorage.shared
+    }
+
+    private class var messageSenderJobQueue: MessageSenderJobQueue {
+        return SSKEnvironment.shared.messageSenderJobQueue
+    }
+
+    // MARK: -
+
+    @discardableResult
+    class func enqueueMessage(withContactShare contactShare: OWSContact,
+                              thread: TSThread) -> TSOutgoingMessage {
+        AssertIsOnMainThread()
+        assert(contactShare.ows_isValid())
+
+        let builder = TSOutgoingMessageBuilder(thread: thread)
+        builder.contactShare = contactShare
+
+        return enqueueMessage(outgoingMessageBuilder: builder, thread: thread)
+    }
+
+    @discardableResult
+    class func enqueueMessage(outgoingMessageBuilder builder: TSOutgoingMessageBuilder,
+                              thread: TSThread) -> TSOutgoingMessage {
+
+        // PAYMENTS TODO: Is there any reason for this to be main-thread only?
+
+        let dmConfiguration = databaseStorage.read { transaction in
+            return thread.disappearingMessagesConfiguration(with: transaction)
+        }
+        builder.expiresInSeconds = dmConfiguration.isEnabled ? dmConfiguration.durationSeconds : 0
+
+        let message = builder.build()
+
+        databaseStorage.asyncWrite { transaction in
+            message.anyInsert(transaction: transaction)
+            self.messageSenderJobQueue.add(message: message.asPreparer, transaction: transaction)
+        }
+
+        return message
+    }
+
+    @discardableResult
+    class func enqueueMessage(outgoingMessageBuilder builder: TSOutgoingMessageBuilder,
+                              thread: TSThread,
+                              transaction: SDSAnyWriteTransaction) -> TSOutgoingMessage {
+
+        // PAYMENTS TODO: Is there any reason for this to be main-thread only?
+
+        let dmConfiguration = thread.disappearingMessagesConfiguration(with: transaction)
+        builder.expiresInSeconds = dmConfiguration.isEnabled ? dmConfiguration.durationSeconds : 0
+
+        let message = builder.build()
+        message.anyInsert(transaction: transaction)
+        self.messageSenderJobQueue.add(message: message.asPreparer, transaction: transaction)
+
+        return message
+    }
+
+    // MARK: -
+
+    class func sendMessageNonDurably(message: TSOutgoingMessage) {
+        messageSender.sendMessage(message.asPreparer,
+                                  success: {
+                                    Logger.info("Successfully sent message.")
+        },
+                                  failure: { error in
+                                    owsFailDebug("Failed to send message with error: \(error)")
+        })
+    }
+
+    // Used by SAE, otherwise we should use the durable `enqueue` counterpart
+    @discardableResult
+    class func sendMessageNonDurably(contactShare: OWSContact,
+                                     thread: TSThread,
+                                     completion: @escaping (Error?) -> Void) -> TSOutgoingMessage {
+        assert(contactShare.ows_isValid())
+
+        let message: TSOutgoingMessage = databaseStorage.write { transaction in
+            let dmConfiguration = thread.disappearingMessagesConfiguration(with: transaction)
+            let expiresInSeconds = dmConfiguration.isEnabled ? dmConfiguration.durationSeconds : 0
+
+            let builder = TSOutgoingMessageBuilder(thread: thread)
+            builder.expiresInSeconds = expiresInSeconds
+            builder.contactShare = contactShare
+            let message = builder.build()
+            message.anyInsert(transaction: transaction)
+            return message
+        }
+
+        messageSender.sendMessage(message.asPreparer,
+                                  success: {
+                                    Logger.debug("Successfully sent contact share.")
+                                    DispatchQueue.main.async {
+                                        completion(nil)
+                                    }
+        },
+                                  failure: { error in
+                                    Logger.error("Failed to send contact share with error: \(error)")
+                                    DispatchQueue.main.async {
+                                        completion(error)
+                                    }
+        })
+
+        return message
+    }
+}
