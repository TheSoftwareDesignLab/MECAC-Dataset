diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 0b08ac50816..95c8c5dcc82 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -3037,7 +3037,6 @@
 		E1B32F842CA6162A002141F4 /* LinkPreviewCallLink.swift in Sources */ = {isa = PBXBuildFile; fileRef = E1CFAAA22C9DD2B1003145C3 /* LinkPreviewCallLink.swift */; };
 		E1B628DA2CCC59E600C4DC7F /* chat_item_view_once_11.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628D22CCC59E600C4DC7F /* chat_item_view_once_11.binproto */; };
 		E1B628DB2CCC59E600C4DC7F /* chat_item_view_once_01.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628BE2CCC59E600C4DC7F /* chat_item_view_once_01.binproto */; };
-		E1B628DC2CCC59E600C4DC7F /* chat_item_view_once_14.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628D82CCC59E600C4DC7F /* chat_item_view_once_14.binproto */; };
 		E1B628DD2CCC59E600C4DC7F /* chat_item_view_once_02.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628C12CCC59E600C4DC7F /* chat_item_view_once_02.txtproto */; };
 		E1B628DE2CCC59E600C4DC7F /* chat_item_view_once_07.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628CB2CCC59E600C4DC7F /* chat_item_view_once_07.txtproto */; };
 		E1B628DF2CCC59E600C4DC7F /* chat_item_view_once_07.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628CA2CCC59E600C4DC7F /* chat_item_view_once_07.binproto */; };
@@ -3054,7 +3053,6 @@
 		E1B628EA2CCC59E600C4DC7F /* chat_item_view_once_12.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628D42CCC59E600C4DC7F /* chat_item_view_once_12.binproto */; };
 		E1B628EB2CCC59E600C4DC7F /* chat_item_view_once_04.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628C42CCC59E600C4DC7F /* chat_item_view_once_04.binproto */; };
 		E1B628EC2CCC59E600C4DC7F /* chat_item_view_once_05.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628C72CCC59E600C4DC7F /* chat_item_view_once_05.txtproto */; };
-		E1B628ED2CCC59E600C4DC7F /* chat_item_view_once_13.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628D62CCC59E600C4DC7F /* chat_item_view_once_13.binproto */; };
 		E1B628EE2CCC59E600C4DC7F /* chat_item_view_once_09.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628CF2CCC59E600C4DC7F /* chat_item_view_once_09.txtproto */; };
 		E1B628EF2CCC59E600C4DC7F /* chat_item_view_once_03.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628C22CCC59E600C4DC7F /* chat_item_view_once_03.binproto */; };
 		E1B628F02CCC59E600C4DC7F /* chat_item_view_once_08.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628CD2CCC59E600C4DC7F /* chat_item_view_once_08.txtproto */; };
@@ -3062,9 +3060,7 @@
 		E1B628F22CCC59E600C4DC7F /* chat_item_view_once_04.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628C52CCC59E600C4DC7F /* chat_item_view_once_04.txtproto */; };
 		E1B628F32CCC59E600C4DC7F /* chat_item_view_once_03.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628C32CCC59E600C4DC7F /* chat_item_view_once_03.txtproto */; };
 		E1B628F42CCC59E600C4DC7F /* chat_item_view_once_08.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628CC2CCC59E600C4DC7F /* chat_item_view_once_08.binproto */; };
-		E1B628F52CCC59E600C4DC7F /* chat_item_view_once_13.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628D72CCC59E600C4DC7F /* chat_item_view_once_13.txtproto */; };
 		E1B628F62CCC59E600C4DC7F /* chat_item_view_once_09.binproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628CE2CCC59E600C4DC7F /* chat_item_view_once_09.binproto */; };
-		E1B628F72CCC59E600C4DC7F /* chat_item_view_once_14.txtproto in Resources */ = {isa = PBXBuildFile; fileRef = E1B628D92CCC59E600C4DC7F /* chat_item_view_once_14.txtproto */; };
 		E1C2A54B2A8FCB0D00AEC4DA /* DeleteSystemContactViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E1C2A54A2A8FCB0D00AEC4DA /* DeleteSystemContactViewController.swift */; };
 		E1D827DA2BDC1F7B0022C1AF /* ReactionBurstManagerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = E1D827D82BDC1F6B0022C1AF /* ReactionBurstManagerTests.swift */; };
 		E44AD4E624E98F440035D7B8 /* PhotoCaptureDismiss.swift in Sources */ = {isa = PBXBuildFile; fileRef = E44AD4E524E98F430035D7B8 /* PhotoCaptureDismiss.swift */; };
@@ -7027,10 +7023,6 @@
 		E1B628D32CCC59E600C4DC7F /* chat_item_view_once_11.txtproto */ = {isa = PBXFileReference; lastKnownFileType = text; path = chat_item_view_once_11.txtproto; sourceTree = "<group>"; };
 		E1B628D42CCC59E600C4DC7F /* chat_item_view_once_12.binproto */ = {isa = PBXFileReference; lastKnownFileType = file; path = chat_item_view_once_12.binproto; sourceTree = "<group>"; };
 		E1B628D52CCC59E600C4DC7F /* chat_item_view_once_12.txtproto */ = {isa = PBXFileReference; lastKnownFileType = text; path = chat_item_view_once_12.txtproto; sourceTree = "<group>"; };
-		E1B628D62CCC59E600C4DC7F /* chat_item_view_once_13.binproto */ = {isa = PBXFileReference; lastKnownFileType = file; path = chat_item_view_once_13.binproto; sourceTree = "<group>"; };
-		E1B628D72CCC59E600C4DC7F /* chat_item_view_once_13.txtproto */ = {isa = PBXFileReference; lastKnownFileType = text; path = chat_item_view_once_13.txtproto; sourceTree = "<group>"; };
-		E1B628D82CCC59E600C4DC7F /* chat_item_view_once_14.binproto */ = {isa = PBXFileReference; lastKnownFileType = file; path = chat_item_view_once_14.binproto; sourceTree = "<group>"; };
-		E1B628D92CCC59E600C4DC7F /* chat_item_view_once_14.txtproto */ = {isa = PBXFileReference; lastKnownFileType = text; path = chat_item_view_once_14.txtproto; sourceTree = "<group>"; };
 		E1C2A54A2A8FCB0D00AEC4DA /* DeleteSystemContactViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DeleteSystemContactViewController.swift; sourceTree = "<group>"; };
 		E1CFAAA22C9DD2B1003145C3 /* LinkPreviewCallLink.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LinkPreviewCallLink.swift; sourceTree = "<group>"; };
 		E1D827D82BDC1F6B0022C1AF /* ReactionBurstManagerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ReactionBurstManagerTests.swift; sourceTree = "<group>"; };
@@ -12180,10 +12172,6 @@
 				E1B628D32CCC59E600C4DC7F /* chat_item_view_once_11.txtproto */,
 				E1B628D42CCC59E600C4DC7F /* chat_item_view_once_12.binproto */,
 				E1B628D52CCC59E600C4DC7F /* chat_item_view_once_12.txtproto */,
-				E1B628D62CCC59E600C4DC7F /* chat_item_view_once_13.binproto */,
-				E1B628D72CCC59E600C4DC7F /* chat_item_view_once_13.txtproto */,
-				E1B628D82CCC59E600C4DC7F /* chat_item_view_once_14.binproto */,
-				E1B628D92CCC59E600C4DC7F /* chat_item_view_once_14.txtproto */,
 				E1650B9A2CD0507100304C58 /* recipient_call_link_00.binproto */,
 				E1650B9B2CD0507100304C58 /* recipient_call_link_00.txtproto */,
 				E1650B9C2CD0507100304C58 /* recipient_call_link_01.binproto */,
@@ -15994,10 +15982,6 @@
 				E1B628E92CCC59E600C4DC7F /* chat_item_view_once_11.txtproto in Resources */,
 				E1B628EA2CCC59E600C4DC7F /* chat_item_view_once_12.binproto in Resources */,
 				E1B628E52CCC59E600C4DC7F /* chat_item_view_once_12.txtproto in Resources */,
-				E1B628ED2CCC59E600C4DC7F /* chat_item_view_once_13.binproto in Resources */,
-				E1B628F52CCC59E600C4DC7F /* chat_item_view_once_13.txtproto in Resources */,
-				E1B628DC2CCC59E600C4DC7F /* chat_item_view_once_14.binproto in Resources */,
-				E1B628F72CCC59E600C4DC7F /* chat_item_view_once_14.txtproto in Resources */,
 				E1650BA12CD0507100304C58 /* recipient_call_link_00.binproto in Resources */,
 				E1650BA22CD0507100304C58 /* recipient_call_link_00.txtproto in Resources */,
 				E1650BA52CD0507100304C58 /* recipient_call_link_01.binproto in Resources */,
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/BackupArchive+Errors.swift b/SignalServiceKit/Backups/Archiving/Archivers/BackupArchive+Errors.swift
index ae513d1c5e8..adf0261a238 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/BackupArchive+Errors.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/BackupArchive+Errors.swift
@@ -479,6 +479,8 @@ extension BackupArchive {
             case blockedRecipientFetchError(RawError)
             case blockedGroupFetchError(RawError)
 
+            case oversizedTextCacheFetchError(RawError)
+
             /// These should never happen; it means some invariant in the backup code
             /// we could not enforce with the type system was broken. Nothing was wrong with
             /// the proto or local database; its the iOS backup code that has a bug somewhere.
@@ -604,6 +606,13 @@ extension BackupArchive {
                 /// A ``BackupProto_DirectStoryReplyMessage`` was in a group thread.
                 case directStoryReplyInGroupThread
 
+                /// A ``BackupProto_StandardMessage/text`` had inlined oversize text that
+                /// was too long (even for oversized text there is a limit).
+                case standardMessageWayTooOversizedBody
+                /// A ``BackupProto_StandardMessage/longText`` was present despite an inlined
+                /// oversize message body (longer than standard message body length). Long text
+                /// pointers should only be included if the attachment is undownloaded and unavailable for inlining.
+                case longTextStandardMessageWithOversizeBody
                 /// A ``BackupProto_StandardMessage/longText`` was present despite an empty
                 /// message body (the body text must always be a prefix of the long text)
                 case longTextStandardMessageMissingBody
@@ -611,6 +620,9 @@ extension BackupArchive {
                 /// A quoted message had no body, attachment, gift badge, or other
                 /// content in its representation of the original being quoted.
                 case quotedMessageEmptyContent
+                /// The text body in a quoted message was too long (as enforced by standard message sending).
+                /// Oversized text in quotes is unsupported on all platforms.
+                case quotedMessageOversizeText
 
                 /// A link preview with an empty string for the url
                 case linkPreviewEmptyUrl
@@ -847,8 +859,11 @@ extension BackupArchive {
                         .directStoryReplyMessageEmptyWithLongText,
                         .directStoryReplyFromNonAci,
                         .directStoryReplyInGroupThread,
+                        .standardMessageWayTooOversizedBody,
+                        .longTextStandardMessageWithOversizeBody,
                         .longTextStandardMessageMissingBody,
                         .quotedMessageEmptyContent,
+                        .quotedMessageOversizeText,
                         .linkPreviewEmptyUrl,
                         .linkPreviewUrlNotInBody,
                         .contactMessageMissingContactAttachment,
@@ -948,7 +963,10 @@ extension BackupArchive {
                         .directStoryReplyMessageEmptyWithLongText,
                         .directStoryReplyFromNonAci,
                         .directStoryReplyInGroupThread,
+                        .standardMessageWayTooOversizedBody,
+                        .longTextStandardMessageWithOversizeBody,
                         .longTextStandardMessageMissingBody,
+                        .quotedMessageOversizeText,
                         .linkPreviewEmptyUrl,
                         .contactMessageMissingContactAttachment,
                         .contactAttachmentPhoneNumberMissingValue,
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchive+ChatItemContexts.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchive+ChatItemContexts.swift
index 8319c88f1eb..c6b57055baf 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchive+ChatItemContexts.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchive+ChatItemContexts.swift
@@ -10,6 +10,8 @@ extension BackupArchive {
         let chatContext: ChatRestoringContext
         let recipientContext: RecipientRestoringContext
 
+        public var uploadEra: String? { chatContext.customChatColorContext.accountDataContext.uploadEra }
+
         init(
             chatContext: ChatRestoringContext,
             recipientContext: RecipientRestoringContext,
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveChatItemArchiver.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveChatItemArchiver.swift
index 79f2d45a811..aa12eb73792 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveChatItemArchiver.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveChatItemArchiver.swift
@@ -36,9 +36,8 @@ public class BackupArchiveChatItemArchiver: BackupArchiveProtoStreamWriter {
 
     private typealias ArchiveFrameError = BackupArchive.ArchiveFrameError<BackupArchive.InteractionUniqueId>
 
-    private let attachmentManager: AttachmentManager
-    private let attachmentStore: AttachmentStore
-    private let backupAttachmentDownloadManager: BackupAttachmentDownloadManager
+    private let archivedPaymentStore: ArchivedPaymentStore
+    private let attachmentsArchiver: BackupArchiveMessageAttachmentArchiver
     private let callRecordStore: CallRecordStore
     private let contactManager: BackupArchive.Shims.ContactManager
     private let editMessageStore: EditMessageStore
@@ -46,15 +45,10 @@ public class BackupArchiveChatItemArchiver: BackupArchiveProtoStreamWriter {
     private let groupUpdateItemBuilder: GroupUpdateItemBuilder
     private let individualCallRecordManager: IndividualCallRecordManager
     private let interactionStore: BackupArchiveInteractionStore
-    private let archivedPaymentStore: ArchivedPaymentStore
+    private let oversizeTextArchiver: BackupArchiveInlinedOversizeTextArchiver
     private let reactionStore: ReactionStore
     private let threadStore: BackupArchiveThreadStore
 
-    private lazy var attachmentsArchiver = BackupArchiveMessageAttachmentArchiver(
-        attachmentManager: attachmentManager,
-        attachmentStore: attachmentStore,
-        backupAttachmentDownloadManager: backupAttachmentDownloadManager,
-    )
     private lazy var reactionArchiver = BackupArchiveReactionArchiver(
         reactionStore: BackupArchiveReactionStore()
     )
@@ -62,6 +56,7 @@ public class BackupArchiveChatItemArchiver: BackupArchiveProtoStreamWriter {
         interactionStore: interactionStore,
         archivedPaymentStore: archivedPaymentStore,
         attachmentsArchiver: attachmentsArchiver,
+        oversizeTextArchiver: oversizeTextArchiver,
         reactionArchiver: reactionArchiver
     )
     private lazy var incomingMessageArchiver = BackupArchiveTSIncomingMessageArchiver(
@@ -83,10 +78,9 @@ public class BackupArchiveChatItemArchiver: BackupArchiveProtoStreamWriter {
         interactionStore: interactionStore
     )
 
-    public init(
-        attachmentManager: AttachmentManager,
-        attachmentStore: AttachmentStore,
-        backupAttachmentDownloadManager: BackupAttachmentDownloadManager,
+    init(
+        archivedPaymentStore: ArchivedPaymentStore,
+        attachmentsArchiver: BackupArchiveMessageAttachmentArchiver,
         callRecordStore: CallRecordStore,
         contactManager: BackupArchive.Shims.ContactManager,
         editMessageStore: EditMessageStore,
@@ -94,13 +88,12 @@ public class BackupArchiveChatItemArchiver: BackupArchiveProtoStreamWriter {
         groupUpdateItemBuilder: GroupUpdateItemBuilder,
         individualCallRecordManager: IndividualCallRecordManager,
         interactionStore: BackupArchiveInteractionStore,
-        archivedPaymentStore: ArchivedPaymentStore,
+        oversizeTextArchiver: BackupArchiveInlinedOversizeTextArchiver,
         reactionStore: ReactionStore,
         threadStore: BackupArchiveThreadStore,
     ) {
-        self.attachmentManager = attachmentManager
-        self.attachmentStore = attachmentStore
-        self.backupAttachmentDownloadManager = backupAttachmentDownloadManager
+        self.archivedPaymentStore = archivedPaymentStore
+        self.attachmentsArchiver = attachmentsArchiver
         self.callRecordStore = callRecordStore
         self.contactManager = contactManager
         self.editMessageStore = editMessageStore
@@ -108,7 +101,7 @@ public class BackupArchiveChatItemArchiver: BackupArchiveProtoStreamWriter {
         self.groupUpdateItemBuilder = groupUpdateItemBuilder
         self.individualCallRecordManager = individualCallRecordManager
         self.interactionStore = interactionStore
-        self.archivedPaymentStore = archivedPaymentStore
+        self.oversizeTextArchiver = oversizeTextArchiver
         self.reactionStore = reactionStore
         self.threadStore = threadStore
     }
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveMessageAttachmentArchiver.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveMessageAttachmentArchiver.swift
index ac6e7bd086e..fe175727720 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveMessageAttachmentArchiver.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveMessageAttachmentArchiver.swift
@@ -105,16 +105,13 @@ internal class BackupArchiveMessageAttachmentArchiver: BackupArchiveProtoStreamW
     }
 
     public func archiveOversizeTextAttachment(
-        messageRowId: Int64,
-        messageId: BackupArchive.InteractionUniqueId,
+        _ referencedAttachment: ReferencedAttachment,
         context: BackupArchive.ArchivingContext
     ) -> BackupArchive.ArchiveInteractionResult<BackupProto_FilePointer?> {
-        return self.archiveSingleAttachment(
-            ownerType: .oversizeText,
-            messageId: messageId,
-            messageRowId: messageRowId,
-            context: context
-        )
+        return .success(referencedAttachment.asBackupFilePointer(
+            currentBackupAttachmentUploadEra: context.currentBackupAttachmentUploadEra,
+            attachmentByteCounter: context.attachmentByteCounter,
+        ))
     }
 
     public func archiveLinkPreviewAttachment(
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSIncomingMessageArchiver.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSIncomingMessageArchiver.swift
index 73ee88e027d..81cee19429e 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSIncomingMessageArchiver.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSIncomingMessageArchiver.swift
@@ -388,8 +388,8 @@ extension BackupArchiveTSIncomingMessageArchiver: BackupArchiveTSMessageEditHist
             case .remoteDeleteTombstone:
                 messageBuilder.wasRemotelyDeleted = true
             case .text(let text):
-                messageBuilder.messageBody = text.body?.text
-                messageBuilder.bodyRanges = text.body?.ranges
+                messageBuilder.messageBody = text.body?.messageBody.text
+                messageBuilder.bodyRanges = text.body?.messageBody.ranges
                 messageBuilder.quotedMessage = text.quotedMessage
                 messageBuilder.linkPreview = text.linkPreview
             case .contactShare(let contactShare):
@@ -409,8 +409,8 @@ extension BackupArchiveTSIncomingMessageArchiver: BackupArchiveTSMessageEditHist
             case .storyReply(let storyReply):
                 switch storyReply.replyType {
                 case .textReply(let textReply):
-                    messageBuilder.messageBody = textReply.body.text
-                    messageBuilder.bodyRanges = textReply.body.ranges
+                    messageBuilder.messageBody = textReply.body.messageBody.text
+                    messageBuilder.bodyRanges = textReply.body.messageBody.ranges
                 case .emoji(let emoji):
                     messageBuilder.storyReactionEmoji = emoji
                 }
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSMessageContentsArchiver.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSMessageContentsArchiver.swift
index ed420b329c1..c605369fa34 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSMessageContentsArchiver.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSMessageContentsArchiver.swift
@@ -33,13 +33,33 @@ extension BackupArchive {
         }
 
         struct Text {
-            let body: MessageBody?
+            struct RestoredMessageBody {
+                enum OversizeText {
+                    // The exporter presumably hadn't downloaded the attachment
+                    // at export time, so all we have is a pointer.
+                    case attachmentPointer(BackupProto_FilePointer)
+                    // Any time the exporter has downloaded the oversize text
+                    // attachment, they inline the text in the backup proto.
+                    // We will unfold it back into a restored attachment stream.
+                    case inlined(String)
+                }
+
+                // This is the body we put on the message
+                let messageBody: MessageBody
+                fileprivate let oversizeText: OversizeText?
+
+                init(messageBody: MessageBody, oversizeText: OversizeText?) {
+                    self.messageBody = messageBody
+                    self.oversizeText = oversizeText
+                }
+            }
+
+            let body: RestoredMessageBody?
             let quotedMessage: TSQuotedMessage?
             let linkPreview: OWSLinkPreview?
             let isVoiceMessage: Bool
 
             fileprivate let reactions: [BackupProto_Reaction]
-            fileprivate let oversizeTextAttachment: BackupProto_FilePointer?
             fileprivate let bodyAttachments: [BackupProto_MessageAttachment]
             fileprivate let quotedMessageThumbnail: BackupProto_MessageAttachment?
             fileprivate let linkPreviewImage: BackupProto_FilePointer?
@@ -79,8 +99,7 @@ extension BackupArchive {
         struct StoryReply {
             enum ReplyType {
                 struct TextReply {
-                    let body: MessageBody
-                    fileprivate let oversizeTextAttachment: BackupProto_FilePointer?
+                    let body: Text.RestoredMessageBody
                 }
 
                 case textReply(TextReply)
@@ -119,17 +138,20 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
     private lazy var contactAttachmentArchiver = BackupArchiveContactAttachmentArchiver(
         attachmentsArchiver: attachmentsArchiver
     )
+    private let oversizeTextArchiver: BackupArchiveInlinedOversizeTextArchiver
     private let reactionArchiver: BackupArchiveReactionArchiver
 
     init(
         interactionStore: BackupArchiveInteractionStore,
         archivedPaymentStore: ArchivedPaymentStore,
         attachmentsArchiver: BackupArchiveMessageAttachmentArchiver,
+        oversizeTextArchiver: BackupArchiveInlinedOversizeTextArchiver,
         reactionArchiver: BackupArchiveReactionArchiver
     ) {
         self.interactionStore = interactionStore
         self.archivedPaymentStore = archivedPaymentStore
         self.attachmentsArchiver = attachmentsArchiver
+        self.oversizeTextArchiver = oversizeTextArchiver
         self.reactionArchiver = reactionArchiver
     }
 
@@ -309,9 +331,24 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
         if let messageBody = message.body?.nilIfEmpty {
             hasPrimaryContent = true
 
+            let oversizeTextResult = oversizeTextArchiver.archiveMessageBody(
+                text: messageBody,
+                messageRowId: messageRowId,
+                messageId: message.uniqueInteractionId,
+                context: context
+            )
+
+            let archivedBody: BackupArchive.ArchivedMessageBody
+            switch oversizeTextResult.bubbleUp(ChatItemType.self, partialErrors: &partialErrors) {
+            case .continue(let _archivedBody):
+                archivedBody = _archivedBody
+            case .bubbleUpError(let errorResult):
+                return errorResult
+            }
+
             let text: BackupProto_Text
             let textResult = archiveText(
-                MessageBody(text: messageBody, ranges: message.bodyRanges ?? .empty),
+                MessageBody(text: archivedBody.inlinedText, ranges: message.bodyRanges ?? .empty),
                 interactionUniqueId: message.uniqueInteractionId
             )
             switch textResult.bubbleUp(ChatItemType.self, partialErrors: &partialErrors) {
@@ -321,21 +358,8 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 return errorResult
             }
             standardMessage.text = text
-
-            // Oversize text is only ever a thing _alongside_ body text, the body
-            // text is a prefix of the oversize text.
-
-            // Returns nil if no oversize text; this is both how we check and how we archive.
-            let oversizeTextResult = attachmentsArchiver.archiveOversizeTextAttachment(
-                messageRowId: messageRowId,
-                messageId: message.uniqueInteractionId,
-                context: context
-            )
-            switch oversizeTextResult.bubbleUp(ChatItemType.self, partialErrors: &partialErrors) {
-            case .continue(let oversizeTextAttachmentProto):
-                oversizeTextAttachmentProto.map { standardMessage.longText = $0 }
-            case .bubbleUpError(let errorResult):
-                return errorResult
+            if let oversizedTextPointer = archivedBody.oversizedTextPointer {
+                standardMessage.longText = oversizedTextPointer
             }
         }
 
@@ -914,8 +938,23 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 )])
             }
 
+            let oversizeTextResult = oversizeTextArchiver.archiveMessageBody(
+                text: body,
+                messageRowId: messageRowId,
+                messageId: message.uniqueInteractionId,
+                context: context
+            )
+
+            let archivedBody: BackupArchive.ArchivedMessageBody
+            switch oversizeTextResult.bubbleUp(ChatItemType.self, partialErrors: &partialErrors) {
+            case .continue(let _archivedBody):
+                archivedBody = _archivedBody
+            case .bubbleUpError(let errorResult):
+                return errorResult
+            }
+
             let textResult = archiveText(
-                MessageBody(text: body, ranges: message.bodyRanges ?? .empty),
+                MessageBody(text: archivedBody.inlinedText, ranges: message.bodyRanges ?? .empty),
                 interactionUniqueId: interactionUniqueId
             )
             let text: BackupProto_Text
@@ -927,19 +966,8 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
             }
             var textReply = BackupProto_DirectStoryReplyMessage.TextReply()
             textReply.text = text
-
-            // We'll only have oversize text if we also have a message body. If
-            // the following returns `nil`, we had no oversize text.
-            let oversizeTextResult = attachmentsArchiver.archiveOversizeTextAttachment(
-                messageRowId: messageRowId,
-                messageId: message.uniqueInteractionId,
-                context: context
-            )
-            switch oversizeTextResult.bubbleUp(ChatItemType.self, partialErrors: &partialErrors) {
-            case .continue(let oversizeTextAttachmentProto):
-                oversizeTextAttachmentProto.map { textReply.longText = $0 }
-            case .bubbleUpError(let errorResult):
-                return errorResult
+            if let oversizedTextPointer = archivedBody.oversizedTextPointer {
+                textReply.longText = oversizedTextPointer
             }
 
             proto.reply = .textReply(textReply)
@@ -1081,13 +1109,13 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 message: message,
                 context: context.recipientContext
             ))
-            if let oversizeTextAttachment = text.oversizeTextAttachment {
-                downstreamObjectResults.append(attachmentsArchiver.restoreOversizeTextAttachment(
-                    oversizeTextAttachment,
-                    chatItemId: chatItemId,
+            if let oversizeText = text.body?.oversizeText {
+                downstreamObjectResults.append(oversizeTextArchiver.restoreOversizeText(
+                    oversizeText,
                     messageRowId: messageRowId,
                     message: message,
                     thread: thread,
+                    chatItemId: chatItemId,
                     context: context
                 ))
             }
@@ -1185,13 +1213,13 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
 
             switch storyReply.replyType {
             case .textReply(let textReply):
-                if let oversizeTextAttachment = textReply.oversizeTextAttachment {
-                    downstreamObjectResults.append(attachmentsArchiver.restoreOversizeTextAttachment(
-                        oversizeTextAttachment,
-                        chatItemId: chatItemId,
+                if let oversizeText = textReply.body.oversizeText {
+                    downstreamObjectResults.append(oversizeTextArchiver.restoreOversizeText(
+                        oversizeText,
                         messageRowId: messageRowId,
                         message: message,
                         thread: thread,
+                        chatItemId: chatItemId,
                         context: context
                     ))
                 }
@@ -1381,13 +1409,6 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
             oversizeTextAttachment = nil
         }
 
-        if oversizeTextAttachment != nil && standardMessage.text.body.isEmpty {
-            return .messageFailure([.restoreFrameError(
-                .invalidProtoData(.longTextStandardMessageMissingBody),
-                chatItemId
-            )])
-        }
-
         if standardMessage.text.body.isEmpty && standardMessage.attachments.isEmpty {
             return .messageFailure([.restoreFrameError(
                 .invalidProtoData(.emptyStandardMessage),
@@ -1406,7 +1427,11 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
             isVoiceMessage = false
         }
 
-        let messageBodyResult = restoreMessageBody(text, chatItemId: chatItemId)
+        let messageBodyResult = restoreMessageBody(
+            text,
+            oversizeTextAttachment: oversizeTextAttachment,
+            chatItemId: chatItemId,
+        )
         switch messageBodyResult {
         case .success(let body):
             let contents = BackupArchive.RestoredMessageContents.text(.init(
@@ -1415,7 +1440,6 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 linkPreview: linkPreview,
                 isVoiceMessage: isVoiceMessage,
                 reactions: standardMessage.reactions,
-                oversizeTextAttachment: oversizeTextAttachment,
                 bodyAttachments: standardMessage.attachments,
                 quotedMessageThumbnail: quotedMessageThumbnail,
                 linkPreviewImage: linkPreviewAttachment
@@ -1433,7 +1457,6 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                     linkPreview: linkPreview,
                     isVoiceMessage: isVoiceMessage,
                     reactions: standardMessage.reactions,
-                    oversizeTextAttachment: oversizeTextAttachment,
                     bodyAttachments: standardMessage.attachments,
                     quotedMessageThumbnail: quotedMessageThumbnail,
                     linkPreviewImage: linkPreviewAttachment
@@ -1447,16 +1470,20 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
         }
     }
 
+    typealias RestoredMessageBody = BackupArchive.RestoredMessageContents.Text.RestoredMessageBody
+
     private func restoreMessageBody(
         _ text: BackupProto_Text,
+        oversizeTextAttachment: BackupProto_FilePointer?,
         chatItemId: BackupArchive.ChatItemId
-    ) -> RestoreInteractionResult<MessageBody?> {
+    ) -> RestoreInteractionResult<RestoredMessageBody?> {
         guard text.body.isEmpty.negated else {
             return .success(nil)
         }
         return restoreMessageBody(
             text: text.body,
             bodyRangeProtos: text.bodyRanges,
+            oversizeTextAttachment: oversizeTextAttachment,
             chatItemId: chatItemId
         )
     }
@@ -1464,8 +1491,9 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
     private func restoreMessageBody(
         text: String,
         bodyRangeProtos: [BackupProto_BodyRange],
+        oversizeTextAttachment: BackupProto_FilePointer?,
         chatItemId: BackupArchive.ChatItemId
-    ) -> RestoreInteractionResult<MessageBody?> {
+    ) -> RestoreInteractionResult<RestoredMessageBody?> {
         var partialErrors = [RestoreFrameError]()
         var bodyMentions = [NSRange: Aci]()
         var bodyStyles = [NSRangedValue<MessageBodyRanges.SingleStyle>]()
@@ -1510,14 +1538,27 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
             }
         }
         let bodyRanges = MessageBodyRanges(mentions: bodyMentions, styles: bodyStyles)
-        let body = MessageBody(text: text, ranges: bodyRanges)
+
+        let restoredBody: RestoredMessageBody?
+        switch oversizeTextArchiver.restoreMessageBody(
+            text,
+            bodyRanges: bodyRanges,
+            oversizeTextAttachment: oversizeTextAttachment,
+            chatItemId: chatItemId
+        ).bubbleUp(Optional<RestoredMessageBody>.self, partialErrors: &partialErrors, ) {
+        case .continue(let component):
+            restoredBody = component
+        case .bubbleUpError(let error):
+            return error
+        }
+
         if partialErrors.isEmpty {
-            return .success(body)
+            return .success(restoredBody)
         } else {
             // We still get text, albeit without any mentions or styles, if
             // we have these failures. So count as a partial restore, not
             // complete failure.
-            return .partialRestore(body, partialErrors)
+            return .partialRestore(restoredBody, partialErrors)
         }
     }
 
@@ -1578,6 +1619,8 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 .restoreMessageBody(
                     text: quote.text.body,
                     bodyRangeProtos: quote.text.bodyRanges,
+                    // Quotes don't support oversize text
+                    oversizeTextAttachment: nil,
                     chatItemId: chatItemId
                 )
                 .bubbleUp(
@@ -1586,7 +1629,14 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 )
             {
             case .continue(let component):
-                quoteBody = component
+                // We drop oversize text for quotes, if any.
+                if component?.oversizeText != nil {
+                    partialErrors.append(.restoreFrameError(
+                        .invalidProtoData(.quotedMessageOversizeText),
+                        chatItemId
+                    ))
+                }
+                quoteBody = component?.messageBody
             case .bubbleUpError(let error):
                 return error
             }
@@ -1870,10 +1920,11 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
                 nil
             }
 
-            let messageBody: MessageBody?
+            let messageBody: RestoredMessageBody?
             switch self
                 .restoreMessageBody(
                     textReply.text,
+                    oversizeTextAttachment: oversizeTextAttachment,
                     chatItemId: chatItemId
                 )
                 .bubbleUp(
@@ -1889,8 +1940,7 @@ class BackupArchiveTSMessageContentsArchiver: BackupArchiveProtoStreamWriter {
 
             if let messageBody {
                 replyType = .textReply(.init(
-                    body: messageBody,
-                    oversizeTextAttachment: oversizeTextAttachment
+                    body: messageBody
                 ))
             } else {
                 let restoreErrorType: RestoreFrameError.ErrorType
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSOutgoingMessageArchiver.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSOutgoingMessageArchiver.swift
index 11fb4f0b18f..1875c87fd18 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSOutgoingMessageArchiver.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupArchiveTSOutgoingMessageArchiver.swift
@@ -555,8 +555,8 @@ extension BackupArchiveTSOutgoingMessageArchiver: BackupArchiveTSMessageEditHist
             case .remoteDeleteTombstone:
                 outgoingMessageBuilder.wasRemotelyDeleted = true
             case .text(let text):
-                outgoingMessageBuilder.messageBody = text.body?.text
-                outgoingMessageBuilder.bodyRanges = text.body?.ranges
+                outgoingMessageBuilder.messageBody = text.body?.messageBody.text
+                outgoingMessageBuilder.bodyRanges = text.body?.messageBody.ranges
                 outgoingMessageBuilder.quotedMessage = text.quotedMessage
                 outgoingMessageBuilder.linkPreview = text.linkPreview
                 outgoingMessageBuilder.isVoiceMessage = text.isVoiceMessage
@@ -577,8 +577,8 @@ extension BackupArchiveTSOutgoingMessageArchiver: BackupArchiveTSMessageEditHist
             case .storyReply(let storyReply):
                 switch storyReply.replyType {
                 case .textReply(let textReply):
-                    outgoingMessageBuilder.messageBody = textReply.body.text
-                    outgoingMessageBuilder.bodyRanges = textReply.body.ranges
+                    outgoingMessageBuilder.messageBody = textReply.body.messageBody.text
+                    outgoingMessageBuilder.bodyRanges = textReply.body.messageBody.ranges
                 case .emoji(let emoji):
                     outgoingMessageBuilder.storyReactionEmoji = emoji
                 }
diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift
index ee60a03ebbf..80418de298e 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift
@@ -62,3 +62,480 @@ public struct BackupOversizeTextCache: Codable, FetchableRecord, MutablePersista
         case text
     }
 }
+
+extension BackupArchive {
+    struct ArchivedMessageBody {
+        let inlinedText: String
+        let oversizedTextPointer: BackupProto_FilePointer?
+    }
+}
+
+class BackupArchiveInlinedOversizeTextArchiver {
+
+    private let attachmentsArchiver: BackupArchiveMessageAttachmentArchiver
+    private let attachmentContentValidator: AttachmentContentValidator
+    private let attachmentManager: AttachmentManager
+    private let attachmentStore: AttachmentStore
+    private let db: any DB
+
+    private static let lastRestoredRowIdKey = "lastRestoredRowIdKey"
+    private let kvStore = KeyValueStore(collection: "BackupOversizeTextCacheStore")
+
+    // MARK: - Public API
+
+    init(
+        attachmentsArchiver: BackupArchiveMessageAttachmentArchiver,
+        attachmentContentValidator: AttachmentContentValidator,
+        attachmentManager: AttachmentManager,
+        attachmentStore: AttachmentStore,
+        db: any DB,
+    ) {
+        self.attachmentsArchiver = attachmentsArchiver
+        self.attachmentContentValidator = attachmentContentValidator
+        self.attachmentManager = attachmentManager
+        self.attachmentStore = attachmentStore
+        self.db = db
+    }
+
+    // MARK: - Archive
+
+    /// Populate the BackupOversizeTextCache table with any oversize text attachment streams that weren't
+    /// already present. After calling this method, BackupOversizeTextCache can be read for backup export.
+    /// Message processing (and sending) should be suspended while this runs, so that new attachments are not created,
+    public func populateTableIncrementally(progress: OWSProgressSink?) async throws {
+        // We can get away with fetching attachment ids in one read then processing in separate
+        // writes because no new attachments should be created while backups is running.
+        // Worst case, we miss an attachment and the oversized text ends up truncated
+        // or as a pointer in the backup.
+        var attachmentIdIndex = 0
+        let attachmentIds: [Attachment.IDType] = try db.read { tx in
+            try self.attachmentRowIdsForTablePopulation(tx: tx)
+        }
+
+        let progressSource: OWSProgressSource?
+        if let progress {
+            progressSource = await progress.addSource(
+                withLabel: "BackupOversizeTextCache",
+                unitCount: max(1, UInt64(attachmentIds.count))
+            )
+        } else {
+            progressSource = nil
+        }
+
+        if attachmentIds.isEmpty {
+            progressSource?.incrementCompletedUnitCount(by: 1)
+            return
+        }
+
+        _ = try await TimeGatedBatch.processAllAsync(db: db) { tx in
+            let batchIds = attachmentIds.dropFirst(attachmentIdIndex).prefix(Self.batchCount)
+            attachmentIdIndex += Self.batchCount
+            try self.populateTableIncrementallyBatch(
+                attachmentIds: batchIds,
+                progress: progressSource,
+                tx: tx
+            )
+            return batchIds.count
+        }
+    }
+
+    typealias ArchivedMessageBody = BackupArchive.ArchivedMessageBody
+
+    func archiveMessageBody(
+        text: String,
+        messageRowId: Int64,
+        messageId: BackupArchive.InteractionUniqueId,
+        context: BackupArchive.ArchivingContext,
+    ) -> BackupArchive.ArchiveInteractionResult<ArchivedMessageBody> {
+        var text = text
+        let originalTextLength =  text.lengthOfBytes(using: .utf8)
+        if originalTextLength > kOversizeTextMessageSizeThreshold {
+            // TSMessage bodies should never be past this length? How is this possible?
+            text = text.trimToUtf8ByteCount(Int(kOversizeTextMessageSizeThreshold))
+        }
+
+        let oversizedTextReference = attachmentStore.fetchFirstReference(
+            owner: .messageOversizeText(messageRowId: messageRowId),
+            tx: context.tx
+        )
+        guard
+            let oversizedTextReference
+        else {
+            // No oversized text if there's no corresponding attachment!
+            return .success(ArchivedMessageBody(
+                inlinedText: text,
+                oversizedTextPointer: nil
+            ))
+        }
+
+        let oversizedText: String?
+        do {
+            oversizedText = try self.fetchInlineableOversizedText(
+                attachmentId: oversizedTextReference.attachmentRowId,
+                tx: context.tx
+            )
+        } catch {
+            return .completeFailure(.fatalArchiveError(.oversizedTextCacheFetchError(error)))
+        }
+
+        if let oversizedText {
+            // If we had downloaded the attachment, we'd have an oversized text to inline.
+            // If we inline, no need to include a pointer (in fact, doing so is disallowed).
+            return .success(ArchivedMessageBody(
+                inlinedText: oversizedText,
+                oversizedTextPointer: nil
+            ))
+        } else {
+            // Otherwise the best we can do is return a pointer.
+            guard let attachment = attachmentStore.fetch(id: oversizedTextReference.attachmentRowId, tx: context.tx) else {
+                return .success(ArchivedMessageBody(
+                    inlinedText: text,
+                    oversizedTextPointer: nil
+                ))
+            }
+            var partialErrors = [BackupArchive.ArchiveFrameError<BackupArchive.InteractionUniqueId>]()
+            let pointerResult = attachmentsArchiver.archiveOversizeTextAttachment(
+                ReferencedAttachment(reference: oversizedTextReference, attachment: attachment),
+                context: context
+            )
+            switch pointerResult.bubbleUp(ArchivedMessageBody.self, partialErrors: &partialErrors) {
+            case .bubbleUpError(let error):
+                return error
+            case .continue(let oversizedTextPointer):
+                let body = ArchivedMessageBody(inlinedText: text, oversizedTextPointer: oversizedTextPointer)
+                if partialErrors.isEmpty {
+                    return .success(body)
+                } else {
+                    return .partialFailure(body, partialErrors)
+                }
+            }
+        }
+    }
+
+    // MARK: Restore
+
+    typealias RestoredMessageBody = BackupArchive.RestoredMessageContents.Text.RestoredMessageBody
+
+    func restoreMessageBody(
+        _ text: String,
+        bodyRanges: MessageBodyRanges,
+        oversizeTextAttachment: BackupProto_FilePointer?,
+        chatItemId: BackupArchive.ChatItemId
+    ) -> BackupArchive.RestoreInteractionResult<RestoredMessageBody?> {
+        var partialErrors = [BackupArchive.RestoreFrameError<BackupArchive.ChatItemId>]()
+
+        var text = text
+        let inlinedTextLength =  text.lengthOfBytes(using: .utf8)
+        if inlinedTextLength > BackupOversizeTextCache.maxTextLengthBytes {
+            // It is never allowed to have text beyond this limit inlined,
+            // truncate and drop any excess.
+            partialErrors.append(.restoreFrameError(
+                .invalidProtoData(.standardMessageWayTooOversizedBody),
+                chatItemId
+            ))
+            text = text.trimToUtf8ByteCount(BackupOversizeTextCache.maxTextLengthBytes)
+        }
+        let messageBody: MessageBody
+        if inlinedTextLength > kOversizeTextMessageSizeThreshold {
+            messageBody = MessageBody(text: text.trimToUtf8ByteCount(Int(kOversizeTextMessageSizeThreshold)), ranges: bodyRanges)
+        } else {
+            messageBody = MessageBody(text: text, ranges: bodyRanges)
+        }
+
+        let oversizeText: RestoredMessageBody.OversizeText?
+        if let oversizeTextAttachment {
+            if text.isEmpty {
+                return .messageFailure([.restoreFrameError(
+                    .invalidProtoData(.longTextStandardMessageMissingBody),
+                    chatItemId
+                )])
+            } else if inlinedTextLength > kOversizeTextMessageSizeThreshold {
+                // If we have an oversize text attachment, we are not allowed to _also_
+                // have inlined oversize text (that exceeds the standard body length limit).
+                partialErrors.append(.restoreFrameError(
+                    .invalidProtoData(.longTextStandardMessageWithOversizeBody),
+                    chatItemId
+                ))
+                // Drop the pointer; treat the text as inlined.
+                oversizeText = .inlined(text)
+            } else {
+                oversizeText = .attachmentPointer(oversizeTextAttachment)
+            }
+        } else if inlinedTextLength > kOversizeTextMessageSizeThreshold {
+            oversizeText = .inlined(text)
+        } else {
+            oversizeText = nil
+        }
+
+        let restoredBody = RestoredMessageBody(
+            messageBody: messageBody,
+            oversizeText: oversizeText
+        )
+
+        if partialErrors.isEmpty {
+            return .success(restoredBody)
+        } else {
+            // We still get text, albeit potentially truncated, if
+            // we have these failures. So count as a partial restore, not
+            // complete failure.
+            return .partialRestore(restoredBody, partialErrors)
+        }
+    }
+
+    /// Restore oversized text from a backup, preparing it to be fully restored later
+    /// (after this tx commits) by `finishRestoringAll()`.
+    func restoreOversizeText(
+        _ oversizedText: RestoredMessageBody.OversizeText,
+        messageRowId: Int64,
+        message: TSMessage,
+        thread: BackupArchive.ChatThread,
+        chatItemId: BackupArchive.ChatItemId,
+        context: BackupArchive.ChatItemRestoringContext,
+    ) -> BackupArchive.RestoreInteractionResult<Void> {
+        let text: String
+        switch oversizedText {
+        case .attachmentPointer(let attachmentPointer):
+            return attachmentsArchiver.restoreOversizeTextAttachment(
+                attachmentPointer,
+                chatItemId: chatItemId,
+                messageRowId: messageRowId,
+                message: message,
+                thread: thread,
+                context: context
+            )
+        case .inlined(let _text):
+            text = _text
+        }
+
+        // Construct an undownloadable FilePointer proto so that we can use it
+        // to construct a placeholder, undownloadable attachment that we will
+        // later populate with the oversized text in `finishRestoringAll`
+        var fakeProto = BackupProto_FilePointer()
+        fakeProto.locatorInfo = BackupProto_FilePointer.LocatorInfo()
+        fakeProto.contentType = MimeType.textXSignalPlain.rawValue
+
+        let ownedAttachment = OwnedAttachmentBackupPointerProto(
+            proto: fakeProto,
+            renderingFlag: .default,
+            clientUUID: nil,
+            owner: .messageOversizeText(.init(
+                messageRowId: messageRowId,
+                receivedAtTimestamp: message.receivedAtTimestamp,
+                threadRowId: thread.threadRowId,
+                isPastEditRevision: message.isPastEditRevision()
+            ))
+        )
+
+        // Whether we're free or paid this should be set when we restored the account data frame.
+        guard let uploadEra = context.uploadEra else {
+            return .messageFailure([.restoreFrameError(.invalidProtoData(.accountDataNotFound), chatItemId)])
+        }
+
+        let errors = attachmentManager.createAttachmentPointers(
+            from: [ownedAttachment],
+            uploadEra: uploadEra,
+            tx: context.tx
+        )
+        guard errors.isEmpty else {
+            return .messageFailure([.restoreFrameError(
+                .failedToCreateAttachment,
+                chatItemId
+            )])
+        }
+
+        // Fetch the attachment reference we just created.
+        let reference = attachmentStore.fetchFirstReference(
+            owner: .messageOversizeText(messageRowId: messageRowId),
+            tx: context.tx
+        )
+
+        guard let reference else {
+            return .messageFailure([.restoreFrameError(
+                .failedToCreateAttachment,
+                chatItemId
+            )])
+        }
+
+        do {
+            try self.insert(attachmentId: reference.attachmentRowId, text: text, tx: context.tx)
+        } catch {
+            return .messageFailure([.restoreFrameError(
+                .failedToCreateAttachment,
+                chatItemId
+            )])
+        }
+
+        return .success(())
+    }
+
+    func finishRestoringOversizedTextAttachments(
+        progress: OWSProgressSink?
+    ) async throws {
+        let progressSource: OWSProgressSource?
+        if let progress {
+            let unitCount = try db.read { tx in
+                let minId = kvStore.getInt64(Self.lastRestoredRowIdKey, defaultValue: 0, transaction: tx)
+                return try BackupOversizeTextCache
+                    .filter(Column(BackupOversizeTextCache.CodingKeys.id) > minId)
+                    .fetchCount(tx.database)
+            }
+            progressSource = await progress.addSource(withLabel: "OversizedTexts", unitCount: UInt64(unitCount))
+        } else {
+            progressSource = nil
+        }
+
+        var finished = false
+        while !finished {
+            finished = try await self.finishRestoringOversizedTextAttachmentBatch()
+            if let progressSource {
+                let remainingUnitCount = progressSource.totalUnitCount - progressSource.completedUnitCount
+                if remainingUnitCount > 0 {
+                    progressSource.incrementCompletedUnitCount(by: min(remainingUnitCount, UInt64(Self.batchCount)))
+                }
+            }
+        }
+    }
+
+    // MARK: - Helpers
+
+    private func fetchInlineableOversizedText(attachmentId: Attachment.IDType, tx: DBReadTransaction) throws -> String? {
+        return try BackupOversizeTextCache
+            .filter(Column(BackupOversizeTextCache.CodingKeys.attachmentRowId) == attachmentId)
+            .fetchOne(tx.database)?
+            .text
+    }
+
+    @discardableResult
+    private func insert(attachmentId: Attachment.IDType, text: String, tx: DBWriteTransaction) throws -> BackupOversizeTextCache.IDType {
+        var text = text
+        if text.lengthOfBytes(using: .utf8) > BackupOversizeTextCache.maxTextLengthBytes {
+            Logger.error("Oversized backup text too long! Truncating...")
+            text = text.trimToUtf8ByteCount(BackupOversizeTextCache.maxTextLengthBytes)
+        }
+        var record = BackupOversizeTextCache(id: nil, attachmentRowId: attachmentId, text: text)
+        try record.insert(tx.database)
+        return record.id!
+    }
+
+    // Work in batches of 50 so we can make (and commit) incremental progress.
+    static let batchCount = 50
+
+    private func attachmentRowIdsForTablePopulation(tx: DBReadTransaction) throws -> [Attachment.IDType] {
+        return try Attachment.Record
+            .filter(Column(Attachment.Record.CodingKeys.contentType) == Attachment.ContentTypeRaw.file.rawValue)
+            .filter(Column(Attachment.Record.CodingKeys.mimeType) == MimeType.textXSignalPlain.rawValue)
+            .filter(Column(Attachment.Record.CodingKeys.localRelativeFilePath) != nil)
+            // Only rows not already represented in the oversize text cache table
+            .filter(
+                !BackupOversizeTextCache
+                    .select(Column(BackupOversizeTextCache.CodingKeys.attachmentRowId))
+                    .filter(
+                        SQL(stringLiteral: "\(Attachment.Record.databaseTableName).\(Attachment.Record.CodingKeys.sqliteId.rawValue)")
+                            == Column(BackupOversizeTextCache.CodingKeys.attachmentRowId))
+                    .exists()
+            )
+            .select(Column(Attachment.Record.CodingKeys.sqliteId))
+            .fetchAll(tx.database)
+    }
+
+    // Returns number of rows processed. Returns 0 if finished.
+    private func populateTableIncrementallyBatch(
+        attachmentIds: ArraySlice<Attachment.IDType>,
+        progress: OWSProgressSource?,
+        tx: DBWriteTransaction
+    ) throws {
+        var maxRecordId: BackupOversizeTextCache.IDType = 0
+        for attachmentId in attachmentIds {
+            guard let stream = attachmentStore.fetch(id: attachmentId, tx: tx)?.asStream() else {
+                continue
+            }
+            owsAssertDebug(stream.contentType.raw == .file)
+            owsAssertDebug(stream.mimeType == MimeType.textXSignalPlain.rawValue)
+            let text = try stream.decryptedLongText()
+            let recordId = try self.insert(attachmentId: stream.id, text: text, tx: tx)
+            maxRecordId = max(maxRecordId, recordId)
+            if let progress {
+                progress.incrementCompletedUnitCount(by: 1)
+            }
+        }
+        // Treat these rows as "restored" (since we already have a corresponding attachment stream).
+        // We'll never do a restore after doing an archive, but its still best practice to set.
+        kvStore.setInt64(maxRecordId, key: Self.lastRestoredRowIdKey, transaction: tx)
+    }
+
+    // Returns true if done (no more rows to restore)
+    private func finishRestoringOversizedTextAttachmentBatch() async throws -> Bool {
+        let records = try db.read { tx in
+            let minId = kvStore.getInt64(Self.lastRestoredRowIdKey, defaultValue: 0, transaction: tx)
+            return try BackupOversizeTextCache
+                .filter(Column(BackupOversizeTextCache.CodingKeys.id) > minId)
+                .order(Column(BackupOversizeTextCache.CodingKeys.id).asc)
+                .limit(Self.batchCount)
+                .fetchAll(tx.database)
+        }
+        if records.isEmpty {
+            return true
+        }
+        var cacheIdToAttachmentId = [BackupOversizeTextCache.IDType: Attachment.IDType]()
+        var attachmentIdToCacheIds = [Attachment.IDType: [BackupOversizeTextCache.IDType]]()
+        var messageBodies = [BackupOversizeTextCache.IDType: MessageBody]()
+        for record in records {
+            cacheIdToAttachmentId[record.id!] = record.attachmentRowId
+            var cacheIds = attachmentIdToCacheIds[record.attachmentRowId] ?? []
+            cacheIds.append(record.id!)
+            attachmentIdToCacheIds[record.attachmentRowId] = cacheIds
+            messageBodies[record.id!] = MessageBody(text: record.text, ranges: .empty)
+        }
+
+        var encryptionKeys = [BackupOversizeTextCache.IDType: Data]()
+        db.read { tx in
+            for attachment in attachmentStore.fetch(ids: Array(attachmentIdToCacheIds.keys), tx: tx) {
+                for recordId in attachmentIdToCacheIds[attachment.id] ?? [] {
+                    encryptionKeys[recordId] = attachment.encryptionKey
+                }
+            }
+        }
+
+        do {
+            let pendingAttachments = try await attachmentContentValidator.prepareOversizeTextsIfNeeded(
+                from: messageBodies,
+                encryptionKeys: encryptionKeys
+            )
+
+            try await db.awaitableWriteWithRollbackIfThrows { tx in
+                var maxRecordId: BackupOversizeTextCache.IDType = 0
+                defer {
+                    // Mark progress by writing the max record id.
+                    kvStore.setInt64(maxRecordId, key: Self.lastRestoredRowIdKey, transaction: tx)
+                }
+                for (recordId, validatedMessageBody) in pendingAttachments {
+                    maxRecordId = max(maxRecordId, recordId)
+                    switch validatedMessageBody {
+                    case .inline:
+                        owsFailDebug("Got oversize text thats fits a normal message?")
+                        continue
+                    case let .oversize(_, pendingAttachment):
+                        guard let attachmentId = cacheIdToAttachmentId[recordId] else {
+                            owsFailDebug("Missing attachment id")
+                            continue
+                        }
+                        try attachmentManager.updateAttachmentWithOversizeTextFromBackup(
+                            attachmentId: attachmentId,
+                            pendingAttachment: pendingAttachment,
+                            tx: tx
+                        )
+                    }
+                }
+            }
+        } catch let error {
+            owsFailDebug("Unable to process batch \(error.grdbErrorForLogging)")
+            // Skip this batch; the backup already committed and theres no going back,
+            // so all we can do is drop this long text to avoid bricking the app entirely.
+            let maxRecordId: BackupOversizeTextCache.IDType = records.lazy.compactMap(\.id).max() ?? 0
+            await db.awaitableWriteWithRollbackIfThrows { tx in
+                kvStore.setInt64(maxRecordId, key: Self.lastRestoredRowIdKey, transaction: tx)
+            }
+        }
+        return false
+    }
+}
diff --git a/SignalServiceKit/Backups/Archiving/BackupArchiveManagerImpl.swift b/SignalServiceKit/Backups/Archiving/BackupArchiveManagerImpl.swift
index c0f96e6ab7e..98a8aa95756 100644
--- a/SignalServiceKit/Backups/Archiving/BackupArchiveManagerImpl.swift
+++ b/SignalServiceKit/Backups/Archiving/BackupArchiveManagerImpl.swift
@@ -65,6 +65,7 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
     private let localStorage: AccountKeyStore
     private let localRecipientArchiver: BackupArchiveLocalRecipientArchiver
     private let messagePipelineSupervisor: MessagePipelineSupervisor
+    private let oversizeTextArchiver: BackupArchiveInlinedOversizeTextArchiver
     private let plaintextStreamProvider: BackupArchivePlaintextProtoStreamProvider
     private let postFrameRestoreActionManager: BackupArchivePostFrameRestoreActionManager
     private let releaseNotesRecipientArchiver: BackupArchiveReleaseNotesRecipientArchiver
@@ -72,7 +73,7 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
     private let stickerPackArchiver: BackupArchiveStickerPackArchiver
     private let tsAccountManager: TSAccountManager
 
-    public init(
+    init(
         accountDataArchiver: BackupArchiveAccountDataArchiver,
         adHocCallArchiver: BackupArchiveAdHocCallArchiver,
         appVersion: AppVersion,
@@ -103,6 +104,7 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
         localStorage: AccountKeyStore,
         localRecipientArchiver: BackupArchiveLocalRecipientArchiver,
         messagePipelineSupervisor: MessagePipelineSupervisor,
+        oversizeTextArchiver: BackupArchiveInlinedOversizeTextArchiver,
         plaintextStreamProvider: BackupArchivePlaintextProtoStreamProvider,
         postFrameRestoreActionManager: BackupArchivePostFrameRestoreActionManager,
         releaseNotesRecipientArchiver: BackupArchiveReleaseNotesRecipientArchiver,
@@ -140,6 +142,7 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
         self.localStorage = localStorage
         self.localRecipientArchiver = localRecipientArchiver
         self.messagePipelineSupervisor = messagePipelineSupervisor
+        self.oversizeTextArchiver = oversizeTextArchiver
         self.plaintextStreamProvider = plaintextStreamProvider
         self.postFrameRestoreActionManager = postFrameRestoreActionManager
         self.releaseNotesRecipientArchiver = releaseNotesRecipientArchiver
@@ -326,21 +329,27 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
         ) -> BackupArchive.ProtoStream.OpenOutputStreamResult<OutputStreamMetadata>
     ) async throws -> OutputStreamMetadata {
         let migrateAttachmentsProgressSink: OWSProgressSink?
+        let prepareOversizeTextAttachmentsProgressSink: OWSProgressSink?
         let exportProgress: BackupArchiveExportProgress?
         if let progressSink {
             migrateAttachmentsProgressSink = await progressSink.addChild(
                 withLabel: "Export Backup: Migrate Attachments",
                 unitCount: 5
             )
+            prepareOversizeTextAttachmentsProgressSink = await progressSink.addChild(
+                withLabel: "Export Backup: Oversize Text Attachments",
+                unitCount: 5
+            )
             exportProgress = try await .prepare(
                 sink: await progressSink.addChild(
                     withLabel: "Export Backup: Export Frames",
-                    unitCount: 95
+                    unitCount: 90
                 ),
                 db: db
             )
         } else {
             migrateAttachmentsProgressSink = nil
+            prepareOversizeTextAttachmentsProgressSink = nil
             exportProgress = nil
         }
 
@@ -351,6 +360,8 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
 
         await migrateAttachmentsBeforeBackup(progress: migrateAttachmentsProgressSink)
 
+        try await oversizeTextArchiver.populateTableIncrementally(progress: prepareOversizeTextAttachmentsProgressSink)
+
         let mediaRootBackupKey = await db.awaitableWrite { tx in
             localStorage.getOrGenerateMediaRootBackupKey(tx: tx)
         }
@@ -742,9 +753,20 @@ public class BackupArchiveManagerImpl: BackupArchiveManager {
     /// Everything in this method MUST be idempotent, as partial progress can be made
     /// before app termination, which will result in this getting called again.
     public func finalizeBackupImport(progress: OWSProgressSink?) async throws {
-        // TODO: add more steps here, like restoring oversize text
-        let source = await progress?.addSource(withLabel: "", unitCount: 1)
-        source?.incrementCompletedUnitCount(by: 1)
+        let oversizedTextProgress: OWSProgressSink?
+        if let progress {
+            oversizedTextProgress = await progress.addChild(
+                withLabel: "Import Backup: Process Oversized Text Attachments",
+                unitCount: 5
+            )
+        } else {
+            oversizedTextProgress = nil
+        }
+
+        try await oversizeTextArchiver.finishRestoringOversizedTextAttachments(
+            progress: oversizedTextProgress
+        )
+
         await db.awaitableWrite { tx in
             kvStore.setInt(
                 BackupRestoreState.finalized.rawValue,
diff --git a/SignalServiceKit/Environment/AppSetup.swift b/SignalServiceKit/Environment/AppSetup.swift
index ef9c55ade22..16ba13a9672 100644
--- a/SignalServiceKit/Environment/AppSetup.swift
+++ b/SignalServiceKit/Environment/AppSetup.swift
@@ -1179,6 +1179,18 @@ public class AppSetup {
             tsAccountManager: tsAccountManager
         )
 
+        let backupAttachmentsArchiver = BackupArchiveMessageAttachmentArchiver(
+            attachmentManager: attachmentManager,
+            attachmentStore: attachmentStore,
+            backupAttachmentDownloadManager: backupAttachmentDownloadManager,
+        )
+        let backupsOversizeTextArchiver = BackupArchiveInlinedOversizeTextArchiver(
+            attachmentsArchiver: backupAttachmentsArchiver,
+            attachmentContentValidator: attachmentContentValidator,
+            attachmentManager: attachmentManager,
+            attachmentStore: attachmentStore,
+            db: db,
+        )
         let backupArchiveManager = BackupArchiveManagerImpl(
             accountDataArchiver: BackupArchiveAccountDataArchiver(
                 backupAttachmentUploadEraStore: backupAttachmentUploadEraStore,
@@ -1228,9 +1240,8 @@ public class AppSetup {
                 threadStore: backupThreadStore
             ),
             chatItemArchiver: BackupArchiveChatItemArchiver(
-                attachmentManager: attachmentManager,
-                attachmentStore: attachmentStore,
-                backupAttachmentDownloadManager: backupAttachmentDownloadManager,
+                archivedPaymentStore: archivedPaymentStore,
+                attachmentsArchiver: backupAttachmentsArchiver,
                 callRecordStore: callRecordStore,
                 contactManager: BackupArchive.Wrappers.ContactManager(contactManager),
                 editMessageStore: editMessageStore,
@@ -1238,7 +1249,7 @@ public class AppSetup {
                 groupUpdateItemBuilder: groupUpdateItemBuilder,
                 individualCallRecordManager: individualCallRecordManager,
                 interactionStore: backupInteractionStore,
-                archivedPaymentStore: archivedPaymentStore,
+                oversizeTextArchiver: backupsOversizeTextArchiver,
                 reactionStore: reactionStore,
                 threadStore: backupThreadStore,
             ),
@@ -1281,6 +1292,7 @@ public class AppSetup {
                 recipientStore: backupRecipientStore
             ),
             messagePipelineSupervisor: messagePipelineSupervisor,
+            oversizeTextArchiver: backupsOversizeTextArchiver,
             plaintextStreamProvider: BackupArchivePlaintextProtoStreamProvider(),
             postFrameRestoreActionManager: BackupArchivePostFrameRestoreActionManager(
                 avatarFetcher: backupArchiveAvatarFetcher,
diff --git a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManager.swift b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManager.swift
index d16912bc8cc..e77770502f5 100644
--- a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManager.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManager.swift
@@ -46,6 +46,17 @@ public protocol AttachmentManager {
         tx: DBWriteTransaction
     ) throws
 
+    /// Update an existing placeholder attachment with the full oversized text attachment file
+    /// we restored from a backup.
+    /// May reuse an existing attachment stream if matched by content, which will delete
+    /// both the provided pending files and the placeholder attachment whose id was provided,
+    /// pointing all its references to the existing duplicate.
+    func updateAttachmentWithOversizeTextFromBackup(
+        attachmentId: Attachment.IDType,
+        pendingAttachment: PendingAttachment,
+        tx: DBWriteTransaction
+    ) throws
+
     // MARK: - Quoted Replies
 
     /// Given an original message available locally, returns metadata
diff --git a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerImpl.swift b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerImpl.swift
index 121d02c875a..c48ac2c6847 100644
--- a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerImpl.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerImpl.swift
@@ -126,6 +126,28 @@ public class AttachmentManagerImpl: AttachmentManager {
         backupAttachmentUploadQueueRunner.backUpAllAttachmentsAfterTxCommits(tx: tx)
     }
 
+    public func updateAttachmentWithOversizeTextFromBackup(
+        attachmentId: Attachment.IDType,
+        pendingAttachment: PendingAttachment,
+        tx: DBWriteTransaction
+    ) throws {
+        guard let attachment = attachmentStore.fetch(id: attachmentId, tx: tx) else {
+            // The attachment got deleted? Should be impossible but ultimately fine.
+            return
+        }
+
+        if attachment.asStream() != nil {
+            // Its already a stream? Should be impossible but ultimately fine.
+            return
+        }
+
+        try _updateAttachmentWithOversizeTextFromBackup(
+            attachment: attachment,
+            pendingAttachment: pendingAttachment,
+            tx: tx
+        )
+    }
+
     // MARK: Quoted Replies
 
     public func quotedReplyAttachmentInfo(
@@ -839,6 +861,96 @@ public class AttachmentManagerImpl: AttachmentManager {
         }
     }
 
+    private func _updateAttachmentWithOversizeTextFromBackup(
+        attachment: Attachment,
+        pendingAttachment: PendingAttachment,
+        tx: DBWriteTransaction
+    ) throws {
+        let mediaName = Attachment.mediaName(
+            sha256ContentHash: pendingAttachment.sha256ContentHash,
+            encryptionKey: pendingAttachment.encryptionKey
+        )
+        let streamInfo = Attachment.StreamInfo(
+            sha256ContentHash: pendingAttachment.sha256ContentHash,
+            mediaName: mediaName,
+            encryptedByteCount: pendingAttachment.encryptedByteCount,
+            unencryptedByteCount: pendingAttachment.unencryptedByteCount,
+            contentType: pendingAttachment.validatedContentType,
+            digestSHA256Ciphertext: pendingAttachment.digestSHA256Ciphertext,
+            localRelativeFilePath: pendingAttachment.localRelativeFilePath
+        )
+
+        do {
+            guard self.orphanedAttachmentStore.orphanAttachmentExists(with: pendingAttachment.orphanRecordId, tx: tx) else {
+                throw OWSAssertionError("Attachment file deleted before creation")
+            }
+
+            // Update the placeholder attachment we previously created with the stream info
+            try self.attachmentStore.updateAttachmentAsDownloaded(
+                // Not technically true but close enough.
+                from: .mediaTierFullsize,
+                priority: .backupRestore,
+                id: attachment.id,
+                validatedMimeType: pendingAttachment.mimeType,
+                streamInfo: streamInfo,
+                // This is used for "last viewed" state which isn't used
+                // for oversize text so it doesn't really matter but give
+                // a real date anyway.
+                timestamp: dateProvider().ows_millisecondsSince1970,
+                tx: tx
+            )
+            // Make sure to clear out the pending attachment from the orphan table so it isn't deleted!
+            self.orphanedAttachmentCleaner.releasePendingAttachment(withId: pendingAttachment.orphanRecordId, tx: tx)
+
+            // Normally, after we create a stream, we schedule it for media tier upload, remove any
+            // media tier deletion jobs, etc. But we don't back up oversize text to media tier (since
+            // we inline it) so we don't need to do any of that.
+
+        } catch let error as AttachmentInsertError {
+            let existingAttachmentId: Attachment.IDType
+            switch error {
+            case .duplicatePlaintextHash(let id):
+                existingAttachmentId = id
+            case .duplicateMediaName(let id):
+                owsFailDebug("How did we match mediaName when using a random encryption key?")
+                existingAttachmentId = id
+            }
+
+            // Already have an attachment with the same plaintext hash or media name!
+            // Move all existing references to that copy, instead.
+            // Doing so should delete the original attachment pointer.
+            // This happens if we have two instances of the same oversized text
+            // in the backup (e.g. some long text message was forwarded)
+
+            // Just hold all refs in memory; there shouldn't in practice be
+            // so many pointers to the same attachment.
+            var references = [AttachmentReference]()
+            try self.attachmentStore.enumerateAllReferences(
+                toAttachmentId: attachment.id,
+                tx: tx
+            ) { reference, _ in
+                references.append(reference)
+            }
+            try references.forEach { reference in
+                try self.attachmentStore.removeOwner(
+                    reference: reference,
+                    tx: tx
+                )
+                let newOwnerParams = AttachmentReference.ConstructionParams(
+                    owner: reference.owner.forReassignmentWithContentType(pendingAttachment.validatedContentType.raw),
+                    sourceFilename: reference.sourceFilename,
+                    sourceUnencryptedByteCount: reference.sourceUnencryptedByteCount,
+                    sourceMediaSizePixels: reference.sourceMediaSizePixels
+                )
+                try self.attachmentStore.addOwner(
+                    newOwnerParams,
+                    for: existingAttachmentId,
+                    tx: tx
+                )
+            }
+        }
+    }
+
     /// When inserting an attachment stream (or updating an existing attachment to a stream),
     /// handle errors due to collisions with existing attachments' mediaName or plaintext hash.
     /// Returns the collided attachment's id, which should be used as the attachment id thereafter.
diff --git a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerMock.swift b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerMock.swift
index 30d0aea9264..a36665270e2 100644
--- a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerMock.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/AttachmentManagerMock.swift
@@ -32,6 +32,14 @@ open class AttachmentManagerMock: AttachmentManager {
         // Do nothing
     }
 
+    open func updateAttachmentWithOversizeTextFromBackup(
+        attachmentId: Attachment.IDType,
+        pendingAttachment: PendingAttachment,
+        tx: DBWriteTransaction
+    ) throws {
+        // Do nothing
+    }
+
     open func quotedReplyAttachmentInfo(
         originalMessage: TSMessage,
         tx: DBReadTransaction
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift
index 91a4c0c4b99..7b34506a5e0 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift
@@ -144,8 +144,13 @@ public protocol AttachmentContentValidator {
     /// If the provided message body is large enough to require an oversize text
     /// attachment, creates a pending one, alongside the truncated message body.
     /// If not, just returns the message body as is.
+    ///
+    /// - parameter encryptionKeys: The encryption key to use for the pending attachment
+    /// file to create for oversize text, if any. If there is no provided encryption key for a given MessageBody
+    /// input, a random key will be used.
     func prepareOversizeTextsIfNeeded<Key: Hashable>(
-        from texts: [Key: MessageBody]
+        from texts: [Key: MessageBody],
+        encryptionKeys: [Key: Data],
     ) async throws -> [Key: ValidatedMessageBody]
 
     /// Build a `QuotedReplyAttachmentDataSource` for a reply to a message with the provided attachment.
@@ -193,4 +198,13 @@ extension AttachmentContentValidator {
             sourceFilename: sourceFilename
         ))
     }
+
+    public func prepareOversizeTextIfNeeded(
+        _ body: MessageBody,
+    ) async throws -> ValidatedMessageBody {
+        return try await prepareOversizeTextsIfNeeded(
+            from: ["": body],
+            encryptionKeys: [:]
+        ).values.first!
+    }
 }
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
index a0568aa683b..e88cbabb00a 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
@@ -223,16 +223,13 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
     }
 
     public func prepareOversizeTextsIfNeeded<Key: Hashable>(
-        from texts: [Key: MessageBody]
+        from texts: [Key: MessageBody],
+        encryptionKeys: [Key: Data],
     ) async throws -> [Key: ValidatedMessageBody] {
         var truncatedBodies = [Key: MessageBody]()
         var oversizedTextInputs = [Key: Input]()
         var results = [Key: ValidatedMessageBody]()
         for (key, messageBody) in texts {
-            guard !messageBody.text.isEmpty else {
-                // Skip this one and don't put it in results
-                continue
-            }
             let truncatedText = messageBody.text.trimmedIfNeeded(maxByteCount: Int(kOversizeTextMessageSizeThreshold))
             guard let truncatedText else {
                 // No need to truncate
@@ -243,7 +240,10 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
             truncatedBodies[key] = truncatedBody
             let inputType = InputType.inMemory(Data(messageBody.text.utf8))
             let primaryFilePlaintextHash = try computePlaintextHash(inputType: inputType)
-            let encryptionKey = encryptionKeyToUse(primaryFilePlaintextHash: primaryFilePlaintextHash, inputEncryptionKey: nil)
+            let encryptionKey = encryptionKeyToUse(
+                primaryFilePlaintextHash: primaryFilePlaintextHash,
+                inputEncryptionKey: encryptionKeys[key]
+            )
             oversizedTextInputs[key] = Input(
                 type: inputType,
                 primaryFilePlaintextHash: primaryFilePlaintextHash,
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift
index c4889334ba9..0d33831717b 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift
@@ -64,7 +64,8 @@ open class AttachmentContentValidatorMock: AttachmentContentValidator {
     }
 
     open func prepareOversizeTextsIfNeeded<Key: Hashable>(
-        from texts: [Key: MessageBody]
+        from texts: [Key: MessageBody],
+        encryptionKeys: [Key: Data],
     ) async throws -> [Key: ValidatedMessageBody] {
         return texts.mapValues { .inline($0) }
     }
diff --git a/SignalServiceKit/tests/MessageBackup/Signal-Message-Backup-Tests b/SignalServiceKit/tests/MessageBackup/Signal-Message-Backup-Tests
index 341379da331..df09e4bfa98 160000
--- a/SignalServiceKit/tests/MessageBackup/Signal-Message-Backup-Tests
+++ b/SignalServiceKit/tests/MessageBackup/Signal-Message-Backup-Tests
@@ -1 +1 @@
-Subproject commit 341379da3316e97421c212e6bb62c795e68c53a9
+Subproject commit df09e4bfa985c68daf845ad96abae3ae8f9b07ca
diff --git a/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift b/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift
index ef397637392..d29248ef6cc 100644
--- a/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift
+++ b/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift
@@ -57,9 +57,9 @@ extension AttachmentMultisend {
             // We only prepare the single shared body.
             let validatedMessageBody: ValidatedMessageBody?
             if let messageBody {
-                validatedMessageBody = try await attachmentValidator.prepareOversizeTextsIfNeeded(
-                    from: ["": messageBody]
-                ).values.first
+                validatedMessageBody = try await attachmentValidator.prepareOversizeTextIfNeeded(
+                    messageBody
+                )
             } else {
                 validatedMessageBody = nil
             }
@@ -83,9 +83,9 @@ extension AttachmentMultisend {
                 ))
                 continue
             }
-            let validatedMessageBody = try await attachmentValidator.prepareOversizeTextsIfNeeded(
-                from: ["": hydratedMessageBody.asMessageBodyForForwarding()]
-            ).values.first
+            let validatedMessageBody = try await attachmentValidator.prepareOversizeTextIfNeeded(
+                hydratedMessageBody.asMessageBodyForForwarding()
+            )
             destinations.append(.init(
                 conversationItem: preDestination.conversationItem,
                 thread: preDestination.thread,
diff --git a/SignalUI/Sending/ThreadUtil+SignalUI.swift b/SignalUI/Sending/ThreadUtil+SignalUI.swift
index 3dfd95f5807..a71572cebfc 100644
--- a/SignalUI/Sending/ThreadUtil+SignalUI.swift
+++ b/SignalUI/Sending/ThreadUtil+SignalUI.swift
@@ -25,8 +25,7 @@ extension ThreadUtil {
             do {
                 let messageBody = try await messageBody.mapAsync {
                     try await DependenciesBridge.shared.attachmentContentValidator
-                        .prepareOversizeTextsIfNeeded(from: ["": $0])
-                        .values.first
+                        .prepareOversizeTextIfNeeded($0)
                 } ?? nil
                 let linkPreviewDataSource = try await linkPreviewDraft.mapAsync {
                     try await DependenciesBridge.shared.linkPreviewManager.buildDataSource(from: $0)
@@ -81,8 +80,7 @@ extension ThreadUtil {
             do {
                 let messageBody = try await messageBody.mapAsync {
                     try await DependenciesBridge.shared.attachmentContentValidator
-                        .prepareOversizeTextsIfNeeded(from: ["": $0])
-                        .values.first
+                        .prepareOversizeTextIfNeeded($0)
                 } ?? nil
                 let linkPreviewDataSource = try await linkPreviewDraft.mapAsync {
                     try await DependenciesBridge.shared.linkPreviewManager.buildDataSource(from: $0)
