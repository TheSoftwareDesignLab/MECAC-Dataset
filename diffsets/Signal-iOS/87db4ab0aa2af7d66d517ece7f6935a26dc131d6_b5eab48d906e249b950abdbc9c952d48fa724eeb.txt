diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index f6fadab4d9f..f48c07e0bd1 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -776,6 +776,7 @@
 		66586D3729005A1B00DDA9B9 /* story_viewer_onboarding_2.json in Resources */ = {isa = PBXBuildFile; fileRef = 66586D3429005A1B00DDA9B9 /* story_viewer_onboarding_2.json */; };
 		66586D3829005A1B00DDA9B9 /* story_viewer_onboarding_1.json in Resources */ = {isa = PBXBuildFile; fileRef = 66586D3529005A1B00DDA9B9 /* story_viewer_onboarding_1.json */; };
 		66586D3929005A1B00DDA9B9 /* story_viewer_onboarding_3.json in Resources */ = {isa = PBXBuildFile; fileRef = 66586D3629005A1B00DDA9B9 /* story_viewer_onboarding_3.json */; };
+		66586D4129009C0000DDA9B9 /* TextAttachment.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66586D4029009C0000DDA9B9 /* TextAttachment.swift */; };
 		667E90D028E799D1005FE603 /* MyStorySettingsLearnMoreSheetViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667E90CF28E799D1005FE603 /* MyStorySettingsLearnMoreSheetViewController.swift */; };
 		667EDE6428F8D6B7001FB487 /* YYAnimatedImage+Duration.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667EDE6328F8D6B7001FB487 /* YYAnimatedImage+Duration.swift */; };
 		667EDE6628FA0372001FB487 /* StoryBadgeCountManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667EDE6528FA0372001FB487 /* StoryBadgeCountManager.swift */; };
@@ -3034,6 +3035,7 @@
 		66586D3429005A1B00DDA9B9 /* story_viewer_onboarding_2.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = story_viewer_onboarding_2.json; sourceTree = "<group>"; };
 		66586D3529005A1B00DDA9B9 /* story_viewer_onboarding_1.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = story_viewer_onboarding_1.json; sourceTree = "<group>"; };
 		66586D3629005A1B00DDA9B9 /* story_viewer_onboarding_3.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = story_viewer_onboarding_3.json; sourceTree = "<group>"; };
+		66586D4029009C0000DDA9B9 /* TextAttachment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TextAttachment.swift; sourceTree = "<group>"; };
 		667E90CF28E799D1005FE603 /* MyStorySettingsLearnMoreSheetViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MyStorySettingsLearnMoreSheetViewController.swift; sourceTree = "<group>"; };
 		667EDE6328F8D6B7001FB487 /* YYAnimatedImage+Duration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "YYAnimatedImage+Duration.swift"; sourceTree = "<group>"; };
 		667EDE6528FA0372001FB487 /* StoryBadgeCountManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryBadgeCountManager.swift; sourceTree = "<group>"; };
@@ -7640,6 +7642,7 @@
 				F9C5C9E1289453B100548EEE /* SignalRecipient.swift */,
 				F9C5C9FA289453B100548EEE /* SignalRecipientFinder.swift */,
 				F9C5C9FC289453B100548EEE /* SignalServiceAddress.swift */,
+				66586D4029009C0000DDA9B9 /* TextAttachment.swift */,
 				F9C5C9F2289453B100548EEE /* ThreadAssociatedData.swift */,
 				45161BA828A2E54B0055AB45 /* ThreadReplyInfo.swift */,
 				F9C5C9FD289453B100548EEE /* TSGroupMember.swift */,
@@ -11040,6 +11043,7 @@
 				F9C5CDCE289453B400548EEE /* TestModel+SDS.swift in Sources */,
 				F9C5CE22289453B400548EEE /* TestModel.m in Sources */,
 				F9C5CE5C289453B400548EEE /* TestProtocolRunner.swift in Sources */,
+				66586D4129009C0000DDA9B9 /* TextAttachment.swift in Sources */,
 				F9C5CCD8289453B300548EEE /* ThreadAssociatedData.swift in Sources */,
 				F9C5CDE2289453B400548EEE /* ThreadBacked.swift in Sources */,
 				F9C5CD17289453B300548EEE /* ThreadFinder.swift in Sources */,
diff --git a/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift b/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
index 088f388e689..caad2ee3d8b 100644
--- a/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
+++ b/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
@@ -18,7 +18,7 @@ class CameraFirstCaptureSendFlow: NSObject {
 
     private var approvedAttachments: [SignalAttachment]?
     private var approvalMessageBody: MessageBody?
-    private var textAttachment: TextAttachment?
+    private var textAttachment: UnsentTextAttachment?
 
     private var mentionCandidates: [SignalServiceAddress] = []
 
@@ -86,7 +86,7 @@ extension CameraFirstCaptureSendFlow: SendMediaNavDelegate {
         sendMediaNavigationController.pushViewController(pickerVC, animated: true)
     }
 
-    func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didFinishWithTextAttachment textAttachment: TextAttachment) {
+    func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didFinishWithTextAttachment textAttachment: UnsentTextAttachment) {
         self.textAttachment = textAttachment
 
         let pickerVC = ConversationPickerViewController(selection: selection, textAttacment: textAttachment)
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
index 1dd7df8459e..2a7bb13cf91 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
@@ -823,7 +823,7 @@ extension ConversationViewController: SendMediaNavDelegate {
     }
 
     func sendMediaNav(_ sendMediaNavifationController: SendMediaNavigationController,
-                      didFinishWithTextAttachment textAttachment: TextAttachment) {
+                      didFinishWithTextAttachment textAttachment: UnsentTextAttachment) {
         owsFailDebug("Can not post text stories to chat.")
     }
 
diff --git a/Signal/src/ViewControllers/ForwardMessageViewController.swift b/Signal/src/ViewControllers/ForwardMessageViewController.swift
index f8a1e465df1..57510f189dd 100644
--- a/Signal/src/ViewControllers/ForwardMessageViewController.swift
+++ b/Signal/src/ViewControllers/ForwardMessageViewController.swift
@@ -387,7 +387,9 @@ extension ForwardMessageViewController {
                                                          approvalMessageBody: item.messageBody,
                                                          approvedAttachments: attachments).asVoid()
         } else if let textAttachment = item.textAttachment {
-            return AttachmentMultisend.sendTextAttachment(textAttachment, to: selectedConversations).asVoid()
+            // TODO: we want to reuse the uploaded link preview image attachment instead of re-uploading
+            // if the original was sent recently (if not the image could be stale)
+            return AttachmentMultisend.sendTextAttachment(textAttachment.asUnsentAttachment(), to: selectedConversations).asVoid()
         } else if let messageBody = item.messageBody {
             let linkPreviewDraft = item.linkPreviewDraft
             let nonStorySendPromise = send(toRecipientThreads: outgoingMessageRecipientThreads) { recipientThread in
diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index 4c671c1e38e..bbebdcbe589 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -15,7 +15,7 @@ import SignalUI
 protocol PhotoCaptureViewControllerDelegate: AnyObject {
     func photoCaptureViewControllerDidFinish(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController,
-                                    didFinishWithTextAttachment textAttachment: TextAttachment)
+                                    didFinishWithTextAttachment textAttachment: UnsentTextAttachment)
     func photoCaptureViewControllerDidCancel(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerDidTryToCaptureTooMany(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerViewWillAppear(_ photoCaptureViewController: PhotoCaptureViewController)
@@ -917,32 +917,16 @@ extension PhotoCaptureViewController {
         let textStyle = textStoryComposerView.textStyle
         let background = textStoryComposerView.background
 
-        var validatedLinkPreview: OWSLinkPreview?
-        if let linkPreview = textStoryComposerView.linkPreviewDraft {
-            self.databaseStorage.write { transaction in
-                do {
-                    validatedLinkPreview = try OWSLinkPreview.buildValidatedLinkPreview(fromInfo: linkPreview, transaction: transaction)
-                } catch LinkPreviewError.featureDisabled {
-                    validatedLinkPreview = OWSLinkPreview(urlString: linkPreview.urlString, title: nil, imageAttachmentId: nil)
-                } catch {
-                    Logger.error("Failed to generate link preview.")
-                }
-            }
-        }
-
-        guard validatedLinkPreview != nil || !text.isEmpty else {
-            owsFailDebug("Empty content")
-            return
-        }
-
-        let textAttachment = TextAttachment(
+        let unsentTextAttachment = UnsentTextAttachment(
             text: text,
             textStyle: textStyle,
             textForegroundColor: textForegroundColor,
             textBackgroundColor: textBackgroundColor,
             background: background,
-            linkPreview: validatedLinkPreview)
-        delegate?.photoCaptureViewController(self, didFinishWithTextAttachment: textAttachment)
+            linkPreviewDraft: textStoryComposerView.linkPreviewDraft
+        )
+
+        delegate?.photoCaptureViewController(self, didFinishWithTextAttachment: unsentTextAttachment)
     }
 }
 
diff --git a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
index 71440a7f8ca..c2ffcfd9569 100644
--- a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
+++ b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
@@ -13,7 +13,7 @@ protocol SendMediaNavDelegate: AnyObject {
 
     func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didApproveAttachments attachments: [SignalAttachment], messageBody: MessageBody?)
 
-    func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didFinishWithTextAttachment textAttachment: TextAttachment)
+    func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didFinishWithTextAttachment textAttachment: UnsentTextAttachment)
 
     func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didChangeMessageBody newMessageBody: MessageBody?)
 
@@ -297,7 +297,7 @@ extension SendMediaNavigationController: PhotoCaptureViewControllerDelegate {
     }
 
     func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController,
-                                    didFinishWithTextAttachment textAttachment: TextAttachment) {
+                                    didFinishWithTextAttachment textAttachment: UnsentTextAttachment) {
         sendMediaNavDelegate?.sendMediaNav(self, didFinishWithTextAttachment: textAttachment)
     }
 
diff --git a/Signal/test/util/StorySharingTests.swift b/Signal/test/util/StorySharingTests.swift
index 506ffe2f88f..c51f2b2820a 100644
--- a/Signal/test/util/StorySharingTests.swift
+++ b/Signal/test/util/StorySharingTests.swift
@@ -26,10 +26,9 @@ class StorySharingTests: SignalBaseTest {
                     text: input,
                     ranges: .empty
                 ),
-                with: OWSLinkPreview(
-                    urlString: "https://signal.org",
-                    title: nil,
-                    imageAttachmentId: nil
+                with: OWSLinkPreviewDraft(
+                    url: URL(string: "https://signal.org")!,
+                    title: nil
                 )
             )
             XCTAssertEqual(output, expectedOutput)
diff --git a/SignalServiceKit/src/Contacts/TextAttachment.swift b/SignalServiceKit/src/Contacts/TextAttachment.swift
new file mode 100644
index 00000000000..55290c86ecf
--- /dev/null
+++ b/SignalServiceKit/src/Contacts/TextAttachment.swift
@@ -0,0 +1,295 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public struct UnsentTextAttachment {
+    public let text: String?
+    public let textStyle: TextAttachment.TextStyle
+    public let textForegroundColor: UIColor
+    public let textBackgroundColor: UIColor?
+    public let background: TextAttachment.Background
+
+    public let linkPreviewDraft: OWSLinkPreviewDraft?
+
+    public init(
+        text: String?,
+        textStyle: TextAttachment.TextStyle,
+        textForegroundColor: UIColor,
+        textBackgroundColor: UIColor?,
+        background: TextAttachment.Background,
+        linkPreviewDraft: OWSLinkPreviewDraft?
+    ) {
+        self.text = text
+        self.textStyle = textStyle
+        self.textForegroundColor = textForegroundColor
+        self.textBackgroundColor = textBackgroundColor
+        self.background = background
+        self.linkPreviewDraft = linkPreviewDraft
+    }
+
+    public func validateLinkPreviewAndBuildTextAttachment(transaction: SDSAnyWriteTransaction) -> TextAttachment? {
+        var validatedLinkPreview: OWSLinkPreview?
+        if let linkPreview = linkPreviewDraft {
+            do {
+                validatedLinkPreview = try OWSLinkPreview.buildValidatedLinkPreview(fromInfo: linkPreview, transaction: transaction)
+            } catch LinkPreviewError.featureDisabled {
+                validatedLinkPreview = OWSLinkPreview(urlString: linkPreview.urlString, title: nil, imageAttachmentId: nil)
+            } catch {
+                Logger.error("Failed to generate link preview.")
+            }
+        }
+
+        guard validatedLinkPreview != nil || !(text?.isEmpty ?? true) else {
+            owsFailDebug("Empty content")
+            return nil
+        }
+        return TextAttachment(
+            text: text,
+            textStyle: textStyle,
+            textForegroundColor: textForegroundColor,
+            textBackgroundColor: textBackgroundColor,
+            background: background,
+            linkPreview: validatedLinkPreview
+        )
+    }
+}
+
+public struct TextAttachment: Codable, Equatable {
+    public let text: String?
+
+    public enum TextStyle: Int, Codable, Equatable {
+        case regular = 0
+        case bold = 1
+        case serif = 2
+        case script = 3
+        case condensed = 4
+    }
+    public let textStyle: TextStyle
+
+    private let textForegroundColorHex: UInt32?
+    public var textForegroundColor: UIColor? { textForegroundColorHex.map { UIColor(argbHex: $0) } }
+
+    private let textBackgroundColorHex: UInt32?
+    public var textBackgroundColor: UIColor? { textBackgroundColorHex.map { UIColor(argbHex: $0) } }
+
+    private enum RawBackground: Codable, Equatable {
+        case color(hex: UInt32)
+        case gradient(raw: RawGradient)
+        struct RawGradient: Codable, Equatable {
+            let colors: [UInt32]
+            let positions: [Float]
+            let angle: UInt32
+
+            init(colors: [UInt32], positions: [Float], angle: UInt32) {
+                self.colors = colors
+                self.positions = positions
+                self.angle = angle
+            }
+
+            init(from decoder: Decoder) throws {
+                let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
+                self.colors = try container.decode([UInt32].self, forKey: .colors)
+                self.positions = try container.decode([Float].self, forKey: .positions)
+                self.angle = try container.decode(UInt32.self, forKey: .angle)
+            }
+
+            func buildProto() throws -> SSKProtoTextAttachmentGradient {
+                let builder = SSKProtoTextAttachmentGradient.builder()
+                if let startColor = colors.first {
+                    builder.setStartColor(startColor)
+                }
+                if let endColor = colors.last {
+                    builder.setEndColor(endColor)
+                }
+                builder.setColors(colors)
+                builder.setPositions(positions)
+                builder.setAngle(angle)
+                return try builder.build()
+            }
+        }
+    }
+    private let rawBackground: RawBackground
+
+    public enum Background {
+        case color(UIColor)
+        case gradient(Gradient)
+        public struct Gradient {
+            public init(colors: [UIColor], locations: [CGFloat], angle: UInt32) {
+                self.colors = colors
+                self.locations = locations
+                self.angle = angle
+            }
+            public init(colors: [UIColor]) {
+                let locations: [CGFloat] = colors.enumerated().map { element in
+                    return CGFloat(element.offset) / CGFloat(colors.count - 1)
+                }
+                self.init(colors: colors, locations: locations, angle: 180)
+            }
+            public let colors: [UIColor]
+            public let locations: [CGFloat]
+            public let angle: UInt32
+        }
+    }
+    public var background: Background {
+        switch rawBackground {
+        case .color(let hex):
+            return .color(.init(argbHex: hex))
+        case .gradient(let rawGradient):
+            return .gradient(.init(
+                colors: rawGradient.colors.map { UIColor(argbHex: $0) },
+                locations: rawGradient.positions.map { CGFloat($0) },
+                angle: rawGradient.angle
+            ))
+        }
+    }
+
+    public private(set) var preview: OWSLinkPreview?
+
+    init(from proto: SSKProtoTextAttachment, transaction: SDSAnyWriteTransaction) throws {
+        self.text = proto.text?.nilIfEmpty
+
+        guard let style = proto.textStyle else {
+            throw OWSAssertionError("Missing style for attachment.")
+        }
+
+        switch style {
+        case .default, .regular:
+            self.textStyle = .regular
+        case .bold:
+            self.textStyle = .bold
+        case .serif:
+            self.textStyle = .serif
+        case .script:
+            self.textStyle = .script
+        case .condensed:
+            self.textStyle = .condensed
+        }
+
+        if proto.hasTextForegroundColor {
+            textForegroundColorHex = proto.textForegroundColor
+        } else {
+            textForegroundColorHex = nil
+        }
+
+        if proto.hasTextBackgroundColor {
+            textBackgroundColorHex = proto.textBackgroundColor
+        } else {
+            textBackgroundColorHex = nil
+        }
+
+        if let gradient = proto.gradient {
+            let colors: [UInt32]
+            let positions: [Float]
+            if !gradient.colors.isEmpty && !gradient.positions.isEmpty {
+                colors = gradient.colors
+                positions = gradient.positions
+            } else {
+                colors = [ gradient.startColor, gradient.endColor ]
+                positions = [ 0, 1 ]
+            }
+            rawBackground = .gradient(raw: .init(
+                colors: colors,
+                positions: positions,
+                angle: gradient.angle
+            ))
+        } else if proto.hasColor {
+            rawBackground = .color(hex: proto.color)
+        } else {
+            throw OWSAssertionError("Missing background for attachment.")
+        }
+
+        if let preview = proto.preview {
+            self.preview = try OWSLinkPreview.buildValidatedLinkPreview(proto: preview, transaction: transaction)
+        }
+    }
+
+    public func buildProto(transaction: SDSAnyReadTransaction) throws -> SSKProtoTextAttachment {
+        let builder = SSKProtoTextAttachment.builder()
+
+        if let text = text {
+            builder.setText(text)
+        }
+
+        let textStyle: SSKProtoTextAttachmentStyle = {
+            switch self.textStyle {
+            case .regular: return .regular
+            case .bold: return .bold
+            case .serif: return .serif
+            case .script: return .script
+            case .condensed: return .condensed
+            }
+        }()
+        builder.setTextStyle(textStyle)
+
+        if let textForegroundColorHex = textForegroundColorHex {
+            builder.setTextForegroundColor(textForegroundColorHex)
+        }
+
+        if let textBackgroundColorHex = textBackgroundColorHex {
+            builder.setTextBackgroundColor(textBackgroundColorHex)
+        }
+
+        switch rawBackground {
+        case .color(let hex):
+            builder.setColor(hex)
+        case .gradient(let raw):
+            builder.setGradient(try raw.buildProto())
+        }
+
+        if let preview = preview {
+            builder.setPreview(try preview.buildProto(transaction: transaction))
+        }
+
+        return try builder.build()
+    }
+
+    public init(
+        text: String?,
+        textStyle: TextStyle,
+        textForegroundColor: UIColor,
+        textBackgroundColor: UIColor?,
+        background: Background,
+        linkPreview: OWSLinkPreview?
+    ) {
+        self.text = text
+        self.textStyle = textStyle
+        self.textForegroundColorHex = textForegroundColor.argbHex
+        self.textBackgroundColorHex = textBackgroundColor?.argbHex
+        self.rawBackground = {
+            switch background {
+            case .color(let color):
+                return .color(hex: color.argbHex)
+
+            case .gradient(let gradient):
+                return .gradient(raw: .init(colors: gradient.colors.map { $0.argbHex },
+                                            positions: gradient.locations.map { Float($0) },
+                                            angle: gradient.angle))
+            }
+        }()
+        self.preview = linkPreview
+    }
+
+    /// Attempts to create a draft from the final version, so that it can be re-sent with new independent link attachment
+    /// objects created. If link recreation from url fails, will omit the link.
+    public func asUnsentAttachment() -> UnsentTextAttachment {
+        var linkPreviewDraft: OWSLinkPreviewDraft?
+        if
+            let preview = preview,
+            let urlString = preview.urlString,
+            let url = URL(string: urlString)
+        {
+            linkPreviewDraft = OWSLinkPreviewDraft(url: url, title: preview.title)
+        }
+        return UnsentTextAttachment(
+            text: text,
+            textStyle: textStyle,
+            textForegroundColor: textForegroundColor ?? .white,
+            textBackgroundColor: textBackgroundColor,
+            background: background,
+            linkPreviewDraft: linkPreviewDraft
+        )
+    }
+}
diff --git a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
index 46b8d99b631..745fa84129c 100644
--- a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
+++ b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
@@ -771,237 +771,6 @@ public enum StoryMessageAttachment: Codable {
     case text(attachment: TextAttachment)
 }
 
-public struct TextAttachment: Codable, Equatable {
-    public let text: String?
-
-    public enum TextStyle: Int, Codable, Equatable {
-        case regular = 0
-        case bold = 1
-        case serif = 2
-        case script = 3
-        case condensed = 4
-    }
-    public let textStyle: TextStyle
-
-    private let textForegroundColorHex: UInt32?
-    public var textForegroundColor: UIColor? { textForegroundColorHex.map { UIColor(argbHex: $0) } }
-
-    private let textBackgroundColorHex: UInt32?
-    public var textBackgroundColor: UIColor? { textBackgroundColorHex.map { UIColor(argbHex: $0) } }
-
-    private enum RawBackground: Codable, Equatable {
-        case color(hex: UInt32)
-        case gradient(raw: RawGradient)
-        struct RawGradient: Codable, Equatable {
-            let colors: [UInt32]
-            let positions: [Float]
-            let angle: UInt32
-
-            init(colors: [UInt32], positions: [Float], angle: UInt32) {
-                self.colors = colors
-                self.positions = positions
-                self.angle = angle
-            }
-
-            enum CodingKeysV1: String, CodingKey {
-                case startColorHex, endColorHex, angle
-            }
-
-            init(from decoder: Decoder) throws {
-                let containerV1: KeyedDecodingContainer<CodingKeysV1> = try decoder.container(keyedBy: CodingKeysV1.self)
-                if
-                    let startColorHex = try? containerV1.decode(UInt32.self, forKey: .startColorHex),
-                    let endColorHex = try? containerV1.decode(UInt32.self, forKey: .endColorHex),
-                    let angle = try? containerV1.decode(UInt32.self, forKey: .angle)
-                {
-                    self.colors = [ startColorHex, endColorHex ]
-                    self.positions = [ 0, 1 ]
-                    self.angle = angle
-                    return
-                }
-                let containerV2: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
-                self.colors = try containerV2.decode([UInt32].self, forKey: .colors)
-                self.positions = try containerV2.decode([Float].self, forKey: .positions)
-                self.angle = try containerV2.decode(UInt32.self, forKey: .angle)
-            }
-
-            func buildProto() throws -> SSKProtoTextAttachmentGradient {
-                let builder = SSKProtoTextAttachmentGradient.builder()
-                if let startColor = colors.first {
-                    builder.setStartColor(startColor)
-                }
-                if let endColor = colors.last {
-                    builder.setEndColor(endColor)
-                }
-                builder.setColors(colors)
-                builder.setPositions(positions)
-                builder.setAngle(angle)
-                return try builder.build()
-            }
-        }
-    }
-    private let rawBackground: RawBackground
-
-    public enum Background {
-        case color(UIColor)
-        case gradient(Gradient)
-        public struct Gradient {
-            public init(colors: [UIColor], locations: [CGFloat], angle: UInt32) {
-                self.colors = colors
-                self.locations = locations
-                self.angle = angle
-            }
-            public init(colors: [UIColor]) {
-                let locations: [CGFloat] = colors.enumerated().map { element in
-                    return CGFloat(element.offset) / CGFloat(colors.count - 1)
-                }
-                self.init(colors: colors, locations: locations, angle: 180)
-            }
-            public let colors: [UIColor]
-            public let locations: [CGFloat]
-            public let angle: UInt32
-        }
-    }
-    public var background: Background {
-        switch rawBackground {
-        case .color(let hex):
-            return .color(.init(argbHex: hex))
-        case .gradient(let rawGradient):
-            return .gradient(.init(
-                colors: rawGradient.colors.map { UIColor(argbHex: $0) },
-                locations: rawGradient.positions.map { CGFloat($0) },
-                angle: rawGradient.angle
-            ))
-        }
-    }
-
-    public private(set) var preview: OWSLinkPreview?
-
-    init(from proto: SSKProtoTextAttachment, transaction: SDSAnyWriteTransaction) throws {
-        self.text = proto.text?.nilIfEmpty
-
-        guard let style = proto.textStyle else {
-            throw OWSAssertionError("Missing style for attachment.")
-        }
-
-        switch style {
-        case .default, .regular:
-            self.textStyle = .regular
-        case .bold:
-            self.textStyle = .bold
-        case .serif:
-            self.textStyle = .serif
-        case .script:
-            self.textStyle = .script
-        case .condensed:
-            self.textStyle = .condensed
-        }
-
-        if proto.hasTextForegroundColor {
-            textForegroundColorHex = proto.textForegroundColor
-        } else {
-            textForegroundColorHex = nil
-        }
-
-        if proto.hasTextBackgroundColor {
-            textBackgroundColorHex = proto.textBackgroundColor
-        } else {
-            textBackgroundColorHex = nil
-        }
-
-        if let gradient = proto.gradient {
-            let colors: [UInt32]
-            let positions: [Float]
-            if !gradient.colors.isEmpty && !gradient.positions.isEmpty {
-                colors = gradient.colors
-                positions = gradient.positions
-            } else {
-                colors = [ gradient.startColor, gradient.endColor ]
-                positions = [ 0, 1 ]
-            }
-            rawBackground = .gradient(raw: .init(
-                colors: colors,
-                positions: positions,
-                angle: gradient.angle
-            ))
-        } else if proto.hasColor {
-            rawBackground = .color(hex: proto.color)
-        } else {
-            throw OWSAssertionError("Missing background for attachment.")
-        }
-
-        if let preview = proto.preview {
-            self.preview = try OWSLinkPreview.buildValidatedLinkPreview(proto: preview, transaction: transaction)
-        }
-    }
-
-    public func buildProto(transaction: SDSAnyReadTransaction) throws -> SSKProtoTextAttachment {
-        let builder = SSKProtoTextAttachment.builder()
-
-        if let text = text {
-            builder.setText(text)
-        }
-
-        let textStyle: SSKProtoTextAttachmentStyle = {
-            switch self.textStyle {
-            case .regular: return .regular
-            case .bold: return .bold
-            case .serif: return .serif
-            case .script: return .script
-            case .condensed: return .condensed
-            }
-        }()
-        builder.setTextStyle(textStyle)
-
-        if let textForegroundColorHex = textForegroundColorHex {
-            builder.setTextForegroundColor(textForegroundColorHex)
-        }
-
-        if let textBackgroundColorHex = textBackgroundColorHex {
-            builder.setTextBackgroundColor(textBackgroundColorHex)
-        }
-
-        switch rawBackground {
-        case .color(let hex):
-            builder.setColor(hex)
-        case .gradient(let raw):
-            builder.setGradient(try raw.buildProto())
-        }
-
-        if let preview = preview {
-            builder.setPreview(try preview.buildProto(transaction: transaction))
-        }
-
-        return try builder.build()
-    }
-
-    public init(
-        text: String?,
-        textStyle: TextStyle,
-        textForegroundColor: UIColor,
-        textBackgroundColor: UIColor?,
-        background: Background,
-        linkPreview: OWSLinkPreview?
-    ) {
-        self.text = text
-        self.textStyle = textStyle
-        self.textForegroundColorHex = textForegroundColor.argbHex
-        self.textBackgroundColorHex = textBackgroundColor?.argbHex
-        self.rawBackground = {
-            switch background {
-            case .color(let color):
-                return .color(hex: color.argbHex)
-
-            case .gradient(let gradient):
-                return .gradient(raw: .init(colors: gradient.colors.map { $0.argbHex },
-                                            positions: gradient.locations.map { Float($0) },
-                                            angle: gradient.angle))
-            }
-        }()
-        self.preview = linkPreview
-    }
-}
-
 extension SignalServiceAddress {
 
     public var isSystemStoryAddress: Bool {
diff --git a/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift
index b39a79b8b80..a1bb6ed0464 100644
--- a/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift	
@@ -23,6 +23,10 @@ public class AttachmentMultisend: Dependencies {
             )
         }.map(on: ThreadUtil.enqueueSendQueue) { (preparedSend: PreparedMediaMultisend) -> [TSThread] in
             self.databaseStorage.write { transaction in
+                // This will upload the TSAttachments whose IDs are the keys of attachmentIdMap
+                // and propagate their upload state to each of the TSAttachment unique IDs in the values.
+                // Each outgoing destination gets its own TSAttachment per attached media, but we upload only one,
+                // and propagate its upload state to each of these independent clones.
                 self.broadcastMediaMessageJobQueue.add(
                     attachmentIdMap: preparedSend.attachmentIdMap,
                     unsavedMessagesToSend: preparedSend.unsavedMessages,
@@ -205,7 +209,9 @@ public class AttachmentMultisend: Dependencies {
                     }
                     return .init(thread: thread, content: .media(attachments))
                 }
-
+                // This will create TSAttachments for each destination, but will not actually upload anything.
+                // It will map the UUIDs we created above for each attachment we want to upload to the unique ids
+                // of each created TSAttachment in state.correspondingAttachmentIds.
                 try wrapper.type.prepareForMultisending(destinations: destinations, state: state, transaction: transaction)
             }
 
@@ -218,6 +224,9 @@ public class AttachmentMultisend: Dependencies {
                     let attachmentToUpload = try attachmentInfo.value.asStreamConsumingDataSource(withIsVoiceMessage: false)
                     attachmentToUpload.anyInsert(transaction: transaction)
 
+                    // Finally we map the unique ID of each TSAttachment we intend to upload to the unique IDs of
+                    // all the independent TSAttachments we created for each destination. This lets us upload only
+                    // the one attachment (the one whose id is the key below) instead of uploading once per destination.
                     state.attachmentIdMap[attachmentToUpload.uniqueId] = state.correspondingAttachmentIds[attachmentInfo.id]
                 } catch {
                     owsFailDebug("error: \(error)")
@@ -236,46 +245,80 @@ public class AttachmentMultisend: Dependencies {
 public extension AttachmentMultisend {
 
     class func sendTextAttachment(
-        _ textAttachment: TextAttachment,
+        _ textAttachment: UnsentTextAttachment,
         to conversations: [ConversationItem]
     ) -> Promise<[TSThread]> {
         return firstly(on: ThreadUtil.enqueueSendQueue) {
             let preparedSend = try self.prepareForSending(conversations: conversations, textAttachment: textAttachment)
             self.databaseStorage.write { transaction in
-                for message in preparedSend.messages {
-                    self.messageSenderJobQueue.add(message: message.asPreparer, transaction: transaction)
-                }
+                // This will upload the TSAttachment at the key of attachmentIdMap (just one, you can
+                // only send one text attachment at a time) and propagate its upload state to each of the
+                // TSAttachment unique IDs in the value (an array). Each outgoing destination gets its own
+                // TSAttachment, but we upload only one, and propagate its upload state to each of them.
+                self.broadcastMediaMessageJobQueue.add(
+                    attachmentIdMap: preparedSend.attachmentIdMap,
+                    unsavedMessagesToSend: preparedSend.messages,
+                    transaction: transaction
+                )
             }
             return preparedSend.threads
         }
     }
 
     private struct PreparedTextMultisend {
+        let attachmentIdMap: [String: [String]]
         let messages: [TSOutgoingMessage]
         let threads: [TSThread]
     }
 
     private class func prepareForSending(
         conversations: [ConversationItem],
-        textAttachment: TextAttachment
+        textAttachment: UnsentTextAttachment
     ) throws -> PreparedTextMultisend {
 
         let state = MultisendState(approvalMessageBody: nil)
         let conversationsByMessageType = Dictionary(grouping: conversations, by: { TypeWrapper(type: $0.outgoingMessageClass) })
         try self.databaseStorage.write { transaction in
+
+            // Create one special TextAttachment from our UnsentTextAttachment; this implicitly creates a TSAttachment
+            // for the link preview's image (if there is any link preview image).
+            // This is the TSAttachment we will upload to the server, and whose uploaded information we will
+            // propagate to the independent TSAttachments that will be created per each destination.
+            // (Each destination needs its own independent TSAttachment so that deleting one has no effect on
+            // the others)
+            let attachmentToUploadIdentifier = UUID()
+            guard let attachmentToUpload = textAttachment.validateLinkPreviewAndBuildTextAttachment(transaction: transaction) else {
+                throw OWSAssertionError("Invalid text attachment")
+            }
+
             for (wrapper, conversations) in conversationsByMessageType {
                 let destinations = try conversations.lazy.map { conversation -> MultisendDestination in
                     guard let thread = conversation.getOrCreateThread(transaction: transaction) else {
                         throw OWSAssertionError("Missing thread for conversation")
                     }
-                    return .init(thread: thread, content: .text(textAttachment))
+                    return .init(thread: thread, content: .text(.init(textAttachment, id: attachmentToUploadIdentifier)))
                 }
 
+                // This will create TextAttachments and TSAttachments if needed for each destination, but
+                // will not actually upload anything.
+                // It will map the id we created above to the unique ids of each created TSAttachment in
+                // state.correspondingAttachmentIds.
                 try wrapper.type.prepareForMultisending(destinations: destinations, state: state, transaction: transaction)
             }
+
+            if
+                let linkPreviewAttachmentId = attachmentToUpload.preview?.imageAttachmentId,
+                let correspondingAttachments = state.correspondingAttachmentIds[attachmentToUploadIdentifier]
+            {
+                // Map the unique ID of the attachment we intend to actually upload to the unique IDs
+                // of all the independent attachments that won't be uploaded, so we know to update their
+                // metadata down the road.
+                state.attachmentIdMap[linkPreviewAttachmentId] = correspondingAttachments
+            }
         }
 
         return PreparedTextMultisend(
+            attachmentIdMap: state.attachmentIdMap,
             messages: state.unsavedMessages,
             threads: state.threads)
     }
@@ -301,7 +344,7 @@ class Identified<T> {
 
 enum MultisendContent {
     case media([Identified<SignalAttachment>])
-    case text(TextAttachment)
+    case text(Identified<UnsentTextAttachment>)
 }
 
 class MultisendDestination: NSObject {
diff --git a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift
index ed8b1650a86..7ba61f61906 100644
--- a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
@@ -51,11 +51,33 @@ extension OutgoingStoryMessage {
                 }
 
             case .text(let textAttachment):
-                let message = try OutgoingStoryMessage.createUnsentMessage(
-                    attachment: .text(attachment: textAttachment),
-                    thread: destination.thread,
-                    transaction: transaction
-                )
+                guard let finalTextAttachment = textAttachment.value.validateLinkPreviewAndBuildTextAttachment(transaction: transaction) else {
+                    throw OWSAssertionError("Invalid text attachment")
+                }
+
+                if let linkPreviewAttachmentId = finalTextAttachment.preview?.imageAttachmentId {
+                    var correspondingIdsForAttachment = state.correspondingAttachmentIds[textAttachment.id] ?? []
+                    correspondingIdsForAttachment += [linkPreviewAttachmentId]
+                    state.correspondingAttachmentIds[textAttachment.id] = correspondingIdsForAttachment
+                }
+
+                let message: OutgoingStoryMessage
+                if destination.thread is TSPrivateStoryThread, let privateStoryMessageId = privateStoryMessageIds[textAttachment.id] {
+                    message = try OutgoingStoryMessage.createUnsentMessage(
+                        thread: destination.thread,
+                        storyMessageId: privateStoryMessageId,
+                        transaction: transaction
+                    )
+                } else {
+                    message = try OutgoingStoryMessage.createUnsentMessage(
+                        attachment: .text(attachment: finalTextAttachment),
+                        thread: destination.thread,
+                        transaction: transaction
+                    )
+                    if destination.thread is TSPrivateStoryThread {
+                        privateStoryMessageIds[textAttachment.id] = message.storyMessageId
+                    }
+                }
 
                 state.messages.append(message)
                 state.unsavedMessages.append(message)
diff --git a/SignalUI/Utils/StorySharing.swift b/SignalUI/Utils/StorySharing.swift
index 316ca796177..9feefc9d63d 100644
--- a/SignalUI/Utils/StorySharing.swift
+++ b/SignalUI/Utils/StorySharing.swift
@@ -18,28 +18,19 @@ public enum StorySharing: Dependencies {
 
         guard !storyConversations.isEmpty else { return Promise.value(()) }
 
-        let linkPreview: OWSLinkPreview?
-        if let linkPreviewDraft = linkPreviewDraft {
-            linkPreview = databaseStorage.write { transaction in
-                try? OWSLinkPreview.buildValidatedLinkPreview(fromInfo: linkPreviewDraft, transaction: transaction)
-            }
-        } else {
-            linkPreview = nil
-        }
-
-        let textAttachment = TextAttachment(
-            text: text(for: messageBody, with: linkPreview),
+        let textAttachment = UnsentTextAttachment(
+            text: text(for: messageBody, with: linkPreviewDraft),
             textStyle: .regular,
             textForegroundColor: .white,
             textBackgroundColor: nil,
             background: .color(.init(rgbHex: 0x688BD4)),
-            linkPreview: linkPreview
+            linkPreviewDraft: linkPreviewDraft
         )
 
         return AttachmentMultisend.sendTextAttachment(textAttachment, to: storyConversations).asVoid()
     }
 
-    internal static func text(for messageBody: MessageBody, with linkPreview: OWSLinkPreview?) -> String? {
+    internal static func text(for messageBody: MessageBody, with linkPreview: OWSLinkPreviewDraft?) -> String? {
         // Turn any mentions in the message body to plaintext
         let plaintextMessageBody = databaseStorage.read { messageBody.plaintextBody(transaction: $0.unwrapGrdbRead) }
 
diff --git a/SignalUI/ViewControllers/ConversationPicker/ConversationPicker.swift b/SignalUI/ViewControllers/ConversationPicker/ConversationPicker.swift
index f5c963aa465..d23d03b9a2f 100644
--- a/SignalUI/ViewControllers/ConversationPicker/ConversationPicker.swift
+++ b/SignalUI/ViewControllers/ConversationPicker/ConversationPicker.swift
@@ -33,7 +33,7 @@ open class ConversationPickerViewController: OWSTableViewController2 {
 
     private let kMaxPickerSelection = 5
     private let attachments: [SignalAttachment]?
-    private let textAttachment: TextAttachment?
+    private let textAttachment: UnsentTextAttachment?
     private let maxVideoAttachmentDuration: TimeInterval?
 
     private let creationDate = Date()
@@ -82,7 +82,7 @@ open class ConversationPickerViewController: OWSTableViewController2 {
     /// Include a text attachment to display an attachment preview at the top (if configured with the `mediaPreview` section option)
     public convenience init(
         selection: ConversationPickerSelection,
-        textAttacment: TextAttachment
+        textAttacment: UnsentTextAttachment
     ) {
         self.init(selection: selection, attachments: nil, textAttachment: textAttacment)
     }
@@ -90,7 +90,7 @@ open class ConversationPickerViewController: OWSTableViewController2 {
     public init(
         selection: ConversationPickerSelection,
         attachments: [SignalAttachment]? = nil,
-        textAttachment: TextAttachment? = nil
+        textAttachment: UnsentTextAttachment? = nil
     ) {
         self.selection = selection
         self.attachments = attachments
@@ -631,7 +631,7 @@ open class ConversationPickerViewController: OWSTableViewController2 {
 
     private func addMediaPreview(
         to section: OWSTableSection,
-        textAttachment: TextAttachment
+        textAttachment: UnsentTextAttachment
     ) {
         let previewView = TextAttachmentView(attachment: textAttachment).asThumbnailView()
         previewView.layer.masksToBounds = true
diff --git a/SignalUI/Views/TextAttachmentView.swift b/SignalUI/Views/TextAttachmentView.swift
index 91e590a8258..63e8a6ff675 100644
--- a/SignalUI/Views/TextAttachmentView.swift
+++ b/SignalUI/Views/TextAttachmentView.swift
@@ -9,7 +9,9 @@ import SignalServiceKit
 
 open class TextAttachmentView: UIView {
 
-    private var textAttachment: TextAttachment?
+    private var linkPreviewUrlString: String? {
+        return linkPreview?.urlString()
+    }
 
     public let contentLayoutGuide = UILayoutGuide()
 
@@ -22,7 +24,18 @@ open class TextAttachmentView: UIView {
             background: attachment.background,
             linkPreview: attachment.preview
         )
-        self.textAttachment = attachment
+    }
+
+    convenience public init(attachment: UnsentTextAttachment) {
+        self.init(
+            text: attachment.text,
+            textStyle: attachment.textStyle,
+            textForegroundColor: attachment.textForegroundColor,
+            textBackgroundColor: attachment.textBackgroundColor,
+            background: attachment.background,
+            linkPreview: nil,
+            linkPreviewDraft: attachment.linkPreviewDraft
+        )
     }
 
     public init(
@@ -31,7 +44,8 @@ open class TextAttachmentView: UIView {
         textForegroundColor: UIColor?,
         textBackgroundColor: UIColor?,
         background: TextAttachment.Background,
-        linkPreview: OWSLinkPreview?
+        linkPreview: OWSLinkPreview?,
+        linkPreviewDraft: OWSLinkPreviewDraft? = nil
     ) {
         self.text = text
         self.textStyle = textStyle
@@ -63,6 +77,8 @@ open class TextAttachmentView: UIView {
                 imageAttachment: attachment,
                 conversationStyle: nil
             )
+        } else if let linkPreviewDraft = linkPreviewDraft {
+            self.linkPreview = LinkPreviewDraft(linkPreviewDraft: linkPreviewDraft)
         }
 
         updateTextAttributes()
@@ -396,7 +412,7 @@ open class TextAttachmentView: UIView {
 
             return true
         } else if let linkPreviewView = linkPreviewView,
-                  let urlString = textAttachment?.preview?.urlString,
+                  let urlString = linkPreviewUrlString,
                   let container = linkPreviewView.superview,
                   linkPreviewView.frame.contains(gesture.location(in: container)) {
             let tooltipView = LinkPreviewTooltipView(
