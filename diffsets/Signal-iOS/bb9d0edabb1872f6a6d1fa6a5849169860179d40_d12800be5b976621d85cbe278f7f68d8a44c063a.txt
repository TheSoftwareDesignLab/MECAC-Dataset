diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index 7c32e3df29c..9272e821635 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -1586,10 +1586,12 @@ private class TextStoryComposerView: TextAttachmentView, UITextViewDelegate {
     private func didTapDecorationStyleButton() {
         Logger.verbose("")
 
-        // Switch between colored text with no background and white text over colored background.
-        let currentDecorationStyle = textViewAccessoryToolbar.decorationStyle
-        let nextDecorationStyle: MediaTextView.DecorationStyle = currentDecorationStyle == .none ? .inverted : .none
-        textViewAccessoryToolbar.decorationStyle = nextDecorationStyle
+        // "Underline" and "Outline" are not available in text story composer.
+        var decorationStyle = textViewAccessoryToolbar.decorationStyle.next()
+        if decorationStyle == .outline || decorationStyle == .underline {
+            decorationStyle = .none
+        }
+        textViewAccessoryToolbar.decorationStyle = decorationStyle
 
         // `textViewAccessoryToolbar` defines both foreground and background color for text based on the decoration style.
         let textForegroundColor = textViewAccessoryToolbar.textForegroundColor
diff --git a/SignalServiceKit/src/Util/UIColor+SSK.swift b/SignalServiceKit/src/Util/UIColor+SSK.swift
index 359728fa1ab..e7fecdb5ad9 100644
--- a/SignalServiceKit/src/Util/UIColor+SSK.swift
+++ b/SignalServiceKit/src/Util/UIColor+SSK.swift
@@ -42,4 +42,23 @@ public extension UIColor {
         getRed(&red, green: &green, blue: &blue, alpha: &alpha)
         return UInt32(alpha * 255) << 24 | UInt32(red * 255) << 16 | UInt32(green * 255) << 8 | UInt32(blue * 255) << 0
     }
+
+    func isEqualToColor(_ color: UIColor, tolerance: CGFloat = 0) -> Bool {
+        var r1: CGFloat = 0
+        var g1: CGFloat = 0
+        var b1: CGFloat = 0
+        var a1: CGFloat = 0
+        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
+
+        var r2: CGFloat = 0
+        var g2: CGFloat = 0
+        var b2: CGFloat = 0
+        var a2: CGFloat = 0
+        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)
+
+        return abs(r1 - r2) <= tolerance &&
+        abs(g1 - g2) <= tolerance &&
+        abs(b1 - b2) <= tolerance &&
+        abs(a1 - a2) <= tolerance
+    }
 }
diff --git a/SignalUI/Views/ColorPickerBar.swift b/SignalUI/Views/ColorPickerBar.swift
index 9e94bd029cb..5764c2c7292 100644
--- a/SignalUI/Views/ColorPickerBar.swift
+++ b/SignalUI/Views/ColorPickerBar.swift
@@ -366,3 +366,10 @@ public class ColorPickerBarView: UIView {
         return gradientView.renderAsImage(opaque: true, scale: UIScreen.main.scale)
     }
 }
+
+public extension UIColor {
+
+    func isCloseToColor(_ color: UIColor) -> Bool {
+        return isEqualToColor(color, tolerance: 0.1)
+    }
+}
diff --git a/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift b/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift
index 4c79d424ed3..99c6b8d195b 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorCanvasView.swift
@@ -755,29 +755,26 @@ class ImageEditorCanvasView: AttachmentPrepContentView {
         let fontSize = item.fontSize * imageFrame.size.width / item.fontReferenceImageWidth
         let font = MediaTextView.font(forTextStyle: item.textStyle, pointSize: fontSize)
 
-        let textColor: UIColor = {
+        let text = item.text.filterForDisplay ?? ""
+        let attributedString = NSMutableAttributedString(
+            string: text,
+            attributes: [ .font: font, .foregroundColor: item.textForegroundColor ]
+        )
+
+        if let textDecorationColor = item.textDecorationColor {
             switch item.decorationStyle {
-            case .none: return item.color.color
-            default: return UIColor.white
+            case .underline:
+                attributedString.addAttributes([ .underlineStyle: NSUnderlineStyle.single.rawValue,
+                                                 .underlineColor: textDecorationColor],
+                                               range: attributedString.entireRange)
+            case .outline:
+                attributedString.addAttributes([ .strokeWidth: -3,
+                                                 .strokeColor: textDecorationColor ],
+                                               range: attributedString.entireRange)
+
+            default:
+                break
             }
-        }()
-
-        let text = item.text.filterForDisplay ?? ""
-        let attributedString = NSMutableAttributedString(string: text,
-                                                         attributes: [ .font: font,
-                                                                       .foregroundColor: textColor ])
-        switch item.decorationStyle {
-        case .underline:
-            attributedString.addAttributes([ .underlineStyle: NSUnderlineStyle.single.rawValue,
-                                             .underlineColor: item.color.color ],
-                                           range: attributedString.entireRange)
-        case .outline:
-            attributedString.addAttributes([ .strokeWidth: -3,
-                                             .strokeColor: item.color.color ],
-                                           range: attributedString.entireRange)
-
-        default:
-            break
         }
 
         let layer = EditorTextLayer(itemId: item.itemId)
@@ -811,9 +808,9 @@ class ImageEditorCanvasView: AttachmentPrepContentView {
         // Enlarge the layer slightly when setting the background color to add some horizontal padding around the text.
         // Unfortunately there's no easy way to add vertical padding because default CATextLayer's behavior
         // is to start drawing text from the top.
-        if item.decorationStyle == .inverted {
+        if let textBackgroundColor = item.textBackgroundColor {
             layer.frame = layer.frame.insetBy(dx: -4, dy: 0)
-            layer.backgroundColor = item.color.color.cgColor
+            layer.backgroundColor = textBackgroundColor.cgColor
             layer.cornerRadius = 8
         }
 
diff --git a/SignalUI/Views/ImageEditor/ImageEditorTextItem.swift b/SignalUI/Views/ImageEditor/ImageEditorTextItem.swift
index d8f12e4b96c..6e10d2bf4af 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorTextItem.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorTextItem.swift
@@ -20,6 +20,37 @@ class ImageEditorTextItem: ImageEditorItem {
         MediaTextView.font(forTextStyle: textStyle, pointSize: fontSize)
     }
 
+    var textForegroundColor: UIColor {
+        switch decorationStyle {
+        case .none, .whiteBackground: return color.color
+
+        case .coloredBackground:
+            let backgroundColor = color.color
+            return backgroundColor.isCloseToColor(.white) ? .black : .white
+
+        case .outline, .underline: return .white
+        }
+    }
+
+    var textBackgroundColor: UIColor? {
+        switch decorationStyle {
+        case .none, .underline, .outline: return nil
+
+        case .whiteBackground:
+            let textColor = color.color
+            return textColor.isCloseToColor(.white) ? .black : .white
+
+        case .coloredBackground: return color.color
+        }
+    }
+
+    var textDecorationColor: UIColor? {
+        switch decorationStyle {
+        case .none, .whiteBackground, .coloredBackground: return nil
+        case .outline, .underline: return color.color
+        }
+    }
+
     // In order to render the text at a consistent size
     // in very differently sized contexts (canvas in
     // portrait, landscape, in the crop tool, before and
diff --git a/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift b/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift
index bef7803e74a..bdf975d989c 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift
@@ -95,31 +95,12 @@ extension ImageEditorViewController {
      * This method needs to be called when text item editing is about to begin.
      */
     private func updateTextViewAttributes(using textItem: ImageEditorTextItem) {
-        let textForegroundColor: UIColor = {
-            switch textItem.decorationStyle {
-            case .none: return textItem.color.color
-            default: return .white
-            }
-        }()
-        let textDecorationColor: UIColor? = {
-            switch textItem.decorationStyle {
-            case .none, .inverted: return nil
-            default: return textItem.color.color
-            }
-        }()
-        textView.updateWith(textForegroundColor: textForegroundColor,
+        textView.updateWith(textForegroundColor: textItem.textForegroundColor,
                             font: textItem.font,
                             textAlignment: .center,
-                            textDecorationColor: textDecorationColor,
+                            textDecorationColor: textItem.textDecorationColor,
                             decorationStyle: textItem.decorationStyle)
-
-        let textBackgroundColor: UIColor = {
-            switch textItem.decorationStyle {
-            case .inverted: return textItem.color.color
-            default: return .clear
-            }
-        }()
-        textViewBackgroundView.backgroundColor = textBackgroundColor
+        textViewBackgroundView.backgroundColor = textItem.textBackgroundColor
     }
 
     // Update UITextView to use style (font, color, decoration) as selected in provided TextToolbar.
diff --git a/SignalUI/Views/MediaTextView.swift b/SignalUI/Views/MediaTextView.swift
index 42f25e70c3f..b2f086c45d8 100644
--- a/SignalUI/Views/MediaTextView.swift
+++ b/SignalUI/Views/MediaTextView.swift
@@ -7,10 +7,11 @@ import UIKit
 public class MediaTextView: UITextView {
 
     public enum DecorationStyle: String, CaseIterable {
-        case none
-        case inverted
-        case underline
-        case outline
+        case none                   // colored text, no background
+        case whiteBackground        // colored text, white background
+        case coloredBackground      // white text, colored background
+        case underline              // white text, colored underline
+        case outline                // white text, colored outline
     }
 
     // Resource names are derived from these values. Do not change without consideration.
@@ -183,19 +184,31 @@ public class TextStylingToolbar: UIControl {
 
     public var textForegroundColor: UIColor {
         switch decorationStyle {
-        case .none: return colorPickerView.color
-        case .inverted, .outline, .underline: return .white
+        case .none, .whiteBackground: return colorPickerView.color
+
+        case .coloredBackground:
+            // Switch text color to black if background is almost white.
+            let backgroundColor = colorPickerView.color
+            return backgroundColor.isCloseToColor(.white) ? .black : .white
+
+        case .outline, .underline: return .white
         }
     }
     public var textBackgroundColor: UIColor? {
         switch decorationStyle {
         case .none, .underline, .outline: return nil
-        case .inverted: return colorPickerView.color
+
+        case .whiteBackground:
+            // Switch background color to black if text color is almost white.
+            let textColor = colorPickerView.color
+            return textColor.isCloseToColor(.white) ? .black : .white
+
+        case .coloredBackground: return colorPickerView.color
         }
     }
     public var textDecorationColor: UIColor? {
         switch decorationStyle {
-        case .none, .inverted: return nil
+        case .none, .whiteBackground, .coloredBackground: return nil
         case .outline, .underline: return colorPickerView.color
         }
     }
@@ -204,15 +217,6 @@ public class TextStylingToolbar: UIControl {
     public var decorationStyle: MediaTextView.DecorationStyle = .none {
         didSet {
             decorationStyleButton.isSelected = (decorationStyle != .none)
-            // Change default decoration style away from white to avoid white on white situation.
-            if decorationStyle != .none && colorPickerView.selectedValue == .white {
-                colorPickerView.selectedValue = .black
-            }
-            // Switch color picker color back to white because it now controls text color.
-            // The idea is that cycling through decoration styles should keep text white.
-            if decorationStyle == .none && colorPickerView.selectedValue == .black {
-                colorPickerView.selectedValue = .white
-            }
         }
     }
 
