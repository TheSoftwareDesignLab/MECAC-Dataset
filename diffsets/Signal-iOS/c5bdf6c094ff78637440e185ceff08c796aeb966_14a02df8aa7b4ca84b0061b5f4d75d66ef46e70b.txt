diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 056d9a34e82..0cfa396e35a 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -1036,6 +1036,7 @@
 		F900F2DD27F25AB400431E09 /* DonationReceiptViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F900F2DC27F25AB300431E09 /* DonationReceiptViewController.swift */; };
 		F9066F0727ECE41B008C9530 /* DonationReceiptsViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9066F0627ECE41B008C9530 /* DonationReceiptsViewController.swift */; };
 		F973DFBA0991C967C4934B08 /* Pods_SignalUITests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = BD0D81F9D93CB5BADE6B9709 /* Pods_SignalUITests.framework */; };
+		F97A2EEA282578C000610669 /* BadgeExpirationSheetStateTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F97A2EE828247C1300610669 /* BadgeExpirationSheetStateTest.swift */; };
 		F9A8ACC7280A175E00AFC6A7 /* DonationViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9A8ACC6280A175E00AFC6A7 /* DonationViewController.swift */; };
 		F9BC0A2527FB8E730085B23D /* AppSettingsViewsUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9BC0A2427FB8E730085B23D /* AppSettingsViewsUtil.swift */; };
 		F9DD70B92811AF82000C5960 /* DonationViewsUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9DD70B82811AF82000C5960 /* DonationViewsUtil.swift */; };
@@ -2421,6 +2422,7 @@
 		F900F2DC27F25AB300431E09 /* DonationReceiptViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationReceiptViewController.swift; sourceTree = "<group>"; };
 		F9066F0627ECE41B008C9530 /* DonationReceiptsViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationReceiptsViewController.swift; sourceTree = "<group>"; };
 		F965C5B87BFDF8F86556C04C /* Pods-SignalNSE.profiling.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalNSE.profiling.xcconfig"; path = "Pods/Target Support Files/Pods-SignalNSE/Pods-SignalNSE.profiling.xcconfig"; sourceTree = "<group>"; };
+		F97A2EE828247C1300610669 /* BadgeExpirationSheetStateTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeExpirationSheetStateTest.swift; sourceTree = "<group>"; };
 		F9A8ACC6280A175E00AFC6A7 /* DonationViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationViewController.swift; sourceTree = "<group>"; };
 		F9BC0A2427FB8E730085B23D /* AppSettingsViewsUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppSettingsViewsUtil.swift; sourceTree = "<group>"; };
 		F9DD70B82811AF82000C5960 /* DonationViewsUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationViewsUtil.swift; sourceTree = "<group>"; };
@@ -3587,6 +3589,7 @@
 		34B3F8951E8DF1B90035BE1A /* ViewControllers */ = {
 			isa = PBXGroup;
 			children = (
+				F97A2EE828247C1300610669 /* BadgeExpirationSheetStateTest.swift */,
 				3463532E256EA525003C5428 /* ConversationViewTest.swift */,
 				4C2A538B23C5462300D28CD8 /* CVMessageMappingTest.swift */,
 				4C6E6C6824241C00009DE948 /* ConversationViewControllerTest.swift */,
@@ -6637,6 +6640,7 @@
 				3485434526BC598800FB9C38 /* EmojiTests.swift in Sources */,
 				458E383A1D6699FA0094BD24 /* OWSDeviceProvisioningURLParserTest.m in Sources */,
 				1704690A25D4C326000793D8 /* SignalAttachmentTest.swift in Sources */,
+				F97A2EEA282578C000610669 /* BadgeExpirationSheetStateTest.swift in Sources */,
 				88D6E94325535D49003142D9 /* CVTextTest.swift in Sources */,
 				3499998222EF1E2100654932 /* GRDBFullTextSearcherTest.swift in Sources */,
 				3471211025ED5F910037CD1F /* PaymentsReconciliationTest.swift in Sources */,
diff --git a/Signal/src/ViewControllers/AppSettings/BadgeExpirationSheet.swift b/Signal/src/ViewControllers/AppSettings/BadgeExpirationSheet.swift
index 958c28774d4..84e65791c3b 100644
--- a/Signal/src/ViewControllers/AppSettings/BadgeExpirationSheet.swift
+++ b/Signal/src/ViewControllers/AppSettings/BadgeExpirationSheet.swift
@@ -7,11 +7,119 @@ import UIKit
 import SignalMessaging
 
 protocol BadgeExpirationSheetDelegate: AnyObject {
-    func badgeExpirationSheetActionButtonTapped(_ badgeExpirationSheet: BadgeExpirationSheet)
-    func badgeExpirationSheetNotNowButtonTapped(_ badgeExpirationSheet: BadgeExpirationSheet)
+    func badgeExpirationSheetActionTapped(_ action: BadgeExpirationSheetAction)
+}
+
+public enum BadgeExpirationSheetAction {
+    case dismiss
+    case openBoostView
+    case openSubscriptionsView
+}
+
+public class BadgeExpirationSheetState {
+    public enum Mode {
+        case subscriptionExpiredBecauseOfChargeFailure
+        case subscriptionExpiredBecauseNotRenewed
+        case boostExpired(hasCurrentSubscription: Bool)
+    }
+
+    public struct Body {
+        public let text: String
+        public let hasLearnMoreLink: Bool
+
+        public init(_ text: String, hasLearnMoreLink: Bool = false) {
+            self.text = text
+            self.hasLearnMoreLink = hasLearnMoreLink
+        }
+    }
+
+    public struct ActionButton {
+        public let action: BadgeExpirationSheetAction
+        public let text: String
+        public let hasNotNow: Bool
+
+        public init(action: BadgeExpirationSheetAction, text: String, hasNotNow: Bool = false) {
+            self.action = action
+            self.text = text
+            self.hasNotNow = hasNotNow
+        }
+    }
+
+    public let badge: ProfileBadge
+    private let mode: Mode
+
+    public init(badge: ProfileBadge, mode: Mode) {
+        self.badge = badge
+        self.mode = mode
+    }
+
+    public lazy var titleText: String = {
+        switch mode {
+        case .subscriptionExpiredBecauseOfChargeFailure, .subscriptionExpiredBecauseNotRenewed:
+            return NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_TITLE",
+                                     comment: "Title for subscription on the badge expiration sheet.")
+        case .boostExpired:
+            return NSLocalizedString("BADGE_EXPIRED_BOOST_TITLE",
+                                     comment: "Title for boost on the badge expiration sheet.")
+        }
+    }()
+
+    public lazy var body: Body = {
+        func format(_ formatText: String) -> String {
+            String(format: formatText, badge.localizedName)
+        }
+
+        switch mode {
+        case .subscriptionExpiredBecauseOfChargeFailure:
+            let formatText = NSLocalizedString("BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_CHARGE_FAILURE_BODY_FORMAT",
+                                               comment: "String explaing to the user that their subscription badge has expired on the badge expiry sheetsheet. Embed {badge name}.")
+            return Body(format(formatText), hasLearnMoreLink: true)
+        case .subscriptionExpiredBecauseNotRenewed:
+            let formatText = NSLocalizedString("BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_INACTIVITY_BODY_FORMAT",
+                                               comment: "Body of the sheet shown when your subscription is canceled due to inactivity")
+            return Body(format(formatText), hasLearnMoreLink: true)
+        case let .boostExpired(hasCurrentSubscription):
+            let formatText: String
+            if hasCurrentSubscription {
+                formatText = NSLocalizedString("BADGE_EXIPRED_BOOST_CURRENT_SUSTAINER_BODY_FORMAT",
+                                               comment: "String explaing to the user that their boost badge has expired while they are a current subscription sustainer on the badge expiry sheetsheet.")
+            } else {
+                formatText = NSLocalizedString("BADGE_EXIPRED_BOOST_BODY_FORMAT",
+                                               comment: "String explaing to the user that their boost badge has expired on the badge expiry sheetsheet.")
+            }
+            return Body(format(formatText))
+        }
+    }()
+
+    public lazy var actionButton: ActionButton = {
+        switch mode {
+        case .subscriptionExpiredBecauseOfChargeFailure:
+            let text = CommonStrings.okayButton
+            return ActionButton(action: .dismiss, text: text)
+        case .subscriptionExpiredBecauseNotRenewed:
+            let text = NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_RENEWAL_BUTTON",
+                                         comment: "Button text when a badge expires, asking you to renew your subscription")
+            return ActionButton(action: .openSubscriptionsView, text: text, hasNotNow: true)
+        case let .boostExpired(hasCurrentSubscription):
+            let action: BadgeExpirationSheetAction
+            let text: String
+            if hasCurrentSubscription {
+                action = .openBoostView
+                text = NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON_SUSTAINER",
+                                         comment: "Button title for boost on the badge expiration sheet, used if the user is already a sustainer.")
+            } else {
+                action = .openSubscriptionsView
+                text = NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON",
+                                         comment: "Button title for boost on the badge expiration sheet, used if the user is not already a sustainer.")
+            }
+            return ActionButton(action: action, text: text, hasNotNow: true)
+        }
+    }()
 }
 
 class BadgeExpirationSheet: InteractiveSheetViewController {
+    private let state: BadgeExpirationSheetState
+
     override var interactiveScrollViews: [UIScrollView] { [tableViewController.tableView] }
     override var sheetBackgroundColor: UIColor { tableViewController.tableBackgroundColor }
     private var shouldMakeVisibleAndPrimary = false
@@ -30,19 +138,9 @@ class BadgeExpirationSheet: InteractiveSheetViewController {
 
     private let tableViewController = OWSTableViewController2()
 
-    private let badge: ProfileBadge
-
-    public var badgeID: String {
-        return badge.id
-    }
-
-    private lazy var isCurrentSustainer = {
-        return SubscriptionManager.hasCurrentSubscriptionWithSneakyTransaction()
-    }()
-
-    required init(badge: ProfileBadge) {
-        owsAssertDebug(badge.assets != nil)
-        self.badge = badge
+    public init(badge: ProfileBadge, mode: BadgeExpirationSheetState.Mode) {
+        self.state = BadgeExpirationSheetState(badge: badge, mode: mode)
+        owsAssertDebug(state.badge.assets != nil)
 
         super.init()
 
@@ -84,60 +182,6 @@ class BadgeExpirationSheet: InteractiveSheetViewController {
         updateTableContents()
     }
 
-    var titleText: String {
-        if BoostBadgeIds.contains(badge.id) {
-            return NSLocalizedString(
-                "BADGE_EXPIRED_BOOST_TITLE",
-                comment: "Title for boost on the badge expiration sheet."
-            )
-        } else {
-            return NSLocalizedString(
-                "BADGE_EXPIRED_SUBSCRIPTION_TITLE",
-                comment: "Title for subscription on the badge expiration sheet."
-            )
-        }
-    }
-
-    var bodyText: String {
-        var formatText: String
-
-        if BoostBadgeIds.contains(badge.id) {
-            if isCurrentSustainer {
-                formatText = NSLocalizedString(
-                    "BADGE_EXIPRED_BOOST_CURRENT_SUSTAINER_BODY_FORMAT",
-                    comment: "String explaing to the user that their boost badge has expired while they are a current subscription sustainer on the badge expiry sheetsheet."
-                )
-            } else {
-                formatText = NSLocalizedString(
-                    "BADGE_EXIPRED_BOOST_BODY_FORMAT",
-                    comment: "String explaing to the user that their boost badge has expired on the badge expiry sheetsheet."
-                )
-            }
-        } else {
-            formatText = NSLocalizedString(
-                "BADGE_EXIPRED_SUBSCRIPTION_BODY_FORMAT",
-                comment: "String explaing to the user that their subscription badge has expired on the badge expiry sheetsheet. Embed {badge name}."
-            )
-        }
-
-        return String(format: formatText, badge.localizedName)
-    }
-
-    var actionButtonText: String {
-        if BoostBadgeIds.contains(badge.id) {
-            if isCurrentSustainer {
-                return NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON_SUSTAINER",
-                                         comment: "Button title for boost on the badge expiration sheet, used if the user is already a sustainer.")
-            } else {
-                return NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON",
-                                         comment: "Button title for boost on the badge expiration sheet, used if the user is not already a sustainer.")
-            }
-        } else {
-            return NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_RENEWAL_BUTTON",
-                                     comment: "Button title for subscription on the badge expiration sheet.")
-        }
-    }
-
     private func updateTableContents() {
         let contents = OWSTableContents()
         defer { tableViewController.contents = contents }
@@ -162,7 +206,7 @@ class BadgeExpirationSheet: InteractiveSheetViewController {
             stackView.autoPinEdgesToSuperviewEdges()
 
             let badgeImageView = UIImageView()
-            badgeImageView.image = self.badge.assets?.universal112
+            badgeImageView.image = self.state.badge.assets?.universal112
             badgeImageView.autoSetDimensions(to: CGSize(square: 112))
             stackView.addArrangedSubview(badgeImageView)
             stackView.setCustomSpacing(16, after: badgeImageView)
@@ -172,16 +216,34 @@ class BadgeExpirationSheet: InteractiveSheetViewController {
             titleLabel.textColor = Theme.primaryTextColor
             titleLabel.textAlignment = .center
             titleLabel.numberOfLines = 0
-            titleLabel.text = self.titleText
+            titleLabel.text = self.state.titleText
             stackView.addArrangedSubview(titleLabel)
             stackView.setCustomSpacing(12, after: titleLabel)
 
-            let bodyLabel = UILabel()
-            bodyLabel.font = .ows_dynamicTypeBody
-            bodyLabel.textColor = Theme.primaryTextColor
-            bodyLabel.textAlignment = .center
-            bodyLabel.numberOfLines = 0
-            bodyLabel.text = self.bodyText
+            let bodyLabel: UIView
+            if self.state.body.hasLearnMoreLink {
+                let learnMore = NSLocalizedString(
+                    "BADGE_EXPIRED_LEARN_MORE_LINK",
+                    comment: "Text for the 'learn more' link in the badge expiration sheet, shown when a badge expires due to a charge failure"
+                ).styled(with: .link(SupportConstants.badgeExpirationLearnMoreURL))
+                let label = LinkingTextView()
+                label.attributedText = .composed(of: [self.state.body.text, " ", learnMore]).styled(with: .color(Theme.primaryTextColor), .font(.ows_dynamicTypeBody))
+                label.textAlignment = .center
+                label.linkTextAttributes = [
+                    .foregroundColor: Theme.accentBlueColor,
+                    .underlineColor: UIColor.clear,
+                    .underlineStyle: NSUnderlineStyle.single.rawValue
+                ]
+                bodyLabel = label
+            } else {
+                let label = UILabel()
+                label.font = .ows_dynamicTypeBody
+                label.textColor = Theme.primaryTextColor
+                label.numberOfLines = 0
+                label.text = self.state.body.text
+                label.textAlignment = .center
+                bodyLabel = label
+            }
             stackView.addArrangedSubview(bodyLabel)
             stackView.setCustomSpacing(30, after: bodyLabel)
 
@@ -199,13 +261,13 @@ class BadgeExpirationSheet: InteractiveSheetViewController {
             let stackView = UIStackView()
             stackView.axis = .vertical
             stackView.alignment = .center
-            stackView.layoutMargins = UIEdgeInsets(top: 30, left: 24, bottom: 0, right: 24)
+            stackView.layoutMargins = UIEdgeInsets(top: 30, left: 24, bottom: 30, right: 24)
             stackView.spacing = 16
             stackView.isLayoutMarginsRelativeArrangement = true
             cell.contentView.addSubview(stackView)
             stackView.autoPinEdgesToSuperviewEdges()
 
-            let actionButton = OWSFlatButton.button(title: self.actionButtonText,
+            let actionButton = OWSFlatButton.button(title: self.state.actionButton.text,
                                                     font: UIFont.ows_dynamicTypeBody.ows_semibold,
                                                     titleColor: .white,
                                                     backgroundColor: .ows_accentBlue,
@@ -216,33 +278,33 @@ class BadgeExpirationSheet: InteractiveSheetViewController {
             stackView.addArrangedSubview(actionButton)
             actionButton.autoPinWidthToSuperviewMargins()
 
-            let notNowButton = OWSButton(title: CommonStrings.notNowButton) { [weak self] in
-                guard let self = self else { return }
-                self.didTapNotNow()
+            if self.state.actionButton.hasNotNow {
+                let notNowButton = OWSButton(title: CommonStrings.notNowButton) { [weak self] in
+                    guard let self = self else { return }
+                    self.didDismiss()
+                }
+                notNowButton.setTitleColor(Theme.accentBlueColor, for: .normal)
+                notNowButton.dimsWhenHighlighted = true
+                stackView.addArrangedSubview(notNowButton)
             }
-            notNowButton.setTitleColor(Theme.accentBlueColor, for: .normal)
-            notNowButton.dimsWhenHighlighted = true
-            stackView.addArrangedSubview(notNowButton)
 
             return cell
         }, actionBlock: nil))
     }
 
     public override func willDismissInteractively() {
-        didTapNotNow()
+        didDismiss()
         super.willDismissInteractively()
     }
 
     @objc
     func didTapAction() {
-        if let delegate = delegate {
-            dismiss(animated: true, completion: nil)
-            delegate.badgeExpirationSheetActionButtonTapped(self)
-        }
+        didDismiss()
+        delegate?.badgeExpirationSheetActionTapped(state.actionButton.action)
     }
 
     @objc
-    func didTapNotNow() {
+    func didDismiss() {
         dismiss(animated: true, completion: nil)
     }
 }
diff --git a/Signal/src/ViewControllers/AppSettings/ContactSupportViewController.swift b/Signal/src/ViewControllers/AppSettings/ContactSupportViewController.swift
index 2896ec8f81b..094caf76e24 100644
--- a/Signal/src/ViewControllers/AppSettings/ContactSupportViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/ContactSupportViewController.swift
@@ -11,6 +11,7 @@ import SafariServices
     static let debugLogsInfoURL = URL(string: "https://support.signal.org/hc/articles/360007318591")!
     static let supportEmail = "support@signal.org"
     static let subscriptionFAQURL = URL(string: "https://support.signal.org/hc/articles/4408365318426")!
+    static let badgeExpirationLearnMoreURL = URL(string: "https://support.signal.org/hc/articles/360031949872#fix")!
 }
 
 enum ContactSupportFilter: String, CaseIterable {
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift
index 427295f901d..c3e8beee3b8 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
@@ -80,23 +80,36 @@ public extension ChatListViewController {
     // MARK: -
 
     func showBadgeExpirationSheetIfNeeded() {
+        Logger.info("[Subscriptions] Checking whether we should show badge expiration sheet...")
+
         guard !hasShownBadgeExpiration else { // Do this once per launch
+            Logger.info("[Subscriptions] Not showing badge expiration sheet, because we've already done so")
             return
         }
 
-        let expiredBadgeID = SubscriptionManager.mostRecentlyExpiredBadgeIDWithSneakyTransaction()
+        let (
+            expiredBadgeID,
+            shouldShowExpirySheet,
+            doesMostRecentSubscriptionBadgeHaveChargeFailure,
+            hasCurrentSubscription
+        ) = databaseStorage.read { transaction in (
+            SubscriptionManager.mostRecentlyExpiredBadgeID(transaction: transaction),
+            SubscriptionManager.showExpirySheetOnHomeScreenKey(transaction: transaction),
+            SubscriptionManager.doesMostRecentSubscriptionBadgeHaveChargeFailure(transaction: transaction),
+            subscriptionManager.hasCurrentSubscription(transaction: transaction)
+        )}
+
         guard let expiredBadgeID = expiredBadgeID else {
-            Logger.info("No expired badgeIDs, not showing sheet")
+            Logger.info("[Subscriptions] No expired badge ID, not showing sheet")
             return
         }
 
-        let shouldShow = databaseStorage.read { transaction in
-            SubscriptionManager.showExpirySheetOnHomeScreenKey(transaction: transaction)
+        guard shouldShowExpirySheet else {
+            Logger.info("[Subscriptions] Not showing badge expiration sheet because the flag is off")
+            return
         }
 
-        guard shouldShow else { return }
-
-        Logger.info("showing expiry sheet for badge \(expiredBadgeID)")
+        Logger.info("[Subscriptions] showing expiry sheet for badge \(expiredBadgeID)")
 
         if BoostBadgeIds.contains(expiredBadgeID) {
             firstly {
@@ -109,7 +122,8 @@ public extension ChatListViewController {
                     guard UIApplication.shared.frontmostViewController == self.conversationSplitViewController,
                           self.conversationSplitViewController?.selectedThread == nil else { return }
 
-                    let badgeSheet = BadgeExpirationSheet(badge: boostBadge)
+                    let badgeSheet = BadgeExpirationSheet(badge: boostBadge,
+                                                          mode: .boostExpired(hasCurrentSubscription: hasCurrentSubscription))
                     badgeSheet.delegate = self
                     self.present(badgeSheet, animated: true)
                     self.hasShownBadgeExpiration = true
@@ -140,7 +154,8 @@ public extension ChatListViewController {
                     guard UIApplication.shared.frontmostViewController == self.conversationSplitViewController,
                           self.conversationSplitViewController?.selectedThread == nil else { return }
 
-                    let badgeSheet = BadgeExpirationSheet(badge: subscriptionLevel.badge)
+                    let badgeSheet = BadgeExpirationSheet(badge: subscriptionLevel.badge,
+                                                          mode: doesMostRecentSubscriptionBadgeHaveChargeFailure ? .subscriptionExpiredBecauseOfChargeFailure : .subscriptionExpiredBecauseNotRenewed)
                     badgeSheet.delegate = self
                     self.present(badgeSheet, animated: true)
                     self.hasShownBadgeExpiration = true
@@ -418,16 +433,16 @@ public extension ChatListViewController {
 }
 
 extension ChatListViewController: BadgeExpirationSheetDelegate {
-    func badgeExpirationSheetActionButtonTapped(_ badgeExpirationSheet: BadgeExpirationSheet) {
-        SubscriptionManager.clearMostRecentlyExpiredBadgeIDWithSneakyTransaction()
-        if BoostBadgeIds.contains(badgeExpirationSheet.badgeID), SubscriptionManager.hasCurrentSubscriptionWithSneakyTransaction() {
+    func badgeExpirationSheetActionTapped(_ action: BadgeExpirationSheetAction) {
+        switch action {
+        case .dismiss:
+            break
+        case .openBoostView:
             showAppSettings(mode: .boost)
-        } else {
+        case .openSubscriptionsView:
             showAppSettings(mode: .subscriptions)
         }
     }
-
-    func badgeExpirationSheetNotNowButtonTapped(_ badgeExpirationSheet: BadgeExpirationSheet) { }
 }
 
 extension ChatListViewController: ThreadSwipeHandler {
diff --git a/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift b/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift
new file mode 100644
index 00000000000..32667b31e7d
--- /dev/null
+++ b/Signal/test/ViewControllers/BadgeExpirationSheetStateTest.swift
@@ -0,0 +1,149 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import XCTest
+import Foundation
+import Signal
+
+class BadgeExpirationSheetStateTest: XCTestCase {
+    private func getBoostBadge(populateAssets: Bool = true) -> ProfileBadge {
+        let result = try! ProfileBadge(jsonDictionary: [
+            "id": "BOOST",
+            "category": "donor",
+            "name": "A Boost",
+            "description": "A boost badge!",
+            "sprites6": ["ldpi.png", "mdpi.png", "hdpi.png", "xhdpi.png", "xxhdpi.png", "xxxhdpi.png"]
+        ])
+        if populateAssets {
+            result._testingOnly_populateAssets()
+        }
+        return result
+    }
+
+    private func getSubscriptionBadge(populateAssets: Bool = true) -> ProfileBadge {
+        let result = try! ProfileBadge(jsonDictionary: [
+            "id": "R_MED",
+            "category": "donor",
+            "name": "Subscriber X",
+            "description": "A subscriber badge!",
+            "sprites6": ["ldpi.png", "mdpi.png", "hdpi.png", "xhdpi.png", "xxhdpi.png", "xxxhdpi.png"]
+        ])
+        if populateAssets {
+            result._testingOnly_populateAssets()
+        }
+        return result
+    }
+
+    func testBadge() throws {
+        let badge = getSubscriptionBadge()
+        let state = BadgeExpirationSheetState(badge: badge, mode: .subscriptionExpiredBecauseNotRenewed)
+        XCTAssertIdentical(state.badge, badge)
+    }
+
+    func testTitleText() throws {
+        let testCases: [(BadgeExpirationSheetState, String)] = [
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .subscriptionExpiredBecauseOfChargeFailure),
+                NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_TITLE",
+                                  comment: "Title for subscription on the badge expiration sheet.")
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .subscriptionExpiredBecauseNotRenewed),
+                NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_TITLE",
+                                  comment: "Title for subscription on the badge expiration sheet.")
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .boostExpired(hasCurrentSubscription: true)),
+                NSLocalizedString("BADGE_EXPIRED_BOOST_TITLE",
+                                  comment: "Title for boost on the badge expiration sheet.")
+            )
+        ]
+
+        for (state, expected) in testCases {
+            XCTAssertEqual(state.titleText, expected)
+        }
+    }
+
+    func testBody() throws {
+        let testCases: [(BadgeExpirationSheetState, String, Bool)] = [
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .subscriptionExpiredBecauseOfChargeFailure),
+                NSLocalizedString("BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_CHARGE_FAILURE_BODY_FORMAT",
+                                  comment: "String explaing to the user that their subscription badge has expired on the badge expiry sheetsheet. Embed {badge name}."),
+                true
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .subscriptionExpiredBecauseNotRenewed),
+                NSLocalizedString("BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_INACTIVITY_BODY_FORMAT",
+                                  comment: "Body of the sheet shown when your subscription is canceled due to inactivity"),
+                true
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .boostExpired(hasCurrentSubscription: false)),
+                NSLocalizedString("BADGE_EXIPRED_BOOST_BODY_FORMAT",
+                                  comment: "String explaing to the user that their boost badge has expired on the badge expiry sheetsheet."),
+                false
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .boostExpired(hasCurrentSubscription: true)),
+                NSLocalizedString("BADGE_EXIPRED_BOOST_CURRENT_SUSTAINER_BODY_FORMAT",
+                                  comment: "String explaing to the user that their boost badge has expired while they are a current subscription sustainer on the badge expiry sheetsheet."),
+                false
+            )
+        ]
+
+        for (state, expectedFormat, expectedHasLearnMore) in testCases {
+            let body = state.body
+            XCTAssertEqual(body.text, String(format: expectedFormat, state.badge.localizedName))
+            XCTAssertEqual(body.hasLearnMoreLink, expectedHasLearnMore)
+        }
+    }
+
+    func testActionButton() throws {
+        let testCases: [(BadgeExpirationSheetState, BadgeExpirationSheetState.ActionButton)] = [
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .subscriptionExpiredBecauseOfChargeFailure),
+                BadgeExpirationSheetState.ActionButton(action: .dismiss, text: CommonStrings.okayButton, hasNotNow: false)
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .subscriptionExpiredBecauseNotRenewed),
+                BadgeExpirationSheetState.ActionButton(action: .openSubscriptionsView,
+                                                    text: NSLocalizedString("BADGE_EXPIRED_SUBSCRIPTION_RENEWAL_BUTTON",
+                                                                            comment: "Button text when a badge expires, asking you to renew your subscription"),
+                                                    hasNotNow: true)
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .boostExpired(hasCurrentSubscription: false)),
+                BadgeExpirationSheetState.ActionButton(action: .openSubscriptionsView,
+                                                    text: NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON",
+                                                                            comment: "Button title for boost on the badge expiration sheet, used if the user is not already a sustainer."),
+                                                    hasNotNow: true)
+            ),
+            (
+                BadgeExpirationSheetState(badge: getSubscriptionBadge(),
+                                          mode: .boostExpired(hasCurrentSubscription: true)),
+                BadgeExpirationSheetState.ActionButton(action: .openBoostView,
+                                                    text: NSLocalizedString("BADGE_EXPIRED_BOOST_RENEWAL_BUTTON_SUSTAINER",
+                                                                            comment: "Button title for boost on the badge expiration sheet, used if the user is already a sustainer."),
+                                                    hasNotNow: true)
+            )
+        ]
+
+        for (state, expectedActionButton) in testCases {
+            XCTAssertEqual(state.actionButton.action, expectedActionButton.action)
+            XCTAssertEqual(state.actionButton.text, expectedActionButton.text)
+            XCTAssertEqual(state.actionButton.hasNotNow, expectedActionButton.hasNotNow)
+        }
+    }
+}
diff --git a/Signal/test/subscriptions/SubscriptionManagerTest.swift b/Signal/test/subscriptions/SubscriptionManagerTest.swift
index 7384ad76cb5..5782187fad9 100644
--- a/Signal/test/subscriptions/SubscriptionManagerTest.swift
+++ b/Signal/test/subscriptions/SubscriptionManagerTest.swift
@@ -19,26 +19,47 @@ class SubscriptionTest: XCTestCase {
             "status": "active"
         ]
     }()
+    let chargeFailureDictionary: [String: Any] = ["code": "foo"]
 
     func testJsonInit() throws {
-        let subscription = try Subscription(jsonDictionary: subscriptionJsonDictionary)
+        let subscription = try Subscription(jsonDictionary: subscriptionJsonDictionary,
+                                            chargeFailureValue: nil)
 
         XCTAssertEqual(subscription.level, 123)
         XCTAssertEqual(subscription.currency, "USD")
         XCTAssertEqual(subscription.amount, 500)
         XCTAssertEqual(subscription.endOfCurrentPeriod, 1618881836)
         XCTAssertEqual(subscription.billingCycleAnchor, 1587345836)
-        XCTAssert(subscription.active)
-        XCTAssert(!subscription.cancelAtEndOfPeriod)
+        XCTAssertTrue(subscription.active)
+        XCTAssertFalse(subscription.cancelAtEndOfPeriod)
         XCTAssertEqual(subscription.status, .active)
+        XCTAssertFalse(subscription.hasChargeFailure)
     }
 
     func testJsonInitWithUnexpectedStatus() throws {
         var jsonDictionaryWithUnexpectedStatus = subscriptionJsonDictionary
         jsonDictionaryWithUnexpectedStatus["status"] = "unexpected!!"
 
-        let subscription = try Subscription(jsonDictionary: jsonDictionaryWithUnexpectedStatus)
+        let subscription = try Subscription(jsonDictionary: jsonDictionaryWithUnexpectedStatus,
+                                            chargeFailureValue: nil)
 
         XCTAssertEqual(subscription.status, .unknown)
+        XCTAssertFalse(subscription.hasChargeFailure)
+    }
+
+    func testChargeFailure() throws {
+        let indicatesFailure: [Any] = [chargeFailureDictionary, 0, 123, true]
+        for chargeFailureValue in indicatesFailure {
+            let subscription = try Subscription(jsonDictionary: subscriptionJsonDictionary,
+                                                chargeFailureValue: chargeFailureValue)
+            XCTAssertTrue(subscription.hasChargeFailure)
+        }
+
+        let indicatesNoFailure: [Any?] = [nil, false]
+        for chargeFailureValue in indicatesNoFailure {
+            let subscription = try Subscription(jsonDictionary: subscriptionJsonDictionary,
+                                                chargeFailureValue: chargeFailureValue)
+            XCTAssertFalse(subscription.hasChargeFailure)
+        }
     }
 }
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 4bf0ca4dd14..07bc5e06e67 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -373,9 +373,6 @@
 /* String explaing to the user that their boost badge has expired while they are a current subscription sustainer on the badge expiry sheetsheet. */
 "BADGE_EXIPRED_BOOST_CURRENT_SUSTAINER_BODY_FORMAT" = "Your Boost badge has expired, and is no longer visible on your profile.\n\nYou can reactivate your Boost badge for another 30 days with a one-time contribution.";
 
-/* String explaing to the user that their subscription badge has expired on the badge expiry sheetsheet. Embed {badge name}. */
-"BADGE_EXIPRED_SUBSCRIPTION_BODY_FORMAT" = "Your recurring monthly donation was automatically cancelled because you were inactive for too long. Your %@ badge is no longer visible on your profile.\n\nYou can keep using Signal but to support the app and reactivate your badge, renew now.";
-
 /* Button title for boost on the badge expiration sheet, used if the user is not already a sustainer. */
 "BADGE_EXPIRED_BOOST_RENEWAL_BUTTON" = "Become a Sustainer";
 
@@ -385,12 +382,21 @@
 /* Title for boost on the badge expiration sheet. */
 "BADGE_EXPIRED_BOOST_TITLE" = "Badge Expired";
 
-/* Button title for subscription on the badge expiration sheet. */
+/* Text for the 'learn more' link in the badge expiration sheet, shown when a badge expires due to a charge failure */
+"BADGE_EXPIRED_LEARN_MORE_LINK" = "Learn more.";
+
+/* Button text when a badge expires, asking you to renew your subscription */
 "BADGE_EXPIRED_SUBSCRIPTION_RENEWAL_BUTTON" = "Renew Subscription";
 
 /* Title for subscription on the badge expiration sheet. */
 "BADGE_EXPIRED_SUBSCRIPTION_TITLE" = "Monthly Donation Cancelled";
 
+/* String explaing to the user that their subscription badge has expired on the badge expiry sheetsheet. Embed {badge name}. */
+"BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_CHARGE_FAILURE_BODY_FORMAT" = "Your recurring monthly donation was automatically cancelled because we couldnâ€™t process your payment. Your badge is no longer visible on your profile.\n\nTo continue supporting Signal and to reactivate your badge, update your payment method in Apple Pay and subscribe again.";
+
+/* Body of the sheet shown when your subscription is canceled due to inactivity */
+"BADGE_SUBSCRIPTION_EXPIRED_BECAUSE_OF_INACTIVITY_BODY_FORMAT" = "Your recurring monthly donation was automatically cancelled because you were inactive for too long. Your %@ badge is no longer visible on your profile.\n\nYou can keep using Signal but to support the app and reactivate your badge, renew now.";
+
 /* Title for boost on the thank you sheet. */
 "BADGE_THANKS_BOOST_TITLE" = "Thanks for the Boost!";
 
diff --git a/SignalMessaging/Subscriptions/SubscriptionManager.swift b/SignalMessaging/Subscriptions/SubscriptionManager.swift
index 588cc0856fe..73420505269 100644
--- a/SignalMessaging/Subscriptions/SubscriptionManager.swift
+++ b/SignalMessaging/Subscriptions/SubscriptionManager.swift
@@ -88,8 +88,9 @@ public struct Subscription {
     public let active: Bool
     public let cancelAtEndOfPeriod: Bool
     public let status: StripeSubscriptionStatus
+    public let hasChargeFailure: Bool
 
-    public init(jsonDictionary: [String: Any]) throws {
+    public init(jsonDictionary: [String: Any], chargeFailureValue: Any?) throws {
         let params = ParamParser(dictionary: jsonDictionary)
         level = try params.required(key: "level")
         currency = try params.required(key: "currency")
@@ -100,6 +101,12 @@ public struct Subscription {
         active = try params.required(key: "active")
         cancelAtEndOfPeriod = try params.required(key: "cancelAtPeriodEnd")
         status = StripeSubscriptionStatus(rawValue: try params.required(key: "status")) ?? .unknown
+        hasChargeFailure = !Self.isNilOrFalse(chargeFailureValue)
+    }
+
+    private static func isNilOrFalse(_ value: Any?) -> Bool {
+        if let value = value as? Bool { return value == false }
+        return value == nil
     }
 }
 
@@ -167,6 +174,7 @@ public class SubscriptionManager: NSObject {
     fileprivate static let knownUserBoostBadgeIDsKey = "knownUserBoostBadgeIDsKey"
     fileprivate static let mostRecentlyExpiredBadgeIDKey = "mostRecentlyExpiredBadgeIDKey"
     fileprivate static let showExpirySheetOnHomeScreenKey = "showExpirySheetOnHomeScreenKey"
+    fileprivate static let doesMostRecentSubscriptionBadgeHaveChargeFailureKey = "doesMostRecentSubscriptionBadgeHaveChargeFailure"
     fileprivate static let hasMigratedToStorageServiceKey = "hasMigratedToStorageServiceKey"
 
     public static var terminateTransactionIfPossible = false
@@ -248,7 +256,8 @@ public class SubscriptionManager: NSObject {
                     return nil
                 }
 
-                return try Subscription(jsonDictionary: subscriptionDict)
+                return try Subscription(jsonDictionary: subscriptionDict,
+                                        chargeFailureValue: try? parser.optional(key: "chargeFailure"))
             } else {
                 return nil
             }
@@ -345,6 +354,10 @@ public class SubscriptionManager: NSObject {
                 throw OWSGenericError("Transaction chain cancelled")
             }
 
+            databaseStorage.write {
+                Self.setMostRecentSubscriptionBadgeHasChargeFailure(hasChargeFailure: false, transaction: $0)
+            }
+
             return setSubscription(for: generatedSubscriberID, subscription: subscription, currency: currencyCode)
 
         // Report success and dismiss sheet
@@ -726,6 +739,16 @@ public class SubscriptionManager: NSObject {
                 return
             }
 
+            if subscription.hasChargeFailure {
+                Logger.info("[Subscriptions] There was a charge failure. Setting status to failed")
+            } else {
+                Logger.info("[Subscriptions] There no charge failure. Clearing failed status, if it existed")
+            }
+            databaseStorage.write {
+                self.setMostRecentSubscriptionBadgeHasChargeFailure(hasChargeFailure: subscription.hasChargeFailure,
+                                                                    transaction: $0)
+            }
+
             if let lastSubscriptionExpiration = lastSubscriptionExpiration, lastSubscriptionExpiration.timeIntervalSince1970 < subscription.endOfCurrentPeriod {
                 // Re-kick
                 let newDate = Date(timeIntervalSince1970: subscription.endOfCurrentPeriod)
@@ -736,7 +759,6 @@ public class SubscriptionManager: NSObject {
                 databaseStorage.write { transaction in
                     self.setLastSubscriptionExpirationDate(Date(timeIntervalSince1970: subscription.endOfCurrentPeriod), transaction: transaction)
                 }
-
             } else {
                 Logger.info("[Subscriptions] Not triggering receipt redemption, expiration date is the same")
             }
@@ -941,6 +963,13 @@ extension SubscriptionManager {
         return subscriptionKVS.getBool(showExpirySheetOnHomeScreenKey, transaction: transaction) ?? false
     }
 
+    public static func doesMostRecentSubscriptionBadgeHaveChargeFailure(transaction: SDSAnyReadTransaction) -> Bool {
+        subscriptionKVS.getBool(doesMostRecentSubscriptionBadgeHaveChargeFailureKey, transaction: transaction) ?? false
+    }
+
+    public static func setMostRecentSubscriptionBadgeHasChargeFailure(hasChargeFailure: Bool, transaction: SDSAnyWriteTransaction) {
+        subscriptionKVS.setBool(hasChargeFailure, key: doesMostRecentSubscriptionBadgeHaveChargeFailureKey, transaction: transaction)
+    }
 }
 
 @objc
diff --git a/SignalServiceKit/src/Util/Profiles/BadgeStore.swift b/SignalServiceKit/src/Util/Profiles/BadgeStore.swift
index 58af4c74860..1ad6ebd3c77 100644
--- a/SignalServiceKit/src/Util/Profiles/BadgeStore.swift
+++ b/SignalServiceKit/src/Util/Profiles/BadgeStore.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -129,6 +129,18 @@ extension ProfileBadge {
     }
 }
 
+// MARK: - ProfileBadge fake assets
+
+#if TESTABLE_BUILD
+extension ProfileBadge {
+    public func _testingOnly_populateAssets() {
+        assets = BadgeAssets(scale: badgeVariant.intendedScale,
+                             remoteSourceUrl: remoteAssetUrl,
+                             localAssetDirectory: localAssetDir)
+    }
+}
+#endif
+
 // MARK: - ProfileBadge<PersistableRecord>
 
 extension ProfileBadge: FetchableRecord, PersistableRecord {
