diff --git a/SignalServiceKit/Backups/Attachments/AttachmentOffloadingManager.swift b/SignalServiceKit/Backups/Attachments/AttachmentOffloadingManager.swift
index 15947d1c9fa..5b90ea06443 100644
--- a/SignalServiceKit/Backups/Attachments/AttachmentOffloadingManager.swift
+++ b/SignalServiceKit/Backups/Attachments/AttachmentOffloadingManager.swift
@@ -50,6 +50,10 @@ extension Attachment {
             mediaTierInfo.isUploaded(currentUploadEra: currentUploadEra)
         else {
             // Don't offload until we've backed up to media tier.
+            // Note that attachments that are ineligible for media tier upload
+            // (some DMs, view-once, oversized text) won't be uploaded and therefore
+            // won't pass this check. We don't need to also check for "eligibility"
+            // here and can just rely on upload mechanisms to have checked that.
             return false
         }
         if
diff --git a/SignalServiceKit/Backups/Attachments/BackupAttachmentUploadScheduler.swift b/SignalServiceKit/Backups/Attachments/BackupAttachmentUploadScheduler.swift
index a91855fce06..50258dc3236 100644
--- a/SignalServiceKit/Backups/Attachments/BackupAttachmentUploadScheduler.swift
+++ b/SignalServiceKit/Backups/Attachments/BackupAttachmentUploadScheduler.swift
@@ -179,6 +179,10 @@ public class BackupAttachmentUploadSchedulerImpl: BackupAttachmentUploadSchedule
             return
         }
 
+        // We only include the provided owner because this is an incremental check;
+        // if some other owner made the attachment eligible for upload, it'd already
+        // be enqueued. We only care if this particular owner makes it newly eligible
+        // (or it was eligible both before and now, but the enqueuing it idempotent).
         guard let uploadOwnerType = self.asEligibleUploadOwnerType(owner, tx: tx) else {
             return
         }
@@ -232,6 +236,20 @@ public class BackupAttachmentUploadSchedulerImpl: BackupAttachmentUploadSchedule
     ) -> QueuedBackupAttachmentUpload.OwnerType? {
         switch owner {
         case .message(let messageSource):
+            switch messageSource.rawMessageOwnerType {
+            case .oversizeText:
+                // We inline oversize text in the backup, and don't back
+                // up the corresponding attachment.
+                return nil
+            case
+                    .bodyAttachment,
+                    .contactAvatar,
+                    .linkPreview,
+                    .quotedReplyAttachment,
+                    .sticker:
+                break
+            }
+
             guard
                 let message = interactionStore.fetchInteraction(
                     rowId: messageSource.messageRowId,
