diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 5f0cd150f8f..b17b68e0659 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -879,6 +879,7 @@
 		665CBD052BADC87A0059EA4F /* DraftQuotedReplyModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665CBD042BADC87A0059EA4F /* DraftQuotedReplyModel.swift */; };
 		665CBD072BAE259A0059EA4F /* StoryMessageTSAttachmentReference.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665CBD062BAE259A0059EA4F /* StoryMessageTSAttachmentReference.swift */; };
 		665CC7C52BF2BF8100E3A00B /* AVAsset+TSAttachment.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665CC7C42BF2BF8100E3A00B /* AVAsset+TSAttachment.swift */; };
+		665D9B452C111C6D00E73E94 /* AttachmentMultisend+OversizeText.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665D9B442C111C6D00E73E94 /* AttachmentMultisend+OversizeText.swift */; };
 		665EF86D290C385B00F490D2 /* OWSNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665EF86C290C385B00F490D2 /* OWSNavigationController.swift */; };
 		665FAE8C2A02C0D400FA298D /* SpoilerRevealState.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665FAE8B2A02C0D400FA298D /* SpoilerRevealState.swift */; };
 		6660725E2BAB36960084B3D2 /* AttachmentDataSource.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6660725D2BAB36960084B3D2 /* AttachmentDataSource.swift */; };
@@ -3797,6 +3798,7 @@
 		665CBD042BADC87A0059EA4F /* DraftQuotedReplyModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DraftQuotedReplyModel.swift; sourceTree = "<group>"; };
 		665CBD062BAE259A0059EA4F /* StoryMessageTSAttachmentReference.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryMessageTSAttachmentReference.swift; sourceTree = "<group>"; };
 		665CC7C42BF2BF8100E3A00B /* AVAsset+TSAttachment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AVAsset+TSAttachment.swift"; sourceTree = "<group>"; };
+		665D9B442C111C6D00E73E94 /* AttachmentMultisend+OversizeText.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AttachmentMultisend+OversizeText.swift"; sourceTree = "<group>"; };
 		665EF86C290C385B00F490D2 /* OWSNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSNavigationController.swift; sourceTree = "<group>"; };
 		665FAE8B2A02C0D400FA298D /* SpoilerRevealState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SpoilerRevealState.swift; sourceTree = "<group>"; };
 		6660725D2BAB36960084B3D2 /* AttachmentDataSource.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttachmentDataSource.swift; sourceTree = "<group>"; };
@@ -8570,6 +8572,7 @@
 			isa = PBXGroup;
 			children = (
 				663A18A12BCDDC10005C1B41 /* TSResource */,
+				665D9B442C111C6D00E73E94 /* AttachmentMultisend+OversizeText.swift */,
 				661566712BCEDD58003F1647 /* AttachmentMultisend.swift */,
 			);
 			path = AttachmentMultisend;
@@ -12447,6 +12450,7 @@
 				763D7DDD27E25DC8002EA7E6 /* AttachmentApprovalTopBar.swift in Sources */,
 				3402AA4A271D9DCD0084CBAE /* AttachmentApprovalViewController.swift in Sources */,
 				3402AA34271D9DCD0084CBAE /* AttachmentItemCollection.swift in Sources */,
+				665D9B452C111C6D00E73E94 /* AttachmentMultisend+OversizeText.swift in Sources */,
 				661566722BCEDD58003F1647 /* AttachmentMultisend.swift in Sources */,
 				3402AA3D271D9DCD0084CBAE /* AttachmentPrepViewController.swift in Sources */,
 				66FF4D302BE2FA3400106033 /* AttachmentSharing+TSResource.swift in Sources */,
diff --git a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManager.swift b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManager.swift
index 5cf0ac08b72..4254d76114c 100644
--- a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManager.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManager.swift
@@ -61,7 +61,7 @@ public protocol TSResourceManager {
     ) throws
 
     func createOversizeTextAttachmentStream(
-        consuming dataSource: DataSource,
+        consuming dataSource: OversizeTextDataSource,
         message: TSMessage,
         tx: DBWriteTransaction
     ) throws
diff --git a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerImpl.swift b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerImpl.swift
index c657ce1124f..1e3a647bfcd 100644
--- a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerImpl.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerImpl.swift
@@ -109,24 +109,11 @@ public class TSResourceManagerImpl: TSResourceManager {
     }
 
     public func createOversizeTextAttachmentStream(
-        consuming dataSource: DataSource,
+        consuming dataSource: OversizeTextDataSource,
         message: TSMessage,
         tx: DBWriteTransaction
     ) throws {
-        let wrappedDataSource = TSResourceDataSource.from(
-            dataSource: dataSource,
-            mimeType: MimeType.textXSignalPlain.rawValue,
-            caption: nil,
-            renderingFlag: .default
-        )
-        switch wrappedDataSource.concreteType {
-        case .legacy(let legacyDataSource):
-            try tsAttachmentManager.createBodyAttachmentStreams(
-                consuming: [legacyDataSource],
-                message: message,
-                tx: SDSDB.shimOnlyBridge(tx)
-            )
-        case .v2(let attachmentDataSource, _):
+        if FeatureFlags.newAttachmentsUseV2, let attachmentDataSource = dataSource.v2DataSource {
             guard let messageRowId = message.sqliteRowId else {
                 owsFailDebug("Adding attachments to an uninserted message!")
                 return
@@ -146,6 +133,12 @@ public class TSResourceManagerImpl: TSResourceManager {
                 ),
                 tx: tx
             )
+        } else {
+            try tsAttachmentManager.createBodyAttachmentStreams(
+                consuming: [dataSource.legacyDataSource],
+                message: message,
+                tx: SDSDB.shimOnlyBridge(tx)
+            )
         }
     }
 
diff --git a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerMock.swift b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerMock.swift
index 03b5e7c9beb..a885daea3b4 100644
--- a/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerMock.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/AttachmentManager/TSResource/TSResourceManagerMock.swift
@@ -32,7 +32,7 @@ public class TSResourceManagerMock: TSResourceManager {
     }
 
     public func createOversizeTextAttachmentStream(
-        consuming dataSource: DataSource,
+        consuming dataSource: OversizeTextDataSource,
         message: TSMessage,
         tx: DBWriteTransaction
     ) throws {
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift
index abbf8363e0a..f9e527e982c 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidator.swift
@@ -19,6 +19,13 @@ public protocol PendingAttachment {
     var orphanRecordId: OrphanedAttachmentRecord.IDType { get }
 }
 
+public enum ValidatedMessageBody {
+    /// The original body was small enough to send as-is.
+    case inline(MessageBody)
+    /// The original body was too large; we truncated and created an attachment with the untruncated text.
+    case oversize(truncated: MessageBody, fullsize: PendingAttachment)
+}
+
 public protocol AttachmentContentValidator {
 
     /// Validate and prepare a DataSource's contents, based on the provided mimetype.
@@ -47,6 +54,13 @@ public protocol AttachmentContentValidator {
         mimeType: String,
         sourceFilename: String?
     ) throws -> PendingAttachment
+
+    /// If the provided message body is large enough to require an oversize text
+    /// attachment, creates a pending one, alongside the truncated message body.
+    /// If not, just returns the message body as is.
+    func prepareOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) throws -> ValidatedMessageBody?
 }
 
 extension AttachmentContentValidator {
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
index c9c0fd60809..3913b53dfa3 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
@@ -86,6 +86,34 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
         )
     }
 
+    public func prepareOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) throws -> ValidatedMessageBody? {
+        guard !messageBody.text.isEmpty else {
+            return nil
+        }
+        let truncatedText = messageBody.text.trimmedIfNeeded(maxByteCount: Int(kOversizeTextMessageSizeThreshold))
+        guard let truncatedText else {
+            // No need to truncate
+            return .inline(messageBody)
+        }
+        let truncatedBody = MessageBody(text: truncatedText, ranges: messageBody.ranges)
+
+        guard let textData = messageBody.text.filterForDisplay.data(using: .utf8) else {
+            throw OWSAssertionError("Unable to encode text")
+        }
+        let input = Input.inMemory(textData)
+        let encryptionKey = Cryptography.randomAttachmentEncryptionKey()
+        let pendingAttachment = try self.validateContents(
+            input: input,
+            encryptionKey: encryptionKey,
+            mimeType: MimeType.textXSignalPlain.rawValue,
+            sourceFilename: nil
+        )
+
+        return .oversize(truncated: truncatedBody, fullsize: pendingAttachment)
+    }
+
     // MARK: - Private
 
     private struct PendingAttachmentImpl: PendingAttachment {
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift
index db630ccdfbd..4f2e9171a24 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorMock.swift
@@ -30,6 +30,12 @@ open class AttachmentContentValidatorMock: AttachmentContentValidator {
     ) throws -> PendingAttachment {
         throw OWSAssertionError("Unimplemented")
     }
+
+    open func prepareOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) throws -> ValidatedMessageBody? {
+        return .inline(messageBody)
+    }
 }
 
 #endif
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/TSResource/TSResourceContentValidator.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/TSResource/TSResourceContentValidator.swift
index 924242de9ee..1dcfbd50b66 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/TSResource/TSResourceContentValidator.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/TSResource/TSResourceContentValidator.swift
@@ -5,6 +5,26 @@
 
 import Foundation
 
+public struct OversizeTextDataSource {
+    public let v2DataSource: AttachmentDataSource?
+    public let legacyDataSource: TSAttachmentDataSource
+
+    public var dataSource: TSResourceDataSource {
+            if FeatureFlags.newAttachmentsUseV2, let v2DataSource {
+                return v2DataSource.tsDataSource
+            } else {
+                return legacyDataSource.tsDataSource
+            }
+        }
+}
+
+public enum ValidatedTSMessageBody {
+    /// The original body was small enough to send as-is.
+    case inline(MessageBody)
+    /// The original body was too large; we truncated and created an attachment with the untruncated text.
+    case oversize(truncated: MessageBody, fullsize: OversizeTextDataSource)
+}
+
 public protocol TSResourceContentValidator {
 
     /// Prepare and possibly validate DataSource's contents, based on the provided mimetype.
@@ -21,6 +41,13 @@ public protocol TSResourceContentValidator {
         caption: MessageBody?,
         renderingFlag: AttachmentReference.RenderingFlag
     ) throws -> TSResourceDataSource
+
+    /// If the provided message body is large enough to require an oversize text
+    /// attachment, creates a pending one, alongside the truncated message body.
+    /// If not, just returns the message body as is.
+    func prepareOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) throws -> ValidatedTSMessageBody?
 }
 
 public class TSResourceContentValidatorImpl: TSResourceContentValidator {
@@ -59,6 +86,83 @@ public class TSResourceContentValidatorImpl: TSResourceContentValidator {
             )
         }
     }
+
+    public func prepareOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) throws -> ValidatedTSMessageBody? {
+        let legacyOnly = Self.prepareLegacyOversizeTextIfNeeded(from: messageBody)
+
+        let truncatedBody: MessageBody
+        let legacyDataSource: TSAttachmentDataSource
+        switch legacyOnly {
+        case nil:
+            return nil
+        case .inline(let messageBody):
+            return .inline(messageBody)
+        case .oversize(let truncated, let fullsize):
+            truncatedBody = truncated
+            legacyDataSource = fullsize.legacyDataSource
+        }
+
+        let v2DataSource: AttachmentDataSource?
+        if FeatureFlags.newAttachmentsUseV2 {
+            let result = try attachmentValidator.prepareOversizeTextIfNeeded(
+                from: messageBody
+            )
+            switch result {
+            case .inline, nil:
+                owsFailDebug("Got no oversize text for v2 even though we have one for v1")
+                v2DataSource = nil
+            case .oversize(_, let fullsize):
+                v2DataSource = .from(pendingAttachment: fullsize)
+            }
+        } else {
+            v2DataSource = nil
+        }
+        let dataSource = OversizeTextDataSource.init(
+            v2DataSource: v2DataSource,
+            legacyDataSource: legacyDataSource
+        )
+
+        return .oversize(
+            truncated: truncatedBody,
+            fullsize: dataSource
+        )
+    }
+
+    // For legacy attachments, don't validate but still truncate.
+    public static func prepareLegacyOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) -> ValidatedTSMessageBody? {
+        guard !messageBody.text.isEmpty else {
+            return nil
+        }
+        let truncatedText = messageBody.text.trimmedIfNeeded(maxByteCount: Int(kOversizeTextMessageSizeThreshold))
+        guard let truncatedText else {
+            // No need to truncate
+            return .inline(messageBody)
+        }
+        let truncatedBody = MessageBody(text: truncatedText, ranges: messageBody.ranges)
+
+        let dataSource = OversizeTextDataSource.init(
+            v2DataSource: nil,
+            legacyDataSource: .init(
+                mimeType: MimeType.textXSignalPlain.rawValue,
+                caption: nil,
+                renderingFlag: .default,
+                sourceFilename: nil,
+                dataSource: .dataSource(
+                    DataSourceValue.dataSource(withOversizeText: messageBody.text),
+                    shouldCopy: false
+                )
+            )
+        )
+
+        return .oversize(
+            truncated: truncatedBody,
+            fullsize: dataSource
+        )
+    }
 }
 
 #if DEBUG
@@ -83,6 +187,12 @@ open class TSResourceContentValidatorMock: TSResourceContentValidator {
             shouldCopyDataSource: !shouldConsume
         )
     }
+
+    open func prepareOversizeTextIfNeeded(
+        from messageBody: MessageBody
+    ) throws -> ValidatedTSMessageBody? {
+        return .inline(messageBody)
+    }
 }
 
 #endif
diff --git a/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachments.swift b/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachments.swift
index 568160cb164..24b5f2b380e 100644
--- a/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachments.swift
+++ b/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachments.swift
@@ -8,7 +8,7 @@ import Foundation
 extension MessageEdits {
 
     public enum OversizeTextSource {
-        case dataSource(DataSource)
+        case dataSource(OversizeTextDataSource)
         case proto(SSKProtoAttachmentPointer)
     }
 
diff --git a/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachmentsImpl.swift b/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachmentsImpl.swift
index e657da0215b..a7936544e9c 100644
--- a/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachmentsImpl.swift
+++ b/SignalServiceKit/Messages/Edit/Attachments/EditManagerAttachmentsImpl.swift
@@ -302,14 +302,12 @@ public class EditManagerAttachmentsImpl: EditManagerAttachments {
         case .none:
             break
         case .dataSource(let dataSource):
+            guard let attachmentDataSource = dataSource.v2DataSource else {
+                throw OWSAssertionError("Missing v2 data source")
+            }
             try attachmentManager.createAttachmentStream(
                 consuming: .init(
-                    dataSource: AttachmentDataSource(
-                        mimeType: MimeType.textXSignalPlain.rawValue,
-                        contentHash: nil,
-                        sourceFilename: nil,
-                        dataSource: .dataSource(dataSource, shouldCopy: false)
-                    ),
+                    dataSource: attachmentDataSource,
                     owner: .messageOversizeText(.init(
                         messageRowId: latestRevisionRowId,
                         receivedAtTimestamp: latestRevision.receivedAtTimestamp,
diff --git a/SignalServiceKit/Messages/Edit/Attachments/TSResource/EditManagerTSResourcesImpl.swift b/SignalServiceKit/Messages/Edit/Attachments/TSResource/EditManagerTSResourcesImpl.swift
index 8dd1327c93b..ef34442bac9 100644
--- a/SignalServiceKit/Messages/Edit/Attachments/TSResource/EditManagerTSResourcesImpl.swift
+++ b/SignalServiceKit/Messages/Edit/Attachments/TSResource/EditManagerTSResourcesImpl.swift
@@ -212,13 +212,7 @@ public class EditManagerTSResourcesImpl: EditManagerTSResources {
                 throw OWSAssertionError("Can only set local data source oversize text on outgoing edits")
             }
             try tsAttachmentManager.createBodyAttachmentStreams(
-                consuming: [TSAttachmentDataSource(
-                    mimeType: MimeType.textXSignalPlain.rawValue,
-                    caption: nil,
-                    renderingFlag: .default,
-                    sourceFilename: nil,
-                    dataSource: .dataSource(dataSource, shouldCopy: false)
-                )],
+                consuming: [dataSource.legacyDataSource],
                 message: latestRevisionOutgoing,
                 tx: SDSDB.shimOnlyBridge(tx)
             )
diff --git a/SignalServiceKit/Messages/Edit/EditManager.swift b/SignalServiceKit/Messages/Edit/EditManager.swift
index e71ef4e5db7..6f1cddc906b 100644
--- a/SignalServiceKit/Messages/Edit/EditManager.swift
+++ b/SignalServiceKit/Messages/Edit/EditManager.swift
@@ -77,7 +77,7 @@ public protocol EditManager {
         targetMessage: TSOutgoingMessage,
         thread: TSThread,
         edits: MessageEdits,
-        oversizeText: DataSource?,
+        oversizeText: OversizeTextDataSource?,
         quotedReplyEdit: MessageEdits.Edit<Void>,
         linkPreview: LinkPreviewTSResourceDataSource?,
         tx: DBWriteTransaction
diff --git a/SignalServiceKit/Messages/Edit/EditManagerImpl.swift b/SignalServiceKit/Messages/Edit/EditManagerImpl.swift
index 0141cbfde77..dcd92397304 100644
--- a/SignalServiceKit/Messages/Edit/EditManagerImpl.swift
+++ b/SignalServiceKit/Messages/Edit/EditManagerImpl.swift
@@ -204,7 +204,7 @@ public class EditManagerImpl: EditManager {
         targetMessage: TSOutgoingMessage,
         thread: TSThread,
         edits: MessageEdits,
-        oversizeText: DataSource?,
+        oversizeText: OversizeTextDataSource?,
         quotedReplyEdit: MessageEdits.Edit<Void>,
         linkPreview: LinkPreviewTSResourceDataSource?,
         tx: DBWriteTransaction
diff --git a/SignalServiceKit/Messages/OutgoingMessagePreparer/UnpreparedOutgoingMessage.swift b/SignalServiceKit/Messages/OutgoingMessagePreparer/UnpreparedOutgoingMessage.swift
index 6bf102f886c..d86661dcb57 100644
--- a/SignalServiceKit/Messages/OutgoingMessagePreparer/UnpreparedOutgoingMessage.swift
+++ b/SignalServiceKit/Messages/OutgoingMessagePreparer/UnpreparedOutgoingMessage.swift
@@ -17,7 +17,7 @@ public class UnpreparedOutgoingMessage {
     public static func forMessage(
         _ message: TSOutgoingMessage,
         unsavedBodyMediaAttachments: [TSResourceDataSource] = [],
-        oversizeTextDataSource: DataSource? = nil,
+        oversizeTextDataSource: OversizeTextDataSource? = nil,
         linkPreviewDraft: LinkPreviewTSResourceDataSource? = nil,
         quotedReplyDraft: DraftQuotedReplyModel? = nil,
         messageStickerDraft: MessageStickerDraft? = nil,
@@ -50,7 +50,7 @@ public class UnpreparedOutgoingMessage {
     public static func forEditMessage(
         targetMessage: TSOutgoingMessage,
         edits: MessageEdits,
-        oversizeTextDataSource: DataSource?,
+        oversizeTextDataSource: OversizeTextDataSource?,
         linkPreviewDraft: LinkPreviewTSResourceDataSource?,
         quotedReplyEdit: MessageEdits.Edit<Void>
     ) -> UnpreparedOutgoingMessage {
@@ -130,7 +130,7 @@ public class UnpreparedOutgoingMessage {
         struct Persistable {
             let message: TSOutgoingMessage
             let unsavedBodyMediaAttachments: [TSResourceDataSource]
-            let oversizeTextDataSource: DataSource?
+            let oversizeTextDataSource: OversizeTextDataSource?
             let linkPreviewDraft: LinkPreviewTSResourceDataSource?
             let quotedReplyDraft: DraftQuotedReplyModel?
             let messageStickerDraft: MessageStickerDraft?
@@ -140,7 +140,7 @@ public class UnpreparedOutgoingMessage {
         struct EditMessage {
             let targetMessage: TSOutgoingMessage
             let edits: MessageEdits
-            let oversizeTextDataSource: DataSource?
+            let oversizeTextDataSource: OversizeTextDataSource?
             let linkPreviewDraft: LinkPreviewTSResourceDataSource?
             let quotedReplyEdit: MessageEdits.Edit<Void>
         }
diff --git a/SignalShareExtension/SharingThreadPickerViewController.swift b/SignalShareExtension/SharingThreadPickerViewController.swift
index a96ff136dec..2b41c36b595 100644
--- a/SignalShareExtension/SharingThreadPickerViewController.swift
+++ b/SignalShareExtension/SharingThreadPickerViewController.swift
@@ -240,10 +240,11 @@ extension SharingThreadPickerViewController {
 
             return await self.sendToOutgoingMessageThreads(
                 selectedConversations: selectedConversations,
-                messageBlock: { thread, tx in
+                messageBody: messageBody,
+                messageBlock: { destination, tx in
                     let unpreparedMessage = UnpreparedOutgoingMessage.build(
-                        thread: thread,
-                        messageBody: messageBody,
+                        thread: destination.thread,
+                        messageBody: destination.messageBody,
                         quotedReplyDraft: nil,
                         linkPreviewDataSource: linkPreviewDataSource,
                         transaction: tx
@@ -274,10 +275,14 @@ extension SharingThreadPickerViewController {
             }
             return await self.sendToOutgoingMessageThreads(
                 selectedConversations: selectedConversations,
-                messageBlock: { thread, tx in
-                    let builder = TSOutgoingMessageBuilder(thread: thread)
+                messageBody: nil,
+                messageBlock: { destination, tx in
+                    let builder = TSOutgoingMessageBuilder(thread: destination.thread)
                     let dmConfigurationStore = DependenciesBridge.shared.disappearingMessagesConfigurationStore
-                    builder.expiresInSeconds = dmConfigurationStore.durationSeconds(for: thread, tx: tx.asV2Read)
+                    builder.expiresInSeconds = dmConfigurationStore.durationSeconds(
+                        for: destination.thread,
+                        tx: tx.asV2Read
+                    )
                     let message = builder.build(transaction: tx)
                     let unpreparedMessage = UnpreparedOutgoingMessage.forMessage(
                         message,
@@ -354,24 +359,32 @@ extension SharingThreadPickerViewController {
 
     private nonisolated func sendToOutgoingMessageThreads(
         selectedConversations: [ConversationItem],
-        messageBlock: @escaping (TSThread, SDSAnyWriteTransaction) throws -> PreparedOutgoingMessage,
+        messageBody: MessageBody?,
+        messageBlock: @escaping (AttachmentMultisend.Destination, SDSAnyWriteTransaction) throws -> PreparedOutgoingMessage,
         storySendBlock: (([ConversationItem]) -> AttachmentMultisend.Result?)?
     ) async -> Result<Void, SendError> {
         let conversations = selectedConversations.filter { $0.outgoingMessageType == .message }
 
         let preparedNonStoryMessages: [PreparedOutgoingMessage]
         let nonStorySendPromises: [Promise<Void>]
+
         do {
+            let destinations = try AttachmentMultisend.prepareForSending(
+                messageBody,
+                to: conversations,
+                db: self.databaseStorage,
+                attachmentValidator: DependenciesBridge.shared.tsResourceContentValidator
+            )
+
             (preparedNonStoryMessages, nonStorySendPromises) = try await self.databaseStorage.awaitableWrite { tx in
-                let threads = self.threads(for: conversations, tx: tx)
-                let preparedMessages = try threads.map { thread in
-                    return try messageBlock(thread, tx)
+                let preparedMessages = try destinations.map { destination in
+                    return try messageBlock(destination, tx)
                 }
 
                 // We're sending a message to this thread, approve any pending message request
-                threads.forEach { thread in
+                destinations.forEach { destination in
                     ThreadUtil.addThreadToProfileWhitelistIfEmptyOrPendingRequest(
-                        thread,
+                        destination.thread,
                         setDefaultTimerIfNecessary: true,
                         tx: tx
                     )
diff --git a/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift b/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift
new file mode 100644
index 00000000000..7dd331fae06
--- /dev/null
+++ b/SignalUI/AttachmentMultisend/AttachmentMultisend+OversizeText.swift
@@ -0,0 +1,97 @@
+//
+// Copyright 2024 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+import SignalServiceKit
+
+extension AttachmentMultisend {
+
+    public struct Destination {
+        public let conversationItem: ConversationItem
+        public let thread: TSThread
+        // Message bodies are re-generated _per destination_,
+        // as mentions must be hydrated based on participants.
+        public let messageBody: ValidatedTSMessageBody?
+    }
+
+    public static func prepareForSending(
+        _ messageBody: MessageBody?,
+        to conversations: [ConversationItem],
+        db: SDSDatabaseStorage,
+        attachmentValidator: TSResourceContentValidator
+    ) throws -> [Destination] {
+
+        // If the message body has no mentions, we can "hydrate" once across all threads
+        // and share it. We only need to re-generate per-thread if there are mentions.
+        let canShareMessageBody = !(messageBody?.ranges.hasMentions ?? false)
+
+        struct PreDestination {
+            let conversationItem: ConversationItem
+            let thread: TSThread
+            let messageBody: HydratedMessageBody?
+        }
+
+        let preDestinations: [PreDestination] = try db.write { tx in
+            return try conversations.map { conversation in
+                guard let thread = conversation.getOrCreateThread(transaction: tx) else {
+                    throw OWSAssertionError("Missing thread for conversation")
+                }
+                let hydratedMessageBody: HydratedMessageBody?
+                if canShareMessageBody {
+                    // Don't set per-destination message bodies.
+                    hydratedMessageBody = nil
+                } else {
+                    hydratedMessageBody = messageBody?.forForwarding(to: thread, transaction: tx.unwrapGrdbRead)
+                }
+                return .init(
+                    conversationItem: conversation,
+                    thread: thread,
+                    messageBody: hydratedMessageBody
+                )
+            }
+        }
+
+        guard !canShareMessageBody else {
+            // We only prepare the single shared body.
+            let validatedMessageBody: ValidatedTSMessageBody?
+            if let messageBody {
+                validatedMessageBody = try attachmentValidator.prepareOversizeTextIfNeeded(
+                    from: messageBody
+                )
+            } else {
+                validatedMessageBody = nil
+            }
+            return preDestinations.map {
+                .init(
+                    conversationItem: $0.conversationItem,
+                    thread: $0.thread,
+                    messageBody: validatedMessageBody
+                )
+            }
+        }
+
+        // Prepare the message body per-thread.
+        var destinations = [Destination]()
+        for preDestination in preDestinations {
+            guard let hydratedMessageBody = preDestination.messageBody else {
+                destinations.append(.init(
+                    conversationItem: preDestination.conversationItem,
+                    thread: preDestination.thread,
+                    messageBody: nil
+                ))
+                continue
+            }
+            let validatedMessageBody = try attachmentValidator.prepareOversizeTextIfNeeded(
+                from: hydratedMessageBody.asMessageBodyForForwarding()
+            )
+            destinations.append(.init(
+                conversationItem: preDestination.conversationItem,
+                thread: preDestination.thread,
+                messageBody: validatedMessageBody
+            ))
+        }
+        return destinations
+    }
+}
diff --git a/SignalUI/AttachmentMultisend/AttachmentMultisend.swift b/SignalUI/AttachmentMultisend/AttachmentMultisend.swift
index b9b377e4880..0aaff8c333d 100644
--- a/SignalUI/AttachmentMultisend/AttachmentMultisend.swift
+++ b/SignalUI/AttachmentMultisend/AttachmentMultisend.swift
@@ -35,16 +35,25 @@ public class AttachmentMultisend {
             let preparedMessages: [PreparedOutgoingMessage]
             let sendPromises: [Promise<Void>]
             do {
+                let destinations = try Self.prepareForSending(
+                    approvedMessageBody,
+                    to: conversations,
+                    db: deps.databaseStorage,
+                    attachmentValidator: deps.attachmentValidator
+                )
+
                 let segmentedAttachments = try await segmentAttachmentsIfNecessary(
                     for: conversations,
                     approvedAttachments: approvedAttachments
                 )
+
                 (threads, preparedMessages, sendPromises) = try await deps.databaseStorage.awaitableWrite { tx in
                     let threads: [TSThread]
                     let preparedMessages: [PreparedOutgoingMessage]
                     (threads, preparedMessages) = try prepareForSending(
-                        conversations: conversations,
-                        approvedMessageBody: approvedMessageBody,
+                        destinations: destinations,
+                        // Stories get an untruncated message body
+                        messageBodyForStories: approvedMessageBody,
                         approvedAttachments: segmentedAttachments,
                         tx: tx
                     )
@@ -147,6 +156,7 @@ public class AttachmentMultisend {
 
     private struct Dependencies {
         let attachmentManager: AttachmentManager
+        let attachmentValidator: TSResourceContentValidator
         let contactsMentionHydrator: ContactsMentionHydrator.Type
         let databaseStorage: SDSDatabaseStorage
         let imageQualityLevel: ImageQualityLevel.Type
@@ -156,6 +166,7 @@ public class AttachmentMultisend {
 
     private static var deps = Dependencies(
         attachmentManager: DependenciesBridge.shared.attachmentManager,
+        attachmentValidator: DependenciesBridge.shared.tsResourceContentValidator,
         contactsMentionHydrator: ContactsMentionHydrator.self,
         databaseStorage: SSKEnvironment.shared.databaseStorage,
         imageQualityLevel: ImageQualityLevel.self,
@@ -201,8 +212,8 @@ public class AttachmentMultisend {
     // MARK: - Preparing messages
 
     private class func prepareForSending(
-        conversations: [ConversationItem],
-        approvedMessageBody: MessageBody?,
+        destinations: [Destination],
+        messageBodyForStories: MessageBody?,
         approvedAttachments: [SignalAttachment.SegmentAttachmentResult],
         tx: SDSAnyWriteTransaction
     ) throws -> ([TSThread], [PreparedOutgoingMessage]) {
@@ -211,17 +222,16 @@ public class AttachmentMultisend {
         })
         let unsegmentedAttachments = approvedAttachments.map(\.original)
 
-        var nonStoryThreads = [TSThread]()
+        var nonStoryThreads = [Destination]()
         var privateStoryThreads = [TSPrivateStoryThread]()
         var groupStoryThreads = [TSGroupThread]()
-        for conversation in conversations {
-            guard let thread = conversation.getOrCreateThread(transaction: tx) else {
-                throw OWSAssertionError("Missing thread for conversation")
-            }
+        for destination in destinations {
+            let conversation = destination.conversationItem
+            let thread = destination.thread
             switch conversation.outgoingMessageType {
             case .message:
                 owsAssertDebug(conversation.limitsVideoAttachmentLengthForStories == false)
-                nonStoryThreads.append(thread)
+                nonStoryThreads.append(destination)
             case .storyMessage where thread is TSPrivateStoryThread:
                 owsAssertDebug(conversation.limitsVideoAttachmentLengthForStories == true)
                 privateStoryThreads.append(thread as! TSPrivateStoryThread)
@@ -234,15 +244,14 @@ public class AttachmentMultisend {
         }
 
         let nonStoryMessages = try prepareNonStoryMessages(
-            threads: nonStoryThreads,
-            approvedMessageBody: approvedMessageBody,
+            threadDestinations: nonStoryThreads,
             unsegmentedAttachments: unsegmentedAttachments,
             tx: tx
         )
 
         let storyMessageBuilders = try storyMessageBuilders(
             segmentedAttachments: segmentedAttachments,
-            approvedMessageBody: approvedMessageBody,
+            approvedMessageBody: messageBodyForStories,
             tx: tx
         )
 
@@ -257,7 +266,7 @@ public class AttachmentMultisend {
             tx: tx
         )
         let preparedMessages = nonStoryMessages + groupStoryMessages + privateStoryMessages
-        let allThreads = nonStoryThreads + groupStoryThreads + privateStoryThreads
+        let allThreads = nonStoryThreads.map(\.thread) + groupStoryThreads + privateStoryThreads
         return (allThreads, preparedMessages)
     }
 
@@ -305,12 +314,12 @@ public class AttachmentMultisend {
     // MARK: Preparing Non-Story Messages
 
     private class func prepareNonStoryMessages(
-        threads: [TSThread],
-        approvedMessageBody: MessageBody?,
+        threadDestinations: [Destination],
         unsegmentedAttachments: [SignalAttachment],
         tx: SDSAnyWriteTransaction
     ) throws -> [PreparedOutgoingMessage] {
-        return try threads.map { thread in
+        return try threadDestinations.map { destination in
+            let thread = destination.thread
             // If this thread has a pending message request, treat it as accepted.
             ThreadUtil.addThreadToProfileWhitelistIfEmptyOrPendingRequest(
                 thread,
@@ -319,7 +328,7 @@ public class AttachmentMultisend {
             )
 
             let preparedMessage = try prepareNonStoryMessage(
-                messageBody: approvedMessageBody,
+                messageBody: destination.messageBody,
                 attachments: unsegmentedAttachments,
                 thread: thread,
                 tx: tx
@@ -332,7 +341,7 @@ public class AttachmentMultisend {
     }
 
     private class func prepareNonStoryMessage(
-        messageBody: MessageBody?,
+        messageBody: ValidatedTSMessageBody?,
         attachments: [SignalAttachment],
         thread: TSThread,
         tx: SDSAnyWriteTransaction
diff --git a/SignalUI/AttachmentMultisend/TSResource/TSOutgoingMessage+TSAttachmentMultisend.swift b/SignalUI/AttachmentMultisend/TSResource/TSOutgoingMessage+TSAttachmentMultisend.swift
index fb0cc252323..7182d253bbc 100644
--- a/SignalUI/AttachmentMultisend/TSResource/TSOutgoingMessage+TSAttachmentMultisend.swift
+++ b/SignalUI/AttachmentMultisend/TSResource/TSOutgoingMessage+TSAttachmentMultisend.swift
@@ -25,13 +25,20 @@ extension TSOutgoingMessage {
                 transaction: transaction.unwrapGrdbRead
             ).asMessageBodyForForwarding()
 
+            // Legacy only codepath; don't need validation.
+            let validatedMessageBody = messageBodyForContext.map {
+                TSResourceContentValidatorImpl.prepareLegacyOversizeTextIfNeeded(
+                    from: $0
+                )
+            } ?? nil
+
             let preparedMessage: PreparedOutgoingMessage
             let attachmentUUIDs: [UUID]
             switch destination.content {
             case .media(let attachments):
                 attachmentUUIDs = attachments.map(\.id)
                 preparedMessage = try Self.createUnsentMessage(
-                    body: messageBodyForContext,
+                    body: validatedMessageBody,
                     mediaAttachments: attachments.map(\.value),
                     thread: destination.thread,
                     transaction: transaction
@@ -59,7 +66,7 @@ extension TSOutgoingMessage {
     }
 
     private class func createUnsentMessage(
-        body messageBody: MessageBody?,
+        body messageBody: ValidatedTSMessageBody?,
         mediaAttachments: [SignalAttachment],
         thread: TSThread,
         transaction: SDSAnyWriteTransaction
diff --git a/SignalUI/Sending/ThreadUtil+SignalUI.swift b/SignalUI/Sending/ThreadUtil+SignalUI.swift
index 733b4fb6911..20ae8b42652 100644
--- a/SignalUI/Sending/ThreadUtil+SignalUI.swift
+++ b/SignalUI/Sending/ThreadUtil+SignalUI.swift
@@ -25,6 +25,10 @@ extension ThreadUtil {
         self.enqueueSendQueue.async {
             let unpreparedMessage: UnpreparedOutgoingMessage
             do {
+                let messageBody = try messageBody.map {
+                    try DependenciesBridge.shared.tsResourceContentValidator
+                        .prepareOversizeTextIfNeeded(from: $0)
+                } ?? nil
                 let linkPreviewDataSource = try linkPreviewDraft.map {
                     try DependenciesBridge.shared.linkPreviewManager.buildDataSource(from: $0)
                 }
@@ -70,6 +74,10 @@ extension ThreadUtil {
         self.enqueueSendQueue.async {
             let unpreparedMessage: UnpreparedOutgoingMessage
             do {
+                let messageBody = try messageBody.map {
+                    try DependenciesBridge.shared.tsResourceContentValidator
+                        .prepareOversizeTextIfNeeded(from: $0)
+                } ?? nil
                 let linkPreviewDataSource = try linkPreviewDraft.map {
                     try DependenciesBridge.shared.linkPreviewManager.buildDataSource(from: $0)
                 }
@@ -168,14 +176,26 @@ extension UnpreparedOutgoingMessage {
     public static func build(
         thread: TSThread,
         timestamp: UInt64? = nil,
-        messageBody: MessageBody?,
+        messageBody: ValidatedTSMessageBody?,
         mediaAttachments: [SignalAttachment] = [],
         quotedReplyDraft: DraftQuotedReplyModel?,
         linkPreviewDataSource: LinkPreviewTSResourceDataSource?,
         transaction: SDSAnyReadTransaction
     ) -> UnpreparedOutgoingMessage {
 
-        let (truncatedBody, oversizeTextDataSource) = handleOversizeText(messageBody: messageBody)
+        let truncatedBody: MessageBody?
+        let oversizeTextDataSource: OversizeTextDataSource?
+        switch messageBody {
+        case .inline(let messageBody):
+            truncatedBody = messageBody
+            oversizeTextDataSource = nil
+        case .oversize(let truncated, let fullsize):
+            truncatedBody = truncated
+            oversizeTextDataSource = fullsize
+        case nil:
+            truncatedBody = nil
+            oversizeTextDataSource = nil
+        }
 
         let dmConfigurationStore = DependenciesBridge.shared.disappearingMessagesConfigurationStore
         let expiresInSeconds = dmConfigurationStore.durationSeconds(for: thread, tx: transaction.asV2Read)
@@ -226,13 +246,25 @@ extension UnpreparedOutgoingMessage {
     public static func buildForEdit(
         thread: TSThread,
         timestamp: UInt64,
-        messageBody: MessageBody?,
+        messageBody: ValidatedTSMessageBody?,
         quotedReplyEdit: MessageEdits.Edit<Void>,
         linkPreviewDataSource: LinkPreviewTSResourceDataSource?,
         editTarget: TSOutgoingMessage
     ) -> UnpreparedOutgoingMessage {
 
-        let (truncatedBody, oversizeTextDataSource) = handleOversizeText(messageBody: messageBody)
+        let truncatedBody: MessageBody?
+        let oversizeTextDataSource: OversizeTextDataSource?
+        switch messageBody {
+        case .inline(let messageBody):
+            truncatedBody = messageBody
+            oversizeTextDataSource = nil
+        case .oversize(let truncated, let fullsize):
+            truncatedBody = truncated
+            oversizeTextDataSource = fullsize
+        case nil:
+            truncatedBody = nil
+            oversizeTextDataSource = nil
+        }
 
         let edits = MessageEdits(
             timestamp: timestamp,
@@ -249,21 +281,4 @@ extension UnpreparedOutgoingMessage {
         )
         return unpreparedMessage
     }
-
-    private static func handleOversizeText(
-        messageBody: MessageBody?
-    ) -> (MessageBody?, DataSource?) {
-        guard let messageBody, !messageBody.text.isEmpty else {
-            return (nil, nil)
-        }
-        if let truncatedText = messageBody.text.trimmedIfNeeded(maxByteCount: Int(kOversizeTextMessageSizeThreshold)) {
-            let bodyRanges = messageBody.ranges
-            let truncatedBody = MessageBody(text: truncatedText, ranges: bodyRanges)
-
-            let dataSource = DataSourceValue.dataSource(withOversizeText: messageBody.text)
-            return (truncatedBody, dataSource)
-        } else {
-            return (messageBody, nil)
-        }
-    }
 }
