diff --git a/Signal/Backups/BackupSettingsViewController.swift b/Signal/Backups/BackupSettingsViewController.swift
index 6823b9a0845..3c160574659 100644
--- a/Signal/Backups/BackupSettingsViewController.swift
+++ b/Signal/Backups/BackupSettingsViewController.swift
@@ -296,7 +296,9 @@ extension BackupSettingsViewController: BackupSettingsViewModel.ActionsDelegate
     // MARK: -
 
     fileprivate func loadBackupPlan() async throws -> BackupSettingsViewModel.BackupPlanLoadingState.LoadedBackupPlan {
-        switch db.read(block: { backupSettingsStore.backupPlan(tx: $0) }) {
+        var currentBackupPlan = db.read { backupSettingsStore.backupPlan(tx: $0) }
+
+        switch currentBackupPlan {
         case .free:
             return .free
         case .disabled, .paid, .paidExpiringSoon:
@@ -310,37 +312,30 @@ extension BackupSettingsViewController: BackupSettingsViewModel.ActionsDelegate
             return .free
         }
 
+        // The subscription fetch may have updated our local Backup plan.
+        currentBackupPlan = db.read { backupSettingsStore.backupPlan(tx: $0) }
+
+        switch currentBackupPlan {
+        case .free:
+            return .free
+        case .disabled, .paid, .paidExpiringSoon:
+            break
+        }
+
         let endOfCurrentPeriod = Date(timeIntervalSince1970: backupSubscription.endOfCurrentPeriod)
 
-        switch backupSubscription.status {
-        case .active, .pastDue:
-            // `.pastDue` means that a renewal failed, but the payment
-            // processor is automatically retrying. For now, assume it
-            // may recover, and show it as paid. If it fails, it'll
-            // become `.canceled` instead.
-            if backupSubscription.cancelAtEndOfPeriod {
-                return .paidExpiringSoon(expirationDate: endOfCurrentPeriod)
+        if backupSubscription.cancelAtEndOfPeriod {
+            if endOfCurrentPeriod.isAfterNow {
+                return .paidButExpiring(expirationDate: endOfCurrentPeriod)
+            } else {
+                return .paidButExpired(expirationDate: endOfCurrentPeriod)
             }
-
-            return .paid(
-                price: backupSubscription.amount,
-                renewalDate: endOfCurrentPeriod
-            )
-        case .canceled:
-            // TODO: [Backups] Downgrade local state to the free plan, if necessary.
-            // This might be the first place we learn, locally, that our
-            // subscription has expired and we've been implicitly downgraded to
-            // the free plan. Correspondingly, we should use this as a change to
-            // set local state, if necessary. Make sure to log that state change
-            // loudly!
-            return .free
-        case .incomplete, .unpaid, .unknown:
-            // These are unexpected statuses, so we know that something
-            // is wrong with the subscription. Consequently, we can show
-            // it as free.
-            owsFailDebug("Unexpected backup subscription status! \(backupSubscription.status)")
-            return .free
         }
+
+        return .paid(
+            price: backupSubscription.amount,
+            renewalDate: endOfCurrentPeriod
+        )
     }
 
     // MARK: -
@@ -370,12 +365,6 @@ extension BackupSettingsViewController: BackupSettingsViewModel.ActionsDelegate
         }
     }
 
-    fileprivate func resubscribeToPaidPlan() {
-        Task {
-            await showChooseBackupPlan(initialPlanSelection: .free)
-        }
-    }
-
     // MARK: -
 
     fileprivate func performManualBackup() {
@@ -474,7 +463,6 @@ private class BackupSettingsViewModel: ObservableObject {
         func loadBackupPlan() async throws -> BackupPlanLoadingState.LoadedBackupPlan
         func upgradeFromFreeToPaidPlan()
         func manageOrCancelPaidPlan()
-        func resubscribeToPaidPlan()
 
         func performManualBackup()
         func setBackupFrequency(_ newBackupFrequency: BackupFrequency)
@@ -487,7 +475,8 @@ private class BackupSettingsViewModel: ObservableObject {
         enum LoadedBackupPlan {
             case free
             case paid(price: FiatMoney, renewalDate: Date)
-            case paidExpiringSoon(expirationDate: Date)
+            case paidButExpiring(expirationDate: Date)
+            case paidButExpired(expirationDate: Date)
         }
 
         case loading
@@ -615,10 +604,6 @@ private class BackupSettingsViewModel: ObservableObject {
         actionsDelegate?.manageOrCancelPaidPlan()
     }
 
-    func resubscribeToPaidPlan() {
-        actionsDelegate?.resubscribeToPaidPlan()
-    }
-
     // MARK: -
 
     func performManualBackup() {
@@ -798,10 +783,10 @@ struct BackupSettingsView: View {
             // Don't let them reenable until we know if they're already paying
             // or not.
             return AnyView(EmptyView())
-        case .loaded(.free), .genericError:
+        case .loaded(.free), .loaded(.paidButExpired), .genericError:
             // Let the reenable with anything.
             implicitPlanSelection = nil
-        case .loaded(.paid), .loaded(.paidExpiringSoon):
+        case .loaded(.paid), .loaded(.paidButExpiring):
             // Only let the user reenable with .paid, because they're already
             // paying.
             implicitPlanSelection = .paid
@@ -957,7 +942,7 @@ private struct BackupPlanView: View {
                             "BACKUP_SETTINGS_BACKUP_PLAN_FREE_HEADER",
                             comment: "Header describing what the free backup plan includes."
                         ))
-                    case .paid, .paidExpiringSoon:
+                    case .paid, .paidButExpiring, .paidButExpired:
                         Text(OWSLocalizedString(
                             "BACKUP_SETTINGS_BACKUP_PLAN_PAID_HEADER",
                             comment: "Header describing what the paid backup plan includes."
@@ -993,11 +978,21 @@ private struct BackupPlanView: View {
                         format: renewalStringFormat,
                         DateFormatter.localizedString(from: renewalDate, dateStyle: .medium, timeStyle: .none)
                     ))
-                case .paidExpiringSoon(let expirationDate):
-                    let expirationDateFutureString = OWSLocalizedString(
-                        "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_FUTURE_EXPIRATION_FORMAT",
-                        comment: "Text explaining that a user's paid plan, which has been canceled, will expire on a future date. Embeds {{ the formatted expiration date }}."
-                    )
+                case .paidButExpiring(let expirationDate), .paidButExpired(let expirationDate):
+                    let expirationDateFormatString = switch loadedBackupPlan {
+                    case .free, .paid:
+                        owsFail("Not possible")
+                    case .paidButExpiring:
+                        OWSLocalizedString(
+                            "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_FUTURE_EXPIRATION_FORMAT",
+                            comment: "Text explaining that a user's paid plan, which has been canceled, will expire on a future date. Embeds {{ the formatted expiration date }}."
+                        )
+                    case .paidButExpired:
+                        OWSLocalizedString(
+                            "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_PAST_EXPIRATION_FORMAT",
+                            comment: "Text explaining that a user's paid plan, which has been canceled, expired on a past date. Embeds {{ the formatted expiration date }}."
+                        )
+                    }
 
                     Text(OWSLocalizedString(
                         "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_DESCRIPTION",
@@ -1005,7 +1000,7 @@ private struct BackupPlanView: View {
                     ))
                     .foregroundStyle(Color.Signal.red)
                     Text(String(
-                        format: expirationDateFutureString,
+                        format: expirationDateFormatString,
                         DateFormatter.localizedString(from: expirationDate, dateStyle: .medium, timeStyle: .none)
                     ))
                 }
@@ -1016,10 +1011,8 @@ private struct BackupPlanView: View {
                     switch loadedBackupPlan {
                     case .free:
                         viewModel.upgradeFromFreeToPaidPlan()
-                    case .paid:
+                    case .paid, .paidButExpiring, .paidButExpired:
                         viewModel.manageOrCancelPaidPlan()
-                    case .paidExpiringSoon:
-                        viewModel.resubscribeToPaidPlan()
                     }
                 } label: {
                     switch loadedBackupPlan {
@@ -1033,7 +1026,7 @@ private struct BackupPlanView: View {
                             "BACKUP_SETTINGS_BACKUP_PLAN_PAID_ACTION_BUTTON_TITLE",
                             comment: "Title for a button allowing users to manage or cancel their paid backup plan."
                         ))
-                    case .paidExpiringSoon:
+                    case .paidButExpiring, .paidButExpired:
                         Text(OWSLocalizedString(
                             "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_ACTION_BUTTON_TITLE",
                             comment: "Title for a button allowing users to reenable a paid backup plan that has been canceled."
@@ -1265,12 +1258,22 @@ private extension BackupSettingsViewModel {
     BackupSettingsView(viewModel: .forPreview(
         backupEnabledState: .enabled,
         latestBackupAttachmentUploadUpdateState: nil,
-        backupPlanLoadResult: .success(.paidExpiringSoon(
+        backupPlanLoadResult: .success(.paidButExpiring(
             expirationDate: Date().addingTimeInterval(.week)
         ))
     ))
 }
 
+#Preview("Expired") {
+    BackupSettingsView(viewModel: .forPreview(
+        backupEnabledState: .enabled,
+        latestBackupAttachmentUploadUpdateState: nil,
+        backupPlanLoadResult: .success(.paidButExpired(
+            expirationDate: Date().addingTimeInterval(-1 * .week)
+        ))
+    ))
+}
+
 #Preview("Plan: Network Error") {
     BackupSettingsView(viewModel: .forPreview(
         backupEnabledState: .enabled,
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index b4d0259fdcd..34b16a4ea02 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -622,6 +622,9 @@
 /* Text explaining that a user's paid plan, which has been canceled, will expire on a future date. Embeds {{ the formatted expiration date }}. */
 "BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_FUTURE_EXPIRATION_FORMAT" = "Expires %1$@";
 
+/* Text explaining that a user's paid plan, which has been canceled, expired on a past date. Embeds {{ the formatted expiration date }}. */
+"BACKUP_SETTINGS_BACKUP_PLAN_PAID_BUT_CANCELED_PAST_EXPIRATION_FORMAT" = "Expired %1$@";
+
 /* Header describing what the paid backup plan includes. */
 "BACKUP_SETTINGS_BACKUP_PLAN_PAID_HEADER" = "Text + all media backup";
 
diff --git a/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift b/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift
index b702a982a0e..ebba3e7a0c6 100644
--- a/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift
+++ b/SignalServiceKit/Subscriptions/Backups/BackupSubscriptionManager.swift
@@ -218,7 +218,9 @@ public final class BackupSubscriptionManager {
 
                     do {
                         /// This transaction entitles us to a subscription, so
-                        /// let's attempt to do so.
+                        /// let's attempt to do so. Because we know we have a
+                        /// novel transaction, we know redemption is necessary.
+                        await setRedemptionAttemptIsNecessary()
                         try await redeemSubscriptionIfNecessary()
                     } catch {
                         owsFailDebug(
@@ -291,15 +293,15 @@ public final class BackupSubscriptionManager {
             let currentBackupPlan = backupPlanManager.backupPlan(tx: tx)
 
             let downgradedBackupPlan: BackupPlan? = {
-                if let subscription, subscription.active, subscription.cancelAtEndOfPeriod {
+                if let subscription, subscription.active {
                     switch currentBackupPlan {
-                    case .paid(let optimizeLocalStorage):
+                    case .paid(let optimizeLocalStorage) where subscription.cancelAtEndOfPeriod:
                         return .paidExpiringSoon(optimizeLocalStorage: optimizeLocalStorage)
+                    case .paid:
+                        break
                     case .disabled, .free, .paidExpiringSoon:
                         break
                     }
-                } else if let subscription, subscription.active {
-                    // No downgrade â€“ subscription present and active!
                 } else {
                     switch currentBackupPlan {
                     case .paid, .paidExpiringSoon:
@@ -348,6 +350,9 @@ public final class BackupSubscriptionManager {
         case .success(let purchaseResult):
             switch purchaseResult {
             case .verified:
+                // We've successfully purchased, which means a redemption
+                // attempt is necessary.
+                await setRedemptionAttemptIsNecessary()
                 return .success
             case .unverified:
                 throw OWSAssertionError(
@@ -369,6 +374,16 @@ public final class BackupSubscriptionManager {
         }
     }
 
+    // MARK: -
+
+    /// We generally only attempt redemptions 1x/3d, but on occasion we know
+    /// that a redemption is necessary and we should bypass that debounce.
+    private func setRedemptionAttemptIsNecessary() async {
+        await db.awaitableWrite { tx in
+            store.wipeLastRedemptionNecessaryCheck(tx: tx)
+        }
+    }
+
     // MARK: - Redeem subscription
 
     /// - Note
@@ -419,7 +434,7 @@ public final class BackupSubscriptionManager {
             if persistedIAPSubscriberData.matches(storeKitTransaction: localEntitlingTransaction) {
                 /// We have an active local subscription that matches our persisted
                 /// identifiers. That's the simplest happy-path! Probably...
-                logger.debug("Local transaction matches persisted: \(localEntitlingTransaction.originalID)")///
+                logger.debug("Local transaction matches persisted: \(localEntitlingTransaction.originalID)")
 
                 /// ...because we may need to register a new subscriber ID.
                 ///
@@ -671,6 +686,10 @@ public final class BackupSubscriptionManager {
         func setLastRedemptionNecessaryCheck(_ now: Date, tx: DBWriteTransaction) {
             kvStore.setDate(now, key: Keys.lastRedemptionNecessaryCheck, transaction: tx)
         }
+
+        func wipeLastRedemptionNecessaryCheck(tx: DBWriteTransaction) {
+            kvStore.removeValue(forKey: Keys.lastRedemptionNecessaryCheck, transaction: tx)
+        }
     }
 }
 
