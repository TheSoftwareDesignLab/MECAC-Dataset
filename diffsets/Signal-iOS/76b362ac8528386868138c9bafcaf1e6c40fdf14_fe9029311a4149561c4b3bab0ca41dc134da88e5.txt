diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index c937332fc9a..b0088b3b3a0 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -484,10 +484,10 @@ public class CVLoadCoordinator: NSObject {
             // Initiate new load if necessary.
             self.loadIfNecessary()
         }.catch(on: CVUtils.workQueue) { [weak self] (error) in
-            owsFailDebug("Error: \(error)")
             guard let self = self else {
                 return
             }
+            owsFailDebug("Error: \(error)")
             guard self.isLoading.tryToClearFlag() else {
                 owsFailDebug("Could not clear isLoading flag.")
                 return
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index bc502cac010..8bb9746f593 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -100,6 +100,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                                   scrollAction: CVScrollAction,
                                   updateToken: CVUpdateToken) {
         AssertIsOnMainThread()
+        owsAssertDebug(layout.hasLayout)
 
         owsAssertDebug(self.viewState.scrollContinuityMap != nil)
 
@@ -327,6 +328,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             UIView.performWithoutAnimation {
                 self.collectionView.reloadData()
                 self.collectionView.collectionViewLayout.invalidateLayout()
+                self.collectionView.collectionViewLayout.prepare()
             }
 
             updateViewToReflectLoad(loadedRenderState: self.renderState)
@@ -364,6 +366,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         UIView.performWithoutAnimation {
             self.collectionView.reloadData()
             self.collectionView.collectionViewLayout.invalidateLayout()
+            self.collectionView.collectionViewLayout.prepare()
         }
 
         benchSteps.step("2")
@@ -422,6 +425,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         UIView.performWithoutAnimation {
             self.collectionView.reloadData()
             self.collectionView.collectionViewLayout.invalidateLayout()
+            self.collectionView.collectionViewLayout.prepare()
         }
 
         DispatchQueue.main.async { [weak self] in
@@ -452,6 +456,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                                 threadInteractionCount: UInt,
                                 updateToken: CVUpdateToken) {
         owsAssertDebug(!items.isEmpty)
+        owsAssertDebug(layout.hasLayout)
 
         Logger.verbose("")
 
@@ -587,6 +592,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             }
         }
 
+        owsAssertDebug(layout.hasLayout)
         self.performBatchUpdates(batchUpdatesBlock,
                                  completion: completion,
                                  logFailureBlock: logFailureBlock,
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index c030882ebea..c9b574beaa5 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -3759,7 +3759,20 @@ - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
     @try {
         void (^updateBlock)(void) = ^{
             [self.collectionView performBatchUpdates:batchUpdates completion:completion];
+
+            // AFAIK the collection view layout should reflect the old layout
+            // until performBatchUpdates(), then we need to invalidate and prepare
+            // the (new) layout just _after_ performBatchUpdates.
+            //
+            // Moreover it's important that the (old) layout is prepared when
+            // performBatchUpdates() is called.  We ensure this in
+            // willUpdateWithNewRenderState().
+            //
+            // Otherwise UICollectionView can throw (crashing) exceptions like this:
+            //
+            // UICollectionView received layout attributes for a cell with an index path that does not exist...
             [self.layout invalidateLayout];
+            [self.layout prepareLayout];
             [BenchManager completeEventWithEventId:@"message-send"];
         };
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index c4dbcb5b70e..0cdb4781257 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -37,7 +37,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
     // prepareLayout from view logic to ensure that we always have aÂ¸valid
     // layout without incurring any of the (great) expense of performing an
     // unnecessary layout pass.
-    private var hasLayout = false {
+    public private(set) var hasLayout = false {
         didSet {
             AssertIsOnMainThread()
 
@@ -77,6 +77,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
         self.conversationStyle = conversationStyle
 
         invalidateLayout()
+        prepare()
     }
 
     @objc
