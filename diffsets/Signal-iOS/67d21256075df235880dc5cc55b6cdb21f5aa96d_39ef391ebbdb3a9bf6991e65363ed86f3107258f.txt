diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index c87edb97a82..a7d3299a26b 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -90,7 +90,10 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         // This will get cleared by updateViewToReflectLoad().
         owsAssertDebug(viewState.scrollContinuityMap == nil)
-        viewState.scrollContinuityMap = buildScrollContinuityMap(forRenderState: renderState)
+        if hasViewWillAppearEverBegun,
+           !renderState.isFirstLoad {
+            viewState.scrollContinuityMap = buildScrollContinuityMap(forRenderState: renderState)
+        }
 
         return CVUpdateToken(isScrolledToBottom: self.isScrolledToBottom,
                              lastMessageForInboxSortId: threadViewModel.lastMessageForInbox?.sortId)
@@ -101,8 +104,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                                   updateToken: CVUpdateToken) {
         AssertIsOnMainThread()
 
-        owsAssertDebug(self.viewState.scrollContinuityMap != nil)
-
         guard hasViewWillAppearEverBegun else {
             // It's safe to ignore updates before viewWillAppear
             // if called for the first time.
@@ -240,7 +241,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         // Do not discard scrollContinuityMap if it corresponds to a
         // subsequent load. Animated and non-animated loads might
         // land in any order and thus complete out of order.
-        owsAssertDebug(viewState.scrollContinuityMap != nil)
         self.viewState.scrollContinuityMap = nil
 
         self.loadCoordinator.loadDidLand()
@@ -377,7 +377,9 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         benchSteps.step("2")
 
         scrollToInitialPosition(animated: false)
-        clearInitialScrollState()
+        if self.hasViewDidAppearEverCompleted {
+            clearInitialScrollState()
+        }
 
         benchSteps.step("3")
 
@@ -403,7 +405,9 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             return
         }
         viewState.hasAppliedFirstLoad = true
-        clearInitialScrollState()
+        if self.hasViewDidAppearEverCompleted {
+            clearInitialScrollState()
+        }
     }
 
     private func updateReloadingAll(renderState: CVRenderState,
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index b6a00e2fd81..a0439658cf5 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -1004,12 +1004,6 @@ - (void)viewDidAppear:(BOOL)animated
             if (!self.requestView) {
                 [self popKeyBoard];
             }
-
-            // When we programmatically pop the keyboard here,
-            // the scroll position gets into a weird state and
-            // content is hidden behind the keyboard so we restore
-            // it to the default position.
-            [self scrollToInitialPositionAnimated:YES];
             break;
         case ConversationViewActionAudioCall:
             [self startIndividualAudioCall];
@@ -1025,6 +1019,11 @@ - (void)viewDidAppear:(BOOL)animated
             break;
     }
 
+    [self scrollToInitialPositionAnimated:NO];
+    if (self.viewState.hasAppliedFirstLoad) {
+        [self clearInitialScrollState];
+    }
+
     // Clear the "on open" state after the view has been presented.
     self.actionOnOpen = ConversationViewActionNone;
 
