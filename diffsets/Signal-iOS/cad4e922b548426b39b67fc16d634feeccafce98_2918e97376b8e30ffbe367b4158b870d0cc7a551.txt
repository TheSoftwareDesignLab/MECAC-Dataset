diff --git a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift
index 80418de298e..2732bedca74 100644
--- a/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift
+++ b/SignalServiceKit/Backups/Archiving/Archivers/ChatItem/BackupOversizeTextCache.swift
@@ -7,8 +7,8 @@ public import GRDB
 
 /// This table is used exclusively by backups to import/export inlined "oversize" text.
 ///
-/// For Context: "oversize" text is when a message's body exceeds ``kOversizeTextMessageSizeThreshold`` bytes;
-/// the full text (including the first ``kOversizeTextMessageSizeThreshold`` bytes) is represented as an Attachment
+/// For Context: "oversize" text is when a message's body exceeds ``OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes``;
+/// the full text (including the first ``OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes`` bytes) is represented as an Attachment
 /// for purposes of message sending/receiving.
 /// Backups have a separate, larger threshold (``BackupOversizeTextCache/maxTextLengthBytes``). All oversize
 /// text attachments are truncated to this length and inlined in the backup proto (bytes past this length are simply dropped).
@@ -30,7 +30,7 @@ public struct BackupOversizeTextCache: Codable, FetchableRecord, MutablePersista
 
     /// Every row in this table is limited to this many bytes (not characters) of text, in both
     /// the Swift model object and at the SQLite level.
-    public static let maxTextLengthBytes = 128 * 1024
+    public static let maxTextLengthBytes = OWSMediaUtils.kMaxOversizeTextMessageReceiveSizeBytes
 
     public typealias IDType = Int64
 
@@ -148,10 +148,11 @@ class BackupArchiveInlinedOversizeTextArchiver {
         context: BackupArchive.ArchivingContext,
     ) -> BackupArchive.ArchiveInteractionResult<ArchivedMessageBody> {
         var text = text
-        let originalTextLength =  text.lengthOfBytes(using: .utf8)
-        if originalTextLength > kOversizeTextMessageSizeThreshold {
-            // TSMessage bodies should never be past this length? How is this possible?
-            text = text.trimToUtf8ByteCount(Int(kOversizeTextMessageSizeThreshold))
+        // It was possible, in the past, to end up with inlined text
+        // longer than OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes; inline
+        // this now at the oversize text limit.
+        if text.lengthOfBytes(using: .utf8) > BackupOversizeTextCache.maxTextLengthBytes {
+            text = text.trimToUtf8ByteCount(BackupOversizeTextCache.maxTextLengthBytes)
         }
 
         let oversizedTextReference = attachmentStore.fetchFirstReference(
@@ -202,7 +203,10 @@ class BackupArchiveInlinedOversizeTextArchiver {
             case .bubbleUpError(let error):
                 return error
             case .continue(let oversizedTextPointer):
-                let body = ArchivedMessageBody(inlinedText: text, oversizedTextPointer: oversizedTextPointer)
+                let body = ArchivedMessageBody(
+                    inlinedText: text.trimToUtf8ByteCount(OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes),
+                    oversizedTextPointer: oversizedTextPointer
+                )
                 if partialErrors.isEmpty {
                     return .success(body)
                 } else {
@@ -236,8 +240,11 @@ class BackupArchiveInlinedOversizeTextArchiver {
             text = text.trimToUtf8ByteCount(BackupOversizeTextCache.maxTextLengthBytes)
         }
         let messageBody: MessageBody
-        if inlinedTextLength > kOversizeTextMessageSizeThreshold {
-            messageBody = MessageBody(text: text.trimToUtf8ByteCount(Int(kOversizeTextMessageSizeThreshold)), ranges: bodyRanges)
+        if inlinedTextLength > OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes {
+            messageBody = MessageBody(
+                text: text.trimToUtf8ByteCount(OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes),
+                ranges: bodyRanges
+            )
         } else {
             messageBody = MessageBody(text: text, ranges: bodyRanges)
         }
@@ -249,7 +256,7 @@ class BackupArchiveInlinedOversizeTextArchiver {
                     .invalidProtoData(.longTextStandardMessageMissingBody),
                     chatItemId
                 )])
-            } else if inlinedTextLength > kOversizeTextMessageSizeThreshold {
+            } else if inlinedTextLength > OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes {
                 // If we have an oversize text attachment, we are not allowed to _also_
                 // have inlined oversize text (that exceeds the standard body length limit).
                 partialErrors.append(.restoreFrameError(
@@ -261,7 +268,7 @@ class BackupArchiveInlinedOversizeTextArchiver {
             } else {
                 oversizeText = .attachmentPointer(oversizeTextAttachment)
             }
-        } else if inlinedTextLength > kOversizeTextMessageSizeThreshold {
+        } else if inlinedTextLength > OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes {
             oversizeText = .inlined(text)
         } else {
             oversizeText = nil
diff --git a/SignalServiceKit/Groups/GroupManager.swift b/SignalServiceKit/Groups/GroupManager.swift
index e6cbe65233d..6d336157c00 100644
--- a/SignalServiceKit/Groups/GroupManager.swift
+++ b/SignalServiceKit/Groups/GroupManager.swift
@@ -33,8 +33,7 @@ public class GroupManager: NSObject {
     // Epoch 5: Promote pending PNI members
     public static let changeProtoEpoch: UInt32 = 5
 
-    // This matches kOversizeTextMessageSizeThreshold.
-    public static let maxEmbeddedChangeProtoLength: UInt = 2 * 1024
+    public static let maxEmbeddedChangeProtoLength: UInt = UInt(OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes)
 
     // MARK: - Group IDs
 
diff --git a/SignalServiceKit/Messages/Attachments/OWSMediaUtils.swift b/SignalServiceKit/Messages/Attachments/OWSMediaUtils.swift
index 59a24362fa1..19cdcf0a254 100644
--- a/SignalServiceKit/Messages/Attachments/OWSMediaUtils.swift
+++ b/SignalServiceKit/Messages/Attachments/OWSMediaUtils.swift
@@ -230,4 +230,20 @@ public enum OWSMediaUtils {
     public static let kMaxVideoDimensions: CGFloat = 4096 // 4k video width
     public static let kMaxAnimatedImageDimensions: UInt = 12 * 1024
     public static let kMaxStillImageDimensions: UInt = 12 * 1024
+
+    /// Text past this size on send (excluding forwarding) is truncated to this length and the rest
+    /// is sent as an oversize text attachment.
+    /// Text past this side on receive is considered an invalid message and will be dropped.
+    public static let kOversizeTextMessageSizeThresholdBytes = 2 * 1024
+    /// Oversize text attachments past this size will be truncated on send.
+    public static let kMaxOversizeTextMessageSendSizeBytes = 64 * 1024
+    /// Oversize text attachments past this size will be rejected on receive. (Larger than send
+    /// to support legacy cases)
+    public static let kMaxOversizeTextMessageReceiveSizeBytes = 128 * 1024
+}
+
+@objc
+class OWSMediaUtilsObjc: NSObject {
+    @objc
+    public static let kOversizeTextMessageSizeThresholdBytes = UInt(OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes)
 }
diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
index e88cbabb00a..65b31d9399a 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
@@ -230,7 +230,7 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
         var oversizedTextInputs = [Key: Input]()
         var results = [Key: ValidatedMessageBody]()
         for (key, messageBody) in texts {
-            let truncatedText = messageBody.text.trimmedIfNeeded(maxByteCount: Int(kOversizeTextMessageSizeThreshold))
+            let truncatedText = messageBody.text.trimmedIfNeeded(maxByteCount: OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes)
             guard let truncatedText else {
                 // No need to truncate
                 results[key] = .inline(messageBody)
diff --git a/SignalServiceKit/Messages/Interactions/Quotes/QuotedReplyManagerImpl.swift b/SignalServiceKit/Messages/Interactions/Quotes/QuotedReplyManagerImpl.swift
index c4f8668277c..fea63fec069 100644
--- a/SignalServiceKit/Messages/Interactions/Quotes/QuotedReplyManagerImpl.swift
+++ b/SignalServiceKit/Messages/Interactions/Quotes/QuotedReplyManagerImpl.swift
@@ -500,11 +500,11 @@ public class QuotedReplyManagerImpl: QuotedReplyManager {
                     let oversizeTextData = try? attachment?.asStream()?.decryptedRawData(),
                     let oversizeText = String(data: oversizeTextData, encoding: .utf8)
                 {
-                    // We don't need to include the entire text body of the message, just
-                    // enough to render a snippet.  kOversizeTextMessageSizeThreshold is our
-                    // limit on how long text should be in protos since they'll be stored in
+                    // We don't need to include the entire text body of the message, just enough
+                    // to render a snippet.  OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes
+                    // is our limit on how long text should be in protos since they'll be stored in
                     // the database. We apply this constant here for the same reasons.
-                    let truncatedText = oversizeText.trimToUtf8ByteCount(Int(kOversizeTextMessageSizeThreshold))
+                    let truncatedText = oversizeText.trimToUtf8ByteCount(OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes)
                     return createDraftReply(content: .text(
                         MessageBody(text: truncatedText, ranges: originalMessage.bodyRanges ?? .empty)
                     ))
diff --git a/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.h b/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.h
index 91079321e56..e43e92b8814 100644
--- a/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.h
+++ b/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.h
@@ -8,8 +8,6 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-extern const NSUInteger kOversizeTextMessageSizeThreshold;
-
 @class OWSOutgoingSyncMessage;
 @class SignalServiceAddress;
 @class TSContactThread;
diff --git a/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.m b/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.m
index 2d6058daff0..785b6f591ea 100644
--- a/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.m
+++ b/SignalServiceKit/Messages/Interactions/TSOutgoingMessage.m
@@ -12,7 +12,6 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-const NSUInteger kOversizeTextMessageSizeThreshold = 2 * 1024;
 
 NSString *const kTSOutgoingMessageSentRecipientAll = @"kTSOutgoingMessageSentRecipientAll";
 
@@ -435,7 +434,11 @@ - (nullable SSKProtoDataMessageBuilder *)dataMessageBuilderWithThread:(TSThread
     }
 
     NSString *body = self.body;
-    NSString *trimmedBody = [body trimToUtf8ByteCount:(NSInteger)kOversizeTextMessageSizeThreshold];
+    NSString *trimmedBody =
+        [body trimToUtf8ByteCount:(NSInteger)OWSMediaUtilsObjc.kOversizeTextMessageSizeThresholdBytes];
+    // It was historically possible to end up with a message in the database that
+    // exceeds this threshold, and therefore possible to hit this assert (by forwarding
+    // an older message). But it is good for us to know when this happens.
     OWSAssertDebug(body.length == trimmedBody.length);
     [builder setBody:trimmedBody];
 
diff --git a/SignalServiceKit/Messages/MessageReceiver.swift b/SignalServiceKit/Messages/MessageReceiver.swift
index 47f1a56ccdd..d1217dab9c0 100644
--- a/SignalServiceKit/Messages/MessageReceiver.swift
+++ b/SignalServiceKit/Messages/MessageReceiver.swift
@@ -969,8 +969,10 @@ public final class MessageReceiver {
             return nil
         }
 
-        // TODO: change this back to kOversizeTextMessageSizeThreshold
-        guard dataMessage.body?.utf8.count ?? 0 <= 6000 else {
+        // TODO: ideally, messages with bodies >OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes
+        // but <=OWSMediaUtils.kMaxOversizeTextMessageReceiveSizeBytes would be truncated inline and transformed
+        // into oversized text attachments.
+        guard dataMessage.body?.utf8.count ?? 0 <= OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes else {
             Logger.error("Dropping message with too large body: \(dataMessage.body?.utf8.count ?? 0)")
             return nil
         }
diff --git a/SignalServiceKit/Messages/OutgoingMessagePreparer/PreparedOutgoingMessage.swift b/SignalServiceKit/Messages/OutgoingMessagePreparer/PreparedOutgoingMessage.swift
index 6ce13b56bd2..97d443bf3e2 100644
--- a/SignalServiceKit/Messages/OutgoingMessagePreparer/PreparedOutgoingMessage.swift
+++ b/SignalServiceKit/Messages/OutgoingMessagePreparer/PreparedOutgoingMessage.swift
@@ -317,7 +317,7 @@ public class PreparedOutgoingMessage {
         }()
 
         if let body {
-            owsAssertDebug(body.lengthOfBytes(using: .utf8) <= kOversizeTextMessageSizeThreshold)
+            owsAssertDebug(body.lengthOfBytes(using: .utf8) <= OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes)
         }
     }
 
diff --git a/SignalServiceKit/Util/LinkValidator.swift b/SignalServiceKit/Util/LinkValidator.swift
index b3463d5ac02..d3b9e218190 100644
--- a/SignalServiceKit/Util/LinkValidator.swift
+++ b/SignalServiceKit/Util/LinkValidator.swift
@@ -45,7 +45,7 @@ public enum LinkValidator {
 
     public static func firstLinkPreviewURL(in entireMessage: MessageBody) -> URL? {
         // Don't include link previews for oversize text messages.
-        guard entireMessage.text.utf8.dropFirst(Int(kOversizeTextMessageSizeThreshold)).isEmpty else {
+        guard entireMessage.text.utf8.dropFirst(OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes).isEmpty else {
             return nil
         }
 
diff --git a/SignalShareExtension/SharingThreadPickerViewController.swift b/SignalShareExtension/SharingThreadPickerViewController.swift
index 037e8852363..a62c566beb5 100644
--- a/SignalShareExtension/SharingThreadPickerViewController.swift
+++ b/SignalShareExtension/SharingThreadPickerViewController.swift
@@ -34,7 +34,8 @@ class SharingThreadPickerViewController: ConversationPickerViewController {
 
     var isTextMessage: Bool {
         guard let attachments = attachments, attachments.count == 1, let attachment = attachments.first else { return false }
-        return attachment.isConvertibleToTextMessage && attachment.dataLength <= kOversizeTextMessageSizeThreshold
+        // TODO: it may be convertible to an oversize text message, check that
+        return attachment.isConvertibleToTextMessage && attachment.dataLength <= OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes
     }
 
     var isContactShare: Bool {
@@ -578,7 +579,7 @@ extension SharingThreadPickerViewController: ConversationPickerDelegate {
         if !storySelections.isEmpty, let attachments = attachments {
             let areImagesOrVideos = attachments.allSatisfy({ $0.isValidImage || $0.isValidVideo })
             let isTextMessage = attachments.count == 1 && attachments.first.map {
-                $0.isConvertibleToTextMessage && $0.dataLength <= kOversizeTextMessageSizeThreshold
+                $0.isConvertibleToTextMessage && $0.dataLength <= OWSMediaUtils.kOversizeTextMessageSizeThresholdBytes
             } ?? false
             if !areImagesOrVideos && !isTextMessage {
                 // Can't send to stories!
