diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index ec8b2f58616..6dd1b4647c3 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -659,6 +659,7 @@
 		45BD60821DE9547E00A8F436 /* Contacts.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 45BD60811DE9547E00A8F436 /* Contacts.framework */; settings = {ATTRIBUTES = (Weak, ); }; };
 		45C845AD291466C0005F6EA5 /* JournalingOrderedDictionary.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45C845AC291466C0005F6EA5 /* JournalingOrderedDictionary.swift */; };
 		45C845AF291467F7005F6EA5 /* JournalingOrderedDictionaryTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45C845AE291467F7005F6EA5 /* JournalingOrderedDictionaryTests.swift */; };
+		45CADA8B298DD2B4009EBDF5 /* MediaTileScrollFlag.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45CADA8A298DD2B4009EBDF5 /* MediaTileScrollFlag.swift */; };
 		45CB2FA81CB7146C00E1B343 /* Launch Screen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 45CB2FA71CB7146C00E1B343 /* Launch Screen.storyboard */; };
 		45D062F527D7F49800BD505E /* OWSContactsManagerTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45D062F427D7F49800BD505E /* OWSContactsManagerTest.swift */; };
 		45D49115296F69AA00B92BB1 /* AllMediaViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45D49114296F69AA00B92BB1 /* AllMediaViewController.swift */; };
@@ -3022,6 +3023,7 @@
 		45BD60811DE9547E00A8F436 /* Contacts.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Contacts.framework; path = System/Library/Frameworks/Contacts.framework; sourceTree = SDKROOT; };
 		45C845AC291466C0005F6EA5 /* JournalingOrderedDictionary.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = JournalingOrderedDictionary.swift; sourceTree = "<group>"; };
 		45C845AE291467F7005F6EA5 /* JournalingOrderedDictionaryTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = JournalingOrderedDictionaryTests.swift; sourceTree = "<group>"; };
+		45CADA8A298DD2B4009EBDF5 /* MediaTileScrollFlag.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaTileScrollFlag.swift; sourceTree = "<group>"; };
 		45CB2FA71CB7146C00E1B343 /* Launch Screen.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; name = "Launch Screen.storyboard"; path = "Signal/src/util/Launch Screen.storyboard"; sourceTree = SOURCE_ROOT; };
 		45D062F427D7F49800BD505E /* OWSContactsManagerTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSContactsManagerTest.swift; sourceTree = "<group>"; };
 		45D231761DC7E8F10034FA89 /* SessionResetJob.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SessionResetJob.swift; sourceTree = "<group>"; };
@@ -6126,6 +6128,7 @@
 				4585B4A2291B2BFB003A8F8E /* MediaGalleryCollectionViewUpdater.swift */,
 				1700E33828B568200073D949 /* MediaGallerySections.swift */,
 				45F32C1D205718B000A300D5 /* MediaPageViewController.swift */,
+				45CADA8A298DD2B4009EBDF5 /* MediaTileScrollFlag.swift */,
 				454A84032059C787008B8C75 /* MediaTileViewController.swift */,
 				45B821F82981F7D400BB08BE /* VideoDurationHelper.swift */,
 			);
@@ -10870,6 +10873,7 @@
 				4C8A6DFE22E54AFA00469AE7 /* MediaInteractiveDismiss.swift in Sources */,
 				45F32C232057297A00A300D5 /* MediaPageViewController.swift in Sources */,
 				4CD675C722E7D393008010D2 /* MediaPresentationContext.swift in Sources */,
+				45CADA8B298DD2B4009EBDF5 /* MediaTileScrollFlag.swift in Sources */,
 				454A84042059C787008B8C75 /* MediaTileViewController.swift in Sources */,
 				4C8A6DFC22E5499300469AE7 /* MediaZoomAnimationController.swift in Sources */,
 				8837F74123DA0B0F00772A32 /* MegaphoneView.swift in Sources */,
diff --git a/Signal/src/ViewControllers/MediaGallery/MediaTileScrollFlag.swift b/Signal/src/ViewControllers/MediaGallery/MediaTileScrollFlag.swift
new file mode 100644
index 00000000000..983d296edab
--- /dev/null
+++ b/Signal/src/ViewControllers/MediaGallery/MediaTileScrollFlag.swift
@@ -0,0 +1,59 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+// The view next to the scroll indicator that shows the currently visible month.
+class MediaTileScrollFlag: UIView {
+    private let label = UILabel()
+    private let inset = CGSize(width: 12.0, height: 6.0)
+    var stringValue: String {
+        get {
+            return label.text ?? ""
+        }
+        set {
+            label.text = newValue
+        }
+    }
+
+    init() {
+        super.init(frame: .zero)
+
+        addSubview(label)
+
+        layer.cornerRadius = 14.0
+        updateColors()
+    }
+
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    override func sizeToFit() {
+        label.sizeToFit()
+        var bounds = self.bounds
+        bounds.size = label.frame.insetBy(dx: -inset.width, dy: -inset.height).size
+        self.bounds = bounds
+    }
+
+    override func layoutSubviews() {
+        label.frame = bounds.insetBy(dx: inset.width, dy: inset.height)
+    }
+
+    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
+        updateColors()
+        super.traitCollectionDidChange(previousTraitCollection)
+    }
+
+    private func updateColors() {
+        if Theme.isDarkThemeEnabled {
+            label.textColor = .ows_gray02
+            layer.backgroundColor = UIColor(rgbHex: 0x3b3b3b).withAlphaComponent(0.8).cgColor
+        } else {
+            label.textColor = UIColor.ows_gray90
+            layer.backgroundColor = UIColor(rgbHex: 0xfafafa).withAlphaComponent(0.8).cgColor
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/MediaGallery/MediaTileViewController.swift b/Signal/src/ViewControllers/MediaGallery/MediaTileViewController.swift
index 347567ff0c0..8b1960e24d0 100644
--- a/Signal/src/ViewControllers/MediaGallery/MediaTileViewController.swift
+++ b/Signal/src/ViewControllers/MediaGallery/MediaTileViewController.swift
@@ -206,8 +206,170 @@ public class MediaTileViewController: UICollectionViewController, MediaGalleryDe
 
     // MARK: UICollectionViewDelegate
 
+    private let scrollFlag = MediaTileScrollFlag()
+
+    private var willDecelerate = false
+    private var scrollingToTop = false
+
+    override public func scrollViewShouldScrollToTop(_ scrollView: UIScrollView) -> Bool {
+        scrollingToTop = true
+        return true
+    }
+
+    override public func scrollViewDidScrollToTop(_ scrollView: UIScrollView) {
+        scrollingToTop = false
+        showOrHideScrollFlag()
+    }
+
+    override public func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
+        willDecelerate = decelerate
+    }
+
+    override public func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
+        willDecelerate = false
+        showOrHideScrollFlag()
+    }
+
+    private var scrollFlagShouldBeVisible = false
+
     override public func scrollViewDidScroll(_ scrollView: UIScrollView) {
         self.autoLoadMoreIfNecessary()
+        showOrHideScrollFlag()
+        if scrollFlag.superview != nil {
+            updateScrollFlag()
+        }
+    }
+
+    private func showOrHideScrollFlag() {
+        if #unavailable(iOS 12) {
+            return
+        }
+        if collectionView.isTracking || scrollingToTop {
+            willDecelerate = false
+            scrollFlagShouldBeVisible = true
+            if scrollFlag.superview == nil {
+                collectionView?.addSubview(scrollFlag)
+            }
+            scrollFlag.alpha = 1.0
+        } else if scrollFlagShouldBeVisible && !willDecelerate {
+            scrollFlagShouldBeVisible = false
+            UIView.animate(withDuration: 0.25) {
+                self.scrollFlag.alpha = 0.0
+            }
+        }
+    }
+
+    // Like indexPathsForVisibleItems but excludes those obscured by the navigation bar.
+    private var reallyVisibleIndexPaths: [IndexPath] {
+        guard let superview = collectionView.superview else {
+            return []
+        }
+        let visibleFrame = collectionView.convert(collectionView.frame.inset(by: collectionView.safeAreaInsets),
+                                                  from: superview)
+        return collectionView.indexPathsForVisibleItems.filter { indexPath in
+            guard let cell = collectionView.cellForItem(at: indexPath) else {
+                return false
+            }
+            return cell.frame.intersects(visibleFrame)
+        }
+    }
+
+    private func updateScrollFlag() {
+        if #unavailable(iOS 12) {
+            return
+        }
+        guard mediaGallery.galleryDates.count > 0,
+              let indexPath = reallyVisibleIndexPaths.min(by: { lhs, rhs in
+                  return lhs.section < rhs.section
+              }) else {
+            scrollFlag.alpha = 0.0
+            return
+        }
+        let i = max(0, indexPath.section - 1)
+        let date = mediaGallery.galleryDates[i]
+        scrollFlag.stringValue = date.localizedString
+        scrollFlag.sizeToFit()
+
+        scrollFlag.center = guessCenterOfFlag()
+    }
+
+    private func guessCenterOfFlag() -> CGPoint {
+        let currentOffset = collectionView.contentOffset.y
+        let contentHeight = collectionView.contentSize.height
+        let visibleHeight = collectionView.bounds.height
+
+        // This crazy mess is to figure out where the scroll indicator is. It is complicated by
+        // the fact that the scrollbar's exact location is not exposed, nor is the minimum
+        // height of the indicator.
+
+        let scrollbarInsets = {
+            // This code is cursed and I'm sorry.
+            let hasNotch = (UIApplication.shared.keyWindow?.safeAreaInsets.bottom) ?? 0 > 0
+            if !hasNotch {
+                return UIEdgeInsets.zero
+            }
+            switch UIApplication.shared.statusBarOrientation {
+            case .portrait, .portraitUpsideDown, .unknown, .landscapeRight:
+                // Note that adjustedContentInset is used because it seems to include the
+                // rounded corners of the device, whereas safeAreaInsets is not enough.
+                var result = collectionView.adjustedContentInset
+                if UIDevice.current.userInterfaceIdiom == .pad {
+                    result.bottom = 8.0
+                }
+                result.right = 0
+                return result
+            case .landscapeLeft:
+                // In landscape the horizontal line to indicate swipe direction makes the bottom inset
+                // too big. safeAreaInsets isn't right either. I don't think iOS exposes anything so
+                // I'm hardcoding this until a better idea comes along.
+                var result = collectionView.adjustedContentInset
+                result.bottom = 8.0
+                // In landscape left the scroll indicator is shifted way in, but its adjusted
+                // content inset is 0.
+                result.right = collectionView.safeAreaInsets.right
+                return result
+            @unknown default:
+                return collectionView.adjustedContentInset
+            }
+        }()
+        // If iOS had a scrollbar, `scrollbarHeight` is how tall it would be. The scroll
+        // indicator moves through an area of this height.
+        let scrollbarHeight = collectionView.frame.height - scrollbarInsets.top - scrollbarInsets.bottom
+        let rightInset = 20.0 + scrollbarInsets.right
+
+        // Set a minimum height for the handle. iOS has no API for this.
+        let minimumHandleHeight = UIDevice.current.userInterfaceIdiom == .pad ? 42.0 : 36.0
+
+        // How much of the content is visible?
+        let fractionVisible = visibleHeight / contentHeight
+
+        // Guess how tall the indicator is.
+        let indicatorHeight = max(minimumHandleHeight,
+                                  scrollbarHeight * fractionVisible)
+
+        // First we calculate what fraction (from 0 to 1) is the top of the visible area at. This can't move through
+        // the entire contentSize (except during overscroll, which we ignore). Reucing the denominator by visibleHeight
+        // ensures it's at 1.0 when you're scrolled all the way down.
+        let topFrac = collectionView.contentOffset.y / max(collectionView.contentOffset.y,
+                                                           collectionView.contentSize.height - visibleHeight)
+        // Next we figure out what the "range of motion" of the indicator is. It can only move through
+        // scrollbarHeight minus its minimum height.
+        let indicatorRangeOfMotion = scrollbarHeight - indicatorHeight
+
+        // Now it's easy to calculate the vertical offset of the *top* of the indicator within the scrollbar.
+        let indicatorOffsetInScrollbar = indicatorRangeOfMotion * topFrac
+
+        // Calculate the top of the scrollbar.
+        let scrollbarMinY = scrollbarInsets.top + currentOffset
+
+        // Finally, we can calculate the coordinate of the vertical center of the indicator.
+        let indicatorMidY = indicatorOffsetInScrollbar + indicatorHeight / 2.0 + scrollbarMinY
+
+        let center = CGPoint(
+            x: collectionView.bounds.width - rightInset - scrollFlag.bounds.width / 2.0,
+            y: indicatorMidY
+        )
+        return center
     }
 
     var previousAdjustedContentInset: UIEdgeInsets = UIEdgeInsets()
@@ -226,6 +388,8 @@ public class MediaTileViewController: UICollectionViewController, MediaGalleryDe
                     scrollView.contentSize.height - scrollView.bounds.height + scrollView.adjustedContentInset.bottom
             }
         }
+
+        updateScrollFlag()
     }
 
     override public func collectionView(_ collectionView: UICollectionView, shouldSelectItemAt indexPath: IndexPath) -> Bool {
@@ -491,7 +655,13 @@ public class MediaTileViewController: UICollectionViewController, MediaGalleryDe
         layout.sectionInsetReference = .fromSafeArea
         layout.minimumInteritemSpacing = kInterItemSpacing
         layout.minimumLineSpacing = kInterItemSpacing
-        layout.sectionHeadersPinToVisibleBounds = true
+        if #available(iOS 12, *) {
+            // Modern design
+            layout.sectionHeadersPinToVisibleBounds = false
+        } else {
+            // Legacy design, which I can't test easily.
+            layout.sectionHeadersPinToVisibleBounds = true
+        }
 
         return layout
     }
