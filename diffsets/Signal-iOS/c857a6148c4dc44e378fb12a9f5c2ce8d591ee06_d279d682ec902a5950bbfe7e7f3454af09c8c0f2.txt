diff --git a/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift b/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift
index 42a07e687a3..bfb825316f8 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift	
@@ -854,6 +854,17 @@ extension CLVTableDataSource {
 public class CLVTableView: UITableView {
     fileprivate var lastReloadDate: Date?
 
+    // A `tableFooterView` that always expands to fill available contentSize
+    // when the table view contents otherwise wouldn't fill the space. This
+    // supports Filter by Unread by helping to make transitions between very
+    // large and very small chat lists more consistent. What this does in
+    // practice is to prevent a glitch where the search bar would momentarily
+    // disappears and then animates back in with the adjusted content insets.
+    //
+    // It also allows the user to swipe up to dismiss the search bar (if the
+    // content height is too small, the search bar otherwise becomes un-hideable).
+    let footerView = UIView()
+
     public override func reloadData() {
         AssertIsOnMainThread()
 
@@ -864,10 +875,50 @@ public class CLVTableView: UITableView {
 
     public init() {
         super.init(frame: .zero, style: .grouped)
+        tableFooterView = footerView
     }
 
     @available(*, unavailable, message: "use other constructor instead.")
     required init?(coder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
+
+    public override func layoutSubviews() {
+        super.layoutSubviews()
+        updateFooterHeight()
+    }
+
+    public override func adjustedContentInsetDidChange() {
+        super.adjustedContentInsetDidChange()
+        updateFooterHeight()
+    }
+
+    private func updateFooterHeight() {
+        let visibleRect = frame.inset(by: adjustedContentInset)
+        let headerHeight = tableHeaderView?.frame.height ?? 0
+
+        // Compute whether the total height content height (excluding the footer)
+        // fits in the available space.
+        var availableHeight = visibleRect.height - headerHeight
+        for section in 0 ..< numberOfSections where availableHeight > 0 {
+            let newValue = availableHeight - rect(forSection: section).height
+            availableHeight = max(0, newValue)
+        }
+
+        // Add one pixel to the final height of the footer to ensure the content
+        // height is always slightly larger than the available space and thus
+        // remains scrollable.
+        //
+        // What this code *doesn't* do is cause scroll indicators to appear when
+        // they shouldn't, because this value is smaller than the amount the
+        // adjusted content insets can change by (i.e., the height of the expanded
+        // search bar).
+        let displayScale = (window?.windowScene?.screen ?? .main).scale
+        let finalHeight = availableHeight + 1 / displayScale
+
+        if footerView.frame.height != finalHeight {
+            footerView.frame.height = finalHeight
+            performBatchUpdates(nil)
+        }
+    }
 }
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift
index 8c6d79162f8..1fa9a40c5e4 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift	
@@ -6,8 +6,9 @@
 import SignalServiceKit
 import UIKit
 
+@MainActor
 protocol ChatListFilterControlDelegate: AnyObject {
-    func filterControlDidStartFiltering()
+    func filterControlWillStartFiltering()
 }
 
 final class ChatListFilterControl: UIView, UIScrollViewDelegate {
@@ -67,8 +68,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         case willStartFiltering
 
         /// `isFiltering == true` where `state >= .filterPending`. Started
-        /// filtering (i.e., called `delegate.filterControlDidStartFiltering()`),
-        /// but haven't finished animating into the "docked" position.
+        /// filtering but haven't finished animating into the "docked" position.
         case filterPending
 
         /// Actively filtering and control is docked to the top of the scroll view.
@@ -97,8 +97,8 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
     }
 
-    private var animationDuration: CGFloat {
-        UIView.inheritedAnimationDuration == 0 ? CATransaction.animationDuration() : UIView.inheritedAnimationDuration
+    private func animationDuration(_ defaultDuration: @autoclosure () -> CGFloat = CATransaction.animationDuration()) -> CGFloat {
+        UIView.inheritedAnimationDuration == 0 ? defaultDuration() : UIView.inheritedAnimationDuration
     }
 
     private var contentHeight: CGFloat {
@@ -150,8 +150,8 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
 
     var preferredContentHeight: CGFloat = 52.0 {
         didSet {
-            if state < .filterPending, let scrollView {
-                scrollView.contentInset.top = preferredContentHeight
+            if state < .filterPending {
+                scrollView?.contentInset.top = -preferredContentHeight
             }
             setNeedsLayout()
         }
@@ -223,6 +223,12 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
     }
 
+    override func didMoveToWindow() {
+        super.didMoveToWindow()
+
+        updateContentInset()
+    }
+
     override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
         // clippingView's position is logically relative to the scroll view's
         // frame, not its bounds (i.e., it's docked near the top of the scroll
@@ -289,30 +295,48 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         contentView.frame.size = bounds.size
         contentView.layoutMargins = layoutMargins
 
-        if let scrollView {
-            var contentInset = -contentHeight
+        updateContentOrigin()
+
+        let horizontalMargins = UIEdgeInsets(top: 0, left: layoutMargins.left, bottom: 0, right: layoutMargins.right)
+        let fullBleedRect = contentView.bounds.inset(by: horizontalMargins)
+
+        clearButton.frame = fullBleedRect
+        clearButton.sizeToFit()
+        clearButton.center = contentView.bounds.center
+
+        let imageHeight = clearButton.frame.height
+        let imageSize = CGSize(width: imageHeight, height: imageHeight)
+        for imageView in imageViews {
+            imageView.frame.size = imageSize
+        }
+        imageContainer.frame.size = imageSize
+        imageContainer.center = contentView.bounds.center
+    }
+
+    func updateContentOrigin() {
+        do {
             var scrollIndicatorInset = max(0, -adjustedContentOffset.y)
 
             if state >= .filterPending {
-                contentInset = 0
                 scrollIndicatorInset += contentHeight
             }
 
-            scrollView.contentInset.top = contentInset
-            scrollView.verticalScrollIndicatorInsets.top = scrollIndicatorInset
+            scrollView?.verticalScrollIndicatorInsets.top = scrollIndicatorInset
 
             // clippingView is offset so that its Y position is always at a
             // logical content offset of 0, never behind the top bar. This
             // prevents the contentView from blending with the navigation bar
             // background material.
-            var clippingOrigin = adjustedContentOffset
-            clippingOrigin.y -= contentInset
-            clippingView.frame.origin = clippingOrigin
+            if let scrollView, let container = scrollView.superview {
+                let safeAreaRect = scrollView.frame.inset(by: scrollView.safeAreaInsets)
+                let contentOrigin = container.convert(safeAreaRect.origin, to: self)
+                clippingView.frame.origin = contentOrigin
+            }
         }
 
         // clippingView's height is adjusted so that it's only >0 in the
         // overscroll area where the pull-to-filter gesture is occuring.
-        clippingView.frame.size.height = if state >= .filterPending {
+        clippingView.frame.size.height = if state >= .willStartFiltering {
             contentHeight
         } else {
             max(0, min(contentHeight, -adjustedContentOffset.y))
@@ -339,26 +363,34 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
             contentOrigin.y = min(contentOrigin.y, 0)
             contentView.frame.origin = contentOrigin
         }
+    }
 
-        let horizontalMargins = UIEdgeInsets(top: 0, left: layoutMargins.left, bottom: 0, right: layoutMargins.right)
-        let fullBleedRect = contentView.bounds.inset(by: horizontalMargins)
-
-        clearButton.frame = fullBleedRect
-        clearButton.sizeToFit()
-        clearButton.center = contentView.bounds.center
-
-        let imageHeight = clearButton.frame.height
-        let imageSize = CGSize(width: imageHeight, height: imageHeight)
-        for imageView in imageViews {
-            imageView.frame.size = imageSize
-        }
-        imageContainer.frame.size = imageSize
-        imageContainer.center = contentView.bounds.center
+    // Setting `UIScrollView.contentInset` triggers implicit changes to both
+    // `contentOffset` and `adjustedContentInset`, and also synchronously calls
+    // the associated `UIScrollViewDelegate` methods (`scrollViewDidScroll(_:)`
+    // and `scrollViewDidChangeAdjustedContentInset(_:)`, respectively). Without
+    // a careful explicit adjustment to the content offset, this tends to break
+    // scroll view animations, causing content to snap to a new scroll position
+    // abruptly.
+    //
+    // This method:
+    //     a) avoids changing the content inset if unchanged, in order to avoid
+    //        triggering unwanted delegate callbacks, and
+    //     b) after changing the contentInset, explicitly adjusts the content
+    //        *offset* by a complementary amount, preventing unwanted animation.
+    func updateContentInset() {
+        let newValue = state >= .filterPending ? 0 : -preferredContentHeight
+        guard let scrollView, scrollView.contentInset.top != newValue else { return }
+        let difference = newValue - scrollView.contentInset.top
+        var targetOffset = scrollView.contentOffset
+        targetOffset.y -= difference
+        scrollView.contentInset.top = newValue
+        scrollView.setContentOffset(targetOffset, animated: false)
     }
 
     func startFiltering(animated: Bool) {
         if animated {
-            animateScrollViewTransition { [self] in
+            animateScrollViewTransition(withDuration: animationDuration()) { [self] in
                 UIView.performWithoutAnimation {
                     clippingView.frame = CGRect(x: 0, y: bounds.maxY, width: bounds.width, height: 0)
                     contentView.frame = CGRect(x: 0, y: -contentHeight, width: 0, height: contentHeight)
@@ -410,6 +442,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         } else {
             showClearButton(animated: false)
             state = .filtering
+            updateContentInset()
         }
     }
 
@@ -422,7 +455,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
 
         if animated {
-            animateScrollViewTransition { [self] in
+            animateScrollViewTransition(withDuration: animationDuration()) { [self] in
                 clearButton.isUserInteractionEnabled = false
                 scrollView?.contentInset.top = -contentHeight
 
@@ -479,15 +512,20 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
             feedback = nil
             state = .stopping
         case .willStartFiltering:
-            scrollView.contentInset.top = 0
-            showClearButton(animated: true)
+            delegate?.filterControlWillStartFiltering()
             state = .filterPending
-            delegate?.filterControlDidStartFiltering()
         default:
             break
         }
     }
 
+    func draggingDidEnd(in scrollView: UIScrollView) {
+        if state == .filterPending {
+            updateContentInset()
+            showClearButton(animated: true)
+        }
+    }
+
     func scrollingDidStop(in scrollView: UIScrollView) {
         if state <= .tracking {
             feedback = nil
@@ -498,11 +536,11 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
     }
 
-    private func animateScrollViewTransition(_ animations: @escaping () -> Void, completion: (() -> Void)? = nil) {
+    private func animateScrollViewTransition(withDuration duration: CGFloat, _ animations: @escaping () -> Void, completion: (() -> Void)? = nil) {
         guard !isTransitioning else {
             owsFailDebug("already transitioning; falling back to default animation")
 
-            UIView.animate(withDuration: animationDuration, delay: 0, options: .beginFromCurrentState) {
+            UIView.animate(withDuration: duration, delay: 0, options: .beginFromCurrentState) {
                 animations()
             } completion: { _ in
                 completion?()
@@ -514,14 +552,14 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         isTransitioning = true
 
         if let scrollView {
-            UIView.transition(with: scrollView, duration: animationDuration, options: .allowAnimatedContent) {
+            UIView.transition(with: scrollView, duration: duration, options: .allowAnimatedContent) {
                 animations()
             } completion: { [self] _ in
                 isTransitioning = false
                 completion?()
             }
         } else {
-            UIView.animate(withDuration: animationDuration) {
+            UIView.animate(withDuration: duration) {
                 animations()
             } completion: { [self] _ in
                 isTransitioning = false
@@ -539,14 +577,17 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
 
         let startFrame = imageContainer.frame.intersection(clearButton.frame)
-        let transitionView = TransitionEffectView(frame: startFrame)
-        transitionView.effect = UIBlurEffect(style: .systemUltraThinMaterial)
-        contentView.insertSubview(transitionView, belowSubview: imageContainer)
+        let transitionView = TransitionEffectView(effect: UIBlurEffect(style: .systemUltraThinMaterial))
         let endFrame = clearButton.frame
         let oldBackground = clearButton.configuration?.background
         clearButton.configuration?.background = .clear()
 
-        let transitionAnimator = UIViewPropertyAnimator(duration: 0.7, dampingRatio: 0.75) { [clearButton, imageContainer] in
+        UIView.performWithoutAnimation {
+            transitionView.frame = startFrame
+            contentView.insertSubview(transitionView, belowSubview: imageContainer)
+        }
+
+        let transitionAnimator = UIViewPropertyAnimator(duration: animationDuration(0.7), dampingRatio: 0.75) { [clearButton, imageContainer] in
             let duration = UIView.inheritedAnimationDuration
 
             UIView.animate(withDuration: 0.1 * duration, delay: 0) {
@@ -614,6 +655,11 @@ private extension ChatListFilterControl {
             fatalError("init(coder:) has not been implemented")
         }
 
+        override func didMoveToSuperview() {
+            super.didMoveToSuperview()
+            updateMask()
+        }
+
         override func layoutSubviews() {
             super.layoutSubviews()
             updateMask()
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift
index 9397a353627..81ef1e77b10 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
@@ -1408,6 +1408,7 @@ extension ChatListViewController {
     private func updateChatListFilter(_ inboxFilter: InboxFilter) {
         viewState.inboxFilter = inboxFilter
         loadCoordinator.saveInboxFilter(inboxFilter)
+        updateBarButtonItems()
     }
 
     private func updateFilterControlSize() {
@@ -1424,7 +1425,7 @@ extension ChatListViewController {
             // This tells UITableView to perform a layout pass, which allows it
             // to adjust to the new filterControl height even when there are no
             // datasource-driven layout changes.
-            tableView.performBatchUpdates {}
+            tableView.performBatchUpdates(nil)
         }
     }
 }
@@ -1720,17 +1721,29 @@ extension ChatListViewController: UIScrollViewDelegate {
         filterControl?.draggingWillEnd(in: scrollView)
     }
 
+    public func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate: Bool) {
+        filterControl?.draggingDidEnd(in: scrollView)
+    }
+
     public func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
         filterControl?.scrollingDidStop(in: scrollView)
     }
+
+    public func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
+        filterControl?.scrollingDidStop(in: scrollView)
+    }
 }
 
 extension ChatListViewController: ChatListFilterControlDelegate {
-    func filterControlDidStartFiltering() {
-        // Perform using the default run loop mode so that scroll view decelaration
-        // can finish gracefully before updating table content.
-        RunLoop.current.perform { [self] in
-            enableChatListFilter(filterControl)
+    func filterControlWillStartFiltering() {
+        updateChatListFilter(.unread)
+
+        // Because this happens in response to an interactive gesture, it feels
+        // better to go a little slower than the default animation duration (0.25 sec).
+        UIView.animate(withDuration: 0.4) { [self] in
+            tableView.performBatchUpdates {
+                loadCoordinator.loadIfNecessary()
+            }
         }
     }
 }
