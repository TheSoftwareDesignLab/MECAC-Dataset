diff --git a/Signal/src/ViewControllers/Photos/MediaControls.swift b/Signal/src/ViewControllers/Photos/MediaControls.swift
index 9374504ef82..c4922570f16 100644
--- a/Signal/src/ViewControllers/Photos/MediaControls.swift
+++ b/Signal/src/ViewControllers/Photos/MediaControls.swift
@@ -102,6 +102,14 @@ class CameraCaptureControl: UIView {
         shutterButtonInnerCircle.centerXAnchor.constraint(equalTo: shutterButtonOuterCircle.centerXAnchor).isActive = true
         shutterButtonInnerCircle.centerYAnchor.constraint(equalTo: shutterButtonOuterCircle.centerYAnchor).isActive = true
 
+        // Stop Button
+        stopButton.alpha = 0
+        addSubview(stopButton)
+        stopButton.autoPin(toAspectRatio: 1)
+        stopButton.autoSetDimension(.width, toSize: CameraCaptureControl.recordingLockControlSize)
+        stopButton.centerXAnchor.constraint(equalTo: shutterButtonLayoutGuide.centerXAnchor).isActive = true
+        stopButton.centerYAnchor.constraint(equalTo: shutterButtonLayoutGuide.centerYAnchor).isActive = true
+
         // The long press handles both the tap and the hold interaction, as well as the animation
         // the presents as the user begins to hold (and the button begins to grow prior to recording)
         let longPressGesture = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPress))
@@ -122,6 +130,7 @@ class CameraCaptureControl: UIView {
         case initial
         case recording
         case recordingLocked
+        case recordingUsingVoiceOver
     }
 
     private var _internalState: State = .initial
@@ -157,6 +166,9 @@ class CameraCaptureControl: UIView {
             // Hide "slide to lock" controls momentarily before animating the rest of the UI to "not recording" state.
             hideLongPressVideoRecordingControls()
         }
+        if state == .recordingUsingVoiceOver {
+            stopButton.alpha = 1
+        }
 
         if animationDuration > 0 {
             UIView.animate(withDuration: animationDuration,
@@ -201,23 +213,20 @@ class CameraCaptureControl: UIView {
         case .recordingLocked:
             // This should already by at the correct size so this assignment is "just in case".
             innerCircleSizeConstraint.constant = CameraCaptureControl.recordingLockControlSize
+
+        case .recordingUsingVoiceOver:
+            outerCircleSizeConstraint.constant = CameraCaptureControl.shutterButtonRecordingSize
+            innerCircleSizeConstraint.constant = CameraCaptureControl.recordingLockControlSize
         }
     }
 
     private func initializeVideoRecordingControlsIfNecessary() {
-        guard stopButton.superview == nil else { return }
+        guard lockIconView.superview == nil else { return }
 
-        // 1. Stop button.
-        addSubview(stopButton)
-        stopButton.autoPin(toAspectRatio: 1)
-        stopButton.autoSetDimension(.width, toSize: CameraCaptureControl.recordingLockControlSize)
-        stopButton.centerXAnchor.constraint(equalTo: shutterButtonLayoutGuide.centerXAnchor).isActive = true
-        stopButton.centerYAnchor.constraint(equalTo: shutterButtonLayoutGuide.centerYAnchor).isActive = true
-
-        // 2. Slider.
+        // 1. Slider.
         insertSubview(slidingCircleView, belowSubview: shutterButtonInnerCircle)
 
-        // 3. Lock Icon
+        // 2. Lock Icon
         addSubview(lockIconView)
         lockIconView.translatesAutoresizingMaskIntoConstraints = false
         // Centered vertically, pinned to trailing edge.
@@ -227,7 +236,7 @@ class CameraCaptureControl: UIView {
         let verticalConstraints = [ lockIconView.centerXAnchor.constraint(equalTo: shutterButtonLayoutGuide.centerXAnchor),
                                     lockIconView.bottomAnchor.constraint(equalTo: bottomAnchor) ]
 
-        // 4. Activate current constraints.
+        // 3. Activate current constraints.
         horizontalAxisConstraints.append(contentsOf: horizontalConstraints)
         if axis == .horizontal {
             addConstraints(horizontalConstraints)
@@ -279,6 +288,24 @@ class CameraCaptureControl: UIView {
         }
     }
 
+    // MARK: - Photo / Video Capture
+
+    private func capturePhoto() {
+        delegate?.cameraCaptureControlDidRequestCapturePhoto(self)
+    }
+
+    private func startVideoRecording() {
+        delegate?.cameraCaptureControlDidRequestStartVideoRecording(self)
+    }
+
+    private func cancelVideoRecording() {
+        delegate?.cameraCaptureControlDidRequestCancelVideoRecording(self)
+    }
+
+    private func finishVideoRecording() {
+        delegate?.cameraCaptureControlDidRequestFinishVideoRecording(self)
+    }
+
     // MARK: - Gestures
 
     private let animationDuration: TimeInterval = 0.2
@@ -321,7 +348,7 @@ class CameraCaptureControl: UIView {
                 guard let self = self else { return }
 
                 self.setState(.recording, isRecordingWithLongPress: true, animationDuration: 2*self.animationDuration)
-                self.delegate?.cameraCaptureControlDidRequestStartVideoRecording(self)
+                self.startVideoRecording()
             }
 
         case .changed:
@@ -433,13 +460,13 @@ class CameraCaptureControl: UIView {
                         self.setState(.initial, animationDuration: self.animationDuration)
                     })
 
-                    delegate?.cameraCaptureControlDidRequestFinishVideoRecording(self)
+                    finishVideoRecording()
                 }
 
             case .initial:
-                delegate?.cameraCaptureControlDidRequestCapturePhoto(self)
+                capturePhoto()
 
-            case .recordingLocked:
+            case .recordingLocked, .recordingUsingVoiceOver:
                 break
             }
 
@@ -447,7 +474,7 @@ class CameraCaptureControl: UIView {
             if state == .recording {
                 sliderTrackingProgress = 0
                 setState(.initial, animationDuration: animationDuration)
-                delegate?.cameraCaptureControlDidRequestCancelVideoRecording(self)
+                cancelVideoRecording()
             }
 
             touchTimer?.invalidate()
@@ -517,7 +544,7 @@ class CameraCaptureControl: UIView {
     // MARK: - Button Actions
 
     private func didTapStopButton() {
-        delegate?.cameraCaptureControlDidRequestFinishVideoRecording(self)
+        finishVideoRecording()
     }
 }
 
@@ -785,3 +812,96 @@ class MediaDoneButton: UIButton, UserInterfaceStyleOverride {
         chevronImageView.tintColor = MediaDoneButton.tintColor(for: userInterfaceStyle)
     }
 }
+
+// MARK: - Accessibility
+
+extension CameraCaptureControl {
+
+    override var isAccessibilityElement: Bool {
+        get { true }
+        set { super.isAccessibilityElement = newValue }
+    }
+
+    override var accessibilityTraits: UIAccessibilityTraits {
+        get { [ .button ] }
+        set { super.accessibilityTraits = newValue }
+    }
+
+    override var accessibilityFrame: CGRect {
+        get { UIAccessibility.convertToScreenCoordinates(shutterButtonLayoutGuide.layoutFrame, in: self) }
+        set { super.accessibilityFrame = newValue }
+    }
+
+    override var accessibilityLabel: String? {
+        get {
+            switch state {
+            case .initial:
+                return NSLocalizedString("CAMERA_VO_TAKE_PICTURE",
+                                         comment: "VoiceOver label for the round capture button in in-app camera.")
+
+            case .recordingUsingVoiceOver:
+                return NSLocalizedString("CAMERA_VO_STOP_VIDEO_REC",
+                                         comment: "VoiceOver label for the round capture button in in-app camera during video recording.")
+
+            default:
+                owsFailDebug("Invalid state")
+                return nil
+            }
+        }
+        set { super.accessibilityLabel = newValue }
+    }
+
+    override var accessibilityCustomActions: [UIAccessibilityCustomAction]? {
+        get {
+            guard state == .initial else { return [] }
+            let actionName = NSLocalizedString("CAMERA_VO_TAKE_VIDEO",
+                                               comment: "VoiceOver label for other possible action for round capture button in in-app camera.")
+            return [ UIAccessibilityCustomAction(name: actionName, target: self, selector: #selector(accessibilityStartVideoRecording)) ] }
+        set { super.accessibilityCustomActions = newValue }
+    }
+
+    override func accessibilityActivate() -> Bool {
+        switch state {
+        case .initial:
+            capturePhoto()
+
+        case .recordingUsingVoiceOver:
+            accessibilityStopVideoRecording()
+
+        default:
+            owsFailDebug("Invalid state")
+            return false
+        }
+        return true
+    }
+
+    @objc
+    private func accessibilityStartVideoRecording() {
+        startVideoRecording()
+    }
+
+    private func accessibilityStopVideoRecording() {
+        finishVideoRecording()
+    }
+}
+
+extension MediaDoneButton {
+
+    override var accessibilityLabel: String? {
+        get { CommonStrings.doneButton }
+        set { super.accessibilityLabel = newValue }
+    }
+
+    override var accessibilityValue: String? {
+        get {
+            guard badgeNumber > 0 else { return nil }
+
+            let format = NSLocalizedString("CAMERA_VO_N_ITEMS", tableName: "PluralAware",
+                                           comment: "VoiceOver text for blue Done button in camera, describing how many items have already been captured.")
+            return String.localizedStringWithFormat(format, badgeNumber)
+        }
+        set {
+            super.accessibilityValue = newValue
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/Photos/PhotoCapture.swift b/Signal/src/ViewControllers/Photos/PhotoCapture.swift
index ce3cd41ae07..ec503d22484 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCapture.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCapture.swift
@@ -531,14 +531,21 @@ class PhotoCapture: NSObject {
         if availableCameras.count == 1, let currentZoomFactor = captureDevice?.videoZoomFactor, currentZoomFactor == zoomFactor {
             zoomFactor *= 2
         }
+        updateZoomFactor(zoomFactor, animated: animated)
+    }
+
+    func changeVisibleZoomFactor(to visibleZoomFactor: CGFloat, animated: Bool) {
+        let zoomFactor = visibleZoomFactor / cameraZoomFactorMultiplier(forPosition: desiredPosition)
+        updateZoomFactor(zoomFactor, animated: animated)
+    }
+
+    private func updateZoomFactor(_ zoomFactor: CGFloat, animated: Bool) {
         sessionQueue.async { [weak self] in
             guard let self = self else { return }
             guard let captureDevice = self.captureDevice else {
                 owsFailDebug("captureDevice was unexpectedly nil")
                 return
             }
-            owsAssertDebug(position == captureDevice.position, "Attempt to select camera for incorrect position")
-
             self.update(captureDevice: captureDevice, zoomFactor: zoomFactor, animated: animated)
         }
     }
diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index 03608a1428c..942346ef9dc 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -199,9 +199,10 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
                 topBar.mode = .videoRecording
                 topBar.recordingTimerView.startCounting()
 
-                bottomBar.captureControl.setState(.recording, animationDuration: 0.4)
+                let captureControlState: CameraCaptureControl.State = UIAccessibility.isVoiceOverRunning ? .recordingUsingVoiceOver : .recording
+                bottomBar.captureControl.setState(captureControlState, animationDuration: 0.4)
                 if let sideBar = sideBar {
-                    sideBar.cameraCaptureControl.setState(.recording, animationDuration: 0.4)
+                    sideBar.cameraCaptureControl.setState(captureControlState, animationDuration: 0.4)
                 }
             } else {
                 topBar.mode = isIPadUIInRegularMode ? .closeButton : .cameraControls
@@ -494,6 +495,10 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
         let isFrontCamera = photoCapture.desiredPosition == .front
         frontCameraZoomControl?.setIsHidden(!isFrontCamera, animated: animated)
         rearCameraZoomControl?.setIsHidden(isFrontCamera, animated: animated)
+        bottomBar.switchCameraButton.isFrontCameraActive = isFrontCamera
+        if let sideBar = sideBar {
+            sideBar.switchCameraButton.isFrontCameraActive = isFrontCamera
+        }
     }
 
     // MARK: - Interactive Dismiss
@@ -788,6 +793,10 @@ extension PhotoCaptureViewController: CameraZoomSelectionControlDelegate {
         let position: AVCaptureDevice.Position = cameraZoomControl == frontCameraZoomControl ? .front : .back
         photoCapture.switchCamera(to: camera, at: position, animated: true)
     }
+
+    fileprivate func cameraZoomControl(_ cameraZoomControl: CameraZoomSelectionControl, didChangeZoomFactor zoomFactor: CGFloat) {
+        photoCapture.changeVisibleZoomFactor(to: zoomFactor, animated: true)
+    }
 }
 
 private class TopBar: MediaTopBar {
@@ -805,6 +814,9 @@ private class TopBar: MediaTopBar {
 
         super.init(frame: frame)
 
+        closeButton.accessibilityLabel = NSLocalizedString("CAMERA_VO_CLOSE_BUTTON",
+                                                           comment: "VoiceOver label for close (X) button in camera.")
+
         addSubview(closeButton)
         closeButton.translatesAutoresizingMaskIntoConstraints = false
         closeButton.layoutMarginsGuide.leadingAnchor.constraint(equalTo: controlsLayoutGuide.leadingAnchor).isActive = true
@@ -1137,6 +1149,8 @@ private class FlashModeButton: RoundMediaButton {
 
 private class CameraChooserButton: RoundMediaButton {
 
+    var isFrontCameraActive = false
+
     required init(backgroundStyle: RoundMediaButton.BackgroundStyle) {
         super.init(image: UIImage(named: "media-composer-switch-camera"), backgroundStyle: backgroundStyle)
     }
@@ -1415,13 +1429,18 @@ private class RecordingTimerView: PillView {
 }
 
 private protocol CameraZoomSelectionControlDelegate: AnyObject {
+
     func cameraZoomControl(_ cameraZoomControl: CameraZoomSelectionControl, didSelect camera: PhotoCapture.CameraType)
+
+    func cameraZoomControl(_ cameraZoomControl: CameraZoomSelectionControl, didChangeZoomFactor zoomFactor: CGFloat)
 }
 
 private class CameraZoomSelectionControl: PillView {
 
     weak var delegate: CameraZoomSelectionControlDelegate?
 
+    private let availableCameras: [PhotoCapture.CameraType]
+
     var selectedCamera: PhotoCapture.CameraType
     var currentZoomFactor: CGFloat {
         didSet {
@@ -1463,16 +1482,16 @@ private class CameraZoomSelectionControl: PillView {
         }
     }
 
-    required init(availableCameras: [(PhotoCapture.CameraType, CGFloat)]) {
+    required init(availableCameras: [(cameraType: PhotoCapture.CameraType, defaultZoomFactor: CGFloat)]) {
         owsAssertDebug(!availableCameras.isEmpty, "availableCameras must not be empty.")
 
-        let (wideAngleCamera, wideAngleCameraZoomFactor) = availableCameras.first(where: { $0.0 == .wideAngle }) ?? availableCameras.first!
+        self.availableCameras = availableCameras.map { $0.cameraType }
+
+        let (wideAngleCamera, wideAngleCameraZoomFactor) = availableCameras.first(where: { $0.cameraType == .wideAngle }) ?? availableCameras.first!
         selectedCamera = wideAngleCamera
         currentZoomFactor = wideAngleCameraZoomFactor
 
-        selectionViews = availableCameras.map { (camera, zoomFactor) in
-            return CameraSelectionCircleView(camera: camera, defaultZoomFactor: zoomFactor)
-        }
+        selectionViews = availableCameras.map { CameraSelectionCircleView(camera: $0.cameraType, defaultZoomFactor: $0.defaultZoomFactor) }
 
         super.init(frame: .zero)
 
@@ -1636,6 +1655,187 @@ private class CameraZoomSelectionControl: PillView {
                 animations()
             }
         }
+
+        override var isAccessibilityElement: Bool {
+            get { false }
+            set { super.isAccessibilityElement = newValue }
+        }
+    }
+}
+
+// MARK: - Accessibility
+
+extension FlashModeButton {
+
+    override var accessibilityLabel: String? {
+        get {
+            NSLocalizedString("CAMERA_VO_FLASH_BUTTON",
+                              comment: "VoiceOver label for Flash button in camera.")
+        }
+        set { super.accessibilityLabel = newValue }
+    }
+
+    override var accessibilityValue: String? {
+        get {
+            switch flashMode {
+            case .auto:
+                return NSLocalizedString("CAMERA_VO_FLASH_AUTO",
+                                         comment: "VoiceOver description of current flash setting.")
+
+            case .on:
+                return NSLocalizedString("CAMERA_VO_FLASH_ON",
+                                         comment: "VoiceOver description of current flash setting.")
+
+            case .off:
+                return NSLocalizedString("CAMERA_VO_FLASH_OFF",
+                                         comment: "VoiceOver description of current flash setting.")
+
+            @unknown default:
+                owsFailDebug("unexpected photoCapture.flashMode: \(flashMode.rawValue)")
+                return nil
+            }
+        }
+        set { super.accessibilityValue = newValue }
+    }
+}
+
+extension CameraChooserButton {
+
+    override var accessibilityLabel: String? {
+        get {
+            NSLocalizedString("CAMERA_VO_CAMERA_CHOOSER_BUTTON",
+                              comment: "VoiceOver label for Switch Camera button in in-app camera.")
+        }
+        set { super.accessibilityLabel = newValue }
+    }
+
+    override var accessibilityHint: String? {
+        get {
+            NSLocalizedString("CAMERA_VO_CAMERA_CHOOSER_HINT",
+                              comment: "VoiceOver hint for Switch Camera button in in-app camera.")
+        }
+        set { super.accessibilityHint = newValue }
+    }
+
+    override var accessibilityValue: String? {
+        get {
+            if isFrontCameraActive {
+                return NSLocalizedString("CAMERA_VO_CAMERA_FRONT_FACING",
+                                         comment: "VoiceOver value for Switch Camera button that tells which camera is currently active.")
+            } else {
+                return NSLocalizedString("CAMERA_VO_CAMERA_BACK_FACING",
+                                         comment: "VoiceOver value for Switch Camera button that tells which camera is currently active.")
+            }
+        }
+        set { super.accessibilityValue = newValue }
+    }
+}
+
+extension CaptureModeButton {
+
+    override var accessibilityLabel: String? {
+        get {
+            NSLocalizedString("CAMERA_VO_CAMERA_ALBUM_MODE",
+                              comment: "VoiceOver label for Flash button in camera.")
+        }
+        set { super.accessibilityLabel = newValue }
+    }
+
+    override var accessibilityValue: String? {
+        get {
+            switch captureMode {
+            case .single:
+                return NSLocalizedString("CAMERA_VO_CAMERA_ALBUM_MODE_OFF",
+                                         comment: "VoiceOver label for Switch Camera button in in-app camera.")
+
+            case .multi:
+                return NSLocalizedString("CAMERA_VO_CAMERA_ALBUM_MODE_ON",
+                                         comment: "VoiceOver label for Switch Camera button in in-app camera.")
+            }
+        }
+        set { super.accessibilityValue = newValue }
+    }
+}
+
+extension MediaPickerThumbnailButton {
+
+    override var accessibilityLabel: String? {
+        get {
+            NSLocalizedString("CAMERA_VO_PHOTO_LIBRARY_BUTTON",
+                          comment: "VoiceOver label for button to choose existing photo/video in in-app camera")
+        }
+        set { super.accessibilityLabel = newValue }
+    }
+}
+
+extension CameraZoomSelectionControl {
+
+    override var isAccessibilityElement: Bool {
+        get { true }
+        set { super.isAccessibilityElement = newValue }
+    }
+
+    override var accessibilityTraits: UIAccessibilityTraits {
+        get { [ .button, .adjustable ] }
+        set { super.accessibilityTraits = newValue }
+    }
+
+    override var accessibilityLabel: String? {
+        get {
+            NSLocalizedString("CAMERA_VO_ZOOM", comment: "VoiceOver label for camera zoom control.")
+        }
+        set { super.accessibilityLabel = newValue }
+    }
+
+    private static let voiceOverNumberFormatter: NumberFormatter = {
+        let numberFormatter = NumberFormatter()
+        numberFormatter.numberStyle = .decimal
+        numberFormatter.minimumIntegerDigits = 1
+        numberFormatter.minimumFractionDigits = 1
+        numberFormatter.maximumFractionDigits = 1
+        return numberFormatter
+    }()
+
+    override var accessibilityValue: String? {
+        get {
+            guard let zoomValueString = CameraZoomSelectionControl.voiceOverNumberFormatter.string(for: currentZoomFactor) else { return nil }
+
+            let formatString = NSLocalizedString("CAMERA_VO_ZOOM_LEVEL",
+                                                 comment: "VoiceOver description of current camera zoom level.")
+            return String(format: formatString, zoomValueString)
+        }
+        set { super.accessibilityValue = newValue }
+    }
+
+    override func accessibilityActivate() -> Bool {
+        // Tapping on a single available camera switches between 1x and 2x.
+        guard availableCameras.count > 1 else {
+            delegate?.cameraZoomControl(self, didSelect: selectedCamera)
+            return true
+        }
+
+        // Cycle through cameras.
+        guard let selectedCameraIndex = availableCameras.firstIndex(of: selectedCamera) else { return false }
+        var nextCameraIndex = availableCameras.index(after: selectedCameraIndex)
+        if nextCameraIndex >= availableCameras.endIndex {
+            nextCameraIndex = availableCameras.startIndex
+        }
+        let nextCamera = availableCameras[nextCameraIndex]
+        selectedCamera = nextCamera
+        delegate?.cameraZoomControl(self, didSelect: nextCamera)
+        return true
+    }
+
+    override func accessibilityIncrement() {
+        // Increment zoom by 0.1.
+        currentZoomFactor = 0.1 * round(currentZoomFactor * 10 + 1)
+        delegate?.cameraZoomControl(self, didChangeZoomFactor: currentZoomFactor)
+    }
+
+    override func accessibilityDecrement() {
+        // Decrement zoom by 0.1.
+        currentZoomFactor = 0.1 * round(currentZoomFactor * 10 - 1)
+        delegate?.cameraZoomControl(self, didChangeZoomFactor: currentZoomFactor)
     }
 }
 
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 5ff7d18ea42..568afdb3acd 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -775,6 +775,60 @@
 /* Accessibility label for camera button. */
 "CAMERA_BUTTON_LABEL" = "Camera";
 
+/* VoiceOver label for Flash button in camera. */
+"CAMERA_VO_CAMERA_ALBUM_MODE" = "Album mode";
+
+/* VoiceOver label for Switch Camera button in in-app camera. */
+"CAMERA_VO_CAMERA_ALBUM_MODE_OFF" = "Off";
+
+/* VoiceOver label for Switch Camera button in in-app camera. */
+"CAMERA_VO_CAMERA_ALBUM_MODE_ON" = "On";
+
+/* VoiceOver value for Switch Camera button that tells which camera is currently active. */
+"CAMERA_VO_CAMERA_BACK_FACING" = "Back facing";
+
+/* VoiceOver label for Switch Camera button in in-app camera. */
+"CAMERA_VO_CAMERA_CHOOSER_BUTTON" = "Camera Chooser";
+
+/* VoiceOver hint for Switch Camera button in in-app camera. */
+"CAMERA_VO_CAMERA_CHOOSER_HINT" = "Switches between cameras";
+
+/* VoiceOver value for Switch Camera button that tells which camera is currently active. */
+"CAMERA_VO_CAMERA_FRONT_FACING" = "Front facing";
+
+/* VoiceOver label for close (X) button in camera. */
+"CAMERA_VO_CLOSE_BUTTON" = "Close";
+
+/* VoiceOver description of current flash setting. */
+"CAMERA_VO_FLASH_AUTO" = "Automatic";
+
+/* VoiceOver label for Flash button in camera. */
+"CAMERA_VO_FLASH_BUTTON" = "Flash";
+
+/* VoiceOver description of current flash setting. */
+"CAMERA_VO_FLASH_OFF" = "Off";
+
+/* VoiceOver description of current flash setting. */
+"CAMERA_VO_FLASH_ON" = "On";
+
+/* VoiceOver label for button to choose existing photo/video in in-app camera */
+"CAMERA_VO_PHOTO_LIBRARY_BUTTON" = "Photo and video viewer";
+
+/* VoiceOver label for the round capture button in in-app camera during video recording. */
+"CAMERA_VO_STOP_VIDEO_REC" = "Stop Recording Video";
+
+/* VoiceOver label for the round capture button in in-app camera. */
+"CAMERA_VO_TAKE_PICTURE" = "Take Picture";
+
+/* VoiceOver label for other possible action for round capture button in in-app camera. */
+"CAMERA_VO_TAKE_VIDEO" = "Take Video";
+
+/* VoiceOver label for camera zoom control. */
+"CAMERA_VO_ZOOM" = "Zoom";
+
+/* VoiceOver description of current camera zoom level. */
+"CAMERA_VO_ZOOM_LEVEL" = "%@times";
+
 /* Message for alert explaining that a user cannot be verified. */
 "CANT_VERIFY_IDENTITY_ALERT_MESSAGE" = "This user can't be verified until you've exchanged messages with them.";
 
diff --git a/Signal/translations/en.lproj/PluralAware.stringsdict b/Signal/translations/en.lproj/PluralAware.stringsdict
index cd7f3cc6c73..4ced83ff8fd 100644
--- a/Signal/translations/en.lproj/PluralAware.stringsdict
+++ b/Signal/translations/en.lproj/PluralAware.stringsdict
@@ -2,6 +2,22 @@
 <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
 <plist version="1.0">
 <dict>
+	<key>CAMERA_VO_N_ITEMS</key>
+	<dict>
+		<key>NSStringLocalizedFormatKey</key>
+		<string>%#@text@</string>
+		<key>text</key>
+		<dict>
+			<key>NSStringFormatSpecTypeKey</key>
+			<string>NSStringPluralRuleType</string>
+			<key>NSStringFormatValueTypeKey</key>
+			<string>d</string>
+			<key>one</key>
+			<string>1 item</string>
+			<key>other</key>
+			<string>%d items</string>
+		</dict>
+	</dict>
 	<key>ACCESSIBILITY_LABEL_VOICE_MEMO_%d</key>
 	<dict>
 		<key>NSStringLocalizedFormatKey</key>
