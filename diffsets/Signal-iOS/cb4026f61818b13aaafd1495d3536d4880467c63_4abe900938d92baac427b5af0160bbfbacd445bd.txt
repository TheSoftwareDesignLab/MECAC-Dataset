diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 49ff91f74b9..66f8a05fa6e 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -974,6 +974,7 @@
 		667EDE6428F8D6B7001FB487 /* YYAnimatedImage+Duration.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667EDE6328F8D6B7001FB487 /* YYAnimatedImage+Duration.swift */; };
 		667EDE6628FA0372001FB487 /* StoryBadgeCountManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667EDE6528FA0372001FB487 /* StoryBadgeCountManager.swift */; };
 		6681AB652B7AE53B0099D187 /* PreloadedTextAttachment.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6681AB642B7AE53B0099D187 /* PreloadedTextAttachment.swift */; };
+		668345502DCA9BEE00566AB3 /* BackupAttachmentUploadProgress.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6683454F2DCA9BE700566AB3 /* BackupAttachmentUploadProgress.swift */; };
 		668444802A3289C700DBED7C /* MessageBodyStyle.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6684447F2A3289C700DBED7C /* MessageBodyStyle.swift */; };
 		668444822A3292AB00DBED7C /* MessageBodyStyleTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668444812A3292AB00DBED7C /* MessageBodyStyleTests.swift */; };
 		668478F72CAB66DC00430D68 /* OrphanedBackupAttachment.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668478F62CAB66D600430D68 /* OrphanedBackupAttachment.swift */; };
@@ -4884,6 +4885,7 @@
 		667EDE6328F8D6B7001FB487 /* YYAnimatedImage+Duration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "YYAnimatedImage+Duration.swift"; sourceTree = "<group>"; };
 		667EDE6528FA0372001FB487 /* StoryBadgeCountManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryBadgeCountManager.swift; sourceTree = "<group>"; };
 		6681AB642B7AE53B0099D187 /* PreloadedTextAttachment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PreloadedTextAttachment.swift; sourceTree = "<group>"; };
+		6683454F2DCA9BE700566AB3 /* BackupAttachmentUploadProgress.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BackupAttachmentUploadProgress.swift; sourceTree = "<group>"; };
 		6684447F2A3289C700DBED7C /* MessageBodyStyle.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageBodyStyle.swift; sourceTree = "<group>"; };
 		668444812A3292AB00DBED7C /* MessageBodyStyleTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageBodyStyleTests.swift; sourceTree = "<group>"; };
 		668478F62CAB66D600430D68 /* OrphanedBackupAttachment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OrphanedBackupAttachment.swift; sourceTree = "<group>"; };
@@ -9639,6 +9641,7 @@
 				66681CDE2C58174F00E50136 /* BackupAttachmentDownloadStoreTests.swift */,
 				66F98DDD2DB70739009F1A86 /* BackupAttachmentQueueStatusManager.swift */,
 				66734F002CA1ED3A00558494 /* BackupAttachmentUploadManager.swift */,
+				6683454F2DCA9BE700566AB3 /* BackupAttachmentUploadProgress.swift */,
 				66C7952C2C9B78E200C13937 /* BackupAttachmentUploadStore.swift */,
 				66C7952E2C9B837500C13937 /* BackupAttachmentUploadStoreTests.swift */,
 				668478F62CAB66D600430D68 /* OrphanedBackupAttachment.swift */,
@@ -17501,6 +17504,7 @@
 				667BB2082C580C1400E79B57 /* BackupAttachmentDownloadStore.swift in Sources */,
 				66F98DDE2DB7073F009F1A86 /* BackupAttachmentQueueStatusManager.swift in Sources */,
 				66734F012CA1ED3F00558494 /* BackupAttachmentUploadManager.swift in Sources */,
+				668345502DCA9BEE00566AB3 /* BackupAttachmentUploadProgress.swift in Sources */,
 				66C7952D2C9B78E900C13937 /* BackupAttachmentUploadStore.swift in Sources */,
 				D923DF9C2DC135D200CDAFC3 /* BackupIdManager.swift in Sources */,
 				D970541F2CFE4D0200AC7954 /* BackupPaymentMethod.swift in Sources */,
diff --git a/SignalServiceKit/Dependencies/DependenciesBridge.swift b/SignalServiceKit/Dependencies/DependenciesBridge.swift
index daf7a09161b..fb8b0784300 100644
--- a/SignalServiceKit/Dependencies/DependenciesBridge.swift
+++ b/SignalServiceKit/Dependencies/DependenciesBridge.swift
@@ -65,6 +65,7 @@ public class DependenciesBridge {
     public let backupAttachmentDownloadStore: BackupAttachmentDownloadStore
     public let backupAttachmentQueueStatusManager: BackupAttachmentQueueStatusManager
     public let backupAttachmentUploadManager: BackupAttachmentUploadManager
+    public let backupAttachmentUploadProgress: BackupAttachmentUploadProgress
     public let backupIdManager: BackupIdManager
     public let backupSubscriptionManager: BackupSubscriptionManager
     public let badgeCountFetcher: BadgeCountFetcher
@@ -190,6 +191,7 @@ public class DependenciesBridge {
         backupAttachmentDownloadStore: BackupAttachmentDownloadStore,
         backupAttachmentQueueStatusManager: BackupAttachmentQueueStatusManager,
         backupAttachmentUploadManager: BackupAttachmentUploadManager,
+        backupAttachmentUploadProgress: BackupAttachmentUploadProgress,
         backupIdManager: BackupIdManager,
         backupSubscriptionManager: BackupSubscriptionManager,
         badgeCountFetcher: BadgeCountFetcher,
@@ -314,6 +316,7 @@ public class DependenciesBridge {
         self.backupAttachmentDownloadStore = backupAttachmentDownloadStore
         self.backupAttachmentQueueStatusManager = backupAttachmentQueueStatusManager
         self.backupAttachmentUploadManager = backupAttachmentUploadManager
+        self.backupAttachmentUploadProgress = backupAttachmentUploadProgress
         self.backupIdManager = backupIdManager
         self.backupSubscriptionManager = backupSubscriptionManager
         self.badgeCountFetcher = badgeCountFetcher
diff --git a/SignalServiceKit/Environment/AppSetup.swift b/SignalServiceKit/Environment/AppSetup.swift
index 89a527c1acd..71362dca555 100644
--- a/SignalServiceKit/Environment/AppSetup.swift
+++ b/SignalServiceKit/Environment/AppSetup.swift
@@ -433,6 +433,11 @@ public class AppSetup {
             tsAccountManager: tsAccountManager
         )
 
+        let backupAttachmentUploadProgress = BackupAttachmentUploadProgress(
+            backupSubscriptionManager: backupSubscriptionManager,
+            db: db
+        )
+
         let backupAttachmentUploadManager = BackupAttachmentUploadManagerImpl(
             appReadiness: appReadiness,
             attachmentStore: attachmentStore,
@@ -443,6 +448,7 @@ public class AppSetup {
             dateProvider: dateProvider,
             db: db,
             messageBackupRequestManager: messageBackupRequestManager,
+            progress: backupAttachmentUploadProgress,
             statusManager: backupAttachmentQueueStatusManager,
             tsAccountManager: tsAccountManager
         )
@@ -1311,6 +1317,7 @@ public class AppSetup {
             backupAttachmentDownloadStore: backupAttachmentDownloadStore,
             backupAttachmentQueueStatusManager: backupAttachmentQueueStatusManager,
             backupAttachmentUploadManager: backupAttachmentUploadManager,
+            backupAttachmentUploadProgress: backupAttachmentUploadProgress,
             backupIdManager: backupIdManager,
             backupSubscriptionManager: backupSubscriptionManager,
             badgeCountFetcher: badgeCountFetcher,
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift
index bc029e715f6..d382b20d0f6 100644
--- a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift
@@ -787,8 +787,10 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             /// Media and transit tier byte counts should be interchangeable.
             /// Still, we shouldn't rely on this for anything other that progress tracking,
             /// where its just a UI glitch if it turns out they are not.
-            let fullsizeByteCountForProgress = UInt64(
-                attachment.anyPointerFullsizeUnencryptedByteCount ?? 0
+            var fullsizeByteCountForProgress = UInt64(
+                Cryptography.paddedSize(
+                    unpaddedSize: UInt(attachment.anyPointerFullsizeUnencryptedByteCount ?? 0)
+                )
             )
 
             // Separately from "eligibility" on a per-download basis, we check
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift
index 56da4e7406e..bbfc911b8c1 100644
--- a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift
@@ -5,6 +5,12 @@
 
 public import GRDB
 
+/// Tracks and reports progress for backup (media tier) attachment downloads.
+///
+/// When we restore a backup (or disable backups or other state changes that trigger bulk rescheduling
+/// of media tier downloads) we compute and store the total bytes to download. This class counts
+/// up to that number until all downloads finish; this ensures we show a stable total even as we make
+/// partial progress.
 public actor BackupAttachmentDownloadProgress {
 
     // MARK: - Public API
@@ -285,12 +291,12 @@ public actor BackupAttachmentDownloadProgress {
                     eligibility.canDownloadMediaTierFullsize,
                     let byteCount = attachment.mediaTierInfo?.unencryptedByteCount
                 {
-                    totalByteCount += UInt64(byteCount)
+                    totalByteCount += UInt64(Cryptography.paddedSize(unpaddedSize: UInt(byteCount)))
                 } else if
                     eligibility.canDownloadTransitTierFullsize,
                     let byteCount = attachment.transitTierInfo?.unencryptedByteCount
                 {
-                    totalByteCount += UInt64(byteCount)
+                    totalByteCount += UInt64(Cryptography.paddedSize(unpaddedSize: UInt(byteCount)))
                 }
                 // We don't count thumbnail downloads towards the total
                 // download count we track the progress of.
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadManager.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadManager.swift
index c41dfa1b8cc..aa54fbef2a6 100644
--- a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadManager.swift
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadManager.swift
@@ -61,6 +61,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
     private let backupSubscriptionManager: BackupSubscriptionManager
     private let db: any DB
     private let messageBackupRequestManager: MessageBackupRequestManager
+    private let progress: BackupAttachmentUploadProgress
     private let statusManager: BackupAttachmentQueueStatusUpdates
     private let taskQueue: TaskQueueLoader<TaskRunner>
     private let tsAccountManager: TSAccountManager
@@ -75,6 +76,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
         dateProvider: @escaping DateProvider,
         db: any DB,
         messageBackupRequestManager: MessageBackupRequestManager,
+        progress: BackupAttachmentUploadProgress,
         statusManager: BackupAttachmentQueueStatusUpdates,
         tsAccountManager: TSAccountManager
     ) {
@@ -84,6 +86,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
         self.backupSubscriptionManager = backupSubscriptionManager
         self.db = db
         self.messageBackupRequestManager = messageBackupRequestManager
+        self.progress = progress
         self.statusManager = statusManager
         self.tsAccountManager = tsAccountManager
         let taskRunner = TaskRunner(
@@ -95,6 +98,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
             dateProvider: dateProvider,
             db: db,
             messageBackupRequestManager: messageBackupRequestManager,
+            progress: progress,
             statusManager: statusManager,
             tsAccountManager: tsAccountManager
         )
@@ -299,6 +303,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
         private let dateProvider: DateProvider
         private let db: any DB
         private let messageBackupRequestManager: MessageBackupRequestManager
+        private let progress: BackupAttachmentUploadProgress
         private let statusManager: BackupAttachmentQueueStatusUpdates
         private let tsAccountManager: TSAccountManager
 
@@ -313,6 +318,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
             dateProvider: @escaping DateProvider,
             db: any DB,
             messageBackupRequestManager: MessageBackupRequestManager,
+            progress: BackupAttachmentUploadProgress,
             statusManager: BackupAttachmentQueueStatusUpdates,
             tsAccountManager: TSAccountManager
         ) {
@@ -324,6 +330,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
             self.dateProvider = dateProvider
             self.db = db
             self.messageBackupRequestManager = messageBackupRequestManager
+            self.progress = progress
             self.statusManager = statusManager
             self.tsAccountManager = tsAccountManager
 
@@ -500,12 +507,26 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
             // Upload fullsize next
             if needsMediaTierUpload {
                 do {
+                    let progressSink = await progress.willBeginUploadingAttachment(
+                        attachmentId: attachment.id,
+                        queuedUploadRowId: record.record.id!
+                    )
                     try await attachmentUploadManager.uploadMediaTierAttachment(
                         attachmentId: attachment.id,
                         uploadEra: currentUploadEra,
                         localAci: localAci,
-                        auth: messageBackupAuth
+                        auth: messageBackupAuth,
+                        progress: progressSink
                     )
+                    if let byteCount = attachment.streamInfo?.encryptedByteCount {
+                        await progress.didFinishUploadOfAttachment(
+                            attachmentId: attachment.id,
+                            queuedUploadRowId: record.record.id!,
+                            byteCount: UInt64(Cryptography.paddedSize(unpaddedSize: UInt(byteCount)))
+                        )
+                    } else {
+                        owsFailDebug("Uploaded a non stream?")
+                    }
                 } catch let error {
                     return await handleUploadError(error: error, isThumbnailUpload: false)
                 }
@@ -527,6 +548,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
         }
 
         func didDrainQueue() async {
+            await progress.didEmptyUploadQueue()
             await statusManager.didEmptyQueue(type: .upload)
         }
     }
@@ -565,7 +587,7 @@ public class BackupAttachmentUploadManagerImpl: BackupAttachmentUploadManager {
     }
 }
 
-fileprivate extension AttachmentStream {
+extension AttachmentStream {
 
     func needsMediaTierUpload(currentUploadEra: String) -> Bool {
         if let mediaTierInfo = attachment.mediaTierInfo {
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadProgress.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadProgress.swift
new file mode 100644
index 00000000000..4fec70c7c39
--- /dev/null
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentUploadProgress.swift
@@ -0,0 +1,257 @@
+//
+// Copyright 2025 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+public import GRDB
+
+/// Tracks and reports progress for backup (media tier) attachment uploads.
+///
+/// At observation time, checks the current total scheduled bytes to upload, and uses that
+/// as the fixed total for the lifetime of the observation. Creating a new observation recomputes
+/// the remaining total (which may have gone up if new attachments have been scheduled,
+/// or gone down, including to 0, if uploads completed).
+/// Note this contrasts with BackupAttachmentDownloadProgress, which is a singleton observer
+/// and "remembers" the total bytes to download.
+///
+/// Note: ignores/excludes thumbnail uploads; just deals with fullsize attachments.
+public actor BackupAttachmentUploadProgress {
+
+    // MARK: - Public API
+
+    public class Observer {
+        fileprivate let queueSnapshot: UploadQueueSnapshot
+        fileprivate let sink: OWSProgressSink
+        fileprivate let source: OWSProgressSource
+        private weak var progress: BackupAttachmentUploadProgress?
+        fileprivate let id: UUID = UUID()
+
+        fileprivate init(
+            queueSnapshot: UploadQueueSnapshot,
+            sink: OWSProgressSink,
+            source: OWSProgressSource,
+            progress: BackupAttachmentUploadProgress?
+        ) {
+            self.queueSnapshot = queueSnapshot
+            self.sink = sink
+            self.source = source
+            self.progress = progress
+        }
+
+        deinit {
+            Task { [weak progress, id] in
+                await progress?.removeObserver(id)
+            }
+        }
+    }
+
+    /// Begin observing progress of all backup attachment uploads that are scheduled as of the time this method is called.
+    /// The total count will not change over the lifetime of the observer, even if new attachments are scheduled for upload.
+    /// The returned observer must be retained to continue receiving updates (Careful of retain cycles; the observer retains the block).
+    public func addObserver(_ block: @escaping (OWSProgress) -> Void) async throws -> Observer {
+        let queueSnapshot = try self.computeRemainingUnuploadedByteCount()
+        let sink = OWSProgress.createSink(block)
+        let source = await sink.addSource(withLabel: "", unitCount: queueSnapshot.totalByteCount)
+        let observer = Observer(
+            queueSnapshot: queueSnapshot,
+            sink: sink,
+            source: source,
+            progress: self
+        )
+        block(OWSProgress(
+            completedUnitCount: 0,
+            totalUnitCount: queueSnapshot.totalByteCount,
+            sourceProgresses: [:]
+        ))
+        observers.append(observer)
+        return observer
+    }
+
+    public func removeObserver(_ observer: Observer) {
+        self.removeObserver(observer.id)
+    }
+
+    // MARK: - BackupAttachmentUploadManager API
+
+    /// Create an OWSProgressSink for a single attachment to be uploaded.
+    /// Should be called prior to uploading any backup attachment.
+    internal func willBeginUploadingAttachment(
+        attachmentId id: Attachment.IDType,
+        queuedUploadRowId: QueuedBackupAttachmentUpload.IDType
+    ) async -> OWSProgressSink {
+        let sink = OWSProgress.createSink { [weak self] progress in
+            Task {
+                await self?.didUpdateProgressForActiveUpload(
+                    attachmentId: id,
+                    queuedUploadRowId: queuedUploadRowId,
+                    completedByteCount: progress.completedUnitCount,
+                    totalByteCount: progress.totalUnitCount
+                )
+            }
+        }
+        return sink
+    }
+
+    /// Stopgap to inform that an attachment finished uploading.
+    /// There are a couple edge cases (e.g. already uploaded) that result in uploads
+    /// finishing without reporting any progress updates. This method ensures we always mark
+    /// attachments as finished in all cases.
+    internal func didFinishUploadOfAttachment(
+        attachmentId id: Attachment.IDType,
+        queuedUploadRowId: QueuedBackupAttachmentUpload.IDType,
+        byteCount: UInt64
+    ) {
+        didUpdateProgressForActiveUpload(
+            attachmentId: id,
+            queuedUploadRowId: queuedUploadRowId,
+            completedByteCount: byteCount,
+            totalByteCount: byteCount
+        )
+    }
+
+    /// Called when there are no more enqueued uploads.
+    /// As a final stopgap, in case we missed some bytes and counting got out of sync,
+    /// this should fully advance the uploaded byte count to the total byte count.
+    internal func didEmptyUploadQueue() async {
+        activeUploadByteCounts.keys.forEach {
+            recentlyCompletedUploads.set(key: $0, value: ())
+        }
+        activeUploadByteCounts = [:]
+        observers.cullExpired()
+        observers.elements.forEach { observer in
+            let source = observer.source
+            if source.totalUnitCount > 0, source.totalUnitCount > source.completedUnitCount {
+                source.incrementCompletedUnitCount(by: source.totalUnitCount - source.completedUnitCount)
+            }
+        }
+    }
+
+    // MARK: - Private
+
+    private nonisolated let backupSubscriptionManager: BackupSubscriptionManager
+    private nonisolated let db: DB
+
+    init(
+        backupSubscriptionManager: BackupSubscriptionManager,
+        db: DB
+    ) {
+        self.backupSubscriptionManager = backupSubscriptionManager
+        self.db = db
+    }
+
+    private var observers = WeakArray<Observer>()
+
+    private struct PerObserverUploadId: Hashable {
+        let observerId: UUID
+        let attachmentId: Attachment.IDType
+    }
+
+    /// Currently active uploads for which we update progress byte-by-byte.
+    private var activeUploadByteCounts = [PerObserverUploadId: UInt64]()
+    /// There is a race between receiving the final OWSProgress update for a given attachment
+    /// and being told the attachment finished uploading by BackupAttachmentUploadManager.
+    /// To resolve this race, track recently completed uploads so we know not to double count.
+    /// There could be tens of thousands of attachments, so to minimize memory usage only keep
+    /// an LRUCache. In practice that will catch all races. Even if it doesn't, the downside
+    /// is we misreport progress until we hit 100%, big whoop.
+    private var recentlyCompletedUploads = LRUCache<PerObserverUploadId, Void>(maxSize: 100)
+
+    private func didUpdateProgressForActiveUpload(
+        attachmentId id: Attachment.IDType,
+        queuedUploadRowId: QueuedBackupAttachmentUpload.IDType,
+        completedByteCount: UInt64,
+        totalByteCount: UInt64
+    ) {
+        guard
+            totalByteCount != 0
+        else {
+            return
+        }
+
+        observers.elements.forEach { observer in
+            guard
+                let maxRowId = observer.queueSnapshot.maxRowId,
+                maxRowId >= queuedUploadRowId
+            else {
+                return
+            }
+            let uploadId = PerObserverUploadId(
+                observerId: observer.id,
+                attachmentId: id
+            )
+            let prevByteCount = activeUploadByteCounts[uploadId] ?? 0
+            let source = observer.source
+            let diff = min(max(completedByteCount, prevByteCount) - prevByteCount, source.totalUnitCount - source.completedUnitCount)
+            if diff > 0 {
+                source.incrementCompletedUnitCount(by: diff)
+            }
+            if completedByteCount >= totalByteCount {
+                recentlyCompletedUploads.set(key: uploadId, value: ())
+            } else {
+                activeUploadByteCounts[uploadId] = completedByteCount
+            }
+        }
+    }
+
+    func removeObserver(_ id: UUID) {
+        observers.removeAll(where: { $0.id == id })
+    }
+
+    fileprivate struct UploadQueueSnapshot {
+        let totalByteCount: UInt64
+        // We want to ignore updates from uploads that were scheduled after
+        // we started observing. Take advantage of sequential row ids by
+        // ignoring updates from ids that came after initial setup.
+        let maxRowId: QueuedBackupAttachmentUpload.IDType?
+    }
+
+    private nonisolated func computeRemainingUnuploadedByteCount() throws -> UploadQueueSnapshot {
+        return try db.read { tx in
+            let currentUploadEra = backupSubscriptionManager.getUploadEra(tx: tx)
+
+            var totalByteCount: UInt64 = 0
+            var maxRowId: Int64?
+
+            struct JoinedRecord: Decodable, FetchableRecord {
+                var QueuedBackupAttachmentUpload: QueuedBackupAttachmentUpload
+                var Attachment: Attachment.Record
+            }
+
+            let cursor = try QueuedBackupAttachmentUpload
+                .including(required: QueuedBackupAttachmentUpload.attachment.self)
+                .asRequest(of: JoinedRecord.self)
+                .fetchCursor(tx.database)
+
+            while let joinedRecord = try cursor.next() {
+                guard let attachment = try? Attachment(record: joinedRecord.Attachment) else {
+                    continue
+                }
+                if
+                    let stream = attachment.asStream(),
+                    stream.needsMediaTierUpload(currentUploadEra: currentUploadEra)
+                {
+                    let attachmentByteCount: UInt = Cryptography.paddedSize(
+                        unpaddedSize: UInt(stream.encryptedByteCount)
+                    )
+                    totalByteCount += UInt64(attachmentByteCount)
+                    if let existingMaxRowId = maxRowId {
+                        maxRowId = max(existingMaxRowId, joinedRecord.QueuedBackupAttachmentUpload.id!)
+                    } else {
+                        maxRowId = joinedRecord.QueuedBackupAttachmentUpload.id
+                    }
+                }
+                // We don't count thumbnail uploads towards the total
+                // upload count we track the progress of.
+            }
+
+            return UploadQueueSnapshot(totalByteCount: totalByteCount, maxRowId: maxRowId)
+        }
+    }
+}
+
+extension QueuedBackupAttachmentUpload: TableRecord {
+    static let attachment = belongsTo(
+        Attachment.Record.self,
+        using: ForeignKey([QueuedBackupAttachmentUpload.CodingKeys.attachmentRowId.rawValue])
+    )
+}
diff --git a/SignalServiceKit/Upload/AttachmentUploadManager.swift b/SignalServiceKit/Upload/AttachmentUploadManager.swift
index 3d71217a3c6..370a3baea0d 100644
--- a/SignalServiceKit/Upload/AttachmentUploadManager.swift
+++ b/SignalServiceKit/Upload/AttachmentUploadManager.swift
@@ -398,7 +398,7 @@ public actor AttachmentUploadManagerImpl: AttachmentUploadManager {
             attachmentId: attachmentId,
             type: .mediaTier(auth: auth, isThumbnail: false),
             logger: logger,
-            progress: nil
+            progress: progress
         )
 
         // Read the attachment fresh from the DB
@@ -483,7 +483,7 @@ public actor AttachmentUploadManagerImpl: AttachmentUploadManager {
             attachmentId: attachmentId,
             type: .mediaTier(auth: auth, isThumbnail: true),
             logger: logger,
-            progress: nil
+            progress: progress
         )
 
         // Read the attachment fresh from the DB
