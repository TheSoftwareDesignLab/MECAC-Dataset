diff --git a/Scripts/sds_codegen/sds_config/sds-config.json b/Scripts/sds_codegen/sds_config/sds-config.json
index 577b3041b3d..addb5a0d954 100644
--- a/Scripts/sds_codegen/sds_config/sds-config.json
+++ b/Scripts/sds_codegen/sds_config/sds-config.json
@@ -70,6 +70,7 @@
 		"OWSOutgoingCallMessage",
 		"OWSOutgoingGroupCallMessage",
 		"OWSOutgoingSenderKeyDistributionMessage",
+		"OWSOutgoingResendRequest",
 		"OWSReceiptsForSenderMessage",
 		"OWSUnknownDBObject",
 		"TSOutgoingDeleteMessage"
diff --git a/Scripts/sds_codegen/sds_config/sds_record_type_map.json b/Scripts/sds_codegen/sds_config/sds_record_type_map.json
index 1456b258eec..c238a562dc3 100644
--- a/Scripts/sds_codegen/sds_config/sds_record_type_map.json
+++ b/Scripts/sds_codegen/sds_config/sds_record_type_map.json
@@ -31,8 +31,10 @@
     "OWSMessageContentJob": 15, 
     "OWSMessageDecryptJob": 8, 
     "OWSOutgoingPaymentMessage": 68, 
+    "OWSOutgoingResendRequest": 71, 
     "OWSReaction": 62, 
     "OWSRecipientIdentity": 38, 
+    "OWSRecoverableDecryptionPlaceholder": 70, 
     "OWSResaveCollectionDBMigration": 49, 
     "OWSSessionResetJobRecord": 52, 
     "OWSUnknownContactBlockOfferMessage": 5, 
diff --git a/Signal/src/Calls/CallService.swift b/Signal/src/Calls/CallService.swift
index 78dd07adec5..d34bc007971 100644
--- a/Signal/src/Calls/CallService.swift
+++ b/Signal/src/Calls/CallService.swift
@@ -709,6 +709,11 @@ extension CallService {
 
     @objc
     func peekCallAndUpdateThread(_ thread: TSGroupThread, expectedEraId: String? = nil, triggerEventTimestamp: UInt64 = NSDate.ows_millisecondTimeStamp()) {
+
+        // Sender Key TODO: This can be called as a result of an incoming message
+        // We'll want to make sure we replace any placeholder messages if necessary
+        // There's just some plumbing that needs to be done.
+
         AssertIsOnMainThread()
 
         guard RemoteConfig.groupCalling, thread.isLocalUserFullMember else { return }
diff --git a/Signal/src/Calls/Individual/IndividualCallService.swift b/Signal/src/Calls/Individual/IndividualCallService.swift
index 6df00a211d9..fae51b7283b 100644
--- a/Signal/src/Calls/Individual/IndividualCallService.swift
+++ b/Signal/src/Calls/Individual/IndividualCallService.swift
@@ -111,7 +111,9 @@ import SignalMessaging
             sentAtTimestamp: call.individualCall.sentAtTimestamp
         )
         databaseStorage.asyncWrite { transaction in
-            callRecord.anyInsert(transaction: transaction)
+            callRecord.insertOrReplacePlaceholder(
+                from: call.individualCall.remoteAddress,
+                transaction: transaction)
         }
         call.individualCall.callRecord = callRecord
 
@@ -157,7 +159,9 @@ import SignalMessaging
                 sentAtTimestamp: call.individualCall.sentAtTimestamp
             )
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyInsert(transaction: transaction)
+                callRecord.insertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
             }
             call.individualCall.callRecord = callRecord
         } else {
@@ -256,7 +260,7 @@ import SignalMessaging
             assert(newCall.individualCall.callRecord == nil)
             newCall.individualCall.callRecord = callRecord
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyInsert(transaction: transaction)
+                callRecord.insertOrReplacePlaceholder(from: thread.contactAddress, transaction: transaction)
             }
 
             newCall.individualCall.state = .localFailure
@@ -289,7 +293,7 @@ import SignalMessaging
             assert(newCall.individualCall.callRecord == nil)
             newCall.individualCall.callRecord = callRecord
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyInsert(transaction: transaction)
+                callRecord.insertOrReplacePlaceholder(from: thread.contactAddress, transaction: transaction)
             }
 
             newCall.individualCall.state = .localFailure
@@ -309,7 +313,7 @@ import SignalMessaging
             assert(newCall.individualCall.callRecord == nil)
             newCall.individualCall.callRecord = callRecord
             databaseStorage.write { transaction in
-                callRecord.anyInsert(transaction: transaction)
+                callRecord.insertOrReplacePlaceholder(from: thread.contactAddress, transaction: transaction)
             }
 
             newCall.individualCall.state = .localFailure
@@ -344,7 +348,7 @@ import SignalMessaging
             assert(newCall.individualCall.callRecord == nil)
             newCall.individualCall.callRecord = callRecord
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyInsert(transaction: transaction)
+                callRecord.insertOrReplacePlaceholder(from: thread.contactAddress, transaction: transaction)
             }
 
             newCall.individualCall.state = .localFailure
@@ -701,7 +705,11 @@ import SignalMessaging
                     thread: call.individualCall.thread,
                     sentAtTimestamp: call.individualCall.sentAtTimestamp
                 )
-                databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
+                databaseStorage.asyncWrite { transaction in
+                    callRecord.insertOrReplacePlaceholder(
+                        from: call.individualCall.remoteAddress,
+                        transaction: transaction)
+                }
                 call.individualCall.callRecord = callRecord
                 callUIAdapter.reportMissedCall(call)
             }
@@ -981,7 +989,9 @@ import SignalMessaging
         switch callRecord.callType {
         case .incomingMissed:
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyUpsert(transaction: transaction)
+                callRecord.upsertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
             }
             callUIAdapter.reportMissedCall(call)
         case .incomingIncomplete, .incoming:
@@ -992,11 +1002,15 @@ import SignalMessaging
         case .incomingMissedBecauseOfChangedIdentity, .incomingDeclined, .outgoingMissed, .outgoing, .incomingAnsweredElsewhere, .incomingDeclinedElsewhere, .incomingBusyElsewhere:
             owsFailDebug("unexpected RPRecentCallType: \(callRecord.callType)")
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyUpsert(transaction: transaction)
+                callRecord.upsertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
             }
         @unknown default:
             databaseStorage.asyncWrite { transaction in
-                callRecord.anyUpsert(transaction: transaction)
+                callRecord.upsertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
             }
             owsFailDebug("unknown RPRecentCallType: \(callRecord.callType)")
         }
@@ -1016,7 +1030,11 @@ import SignalMessaging
                 sentAtTimestamp: call.individualCall.sentAtTimestamp
             )
             call.individualCall.callRecord = callRecord
-            databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
+            databaseStorage.asyncWrite { transaction in
+                callRecord.insertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
+            }
         }
 
         call.individualCall.state = .answeredElsewhere
@@ -1041,7 +1059,11 @@ import SignalMessaging
                 sentAtTimestamp: call.individualCall.sentAtTimestamp
             )
             call.individualCall.callRecord = callRecord
-            databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
+            databaseStorage.asyncWrite { transaction in
+                callRecord.insertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
+            }
         }
 
         call.individualCall.state = .declinedElsewhere
@@ -1066,7 +1088,11 @@ import SignalMessaging
                 sentAtTimestamp: call.individualCall.sentAtTimestamp
             )
             call.individualCall.callRecord = callRecord
-            databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
+            databaseStorage.asyncWrite { transaction in
+                callRecord.insertOrReplacePlaceholder(
+                    from: call.individualCall.remoteAddress,
+                    transaction: transaction)
+            }
         }
 
         call.individualCall.state = .busyElsewhere
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift
index c4c5f13e6e8..77b254b7945 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift
@@ -652,6 +652,7 @@ fileprivate extension CVComponentState.Builder {
                                                    avatar: avatar)
             return build()
         case .info, .error, .call:
+            // Sender Key TODO: Error interaction UI?
             let currentCallThreadId = viewStateSnapshot.currentCallThreadId
             self.systemMessage = CVComponentSystemMessage.buildComponentState(interaction: interaction,
                                                                               threadViewModel: threadViewModel,
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentSystemMessage.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentSystemMessage.swift
index d92e01a3dbf..808fa0f057c 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentSystemMessage.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentSystemMessage.swift
@@ -680,7 +680,8 @@ extension CVComponentSystemMessage {
                  .duplicateMessage,
                  .invalidVersion,
                  .unknownContactBlockOffer,
-                 .groupCreationFailed:
+                 .groupCreationFailed,
+                 .decryptionFailure:
                 return nil
             @unknown default:
                 owsFailDebug("Unknown value.")
@@ -952,6 +953,9 @@ extension CVComponentSystemMessage {
             return Action(title: CommonStrings.learnMore,
                           accessibilityIdentifier: "learn_more",
                           action: .cvc_didTapSessionRefreshMessage(errorMessage: message))
+        case .decryptionFailure:
+            // Sender Key TODO: Error interaction UI?
+            return nil
         case .duplicateMessage,
              .invalidVersion:
             return nil
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
index 815320f6d72..0ec38c4a3de 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
@@ -600,6 +600,7 @@ struct CVItemModelBuilder: CVItemBuilding, Dependencies {
             return
         }
 
+        // Sender Key TODO: How do these errors collapse?
         switch item.interactionType {
         case .error:
             guard let errorMessage = interaction as? TSErrorMessage,
@@ -686,6 +687,7 @@ private class ItemBuilder {
             // Only show the date for non-synced thread messages;
             return infoMessage.messageType != .syncedThread
         case .unreadIndicator, .incomingMessage, .outgoingMessage, .error, .call:
+            // Sender Key TODO: Check UI design
             return true
         }
     }
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVRenderItem.swift b/Signal/src/ViewControllers/ConversationView/CV/CVRenderItem.swift
index 069a40bd429..7361f2d10fa 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVRenderItem.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVRenderItem.swift
@@ -133,6 +133,7 @@ extension CVRenderItem: ConversationViewLayoutItem {
                 return ConversationStyle.defaultMessageSpacing
             }
         case .call, .info, .error:
+            // Sender Key TODO: Error interaction UI?
             if previousInteraction.interactionType() == interaction.interactionType() {
                 switch previousInteraction.interactionType() {
                 case .error:
diff --git a/Signal/src/ViewControllers/DebugUI/DebugUISessionState.m b/Signal/src/ViewControllers/DebugUI/DebugUISessionState.m
index f8905477a66..ace30199085 100644
--- a/Signal/src/ViewControllers/DebugUI/DebugUISessionState.m
+++ b/Signal/src/ViewControllers/DebugUI/DebugUISessionState.m
@@ -78,6 +78,17 @@ - (nullable OWSTableSection *)sectionForThread:(nullable TSThread *)threadParame
         ]];
     }
 
+    if ([threadParameter isKindOfClass:[TSGroupThread class]]) {
+        TSGroupThread *groupThread = (TSGroupThread *)threadParameter;
+        [items addObject:[OWSTableItem itemWithTitle:@"Rotate sender key"
+                                         actionBlock:^{
+            DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
+                [self.senderKeyStore resetSenderKeySessionFor:groupThread
+                                                  transaction:transaction];
+            });
+        }]];
+    }
+
     if (threadParameter) {
         [items addObject:[OWSTableItem itemWithTitle:@"Update verification state"
                                          actionBlock:^{ [self updateIdentityVerificationForThread:threadParameter]; }]];
@@ -88,6 +99,13 @@ - (nullable OWSTableSection *)sectionForThread:(nullable TSThread *)threadParame
                         actionBlock:^{ [self clearSessionAndIdentityStore]; }],
     ]];
 
+    [items addObject:[OWSTableItem itemWithTitle:@"Clear sender key store"
+                                     actionBlock:^{
+        DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
+            [self.senderKeyStore resetSenderKeyStoreWithTransaction:transaction];
+        });
+    }]];
+
     return [OWSTableSection sectionWithTitle:self.name items:items];
 }
 
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index c02afd89c9b..c2e97c026f5 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -1600,6 +1600,9 @@
 /* Error message indicating that attachment download(s) failed. */
 "ERROR_MESSAGE_ATTACHMENT_DOWNLOAD_FAILED" = "Attachment download failed.";
 
+/* Error message for a decryption failure. Embeds {{senders name}}. */
+"ERROR_MESSAGE_DECRYPTION_FAILURE" = "A message from %@ could not be delivered";
+
 /* No comment provided by engineer. */
 "ERROR_MESSAGE_DUPLICATE_MESSAGE" = "Received a duplicate message.";
 
diff --git a/SignalMessaging/Notifications/AppNotifications.swift b/SignalMessaging/Notifications/AppNotifications.swift
index 1125ad23b56..e73a3cc538f 100644
--- a/SignalMessaging/Notifications/AppNotifications.swift
+++ b/SignalMessaging/Notifications/AppNotifications.swift
@@ -624,6 +624,7 @@ public class NotificationPresenter: NSObject, NotificationsProtocol {
              .invalidVersion,
              .nonBlockingIdentityChange,
              .unknownContactBlockOffer,
+             .decryptionFailure,
              .groupCreationFailed:
             return
         @unknown default:
diff --git a/SignalServiceKit/protobuf/SignalService.proto b/SignalServiceKit/protobuf/SignalService.proto
index 3698539fb2e..771ffc8b066 100644
--- a/SignalServiceKit/protobuf/SignalService.proto
+++ b/SignalServiceKit/protobuf/SignalService.proto
@@ -23,6 +23,7 @@ message Envelope {
     RECEIPT             = 5;
     UNIDENTIFIED_SENDER = 6;
     SENDERKEY_MESSAGE   = 7;
+    PLAINTEXT_CONTENT   = 8;
   }
 
   optional Type   type            = 1;
@@ -61,6 +62,7 @@ message Content {
   optional ReceiptMessage receiptMessage                = 5;
   optional TypingMessage  typingMessage                 = 6;
   optional bytes          senderKeyDistributionMessage  = 7;    // Serialized SKDM
+  optional bytes          decryptionErrorMessage        = 8;    // Serialized decryption error
 }
 
 message CallMessage {
@@ -693,3 +695,9 @@ message PaymentAddress {
   optional MobileCoin mobileCoin = 1;
   // }
 }
+
+message DecryptionErrorMessage {
+  optional bytes    ratchetKey  = 1;
+  optional uint64   timestamp   = 2;
+  optional uint32   deviceId    = 3;
+}
diff --git a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage+SDS.swift b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage+SDS.swift
index 531109c3990..c0c87691670 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage+SDS.swift
+++ b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage+SDS.swift
@@ -102,7 +102,7 @@ class TSErrorMessageSerializer: SDSSerializer {
         let read: Bool? = model.wasRead
         let recipientAddress: Data? = optionalArchive(model.recipientAddress)
         let recipientAddressStates: Data? = nil
-        let sender: Data? = nil
+        let sender: Data? = optionalArchive(model.sender)
         let serverTimestamp: UInt64? = nil
         let sourceDeviceId: UInt32? = nil
         let storedMessageState: TSOutgoingMessageState? = nil
diff --git a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.h b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.h
index 8aa949a9f8e..8447876a383 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.h
+++ b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.h
@@ -26,7 +26,8 @@ typedef NS_ENUM(int32_t, TSErrorMessageType) {
     TSErrorMessageNonBlockingIdentityChange,
     TSErrorMessageUnknownContactBlockOffer,
     TSErrorMessageGroupCreationFailed,
-    TSErrorMessageSessionRefresh
+    TSErrorMessageSessionRefresh,
+    TSErrorMessageDecryptionFailure,
 };
 
 extern NSUInteger TSErrorMessageSchemaVersion;
@@ -97,8 +98,9 @@ extern NSUInteger TSErrorMessageSchemaVersion;
                        errorType:(TSErrorMessageType)errorType
                             read:(BOOL)read
                 recipientAddress:(nullable SignalServiceAddress *)recipientAddress
+                          sender:(nullable SignalServiceAddress *)sender
              wasIdentityVerified:(BOOL)wasIdentityVerified
-NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:attachmentIds:body:bodyRanges:contactShare:expireStartedAt:expiresAt:expiresInSeconds:isViewOnceComplete:isViewOnceMessage:linkPreview:messageSticker:quotedMessage:storedShouldStartExpireTimer:wasRemotelyDeleted:errorType:read:recipientAddress:wasIdentityVerified:));
+NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:attachmentIds:body:bodyRanges:contactShare:expireStartedAt:expiresAt:expiresInSeconds:isViewOnceComplete:isViewOnceMessage:linkPreview:messageSticker:quotedMessage:storedShouldStartExpireTimer:wasRemotelyDeleted:errorType:read:recipientAddress:sender:wasIdentityVerified:));
 
 // clang-format on
 
@@ -123,7 +125,12 @@ NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp
                                           address:(SignalServiceAddress *)address
                               wasIdentityVerified:(BOOL)wasIdentityVerified;
 
++ (instancetype)failedDecryptionForEnvelope:(SSKProtoEnvelope *)envelope
+                                    groupId:(nullable NSData *)groupId
+                            withTransaction:(SDSAnyWriteTransaction *)transaction;
+
 @property (nonatomic, readonly) TSErrorMessageType errorType;
+@property (nullable, nonatomic, readonly) SignalServiceAddress *sender;
 @property (nullable, nonatomic, readonly) SignalServiceAddress *recipientAddress;
 
 // This property only applies if errorType == .nonBlockingIdentityChange.
diff --git a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.m b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.m
index f0969225137..44b6d41a680 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.m
+++ b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.m
@@ -105,6 +105,7 @@ - (instancetype)initErrorMessageWithBuilder:(TSErrorMessageBuilder *)errorMessag
     }
 
     _errorType = errorMessageBuilder.errorType;
+    _sender = errorMessageBuilder.senderAddress;
     _recipientAddress = errorMessageBuilder.recipientAddress;
     _errorMessageSchemaVersion = TSErrorMessageSchemaVersion;
     _wasIdentityVerified = errorMessageBuilder.wasIdentityVerified;
@@ -145,6 +146,7 @@ - (instancetype)initWithGrdbId:(int64_t)grdbId
                        errorType:(TSErrorMessageType)errorType
                             read:(BOOL)read
                 recipientAddress:(nullable SignalServiceAddress *)recipientAddress
+                          sender:(nullable SignalServiceAddress *)sender
              wasIdentityVerified:(BOOL)wasIdentityVerified
 {
     self = [super initWithGrdbId:grdbId
@@ -175,6 +177,7 @@ - (instancetype)initWithGrdbId:(int64_t)grdbId
     _errorType = errorType;
     _read = read;
     _recipientAddress = recipientAddress;
+    _sender = sender;
     _wasIdentityVerified = wasIdentityVerified;
 
     return self;
@@ -228,6 +231,13 @@ - (NSString *)previewTextWithTransaction:(SDSAnyReadTransaction *)transaction
         case TSErrorMessageSessionRefresh:
             return NSLocalizedString(
                 @"ERROR_MESSAGE_SESSION_REFRESH", @"Text notifying the user that their secure session has been reset");
+        case TSErrorMessageDecryptionFailure: {
+            NSString *formatString = NSLocalizedString(@"ERROR_MESSAGE_DECRYPTION_FAILURE",
+                @"Error message for a decryption failure. Embeds {{senders name}}.");
+            NSString *senderName = [self.contactsManager shortDisplayNameForAddress:self.sender
+                                                                        transaction:transaction];
+            return [[NSString alloc] initWithFormat:formatString, senderName];
+        }
         default:
             OWSFailDebug(@"failure: unknown error type");
             break;
@@ -286,6 +296,34 @@ + (instancetype)nonblockingIdentityChangeInThread:(TSThread *)thread
     return [builder build];
 }
 
++ (instancetype)failedDecryptionForEnvelope:(SSKProtoEnvelope *)envelope
+                                    groupId:(nullable NSData *)groupId
+                            withTransaction:(SDSAnyWriteTransaction *)transaction
+{
+    SignalServiceAddress *sender = [[SignalServiceAddress alloc] initWithUuidString:envelope.sourceUuid];
+    if (!sender) {
+        OWSFailDebug(@"Invalid UUID");
+        return nil;
+    }
+
+    TSThread *thread;
+    if (groupId.length > 0) {
+        thread = [TSGroupThread fetchWithGroupId:groupId transaction:transaction];
+        OWSAssertDebug(thread);
+    }
+    if (!thread) {
+        thread = [TSContactThread getThreadWithContactAddress:sender transaction:transaction];
+        OWSAssertDebug(thread);
+    }
+    if (!thread) {
+        return nil;
+    }
+    TSErrorMessageBuilder *builder = [TSErrorMessageBuilder errorMessageBuilderWithThread:thread errorType:TSErrorMessageDecryptionFailure];
+    builder.senderAddress = sender;
+    builder.timestamp = envelope.timestamp;
+    return [builder build];
+}
+
 #pragma mark - OWSReadTracking
 
 - (uint64_t)expireStartedAt
diff --git a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.swift b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.swift
index 9e56754015b..d5a8a8c14eb 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.swift
+++ b/SignalServiceKit/src/Messages/Interactions/TSErrorMessage.swift
@@ -15,6 +15,8 @@ public class TSErrorMessageBuilder: TSMessageBuilder {
     @objc
     public var recipientAddress: SignalServiceAddress?
     @objc
+    public var senderAddress: SignalServiceAddress?
+    @objc
     public var wasIdentityVerified: Bool
 
     public required init(thread: TSThread,
@@ -29,10 +31,12 @@ public class TSErrorMessageBuilder: TSMessageBuilder {
                          messageSticker: MessageSticker? = nil,
                          isViewOnceMessage: Bool = false,
                          errorType: TSErrorMessageType,
+                         senderAddress: SignalServiceAddress? = nil,
                          recipientAddress: SignalServiceAddress? = nil,
                          wasIdentityVerified: Bool = false) {
 
         self.errorType = errorType
+        self.senderAddress = senderAddress
         self.recipientAddress = recipientAddress
         self.wasIdentityVerified = wasIdentityVerified
 
diff --git a/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift b/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift
index 5d9493c1651..cd5ca164f13 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift
+++ b/SignalServiceKit/src/Messages/Interactions/TSInteraction+SDS.swift
@@ -589,6 +589,69 @@ extension TSInteraction {
                                              paymentNotification: paymentNotification,
                                              paymentRequest: paymentRequest)
 
+        case .recoverableDecryptionPlaceholder:
+
+            let uniqueId: String = record.uniqueId
+            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
+            let sortId: UInt64 = UInt64(recordId)
+            let timestamp: UInt64 = record.timestamp
+            let uniqueThreadId: String = record.threadUniqueId
+            let attachmentIdsSerialized: Data? = record.attachmentIds
+            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
+            let body: String? = record.body
+            let bodyRangesSerialized: Data? = record.bodyRanges
+            let bodyRanges: MessageBodyRanges? = try SDSDeserialization.optionalUnarchive(bodyRangesSerialized, name: "bodyRanges")
+            let contactShareSerialized: Data? = record.contactShare
+            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
+            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
+            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
+            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
+            let isViewOnceComplete: Bool = try SDSDeserialization.required(record.isViewOnceComplete, name: "isViewOnceComplete")
+            let isViewOnceMessage: Bool = try SDSDeserialization.required(record.isViewOnceMessage, name: "isViewOnceMessage")
+            let linkPreviewSerialized: Data? = record.linkPreview
+            let linkPreview: OWSLinkPreview? = try SDSDeserialization.optionalUnarchive(linkPreviewSerialized, name: "linkPreview")
+            let messageStickerSerialized: Data? = record.messageSticker
+            let messageSticker: MessageSticker? = try SDSDeserialization.optionalUnarchive(messageStickerSerialized, name: "messageSticker")
+            let quotedMessageSerialized: Data? = record.quotedMessage
+            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
+            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
+            let wasRemotelyDeleted: Bool = try SDSDeserialization.required(record.wasRemotelyDeleted, name: "wasRemotelyDeleted")
+            guard let errorType: TSErrorMessageType = record.errorType else {
+               throw SDSError.missingRequiredField
+            }
+            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
+            let recipientAddressSerialized: Data? = record.recipientAddress
+            let recipientAddress: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(recipientAddressSerialized, name: "recipientAddress")
+            let senderSerialized: Data? = record.sender
+            let sender: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(senderSerialized, name: "sender")
+            let wasIdentityVerified: Bool = try SDSDeserialization.required(record.wasIdentityVerified, name: "wasIdentityVerified")
+
+            return OWSRecoverableDecryptionPlaceholder(grdbId: recordId,
+                                                       uniqueId: uniqueId,
+                                                       receivedAtTimestamp: receivedAtTimestamp,
+                                                       sortId: sortId,
+                                                       timestamp: timestamp,
+                                                       uniqueThreadId: uniqueThreadId,
+                                                       attachmentIds: attachmentIds,
+                                                       body: body,
+                                                       bodyRanges: bodyRanges,
+                                                       contactShare: contactShare,
+                                                       expireStartedAt: expireStartedAt,
+                                                       expiresAt: expiresAt,
+                                                       expiresInSeconds: expiresInSeconds,
+                                                       isViewOnceComplete: isViewOnceComplete,
+                                                       isViewOnceMessage: isViewOnceMessage,
+                                                       linkPreview: linkPreview,
+                                                       messageSticker: messageSticker,
+                                                       quotedMessage: quotedMessage,
+                                                       storedShouldStartExpireTimer: storedShouldStartExpireTimer,
+                                                       wasRemotelyDeleted: wasRemotelyDeleted,
+                                                       errorType: errorType,
+                                                       read: read,
+                                                       recipientAddress: recipientAddress,
+                                                       sender: sender,
+                                                       wasIdentityVerified: wasIdentityVerified)
+
         case .unknownContactBlockOfferMessage:
 
             let uniqueId: String = record.uniqueId
@@ -622,6 +685,8 @@ extension TSInteraction {
             let read: Bool = try SDSDeserialization.required(record.read, name: "read")
             let recipientAddressSerialized: Data? = record.recipientAddress
             let recipientAddress: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(recipientAddressSerialized, name: "recipientAddress")
+            let senderSerialized: Data? = record.sender
+            let sender: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(senderSerialized, name: "sender")
             let wasIdentityVerified: Bool = try SDSDeserialization.required(record.wasIdentityVerified, name: "wasIdentityVerified")
 
             return OWSUnknownContactBlockOfferMessage(grdbId: recordId,
@@ -647,6 +712,7 @@ extension TSInteraction {
                                                       errorType: errorType,
                                                       read: read,
                                                       recipientAddress: recipientAddress,
+                                                      sender: sender,
                                                       wasIdentityVerified: wasIdentityVerified)
 
         case .unknownProtocolVersionMessage:
@@ -847,6 +913,8 @@ extension TSInteraction {
             let read: Bool = try SDSDeserialization.required(record.read, name: "read")
             let recipientAddressSerialized: Data? = record.recipientAddress
             let recipientAddress: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(recipientAddressSerialized, name: "recipientAddress")
+            let senderSerialized: Data? = record.sender
+            let sender: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(senderSerialized, name: "sender")
             let wasIdentityVerified: Bool = try SDSDeserialization.required(record.wasIdentityVerified, name: "wasIdentityVerified")
 
             return TSErrorMessage(grdbId: recordId,
@@ -872,6 +940,7 @@ extension TSInteraction {
                                   errorType: errorType,
                                   read: read,
                                   recipientAddress: recipientAddress,
+                                  sender: sender,
                                   wasIdentityVerified: wasIdentityVerified)
 
         case .incomingMessage:
@@ -1052,6 +1121,8 @@ extension TSInteraction {
             let read: Bool = try SDSDeserialization.required(record.read, name: "read")
             let recipientAddressSerialized: Data? = record.recipientAddress
             let recipientAddress: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(recipientAddressSerialized, name: "recipientAddress")
+            let senderSerialized: Data? = record.sender
+            let sender: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(senderSerialized, name: "sender")
             let wasIdentityVerified: Bool = try SDSDeserialization.required(record.wasIdentityVerified, name: "wasIdentityVerified")
 
             return TSInvalidIdentityKeyErrorMessage(grdbId: recordId,
@@ -1077,6 +1148,7 @@ extension TSInteraction {
                                                     errorType: errorType,
                                                     read: read,
                                                     recipientAddress: recipientAddress,
+                                                    sender: sender,
                                                     wasIdentityVerified: wasIdentityVerified)
 
         case .invalidIdentityKeyReceivingErrorMessage:
@@ -1112,6 +1184,8 @@ extension TSInteraction {
             let read: Bool = try SDSDeserialization.required(record.read, name: "read")
             let recipientAddressSerialized: Data? = record.recipientAddress
             let recipientAddress: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(recipientAddressSerialized, name: "recipientAddress")
+            let senderSerialized: Data? = record.sender
+            let sender: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(senderSerialized, name: "sender")
             let wasIdentityVerified: Bool = try SDSDeserialization.required(record.wasIdentityVerified, name: "wasIdentityVerified")
             let authorId: String = try SDSDeserialization.required(record.authorId, name: "authorId")
             let envelopeData: Data? = SDSDeserialization.optionalData(record.envelopeData, name: "envelopeData")
@@ -1139,6 +1213,7 @@ extension TSInteraction {
                                                              errorType: errorType,
                                                              read: read,
                                                              recipientAddress: recipientAddress,
+                                                             sender: sender,
                                                              wasIdentityVerified: wasIdentityVerified,
                                                              authorId: authorId,
                                                              envelopeData: envelopeData)
@@ -1176,6 +1251,8 @@ extension TSInteraction {
             let read: Bool = try SDSDeserialization.required(record.read, name: "read")
             let recipientAddressSerialized: Data? = record.recipientAddress
             let recipientAddress: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(recipientAddressSerialized, name: "recipientAddress")
+            let senderSerialized: Data? = record.sender
+            let sender: SignalServiceAddress? = try SDSDeserialization.optionalUnarchive(senderSerialized, name: "sender")
             let wasIdentityVerified: Bool = try SDSDeserialization.required(record.wasIdentityVerified, name: "wasIdentityVerified")
             let messageId: String = try SDSDeserialization.required(record.messageId, name: "messageId")
             let preKeyBundleSerialized: Data? = record.preKeyBundle
@@ -1204,6 +1281,7 @@ extension TSInteraction {
                                                            errorType: errorType,
                                                            read: read,
                                                            recipientAddress: recipientAddress,
+                                                           sender: sender,
                                                            wasIdentityVerified: wasIdentityVerified,
                                                            messageId: messageId,
                                                            preKeyBundle: preKeyBundle)
@@ -1407,6 +1485,9 @@ extension TSInteraction: SDSModel {
         case let model as OWSUnknownContactBlockOfferMessage:
             assert(type(of: model) == OWSUnknownContactBlockOfferMessage.self)
             return OWSUnknownContactBlockOfferMessageSerializer(model: model)
+        case let model as OWSRecoverableDecryptionPlaceholder:
+            assert(type(of: model) == OWSRecoverableDecryptionPlaceholder.self)
+            return OWSRecoverableDecryptionPlaceholderSerializer(model: model)
         case let model as TSErrorMessage:
             assert(type(of: model) == TSErrorMessage.self)
             return TSErrorMessageSerializer(model: model)
@@ -2881,6 +2962,19 @@ extension TSInteraction: DeepCopyable {
             } else {
                recipientAddress = nil
             }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let sender: SignalServiceAddress?
+            if let senderForCopy = modelToCopy.sender {
+               sender = try DeepCopies.deepCopy(senderForCopy)
+            } else {
+               sender = nil
+            }
             let wasIdentityVerified: Bool = modelToCopy.wasIdentityVerified
             let messageId: String = modelToCopy.messageId
             // NOTE: If this generates build errors, you made need to
@@ -2910,6 +3004,7 @@ extension TSInteraction: DeepCopyable {
                                                            errorType: errorType,
                                                            read: read,
                                                            recipientAddress: recipientAddress,
+                                                           sender: sender,
                                                            wasIdentityVerified: wasIdentityVerified,
                                                            messageId: messageId,
                                                            preKeyBundle: preKeyBundle)
@@ -3013,6 +3108,19 @@ extension TSInteraction: DeepCopyable {
             } else {
                recipientAddress = nil
             }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let sender: SignalServiceAddress?
+            if let senderForCopy = modelToCopy.sender {
+               sender = try DeepCopies.deepCopy(senderForCopy)
+            } else {
+               sender = nil
+            }
             let wasIdentityVerified: Bool = modelToCopy.wasIdentityVerified
             let authorId: String = modelToCopy.authorId
             let envelopeData: Data? = modelToCopy.envelopeData
@@ -3040,6 +3148,7 @@ extension TSInteraction: DeepCopyable {
                                                              errorType: errorType,
                                                              read: read,
                                                              recipientAddress: recipientAddress,
+                                                             sender: sender,
                                                              wasIdentityVerified: wasIdentityVerified,
                                                              authorId: authorId,
                                                              envelopeData: envelopeData)
@@ -3143,6 +3252,19 @@ extension TSInteraction: DeepCopyable {
             } else {
                recipientAddress = nil
             }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let sender: SignalServiceAddress?
+            if let senderForCopy = modelToCopy.sender {
+               sender = try DeepCopies.deepCopy(senderForCopy)
+            } else {
+               sender = nil
+            }
             let wasIdentityVerified: Bool = modelToCopy.wasIdentityVerified
 
             return TSInvalidIdentityKeyErrorMessage(grdbId: id,
@@ -3168,6 +3290,7 @@ extension TSInteraction: DeepCopyable {
                                                     errorType: errorType,
                                                     read: read,
                                                     recipientAddress: recipientAddress,
+                                                    sender: sender,
                                                     wasIdentityVerified: wasIdentityVerified)
         }
 
@@ -3269,6 +3392,19 @@ extension TSInteraction: DeepCopyable {
             } else {
                recipientAddress = nil
             }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let sender: SignalServiceAddress?
+            if let senderForCopy = modelToCopy.sender {
+               sender = try DeepCopies.deepCopy(senderForCopy)
+            } else {
+               sender = nil
+            }
             let wasIdentityVerified: Bool = modelToCopy.wasIdentityVerified
 
             return OWSUnknownContactBlockOfferMessage(grdbId: id,
@@ -3294,9 +3430,150 @@ extension TSInteraction: DeepCopyable {
                                                       errorType: errorType,
                                                       read: read,
                                                       recipientAddress: recipientAddress,
+                                                      sender: sender,
                                                       wasIdentityVerified: wasIdentityVerified)
         }
 
+        if let modelToCopy = self as? OWSRecoverableDecryptionPlaceholder {
+            assert(type(of: modelToCopy) == OWSRecoverableDecryptionPlaceholder.self)
+            let uniqueId: String = modelToCopy.uniqueId
+            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
+            let sortId: UInt64 = modelToCopy.sortId
+            let timestamp: UInt64 = modelToCopy.timestamp
+            let uniqueThreadId: String = modelToCopy.uniqueThreadId
+            // NOTE: If this generates build errors, you made need to
+            // implement DeepCopyable for this type in DeepCopy.swift.
+            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
+            let body: String? = modelToCopy.body
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let bodyRanges: MessageBodyRanges?
+            if let bodyRangesForCopy = modelToCopy.bodyRanges {
+               bodyRanges = try DeepCopies.deepCopy(bodyRangesForCopy)
+            } else {
+               bodyRanges = nil
+            }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let contactShare: OWSContact?
+            if let contactShareForCopy = modelToCopy.contactShare {
+               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
+            } else {
+               contactShare = nil
+            }
+            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
+            let expiresAt: UInt64 = modelToCopy.expiresAt
+            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
+            let isViewOnceComplete: Bool = modelToCopy.isViewOnceComplete
+            let isViewOnceMessage: Bool = modelToCopy.isViewOnceMessage
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let linkPreview: OWSLinkPreview?
+            if let linkPreviewForCopy = modelToCopy.linkPreview {
+               linkPreview = try DeepCopies.deepCopy(linkPreviewForCopy)
+            } else {
+               linkPreview = nil
+            }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let messageSticker: MessageSticker?
+            if let messageStickerForCopy = modelToCopy.messageSticker {
+               messageSticker = try DeepCopies.deepCopy(messageStickerForCopy)
+            } else {
+               messageSticker = nil
+            }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let quotedMessage: TSQuotedMessage?
+            if let quotedMessageForCopy = modelToCopy.quotedMessage {
+               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
+            } else {
+               quotedMessage = nil
+            }
+            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
+            let wasRemotelyDeleted: Bool = modelToCopy.wasRemotelyDeleted
+            let errorType: TSErrorMessageType = modelToCopy.errorType
+            let read: Bool = modelToCopy.wasRead
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let recipientAddress: SignalServiceAddress?
+            if let recipientAddressForCopy = modelToCopy.recipientAddress {
+               recipientAddress = try DeepCopies.deepCopy(recipientAddressForCopy)
+            } else {
+               recipientAddress = nil
+            }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let sender: SignalServiceAddress?
+            if let senderForCopy = modelToCopy.sender {
+               sender = try DeepCopies.deepCopy(senderForCopy)
+            } else {
+               sender = nil
+            }
+            let wasIdentityVerified: Bool = modelToCopy.wasIdentityVerified
+
+            return OWSRecoverableDecryptionPlaceholder(grdbId: id,
+                                                       uniqueId: uniqueId,
+                                                       receivedAtTimestamp: receivedAtTimestamp,
+                                                       sortId: sortId,
+                                                       timestamp: timestamp,
+                                                       uniqueThreadId: uniqueThreadId,
+                                                       attachmentIds: attachmentIds,
+                                                       body: body,
+                                                       bodyRanges: bodyRanges,
+                                                       contactShare: contactShare,
+                                                       expireStartedAt: expireStartedAt,
+                                                       expiresAt: expiresAt,
+                                                       expiresInSeconds: expiresInSeconds,
+                                                       isViewOnceComplete: isViewOnceComplete,
+                                                       isViewOnceMessage: isViewOnceMessage,
+                                                       linkPreview: linkPreview,
+                                                       messageSticker: messageSticker,
+                                                       quotedMessage: quotedMessage,
+                                                       storedShouldStartExpireTimer: storedShouldStartExpireTimer,
+                                                       wasRemotelyDeleted: wasRemotelyDeleted,
+                                                       errorType: errorType,
+                                                       read: read,
+                                                       recipientAddress: recipientAddress,
+                                                       sender: sender,
+                                                       wasIdentityVerified: wasIdentityVerified)
+        }
+
         if let modelToCopy = self as? TSErrorMessage {
             assert(type(of: modelToCopy) == TSErrorMessage.self)
             let uniqueId: String = modelToCopy.uniqueId
@@ -3395,6 +3672,19 @@ extension TSInteraction: DeepCopyable {
             } else {
                recipientAddress = nil
             }
+            // NOTE: If this generates build errors, you made need to
+            // modify DeepCopy.swift to support this type.
+            //
+            // That might mean:
+            //
+            // * Implement DeepCopyable for this type (e.g. a model).
+            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
+            let sender: SignalServiceAddress?
+            if let senderForCopy = modelToCopy.sender {
+               sender = try DeepCopies.deepCopy(senderForCopy)
+            } else {
+               sender = nil
+            }
             let wasIdentityVerified: Bool = modelToCopy.wasIdentityVerified
 
             return TSErrorMessage(grdbId: id,
@@ -3420,6 +3710,7 @@ extension TSInteraction: DeepCopyable {
                                   errorType: errorType,
                                   read: read,
                                   recipientAddress: recipientAddress,
+                                  sender: sender,
                                   wasIdentityVerified: wasIdentityVerified)
         }
 
diff --git a/SignalServiceKit/src/Messages/Interactions/TSInteraction.swift b/SignalServiceKit/src/Messages/Interactions/TSInteraction.swift
index e5ae44ed021..0328930faea 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSInteraction.swift
+++ b/SignalServiceKit/src/Messages/Interactions/TSInteraction.swift
@@ -72,4 +72,47 @@ extension TSInteraction {
             return true
         }
     }
+
+    private func replacePlaceholder(
+        from sender: SignalServiceAddress,
+        transaction: SDSAnyWriteTransaction
+    ) -> Bool {
+        do {
+            let placeholders = try InteractionFinder.interactions(
+                withTimestamp: timestamp,
+                filter: { candidate in
+                    guard let placeholder = candidate as? OWSRecoverableDecryptionPlaceholder else { return false }
+                    return placeholder.sender == sender && placeholder.timestamp == self.timestamp
+                },
+                transaction: transaction
+            )
+
+            if let placeholder = (placeholders.first as? OWSRecoverableDecryptionPlaceholder) {
+                owsAssertDebug(placeholders.count == 1)
+                placeholder.replaceWithInteraction(self, writeTx: transaction)
+                return true
+            }
+        } catch {
+            owsFailDebug("\(error)")
+        }
+        return false
+    }
+
+    @objc
+    public func insertOrReplacePlaceholder(from sender: SignalServiceAddress, transaction: SDSAnyWriteTransaction) {
+        if replacePlaceholder(from: sender, transaction: transaction) {
+            // Done!
+        } else {
+            anyInsert(transaction: transaction)
+        }
+    }
+
+    @objc
+    public func upsertOrReplacePlaceholder(from sender: SignalServiceAddress, transaction: SDSAnyWriteTransaction) {
+        if replacePlaceholder(from: sender, transaction: transaction) {
+            // Done!
+        } else {
+            anyUpsert(transaction: transaction)
+        }
+    }
 }
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyErrorMessage+SDS.swift b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyErrorMessage+SDS.swift
index e420740a1b2..6f59a384bed 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyErrorMessage+SDS.swift
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyErrorMessage+SDS.swift
@@ -102,7 +102,7 @@ class TSInvalidIdentityKeyErrorMessageSerializer: SDSSerializer {
         let read: Bool? = model.wasRead
         let recipientAddress: Data? = optionalArchive(model.recipientAddress)
         let recipientAddressStates: Data? = nil
-        let sender: Data? = nil
+        let sender: Data? = optionalArchive(model.sender)
         let serverTimestamp: UInt64? = nil
         let sourceDeviceId: UInt32? = nil
         let storedMessageState: TSOutgoingMessageState? = nil
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage+SDS.swift b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage+SDS.swift
index e7ce8a2babc..ef941ff8197 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage+SDS.swift
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage+SDS.swift
@@ -102,7 +102,7 @@ class TSInvalidIdentityKeyReceivingErrorMessageSerializer: SDSSerializer {
         let read: Bool? = model.wasRead
         let recipientAddress: Data? = optionalArchive(model.recipientAddress)
         let recipientAddressStates: Data? = nil
-        let sender: Data? = nil
+        let sender: Data? = optionalArchive(model.sender)
         let serverTimestamp: UInt64? = nil
         let sourceDeviceId: UInt32? = nil
         let storedMessageState: TSOutgoingMessageState? = nil
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.h b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.h
index 131f3804e8d..9986f0874c4 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.h
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.h
@@ -48,10 +48,11 @@ __attribute__((deprecated)) @interface TSInvalidIdentityKeyReceivingErrorMessage
                        errorType:(TSErrorMessageType)errorType
                             read:(BOOL)read
                 recipientAddress:(nullable SignalServiceAddress *)recipientAddress
+                          sender:(nullable SignalServiceAddress *)sender
              wasIdentityVerified:(BOOL)wasIdentityVerified
                         authorId:(NSString *)authorId
                     envelopeData:(nullable NSData *)envelopeData
-NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:attachmentIds:body:bodyRanges:contactShare:expireStartedAt:expiresAt:expiresInSeconds:isViewOnceComplete:isViewOnceMessage:linkPreview:messageSticker:quotedMessage:storedShouldStartExpireTimer:wasRemotelyDeleted:errorType:read:recipientAddress:wasIdentityVerified:authorId:envelopeData:));
+NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:attachmentIds:body:bodyRanges:contactShare:expireStartedAt:expiresAt:expiresInSeconds:isViewOnceComplete:isViewOnceMessage:linkPreview:messageSticker:quotedMessage:storedShouldStartExpireTimer:wasRemotelyDeleted:errorType:read:recipientAddress:sender:wasIdentityVerified:authorId:envelopeData:));
 
 // clang-format on
 
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.m b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.m
index 68f669fb0b5..4d746703f99 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.m
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeyReceivingErrorMessage.m
@@ -109,6 +109,7 @@ - (instancetype)initWithGrdbId:(int64_t)grdbId
                        errorType:(TSErrorMessageType)errorType
                             read:(BOOL)read
                 recipientAddress:(nullable SignalServiceAddress *)recipientAddress
+                          sender:(nullable SignalServiceAddress *)sender
              wasIdentityVerified:(BOOL)wasIdentityVerified
                         authorId:(NSString *)authorId
                     envelopeData:(nullable NSData *)envelopeData
@@ -136,6 +137,7 @@ - (instancetype)initWithGrdbId:(int64_t)grdbId
                          errorType:errorType
                               read:read
                   recipientAddress:recipientAddress
+                            sender:sender
                wasIdentityVerified:wasIdentityVerified];
 
     if (!self) {
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage+SDS.swift b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage+SDS.swift
index 68d20b697bc..a1f24442e36 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage+SDS.swift
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage+SDS.swift
@@ -102,7 +102,7 @@ class TSInvalidIdentityKeySendingErrorMessageSerializer: SDSSerializer {
         let read: Bool? = model.wasRead
         let recipientAddress: Data? = optionalArchive(model.recipientAddress)
         let recipientAddressStates: Data? = nil
-        let sender: Data? = nil
+        let sender: Data? = optionalArchive(model.sender)
         let serverTimestamp: UInt64? = nil
         let sourceDeviceId: UInt32? = nil
         let storedMessageState: TSOutgoingMessageState? = nil
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.h b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.h
index eab9404bb07..effae9d7c9b 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.h
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.h
@@ -47,10 +47,11 @@ __attribute__((deprecated)) @interface TSInvalidIdentityKeySendingErrorMessage :
                        errorType:(TSErrorMessageType)errorType
                             read:(BOOL)read
                 recipientAddress:(nullable SignalServiceAddress *)recipientAddress
+                          sender:(nullable SignalServiceAddress *)sender
              wasIdentityVerified:(BOOL)wasIdentityVerified
                        messageId:(NSString *)messageId
                     preKeyBundle:(PreKeyBundle *)preKeyBundle
-NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:attachmentIds:body:bodyRanges:contactShare:expireStartedAt:expiresAt:expiresInSeconds:isViewOnceComplete:isViewOnceMessage:linkPreview:messageSticker:quotedMessage:storedShouldStartExpireTimer:wasRemotelyDeleted:errorType:read:recipientAddress:wasIdentityVerified:messageId:preKeyBundle:));
+NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:attachmentIds:body:bodyRanges:contactShare:expireStartedAt:expiresAt:expiresInSeconds:isViewOnceComplete:isViewOnceMessage:linkPreview:messageSticker:quotedMessage:storedShouldStartExpireTimer:wasRemotelyDeleted:errorType:read:recipientAddress:sender:wasIdentityVerified:messageId:preKeyBundle:));
 
 // clang-format on
 
diff --git a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.m b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.m
index 5480ea252a8..28671902681 100644
--- a/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.m
+++ b/SignalServiceKit/src/Messages/InvalidKeyMessages/TSInvalidIdentityKeySendingErrorMessage.m
@@ -62,6 +62,7 @@ - (instancetype)initWithGrdbId:(int64_t)grdbId
                        errorType:(TSErrorMessageType)errorType
                             read:(BOOL)read
                 recipientAddress:(nullable SignalServiceAddress *)recipientAddress
+                          sender:(nullable SignalServiceAddress *)sender
              wasIdentityVerified:(BOOL)wasIdentityVerified
                        messageId:(NSString *)messageId
                     preKeyBundle:(PreKeyBundle *)preKeyBundle
@@ -89,6 +90,7 @@ - (instancetype)initWithGrdbId:(int64_t)grdbId
                          errorType:errorType
                               read:read
                   recipientAddress:recipientAddress
+                            sender:sender
                wasIdentityVerified:wasIdentityVerified];
 
     if (!self) {
diff --git a/SignalServiceKit/src/Messages/MessageSender.m b/SignalServiceKit/src/Messages/MessageSender.m
index 734c7c77591..1e27ce0e79d 100644
--- a/SignalServiceKit/src/Messages/MessageSender.m
+++ b/SignalServiceKit/src/Messages/MessageSender.m
@@ -1,5 +1,6 @@
 //
 //  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
 
 #import <SignalServiceKit/MessageSender.h>
 #import "NSData+keyVersionByte.h"
@@ -1141,18 +1142,18 @@ - (void)_sendMessageToRecipient:(OWSMessageSend *)messageSend
     }
 
     for (NSDictionary *deviceMessage in deviceMessages) {
-        NSNumber *_Nullable messageType = deviceMessage[@"type"];
-        OWSAssertDebug(messageType);
-        BOOL hasValidMessageType;
+        TSWhisperMessageType messageType = [deviceMessage[@"type"] integerValue];
+        BOOL hasValidMessageType = NO;
         if (messageSend.isUDSend) {
-            hasValidMessageType = [messageType isEqualToNumber:@(TSUnidentifiedSenderMessageType)];
+            hasValidMessageType |= (messageType == TSUnidentifiedSenderMessageType);
         } else {
-            hasValidMessageType = ([messageType isEqualToNumber:@(TSEncryptedWhisperMessageType)] ||
-                [messageType isEqualToNumber:@(TSPreKeyWhisperMessageType)]);
+            hasValidMessageType |= (messageType == TSEncryptedWhisperMessageType);
+            hasValidMessageType |= (messageType == TSPreKeyWhisperMessageType);
+            hasValidMessageType |= (messageType == TSPlaintextMessageType);
         }
 
         if (!hasValidMessageType) {
-            OWSFailDebug(@"Invalid message type: %@", messageType);
+            OWSFailDebug(@"Invalid message type: %ld", (long)messageType);
             NSError *error = OWSErrorMakeFailedToSendOutgoingMessageError();
             [error setIsRetryable:NO];
             return messageSend.failure(error);
diff --git a/SignalServiceKit/src/Messages/MessageSender.swift b/SignalServiceKit/src/Messages/MessageSender.swift
index 60c7578c0d3..c2405fce443 100644
--- a/SignalServiceKit/src/Messages/MessageSender.swift
+++ b/SignalServiceKit/src/Messages/MessageSender.swift
@@ -1245,7 +1245,10 @@ extension MessageSender {
                 messageType = .encryptedWhisperMessageType
             case .preKey:
                 messageType = .preKeyWhisperMessageType
+            case .plaintext:
+                messageType = .plaintextMessageType
             default:
+                owsFailDebug("Unrecognized message type")
                 messageType = .unknownMessageType
             }
 
diff --git a/SignalServiceKit/src/Messages/OWSMessageDecrypter.swift b/SignalServiceKit/src/Messages/OWSMessageDecrypter.swift
index b7c787b3eae..356ea5f7860 100644
--- a/SignalServiceKit/src/Messages/OWSMessageDecrypter.swift
+++ b/SignalServiceKit/src/Messages/OWSMessageDecrypter.swift
@@ -162,6 +162,12 @@ public class OWSMessageDecrypter: OWSMessageHandler {
                 envelopeData: envelopeData,
                 cipherType: .senderKey,
                 transaction: transaction)
+        case .plaintextContent:
+            return decrypt(
+                envelope,
+                envelopeData: envelopeData,
+                cipherType: .plaintext,
+                transaction: transaction)
         @unknown default:
             Logger.warn("Received unhandled envelope type: \(envelope.unwrappedType)")
             return .failure(OWSGenericError("Received unhandled envelope type: \(envelope.unwrappedType)"))
@@ -284,13 +290,14 @@ public class OWSMessageDecrypter: OWSMessageHandler {
         }
     }
 
-    @objc
     private func processError(
         _ error: Error,
         envelope: SSKProtoEnvelope,
+        groupId: Data?,
+        cipherType: CiphertextMessage.MessageType,
+        contentHint: UnidentifiedSenderMessageContent.ContentHint,
         transaction: SDSAnyWriteTransaction
     ) -> Error {
-        // TODO: Handle missing sender key recovery
         let logString = "Error while decrypting \(Self.description(forEnvelopeType: envelope)) message: \(error)"
 
         if case SignalError.duplicatedMessage(_) = error {
@@ -323,35 +330,50 @@ public class OWSMessageDecrypter: OWSMessageHandler {
                                                               transaction: transaction)
 
         let errorMessage: TSErrorMessage?
-        if let sourceUuid = envelope.sourceUuid {
-            // Since the message failed to decrypt, we want to reset our session
-            // with this device to ensure future messages we receive are decryptable.
-            // We achieve this by archiving our current session with this device.
-            // It's important we don't do this if we've already recently reset the
-            // session for a given device, for example if we're processing a backlog
-            // of 50 message from Alice that all fail to decrypt we don't want to
-            // reset the session 50 times. We acomplish this by tracking the UUID +
-            // device ID pair that we have recently reset, so we can skip subsequent
-            // resets. When the message decrypt queue is drained, the list of recently
-            // reset IDs is cleared.
-
-            let senderId = "\(sourceUuid).\(envelope.sourceDevice)"
-            if !senderIdsResetDuringCurrentBatch.contains(senderId) {
-                senderIdsResetDuringCurrentBatch.add(senderId)
-
-                Logger.warn("Archiving session for undecryptable message from \(senderId)")
-                Self.sessionStore.archiveSession(for: sourceAddress,
-                                                                  deviceId: Int32(envelope.sourceDevice),
-                                                                  transaction: transaction)
-
-                // Always notify the user that we have performed an automatic archive.
-                errorMessage = TSErrorMessage.sessionRefresh(with: envelope, with: transaction)
-
-                trySendNullMessage(in: contactThread, senderId: senderId, transaction: transaction)
+        if envelope.hasSourceUuid {
+            let supportsModernResend = GroupManager.doesUserHaveSenderKeyCapability(
+                address: sourceAddress,
+                transaction: transaction)
+
+            if supportsModernResend {
+                switch contentHint {
+                case .default:
+                    // If default, insert an error message right away
+                    errorMessage = TSErrorMessage.failedDecryption(
+                        for: envelope,
+                        groupId: groupId,
+                        with: transaction)
+                case .resendable:
+                    // If resendable, insert a placeholder and delay showing the error until later
+                    OWSRecoverableDecryptionPlaceholder(
+                        failedEnvelope: envelope,
+                        groupId: groupId,
+                        transaction: transaction
+                    )?.anyInsert(transaction: transaction)
+                    errorMessage = nil
+                case .implicit:
+                    errorMessage = nil
+                default:
+                    owsFailDebug("Unexpected content hint")
+                    errorMessage = nil
+                }
+
+                // We always send a resend request, even if the contentHint indicates the sender
+                // won't be able to fulfill the request. This will notify the sender to reset
+                // the session.
+                sendResendRequest(envelope: envelope, cipherType: cipherType, transaction: transaction)
             } else {
-                Logger.warn("Skipping session reset for undecryptable message from \(senderId), " +
-                                "already reset during this batch")
-                errorMessage = nil
+                let didReset = resetSessionIfNecessary(
+                    envelope: envelope,
+                    contactThread: contactThread,
+                    transaction: transaction)
+
+                if didReset {
+                    // Always notify the user that we have performed an automatic archive.
+                    errorMessage = TSErrorMessage.sessionRefresh(with: envelope, with: transaction)
+                } else {
+                    errorMessage = nil
+                }
             }
         } else {
             owsFailDebug("Received envelope missing UUID \(sourceAddress).\(envelope.sourceDevice)")
@@ -388,6 +410,53 @@ public class OWSMessageDecrypter: OWSMessageHandler {
         return wrappedError
     }
 
+    func sendResendRequest(envelope: SSKProtoEnvelope,
+                           cipherType: CiphertextMessage.MessageType,
+                           transaction: SDSAnyWriteTransaction) {
+        let resendRequest = OWSOutgoingResendRequest(
+            failedEnvelope: envelope,
+            cipherType: UInt32(cipherType.rawValue),
+            transaction: transaction)
+        messageSenderJobQueue.add(message: resendRequest.asPreparer, transaction: transaction)
+    }
+
+    func resetSessionIfNecessary(envelope: SSKProtoEnvelope,
+                                 contactThread: TSContactThread,
+                                 transaction: SDSAnyWriteTransaction) -> Bool {
+        // Since the message failed to decrypt, we want to reset our session
+        // with this device to ensure future messages we receive are decryptable.
+        // We achieve this by archiving our current session with this device.
+        // It's important we don't do this if we've already recently reset the
+        // session for a given device, for example if we're processing a backlog
+        // of 50 message from Alice that all fail to decrypt we don't want to
+        // reset the session 50 times. We acomplish this by tracking the UUID +
+        // device ID pair that we have recently reset, so we can skip subsequent
+        // resets. When the message decrypt queue is drained, the list of recently
+        // reset IDs is cleared.
+        guard let sourceAddress = envelope.sourceAddress,
+              let sourceUuid = envelope.sourceUuid else {
+            owsFailDebug("Expected UUID")
+            return false
+        }
+
+        let senderId = "\(sourceUuid).\(envelope.sourceDevice)"
+        if !senderIdsResetDuringCurrentBatch.contains(senderId) {
+            senderIdsResetDuringCurrentBatch.add(senderId)
+
+            Logger.warn("Archiving session for undecryptable message from \(senderId)")
+            Self.sessionStore.archiveSession(for: sourceAddress,
+                                             deviceId: Int32(envelope.sourceDevice),
+                                             transaction: transaction)
+
+            trySendNullMessage(in: contactThread, senderId: senderId, transaction: transaction)
+            return true
+        } else {
+            Logger.warn("Skipping session reset for undecryptable message from \(senderId), " +
+                            "already reset during this batch")
+            return false
+        }
+    }
+
     @objc
     private func isSignalClientError(_ error: Error) -> Bool {
         return error is SignalError
@@ -488,6 +557,9 @@ public class OWSMessageDecrypter: OWSMessageHandler {
                     from: protocolAddress,
                     store: Self.senderKeyStore,
                     context: transaction)
+            case .plaintext:
+                let plaintextMessage = try PlaintextContent(bytes: encryptedData)
+                plaintext = plaintextMessage.body
 
             // FIXME: return this to @unknown default once cipherType is represented
             // as a finite enum.
@@ -512,6 +584,9 @@ public class OWSMessageDecrypter: OWSMessageHandler {
             let wrappedError = processError(
                 error,
                 envelope: envelope,
+                groupId: nil,
+                cipherType: cipherType,
+                contentHint: .default,
                 transaction: transaction
             )
 
@@ -565,62 +640,54 @@ public class OWSMessageDecrypter: OWSMessageHandler {
                 localDeviceId: Int32(localDeviceId),
                 protocolContext: transaction
             )
-        } catch {
-            // TODO: Handle decryption failure because of missing sender key
-            // Decrypt Failure Part 1: Unwrap failure details
+        } catch let error as SecretSessionKnownSenderError {
+            let underlyingError = error.underlyingError
 
-            let nsError = error as NSError
-
-            let underlyingError: Error
-            let identifiedEnvelope: SSKProtoEnvelope
-
-            if nsError.domain == "SignalMetadataKit.SecretSessionKnownSenderError" {
-                underlyingError = nsError.userInfo[NSUnderlyingErrorKey] as! Error
+            if isSecretSessionSelfSentMessageError(underlyingError) || !isSignalClientError(underlyingError) {
+                return .failure(underlyingError)
+            } else {
+                // Let's rebuild the envelope with the known sender info
+                let senderAddress = SignalServiceAddress(
+                    uuid: error.senderAddress.uuid,
+                    phoneNumber: error.senderAddress.e164,
+                    trustLevel: .high)
 
-                let senderE164 = nsError.userInfo[SecretSessionKnownSenderError.kSenderE164Key] as? String
-                let senderUuid = nsError.userInfo[SecretSessionKnownSenderError.kSenderUuidKey] as? UUID
-                let senderAddress = SignalServiceAddress(uuid: senderUuid, phoneNumber: senderE164, trustLevel: .high)
                 owsAssert(senderAddress.isValid)
 
-                let senderDeviceId = nsError.userInfo[SecretSessionKnownSenderError.kSenderDeviceIdKey] as! NSNumber
-
                 let identifiedEnvelopeBuilder = envelope.asBuilder()
-                if let sourceE164 = senderAddress.phoneNumber {
-                    identifiedEnvelopeBuilder.setSourceE164(sourceE164)
-                }
-                if let sourceUuid = senderAddress.uuidString {
-                    identifiedEnvelopeBuilder.setSourceUuid(sourceUuid)
-                }
-                identifiedEnvelopeBuilder.setSourceDevice(senderDeviceId.uint32Value)
+                senderAddress.phoneNumber.map { identifiedEnvelopeBuilder.setSourceE164($0) }
+                senderAddress.uuidString.map { identifiedEnvelopeBuilder.setSourceUuid($0) }
+                identifiedEnvelopeBuilder.setSourceDevice(error.senderDeviceId)
 
+                let identifiedEnvelope: SSKProtoEnvelope
                 do {
                     identifiedEnvelope = try identifiedEnvelopeBuilder.build()
                 } catch {
                     owsFail("failure identifiedEnvelopeBuilderError: \(error)")
                 }
-            } else {
-                underlyingError = error
-                identifiedEnvelope = envelope
-            }
-
-            // Decrypt Failure Part 2: Handle unwrapped failure details
-
-            guard !isSignalClientError(underlyingError) else {
                 let wrappedError = processError(
                     underlyingError,
                     envelope: identifiedEnvelope,
-                    transaction: transaction
-                )
+                    groupId: error.groupId,
+                    cipherType: error.cipherType,
+                    contentHint: error.contentHint,
+                    transaction: transaction)
                 return .failure(wrappedError)
             }
+        } catch {
+            if isSecretSessionSelfSentMessageError(error) || !isSignalClientError(error) {
+                return .failure(error)
+            } else {
+                let wrappedError = processError(
+                    error,
+                    envelope: envelope,
+                    groupId: nil,
+                    cipherType: .plaintext,
+                    contentHint: .default,
+                    transaction: transaction)
 
-            guard !isSecretSessionSelfSentMessageError(underlyingError) else {
-                // Self-sent messages can be safely discarded.
-                return .failure(underlyingError)
+                return .failure(wrappedError)
             }
-
-            owsFailDebug("Could not decrypt UD message: \(underlyingError), identified envelope: \(description(for: identifiedEnvelope))")
-            return .failure(underlyingError)
         }
 
         if decryptResult.messageType == .prekey {
diff --git a/SignalServiceKit/src/Messages/OWSMessageHandler.m b/SignalServiceKit/src/Messages/OWSMessageHandler.m
index b9c7b64842f..d80bbec9100 100644
--- a/SignalServiceKit/src/Messages/OWSMessageHandler.m
+++ b/SignalServiceKit/src/Messages/OWSMessageHandler.m
@@ -24,8 +24,6 @@ + (NSString *)descriptionForEnvelopeType:(SSKProtoEnvelope *)envelope
         return @"Missing Type.";
     }
     switch (envelope.unwrappedType) {
-        case SSKProtoEnvelopeTypeReceipt:
-            return @"DeliveryReceipt";
         case SSKProtoEnvelopeTypeUnknown:
             // Shouldn't happen
             OWSProdFail([OWSAnalyticsEvents messageManagerErrorEnvelopeTypeUnknown]);
@@ -38,8 +36,14 @@ + (NSString *)descriptionForEnvelopeType:(SSKProtoEnvelope *)envelope
             return @"KeyExchange";
         case SSKProtoEnvelopeTypePrekeyBundle:
             return @"PreKeyEncryptedMessage";
+        case SSKProtoEnvelopeTypeReceipt:
+            return @"DeliveryReceipt";
         case SSKProtoEnvelopeTypeUnidentifiedSender:
             return @"UnidentifiedSender";
+        case SSKProtoEnvelopeTypeSenderkeyMessage:
+            return @"SenderKey";
+        case SSKProtoEnvelopeTypePlaintextContent:
+            return @"PlaintextContent";
         default:
             // Shouldn't happen
             OWSProdFail([OWSAnalyticsEvents messageManagerErrorEnvelopeTypeOther]);
@@ -83,6 +87,8 @@ - (NSString *)descriptionForContent:(SSKProtoContent *)content
         [message appendFormat:@"<ReceiptMessage: %@ />", content.receiptMessage];
     } else if (content.typingMessage) {
         [message appendFormat:@"<TypingMessage: %@ />", content.typingMessage];
+    } else if (content.decryptionErrorMessage) {
+        [message appendFormat:@"<DecryptionErrorMessage: %@ />", content.decryptionErrorMessage];
     }
 
     // SKDM's are not mutually exclusive with other content types
diff --git a/SignalServiceKit/src/Messages/OWSMessageManager.m b/SignalServiceKit/src/Messages/OWSMessageManager.m
index 647c5c32232..b6c2ec72518 100644
--- a/SignalServiceKit/src/Messages/OWSMessageManager.m
+++ b/SignalServiceKit/src/Messages/OWSMessageManager.m
@@ -239,6 +239,8 @@ - (void)throws_processEnvelope:(SSKProtoEnvelope *)envelope
         case SSKProtoEnvelopeTypeCiphertext:
         case SSKProtoEnvelopeTypePrekeyBundle:
         case SSKProtoEnvelopeTypeUnidentifiedSender:
+        case SSKProtoEnvelopeTypeSenderkeyMessage:
+        case SSKProtoEnvelopeTypePlaintextContent:
             if (!plaintextData) {
                 OWSFailDebug(@"missing decrypted data for envelope: %@", [self descriptionForEnvelope:envelope]);
                 return;
@@ -466,6 +468,10 @@ - (void)throws_handleEnvelope:(SSKProtoEnvelope *)envelope
             [self handleIncomingEnvelope:envelope
                       withReceiptMessage:contentProto.receiptMessage
                              transaction:transaction];
+        } else if (contentProto.decryptionErrorMessage) {
+            [self handleIncomingEnvelope:envelope
+                withDecryptionErrorMessage:contentProto.decryptionErrorMessage
+                               transaction:transaction];
         } else if (!contentProto.hasSenderKeyDistributionMessage) {
             // An SKDM can be sent in isolation. Only warn if we don't have any
             // of the above messages *and* no sender key
@@ -1995,12 +2001,10 @@ - (TSIncomingMessage *_Nullable)handleReceivedEnvelope:(SSKProtoEnvelope *)envel
         return nil;
     }
 
-    [message anyInsertWithTransaction:transaction];
-
-    OWSAssertDebug(message.sortId == 0);
-    [message fillInMissingSortIdForJustInsertedInteractionWithTransaction:transaction];
-    OWSAssertDebug(message.sortId > 0);
-
+    // Check for any placeholders inserted because of a previously undecryptable message
+    // The sender may have resent the message. If so, we should swap it in place of the placeholder
+    // Sender Key TODO: Insert sortId?
+    [message insertOrReplacePlaceholderFrom:authorAddress transaction:transaction];
     [self.earlyMessageManager applyPendingMessagesFor:message transaction:transaction];
 
     // Any messages sent from the current user - from this device or another - should be automatically marked as read.
diff --git a/SignalServiceKit/src/Messages/OWSMessageManager.swift b/SignalServiceKit/src/Messages/OWSMessageManager.swift
index 86dfd44f938..d48e4750a64 100644
--- a/SignalServiceKit/src/Messages/OWSMessageManager.swift
+++ b/SignalServiceKit/src/Messages/OWSMessageManager.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import SignalClient
@@ -28,4 +28,43 @@ extension OWSMessageManager {
             owsFailDebug("Failed to process incoming sender key \(error)")
         }
     }
+
+    @objc
+    func handleIncomingEnvelope(
+        _ envelope: SSKProtoEnvelope,
+        withDecryptionErrorMessage bytes: Data,
+        transaction writeTx: SDSAnyWriteTransaction
+    ) {
+        guard let sourceAddress = envelope.sourceAddress, sourceAddress.isValid,
+              let sourceUuid = envelope.sourceUuid else {
+            return owsFailDebug("Invalid source address")
+        }
+        let sourceDeviceId = envelope.sourceDevice
+
+        do {
+            let errorMessage = try DecryptionErrorMessage(bytes: bytes)
+            guard errorMessage.deviceId == tsAccountManager.storedDeviceId() else {
+                // Not for this device. Let the other device handle this.
+                Logger.info("")
+                return
+            }
+            let protocolAddress = try ProtocolAddress(name: sourceUuid, deviceId: sourceDeviceId)
+
+            // If a ratchet key is included, this was a 1:1 session message
+            // Archive the session if the current key matches.
+            if let ratchetKey = errorMessage.ratchetKey {
+                let sessionRecord = try sessionStore.loadSession(for: protocolAddress, context: writeTx)
+                if try sessionRecord?.currentRatchetKeyMatches(ratchetKey) == true {
+                    sessionStore.archiveSession(for: sourceAddress,
+                                                deviceId: Int32(sourceDeviceId),
+                                                transaction: writeTx)
+                }
+            }
+
+            // Sender Key TODO: perform the resend
+            Logger.warn("Attempt to retry message \(errorMessage)")
+        } catch {
+            owsFailDebug("Failed to process decryption error message \(error)")
+        }
+    }
 }
diff --git a/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.h b/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.h
new file mode 100644
index 00000000000..1eb0cd88e82
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.h
@@ -0,0 +1,57 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+#import <TSOutgoingMessage.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class SSKProtoEnvelope;
+
+@interface OWSOutgoingResendRequest : TSOutgoingMessage
+
+- (instancetype)initWithFailedEnvelope:(SSKProtoEnvelope *)envelope
+                            cipherType:(uint32_t)cipherType
+                           transaction:(SDSAnyWriteTransaction *)transaction;
+
+@property (strong, nonatomic, readonly) NSData *originalMessageBytes;
+@property (assign, nonatomic, readonly) uint32_t cipherType;
+@property (assign, nonatomic, readonly) uint64_t originalMessageTimestamp;
+@property (assign, nonatomic, readonly) uint32_t senderDeviceId;
+
+- (instancetype)initOutgoingMessageWithBuilder:(TSOutgoingMessageBuilder *)outgoingMessageBuilder NS_UNAVAILABLE;
+- (instancetype)initWithGrdbId:(int64_t)grdbId
+                      uniqueId:(NSString *)uniqueId
+           receivedAtTimestamp:(uint64_t)receivedAtTimestamp
+                        sortId:(uint64_t)sortId
+                     timestamp:(uint64_t)timestamp
+                uniqueThreadId:(NSString *)uniqueThreadId
+                 attachmentIds:(NSArray<NSString *> *)attachmentIds
+                          body:(nullable NSString *)body
+                    bodyRanges:(nullable MessageBodyRanges *)bodyRanges
+                  contactShare:(nullable OWSContact *)contactShare
+               expireStartedAt:(uint64_t)expireStartedAt
+                     expiresAt:(uint64_t)expiresAt
+              expiresInSeconds:(unsigned int)expiresInSeconds
+            isViewOnceComplete:(BOOL)isViewOnceComplete
+             isViewOnceMessage:(BOOL)isViewOnceMessage
+                   linkPreview:(nullable OWSLinkPreview *)linkPreview
+                messageSticker:(nullable MessageSticker *)messageSticker
+                 quotedMessage:(nullable TSQuotedMessage *)quotedMessage
+  storedShouldStartExpireTimer:(BOOL)storedShouldStartExpireTimer
+            wasRemotelyDeleted:(BOOL)wasRemotelyDeleted
+                 customMessage:(nullable NSString *)customMessage
+              groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
+         hasLegacyMessageState:(BOOL)hasLegacyMessageState
+           hasSyncedTranscript:(BOOL)hasSyncedTranscript
+            isFromLinkedDevice:(BOOL)isFromLinkedDevice
+                isVoiceMessage:(BOOL)isVoiceMessage
+            legacyMessageState:(TSOutgoingMessageState)legacyMessageState
+            legacyWasDelivered:(BOOL)legacyWasDelivered
+         mostRecentFailureText:(nullable NSString *)mostRecentFailureText
+        recipientAddressStates:(nullable NSDictionary<SignalServiceAddress *,TSOutgoingMessageRecipientState *> *)recipientAddressStates
+            storedMessageState:(TSOutgoingMessageState)storedMessageState NS_UNAVAILABLE;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.m b/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.m
new file mode 100644
index 00000000000..0808daf5255
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.m
@@ -0,0 +1,71 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+#import "OWSOutgoingResendRequest.h"
+#import <SignalServiceKit/SignalServiceKit-Swift.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@implementation OWSOutgoingResendRequest
+
+- (instancetype)initWithFailedEnvelope:(SSKProtoEnvelope *)envelope
+                            cipherType:(uint32_t)cipherType
+                           transaction:(SDSAnyWriteTransaction *)transaction
+{
+    OWSAssertDebug(envelope);
+    OWSAssertDebug(transaction);
+
+    SignalServiceAddress *sender = [[SignalServiceAddress alloc] initWithUuidString:envelope.sourceUuid];
+    if (!sender.isValid) {
+        OWSFailDebug(@"Invalid UUID");
+        return nil;
+    }
+    TSContactThread *thread = [TSContactThread getOrCreateThreadWithContactAddress:sender transaction:transaction];
+    TSOutgoingMessageBuilder *builder = [TSOutgoingMessageBuilder outgoingMessageBuilderWithThread:thread];
+
+    self = [super initOutgoingMessageWithBuilder:builder];
+    if (self) {
+        _originalMessageBytes = envelope.content;
+        _cipherType = cipherType;
+        _originalMessageTimestamp = envelope.timestamp;
+        _senderDeviceId = envelope.sourceDevice;
+    }
+    return self;
+}
+
+- (nullable NSData *)buildPlainTextData:(nullable SignalServiceAddress *)address
+                                 thread:(TSThread *)thread
+                            transaction:(SDSAnyReadTransaction *)transaction
+{
+    NSData *decryptionErrorData = [self buildDecryptionError];
+    if (!decryptionErrorData) {
+        OWSFailDebug(@"");
+        return nil;
+    }
+
+    SSKProtoContentBuilder *builder = [SSKProtoContent builder];
+    builder.decryptionErrorMessage = decryptionErrorData;
+
+    NSError *error;
+    NSData *_Nullable data = [builder buildSerializedDataAndReturnError:&error];
+    if (error || !data) {
+        OWSFailDebug(@"could not serialize protobuf: %@", error);
+        return nil;
+    }
+    return data;
+}
+
+- (BOOL)shouldSyncTranscript
+{
+    return NO;
+}
+
+- (BOOL)shouldBeSaved
+{
+    return NO;
+}
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.swift b/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.swift
new file mode 100644
index 00000000000..fbcfd61e9e7
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSOutgoingResendRequest.swift
@@ -0,0 +1,29 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import SignalClient
+
+extension OWSOutgoingResendRequest {
+
+    @objc
+    func buildDecryptionError() -> Data? {
+        do {
+            let cipherType = CiphertextMessage.MessageType(rawValue: UInt8(self.cipherType))
+            guard [.whisper, .senderKey, .preKey, .plaintext].contains(cipherType) else {
+                owsFailDebug("Invalid message type")
+                return nil
+            }
+            let error = try DecryptionErrorMessage(
+                originalMessageBytes: originalMessageBytes,
+                type: cipherType,
+                timestamp: originalMessageTimestamp,
+                originalSenderDeviceId: senderDeviceId)
+            return Data(error.serialize())
+
+        } catch {
+            owsFailDebug("Failed to construct message \(error)")
+            return nil
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder+Replace.swift b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder+Replace.swift
new file mode 100644
index 00000000000..07198e58043
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder+Replace.swift
@@ -0,0 +1,18 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+extension OWSRecoverableDecryptionPlaceholder {
+    @objc
+    func replaceWithInteraction(_ interaction: TSInteraction, writeTx: SDSAnyWriteTransaction) {
+        anyRemove(transaction: writeTx)
+
+        if let inheritedId = grdbId?.int64Value {
+            interaction.clearRowId()
+            interaction.updateRowId(inheritedId)
+        } else {
+            owsFailDebug("Missing rowId")
+        }
+        anyInsert(transaction: writeTx)
+    }
+}
diff --git a/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder+SDS.swift b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder+SDS.swift
new file mode 100644
index 00000000000..8c8c6624662
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder+SDS.swift
@@ -0,0 +1,131 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDB
+import SignalCoreKit
+
+// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
+// Do not manually edit it, instead run `sds_codegen.sh`.
+
+// MARK: - Typed Convenience Methods
+
+@objc
+public extension OWSRecoverableDecryptionPlaceholder {
+    // NOTE: This method will fail if the object has unexpected type.
+    class func anyFetchRecoverableDecryptionPlaceholder(uniqueId: String,
+                                   transaction: SDSAnyReadTransaction) -> OWSRecoverableDecryptionPlaceholder? {
+        assert(uniqueId.count > 0)
+
+        guard let object = anyFetch(uniqueId: uniqueId,
+                                    transaction: transaction) else {
+                                        return nil
+        }
+        guard let instance = object as? OWSRecoverableDecryptionPlaceholder else {
+            owsFailDebug("Object has unexpected type: \(type(of: object))")
+            return nil
+        }
+        return instance
+    }
+
+    // NOTE: This method will fail if the object has unexpected type.
+    func anyUpdateRecoverableDecryptionPlaceholder(transaction: SDSAnyWriteTransaction, block: (OWSRecoverableDecryptionPlaceholder) -> Void) {
+        anyUpdate(transaction: transaction) { (object) in
+            guard let instance = object as? OWSRecoverableDecryptionPlaceholder else {
+                owsFailDebug("Object has unexpected type: \(type(of: object))")
+                return
+            }
+            block(instance)
+        }
+    }
+}
+
+// MARK: - SDSSerializer
+
+// The SDSSerializer protocol specifies how to insert and update the
+// row that corresponds to this model.
+class OWSRecoverableDecryptionPlaceholderSerializer: SDSSerializer {
+
+    private let model: OWSRecoverableDecryptionPlaceholder
+    public required init(model: OWSRecoverableDecryptionPlaceholder) {
+        self.model = model
+    }
+
+    // MARK: - Record
+
+    func asRecord() throws -> SDSRecord {
+        let id: Int64? = model.sortId > 0 ? Int64(model.sortId) : model.grdbId?.int64Value
+
+        let recordType: SDSRecordType = .recoverableDecryptionPlaceholder
+        let uniqueId: String = model.uniqueId
+
+        // Properties
+        let receivedAtTimestamp: UInt64 = model.receivedAtTimestamp
+        let timestamp: UInt64 = model.timestamp
+        let threadUniqueId: String = model.uniqueThreadId
+        let attachmentIds: Data? = optionalArchive(model.attachmentIds)
+        let authorId: String? = nil
+        let authorPhoneNumber: String? = nil
+        let authorUUID: String? = nil
+        let body: String? = model.body
+        let callType: RPRecentCallType? = nil
+        let configurationDurationSeconds: UInt32? = nil
+        let configurationIsEnabled: Bool? = nil
+        let contactShare: Data? = optionalArchive(model.contactShare)
+        let createdByRemoteName: String? = nil
+        let createdInExistingGroup: Bool? = nil
+        let customMessage: String? = nil
+        let envelopeData: Data? = nil
+        let errorType: TSErrorMessageType? = model.errorType
+        let expireStartedAt: UInt64? = model.expireStartedAt
+        let expiresAt: UInt64? = model.expiresAt
+        let expiresInSeconds: UInt32? = model.expiresInSeconds
+        let groupMetaMessage: TSGroupMetaMessage? = nil
+        let hasLegacyMessageState: Bool? = nil
+        let hasSyncedTranscript: Bool? = nil
+        let isFromLinkedDevice: Bool? = nil
+        let isLocalChange: Bool? = nil
+        let isViewOnceComplete: Bool? = model.isViewOnceComplete
+        let isViewOnceMessage: Bool? = model.isViewOnceMessage
+        let isVoiceMessage: Bool? = nil
+        let legacyMessageState: TSOutgoingMessageState? = nil
+        let legacyWasDelivered: Bool? = nil
+        let linkPreview: Data? = optionalArchive(model.linkPreview)
+        let messageId: String? = nil
+        let messageSticker: Data? = optionalArchive(model.messageSticker)
+        let messageType: TSInfoMessageType? = nil
+        let mostRecentFailureText: String? = nil
+        let preKeyBundle: Data? = nil
+        let protocolVersion: UInt? = nil
+        let quotedMessage: Data? = optionalArchive(model.quotedMessage)
+        let read: Bool? = model.wasRead
+        let recipientAddress: Data? = optionalArchive(model.recipientAddress)
+        let recipientAddressStates: Data? = nil
+        let sender: Data? = optionalArchive(model.sender)
+        let serverTimestamp: UInt64? = nil
+        let sourceDeviceId: UInt32? = nil
+        let storedMessageState: TSOutgoingMessageState? = nil
+        let storedShouldStartExpireTimer: Bool? = model.storedShouldStartExpireTimer
+        let unregisteredAddress: Data? = nil
+        let verificationState: OWSVerificationState? = nil
+        let wasReceivedByUD: Bool? = nil
+        let infoMessageUserInfo: Data? = nil
+        let wasRemotelyDeleted: Bool? = model.wasRemotelyDeleted
+        let bodyRanges: Data? = optionalArchive(model.bodyRanges)
+        let offerType: TSRecentCallOfferType? = nil
+        let serverDeliveryTimestamp: UInt64? = nil
+        let eraId: String? = nil
+        let hasEnded: Bool? = nil
+        let creatorUuid: String? = nil
+        let joinedMemberUuids: Data? = nil
+        let wasIdentityVerified: Bool? = model.wasIdentityVerified
+        let paymentCancellation: Data? = nil
+        let paymentNotification: Data? = nil
+        let paymentRequest: Data? = nil
+        let viewed: Bool? = nil
+        let serverGuid: String? = nil
+
+        return InteractionRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, receivedAtTimestamp: receivedAtTimestamp, timestamp: timestamp, threadUniqueId: threadUniqueId, attachmentIds: attachmentIds, authorId: authorId, authorPhoneNumber: authorPhoneNumber, authorUUID: authorUUID, body: body, callType: callType, configurationDurationSeconds: configurationDurationSeconds, configurationIsEnabled: configurationIsEnabled, contactShare: contactShare, createdByRemoteName: createdByRemoteName, createdInExistingGroup: createdInExistingGroup, customMessage: customMessage, envelopeData: envelopeData, errorType: errorType, expireStartedAt: expireStartedAt, expiresAt: expiresAt, expiresInSeconds: expiresInSeconds, groupMetaMessage: groupMetaMessage, hasLegacyMessageState: hasLegacyMessageState, hasSyncedTranscript: hasSyncedTranscript, isFromLinkedDevice: isFromLinkedDevice, isLocalChange: isLocalChange, isViewOnceComplete: isViewOnceComplete, isViewOnceMessage: isViewOnceMessage, isVoiceMessage: isVoiceMessage, legacyMessageState: legacyMessageState, legacyWasDelivered: legacyWasDelivered, linkPreview: linkPreview, messageId: messageId, messageSticker: messageSticker, messageType: messageType, mostRecentFailureText: mostRecentFailureText, preKeyBundle: preKeyBundle, protocolVersion: protocolVersion, quotedMessage: quotedMessage, read: read, recipientAddress: recipientAddress, recipientAddressStates: recipientAddressStates, sender: sender, serverTimestamp: serverTimestamp, sourceDeviceId: sourceDeviceId, storedMessageState: storedMessageState, storedShouldStartExpireTimer: storedShouldStartExpireTimer, unregisteredAddress: unregisteredAddress, verificationState: verificationState, wasReceivedByUD: wasReceivedByUD, infoMessageUserInfo: infoMessageUserInfo, wasRemotelyDeleted: wasRemotelyDeleted, bodyRanges: bodyRanges, offerType: offerType, serverDeliveryTimestamp: serverDeliveryTimestamp, eraId: eraId, hasEnded: hasEnded, creatorUuid: creatorUuid, joinedMemberUuids: joinedMemberUuids, wasIdentityVerified: wasIdentityVerified, paymentCancellation: paymentCancellation, paymentNotification: paymentNotification, paymentRequest: paymentRequest, viewed: viewed, serverGuid: serverGuid)
+    }
+}
diff --git a/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder.h b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder.h
new file mode 100644
index 00000000000..c2ce8139d03
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder.h
@@ -0,0 +1,32 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+#import <TSErrorMessage.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface OWSRecoverableDecryptionPlaceholder : TSErrorMessage <OWSReadTracking>
+
+- (instancetype)initErrorMessageWithBuilder:(TSErrorMessageBuilder *)errorMessageBuilder NS_UNAVAILABLE;
+- (nullable instancetype)initWithFailedEnvelope:(SSKProtoEnvelope *)envelope
+                                        groupId:(nullable NSData *)groupId
+                                    transaction:(SDSAnyWriteTransaction *)writeTx NS_DESIGNATED_INITIALIZER;
+- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;
+
+@property (assign, nonatomic, readonly) BOOL isVisible;
+@property (assign, nonatomic, readonly) BOOL supportsReplacement;
+
+// --- CODE GENERATION MARKER
+
+// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run
+// `sds_codegen.sh`.
+
+// clang-format off
+// clang-format on
+
+// --- CODE GENERATION MARKER
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder.m b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder.m
new file mode 100644
index 00000000000..81f8d02eec6
--- /dev/null
+++ b/SignalServiceKit/src/Messages/OWSRecoverableDecryptionPlaceholder.m
@@ -0,0 +1,86 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+#import "OWSRecoverableDecryptionPlaceholder.h"
+#import "TSThread.h"
+#import <SignalServiceKit/SignalServiceKit-Swift.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@implementation OWSRecoverableDecryptionPlaceholder
+
+- (nullable instancetype)initWithFailedEnvelope:(SSKProtoEnvelope *)envelope
+                                        groupId:(nullable NSData *)groupId
+                                    transaction:(SDSAnyWriteTransaction *)writeTx
+{
+    SignalServiceAddress *sender = [[SignalServiceAddress alloc] initWithUuidString:envelope.sourceUuid];
+    if (!sender) {
+        OWSFailDebug(@"Invalid UUID");
+        return nil;
+    }
+
+    TSThread *thread;
+    if (groupId.length > 0) {
+        thread = [TSGroupThread fetchWithGroupId:groupId transaction:writeTx];
+        OWSAssertDebug(thread);
+    }
+    if (!thread) {
+        thread = [TSContactThread getThreadWithContactAddress:sender transaction:writeTx];
+        OWSAssertDebug(thread);
+    }
+    if (!thread) {
+        return nil;
+    }
+    TSErrorMessageBuilder *builder = [TSErrorMessageBuilder errorMessageBuilderWithThread:thread errorType:TSErrorMessageDecryptionFailure];
+    builder.timestamp = envelope.timestamp;
+    builder.senderAddress = sender;
+
+    return [super initErrorMessageWithBuilder:builder];
+}
+
+- (nullable instancetype)initWithCoder:(NSCoder *)coder
+{
+    return [super initWithCoder:coder];
+}
+
+// --- CODE GENERATION MARKER
+
+// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run
+// `sds_codegen.sh`.
+
+// clang-format off
+// clang-format on
+
+// --- CODE GENERATION MARKER
+
+#pragma mark - Methods
+
+- (BOOL)isVisible
+{
+    // Check if 60mins have elapsed
+    NSDate *expiration = [self.receivedAtDate dateByAddingTimeInterval:kHourInterval];
+    return [expiration isBeforeNow] || self.wasRead;
+}
+
+- (BOOL)supportsReplacement
+{
+    return !self.isVisible;
+}
+
+- (NSString *)previewTextWithTransaction:(SDSAnyReadTransaction *)transaction
+{
+    if (self.isVisible) {
+        NSString *formatString = NSLocalizedString(
+            @"ERROR_MESSAGE_DECRYPTION_FAILURE", @"Error message for a decryption failure. Embeds {{senders name}}.");
+
+        NSString *senderName = [self.contactsManager shortDisplayNameForAddress:self.sender transaction:transaction];
+        return [[NSString alloc] initWithFormat:formatString, senderName];
+    } else {
+        return @""; // Sender Key TODO: Should conversation list walk backwards to find the last interaction with a preview?
+    }
+}
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/OWSUnknownContactBlockOfferMessage+SDS.swift b/SignalServiceKit/src/Messages/OWSUnknownContactBlockOfferMessage+SDS.swift
index b62c8de44bf..cc7c7b503c0 100644
--- a/SignalServiceKit/src/Messages/OWSUnknownContactBlockOfferMessage+SDS.swift
+++ b/SignalServiceKit/src/Messages/OWSUnknownContactBlockOfferMessage+SDS.swift
@@ -102,7 +102,7 @@ class OWSUnknownContactBlockOfferMessageSerializer: SDSSerializer {
         let read: Bool? = model.wasRead
         let recipientAddress: Data? = optionalArchive(model.recipientAddress)
         let recipientAddressStates: Data? = nil
-        let sender: Data? = nil
+        let sender: Data? = optionalArchive(model.sender)
         let serverTimestamp: UInt64? = nil
         let sourceDeviceId: UInt32? = nil
         let storedMessageState: TSOutgoingMessageState? = nil
diff --git a/SignalServiceKit/src/Protos/Generated/SSKProto.swift b/SignalServiceKit/src/Protos/Generated/SSKProto.swift
index d264b7e0f1e..27491e93ea5 100644
--- a/SignalServiceKit/src/Protos/Generated/SSKProto.swift
+++ b/SignalServiceKit/src/Protos/Generated/SSKProto.swift
@@ -23,6 +23,7 @@ public enum SSKProtoEnvelopeType: Int32 {
     case receipt = 5
     case unidentifiedSender = 6
     case senderkeyMessage = 7
+    case plaintextContent = 8
 }
 
 private func SSKProtoEnvelopeTypeWrap(_ value: SignalServiceProtos_Envelope.TypeEnum) -> SSKProtoEnvelopeType {
@@ -34,6 +35,7 @@ private func SSKProtoEnvelopeTypeWrap(_ value: SignalServiceProtos_Envelope.Type
     case .receipt: return .receipt
     case .unidentifiedSender: return .unidentifiedSender
     case .senderkeyMessage: return .senderkeyMessage
+    case .plaintextContent: return .plaintextContent
     }
 }
 
@@ -46,6 +48,7 @@ private func SSKProtoEnvelopeTypeUnwrap(_ value: SSKProtoEnvelopeType) -> Signal
     case .receipt: return .receipt
     case .unidentifiedSender: return .unidentifiedSender
     case .senderkeyMessage: return .senderkeyMessage
+    case .plaintextContent: return .plaintextContent
     }
 }
 
@@ -702,6 +705,9 @@ public class SSKProtoContent: NSObject, Codable {
         if let _value = senderKeyDistributionMessage {
             builder.setSenderKeyDistributionMessage(_value)
         }
+        if let _value = decryptionErrorMessage {
+            builder.setDecryptionErrorMessage(_value)
+        }
         if let _value = unknownFields {
             builder.setUnknownFields(_value)
         }
@@ -793,6 +799,17 @@ public class SSKProtoContent: NSObject, Codable {
             proto.senderKeyDistributionMessage = valueParam
         }
 
+        @objc
+        @available(swift, obsoleted: 1.0)
+        public func setDecryptionErrorMessage(_ valueParam: Data?) {
+            guard let valueParam = valueParam else { return }
+            proto.decryptionErrorMessage = valueParam
+        }
+
+        public func setDecryptionErrorMessage(_ valueParam: Data) {
+            proto.decryptionErrorMessage = valueParam
+        }
+
         public func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
             proto.unknownFields = unknownFields
         }
@@ -840,6 +857,18 @@ public class SSKProtoContent: NSObject, Codable {
         return proto.hasSenderKeyDistributionMessage
     }
 
+    @objc
+    public var decryptionErrorMessage: Data? {
+        guard hasDecryptionErrorMessage else {
+            return nil
+        }
+        return proto.decryptionErrorMessage
+    }
+    @objc
+    public var hasDecryptionErrorMessage: Bool {
+        return proto.hasDecryptionErrorMessage
+    }
+
     public var hasUnknownFields: Bool {
         return !proto.unknownFields.data.isEmpty
     }
@@ -14957,3 +14986,175 @@ extension SSKProtoPaymentAddress.SSKProtoPaymentAddressBuilder {
 }
 
 #endif
+
+// MARK: - SSKProtoDecryptionErrorMessage
+
+@objc
+public class SSKProtoDecryptionErrorMessage: NSObject, Codable {
+
+    // MARK: - SSKProtoDecryptionErrorMessageBuilder
+
+    @objc
+    public static func builder() -> SSKProtoDecryptionErrorMessageBuilder {
+        return SSKProtoDecryptionErrorMessageBuilder()
+    }
+
+    // asBuilder() constructs a builder that reflects the proto's contents.
+    @objc
+    public func asBuilder() -> SSKProtoDecryptionErrorMessageBuilder {
+        let builder = SSKProtoDecryptionErrorMessageBuilder()
+        if let _value = ratchetKey {
+            builder.setRatchetKey(_value)
+        }
+        if hasTimestamp {
+            builder.setTimestamp(timestamp)
+        }
+        if hasDeviceID {
+            builder.setDeviceID(deviceID)
+        }
+        if let _value = unknownFields {
+            builder.setUnknownFields(_value)
+        }
+        return builder
+    }
+
+    @objc
+    public class SSKProtoDecryptionErrorMessageBuilder: NSObject {
+
+        private var proto = SignalServiceProtos_DecryptionErrorMessage()
+
+        @objc
+        fileprivate override init() {}
+
+        @objc
+        @available(swift, obsoleted: 1.0)
+        public func setRatchetKey(_ valueParam: Data?) {
+            guard let valueParam = valueParam else { return }
+            proto.ratchetKey = valueParam
+        }
+
+        public func setRatchetKey(_ valueParam: Data) {
+            proto.ratchetKey = valueParam
+        }
+
+        @objc
+        public func setTimestamp(_ valueParam: UInt64) {
+            proto.timestamp = valueParam
+        }
+
+        @objc
+        public func setDeviceID(_ valueParam: UInt32) {
+            proto.deviceID = valueParam
+        }
+
+        public func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
+            proto.unknownFields = unknownFields
+        }
+
+        @objc
+        public func build() throws -> SSKProtoDecryptionErrorMessage {
+            return try SSKProtoDecryptionErrorMessage(proto)
+        }
+
+        @objc
+        public func buildSerializedData() throws -> Data {
+            return try SSKProtoDecryptionErrorMessage(proto).serializedData()
+        }
+    }
+
+    fileprivate let proto: SignalServiceProtos_DecryptionErrorMessage
+
+    @objc
+    public var ratchetKey: Data? {
+        guard hasRatchetKey else {
+            return nil
+        }
+        return proto.ratchetKey
+    }
+    @objc
+    public var hasRatchetKey: Bool {
+        return proto.hasRatchetKey
+    }
+
+    @objc
+    public var timestamp: UInt64 {
+        return proto.timestamp
+    }
+    @objc
+    public var hasTimestamp: Bool {
+        return proto.hasTimestamp
+    }
+
+    @objc
+    public var deviceID: UInt32 {
+        return proto.deviceID
+    }
+    @objc
+    public var hasDeviceID: Bool {
+        return proto.hasDeviceID
+    }
+
+    public var hasUnknownFields: Bool {
+        return !proto.unknownFields.data.isEmpty
+    }
+    public var unknownFields: SwiftProtobuf.UnknownStorage? {
+        guard hasUnknownFields else { return nil }
+        return proto.unknownFields
+    }
+
+    private init(proto: SignalServiceProtos_DecryptionErrorMessage) {
+        self.proto = proto
+    }
+
+    @objc
+    public func serializedData() throws -> Data {
+        return try self.proto.serializedData()
+    }
+
+    @objc
+    public convenience init(serializedData: Data) throws {
+        let proto = try SignalServiceProtos_DecryptionErrorMessage(serializedData: serializedData)
+        try self.init(proto)
+    }
+
+    fileprivate convenience init(_ proto: SignalServiceProtos_DecryptionErrorMessage) throws {
+        // MARK: - Begin Validation Logic for SSKProtoDecryptionErrorMessage -
+
+        // MARK: - End Validation Logic for SSKProtoDecryptionErrorMessage -
+
+        self.init(proto: proto)
+    }
+
+    public required convenience init(from decoder: Swift.Decoder) throws {
+        let singleValueContainer = try decoder.singleValueContainer()
+        let serializedData = try singleValueContainer.decode(Data.self)
+        try self.init(serializedData: serializedData)
+    }
+    public func encode(to encoder: Swift.Encoder) throws {
+        var singleValueContainer = encoder.singleValueContainer()
+        try singleValueContainer.encode(try serializedData())
+    }
+
+    @objc
+    public override var debugDescription: String {
+        return "\(proto)"
+    }
+}
+
+#if DEBUG
+
+extension SSKProtoDecryptionErrorMessage {
+    @objc
+    public func serializedDataIgnoringErrors() -> Data? {
+        return try! self.serializedData()
+    }
+}
+
+extension SSKProtoDecryptionErrorMessage.SSKProtoDecryptionErrorMessageBuilder {
+    @objc
+    public func buildIgnoringErrors() -> SSKProtoDecryptionErrorMessage? {
+        return try! self.build()
+    }
+}
+
+#endif
diff --git a/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift b/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
index f77c29bfb51..a627699fa26 100644
--- a/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
+++ b/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
@@ -135,6 +135,7 @@ struct SignalServiceProtos_Envelope {
     case receipt // = 5
     case unidentifiedSender // = 6
     case senderkeyMessage // = 7
+    case plaintextContent // = 8
 
     init() {
       self = .unknown
@@ -149,6 +150,7 @@ struct SignalServiceProtos_Envelope {
       case 5: self = .receipt
       case 6: self = .unidentifiedSender
       case 7: self = .senderkeyMessage
+      case 8: self = .plaintextContent
       default: return nil
       }
     }
@@ -162,6 +164,7 @@ struct SignalServiceProtos_Envelope {
       case .receipt: return 5
       case .unidentifiedSender: return 6
       case .senderkeyMessage: return 7
+      case .plaintextContent: return 8
       }
     }
 
@@ -334,6 +337,16 @@ struct SignalServiceProtos_Content {
   /// Clears the value of `senderKeyDistributionMessage`. Subsequent reads from it will return its default value.
   mutating func clearSenderKeyDistributionMessage() {self._senderKeyDistributionMessage = nil}
 
+  /// Serialized decryption error
+  var decryptionErrorMessage: Data {
+    get {return _decryptionErrorMessage ?? Data()}
+    set {_decryptionErrorMessage = newValue}
+  }
+  /// Returns true if `decryptionErrorMessage` has been explicitly set.
+  var hasDecryptionErrorMessage: Bool {return self._decryptionErrorMessage != nil}
+  /// Clears the value of `decryptionErrorMessage`. Subsequent reads from it will return its default value.
+  mutating func clearDecryptionErrorMessage() {self._decryptionErrorMessage = nil}
+
   var unknownFields = SwiftProtobuf.UnknownStorage()
 
   init() {}
@@ -345,6 +358,7 @@ struct SignalServiceProtos_Content {
   fileprivate var _receiptMessage: SignalServiceProtos_ReceiptMessage?
   fileprivate var _typingMessage: SignalServiceProtos_TypingMessage?
   fileprivate var _senderKeyDistributionMessage: Data?
+  fileprivate var _decryptionErrorMessage: Data?
 }
 
 struct SignalServiceProtos_CallMessage {
@@ -4054,6 +4068,47 @@ struct SignalServiceProtos_PaymentAddress {
   fileprivate var _mobileCoin: SignalServiceProtos_PaymentAddress.MobileCoin?
 }
 
+struct SignalServiceProtos_DecryptionErrorMessage {
+  // SwiftProtobuf.Message conformance is added in an extension below. See the
+  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
+  // methods supported on all messages.
+
+  var ratchetKey: Data {
+    get {return _ratchetKey ?? Data()}
+    set {_ratchetKey = newValue}
+  }
+  /// Returns true if `ratchetKey` has been explicitly set.
+  var hasRatchetKey: Bool {return self._ratchetKey != nil}
+  /// Clears the value of `ratchetKey`. Subsequent reads from it will return its default value.
+  mutating func clearRatchetKey() {self._ratchetKey = nil}
+
+  var timestamp: UInt64 {
+    get {return _timestamp ?? 0}
+    set {_timestamp = newValue}
+  }
+  /// Returns true if `timestamp` has been explicitly set.
+  var hasTimestamp: Bool {return self._timestamp != nil}
+  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
+  mutating func clearTimestamp() {self._timestamp = nil}
+
+  var deviceID: UInt32 {
+    get {return _deviceID ?? 0}
+    set {_deviceID = newValue}
+  }
+  /// Returns true if `deviceID` has been explicitly set.
+  var hasDeviceID: Bool {return self._deviceID != nil}
+  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
+  mutating func clearDeviceID() {self._deviceID = nil}
+
+  var unknownFields = SwiftProtobuf.UnknownStorage()
+
+  init() {}
+
+  fileprivate var _ratchetKey: Data?
+  fileprivate var _timestamp: UInt64?
+  fileprivate var _deviceID: UInt32?
+}
+
 // MARK: - Code below here is support for the SwiftProtobuf runtime.
 
 private let _protobuf_package = "SignalServiceProtos"
@@ -4152,7 +4207,8 @@ extension SignalServiceProtos_Envelope.TypeEnum: SwiftProtobuf._ProtoNameProvidi
     3: .same(proto: "PREKEY_BUNDLE"),
     5: .same(proto: "RECEIPT"),
     6: .same(proto: "UNIDENTIFIED_SENDER"),
-    7: .same(proto: "SENDERKEY_MESSAGE")
+    7: .same(proto: "SENDERKEY_MESSAGE"),
+    8: .same(proto: "PLAINTEXT_CONTENT")
   ]
 }
 
@@ -4216,7 +4272,8 @@ extension SignalServiceProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._Mes
     4: .same(proto: "nullMessage"),
     5: .same(proto: "receiptMessage"),
     6: .same(proto: "typingMessage"),
-    7: .same(proto: "senderKeyDistributionMessage")
+    7: .same(proto: "senderKeyDistributionMessage"),
+    8: .same(proto: "decryptionErrorMessage")
   ]
 
   mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
@@ -4232,6 +4289,7 @@ extension SignalServiceProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._Mes
       case 5: try { try decoder.decodeSingularMessageField(value: &self._receiptMessage) }()
       case 6: try { try decoder.decodeSingularMessageField(value: &self._typingMessage) }()
       case 7: try { try decoder.decodeSingularBytesField(value: &self._senderKeyDistributionMessage) }()
+      case 8: try { try decoder.decodeSingularBytesField(value: &self._decryptionErrorMessage) }()
       default: break
       }
     }
@@ -4259,6 +4317,9 @@ extension SignalServiceProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._Mes
     if let v = self._senderKeyDistributionMessage {
       try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
     }
+    if let v = self._decryptionErrorMessage {
+      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -4270,6 +4331,7 @@ extension SignalServiceProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._Mes
     if lhs._receiptMessage != rhs._receiptMessage {return false}
     if lhs._typingMessage != rhs._typingMessage {return false}
     if lhs._senderKeyDistributionMessage != rhs._senderKeyDistributionMessage {return false}
+    if lhs._decryptionErrorMessage != rhs._decryptionErrorMessage {return false}
     if lhs.unknownFields != rhs.unknownFields {return false}
     return true
   }
@@ -7970,3 +8032,47 @@ extension SignalServiceProtos_PaymentAddress.MobileCoin: SwiftProtobuf.Message,
     return true
   }
 }
+
+extension SignalServiceProtos_DecryptionErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
+  static let protoMessageName: String = _protobuf_package + ".DecryptionErrorMessage"
+  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
+    1: .same(proto: "ratchetKey"),
+    2: .same(proto: "timestamp"),
+    3: .same(proto: "deviceId")
+  ]
+
+  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
+    while let fieldNumber = try decoder.nextFieldNumber() {
+      // The use of inline closures is to circumvent an issue where the compiler
+      // allocates stack space for every case branch when no optimizations are
+      // enabled. https://github.com/apple/swift-protobuf/issues/1034
+      switch fieldNumber {
+      case 1: try { try decoder.decodeSingularBytesField(value: &self._ratchetKey) }()
+      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
+      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._deviceID) }()
+      default: break
+      }
+    }
+  }
+
+  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
+    if let v = self._ratchetKey {
+      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
+    }
+    if let v = self._timestamp {
+      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
+    }
+    if let v = self._deviceID {
+      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
+    }
+    try unknownFields.traverse(visitor: &visitor)
+  }
+
+  static func ==(lhs: SignalServiceProtos_DecryptionErrorMessage, rhs: SignalServiceProtos_DecryptionErrorMessage) -> Bool {
+    if lhs._ratchetKey != rhs._ratchetKey {return false}
+    if lhs._timestamp != rhs._timestamp {return false}
+    if lhs._deviceID != rhs._deviceID {return false}
+    if lhs.unknownFields != rhs.unknownFields {return false}
+    return true
+  }
+}
diff --git a/SignalServiceKit/src/SignalServiceKit.h b/SignalServiceKit/src/SignalServiceKit.h
index 1c2f024beb1..5a188deaf10 100644
--- a/SignalServiceKit/src/SignalServiceKit.h
+++ b/SignalServiceKit/src/SignalServiceKit.h
@@ -41,6 +41,8 @@
 #import <SignalServiceKit/OWSReaction.h>
 #import <SignalServiceKit/OWSReceiptManager.h>
 #import <SignalServiceKit/OWSRecipientIdentity.h>
+#import <SignalServiceKit/OWSRecoverableDecryptionPlaceholder.h>
+#import <SignalServiceKit/OWSOutgoingResendRequest.h>
 #import <SignalServiceKit/OWSRequestFactory.h>
 #import <SignalServiceKit/OWSSessionResetJobRecord.h>
 #import <SignalServiceKit/OWSSignalService.h>
diff --git a/SignalServiceKit/src/Storage/AxolotlStore/SenderKeyStore.swift b/SignalServiceKit/src/Storage/AxolotlStore/SenderKeyStore.swift
index a10b8f28f13..305ee660e69 100644
--- a/SignalServiceKit/src/Storage/AxolotlStore/SenderKeyStore.swift
+++ b/SignalServiceKit/src/Storage/AxolotlStore/SenderKeyStore.swift
@@ -128,7 +128,8 @@ public class SenderKeyStore: NSObject {
         }
     }
 
-    public func resetSenderKeySession(for thread: TSGroupThread, writeTx: SDSAnyWriteTransaction) {
+    @objc
+    public func resetSenderKeySession(for thread: TSGroupThread, transaction writeTx: SDSAnyWriteTransaction) {
         storageLock.withLock {
             let distributionId = distributionIdForSendingToThreadId(thread.threadUniqueId, writeTx: writeTx)
             setMetadata(nil, for: distributionId, writeTx: writeTx)
diff --git a/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift b/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift
index 387b85d3354..9da4d2ef1b7 100644
--- a/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift
+++ b/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift
@@ -608,6 +608,7 @@ public class GRDBInteractionFinder: NSObject, InteractionFinderAdapter {
                     WHERE \(interactionColumn: .timestamp) = ?
                     AND \(interactionColumn: .authorUUID) = ?
                     AND \(interactionColumn: .sourceDeviceId) = ?
+                    AND \(interactionColumn: .recordType) IS NOT \(SDSRecordType.recoverableDecryptionPlaceholder.rawValue)
                 )
             """
             let arguments: StatementArguments = [timestamp, uuidString, sourceDeviceId]
@@ -622,6 +623,7 @@ public class GRDBInteractionFinder: NSObject, InteractionFinderAdapter {
                     WHERE \(interactionColumn: .timestamp) = ?
                     AND \(interactionColumn: .authorPhoneNumber) = ?
                     AND \(interactionColumn: .sourceDeviceId) = ?
+                    AND \(interactionColumn: .recordType) IS NOT \(SDSRecordType.recoverableDecryptionPlaceholder.rawValue)
                 )
             """
             let arguments: StatementArguments = [timestamp, phoneNumber, sourceDeviceId]
@@ -1219,7 +1221,8 @@ public class GRDBInteractionFinder: NSObject, InteractionFinderAdapter {
             .invalidMessage,
             .duplicateMessage,
             .groupCreationFailed,
-            .sessionRefresh
+            .sessionRefresh,
+            .decryptionFailure
         ]
 
         let interactionTypes: [SDSRecordType] = [
diff --git a/SignalServiceKit/src/Storage/Database/SDSRecordType.swift b/SignalServiceKit/src/Storage/Database/SDSRecordType.swift
index 14887770df0..27fb51cae64 100644
--- a/SignalServiceKit/src/Storage/Database/SDSRecordType.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSRecordType.swift
@@ -80,4 +80,6 @@ public enum SDSRecordType: UInt {
     case paymentModel = 67
     case outgoingPaymentMessage = 68
     case groupMember = 69
+    case recoverableDecryptionPlaceholder = 70
+    case outgoingResendRequest = 71
 }
diff --git a/SignalServiceKit/src/TSConstants.h b/SignalServiceKit/src/TSConstants.h
index 35f797ef4ab..41c9bb0ff5b 100644
--- a/SignalServiceKit/src/TSConstants.h
+++ b/SignalServiceKit/src/TSConstants.h
@@ -14,6 +14,7 @@ typedef NS_ENUM(NSInteger, TSWhisperMessageType) {
     TSPreKeyWhisperMessageType = 3,
     TSUnencryptedWhisperMessageType = 4,
     TSUnidentifiedSenderMessageType = 6,
+    TSPlaintextMessageType = 7,
 };
 
 #pragma mark Server Address
diff --git a/SignalServiceKit/src/groups/GroupManager.swift b/SignalServiceKit/src/groups/GroupManager.swift
index ef769098ae0..2a8a259ee78 100644
--- a/SignalServiceKit/src/groups/GroupManager.swift
+++ b/SignalServiceKit/src/groups/GroupManager.swift
@@ -2117,7 +2117,7 @@ public class GroupManager: NSObject {
             let newMembers = newGroupModelV2.membership.allMembersOfAnyKind
 
             if oldMembers.subtracting(newMembers).isEmpty == false {
-                senderKeyStore.resetSenderKeySession(for: groupThread, writeTx: transaction)
+                senderKeyStore.resetSenderKeySession(for: groupThread, transaction: transaction)
             }
         }
 
