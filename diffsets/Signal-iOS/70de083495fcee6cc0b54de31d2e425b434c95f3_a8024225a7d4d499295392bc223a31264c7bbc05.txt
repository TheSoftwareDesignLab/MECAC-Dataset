diff --git a/Signal/Images.xcassets/reply-outline-24.imageset/Contents.json b/Signal/Images.xcassets/reply-outline-24.imageset/Contents.json
new file mode 100644
index 00000000000..43664d990c4
--- /dev/null
+++ b/Signal/Images.xcassets/reply-outline-24.imageset/Contents.json
@@ -0,0 +1,23 @@
+{
+  "images" : [
+    {
+      "idiom" : "universal",
+      "filename" : "reply-outline-24@1x.png",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "filename" : "reply-outline-24@2x.png",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "filename" : "reply-outline-24@3x.png",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "version" : 1,
+    "author" : "xcode"
+  }
+}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@1x.png b/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@1x.png
new file mode 100644
index 00000000000..326dd566d86
Binary files /dev/null and b/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@1x.png differ
diff --git a/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@2x.png b/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@2x.png
new file mode 100644
index 00000000000..7ea3e634c77
Binary files /dev/null and b/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@2x.png differ
diff --git a/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@3x.png b/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@3x.png
new file mode 100644
index 00000000000..596d6c79b04
Binary files /dev/null and b/Signal/Images.xcassets/reply-outline-24.imageset/reply-outline-24@3x.png differ
diff --git a/Signal/src/ViewControllers/ConversationView/Cells/OWSMessageCell.m b/Signal/src/ViewControllers/ConversationView/Cells/OWSMessageCell.m
index 4a4a72d7376..653d8af768f 100644
--- a/Signal/src/ViewControllers/ConversationView/Cells/OWSMessageCell.m
+++ b/Signal/src/ViewControllers/ConversationView/Cells/OWSMessageCell.m
@@ -30,8 +30,9 @@ @interface OWSMessageCell () <UIGestureRecognizerDelegate>
 @property (nonatomic) UIPanGestureRecognizer *panGestureRecognizer;
 @property (nonatomic) UIView *swipeableContentView;
 @property (nonatomic) UIImageView *swipeToReplyImageView;
-@property (nonatomic) NSArray<NSLayoutConstraint *> *swipeToReplyConstraints;
-@property (nonatomic, readonly) CGFloat swipeToReplyPosition;
+@property (nonatomic) CGFloat swipeableContentViewInitialX;
+@property (nonatomic) CGFloat messageViewInitialX;
+@property (nonatomic) BOOL isReplyActive;
 
 @property (nonatomic) BOOL isPresentingMenuController;
 
@@ -170,7 +171,7 @@ - (void)loadForDisplay
     messageView.cellMediaCache = self.delegate.cellMediaCache;
     [messageView configureViews];
     [messageView loadContent];
-    [self.swipeableContentView addSubview:messageView];
+    [self.contentView addSubview:messageView];
     [messageView autoPinBottomToSuperviewMarginWithInset:0];
 
     if (self.viewItem.hasCellHeader) {
@@ -205,7 +206,7 @@ - (void)loadForDisplay
             self.sendFailureBadgeView.image =
                 [self.sendFailureBadge imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
             self.sendFailureBadgeView.tintColor = [UIColor ows_destructiveRedColor];
-            [self.swipeableContentView addSubview:self.sendFailureBadgeView];
+            [self.contentView addSubview:self.sendFailureBadgeView];
 
             CGFloat sendFailureBadgeBottomMargin
                 = round(self.conversationStyle.lastTextLineAxis - self.sendFailureBadgeSize * 0.5f);
@@ -244,12 +245,14 @@ - (void)loadForDisplay
             // would be).
             [messageView autoPinLeadingToTrailingEdgeOfView:self.avatarView offset:8],
             [messageView autoPinEdge:ALEdgeBottom toEdge:ALEdgeBottom ofView:self.avatarView],
-            [self.swipeToReplyImageView autoAlignAxis:ALAxisHorizontal toSameAxisOfView:self.avatarView],
         ]];
-    } else {
-        [self.viewConstraints addObject:[self.swipeToReplyImageView autoAlignAxis:ALAxisHorizontal
-                                                                 toSameAxisOfView:messageView]];
     }
+
+    // Swipe-to-reply
+    [self.viewConstraints addObjectsFromArray:@[
+        [self.swipeToReplyImageView autoPinEdge:ALEdgeLeading toEdge:ALEdgeLeading ofView:messageView withOffset:8],
+        [self.swipeToReplyImageView autoAlignAxis:ALAxisHorizontal toSameAxisOfView:messageView],
+    ]];
 }
 
 - (UIImage *)sendFailureBadge
@@ -414,6 +417,7 @@ - (void)prepareForReuse
     [[NSNotificationCenter defaultCenter] removeObserver:self];
 
     [self resetSwipePositionAnimated:NO];
+    self.swipeToReplyImageView.alpha = 0;
 }
 
 #pragma mark - Notifications
@@ -557,37 +561,63 @@ - (BOOL)shouldAllowReply
     return YES;
 }
 
-- (CGFloat)maxSwipeDistance
+- (CGFloat)swipeToReplyThreshold
+{
+    return 55.f;
+}
+
+- (BOOL)useSwipeFadeTransition
 {
-    return ScaleFromIPhone5(74.f);
+    // Right now, only stickers need the reply button to fade in.
+    // If we add other message types that don't have bubbles,
+    // we should add them here.
+    return self.cellType == OWSMessageCellType_StickerMessage;
 }
 
-- (CGFloat)swipeToReplyPosition
+- (void)setIsReplyActive:(BOOL)isReplyActive
 {
-    OWSAssertDebug(self.swipeToReplyConstraints.firstObject);
-    return self.swipeToReplyConstraints.firstObject.constant;
+    if (isReplyActive == _isReplyActive) {
+        return;
+    }
+
+    _isReplyActive = isReplyActive;
+
+    // Update the reply image styling to reflect active state
+    CGAffineTransform transform = CGAffineTransformIdentity;
+    UIColor *tintColor = [UIColor ows_gray45Color];
+
+    if (isReplyActive) {
+        transform = CGAffineTransformMakeScale(1.16, 1.16);
+        tintColor = Theme.isDarkThemeEnabled ? [UIColor ows_gray25Color] : [UIColor ows_gray75Color];
+
+        // If we're transitioning to the active state, play haptic feedback
+        [[ImpactHapticFeedback new] impactOccurred];
+    }
+
+    [UIView animateWithDuration:0.2
+                          delay:0
+                        options:UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionBeginFromCurrentState
+                     animations:^{
+                         self.swipeToReplyImageView.transform = transform;
+                         self.swipeToReplyImageView.tintColor = tintColor;
+                     }
+                     completion:nil];
 }
 
 - (void)setupSwipeContainer
 {
     self.swipeableContentView = [UIView new];
     [self.contentView addSubview:self.swipeableContentView];
-    self.swipeToReplyConstraints = [self.swipeableContentView autoPinWidthToSuperview];
-    [self.swipeableContentView autoPinEdgeToSuperviewEdge:ALEdgeTop];
-    [NSLayoutConstraint autoSetPriority:UILayoutPriorityDefaultLow forConstraints:^{
-        [self.swipeableContentView autoPinEdgeToSuperviewEdge:ALEdgeBottom];
-    }];
+    [self.swipeableContentView autoPinEdgeToSuperviewEdge:ALEdgeLeading];
 
     self.swipeToReplyImageView = [UIImageView new];
-    self.swipeToReplyImageView.image = [[UIImage imageNamed:@"ic_reply"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
-    self.swipeToReplyImageView.tintColor = Theme.isDarkThemeEnabled ? [UIColor ows_gray25Color] : [UIColor ows_blackColor];
+    self.swipeToReplyImageView.image =
+        [[UIImage imageNamed:@"reply-outline-24"] imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate];
+    self.swipeToReplyImageView.tintColor
+        = Theme.isDarkThemeEnabled ? [UIColor ows_gray45Color] : [UIColor ows_gray45Color];
     self.swipeToReplyImageView.contentMode = UIViewContentModeScaleAspectFit;
     self.swipeToReplyImageView.alpha = 0;
     [self.swipeableContentView addSubview:self.swipeToReplyImageView];
-    [self.swipeToReplyImageView autoPinEdge:ALEdgeTrailing
-                                     toEdge:ALEdgeLeading
-                                     ofView:self.swipeableContentView
-                                 withOffset:ScaleFromIPhone5(-25)];
 }
 
 - (void)handleSwipeToReplyGesture:(UIPanGestureRecognizer *)sender
@@ -605,6 +635,8 @@ - (void)handleSwipeToReplyGesture:(UIPanGestureRecognizer *)sender
                 sender.enabled = YES;
                 return;
             }
+            self.messageViewInitialX = self.messageView.frame.origin.x;
+            self.swipeableContentViewInitialX = self.swipeableContentView.frame.origin.x;
             break;
         }
         case UIGestureRecognizerStateEnded:
@@ -620,25 +652,15 @@ - (void)handleSwipeToReplyGesture:(UIPanGestureRecognizer *)sender
     }
 
     CGFloat translationX = [sender translationInView:self].x;
-    CGFloat currentPosition = self.swipeToReplyPosition;
-
     // Invert positions for RTL logic, since the user is swiping in the opposite direction.
     if (CurrentAppContext().isRTL) {
         translationX = -translationX;
-        currentPosition = -currentPosition;
     }
 
-    BOOL mayReply = translationX >= self.maxSwipeDistance;
-
-    if (mayReply && !hasFailed) {
-        // When we transition into the reply range, play haptic feedback for the user
-        if (currentPosition < self.maxSwipeDistance) {
-            [[ImpactHapticFeedback new] impactOccurred];
-        }
+    self.isReplyActive = translationX >= self.swipeToReplyThreshold;
 
-        if (hasFinished) {
-            [self.delegate conversationCell:self didReplyToItem:self.viewItem];
-        }
+    if (self.isReplyActive && hasFinished) {
+        [self.delegate conversationCell:self didReplyToItem:self.viewItem];
     }
 
     if (hasFailed || hasFinished) {
@@ -654,34 +676,42 @@ - (void)setSwipePosition:(CGFloat)position animated:(BOOL)animated
     // to produce an elastic feeling when you overscroll.
     if (position < 0) {
         position = position / 4;
-    } else if (position > self.maxSwipeDistance) {
-        CGFloat overflow = position - self.maxSwipeDistance;
-        position = self.maxSwipeDistance + overflow / 4;
+    } else if (position > self.swipeToReplyThreshold) {
+        CGFloat overflow = position - self.swipeToReplyThreshold;
+        position = self.swipeToReplyThreshold + overflow / 4;
     }
 
-    for (NSLayoutConstraint *constraint in self.swipeToReplyConstraints) {
-        // The position passed to this function is assumed to always be
-        // relative to a LTR swipe. If we're actually swiping RTL, we
-        // must invert the position before updating the constraints.
-        constraint.constant = CurrentAppContext().isRTL ? -position : position;
+    CGRect newMessageViewFrame = self.messageView.frame;
+    newMessageViewFrame.origin.x = self.messageViewInitialX + (CurrentAppContext().isRTL ? -position : position);
+
+    // The swipe content moves at 1/8th the speed of the message bubble,
+    // so that it reveals itself from underneath with an elastic feel.
+    CGRect newSwipeContentFrame = self.swipeableContentView.frame;
+    newSwipeContentFrame.origin.x
+        = self.swipeableContentViewInitialX + (CurrentAppContext().isRTL ? -position : position) / 8;
+
+    CGFloat alpha = 1;
+    if ([self useSwipeFadeTransition]) {
+        alpha = CGFloatClamp01(CGFloatInverseLerp(position, 0, self.swipeToReplyThreshold));
     }
 
-    CGFloat alpha = CGFloatClamp01(CGFloatInverseLerp(position, 0, self.maxSwipeDistance));
+    void (^viewUpdates)(void) = ^() {
+        self.swipeToReplyImageView.alpha = alpha;
+        self.messageView.frame = newMessageViewFrame;
+        self.swipeableContentView.frame = newSwipeContentFrame;
+    };
 
     if (animated) {
-        [UIView animateWithDuration:0.1
-                         animations:^{
-                             self.swipeToReplyImageView.alpha = alpha;
-                             [self layoutIfNeeded];
-                         }];
+        [UIView animateWithDuration:0.1 animations:viewUpdates];
     } else {
-        self.swipeToReplyImageView.alpha = alpha;
+        viewUpdates();
     }
 }
 
 - (void)resetSwipePositionAnimated:(BOOL)animated
 {
     [self setSwipePosition:0 animated:animated];
+    self.isReplyActive = NO;
 }
 
 @end
