diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index e509febb5f6..bfe4af3c339 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -221,7 +221,7 @@ class PhotoCaptureViewController: OWSViewController {
 
         previewView.setIsHidden(composerMode == .text, animated: animated)
         if textEditorUIInitialized {
-            textViewContainerToolbar.setIsHidden(composerMode != .text, animated: animated)
+            textEditorToolbar.setIsHidden(composerMode != .text, animated: animated)
         }
     }
 
@@ -298,7 +298,7 @@ class PhotoCaptureViewController: OWSViewController {
     private func updateBottomBarVisibility(animated: Bool) {
         let isBarHidden: Bool = {
             if textEditorUIInitialized {
-                return textView.isFirstResponder
+                return textStoryComposerView.isEditing
             }
             if bottomBar.isContentTypeSelectionControlAvailable {
                 return false
@@ -344,70 +344,16 @@ class PhotoCaptureViewController: OWSViewController {
     private var textEditorUIInitialized = false
     private var textEditoriPhoneConstraints = [NSLayoutConstraint]()
     private var textEditoriPadConstraints = [NSLayoutConstraint]()
-    private lazy var textViewContentLayoutGuide = UILayoutGuide()
-    private lazy var textViewContainer: UIView = {
-        let view = UIView()
-        view.translatesAutoresizingMaskIntoConstraints = false
-        view.preservesSuperviewLayoutMargins = true
-        view.layer.masksToBounds = true
-
-        view.addSubview(textViewContainerBackgroundView)
-        textViewContainerBackgroundView.autoPinEdgesToSuperviewEdges()
 
-        // This defines bounds for text content: text view and link preview.
-        view.addLayoutGuide(textViewContentLayoutGuide)
-        view.addConstraints([
-            textViewContentLayoutGuide.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor),
-            textViewContentLayoutGuide.topAnchor.constraint(equalTo: view.layoutMarginsGuide.topAnchor, constant: 8),
-            textViewContentLayoutGuide.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor)
-        ])
+    private lazy var textStoryComposerView = TextStoryComposerView(text: "")
 
-        // This is a colored background for `inverted` text style.
-        let textViewWrapper = UIView()
-        textViewWrapper.addSubview(textViewBackgroundView)
-        textViewWrapper.addSubview(textView)
-        textViewBackgroundView.autoSetDimension(.width, toSize: 52, relation: .greaterThanOrEqual)
-        textViewBackgroundView.autoSetDimension(.height, toSize: 52, relation: .greaterThanOrEqual)
-        textViewBackgroundView.autoPinWidthToSuperview(relation: .lessThanOrEqual)
-        textViewBackgroundView.autoPinHeightToSuperview(relation: .lessThanOrEqual)
-        textViewBackgroundView.autoCenterInSuperview()
-        textView.autoPin(toEdgesOf: textViewBackgroundView, with: UIEdgeInsets(hMargin: 16, vMargin: 2))
-
-        // Text view and link preview are grouped together in a vertical stack view
-        // that is centered vertically in text content area.
-        let stackView = UIStackView(arrangedSubviews: [ textViewWrapper, linkPreviewWrapperView ])
-        stackView.axis = .vertical
-        stackView.translatesAutoresizingMaskIntoConstraints = false
-        view.addSubview(stackView)
-        view.addConstraints([
-            stackView.leadingAnchor.constraint(equalTo: textViewContentLayoutGuide.leadingAnchor),
-            stackView.topAnchor.constraint(greaterThanOrEqualTo: textViewContentLayoutGuide.topAnchor),
-            stackView.trailingAnchor.constraint(equalTo: textViewContentLayoutGuide.trailingAnchor),
-            stackView.bottomAnchor.constraint(lessThanOrEqualTo: textViewContentLayoutGuide.bottomAnchor),
-            stackView.centerYAnchor.constraint(equalTo: textViewContentLayoutGuide.centerYAnchor)
-        ])
-
-        // Placeholder text is centered in "text content area".
-        textViewPlaceholderLabel.translatesAutoresizingMaskIntoConstraints = false
-        view.addSubview(textViewPlaceholderLabel)
-        view.addConstraints([
-            textViewPlaceholderLabel.leadingAnchor.constraint(equalTo: textViewContentLayoutGuide.leadingAnchor),
-            textViewPlaceholderLabel.topAnchor.constraint(equalTo: textViewContentLayoutGuide.topAnchor),
-            textViewPlaceholderLabel.trailingAnchor.constraint(equalTo: textViewContentLayoutGuide.trailingAnchor),
-            textViewPlaceholderLabel.bottomAnchor.constraint(equalTo: textViewContentLayoutGuide.bottomAnchor)
-        ])
-
-        return view
-    }()
-    private lazy var textViewContainerBackgroundView = GradientView(colors: [])
-    private lazy var textViewContainerToolbar: UIView = {
+    private lazy var textEditorToolbar: UIView = {
         let stackView = UIStackView(arrangedSubviews: [ textBackgroundSelectionButton, textViewAttachLinkButton ])
         stackView.axis = .horizontal
         stackView.spacing = 16
         stackView.translatesAutoresizingMaskIntoConstraints = false
         return stackView
     }()
-    private var textBackgroundIndex = 0
     private lazy var textBackgroundSelectionButton = RoundGradientButton()
     private lazy var textViewAttachLinkButton: UIButton = {
         let button = RoundMediaButton(image: UIImage(imageLiteralResourceName: "link-diagonal"), backgroundStyle: .blur)
@@ -415,58 +361,12 @@ class PhotoCaptureViewController: OWSViewController {
         button.layoutMargins = .zero
         return button
     }()
-    private lazy var textViewBackgroundView: UIView = {
-        let backgroundView = UIView()
-        backgroundView.layer.cornerRadius = 12
-        return backgroundView
-    }()
-    private lazy var textView: MediaTextView = {
-        let textView = MediaTextView()
-        textView.delegate = self
-        return textView
-    }()
-    private lazy var textViewAccessoryToolbar: TextStylingToolbar = {
-        let toolbar = TextStylingToolbar(layout: .textStory)
-        toolbar.preservesSuperviewLayoutMargins = true
-        toolbar.addTarget(self, action: #selector(didChangeTextColor), for: .valueChanged)
-        toolbar.textStyleButton.addTarget(self, action: #selector(didTapTextStyleButton), for: .touchUpInside)
-        toolbar.decorationStyleButton.addTarget(self, action: #selector(didTapDecorationStyleButton), for: .touchUpInside)
-        toolbar.doneButton.addTarget(self, action: #selector(didTapTextViewDoneButton), for: .touchUpInside)
-        return toolbar
-    }()
-    private lazy var textViewPlaceholderLabel: UILabel = {
-        let label = UILabel()
-        label.textAlignment = .center
-        label.numberOfLines = 0
-        label.textColor = .ows_whiteAlpha60
-        label.font = .ows_dynamicTypeLargeTitle1Clamped
-        label.isUserInteractionEnabled = true
-        label.text = NSLocalizedString("STORY_COMPOSER_TAP_ADD_TEXT",
-                                       value: "Tap to add text",
-                                       comment: "Placeholder text in text stories compose UI")
-        return label
-    }()
 
     // This constraint gets updated when onscreen keyboard appears/disappears.
-    private var textViewBottomToScreenBottomConstraint: NSLayoutConstraint?
+    private var textStoryComposerContentLayoutGuideBottomIphone: NSLayoutConstraint?
+    private var textStoryComposerContentLayoutGuideBottomIpad: NSLayoutConstraint?
     private var observingKeyboardNotifications = false
 
-    private var linkPreview: OWSLinkPreviewDraft?
-    private var linkPreviewView: UIView?
-    private lazy var linkPreviewWrapperView: UIView = {
-        let view = UIView()
-        view.layoutMargins = UIEdgeInsets(margin: 20)
-        return view
-    }()
-    private lazy var deleteLinkPreviewButton: UIButton = {
-        let button = RoundMediaButton(image: UIImage(imageLiteralResourceName: "x-24"), backgroundStyle: .blurLight)
-        button.tintColor = Theme.lightThemePrimaryColor
-        button.contentEdgeInsets = UIEdgeInsets(margin: 8)
-        button.layoutMargins = UIEdgeInsets(margin: 2)
-        button.translatesAutoresizingMaskIntoConstraints = false
-        return button
-    }()
-
     private lazy var doneButton: MediaDoneButton = {
         let button = MediaDoneButton(type: .custom)
         button.badgeNumber = 0
@@ -694,7 +594,7 @@ class PhotoCaptureViewController: OWSViewController {
         updateSideBarVisibility(animated: true)
 
         if textEditorUIInitialized {
-            textViewContainer.layer.cornerRadius = isIPadUIInRegularMode || UIDevice.current.hasIPhoneXNotch ? 18 : 0
+            textStoryComposerView.layer.cornerRadius = isIPadUIInRegularMode || UIDevice.current.hasIPhoneXNotch ? 18 : 0
 
             if isIPadUIInRegularMode {
                 view.removeConstraints(textEditoriPhoneConstraints)
@@ -780,57 +680,49 @@ extension PhotoCaptureViewController {
         bottomBar.proceedButton.addTarget(self, action: #selector(didTapTextStoryProceedButton), for: .touchUpInside)
         textBackgroundSelectionButton.addTarget(self, action: #selector(didTapTextBackgroundButton), for: .touchUpInside)
         textViewAttachLinkButton.addTarget(self, action: #selector(didTapAttachLinkPreviewButton), for: .touchUpInside)
-        textViewContainer.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(textViewPlaceholderTapped)))
-
-        // Prepare text styling toolbar (only visible when editing text).
-        let toolbarSize = textViewAccessoryToolbar.systemLayoutSizeFitting(CGSize(width: view.width, height: .greatestFiniteMagnitude),
-                                                                           withHorizontalFittingPriority: .required,
-                                                                           verticalFittingPriority: .fittingSizeLevel)
-        textViewAccessoryToolbar.bounds.size = toolbarSize
-        textView.inputAccessoryView = textViewAccessoryToolbar
-        updateTextViewAttributes(using: textViewAccessoryToolbar)
+        updateTextBackgroundSelectionButton()
 
-        // Set up text view container.
-        textViewContainer.layer.cornerRadius = isIPadUIInRegularMode || UIDevice.current.hasIPhoneXNotch ? 18 : 0
-        view.insertSubview(textViewContainer, aboveSubview: previewView)
+        // Set up composer view.
+        textStoryComposerView.delegate = self
+        textStoryComposerView.translatesAutoresizingMaskIntoConstraints = false
+        textStoryComposerView.layer.cornerRadius = isIPadUIInRegularMode || UIDevice.current.hasIPhoneXNotch ? 18 : 0
+        view.insertSubview(textStoryComposerView, aboveSubview: previewView)
         textEditoriPhoneConstraints.append(contentsOf: [
-            textViewContainer.leadingAnchor.constraint(equalTo: contentLayoutGuide.leadingAnchor),
-            textViewContainer.topAnchor.constraint(equalTo: contentLayoutGuide.topAnchor),
-            textViewContainer.trailingAnchor.constraint(equalTo: contentLayoutGuide.trailingAnchor),
-            textViewContainer.bottomAnchor.constraint(equalTo: contentLayoutGuide.bottomAnchor)
+            textStoryComposerView.leadingAnchor.constraint(equalTo: contentLayoutGuide.leadingAnchor),
+            textStoryComposerView.topAnchor.constraint(equalTo: contentLayoutGuide.topAnchor),
+            textStoryComposerView.trailingAnchor.constraint(equalTo: contentLayoutGuide.trailingAnchor),
+            textStoryComposerView.bottomAnchor.constraint(equalTo: contentLayoutGuide.bottomAnchor)
         ])
 
-        // This constraint would allow to resize textView to clear onscreen keyboard.
-        textViewBottomToScreenBottomConstraint = textViewContainer.bottomAnchor.constraint(greaterThanOrEqualTo: textViewContentLayoutGuide.bottomAnchor)
-        textViewBottomToScreenBottomConstraint?.isActive = true
-
         // Choose Background and Attach Link buttons.
-        view.addSubview(textViewContainerToolbar)
+        // Toolbar is added to VC's view because it might be located outside of the textStoryComposerView.
+        view.addSubview(textEditorToolbar)
         // Align leading edge of Background button to leading edge of the Close button at the top.
-        view.addConstraint(textViewContainerToolbar.leadingAnchor.constraint(equalTo: topBar.controlsLayoutGuide.leadingAnchor))
-        textEditoriPhoneConstraints.append({
-            // On iPhones text content should not overlap with Background and Attach Link buttons.
-            let constraint = textViewContentLayoutGuide.bottomAnchor.constraint(
-                equalTo: textViewContainerToolbar.topAnchor, constant: -16)
-            constraint.priority = .defaultHigh
-            return constraint
-        }())
+        view.addConstraint(textEditorToolbar.leadingAnchor.constraint(equalTo: topBar.controlsLayoutGuide.leadingAnchor))
         if bottomBar.isCompactHeightLayout {
+            // On devices without top and bottom safe areas buttons are placed above CAMERA | TEXT controls.
             textEditoriPhoneConstraints.append(
-                textViewContainerToolbar.bottomAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.topAnchor))
+                textEditorToolbar.bottomAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.topAnchor))
         } else {
+            // On devices with bottom safe area buttons are pinned to the bottom edge of the colored background,
+            // which always clears CAMERA | TEXT controls.
             textEditoriPhoneConstraints.append(
-                textViewContainerToolbar.bottomAnchor.constraint(equalTo: textViewContainer.bottomAnchor, constant: -16))
+                textEditorToolbar.bottomAnchor.constraint(equalTo: textStoryComposerView.bottomAnchor, constant: -16))
         }
 
+        // This constraint defines bottom edge of the area that contains text view and link preview inside of the `textStoryComposerView`.
+        // Initially the bottom edge is pinned to the top of `textEditorToolbar`.
+        // If on-screen keyboard appears the constraint is updated so that content clears the keyboard.
+        textStoryComposerContentLayoutGuideBottomIphone = textStoryComposerView.contentLayoutGuide.bottomAnchor.constraint(
+            equalTo: textEditorToolbar.bottomAnchor)
+        textEditoriPhoneConstraints.append(textStoryComposerContentLayoutGuideBottomIphone!)
+
         if isIPadUIInRegularMode {
             initializeTextEditoriPadUI()
         } else {
             view.addConstraints(textEditoriPhoneConstraints)
         }
 
-        updateTextBackground()
-
         view.setNeedsLayout()
         UIView.performWithoutAnimation {
             self.view.layoutIfNeeded()
@@ -844,87 +736,40 @@ extension PhotoCaptureViewController {
 
         // Container - 16:9 aspect ratio, constrained vertically, centered on the screen horizontally.
         textEditoriPadConstraints.append(contentsOf: [
-            textViewContainer.topAnchor.constraint(equalTo: topBar.bottomAnchor, constant: -8),
-            textViewContainer.bottomAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.topAnchor, constant: -24),
-            textViewContainer.centerXAnchor.constraint(equalTo: contentLayoutGuide.centerXAnchor),
-            textViewContainer.widthAnchor.constraint(equalTo: textViewContainer.heightAnchor, multiplier: 9/16)
+            textStoryComposerView.topAnchor.constraint(equalTo: topBar.bottomAnchor, constant: -8),
+            textStoryComposerView.bottomAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.topAnchor, constant: -24),
+            textStoryComposerView.centerXAnchor.constraint(equalTo: contentLayoutGuide.centerXAnchor),
+            textStoryComposerView.widthAnchor.constraint(equalTo: textStoryComposerView.heightAnchor, multiplier: 9/16)
         ])
 
-        // Allow text view content take entire textViewContainer because all controls are outside of textViewContainer.
-        // This is a non-required constraint because it needs to fail when on-screen keyboard is visible.
-        textEditoriPadConstraints.append({
-            let constraint = textViewContentLayoutGuide.bottomAnchor.constraint(equalTo: textViewContainer.layoutMarginsGuide.bottomAnchor)
-            constraint.priority = .defaultHigh
-            return constraint
-        }())
+        // This constraint defines bottom edge of the text content area
+        // and would allow to resize content to clear onscreen keyboard.
+        textStoryComposerContentLayoutGuideBottomIpad = textStoryComposerView.contentLayoutGuide.bottomAnchor.constraint(
+            equalTo: textStoryComposerView.bottomAnchor, constant: -8)
+        textEditoriPadConstraints.append(textStoryComposerContentLayoutGuideBottomIpad!)
 
         // Background and Add Link buttons are vertically centered with CAMERA|TEXT switch and Proceed button.
         textEditoriPadConstraints.append(
-            textViewContainerToolbar.centerYAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.centerYAnchor))
+            textEditorToolbar.centerYAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.centerYAnchor))
 
         view.addConstraints(textEditoriPadConstraints)
     }
 
-    private var strippedTextViewText: String { textView.text.stripped }
-
-    private var isTextViewContentEmpty: Bool {
-        strippedTextViewText.isEmpty && linkPreview == nil
-    }
-
-    private static func desiredAttributes(forText text: String) -> (fontPointSize: CGFloat, textAlignment: NSTextAlignment) {
-        switch text.count {
-        case ..<50: return (34, .center)
-        case 50...199: return (24, .center)
-        default: return (18, .natural)
-        }
-    }
-
-    private func updateTextViewAttributes(using textToolbar: TextStylingToolbar) {
-        let (fontPointSize, textAlignment) = PhotoCaptureViewController.desiredAttributes(forText: strippedTextViewText)
-        textView.update(using: textToolbar, fontPointSize: fontPointSize, textAlignment: textAlignment)
-        textViewBackgroundView.backgroundColor = textViewAccessoryToolbar.textBackgroundColor
-    }
-
-    private func adjustFontSizeIfNecessary() {
-        guard let currentFontSize = textView.font?.pointSize else { return }
-        let desiredFontSize = PhotoCaptureViewController.desiredAttributes(forText: strippedTextViewText).fontPointSize
-        guard desiredFontSize != currentFontSize else { return }
-        updateTextViewAttributes(using: textViewAccessoryToolbar)
+    private func updateTextEditorToolbarVisibility(animated: Bool) {
+        textEditorToolbar.setIsHidden(textStoryComposerView.isEditing || composerMode != .text, animated: animated)
     }
 
-    private func updateLinkPreviewAppearance() {
-        if let linkPreviewView = linkPreviewView {
-            linkPreviewView.removeFromSuperview()
-            self.linkPreviewView = nil
-        }
-
-        guard let linkPreview = linkPreview else {
-            linkPreviewWrapperView.isHiddenInStackView = true
-            return
-        }
-
-        linkPreviewWrapperView.isHiddenInStackView = false
-
-        let linkPreviewView = TextAttachmentView.LinkPreviewView(linkPreview: LinkPreviewDraft(linkPreviewDraft: linkPreview))
-        linkPreviewWrapperView.addSubview(linkPreviewView)
-        linkPreviewView.autoPinEdgesToSuperviewMargins()
-        self.linkPreviewView = linkPreviewView
+    // Update background of the background selection button to match the editor.
+    private func updateTextBackgroundSelectionButton() {
+        switch textStoryComposerView.background {
+        case .color(let color):
+            textBackgroundSelectionButton.gradientView.colors = [ color, color ]
 
-        if deleteLinkPreviewButton.superview == nil {
-            linkPreviewWrapperView.addSubview(deleteLinkPreviewButton)
-            deleteLinkPreviewButton.addTarget(self, action: #selector(didTapDeleteLinkPreviewButton), for: .touchUpInside)
+        case .gradient(let gradient):
+            textBackgroundSelectionButton.gradientView.colors = gradient.colors
+            textBackgroundSelectionButton.gradientView.locations = gradient.locations
+            textBackgroundSelectionButton.gradientView.setAngle(gradient.angle)
         }
-        linkPreviewWrapperView.addConstraints([
-            deleteLinkPreviewButton.centerXAnchor.constraint(equalTo: linkPreviewView.trailingAnchor, constant: -5),
-            deleteLinkPreviewButton.centerYAnchor.constraint(equalTo: linkPreviewView.topAnchor, constant: 5)
-        ])
-        linkPreviewWrapperView.bringSubviewToFront(deleteLinkPreviewButton)
-    }
-
-    private func updateTextEditorUI(animated: Bool) {
-        let isPlaceholderHidden = textView.isFirstResponder || textView.hasText || linkPreview != nil
-        textViewPlaceholderLabel.setIsHidden(isPlaceholderHidden, animated: animated)
-        bottomBar.proceedButton.isEnabled = !isTextViewContentEmpty
     }
 
     // MARK: - Keyboard Handling
@@ -957,16 +802,18 @@ extension PhotoCaptureViewController {
     private func handleKeyboardNotification(_ notification: Notification) {
         guard composerMode == .text else { return }
 
-        guard let constraint = textViewBottomToScreenBottomConstraint else { return }
+        guard let iPhoneConstraint = textStoryComposerContentLayoutGuideBottomIphone else { return }
+        let iPadConstraint = textStoryComposerContentLayoutGuideBottomIpad
 
         guard let userInfo = notification.userInfo,
               let endFrame = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect else { return }
 
-        let convertedEndFrame = textViewContainer.convert(endFrame, from: nil)
-        let inset = textViewContainer.bounds.maxY - convertedEndFrame.minY
+        let iPhoneInset = textEditorToolbar.convert(endFrame, from: nil).minY - textEditorToolbar.bounds.maxY
+        let iPadInset = textStoryComposerView.convert(endFrame, from: nil).minY - textStoryComposerView.bounds.maxY
 
         let layoutUpdateBlock = {
-            constraint.constant = inset + 16
+            iPhoneConstraint.constant = min(iPhoneInset, 0) - 8
+            iPadConstraint?.constant = min(iPadInset, 0) - 8
         }
         if let animationDuration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? TimeInterval,
            let rawAnimationCurve = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? Int,
@@ -988,19 +835,7 @@ extension PhotoCaptureViewController {
 
     // MARK: - Background
 
-    private static var textBackgrounds: [TextAttachment.Background] = [
-        .color(.init(rgbHex: 0x688BD4)),
-        .color(.init(rgbHex: 0x8687C1)),
-        .color(.init(rgbHex: 0xB47F8C)),
-        .color(.init(rgbHex: 0x899188)),
-        .color(.init(rgbHex: 0x539383)),
-        .gradient(.init(colors: [ .init(rgbHex: 0x19A9FA), .init(rgbHex: 0x7097D7), .init(rgbHex: 0xD1998D), .init(rgbHex: 0xFFC369) ])),
-        .gradient(.init(colors: [ .init(rgbHex: 0x4437D8), .init(rgbHex: 0x6B70DE), .init(rgbHex: 0xB774E0), .init(rgbHex: 0xFF8E8E) ])),
-        .gradient(.init(colors: [ .init(rgbHex: 0x004044), .init(rgbHex: 0x2C5F45), .init(rgbHex: 0x648E52), .init(rgbHex: 0x93B864) ]))
-    ]
-
     private class RoundGradientButton: RoundMediaButton {
-
         let gradientView = GradientView(colors: [])
 
         init() {
@@ -1021,113 +856,33 @@ extension PhotoCaptureViewController {
         override var intrinsicContentSize: CGSize { CGSize(square: 44) }
     }
 
-    private func switchToNextBackground() {
-        textBackgroundIndex += 1
-        if textBackgroundIndex > PhotoCaptureViewController.textBackgrounds.count - 1 {
-            textBackgroundIndex = 0
-        }
-        updateTextBackground()
-    }
-
-    private func updateTextBackground() {
-        let textBackground = PhotoCaptureViewController.textBackgrounds[textBackgroundIndex]
-        switch textBackground {
-        case .color(let color):
-            textViewContainerBackgroundView.colors = [ color, color ]
-            textBackgroundSelectionButton.gradientView.colors = [ color, color ]
-
-        case .gradient(let gradient):
-            textViewContainerBackgroundView.colors = gradient.colors
-            textViewContainerBackgroundView.locations = gradient.locations
-            textViewContainerBackgroundView.setAngle(gradient.angle)
-
-            textBackgroundSelectionButton.gradientView.colors = gradient.colors
-            textBackgroundSelectionButton.gradientView.locations = gradient.locations
-            textBackgroundSelectionButton.gradientView.setAngle(gradient.angle)
-        }
-    }
-
     // MARK: - Button Actions
 
-    @objc
-    private func textViewPlaceholderTapped() {
-        textView.becomeFirstResponder()
-    }
-
-    @objc
-    private func didTapTextStyleButton() {
-        let currentTextStyle = textViewAccessoryToolbar.textStyle
-        let nextTextStyle = MediaTextView.TextStyle(rawValue: currentTextStyle.rawValue + 1) ?? .regular
-
-        // Update toolbar.
-        textViewAccessoryToolbar.textStyle = nextTextStyle
-
-        // Update text view.
-        if textView.isFirstResponder {
-            updateTextViewAttributes(using: textViewAccessoryToolbar)
-        }
-    }
-
-    @objc
-    private func didTapDecorationStyleButton() {
-        // Switch between colored text with no background and white text over colored background.
-        let currentDecorationStyle = textViewAccessoryToolbar.decorationStyle
-        let nextDecorationStyle: MediaTextView.DecorationStyle = currentDecorationStyle == .none ? .inverted : .none
-
-        // Update toolbar.
-        textViewAccessoryToolbar.decorationStyle = nextDecorationStyle
-
-        // Update text view.
-        updateTextViewAttributes(using: textViewAccessoryToolbar)
-    }
-
     @objc
     private func didTapTextBackgroundButton() {
-        switchToNextBackground()
+        textStoryComposerView.switchToNextBackground()
+        updateTextBackgroundSelectionButton()
     }
 
     @objc
     private func didTapAttachLinkPreviewButton() {
-        let linkPreviewViewController = LinkPreviewAttachmentViewController(linkPreview)
+        let linkPreviewViewController = LinkPreviewAttachmentViewController(textStoryComposerView.linkPreviewDraft)
         linkPreviewViewController.delegate = self
         present(linkPreviewViewController, animated: true)
     }
 
-    @objc
-    private func didTapDeleteLinkPreviewButton() {
-        linkPreview = nil
-        updateLinkPreviewAppearance()
-        updateTextEditorUI(animated: true)
-    }
-
-    @objc
-    private func didTapTextViewDoneButton() {
-        Logger.verbose("")
-
-        textView.acceptAutocorrectSuggestion()
-        textView.resignFirstResponder()
-    }
-
     @objc
     private func didTapTextStoryProceedButton() {
         Logger.verbose("")
 
-        let textForegroundColor = textViewAccessoryToolbar.textForegroundColor
-        let textBackgroundColor = textViewAccessoryToolbar.textBackgroundColor
-
-        let textStyle: TextAttachment.TextStyle = {
-            switch textViewAccessoryToolbar.textStyle {
-            case .regular: return .regular
-            case .bold: return .bold
-            case .condensed: return .condensed
-            case .script: return .script
-            case .serif: return .serif
-            }
-        }()
-        let background = PhotoCaptureViewController.textBackgrounds[textBackgroundIndex]
+        let text = textStoryComposerView.text ?? ""
+        let textForegroundColor = textStoryComposerView.textForegroundColor
+        let textBackgroundColor = textStoryComposerView.textBackgroundColor
+        let textStyle = textStoryComposerView.textStyle
+        let background = textStoryComposerView.background
 
         var validatedLinkPreview: OWSLinkPreview?
-        if let linkPreview = linkPreview {
+        if let linkPreview = textStoryComposerView.linkPreviewDraft {
             self.databaseStorage.write { transaction in
                 do {
                     validatedLinkPreview = try OWSLinkPreview.buildValidatedLinkPreview(fromInfo: linkPreview, transaction: transaction)
@@ -1139,13 +894,13 @@ extension PhotoCaptureViewController {
             }
         }
 
-        guard validatedLinkPreview != nil || !strippedTextViewText.isEmpty else {
+        guard validatedLinkPreview != nil || !text.isEmpty else {
             owsFailDebug("Empty content")
             return
         }
 
         let textAttachment = TextAttachment(
-            text: strippedTextViewText,
+            text: text,
             textStyle: textStyle,
             textForegroundColor: textForegroundColor,
             textBackgroundColor: textBackgroundColor,
@@ -1153,40 +908,22 @@ extension PhotoCaptureViewController {
             linkPreview: validatedLinkPreview)
         delegate?.photoCaptureViewController(self, didFinishWithTextAttachment: textAttachment)
     }
-
-    @objc
-    private func didChangeTextColor() {
-        updateTextViewAttributes(using: textViewAccessoryToolbar)
-    }
 }
 
-extension PhotoCaptureViewController: UITextViewDelegate {
+extension PhotoCaptureViewController: TextStoryComposerViewDelegate {
 
-    func textViewDidBeginEditing(_ textView: UITextView) {
+    fileprivate func textStoryComposerDidBeginEditing(_ textStoryComposer: TextStoryComposerView) {
         updateBottomBarVisibility(animated: true)
-        textViewContainerToolbar.setIsHidden(true, animated: true)
-        updateTextEditorUI(animated: true)
+        updateTextEditorToolbarVisibility(animated: true)
     }
 
-    func textViewDidEndEditing(_ textView: UITextView) {
+    fileprivate func textStoryComposerDidEndEditing(_ textStoryComposer: TextStoryComposerView) {
         updateBottomBarVisibility(animated: true)
-        textViewContainerToolbar.setIsHidden(false, animated: true)
-        updateTextEditorUI(animated: true)
-    }
-
-    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
-        // Truncate the replacement to fit.
-        return TextViewHelper.textView(
-            textView,
-            shouldChangeTextIn: range,
-            replacementText: text,
-            maxGlyphCount: 700
-        )
+        updateTextEditorToolbarVisibility(animated: true)
     }
 
-    func textViewDidChange(_ textView: UITextView) {
-        adjustFontSizeIfNecessary()
-        updateTextEditorUI(animated: false)
+    fileprivate func textStoryComposerDidChange(_ textStoryComposer: TextStoryComposerView) {
+        bottomBar.proceedButton.isEnabled = !textStoryComposer.isEmpty
     }
 }
 
@@ -1194,9 +931,7 @@ extension PhotoCaptureViewController: LinkPreviewAttachmentViewControllerDelegat
 
     func linkPreviewAttachmentViewController(_ viewController: LinkPreviewAttachmentViewController,
                                              didFinishWith linkPreview: OWSLinkPreviewDraft) {
-        self.linkPreview = linkPreview
-        updateLinkPreviewAppearance()
-        updateTextEditorUI(animated: false)
+        textStoryComposerView.linkPreviewDraft = linkPreview
         viewController.dismiss(animated: true)
     }
 }
@@ -1288,12 +1023,12 @@ extension PhotoCaptureViewController {
         switch newComposerMode {
         case .camera:
             resumePhotoCapture()
-            textViewContainer.setIsHidden(true, animated: true)
+            textStoryComposerView.setIsHidden(true, animated: true)
 
         case .text:
             startObservingKeyboardNotifications()
             initializeTextEditorUIIfNecessary()
-            textViewContainer.setIsHidden(false, animated: true)
+            textStoryComposerView.setIsHidden(false, animated: true)
             pausePhotoCapture()
         }
     }
@@ -1585,3 +1320,362 @@ extension PhotoCaptureViewController: PhotoCaptureDelegate {
         completeFocusAnimation(forFocusPoint: focusPoint)
     }
 }
+
+private protocol TextStoryComposerViewDelegate: AnyObject {
+    func textStoryComposerDidBeginEditing(_ textStoryComposer: TextStoryComposerView)
+    func textStoryComposerDidEndEditing(_ textStoryComposer: TextStoryComposerView)
+    func textStoryComposerDidChange(_ textStoryComposer: TextStoryComposerView)
+}
+
+private class TextStoryComposerView: TextAttachmentView, UITextViewDelegate {
+
+    weak var delegate: TextStoryComposerViewDelegate?
+
+    init(text: String) {
+        super.init(
+            text: text,
+            textStyle: .regular,
+            textForegroundColor: TextStylingToolbar.defaultColor(forLayout: .textStory).color,
+            textBackgroundColor: nil,
+            background: TextStoryComposerView.defaultBackground,
+            linkPreview: nil
+        )
+
+        // Placeholder Label
+        textPlaceholderLabel.translatesAutoresizingMaskIntoConstraints = false
+        addSubview(textPlaceholderLabel)
+        addConstraints([
+            textPlaceholderLabel.leadingAnchor.constraint(equalTo: contentLayoutGuide.leadingAnchor),
+            textPlaceholderLabel.topAnchor.constraint(equalTo: contentLayoutGuide.topAnchor),
+            textPlaceholderLabel.trailingAnchor.constraint(equalTo: contentLayoutGuide.trailingAnchor),
+            textPlaceholderLabel.bottomAnchor.constraint(equalTo: contentLayoutGuide.bottomAnchor)
+        ])
+
+        // Prepare text styling toolbar - attached to keyboard.
+        let toolbarSize = textViewAccessoryToolbar.systemLayoutSizeFitting(
+            CGSize(width: UIScreen.main.bounds.width, height: .greatestFiniteMagnitude),
+            withHorizontalFittingPriority: .required,
+            verticalFittingPriority: .fittingSizeLevel
+        )
+        textViewAccessoryToolbar.bounds.size = toolbarSize
+        textView.inputAccessoryView = textViewAccessoryToolbar
+
+        // Text View
+        textViewBackgroundView.layer.cornerRadius = LayoutConstants.textBackgroundCornerRadius
+        textViewBackgroundView.addSubview(textView)
+        addSubview(textViewBackgroundView)
+
+        updateTextViewAttributes()
+        updateVisibilityOfComponents(animated: false)
+
+        addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(placeholderTapped)))
+    }
+
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    // Slightly smaller vertical margins for UITextView because UITextView
+    // has larger embedded padding above and below the text.
+    private static let textViewBackgroundVMargin = LayoutConstants.textBackgroundVMargin - 8
+    private static let textViewBackgroundHMargin = LayoutConstants.textBackgroundHMargin
+
+    public override func layoutTextContentAndLinkPreview() {
+        super.layoutTextContentAndLinkPreview()
+
+        var textViewSize = textContentSize
+
+        // Min dimensions for an empty text view.
+        textViewSize.width = max(textViewSize.width, 20)
+        textViewSize.height = max(textViewSize.height, 48)
+
+        // Limit text view height to available content height, deducting link preview area height if needed.
+        var linkPreviewAreaHeight: CGFloat = 0
+        if linkPreviewView != nil {
+            linkPreviewAreaHeight = linkPreviewWrapperView.frame.height + LayoutConstants.linkPreviewAreaTopMargin
+        }
+        textViewSize.height = min(
+            textViewSize.height,
+            contentLayoutGuide.layoutFrame.height - linkPreviewAreaHeight - 2 * TextStoryComposerView.textViewBackgroundVMargin
+        )
+
+        // Enable / disable vertical text scrolling if all text doesn't fit the available screen space.
+        if textContentSize.height > textViewSize.height {
+            textView.isScrollEnabled = true
+        } else {
+            textView.isScrollEnabled = false
+        }
+        textView.bounds.size = textViewSize
+
+        textViewBackgroundView.bounds.size = CGSize(
+            width: textViewSize.width + 2 * TextStoryComposerView.textViewBackgroundHMargin,
+            height: textViewSize.height + 2 * TextStoryComposerView.textViewBackgroundVMargin
+        )
+        textViewBackgroundView.center = CGPoint(
+            x: contentLayoutGuide.layoutFrame.center.x,
+            y: contentLayoutGuide.layoutFrame.center.y - 0.5 * linkPreviewAreaHeight
+        )
+        textView.center = textViewBackgroundView.bounds.center
+
+        linkPreviewWrapperView.center = CGPoint(
+            x: linkPreviewWrapperView.center.x,
+            y: textViewBackgroundView.frame.maxY + LayoutConstants.linkPreviewAreaTopMargin + 0.5 * linkPreviewWrapperView.bounds.height
+        )
+    }
+
+    override func calculateTextContentSize() -> CGSize {
+        guard isEditing else {
+            return super.calculateTextContentSize()
+        }
+        let maxTextViewSize = contentLayoutGuide.layoutFrame.insetBy(
+            dx: LayoutConstants.textBackgroundHMargin,
+            dy: TextStoryComposerView.textViewBackgroundVMargin
+        ).size
+        return textView.systemLayoutSizeFitting(
+            maxTextViewSize,
+            withHorizontalFittingPriority: .required,
+            verticalFittingPriority: .fittingSizeLevel
+        )
+    }
+
+    // MARK: -
+
+    override var isEditing: Bool { textView.isFirstResponder }
+
+    var isEmpty: Bool {
+        guard let text = text else { return true }
+        return text.isEmpty && linkPreview == nil
+    }
+
+    // MARK: - Text View
+
+    private lazy var textView: MediaTextView = {
+        let textView = MediaTextView()
+        textView.delegate = self
+        textView.showsVerticalScrollIndicator = false
+        return textView
+    }()
+
+    private let textViewBackgroundView = UIView()
+
+    private lazy var textViewAccessoryToolbar: TextStylingToolbar = {
+        let toolbar = TextStylingToolbar(layout: .textStory)
+        toolbar.preservesSuperviewLayoutMargins = true
+        toolbar.addTarget(self, action: #selector(didChangeTextColor), for: .valueChanged)
+        toolbar.textStyleButton.addTarget(self, action: #selector(didTapTextStyleButton), for: .touchUpInside)
+        toolbar.decorationStyleButton.addTarget(self, action: #selector(didTapDecorationStyleButton), for: .touchUpInside)
+        toolbar.doneButton.addTarget(self, action: #selector(didTapTextViewDoneButton), for: .touchUpInside)
+        return toolbar
+    }()
+
+    private let textPlaceholderLabel: UILabel = {
+        let label = UILabel()
+        label.textAlignment = .center
+        label.numberOfLines = 0
+        label.textColor = .ows_whiteAlpha60
+        label.font = .ows_dynamicTypeLargeTitle1Clamped
+        label.text = NSLocalizedString("STORY_COMPOSER_TAP_ADD_TEXT",
+                                       value: "Tap to add text",
+                                       comment: "Placeholder text in text stories compose UI")
+        return label
+    }()
+
+    override public func updateVisibilityOfComponents(animated: Bool) {
+        super.updateVisibilityOfComponents(animated: animated)
+
+        let isEditing = isEditing
+        textPlaceholderLabel.setIsHidden(isEditing || !isEmpty, animated: animated)
+        textViewBackgroundView.setIsHidden(!isEditing, animated: animated)
+    }
+
+    private func updateTextViewAttributes() {
+        let text = textView.text.stripped
+        let (fontPointSize, textAlignment) = sizeAndAlignment(forText: text)
+        textView.updateWith(
+            textForegroundColor: textForegroundColor,
+            font: font(for: textStyle, withPointSize: fontPointSize),
+            textAlignment: textAlignment,
+            textDecorationColor: nil,
+            decorationStyle: .none)
+        textViewBackgroundView.backgroundColor = textBackgroundColor
+    }
+
+    private func adjustFontSizeIfNecessary() {
+        guard let currentFontSize = textView.font?.pointSize else { return }
+        let text = textView.text.stripped
+        let desiredFontSize = sizeAndAlignment(forText: text).fontPointSize
+        guard desiredFontSize != currentFontSize else { return }
+        self.text = text
+        updateTextAttributes()
+        updateTextViewAttributes()
+    }
+
+    @objc
+    private func placeholderTapped() {
+        textView.becomeFirstResponder()
+    }
+
+    @objc
+    private func didTapTextStyleButton() {
+        Logger.verbose("")
+
+        let currentTextStyle = textViewAccessoryToolbar.textStyle
+        let nextTextStyle = MediaTextView.TextStyle(rawValue: currentTextStyle.rawValue + 1) ?? .regular
+        textViewAccessoryToolbar.textStyle = nextTextStyle
+
+        textStyle = {
+            switch nextTextStyle {
+            case .regular: return .regular
+            case .bold: return .bold
+            case .serif: return .serif
+            case .script: return .script
+            case .condensed: return .condensed
+            }
+        }()
+
+        updateTextViewAttributes()
+    }
+
+    @objc
+    private func didTapDecorationStyleButton() {
+        Logger.verbose("")
+
+        // Switch between colored text with no background and white text over colored background.
+        let currentDecorationStyle = textViewAccessoryToolbar.decorationStyle
+        let nextDecorationStyle: MediaTextView.DecorationStyle = currentDecorationStyle == .none ? .inverted : .none
+        textViewAccessoryToolbar.decorationStyle = nextDecorationStyle
+
+        // `textViewAccessoryToolbar` defines both foreground and background color for text based on the decoration style.
+        let textForegroundColor = textViewAccessoryToolbar.textForegroundColor
+        let textBackgroundColor = textViewAccessoryToolbar.textBackgroundColor
+        setTextForegroundColor(textForegroundColor, backgroundColor: textBackgroundColor)
+
+        updateTextViewAttributes()
+    }
+
+    @objc
+    private func didChangeTextColor() {
+        Logger.verbose("")
+
+        // Depending on text decoration style color picker changes either color of the text or background color.
+        // That's why we need to update both.
+        let textForegroundColor = textViewAccessoryToolbar.textForegroundColor
+        let textBackgroundColor = textViewAccessoryToolbar.textBackgroundColor
+        setTextForegroundColor(textForegroundColor, backgroundColor: textBackgroundColor)
+
+        updateTextViewAttributes()
+    }
+
+    @objc
+    private func didTapTextViewDoneButton() {
+        Logger.verbose("")
+
+        textView.acceptAutocorrectSuggestion()
+        textView.resignFirstResponder()
+    }
+
+    // MARK: - UITextViewDelegate
+
+    func textViewDidBeginEditing(_ textView: UITextView) {
+        updateVisibilityOfComponents(animated: true)
+        delegate?.textStoryComposerDidBeginEditing(self)
+        setNeedsLayout()
+    }
+
+    func textViewDidEndEditing(_ textView: UITextView) {
+        self.text = textView.text.stripped
+        updateVisibilityOfComponents(animated: true)
+        delegate?.textStoryComposerDidEndEditing(self)
+    }
+
+    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
+        // Truncate the replacement to fit.
+        return TextViewHelper.textView(
+            textView,
+            shouldChangeTextIn: range,
+            replacementText: text,
+            maxGlyphCount: 700
+        )
+    }
+
+    func textViewDidChange(_ textView: UITextView) {
+        self.text = textView.text.stripped
+        adjustFontSizeIfNecessary()
+        delegate?.textStoryComposerDidChange(self)
+        setNeedsLayout()
+    }
+
+    // MARK: - Link Preview
+
+    fileprivate var linkPreviewDraft: OWSLinkPreviewDraft? {
+        didSet {
+            if let linkPreviewDraft = linkPreviewDraft {
+                linkPreview = LinkPreviewDraft(linkPreviewDraft: linkPreviewDraft)
+            } else {
+                linkPreview = nil
+            }
+            delegate?.textStoryComposerDidChange(self)
+        }
+    }
+
+    private lazy var deleteLinkPreviewButton: UIButton = {
+        let button = RoundMediaButton(image: UIImage(imageLiteralResourceName: "x-24"), backgroundStyle: .blurLight)
+        button.tintColor = Theme.lightThemePrimaryColor
+        button.contentEdgeInsets = UIEdgeInsets(margin: 8)
+        button.layoutMargins = UIEdgeInsets(margin: 2)
+        button.translatesAutoresizingMaskIntoConstraints = false
+        button.addTarget(self, action: #selector(didTapDeleteLinkPreviewButton), for: .touchUpInside)
+        return button
+    }()
+
+    override func reloadLinkPreviewAppearance() {
+        super.reloadLinkPreviewAppearance()
+
+        guard let linkPreviewView = linkPreviewView else { return }
+
+        if deleteLinkPreviewButton.superview == nil {
+            linkPreviewWrapperView.addSubview(deleteLinkPreviewButton)
+        }
+        linkPreviewWrapperView.bringSubviewToFront(deleteLinkPreviewButton)
+        linkPreviewWrapperView.addConstraints([
+            deleteLinkPreviewButton.centerXAnchor.constraint(equalTo: linkPreviewView.trailingAnchor, constant: -5),
+            deleteLinkPreviewButton.centerYAnchor.constraint(equalTo: linkPreviewView.topAnchor, constant: 5)
+        ])
+
+        updateVisibilityOfComponents(animated: true)
+    }
+
+    @objc
+    private func didTapDeleteLinkPreviewButton() {
+        linkPreviewDraft = nil
+    }
+
+    // MARK: - Background
+
+    private var currentBackgroundIndex = 0 {
+        didSet {
+            background = TextStoryComposerView.textBackgrounds[currentBackgroundIndex]
+        }
+    }
+
+    private static var defaultBackground: TextAttachment.Background { textBackgrounds[0] }
+
+    private static var textBackgrounds: [TextAttachment.Background] = [
+        .color(.init(rgbHex: 0x688BD4)),
+        .color(.init(rgbHex: 0x8687C1)),
+        .color(.init(rgbHex: 0xB47F8C)),
+        .color(.init(rgbHex: 0x899188)),
+        .color(.init(rgbHex: 0x539383)),
+        .gradient(.init(colors: [ .init(rgbHex: 0x19A9FA), .init(rgbHex: 0x7097D7), .init(rgbHex: 0xD1998D), .init(rgbHex: 0xFFC369) ])),
+        .gradient(.init(colors: [ .init(rgbHex: 0x4437D8), .init(rgbHex: 0x6B70DE), .init(rgbHex: 0xB774E0), .init(rgbHex: 0xFF8E8E) ])),
+        .gradient(.init(colors: [ .init(rgbHex: 0x004044), .init(rgbHex: 0x2C5F45), .init(rgbHex: 0x648E52), .init(rgbHex: 0x93B864) ]))
+    ]
+
+    func switchToNextBackground() {
+        var nextBackgroundIndex = currentBackgroundIndex + 1
+        if nextBackgroundIndex > TextStoryComposerView.textBackgrounds.count - 1 {
+            nextBackgroundIndex = 0
+        }
+        currentBackgroundIndex = nextBackgroundIndex
+    }
+}
diff --git a/SignalUI/Views/ColorPickerBar.swift b/SignalUI/Views/ColorPickerBar.swift
index 1a0faf9c159..9e94bd029cb 100644
--- a/SignalUI/Views/ColorPickerBar.swift
+++ b/SignalUI/Views/ColorPickerBar.swift
@@ -13,7 +13,7 @@ public protocol ColorPickerBarViewDelegate: AnyObject {
 // We represent picker colors using this (color, phase)
 // tuple so that we can consistently restore palette view state.
 public class ColorPickerBarColor {
-    let color: UIColor
+    public let color: UIColor
 
     // Colors are chosen from a spectrum of colors.
     // This unit value represents the location of the
diff --git a/SignalUI/Views/MediaTextView.swift b/SignalUI/Views/MediaTextView.swift
index 7b609553bb1..7f9832602e2 100644
--- a/SignalUI/Views/MediaTextView.swift
+++ b/SignalUI/Views/MediaTextView.swift
@@ -159,7 +159,7 @@ public class TextStylingToolbar: UIControl {
         set { colorPickerView.selectedValue = newValue }
     }
 
-    private static func defaultColor(forLayout layout: Layout) -> ColorPickerBarColor {
+    public static func defaultColor(forLayout layout: Layout) -> ColorPickerBarColor {
         switch layout {
         case .photoOverlay:
             return ColorPickerBarColor.defaultColor()
diff --git a/SignalUI/Views/RoundMediaButton.swift b/SignalUI/Views/RoundMediaButton.swift
index 51c32b2b8a6..0a03dce68f1 100644
--- a/SignalUI/Views/RoundMediaButton.swift
+++ b/SignalUI/Views/RoundMediaButton.swift
@@ -55,6 +55,8 @@ open class RoundMediaButton: UIButton {
         tintColor = Theme.darkThemePrimaryColor
         insetsLayoutMarginsFromSafeArea = false
 
+        setCompressionResistanceHigh()
+
         if backgroundView != nil || customView != nil {
             let backgroundContainerView = PillView()
             backgroundContainerView.isUserInteractionEnabled = false
diff --git a/SignalUI/Views/TextAttachmentView.swift b/SignalUI/Views/TextAttachmentView.swift
index 0be94bb6b37..5b588bbdcdd 100644
--- a/SignalUI/Views/TextAttachmentView.swift
+++ b/SignalUI/Views/TextAttachmentView.swift
@@ -6,121 +6,250 @@ import Foundation
 import UIKit
 import SignalServiceKit
 
-public class TextAttachmentView: UIView {
-    private(set) weak var linkPreviewView: UIView?
-    private let textAttachment: TextAttachment
+open class TextAttachmentView: UIView {
 
-    public init(attachment: TextAttachment) {
-        self.textAttachment = attachment
+    private var textAttachment: TextAttachment?
 
-        super.init(frame: .zero)
+    public let contentLayoutGuide = UILayoutGuide()
 
-        switch attachment.background {
-        case .color(let color):
-            backgroundColor = color
-        case .gradient(let gradient):
-            addGradientBackground(gradient)
-        }
+    convenience public init(attachment: TextAttachment) {
+        self.init(
+            text: attachment.text,
+            textStyle: attachment.textStyle,
+            textForegroundColor: attachment.textForegroundColor,
+            textBackgroundColor: attachment.textBackgroundColor,
+            background: attachment.background,
+            linkPreview: attachment.preview
+        )
+        self.textAttachment = attachment
+    }
 
-        let contentStackView = UIStackView()
-        contentStackView.axis = .vertical
-        contentStackView.alignment = .center
-        contentStackView.spacing = 16
-        addSubview(contentStackView)
-        contentStackView.autoPinEdgesToSuperviewEdges()
-
-        if let text = attachment.text {
-            let label = UILabel()
-            label.numberOfLines = 0
-            label.textColor = attachment.textForegroundColor ?? Theme.darkThemePrimaryColor
-            label.text = transformedText(text, for: attachment.textStyle)
-            label.textAlignment = .center
-            label.font = font(for: attachment.textStyle)
-            label.adjustsFontSizeToFitWidth = true
-            label.minimumScaleFactor = 0.2
-
-            if let textBackgroundColor = attachment.textBackgroundColor {
-                let labelBackgroundView = UIView()
-                labelBackgroundView.layoutMargins = UIEdgeInsets(hMargin: 16, vMargin: 16)
-                labelBackgroundView.backgroundColor = textBackgroundColor
-                labelBackgroundView.layer.cornerRadius = 18
-
-                labelBackgroundView.addSubview(label)
-                label.autoPinEdgesToSuperviewMargins()
-
-                let labelWrapper = UIView()
-                labelWrapper.addSubview(labelBackgroundView)
-                labelBackgroundView.autoPinWidthToSuperview(withMargin: 24)
-                labelBackgroundView.autoPinHeightToSuperview()
-                contentStackView.addArrangedSubview(labelWrapper)
-            } else {
-                let labelWrapper = UIView()
-                labelWrapper.addSubview(label)
-                label.autoPinWidthToSuperview(withMargin: 40)
-                label.autoPinHeightToSuperview()
-                contentStackView.addArrangedSubview(labelWrapper)
-            }
-        }
+    public init(
+        text: String?,
+        textStyle: TextAttachment.TextStyle,
+        textForegroundColor: UIColor?,
+        textBackgroundColor: UIColor?,
+        background: TextAttachment.Background,
+        linkPreview: OWSLinkPreview?
+    ) {
+        self.text = text
+        self.textStyle = textStyle
+        self.textForegroundColor = textForegroundColor ?? Theme.darkThemePrimaryColor
+        self.textBackgroundColor = textBackgroundColor
+        self.background = background
 
-        if let linkPreview = attachment.preview {
+        super.init(frame: .zero)
+
+        addLayoutGuide(contentLayoutGuide)
+        let constraints = [
+            contentLayoutGuide.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 24),
+            contentLayoutGuide.topAnchor.constraint(equalTo: topAnchor, constant: 20),
+            contentLayoutGuide.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -24),
+            contentLayoutGuide.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -20)
+        ]
+        constraints.forEach { $0.priority = .defaultHigh }
+        addConstraints(constraints)
+
+        if let linkPreview = linkPreview {
             var attachment: TSAttachment?
             if let imageAttachmentId = linkPreview.imageAttachmentId {
                 attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: imageAttachmentId, transaction: $0) })
             }
-            let linkPreviewView = LinkPreviewView(linkPreview: LinkPreviewSent(linkPreview: linkPreview,
-                                                                               imageAttachment: attachment,
-                                                                               conversationStyle: nil))
-            let previewWrapper = UIView()
-            previewWrapper.addSubview(linkPreviewView)
-            linkPreviewView.autoPinWidthToSuperview(withMargin: 36)
-            linkPreviewView.autoPinHeightToSuperview()
-            contentStackView.addArrangedSubview(previewWrapper)
-            self.linkPreviewView = linkPreviewView
+            self.linkPreview = LinkPreviewSent(
+                linkPreview: linkPreview,
+                imageAttachment: attachment,
+                conversationStyle: nil
+            )
         }
 
-        // Keep content vertically centered, but limit to screen size.
-        let topSpacer = UIView.vStretchingSpacer()
-        let bottomSpacer = UIView.vStretchingSpacer()
-        contentStackView.insertArrangedSubview(topSpacer, at: 0)
-        contentStackView.addArrangedSubview(bottomSpacer)
-        topSpacer.autoMatch(.height, to: .height, of: bottomSpacer)
+        updateTextAttributes()
+        reloadLinkPreviewAppearance()
+        updateBackground()
     }
 
     public func asThumbnailView() -> TextAttachmentThumbnailView { TextAttachmentThumbnailView(self) }
 
-    public var isPresentingLinkTooltip: Bool { linkPreviewTooltipView != nil }
+    required public init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
 
-    private var linkPreviewTooltipView: LinkPreviewTooltipView?
-    public func willHandleTapGesture(_ gesture: UITapGestureRecognizer) -> Bool {
-        if let linkPreviewTooltipView = linkPreviewTooltipView {
-            if let container = linkPreviewTooltipView.superview,
-               linkPreviewTooltipView.frame.contains(gesture.location(in: container)) {
-                CurrentAppContext().open(linkPreviewTooltipView.url)
-            } else {
-                linkPreviewTooltipView.removeFromSuperview()
-                self.linkPreviewTooltipView = nil
+    public enum LayoutConstants {
+        public static let textBackgroundHMargin: CGFloat = 16
+        public static let textBackgroundVMargin: CGFloat = 16
+        public static let textBackgroundCornerRadius: CGFloat = 18
+        public static let linkPreviewAreaTopMargin: CGFloat = 8
+        public static let linkPreviewHMargin: CGFloat = 12
+        public static let linkPreviewVMargin: CGFloat = 20
+    }
+
+    open var isEditing: Bool { false }
+
+    public private(set) var textContentSize: CGSize = .zero
+
+    public override func layoutSubviews() {
+        super.layoutSubviews()
+
+        // Resize link preview view to its desired size.
+        if let linkPreviewView = linkPreviewView {
+            let linkPreviewMaxSize = contentLayoutGuide.layoutFrame.inset(by: linkPreviewWrapperView.layoutMargins).size
+            let linkPreviewSize = linkPreviewView.systemLayoutSizeFitting(
+                linkPreviewMaxSize,
+                withHorizontalFittingPriority: .required,
+                verticalFittingPriority: .fittingSizeLevel
+            )
+
+            linkPreviewWrapperView.bounds.size = CGSize(
+                width: linkPreviewSize.width + 2 * LayoutConstants.linkPreviewHMargin,
+                height: linkPreviewSize.height + 2 * LayoutConstants.linkPreviewVMargin
+            )
+            linkPreviewView.frame = linkPreviewWrapperView.bounds.insetBy(
+                dx: LayoutConstants.linkPreviewHMargin,
+                dy: LayoutConstants.linkPreviewVMargin
+            )
+        }
+
+        textContentSize = calculateTextContentSize()
+
+        // If link preview view has "regular" (tall) layout and there's no enough vertical space for both link and text,
+        // we force "compact" layout for the link preview and trigger a new layout pass.
+        if let linkPreviewView = linkPreviewView, linkPreviewView.layout == .regular, textContentSize.height > 0 {
+            let contentHeight = textContentSize.height + LayoutConstants.linkPreviewAreaTopMargin + linkPreviewWrapperView.frame.height
+            if contentHeight > contentLayoutGuide.layoutFrame.height {
+                forceCompactLayoutForLinkPreview = true
+                reloadLinkPreviewAppearance()
+                return
             }
+        }
 
-            return true
-        } else if let linkPreviewView = linkPreviewView,
-                  let urlString = textAttachment.preview?.urlString,
-                  let container = linkPreviewView.superview,
-                  linkPreviewView.frame.contains(gesture.location(in: container)) {
-            let tooltipView = LinkPreviewTooltipView(
-                fromView: self,
-                tailReferenceView: linkPreviewView,
-                url: URL(string: urlString)!
+        layoutTextContentAndLinkPreview()
+    }
+
+    open func layoutTextContentAndLinkPreview() {
+        var maxTextAreaHeight = contentLayoutGuide.layoutFrame.height
+        var linkPreviewAreaHeight: CGFloat = 0
+        if linkPreviewView != nil {
+            linkPreviewAreaHeight = linkPreviewWrapperView.frame.height
+            maxTextAreaHeight -= (linkPreviewAreaHeight + LayoutConstants.linkPreviewAreaTopMargin)
+        }
+
+        var textAreaHeight: CGFloat = 0
+
+        // Position text and/or link preview.
+        if let textLabel = textLabel, textContentSize.height > 0 {
+            textLabel.bounds.size = textContentSize
+
+            let cappedTextContentHeight = min(textContentSize.height, maxTextAreaHeight - 2 * LayoutConstants.textBackgroundVMargin)
+            let scaleFactor = min(1, cappedTextContentHeight / textContentSize.height)
+            textLabel.transform = CGAffineTransform.scale(scaleFactor)
+
+            let verticalOffset = linkPreviewAreaHeight > 0 ? 0.5 * (linkPreviewAreaHeight + LayoutConstants.linkPreviewAreaTopMargin) : 0
+            textLabel.center = CGPoint(
+                x: contentLayoutGuide.layoutFrame.center.x,
+                y: contentLayoutGuide.layoutFrame.center.y - verticalOffset
             )
-            self.linkPreviewTooltipView = tooltipView
+            if let textBackgroundView = textBackgroundView {
+                textBackgroundView.frame = convert(textLabel.bounds, from: textLabel).insetBy(
+                    dx: -LayoutConstants.textBackgroundHMargin,
+                    dy: -LayoutConstants.textBackgroundVMargin
+                )
+            }
 
-            return true
+            textAreaHeight = cappedTextContentHeight + 2 * LayoutConstants.textBackgroundVMargin
         }
+        if linkPreviewView != nil {
+            let verticalOffset = textAreaHeight > 0 ? 0.5 * (textAreaHeight + LayoutConstants.linkPreviewAreaTopMargin) : 0
+            linkPreviewWrapperView.center = CGPoint(
+                x: contentLayoutGuide.layoutFrame.center.x,
+                y: contentLayoutGuide.layoutFrame.center.y + verticalOffset
+            )
+        }
+    }
 
-        return false
+    open func calculateTextContentSize() -> CGSize {
+        guard let textLabel = textLabel else {
+            return .zero
+        }
+
+        let maxTextLabelSize = contentLayoutGuide.layoutFrame.insetBy(
+            dx: LayoutConstants.textBackgroundHMargin,
+            dy: LayoutConstants.textBackgroundVMargin
+        ).size
+        return textLabel.systemLayoutSizeFitting(
+            maxTextLabelSize,
+            withHorizontalFittingPriority: .required,
+            verticalFittingPriority: .fittingSizeLevel
+        )
     }
 
-    required init?(coder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
+    // MARK: - Attributes
+
+    public var text: String? {
+        didSet { updateTextAttributes() }
+    }
+
+    public var textStyle: TextAttachment.TextStyle = .regular {
+        didSet { updateTextAttributes() }
+    }
+
+    public private(set) var textForegroundColor: UIColor = Theme.darkThemePrimaryColor
+
+    public private(set) var textBackgroundColor: UIColor?
+
+    public func setTextForegroundColor(_ textForegroundColor: UIColor, backgroundColor: UIColor?) {
+        self.textForegroundColor = textForegroundColor
+        self.textBackgroundColor = backgroundColor
+        updateTextAttributes()
+    }
+
+    // MARK: - Text
+
+    public func sizeAndAlignment(forText text: String) -> (fontPointSize: CGFloat, textAlignment: NSTextAlignment) {
+        switch text.count {
+        case ..<50: return (34, .center)
+        case 50...199: return (24, .center)
+        default: return (18, .natural)
+        }
+    }
+
+    public func updateTextAttributes() {
+        defer { updateVisibilityOfComponents(animated: false) }
+
+        guard let text = text else { return }
+
+        var textLabel: UILabel
+        if let existingLabel = self.textLabel {
+            textLabel = existingLabel
+        } else {
+            textLabel = UILabel()
+            textLabel.adjustsFontSizeToFitWidth = true
+            textLabel.allowsDefaultTighteningForTruncation = true
+            textLabel.lineBreakMode = .byWordWrapping
+            textLabel.minimumScaleFactor = 0.2
+            textLabel.numberOfLines = 0
+            addSubview(textLabel)
+            self.textLabel = textLabel
+        }
+
+        let (fontPointSize, textAlignment) = sizeAndAlignment(forText: text)
+        textLabel.text = transformedText(text, for: textStyle)
+        textLabel.textAlignment = textAlignment
+        textLabel.font = font(for: textStyle, withPointSize: fontPointSize)
+        textLabel.textColor = textForegroundColor
+
+        if let textBackgroundColor = textBackgroundColor {
+            var textBackgroundView: UIView
+            if let existingBackgroundView = self.textBackgroundView {
+                textBackgroundView = existingBackgroundView
+            } else {
+                textBackgroundView = UIView()
+                textBackgroundView.layer.cornerRadius = LayoutConstants.textBackgroundCornerRadius
+                insertSubview(textBackgroundView, belowSubview: textLabel)
+                self.textBackgroundView = textBackgroundView
+            }
+            textBackgroundView.backgroundColor = textBackgroundColor
+        }
+
+        setNeedsLayout()
     }
 
     private func transformedText(_ text: String, for textStyle: TextAttachment.TextStyle) -> String {
@@ -128,7 +257,7 @@ public class TextAttachmentView: UIView {
         return text.uppercased()
     }
 
-    private func font(for textStyle: TextAttachment.TextStyle) -> UIFont {
+    public func font(for textStyle: TextAttachment.TextStyle, withPointSize pointSize: CGFloat) -> UIFont {
         let attributes: [UIFontDescriptor.AttributeName: Any]
 
         switch textStyle {
@@ -152,27 +281,147 @@ public class TextAttachmentView: UIView {
         // the built in OS fallbacks that don't tend to match the desired style.
         let descriptor = UIFontDescriptor(fontAttributes: attributes)
 
-        return UIFont(descriptor: descriptor, size: 28)
+        return UIFont(descriptor: descriptor, size: pointSize)
+    }
+
+    open func updateVisibilityOfComponents(animated: Bool) {
+        let isEditing = isEditing
+        if text != nil {
+            textLabel?.setIsHidden(isEditing, animated: animated)
+            textBackgroundView?.setIsHidden(isEditing || textBackgroundColor == nil, animated: animated)
+        } else {
+            textLabel?.setIsHidden(true, animated: animated)
+            textBackgroundView?.setIsHidden(true, animated: animated)
+        }
+    }
+
+    public private(set) var textLabel: UILabel?
+
+    public private(set) var textBackgroundView: UIView?
+
+    // MARK: - Background
+
+    public var background: TextAttachment.Background {
+        didSet { updateBackground() }
+    }
+
+    private var gradientView: GradientView?
+
+    private func updateBackground() {
+        switch background {
+        case .color(let color):
+            if let gradientView = gradientView {
+                gradientView.isHidden = true
+            }
+            backgroundColor = color
+
+        case .gradient(let gradient):
+            var gradientView: GradientView
+            if let existingGradientView = self.gradientView {
+                gradientView = existingGradientView
+            } else {
+                gradientView = GradientView(colors: [])
+                insertSubview(gradientView, at: 0)
+                gradientView.autoPinEdgesToSuperviewEdges()
+                self.gradientView = gradientView
+            }
+            gradientView.isHidden = false
+            gradientView.colors = gradient.colors
+            gradientView.locations = gradient.locations
+            gradientView.setAngle(gradient.angle)
+        }
+    }
+
+    // MARK: - Link Preview
+
+    public var linkPreview: LinkPreviewState? {
+        didSet { reloadLinkPreviewAppearance() }
     }
 
-    private func addGradientBackground(_ gradient: TextAttachment.Background.Gradient) {
-        let gradientView = GradientView(colors: gradient.colors, locations: gradient.locations)
-        gradientView.setAngle(gradient.angle)
+    public private(set) var linkPreviewView: LinkPreviewView?
+
+    public private(set) lazy var linkPreviewWrapperView = UIView()
 
-        addSubview(gradientView)
-        gradientView.autoPinEdgesToSuperviewEdges()
+    private var forceCompactLayoutForLinkPreview = false
+
+    private func shouldUseCompactLayoutForLinkPreview() -> Bool {
+        if let text = text, text.count >= 50 { return true }
+        return forceCompactLayoutForLinkPreview
     }
 
+    open func reloadLinkPreviewAppearance() {
+        if let linkPreviewView = linkPreviewView {
+            linkPreviewView.removeFromSuperview()
+            self.linkPreviewView = nil
+        }
+
+        defer {
+            setNeedsLayout()
+        }
+
+        guard let linkPreview = linkPreview else {
+            linkPreviewWrapperView.isHidden = true
+            return
+        }
+
+        if linkPreviewWrapperView.superview == nil {
+            addSubview(linkPreviewWrapperView)
+        }
+        linkPreviewWrapperView.isHidden = false
+
+        let linkPreviewView = TextAttachmentView.LinkPreviewView(
+            linkPreview: linkPreview,
+            forceCompactSize: shouldUseCompactLayoutForLinkPreview()
+        )
+        linkPreviewWrapperView.addSubview(linkPreviewView)
+        self.linkPreviewView = linkPreviewView
+    }
+
+    public var isPresentingLinkTooltip: Bool { linkPreviewTooltipView != nil }
+
+    private var linkPreviewTooltipView: LinkPreviewTooltipView?
+
+    public func willHandleTapGesture(_ gesture: UITapGestureRecognizer) -> Bool {
+        if let linkPreviewTooltipView = linkPreviewTooltipView {
+            if let container = linkPreviewTooltipView.superview,
+               linkPreviewTooltipView.frame.contains(gesture.location(in: container)) {
+                CurrentAppContext().open(linkPreviewTooltipView.url)
+            } else {
+                linkPreviewTooltipView.removeFromSuperview()
+                self.linkPreviewTooltipView = nil
+            }
+
+            return true
+        } else if let linkPreviewView = linkPreviewView,
+                  let urlString = textAttachment?.preview?.urlString,
+                  let container = linkPreviewView.superview,
+                  linkPreviewView.frame.contains(gesture.location(in: container)) {
+            let tooltipView = LinkPreviewTooltipView(
+                fromView: self,
+                tailReferenceView: linkPreviewView,
+                url: URL(string: urlString)!
+            )
+            self.linkPreviewTooltipView = tooltipView
+
+            return true
+        }
+
+        return false
+    }
+
+    // MARK: - LinkPreviewView
+
     public class LinkPreviewView: UIStackView {
 
-        private enum Layout {
+        public enum Layout {
             case regular
             case compact
             case draft
             case domainOnly
         }
+        public private(set) var layout: Layout = .regular
 
-        public init(linkPreview: LinkPreviewState, isDraft: Bool = false) {
+        public init(linkPreview: LinkPreviewState, isDraft: Bool = false, forceCompactSize: Bool = false) {
             super.init(frame: .zero)
 
             let backgroundColor: UIColor = isDraft ? Theme.darkThemeTableView2PresentedBackgroundColor : .ows_gray02
@@ -181,7 +430,13 @@ public class TextAttachmentView: UIView {
             let title = linkPreview.title()
             let description = linkPreview.previewDescription()
             let hasTitleOrDescription = title != nil || description != nil
-            var layout: Layout = isDraft ? .draft : (hasTitleOrDescription ? .regular : .domainOnly)
+            if isDraft {
+                layout = .draft
+            } else if hasTitleOrDescription {
+                layout = forceCompactSize ? .compact : .regular
+            } else {
+                layout = .domainOnly
+            }
 
             let thumbnailImageView = UIImageView()
             thumbnailImageView.clipsToBounds = true
