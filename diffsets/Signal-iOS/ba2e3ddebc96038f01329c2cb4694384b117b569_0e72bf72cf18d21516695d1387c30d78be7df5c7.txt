diff --git a/Signal/src/ViewControllers/HomeView/ConversationSearchViewController.swift b/Signal/src/ViewControllers/HomeView/ConversationSearchViewController.swift
index 18d34c7db98..b359c380cd9 100644
--- a/Signal/src/ViewControllers/HomeView/ConversationSearchViewController.swift
+++ b/Signal/src/ViewControllers/HomeView/ConversationSearchViewController.swift
@@ -248,10 +248,26 @@ public class ConversationSearchViewController: UITableViewController {
                 owsFailDebug("Missing configuration.")
                 return UITableView.automaticDimension
             }
-            return HomeViewCell.measureCellHeight(configuration: configuration)
+            let cellContentToken = cellContentToken(forConfiguration: configuration)
+            return HomeViewCell.measureCellHeight(cellContentToken: cellContentToken)
         }
     }
 
+    private func cellContentToken(forConfiguration configuration: HomeViewCell.Configuration) -> HVCellContentToken {
+        AssertIsOnMainThread()
+
+        // If we have an existing HVCellContentToken, use it.
+        // Cell measurement/arrangement is expensive.
+        let cacheKey = configuration.thread.threadRecord.uniqueId
+        if let cellContentToken = cellContentCache.get(key: cacheKey) {
+            return cellContentToken
+        }
+
+        let cellContentToken = HomeViewCell.buildCellContentToken(forConfiguration: configuration)
+        cellContentCache.set(key: cacheKey, value: cellContentToken)
+        return cellContentToken
+    }
+
     public override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
 
         guard let searchSection = SearchSection(rawValue: indexPath.section) else {
@@ -297,7 +313,8 @@ public class ConversationSearchViewController: UITableViewController {
                 owsFailDebug("Missing configuration.")
                 return UITableViewCell()
             }
-            cell.configure(configuration: configuration)
+            let cellContentToken = cellContentToken(forConfiguration: configuration)
+            cell.configure(cellContentToken: cellContentToken)
             return cell
         }
     }
@@ -311,7 +328,6 @@ public class ConversationSearchViewController: UITableViewController {
             }
             return self.lastReloadDate
         }()
-        let cellContentCache = self.cellContentCache
 
         switch searchSection {
         case .noResults:
@@ -325,8 +341,7 @@ public class ConversationSearchViewController: UITableViewController {
             return HomeViewCell.Configuration(
                 thread: searchResult.thread,
                 lastReloadDate: lastReloadDate,
-                isBlocked: isBlocked(thread: searchResult.thread),
-                cellContentCache: cellContentCache
+                isBlocked: isBlocked(thread: searchResult.thread)
             )
         case .groupThreads:
             guard let searchResult = self.searchResultSet.groupThreads[safe: row] else {
@@ -338,8 +353,7 @@ public class ConversationSearchViewController: UITableViewController {
                 lastReloadDate: lastReloadDate,
                 isBlocked: isBlocked(thread: searchResult.thread),
                 overrideSnippet: searchResult.matchedMembersSnippet?.styled(with: Self.matchSnippetStyle),
-                overrideDate: nil,
-                cellContentCache: cellContentCache
+                overrideDate: nil
             )
         case .contacts:
             owsFailDebug("Invalid section.")
@@ -373,8 +387,7 @@ public class ConversationSearchViewController: UITableViewController {
                 lastReloadDate: lastReloadDate,
                 isBlocked: isBlocked(thread: searchResult.thread),
                 overrideSnippet: overrideSnippet,
-                overrideDate: overrideDate,
-                cellContentCache: cellContentCache
+                overrideDate: overrideDate
             )
         }
     }
diff --git a/Signal/src/ViewControllers/HomeView/HVTableDataSource.swift b/Signal/src/ViewControllers/HomeView/HVTableDataSource.swift
index e2f671880c3..259a999e52c 100644
--- a/Signal/src/ViewControllers/HomeView/HVTableDataSource.swift
+++ b/Signal/src/ViewControllers/HomeView/HVTableDataSource.swift
@@ -69,6 +69,122 @@ extension HVTableDataSource {
     }
 }
 
+// MARK: - UIScrollViewDelegate
+
+extension HVTableDataSource: UIScrollViewDelegate {
+
+    public func scrollViewDidScroll(_ scrollView: UIScrollView) {
+        AssertIsOnMainThread()
+
+        Logger.verbose("----")
+
+        preloadCellsIfNecessary()
+    }
+
+    private func preloadCellsIfNecessary() {
+        AssertIsOnMainThread()
+
+        guard let viewController = self.viewController else {
+            owsFailDebug("Missing viewController.")
+            return
+        }
+        let newContentOffset = tableView.contentOffset
+        defer {
+            viewController.lastKnownTableViewContentOffset = newContentOffset
+        }
+        guard let oldContentOffset = viewController.lastKnownTableViewContentOffset else {
+            return
+        }
+        let deltaY = (newContentOffset - oldContentOffset).y
+        let isScrollingDownward = deltaY > 0
+
+        Logger.verbose("---- deltaY: \(deltaY), isScrollingDownward: \(isScrollingDownward), ")
+        guard let visibleIndexPaths = tableView.indexPathsForVisibleRows else {
+            owsFailDebug("Missing visibleIndexPaths.")
+            return
+        }
+        let conversationIndexPaths = visibleIndexPaths.compactMap { indexPath -> IndexPath? in
+            guard let section = HomeViewSection(rawValue: indexPath.section) else {
+                owsFailDebug("Invalid section: \(indexPath.section).")
+                return nil
+            }
+
+            switch section {
+            case .reminders:
+                return nil
+            case .pinned, .unpinned:
+                return indexPath
+            case .archiveButton:
+                return nil
+            }
+        }
+        guard !conversationIndexPaths.isEmpty else {
+            return
+        }
+        let sortedIndexPaths = conversationIndexPaths.sorted()
+        var indexPathsToPreload = [IndexPath]()
+        func tryToEnqueue(_ indexPath: IndexPath) {
+            let rowCount = numberOfRows(inSection: indexPath.section)
+            guard indexPath.row >= 0,
+                  indexPath.row < rowCount else {
+                return
+            }
+            indexPathsToPreload.append(indexPath)
+        }
+
+        if isScrollingDownward {
+            guard let lastIndexPath = sortedIndexPaths.last else {
+                owsFailDebug("Missing indexPath.")
+                return
+            }
+            Logger.verbose("---- lastIndexPath: \(lastIndexPath), ")
+            // Order matters; we want to preload in order of proximity
+            // to viewport.
+            tryToEnqueue(IndexPath(row: lastIndexPath.row + 1,
+                                   section: lastIndexPath.section))
+            tryToEnqueue(IndexPath(row: lastIndexPath.row + 2,
+                                   section: lastIndexPath.section))
+            tryToEnqueue(IndexPath(row: lastIndexPath.row + 3,
+                                   section: lastIndexPath.section))
+        } else {
+            guard let firstIndexPath = sortedIndexPaths.first else {
+                owsFailDebug("Missing indexPath.")
+                return
+            }
+            guard firstIndexPath.row > 0 else {
+                return
+            }
+            Logger.verbose("---- firstIndexPath: \(firstIndexPath), ")
+            // Order matters; we want to preload in order of proximity
+            // to viewport.
+            tryToEnqueue(IndexPath(row: firstIndexPath.row - 1,
+                                   section: firstIndexPath.section))
+            tryToEnqueue(IndexPath(row: firstIndexPath.row - 2,
+                                   section: firstIndexPath.section))
+            tryToEnqueue(IndexPath(row: firstIndexPath.row - 3,
+                                   section: firstIndexPath.section))
+        }
+        Logger.verbose("---- sortedIndexPaths: \(sortedIndexPaths), ")
+
+        for indexPath in indexPathsToPreload {
+            Logger.verbose("---- indexPathToPreload: \(indexPath), ")
+
+            preloadCellIfNecessaryAsync(indexPath: indexPath)
+        }
+    }
+
+    public func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
+        AssertIsOnMainThread()
+
+        guard let viewController = viewController else {
+            owsFailDebug("Missing viewController.")
+            return
+        }
+
+        viewController.dismissSearchKeyboard()
+    }
+}
+
 // MARK: -
 
 @objc
@@ -320,6 +436,12 @@ extension HVTableDataSource: UITableViewDataSource {
     public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
         AssertIsOnMainThread()
 
+        return numberOfRows(inSection: section)
+    }
+
+    fileprivate func numberOfRows(inSection section: Int) -> Int {
+        AssertIsOnMainThread()
+
         guard let viewController = self.viewController else {
             owsFailDebug("Missing viewController.")
             return 0
@@ -396,26 +518,32 @@ extension HVTableDataSource: UITableViewDataSource {
     private func measureConversationCell(tableView: UITableView, indexPath: IndexPath) -> CGFloat {
         AssertIsOnMainThread()
 
-        guard let configuration = cellConfiguration(forIndexPath: indexPath) else {
-            owsFailDebug("Missing configuration.")
+        Logger.verbose("---- measureConversationCell 1: \(indexPath)")
+
+        guard let cellConfigurationAndContentToken = buildCellConfigurationAndContentTokenSync(forIndexPath: indexPath) else {
+            owsFailDebug("Missing cellConfigurationAndContentToken.")
             return UITableView.automaticDimension
         }
-        return HomeViewCell.measureCellHeight(configuration: configuration)
+        return HomeViewCell.measureCellHeight(cellContentToken: cellConfigurationAndContentToken.contentToken)
     }
 
     private func buildConversationCell(tableView: UITableView, indexPath: IndexPath) -> UITableViewCell {
         AssertIsOnMainThread()
 
+        Logger.verbose("---- buildConversationCell 1: \(indexPath)")
+
         guard let cell = tableView.dequeueReusableCell(withIdentifier: HomeViewCell.reuseIdentifier) as? HomeViewCell else {
             owsFailDebug("Invalid cell.")
             return UITableViewCell()
         }
-        guard let configuration = cellConfiguration(forIndexPath: indexPath) else {
-            owsFailDebug("Missing configuration.")
+        guard let cellConfigurationAndContentToken = buildCellConfigurationAndContentTokenSync(forIndexPath: indexPath) else {
+            owsFailDebug("Missing cellConfigurationAndContentToken.")
             return UITableViewCell()
         }
+        let configuration = cellConfigurationAndContentToken.configuration
+        let contentToken = cellConfigurationAndContentToken.contentToken
 
-        cell.configure(configuration: configuration)
+        cell.configure(cellContentToken: contentToken)
 
         let thread = configuration.thread.threadRecord
         let cellName: String = {
@@ -439,34 +567,6 @@ extension HVTableDataSource: UITableViewDataSource {
         return cell
     }
 
-    private func cellConfiguration(forIndexPath indexPath: IndexPath) -> HomeViewCell.Configuration? {
-        AssertIsOnMainThread()
-
-        guard let threadViewModel = threadViewModel(forIndexPath: indexPath) else {
-            owsFailDebug("Missing threadViewModel.")
-            return nil
-        }
-        guard let viewController = self.viewController else {
-            owsFailDebug("Missing viewController.")
-            return nil
-        }
-
-        let lastReloadDate: Date? = {
-            guard viewState.hasEverAppeared else {
-                return nil
-            }
-            return self.lastReloadDate
-        }()
-        owsAssertDebug(threadViewModel.homeViewInfo != nil)
-        let isBlocked = threadViewModel.homeViewInfo?.isBlocked == true
-        let cellContentCache = viewController.cellContentCache
-        let configuration = HomeViewCell.Configuration(thread: threadViewModel,
-                                                       lastReloadDate: lastReloadDate,
-                                                       isBlocked: isBlocked,
-                                                       cellContentCache: cellContentCache)
-        return configuration
-    }
-
     private func isConversationActive(forThread thread: TSThread) -> Bool {
         AssertIsOnMainThread()
 
@@ -710,6 +810,140 @@ extension HVTableDataSource: UITableViewDataSource {
 
 // MARK: -
 
+extension HVTableDataSource {
+
+    fileprivate struct HVCellConfigurationAndContentToken {
+        let configuration: HomeViewCell.Configuration
+        let contentToken: HVCellContentToken
+    }
+
+    // This method can be called from any thread.
+    private static func buildCellConfiguration(threadViewModel: ThreadViewModel,
+                                               lastReloadDate: Date?) -> HomeViewCell.Configuration {
+        owsAssertDebug(threadViewModel.homeViewInfo != nil)
+
+        let isBlocked = threadViewModel.homeViewInfo?.isBlocked == true
+        let configuration = HomeViewCell.Configuration(thread: threadViewModel,
+                                                       lastReloadDate: lastReloadDate,
+                                                       isBlocked: isBlocked)
+        return configuration
+    }
+
+    fileprivate func buildCellConfigurationAndContentTokenSync(forIndexPath indexPath: IndexPath) -> HVCellConfigurationAndContentToken? {
+        AssertIsOnMainThread()
+
+        guard let threadViewModel = threadViewModel(forIndexPath: indexPath) else {
+            owsFailDebug("Missing threadViewModel.")
+            return nil
+        }
+        guard let viewController = self.viewController else {
+            owsFailDebug("Missing viewController.")
+            return nil
+        }
+        let lastReloadDate: Date? = {
+            guard viewState.hasEverAppeared else {
+                return nil
+            }
+            return self.lastReloadDate
+        }()
+        let configuration = Self.buildCellConfiguration(threadViewModel: threadViewModel,
+                                                        lastReloadDate: lastReloadDate)
+        let cellContentCache = viewController.cellContentCache
+        let contentToken = { () -> HVCellContentToken in
+            // If we have an existing HVCellContentToken, use it.
+            // Cell measurement/arrangement is expensive.
+            let cacheKey = configuration.thread.threadRecord.uniqueId
+            if let cellContentToken = cellContentCache.get(key: cacheKey) {
+                return cellContentToken
+            }
+
+            let cellContentToken = HomeViewCell.buildCellContentToken(forConfiguration: configuration)
+            cellContentCache.set(key: cacheKey, value: cellContentToken)
+            return cellContentToken
+        }()
+        return HVCellConfigurationAndContentToken(configuration: configuration,
+                                                  contentToken: contentToken)
+    }
+
+    // TODO: It would be preferable to figure out some way to use ReverseDispatchQueue.
+    private static let preloadSerialQueue = DispatchQueue(label: "HVTableDataSource.preloadSerialQueue")
+
+    fileprivate func preloadCellIfNecessaryAsync(indexPath: IndexPath) {
+        AssertIsOnMainThread()
+
+        Logger.verbose("---- preloadCellIfNecessaryAsync 1: \(indexPath)")
+
+        guard let viewController = self.viewController else {
+            owsFailDebug("Missing viewController.")
+            return
+        }
+        // These caches should only be accessed on the main thread.
+        // They are thread-safe, but we don't want to race with a reset.
+        let cellContentCache = viewController.cellContentCache
+        let threadViewModelCache = viewController.threadViewModelCache
+        // Take note of the cache reset counts. If either cache is reset
+        // before we complete, discard the outcome of the preload.
+        let cellContentCacheResetCount = cellContentCache.resetCount
+        let threadViewModelCacheResetCount = threadViewModelCache.resetCount
+
+        guard let thread = self.thread(forIndexPath: indexPath) else {
+            owsFailDebug("Missing thread.")
+            return
+        }
+        let cacheKey = thread.uniqueId
+        if nil != cellContentCache.get(key: cacheKey) {
+            // If we already have an existing HVCellContentToken, abort.
+            return
+        }
+
+        let lastReloadDate: Date? = {
+            guard viewState.hasEverAppeared else {
+                return nil
+            }
+            return self.lastReloadDate
+        }()
+
+        // We use a serial queue to ensure we don't race and preload the same cell
+        // twice at the same time.
+        firstly(on: Self.preloadSerialQueue) { () -> (ThreadViewModel, HVCellContentToken) in
+            // This is the expensive work we do off the main thread.
+            let threadViewModel = Self.databaseStorage.read { transaction in
+                ThreadViewModel(thread: thread, forHomeView: true, transaction: transaction)
+            }
+            let configuration = Self.buildCellConfiguration(threadViewModel: threadViewModel,
+                                                            lastReloadDate: lastReloadDate)
+            let contentToken = HomeViewCell.buildCellContentToken(forConfiguration: configuration)
+            return (threadViewModel, contentToken)
+        }.done(on: .main) { (threadViewModel: ThreadViewModel,
+                             contentToken: HVCellContentToken) in
+            // Commit the preloaded values to their respective caches.
+            guard cellContentCacheResetCount == cellContentCache.resetCount else {
+                Logger.info("cellContentCache was reset.")
+                return
+            }
+            guard threadViewModelCacheResetCount == threadViewModelCache.resetCount else {
+                Logger.info("cellContentCache was reset.")
+                return
+            }
+            if nil == threadViewModelCache.get(key: cacheKey) {
+                threadViewModelCache.set(key: cacheKey, value: threadViewModel)
+            } else {
+                Logger.info("threadViewModel already loaded.")
+            }
+            if nil == cellContentCache.get(key: cacheKey) {
+                cellContentCache.set(key: cacheKey, value: contentToken)
+            } else {
+                Logger.info("contentToken already loaded.")
+            }
+            Logger.verbose("---- preloadCellIfNecessaryAsync 2: \(indexPath)")
+        }.catch(on: .global()) { error in
+            owsFailDebugUnlessNetworkFailure(error)
+        }
+    }
+}
+
+// MARK: -
+
 public class HVTableView: UITableView {
 
     fileprivate var lastReloadDate: Date?
diff --git a/Signal/src/ViewControllers/HomeView/HVViewState.swift b/Signal/src/ViewControllers/HomeView/HVViewState.swift
index a9b41e4fc9d..4e8244d600d 100644
--- a/Signal/src/ViewControllers/HomeView/HVViewState.swift
+++ b/Signal/src/ViewControllers/HomeView/HVViewState.swift
@@ -31,6 +31,7 @@ public class HVViewState: NSObject {
 
     public var unreadPaymentNotificationsCount: UInt = 0
     public var firstUnreadPaymentModel: TSPaymentModel?
+    public var lastKnownTableViewContentOffset: CGPoint?
 
     // MARK: - Initializer
 
@@ -77,4 +78,10 @@ public extension HomeViewController {
         get { viewState.hasEverAppeared }
         set { viewState.hasEverAppeared = newValue }
     }
+
+    @nonobjc
+    var lastKnownTableViewContentOffset: CGPoint? {
+        get { viewState.lastKnownTableViewContentOffset }
+        set { viewState.lastKnownTableViewContentOffset = newValue }
+    }
 }
diff --git a/Signal/src/ViewControllers/HomeView/HomeViewCell.swift b/Signal/src/ViewControllers/HomeView/HomeViewCell.swift
index a0cf488b069..e0757d10968 100644
--- a/Signal/src/ViewControllers/HomeView/HomeViewCell.swift
+++ b/Signal/src/ViewControllers/HomeView/HomeViewCell.swift
@@ -62,13 +62,21 @@ public class HomeViewCell: UITableViewCell {
 
     // MARK: - Configuration
 
+    // Compare with HVCellContentToken:
+    //
+    // * Configuration captures _how_ the view wants to render the cell.
+    //   HomeViewCell is used by Home view and Home Search view and they
+    //   render cells differently. Configuration reflects that.
+    //   Configuration is cheap to build.
+    // * HVCellContentToken captures (only) the exact content that will
+    //   be rendered in the cell, its measurement/layout, etc.
+    //   HVCellContentToken is expensive to build.
     struct Configuration {
         let thread: ThreadViewModel
         let lastReloadDate: Date?
         let isBlocked: Bool
         let overrideSnippet: NSAttributedString?
         let overrideDate: Date?
-        let cellContentCache: LRUCache<String, HVCellContentToken>
 
         fileprivate var hasOverrideSnippet: Bool {
             overrideSnippet != nil
@@ -81,14 +89,12 @@ public class HomeViewCell: UITableViewCell {
              lastReloadDate: Date?,
              isBlocked: Bool,
              overrideSnippet: NSAttributedString? = nil,
-             overrideDate: Date? = nil,
-             cellContentCache: LRUCache<String, HVCellContentToken>) {
+             overrideDate: Date? = nil) {
             self.thread = thread
             self.lastReloadDate = lastReloadDate
             self.isBlocked = isBlocked
             self.overrideSnippet = overrideSnippet
             self.overrideDate = overrideDate
-            self.cellContentCache = cellContentCache
         }
     }
     private var cellContentToken: HVCellContentToken?
@@ -151,52 +157,18 @@ public class HomeViewCell: UITableViewCell {
         self.selectionStyle = .default
     }
 
-    static func measureCellHeight(configuration: Configuration) -> CGFloat {
-        AssertIsOnMainThread()
-
-        let cellContentToken = Self.cellContentToken(forConfiguration: configuration)
-        return cellContentToken.measurements.outerHStackMeasurement.measuredSize.height
+    // This method can be invoked from any thread.
+    static func measureCellHeight(cellContentToken: HVCellContentToken) -> CGFloat {
+        cellContentToken.measurements.outerHStackMeasurement.measuredSize.height
     }
 
-    func configure(configuration: Configuration) {
-        AssertIsOnMainThread()
-
-        let cellContentToken = Self.cellContentToken(forConfiguration: configuration)
-        configure(cellContentToken: cellContentToken)
-    }
-
-    // Perf matters in home view.  Configuring home view cells is
-    // probably the biggest perf bottleneck.  In conversation view,
-    // we address this by doing cell measurement/arrangement off
-    // the main thread.  That's viable in conversation view because
-    // there's a "load window" so there's an upper bound on how
-    // many cells need to be prepared.
-    //
-    // Home view has no load window.  Therefore, home view defers
-    // the expensive work of a) building ThreadViewModel
-    // b) measurement/arrangement of cells.  threadViewModelCache
-    // caches a).  cellContentCache caches b).
-    //
-    // When configuring a hohome view cell, we reuse any existing
-    // cell measurement in cellContentCache.  If none exists,
-    // we build one and store it in cellContentCache for next
-    // time.
-    private static func cellContentToken(forConfiguration configuration: Configuration) -> HVCellContentToken {
-        let cellContentCache = configuration.cellContentCache
-
-        // If we have an existing HVCellContentToken, use it.
-        // Cell measurement/arrangement is expensive.
-        let cacheKey = configuration.thread.threadRecord.uniqueId
-        if let cellContentToken = cellContentCache.get(key: cacheKey) {
-            return cellContentToken
-        }
-
+    // This method can be invoked from any thread.
+    internal static func buildCellContentToken(forConfiguration configuration: Configuration) -> HVCellContentToken {
         let configs = buildCellConfigs(configuration: configuration)
         let measurements = buildMeasurements(configuration: configuration,
                                              configs: configs)
         let cellContentToken = HVCellContentToken(configs: configs,
                                                   measurements: measurements)
-        cellContentCache.set(key: cacheKey, value: cellContentToken)
         return cellContentToken
     }
 
@@ -304,7 +276,7 @@ public class HomeViewCell: UITableViewCell {
                                   snippetLineHeight: snippetLineHeight)
     }
 
-    private func configure(cellContentToken: HVCellContentToken) {
+    internal func configure(cellContentToken: HVCellContentToken) {
         AssertIsOnMainThread()
 
         OWSTableItem.configureCell(self)
@@ -966,6 +938,34 @@ private struct HVCellMeasurements {
 
 // MARK: -
 
+// Perf matters in home view.  Configuring home view cells is
+// probably the biggest perf bottleneck.  In conversation view,
+// we address this by doing cell measurement/arrangement off
+// the main thread.  That's viable in conversation view because
+// there's a "load window" so there's an upper bound on how
+// many cells need to be prepared.
+//
+// Home view has no load window.  Therefore, home view defers
+// the expensive work of a) building ThreadViewModel
+// b) measurement/arrangement of cells.  threadViewModelCache
+// caches a).  cellContentCache caches b).
+//
+// When configuring a hohome view cell, we reuse any existing
+// cell measurement in cellContentCache.  If none exists,
+// we build one and store it in cellContentCache for next
+// time.
+//
+// These content tokens can be preloaded async.
+//
+// Compare with Configuration:
+//
+// * Configuration captures _how_ the view wants to render the cell.
+//   HomeViewCell is used by Home view and Home Search view and they
+//   render cells differently. Configuration reflects that.
+//   Configuration is cheap to build.
+// * HVCellContentToken captures (only) the exact content that will
+//   be rendered in the cell, its measurement/layout, etc.
+//   HVCellContentToken is expensive to build.
 class HVCellContentToken {
     fileprivate let configs: HVCellConfigs
     fileprivate let measurements: HVCellMeasurements
diff --git a/Signal/src/ViewControllers/HomeView/HomeViewController.m b/Signal/src/ViewControllers/HomeView/HomeViewController.m
index ac03e163022..d418e3c2545 100644
--- a/Signal/src/ViewControllers/HomeView/HomeViewController.m
+++ b/Signal/src/ViewControllers/HomeView/HomeViewController.m
@@ -859,13 +859,6 @@ - (void)scrollSearchBarToTopAnimated:(BOOL)isAnimated
     [self.tableView setContentOffset:CGPointMake(0, -topInset) animated:isAnimated];
 }
 
-#pragma mark - UIScrollViewDelegate
-
-- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView
-{
-    [self dismissSearchKeyboard];
-}
-
 #pragma mark - ConversationSearchViewDelegate
 
 - (void)conversationSearchViewWillBeginDragging
diff --git a/SignalServiceKit/src/Util/LRUCache.swift b/SignalServiceKit/src/Util/LRUCache.swift
index 5771b7fecd9..a6f5549560a 100644
--- a/SignalServiceKit/src/Util/LRUCache.swift
+++ b/SignalServiceKit/src/Util/LRUCache.swift
@@ -65,6 +65,10 @@ public class LRUCache<KeyType: Hashable & Equatable, ValueType> {
 
     private let cache = NSCache<AnyObject, AnyObject>()
     private let maxSize: Int
+    private let _resetCount = AtomicUInt(0)
+    public var resetCount: UInt {
+        _resetCount.get()
+    }
 
     public init(maxSize: Int,
                 nseMaxSize: Int = 0,
@@ -118,6 +122,8 @@ public class LRUCache<KeyType: Hashable & Equatable, ValueType> {
 
     @objc
     public func clear() {
+        _resetCount.increment()
+
         autoreleasepool {
             cache.removeAllObjects()
         }
