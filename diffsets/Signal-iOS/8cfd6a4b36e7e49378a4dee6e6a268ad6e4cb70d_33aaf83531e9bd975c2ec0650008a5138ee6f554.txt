diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index 1be5a27576e..4b9590d66ee 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -836,6 +836,14 @@ extension CVLoadCoordinator: ConversationViewLayoutDelegate {
     public var layoutFooterHeight: CGFloat {
         showLoadNewerHeader ? LoadMoreMessagesView.fixedHeight : 0
     }
+
+    public func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
+        guard let delegate = self.delegate else {
+            owsFailDebug("Missing delegate.")
+            return proposedContentOffset
+        }
+        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+    }
 }
 
 // MARK: -
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index 7b35a0bafaa..690bc330091 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -327,7 +327,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             UIView.performWithoutAnimation {
                 self.collectionView.reloadData()
                 self.collectionView.collectionViewLayout.invalidateLayout()
-                self.collectionView.collectionViewLayout.prepare()
             }
 
             updateViewToReflectLoad(loadedRenderState: self.renderState)
@@ -365,7 +364,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         UIView.performWithoutAnimation {
             self.collectionView.reloadData()
             self.collectionView.collectionViewLayout.invalidateLayout()
-            self.collectionView.collectionViewLayout.prepare()
         }
 
         benchSteps.step("2")
@@ -424,7 +422,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         UIView.performWithoutAnimation {
             self.collectionView.reloadData()
             self.collectionView.collectionViewLayout.invalidateLayout()
-            self.collectionView.collectionViewLayout.prepare()
         }
 
         DispatchQueue.main.async { [weak self] in
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift
index f10c3d3d9ea..46537d1e38c 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift
@@ -25,7 +25,6 @@ extension ConversationViewController {
         // with the updated -contentOffset in -scrollViewDidScroll:. So instead, we'll just see what layoutAttributes
         // are now in the collection view's visible content rect. This should be safe, since it's computed from the
         // already updated -contentOffset.
-        layout.prepare()
         let visibleLayoutAttributes = layout.layoutAttributesForElements(in: visibleContentRect) ?? []
 
         let firstVisibleIndexPath = visibleLayoutAttributes
@@ -33,7 +32,7 @@ extension ConversationViewController {
             .min { $0.row < $1.row }
 
         if let firstVisibleIndexPath = firstVisibleIndexPath {
-             assert(percentOfIndexPathVisibleAboveBottom(firstVisibleIndexPath) > 0)
+//            owsAssertDebug(percentOfIndexPathVisibleAboveBottom(firstVisibleIndexPath) > 0)
         }
         return firstVisibleIndexPath
     }
@@ -49,7 +48,6 @@ extension ConversationViewController {
         // with the updated -contentOffset in -scrollViewDidScroll:. So instead, we'll just see what layoutAttributes
         // are now in the collection view's visible content rect. This should be safe, since it's computed from the
         // already updated -contentOffset.
-        layout.prepare()
         let visibleLayoutAttributes = layout.layoutAttributesForElements(in: visibleContentRect) ?? []
 
         let lastVisibleIndexPath = visibleLayoutAttributes
@@ -58,7 +56,7 @@ extension ConversationViewController {
 
         if let lastVisibleIndexPath = lastVisibleIndexPath {
             // TODO: Fix this assert.
-             assert(percentOfIndexPathVisibleAboveBottom(lastVisibleIndexPath) > 0)
+//            owsAssertDebug(percentOfIndexPathVisibleAboveBottom(lastVisibleIndexPath) > 0)
         }
         return lastVisibleIndexPath
     }
@@ -139,7 +137,6 @@ extension ConversationViewController {
     }
 
     private func percentOfIndexPathVisibleAboveBottom(_ indexPath: IndexPath) -> CGFloat {
-        layout.prepare()
 
         // If we don't have layout attributes, it's not visible
         guard let attributes = layout.layoutAttributesForItem(at: indexPath) else { return 0.0 }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index e15133032da..8bd6d1be861 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -236,7 +236,6 @@ extension ConversationViewController {
         guard !isUserScrolling else { return }
 
         view.layoutIfNeeded()
-        layout.prepare()
 
         guard let attributes = layout.layoutAttributesForItem(at: indexPath) else {
             return owsFailDebug("failed to get attributes for indexPath \(indexPath)")
@@ -556,7 +555,6 @@ extension ConversationViewController {
                                          items: [])
         }
 
-        layout.prepare()
 
         let contentOffset = collectionView.contentOffset
 
@@ -617,7 +615,6 @@ extension ConversationViewController {
         guard let scrollContinuityMap = viewState.scrollContinuityMap else {
             return nil
         }
-        layout.prepare()
 
         var sortIdToIndexPathMap = [UInt64: IndexPath]()
         for (index, renderItem) in renderItems.enumerated() {
@@ -642,7 +639,8 @@ extension ConversationViewController {
                 continue
             }
 
-            guard let layoutAttributes = layout.layoutAttributesForItem(at: indexPath) else {
+            guard let layoutAttributes = layout.layoutAttributesForItem(at: indexPath,
+                                                                        alwaysUseLatestLayout: true) else {
                 owsFailDebug("Missing layoutAttributes.")
                 continue
             }
@@ -679,7 +677,6 @@ extension ConversationViewController {
     private func targetContentOffsetForScrollAction(_ scrollAction: CVScrollAction) -> CGPoint? {
         owsAssertDebug(!scrollAction.isAnimated)
 
-        layout.prepare()
 
         switch scrollAction.action {
         case .bottomOfLoadWindow:
@@ -741,7 +738,6 @@ extension ConversationViewController {
             // This is expected if the menu action interaction is being deleted.
             return nil
         }
-        layout.prepare()
         guard let layoutAttributes = layout.layoutAttributesForItem(at: indexPath) else {
             owsFailDebug("Missing layoutAttributes.")
             return nil
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Selection.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Selection.swift
index d2b7da57261..aa72498f0ed 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Selection.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Selection.swift
@@ -200,8 +200,7 @@ extension ConversationViewController {
             return nil
         }
 
-        layout.prepare()
-        guard let firstFrame = self.layout.layoutAttributesForItem(at: first)?.frame else {
+        guard let firstFrame = layout.layoutAttributesForItem(at: first)?.frame else {
             owsFailDebug("firstFrame was unexpectedly nil")
             return nil
         }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 89ebb252b90..265a6386c3b 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -1840,7 +1840,6 @@ - (nullable NSValue *)targetContentOffsetForMessageActionInteraction
         // This is expected if the menu action interaction is being deleted.
         return nil;
     }
-    [self.layout prepareLayout];
     UICollectionViewLayoutAttributes *_Nullable layoutAttributes =
         [self.layout layoutAttributesForItemAtIndexPath:indexPath];
     if (layoutAttributes == nil) {
@@ -3117,7 +3116,6 @@ - (CGFloat)safeContentHeight
     //
     // We can safely call prepareLayout to ensure the layout state is up-to-date
     // since our layout uses a dirty flag internally to debounce redundant work.
-    [self.layout prepareLayout];
     return [self.collectionView.collectionViewLayout collectionViewContentSize].height;
 }
 
@@ -3753,6 +3751,9 @@ - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
 {
     @try {
         void (^updateBlock)(void) = ^{
+            // Suppress responding to certain events during the updates.
+            self.isPerformingBatchUpdates = YES;
+
             [self.layout willPerformBatchUpdates];
             [self.collectionView
                 performBatchUpdates:^{
@@ -3761,6 +3762,8 @@ - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
                          completion:completion];
             [self.layout didPerformBatchUpdates];
 
+            self.isPerformingBatchUpdates = NO;
+
             // AFAIK the collection view layout should reflect the old layout
             // until performBatchUpdates(), then we need to invalidate and prepare
             // the (new) layout just _after_ performBatchUpdates.
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index 35938e73e21..0bb484bb8c4 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -10,7 +10,6 @@ public protocol ConversationViewLayoutItem {
     var cellSize: CGSize { get }
 
     func vSpacing(previousLayoutItem: ConversationViewLayoutItem) -> CGFloat
-
 }
 
 // MARK: -
@@ -22,6 +21,8 @@ public protocol ConversationViewLayoutDelegate {
 
     var layoutHeaderHeight: CGFloat { get }
     var layoutFooterHeight: CGFloat { get }
+
+    func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint
 }
 
 // MARK: -
@@ -34,13 +35,26 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     private var conversationStyle: ConversationStyle
 
-    private struct LayoutInfo {
+    private class LayoutInfo {
+
         let viewWidth: CGFloat
         let contentSize: CGSize
         let itemAttributesMap: [Int: UICollectionViewLayoutAttributes]
         let headerLayoutAttributes: UICollectionViewLayoutAttributes?
         let footerLayoutAttributes: UICollectionViewLayoutAttributes?
 
+        required init(viewWidth: CGFloat,
+                      contentSize: CGSize,
+                      itemAttributesMap: [Int: UICollectionViewLayoutAttributes],
+                      headerLayoutAttributes: UICollectionViewLayoutAttributes?,
+                      footerLayoutAttributes: UICollectionViewLayoutAttributes?) {
+            self.viewWidth = viewWidth
+            self.contentSize = contentSize
+            self.itemAttributesMap = itemAttributesMap
+            self.headerLayoutAttributes = headerLayoutAttributes
+            self.footerLayoutAttributes = footerLayoutAttributes
+        }
+
         func layoutAttributesForItem(at indexPath: IndexPath, assertIfMissing: Bool) -> UICollectionViewLayoutAttributes? {
             if assertIfMissing {
                 owsAssertDebug(indexPath.row >= 0 && indexPath.row < itemAttributesMap.count)
@@ -105,13 +119,18 @@ public class ConversationViewLayout: UICollectionViewLayout {
     // the initial (last) layout state for items.
     private var lastLayoutInfo: LayoutInfo?
 
+    private var isPerformingBatchUpdates = false
+    private var hasInvalidatedDataSourceCounts = false
+
     @objc
     public func willPerformBatchUpdates() {
         AssertIsOnMainThread()
         owsAssertDebug(currentLayoutInfo != nil)
         owsAssertDebug(lastLayoutInfo == nil)
 
+        isPerformingBatchUpdates = true
         lastLayoutInfo = ensureCurrentLayoutInfo()
+        hasInvalidatedDataSourceCounts = false
         invalidateLayout()
     }
 
@@ -120,7 +139,9 @@ public class ConversationViewLayout: UICollectionViewLayout {
         AssertIsOnMainThread()
         owsAssertDebug(lastLayoutInfo != nil)
 
+        isPerformingBatchUpdates = false
         lastLayoutInfo = nil
+        hasInvalidatedDataSourceCounts = false
     }
 
     @objc
@@ -143,7 +164,6 @@ public class ConversationViewLayout: UICollectionViewLayout {
         self.conversationStyle = conversationStyle
 
         invalidateLayout()
-        prepare()
     }
 
     @objc
@@ -155,6 +175,11 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) {
+
+        if context.invalidateDataSourceCounts {
+            hasInvalidatedDataSourceCounts = true
+        }
+
         super.invalidateLayout(with: context)
 
         clearState()
@@ -210,7 +235,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
         } else {
             let headerIndexPath = IndexPath(row: 0, section: 0)
             let layoutAttributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader,
-                                                                          with: headerIndexPath)
+                                                                    with: headerIndexPath)
 
             layoutAttributes.frame = CGRect(x: 0, y: y, width: viewWidth, height: layoutHeaderHeight)
             headerLayoutAttributes = layoutAttributes
@@ -259,7 +284,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
             // Do nothing.
         } else {
             let layoutAttributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionFooter,
-                                                                          with: footerIndexPath)
+                                                                    with: footerIndexPath)
 
             layoutAttributes.frame = CGRect(x: 0, y: contentBottom, width: viewWidth, height: layoutFooterHeight)
             footerLayoutAttributes = layoutAttributes
@@ -277,7 +302,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
-        let layoutInfo = ensureCurrentLayoutInfo()
+        let layoutInfo = effectiveLayoutInfo
         var result = [UICollectionViewLayoutAttributes]()
         if let headerLayoutAttributes = layoutInfo.headerLayoutAttributes {
             result.append(headerLayoutAttributes)
@@ -291,9 +316,17 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+        layoutAttributesForItem(at: indexPath, alwaysUseLatestLayout: false)
+    }
+
+    @objc
+    public func layoutAttributesForItem(at indexPath: IndexPath,
+                                        alwaysUseLatestLayout: Bool) -> UICollectionViewLayoutAttributes? {
         AssertIsOnMainThread()
 
-        return ensureCurrentLayoutInfo().layoutAttributesForItem(at: indexPath, assertIfMissing: true)
+        let layoutInfo = alwaysUseLatestLayout ? ensureCurrentLayoutInfo() : effectiveLayoutInfo
+
+        return layoutInfo.layoutAttributesForItem(at: indexPath, assertIfMissing: true)
     }
 
     @objc
@@ -301,8 +334,8 @@ public class ConversationViewLayout: UICollectionViewLayout {
                                                               at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
         AssertIsOnMainThread()
 
-        return ensureCurrentLayoutInfo().layoutAttributesForSupplementaryElement(ofKind: elementKind,
-                                                                                 at: indexPath)
+        return effectiveLayoutInfo.layoutAttributesForSupplementaryElement(ofKind: elementKind,
+                                                                           at: indexPath)
     }
 
     @objc
@@ -316,23 +349,71 @@ public class ConversationViewLayout: UICollectionViewLayout {
         return lastViewWidth != newBounds.width
     }
 
-//    // A layout can return the content offset to be applied during transition or update animations.
-//    public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint,
-//                                             withScrollingVelocity velocity: CGPoint) -> CGPoint {
-//        guard let delegate = delegate else {
-//            return super.targetContentOffset(forProposedContentOffset: proposedContentOffset,
-//                                             withScrollingVelocity: velocity)
-//        }
-//        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
-//    }
-//
-//    // A layout can return the content offset to be applied during transition or update animations.
-//    public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
-//        guard let delegate = delegate else {
-//            return super.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+    private var effectiveLayoutInfo: LayoutInfo {
+        if isPerformingBatchUpdates, !hasInvalidatedDataSourceCounts {
+            if let lastLayoutInfo = self.lastLayoutInfo {
+                return lastLayoutInfo
+            } else {
+                owsFailDebug("Missing lastLayoutInfo.")
+            }
+        }
+
+        return ensureCurrentLayoutInfo()
 //        }
-//        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
-//    }
+    }
+
+    // This method is called when there is an update with deletes/inserts to the collection view.
+    //
+    // It will be called prior to calling the initial/final layout attribute methods below to give
+    // the layout an opportunity to do batch computations for the insertion and deletion layout attributes.
+    //
+    // The updateItems parameter is an array of UICollectionViewUpdateItem instances for each
+    // element that is moving to a new index path.
+    public override func prepare(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem]) {
+        super.prepare(forCollectionViewUpdates: updateItems)
+    }
+
+    // Called inside an animation block after the update.
+    public override func finalizeCollectionViewUpdates() {
+        super.finalizeCollectionViewUpdates()
+    }
+
+    // UICollectionView calls this when its bounds have changed inside an
+    // animation block before displaying cells in its new bounds.
+    public override func prepare(forAnimatedBoundsChange oldBounds: CGRect) {
+        super.prepare(forAnimatedBoundsChange: oldBounds)
+    }
+
+    // also called inside the animation block
+    public override func finalizeAnimatedBoundsChange() {
+        super.finalizeAnimatedBoundsChange()
+    }
+
+    // UICollectionView calls this when prior the layout transition animation
+    // on the incoming and outgoing layout.
+    public override func prepareForTransition(to newLayout: UICollectionViewLayout) {
+        super.prepareForTransition(to: newLayout)
+    }
+
+    public override func prepareForTransition(from oldLayout: UICollectionViewLayout) {
+        super.prepareForTransition(from: oldLayout)
+    }
+
+    // called inside an animation block after the transition
+    public override func finalizeLayoutTransition() {
+        super.finalizeLayoutTransition()
+    }
+
+    // A layout can return the content offset to be applied during transition or update animations.
+    public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint,
+                                             withScrollingVelocity velocity: CGPoint) -> CGPoint {
+        return proposedContentOffset
+    }
+
+    // A layout can return the content offset to be applied during transition or update animations.
+    public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
+        return proposedContentOffset
+    }
 
     private var initialLayoutInfo: LayoutInfo? {
         lastLayoutInfo
