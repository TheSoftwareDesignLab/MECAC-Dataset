diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 21980f8aa36..0c12736240e 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -884,6 +884,8 @@
 		66E3C8F62994634E00BB38ED /* RegistrationCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66E3C8F52994634E00BB38ED /* RegistrationCoordinator.swift */; };
 		66F0F1DD29C1230C008C0ECE /* RegistrationCoordinatorLoader.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66F0F1DC29C1230C008C0ECE /* RegistrationCoordinatorLoader.swift */; };
 		66F0F1DF29C12363008C0ECE /* RegistrationCoordinatorDependencies.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66F0F1DE29C12363008C0ECE /* RegistrationCoordinatorDependencies.swift */; };
+		66F2CE1F2A3A37CB00519342 /* EditableMessageBody.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66F2CE1E2A3A37CB00519342 /* EditableMessageBody.swift */; };
+		66F2CE212A3CBE4A00519342 /* NSRangedValue.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66F2CE202A3CBE4A00519342 /* NSRangedValue.swift */; };
 		66F44B4B2909EEDA004CF66C /* OWSViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66F44B4A2909EEDA004CF66C /* OWSViewController.swift */; };
 		66FA2B1D28CB0DE1006845CD /* PaymentsBiometryLockPromptViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66FA2B1C28CB0DE1006845CD /* PaymentsBiometryLockPromptViewController.swift */; };
 		66FA2B1F28CBA4A5006845CD /* BiometryType.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66FA2B1E28CBA4A5006845CD /* BiometryType.swift */; };
@@ -3360,6 +3362,8 @@
 		66E3C8F52994634E00BB38ED /* RegistrationCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RegistrationCoordinator.swift; sourceTree = "<group>"; };
 		66F0F1DC29C1230C008C0ECE /* RegistrationCoordinatorLoader.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RegistrationCoordinatorLoader.swift; sourceTree = "<group>"; };
 		66F0F1DE29C12363008C0ECE /* RegistrationCoordinatorDependencies.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RegistrationCoordinatorDependencies.swift; sourceTree = "<group>"; };
+		66F2CE1E2A3A37CB00519342 /* EditableMessageBody.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditableMessageBody.swift; sourceTree = "<group>"; };
+		66F2CE202A3CBE4A00519342 /* NSRangedValue.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NSRangedValue.swift; sourceTree = "<group>"; };
 		66F44B4A2909EEDA004CF66C /* OWSViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSViewController.swift; sourceTree = "<group>"; };
 		66FA2B1C28CB0DE1006845CD /* PaymentsBiometryLockPromptViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PaymentsBiometryLockPromptViewController.swift; sourceTree = "<group>"; };
 		66FA2B1E28CBA4A5006845CD /* BiometryType.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BiometryType.swift; sourceTree = "<group>"; };
@@ -6779,12 +6783,14 @@
 		66FC636C29DF78FE00F00DAC /* BodyRanges */ = {
 			isa = PBXGroup;
 			children = (
+				66F2CE1E2A3A37CB00519342 /* EditableMessageBody.swift */,
 				66FC637B29DF8FF200F00DAC /* HydratedMessageBody.swift */,
 				66FC637929DF8C6D00F00DAC /* MentionAttribute.swift */,
 				66FC637529DF7FCC00F00DAC /* MentionHydrator.swift */,
 				F9C5C8D4289453B100548EEE /* MessageBody.swift */,
 				66FC636E29DF797700F00DAC /* MessageBodyRanges.swift */,
 				6684447F2A3289C700DBED7C /* MessageBodyStyle.swift */,
+				66F2CE202A3CBE4A00519342 /* NSRangedValue.swift */,
 				66FC638529E4B9AF00F00DAC /* RecoveredHydratedMessageBody.swift */,
 				665FAE8B2A02C0D400FA298D /* SpoilerRevealState.swift */,
 				66FC637729DF8BEF00F00DAC /* StyleAttribute.swift */,
@@ -11904,6 +11910,7 @@
 				F9C5CC18289453B300548EEE /* DownloadStickerPackOperation.swift in Sources */,
 				5003BB43299F034D0037159B /* E164.swift in Sources */,
 				F9C5CC8A289453B300548EEE /* EarlyMessageManager.swift in Sources */,
+				66F2CE1F2A3A37CB00519342 /* EditableMessageBody.swift in Sources */,
 				C1DB22C329C9F95500757380 /* EditManager.swift in Sources */,
 				C1C4AA3329E7038D000CE9D3 /* EditManagerShims.swift in Sources */,
 				C167387529E8397B0068EA92 /* EditMessageFinder.swift in Sources */,
@@ -12044,6 +12051,7 @@
 				F9C5CD3B289453B300548EEE /* NSData+keyVersionByte.m in Sources */,
 				507E1BDF2A0E13B100650611 /* NSKeyedUnarchiver+SSK.swift in Sources */,
 				F9C5CE0B289453B400548EEE /* NSNotificationCenter+OWS.swift in Sources */,
+				66F2CE212A3CBE4A00519342 /* NSRangedValue.swift in Sources */,
 				F9C5CDF1289453B400548EEE /* NSRegularExpression+SSK.swift in Sources */,
 				F9C5CDF2289453B400548EEE /* NSString+SSK.m in Sources */,
 				F9C5CDD1289453B400548EEE /* NSTimer+OWS.m in Sources */,
diff --git a/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift b/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
index 87abb6c77a8..eca244f6c06 100644
--- a/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
+++ b/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
@@ -126,8 +126,12 @@ extension CameraFirstCaptureSendFlow: SendMediaNavDataSource {
         selectedConversations.map { $0.titleWithSneakyTransaction }
     }
 
-    var sendMediaNavMentionableAddresses: [SignalServiceAddress] {
-        mentionCandidates
+    func sendMediaNavMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
+        return mentionCandidates
+    }
+
+    func sendMediaNavMentionCacheInvalidationKey() -> String {
+        return "\(mentionCandidates.hashValue)"
     }
 }
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationInputTextView.swift b/Signal/src/ViewControllers/ConversationView/ConversationInputTextView.swift
index 4aeac59a7d8..a002d048823 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationInputTextView.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationInputTextView.swift
@@ -30,8 +30,8 @@ class ConversationInputTextView: BodyRangesTextView {
     weak var inputTextViewDelegate: ConversationInputTextViewDelegate?
     weak var textViewToolbarDelegate: ConversationTextViewToolbarDelegate?
 
-    var trimmedText: String { text.ows_stripped() }
-    var untrimmedText: String { text }
+    var trimmedText: String { textStorage.string.ows_stripped() }
+    var untrimmedText: String { textStorage.string }
     private var textIsChanging = false
 
     required init() {
@@ -61,7 +61,7 @@ class ConversationInputTextView: BodyRangesTextView {
         textAlignment = .natural
         textContainer.lineFragmentPadding = 0
         contentInset = .zero
-        text = nil
+        setMessageBody(nil, txProvider: databaseStorage.readTxProvider)
 
         ensurePlaceholderConstraints()
         updatePlaceholderVisibility()
@@ -113,7 +113,7 @@ class ConversationInputTextView: BodyRangesTextView {
     }
 
     private func updatePlaceholderVisibility() {
-        placeholderView.isHidden = !text.isEmpty
+        placeholderView.isHidden = !textStorage.string.isEmpty
     }
 
     override var font: UIFont? {
@@ -128,11 +128,10 @@ class ConversationInputTextView: BodyRangesTextView {
         didSet { ensurePlaceholderConstraints() }
     }
 
-    override var text: String! {
-        didSet {
-            updatePlaceholderVisibility()
-            updateTextContainerInset()
-        }
+    override func setMessageBody(_ messageBody: MessageBody?, txProvider: ((DBReadTransaction) -> Void) -> Void) {
+        super.setMessageBody(messageBody, txProvider: txProvider)
+        updatePlaceholderVisibility()
+        updateTextContainerInset()
     }
 
     override func becomeFirstResponder() -> Bool {
@@ -149,7 +148,7 @@ class ConversationInputTextView: BodyRangesTextView {
 
     override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
         if action == #selector(paste(_:)) {
-            if pasteboardHasPossibleAttachment {
+            if pasteboardHasPossibleAttachment && !super.disallowsAnyPasteAction() {
                 return true
             }
         }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationInputToolbar.swift b/Signal/src/ViewControllers/ConversationView/ConversationInputToolbar.swift
index 675a72fdcfd..3a2bc554fb6 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationInputToolbar.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationInputToolbar.swift
@@ -848,10 +848,10 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
 
     // MARK: Message Body
 
-    var messageBody: MessageBody? { inputTextView.messageBody }
+    var messageBodyForSending: MessageBody? { inputTextView.messageBodyForSending }
 
     func setMessageBody(_ messageBody: MessageBody?, animated: Bool, doLayout: Bool = true) {
-        inputTextView.messageBody = messageBody
+        inputTextView.setMessageBody(messageBody, txProvider: DependenciesBridge.shared.db.readTxProvider)
 
         // It's important that we set the textViewHeight before
         // doing any animation in `ensureButtonVisibility(withAnimation:doLayout)`
@@ -1025,7 +1025,7 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
     private func updateInputLinkPreview() {
         AssertIsOnMainThread()
 
-        linkPreviewFetcher.update(messageBody?.text ?? "", enableIfEmpty: true)
+        linkPreviewFetcher.update(messageBodyForSending?.text ?? "", enableIfEmpty: true)
     }
 
     private func updateLinkPreviewView() {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+BottomBar.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+BottomBar.swift
index 091f62c5e55..b1d5a934252 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+BottomBar.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+BottomBar.swift
@@ -163,7 +163,7 @@ public extension ConversationViewController {
         var voiceMemoDraft: VoiceMessageInterruptedDraft?
         if let oldInputToolbar = self.inputToolbar {
             // Maintain draft continuity.
-            messageDraft = oldInputToolbar.messageBody
+            messageDraft = oldInputToolbar.messageBodyForSending
             replyDraft = oldInputToolbar.draftReply
             voiceMemoDraft = oldInputToolbar.voiceMemoDraft
         } else {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
index 83776ff771e..78d7917ffc9 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
@@ -32,7 +32,7 @@ extension ConversationViewController: ConversationInputToolbarDelegate {
 
         inputToolbar.acceptAutocorrectSuggestion()
 
-        guard let messageBody = inputToolbar.messageBody else {
+        guard let messageBody = inputToolbar.messageBodyForSending else {
             return
         }
 
@@ -243,7 +243,7 @@ extension ConversationViewController: ConversationInputToolbarDelegate {
 
         if !inputToolbar.isHidden {
             let thread = self.thread
-            let currentDraft = inputToolbar.messageBody
+            let currentDraft = inputToolbar.messageBodyForSending
             let quotedReply = inputToolbar.quotedReply
             Self.databaseStorage.asyncWrite { transaction in
                 // Reload a fresh instance of the thread model; our models are not
@@ -503,7 +503,7 @@ public extension ConversationViewController {
         }
 
         let modal = AttachmentApprovalViewController.wrappedInNavController(attachments: attachments,
-                                                                            initialMessageBody: inputToolbar.messageBody,
+                                                                            initialMessageBody: inputToolbar.messageBodyForSending,
                                                                             approvalDelegate: self,
                                                                             approvalDataSource: self)
         presentFullScreen(modal, animated: true)
@@ -621,7 +621,7 @@ fileprivate extension ConversationViewController {
 
 public extension ConversationViewController {
     func showGifPicker() {
-        let gifModal = GifPickerNavigationViewController(initialMessageBody: inputToolbar?.messageBody)
+        let gifModal = GifPickerNavigationViewController(initialMessageBody: inputToolbar?.messageBodyForSending)
         gifModal.approvalDelegate = self
         gifModal.approvalDataSource = self
         dismissKeyBoard()
@@ -863,7 +863,7 @@ extension ConversationViewController: SendMediaNavDelegate {
 extension ConversationViewController: SendMediaNavDataSource {
 
     func sendMediaNavInitialMessageBody(_ sendMediaNavigationController: SendMediaNavigationController) -> MessageBody? {
-        inputToolbar?.messageBody
+        inputToolbar?.messageBodyForSending
     }
 
     var sendMediaNavTextInputContextIdentifier: String? { textInputContextIdentifier }
@@ -872,7 +872,11 @@ extension ConversationViewController: SendMediaNavDataSource {
         [ Self.contactsManager.displayNameWithSneakyTransaction(thread: thread) ]
     }
 
-    var sendMediaNavMentionableAddresses: [SignalServiceAddress] {
-        supportsMentions ? thread.recipientAddressesWithSneakyTransaction : []
+    func sendMediaNavMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
+        supportsMentions ? thread.recipientAddresses(with: SDSDB.shimOnlyBridge(tx)) : []
+    }
+
+    func sendMediaNavMentionCacheInvalidationKey() -> String {
+        return thread.uniqueId
     }
 }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift
index 3e2a2bfeb93..6b6afe1a9ac 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Delegates.swift
@@ -66,8 +66,12 @@ extension ConversationViewController: AttachmentApprovalViewControllerDataSource
         [ Self.contactsManager.displayNameWithSneakyTransaction(thread: thread) ]
     }
 
-    public var attachmentApprovalMentionableAddresses: [SignalServiceAddress] {
-        supportsMentions ? thread.recipientAddressesWithSneakyTransaction : []
+    public func attachmentApprovalMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
+        supportsMentions ? thread.recipientAddresses(with: SDSDB.shimOnlyBridge(tx)) : []
+    }
+
+    public func attachmentApprovalMentionCacheInvalidationKey() -> String {
+        return thread.uniqueId
     }
 }
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Mentions.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Mentions.swift
index 4e5f986a778..cec602c8092 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Mentions.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Mentions.swift
@@ -21,12 +21,16 @@ extension ConversationViewController: BodyRangesTextViewDelegate {
         bottomBar
     }
 
-    public func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView) -> [SignalServiceAddress] {
-        supportsMentions ? thread.recipientAddressesWithSneakyTransaction : []
+    public func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView, tx: DBReadTransaction) -> [SignalServiceAddress] {
+        supportsMentions ? thread.recipientAddresses(with: SDSDB.shimOnlyBridge(tx)) : []
     }
 
-    public func textViewMentionDisplayConfiguration(_ textView: BodyRangesTextView) -> MentionDisplayConfiguration {
-        return .composing
+    public func textViewMentionCacheInvalidationKey(_ textView: BodyRangesTextView) -> String {
+        return thread.uniqueId
+    }
+
+    public func textViewDisplayConfiguration(_ textView: BodyRangesTextView) -> HydratedMessageBody.DisplayConfiguration {
+        return .init(mention: .composing, style: .composing, searchRanges: nil)
     }
 
     public func mentionPickerStyle(_ textView: BodyRangesTextView) -> MentionPickerStyle {
diff --git a/Signal/src/ViewControllers/GifPicker/GifPickerViewController.swift b/Signal/src/ViewControllers/GifPicker/GifPickerViewController.swift
index 8999d735513..e3c2fc7c9f9 100644
--- a/Signal/src/ViewControllers/GifPicker/GifPickerViewController.swift
+++ b/Signal/src/ViewControllers/GifPicker/GifPickerViewController.swift
@@ -33,7 +33,7 @@ extension GifPickerNavigationViewController: GifPickerViewControllerDelegate {
 
         let attachmentApprovalItem = AttachmentApprovalItem(attachment: attachment, canSave: false)
         let attachmentApproval = AttachmentApprovalViewController(options: [], attachmentApprovalItems: [attachmentApprovalItem])
-        attachmentApproval.messageBody = initialMessageBody
+        attachmentApproval.setMessageBody(initialMessageBody, txProvider: DependenciesBridge.shared.db.readTxProvider)
         attachmentApproval.approvalDelegate = self
         attachmentApproval.approvalDataSource = self
         pushViewController(attachmentApproval, animated: true) {
@@ -81,8 +81,12 @@ extension GifPickerNavigationViewController: AttachmentApprovalViewControllerDat
         approvalDataSource?.attachmentApprovalRecipientNames ?? []
     }
 
-    public var attachmentApprovalMentionableAddresses: [SignalServiceAddress] {
-        return approvalDataSource?.attachmentApprovalMentionableAddresses ?? []
+    public func attachmentApprovalMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
+        return approvalDataSource?.attachmentApprovalMentionableAddresses(tx: tx) ?? []
+    }
+
+    public func attachmentApprovalMentionCacheInvalidationKey() -> String {
+        return approvalDataSource?.attachmentApprovalMentionCacheInvalidationKey() ?? UUID().uuidString
     }
 }
 
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/Group Reply Sheet/StoryGroupReplyViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/Group Reply Sheet/StoryGroupReplyViewController.swift
index a3a6147beb4..a6bd7754dfd 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/Group Reply Sheet/StoryGroupReplyViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/Group Reply Sheet/StoryGroupReplyViewController.swift	
@@ -108,7 +108,7 @@ class StoryGroupReplyViewController: OWSViewController, StoryReplySheet {
 
     func didSendMessage() {
         replyLoader?.reload()
-        inputToolbar.messageBody = nil
+        inputToolbar.setMessageBody(nil, txProvider: DependenciesBridge.shared.db.readTxProvider)
     }
 }
 
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplyInputToolbar.swift b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplyInputToolbar.swift
index f6a9b8fb14f..1e23ee90aa0 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplyInputToolbar.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplyInputToolbar.swift	
@@ -15,7 +15,8 @@ protocol StoryReplyInputToolbarDelegate: AnyObject {
     func storyReplyInputToolbarDidTapReact(_ storyReplyInputToolbar: StoryReplyInputToolbar)
     func storyReplyInputToolbarDidBeginEditing(_ storyReplyInputToolbar: StoryReplyInputToolbar)
     func storyReplyInputToolbarHeightDidChange(_ storyReplyInputToolbar: StoryReplyInputToolbar)
-    func storyReplyInputToolbarMentionPickerPossibleAddresses(_ storyReplyInputToolbar: StoryReplyInputToolbar) -> [SignalServiceAddress]
+    func storyReplyInputToolbarMentionPickerPossibleAddresses(_ storyReplyInputToolbar: StoryReplyInputToolbar, tx: DBReadTransaction) -> [SignalServiceAddress]
+    func storyReplyInputToolbarMentionCacheInvalidationKey() -> String
     func storyReplyInputToolbarMentionPickerReferenceView(_ storyReplyInputToolbar: StoryReplyInputToolbar) -> UIView?
     func storyReplyInputToolbarMentionPickerParentView(_ storyReplyInputToolbar: StoryReplyInputToolbar) -> UIView?
 }
@@ -27,12 +28,13 @@ class StoryReplyInputToolbar: UIView {
     weak var delegate: StoryReplyInputToolbarDelegate?
     let quotedReplyModel: QuotedReplyModel?
 
-    var messageBody: MessageBody? {
-        get { textView.messageBody }
-        set {
-            textView.messageBody = newValue
-            updateContent(animated: false)
-        }
+    var messageBodyForSending: MessageBody? {
+        textView.messageBodyForSending
+    }
+
+    func setMessageBody(_ messageBody: MessageBody?, txProvider: EditableMessageBodyTextStorage.ReadTxProvider) {
+        textView.setMessageBody(messageBody, txProvider: txProvider)
+        updateContent(animated: false)
     }
 
     override var bounds: CGRect {
@@ -169,10 +171,11 @@ class StoryReplyInputToolbar: UIView {
     private lazy var placeholderTextView: UITextView = {
         let placeholderTextView = buildTextView()
 
-        placeholderTextView.text = OWSLocalizedString(
+        let placeholderText = OWSLocalizedString(
             "STORY_REPLY_TEXT_FIELD_PLACEHOLDER",
             comment: "placeholder text for replying to a story"
         )
+        placeholderTextView.setMessageBody(.init(text: placeholderText, ranges: .empty), txProvider: databaseStorage.readTxProvider)
         placeholderTextView.isEditable = false
         placeholderTextView.textContainer.maximumNumberOfLines = 1
         placeholderTextView.textContainer.lineBreakMode = .byTruncatingTail
@@ -278,10 +281,10 @@ class StoryReplyInputToolbar: UIView {
 
         updateHeight(textView: textView)
 
-        let hasAnyText = !textView.text.isEmptyOrNil
+        let hasAnyText = !textView.isEmpty
         placeholderTextView.isHidden = hasAnyText
 
-        let hasNonWhitespaceText = !textView.text.ows_stripped().isEmpty
+        let hasNonWhitespaceText = !textView.isWhitespaceOrEmpty
         setSendButtonHidden(!hasNonWhitespaceText, animated: animated)
     }
 
@@ -353,12 +356,16 @@ extension StoryReplyInputToolbar: BodyRangesTextViewDelegate {
         delegate?.storyReplyInputToolbarMentionPickerReferenceView(self)
     }
 
-    func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView) -> [SignalServiceAddress] {
-        delegate?.storyReplyInputToolbarMentionPickerPossibleAddresses(self) ?? []
+    func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView, tx: DBReadTransaction) -> [SignalServiceAddress] {
+        delegate?.storyReplyInputToolbarMentionPickerPossibleAddresses(self, tx: tx) ?? []
     }
 
-    public func textViewMentionDisplayConfiguration(_ textView: BodyRangesTextView) -> MentionDisplayConfiguration {
-        return .groupReply
+    func textViewMentionCacheInvalidationKey(_ textView: BodyRangesTextView) -> String {
+        return delegate?.storyReplyInputToolbarMentionCacheInvalidationKey() ?? UUID().uuidString
+    }
+
+    public func textViewDisplayConfiguration(_ textView: BodyRangesTextView) -> HydratedMessageBody.DisplayConfiguration {
+        return .init(mention: .groupReply, style: .composingGroupReply, searchRanges: nil)
     }
 
     public func mentionPickerStyle(_ textView: BodyRangesTextView) -> MentionPickerStyle {
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplySheet.swift b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplySheet.swift
index 6d92c6fcc48..612a7241ffc 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplySheet.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryReplySheet.swift	
@@ -122,7 +122,7 @@ extension StoryReplySheet {
 
 extension StoryReplySheet {
     func storyReplyInputToolbarDidTapSend(_ storyReplyInputToolbar: StoryReplyInputToolbar) {
-        guard let messageBody = storyReplyInputToolbar.messageBody, !messageBody.text.isEmpty else {
+        guard let messageBody = storyReplyInputToolbar.messageBodyForSending, !messageBody.text.isEmpty else {
             return owsFailDebug("Unexpectedly missing message body")
         }
 
@@ -150,9 +150,13 @@ extension StoryReplySheet {
     func storyReplyInputToolbarDidBeginEditing(_ storyReplyInputToolbar: StoryReplyInputToolbar) {}
     func storyReplyInputToolbarHeightDidChange(_ storyReplyInputToolbar: StoryReplyInputToolbar) {}
 
-    func storyReplyInputToolbarMentionPickerPossibleAddresses(_ storyReplyInputToolbar: StoryReplyInputToolbar) -> [SignalServiceAddress] {
+    func storyReplyInputToolbarMentionPickerPossibleAddresses(_ storyReplyInputToolbar: StoryReplyInputToolbar, tx: DBReadTransaction) -> [SignalServiceAddress] {
         guard let thread = thread, thread.isGroupThread else { return [] }
-        return thread.recipientAddressesWithSneakyTransaction
+        return thread.recipientAddresses(with: SDSDB.shimOnlyBridge(tx))
+    }
+
+    func storyReplyInputToolbarMentionCacheInvalidationKey() -> String {
+        return thread?.uniqueId ?? UUID().uuidString
     }
 
     func storyReplyInputToolbarMentionPickerParentView(_ storyReplyInputToolbar: StoryReplyInputToolbar) -> UIView? {
diff --git a/Signal/src/ViewControllers/LongTextViewController.swift b/Signal/src/ViewControllers/LongTextViewController.swift
index dbc49a76530..a529d13452d 100644
--- a/Signal/src/ViewControllers/LongTextViewController.swift
+++ b/Signal/src/ViewControllers/LongTextViewController.swift
@@ -85,7 +85,9 @@ public class LongTextViewController: OWSViewController {
             mutableText = recoveredMessageBody.reapplyAttributes(
                 config: HydratedMessageBody.DisplayConfiguration(
                     mention: .longMessageView,
-                    style: .todo(),
+                    style: .longTextView(revealedSpoilerIds: spoilerReveal.revealedSpoilerIds(
+                        interactionIdentifier: .fromInteraction(itemViewModel.interaction))
+                    ),
                     searchRanges: nil
                 ),
                 isDarkThemeEnabled: Theme.isDarkThemeEnabled
diff --git a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
index bd28a520618..9e044695831 100644
--- a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
+++ b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
@@ -28,7 +28,9 @@ protocol SendMediaNavDataSource: AnyObject {
 
     var sendMediaNavRecipientNames: [String] { get }
 
-    var sendMediaNavMentionableAddresses: [SignalServiceAddress] { get }
+    func sendMediaNavMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress]
+
+    func sendMediaNavMentionCacheInvalidationKey() -> String
 }
 
 class CameraFirstCaptureNavigationController: SendMediaNavigationController {
@@ -170,7 +172,8 @@ class SendMediaNavigationController: OWSNavigationController {
         let approvalViewController = AttachmentApprovalViewController(options: options, attachmentApprovalItems: attachmentApprovalItems)
         approvalViewController.approvalDelegate = self
         approvalViewController.approvalDataSource = self
-        approvalViewController.messageBody = sendMediaNavDataSource.sendMediaNavInitialMessageBody(self)
+        let messageBody = sendMediaNavDataSource.sendMediaNavInitialMessageBody(self)
+        approvalViewController.setMessageBody(messageBody, txProvider: DependenciesBridge.shared.db.readTxProvider)
 
         if animated {
             fadeTo(viewControllers: viewControllers + [approvalViewController], duration: 0.3)
@@ -462,8 +465,12 @@ extension SendMediaNavigationController: AttachmentApprovalViewControllerDataSou
         sendMediaNavDataSource?.sendMediaNavRecipientNames ?? []
     }
 
-    var attachmentApprovalMentionableAddresses: [SignalServiceAddress] {
-        sendMediaNavDataSource?.sendMediaNavMentionableAddresses ?? []
+    func attachmentApprovalMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
+        sendMediaNavDataSource?.sendMediaNavMentionableAddresses(tx: tx) ?? []
+    }
+
+    func attachmentApprovalMentionCacheInvalidationKey() -> String {
+        sendMediaNavDataSource?.sendMediaNavMentionCacheInvalidationKey() ?? UUID().uuidString
     }
 }
 
diff --git a/Signal/src/ViewControllers/SendMessageFlow.swift b/Signal/src/ViewControllers/SendMessageFlow.swift
index a074e012013..beaf8bc649f 100644
--- a/Signal/src/ViewControllers/SendMessageFlow.swift
+++ b/Signal/src/ViewControllers/SendMessageFlow.swift
@@ -292,7 +292,7 @@ extension SendMessageFlow {
             let approvalViewController = AttachmentApprovalViewController(options: options, attachmentApprovalItems: attachmentApprovalItems)
             approvalViewController.approvalDelegate = self
             approvalViewController.approvalDataSource = self
-            approvalViewController.messageBody = messageBody
+            approvalViewController.setMessageBody(messageBody, txProvider: DependenciesBridge.shared.db.readTxProvider)
 
             pushViewController(approvalViewController, animated: true)
         default:
@@ -595,9 +595,13 @@ extension SendMessageFlow: AttachmentApprovalViewControllerDataSource {
         []
     }
 
-    var attachmentApprovalMentionableAddresses: [SignalServiceAddress] {
+    func attachmentApprovalMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
         mentionCandidates
     }
+
+    func attachmentApprovalMentionCacheInvalidationKey() -> String {
+        return "\(mentionCandidates.hashValue)"
+    }
 }
 
 // MARK: -
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index fd2222abf3b..f7423367e98 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -7072,6 +7072,9 @@
 /* Option in selected text edit menu to make text bold */
 "TEXT_MENU_BOLD" = "Bold";
 
+/* Option in selected text edit menu to clear all text formatting in the selected text range */
+"TEXT_MENU_CLEAR_FORMATTING" = "Clear Formatting";
+
 /* Option in selected text edit menu to view text formatting options */
 "TEXT_MENU_FORMAT" = "Format";
 
diff --git a/SignalMessaging/attachments/SignalAttachment.swift b/SignalMessaging/attachments/SignalAttachment.swift
index d4fffd0a26e..11c11e61d28 100644
--- a/SignalMessaging/attachments/SignalAttachment.swift
+++ b/SignalMessaging/attachments/SignalAttachment.swift
@@ -552,7 +552,9 @@ public class SignalAttachment: NSObject {
         return UIPasteboard.general.numberOfItems > 0
     }
 
-    public static let mentionPasteboardType = "private.archived-mention-text"
+    // This can be more than just mentions (e.g. also text formatting styles)
+    // but the name remains as-is for backwards compatibility.
+    public static let bodyRangesPasteboardType = "private.archived-mention-text"
 
     public class func pasteboardHasText() -> Bool {
         if UIPasteboard.general.numberOfItems < 1 {
@@ -569,7 +571,7 @@ public class SignalAttachment: NSObject {
 
         // The mention text view has a special pasteboard type, if we see it
         // we know that the pasteboard contains text.
-        guard !pasteboardUTISet.contains(mentionPasteboardType) else {
+        guard !pasteboardUTISet.contains(bodyRangesPasteboardType) else {
             return true
         }
 
diff --git a/SignalServiceKit/src/Messages/BodyRanges/EditableMessageBody.swift b/SignalServiceKit/src/Messages/BodyRanges/EditableMessageBody.swift
new file mode 100644
index 00000000000..bcf5b186212
--- /dev/null
+++ b/SignalServiceKit/src/Messages/BodyRanges/EditableMessageBody.swift
@@ -0,0 +1,858 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public protocol EditableMessageBodyDelegate: AnyObject {
+
+    func editableMessageBodyHydrator(tx: DBReadTransaction) -> MentionHydrator
+
+    func editableMessageSelectedRange() -> NSRange
+
+    func editableMessageBodyDidRequestNewSelectedRange(_ newSelectedRange: NSRange)
+
+    func editableMessageBodyDisplayConfig() -> HydratedMessageBody.DisplayConfiguration
+
+    func isEditableMessageBodyDarkThemeEnabled() -> Bool
+
+    // If this key changes, the cached mentions will be invalidated at read-time.
+    func mentionCacheInvalidationKey() -> String
+}
+
+public class EditableMessageBodyTextStorage: NSTextStorage {
+
+    public typealias SingleStyle = MessageBodyRanges.SingleStyle
+
+    /// Abstraction so callers can either provide an already-open transaction or allow
+    /// opening a new transaction.
+    public typealias ReadTxProvider = ((DBReadTransaction) -> Void) -> Void
+
+    // MARK: - Init
+
+    // DB reference so we can hydrate mentions.
+    private let db: DB
+
+    public weak var editableBodyDelegate: EditableMessageBodyDelegate?
+
+    public init(
+        db: DB
+    ) {
+        self.db = db
+        super.init()
+    }
+
+    @available(*, unavailable)
+    required public init?(coder: NSCoder) {
+        owsFail("Use another initializer")
+    }
+
+    // MARK: - NSTextStorage
+
+    public override var string: String {
+        return body.hydratedText
+    }
+
+    public override func attributes(at location: Int, effectiveRange range: NSRangePointer?) -> [NSAttributedString.Key: Any] {
+        return displayString.attributes(at: location, effectiveRange: range)
+    }
+
+    public override func replaceCharacters(in range: NSRange, with str: String) {
+        self.replaceCharacters(
+            in: range,
+            with: str,
+            selectedRange: editableBodyDelegate?.editableMessageSelectedRange()
+                ?? NSRange(location: (body.hydratedText as NSString).length, length: 0)
+        )
+    }
+
+    public override func setAttributes(_ attrs: [NSAttributedString.Key: Any]?, range: NSRange) {
+        guard isFixingAttributes else {
+            // Don't allow external attribute setting except from
+            // fixing, which is applied for emojis.
+            return
+        }
+        displayString.setAttributes(attrs, range: range)
+    }
+
+    private var isFixingAttributes = false
+
+    public override func fixAttributes(in range: NSRange) {
+        isFixingAttributes = true
+        super.fixAttributes(in: range)
+        isFixingAttributes = false
+    }
+
+    private var isEditing = false
+
+    private var selectionAfterEdits: NSRange?
+
+    public override func beginEditing() {
+        super.beginEditing()
+        isEditing = true
+        self.selectionAfterEdits = nil
+    }
+
+    public override func endEditing() {
+        super.endEditing()
+        isEditing = false
+        DispatchQueue.main.async {
+            if let selectionAfterEdits = self.selectionAfterEdits {
+                self.selectionAfterEdits = nil
+                self.editableBodyDelegate?.editableMessageBodyDidRequestNewSelectedRange(selectionAfterEdits)
+            }
+        }
+    }
+
+    // MARK: - State Representation
+
+    internal struct Body: Equatable {
+        var hydratedText: String
+        var mentions: [NSRange: UUID]
+        var flattenedStyles: [NSRangedValue<SingleStyle>]
+    }
+
+    private var body = Body(hydratedText: "", mentions: [:], flattenedStyles: []) {
+        didSet {
+            cachedMessageBody = nil
+        }
+    }
+
+    private var displayString: NSMutableAttributedString = NSMutableAttributedString(string: "")
+
+    public var hydratedPlaintext: String {
+        return body.hydratedText
+    }
+
+    public var attributedString: NSAttributedString {
+        return displayString
+    }
+
+    // Unordered
+    public var mentionRanges: [NSRange] {
+        return body.mentions.keys.map({ $0 })
+    }
+
+    // MARK: - Making Updates
+
+    public func didUpdateTheming() {
+        let selectedRange = editableBodyDelegate?.editableMessageSelectedRange() ?? NSRange(location: displayString.length, length: 0)
+        regenerateDisplayString(
+            hydratedTextBeforeChange: body.hydratedText,
+            hydrator: makeMentionHydratorForCurrentBody(),
+            modifiedRange: NSRange(location: 0, length: (body.hydratedText as NSString).length),
+            selectedRangeAfterChange: selectedRange
+        )
+    }
+
+    /// Replace characters in the provided range with a plaintext string. The string will not
+    /// have any formatting properties applied, even if inserted in the middle of a formatted range.
+    /// If any change is made to a mention range, the mention will be removed (but its representation
+    /// as plaintext will persist).
+    public func replaceCharacters(in range: NSRange, with string: String, selectedRange: NSRange) {
+        replaceCharacters(in: range, with: string, selectedRange: selectedRange, txProvider: db.readTxProvider)
+    }
+
+    private func replaceCharacters(in range: NSRange, with string: String, selectedRange: NSRange, txProvider: ReadTxProvider) {
+        let hydratedTextBeforeChange = body.hydratedText
+        let changeInLength = (string as NSString).length - range.length
+        var modifiedRange = range
+        // For append-only, we can efficiently update without recomputing anything.
+        if range.location == displayString.length, range.length == 0 {
+            self.body.hydratedText = body.hydratedText + string
+            guard let editableBodyDelegate else {
+                owsFailDebug("Should have delegate")
+                self.displayString.append(string)
+                return
+            }
+            let config = editableBodyDelegate.editableMessageBodyDisplayConfig()
+            let isDarkThemeEnabled = editableBodyDelegate.isEditableMessageBodyDarkThemeEnabled()
+            self.displayString.append(
+                string,
+                attributes: [
+                    .font: config.mention.font,
+                    .foregroundColor: config.mention.foregroundColor.color(isDarkThemeEnabled: isDarkThemeEnabled)
+                ]
+            )
+            super.edited(.editedCharacters, range: range, changeInLength: changeInLength)
+            return
+        }
+        // If the change is within a mention, that mention is eliminated.
+        // Note that the hydrated text of the mention is preserved; its just plaintext now.
+        var intersectingMentionRanges = [NSRange]()
+        body.mentions.forEach { (mentionRange, mentionUuid) in
+            if
+                // An insert, which can happen in the middle of a mention.
+                (range.length == 0 && mentionRange.contains(range.location))
+                || (mentionRange.intersection(range)?.length ?? 0) > 0
+            {
+                intersectingMentionRanges.append(mentionRange)
+            } else if range.upperBound <= mentionRange.location {
+                // If the change is before a mention, we have to shift the mention.
+                body.mentions[mentionRange] = nil
+                body.mentions[NSRange(location: mentionRange.location + changeInLength, length: mentionRange.length)] = mentionUuid
+            }
+        }
+        if
+            string.isEmpty,
+            selectedRange.length <= 1,
+            let intersectingMentionRange = intersectingMentionRanges.first,
+            range.length == 1,
+            range.upperBound == intersectingMentionRange.upperBound
+        {
+            // Backspace at the end of a mention, just clear the whole mention minus the prefix.
+            self.replaceCharacters(in: intersectingMentionRange, with: MentionAttribute.mentionPrefix, selectedRange: selectedRange)
+            // Put the selection after the prefix so a new mention can be typed.
+            let newSelectedRange = NSRange(
+                location: intersectingMentionRange.location + (MentionAttribute.mentionPrefix as NSString).length,
+                length: 0
+            )
+            self.selectionAfterEdits = newSelectedRange
+            return
+        }
+        intersectingMentionRanges.forEach {
+            body.mentions.removeValue(forKey: $0)
+            modifiedRange.formUnion($0)
+        }
+
+        // Styles need updated ranges.
+        body.flattenedStyles = Self.updateFlattenedStyles(
+            body.flattenedStyles,
+            forReplacementOf: range,
+            with: string,
+            preserveStyleInReplacement: false
+        )
+
+        body.hydratedText = (body.hydratedText as NSString).replacingCharacters(in: range, with: string)
+
+        regenerateDisplayString(
+            hydratedTextBeforeChange: hydratedTextBeforeChange,
+            hydrator: makeMentionHydrator(for: Array(self.body.mentions.values), txProvider: txProvider),
+            modifiedRange: modifiedRange,
+            selectedRangeAfterChange: nil
+        )
+    }
+
+    public func replaceCharacters(in range: NSRange, withMentionUUID mentionUuid: UUID, txProvider: ReadTxProvider) {
+        let hydrator = makeMentionHydrator(for: Array(body.mentions.values) + [mentionUuid], txProvider: txProvider)
+        replaceCharacters(in: range, withMentionUUID: mentionUuid, hydrator: hydrator, insertSpaceAfter: true)
+    }
+
+    private func replaceCharacters(
+        in range: NSRange,
+        withMentionUUID mentionUuid: UUID,
+        hydrator: CacheMentionHydrator,
+        insertSpaceAfter: Bool
+    ) {
+        let hydratedTextBeforeChange = body.hydratedText
+        var modifiedRange = range
+        let hydratedMention: String
+        switch hydrator.hydrator(mentionUuid) {
+        case .hydrate(let mentionString):
+            if CurrentAppContext().isRTL {
+                hydratedMention = mentionString + MentionAttribute.mentionPrefix
+            } else {
+                hydratedMention = MentionAttribute.mentionPrefix + mentionString
+            }
+        case .preserveMention:
+            return
+        }
+
+        // If the change is within an existing mention, that mention is eliminated.
+        // Note that the hydrated text of the mention is preserved; its just plaintext now.
+        let intersectingMentionRanges = body.mentions.keys.filter { mentionRange in
+            if range.length == 0 {
+                // An insert, which can happen in the middle of a mention.
+                return mentionRange.contains(range.location)
+            } else {
+                return (mentionRange.intersection(range)?.length ?? 0) > 0
+            }
+        }
+        intersectingMentionRanges.forEach {
+            body.mentions.removeValue(forKey: $0)
+            modifiedRange.formUnion($0)
+        }
+
+        // Styles need updated ranges.
+        body.flattenedStyles = Self.updateFlattenedStyles(
+            body.flattenedStyles,
+            forReplacementOf: range,
+            with: hydratedMention,
+            preserveStyleInReplacement: true
+        )
+
+        // Add a space after the inserted mention
+        let suffix = insertSpaceAfter ? " " : ""
+        body.hydratedText = (body.hydratedText as NSString).replacingCharacters(in: range, with: hydratedMention + suffix)
+        // Any space isn't included in the mention's range.
+        let mentionRange = NSRange(location: range.location, length: (hydratedMention as NSString).length)
+        body.mentions[mentionRange] = mentionUuid
+
+        // Put the cursor after the space, if any
+        let newSelectedRange = NSRange(location: mentionRange.upperBound + (suffix as NSString).length, length: 0)
+
+        regenerateDisplayString(
+            hydratedTextBeforeChange: hydratedTextBeforeChange,
+            hydrator: hydrator,
+            modifiedRange: modifiedRange,
+            selectedRangeAfterChange: newSelectedRange
+        )
+    }
+
+    public func hasFormatting(in range: NSRange) -> Bool {
+        return body.flattenedStyles.contains(where: { ($0.range.intersection(range)?.length ?? 0) > 0 })
+    }
+
+    public func clearFormatting(in range: NSRange) {
+        // Check for overlaps with mentions; any styles we apply to a mention applies
+        // to the whole mention.
+        var range = range
+        for mentionRange in mentionRanges {
+            if let intersection = mentionRange.intersection(range), intersection.length > 0 {
+                range.formUnion(mentionRange)
+            }
+        }
+
+        let previouslySelectedRange = editableBodyDelegate?.editableMessageSelectedRange()
+        // Reverse order so we can modify indexes in the for loop and not hit problems.
+        for (i, style) in body.flattenedStyles.enumerated().reversed() {
+            guard style.range.upperBound > range.location else {
+                // We got past all relevant ranges, safe to stop now.
+                break
+            }
+            guard let intersection = style.range.intersection(range), intersection.length > 0 else {
+                continue
+            }
+            body.flattenedStyles.remove(at: i)
+            if range.location > style.range.location {
+                // Chop off the start of the existing range and reinsert it.
+                let newStyle = NSRangedValue(
+                    style.value,
+                    range: NSRange(
+                        location: style.range.location,
+                        length: range.location - style.range.location
+                    )
+                )
+                insertStylePreservingSort(newStyle)
+            }
+            if range.upperBound < style.range.upperBound {
+                // Chop off the end of the existing range and reinsert it.
+                let newStyle = NSRangedValue(
+                    style.value,
+                    range: NSRange(
+                        location: range.upperBound,
+                        length: style.range.upperBound - range.upperBound
+                    )
+                )
+                insertStylePreservingSort(newStyle)
+            }
+        }
+
+        let newSelectedRange: NSRange
+        if let previouslySelectedRange {
+            newSelectedRange = NSRange(location: previouslySelectedRange.upperBound, length: 0)
+        } else {
+            // Put it at the end.
+            newSelectedRange = NSRange(location: (body.hydratedText as NSString).length, length: 0)
+        }
+
+        regenerateDisplayString(
+            hydratedTextBeforeChange: body.hydratedText /* text doesn't change */,
+            hydrator: makeMentionHydratorForCurrentBody(),
+            modifiedRange: range,
+            selectedRangeAfterChange: newSelectedRange
+        )
+    }
+
+    public func toggleStyle(_ style: SingleStyle, in range: NSRange) {
+        toggleStyle(style, in: range, txProvider: db.readTxProvider)
+    }
+
+    private func toggleStyle(_ style: SingleStyle, in range: NSRange, txProvider: ReadTxProvider) {
+        let hydratedTextBeforeChange = body.hydratedText
+        // We want to put the selection at the end of the previously selected range.
+        let previouslySelectedRange = editableBodyDelegate?.editableMessageSelectedRange()
+
+        // Check for overlaps with mentions; any styles we apply to a mention applies
+        // to the whole mention.
+        var range = range
+        for mentionRange in mentionRanges {
+            if let intersection = mentionRange.intersection(range), intersection.length > 0 {
+                range.formUnion(mentionRange)
+            }
+        }
+
+        let newStyle = NSRangedValue<SingleStyle>(style, range: range)
+        let overlaps = NSRangedValue<Any>.overlaps(
+            of: newStyle,
+            in: self.body.flattenedStyles,
+            isEqual: ==
+        )
+
+        switch overlaps {
+        case .none(let insertionIndex):
+            // Easiest case; no overlaps so just insert as a new style.
+            body.flattenedStyles.insert(newStyle, at: insertionIndex)
+
+        case .withinExistingRange(let containingRangeIndex):
+            // Contained within one range, so we want to un-apply.
+            // Remove the existing range, then determine if there are any
+            // non-overlapping sections to chop off and reinsert.
+            let containingStyle = self.body.flattenedStyles[containingRangeIndex]
+            self.body.flattenedStyles.remove(at: containingRangeIndex)
+            if range.location > containingStyle.range.location {
+                // Chop off the start of the existing range and reinsert it.
+                let newStyle = NSRangedValue(
+                    style,
+                    range: NSRange(
+                        location: containingStyle.range.location,
+                        length: range.location - containingStyle.range.location
+                    )
+                )
+                insertStylePreservingSort(newStyle)
+            }
+            if range.upperBound < containingStyle.range.upperBound {
+                // Chop off the end of the existing range and reinsert it.
+                let newStyle = NSRangedValue(
+                    style,
+                    range: NSRange(
+                        location: range.upperBound,
+                        length: containingStyle.range.upperBound - range.upperBound
+                    )
+                )
+                insertStylePreservingSort(newStyle)
+            }
+
+        case .acrossExistingRanges(let overlapIndexes, let gaps):
+            let shouldUnapply: Bool
+            if gaps.isEmpty {
+                // If there are no gaps, we will un-apply.
+                shouldUnapply = true
+            } else {
+                // There are gaps. For some styles, we ignore whitespace gaps.
+                switch style {
+                case .strikethrough, .monospace, .spoiler:
+                    // Styles visually apply to all gaps, so we should apply.
+                    shouldUnapply = false
+                case .bold, .italic:
+                    // Ignore gaps if they're all whitespace, so its like
+                    // if we had no gaps.
+                    shouldUnapply = gaps.allSatisfy({ gap in
+                        return self.body.hydratedText.substring(withRange: gap).allSatisfy(\.isWhitespace)
+                    })
+                }
+            }
+
+            if shouldUnapply {
+                // If unapplying, remove existing styles but be careful to keep
+                // any hanging head or tail sections.
+                var newRangesToInsert = [NSRangedValue<SingleStyle>]()
+                if let firstIndex = overlapIndexes.first {
+                    // Chop off the start of the first overlapping range and reinsert it.
+                    let existingRange = self.body.flattenedStyles[firstIndex]
+                    let newStyle = NSRangedValue(
+                        style,
+                        range: NSRange(
+                            location: existingRange.range.location,
+                            length: range.location - existingRange.range.location
+                        )
+                    )
+                    if newStyle.range.length > 0 {
+                        newRangesToInsert.append(newStyle)
+                    }
+                }
+                if let lastIndex = overlapIndexes.last {
+                    // Chop off the end of the last overlapping range and reinsert it.
+                    let existingRange = self.body.flattenedStyles[lastIndex]
+                    let newStyle = NSRangedValue(
+                        style,
+                        range: NSRange(
+                            location: range.upperBound,
+                            length: existingRange.range.upperBound - range.upperBound
+                        )
+                    )
+                    if newStyle.range.length > 0 {
+                        newRangesToInsert.append(newStyle)
+                    }
+                }
+                // Remove the overlaps.
+                for i in overlapIndexes.reversed() {
+                    self.body.flattenedStyles.remove(at: i)
+                }
+                newRangesToInsert.forEach(insertStylePreservingSort(_:))
+            } else {
+                // If applying, merge all styles into one.
+                var mergedRange = range
+                for i in overlapIndexes.reversed() {
+                    let existingRange = self.body.flattenedStyles.remove(at: i)
+                    mergedRange.formUnion(existingRange.range)
+                }
+                insertStylePreservingSort(.init(style, range: mergedRange))
+            }
+        }
+
+        let newSelectedRange: NSRange
+        if let previouslySelectedRange {
+            newSelectedRange = NSRange(location: previouslySelectedRange.upperBound, length: 0)
+        } else {
+            // Put it at the end.
+            newSelectedRange = NSRange(location: (body.hydratedText as NSString).length, length: 0)
+        }
+
+        regenerateDisplayString(
+            hydratedTextBeforeChange: hydratedTextBeforeChange,
+            hydrator: makeMentionHydrator(for: Array(self.body.mentions.values), txProvider: txProvider),
+            modifiedRange: range,
+            selectedRangeAfterChange: newSelectedRange
+        )
+    }
+
+    /// Be careful using this method; styles cannot overlap with styles of the same type and that
+    /// invariant must be enforced by callers of this method.
+    private func insertStylePreservingSort(_ newStyle: NSRangedValue<SingleStyle>) {
+        var low = self.body.flattenedStyles.startIndex
+        var high = self.body.flattenedStyles.endIndex
+        while low != high {
+            let mid = self.body.flattenedStyles.index(
+                low,
+                offsetBy: self.body.flattenedStyles.distance(from: low, to: high) / 2
+            )
+            let element = self.body.flattenedStyles[mid]
+            if newStyle.range.location == element.range.location {
+                // Good insertion point; we can stop
+                self.body.flattenedStyles.insert(newStyle, at: mid)
+                return
+            } else if newStyle.range.location > element.range.location {
+                low = self.body.flattenedStyles.index(after: mid)
+            } else {
+                high = mid
+            }
+        }
+        self.body.flattenedStyles.insert(newStyle, at: low)
+    }
+
+    public func replaceCharacters(in range: NSRange, withPastedMessageBody messageBody: MessageBody, txProvider: ReadTxProvider) {
+        let hydrator = self.makeMentionHydrator(for: Array(messageBody.ranges.mentions.values), txProvider: txProvider)
+        let hydrated = messageBody.hydrating(mentionHydrator: hydrator.hydrator)
+        let insertedBody = hydrated.asEditableMessageBody()
+
+        // First replace with plaintext, then apply the styles and mentions.
+        self.replaceCharacters(in: range, with: insertedBody.hydratedText, selectedRange: range, txProvider: txProvider)
+        for mention in insertedBody.mentions {
+            self.replaceCharacters(
+                in: NSRange(location: range.location + mention.key.location, length: mention.key.length),
+                withMentionUUID: mention.value,
+                hydrator: hydrator,
+                insertSpaceAfter: false
+            )
+        }
+        for style in insertedBody.flattenedStyles {
+            self.toggleStyle(
+                style.value,
+                in: NSRange(location: range.location + style.range.location, length: style.range.length),
+                txProvider: txProvider
+            )
+        }
+        let hydratedTextBeforeChange = body.hydratedText
+        let wholeBodyHydrator = makeMentionHydrator(for: Array(self.body.mentions.values), txProvider: txProvider)
+        // Put the range at the very end.
+        let newSelectedRange = NSRange(location: range.location + (insertedBody.hydratedText as NSString).length, length: 0)
+        self.regenerateDisplayString(
+            hydratedTextBeforeChange: hydratedTextBeforeChange,
+            hydrator: wholeBodyHydrator,
+            modifiedRange: range,
+            selectedRangeAfterChange: newSelectedRange
+        )
+    }
+
+    private static func updateFlattenedStyles(
+        _ flattenedStyles: [NSRangedValue<SingleStyle>],
+        forReplacementOf range: NSRange,
+        with string: String,
+        preserveStyleInReplacement: Bool
+    ) -> [NSRangedValue<SingleStyle>] {
+        let stringLength = (string as NSString).length
+        let changeLengthDiff = stringLength - range.length
+        var newStyles = [NSRangedValue<SingleStyle>]()
+        for style in flattenedStyles {
+            if style.range.upperBound <= range.location {
+                // Its before the changed region, no changes needed.
+                newStyles.append(style)
+            } else if style.range.location >= range.upperBound {
+                // Its after the changed region, just update the location.
+                newStyles.append(.init(
+                    style.value,
+                    range: NSRange(
+                        location: style.range.location + changeLengthDiff,
+                        length: style.range.length
+                    )
+                ))
+            } else if style.range.location >= range.location, style.range.upperBound <= range.upperBound {
+                // Total overlap.
+                guard preserveStyleInReplacement, string.isEmpty.negated else {
+                    // we can skip this style entirely; its wiped.
+                    continue
+                }
+                // We just shrink the style to the new range.
+                newStyles.append(.init(
+                    style.value,
+                    range: NSRange(location: range.location, length: stringLength)
+                ))
+            } else if style.range.location < range.location, style.range.upperBound > range.upperBound {
+                // The style contains the changed range.
+                if preserveStyleInReplacement {
+                    // Shrink the style by the change in range.
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(location: style.range.location, length: style.range.length + changeLengthDiff)
+                    ))
+                } else {
+                    // Split the style in two on either side of the eliminated region.
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(
+                            location: style.range.location,
+                            length: range.location - style.range.location
+                        )
+                    ))
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(
+                            location: range.upperBound + changeLengthDiff,
+                            length: style.range.upperBound - range.upperBound
+                        )
+                    ))
+                }
+            } else if style.range.location < range.location {
+                // The style hangs off the start of the affected range.
+                if preserveStyleInReplacement {
+                    // Extend the style to the whole new range.
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(
+                            location: style.range.location,
+                            length: (range.location + stringLength) - style.range.location
+                        )
+                    ))
+                } else {
+                    // Add the hanging head
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(
+                            location: style.range.location,
+                            length: range.location - style.range.location
+                        )
+                    ))
+                }
+            } else {
+                // The style hangs off the end of the affected range.
+                if preserveStyleInReplacement {
+                    // Extend the style to the whole new range.
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(
+                            location: range.location,
+                            length: style.range.upperBound - range.location + changeLengthDiff
+                        )
+                    ))
+                } else {
+                    // Add the hanging tail
+                    newStyles.append(.init(
+                        style.value,
+                        range: NSRange(
+                            location: range.upperBound + changeLengthDiff,
+                            length: style.range.upperBound - range.upperBound
+                        )
+                    ))
+                }
+            }
+        }
+        return newStyles
+    }
+
+    // MARK: - MessageBody
+
+    public var messageBody: MessageBody { return makeMessageBody() }
+
+    public func setMessageBody(_ messageBody: MessageBody?, txProvider: ReadTxProvider) {
+        let hydratedTextBeforeChange = body.hydratedText
+        let messageBody = messageBody ?? MessageBody(text: "", ranges: .empty)
+        let hydrator = self.makeMentionHydrator(for: Array(messageBody.ranges.mentions.values), txProvider: txProvider)
+        let hydrated = messageBody.hydrating(mentionHydrator: hydrator.hydrator)
+        self.body = hydrated.asEditableMessageBody()
+        // While this could open a _second_ transaction, in practice it won't because
+        // we have the cached values from the hydator above
+        regenerateDisplayString(
+            hydratedTextBeforeChange: hydratedTextBeforeChange,
+            hydrator: hydrator,
+            modifiedRange: NSRange(location: 0, length: (hydratedTextBeforeChange as NSString).length),
+            selectedRangeAfterChange: NSRange(location: (body.hydratedText as NSString).length, length: 0)
+        )
+    }
+
+    // Constructing this is expensive and is used as input to the displayed string. Cache it.
+    private var cachedMessageBody: MessageBody?
+
+    private func makeMessageBody() -> MessageBody {
+        Self.makeMessageBody(cache: &cachedMessageBody, body: body)
+    }
+
+    private static func makeMessageBody(cache: inout MessageBody?, body: Body) -> MessageBody {
+        if let cache {
+            return cache
+        }
+        // Un-hydrate the mentions first.
+        var text: NSString = body.hydratedText as NSString
+        var flattenedStyles = body.flattenedStyles
+        let orderedMentions: [NSRangedValue<UUID>] = body.mentions.lazy
+            .map({
+                return NSRangedValue($0.value, range: $0.key)
+            })
+            .sorted(by: {
+                return $0.range.location < $1.range.location
+            })
+
+        let mentionPlaceholderLength = (MessageBody.mentionPlaceholder as NSString).length
+        var finalMentions = [NSRange: UUID]()
+        var mentionOffset = 0
+        for mention in orderedMentions {
+            let effectiveRange = NSRange(location: mention.range.location + mentionOffset, length: mention.range.length)
+            text = text.replacingCharacters(in: effectiveRange, with: MessageBody.mentionPlaceholder) as NSString
+            finalMentions[NSRange(location: effectiveRange.location, length: mentionPlaceholderLength)] = mention.value
+            flattenedStyles = Self.updateFlattenedStyles(
+                flattenedStyles,
+                forReplacementOf: effectiveRange,
+                with: MessageBody.mentionPlaceholder,
+                preserveStyleInReplacement: true
+            )
+            mentionOffset += mentionPlaceholderLength - mention.range.length
+        }
+        let body = MessageBody(
+            text: text as String,
+            ranges: MessageBodyRanges(
+                mentions: finalMentions,
+                styles: flattenedStyles
+            )
+        )
+        cache = body
+        return body
+    }
+
+    private func regenerateDisplayString(
+        hydratedTextBeforeChange: String,
+        hydrator: CacheMentionHydrator,
+        modifiedRange: NSRange,
+        selectedRangeAfterChange: NSRange?
+    ) {
+        guard let editableBodyDelegate else {
+            owsFailDebug("Should have delegate")
+            return
+        }
+        let config = editableBodyDelegate.editableMessageBodyDisplayConfig()
+        let isDarkThemeEnabled = editableBodyDelegate.isEditableMessageBodyDarkThemeEnabled()
+        let baseAttributes: [NSAttributedString.Key: Any] = [
+            .font: config.mention.font,
+            .foregroundColor: config.mention.foregroundColor.color(isDarkThemeEnabled: isDarkThemeEnabled)
+        ]
+        let displayString = makeMessageBody()
+            .hydrating(mentionHydrator: hydrator.hydrator, filterStringForDisplay: false)
+            .asAttributedStringForDisplay(
+                config: config,
+                baseAttributes: baseAttributes,
+                isDarkThemeEnabled: isDarkThemeEnabled
+            )
+        self.displayString = (displayString as? NSMutableAttributedString) ?? NSMutableAttributedString(attributedString: displayString)
+        self.fixAttributes(in: NSRange(location: 0, length: displayString.length))
+
+        let changeInLength = (body.hydratedText as NSString).length - (hydratedTextBeforeChange as NSString).length
+        super.edited(
+            body.hydratedText == hydratedTextBeforeChange ? [.editedCharacters, .editedAttributes] : .editedAttributes,
+            range: modifiedRange,
+            changeInLength: changeInLength
+        )
+        self.selectionAfterEdits = selectedRangeAfterChange
+        if !isEditing, let selectedRangeAfterChange {
+            self.selectionAfterEdits = nil
+            editableBodyDelegate.editableMessageBodyDidRequestNewSelectedRange(selectedRangeAfterChange)
+        }
+    }
+
+    // MARK: - Hydrating
+
+    private var mentionCacheKey: String?
+    private var mentionCache = [UUID: String]()
+    private var skippedMentionUUIDS = Set<UUID>()
+
+    /// This object represents the results of already having opened, and finished with, a
+    /// transaction to read mention hydrated names. We cache the results, put them in this
+    /// object, and make them available for reading without needing to open a new transaction.
+    ///
+    /// Cache mention hydration results so we don't constantly fetch; we avoid even opening
+    /// a transaction until we absolutely have to.
+    /// Note that if this gets out of sync with the DB because some contact name changes that's ultimately fine;
+    /// we un-hydrate mentions before we send them so this state is only for display of the message being composed.
+    class CacheMentionHydrator {
+        private let mentionCache: [UUID: String]
+
+        init(mentionCache: [UUID: String]) {
+            self.mentionCache = mentionCache
+        }
+
+        var hydrator: MentionHydrator {
+            return { [mentionCache] uuid in
+                guard let mentionString = mentionCache[uuid] else {
+                    return .preserveMention
+                }
+                return .hydrate(mentionString)
+            }
+        }
+    }
+
+    private func makeMentionHydratorForCurrentBody() -> CacheMentionHydrator {
+        return makeMentionHydrator(for: Array(self.body.mentions.values), txProvider: db.readTxProvider)
+    }
+
+    private func makeMentionHydrator(for mentions: [UUID], txProvider: ReadTxProvider) -> CacheMentionHydrator {
+        var mentionCache: [UUID: String]
+        if let mentionCacheKey, mentionCacheKey == editableBodyDelegate?.mentionCacheInvalidationKey() {
+            mentionCache = self.mentionCache
+        } else {
+            self.mentionCache = [:]
+            mentionCache = [:]
+        }
+        // If all mentions are in the cache, no need to recompute.
+        if !mentions.allSatisfy({ mentionCache[$0] != nil || skippedMentionUUIDS.contains($0) }) {
+            // If any are missing, we have to open a transaction and put them in the cache.
+            txProvider { tx in
+                let hydrator = editableBodyDelegate?.editableMessageBodyHydrator(tx: tx) ?? ContactsMentionHydrator.mentionHydrator(transaction: tx)
+                mentions.forEach { uuid in
+                    switch hydrator(uuid) {
+                    case .hydrate(let hydratedString):
+                        mentionCache[uuid] = hydratedString
+                    case .preserveMention:
+                        skippedMentionUUIDS.insert(uuid)
+                    }
+                }
+            }
+        }
+        self.mentionCache = mentionCache
+        self.mentionCacheKey = editableBodyDelegate?.mentionCacheInvalidationKey()
+
+        return .init(mentionCache: mentionCache)
+    }
+}
+
+extension DB {
+
+    public var readTxProvider: EditableMessageBodyTextStorage.ReadTxProvider {
+        return { self.read(block: $0) }
+    }
+}
+
+extension SDSDatabaseStorage {
+
+    public var readTxProvider: EditableMessageBodyTextStorage.ReadTxProvider {
+        return { block in self.read(block: { block($0.asV2Read) }) }
+    }
+}
diff --git a/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift b/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift
index 58cdc1b062e..8dc231d01ab 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift
@@ -5,22 +5,6 @@
 
 import Foundation
 
-public struct NSRangedValue<T> {
-    public let range: NSRange
-    public let value: T
-
-    public init( _ value: T, range: NSRange) {
-        self.range = range
-        self.value = value
-    }
-}
-
-extension NSRangedValue: Equatable where T: Equatable {}
-
-extension NSRangedValue: Hashable where T: Hashable {}
-
-extension NSRangedValue: Codable where T: Codable {}
-
 /// The result of stripping, filtering, and hydrating mentions in a `MessageBody`.
 /// This object can be held durably in memory as a way to cache mention hydrations
 /// and other expensive string operations, and can subsequently be transformed
@@ -28,6 +12,7 @@ extension NSRangedValue: Codable where T: Codable {}
 public class HydratedMessageBody: Equatable, Hashable {
 
     public typealias Style = MessageBodyRanges.Style
+    public typealias SingleStyle = MessageBodyRanges.SingleStyle
     public typealias CollapsedStyle = MessageBodyRanges.CollapsedStyle
 
     private let hydratedText: String
@@ -78,47 +63,11 @@ public class HydratedMessageBody: Equatable, Hashable {
             return
         }
 
-        let originalText = messageBody.text as NSString
-        let filteredText = originalText.filterStringForDisplay() as NSString
-
-        // NOTE that we only handle leading characters getting stripped;
-        // if characters in the middle of the string get stripped that
-        // will mess up all the ranges. That is not now and never has been
-        // handled by the app.
-        let strippedPrefixLength: Int
-        if filteredText.length != originalText.length {
-            // We filtered things, we need to adjust ranges.
-            strippedPrefixLength = originalText.range(of: filteredText as String).location
-        } else {
-            strippedPrefixLength = 0
-        }
-        var mentionsInOriginal: [NSRangedValue<UUID>]
-        var stylesInOriginal: [NSRangedValue<CollapsedStyle>]
-        if strippedPrefixLength != 0 {
-            mentionsInOriginal = messageBody.ranges.orderedMentions.map { mention in
-                return .init(
-                    mention.value,
-                    range: NSRange(
-                        location: mention.range.location + strippedPrefixLength,
-                        length: mention.range.length
-                    )
-                )
-            }
-            stylesInOriginal = messageBody.ranges.collapsedStyles.map { style in
-                return .init(
-                    style.value,
-                    range: NSRange(
-                        location: style.range.location + strippedPrefixLength,
-                        length: style.range.length
-                    )
-                )
-            }
-        } else {
-            mentionsInOriginal = messageBody.ranges.orderedMentions
-            stylesInOriginal = messageBody.ranges.collapsedStyles
-        }
+        var mentionsInOriginal = messageBody.ranges.orderedMentions
+        var stylesInOriginal = messageBody.ranges.collapsedStyles
 
-        let finalText = NSMutableString(string: filteredText)
+        let finalText = NSMutableString(string: messageBody.text)
+        let startLength = finalText.length
         var unhydratedMentions = [NSRangedValue<MentionAttribute>]()
         var finalStyleAttributes = [NSRangedValue<StyleAttribute>]()
         var finalMentionAttributes = [NSRangedValue<MentionAttribute>]()
@@ -132,7 +81,6 @@ public class HydratedMessageBody: Equatable, Hashable {
         }
         var styleAtCurrentIndex: ProcessingStyle?
 
-        let startLength = (filteredText as NSString).length
         for currentIndex in 0..<startLength {
             // If we are past the end, apply the active style to the final result
             // and drop.
@@ -410,16 +358,57 @@ public class HydratedMessageBody: Equatable, Hashable {
         unhydratedMentions.forEach {
             unhydratedMentionsDict[$0.range] = $0.value.mentionUuid
         }
+
         return MessageBody(
             text: hydratedText,
             ranges: MessageBodyRanges(
                 mentions: unhydratedMentionsDict,
-                styles: styleAttributes.flatMap { styleAttribute in
-                    return styleAttribute.value.style.contents.map {
-                        return NSRangedValue($0, range: styleAttribute.range)
+                styles: Self.flattenStylesPreservingSharedIds(styleAttributes)
+            )
+        )
+    }
+
+    // MARK: - Editing
+
+    internal func asEditableMessageBody() -> EditableMessageBodyTextStorage.Body {
+        var mentions = [NSRange: UUID]()
+        self.mentionAttributes.forEach {
+            mentions[$0.range] = $0.value.mentionUuid
+        }
+        self.unhydratedMentions.forEach {
+            mentions[$0.range] = $0.value.mentionUuid
+        }
+        var flattenedStyles = [NSRangedValue<SingleStyle>]()
+        var runningStyles = [SingleStyle: (StyleIdType, NSRange)]()
+
+        styleAttributes.forEach { (styleAttribute: NSRangedValue<StyleAttribute>) in
+            SingleStyle.allCases.forEach { style in
+                guard styleAttribute.value.style.contains(style: style), let id = styleAttribute.value.ids[style] else {
+                    return
+                }
+                if let runningStyle: (StyleIdType, NSRange) = runningStyles[style] {
+                    // Append to the running style.
+                    if runningStyle.0 == id {
+                        runningStyles[style] = (id, runningStyle.1.union(styleAttribute.range))
+                    } else {
+                        flattenedStyles.append(.init(style, range: runningStyle.1))
+                        runningStyles[style] = (id, styleAttribute.range)
                     }
+                } else {
+                    runningStyles[style] = (id, styleAttribute.range)
                 }
-            )
+            }
+        }
+        flattenedStyles.append(contentsOf: runningStyles
+            .map({ style, values in
+                return NSRangedValue<SingleStyle>(style, range: values.1)
+            })
+        )
+        flattenedStyles.sort(by: { $0.range.location < $1.range.location })
+        return .init(
+            hydratedText: hydratedText,
+            mentions: mentions,
+            flattenedStyles: flattenedStyles
         )
     }
 
@@ -548,6 +537,35 @@ public class HydratedMessageBody: Equatable, Hashable {
 
         return items
     }
+
+    // MARK: - Helpers
+
+    internal static func flattenStylesPreservingSharedIds(_ styleAttributes: [NSRangedValue<StyleAttribute>]) -> [NSRangedValue<SingleStyle>] {
+        var styleIdToIndex = [StyleIdType: Int]()
+        var styles = [NSRangedValue<MessageBodyRanges.SingleStyle>]()
+        for styleAttribute in styleAttributes {
+            for singleStyle in styleAttribute.value.style.contents {
+                let styleId = styleAttribute.value.ids[singleStyle]
+                if
+                    let styleId,
+                    let styleIndexToJoinInto = styleIdToIndex[styleId],
+                    let styleToJoinInto = styles[safe: styleIndexToJoinInto],
+                    styleToJoinInto.value == singleStyle,
+                    styleToJoinInto.range.upperBound == styleAttribute.range.location
+                {
+                    // Merge into an existing range with the same id.
+                    styles[styleIndexToJoinInto] = .init(singleStyle, range: styleToJoinInto.range.union(styleAttribute.range))
+                } else {
+                    if let styleId {
+                        styleIdToIndex[styleId] = styles.count
+                    }
+                    styles.append(.init(singleStyle, range: styleAttribute.range))
+                }
+
+            }
+        }
+        return styles
+    }
 }
 
 fileprivate extension NSRangedValue {
diff --git a/SignalServiceKit/src/Messages/BodyRanges/MentionHydrator.swift b/SignalServiceKit/src/Messages/BodyRanges/MentionHydrator.swift
index a9caf496578..465c644b466 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/MentionHydrator.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/MentionHydrator.swift
@@ -33,7 +33,7 @@ public class ContactsMentionHydrator {
         }
     }
 
-    private static func hydrateMention(
+    public static func hydrateMention(
         with mentionUuid: UUID,
         transaction: DBReadTransaction
     ) -> (SignalServiceAddress, String) {
diff --git a/SignalServiceKit/src/Messages/BodyRanges/MessageBody.swift b/SignalServiceKit/src/Messages/BodyRanges/MessageBody.swift
index 29d5c2dcac3..7aadf0b9070 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/MessageBody.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/MessageBody.swift
@@ -12,13 +12,15 @@ import Foundation
 public class MessageBody: NSObject, NSCopying, NSSecureCoding {
 
     typealias Style = MessageBodyRanges.Style
+    typealias CollapsedStyle = MessageBodyRanges.CollapsedStyle
 
     public static var supportsSecureCoding = true
     public static let mentionPlaceholder = "\u{FFFC}" // Object Replacement Character
 
     public let text: String
     public let ranges: MessageBodyRanges
-    public var hasMentions: Bool { ranges.hasMentions }
+    public var hasRanges: Bool { ranges.hasRanges }
+    private var hasMentions: Bool { ranges.hasMentions }
 
     public init(text: String, ranges: MessageBodyRanges) {
         self.text = text
@@ -51,15 +53,75 @@ public class MessageBody: NSObject, NSCopying, NSSecureCoding {
 
     public func hydrating(
         mentionHydrator: MentionHydrator,
+        filterStringForDisplay: Bool = true,
         isRTL: Bool = CurrentAppContext().isRTL
     ) -> HydratedMessageBody {
+        let body = filterStringForDisplay ? self.filterStringForDisplay() : self
         return HydratedMessageBody(
-            messageBody: self,
+            messageBody: body,
             mentionHydrator: mentionHydrator,
             isRTL: isRTL
         )
     }
 
+    // Strip leading and trailing whitespace and other non-printed characters,
+    // preserving ranges.
+    public func filterStringForDisplay() -> MessageBody {
+        let originalText = text as NSString
+        let filteredText = originalText.filterStringForDisplay() as NSString
+
+        guard filteredText.length != originalText.length else {
+            // if we didn't strip anything, nothing needs to change.
+            return self
+        }
+        // We filtered things, we need to adjust ranges.
+
+        // NOTE that we only handle leading characters getting stripped;
+        // if characters in the middle of the string get stripped that
+        // will mess up all the ranges. That never has been handled by the app.
+
+        let strippedPrefixLength = originalText.range(of: filteredText as String).location
+        let filteredStringEntireRange = NSRange(location: 0, length: filteredText.length)
+
+        var adjustedMentions = [NSRange: UUID]()
+        let orderedAdjustedMentions: [NSRangedValue<UUID>] = ranges.orderedMentions.compactMap { mention in
+            guard
+                let newRange = NSRange(
+                    location: mention.range.location - strippedPrefixLength,
+                    length: mention.range.length
+                ).intersection(filteredStringEntireRange),
+                  newRange.length > 0
+            else {
+                return nil
+            }
+            adjustedMentions[newRange] = mention.value
+            return .init(mention.value, range: newRange)
+        }
+        let adjustedStyles: [NSRangedValue<CollapsedStyle>] = ranges.collapsedStyles.compactMap { style in
+            guard
+                let newRange = NSRange(
+                    location: style.range.location - strippedPrefixLength,
+                    length: style.range.length
+                ).intersection(filteredStringEntireRange),
+                newRange.length > 0
+            else {
+                return nil
+            }
+            return .init(
+                style.value,
+                range: newRange
+            )
+        }
+        return MessageBody(
+            text: filteredText as String,
+            ranges: MessageBodyRanges(
+                mentions: adjustedMentions,
+                orderedMentions: orderedAdjustedMentions,
+                collapsedStyles: adjustedStyles
+            )
+        )
+    }
+
     override public func isEqual(_ object: Any?) -> Bool {
         guard let other = object as? MessageBody else {
             return false
@@ -104,6 +166,27 @@ extension MessageBody {
         return hydrating(mentionHydrator: mentionHydrator, isRTL: isRTL)
     }
 
+    /// When pasting a message body into a new context, we need to hydrate mentions
+    /// that don't belong in the new context (such that they are just plaintext of the contact name
+    /// as we know it), and maintain mentions that do apply.
+    ///
+    /// This context is not necessarily one single thread; we could be pasting into a composer
+    /// for sending to multiple threads. So the input array is _all_ valid addresses.
+    public func forPasting(
+        intoContextWithPossibleAddresses possibleAddresses: [SignalServiceAddress],
+        transaction: DBReadTransaction,
+        isRTL: Bool = CurrentAppContext().isRTL
+    ) -> MessageBody {
+        guard hasMentions else {
+            return self
+        }
+        let mentionHydrator = ContactsMentionHydrator.mentionHydrator(
+            excludedUuids: Set(possibleAddresses.compactMap(\.uuid)),
+            transaction: transaction
+        )
+        return hydrating(mentionHydrator: mentionHydrator, isRTL: isRTL).asMessageBodyForForwarding()
+    }
+
     // MARK: Merging
 
     /// Given a substring and set of styles _within that substring_, returns the same
diff --git a/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift b/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift
index 126698c6cff..f5ff4984728 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift
@@ -261,7 +261,7 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         _ sortedStyles: inout [NSRangedValue<SingleStyle>],
         orderedMentions: [NSRangedValue<UUID>]
     ) {
-        var orderedMentions = orderedMentions
+        let orderedMentions = orderedMentions
         let enumeratedStyles = sortedStyles.enumerated()
         for mention in orderedMentions {
             guard mention.range.length > 0 else {
@@ -415,6 +415,7 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
 
         var mentionIndex = 0
         var styleIndex = 0
+        let flattenedStyles = CollapsedStyle.flatten(collapsedStyles)
 
         func appendMention(_ mention: NSRangedValue<UUID>) {
             guard let builder = self.protoBuilder(mention.range, maxBodyLength: maxBodyLength) else {
@@ -428,23 +429,21 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
             }
         }
 
-        func appendStyle(_ style: NSRangedValue<CollapsedStyle>) {
-            for protoStyle in style.value.style.asProtoStyles() {
-                guard let builder = self.protoBuilder(style.range, maxBodyLength: maxBodyLength) else {
-                    continue
-                }
-                builder.setStyle(protoStyle)
-                do {
-                    try protos.append(builder.build())
-                } catch {
-                    owsFailDebug("Failed to build body range proto: \(error)")
-                }
+        func appendStyle(_ style: NSRangedValue<SingleStyle>) {
+            guard let builder = self.protoBuilder(style.range, maxBodyLength: maxBodyLength) else {
+                return
+            }
+            builder.setStyle(style.value.asProtoStyle)
+            do {
+                try protos.append(builder.build())
+            } catch {
+                owsFailDebug("Failed to build body range proto: \(error)")
             }
         }
 
-        while mentionIndex < orderedMentions.count || styleIndex < collapsedStyles.count {
+        while mentionIndex < orderedMentions.count || styleIndex < flattenedStyles.count {
             if mentionIndex >= orderedMentions.count {
-                appendStyle(collapsedStyles[styleIndex])
+                appendStyle(flattenedStyles[styleIndex])
                 styleIndex += 1
                 continue
             }
@@ -460,7 +459,7 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
                 appendMention(orderedMentions[mentionIndex])
                 mentionIndex += 1
             } else {
-                appendStyle(collapsedStyles[styleIndex])
+                appendStyle(flattenedStyles[styleIndex])
                 styleIndex += 1
             }
         }
diff --git a/SignalServiceKit/src/Messages/BodyRanges/MessageBodyStyle.swift b/SignalServiceKit/src/Messages/BodyRanges/MessageBodyStyle.swift
index 63d37025854..f37ea2e314a 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/MessageBodyStyle.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/MessageBodyStyle.swift
@@ -82,17 +82,6 @@ extension MessageBodyRanges {
                 return self.contains(style: $0) ? $0 : nil
             }
         }
-
-        /// Note it is one to many; we collapse styles into this option set
-        /// in swift but in proto-land we fan out to one style per instance.
-        public func asProtoStyles() -> [SSKProtoBodyRangeStyle] {
-            return SingleStyle.allCases.compactMap {
-                guard self.contains(style: $0) else {
-                    return nil
-                }
-                return $0.asProtoStyle
-            }
-        }
     }
 
     /// Result of taking the styles as they appear in the original protos, and merging overlapping
@@ -200,5 +189,17 @@ extension MessageBodyRanges {
             self.style.remove(style: style)
             originals[style] = nil
         }
+
+        public static func flatten(_ collapsedStyles: [NSRangedValue<CollapsedStyle>]) -> [NSRangedValue<SingleStyle>] {
+            var coveredIds = Set<StyleIdType>()
+            return collapsedStyles.flatMap { collapsedStyle in
+                return collapsedStyle.value.originals.compactMap { original in
+                    guard !coveredIds.contains(original.value.id) else {
+                        return nil
+                    }
+                    return NSRangedValue(original.value.style, range: original.value.mergedRange)
+                }
+            }
+        }
     }
 }
diff --git a/SignalServiceKit/src/Messages/BodyRanges/NSRangedValue.swift b/SignalServiceKit/src/Messages/BodyRanges/NSRangedValue.swift
new file mode 100644
index 00000000000..086dd2dacc4
--- /dev/null
+++ b/SignalServiceKit/src/Messages/BodyRanges/NSRangedValue.swift
@@ -0,0 +1,86 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public struct NSRangedValue<T> {
+    public let range: NSRange
+    public let value: T
+
+    public init( _ value: T, range: NSRange) {
+        self.range = range
+        self.value = value
+    }
+}
+
+extension NSRangedValue: Equatable where T: Equatable {}
+
+extension NSRangedValue: Hashable where T: Hashable {}
+
+extension NSRangedValue: Codable where T: Codable {}
+
+extension NSRangedValue {
+
+    enum Overlaps {
+        /// There are no overlaps; new range can be applied directly.
+        /// Provides index in the sorted array into which the new element can be inserted.
+        case none(insertionIndex: Int)
+        /// The input range falls entirely within an existing range at the provided index.
+        case withinExistingRange(atIndex: Int)
+        /// The input range lies across multiple existing ranges. There may be gaps
+        /// between the ranges; if there are no gaps that means the ranges collectively cover
+        /// the entire input range.
+        case acrossExistingRanges(indexes: [Int], gaps: [NSRange])
+    }
+
+    /// Takes a sorted array of existing non-empty ranges and a single new range, and determines how
+    /// the input range overlaps with the existing ranges that are "equal", for some provided
+    /// definition of equal.
+    /// The array is assumed to contain no overlaps between "equal" elements; if there are
+    /// the results of this method are undetermined.
+    static func overlaps<T>(
+        of range: NSRangedValue<T>,
+        in array: [NSRangedValue<T>],
+        isEqual: (T, T) -> Bool
+    ) -> Overlaps {
+        var insertionIndex = 0
+        var overlapIndexes = [Int]()
+        var gaps = [NSRange]()
+        for (i, existingRange) in array.enumerated() {
+            if existingRange.range.location >= range.range.upperBound {
+                // We are past the end, no need to check anymore.
+                break
+            }
+            if existingRange.range.location < range.range.location {
+                insertionIndex = i + 1
+            }
+            guard isEqual(existingRange.value, range.value) else {
+                continue
+            }
+            guard let intersection = existingRange.range.intersection(range.range), intersection.length > 0 else {
+                continue
+            }
+            if intersection == range.range {
+                return .withinExistingRange(atIndex: i)
+            }
+            let lastOverlapIndex = overlapIndexes.last
+            overlapIndexes.append(i)
+            if let lastOverlapIndex {
+                let lastOverlapRange = array[lastOverlapIndex]
+                let gap = NSRange(
+                    location: lastOverlapRange.range.upperBound,
+                    length: existingRange.range.location - lastOverlapRange.range.upperBound
+                )
+                if gap.length > 0 {
+                    gaps.append(gap)
+                }
+            }
+        }
+        if overlapIndexes.isEmpty {
+            return .none(insertionIndex: insertionIndex)
+        }
+        return .acrossExistingRanges(indexes: overlapIndexes, gaps: gaps)
+    }
+}
diff --git a/SignalServiceKit/src/Messages/BodyRanges/RecoveredHydratedMessageBody.swift b/SignalServiceKit/src/Messages/BodyRanges/RecoveredHydratedMessageBody.swift
index a043f0d8460..8f775006333 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/RecoveredHydratedMessageBody.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/RecoveredHydratedMessageBody.swift
@@ -175,10 +175,9 @@ public class RecoveredHydratedMessageBody {
         return mentionAttributes.map { ($0.range, $0.value.mentionUuid) }
     }
 
-    // TODO[TextFormatting]: Remove this; we should be explicitly
-    // holding onto a MessageBody, not recovering from
-    // an attributed string.
-    // Needed for now for editing.
+    // Ideally we should be explicitly holding onto a MessageBody, not recovering from
+    // an attributed string. Needed for now because message bubbles hold only the
+    // attributed string.
     public func toMessageBody() -> MessageBody {
         var mentions = [NSRange: UUID]()
         mentionAttributes.forEach {
@@ -188,11 +187,7 @@ public class RecoveredHydratedMessageBody {
             text: string.string,
             ranges: MessageBodyRanges(
                 mentions: mentions,
-                styles: styleAttributes.flatMap { styleAttribute in
-                    return styleAttribute.value.style.contents.map {
-                        return NSRangedValue($0, range: styleAttribute.range)
-                    }
-                }
+                styles: HydratedMessageBody.flattenStylesPreservingSharedIds(styleAttributes)
             )
         )
     }
diff --git a/SignalServiceKit/src/Messages/BodyRanges/StyleAttribute.swift b/SignalServiceKit/src/Messages/BodyRanges/StyleAttribute.swift
index ec8abe6dd7c..3a10e3b4363 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/StyleAttribute.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/StyleAttribute.swift
@@ -13,6 +13,7 @@ import Foundation
 public struct StyleDisplayConfiguration: Equatable {
     public let baseFont: UIFont
     public let textColor: ThemedColor
+    public let revealedSpoilerBgColor: ThemedColor?
 
     public let revealAllIds: Bool
     public let revealedIds: Set<StyleIdType>
@@ -20,11 +21,13 @@ public struct StyleDisplayConfiguration: Equatable {
     public init(
         baseFont: UIFont,
         textColor: ThemedColor,
+        revealedSpoilerBgColor: ThemedColor? = nil,
         revealAllIds: Bool,
         revealedIds: Set<StyleIdType>
     ) {
         self.baseFont = baseFont
         self.textColor = textColor
+        self.revealedSpoilerBgColor = revealedSpoilerBgColor
         self.revealAllIds = revealAllIds
         self.revealedIds = revealedIds
     }
@@ -97,6 +100,9 @@ internal struct StyleAttribute: Equatable, Hashable {
             if !isSpoilerRevealed {
                 attributes[.foregroundColor] = UIColor.clear
                 attributes[.backgroundColor] = config.textColor.color(isDarkThemeEnabled: isDarkThemeEnabled)
+            } else if let revealedSpoilerBgColor = config.revealedSpoilerBgColor {
+                attributes[.foregroundColor] = config.textColor.color(isDarkThemeEnabled: isDarkThemeEnabled)
+                attributes[.backgroundColor] = revealedSpoilerBgColor.color(isDarkThemeEnabled: isDarkThemeEnabled)
             }
         }
         if !fontTraits.isEmpty {
diff --git a/SignalShareExtension/SharingThreadPickerViewController.swift b/SignalShareExtension/SharingThreadPickerViewController.swift
index 3b3b8db199e..20a5c13815e 100644
--- a/SignalShareExtension/SharingThreadPickerViewController.swift
+++ b/SignalShareExtension/SharingThreadPickerViewController.swift
@@ -719,7 +719,11 @@ extension SharingThreadPickerViewController: AttachmentApprovalViewControllerDat
         selectedConversations.map { $0.titleWithSneakyTransaction }
     }
 
-    var attachmentApprovalMentionableAddresses: [SignalServiceAddress] {
+    func attachmentApprovalMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress] {
         mentionCandidates
     }
+
+    func attachmentApprovalMentionCacheInvalidationKey() -> String {
+        return "\(mentionCandidates.hashValue)"
+    }
 }
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
index 64491ab2393..ab1105355eb 100644
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
+++ b/SignalUI/ViewControllers/AttachmentApproval/AttachmentApprovalViewController.swift
@@ -37,7 +37,9 @@ public protocol AttachmentApprovalViewControllerDataSource: AnyObject {
 
     var attachmentApprovalRecipientNames: [String] { get }
 
-    var attachmentApprovalMentionableAddresses: [SignalServiceAddress] { get }
+    func attachmentApprovalMentionableAddresses(tx: DBReadTransaction) -> [SignalServiceAddress]
+
+    func attachmentApprovalMentionCacheInvalidationKey() -> String
 }
 
 // MARK: -
@@ -149,15 +151,16 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
         }
     }
 
-    public class func wrappedInNavController(attachments: [SignalAttachment],
-                                             initialMessageBody: MessageBody?,
-                                             approvalDelegate: AttachmentApprovalViewControllerDelegate,
-                                             approvalDataSource: AttachmentApprovalViewControllerDataSource)
-        -> OWSNavigationController {
+    public class func wrappedInNavController(
+        attachments: [SignalAttachment],
+        initialMessageBody: MessageBody?,
+        approvalDelegate: AttachmentApprovalViewControllerDelegate,
+        approvalDataSource: AttachmentApprovalViewControllerDataSource
+    ) -> OWSNavigationController {
 
         let attachmentApprovalItems = attachments.map { AttachmentApprovalItem(attachment: $0, canSave: false) }
         let vc = AttachmentApprovalViewController(options: [.hasCancel], attachmentApprovalItems: attachmentApprovalItems)
-        vc.messageBody = initialMessageBody
+        vc.setMessageBody(initialMessageBody, txProvider: DependenciesBridge.shared.db.readTxProvider)
         vc.approvalDelegate = approvalDelegate
         vc.approvalDataSource = approvalDataSource
         let navController = OWSNavigationController(rootViewController: vc)
@@ -393,13 +396,12 @@ public class AttachmentApprovalViewController: UIPageViewController, UIPageViewC
         )
     }
 
-    public var messageBody: MessageBody? {
-        get {
-            return attachmentTextToolbar.messageBody
-        }
-        set {
-            attachmentTextToolbar.messageBody = newValue
-        }
+    public var messageBodyForSending: MessageBody? {
+        return attachmentTextToolbar.messageBodyForSending
+    }
+
+    public func setMessageBody(_ messageBody: MessageBody?, txProvider: EditableMessageBodyTextStorage.ReadTxProvider) {
+        attachmentTextToolbar.setMessageBody(messageBody, txProvider: txProvider)
     }
 
     // MARK: - Control Visibility
@@ -867,7 +869,7 @@ extension AttachmentApprovalViewController {
                             assert(attachments.count <= 1)
                         }
 
-                        self.approvalDelegate?.attachmentApproval(self, didApproveAttachments: attachments, messageBody: self.attachmentTextToolbar.messageBody)
+                        self.approvalDelegate?.attachmentApproval(self, didApproveAttachments: attachments, messageBody: self.attachmentTextToolbar.messageBodyForSending)
                     }
                 }.catch { error in
                     AssertIsOnMainThread()
@@ -943,7 +945,7 @@ extension AttachmentApprovalViewController: AttachmentTextToolbarDelegate {
     }
 
     func attachmentTextToolbarDidChange(_ attachmentTextToolbar: AttachmentTextToolbar) {
-        approvalDelegate?.attachmentApproval(self, didChangeMessageBody: attachmentTextToolbar.messageBody)
+        approvalDelegate?.attachmentApproval(self, didChangeMessageBody: attachmentTextToolbar.messageBodyForSending)
     }
 
     func attachmentTextToolBarDidChangeHeight(_ attachmentTextToolbar: AttachmentTextToolbar) { }
@@ -1264,17 +1266,25 @@ extension AttachmentApprovalViewController: BodyRangesTextViewDelegate {
         return bottomToolView.attachmentTextToolbar
     }
 
-    public func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView) -> [SignalServiceAddress] {
-        return approvalDataSource?.attachmentApprovalMentionableAddresses ?? []
+    public func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView, tx: DBReadTransaction) -> [SignalServiceAddress] {
+        return approvalDataSource?.attachmentApprovalMentionableAddresses(tx: tx) ?? []
     }
 
-    public func textViewMentionDisplayConfiguration(_ textView: BodyRangesTextView) -> MentionDisplayConfiguration {
-        return .composingAttachment
+    public func textViewDisplayConfiguration(_ textView: BodyRangesTextView) -> HydratedMessageBody.DisplayConfiguration {
+        return .init(
+            mention: .composingAttachment,
+            style: .composingAttachment,
+            searchRanges: nil
+        )
     }
 
     public func mentionPickerStyle(_ textView: BodyRangesTextView) -> MentionPickerStyle {
         return .composingAttachment
     }
+
+    public func textViewMentionCacheInvalidationKey(_ textView: BodyRangesTextView) -> String {
+        return approvalDataSource?.attachmentApprovalMentionCacheInvalidationKey() ?? UUID().uuidString
+    }
 }
 
 // MARK: -
diff --git a/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift b/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift
index 4d4158e31d1..0c1a63c16aa 100644
--- a/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift
+++ b/SignalUI/ViewControllers/AttachmentApproval/AttachmentTextToolbar.swift
@@ -39,19 +39,17 @@ class AttachmentTextToolbar: UIView {
         textView.isFirstResponder
     }
 
-    var messageBody: MessageBody? {
-        get {
-            // Ignore message text if "view-once" is enabled.
-            guard !isViewOnceEnabled else {
-                return nil
-            }
-            return textView.messageBody
+    var messageBodyForSending: MessageBody? {
+        // Ignore message text if "view-once" is enabled.
+        guard !isViewOnceEnabled else {
+            return nil
         }
+        return textView.messageBodyForSending
+    }
 
-        set {
-            textView.messageBody = newValue
-            updateAppearance(animated: false)
-        }
+    func setMessageBody(_ messageBody: MessageBody?, txProvider: EditableMessageBodyTextStorage.ReadTxProvider) {
+        textView.setMessageBody(messageBody, txProvider: txProvider)
+        updateAppearance(animated: false)
     }
 
     // MARK: - Initializers
@@ -153,7 +151,7 @@ class AttachmentTextToolbar: UIView {
     }
 
     private func updateAppearance(animated: Bool) {
-        let hasText = !textView.text.isEmptyOrNil
+        let hasText = !textView.isEmpty
         let isEditing = isEditingText
 
         addMessageButton.setIsHidden(hasText || isEditing || isViewOnceEnabled, animated: animated)
@@ -219,7 +217,7 @@ class AttachmentTextToolbar: UIView {
 
     private lazy var placeholderTextView: UITextView = {
         let placeholderTextView = buildTextView()
-        placeholderTextView.text = placeholderText
+        placeholderTextView.setMessageBody(.init(text: placeholderText, ranges: .empty), txProvider: databaseStorage.readTxProvider)
         placeholderTextView.isEditable = false
         placeholderTextView.isUserInteractionEnabled = false
         placeholderTextView.textContainer.maximumNumberOfLines = 1
@@ -297,7 +295,7 @@ class AttachmentTextToolbar: UIView {
         return wrapperView
     }()
 
-    private func buildTextView() -> BodyRangesTextView {
+    private func buildTextView() -> AttachmentTextView {
         let textView = AttachmentTextView()
         textView.keyboardAppearance = Theme.darkThemeKeyboardAppearance
         textView.backgroundColor = .clear
@@ -343,17 +341,21 @@ extension AttachmentTextToolbar: BodyRangesTextViewDelegate {
         return mentionTextViewDelegate?.textViewMentionPickerReferenceView(textView)
     }
 
-    func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView) -> [SignalServiceAddress] {
-        return mentionTextViewDelegate?.textViewMentionPickerPossibleAddresses(textView) ?? []
+    func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView, tx: DBReadTransaction) -> [SignalServiceAddress] {
+        return mentionTextViewDelegate?.textViewMentionPickerPossibleAddresses(textView, tx: tx) ?? []
     }
 
-    public func textViewMentionDisplayConfiguration(_ textView: BodyRangesTextView) -> MentionDisplayConfiguration {
-        return .composingAttachment
+    public func textViewDisplayConfiguration(_ textView: BodyRangesTextView) -> HydratedMessageBody.DisplayConfiguration {
+        return .init(mention: .composingAttachment, style: .composingAttachment, searchRanges: nil)
     }
 
     public func mentionPickerStyle(_ textView: BodyRangesTextView) -> MentionPickerStyle {
         return .composingAttachment
     }
+
+    public func textViewMentionCacheInvalidationKey(_ textView: BodyRangesTextView) -> String {
+        return mentionTextViewDelegate?.textViewMentionCacheInvalidationKey(textView) ?? UUID().uuidString
+    }
 }
 
 extension AttachmentTextToolbar: UITextViewDelegate {
diff --git a/SignalUI/ViewControllers/TextApprovalViewController.swift b/SignalUI/ViewControllers/TextApprovalViewController.swift
index a8aee5287e4..8ed74945dc6 100644
--- a/SignalUI/ViewControllers/TextApprovalViewController.swift
+++ b/SignalUI/ViewControllers/TextApprovalViewController.swift
@@ -95,7 +95,7 @@ public class TextApprovalViewController: OWSViewController, BodyRangesTextViewDe
 
     private func updateSendButton() {
         guard
-            !textView.text.isEmpty,
+            !textView.isEmpty,
             let recipientsDescription = delegate?.textApprovalRecipientsDescription(self)
         else {
             footerView.isHidden = true
@@ -123,7 +123,7 @@ public class TextApprovalViewController: OWSViewController, BodyRangesTextViewDe
     }()
 
     private func updateLinkPreviewText() {
-        linkPreviewFetcher.update(textView.text)
+        linkPreviewFetcher.update(textView.messageBodyForSending.text)
     }
 
     private func updateLinkPreviewView() {
@@ -159,7 +159,7 @@ public class TextApprovalViewController: OWSViewController, BodyRangesTextViewDe
         textView.backgroundColor = Theme.backgroundColor
         textView.textColor = Theme.primaryTextColor
         textView.font = UIFont.dynamicTypeBody
-        textView.messageBody = self.initialMessageBody
+        textView.setMessageBody(self.initialMessageBody, txProvider: DependenciesBridge.shared.db.readTxProvider)
         textView.contentInset = UIEdgeInsets(top: 0.0, left: 0.0, bottom: 0.0, right: 0.0)
         textView.textContainerInset = UIEdgeInsets(top: 10.0, left: 10.0, bottom: 10.0, right: 10.0)
     }
@@ -190,17 +190,24 @@ public class TextApprovalViewController: OWSViewController, BodyRangesTextViewDe
         return nil
     }
 
-    public func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView) -> [SignalServiceAddress] {
+    public func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView, tx: DBReadTransaction) -> [SignalServiceAddress] {
         return []
     }
 
-    public func textViewMentionDisplayConfiguration(_ textView: BodyRangesTextView) -> MentionDisplayConfiguration {
-        return .composing
+    public func textViewDisplayConfiguration(_ textView: BodyRangesTextView) -> HydratedMessageBody.DisplayConfiguration {
+        return .init(mention: .composing, style: .composing, searchRanges: nil)
     }
 
     public func mentionPickerStyle(_ textView: BodyRangesTextView) -> MentionPickerStyle {
         return .default
     }
+
+    // We want to invalidate the cache but reuse it within this same controller.
+    private let mentionCacheInvalidationKey = UUID().uuidString
+
+    public func textViewMentionCacheInvalidationKey(_ textView: BodyRangesTextView) -> String {
+        return mentionCacheInvalidationKey
+    }
 }
 
 // MARK: -
@@ -208,7 +215,7 @@ public class TextApprovalViewController: OWSViewController, BodyRangesTextViewDe
 extension TextApprovalViewController: ApprovalFooterDelegate {
     public func approvalFooterDelegateDidRequestProceed(_ approvalFooterView: ApprovalFooterView) {
         let linkPreviewDraft = linkPreviewFetcher.linkPreviewDraftIfLoaded
-        delegate?.textApproval(self, didApproveMessage: self.textView.messageBody, linkPreviewDraft: linkPreviewDraft)
+        delegate?.textApproval(self, didApproveMessage: self.textView.messageBodyForSending, linkPreviewDraft: linkPreviewDraft)
     }
 
     public func approvalMode(_ approvalFooterView: ApprovalFooterView) -> ApprovalMode {
diff --git a/SignalUI/Views/BodyRanges/BodyRangesTextView.swift b/SignalUI/Views/BodyRanges/BodyRangesTextView.swift
index d351ae387e3..bdaa0bd48de 100644
--- a/SignalUI/Views/BodyRanges/BodyRangesTextView.swift
+++ b/SignalUI/Views/BodyRanges/BodyRangesTextView.swift
@@ -11,9 +11,12 @@ public protocol BodyRangesTextViewDelegate: UITextViewDelegate {
 
     func textViewMentionPickerParentView(_ textView: BodyRangesTextView) -> UIView?
     func textViewMentionPickerReferenceView(_ textView: BodyRangesTextView) -> UIView?
-    func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView) -> [SignalServiceAddress]
+    // It doesn't matter what this key is; but when it changes cached mention names will be discarded.
+    // Typically, we want this to change in new thread contexts and such.
+    func textViewMentionCacheInvalidationKey(_ textView: BodyRangesTextView) -> String
+    func textViewMentionPickerPossibleAddresses(_ textView: BodyRangesTextView, tx: DBReadTransaction) -> [SignalServiceAddress]
 
-    func textViewMentionDisplayConfiguration(_ textView: BodyRangesTextView) -> MentionDisplayConfiguration
+    func textViewDisplayConfiguration(_ textView: BodyRangesTextView) -> HydratedMessageBody.DisplayConfiguration
     func mentionPickerStyle(_ textView: BodyRangesTextView) -> MentionPickerStyle
 }
 
@@ -31,10 +34,25 @@ open class BodyRangesTextView: OWSTextView {
         }
     }
 
+    private let customLayoutManager: NSLayoutManager
+
     public required init() {
-        super.init(frame: .zero, textContainer: nil)
+        let editableBody = EditableMessageBodyTextStorage(db: DependenciesBridge.shared.db)
+        self.editableBody = editableBody
+        let container = NSTextContainer()
+        let layoutManager = NSLayoutManager()
+        self.customLayoutManager = layoutManager
+        layoutManager.textStorage = editableBody
+        layoutManager.addTextContainer(container)
+        container.replaceLayoutManager(layoutManager)
+        super.init(frame: .zero, textContainer: container)
         updateTextContainerInset()
         delegate = self
+        editableBody.editableBodyDelegate = self
+    }
+
+    public override var layoutManager: NSLayoutManager {
+        return customLayoutManager
     }
 
     deinit {
@@ -59,9 +77,6 @@ open class BodyRangesTextView: OWSTextView {
             ),
             withMentionAddress: address
         )
-
-        // Add a space after the typed mention
-        replaceCharacters(in: selectedRange, with: " ")
     }
 
     public func replaceCharacters(
@@ -79,121 +94,32 @@ open class BodyRangesTextView: OWSTextView {
             text: "@",
             ranges: MessageBodyRanges(mentions: [NSRange(location: 0, length: 1): mentionUuid], styles: [])
         )
-        let hydrated = Self.databaseStorage.read { tx in
-            return body.hydrating(mentionHydrator: ContactsMentionHydrator.mentionHydrator(transaction: tx.asV2Read))
-        }
-
-        let replacementString: NSAttributedString
-        if mentionDelegate.textViewMentionPickerPossibleAddresses(self).contains(mentionAddress) {
-            let mentionConfig =  mentionDelegate.textViewMentionDisplayConfiguration(self)
-            replacementString = hydrated.asAttributedStringForDisplay(
-                config: HydratedMessageBody.DisplayConfiguration(
-                    mention: mentionConfig,
-                    style: .todo(),
-                    searchRanges: nil
-                ),
-                baseAttributes: [
-                    .font: mentionConfig.font,
-                    .foregroundColor: mentionConfig.foregroundColor.forCurrentTheme
-                ],
-                isDarkThemeEnabled: Theme.isDarkThemeEnabled
+        let (hydrated, possibleAddresses) = DependenciesBridge.shared.db.read { tx in
+            return (
+                body.hydrating(mentionHydrator: ContactsMentionHydrator.mentionHydrator(transaction: tx)),
+                mentionDelegate.textViewMentionPickerPossibleAddresses(self, tx: tx)
             )
-        } else {
-            // If we shouldn't resolve the mention, insert the plaintext representation.
-            replacementString = NSAttributedString(string: hydrated.asPlaintext(), attributes: defaultAttributes)
         }
+        let hydratedPlaintext = hydrated.asPlaintext()
 
-        replaceCharacters(in: range, with: replacementString)
-    }
-
-    public func replaceCharacters(in range: NSRange, with messageBody: MessageBody) {
-        guard let mentionDelegate = mentionDelegate else {
-            return owsFailDebug("Can't replace characters without delegate")
-        }
-
-        // This might perform a sneaky transaction, so needs to be outside the
-        // read block below.
-        var possibleMentionUUIDs = Set<UUID>()
-        mentionDelegate.textViewMentionPickerPossibleAddresses(self).forEach {
-            if let uuid = $0.uuid {
-                possibleMentionUUIDs.insert(uuid)
-            }
-        }
-        let mentionConfig = mentionDelegate.textViewMentionDisplayConfiguration(self)
-
-        let attributedBody = SDSDatabaseStorage.shared.read { transaction in
-            let contactHydrator = ContactsMentionHydrator.mentionHydrator(transaction: transaction.asV2Read)
-            return messageBody
-                .hydrating(mentionHydrator: { uuid in
-                    if possibleMentionUUIDs.contains(uuid) {
-                        return contactHydrator(uuid)
-                    } else {
-                        return .preserveMention
-                    }
-                })
-                .asAttributedStringForDisplay(
-                    config: HydratedMessageBody.DisplayConfiguration(
-                        mention: mentionConfig,
-                        style: .todo(),
-                        searchRanges: nil
-                    ),
-                    baseAttributes: [
-                        .font: mentionConfig.font,
-                        .foregroundColor: mentionConfig.foregroundColor.forCurrentTheme
-                    ],
-                    isDarkThemeEnabled: Theme.isDarkThemeEnabled
-                )
-        }
-
-        replaceCharacters(in: range, with: attributedBody)
-    }
-
-    public func replaceCharacters(in range: NSRange, with string: String) {
-        replaceCharacters(in: range, with: NSAttributedString(string: string, attributes: defaultAttributes))
-    }
-
-    public func replaceCharacters(in range: NSRange, with attributedString: NSAttributedString) {
-        let previouslySelectedRange = selectedRange
-
-        textStorage.replaceCharacters(in: range, with: attributedString)
-
-        updateSelectedRangeAfterReplacement(
-            previouslySelectedRange: previouslySelectedRange,
-            replacedRange: range,
-            replacementLength: attributedString.length
-        )
-
-        textViewDidChange(self)
-    }
-
-    private func updateSelectedRangeAfterReplacement(previouslySelectedRange: NSRange, replacedRange: NSRange, replacementLength: Int) {
-        let replacedRangeEnd = replacedRange.location + replacedRange.length
-
-        let replacedRangeIntersectsSelectedRange = previouslySelectedRange.location <= replacedRange.location
-            && previouslySelectedRange.location < replacedRangeEnd
-
-        let replacedRangeIsEntirelyBeforeSelectedRange = replacedRangeEnd <= previouslySelectedRange.location
-
-        // If the replaced range intersected the selected range, move the cursor after the replacement text
-        if replacedRangeIntersectsSelectedRange {
-            selectedRange = NSRange(location: replacedRange.location + replacementLength, length: 0)
-
-        // If the replaced range was entirely before the selected range, shift the selected range to
-        // account for our newly inserted text.
-        } else if replacedRangeIsEntirelyBeforeSelectedRange {
-            selectedRange = NSRange(
-                location: previouslySelectedRange.location + (replacementLength - replacedRange.length),
-                length: previouslySelectedRange.length
-            )
+        if possibleAddresses.contains(mentionAddress) {
+            editableBody.beginEditing()
+            editableBody.replaceCharacters(in: range, withMentionUUID: mentionUuid, txProvider: DependenciesBridge.shared.db.readTxProvider)
+            editableBody.endEditing()
+        } else {
+            // If we shouldn't resolve the mention, insert the plaintext representation.
+            editableBody.beginEditing()
+            editableBody.replaceCharacters(in: range, with: hydratedPlaintext, selectedRange: selectedRange)
+            editableBody.endEditing()
         }
     }
 
     public var currentlyTypingMentionText: String? {
         guard case .typingMention(let range) = state else { return nil }
-        guard textStorage.length >= range.location + range.length else { return nil }
+        guard (editableBody.hydratedPlaintext as NSString).length >= range.location + range.length else { return nil }
         guard range.length > 0 else { return "" }
 
-        return attributedText.attributedSubstring(from: range).string
+        return (editableBody.hydratedPlaintext as NSString).substring(with: range)
     }
 
     public var defaultAttributes: [NSAttributedString.Key: Any] {
@@ -203,24 +129,46 @@ open class BodyRangesTextView: OWSTextView {
         return defaultAttributes
     }
 
-    public var messageBody: MessageBody? {
-        get { RecoveredHydratedMessageBody.recover(from: attributedText.ows_stripped()).toMessageBody() }
+    public var isEmpty: Bool {
+        return editableBody.isEmpty
+    }
+
+    public var isWhitespaceOrEmpty: Bool {
+        return editableBody.hydratedPlaintext.filterForDisplay.isEmpty
+    }
+
+    @available(*, unavailable)
+    public override var text: String! {
+        get {
+            return textStorage.string
+        }
         set {
-            guard let newValue = newValue else {
-                replaceCharacters(
-                    in: textStorage.entireRange,
-                    with: ""
-                )
-                typingAttributes = defaultAttributes
-                return
-            }
-            replaceCharacters(
-                in: textStorage.entireRange,
-                with: newValue
-            )
+            // Ignore setters; this is illegal
+        }
+    }
+
+    @available(*, unavailable)
+    public override var attributedText: NSAttributedString! {
+        get {
+            return textStorage.attributedString()
+        }
+        set {
+            // Ignore setters; this is illegal
         }
     }
 
+    private let editableBody: EditableMessageBodyTextStorage
+
+    public var messageBodyForSending: MessageBody {
+        return editableBody.messageBody.filterStringForDisplay()
+    }
+
+    open func setMessageBody(_ messageBody: MessageBody?, txProvider: EditableMessageBodyTextStorage.ReadTxProvider) {
+        editableBody.beginEditing()
+        editableBody.setMessageBody(messageBody, txProvider: txProvider)
+        editableBody.endEditing()
+    }
+
     public func stopTypingMention() {
         state = .notTypingMention
     }
@@ -264,7 +212,9 @@ open class BodyRangesTextView: OWSTextView {
 
         pickerView?.removeFromSuperview()
 
-        let mentionableAddresses = mentionDelegate.textViewMentionPickerPossibleAddresses(self)
+        let mentionableAddresses = databaseStorage.read { tx in
+            return mentionDelegate.textViewMentionPickerPossibleAddresses(self, tx: tx.asV2Read)
+        }
 
         guard !mentionableAddresses.isEmpty else { return }
 
@@ -349,8 +299,7 @@ open class BodyRangesTextView: OWSTextView {
     }
 
     private func shouldUpdateMentionText(in range: NSRange, changedText text: String) -> Bool {
-        var deletedMentionRanges = Set<NSRange>()
-        let mentionRanges = RecoveredHydratedMessageBody.recover(from: textStorage).mentions().map(\.0)
+        let mentionRanges = editableBody.mentionRanges
 
         if range.length > 0 {
             // Locate any mentions in the edited range.
@@ -361,9 +310,6 @@ open class BodyRangesTextView: OWSTextView {
                 if mentionRange.location > range.upperBound {
                     break
                 }
-                if let intersection = range.intersection(mentionRange), intersection.length > 0 {
-                    deletedMentionRanges.insert(mentionRange)
-                }
             }
         } else if
             range.location > 0,
@@ -376,38 +322,6 @@ open class BodyRangesTextView: OWSTextView {
             typingAttributes = defaultAttributes
         }
 
-        if range.length == 0, range.location > 0, range.location < textStorage.length - 1 {
-            // If we're not at the start of the string, and we're not replacing
-            // any existing characters, check if we're typing in the middle of
-            // a mention. If so, we need to delete it.
-            if
-                let rightMention = mentionRanges.first(where: { mentionRange in
-                    return (range.intersection(mentionRange)?.length ?? 0) > 0
-                }) {
-                deletedMentionRanges.insert(rightMention)
-            }
-        }
-
-        for deletedMentionRange in deletedMentionRanges {
-
-            // Convert the mention to plain-text, in case we only deleted part of it
-            textStorage.setAttributes(defaultAttributes, range: deletedMentionRange)
-        }
-
-        // If the deleted range was the last character of a mention, we'll
-        // handle the delete internally. We remove the mention and replace it
-        // with an @ so the user can start typing a new mention to replace the
-        // deleted mention immediately.
-        if deletedMentionRanges.count == 1,
-            let deletedMentionRange = deletedMentionRanges.first,
-            range.length == 1,
-            text.isEmpty,
-            range.location == deletedMentionRange.location + deletedMentionRange.length - 1 {
-            replaceCharacters(in: deletedMentionRange, with: MentionAttribute.mentionPrefix)
-            selectedRange = NSRange(location: deletedMentionRange.location + MentionAttribute.mentionPrefix.count, length: 0)
-            return false
-        }
-
         return true
     }
 
@@ -416,7 +330,13 @@ open class BodyRangesTextView: OWSTextView {
         // We'll check again when the delegate is assigned.
         guard mentionDelegate != nil else { return }
 
-        guard selectedRange.length == 0, selectedRange.location > 0, textStorage.length > 0 else {
+        let bodyLength = (editableBody.hydratedPlaintext as NSString).length
+        guard
+            selectedRange.length == 0,
+            selectedRange.location > 0,
+            bodyLength > 0,
+            selectedRange.upperBound <= bodyLength
+        else {
             state = .notTypingMention
             return
         }
@@ -424,22 +344,18 @@ open class BodyRangesTextView: OWSTextView {
         var location = selectedRange.location
 
         while location > 0 {
-            let possibleAttributedPrefix = attributedText.attributedSubstring(
-                from: NSRange(location: location - MentionAttribute.mentionPrefix.count, length: MentionAttribute.mentionPrefix.count)
+            let possiblePrefix = editableBody.hydratedPlaintext.substring(
+                withRange: NSRange(location: location - MentionAttribute.mentionPrefix.count, length: MentionAttribute.mentionPrefix.count)
             )
 
-            let mentionRanges = RecoveredHydratedMessageBody.recover(
-                from: possibleAttributedPrefix
-            ).mentions().map(\.0)
+            let mentionRanges = editableBody.mentionRanges
 
             // If the previous character is part of a mention, we're not typing a mention
-            if mentionRanges.first(where: { $0.contains(0) }) != nil {
+            if mentionRanges.first(where: { $0.contains(location) }) != nil {
                 state = .notTypingMention
                 return
             }
 
-            let possiblePrefix = possibleAttributedPrefix.string
-
             // If we find whitespace before the selected range, we're not typing a mention.
             // Mention typing breaks on whitespace.
             if possiblePrefix.unicodeScalars.allSatisfy({ NSCharacterSet.whitespacesAndNewlines.contains($0) }) {
@@ -452,9 +368,9 @@ open class BodyRangesTextView: OWSTextView {
                 // If there's more text before the mention prefix, check if it's whitespace. Mentions
                 // only start at the beginning of the string OR after a whitespace character.
                 if location - MentionAttribute.mentionPrefix.count > 0 {
-                    let characterPrecedingPrefix = attributedText.attributedSubstring(
-                        from: NSRange(location: location - MentionAttribute.mentionPrefix.count - 1, length: MentionAttribute.mentionPrefix.count)
-                    ).string
+                    let characterPrecedingPrefix = editableBody.hydratedPlaintext.substring(
+                        withRange: NSRange(location: location - MentionAttribute.mentionPrefix.count - 1, length: MentionAttribute.mentionPrefix.count)
+                    )
 
                     // If it's not whitespace, keep looking back. Mention text can contain an "@" character,
                     // for example when trying to match a profile name that contains "@"
@@ -515,6 +431,10 @@ open class BodyRangesTextView: OWSTextView {
         super.buildMenu(with: builder)
     }
 
+    public func disallowsAnyPasteAction() -> Bool {
+        return isShowingFormatMenu
+    }
+
     open override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
         // We only mess with actions when there's a selection.
         guard FeatureFlags.textFormattingSend, selectedRange.length > 0 else {
@@ -531,6 +451,12 @@ open class BodyRangesTextView: OWSTextView {
             .contains(action) {
             return isShowingFormatMenu
         }
+        if action == #selector(didSelectClearStyles) {
+            guard isShowingFormatMenu, selectedRange.length > 0 else {
+                return false
+            }
+            return editableBody.hasFormatting(in: selectedRange)
+        }
 
         switch action {
         // Cut, copy, paste are let through as they are first in the list.
@@ -593,7 +519,13 @@ open class BodyRangesTextView: OWSTextView {
                 ]
                 UIMenuController.shared.menuItems = orderedStyles.map { style in
                     return UIMenuItem(title: style.displayText, action: self.uiMenuItemSelector(for: style))
-                }
+                } + [UIMenuItem(
+                    title: OWSLocalizedString(
+                        "TEXT_MENU_CLEAR_FORMATTING",
+                        comment: "Option in selected text edit menu to clear all text formatting in the selected text range"
+                    ),
+                    action: #selector(didSelectClearStyles)
+                )]
             } else {
                 UIMenuController.shared.menuItems = [
                     // to get format to show up before system menu items, put our format
@@ -690,7 +622,24 @@ open class BodyRangesTextView: OWSTextView {
         guard selectedRange.length > 0 else {
             return
         }
-        // TODO[TextFormattingSend]
+        editableBody.beginEditing()
+        editableBody.toggleStyle(style, in: selectedRange)
+        editableBody.endEditing()
+    }
+
+    @objc
+    private func didSelectClearStyles() {
+        guard FeatureFlags.textFormattingSend else {
+            return
+        }
+        Logger.info("Clearing styles")
+        isShowingFormatMenu = false
+        guard selectedRange.length > 0 else {
+            return
+        }
+        editableBody.beginEditing()
+        editableBody.clearFormatting(in: selectedRange)
+        editableBody.endEditing()
     }
 
     // MARK: - Text Container Insets
@@ -723,6 +672,47 @@ open class BodyRangesTextView: OWSTextView {
     }
 }
 
+// MARK: - EditableMessageBodyDelegate
+
+extension BodyRangesTextView: EditableMessageBodyDelegate {
+
+    public func editableMessageBodyDidRequestNewSelectedRange(_ newSelectedRange: NSRange) {
+        self.selectedRange = newSelectedRange
+    }
+
+    public func editableMessageBodyHydrator(tx: DBReadTransaction) -> MentionHydrator {
+        var possibleMentionUUIDs = Set<UUID>()
+        mentionDelegate?.textViewMentionPickerPossibleAddresses(self, tx: tx).forEach {
+            if let uuid = $0.uuid {
+                possibleMentionUUIDs.insert(uuid)
+            }
+        }
+        let hydrator = ContactsMentionHydrator.mentionHydrator(transaction: tx)
+        return { uuid in
+            guard possibleMentionUUIDs.contains(uuid) else {
+                return .preserveMention
+            }
+            return hydrator(uuid)
+        }
+    }
+
+    public func editableMessageBodyDisplayConfig() -> HydratedMessageBody.DisplayConfiguration {
+        return mentionDelegate?.textViewDisplayConfiguration(self) ?? .init(mention: .composing, style: .composing, searchRanges: nil)
+    }
+
+    public func isEditableMessageBodyDarkThemeEnabled() -> Bool {
+        return Theme.isDarkThemeEnabled
+    }
+
+    public func editableMessageSelectedRange() -> NSRange {
+        return selectedRange
+    }
+
+    public func mentionCacheInvalidationKey() -> String {
+        return mentionDelegate?.textViewMentionCacheInvalidationKey(self) ?? UUID().uuidString
+    }
+}
+
 // MARK: - Picker Keyboard Interaction
 
 extension BodyRangesTextView {
@@ -767,7 +757,9 @@ extension BodyRangesTextView {
 extension BodyRangesTextView {
     open override func cut(_ sender: Any?) {
         copy(sender)
-        replaceCharacters(in: selectedRange, with: "")
+        editableBody.beginEditing()
+        editableBody.replaceCharacters(in: selectedRange, with: "", selectedRange: selectedRange)
+        editableBody.endEditing()
     }
 
     public class func copyAttributedStringToPasteboard(_ attributedString: NSAttributedString) {
@@ -779,8 +771,7 @@ extension BodyRangesTextView {
             from: attributedString
         ).toMessageBody()
 
-        // TODO[TextFormatting]: apply text styles to copy pasted things?
-        if messageBody.hasMentions, let encodedMessageBody = try? NSKeyedArchiver.archivedData(withRootObject: messageBody, requiringSecureCoding: true) {
+        if messageBody.hasRanges, let encodedMessageBody = try? NSKeyedArchiver.archivedData(withRootObject: messageBody, requiringSecureCoding: true) {
             UIPasteboard.general.setItems([[Self.pasteboardType: encodedMessageBody]], options: [.localOnly: true])
         } else {
             UIPasteboard.general.setItems([], options: [:])
@@ -789,18 +780,29 @@ extension BodyRangesTextView {
         UIPasteboard.general.addItems([["public.utf8-plain-text": plaintextData]])
     }
 
-    public static var pasteboardType: String { SignalAttachment.mentionPasteboardType }
+    public static var pasteboardType: String { SignalAttachment.bodyRangesPasteboardType }
 
     open override func copy(_ sender: Any?) {
-        Self.copyAttributedStringToPasteboard(attributedText.attributedSubstring(from: selectedRange))
+        Self.copyAttributedStringToPasteboard(editableBody.attributedString.attributedSubstring(from: selectedRange))
     }
 
     open override func paste(_ sender: Any?) {
         if let encodedMessageBody = UIPasteboard.general.data(forPasteboardType: Self.pasteboardType),
-            let messageBody = try? NSKeyedUnarchiver.unarchivedObject(ofClass: MessageBody.self, from: encodedMessageBody) {
-            replaceCharacters(in: selectedRange, with: messageBody)
+            var messageBody = try? NSKeyedUnarchiver.unarchivedObject(ofClass: MessageBody.self, from: encodedMessageBody) {
+            editableBody.beginEditing()
+            DependenciesBridge.shared.db.read { tx in
+                if let possibleAddresses = mentionDelegate?.textViewMentionPickerPossibleAddresses(self, tx: tx) {
+                    messageBody = messageBody.forPasting(intoContextWithPossibleAddresses: possibleAddresses, transaction: tx)
+                }
+                editableBody.replaceCharacters(in: selectedRange, withPastedMessageBody: messageBody, txProvider: { $0(tx) })
+            }
+            editableBody.endEditing()
         } else if let string = UIPasteboard.general.strings?.first {
-            replaceCharacters(in: selectedRange, with: string)
+            editableBody.beginEditing()
+            editableBody.replaceCharacters(in: selectedRange, with: string, selectedRange: selectedRange)
+            editableBody.endEditing()
+            // Put the selection at the end of the new range.
+            self.selectedRange = NSRange(location: selectedRange.location + (string as NSString).length, length: 0)
         }
 
         if !textStorage.isEmpty {
@@ -818,6 +820,7 @@ extension BodyRangesTextView {
                 }
             }
         }
+        self.textViewDidChange(self)
     }
 }
 
@@ -839,7 +842,7 @@ extension BodyRangesTextView: UITextViewDelegate {
     open func textViewDidChange(_ textView: UITextView) {
         isShowingFormatMenu = false
         mentionDelegate?.textViewDidChange?(textView)
-        if textStorage.length == 0 { updateMentionState() }
+        if editableBody.hydratedPlaintext.isEmpty { updateMentionState() }
     }
 
     open func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
diff --git a/SignalUI/Views/BodyRanges/SpoilerDisplayConfigurations.swift b/SignalUI/Views/BodyRanges/SpoilerDisplayConfigurations.swift
index b1adb881560..34ea2e1c700 100644
--- a/SignalUI/Views/BodyRanges/SpoilerDisplayConfigurations.swift
+++ b/SignalUI/Views/BodyRanges/SpoilerDisplayConfigurations.swift
@@ -84,11 +84,31 @@ extension StyleDisplayConfiguration {
         dark: Theme.darkThemePrimaryColor
     )
 
-    // TODO: this a placeholder for some callsites
-    public static func todo() -> Self {
+    public static var composing: Self {
         return StyleDisplayConfiguration(
             baseFont: .dynamicTypeBody,
-            textColor: .fixed(.black),
+            textColor: ConversationStyle.bubbleTextColorIncomingThemed,
+            revealedSpoilerBgColor: ThemedColor(light: .ows_gray20, dark: .ows_gray60),
+            revealAllIds: true,
+            revealedIds: Set()
+        )
+    }
+
+    public static var composingAttachment: Self {
+        return StyleDisplayConfiguration(
+            baseFont: .dynamicTypeBody,
+            textColor: .fixed(Theme.darkThemePrimaryColor),
+            revealedSpoilerBgColor: .fixed(.ows_gray75),
+            revealAllIds: true,
+            revealedIds: Set()
+        )
+    }
+
+    public static var composingGroupReply: Self {
+        return StyleDisplayConfiguration(
+            baseFont: .dynamicTypeBody,
+            textColor: .fixed(.ows_gray05),
+            revealedSpoilerBgColor: .fixed(.ows_gray60),
             revealAllIds: true,
             revealedIds: Set()
         )
