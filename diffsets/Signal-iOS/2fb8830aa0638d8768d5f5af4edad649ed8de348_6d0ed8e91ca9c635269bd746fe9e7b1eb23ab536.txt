diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index dc1240d7e11..bea559cd43b 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -33,6 +33,7 @@
 		059982642C6D0C5200C87533 /* ChatListPinInfo.swift in Sources */ = {isa = PBXBuildFile; fileRef = 059982632C6D0C4F00C87533 /* ChatListPinInfo.swift */; };
 		05A180362CD1840F00579FA4 /* UIViewPropertyAnimator+SignalUI.swift in Sources */ = {isa = PBXBuildFile; fileRef = 05A180352CD1840F00579FA4 /* UIViewPropertyAnimator+SignalUI.swift */; };
 		05B411252C62845000A1EDBC /* ChatListInboxFilterSection.swift in Sources */ = {isa = PBXBuildFile; fileRef = 05B411242C62845000A1EDBC /* ChatListInboxFilterSection.swift */; };
+		05FDBC292CD91B31000C87BC /* ChatListContainerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 05FDBC282CD91B31000C87BC /* ChatListContainerView.swift */; };
 		0CE014267EDFBD2538E940A0 /* Pods_Signal.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 7FF88FB580BC19B240EEB86A /* Pods_Signal.framework */; };
 		1404D8B3276A353B0068E2F6 /* ChatListViewController+Multiselect.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1404D8B2276A353A0068E2F6 /* ChatListViewController+Multiselect.swift */; };
 		1466AB282817F7E7003B3D9F /* PluralAware.stringsdict in Resources */ = {isa = PBXBuildFile; fileRef = 1466AB262817F7E7003B3D9F /* PluralAware.stringsdict */; };
@@ -3650,6 +3651,7 @@
 		05EA61432CC943D200B16D4E /* Project-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Project-Release.xcconfig"; sourceTree = "<group>"; };
 		05EA61442CC943DD00B16D4E /* Project.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Project.xcconfig; sourceTree = "<group>"; };
 		05EA61472CC9491400B16D4E /* User.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = User.xcconfig; sourceTree = "<group>"; };
+		05FDBC282CD91B31000C87BC /* ChatListContainerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatListContainerView.swift; sourceTree = "<group>"; };
 		0BADD293DAFC82BF3274F0F6 /* Pods_SignalTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_SignalTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		1404D8B2276A353A0068E2F6 /* ChatListViewController+Multiselect.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ChatListViewController+Multiselect.swift"; sourceTree = "<group>"; };
 		1466AB272817F7E7003B3D9F /* en */ = {isa = PBXFileReference; lastKnownFileType = text.plist.stringsdict; name = en; path = translations/en.lproj/PluralAware.stringsdict; sourceTree = "<group>"; };
@@ -10495,6 +10497,7 @@
 			children = (
 				1489ED0127A3D70200C7043A /* ArchivedConversationsCell.swift */,
 				346E09002662FBBE0042375E /* ChatListCell.swift */,
+				05FDBC282CD91B31000C87BC /* ChatListContainerView.swift */,
 				052A33372C52BF410083D812 /* ChatListFilterActions.swift */,
 				0550A5DF2C3ECB230072CC02 /* ChatListFilterButton.swift */,
 				052647BE2C63BAC40076E99D /* ChatListFilterControl.swift */,
@@ -16128,6 +16131,7 @@
 				D9EB22212A4B636C00C73E1D /* CGContext+LineDrawing.swift in Sources */,
 				34546F502649989D007C4958 /* ChatColorViewController.swift in Sources */,
 				346E09012662FBBE0042375E /* ChatListCell.swift in Sources */,
+				05FDBC292CD91B31000C87BC /* ChatListContainerView.swift in Sources */,
 				052A33382C52BF410083D812 /* ChatListFilterActions.swift in Sources */,
 				0550A5E02C3ECB230072CC02 /* ChatListFilterButton.swift in Sources */,
 				052647BF2C63BAD60076E99D /* ChatListFilterControl.swift in Sources */,
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift b/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift
index 0d09b5e71c7..8b6fc855692 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/CLVTableDataSource.swift	
@@ -3,14 +3,9 @@
 // SPDX-License-Identifier: AGPL-3.0-only
 //
 
-private import ObjectiveC.runtime
 import SignalServiceKit
 public import SignalUI
 
-@objc protocol UIScrollViewExtendedDelegate: UIScrollViewDelegate {
-    @objc func scrollViewDidChangeContentSize(_ scrollView: UIScrollView)
-}
-
 class CLVTableDataSource: NSObject {
     private var viewState: CLVViewState!
 
@@ -858,8 +853,6 @@ extension CLVTableDataSource {
 public class CLVTableView: UITableView {
     fileprivate var lastReloadDate: Date?
 
-    private var contentSizeDidChange: ((UIScrollView) -> Void)?
-
     // A `tableFooterView` that always expands to fill available contentSize
     // when the table view contents otherwise wouldn't fill the space. This
     // supports Filter by Unread by helping to make transitions between very
@@ -881,46 +874,6 @@ public class CLVTableView: UITableView {
         fatalError("init(coder:) has not been implemented")
     }
 
-    public override var dataSource: (any UITableViewDataSource)? {
-        didSet {
-            updateExtendedScrollViewDelegate()
-        }
-    }
-
-    public override var delegate: (any UITableViewDelegate)? {
-        didSet {
-            updateExtendedScrollViewDelegate()
-        }
-    }
-
-    public override var contentSize: CGSize {
-        didSet {
-            if let contentSizeDidChange, contentSize != oldValue {
-                contentSizeDidChange(self)
-            }
-        }
-    }
-
-    // Tests that the scroll view delegate conforms to UIScrollViewExtendedDelegate
-    // and sets up a `contentSizeDidChange` callback that doesn't need to perform
-    // a dynamic cast on every call. This is similar to how UIScrollView checks
-    // whether its delegate responds to various selectors up front so that
-    // rapidly-called methods like `-scrollViewDidScroll:` don't pay the cost
-    // of a `-respondsToSelector:` check with every call.
-    private func updateExtendedScrollViewDelegate() {
-        if
-            let dataSource = dataSource as? CLVTableDataSource,
-            delegate === dataSource,
-            let scrollViewDelegate = dataSource.scrollViewDelegate as? UIScrollViewExtendedDelegate
-        {
-            contentSizeDidChange = { [weak scrollViewDelegate] scrollView in
-                scrollViewDelegate?.scrollViewDidChangeContentSize(scrollView)
-            }
-        } else {
-            contentSizeDidChange = nil
-        }
-    }
-
     public override func reloadData() {
         AssertIsOnMainThread()
 
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListContainerView.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListContainerView.swift
new file mode 100644
index 00000000000..d14b3698ff0
--- /dev/null
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListContainerView.swift	
@@ -0,0 +1,181 @@
+//
+// Copyright 2024 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+private import PureLayout
+private import SignalServiceKit
+import UIKit
+
+final class ChatListContainerView: UIView {
+    let tableView: CLVTableView
+    private unowned let searchBar: UISearchBar
+    private var adjustedContentOffset: CGPoint = .zero
+    private var needsFilterControlSizeChange = true
+    private var sizeForControllerTransition: CGSize?
+    private var smallestSafeArea = CGRect.infinite
+    private var observation: NSKeyValueObservation?
+    private var transitionAnimator: UIViewPropertyAnimator?
+    private var _filterControl: ChatListFilterControl?
+
+    private var isTransitioning: Bool {
+        transitionAnimator != nil
+    }
+
+    var filterControl: ChatListFilterControl? {
+        _filterControl
+    }
+
+    init(tableView: CLVTableView, searchBar: UISearchBar) {
+        self.searchBar = searchBar
+        self.tableView = tableView
+        super.init(frame: .zero)
+
+        addSubview(tableView)
+        tableView.autoPinEdgesToSuperviewEdges()
+
+        if FeatureFlags.chatListFilter {
+            let filterControl = ChatListFilterControl(container: self, scrollView: tableView)
+            _filterControl = filterControl
+            insertSubview(filterControl, aboveSubview: tableView)
+
+            observation = tableView.observe(\.contentOffset) { [unowned self] _, _ in
+                scrollPositionDidChange()
+                updateContentHeight()
+                filterControl.setAdjustedContentOffset(adjustedContentOffset)
+            }
+        }
+    }
+
+    @available(*, unavailable)
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    override func didMoveToWindow() {
+        super.didMoveToWindow()
+
+        if window != nil {
+            updateKnownSafeArea()
+        } else {
+            smallestSafeArea = .infinite
+        }
+    }
+
+    func willTransition(to size: CGSize, with coordinator: any UIViewControllerTransitionCoordinator) {
+        sizeForControllerTransition = size
+        smallestSafeArea = .infinite
+    }
+
+    override func safeAreaInsetsDidChange() {
+        super.safeAreaInsetsDidChange()
+
+        updateKnownSafeArea()
+    }
+
+    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
+        super.traitCollectionDidChange(previousTraitCollection)
+
+        if filterControl != nil, traitCollection.preferredContentSizeCategory != previousTraitCollection?.preferredContentSizeCategory {
+            // The filter control needs to match the size of the search bar, which
+            // changes depending on dynamic type. Set a flag so that we can
+            // calculate the new search bar size in `layoutSubviews()`.
+            needsFilterControlSizeChange = true
+            smallestSafeArea = .infinite
+            updateKnownSafeArea()
+            setNeedsLayout()
+        }
+    }
+
+    override func layoutSubviews() {
+        super.layoutSubviews()
+
+        defer {
+            needsFilterControlSizeChange = false
+
+            if let sizeForControllerTransition, bounds.size == sizeForControllerTransition {
+                self.sizeForControllerTransition = nil
+            }
+        }
+
+        if let filterControl, needsFilterControlSizeChange {
+            UIView.performWithoutAnimation {
+                let searchBarHeight = searchBar.systemLayoutSizeFitting(UIView.layoutFittingExpandedSize).height
+                filterControl.preferredContentHeight = searchBarHeight
+            }
+        }
+    }
+
+    // FIXME: unify this method with `ChatListFilterControl.State.isAnimatingTransition`
+    func animateTransition(withDuration duration: CGFloat, animations: @escaping () -> Void, completion: (() -> Void)? = nil) {
+        if let transitionAnimator {
+            // If we're already transitioning, just add the new animation to
+            // the in-progress transition.
+
+            transitionAnimator.addAnimations {
+                animations()
+            }
+
+            if let completion {
+                transitionAnimator.addCompletion { _ in
+                    completion()
+                }
+            }
+        } else {
+            let transitionAnimator = UIViewPropertyAnimator(duration: duration, curve: .easeInOut)
+            self.transitionAnimator = transitionAnimator
+
+            transitionAnimator.addAnimations {
+                animations()
+            }
+
+            transitionAnimator.addCompletion { _ in
+                self.transitionAnimator = nil
+                completion?()
+            }
+
+            transitionAnimator.startAnimation()
+        }
+    }
+
+    private func scrollPositionDidChange() {
+        var contentOffset = tableView.contentOffset
+        contentOffset.y += tableView.adjustedContentInset.top
+        adjustedContentOffset = contentOffset
+    }
+
+    private func updateContentHeight() {
+        guard !isTransitioning, let filterControl else { return }
+
+        let height = if filterControl.state >= .willStartFiltering {
+            filterControl.preferredContentHeight
+        } else {
+            max(0, min(filterControl.preferredContentHeight, tableView.contentInset.top - adjustedContentOffset.y))
+        }
+
+        UIView.performWithoutAnimation {
+            filterControl.frame = CGRect(x: 0, y: safeAreaInsets.top, width: bounds.width, height: height)
+        }
+    }
+
+    // A swipe threshold that feels good and is portable across many device
+    // sizes is about 25% of the scrollable area.
+    //
+    // In order to make the swipe gesture threshold relative to the visible
+    // scrollable area, we need to keep track of whenever the safe area gets
+    // smaller (which happens as the content insets are automatically adjusted
+    // to reveal the search bar), then recompute the threshold.
+    private func updateKnownSafeArea() {
+        guard let filterControl else { return }
+
+        let fullFrame = if let size = sizeForControllerTransition {
+            CGRect(origin: bounds.origin, size: size)
+        } else {
+            bounds
+        }
+        let layoutFrame = fullFrame.inset(by: safeAreaInsets)
+        smallestSafeArea = smallestSafeArea.intersection(layoutFrame)
+
+        filterControl.swipeGestureThreshold = smallestSafeArea.height * 0.25
+    }
+}
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift
index 1dae471839a..8a6ff449cd7 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListFilterControl.swift	
@@ -12,7 +12,7 @@ protocol ChatListFilterControlDelegate: AnyObject {
     func filterControlWillStartFiltering()
 }
 
-final class ChatListFilterControl: UIView, UIScrollViewDelegate {
+final class ChatListFilterControl: UIView {
     private struct AnimationFrame: CaseIterable {
         static let allCases = [
             AnimationFrame(step: 0, relativeStartTime: 0.01, relativeDuration: 0, isFiltering: false),
@@ -50,7 +50,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
     }
 
-    private enum State: Comparable {
+    enum State: Comparable {
         /// Control is not visible, filtering is disabled.
         case inactive
 
@@ -61,6 +61,10 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         /// Control is appearing, tracking scroll position.
         case tracking
 
+        /// `startFiltering()` was called to programmatically begin filtering,
+        /// and the transition is animating.
+        case starting
+
         /// Control enters this state while interactively dragging the scroll
         /// view, indicating that filtering will begin when the user lifts
         /// their finger and dragging ends. Can't return to `tracking` after
@@ -73,26 +77,39 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
 
         /// Actively filtering and control is docked to the top of the scroll view.
         case filtering
+
+        var isAnimatingTransition: Bool {
+            switch self {
+            case .starting, .stopping:
+                return true
+            case .inactive, .tracking, .willStartFiltering, .filterPending, .filtering:
+                return false
+            }
+        }
     }
 
+    private let animationFrames: [AnimationFrame]
     private let clearButton: ChatListFilterButton
-    private let clippingView: UIView
+    private let contentHeightConstraint: NSLayoutConstraint
     private let contentView: UIView
     private let imageContainer: UIView
     private let imageViews: [UIImageView]
-    private let animationFrames: [AnimationFrame]
+
+    private var contentTranslationConstraint: NSLayoutConstraint!
     private var feedback: UIImpactFeedbackGenerator?
     private var filterIconAnimator: UIViewPropertyAnimator?
+    private var fractionComplete: CGFloat = 0.0
+    private var scrollViewTransitionAnimator: UIViewPropertyAnimator?
+
+    private unowned let container: ChatListContainerView
+    private weak var scrollView: UIScrollView?
 
     weak var delegate: (any ChatListFilterControlDelegate)?
 
     private var adjustedContentOffset: CGPoint = .zero {
         didSet {
             if adjustedContentOffset != oldValue {
-                let position = max(0, -adjustedContentOffset.y)
-                let limit = contentHeight * 2
-                fractionComplete = min(1, position / limit)
-                setNeedsLayout()
+                updateFractionComplete()
             }
         }
     }
@@ -101,29 +118,14 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         UIView.inheritedAnimationDuration == 0 ? defaultDuration() : UIView.inheritedAnimationDuration
     }
 
-    private var contentHeight: CGFloat {
-        get { frame.size.height }
-        set { frame.size.height = newValue }
+    private func updateFractionComplete() {
+        let position = max(0, -adjustedContentOffset.y)
+        let limit = swipeGestureThreshold
+        fractionComplete = min(1, position / limit)
+        setNeedsLayout()
     }
 
-    private var fractionComplete: CGFloat = 0.0
-
-    // When set to `true`, disables all layout for the duration of an animated
-    // transition. This is automatically set by the `animateScrollViewTransition(_:completion:)`
-    // helper method.
-    private var isTransitioning = false {
-        didSet {
-            if !isTransitioning && oldValue {
-                setNeedsLayout()
-            }
-        }
-    }
-
-    private var scrollView: UIScrollView? {
-        superview as? UIScrollView
-    }
-
-    private var state = State.inactive {
+    private(set) var state = State.inactive {
         didSet {
             if state != oldValue {
                 setNeedsLayout()
@@ -145,48 +147,72 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
 
     /// Whether the control is in the filtering state or transitioning into it (i.e., pending).
     var isFiltering: Bool {
-        state >= .filterPending
+        switch state {
+        case .starting, .filterPending, .filtering:
+            return true
+        case .inactive, .tracking, .willStartFiltering, .stopping:
+            return false
+        }
     }
 
     var preferredContentHeight: CGFloat = 52.0 {
         didSet {
-            if state < .filterPending {
-                scrollView?.contentInset.top = -preferredContentHeight
-            }
+            contentHeightConstraint.constant = preferredContentHeight
             setNeedsLayout()
+
+            if state >= .filterPending {
+                updateContentInset(for: state)
+            }
+        }
+    }
+
+    var swipeGestureThreshold: CGFloat = 150.0 {
+        didSet {
+            swipeGestureThreshold = swipeGestureThreshold.clamp(75.0, 150.0)
+
+            if swipeGestureThreshold != oldValue {
+                updateFractionComplete()
+            }
         }
     }
 
-    override init(frame: CGRect) {
-        let bounds = CGRect(origin: .zero, size: frame.size)
-        clippingView = UIView(frame: bounds)
-        clippingView.autoresizesSubviews = false
-        clippingView.clipsToBounds = true
-        contentView = UIView(frame: bounds)
+    init(container: ChatListContainerView, scrollView: UIScrollView) {
+        self.container = container
+        self.scrollView = scrollView
+
+        contentView = UIView()
         contentView.autoresizesSubviews = false
+        contentView.translatesAutoresizingMaskIntoConstraints = false
+        contentHeightConstraint = contentView.heightAnchor.constraint(equalToConstant: preferredContentHeight)
+
         animationFrames = AnimationFrame.allCases
         imageViews = animationFrames.map { UIImageView(image: $0.image) }
         imageContainer = UIView()
         imageContainer.translatesAutoresizingMaskIntoConstraints = false
+
         clearButton = ChatListFilterButton()
         clearButton.alpha = 0
         clearButton.configuration?.title = OWSLocalizedString("CHAT_LIST_FILTERED_BY_UNREAD_CLEAR_BUTTON", comment: "Button at top of chat list indicating the active filter is 'Filtered by Unread' and tapping will clear the filter")
         clearButton.isUserInteractionEnabled = false
         clearButton.showsClearIcon = true
-        super.init(frame: frame)
 
-        autoresizesSubviews = false
+        super.init(frame: .zero)
+
+        clipsToBounds = true
         maximumContentSizeCategory = .extraExtraExtraLarge
         preservesSuperviewLayoutMargins = true
-        setContentHuggingPriority(.required, for: .vertical)
-        ensureContentHeight()
 
-        addSubview(clippingView)
-        clippingView.addSubview(contentView)
+        addSubview(contentView)
+        contentTranslationConstraint = contentView.bottomAnchor.constraint(equalTo: topAnchor, constant: 0)
+
         contentView.addSubview(imageContainer)
         contentView.insertSubview(clearButton, aboveSubview: imageContainer)
 
         NSLayoutConstraint.activate([
+            contentHeightConstraint,
+            contentTranslationConstraint,
+            contentView.leadingAnchor.constraint(equalTo: leadingAnchor),
+            contentView.trailingAnchor.constraint(equalTo: trailingAnchor),
             imageContainer.centerXAnchor.constraint(equalTo: contentView.centerXAnchor),
             imageContainer.centerYAnchor.constraint(equalTo: contentView.centerYAnchor),
         ])
@@ -224,10 +250,6 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         fatalError("unimplemented")
     }
 
-    private func ensureContentHeight() {
-        frame.size.height = preferredContentHeight
-    }
-
     override var intrinsicContentSize: CGSize {
         CGSize(width: UIView.noIntrinsicMetric, height: preferredContentHeight)
     }
@@ -247,17 +269,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
     override func didMoveToWindow() {
         super.didMoveToWindow()
 
-        updateContentInset()
-    }
-
-    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
-        // clippingView's position is logically relative to the scroll view's
-        // frame, not its bounds (i.e., it's docked near the top of the scroll
-        // view regardless of scroll position). This means we should ignore the
-        // default hit testing that's relative to scroll position and just
-        // consult clippingView directly.
-        let point = convert(point, to: clippingView)
-        return clippingView.hitTest(point, with: event)
+        updateContentInset(for: state)
     }
 
     @objc private func cancelFilterIconAnimator() {
@@ -309,12 +321,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         // we need to disable normal layout until the transition completes. This
         // makes animation code easier to understand because all layout changes
         // happen explicitly.
-        guard !isTransitioning else { return }
-
-        ensureContentHeight()
-        clippingView.frame.size = bounds.size
-        contentView.frame.size = bounds.size
-        contentView.layoutMargins = layoutMargins
+        guard !state.isAnimatingTransition else { return }
 
         updateContentOrigin()
 
@@ -329,54 +336,13 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
     }
 
     func updateContentOrigin() {
-        do {
-            var scrollIndicatorInset = max(0, -adjustedContentOffset.y)
-
-            if state >= .filterPending {
-                scrollIndicatorInset += contentHeight
-            }
-
-            scrollView?.verticalScrollIndicatorInsets.top = scrollIndicatorInset
-
-            // clippingView is offset so that its Y position is always at a
-            // logical content offset of 0, never behind the top bar. This
-            // prevents the contentView from blending with the navigation bar
-            // background material.
-            if let scrollView, let container = scrollView.superview {
-                let safeAreaRect = scrollView.frame.inset(by: scrollView.safeAreaInsets)
-                let contentOrigin = container.convert(safeAreaRect.origin, to: self)
-                clippingView.frame.origin = contentOrigin
-            }
-        }
-
-        // clippingView's height is adjusted so that it's only >0 in the
-        // overscroll area where the pull-to-filter gesture is occuring.
-        clippingView.frame.size.height = if state >= .willStartFiltering {
-            contentHeight
-        } else {
-            max(0, min(contentHeight, -adjustedContentOffset.y))
-        }
-
-        // contentView is a subview of clippingView so that it is clipped
-        // appropriately, but its position is first calculated in this view's
-        // coordinate space before being converted to clippingView. The effect
-        // is that clippingView acts as a sliding window over contentView and
-        // its children.
-        //
-        // An additional content translation factor is also applied to
-        // contentView so that it effectively scrolls at half the speed of the
-        // scroll gesture. Because the threshold for the gesture is
-        // `contentHeight * 2`, the result is that the gesture triggers at the
-        // moment that the content reaches its final scroll position
-        // (even though you've physically scrolled twice as far).
-        if state >= .willStartFiltering {
-            contentView.frame.origin = CGPoint(x: 0, y: clippingView.bounds.maxY - contentHeight)
-        } else {
-            let contentTranslation = fractionComplete * -contentHeight
-            var contentOrigin = CGPoint(x: 0, y: contentTranslation)
-            contentOrigin = convert(contentOrigin, to: clippingView)
-            contentOrigin.y = min(contentOrigin.y, 0)
-            contentView.frame.origin = contentOrigin
+        switch state {
+        case .inactive:
+            contentTranslationConstraint.constant = 0
+        case .tracking, .stopping:
+            contentTranslationConstraint.constant = fractionComplete * preferredContentHeight
+        case .starting, .willStartFiltering, .filterPending, .filtering:
+            contentTranslationConstraint.constant = preferredContentHeight
         }
     }
 
@@ -393,8 +359,8 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
     //        triggering unwanted delegate callbacks, and
     //     b) after changing the contentInset, explicitly adjusts the content
     //        *offset* by a complementary amount, preventing unwanted animation.
-    func updateContentInset() {
-        let newValue = state >= .filterPending ? 0 : -preferredContentHeight
+    private func updateContentInset(for state: State) {
+        let newValue = state >= .filterPending ? preferredContentHeight : 0
         guard let scrollView, scrollView.contentInset.top != newValue else { return }
         let difference = newValue - scrollView.contentInset.top
         var targetOffset = scrollView.contentOffset
@@ -404,60 +370,25 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
     }
 
     func startFiltering(animated: Bool) {
-        if animated {
-            animateScrollViewTransition(withDuration: animationDuration()) { [self] in
-                UIView.performWithoutAnimation {
-                    clippingView.frame = CGRect(x: 0, y: bounds.maxY, width: bounds.width, height: 0)
-                    contentView.frame = CGRect(x: 0, y: -contentHeight, width: 0, height: contentHeight)
-                    showClearButton(animated: false)
-                }
+        guard state != .filtering  else { return }
 
-                // The way UIScrollView converts contentInset changes into
-                // complementary contentOffset changes is for some reason
-                // different depending on whether the `contentSize` is big
-                // enough for the content to be scrollable.
-                //
-                // The following adjustment ensures that the new `contentOffset`
-                // is correct when the chat list is scrollable, and the change
-                // animates smoothly. However, if `contentSize` is small both
-                // before and after the this change (i.e., the chat list has a
-                // very small number of chats), this happens:
-                //
-                //   - The scroll view doesn't call `scrollViewDidScroll(_:)`
-                //   - `adjustedContentOffset` thus has a stale value
-                //   - Until the user next interacts with the scroll view, the
-                //     filter control will be rendered behind the search bar.
-                //
-                // The workaround is to manually call `updateScrollPosition(in:)`
-                // below so that we have a consistent content offset before
-                // `layoutSubviews()`.
-                if let scrollView {
-                    let previousInset = scrollView.adjustedContentInset.top
-                    scrollView.contentInset.top = 0
-                    let insetDifference = scrollView.adjustedContentInset.top - previousInset
-                    scrollView.contentOffset.y -= insetDifference
-                }
-
-                UIView.animate(withDuration: UIView.inheritedAnimationDuration) { [self] in
-                    clippingView.frame = bounds
-                }
+        if animated {
+            UIView.performWithoutAnimation {
+                state = .starting
+                updateContentOrigin()
+                showClearButton(animated: false)
+            }
 
-                UIView.animate(withDuration: UIView.inheritedAnimationDuration) { [self] in
-                    contentView.frame = clippingView.bounds
-                }
+            container.animateTransition(withDuration: animationDuration()) { [self] in
+                frame.height = preferredContentHeight
+                updateContentInset(for: .filtering)
             } completion: { [self] in
                 state = .filtering
-
-                // See comment in the animation block above explaining why it's
-                // necessary to manually call `updateScrollPosition(in:)`.
-                if let scrollView {
-                    updateScrollPosition(in: scrollView)
-                }
             }
         } else {
             showClearButton(animated: false)
             state = .filtering
-            updateContentInset()
+            updateContentInset(for: state)
         }
     }
 
@@ -470,17 +401,13 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
 
         if animated {
-            animateScrollViewTransition(withDuration: animationDuration()) { [self] in
-                clearButton.isUserInteractionEnabled = false
-                scrollView?.contentInset.top = -contentHeight
-
-                UIView.animate(withDuration: UIView.inheritedAnimationDuration) { [self] in
-                    clippingView.frame = CGRect(x: 0, y: bounds.maxY, width: bounds.width, height: 0)
-                }
+            state = .stopping
+            clearButton.isUserInteractionEnabled = false
 
-                UIView.animate(withDuration: UIView.inheritedAnimationDuration) { [self] in
-                    contentView.frame = CGRect(x: 0, y: -contentHeight, width: bounds.width, height: contentHeight)
-                }
+            container.animateTransition(withDuration: animationDuration()) { [self] in
+                contentTranslationConstraint.constant = 0
+                frame.height = 0
+                updateContentInset(for: .inactive)
             } completion: {
                 cleanUp()
             }
@@ -490,21 +417,22 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
     }
 
-    func updateScrollPosition(in scrollView: UIScrollView) {
-        do {
-            var contentOffset = scrollView.contentOffset
-            contentOffset.y += scrollView.adjustedContentInset.top
-            adjustedContentOffset = contentOffset
-        }
+    func setAdjustedContentOffset(_ adjustedContentOffset: CGPoint) {
+        self.adjustedContentOffset = adjustedContentOffset
 
-        if state == .tracking {
-            filterIconAnimator?.fractionComplete = fractionComplete
-
-            if fractionComplete == 1 {
-                feedback?.impactOccurred()
-                feedback = nil
-                state = .willStartFiltering
-            }
+        switch state {
+        case .tracking where fractionComplete == 1:
+            feedback?.impactOccurred()
+            feedback = nil
+            state = .willStartFiltering
+            filterIconAnimator?.fractionComplete = 1
+        case .tracking, .stopping:
+            // Limiting to 99% means that even if a rapid swipe has enough velocity
+            // to exceed the threshold, if the drag has stopped and we've moved to
+            // the 'stopping' state, the filter icon won't turn blue.
+            filterIconAnimator?.fractionComplete = min(fractionComplete, 0.99)
+        default:
+            break
         }
     }
 
@@ -525,7 +453,11 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         switch state {
         case .tracking:
             feedback = nil
-            state = .stopping
+            if scrollView.isTracking {
+                state = .stopping
+            } else {
+                state = .inactive
+            }
         case .willStartFiltering:
             delegate?.filterControlWillStartFiltering()
             state = .filterPending
@@ -536,7 +468,7 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
 
     func draggingDidEnd(in scrollView: UIScrollView) {
         if state == .filterPending {
-            updateContentInset()
+            updateContentInset(for: state)
             showClearButton(animated: true)
         }
     }
@@ -551,38 +483,6 @@ final class ChatListFilterControl: UIView, UIScrollViewDelegate {
         }
     }
 
-    private func animateScrollViewTransition(withDuration duration: CGFloat, _ animations: @escaping () -> Void, completion: (() -> Void)? = nil) {
-        guard !isTransitioning else {
-            owsFailDebug("already transitioning; falling back to default animation")
-
-            UIView.animate(withDuration: duration, delay: 0, options: .beginFromCurrentState) {
-                animations()
-            } completion: { _ in
-                completion?()
-            }
-
-            return
-        }
-
-        isTransitioning = true
-
-        if let scrollView {
-            UIView.transition(with: scrollView, duration: duration, options: .allowAnimatedContent) {
-                animations()
-            } completion: { [self] _ in
-                isTransitioning = false
-                completion?()
-            }
-        } else {
-            UIView.animate(withDuration: duration) {
-                animations()
-            } completion: { [self] _ in
-                isTransitioning = false
-                completion?()
-            }
-        }
-    }
-
     private func showClearButton(animated: Bool) {
         guard animated else {
             clearButton.alpha = 1
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift
index 0a14599953b..92a8d15ec16 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.swift	
@@ -34,12 +34,13 @@ public class ChatListViewController: OWSViewController, HomeTabViewController {
 
     // MARK: View Lifecycle
 
-    private lazy var filterControl: ChatListFilterControl? = if FeatureFlags.chatListFilter {
-        ChatListFilterControl()
-    } else {
-        nil
+    private var container: ChatListContainerView!
+    private var filterControl: ChatListFilterControl? { container.filterControl }
+
+    public override func loadView() {
+        container = ChatListContainerView(tableView: tableView, searchBar: searchBar)
+        view = container
     }
-    private var filterControlNeedsSizeChange = true
 
     public override func viewDidLoad() {
         super.viewDidLoad()
@@ -58,8 +59,6 @@ public class ChatListViewController: OWSViewController, HomeTabViewController {
         }
 
         // Table View
-        view.addSubview(tableView)
-        tableView.autoPinEdgesToSuperviewEdges()
         tableView.accessibilityIdentifier = "ChatListViewController.tableView"
         tableView.rowHeight = UITableView.automaticDimension
         tableView.estimatedRowHeight = 60
@@ -67,7 +66,6 @@ public class ChatListViewController: OWSViewController, HomeTabViewController {
         tableView.allowsMultipleSelectionDuringEditing = true
 
         if let filterControl {
-            tableView.tableHeaderView = filterControl
             filterControl.clearAction = .disableChatListFilter(target: self)
             filterControl.delegate = self
         }
@@ -252,16 +250,6 @@ public class ChatListViewController: OWSViewController, HomeTabViewController {
 
         if FeatureFlags.chatListFilter {
             updateFilterControl(animated: false)
-            updateFilterControlSize()
-        }
-    }
-
-    public override func viewWillLayoutSubviews() {
-        super.viewWillLayoutSubviews()
-
-        if let filterControl {
-            tableView.bringSubviewToFront(filterControl)
-            updateFilterControlSize()
         }
     }
 
@@ -308,6 +296,8 @@ public class ChatListViewController: OWSViewController, HomeTabViewController {
 
         guard isViewLoaded else { return }
 
+        container.willTransition(to: size, with: coordinator)
+
         // There is a subtle difference in when the split view controller
         // transitions between collapsed and expanded state on iPad vs
         // when it does on iPhone. We reloadData here in order to ensure
@@ -340,17 +330,6 @@ public class ChatListViewController: OWSViewController, HomeTabViewController {
         }
     }
 
-    public override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
-        super.traitCollectionDidChange(previousTraitCollection)
-
-        if traitCollection.preferredContentSizeCategory != previousTraitCollection?.preferredContentSizeCategory {
-            // The filter control needs to match the size of the search bar, which
-            // changes depending on dynamic type. Set a flag so that we can
-            // calculate the new search bar size in `viewDidLayoutSubviews()`.
-            filterControlNeedsSizeChange = true
-        }
-    }
-
     // MARK: UI Components
 
     private lazy var emptyInboxView: UIView = {
@@ -1385,11 +1364,9 @@ extension ChatListViewController {
             // filtering state.
             loadCoordinator.loadIfNecessary()
         } else {
-            UIView.animate(withDuration: CATransaction.animationDuration()) { [filterControl, loadCoordinator, tableView] in
-                tableView.performBatchUpdates { [loadCoordinator] in
-                    filterControl?.startFiltering(animated: true)
-                    loadCoordinator.loadIfNecessary()
-                }
+            UIView.animate(withDuration: CATransaction.animationDuration()) { [filterControl, loadCoordinator] in
+                filterControl?.startFiltering(animated: true)
+                loadCoordinator.loadIfNecessary()
             }
         }
     }
@@ -1417,24 +1394,6 @@ extension ChatListViewController {
         loadCoordinator.saveInboxFilter(inboxFilter)
         updateBarButtonItems()
     }
-
-    private func updateFilterControlSize() {
-        guard let filterControl, filterControlNeedsSizeChange else { return }
-        filterControlNeedsSizeChange = false
-
-        let searchBarHeight = searchBar.systemLayoutSizeFitting(UIView.layoutFittingExpandedSize).height
-
-        // Performed without animation so it can't interact with a view controller
-        // transition or some other animation.
-        UIView.performWithoutAnimation {
-            filterControl.preferredContentHeight = searchBarHeight
-
-            // This tells UITableView to perform a layout pass, which allows it
-            // to adjust to the new filterControl height even when there are no
-            // datasource-driven layout changes.
-            tableView.performBatchUpdates(nil)
-        }
-    }
 }
 
 // MARK: - Settings Button
@@ -1710,24 +1669,12 @@ extension ChatListViewController {
     }
 }
 
-extension ChatListViewController: UIScrollViewExtendedDelegate {
+extension ChatListViewController: UIScrollViewDelegate {
     public func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
         filterControl?.draggingWillBegin(in: scrollView)
         cancelSearch()
     }
 
-    public func scrollViewDidScroll(_ scrollView: UIScrollView) {
-        filterControl?.updateScrollPosition(in: scrollView)
-    }
-
-    public func scrollViewDidChangeAdjustedContentInset(_ scrollView: UIScrollView) {
-        filterControl?.updateScrollPosition(in: scrollView)
-    }
-
-    public func scrollViewDidChangeContentSize(_ scrollView: UIScrollView) {
-        filterControl?.updateScrollPosition(in: scrollView)
-    }
-
     public func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer<CGPoint>) {
         filterControl?.draggingWillEnd(in: scrollView)
     }
