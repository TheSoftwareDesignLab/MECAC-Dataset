diff --git a/Scripts/sds_codegen/sds_generate.py b/Scripts/sds_codegen/sds_generate.py
index e8be39d7cff..618185ba9a3 100755
--- a/Scripts/sds_codegen/sds_generate.py
+++ b/Scripts/sds_codegen/sds_generate.py
@@ -1128,26 +1128,7 @@ def write_column_metadata(property, force_optional=False):
     }
 
     func anyRemove(transaction: SDSAnyWriteTransaction) {
-        guard shouldBeSaved else {
-            // Skipping remove.
-            return
-        }
-        
-        anyWillRemove(with: transaction)
-
-        switch transaction.writeTransaction {
-        case .yapWrite(let ydbTransaction):
-            ydb_remove(with: ydbTransaction)
-        case .grdbWrite(let grdbTransaction):
-            do {
-                let record = try asRecord()
-                record.sdsRemove(transaction: grdbTransaction)
-            } catch {
-                owsFail("Remove failed: \(error)")
-            }
-        }
-        
-        anyDidRemove(with: transaction)
+        sdsRemove(transaction: transaction)
     }
 
     func anyReload(transaction: SDSAnyReadTransaction) {
@@ -1272,7 +1253,7 @@ class func anyEnumerate(transaction: SDSAnyReadTransaction, block: @escaping (%s
                         break
                     }
                 }
-            } catch let error as NSError {
+            } catch let error {
                 owsFailDebug("Couldn't fetch models: \(error)")
             }
         }
@@ -1349,12 +1330,20 @@ class func anyRemoveAllWithoutInstantation(transaction: SDSAnyWriteTransaction)
                 owsFailDebug("deleteAll() failed: \(error)")
             }
         }
+        
+        if shouldBeIndexedForFTS {
+            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
+        }
     }
     
     class func anyRemoveAllWithInstantation(transaction: SDSAnyWriteTransaction) {
         anyEnumerate(transaction: transaction) { (instance, stop) in
             instance.anyRemove(transaction: transaction)
         }
+        
+        if shouldBeIndexedForFTS {
+            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
+        }
     }
 }
 ''' % ( str(clazz.name),  record_name, )
diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 44e630135b1..4949b9363cc 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -183,6 +183,9 @@
 		3496957321A301A100DCFE74 /* OWSBackupJob.m in Sources */ = {isa = PBXBuildFile; fileRef = 3496956A21A301A100DCFE74 /* OWSBackupJob.m */; };
 		3496957421A301A100DCFE74 /* OWSBackupAPI.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3496956B21A301A100DCFE74 /* OWSBackupAPI.swift */; };
 		3499997822EA064100654932 /* YDBToGRDBMigrationTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3499997622EA063A00654932 /* YDBToGRDBMigrationTest.swift */; };
+		3499998122EF1E2100654932 /* SearcherTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3499997E22EF1E2100654932 /* SearcherTest.swift */; };
+		3499998222EF1E2100654932 /* GRDBFullTextSearcherTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3499997F22EF1E2100654932 /* GRDBFullTextSearcherTest.swift */; };
+		3499998322EF1E2100654932 /* YDBFullTextSearcherTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3499998022EF1E2100654932 /* YDBFullTextSearcherTest.swift */; };
 		349EA07C2162AEA800F7B17F /* OWS111UDAttributesMigration.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349EA07B2162AEA700F7B17F /* OWS111UDAttributesMigration.swift */; };
 		349ED990221B0194008045B0 /* Onboarding2FAViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349ED98F221B0194008045B0 /* Onboarding2FAViewController.swift */; };
 		349ED992221EE80D008045B0 /* AppPreferences.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349ED991221EE80D008045B0 /* AppPreferences.swift */; };
@@ -386,7 +389,6 @@
 		453518991FC63DBF00210559 /* SignalMessaging.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 453518921FC63DBF00210559 /* SignalMessaging.framework */; };
 		4535189A1FC63DBF00210559 /* SignalMessaging.framework in Embed Frameworks */ = {isa = PBXBuildFile; fileRef = 453518921FC63DBF00210559 /* SignalMessaging.framework */; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
 		453518A21FC63E2900210559 /* SignalMessaging.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 453518921FC63DBF00210559 /* SignalMessaging.framework */; };
-		45360B901F9527DA00FA666C /* SearcherTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45360B8F1F9527DA00FA666C /* SearcherTest.swift */; };
 		45360B911F952AA900FA666C /* MarqueeLabel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45E5A6981F61E6DD001E4A8A /* MarqueeLabel.swift */; };
 		4539B5861F79348F007141FF /* PushRegistrationManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4539B5851F79348F007141FF /* PushRegistrationManager.swift */; };
 		4541B71D209D3B7A0008608F /* ContactShareViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4541B71A209D2DAE0008608F /* ContactShareViewModel.swift */; };
@@ -912,6 +914,9 @@
 		3496956C21A301A100DCFE74 /* OWSBackupImportJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = OWSBackupImportJob.h; sourceTree = "<group>"; };
 		3496956D21A301A100DCFE74 /* OWSBackupIO.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = OWSBackupIO.h; sourceTree = "<group>"; };
 		3499997622EA063A00654932 /* YDBToGRDBMigrationTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = YDBToGRDBMigrationTest.swift; sourceTree = "<group>"; };
+		3499997E22EF1E2100654932 /* SearcherTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = SearcherTest.swift; sourceTree = "<group>"; };
+		3499997F22EF1E2100654932 /* GRDBFullTextSearcherTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GRDBFullTextSearcherTest.swift; sourceTree = "<group>"; };
+		3499998022EF1E2100654932 /* YDBFullTextSearcherTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = YDBFullTextSearcherTest.swift; sourceTree = "<group>"; };
 		349EA07B2162AEA700F7B17F /* OWS111UDAttributesMigration.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OWS111UDAttributesMigration.swift; sourceTree = "<group>"; };
 		349ED98F221B0194008045B0 /* Onboarding2FAViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Onboarding2FAViewController.swift; sourceTree = "<group>"; };
 		349ED991221EE80D008045B0 /* AppPreferences.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppPreferences.swift; sourceTree = "<group>"; };
@@ -1144,7 +1149,6 @@
 		453518941FC63DBF00210559 /* SignalMessaging.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = SignalMessaging.h; sourceTree = "<group>"; };
 		453518951FC63DBF00210559 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 		45360B8C1F9521F800FA666C /* Searcher.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Searcher.swift; sourceTree = "<group>"; };
-		45360B8F1F9527DA00FA666C /* SearcherTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearcherTest.swift; sourceTree = "<group>"; };
 		4539B5851F79348F007141FF /* PushRegistrationManager.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PushRegistrationManager.swift; sourceTree = "<group>"; };
 		453CC0361D08E1A60040EBA3 /* sn */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = sn; path = translations/sn.lproj/Localizable.strings; sourceTree = "<group>"; };
 		4541B71A209D2DAE0008608F /* ContactShareViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContactShareViewModel.swift; sourceTree = "<group>"; };
@@ -1969,6 +1973,16 @@
 			path = Backup;
 			sourceTree = "<group>";
 		};
+		3499997D22EF1E2100654932 /* FTS */ = {
+			isa = PBXGroup;
+			children = (
+				3499997F22EF1E2100654932 /* GRDBFullTextSearcherTest.swift */,
+				3499997E22EF1E2100654932 /* SearcherTest.swift */,
+				3499998022EF1E2100654932 /* YDBFullTextSearcherTest.swift */,
+			);
+			path = FTS;
+			sourceTree = "<group>";
+		};
 		34B3F8331E8DF1700035BE1A /* ViewControllers */ = {
 			isa = PBXGroup;
 			children = (
@@ -2681,6 +2695,7 @@
 			children = (
 				3421981B21061D2E00C57195 /* ByteParserTest.swift */,
 				45E7A6A61E71CA7E00D44FB5 /* DisplayableTextFilterTest.swift */,
+				3499997D22EF1E2100654932 /* FTS */,
 				B660F6AD1C29868000687D6E /* FunctionalUtilTest.m */,
 				455AC69D1F4F8B0300134004 /* ImageCacheTest.swift */,
 				34DB0BEC2011548B007B313F /* OWSDatabaseConverterTest.m */,
@@ -2688,7 +2703,6 @@
 				45666F571D9B2880008FE134 /* OWSScrubbingLogFormatterTest.m */,
 				34E8A8D02085238900B272B1 /* ProtoParsingTest.m */,
 				3491D9A021022DB7001EF5A1 /* RemoteAttestationSigningCertificateTest.m */,
-				45360B8F1F9527DA00FA666C /* SearcherTest.swift */,
 				452D1AF02081059C00A67F7F /* StringAdditionsTest.swift */,
 				B660F6B31C29868000687D6E /* UtilTest.h */,
 				B660F6B41C29868000687D6E /* UtilTest.m */,
@@ -3929,12 +3943,13 @@
 				34BBC861220E883300857249 /* ImageEditorModelTest.swift in Sources */,
 				340B02BA1FA0D6C700F9CFEC /* ConversationViewItemTest.m in Sources */,
 				458E383A1D6699FA0094BD24 /* OWSDeviceProvisioningURLParserTest.m in Sources */,
+				3499998222EF1E2100654932 /* GRDBFullTextSearcherTest.swift in Sources */,
 				3421981C21061D2E00C57195 /* ByteParserTest.swift in Sources */,
 				34843B26214327C9004DED45 /* OWSOrphanDataCleanerTest.m in Sources */,
 				4C04F58421C860C50090D0BB /* MantlePerfTest.swift in Sources */,
-				45360B901F9527DA00FA666C /* SearcherTest.swift in Sources */,
 				34BBC862220E883300857249 /* ImageEditorTest.swift in Sources */,
 				34DB0BED2011548B007B313F /* OWSDatabaseConverterTest.m in Sources */,
+				3499998122EF1E2100654932 /* SearcherTest.swift in Sources */,
 				34843B2C214FE296004DED45 /* MockEnvironment.m in Sources */,
 				45360B911F952AA900FA666C /* MarqueeLabel.swift in Sources */,
 				454EBAB41F2BE14C00ACE0BB /* OWSAnalytics.swift in Sources */,
@@ -3949,6 +3964,7 @@
 				4C5250D421E7C51900CE3D95 /* PhoneNumberValidatorTest.swift in Sources */,
 				3499997822EA064100654932 /* YDBToGRDBMigrationTest.swift in Sources */,
 				452D1AF12081059C00A67F7F /* StringAdditionsTest.swift in Sources */,
+				3499998322EF1E2100654932 /* YDBFullTextSearcherTest.swift in Sources */,
 				4C4BC6C32102D697004040C9 /* ContactDiscoveryOperationTest.swift in Sources */,
 				455AC69E1F4F8B0300134004 /* ImageCacheTest.swift in Sources */,
 				34E8A8D12085238A00B272B1 /* ProtoParsingTest.m in Sources */,
diff --git a/Signal/src/ConversationSearch.swift b/Signal/src/ConversationSearch.swift
index 85cbc008536..802cdc3ae00 100644
--- a/Signal/src/ConversationSearch.swift
+++ b/Signal/src/ConversationSearch.swift
@@ -19,6 +19,14 @@ public protocol ConversationSearchControllerDelegate: UISearchControllerDelegate
 @objc
 public class ConversationSearchController: NSObject {
 
+    // MARK: - Dependencies
+
+    private var databaseStorage: SDSDatabaseStorage {
+        return SDSDatabaseStorage.shared
+    }
+
+    // MARK: -
+
     @objc
     public static let kMinimumSearchTextLength: UInt = 2
 
@@ -54,12 +62,6 @@ public class ConversationSearchController: NSObject {
     func applyTheme() {
         OWSSearchBar.applyTheme(to: uiSearchController.searchBar)
     }
-
-    // MARK: Dependencies
-
-    var dbReadConnection: YapDatabaseConnection {
-        return OWSPrimaryStorage.shared().dbReadConnection
-    }
 }
 
 extension ConversationSearchController: UISearchControllerDelegate {
@@ -97,12 +99,12 @@ extension ConversationSearchController: UISearchResultsUpdating {
         }
 
         var resultSet: ConversationScreenSearchResultSet?
-        self.dbReadConnection.asyncRead({ [weak self] transaction in
+        databaseStorage.asyncRead(block: { [weak self] transaction in
             guard let self = self else {
                 return
             }
             resultSet = self.dbSearcher.searchWithinConversation(thread: self.thread, searchText: searchText, transaction: transaction)
-        }, completionBlock: { [weak self] in
+        }, completion: { [weak self] in
             guard let self = self else {
                 return
             }
diff --git a/Signal/src/ViewControllers/ConversationPicker/ConversationPicker.swift b/Signal/src/ViewControllers/ConversationPicker/ConversationPicker.swift
index b2bd570cfc6..367d78b3412 100644
--- a/Signal/src/ViewControllers/ConversationPicker/ConversationPicker.swift
+++ b/Signal/src/ViewControllers/ConversationPicker/ConversationPicker.swift
@@ -127,9 +127,8 @@ class ConversationPickerViewController: OWSViewController {
 
         return DispatchQueue.global().async(.promise) {
             return self.databaseStorage.readReturningResult { transaction in
-                // GRDB TODO - reconcile with GRDB FTS work
                 return self.fullTextSearcher.searchForComposeScreen(searchText: searchText,
-                                                                    transaction: transaction.transitional_yapReadTransaction!)
+                                                                    transaction: transaction)
             }
         }
     }
diff --git a/Signal/src/ViewControllers/NewContactThreadViewController.m b/Signal/src/ViewControllers/NewContactThreadViewController.m
index e6dda8087f9..49209ddd2fc 100644
--- a/Signal/src/ViewControllers/NewContactThreadViewController.m
+++ b/Signal/src/ViewControllers/NewContactThreadViewController.m
@@ -81,14 +81,14 @@ - (FullTextSearcher *)fullTextSearcher
     return FullTextSearcher.shared;
 }
 
-- (YapDatabaseConnection *)uiDatabaseConnection
+- (OWSContactsManager *)contactsManager
 {
-    return OWSPrimaryStorage.sharedManager.uiDatabaseConnection;
+    return Environment.shared.contactsManager;
 }
 
-- (OWSContactsManager *)contactsManager
+- (SDSDatabaseStorage *)databaseStorage
 {
-    return Environment.shared.contactsManager;
+    return SDSDatabaseStorage.shared;
 }
 
 #pragma mark -
@@ -954,12 +954,12 @@ - (void)searchTextDidChange
 
     __weak __typeof(self) weakSelf = self;
 
-    [self.uiDatabaseConnection
-        asyncReadWithBlock:^(YapDatabaseReadTransaction *_Nonnull transaction) {
+    [self.databaseStorage
+        asyncUIReadWithBlock:^(SDSAnyReadTransaction *transaction) {
             self.searchResults = [self.fullTextSearcher searchForComposeScreenWithSearchText:searchText
                                                                                  transaction:transaction];
         }
-        completionBlock:^{
+        completion:^{
             __typeof(self) strongSelf = weakSelf;
             if (!strongSelf) {
                 return;
diff --git a/Signal/test/SignalBaseTest.m b/Signal/test/SignalBaseTest.m
index eab6d7ca5f4..63b21f6d9db 100644
--- a/Signal/test/SignalBaseTest.m
+++ b/Signal/test/SignalBaseTest.m
@@ -10,6 +10,14 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
+@interface SignalBaseTest ()
+
+@property (nonatomic) YapDatabaseConnection *ydbConnection;
+
+@end
+
+#pragma mark -
+
 @implementation SignalBaseTest
 
 - (void)setUp
@@ -25,6 +33,8 @@ - (void)setUp
     SetCurrentAppContext([TestAppContext new]);
     [MockSSKEnvironment activate];
     [MockEnvironment activate];
+
+    self.ydbConnection = [SSKEnvironment.shared.primaryStorage newDatabaseConnection];
 }
 
 - (void)tearDown
@@ -47,15 +57,17 @@ -(void)writeWithBlock:(void (^)(SDSAnyWriteTransaction *))block
 - (void)yapReadWithBlock:(void (^)(YapDatabaseReadTransaction *transaction))block
 {
     OWSAssert(block);
+    OWSAssert(self.ydbConnection);
 
-    [[SSKEnvironment.shared.primaryStorage newDatabaseConnection] readWithBlock:block];
+    [self.ydbConnection readWithBlock:block];
 }
 
 - (void)yapWriteWithBlock:(void (^)(YapDatabaseReadWriteTransaction *transaction))block
 {
     OWSAssert(block);
+    OWSAssert(self.ydbConnection);
 
-    [[SSKEnvironment.shared.primaryStorage newDatabaseConnection] readWriteWithBlock:block];
+    [self.ydbConnection readWriteWithBlock:block];
 }
 
 @end
diff --git a/Signal/test/util/FTS/GRDBFullTextSearcherTest.swift b/Signal/test/util/FTS/GRDBFullTextSearcherTest.swift
new file mode 100644
index 00000000000..85dde2b0651
--- /dev/null
+++ b/Signal/test/util/FTS/GRDBFullTextSearcherTest.swift
@@ -0,0 +1,524 @@
+//
+//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//
+
+import XCTest
+@testable import Signal
+@testable import SignalMessaging
+
+// TODO: We might be able to merge this with OWSFakeContactsManager.
+@objc
+class GRDBFullTextSearcherContactsManager: NSObject, ContactsManagerProtocol {
+    func displayName(for address: SignalServiceAddress?, transaction: SDSAnyReadTransaction) -> String {
+        return self.displayName(for: address)
+    }
+
+    func displayName(for address: SignalServiceAddress?) -> String {
+        if address == aliceRecipient {
+            return "Alice"
+        } else if address == bobRecipient {
+            return "Bob Barker"
+        } else {
+            return ""
+        }
+    }
+
+    func signalAccounts() -> [SignalAccount] {
+        return []
+    }
+
+    func isSystemContact(_ recipientId: String) -> Bool {
+        return true
+    }
+
+    func isSystemContact(withSignalAccount recipientId: String) -> Bool {
+        return true
+    }
+
+    func compare(signalAccount left: SignalAccount, with right: SignalAccount) -> ComparisonResult {
+        owsFailDebug("if this method ends up being used by the tests, we should provide a better implementation.")
+
+        return .orderedAscending
+    }
+
+    func cnContact(withId contactId: String?) -> CNContact? {
+        return nil
+    }
+
+    func avatarData(forCNContactId contactId: String?) -> Data? {
+        return nil
+    }
+
+    func avatarImage(forCNContactId contactId: String?) -> UIImage? {
+        return nil
+    }
+}
+
+private let bobRecipient = SignalServiceAddress(phoneNumber: "+49030183000")
+private let aliceRecipient = SignalServiceAddress(phoneNumber: "+12345678900")
+
+// MARK: -
+
+class GRDBFullTextSearcherTest: SignalBaseTest {
+
+    // MARK: - Dependencies
+
+    var searcher: FullTextSearcher {
+        return FullTextSearcher.shared
+    }
+
+    // MARK: - Test Life Cycle
+
+    override func tearDown() {
+        super.tearDown()
+    }
+
+    override func setUp() {
+        super.setUp()
+
+        // Replace this singleton.
+        SSKEnvironment.shared.contactsManager = GRDBFullTextSearcherContactsManager()
+
+        self.write { transaction in
+            let bookModel = TSGroupModel(title: "Book Club", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            let bookClubGroupThread = TSGroupThread.getOrCreateThread(with: bookModel, transaction: transaction)
+            self.bookClubThread = ThreadViewModel(thread: bookClubGroupThread, transaction: transaction)
+
+            let snackModel = TSGroupModel(title: "Snack Club", members: [aliceRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            let snackClubGroupThread = TSGroupThread.getOrCreateThread(with: snackModel, transaction: transaction)
+            self.snackClubThread = ThreadViewModel(thread: snackClubGroupThread, transaction: transaction)
+
+            let aliceContactThread = TSContactThread.getOrCreateThread(withContactAddress: aliceRecipient, transaction: transaction)
+            self.aliceThread = ThreadViewModel(thread: aliceContactThread, transaction: transaction)
+
+            let bobContactThread = TSContactThread.getOrCreateThread(withContactAddress: bobRecipient, transaction: transaction)
+            self.bobEmptyThread = ThreadViewModel(thread: bobContactThread, transaction: transaction)
+
+            let helloAlice = TSOutgoingMessage(in: aliceContactThread, messageBody: "Hello Alice", attachmentId: nil)
+            helloAlice.anyInsert(transaction: transaction)
+
+            let goodbyeAlice = TSOutgoingMessage(in: aliceContactThread, messageBody: "Goodbye Alice", attachmentId: nil)
+            goodbyeAlice.anyInsert(transaction: transaction)
+
+            let helloBookClub = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "Hello Book Club", attachmentId: nil)
+            helloBookClub.anyInsert(transaction: transaction)
+
+            let goodbyeBookClub = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "Goodbye Book Club", attachmentId: nil)
+            goodbyeBookClub.anyInsert(transaction: transaction)
+
+            let bobsPhoneNumber = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "My phone number is: 321-321-4321", attachmentId: nil)
+            bobsPhoneNumber.anyInsert(transaction: transaction)
+
+            let bobsFaxNumber = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "My fax is: 222-333-4444", attachmentId: nil)
+            bobsFaxNumber.anyInsert(transaction: transaction)
+        }
+    }
+
+    // MARK: - Fixtures
+
+    var bookClubThread: ThreadViewModel!
+    var snackClubThread: ThreadViewModel!
+
+    var aliceThread: ThreadViewModel!
+    var bobEmptyThread: ThreadViewModel!
+
+    // MARK: Tests
+
+    private func AssertEqualThreadLists(_ left: [ThreadViewModel], _ right: [ThreadViewModel], file: StaticString = #file, line: UInt = #line) {
+        XCTAssertEqual(left.count, right.count, file: file, line: line)
+        guard left.count != right.count else {
+            return
+        }
+        // Only bother comparing uniqueIds.
+        let leftIds = left.map { $0.threadRecord.uniqueId }
+        let rightIds = right.map { $0.threadRecord.uniqueId }
+        XCTAssertEqual(leftIds, rightIds, file: file, line: line)
+    }
+
+    func testSearchByGroupName() {
+        var threads: [ThreadViewModel] = []
+
+        // No Match
+        threads = searchConversations(searchText: "asdasdasd")
+        XCTAssert(threads.isEmpty)
+
+        // Partial Match
+        threads = searchConversations(searchText: "Book")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([bookClubThread], threads)
+
+        threads = searchConversations(searchText: "Snack")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([snackClubThread], threads)
+
+        // Multiple Partial Matches
+        threads = searchConversations(searchText: "Club")
+        XCTAssertEqual(2, threads.count)
+        AssertEqualThreadLists([bookClubThread, snackClubThread], threads)
+
+        // Match Name Exactly
+        threads = searchConversations(searchText: "Book Club")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([bookClubThread], threads)
+    }
+
+    func testSearchContactByNumber() {
+        var threads: [ThreadViewModel] = []
+
+        // No match
+        threads = searchConversations(searchText: "+5551239999")
+        XCTAssertEqual(0, threads.count)
+
+        // Exact match
+        threads = searchConversations(searchText: aliceRecipient.phoneNumber!)
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        // Partial match
+        threads = searchConversations(searchText: "+123456")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        // Prefixes
+        threads = searchConversations(searchText: "12345678900")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        threads = searchConversations(searchText: "49")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([bookClubThread], threads)
+
+        threads = searchConversations(searchText: "1-234-56")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        threads = searchConversations(searchText: "123456")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        threads = searchConversations(searchText: "1.234.56")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        threads = searchConversations(searchText: "1 234 56")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+    }
+
+    func testSearchContactByNumberWithoutCountryCode() {
+        var threads: [ThreadViewModel] = []
+        // Phone Number formatting should be forgiving
+        threads = searchConversations(searchText: "234.56")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        threads = searchConversations(searchText: "234 56")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+    }
+
+    func testSearchConversationByContactByName() {
+        var threads: [ThreadViewModel] = []
+
+        threads = searchConversations(searchText: "Alice")
+        XCTAssertEqual(3, threads.count)
+        AssertEqualThreadLists([bookClubThread, aliceThread, snackClubThread], threads)
+
+        threads = searchConversations(searchText: "Bob")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([bookClubThread], threads)
+
+        threads = searchConversations(searchText: "Barker")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([bookClubThread], threads)
+
+        threads = searchConversations(searchText: "Bob B")
+        XCTAssertEqual(1, threads.count)
+        AssertEqualThreadLists([bookClubThread], threads)
+    }
+
+    func testSearchMessageByBodyContent() {
+        var resultSet: HomeScreenSearchResultSet = .empty
+
+        resultSet = getResultSet(searchText: "Hello Alice")
+        XCTAssertEqual(1, resultSet.messages.count)
+        AssertEqualThreadLists([aliceThread], resultSet.messages.map { $0.thread })
+
+        resultSet = getResultSet(searchText: "Hello")
+        XCTAssertEqual(2, resultSet.messages.count)
+        AssertEqualThreadLists([aliceThread, bookClubThread], resultSet.messages.map { $0.thread })
+    }
+
+    func testSearchEdgeCases() {
+        var resultSet: HomeScreenSearchResultSet = .empty
+
+        resultSet = getResultSet(searchText: "Hello Alice")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "hello alice")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "Hel")
+        XCTAssertEqual(2, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice", "Hello Book Club"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "Hel Ali")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "Hel Ali Alic")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "Ali Hel")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "CLU")
+        XCTAssertEqual(2, resultSet.messages.count)
+        XCTAssertEqual(["Goodbye Book Club", "Hello Book Club"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "hello !@##!@#!$^@!@#! alice")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["Hello Alice"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "3213 phone")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["My phone number is: 321-321-4321"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "PHO 3213")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["My phone number is: 321-321-4321"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "fax")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["My fax is: 222-333-4444"], bodies(forMessageResults: resultSet.messages))
+
+        resultSet = getResultSet(searchText: "fax 2223")
+        XCTAssertEqual(1, resultSet.messages.count)
+        XCTAssertEqual(["My fax is: 222-333-4444"], bodies(forMessageResults: resultSet.messages))
+    }
+
+    // MARK: - More Tests
+
+    func testModelLifecycle1() {
+
+        var thread: TSGroupThread! = nil
+        self.write { transaction in
+            let groupModel = TSGroupModel(title: "Lifecycle", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            thread = TSGroupThread.getOrCreateThread(with: groupModel, transaction: transaction)
+        }
+
+        let message1 = TSOutgoingMessage(in: thread, messageBody: "This world contains glory and despair.", attachmentId: nil)
+        let message2 = TSOutgoingMessage(in: thread, messageBody: "This world contains hope and despair.", attachmentId: nil)
+
+        XCTAssertEqual(0, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+
+        self.write { transaction in
+            message1.anyInsert(transaction: transaction)
+            message2.anyInsert(transaction: transaction)
+        }
+
+        XCTAssertEqual(1, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(2, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+
+        self.write { transaction in
+            message1.update(withMessageBody: "This world contains glory and defeat.", transaction: transaction)
+        }
+
+        XCTAssertEqual(1, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "DEFEAT").messages.count)
+
+        self.write { transaction in
+            message1.anyRemove(transaction: transaction)
+        }
+
+        XCTAssertEqual(0, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+
+        self.write { transaction in
+            message2.anyRemove(transaction: transaction)
+        }
+
+        XCTAssertEqual(0, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+    }
+
+    func testModelLifecycle2() {
+
+        self.write { transaction in
+            let groupModel = TSGroupModel(title: "Lifecycle", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            let thread = TSGroupThread.getOrCreateThread(with: groupModel, transaction: transaction)
+
+            let message1 = TSOutgoingMessage(in: thread, messageBody: "This world contains glory and despair.", attachmentId: nil)
+            let message2 = TSOutgoingMessage(in: thread, messageBody: "This world contains hope and despair.", attachmentId: nil)
+
+            message1.anyInsert(transaction: transaction)
+            message2.anyInsert(transaction: transaction)
+        }
+
+        XCTAssertEqual(1, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(2, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+
+        self.write { transaction in
+            TSInteraction.anyRemoveAllWithInstantation(transaction: transaction)
+        }
+
+        XCTAssertEqual(0, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+    }
+
+    func testModelLifecycle3() {
+
+        self.write { transaction in
+            let groupModel = TSGroupModel(title: "Lifecycle", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            let thread = TSGroupThread.getOrCreateThread(with: groupModel, transaction: transaction)
+
+            let message1 = TSOutgoingMessage(in: thread, messageBody: "This world contains glory and despair.", attachmentId: nil)
+            let message2 = TSOutgoingMessage(in: thread, messageBody: "This world contains hope and despair.", attachmentId: nil)
+
+            message1.anyInsert(transaction: transaction)
+            message2.anyInsert(transaction: transaction)
+        }
+
+        XCTAssertEqual(1, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(2, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+
+        self.write { transaction in
+            TSInteraction.anyRemoveAllWithoutInstantation(transaction: transaction)
+        }
+
+        XCTAssertEqual(0, getResultSet(searchText: "GLORY").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "HOPE").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DESPAIR").messages.count)
+        XCTAssertEqual(0, getResultSet(searchText: "DEFEAT").messages.count)
+    }
+
+    func testDiacritics() {
+
+        self.write { transaction in
+            let groupModel = TSGroupModel(title: "Lifecycle", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            let thread = TSGroupThread.getOrCreateThread(with: groupModel, transaction: transaction)
+
+            TSOutgoingMessage(in: thread, messageBody: "NO칆L and S칒RINA and ADRI츼N and FRAN칂OIS and NU칌EZ and Bj칬rk.", attachmentId: nil).anyInsert(transaction: transaction)
+        }
+
+        XCTAssertEqual(1, getResultSet(searchText: "NO칆L").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "noel").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "S칒RINA").messages.count)
+        // I guess 칒 isn't a diacritical mark but a separate letter.
+        XCTAssertEqual(0, getResultSet(searchText: "sorina").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "ADRI츼N").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "adrian").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "FRAN칂OIS").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "francois").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "NU칌EZ").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "nunez").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "Bj칬rk").messages.count)
+        XCTAssertEqual(1, getResultSet(searchText: "Bjork").messages.count)
+    }
+
+    private func AssertValidResultSet(query: String, expectedResultCount: Int, file: StaticString = #file, line: UInt = #line) {
+        // For these simple test cases, the snippet should contain the entire query.
+        let expectedSnippetContent: String = query
+
+        let resultSet = getResultSet(searchText: query)
+        XCTAssertEqual(expectedResultCount, resultSet.messages.count, file: file, line: line)
+        for result in resultSet.messages {
+            guard let snippet = result.snippet else {
+                XCTFail("Missing snippet.", file: file, line: line)
+                continue
+            }
+            XCTAssertTrue(snippet.lowercased().contains(expectedSnippetContent.lowercased()), file: file, line: line)
+        }
+    }
+
+    func testSnippets() {
+
+        var thread: TSGroupThread! = nil
+        self.write { transaction in
+            let groupModel = TSGroupModel(title: "Lifecycle", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
+            thread = TSGroupThread.getOrCreateThread(with: groupModel, transaction: transaction)
+        }
+
+        let message1 = TSOutgoingMessage(in: thread, messageBody: "This world contains glory and despair.", attachmentId: nil)
+        let message2 = TSOutgoingMessage(in: thread, messageBody: "This world contains hope and despair.", attachmentId: nil)
+
+        AssertValidResultSet(query: "GLORY", expectedResultCount: 0)
+        AssertValidResultSet(query: "HOPE", expectedResultCount: 0)
+        AssertValidResultSet(query: "DESPAIR", expectedResultCount: 0)
+        AssertValidResultSet(query: "DEFEAT", expectedResultCount: 0)
+
+        self.write { transaction in
+            message1.anyInsert(transaction: transaction)
+            message2.anyInsert(transaction: transaction)
+        }
+
+        AssertValidResultSet(query: "GLORY", expectedResultCount: 1)
+        AssertValidResultSet(query: "HOPE", expectedResultCount: 1)
+        AssertValidResultSet(query: "DESPAIR", expectedResultCount: 2)
+        AssertValidResultSet(query: "DEFEAT", expectedResultCount: 0)
+    }
+
+    // MARK: - Helpers
+
+    func bodies<T>(forMessageResults messageResults: [ConversationSearchResult<T>]) -> [String] {
+        var result = [String]()
+
+        self.read { transaction in
+            for messageResult in messageResults {
+                guard let messageId = messageResult.messageId else {
+                    owsFailDebug("message result missing message id")
+                    continue
+                }
+                guard let interaction = TSInteraction.anyFetch(uniqueId: messageId, transaction: transaction) else {
+                    owsFailDebug("couldn't load interaction for message result")
+                    continue
+                }
+                guard let message = interaction as? TSMessage else {
+                    owsFailDebug("invalid message for message result")
+                    continue
+                }
+                guard let messageBody = message.body else {
+                    owsFailDebug("message result missing message body")
+                    continue
+                }
+                result.append(messageBody)
+            }
+        }
+
+        return result.sorted()
+    }
+
+    private func searchConversations(searchText: String) -> [ThreadViewModel] {
+        let results = getResultSet(searchText: searchText)
+        return results.conversations.map { $0.thread }
+    }
+
+    private func getResultSet(searchText: String) -> HomeScreenSearchResultSet {
+        var results: HomeScreenSearchResultSet!
+        self.read { transaction in
+            results = self.searcher.searchForHomeScreen(searchText: searchText, transaction: transaction, contactsManager: SSKEnvironment.shared.contactsManager)
+        }
+        return results
+    }
+}
diff --git a/Signal/test/util/FTS/SearcherTest.swift b/Signal/test/util/FTS/SearcherTest.swift
new file mode 100644
index 00000000000..6f46cb0bcd6
--- /dev/null
+++ b/Signal/test/util/FTS/SearcherTest.swift
@@ -0,0 +1,99 @@
+//
+//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//
+
+import XCTest
+@testable import Signal
+@testable import SignalMessaging
+
+class SearcherTest: SignalBaseTest {
+
+    struct TestCharacter {
+        let name: String
+        let description: String
+        let phoneNumber: String?
+    }
+
+    let smerdyakov = TestCharacter(name: "Pavel Fyodorovich Smerdyakov", description: "A rusty hue in the sky", phoneNumber: nil)
+    let stinkingLizaveta = TestCharacter(name: "Stinking Lizaveta", description: "object of pity", phoneNumber: "+13235555555")
+    let regularLizaveta = TestCharacter(name: "Lizaveta", description: "", phoneNumber: "1 (415) 555-5555")
+
+    let indexer = { (character: TestCharacter) in
+        return "\(character.name) \(character.description) \(character.phoneNumber ?? "")"
+    }
+
+    var searcher: Searcher<TestCharacter> {
+        return Searcher(indexer: indexer)
+    }
+
+    override func setUp() {
+        super.setUp()
+        // Put setup code here. This method is called before the invocation of each test method in the class.
+    }
+
+    override func tearDown() {
+        // Put teardown code here. This method is called after the invocation of each test method in the class.
+        super.tearDown()
+    }
+
+    func testSimple() {
+        XCTAssert(searcher.matches(item: smerdyakov, query: "Pavel"))
+        XCTAssert(searcher.matches(item: smerdyakov, query: "pavel"))
+        XCTAssertFalse(searcher.matches(item: smerdyakov, query: "asdf"))
+        XCTAssertFalse(searcher.matches(item: smerdyakov, query: ""))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Pity"))
+    }
+
+    func testRepeats() {
+        XCTAssert(searcher.matches(item: smerdyakov, query: "pavel pavel"))
+        XCTAssertFalse(searcher.matches(item: smerdyakov, query: "pavelpavel"))
+    }
+
+    func testSplitWords() {
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Lizaveta"))
+        XCTAssert(searcher.matches(item: regularLizaveta, query: "Lizaveta"))
+
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Stinking Lizaveta"))
+        XCTAssertFalse(searcher.matches(item: regularLizaveta, query: "Stinking Lizaveta"))
+
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Lizaveta Stinking"))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Lizaveta St"))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "  Lizaveta St "))
+    }
+
+    func testFormattingChars() {
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "323"))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "1-323-555-5555"))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "13235555555"))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "+1-323"))
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Liza +1-323"))
+
+        // Sanity check, match both by names
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Liza"))
+        XCTAssert(searcher.matches(item: regularLizaveta, query: "Liza"))
+
+        // Disambiguate the two Liza's by area code
+        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Liza 323"))
+        XCTAssertFalse(searcher.matches(item: regularLizaveta, query: "Liza 323"))
+    }
+
+    func testSearchQuery() {
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza"), "\"Liza\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza +1-323"), "\"1323\"* \"Liza\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "\"\\ `~!@#$%^&*()_+-={}|[]:;'<>?,./Liza +1-323"), "\"1323\"* \"Liza\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "renaldo RENALDO re침aldo RE칌ALDO"), "\"RENALDO\"* \"RE칌ALDO\"* \"renaldo\"* \"re침aldo\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "游땚"), "\"游땚\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "alice 123 bob 456"), "\"123456\"* \"alice\"* \"bob\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Li!za"), "\"Liza\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza Liza"), "\"Liza\"*")
+        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza liza"), "\"Liza\"* \"liza\"*")
+    }
+
+    func testTextNormalization() {
+        XCTAssertEqual(FullTextSearchFinder.normalize(text: "Liza"), "Liza")
+        XCTAssertEqual(FullTextSearchFinder.normalize(text: "Liza +1-323"), "Liza 1323")
+        XCTAssertEqual(FullTextSearchFinder.normalize(text: "\"\\ `~!@#$%^&*()_+-={}|[]:;'<>?,./Liza +1-323"), "Liza 1323")
+        XCTAssertEqual(FullTextSearchFinder.normalize(text: "renaldo RENALDO re침aldo RE칌ALDO"), "renaldo RENALDO re침aldo RE칌ALDO")
+        XCTAssertEqual(FullTextSearchFinder.normalize(text: "游땚"), "游땚")
+    }
+}
diff --git a/Signal/test/util/SearcherTest.swift b/Signal/test/util/FTS/YDBFullTextSearcherTest.swift
similarity index 67%
rename from Signal/test/util/SearcherTest.swift
rename to Signal/test/util/FTS/YDBFullTextSearcherTest.swift
index b1462d2814e..003a07db28d 100644
--- a/Signal/test/util/SearcherTest.swift
+++ b/Signal/test/util/FTS/YDBFullTextSearcherTest.swift
@@ -8,7 +8,7 @@ import XCTest
 
 // TODO: We might be able to merge this with OWSFakeContactsManager.
 @objc
-class FullTextSearcherContactsManager: NSObject, ContactsManagerProtocol {
+class YDBFullTextSearcherContactsManager: NSObject, ContactsManagerProtocol {
     func displayName(for address: SignalServiceAddress?, transaction: SDSAnyReadTransaction) -> String {
         return self.displayName(for: address)
     }
@@ -57,7 +57,9 @@ class FullTextSearcherContactsManager: NSObject, ContactsManagerProtocol {
 private let bobRecipient = SignalServiceAddress(phoneNumber: "+49030183000")
 private let aliceRecipient = SignalServiceAddress(phoneNumber: "+12345678900")
 
-class FullTextSearcherTest: SignalBaseTest {
+// MARK: -
+
+class YDBFullTextSearcherTest: SignalBaseTest {
 
     // MARK: - Dependencies
 
@@ -65,10 +67,6 @@ class FullTextSearcherTest: SignalBaseTest {
         return FullTextSearcher.shared
     }
 
-    var databaseStorage: SDSDatabaseStorage {
-        return SDSDatabaseStorage.shared
-    }
-
     // MARK: - Test Life Cycle
 
     override func tearDown() {
@@ -78,43 +76,43 @@ class FullTextSearcherTest: SignalBaseTest {
     override func setUp() {
         super.setUp()
 
-        FullTextSearchFinder.ensureDatabaseExtensionRegistered(storage: OWSPrimaryStorage.shared())
+        YDBFullTextSearchFinder.ensureDatabaseExtensionRegistered(storage: OWSPrimaryStorage.shared())
 
         // Replace this singleton.
-        SSKEnvironment.shared.contactsManager = FullTextSearcherContactsManager()
+        SSKEnvironment.shared.contactsManager = YDBFullTextSearcherContactsManager()
 
-        self.write { transaction in
+        self.yapWrite { transaction in
             let bookModel = TSGroupModel(title: "Book Club", members: [aliceRecipient, bobRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
-            let bookClubGroupThread = TSGroupThread.getOrCreateThread(with: bookModel, transaction: transaction)
-            self.bookClubThread = ThreadViewModel(thread: bookClubGroupThread, transaction: transaction)
+            let bookClubGroupThread = TSGroupThread.getOrCreateThread(with: bookModel, transaction: transaction.asAnyWrite)
+            self.bookClubThread = ThreadViewModel(thread: bookClubGroupThread, transaction: transaction.asAnyRead)
 
             let snackModel = TSGroupModel(title: "Snack Club", members: [aliceRecipient], image: nil, groupId: Randomness.generateRandomBytes(kGroupIdLength))
-            let snackClubGroupThread = TSGroupThread.getOrCreateThread(with: snackModel, transaction: transaction)
-            self.snackClubThread = ThreadViewModel(thread: snackClubGroupThread, transaction: transaction)
+            let snackClubGroupThread = TSGroupThread.getOrCreateThread(with: snackModel, transaction: transaction.asAnyWrite)
+            self.snackClubThread = ThreadViewModel(thread: snackClubGroupThread, transaction: transaction.asAnyRead)
 
-            let aliceContactThread = TSContactThread.getOrCreateThread(withContactAddress: aliceRecipient, transaction: transaction)
-            self.aliceThread = ThreadViewModel(thread: aliceContactThread, transaction: transaction)
+            let aliceContactThread = TSContactThread.getOrCreateThread(withContactAddress: aliceRecipient, transaction: transaction.asAnyWrite)
+            self.aliceThread = ThreadViewModel(thread: aliceContactThread, transaction: transaction.asAnyRead)
 
-            let bobContactThread = TSContactThread.getOrCreateThread(withContactAddress: bobRecipient, transaction: transaction)
-            self.bobEmptyThread = ThreadViewModel(thread: bobContactThread, transaction: transaction)
+            let bobContactThread = TSContactThread.getOrCreateThread(withContactAddress: bobRecipient, transaction: transaction.asAnyWrite)
+            self.bobEmptyThread = ThreadViewModel(thread: bobContactThread, transaction: transaction.asAnyRead)
 
             let helloAlice = TSOutgoingMessage(in: aliceContactThread, messageBody: "Hello Alice", attachmentId: nil)
-            helloAlice.anyInsert(transaction: transaction)
+            helloAlice.anyInsert(transaction: transaction.asAnyWrite)
 
             let goodbyeAlice = TSOutgoingMessage(in: aliceContactThread, messageBody: "Goodbye Alice", attachmentId: nil)
-            goodbyeAlice.anyInsert(transaction: transaction)
+            goodbyeAlice.anyInsert(transaction: transaction.asAnyWrite)
 
             let helloBookClub = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "Hello Book Club", attachmentId: nil)
-            helloBookClub.anyInsert(transaction: transaction)
+            helloBookClub.anyInsert(transaction: transaction.asAnyWrite)
 
             let goodbyeBookClub = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "Goodbye Book Club", attachmentId: nil)
-            goodbyeBookClub.anyInsert(transaction: transaction)
+            goodbyeBookClub.anyInsert(transaction: transaction.asAnyWrite)
 
             let bobsPhoneNumber = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "My phone number is: 321-321-4321", attachmentId: nil)
-            bobsPhoneNumber.anyInsert(transaction: transaction)
+            bobsPhoneNumber.anyInsert(transaction: transaction.asAnyWrite)
 
             let bobsFaxNumber = TSOutgoingMessage(in: bookClubGroupThread, messageBody: "My fax is: 222-333-4444", attachmentId: nil)
-            bobsFaxNumber.anyInsert(transaction: transaction)
+            bobsFaxNumber.anyInsert(transaction: transaction.asAnyWrite)
         }
     }
 
@@ -238,6 +236,7 @@ class FullTextSearcherTest: SignalBaseTest {
         XCTAssertEqual(aliceThread, resultSet.messages.first?.thread)
 
         resultSet = getResultSet(searchText: "Hello")
+
         XCTAssertEqual(2, resultSet.messages.count)
         XCTAssert(resultSet.messages.map { $0.thread }.contains(aliceThread))
         XCTAssert(resultSet.messages.map { $0.thread }.contains(bookClubThread))
@@ -300,13 +299,13 @@ class FullTextSearcherTest: SignalBaseTest {
     func bodies<T>(forMessageResults messageResults: [ConversationSearchResult<T>]) -> [String] {
         var result = [String]()
 
-        self.read { transaction in
+        self.yapRead { transaction in
             for messageResult in messageResults {
                 guard let messageId = messageResult.messageId else {
                     owsFailDebug("message result missing message id")
                     continue
                 }
-                guard let interaction = TSInteraction.anyFetch(uniqueId: messageId, transaction: transaction) else {
+                guard let interaction = TSInteraction.anyFetch(uniqueId: messageId, transaction: transaction.asAnyRead) else {
                     owsFailDebug("couldn't load interaction for message result")
                     continue
                 }
@@ -332,101 +331,9 @@ class FullTextSearcherTest: SignalBaseTest {
 
     private func getResultSet(searchText: String) -> HomeScreenSearchResultSet {
         var results: HomeScreenSearchResultSet!
-        self.databaseStorage.read { transaction in
-            results = self.searcher.searchForHomeScreen(searchText: searchText, transaction: transaction, contactsManager: SSKEnvironment.shared.contactsManager)
+        self.yapRead { transaction in
+            results = self.searcher.searchForHomeScreen(searchText: searchText, transaction: transaction.asAnyRead, contactsManager: SSKEnvironment.shared.contactsManager)
         }
         return results
     }
 }
-
-class SearcherTest: SignalBaseTest {
-
-    struct TestCharacter {
-        let name: String
-        let description: String
-        let phoneNumber: String?
-    }
-
-    let smerdyakov = TestCharacter(name: "Pavel Fyodorovich Smerdyakov", description: "A rusty hue in the sky", phoneNumber: nil)
-    let stinkingLizaveta = TestCharacter(name: "Stinking Lizaveta", description: "object of pity", phoneNumber: "+13235555555")
-    let regularLizaveta = TestCharacter(name: "Lizaveta", description: "", phoneNumber: "1 (415) 555-5555")
-
-    let indexer = { (character: TestCharacter) in
-        return "\(character.name) \(character.description) \(character.phoneNumber ?? "")"
-    }
-
-    var searcher: Searcher<TestCharacter> {
-        return Searcher(indexer: indexer)
-    }
-
-    override func setUp() {
-        super.setUp()
-        // Put setup code here. This method is called before the invocation of each test method in the class.
-    }
-
-    override func tearDown() {
-        // Put teardown code here. This method is called after the invocation of each test method in the class.
-        super.tearDown()
-    }
-
-    func testSimple() {
-        XCTAssert(searcher.matches(item: smerdyakov, query: "Pavel"))
-        XCTAssert(searcher.matches(item: smerdyakov, query: "pavel"))
-        XCTAssertFalse(searcher.matches(item: smerdyakov, query: "asdf"))
-        XCTAssertFalse(searcher.matches(item: smerdyakov, query: ""))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Pity"))
-    }
-
-    func testRepeats() {
-        XCTAssert(searcher.matches(item: smerdyakov, query: "pavel pavel"))
-        XCTAssertFalse(searcher.matches(item: smerdyakov, query: "pavelpavel"))
-    }
-
-    func testSplitWords() {
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Lizaveta"))
-        XCTAssert(searcher.matches(item: regularLizaveta, query: "Lizaveta"))
-
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Stinking Lizaveta"))
-        XCTAssertFalse(searcher.matches(item: regularLizaveta, query: "Stinking Lizaveta"))
-
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Lizaveta Stinking"))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Lizaveta St"))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "  Lizaveta St "))
-    }
-
-    func testFormattingChars() {
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "323"))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "1-323-555-5555"))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "13235555555"))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "+1-323"))
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Liza +1-323"))
-
-        // Sanity check, match both by names
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Liza"))
-        XCTAssert(searcher.matches(item: regularLizaveta, query: "Liza"))
-
-        // Disambiguate the two Liza's by area code
-        XCTAssert(searcher.matches(item: stinkingLizaveta, query: "Liza 323"))
-        XCTAssertFalse(searcher.matches(item: regularLizaveta, query: "Liza 323"))
-    }
-
-    func testSearchQuery() {
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza"), "\"Liza\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza +1-323"), "\"1323\"* \"Liza\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "\"\\ `~!@#$%^&*()_+-={}|[]:;'<>?,./Liza +1-323"), "\"1323\"* \"Liza\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "renaldo RENALDO re침aldo RE칌ALDO"), "\"RENALDO\"* \"RE칌ALDO\"* \"renaldo\"* \"re침aldo\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "游땚"), "\"游땚\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "alice 123 bob 456"), "\"123456\"* \"alice\"* \"bob\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Li!za"), "\"Liza\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza Liza"), "\"Liza\"*")
-        XCTAssertEqual(FullTextSearchFinder.query(searchText: "Liza liza"), "\"Liza\"* \"liza\"*")
-    }
-
-    func testTextNormalization() {
-        XCTAssertEqual(FullTextSearchFinder.normalize(text: "Liza"), "Liza")
-        XCTAssertEqual(FullTextSearchFinder.normalize(text: "Liza +1-323"), "Liza 1323")
-        XCTAssertEqual(FullTextSearchFinder.normalize(text: "\"\\ `~!@#$%^&*()_+-={}|[]:;'<>?,./Liza +1-323"), "Liza 1323")
-        XCTAssertEqual(FullTextSearchFinder.normalize(text: "renaldo RENALDO re침aldo RE칌ALDO"), "renaldo RENALDO re침aldo RE칌ALDO")
-        XCTAssertEqual(FullTextSearchFinder.normalize(text: "游땚"), "游땚")
-    }
-}
diff --git a/SignalMessaging/utils/FullTextSearcher.swift b/SignalMessaging/utils/FullTextSearcher.swift
index 2b75e0d3b04..00a5b24e33d 100644
--- a/SignalMessaging/utils/FullTextSearcher.swift
+++ b/SignalMessaging/utils/FullTextSearcher.swift
@@ -236,12 +236,12 @@ public class FullTextSearcher: NSObject {
 
     @objc
     public func searchForComposeScreen(searchText: String,
-                                       transaction: YapDatabaseReadTransaction) -> ComposeScreenSearchResultSet {
+                                       transaction: SDSAnyReadTransaction) -> ComposeScreenSearchResultSet {
 
         var signalContacts: [ContactSearchResult] = []
         var groups: [GroupSearchResult] = []
 
-        self.finder.enumerateObjects(searchText: searchText, transaction: transaction) { (match: Any, _: String?) in
+        self.finder.enumerateObjects(searchText: searchText, transaction: transaction) { (match: Any, _: String?, _: UnsafeMutablePointer<ObjCBool>) in
 
             switch match {
             case let signalAccount as SignalAccount:
@@ -249,8 +249,8 @@ public class FullTextSearcher: NSObject {
                 signalContacts.append(searchResult)
             case let groupThread as TSGroupThread:
                 let sortKey = ConversationSortKey(creationDate: groupThread.creationDate,
-                                                  lastMessageReceivedAtDate: groupThread.lastInteractionForInbox(transaction: transaction.asAnyRead)?.receivedAtDate())
-                let threadViewModel = ThreadViewModel(thread: groupThread, transaction: transaction.asAnyRead)
+                                                  lastMessageReceivedAtDate: groupThread.lastInteractionForInbox(transaction: transaction)?.receivedAtDate())
+                let threadViewModel = ThreadViewModel(thread: groupThread, transaction: transaction)
                 let searchResult = GroupSearchResult(thread: threadViewModel, sortKey: sortKey)
                 groups.append(searchResult)
             case is TSContactThread:
@@ -277,18 +277,13 @@ public class FullTextSearcher: NSObject {
     public func searchForHomeScreen(searchText: String,
                                     transaction: SDSAnyReadTransaction) -> HomeScreenSearchResultSet {
 
-        // GRDB TODO:
-        guard let ydbTransaction = transaction.transitional_yapReadTransaction else {
-            return HomeScreenSearchResultSet(searchText: searchText, conversations: [], contacts: [], messages: [])
-        }
-
         var conversations: [ConversationSearchResult<ConversationSortKey>] = []
         var contacts: [ContactSearchResult] = []
         var messages: [ConversationSearchResult<MessageSortKey>] = []
 
         var existingConversationAddresses: Set<SignalServiceAddress> = Set()
 
-        self.finder.enumerateObjects(searchText: searchText, transaction: ydbTransaction) { (match: Any, snippet: String?) in
+        self.finder.enumerateObjects(searchText: searchText, transaction: transaction) { (match: Any, snippet: String?, _: UnsafeMutablePointer<ObjCBool>) in
 
             if let thread = match as? TSThread {
                 let threadViewModel = ThreadViewModel(thread: thread, transaction: transaction)
@@ -336,11 +331,11 @@ public class FullTextSearcher: NSObject {
 
     public func searchWithinConversation(thread: TSThread,
                                          searchText: String,
-                                         transaction: YapDatabaseReadTransaction) -> ConversationScreenSearchResultSet {
+                                         transaction: SDSAnyReadTransaction) -> ConversationScreenSearchResultSet {
 
         var messages: [MessageSearchResult] = []
 
-        self.finder.enumerateObjects(searchText: searchText, transaction: transaction) { (match: Any, _: String?) in
+        self.finder.enumerateObjects(searchText: searchText, transaction: transaction) { (match: Any, _: String?, _: UnsafeMutablePointer<ObjCBool>) in
             if let message = match as? TSMessage {
                 guard message.uniqueThreadId == thread.uniqueId else {
                     return
diff --git a/SignalServiceKit/src/Contacts/SignalAccount.m b/SignalServiceKit/src/Contacts/SignalAccount.m
index 12a58a69ecd..71e9d80b9dc 100644
--- a/SignalServiceKit/src/Contacts/SignalAccount.m
+++ b/SignalServiceKit/src/Contacts/SignalAccount.m
@@ -22,6 +22,11 @@ @interface SignalAccount ()
 
 @implementation SignalAccount
 
++ (BOOL)shouldBeIndexedForFTS
+{
+    return YES;
+}
+
 - (instancetype)initWithSignalRecipient:(SignalRecipient *)signalRecipient
 {
     OWSAssertDebug(signalRecipient);
diff --git a/SignalServiceKit/src/Contacts/TSThread.m b/SignalServiceKit/src/Contacts/TSThread.m
index 3a69d77d907..00b58116f9d 100644
--- a/SignalServiceKit/src/Contacts/TSThread.m
+++ b/SignalServiceKit/src/Contacts/TSThread.m
@@ -74,6 +74,11 @@ + (NSString *)collection {
     return @"TSThread";
 }
 
++ (BOOL)shouldBeIndexedForFTS
+{
+    return YES;
+}
+
 - (instancetype)initWithUniqueId:(NSString *)uniqueId
 {
     self = [super initWithUniqueId:uniqueId];
diff --git a/SignalServiceKit/src/Messages/Interactions/TSInteraction.m b/SignalServiceKit/src/Messages/Interactions/TSInteraction.m
index ccb48bc05c8..d596f965ebb 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSInteraction.m
+++ b/SignalServiceKit/src/Messages/Interactions/TSInteraction.m
@@ -40,6 +40,11 @@ @interface TSInteraction ()
 
 @implementation TSInteraction
 
++ (BOOL)shouldBeIndexedForFTS
+{
+    return YES;
+}
+
 + (NSArray<TSInteraction *> *)ydb_interactionsWithTimestamp:(uint64_t)timestamp
                                                     ofClass:(Class)clazz
                                             withTransaction:(YapDatabaseReadTransaction *)transaction
diff --git a/SignalServiceKit/src/Messages/Interactions/TSMessage.h b/SignalServiceKit/src/Messages/Interactions/TSMessage.h
index 4fb2fec1fc5..34252fed57c 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSMessage.h
+++ b/SignalServiceKit/src/Messages/Interactions/TSMessage.h
@@ -122,6 +122,13 @@ NS_SWIFT_NAME(init(uniqueId:receivedAtTimestamp:sortId:timestamp:uniqueThreadId:
 
 - (void)updateWithMessageSticker:(MessageSticker *)messageSticker transaction:(SDSAnyWriteTransaction *)transaction;
 
+#ifdef DEBUG
+
+// This method is for testing purposes only.
+- (void)updateWithMessageBody:(nullable NSString *)messageBody transaction:(SDSAnyWriteTransaction *)transaction;
+
+#endif
+
 #pragma mark - Per-message expiration
 
 // This method is used when we start expiration of per-message expiration.
diff --git a/SignalServiceKit/src/Messages/Interactions/TSMessage.m b/SignalServiceKit/src/Messages/Interactions/TSMessage.m
index ee53e05b18e..278d5febb59 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSMessage.m
+++ b/SignalServiceKit/src/Messages/Interactions/TSMessage.m
@@ -624,6 +624,21 @@ - (void)updateWithMessageSticker:(MessageSticker *)messageSticker transaction:(S
                                     }];
 }
 
+#ifdef DEBUG
+
+// This method is for testing purposes only.
+- (void)updateWithMessageBody:(nullable NSString *)messageBody transaction:(SDSAnyWriteTransaction *)transaction
+{
+    OWSAssertDebug(transaction);
+
+    [self anyUpdateMessageWithTransaction:transaction
+                                    block:^(TSMessage *message) {
+                                        message.body = messageBody;
+                                    }];
+}
+
+#endif
+
 #pragma mark - Renderable Content
 
 - (BOOL)hasRenderableContent
diff --git a/SignalServiceKit/src/Storage/BaseModel.h b/SignalServiceKit/src/Storage/BaseModel.h
index e30f70d4a8e..744a00b3c97 100644
--- a/SignalServiceKit/src/Storage/BaseModel.h
+++ b/SignalServiceKit/src/Storage/BaseModel.h
@@ -8,6 +8,8 @@ NS_ASSUME_NONNULL_BEGIN
 
 @interface BaseModel : TSYapDatabaseObject
 
+@property (class, nonatomic) BOOL shouldBeIndexedForFTS;
+
 #pragma mark - YDB Deprecation
 
 // Deprecate all YDB methods.
diff --git a/SignalServiceKit/src/Storage/BaseModel.m b/SignalServiceKit/src/Storage/BaseModel.m
index 04df03e62dc..1f2865451a9 100644
--- a/SignalServiceKit/src/Storage/BaseModel.m
+++ b/SignalServiceKit/src/Storage/BaseModel.m
@@ -8,6 +8,11 @@
 
 @implementation BaseModel
 
++ (BOOL)shouldBeIndexedForFTS
+{
+    return NO;
+}
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
index d539d45f9ef..4309f425d84 100644
--- a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
@@ -570,6 +570,8 @@ public class GRDBDatabaseStorageAdapter: NSObject {
                           columns: [
                             ContactQueryRecord.columnName(.lastQueried)
                 ])
+
+            try GRDBFullTextSearchFinder.createTables(database: db)
         }
         return migrator
     }()
diff --git a/SignalServiceKit/src/Storage/Database/SDSModel.swift b/SignalServiceKit/src/Storage/Database/SDSModel.swift
index 20488bc459e..afb167852d1 100644
--- a/SignalServiceKit/src/Storage/Database/SDSModel.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSModel.swift
@@ -13,6 +13,8 @@ public protocol SDSModel: TSYapDatabaseObject {
     func anyInsert(transaction: SDSAnyWriteTransaction)
 
     func anyRemove(transaction: SDSAnyWriteTransaction)
+
+    static var shouldBeIndexedForFTS: Bool { get }
 }
 
 // MARK: -
@@ -46,8 +48,43 @@ public extension SDSModel {
         switch saveMode {
         case .insert:
             anyDidInsert(with: transaction)
+
+            if type(of: self).shouldBeIndexedForFTS {
+                FullTextSearchFinder().modelWasInserted(model: self, transaction: transaction)
+            }
         case .update:
             anyDidUpdate(with: transaction)
+
+            if type(of: self).shouldBeIndexedForFTS {
+                FullTextSearchFinder().modelWasUpdated(model: self, transaction: transaction)
+            }
+        }
+    }
+
+    func sdsRemove(transaction: SDSAnyWriteTransaction) {
+        guard shouldBeSaved else {
+            // Skipping remove.
+            return
+        }
+
+        anyWillRemove(with: transaction)
+
+        switch transaction.writeTransaction {
+        case .yapWrite(let ydbTransaction):
+            ydb_remove(with: ydbTransaction)
+        case .grdbWrite(let grdbTransaction):
+            do {
+                let record = try asRecord()
+                record.sdsRemove(transaction: grdbTransaction)
+            } catch {
+                owsFail("Remove failed: \(error)")
+            }
+        }
+
+        anyDidRemove(with: transaction)
+
+        if type(of: self).shouldBeIndexedForFTS {
+            FullTextSearchFinder().modelWasRemoved(model: self, transaction: transaction)
         }
     }
 }
diff --git a/SignalServiceKit/src/Storage/FullTextSearchFinder.swift b/SignalServiceKit/src/Storage/FullTextSearchFinder.swift
index 2945c4122af..63f420f310d 100644
--- a/SignalServiceKit/src/Storage/FullTextSearchFinder.swift
+++ b/SignalServiceKit/src/Storage/FullTextSearchFinder.swift
@@ -3,35 +3,137 @@
 //
 
 import Foundation
+import GRDBCipher
 
-// Create a searchable index for objects of type T
-public class SearchIndexer<T> {
+@objc
+public class FullTextSearchFinder: NSObject {
+    public func enumerateObjects(searchText: String, transaction: SDSAnyReadTransaction, block: @escaping (Any, String, UnsafeMutablePointer<ObjCBool>) -> Void) {
+        switch transaction.readTransaction {
+        case .yapRead(let yapRead):
+            YDBFullTextSearchFinder().enumerateObjects(searchText: searchText, transaction: yapRead, block: block)
+        case .grdbRead(let grdbRead):
+            GRDBFullTextSearchFinder.enumerateObjects(searchText: searchText, transaction: grdbRead, block: block)
+        }
+    }
 
-    private let indexBlock: (T, YapDatabaseReadTransaction) -> String
+    public func modelWasInserted(model: SDSModel, transaction: SDSAnyWriteTransaction) {
+        assert(type(of: model).shouldBeIndexedForFTS)
 
-    public init(indexBlock: @escaping (T, YapDatabaseReadTransaction) -> String) {
-        self.indexBlock = indexBlock
+        switch transaction.writeTransaction {
+        case .yapWrite:
+            // Do nothing.
+            break
+        case .grdbWrite(let grdbWrite):
+            GRDBFullTextSearchFinder.modelWasInserted(model: model, transaction: grdbWrite)
+        }
     }
 
-    public func index(_ item: T, transaction: YapDatabaseReadTransaction) -> String {
-        return normalize(indexingText: indexBlock(item, transaction))
+    public func modelWasUpdated(model: SDSModel, transaction: SDSAnyWriteTransaction) {
+        assert(type(of: model).shouldBeIndexedForFTS)
+
+        switch transaction.writeTransaction {
+        case .yapWrite:
+            // Do nothing.
+            break
+        case .grdbWrite(let grdbWrite):
+            GRDBFullTextSearchFinder.modelWasUpdated(model: model, transaction: grdbWrite)
+        }
     }
 
-    private func normalize(indexingText: String) -> String {
-        return FullTextSearchFinder.normalize(text: indexingText)
+    public func modelWasRemoved(model: SDSModel, transaction: SDSAnyWriteTransaction) {
+        assert(type(of: model).shouldBeIndexedForFTS)
+
+        switch transaction.writeTransaction {
+        case .yapWrite:
+            // Do nothing.
+            break
+        case .grdbWrite(let grdbWrite):
+            GRDBFullTextSearchFinder.modelWasRemoved(model: model, transaction: grdbWrite)
+        }
+    }
+
+    public class func allModelsWereRemoved(collection: String, transaction: SDSAnyWriteTransaction) {
+        switch transaction.writeTransaction {
+        case .yapWrite:
+            // Do nothing.
+            break
+        case .grdbWrite(let grdbWrite):
+            GRDBFullTextSearchFinder.allModelsWereRemoved(collection: collection, transaction: grdbWrite)
+        }
     }
 }
 
-@objc
-public class FullTextSearchFinder: NSObject {
+// MARK: - Normalization
 
-    // MARK: - Dependencies
+extension FullTextSearchFinder {
 
-    private static var tsAccountManager: TSAccountManager {
-        return TSAccountManager.sharedInstance()
+    fileprivate static var charactersToRemove: CharacterSet = {
+        // * We want to strip punctuation - and our definition of "punctuation"
+        //   is broader than `CharacterSet.punctuationCharacters`.
+        // * FTS should be robust to (i.e. ignore) illegal and control characters,
+        //   but it's safer if we filter them ourselves as well.
+        var charactersToFilter = CharacterSet.punctuationCharacters
+        charactersToFilter.formUnion(CharacterSet.illegalCharacters)
+        charactersToFilter.formUnion(CharacterSet.controlCharacters)
+
+        // We want to strip all ASCII characters except:
+        // * Letters a-z, A-Z
+        // * Numerals 0-9
+        // * Whitespace
+        var asciiToFilter = CharacterSet(charactersIn: UnicodeScalar(0x0)!..<UnicodeScalar(0x80)!)
+        assert(!asciiToFilter.contains(UnicodeScalar(0x80)!))
+        asciiToFilter.subtract(CharacterSet.alphanumerics)
+        asciiToFilter.subtract(CharacterSet.whitespacesAndNewlines)
+        charactersToFilter.formUnion(asciiToFilter)
+
+        return charactersToFilter
+    }()
+
+    // This is a hot method, especially while running large migrations.
+    // Changes to it should go through a profiler to make sure large migrations
+    // aren't adversely affected.
+    @objc
+    public class func normalize(text: String) -> String {
+        // 1. Filter out invalid characters.
+        let filtered = text.removeCharacters(characterSet: charactersToRemove)
+
+        // 2. Simplify whitespace.
+        let simplified = filtered.replaceCharacters(characterSet: .whitespacesAndNewlines,
+                                                    replacement: " ")
+
+        // 3. Strip leading & trailing whitespace last, since we may replace
+        // filtered characters with whitespace.
+        let trimmed = simplified.trimmingCharacters(in: .whitespacesAndNewlines)
+
+        // 4. Use canonical mapping.
+        //
+        // From the GRDB docs:
+        //
+        // Generally speaking, matches may fail when content and query don뗪 use
+        // the same unicode normalization. SQLite actually exhibits inconsistent
+        // behavior in this regard.
+        //
+        // For example, for aim칠 to match aim칠, they better have the same
+        // normalization: the NFC aim\u{00E9} form may not match its NFD aime\u{0301}
+        // equivalent. Most strings that you get from Swift, UIKit and Cocoa use NFC,
+        // so be careful with NFD inputs (such as strings from the HFS+ file system,
+        // or strings that you can뗪 trust like network inputs). Use
+        // String.precomposedStringWithCanonicalMapping to turn a string into NFC.
+        //
+        // Besides, if you want fi to match the ligature 遼 (U+FB01), then you need
+        // to normalize your indexed contents and inputs to NFKC or NFKD. Use
+        // String.precomposedStringWithCompatibilityMapping to turn a string into NFKC.
+        let canonical = trimmed.precomposedStringWithCanonicalMapping
+
+        return canonical
     }
+}
 
-    // MARK: - Querying
+// MARK: - Querying
+
+// We use SQLite's FTS5 for both YDB and GRDB, we can use the
+// same query for both cases.
+extension FullTextSearchFinder {
 
     // We want to match by prefix for "search as you type" functionality.
     // SQLite does not support suffix or contains matches.
@@ -69,23 +171,29 @@ public class FullTextSearchFinder: NSObject {
         let filteredQueryTerms = queryTerms.filter {
             // Ignore empty terms.
             $0.count > 0
-        }.map {
-            // Allow partial match of each term.
-            //
-            // Note that we use double-quotes to enclose each search term.
-            // Quoted search terms can include a few more characters than
-            // "bareword" (non-quoted) search terms.  This shouldn't matter,
-            // since we're filtering all of the affected characters, but
-            // quoting protects us from any bugs in that logic.
-            "\"\($0)\"*"
+            }.map {
+                // Allow partial match of each term.
+                //
+                // Note that we use double-quotes to enclose each search term.
+                // Quoted search terms can include a few more characters than
+                // "bareword" (non-quoted) search terms.  This shouldn't matter,
+                // since we're filtering all of the affected characters, but
+                // quoting protects us from any bugs in that logic.
+                "\"\($0)\"*"
         }
 
         // 6. Join terms into query string.
         let query = filteredQueryTerms.joined(separator: " ")
         return query
     }
+}
+
+// MARK: -
 
-    public func enumerateObjects(searchText: String, transaction: YapDatabaseReadTransaction, block: @escaping (Any, String) -> Void) {
+@objc
+public class YDBFullTextSearchFinder: NSObject {
+
+    public func enumerateObjects(searchText: String, transaction: YapDatabaseReadTransaction, block: @escaping (Any, String, UnsafeMutablePointer<ObjCBool>) -> Void) {
         guard let ext: YapDatabaseFullTextSearchTransaction = ext(transaction: transaction) else {
             owsFailDebug("ext was unexpectedly nil")
             return
@@ -93,6 +201,11 @@ public class FullTextSearchFinder: NSObject {
 
         let query = FullTextSearchFinder.query(searchText: searchText)
 
+        guard query.count > 0 else {
+            owsFailDebug("Empty query.")
+            return
+        }
+
         Logger.verbose("query: \(query)")
 
         let maxSearchResults = 500
@@ -107,68 +220,291 @@ public class FullTextSearchFinder: NSObject {
             }
             searchResultCount += 1
 
-            block(object, snippet)
+            block(object, snippet, stop)
         }
     }
 
-    // MARK: - Normalization
-
-    fileprivate static var charactersToRemove: CharacterSet = {
-        // * We want to strip punctuation - and our definition of "punctuation"
-        //   is broader than `CharacterSet.punctuationCharacters`.
-        // * FTS should be robust to (i.e. ignore) illegal and control characters,
-        //   but it's safer if we filter them ourselves as well.
-        var charactersToFilter = CharacterSet.punctuationCharacters
-        charactersToFilter.formUnion(CharacterSet.illegalCharacters)
-        charactersToFilter.formUnion(CharacterSet.controlCharacters)
+    // MARK: - Extension Registration
 
-        // We want to strip all ASCII characters except:
-        // * Letters a-z, A-Z
-        // * Numerals 0-9
-        // * Whitespace
-        var asciiToFilter = CharacterSet(charactersIn: UnicodeScalar(0x0)!..<UnicodeScalar(0x80)!)
-        assert(!asciiToFilter.contains(UnicodeScalar(0x80)!))
-        asciiToFilter.subtract(CharacterSet.alphanumerics)
-        asciiToFilter.subtract(CharacterSet.whitespacesAndNewlines)
-        charactersToFilter.formUnion(asciiToFilter)
+    private static let dbExtensionName: String = "FullTextSearchFinderExtension"
 
-        return charactersToFilter
-    }()
+    private func ext(transaction: YapDatabaseReadTransaction) -> YapDatabaseFullTextSearchTransaction? {
+        return transaction.safeFullTextSearchTransaction(YDBFullTextSearchFinder.dbExtensionName)
+    }
 
-    // This is a hot method, especially while running large migrations.
-    // Changes to it should go through a profiler to make sure large migrations
-    // aren't adversely affected.
     @objc
-    public class func normalize(text: String) -> String {
-        // 1. Filter out invalid characters.
-        let filtered = text.removeCharacters(characterSet: charactersToRemove)
+    public class func asyncRegisterDatabaseExtension(storage: OWSStorage) {
+        storage.asyncRegister(dbExtensionConfig, withName: dbExtensionName)
+    }
 
-        // 2. Simplify whitespace.
-        let simplified = filtered.replaceCharacters(characterSet: .whitespacesAndNewlines,
-                                                    replacement: " ")
+    // Only for testing.
+    public class func ensureDatabaseExtensionRegistered(storage: OWSStorage) {
+        guard storage.registeredExtension(dbExtensionName) == nil else {
+            return
+        }
 
-        // 3. Strip leading & trailing whitespace last, since we may replace
-        // filtered characters with whitespace.
-        return simplified.trimmingCharacters(in: .whitespacesAndNewlines)
+        storage.register(dbExtensionConfig, withName: dbExtensionName)
     }
 
-    // MARK: - Index Building
+    private class var dbExtensionConfig: YapDatabaseFullTextSearch {
+        AssertIsOnMainThread()
+
+        let contentColumnName = "content"
+
+        let handler = YapDatabaseFullTextSearchHandler.withObjectBlock { (transaction: YapDatabaseReadTransaction, dict: NSMutableDictionary, _: String, _: String, object: Any) in
+            dict[contentColumnName] = AnySearchIndexer.indexContent(object: object, transaction: transaction.asAnyRead)
+        }
+
+        // update search index on contact name changes?
+
+        return YapDatabaseFullTextSearch(columnNames: ["content"],
+                                         options: nil,
+                                         handler: handler,
+                                         ftsVersion: YapDatabaseFullTextSearchFTS5Version,
+                                         versionTag: "1")
+    }
+}
+
+// MARK: -
+
+// See: http://groue.github.io/GRDB.swift/docs/4.1/index.html#full-text-search
+// See: https://www.sqlite.org/fts5.html
+@objc
+class GRDBFullTextSearchFinder: NSObject {
+
+    static let databaseTableName: String = "signal_grdb_fts"
+    static let uniqueIdColumn: String = "uniqueId"
+    static let collectionColumn: String = "collection"
+    static let ftsContentColumn: String = "ftsContent"
+
+    class func createTables(database: Database) throws {
+        try database.create(virtualTable: databaseTableName, using: FTS5()) { table in
+            // We could use FTS5TokenizerDescriptor.porter(wrapping: FTS5TokenizerDescriptor.unicode61())
+            //
+            // Porter does stemming (e.g. "hunting" will match "hunter").
+            // unicode61 will remove diacritics (e.g. "senor" will match "se침or").
+            //
+            // GRDB TODO: Should we do stemming?
+            let tokenizer = FTS5TokenizerDescriptor.unicode61()
+            table.tokenizer = tokenizer
+
+            table.column("\(collectionColumn)").notIndexed()
+            table.column("\(uniqueIdColumn)").notIndexed()
+            table.column("\(ftsContentColumn)")
+        }
+    }
+
+    private class func collection(forModel model: SDSModel) -> String {
+        // Note that allModelsWereRemoved(collection: ) makes the same
+        // assumption that the FTS collection matches the
+        // TSYapDatabaseObject.collection.
+        return type(of: model).collection()
+    }
+
+    public class func modelWasInserted(model: SDSModel, transaction: GRDBWriteTransaction) {
+        let uniqueId = model.uniqueId
+        let collection = self.collection(forModel: model)
+        let ftsContent = AnySearchIndexer.indexContent(object: model, transaction: transaction.asAnyRead) ?? ""
+
+        do {
+            try transaction.database.execute(
+                sql: """
+                INSERT INTO \(databaseTableName)
+                (\(collectionColumn), \(uniqueIdColumn), \(ftsContentColumn))
+                VALUES
+                (?, ?, ?)
+                """,
+                arguments: [collection, uniqueId, ftsContent])
+        } catch {
+            owsFailDebug("Error: \(error)")
+        }
+    }
+
+    public class func modelWasUpdated(model: SDSModel, transaction: GRDBWriteTransaction) {
+        let uniqueId = model.uniqueId
+        let collection = self.collection(forModel: model)
+        let ftsContent = AnySearchIndexer.indexContent(object: model, transaction: transaction.asAnyRead) ?? ""
+
+        do {
+            try transaction.database.execute(
+                sql: """
+                UPDATE \(databaseTableName)
+                SET \(ftsContentColumn) = ?
+                WHERE \(collectionColumn) == ?
+                AND \(uniqueIdColumn) == ?
+                """,
+                arguments: [ftsContent, collection, uniqueId])
+        } catch {
+            owsFailDebug("Error: \(error)")
+        }
+    }
+
+    public class func modelWasRemoved(model: SDSModel, transaction: GRDBWriteTransaction) {
+        let uniqueId = model.uniqueId
+        let collection = self.collection(forModel: model)
+
+        do {
+            try transaction.database.execute(
+                sql: """
+                DELETE FROM \(databaseTableName)
+                WHERE \(uniqueIdColumn) == ?
+                AND \(collectionColumn) == ?
+                """,
+                arguments: [uniqueId, collection])
+        } catch {
+            owsFailDebug("Error: \(error)")
+        }
+    }
+
+    public class func allModelsWereRemoved(collection: String, transaction: GRDBWriteTransaction) {
+        do {
+            try transaction.database.execute(
+                sql: """
+                DELETE FROM \(databaseTableName)
+                WHERE \(collectionColumn) == ?
+                """,
+                arguments: [collection])
+        } catch {
+            owsFailDebug("Error: \(error)")
+        }
+    }
+
+    private class func modelForFTSMatch(collection: String,
+                                        uniqueId: String,
+                                        transaction: GRDBReadTransaction) -> SDSModel? {
+        switch collection {
+        case SignalAccount.collection():
+            guard let model = SignalAccount.anyFetch(uniqueId: uniqueId,
+                                                     transaction: transaction.asAnyRead) else {
+                                                        owsFailDebug("Couldn't load record: \(collection)")
+                                                        return nil
+            }
+            return model
+        case TSThread.collection():
+            guard let model = TSThread.anyFetch(uniqueId: uniqueId,
+                                                transaction: transaction.asAnyRead) else {
+                                                    owsFailDebug("Couldn't load record: \(collection)")
+                                                    return nil
+            }
+            return model
+        case TSInteraction.collection():
+            guard let model = TSInteraction.anyFetch(uniqueId: uniqueId,
+                                                     transaction: transaction.asAnyRead) else {
+                                                        owsFailDebug("Couldn't load record: \(collection)")
+                                                        return nil
+            }
+            return model
+        default:
+            owsFailDebug("Unexpected record type: \(collection)")
+            return nil
+        }
+    }
+
+    // MARK: - Querying
+
+    public class func enumerateObjects(searchText: String, transaction: GRDBReadTransaction, block: @escaping (Any, String, UnsafeMutablePointer<ObjCBool>) -> Void) {
+
+        let query = FullTextSearchFinder.query(searchText: searchText)
+
+        guard query.count > 0 else {
+            owsFailDebug("Empty query.")
+            return
+        }
+
+        // Search with the query interface or SQL
+        do {
+            var stop: ObjCBool = false
+
+            // GRDB TODO: We could use bm25() instead of rank to order results.
+            let columnIndex = 2
+            // Determines the length of the snippet.
+            let numTokens: UInt = 15
+            let matchSnippet = "match_snippet"
+            let sql: String = """
+                SELECT
+                \(collectionColumn), \(uniqueIdColumn), \(ftsContentColumn),
+                snippet(\(databaseTableName), \(columnIndex), '', '', '', \(numTokens) ) as \(matchSnippet)
+                FROM \(databaseTableName)
+                WHERE \(databaseTableName)
+                MATCH '"\(ftsContentColumn)" : \(query)'
+                ORDER BY rank
+            """
+            let cursor = try Row.fetchCursor(transaction.database, sql: sql)
+            while let row = try cursor.next() {
+                let collection: String = row[collectionColumn]
+                let uniqueId: String = row[uniqueIdColumn]
+                let snippet: String = row[matchSnippet]
+                guard collection.count > 0,
+                    uniqueId.count > 0 else {
+                        owsFailDebug("Invalid match: collection: \(collection), uniqueId: \(uniqueId).")
+                        continue
+                }
+                guard let model = modelForFTSMatch(collection: collection,
+                                                   uniqueId: uniqueId,
+                                                   transaction: transaction) else {
+                                                    owsFailDebug("Missing model for search result.")
+                                                    continue
+                }
+
+                block(model, snippet, &stop)
+                guard !stop.boolValue else {
+                    break
+                }
+            }
+        } catch {
+            owsFailDebug("Couldn't fetch results: \(error)")
+        }
+    }
+
+}
+
+// MARK: -
+
+// Create a searchable index for objects of type T
+class SearchIndexer<T> {
+
+    private let indexBlock: (T, SDSAnyReadTransaction) -> String
+
+    public init(indexBlock: @escaping (T, SDSAnyReadTransaction) -> String) {
+        self.indexBlock = indexBlock
+    }
+
+    public func index(_ item: T, transaction: SDSAnyReadTransaction) -> String {
+        return normalize(indexingText: indexBlock(item, transaction))
+    }
+
+    private func normalize(indexingText: String) -> String {
+        return FullTextSearchFinder.normalize(text: indexingText)
+    }
+}
+
+// MARK: -
+
+class AnySearchIndexer {
+
+    // MARK: - Dependencies
+
+    private static var tsAccountManager: TSAccountManager {
+        return TSAccountManager.sharedInstance()
+    }
 
     private class var contactsManager: ContactsManagerProtocol {
         return SSKEnvironment.shared.contactsManager
     }
 
-    private static let groupThreadIndexer: SearchIndexer<TSGroupThread> = SearchIndexer { (groupThread: TSGroupThread, transaction: YapDatabaseReadTransaction) in
+    // MARK: - Index Building
+
+    private static let groupThreadIndexer: SearchIndexer<TSGroupThread> = SearchIndexer { (groupThread: TSGroupThread, transaction: SDSAnyReadTransaction) in
         let groupName = groupThread.groupModel.groupName ?? ""
 
         let memberStrings = groupThread.groupModel.groupMembers.map { address in
             recipientIndexer.index(address, transaction: transaction)
-        }.joined(separator: " ")
+            }.joined(separator: " ")
 
         return "\(groupName) \(memberStrings)"
     }
 
-    private static let contactThreadIndexer: SearchIndexer<TSContactThread> = SearchIndexer { (contactThread: TSContactThread, transaction: YapDatabaseReadTransaction) in
+    private static let contactThreadIndexer: SearchIndexer<TSContactThread> = SearchIndexer { (contactThread: TSContactThread, transaction: SDSAnyReadTransaction) in
         let recipientAddress = contactThread.contactAddress
         var result = recipientIndexer.index(recipientAddress, transaction: transaction)
 
@@ -181,7 +517,7 @@ public class FullTextSearchFinder: NSObject {
     }
 
     private static let recipientIndexer: SearchIndexer<SignalServiceAddress> = SearchIndexer { recipientAddress, transaction in
-        let displayName = contactsManager.displayName(for: recipientAddress, transaction: transaction.asAnyRead)
+        let displayName = contactsManager.displayName(for: recipientAddress, transaction: transaction)
 
         let nationalNumber: String? = { (recipientId: String?) -> String? in
             guard let recipientId = recipientId else { return nil }
@@ -202,14 +538,14 @@ public class FullTextSearchFinder: NSObject {
         return "\(recipientAddress.phoneNumber ?? "") \(nationalNumber ?? "") \(displayName)"
     }
 
-    private static let messageIndexer: SearchIndexer<TSMessage> = SearchIndexer { (message: TSMessage, transaction: YapDatabaseReadTransaction) in
-        if let bodyText = message.bodyText(with: transaction.asAnyRead) {
+    private static let messageIndexer: SearchIndexer<TSMessage> = SearchIndexer { (message: TSMessage, transaction: SDSAnyReadTransaction) in
+        if let bodyText = message.bodyText(with: transaction) {
             return bodyText
         }
         return ""
     }
 
-    private class func indexContent(object: Any, transaction: YapDatabaseReadTransaction) -> String? {
+    class func indexContent(object: Any, transaction: SDSAnyReadTransaction) -> String? {
         if let groupThread = object as? TSGroupThread {
             return self.groupThreadIndexer.index(groupThread, transaction: transaction)
         } else if let contactThread = object as? TSContactThread {
@@ -232,44 +568,4 @@ public class FullTextSearchFinder: NSObject {
             return nil
         }
     }
-
-    // MARK: - Extension Registration
-
-    private static let dbExtensionName: String = "FullTextSearchFinderExtension"
-
-    private func ext(transaction: YapDatabaseReadTransaction) -> YapDatabaseFullTextSearchTransaction? {
-        return transaction.safeFullTextSearchTransaction(FullTextSearchFinder.dbExtensionName)
-    }
-
-    @objc
-    public class func asyncRegisterDatabaseExtension(storage: OWSStorage) {
-        storage.asyncRegister(dbExtensionConfig, withName: dbExtensionName)
-    }
-
-    // Only for testing.
-    public class func ensureDatabaseExtensionRegistered(storage: OWSStorage) {
-        guard storage.registeredExtension(dbExtensionName) == nil else {
-            return
-        }
-
-        storage.register(dbExtensionConfig, withName: dbExtensionName)
-    }
-
-    private class var dbExtensionConfig: YapDatabaseFullTextSearch {
-        AssertIsOnMainThread()
-
-        let contentColumnName = "content"
-
-        let handler = YapDatabaseFullTextSearchHandler.withObjectBlock { (transaction: YapDatabaseReadTransaction, dict: NSMutableDictionary, _: String, _: String, object: Any) in
-            dict[contentColumnName] = indexContent(object: object, transaction: transaction)
-        }
-
-        // update search index on contact name changes?
-
-        return YapDatabaseFullTextSearch(columnNames: ["content"],
-                                         options: nil,
-                                         handler: handler,
-                                         ftsVersion: YapDatabaseFullTextSearchFTS5Version,
-                                         versionTag: "1")
-    }
 }
diff --git a/SignalServiceKit/src/Storage/OWSPrimaryStorage.m b/SignalServiceKit/src/Storage/OWSPrimaryStorage.m
index ce50c489c27..c1f824b955c 100644
--- a/SignalServiceKit/src/Storage/OWSPrimaryStorage.m
+++ b/SignalServiceKit/src/Storage/OWSPrimaryStorage.m
@@ -219,7 +219,7 @@ - (void)runAsyncRegistrationsWithCompletion:(void (^_Nonnull)(void))completion
                                       [TSDatabaseView asyncRegisterThreadSpecialMessagesDatabaseView:self];
                                       [TSDatabaseView asyncRegisterPerMessageExpirationMessagesDatabaseView:self];
 
-                                      [FullTextSearchFinder asyncRegisterDatabaseExtensionWithStorage:self];
+                                      [YDBFullTextSearchFinder asyncRegisterDatabaseExtensionWithStorage:self];
                                       [OWSIncomingMessageFinder asyncRegisterExtensionWithPrimaryStorage:self];
                                       [OWSDisappearingMessagesFinder asyncRegisterDatabaseExtensions:self];
                                       [OWSFailedMessagesJob asyncRegisterDatabaseExtensionsWithPrimaryStorage:self];
diff --git a/SignalServiceKit/src/Util/OWSUserProfile.h b/SignalServiceKit/src/Util/OWSUserProfile.h
index 6126d21f048..ea9db1f8894 100644
--- a/SignalServiceKit/src/Util/OWSUserProfile.h
+++ b/SignalServiceKit/src/Util/OWSUserProfile.h
@@ -2,7 +2,7 @@
 //  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
 //
 
-#import <SignalServiceKit/TSYapDatabaseObject.h>
+#import <SignalServiceKit/BaseModel.h>
 
 NS_ASSUME_NONNULL_BEGIN
 
@@ -23,7 +23,7 @@ extern NSString *const kNSNotificationKey_ProfileGroupId;
 //
 // It is critical for coherency that all DB operations for this
 // class should be done on OWSProfileManager's databaseQueue.
-@interface OWSUserProfile : TSYapDatabaseObject
+@interface OWSUserProfile : BaseModel
 
 @property (atomic, readonly) SignalServiceAddress *address;
 @property (atomic, readonly, nullable) OWSAES256Key *profileKey;
