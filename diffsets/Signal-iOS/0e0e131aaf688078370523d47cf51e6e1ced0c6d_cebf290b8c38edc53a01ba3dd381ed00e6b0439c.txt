diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index 196cf2927d6..5ec510fb8fd 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -23,6 +23,14 @@ protocol CVLoadCoordinatorDelegate: UIScrollViewDelegate {
     var isScrollNearTopOfLoadWindow: Bool { get }
 
     var isScrollNearBottomOfLoadWindow: Bool { get }
+
+    var isUserScrolling: Bool { get }
+
+    var hasScrollingAnimation: Bool { get }
+
+    var scrollContinuity: ScrollContinuity { get }
+
+    var isLayoutApplyingUpdate: Bool { get }
 }
 
 // MARK: -
@@ -531,31 +539,11 @@ public class CVLoadCoordinator: NSObject {
 
         let (loadPromise, loadResolver) = Promise<Void>.pending()
 
-        let viewState = self.viewState
         func canLandLoad() -> Bool {
-            // Ensure isUserScrolling is a substate of hasScrollingAnimation.
-            if viewState.isUserScrolling {
-                owsAssertDebug(viewState.hasScrollingAnimation)
-            }
-            guard viewState.hasScrollingAnimation else {
-                // If no scroll gesture or animation is in progress,
-                // we can land the load.
-                return true
-            }
-            if let delegate = self.delegate {
-                if update.loadType == .loadOlder,
-                   delegate.isScrollNearTopOfLoadWindow {
-                    // If a scroll animation is progress, but we're very
-                    // close to the edge of the load window, land the load.
-                    return true
-                } else if update.loadType == .loadNewer,
-                          delegate.isScrollNearBottomOfLoadWindow {
-                    // If a scroll animation is progress, but we're very
-                    // close to the edge of the load window, land the load.
-                    return true
-                }
+            if delegate.isLayoutApplyingUpdate {
+                Logger.verbose("----")
             }
-            return false
+            return !delegate.isLayoutApplyingUpdate
         }
 
         func tryToResolve() {
@@ -802,7 +790,11 @@ extension CVLoadCoordinator: UICollectionViewDelegate {
             owsFailDebug("Missing delegate.")
             return proposedContentOffset
         }
-        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+        let targetContentOffset = delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+        Logger.verbose("---- lc isUserScrolling: \(delegate.isUserScrolling), hasScrollingAnimation: \(viewState.hasScrollingAnimation), proposedContentOffset: \(proposedContentOffset), targetContentOffset: \(targetContentOffset), ")
+//        return targetContentOffset
+        return proposedContentOffset
+//       return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
     }
 }
 
@@ -844,6 +836,30 @@ extension CVLoadCoordinator: ConversationViewLayoutDelegate {
         }
         return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
     }
+
+    public var isUserScrolling: Bool {
+        guard let delegate = self.delegate else {
+            owsFailDebug("Missing delegate.")
+            return false
+        }
+        return delegate.isUserScrolling
+    }
+
+    public var hasScrollingAnimation: Bool {
+        guard let delegate = self.delegate else {
+            owsFailDebug("Missing delegate.")
+            return false
+        }
+        return delegate.hasScrollingAnimation
+    }
+
+    public var scrollContinuity: ScrollContinuity {
+        guard let delegate = self.delegate else {
+            owsFailDebug("Missing delegate.")
+            return .bottom
+        }
+        return delegate.scrollContinuity
+    }
 }
 
 // MARK: -
diff --git a/Signal/src/ViewControllers/ConversationView/CVViewState.swift b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
index 596a1438f37..2278f900bda 100644
--- a/Signal/src/ViewControllers/ConversationView/CVViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
@@ -63,10 +63,13 @@ public class CVViewState: NSObject {
     @objc
     public var scrollingAnimationCompletionTimer: Timer?
     @objc
-    public var hasScrollingAnimation: Bool { scrollingAnimationCompletionTimer != nil }
+    public var hasScrollingAnimation: Bool {
+        AssertIsOnMainThread()
+
+        return scrollingAnimationCompletionTimer != nil
+    }
     @objc
     public var scrollContinuity: ScrollContinuity = .bottom
-    public var scrollContinuityMap: CVScrollContinuityMap?
     public var scrollActionForSizeTransition: CVScrollAction?
     public var scrollActionForUpdate: CVScrollAction?
     public var lastKnownDistanceFromBottom: CGFloat?
@@ -131,6 +134,11 @@ public class CVViewState: NSObject {
     @objc
     public let backgroundContainer = CVBackgroundContainer()
 
+    @objc
+    public let loadLabel = UILabel()
+    @objc
+    public let startDate = Date()
+
     // MARK: - 
 
     @objc
@@ -559,15 +567,3 @@ public extension ConversationViewController {
         hasViewDidAppearEverCompleted
     }
 }
-
-// MARK: -
-
-public struct CVScrollContinuityMap {
-    let renderStateId: UInt
-
-    public struct Item {
-        let sortId: UInt64
-        let distanceY: CGFloat
-    }
-    public let items: [Item]
-}
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index 0b48edf8c3d..48dd20625c2 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -59,6 +59,11 @@ extension ConversationViewController {
     public var currentRenderStateDebugDescription: String {
         renderState.debugDescription
     }
+
+    @objc
+    public var isLayoutApplyingUpdate: Bool {
+        layout.isApplyingUpdate
+    }
 }
 
 // MARK: -
@@ -88,13 +93,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         collectionView.layoutIfNeeded()
         // ENDHACK to work around radar #28167779
 
-        // This will get cleared by updateViewToReflectLoad().
-        owsAssertDebug(viewState.scrollContinuityMap == nil)
-        if hasViewWillAppearEverBegun,
-           !renderState.isFirstLoad {
-            viewState.scrollContinuityMap = buildScrollContinuityMap(forRenderState: renderState)
-        }
-
         return CVUpdateToken(isScrolledToBottom: self.isScrolledToBottom,
                              lastMessageForInboxSortId: threadViewModel.lastMessageForInbox?.sortId)
     }
@@ -237,13 +235,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
     }
 
     private func loadDidLand() {
-        // Discard scrollContinuityMap after the load is complete.
-        //
-        // Do not discard scrollContinuityMap if it corresponds to a
-        // subsequent load. Animated and non-animated loads might
-        // land in any order and thus complete out of order.
-        self.viewState.scrollContinuityMap = nil
-
         self.loadCoordinator.loadDidLand()
     }
 
@@ -325,10 +316,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         // completes first, we need to update the collection view
         // to reflect its contents.
         if reloadIfClearingFlag, hasRenderState {
-            UIView.performWithoutAnimation {
-                self.collectionView.reloadData()
-                self.layout.invalidateLayout()
-            }
+            reloadCollectionViewImmediately()
 
             scrollToInitialPosition(animated: false)
 
@@ -340,6 +328,17 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         }
     }
 
+    private func reloadCollectionViewImmediately() {
+        AssertIsOnMainThread()
+
+        layout.willReloadData()
+        UIView.performWithoutAnimation {
+            self.collectionView.reloadData()
+            self.layout.invalidateLayout()
+        }
+        layout.didReloadData()
+    }
+
     private func updateForMinorUpdate(scrollAction: CVScrollAction) {
         Logger.verbose("")
 
@@ -370,10 +369,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         benchSteps.step("1")
 
-        UIView.performWithoutAnimation {
-            self.collectionView.reloadData()
-            self.layout.invalidateLayout()
-        }
+        reloadCollectionViewImmediately()
 
         benchSteps.step("2")
 
@@ -416,10 +412,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         Logger.verbose("")
 
-        UIView.performWithoutAnimation {
-            self.collectionView.reloadData()
-            self.layout.invalidateLayout()
-        }
+        reloadCollectionViewImmediately()
 
         DispatchQueue.main.async { [weak self] in
             guard let self = self else { return }
@@ -442,7 +435,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         scrollContinuity = .bottom
 
-        reloadCollectionView()
+        reloadCollectionViewForReset()
 
         // Try to update the lastKnownDistanceFromBottom; the content size may have changed.
         updateLastKnownDistanceFromBottom()
@@ -466,15 +459,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         var scrollAction = scrollActionParam
 
-        scrollContinuity = isScrolledToBottom ? .bottom : .top
-        if let loadType = renderState.loadType {
-            if loadType == .loadOlder {
-                scrollContinuity = .bottom
-            }
-        } else {
-            owsFailDebug("Missing loadType.")
-        }
-
         // Update scroll action to auto-scroll if necessary.
         if scrollAction.action == .none, !self.isUserScrolling {
             for item in items {
@@ -529,6 +513,23 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             }
         }
 
+        scrollContinuity = isScrolledToBottom ? .bottom : .top
+        var isLoadAdjacent = false
+        if let loadType = renderState.loadType {
+            switch loadType {
+            case .loadOlder:
+                scrollContinuity = .bottom
+                scrollAction = .none
+                isLoadAdjacent = true
+            case .loadNewer, .loadNewest:
+                isLoadAdjacent = true
+            default:
+                break
+            }
+        } else {
+            owsFailDebug("Missing loadType.")
+        }
+
         viewState.scrollActionForUpdate = scrollAction
 
         let batchUpdatesBlock = {
@@ -615,7 +616,8 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         self.performBatchUpdates(batchUpdatesBlock,
                                  completion: completion,
                                  logFailureBlock: logFailureBlock,
-                                 shouldAnimateUpdates: shouldAnimateUpdate)
+                                 shouldAnimateUpdates: shouldAnimateUpdate,
+                                 isLoadAdjacent: isLoadAdjacent)
     }
 
     private var scrolledToEdgeTolerancePoints: CGFloat {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index 5a1e1ae9b55..6254f707a6d 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -538,14 +538,7 @@ extension ConversationViewController {
         if let contentOffset = targetContentOffsetForUpdate() {
             if !DebugFlags.reduceLogChatter {
                 Logger.verbose("---- targetContentOffsetForUpdate: \(contentOffset)")
-            }
-            return contentOffset
-        }
-
-        if let contentOffset = targetContentOffsetForScrollContinuityMap() {
-            if !DebugFlags.reduceLogChatter {
-                Logger.verbose("---- targetContentOffsetForScrollContinuityMap: \(contentOffset)")
-            }
+//            }
             return contentOffset
         }
 
@@ -572,57 +565,6 @@ extension ConversationViewController {
         return contentOffset
     }
 
-    func buildScrollContinuityMap(forRenderState renderState: CVRenderState) -> CVScrollContinuityMap {
-        AssertIsOnMainThread()
-
-        // We don't need to worry about scroll continuity when landing
-        // the first load or if we're not yet displaying the collection
-        // view content.
-        if renderState.isFirstLoad || loadCoordinator.shouldHideCollectionViewContent {
-            return CVScrollContinuityMap(renderStateId: renderState.renderStateId,
-                                         items: [])
-        }
-
-        let contentOffset = collectionView.contentOffset
-
-        var sortIdToIndexPathMap = [UInt64: IndexPath]()
-        for (index, renderItem) in renderItems.enumerated() {
-            let indexPath = IndexPath(row: index, section: Self.messageSection)
-            let sortId = renderItem.interaction.sortId
-            sortIdToIndexPathMap[sortId] = indexPath
-        }
-
-        var items = [CVScrollContinuityMap.Item]()
-        for cell in collectionView.visibleCells {
-            guard let cell = cell as? CVCell else {
-                owsFailDebug("Invalid cell.")
-                continue
-            }
-            guard let renderItem = cell.renderItem else {
-                owsFailDebug("Missing renderItem.")
-                continue
-            }
-            guard canInteractionBeUsedForScrollContinuity(renderItem.interaction) else {
-                continue
-            }
-            let sortId = renderItem.interaction.sortId
-            guard let indexPath = sortIdToIndexPathMap[sortId] else {
-                owsFailDebug("Missing indexPath.")
-                continue
-            }
-            guard let layoutAttributes = layout.layoutAttributesForItem(at: indexPath) else {
-                owsFailDebug("Missing layoutAttributes.")
-                continue
-            }
-            let distanceY = layoutAttributes.frame.topLeft.y - contentOffset.y
-
-            items.append(CVScrollContinuityMap.Item(sortId: sortId,
-                                                    distanceY: distanceY))
-        }
-        return CVScrollContinuityMap(renderStateId: renderState.renderStateId,
-                                     items: items)
-    }
-
     private func canInteractionBeUsedForScrollContinuity(_ interaction: TSInteraction) -> Bool {
         guard !interaction.isDynamicInteraction() else {
             return false
@@ -636,51 +578,6 @@ extension ConversationViewController {
         }
     }
 
-    // We use this hook to ensure scroll state continuity.  As the collection
-    // view's content size changes, we want to keep the same cells in view.
-    private func targetContentOffsetForScrollContinuityMap() -> CGPoint? {
-        guard let scrollContinuityMap = viewState.scrollContinuityMap else {
-            return nil
-        }
-
-        var sortIdToIndexPathMap = [UInt64: IndexPath]()
-        for (index, renderItem) in renderItems.enumerated() {
-            let indexPath = IndexPath(row: index, section: Self.messageSection)
-            let sortId = renderItem.interaction.sortId
-            sortIdToIndexPathMap[sortId] = indexPath
-        }
-
-        // Honor the scroll continuity bias.
-        //
-        // If we prefer continuity with regard to the bottom
-        // of the conversation, start with the last items.
-        let items = (scrollContinuity == .bottom
-                        ? scrollContinuityMap.items.reversed()
-                        : scrollContinuityMap.items)
-
-        for item in items {
-            let sortId = item.sortId
-            let oldDistanceY = item.distanceY
-
-            guard let indexPath = sortIdToIndexPathMap[sortId] else {
-                continue
-            }
-            guard let latestFrame = layout.latestFrame(forIndexPath: indexPath) else {
-                owsFailDebug("Missing layoutAttributes.")
-                continue
-            }
-
-            let newLocation = latestFrame.topLeft
-            let contentOffsetY = newLocation.y - oldDistanceY
-            let contentOffset = CGPoint(x: 0, y: contentOffsetY)
-            return contentOffset
-        }
-
-        Logger.verbose("No continuity match.")
-
-        return nil
-    }
-
     private func targetContentOffsetForSizeTransition() -> CGPoint? {
         guard let scrollAction = viewState.scrollActionForSizeTransition else {
             return nil
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.h b/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
index 55f96f604fc..45e096d7a4a 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
@@ -94,7 +94,7 @@ typedef NS_CLOSED_ENUM(NSUInteger, ConversationUIMode) {
 - (void)ensureBannerState;
 
 // TODO: Remove or rework method.
-- (void)reloadCollectionView;
+- (void)reloadCollectionViewForReset;
 
 - (void)updateNavigationBarSubtitleLabel;
 - (void)dismissMessageActionsIfNecessary;
@@ -106,7 +106,8 @@ typedef NS_CLOSED_ENUM(NSUInteger, ConversationUIMode) {
 - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
                  completion:(void (^_Nonnull)(BOOL))completion
             logFailureBlock:(void (^_Nonnull)(void))logFailureBlock
-       shouldAnimateUpdates:(BOOL)shouldAnimateUpdates;
+       shouldAnimateUpdates:(BOOL)shouldAnimateUpdates
+             isLoadAdjacent:(BOOL)isLoadAdjacent;
 - (BOOL)autoLoadMoreIfNecessary;
 
 #pragma mark - Search
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index c7172bf91f7..3b94fc7d050 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -928,7 +928,7 @@ - (void)startReadTimer
 
 - (void)readTimerDidFire
 {
-    if (self.layout.isPerformingBatchUpdates) {
+    if (self.layout.isUpdating) {
         return;
     }
     [self markVisibleMessagesAsRead];
@@ -2982,14 +2982,16 @@ - (void)applyTheme
     [self dismissReactionsDetailSheetAnimated:NO];
 }
 
-- (void)reloadCollectionView
+- (void)reloadCollectionViewForReset
 {
     if (!self.hasAppearedAndHasAppliedFirstLoad) {
         return;
     }
     @try {
+        [self.layout willReloadData];
         [self.collectionView reloadData];
         [self.layout invalidateLayout];
+        [self.layout didReloadData];
     } @catch (NSException *exception) {
         OWSLogWarn(@"currentRenderStateDebugDescription: %@", self.currentRenderStateDebugDescription);
         OWSFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
@@ -3118,6 +3120,7 @@ - (void)scheduleScrollUpdateTimer
     }
 
     OWSLogVerbose(@"");
+    [self.scrollUpdateTimer invalidate];
 
     // We need to manually schedule this timer using NSRunLoopCommonModes
     // or it won't fire during scrolling.
@@ -3793,25 +3796,20 @@ - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
                  completion:(void (^_Nonnull)(BOOL))completion
             logFailureBlock:(void (^_Nonnull)(void))logFailureBlock
        shouldAnimateUpdates:(BOOL)shouldAnimateUpdates
+             isLoadAdjacent:(BOOL)isLoadAdjacent
 {
     @try {
         void (^updateBlock)(void) = ^{
-            [self.layout willPerformBatchUpdates];
-            [self.collectionView performBatchUpdates:batchUpdates completion:completion];
-            [self.layout didPerformBatchUpdates];
+            ConversationViewLayout *layout = self.layout;
+            [layout willPerformBatchUpdatesWithAnimated:shouldAnimateUpdates isLoadAdjacent:isLoadAdjacent];
+            [self.collectionView performBatchUpdates:batchUpdates
+                                          completion:^(BOOL finished) {
+                                              [layout didCompleteBatchUpdates];
+
+                                              completion(finished);
+                                          }];
+            [layout didPerformBatchUpdatesWithAnimated:shouldAnimateUpdates];
 
-            // AFAIK the collection view layout should reflect the old layout
-            // until performBatchUpdates(), then we need to invalidate and prepare
-            // the (new) layout just _after_ performBatchUpdates.
-            //
-            // Moreover it's important that the (old) layout is prepared when
-            // performBatchUpdates() is called.  We ensure this in
-            // willUpdateWithNewRenderState().
-            //
-            // Otherwise UICollectionView can throw (crashing) exceptions like this:
-            //
-            // UICollectionView received layout attributes for a cell with an index path that does not exist...
-            [self.layout invalidateLayout];
             [BenchManager completeEventWithEventId:@"message-send"];
         };
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index 1d809fb4aba..5a591bb256d 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -7,6 +7,8 @@ import Foundation
 @objc
 public protocol ConversationViewLayoutItem {
 
+    var interactionUniqueId: String { get }
+
     var cellSize: CGSize { get }
 
     func vSpacing(previousLayoutItem: ConversationViewLayoutItem) -> CGFloat
@@ -24,6 +26,10 @@ public protocol ConversationViewLayoutDelegate {
     var layoutFooterHeight: CGFloat { get }
 
     func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint
+
+    var isUserScrolling: Bool { get }
+    var hasScrollingAnimation: Bool { get }
+    var scrollContinuity: ScrollContinuity { get }
 }
 
 // MARK: -
@@ -36,12 +42,13 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     private var conversationStyle: ConversationStyle
 
-    private struct ItemLayout {
+    fileprivate struct ItemLayout {
+        let interactionUniqueId: String
         let indexPath: IndexPath
         let layoutAttributes: UICollectionViewLayoutAttributes
     }
 
-    private class LayoutInfo {
+    fileprivate class LayoutInfo {
 
         let viewWidth: CGFloat
         let contentSize: CGSize
@@ -49,19 +56,22 @@ public class ConversationViewLayout: UICollectionViewLayout {
         let headerLayoutAttributes: UICollectionViewLayoutAttributes?
         let footerLayoutAttributes: UICollectionViewLayoutAttributes?
         let itemLayouts: [ItemLayout]
+        let renderStateId: UInt
 
         required init(viewWidth: CGFloat,
                       contentSize: CGSize,
                       itemAttributesMap: [Int: UICollectionViewLayoutAttributes],
                       headerLayoutAttributes: UICollectionViewLayoutAttributes?,
                       footerLayoutAttributes: UICollectionViewLayoutAttributes?,
-                      itemLayouts: [ItemLayout]) {
+                      itemLayouts: [ItemLayout],
+                      renderStateId: UInt) {
             self.viewWidth = viewWidth
             self.contentSize = contentSize
             self.itemAttributesMap = itemAttributesMap
             self.headerLayoutAttributes = headerLayoutAttributes
             self.footerLayoutAttributes = footerLayoutAttributes
             self.itemLayouts = itemLayouts
+            self.renderStateId = renderStateId
         }
 
         func layoutAttributesForItem(at indexPath: IndexPath, assertIfMissing: Bool) -> UICollectionViewLayoutAttributes? {
@@ -121,7 +131,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
             return layoutInfo
         }
 
-        updateState()
+        ensureState()
 
         let layoutInfo = Self.buildLayoutInfo(state: currentState)
         currentLayoutInfo = layoutInfo
@@ -155,22 +165,20 @@ public class ConversationViewLayout: UICollectionViewLayout {
     public override func invalidateLayout() {
         super.invalidateLayout()
 
-        updateState()
+        ensureState()
     }
 
     @objc
     public override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) {
 
-        if context.invalidateDataSourceCounts {
-            hasInvalidatedDataSourceCounts = true
-        }
+        Logger.verbose("---- invalidateEverything: \(context.invalidateEverything), invalidateDataSourceCounts: \(context.invalidateDataSourceCounts), contentOffsetAdjustment: \(context.contentOffsetAdjustment), contentSizeAdjustment: \(context.contentSizeAdjustment), interactiveMovementTarget: \(context.interactiveMovementTarget)")
 
         super.invalidateLayout(with: context)
 
-        updateState()
+        ensureState()
     }
 
-    private func updateState() {
+    private func ensureState() {
         AssertIsOnMainThread()
 
         let newState = State.build(delegate: delegate, conversationStyle: conversationStyle)
@@ -234,7 +242,8 @@ public class ConversationViewLayout: UICollectionViewLayout {
                               itemAttributesMap: [:],
                               headerLayoutAttributes: nil,
                               footerLayoutAttributes: nil,
-                              itemLayouts: [])
+                              itemLayouts: [],
+                              renderStateId: 0)
         }
 
         guard let state = state else {
@@ -302,7 +311,8 @@ public class ConversationViewLayout: UICollectionViewLayout {
             row += 1
             previousLayoutItem = layoutItem
 
-            itemLayouts.append(ItemLayout(indexPath: indexPath,
+            itemLayouts.append(ItemLayout(interactionUniqueId: layoutItem.interactionUniqueId,
+                                          indexPath: indexPath,
                                           layoutAttributes: itemAttributes))
         }
 
@@ -323,13 +333,15 @@ public class ConversationViewLayout: UICollectionViewLayout {
         }
 
         let contentSize = CGSize(width: viewWidth, height: contentBottom)
+        let renderStateId = state.renderStateId
 
         return LayoutInfo(viewWidth: viewWidth,
                           contentSize: contentSize,
                           itemAttributesMap: itemAttributesMap,
                           headerLayoutAttributes: headerLayoutAttributes,
                           footerLayoutAttributes: footerLayoutAttributes,
-                          itemLayouts: itemLayouts)
+                          itemLayouts: itemLayouts,
+                          renderStateId: renderStateId)
     }
 
     // MARK: - UICollectionViewLayout Impl.
@@ -338,21 +350,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
     public override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
         AssertIsOnMainThread()
 
-        func getPreUpdateLayoutInfo() -> LayoutInfo? {
-            guard isPerformingBatchUpdates, !hasInvalidatedDataSourceCounts else {
-                return nil
-            }
-            guard let lastLayoutInfo = lastLayoutInfo else {
-                owsFailDebug("Missing lastLayoutInfo.")
-                return nil
-            }
-            return lastLayoutInfo
-        }
-
-        // During performBatchUpdates(), this method should reflect
-        // pre-update layout info until the layout is invalidated
-        // with the invalidateDataSourceCounts flag set.
-        let layoutInfo = getPreUpdateLayoutInfo() ?? ensureCurrentLayoutInfo()
+        let layoutInfo = ensureCurrentLayoutInfo()
 
         var result = [UICollectionViewLayoutAttributes]()
         if let headerLayoutAttributes = layoutInfo.headerLayoutAttributes {
@@ -371,15 +369,12 @@ public class ConversationViewLayout: UICollectionViewLayout {
     public override func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
         AssertIsOnMainThread()
 
+        //        Logger.verbose("---- indexPath: \(indexPath), updateState: \(updateState)")
+
         let layoutInfo = ensureCurrentLayoutInfo()
         return layoutInfo.layoutAttributesForItem(at: indexPath, assertIfMissing: true)
     }
 
-    // Used by targetContentOffset(forProposedContentOffset:).
-    public func latestFrame(forIndexPath indexPath: IndexPath) -> CGRect? {
-        layoutAttributesForItem(at: indexPath)?.frame
-    }
-
     @objc
     public override func layoutAttributesForSupplementaryView(ofKind elementKind: String,
                                                               at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
@@ -399,41 +394,106 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -> Bool {
-        let lastViewWidth = currentLayoutInfo?.viewWidth
-        return lastViewWidth != newBounds.width
+        return true
     }
 
-    // MARK: -
-
     // MARK: - performBatchUpdates()
 
-    // This is used during performBatchUpdates() to determine
-    // the initial (last) layout state for items.
-    private var lastLayoutInfo: LayoutInfo?
+    private struct UpdateScrollContinuity {
+        let layoutInfo: LayoutInfo
+        let contentOffset: CGPoint
+
+        private static let idCounter = AtomicUInt(0)
+        public let id: UInt = UpdateScrollContinuity.idCounter.increment()
+    }
+    private var updateScrollContinuity: UpdateScrollContinuity?
 
+    private var isAnimatingBoundsChange = false {
+        didSet {
+            if !isAnimatingBoundsChange {
+                updateScrollContinuity = nil
+            }
+        }
+    }
+
+    // TODO: Remove.
     @objc
-    public var isPerformingBatchUpdates = false
-    private var hasInvalidatedDataSourceCounts = false
+    public var isUpdating: Bool {
+        isPerformingBatchUpdates || isReloadingData
+    }
 
     @objc
-    public func willPerformBatchUpdates() {
+    public var isApplyingUpdate: Bool {
+        updateScrollContinuity != nil
+    }
+
+    private var isPerformingBatchUpdates = false
+
+    @objc
+    public func willPerformBatchUpdates(animated: Bool, isLoadAdjacent: Bool) {
         AssertIsOnMainThread()
         owsAssertDebug(currentLayoutInfo != nil)
-        owsAssertDebug(lastLayoutInfo == nil)
+
+        Logger.verbose("----- animated: \(animated), isLoadAdjacent: \(isLoadAdjacent)")
 
         isPerformingBatchUpdates = true
-        lastLayoutInfo = ensureCurrentLayoutInfo()
-        hasInvalidatedDataSourceCounts = false
+        if isLoadAdjacent {
+            captureUpdateScrollContinuity()
+        }
     }
 
     @objc
-    public func didPerformBatchUpdates() {
+    public func didPerformBatchUpdates(animated: Bool) {
         AssertIsOnMainThread()
-        owsAssertDebug(lastLayoutInfo != nil)
+
+        Logger.verbose("-----")
 
         isPerformingBatchUpdates = false
-        lastLayoutInfo = nil
-        hasInvalidatedDataSourceCounts = false
+    }
+
+    @objc
+    public func didCompleteBatchUpdates() {
+        AssertIsOnMainThread()
+
+        Logger.verbose("-----")
+    }
+
+    private var isReloadingData = false
+
+    @objc
+    public func willReloadData() {
+        AssertIsOnMainThread()
+
+        isReloadingData = true
+    }
+
+    @objc
+    public func didReloadData() {
+        AssertIsOnMainThread()
+
+        isReloadingData = false
+    }
+
+    private func captureUpdateScrollContinuity() {
+        AssertIsOnMainThread()
+
+        if let collectionView = collectionView {
+            let updateScrollContinuity = UpdateScrollContinuity(layoutInfo: ensureCurrentLayoutInfo(),
+                                                                contentOffset: collectionView.contentOffset)
+            self.updateScrollContinuity = updateScrollContinuity
+
+            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
+                guard let self = self else { return }
+                if let currentContinuity = self.updateScrollContinuity,
+                   currentContinuity.id == updateScrollContinuity.id {
+                    Logger.warn("---- UpdateScrollContinuity did not get cleaned up in a timely way.")
+                    self.updateScrollContinuity = nil
+                }
+            }
+        } else {
+            owsFailDebug("Missing collectionView.")
+            updateScrollContinuity = nil
+        }
     }
 
     // This method is called when there is an update with deletes/inserts to the collection view.
@@ -444,38 +504,39 @@ public class ConversationViewLayout: UICollectionViewLayout {
     // The updateItems parameter is an array of UICollectionViewUpdateItem instances for each
     // element that is moving to a new index path.
     public override func prepare(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem]) {
+        Logger.verbose("---- \(debugInfo)")
         super.prepare(forCollectionViewUpdates: updateItems)
     }
 
     // Called inside an animation block after the update.
     public override func finalizeCollectionViewUpdates() {
+        Logger.verbose("---- \(debugInfo)")
         super.finalizeCollectionViewUpdates()
     }
 
     // UICollectionView calls this when its bounds have changed inside an
     // animation block before displaying cells in its new bounds.
     public override func prepare(forAnimatedBoundsChange oldBounds: CGRect) {
+        Logger.verbose("---- oldBounds: \(oldBounds), \(debugInfo)")
         super.prepare(forAnimatedBoundsChange: oldBounds)
+
+        isAnimatingBoundsChange = true
     }
 
     // also called inside the animation block
     public override func finalizeAnimatedBoundsChange() {
+        Logger.verbose("---- \(debugInfo)")
         super.finalizeAnimatedBoundsChange()
-    }
 
-    // UICollectionView calls this when prior the layout transition animation
-    // on the incoming and outgoing layout.
-    public override func prepareForTransition(to newLayout: UICollectionViewLayout) {
-        super.prepareForTransition(to: newLayout)
+        isAnimatingBoundsChange = false
     }
 
-    public override func prepareForTransition(from oldLayout: UICollectionViewLayout) {
-        super.prepareForTransition(from: oldLayout)
-    }
-
-    // called inside an animation block after the transition
-    public override func finalizeLayoutTransition() {
-        super.finalizeLayoutTransition()
+    private var debugInfo: String {
+        guard let delegate = delegate else {
+            owsFailDebug("Missing delegate.")
+            return "Missing delegate"
+        }
+        return "isUserScrolling: \(delegate.isUserScrolling), hasScrollingAnimation: \(delegate.hasScrollingAnimation), scrollContinuity: \(delegate.scrollContinuity), isPerformingBatchUpdates: \(isPerformingBatchUpdates), isReloadingData: \(isReloadingData), updateScrollContinuity: \(updateScrollContinuity != nil)"
     }
 
     // MARK: -
@@ -483,25 +544,98 @@ public class ConversationViewLayout: UICollectionViewLayout {
     // A layout can return the content offset to be applied during transition or update animations.
     public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint,
                                              withScrollingVelocity velocity: CGPoint) -> CGPoint {
-        guard isPerformingBatchUpdates else {
-            return proposedContentOffset
-        }
-        guard let delegate = delegate else {
-            return super.targetContentOffset(forProposedContentOffset: proposedContentOffset,
-                                             withScrollingVelocity: velocity)
-        }
-        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+
+        targetContentOffset(proposedContentOffset: proposedContentOffset,
+                            withScrollingVelocity: velocity)
     }
 
     // A layout can return the content offset to be applied during transition or update animations.
     public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
-        guard isPerformingBatchUpdates else {
+
+        targetContentOffset(proposedContentOffset: proposedContentOffset,
+                            withScrollingVelocity: nil)
+    }
+
+    private func targetContentOffset(proposedContentOffset: CGPoint,
+                                     withScrollingVelocity velocity: CGPoint?) -> CGPoint {
+
+        guard let delegate = delegate else {
+            owsFailDebug("Missing delegate.")
+            if let velocity = velocity {
+                return super.targetContentOffset(forProposedContentOffset: proposedContentOffset,
+                                                 withScrollingVelocity: velocity)
+            } else {
+                return super.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+            }
+        }
+
+        guard velocity == nil else {
             return proposedContentOffset
         }
-        guard let delegate = delegate else {
-            return super.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+
+        if let updateScrollContinuity = updateScrollContinuity {
+            let layoutInfoCurrent = ensureCurrentLayoutInfo()
+            if let targetContentOffset = Self.targetContentOffsetForUpdate(delegate: delegate,
+                                                                           updateScrollContinuity: updateScrollContinuity,
+                                                                           layoutInfoCurrent: layoutInfoCurrent) {
+                Logger.verbose("---- for update. proposedContentOffset: \(proposedContentOffset), targetContentOffset: \(targetContentOffset), \(debugInfo)")
+                return targetContentOffset
+            } else {
+                Logger.warn("Could not ensure scroll continuity.")
+            }
+        }
+
+        if isUpdating {
+            let targetContentOffset = delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+            Logger.verbose("---- default.1 proposedContentOffset: \(proposedContentOffset), targetContentOffset: \(targetContentOffset), velocity: \(velocity), \(debugInfo) ")
+            return targetContentOffset
+        } else {
+            Logger.verbose("---- default.2 proposedContentOffset: \(proposedContentOffset), velocity: \(velocity), \(debugInfo), ")
+            return proposedContentOffset
+        }
+    }
+
+    // We use this hook to ensure scroll state continuity.  As the collection
+    // view's content size changes, we want to keep the same cells in view.
+    private static func targetContentOffsetForUpdate(delegate: ConversationViewLayoutDelegate,
+                                                     updateScrollContinuity: UpdateScrollContinuity,
+                                                     layoutInfoCurrent layoutInfoAfterUpdate: LayoutInfo) -> CGPoint? {
+        let layoutInfoBeforeUpdate = updateScrollContinuity.layoutInfo
+        let contentOffsetBeforeUpdate = updateScrollContinuity.contentOffset
+
+        //        guard let scrollContinuityMap = viewState.scrollContinuityMap else {
+        //            return nil
+        //        }
+
+        var beforeItemLayoutMap = [String: ItemLayout]()
+        for itemLayout in layoutInfoBeforeUpdate.itemLayouts {
+            beforeItemLayoutMap[itemLayout.interactionUniqueId] = itemLayout
         }
-        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+
+        // Honor the scroll continuity bias.
+        //
+        // If we prefer continuity with regard to the bottom
+        // of the conversation, start with the last items.
+        let afterItemLayouts = (delegate.scrollContinuity == .bottom
+                                    ? layoutInfoAfterUpdate.itemLayouts.reversed()
+                                    : layoutInfoAfterUpdate.itemLayouts)
+
+        for afterItemLayout in afterItemLayouts {
+            guard let beforeItemLayout = beforeItemLayoutMap[afterItemLayout.interactionUniqueId] else {
+                continue
+            }
+            let frameBeforeUpdate = beforeItemLayout.layoutAttributes.frame
+            let frameAfterUpdate = afterItemLayout.layoutAttributes.frame
+            let offset = frameAfterUpdate.origin - frameBeforeUpdate.origin
+            let updatedContentOffset = CGPoint(x: 0,
+                                               y: (contentOffsetBeforeUpdate + offset).y)
+            Logger.verbose("---- contentOffsetBeforeUpdate: \(contentOffsetBeforeUpdate) -> updatedContentOffset: \(updatedContentOffset)")
+            return updatedContentOffset
+        }
+
+        Logger.verbose("No continuity match.")
+
+        return nil
     }
 
     @objc
