diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index 00b248a800b..088348ccd9c 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -450,52 +450,6 @@ public class CVLoadCoordinator: NSObject {
                 throw OWSGenericError("Missing delegate.")
             }
             return self.loadLandWhenSafePromise(update: update, delegate: delegate)
-//            return self.loadLandWhenSafePromise {
-//                let renderState = update.renderState
-//                let oldItemCount = update.lastRenderState.items.count
-//                let newItemCount = renderState.items.count
-//
-//                let updateToken = delegate.willUpdateWithNewRenderState(renderState)
-//
-//                self.renderState = renderState
-//
-//                let (promise, resolver) = Promise<Void>.pending()
-//                self.loadDidLandResolver = resolver
-//                delegate.updateWithNewRenderState(update: update,
-//                                                  scrollAction: loadRequest.scrollAction,
-//                                                  updateToken: updateToken)
-//            }
-
-//            firstly { () -> Promise<Void> in
-//                guard let self = self else {
-//                    throw OWSGenericError("Missing self.")
-//                }
-//                return self.viewState.waitUntilCanLandLoad()
-//            }.map { () -> CVUpdate in
-//                update
-//            }
-//        }.then { [weak self] (update: CVUpdate) -> Promise<Void> in
-//            guard let self = self else {
-//                throw OWSGenericError("Missing self.")
-//            }
-//            guard let delegate = self.delegate else {
-//                throw OWSGenericError("Missing delegate.")
-//            }
-//
-//            let renderState = update.renderState
-//            let oldItemCount = update.lastRenderState.items.count
-//            let newItemCount = renderState.items.count
-//
-//            let updateToken = delegate.willUpdateWithNewRenderState(renderState)
-//
-//            self.renderState = renderState
-//
-//            let (promise, resolver) = Promise<Void>.pending()
-//            self.loadDidLandResolver = resolver
-//            delegate.updateWithNewRenderState(update: update,
-//                                              scrollAction: loadRequest.scrollAction,
-//                                              updateToken: updateToken)
-//            return promise
         }.done { [weak self] () -> Void in
             guard let self = self else {
                 throw OWSGenericError("Missing self.")
@@ -522,27 +476,24 @@ public class CVLoadCoordinator: NSObject {
 
     // MARK: - Safe Landing
 
+    // Lands the load when its safe, blocking on scrolling.
     private func loadLandWhenSafePromise(update: CVUpdate,
                                          delegate: CVLoadCoordinatorDelegate) -> Promise<Void> {
         AssertIsOnMainThread()
 
         let (loadPromise, loadResolver) = Promise<Void>.pending()
 
-        var attemptCount = 0
-
         let viewState = self.viewState
         func canLandLoad() -> Bool {
-            let canLandLoad = !viewState.hasScrollingAnimation && !viewState.isUserScrolling
-            attemptCount += 1
-            Logger.verbose("attemptCount: \(attemptCount), canLandLoad: \(canLandLoad), hasScrollingAnimation: \(viewState.hasScrollingAnimation), isUserScrolling: \(viewState.isUserScrolling), ")
-            return canLandLoad
-//            !viewState.hasScrollingAnimation && !viewState.isUserScrolling
+            !viewState.hasScrollingAnimation && !viewState.isUserScrolling
         }
 
         func tryToResolve() {
             guard canLandLoad() else {
                 // TODO: async() or asyncAfter()?
                 Logger.verbose("Waiting to land load.")
+                // We wait in a pretty tight loop to ensure loads land in a timely way.
+                //
                 // DispatchQueue.asyncAfter() will take longer to perform
                 // its block than DispatchQueue.async() if the CPU is under
                 // heavy load. That's desirable in this case.
@@ -553,9 +504,6 @@ public class CVLoadCoordinator: NSObject {
             }
 
             let renderState = update.renderState
-//            let oldItemCount = update.lastRenderState.items.count
-//            let newItemCount = renderState.items.count
-
             let updateToken = delegate.willUpdateWithNewRenderState(renderState)
 
             self.renderState = renderState
@@ -569,6 +517,10 @@ public class CVLoadCoordinator: NSObject {
                                               updateToken: updateToken)
 
             firstly { () -> Promise<Void> in
+                // We've started the process of landing the load,
+                // but its completion may be async.
+                //
+                // Block on load land completion.
                 loadDidLandPromise
             }.done(on: .global()) {
                 loadResolver.fulfill(())
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index fcec6ddffe5..e58fd5d94ea 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -190,6 +190,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
     //       doing layout should be pretty cheap now.
     private static func buildLayoutInfo(delegate: ConversationViewLayoutDelegate?,
                                         conversationStyle: ConversationStyle) -> LayoutInfo {
+        AssertIsOnMainThread()
 
         func buildEmptyLayoutInfo() -> LayoutInfo {
             return LayoutInfo(viewWidth: 0,
@@ -298,6 +299,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
+        AssertIsOnMainThread()
 
         func getPreUpdateLayoutInfo() -> LayoutInfo? {
             guard isPerformingBatchUpdates, !hasInvalidatedDataSourceCounts else {
@@ -330,19 +332,15 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
-        layoutAttributesForItem(at: indexPath, alwaysUseLatestLayout: false)
-    }
-
-    private func layoutAttributesForItem(at indexPath: IndexPath,
-                                         alwaysUseLatestLayout: Bool) -> UICollectionViewLayoutAttributes? {
         AssertIsOnMainThread()
 
         let layoutInfo = ensureCurrentLayoutInfo()
         return layoutInfo.layoutAttributesForItem(at: indexPath, assertIfMissing: true)
     }
 
+    // Used by targetContentOffset(forProposedContentOffset:).
     public func latestFrame(forIndexPath indexPath: IndexPath) -> CGRect? {
-        layoutAttributesForItem(at: indexPath, alwaysUseLatestLayout: true)?.frame
+        layoutAttributesForItem(at: indexPath)?.frame
     }
 
     @objc
@@ -357,7 +355,9 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override var collectionViewContentSize: CGSize {
-        ensureCurrentLayoutInfo().contentSize
+        AssertIsOnMainThread()
+
+        return ensureCurrentLayoutInfo().contentSize
     }
 
     @objc
