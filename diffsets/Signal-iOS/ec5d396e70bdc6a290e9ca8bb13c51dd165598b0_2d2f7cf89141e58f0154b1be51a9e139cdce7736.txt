diff --git a/Signal/src/ViewControllers/ConversationView/CVViewState.swift b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
index 34c15e5a41b..390e624f595 100644
--- a/Signal/src/ViewControllers/ConversationView/CVViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
@@ -73,6 +73,7 @@ public class CVViewState: NSObject {
     public var scrollContinuity: ScrollContinuity = .bottom
     public var scrollContinuityMap: CVScrollContinuityMap?
     public var scrollActionForSizeTransition: CVScrollAction?
+    public var scrollActionForUpdate: CVScrollAction?
     public var lastKnownDistanceFromBottom: CGFloat?
     @objc
     public var lastSearchedText: String?
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index e039154d4a5..bc502cac010 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -457,6 +457,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
         let renderState = update.renderState
         let isScrolledToBottom = updateToken.isScrolledToBottom
+        let viewState = self.viewState
 
         var scrollAction = scrollActionParam
 
@@ -469,23 +470,11 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             owsFailDebug("Missing loadType.")
         }
 
-        let batchUpdatesBlock = {
-            AssertIsOnMainThread()
-
-            let section = Self.messageSection
-            var hasInserted = false
-            var hasUpdated = false
+        // Update scroll action to auto-scroll if necessary.
+        if scrollAction.action == .none, !self.isUserScrolling {
             for item in items {
                 switch item {
-                case .insert(let renderItem, let newIndex):
-                    // Always perform inserts before updates.
-                    owsAssertDebug(!hasUpdated)
-
-                    Logger.verbose("insert newIndex: \(newIndex)")
-
-                    let indexPath = IndexPath(row: newIndex, section: section)
-                    self.collectionView.insertItems(at: [indexPath])
-                    hasInserted = true
+                case .insert(let renderItem, _):
 
                     var wasJustInserted = false
                     if let lastMessageForInboxSortId = updateToken.lastMessageForInboxSortId,
@@ -500,31 +489,54 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                     case .typingIndicator:
                         isAutoScrollInteraction = true
                     case .incomingMessage,
-                        .outgoingMessage,
-                        .call,
-                        .error,
-                        .info:
+                         .outgoingMessage,
+                         .call,
+                         .error,
+                         .info:
                         isAutoScrollInteraction = wasJustInserted
                     default:
                         isAutoScrollInteraction = false
                     }
-                    if scrollAction.action == .none,
-                       !self.isUserScrolling {
-                        if let outgoingMessage = renderItem.interaction as? TSOutgoingMessage,
-                           !outgoingMessage.isFromLinkedDevice,
-                           wasJustInserted {
-                            // Whenever we send an outgoing message from the local device,
-                            // auto-scroll to the bottom of the conversation, regardless
-                            // of scroll state.
-                            scrollAction = CVScrollAction(action: .bottomOfLoadWindow, isAnimated: false)
-                        } else if isAutoScrollInteraction,
-                                  isScrolledToBottom {
-                            // If we're already at the bottom of the conversation and
-                            // a freshly inserted message or typing indicator appears,
-                            // auto-scroll to show it.
-                            scrollAction = CVScrollAction(action: .bottomOfLoadWindow, isAnimated: false)
-                        }
+
+                    if let outgoingMessage = renderItem.interaction as? TSOutgoingMessage,
+                       !outgoingMessage.isFromLinkedDevice,
+                       wasJustInserted {
+                        // Whenever we send an outgoing message from the local device,
+                        // auto-scroll to the bottom of the conversation, regardless
+                        // of scroll state.
+                        scrollAction = CVScrollAction(action: .bottomOfLoadWindow, isAnimated: false)
+                        break
+                    } else if isAutoScrollInteraction,
+                              isScrolledToBottom {
+                        // If we're already at the bottom of the conversation and
+                        // a freshly inserted message or typing indicator appears,
+                        // auto-scroll to show it.
+                        scrollAction = CVScrollAction(action: .bottomOfLoadWindow, isAnimated: false)
+                        break
                     }
+                default:
+                    break
+                }
+            }
+        }
+
+        viewState.scrollActionForUpdate = scrollAction
+
+        let batchUpdatesBlock = {
+            AssertIsOnMainThread()
+
+            let section = Self.messageSection
+            var hasInserted = false
+            var hasUpdated = false
+            for item in items {
+                switch item {
+                case .insert(_, let newIndex):
+                    // Always perform inserts before updates.
+                    owsAssertDebug(!hasUpdated)
+                    Logger.verbose("insert newIndex: \(newIndex)")
+                    let indexPath = IndexPath(row: newIndex, section: section)
+                    self.collectionView.insertItems(at: [indexPath])
+                    hasInserted = true
                 case .update(_, let oldIndex, _):
                     Logger.verbose("update oldIndex: \(oldIndex)")
                     let indexPath = IndexPath(row: oldIndex, section: section)
@@ -554,6 +566,8 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
 
             self.perform(scrollAction: scrollAction)
 
+            viewState.scrollActionForUpdate = nil
+
             if !finished {
                 Logger.warn("performBatchUpdates did not finish")
                 Logger.warn("Layout: \(self.layout.debugDescription)")
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index 4717d1d8382..7ad4e1256b9 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -87,7 +87,7 @@ public struct CVScrollAction: Equatable, CustomStringConvertible {
     // MARK: - CustomStringConvertible
 
     public var description: String {
-        "action: \(action), isAnimated: \(isAnimated)"
+        "[scrollAction: \(action), isAnimated: \(isAnimated)]"
     }
 }
 
@@ -505,23 +505,28 @@ extension ConversationViewController {
         Logger.verbose("---- proposedContentOffset: \(proposedContentOffset)")
 
         if isPresentingMessageActions,
-           let contentOffset = contentOffsetForMessageActionInteraction {
-            Logger.verbose("---- contentOffsetForMessageActionInteraction: \(contentOffset)")
+           let contentOffset = targetContentOffsetForMessageActionInteraction {
+            Logger.verbose("---- targetContentOffsetForMessageActionInteraction: \(contentOffset)")
             return contentOffset
         }
 
-        if let contentOffset = contentOffsetForSizeTransition() {
-            Logger.verbose("---- contentOffsetForSizeTransition: \(contentOffset)")
+        if let contentOffset = targetContentOffsetForSizeTransition() {
+            Logger.verbose("---- targetContentOffsetForSizeTransition: \(contentOffset)")
             return contentOffset
         }
 
-        if let contentOffset = contentOffsetForScrollContinuityMap() {
-            Logger.verbose("---- contentOffsetForScrollContinuityMap: \(contentOffset)")
+        if let contentOffset = targetContentOffsetForUpdate() {
+            Logger.verbose("---- targetContentOffsetForUpdate: \(contentOffset)")
+            return contentOffset
+        }
+
+        if let contentOffset = targetContentOffsetForScrollContinuityMap() {
+            Logger.verbose("---- targetContentOffsetForScrollContinuityMap: \(contentOffset)")
             return contentOffset
         }
 
         if scrollContinuity == .bottom,
-           let contentOffset = contentOffsetForBottom() {
+           let contentOffset = targetContentOffsetForBottom() {
             Logger.verbose("---- forLastKnownDistanceFromBottom: \(contentOffset)")
             return contentOffset
         }
@@ -530,7 +535,7 @@ extension ConversationViewController {
         return proposedContentOffset
     }
 
-    private func contentOffsetForBottom() -> CGPoint? {
+    private func targetContentOffsetForBottom() -> CGPoint? {
         guard let lastKnownDistanceFromBottom = self.lastKnownDistanceFromBottom else {
             return nil
         }
@@ -607,7 +612,7 @@ extension ConversationViewController {
 
     // We use this hook to ensure scroll state continuity.  As the collection
     // view's content size changes, we want to keep the same cells in view.
-    private func contentOffsetForScrollContinuityMap() -> CGPoint? {
+    private func targetContentOffsetForScrollContinuityMap() -> CGPoint? {
         guard let scrollContinuityMap = viewState.scrollContinuityMap else {
             return nil
         }
@@ -652,10 +657,27 @@ extension ConversationViewController {
         return nil
     }
 
-    private func contentOffsetForSizeTransition() -> CGPoint? {
+    private func targetContentOffsetForSizeTransition() -> CGPoint? {
         guard let scrollAction = viewState.scrollActionForSizeTransition else {
             return nil
         }
+        owsAssertDebug(!scrollAction.isAnimated)
+        return targetContentOffsetForScrollAction(scrollAction)
+    }
+
+    private func targetContentOffsetForUpdate() -> CGPoint? {
+        guard let scrollAction = viewState.scrollActionForUpdate else {
+            return nil
+        }
+        guard scrollAction.action != .none, !scrollAction.isAnimated else {
+            return nil
+        }
+        return targetContentOffsetForScrollAction(scrollAction)
+    }
+
+    private func targetContentOffsetForScrollAction(_ scrollAction: CVScrollAction) -> CGPoint? {
+        owsAssertDebug(!scrollAction.isAnimated)
+
         layout.prepare()
 
         switch scrollAction.action {
@@ -705,7 +727,7 @@ extension ConversationViewController {
         }
     }
 
-    private var contentOffsetForMessageActionInteraction: CGPoint? {
+    private var targetContentOffsetForMessageActionInteraction: CGPoint? {
         guard isPresentingMessageActions,
               let messageActionsViewController = messageActionsViewController else {
             owsFailDebug("Not presenting message actions.")
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 1b11b5b860c..6186da28591 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -1830,7 +1830,7 @@ - (BOOL)shouldDismissMessageActions
     return [self indexPathForInteractionUniqueId:messageActionInteractionId] == nil;
 }
 
-- (nullable NSValue *)contentOffsetForMessageActionInteraction
+- (nullable NSValue *)targetContentOffsetForMessageActionInteraction
 {
     OWSAssertDebug(self.messageActionsViewController);
 
