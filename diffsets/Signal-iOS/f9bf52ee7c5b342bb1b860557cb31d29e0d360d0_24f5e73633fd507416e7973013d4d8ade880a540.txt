diff --git a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
index 832add62da0..12481009532 100644
--- a/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/ContentValidation/AttachmentContentValidatorImpl.swift
@@ -253,7 +253,10 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
             }
             let truncatedBody = MessageBody(text: truncatedText, ranges: messageBody.ranges)
             truncatedBodies[key] = truncatedBody
-            let inputType = InputType.inMemory(Data(messageBody.text.utf8))
+            // Trim to the max length for oversize text.
+            // TODO: throw a user-visible error if we pass this threshold; for now silently truncate.
+            let oversizedTextData = Data(messageBody.text.trimToUtf8ByteCount(OWSMediaUtils.kMaxOversizeTextMessageSendSizeBytes).utf8)
+            let inputType = InputType.inMemory(oversizedTextData)
             let primaryFilePlaintextHash = try computePlaintextHash(inputType: inputType)
             let encryptionKey = encryptionKeyToUse(
                 primaryFilePlaintextHash: primaryFilePlaintextHash,
@@ -394,6 +397,17 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
             self.renderingFlag = renderingFlag
             self.sourceFilename = sourceFilename
         }
+
+        var byteSize: Int {
+            switch type {
+            case .inMemory(let data):
+                return data.count
+            case .unencryptedFile(let fileUrl):
+                return OWSFileSystem.fileSize(of: fileUrl)?.intValue ?? 0
+            case .encryptedFile(_, _, let plaintextLength, _):
+                return Int(plaintextLength)
+            }
+        }
     }
 
     private func validateContents<Key: Hashable>(
@@ -506,6 +520,12 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
             blurHash = nil
             audioWaveformFile = nil
             videoStillFrameFile = nil
+            if
+                input.mimeType == MimeType.textXSignalPlain.rawValue,
+                input.byteSize > OWSMediaUtils.kMaxOversizeTextMessageReceiveSizeBytes
+            {
+                throw OWSAssertionError("Oversize text attachment too big!")
+            }
         case .image, .animatedImage:
             var mimeType = input.mimeType
             (contentType, blurHash) = try validateImageContentType(input, mimeType: &mimeType)
@@ -624,17 +644,7 @@ public class AttachmentContentValidatorImpl: AttachmentContentValidator {
     private func validateVideoContentType(
         _ input: Input
     ) throws -> (Attachment.ContentType, stillFrame: PendingFile?, blurHash: String?) {
-        let byteSize: Int = {
-            switch input.type {
-            case .inMemory(let data):
-                return data.count
-            case .unencryptedFile(let fileUrl):
-                return OWSFileSystem.fileSize(of: fileUrl)?.intValue ?? 0
-            case .encryptedFile(_, _, let plaintextLength, _):
-                return Int(plaintextLength)
-            }
-        }()
-        guard byteSize < SignalAttachment.kMaxFileSizeVideo else {
+        guard input.byteSize < SignalAttachment.kMaxFileSizeVideo else {
             throw OWSAssertionError("Video too big!")
         }
 
