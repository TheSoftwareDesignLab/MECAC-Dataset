diff --git a/Signal/ConversationView/ConversationViewController+Misc.swift b/Signal/ConversationView/ConversationViewController+Misc.swift
index 8819120bf18..e71725a56ce 100644
--- a/Signal/ConversationView/ConversationViewController+Misc.swift
+++ b/Signal/ConversationView/ConversationViewController+Misc.swift
@@ -291,26 +291,11 @@ extension ConversationViewController: ConversationSettingsViewDelegate {
         self.uiMode = .search
 
         self.popAllConversationSettingsViews {
-            // This delay is unfortunate, but without it, self.searchController.uiSearchController.searchBar
-            // isn't yet ready to become first responder. Presumably we're still mid transition.
-            // A hardcorded constant like this isn't great because it's either too slow, making our users
-            // wait, or too fast, and fails to wait long enough to be ready to become first responder.
-            // Luckily in this case the stakes aren't catastrophic. In the case that we're too aggressive
-            // the user will just have to manually tap into the search field before typing.
-
-            // Leaving this assert in as proof that we're not ready to become first responder yet.
-            // If this assert fails, *great* maybe we can get rid of this delay.
-            owsAssertDebug(!self.searchController.uiSearchController.searchBar.canBecomeFirstResponder)
-
-            // We wait N seconds for it to become ready.
-            let initialDelay: TimeInterval = 0.4
-            DispatchQueue.main.asyncAfter(deadline: .now() + initialDelay) { [weak self] in
-                self?.tryToBecomeFirstResponderForSearch(cumulativeDelay: initialDelay)
-            }
+            self.searchController.uiSearchController.searchBar.becomeFirstResponder()
         }
     }
 
-    private func popAllConversationSettingsViews(completion: (() -> Void)?) {
+    private func popAllConversationSettingsViews(completion: @escaping () -> Void) {
         AssertIsOnMainThread()
 
         guard let presentedViewController = presentedViewController else {
@@ -321,29 +306,6 @@ extension ConversationViewController: ConversationSettingsViewDelegate {
             self.navigationController?.popToViewController(self, animated: true, completion: completion)
         }
     }
-
-    // MARK: - Conversation Search
-
-    private func tryToBecomeFirstResponderForSearch(cumulativeDelay: TimeInterval) {
-        // If this took more than N seconds, assume we're not going
-        // to be able to present search and bail.
-        if cumulativeDelay >= 1.5 {
-            owsFailDebug("Giving up presenting search after excessive retry attempts.")
-            self.uiMode = .normal
-            return
-        }
-
-        // Sometimes it takes longer, so we'll keep retrying..
-        if !searchController.uiSearchController.searchBar.canBecomeFirstResponder {
-            let additionalDelay: TimeInterval = 0.05
-            DispatchQueue.main.asyncAfter(deadline: .now() + additionalDelay) { [weak self] in
-                self?.tryToBecomeFirstResponderForSearch(cumulativeDelay: cumulativeDelay + additionalDelay)
-            }
-            return
-        }
-
-        searchController.uiSearchController.searchBar.becomeFirstResponder()
-    }
 }
 
 // MARK: - Preview / 3D Touch / UIContextMenu Methods
diff --git a/Signal/Registration/UserInterface/RegistrationNavigationController.swift b/Signal/Registration/UserInterface/RegistrationNavigationController.swift
index f1720cb8804..cd6ca0b8f32 100644
--- a/Signal/Registration/UserInterface/RegistrationNavigationController.swift
+++ b/Signal/Registration/UserInterface/RegistrationNavigationController.swift
@@ -133,7 +133,7 @@ public class RegistrationNavigationController: OWSNavigationController {
             }
 
             Logger.info("Pushing controller for \(step.logSafeString)")
-            self.pushViewController(vc, animated: true, completion: nil)
+            self.pushViewController(vc, animated: true)
         }
     }
 
@@ -510,7 +510,7 @@ extension RegistrationNavigationController: RegistrationSplashPresenter {
     public func switchToDeviceLinkingMode() {
         Logger.info("Pushing device linking")
         let controller = RegistrationConfirmModeSwitchViewController(presenter: self)
-        pushViewController(controller, animated: true, completion: nil)
+        pushViewController(controller, animated: true)
     }
 }
 
@@ -636,7 +636,7 @@ extension RegistrationNavigationController: RegistrationTransferChoicePresenter
             // back (direct calls to push and pop) and, when they complete, they will have _totally_
             // overwritten our local database, thus wiping any in progress reg coordinator state
             // and putting us into the chat list.
-            pushViewController(RegistrationTransferQRCodeViewController(url: url), animated: true, completion: nil)
+            pushViewController(RegistrationTransferQRCodeViewController(url: url), animated: true)
         } catch {
             // TODO: [Backups] - update this error handling
             Logger.error("Error transferring")
diff --git a/SignalUI/SafetyNumbers/FingerprintScanViewController.swift b/SignalUI/SafetyNumbers/FingerprintScanViewController.swift
index 92f75338924..609e1d99d47 100644
--- a/SignalUI/SafetyNumbers/FingerprintScanViewController.swift
+++ b/SignalUI/SafetyNumbers/FingerprintScanViewController.swift
@@ -164,7 +164,7 @@ class FingerprintScanViewController: OWSViewController, OWSNavigationChildContro
                     )
                 }
                 if let navigationController = viewController.navigationController {
-                    navigationController.popViewController(animated: true, completion: nil)
+                    navigationController.popViewController(animated: true)
                 } else {
                     viewController.dismiss(animated: true)
                 }
@@ -175,7 +175,7 @@ class FingerprintScanViewController: OWSViewController, OWSNavigationChildContro
             style: .cancel,
             handler: { _ in
                 if let navigationController = viewController.navigationController {
-                    navigationController.popViewController(animated: true, completion: nil)
+                    navigationController.popViewController(animated: true)
                 } else {
                     viewController.dismiss(animated: true)
                 }
diff --git a/SignalUI/UIKitExtensions/UIViewController+SignalUI.swift b/SignalUI/UIKitExtensions/UIViewController+SignalUI.swift
index 3a5be2e097d..5f227ec6bb4 100644
--- a/SignalUI/UIKitExtensions/UIViewController+SignalUI.swift
+++ b/SignalUI/UIKitExtensions/UIViewController+SignalUI.swift
@@ -4,6 +4,7 @@
 //
 
 import UIKit
+import SignalServiceKit
 
 public extension UIViewController {
 
@@ -79,30 +80,40 @@ public extension UIViewController {
 
 public extension UINavigationController {
 
-    func pushViewController(_ viewController: UIViewController,
-                            animated: Bool,
-                            completion: (() -> Void)?) {
-        CATransaction.begin()
-        CATransaction.setCompletionBlock(completion)
+    func pushViewController(
+        _ viewController: UIViewController,
+        animated: Bool,
+        completion: @escaping () -> Void
+    ) {
         pushViewController(viewController, animated: animated)
-        CATransaction.commit()
+        addCompletion(completion)
     }
 
-    func popViewController(animated: Bool,
-                           completion: (() -> Void)?) {
-        CATransaction.begin()
-        CATransaction.setCompletionBlock(completion)
+    func popViewController(
+        animated: Bool,
+        completion: @escaping () -> Void
+    ) {
         popViewController(animated: animated)
-        CATransaction.commit()
+        addCompletion(completion)
     }
 
-    func popToViewController(_ viewController: UIViewController,
-                             animated: Bool,
-                             completion: (() -> Void)?) {
-        CATransaction.begin()
-        CATransaction.setCompletionBlock(completion)
+    func popToViewController(
+        _ viewController: UIViewController,
+        animated: Bool,
+        completion: @escaping () -> Void
+    ) {
         self.popToViewController(viewController, animated: animated)
-        CATransaction.commit()
+        addCompletion(completion)
+    }
+
+    private func addCompletion(_ completion: @escaping () -> Void) {
+        guard let transitionCoordinator else {
+            owsFailBeta("Missing transitionCoordinator")
+            return completion()
+        }
+        transitionCoordinator.animate(alongsideTransition: nil) { _ in
+            completion()
+        }
     }
 }
 
