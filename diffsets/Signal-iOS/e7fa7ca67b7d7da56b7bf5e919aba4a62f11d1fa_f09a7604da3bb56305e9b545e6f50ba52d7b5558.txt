diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift
index 81cfe897143..e9d1f68f7d1 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
@@ -1,47 +1,49 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
 
 public class ContextMenuActionsAccessory: ContextMenuTargetedPreviewAccessory, ContextMenuActionsViewDelegate {
-    
+
     public let menu: ContextMenu
-    
+
     private let menuView: ContextMenuActionsView
-    
+
     public init(
         menu: ContextMenu,
         accessoryAlignment: AccessoryAlignment
     ) {
         self.menu = menu
-        
+
         menuView = ContextMenuActionsView(menu: menu)
         super.init(accessoryView: menuView, accessoryAlignment: accessoryAlignment)
         menuView.delegate = self
     }
+
+    override func touchLocationInViewDidChange(locationInView: CGPoint) {
+        menuView.handleGestureChanged(locationInView: locationInView)
+    }
+
+    override func touchLocationInViewDidEnd(locationInView: CGPoint) {
+        menuView.handleGestureEnded(locationInView: locationInView)
+    }
+
 }
 
 protocol ContextMenuActionsViewDelegate: AnyObject {
-    
+
 }
 
 public class ContextMenuActionsView: UIView {
-    weak var delegate: ContextMenuActionsViewDelegate?
-    public let menu: ContextMenu
-    
-    private let actionViews: [ContextMenuActionRow]
-    private let backdropView: UIVisualEffectView
-    
-    let cornerRadius: CGFloat = 12
-    
+
     private class ContextMenuActionRow: UIView {
         let attributes: ContextMenuAction.Attributes
         let hostEffect: UIBlurEffect
         let titleLabel: UILabel
         let iconView: UIImageView
         let seperatorView: UIVisualEffectView
-        var highlightedView: UIView? = nil
+        var highlightedView: UIView?
         var isHighlighted: Bool {
             didSet {
                 if oldValue != isHighlighted {
@@ -56,7 +58,7 @@ public class ContextMenuActionsView: UIView {
                             vibrancyView.contentView.addSubview(view)
                             highlightedView = vibrancyView
                         }
-                        
+
                         if let view = highlightedView {
                             addSubview(view)
                         }
@@ -71,7 +73,7 @@ public class ContextMenuActionsView: UIView {
         let margin: CGFloat = 16
         let verticalPadding: CGFloat = 20
         let iconSize: CGFloat = 18
-        
+
         public init(
             title: String,
             icon: UIImage?,
@@ -81,10 +83,10 @@ public class ContextMenuActionsView: UIView {
             titleLabel = UILabel(frame: CGRect.zero)
             titleLabel.text = title
             titleLabel.font = UIFont.ows_dynamicTypeTitle3
-            
+
             self.attributes = attributes
             hostEffect = hostBlurEffect
-            
+
             if attributes.contains(.destructive) {
                 titleLabel.textColor = Theme.ActionSheet.default.destructiveButtonTextColor
             } else if attributes.contains(.disabled) {
@@ -92,42 +94,40 @@ public class ContextMenuActionsView: UIView {
             } else {
                 titleLabel.textColor = Theme.primaryTextColor
             }
-            
+
             iconView = UIImageView(image: icon)
             iconView.contentMode = .scaleAspectFit
             iconView.tintColor = titleLabel.textColor
-            
+
             seperatorView = UIVisualEffectView(effect: UIVibrancyEffect(blurEffect: hostBlurEffect))
             let seperator = UIView(frame: seperatorView.bounds)
             seperator.backgroundColor = Theme.cellSeparatorColor
             seperator.autoresizingMask = [.flexibleWidth, .flexibleHeight]
             seperatorView.contentView.addSubview(seperator)
             isHighlighted = false
-            
-            super.init(frame:CGRect.zero)
-            
+
+            super.init(frame: CGRect.zero)
+
             addSubview(titleLabel)
             addSubview(iconView)
             addSubview(seperatorView)
         }
-        
+
         required init(coder: NSCoder) {
             fatalError("init(coder:) has not been implemented")
         }
-        
+
         public override func layoutSubviews() {
             super.layoutSubviews()
-            
-            isHighlighted = attributes.contains(.highlighted)
-            
+
             let isRTL = CurrentAppContext().isRTL
             titleLabel.sizeToFit()
             var titleFrame = titleLabel.frame
             var iconViewFrame = CGRect(x: 0, y: 0, width: iconSize, height: iconSize)
-            
+
             titleFrame.y = ceil((bounds.height - titleFrame.height) / 2)
             iconViewFrame.height = bounds.height
-            
+
             if !isRTL {
                 titleFrame.x = margin
                 titleFrame.width = bounds.width - iconViewFrame.width - 3*margin
@@ -137,16 +137,16 @@ public class ContextMenuActionsView: UIView {
                 titleFrame.x = iconViewFrame.maxX + margin
                 titleFrame.width = bounds.width - iconViewFrame.width  - 3*margin
             }
-            
+
             titleLabel.frame = titleFrame
             iconView.frame = iconViewFrame
-            
+
             var seperatorFrame = bounds
             seperatorFrame.height = 1.0 / UIScreen.main.scale
             seperatorFrame.y = bounds.maxY - seperatorFrame.height
             seperatorView.frame = seperatorFrame
         }
-        
+
         public override func sizeThatFits(
             _ size: CGSize
         ) -> CGSize {
@@ -154,44 +154,59 @@ public class ContextMenuActionsView: UIView {
             return CGSize(width: maxWidth, height: height)
         }
     }
-    
+
+    weak var delegate: ContextMenuActionsViewDelegate?
+    public let menu: ContextMenu
+
+    private let actionViews: [ContextMenuActionRow]
+    private let backdropView: UIVisualEffectView
+
+    private var tapGestureRecognizer: UILongPressGestureRecognizer?
+
+    let cornerRadius: CGFloat = 12
+
     public init(
         menu: ContextMenu
     ) {
         self.menu = menu
-        
+
         let effect = UIBlurEffect(style: UIBlurEffect.Style.prominent)
         backdropView = UIVisualEffectView(effect: effect)
-        
+
         var actionViews: [ContextMenuActionRow] = []
         for action in menu.children {
             let actionView = ContextMenuActionRow(title: action.title, icon: action.image, attributes: action.attributes, hostBlurEffect: effect)
             actionViews.append(actionView)
         }
         self.actionViews = actionViews
-        
+
         super.init(frame: CGRect.zero)
 
+        let tapGestureRecognizer = UILongPressGestureRecognizer(target: self, action: #selector(tapGestureRecognized(sender:)))
+        tapGestureRecognizer.minimumPressDuration = 0
+        addGestureRecognizer(tapGestureRecognizer)
+        self.tapGestureRecognizer = tapGestureRecognizer
+
         layer.cornerRadius = cornerRadius
         layer.masksToBounds = true
         addSubview(backdropView)
-        
+
         for actionView in actionViews {
             backdropView.contentView.addSubview(actionView)
         }
-        
+
         actionViews.last?.seperatorView.isHidden = true
     }
-    
+
     required init?(coder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
-    
-    //MARK: UIView
-    
+
+    // MARK: UIView
+
     public override func layoutSubviews() {
         super.layoutSubviews()
-        
+
         backdropView.frame = bounds
         var yOffset: CGFloat = 0
         let actionViewSize = actionViewSizeThatFits(bounds.size)
@@ -200,18 +215,59 @@ public class ContextMenuActionsView: UIView {
             yOffset += actionViewSize.height
         }
     }
-    
+
     public override func sizeThatFits(
         _ size: CGSize
     ) -> CGSize {
         let actionViewSize = actionViewSizeThatFits(size)
         return CGSize(width: actionViewSize.width, height: actionViewSize.height * CGFloat(actionViews.count))
     }
-    
+
     private func actionViewSizeThatFits(
         _ size: CGSize)
     -> CGSize {
         return actionViews.first?.sizeThatFits(size) ?? CGSize.zero
     }
-    
+
+    // MARK: Gestures
+    @objc
+    func tapGestureRecognized(sender: UIGestureRecognizer) {
+        if sender.state == .began || sender.state == .changed {
+            handleGestureChanged(locationInView: sender.location(in: self))
+        } else if sender.state == .ended {
+            handleGestureEnded(locationInView: sender.location(in: self))
+        }
+    }
+
+    func handleGestureChanged(locationInView: CGPoint) {
+        // Add impact effect here
+        var highlightStateChanged = false
+        var rowWasPreviouslyHighlighted = false
+        for actionRow in actionViews {
+            let wasHighlighted = actionRow.isHighlighted
+            if !rowWasPreviouslyHighlighted {
+                rowWasPreviouslyHighlighted = wasHighlighted
+            }
+
+            let shouldHighlight = actionRow.frame.contains(locationInView) && !actionRow.attributes.contains(.disabled)
+            actionRow.isHighlighted = shouldHighlight
+
+            if !highlightStateChanged {
+                highlightStateChanged = wasHighlighted != shouldHighlight
+            }
+        }
+
+        if highlightStateChanged && rowWasPreviouslyHighlighted {
+            ImpactHapticFeedback.impactOccured(style: .light)
+        }
+    }
+
+    func handleGestureEnded(locationInView: CGPoint) {
+        for actionRow in actionViews {
+            actionRow.isHighlighted = false
+        }
+
+        // Fire action here
+    }
+
 }
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift
index e4883f6f2cf..af13ca07f9b 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift	
@@ -18,7 +18,6 @@ public class ContextMenuAction {
 
         public static let disabled = ContextMenuAction.Attributes(rawValue: 1 << 0)
         public static let destructive = ContextMenuAction.Attributes(rawValue: 1 << 1)
-        public static let highlighted = ContextMenuAction.Attributes(rawValue: 1 << 2)
     }
 
     public let title: String
@@ -108,6 +107,17 @@ public class ContextMenuTargetedPreviewAccessory {
     ) {
         completion()
     }
+
+    /// Called when a current touch event changed location
+    /// - Parameter locationInView: location relative to accessoryView's coordinate space
+    func touchLocationInViewDidChange(locationInView: CGPoint) {
+
+    }
+    /// Called when a current touch event ended
+    /// - Parameter locationInView: location relative to accessoryView's coordinate space
+    func touchLocationInViewDidEnd(locationInView: CGPoint) {
+
+    }
 }
 
 // UITargetedPreview analog
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift
index bd75480e308..4e2c4ca6d89 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift	
@@ -110,12 +110,15 @@ class ContextMenuHostView: UIView {
     }
 }
 
-class ContextMenuController: UIViewController, ContextMenuViewDelegate {
+class ContextMenuController: UIViewController, ContextMenuViewDelegate, UIGestureRecognizerDelegate {
     weak var delegate: ContextMenuControllerDelegate?
 
     let contextMenuPreview: ContextMenuTargetedPreview
     let contextMenuConfiguration: ContextMenuConfiguration
     let menuAccessory: ContextMenuActionsAccessory?
+
+    var gestureRecognizer: UIGestureRecognizer?
+
     var accessoryViews: [ContextMenuTargetedPreviewAccessory] {
         var accessories = contextMenuPreview.accessoryViews
         if let menuAccessory = self.menuAccessory {
@@ -134,10 +137,12 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
     init (
         configuration: ContextMenuConfiguration,
         preview: ContextMenuTargetedPreview,
+        initiatingGestureRecognizer: UIGestureRecognizer?,
         menuAccessory: ContextMenuActionsAccessory?
     ) {
         self.contextMenuConfiguration = configuration
         self.contextMenuPreview = preview
+        self.gestureRecognizer = initiatingGestureRecognizer
         self.menuAccessory = menuAccessory
 
         super.init(nibName: nil, bundle: nil)
@@ -159,7 +164,7 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
         contextMenuView.previewView = contextMenuPreview.snapshot
         contextMenuView.accessoryViews = accessoryViews
 
-        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGestureRecogznied(sender:)))
+        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGestureRecognized(sender:)))
         view.addGestureRecognizer(tapGesture)
     }
 
@@ -178,6 +183,34 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
 
     // MARK: Public
 
+    // MARK: Gesture Recognizer Support
+    public func gestureDidChange() {
+        if let locationInView = gestureRecognizer?.location(in: view) {
+            for accessory in accessoryViews {
+                let locationInAccessory = view .convert(locationInView, to: accessory.accessoryView)
+                accessory.touchLocationInViewDidChange(locationInView: locationInAccessory)
+            }
+        }
+
+    }
+
+    public func gestureDidEnd() {
+        if let locationInView = gestureRecognizer?.location(in: view) {
+            for accessory in accessoryViews {
+                let locationInAccessory = view .convert(locationInView, to: accessory.accessoryView)
+                accessory.touchLocationInViewDidEnd(locationInView: locationInAccessory)
+            }
+        }
+
+        if let gestureRecognizer = self.gestureRecognizer {
+            view.removeGestureRecognizer(gestureRecognizer)
+        }
+        let newPanGesture = UIPanGestureRecognizer(target: self, action: #selector(panGestureRecognized(sender:)))
+        view.addGestureRecognizer(newPanGesture)
+        gestureRecognizer = newPanGesture
+    }
+
+    // MARK: Emoji Sheet
     public func showEmojiSheet(completion: @escaping (String) -> Void) {
         let picker = EmojiPickerSheet { [weak self] emoji in
             guard let self = self else { return }
@@ -211,7 +244,17 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
     // MARK: Private
 
     @objc
-    private func tapGestureRecogznied(sender: UIGestureRecognizer) {
+    private func tapGestureRecognized(sender: UIGestureRecognizer) {
         delegate?.contextMenuControllerRequestsDismissal(self)
     }
+
+    @objc
+    private func panGestureRecognized(sender: UIGestureRecognizer) {
+        if sender.state == .began || sender.state == .changed {
+            gestureDidChange()
+        } else if sender.state == .ended {
+            gestureDidEnd()
+        }
+    }
+
 }
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift
index 035a3965a1d..48d65903740 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift	
@@ -5,20 +5,24 @@
 import Foundation
 
 /// UIContextMenuInteractionDelegate analog
-protocol ContextMenuInteractionDelegate: AnyObject {
+public protocol ContextMenuInteractionDelegate: AnyObject {
     func contextMenuInteraction(
         _ interaction: ContextMenuInteraction,
         configurationForMenuAtLocation location: CGPoint) -> ContextMenuConfiguration?
     func contextMenuInteraction(
         _ interaction: ContextMenuInteraction,
         previewForHighlightingMenuWithConfiguration configuration: ContextMenuConfiguration) -> ContextMenuTargetedPreview?
+    func contextMenuInteraction(_ interaction: ContextMenuInteraction,
+                                willEndForConfiguration: ContextMenuConfiguration)
+
 }
 
 /// UIContextMenuInteraction analog
-class ContextMenuInteraction: NSObject, UIInteraction {
+public class ContextMenuInteraction: NSObject, UIInteraction {
 
     weak var delegate: ContextMenuInteractionDelegate?
-    private var contextMenuController: ContextMenuController?
+    fileprivate var contextMenuController: ContextMenuController?
+    var configuration: ContextMenuConfiguration?
 
     private var longPressGestureRecognizer: UIGestureRecognizer = {
         let recognizer = UILongPressGestureRecognizer(target: self, action: #selector(longPressRecognized(sender:)))
@@ -29,13 +33,13 @@ class ContextMenuInteraction: NSObject, UIInteraction {
     // MARK: UIInteraction
     public var view: UIView?
 
-    func willMove(to view: UIView?) {
+    public func willMove(to view: UIView?) {
         if view != self.view {
             self.view?.removeGestureRecognizer(longPressGestureRecognizer)
         }
     }
 
-    func didMove(to view: UIView?) {
+    public func didMove(to view: UIView?) {
         if view != self.view {
             self.view = view
             self.view?.addGestureRecognizer(longPressGestureRecognizer)
@@ -61,27 +65,40 @@ class ContextMenuInteraction: NSObject, UIInteraction {
             return
         }
 
+        guard let window = view.window else {
+            owsFailDebug("View must be in a window!")
+            return
+        }
+
         guard let contextMenuConfiguration = delegate.contextMenuInteraction(self, configurationForMenuAtLocation: locationInView) else {
             owsFailDebug("Failed to get context menu configuration from delegate")
             return
         }
 
+        configuration = contextMenuConfiguration
+
         let targetedPreview = delegate.contextMenuInteraction(self, previewForHighlightingMenuWithConfiguration: contextMenuConfiguration) ?? ContextMenuTargetedPreview(view: view, accessoryViews: nil)
 
         for accessory in targetedPreview.accessoryViews {
             accessory.delegate = self
         }
 
-        presentMenu(locationInView: locationInView, contextMenuConfiguration: contextMenuConfiguration, targetedPreview: targetedPreview)
+        presentMenu(window: window, contextMenuConfiguration: contextMenuConfiguration, targetedPreview: targetedPreview)
     }
 
-    public func presentMenu(locationInView: CGPoint, contextMenuConfiguration: ContextMenuConfiguration, targetedPreview: ContextMenuTargetedPreview) {
+    public func presentMenu(window: UIWindow, contextMenuConfiguration: ContextMenuConfiguration, targetedPreview: ContextMenuTargetedPreview) {
         let menuAccessory = menuAccessory(configuration: contextMenuConfiguration)
-        let contextMenuController = ContextMenuController(configuration: contextMenuConfiguration, preview: targetedPreview, menuAccessory: menuAccessory)
+        let contextMenuController = ContextMenuController(configuration: contextMenuConfiguration, preview: targetedPreview, initiatingGestureRecognizer: initiatingGestureRecognizer(), menuAccessory: menuAccessory)
         contextMenuController.delegate = self
         self.contextMenuController = contextMenuController
-        ImpactHapticFeedback.impactOccured(style: .light)
-        OWSWindowManager.shared.presentContextMenu(contextMenuController)
+        ImpactHapticFeedback.impactOccured(style: .medium)
+
+        window.addSubview(contextMenuController.view)
+        contextMenuController.view.frame = window.bounds
+    }
+
+    public func initiatingGestureRecognizer() -> UIGestureRecognizer? {
+        return longPressGestureRecognizer
     }
 
     public func menuAccessory(configuration: ContextMenuConfiguration) -> ContextMenuActionsAccessory {
@@ -91,7 +108,11 @@ class ContextMenuInteraction: NSObject, UIInteraction {
     }
 
     public func dismissMenu() {
-        OWSWindowManager.shared.dismissContextMenu()
+        if let configuarion = self.configuration {
+            delegate?.contextMenuInteraction(self, willEndForConfiguration: configuarion)
+        }
+
+        contextMenuController?.view.removeFromSuperview()
         contextMenuController = nil
     }
 
@@ -128,11 +149,12 @@ extension ContextMenuInteraction: ContextMenuControllerDelegate, ContextMenuTarg
 }
 
 // Custom subclass for chat history CVC interactions
-class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
+public class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
 
     public let itemViewModel: CVItemViewModelImpl
     public let thread: TSThread
     public let messageActions: [MessageAction]
+    public let chatHistoryLongPressGesture: UIGestureRecognizer?
 
     /// Default initializer
     /// - Parameters:
@@ -143,11 +165,13 @@ class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
         delegate: ContextMenuInteractionDelegate,
         itemViewModel: CVItemViewModelImpl,
         thread: TSThread,
-        messageActions: [MessageAction]
+        messageActions: [MessageAction],
+        initiatingGestureRecognizer: UIGestureRecognizer?
     ) {
         self.itemViewModel = itemViewModel
         self.thread = thread
         self.messageActions = messageActions
+        self.chatHistoryLongPressGesture = initiatingGestureRecognizer
         super.init(delegate: delegate)
     }
 
@@ -157,6 +181,19 @@ class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
         self.view = view
     }
 
+    public func initiatingGestureRecognizerDidChange() {
+        contextMenuController?.gestureDidChange()
+    }
+
+    public func initiatingGestureRecognizerDidEnd() {
+        contextMenuController?.gestureDidEnd()
+
+    }
+
+    public override func initiatingGestureRecognizer() -> UIGestureRecognizer? {
+        return chatHistoryLongPressGesture
+    }
+
     public override func menuAccessory(configuration: ContextMenuConfiguration) -> ContextMenuActionsAccessory {
         let menu = configuration.actionProvider?([]) ?? ContextMenu([])
         let isIncomingMessage = itemViewModel.interaction.interactionType() == .incomingMessage
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift
index a5358b3db74..3a97e1eb485 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift	
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -7,17 +7,21 @@ import Foundation
 public class ContextMenuRectionBarAccessory: ContextMenuTargetedPreviewAccessory, MessageReactionPickerDelegate {
     public let thread: TSThread
     public let itemViewModel: CVItemViewModelImpl?
-    public var didSelectReactionHandler: ((TSMessage, String, Bool)->Void)? // = {(message: TSMessage, reaction: String, isRemoving: Bool) -> Void in }
-    
+    public var didSelectReactionHandler: ((TSMessage, String, Bool) -> Void)? // = {(message: TSMessage, reaction: String, isRemoving: Bool) -> Void in }
+
     private var reactionPicker: MessageReactionPicker
-    
+
+    private var gestureExitedDeadZone: Bool = false
+    private let deadZoneRadius: CGFloat = 30
+    private var initialTouchLocation: CGPoint?
+
     public init(
         thread: TSThread,
         itemViewModel: CVItemViewModelImpl?
     ) {
         self.thread = thread
         self.itemViewModel = itemViewModel
-        
+
         reactionPicker = MessageReactionPicker(selectedEmoji: itemViewModel?.reactionState?.localUserEmoji, delegate: nil)
         let isIncomingMessage = itemViewModel?.interaction.interactionType() == .incomingMessage
         let alignmnetOffset = isIncomingMessage && thread.isGroupThread ? -22 : 0
@@ -25,7 +29,7 @@ public class ContextMenuRectionBarAccessory: ContextMenuTargetedPreviewAccessory
         super.init(accessoryView: reactionPicker, accessoryAlignment: alignment)
         reactionPicker.delegate = self
     }
-    
+
     override func animateIn(
         duration: TimeInterval,
         completion: @escaping () -> Void
@@ -33,15 +37,48 @@ public class ContextMenuRectionBarAccessory: ContextMenuTargetedPreviewAccessory
         reactionPicker.playPresentationAnimation(duration: duration)
         completion()
     }
-    
+
     override func animateOut(
         duration: TimeInterval,
         completion: @escaping () -> Void
     ) {
         reactionPicker.playDismissalAnimation(duration: duration, completion: completion)
     }
-    
-    //MARK: MessageReactionPickerDelegate
+
+    override func touchLocationInViewDidChange(locationInView: CGPoint) {
+        if !gestureExitedDeadZone {
+            guard let initialTouchLocation = self.initialTouchLocation else {
+                self.initialTouchLocation = locationInView
+                return
+            }
+
+            let distanceFromInitialLocation = abs(hypot(
+                locationInView.x - initialTouchLocation.x,
+                locationInView.y - initialTouchLocation.y
+            ))
+            gestureExitedDeadZone = distanceFromInitialLocation >= deadZoneRadius
+
+            if !gestureExitedDeadZone { return }
+        }
+
+        reactionPicker.updateFocusPosition(locationInView, animated: true)
+    }
+
+    override func touchLocationInViewDidEnd(locationInView: CGPoint) {
+        if !gestureExitedDeadZone { return }
+
+        // Send focused emoji if needed
+        if let focusedEmoji = reactionPicker.focusedEmoji {
+            if focusedEmoji == MessageReactionPicker.anyEmojiName {
+                didSelectAnyEmoji()
+            } else {
+                let isRemoving = focusedEmoji == self.itemViewModel?.reactionState?.localUserEmoji
+                didSelectReaction(reaction: focusedEmoji, isRemoving: isRemoving )
+            }
+        }
+    }
+
+    // MARK: MessageReactionPickerDelegate
     func didSelectReaction(
         reaction: String,
         isRemoving: Bool
@@ -50,22 +87,22 @@ public class ContextMenuRectionBarAccessory: ContextMenuTargetedPreviewAccessory
             owsFailDebug("Not sending reaction for unexpected interaction type")
             return
         }
-        
+
         reactionPicker.playDismissalAnimation(duration: 0.2) {
             self.didSelectReactionHandler?(message, reaction, isRemoving)
             self.delegate?.contextMenuTargetedPreviewAccessoryRequestsDismissal(self)
 
         }
     }
-    
+
     func didSelectAnyEmoji() {
         guard let message = itemViewModel?.interaction as? TSMessage else {
             owsFailDebug("Not sending reaction for unexpected interaction type")
             return
         }
-        
+
         reactionPicker.playDismissalAnimation(duration: 0.2) { }
-        
+
         self.delegate?.contextMenuTargetedPreviewAccessoryRequestsEmojiPicker(self) { emojiString in
             let isRemoving = emojiString == self.itemViewModel?.reactionState?.localUserEmoji
             self.didSelectReactionHandler?(message, emojiString, isRemoving)
diff --git a/Signal/src/ViewControllers/ConversationView/CVViewState.swift b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
index 4a0a05f1b2c..53a5e38c090 100644
--- a/Signal/src/ViewControllers/ConversationView/CVViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
@@ -123,7 +123,7 @@ public class CVViewState: NSObject {
     public let collectionViewTapGestureRecognizer = UITapGestureRecognizer()
     public let collectionViewLongPressGestureRecognizer = UILongPressGestureRecognizer()
     public let collectionViewPanGestureRecognizer = UIPanGestureRecognizer()
-
+    public var collectionViewActiveContextMenuInteraction: ChatHistoryContextMenuInteraction?
     public var longPressHandler: CVLongPressHandler?
     public var panHandler: CVPanHandler?
 
@@ -290,6 +290,11 @@ public extension ConversationViewController {
         viewState.collectionViewPanGestureRecognizer
     }
 
+    var collectionViewActiveContextMenuInteraction: ChatHistoryContextMenuInteraction? {
+        get { viewState.collectionViewActiveContextMenuInteraction }
+        set { viewState.collectionViewActiveContextMenuInteraction = newValue }
+    }
+
     // MARK: - Message Actions
 
     var messageActionsViewController: MessageActionsViewController? {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVComponentDelegate.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVComponentDelegate.swift
index f104a3b9601..6d8ab8ebb88 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVComponentDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVComponentDelegate.swift
@@ -84,6 +84,8 @@ extension ConversationViewController: CVComponentDelegate {
     public func cvc_didChangeLongpress(_ itemViewModel: CVItemViewModelImpl) {
         AssertIsOnMainThread()
 
+        collectionViewActiveContextMenuInteraction?.initiatingGestureRecognizerDidChange()
+
         guard let messageActionsViewController = messageActionsViewController else {
             return
         }
@@ -98,6 +100,8 @@ extension ConversationViewController: CVComponentDelegate {
     public func cvc_didEndLongpress(_ itemViewModel: CVItemViewModelImpl) {
         AssertIsOnMainThread()
 
+        collectionViewActiveContextMenuInteraction?.initiatingGestureRecognizerDidEnd()
+
         guard let messageActionsViewController = messageActionsViewController else {
             return
         }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
index 17fd38d4140..cda8e737746 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
@@ -15,7 +15,8 @@ extension ConversationViewController {
             return
         }
         if FeatureFlags.contextMenus {
-            let interaction = ChatHistoryContextMenuInteraction(delegate: self, itemViewModel: itemViewModel, thread: thread, messageActions: messageActions)
+            let interaction = ChatHistoryContextMenuInteraction(delegate: self, itemViewModel: itemViewModel, thread: thread, messageActions: messageActions, initiatingGestureRecognizer: collectionViewLongPressGestureRecognizer)
+            collectionViewActiveContextMenuInteraction = interaction
             cell.addInteraction(interaction)
             let cellCenterPoint = cell.frame.center
             let screenPoint = self.collectionView .convert(cellCenterPoint, from: cell)
@@ -183,7 +184,7 @@ extension ConversationViewController {
 
 extension ConversationViewController: ContextMenuInteractionDelegate {
 
-    func contextMenuInteraction(
+    public func contextMenuInteraction(
         _ interaction: ContextMenuInteraction,
         configurationForMenuAtLocation location: CGPoint) -> ContextMenuConfiguration? {
 
@@ -196,8 +197,8 @@ extension ConversationViewController: ContextMenuInteractionDelegate {
                 Logger.debug("disabled state handler")
             })
 
-            let highlighted = ContextMenuAction.init(title: "Highlighted", image: Theme.iconImage(.messageActionDelete), attributes: [.highlighted], handler: { _ in
-                Logger.debug("highlighted state handler")
+            let highlighted = ContextMenuAction.init(title: "Default 2", image: Theme.iconImage(.messageActionForward), attributes: [], handler: { _ in
+                Logger.debug("default 2 state handler")
             })
 
             let destructive = ContextMenuAction.init(title: "Destructive", image: Theme.iconImage(.messageActionDelete), attributes: [.destructive], handler: { _ in
@@ -208,7 +209,7 @@ extension ConversationViewController: ContextMenuInteractionDelegate {
         })
     }
 
-    func contextMenuInteraction(
+    public func contextMenuInteraction(
         _ interaction: ContextMenuInteraction,
         previewForHighlightingMenuWithConfiguration configuration: ContextMenuConfiguration) -> ContextMenuTargetedPreview? {
 
@@ -251,4 +252,8 @@ extension ConversationViewController: ContextMenuInteractionDelegate {
         }
     }
 
+    public func contextMenuInteraction(_ interaction: ContextMenuInteraction, willEndForConfiguration: ContextMenuConfiguration) {
+        collectionViewActiveContextMenuInteraction = nil
+    }
+
 }
diff --git a/SignalMessaging/utils/OWSWindowManager.h b/SignalMessaging/utils/OWSWindowManager.h
index 94700388efb..1314ff38740 100644
--- a/SignalMessaging/utils/OWSWindowManager.h
+++ b/SignalMessaging/utils/OWSWindowManager.h
@@ -46,11 +46,6 @@ extern const UIWindowLevel UIWindowLevel_Background;
 - (void)returnToCallView;
 @property (nonatomic, readonly) BOOL hasCall;
 
-#pragma mark - Context Menu
-- (void)presentContextMenu:(UIViewController *)contextMenuController;
-- (void)dismissContextMenu;
-@property (nonatomic, readonly) BOOL shouldShowContextMenu;
-
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/SignalMessaging/utils/OWSWindowManager.m b/SignalMessaging/utils/OWSWindowManager.m
index 355d59f595e..6eb8a5fc73d 100644
--- a/SignalMessaging/utils/OWSWindowManager.m
+++ b/SignalMessaging/utils/OWSWindowManager.m
@@ -30,13 +30,6 @@ const UIWindowLevel UIWindowLevel_CallView(void)
     return UIWindowLevelNormal + 2.f;
 }
 
-// In front of the root window, behind the screen blocking window and call window.
-const UIWindowLevel UIWindowLevel_ContextMenuView(void);
-const UIWindowLevel UIWindowLevel_ContextMenuView(void)
-{
-    return UIWindowLevelNormal + 1.f;
-}
-
 // In front of the status bar and CallView
 const UIWindowLevel UIWindowLevel_ScreenBlocking(void);
 const UIWindowLevel UIWindowLevel_ScreenBlocking(void)
@@ -91,16 +84,11 @@ @interface OWSWindowManager ()
 @property (nonatomic) UIWindow *callViewWindow;
 @property (nonatomic) UINavigationController *callNavigationController;
 
-// UIWindowLevel_ContextMenu
-@property (nonatomic) UIWindow *contextMenuWindow;
-@property (nonatomic, nullable) UINavigationController *contextMenuNavigationController;
-
 // UIWindowLevel_Background if inactive,
 // UIWindowLevel_ScreenBlocking() if active.
 @property (nonatomic) UIWindow *screenBlockingWindow;
 
 @property (nonatomic) BOOL shouldShowCallView;
-@property (nonatomic) BOOL shouldShowContextMenu;
 
 @property (nonatomic, nullable) UIViewController<CallViewControllerWindowReference> *callViewController;
 
@@ -138,8 +126,6 @@ - (void)setupWithRootWindow:(UIWindow *)rootWindow screenBlockingWindow:(UIWindo
     self.returnToCallWindow = [self createReturnToCallWindow:rootWindow];
     self.callViewWindow = [self createCallViewWindow:rootWindow];
 
-    self.contextMenuWindow = [self createContextMenuWindow:rootWindow];
-
     [self ensureWindowState];
 }
 
@@ -191,29 +177,6 @@ - (UIWindow *)createCallViewWindow:(UIWindow *)rootWindow
     return window;
 }
 
-- (UIWindow *)createContextMenuWindow:(UIWindow *)rootWindow
-{
-    OWSAssertIsOnMainThread();
-    OWSAssertDebug(rootWindow);
-
-    UIWindow *window = [[OWSWindow alloc] initWithFrame:rootWindow.bounds];
-    window.hidden = YES;
-    window.windowLevel = UIWindowLevel_ContextMenuView();
-    window.opaque = YES;
-
-    UIViewController *viewController = [OWSWindowRootViewController new];
-
-    OWSWindowRootNavigationViewController *navigationController =
-        [[OWSWindowRootNavigationViewController alloc] initWithRootViewController:viewController];
-    navigationController.navigationBarHidden = YES;
-    OWSAssertDebug(!self.contextMenuNavigationController);
-    self.contextMenuNavigationController = navigationController;
-
-    window.rootViewController = navigationController;
-
-    return window;
-}
-
 - (void)setIsScreenBlockActive:(BOOL)isScreenBlockActive
 {
     OWSAssertIsOnMainThread();
@@ -232,7 +195,7 @@ - (BOOL)isAppWindow:(UIWindow *)window
     OWSAssertDebug(window);
 
     return (window == self.rootWindow || window == self.returnToCallWindow || window == self.callViewWindow
-        || window == self.contextMenuWindow || window == self.screenBlockingWindow);
+        || window == self.screenBlockingWindow);
 }
 
 - (void)updateWindowFrames
@@ -242,7 +205,6 @@ - (void)updateWindowFrames
     for (UIWindow *window in @[
              self.rootWindow,
              self.callViewWindow,
-             self.contextMenuWindow,
              self.screenBlockingWindow,
          ]) {
         if (!CGRectEqualToRect(window.frame, CurrentAppContext().frame)) {
@@ -251,30 +213,6 @@ - (void)updateWindowFrames
     }
 }
 
-#pragma mark - Context Menu
-
-- (void)presentContextMenu:(UIViewController *)contextMenuController
-{
-    OWSAssertIsOnMainThread();
-    OWSAssertDebug(contextMenuController);
-
-    // Attach contextMenuController to window.
-    [self.contextMenuNavigationController popToRootViewControllerAnimated:NO];
-    [self.contextMenuNavigationController pushViewController:contextMenuController animated:NO];
-    self.shouldShowContextMenu = YES;
-    [self ensureWindowState];
-}
-
-- (void)dismissContextMenu
-{
-    OWSAssertIsOnMainThread();
-
-    // Detach contextMenuController from window.
-    [self.contextMenuNavigationController popToRootViewControllerAnimated:NO];
-    self.shouldShowContextMenu = NO;
-    [self ensureWindowState];
-}
-
 #pragma mark - Calls
 
 - (void)setCallViewController:(nullable UIViewController<CallViewControllerWindowReference> *)callViewController
@@ -385,7 +323,6 @@ - (void)ensureWindowState
         [self ensureRootWindowHidden];
         [self ensureReturnToCallWindowHidden];
         [self ensureCallViewWindowHidden];
-        [self ensureContextMenuWindowHidden];
         [self ensureScreenBlockWindowShown];
     } else if (self.callViewController && self.shouldShowCallView) {
         // Show Call View.
@@ -393,7 +330,6 @@ - (void)ensureWindowState
         [self ensureRootWindowHidden];
         [self ensureCallViewWindowShown];
         [self ensureReturnToCallWindowHidden];
-        [self ensureContextMenuWindowHidden];
         [self ensureScreenBlockWindowHidden];
     } else {
         // Show Root Window
@@ -409,12 +345,6 @@ - (void)ensureWindowState
             [self ensureReturnToCallWindowHidden];
         }
 
-        if (self.shouldShowContextMenu) {
-            [self ensureContextMenuWindowShown];
-        } else {
-            [self ensureContextMenuWindowHidden];
-        }
-
         [self ensureCallViewWindowHidden];
     }
 }
@@ -495,28 +425,6 @@ - (void)ensureCallViewWindowHidden
     self.callViewWindow.hidden = YES;
 }
 
-- (void)ensureContextMenuWindowHidden
-{
-    OWSAssertIsOnMainThread();
-
-    if (!self.contextMenuWindow.hidden) {
-        OWSLogInfo(@"hiding context menu window.");
-    }
-
-    self.contextMenuWindow.hidden = YES;
-}
-
-- (void)ensureContextMenuWindowShown
-{
-    OWSAssertIsOnMainThread();
-
-    if (self.contextMenuWindow.hidden) {
-        OWSLogInfo(@"hiding context menu window.");
-    }
-
-    [self.contextMenuWindow makeKeyAndVisible];
-}
-
 - (void)ensureScreenBlockWindowShown
 {
     OWSAssertIsOnMainThread();
