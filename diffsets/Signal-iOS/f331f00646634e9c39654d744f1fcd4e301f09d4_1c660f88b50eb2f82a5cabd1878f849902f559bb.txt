diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift
index c3656a63aaa..74e2f41a28b 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -147,7 +147,7 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
                             vibrancyView.frame = bounds
                             let view = UIView(frame: bounds)
                             view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
-                            view.backgroundColor = Theme.cellSelectedColor
+                            view.backgroundColor = Theme.isDarkThemeEnabled ? .ows_gray80 : .ows_gray12
                             if Theme.isDarkThemeEnabled {
                                 vibrancyView.backgroundColor = UIColor.ows_whiteAlpha20
                             }
@@ -168,8 +168,8 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
 
         var maxWidth: CGFloat = 250
         let margin: CGFloat = 16
-        let verticalPadding: CGFloat = 20
-        let iconSize: CGFloat = 22
+        let verticalPadding: CGFloat = 22
+        let iconSize: CGFloat = 20
 
         public init(
             title: String,
@@ -180,6 +180,7 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
             titleLabel = UILabel(frame: CGRect.zero)
             titleLabel.text = title
             titleLabel.font = .ows_dynamicTypeBodyClamped
+            titleLabel.numberOfLines = 2
 
             self.attributes = attributes
             hostEffect = hostBlurEffect
@@ -202,7 +203,7 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
             }
 
             let seperator = UIView(frame: seperatorView.bounds)
-            seperator.backgroundColor = Theme.cellSeparatorColor
+            seperator.backgroundColor = Theme.isDarkThemeEnabled ? .ows_gray75 : .ows_gray22
             seperator.autoresizingMask = [.flexibleWidth, .flexibleHeight]
             seperatorView.contentView.addSubview(seperator)
             isHighlighted = false
@@ -231,7 +232,7 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
             var iconViewFrame = CGRect(x: 0, y: 0, width: iconSize, height: iconSize)
 
             titleFrame.y = ceil((bounds.height - titleFrame.height) / 2)
-            iconViewFrame.height = bounds.height
+            iconViewFrame.y = max(0, (bounds.height - iconView.height) / 2)
 
             if !isRTL {
                 titleFrame.x = margin
@@ -255,7 +256,7 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
         public override func sizeThatFits(
             _ size: CGSize
         ) -> CGSize {
-            let height = ceil(titleLabel.sizeThatFits(CGSize(width: 0, height: 0)).height) + verticalPadding
+            let height = ceil(titleLabel.sizeThatFits(CGSize(width: maxWidth - 3 * margin - iconSize, height: 0)).height) + verticalPadding
             return CGSize(width: maxWidth, height: height)
         }
     }
@@ -342,28 +343,31 @@ public class ContextMenuActionsView: UIView, UIGestureRecognizerDelegate, UIScro
         backdropView.frame = bounds
         scrollView.frame = bounds
         var yOffset: CGFloat = 0
-        let actionViewSize = actionViewSizeThatFits(bounds.size)
         var maxY: CGFloat = 0
+        var width: CGFloat = 0.0
         for actionView in actionViews {
-            actionView.frame = CGRect(x: 0, y: yOffset, width: actionViewSize.width, height: actionViewSize.height)
-            yOffset += actionViewSize.height
+            let size = actionView.sizeThatFits(.zero)
+            width = max(width, size.width)
+            actionView.frame = CGRect(x: 0, y: yOffset, width: width, height: size.height)
+            yOffset += size.height
             maxY = max(maxY, actionView.frame.maxY)
         }
 
-        scrollView.contentSize = CGSize(width: bounds.width, height: maxY)
+        scrollView.contentSize = CGSize(width: width, height: maxY)
     }
 
     public override func sizeThatFits(
         _ size: CGSize
     ) -> CGSize {
-        let actionViewSize = actionViewSizeThatFits(size)
-        return CGSize(width: actionViewSize.width, height: actionViewSize.height * CGFloat(actionViews.count))
-    }
-
-    private func actionViewSizeThatFits(
-        _ size: CGSize)
-    -> CGSize {
-        return actionViews.first?.sizeThatFits(size) ?? CGSize.zero
+        // every entry may have a different height
+        var height = 0.0
+        var width = 0.0
+        for actionView in actionViews {
+            let size = actionView.sizeThatFits(size)
+            height += size.height
+            width = max(width, size.width)
+        }
+        return CGSize(width: width, height: height)
     }
 
     // MARK: Gestures
diff --git a/Signal/src/ViewControllers/HomeView/HomeViewController+Multiselect.swift b/Signal/src/ViewControllers/HomeView/HomeViewController+Multiselect.swift
index 891232dc88f..55c73736a65 100644
--- a/Signal/src/ViewControllers/HomeView/HomeViewController+Multiselect.swift
+++ b/Signal/src/ViewControllers/HomeView/HomeViewController+Multiselect.swift
@@ -11,7 +11,7 @@ extension HomeViewController {
         AssertIsOnMainThread()
 
         if viewState.multiSelectState.parentButton == nil {
-            showMenu(button: sender, animated: true)
+            showMenu(from: sender, animated: true)
         } else {
             hideMenu()
         }
@@ -96,19 +96,22 @@ extension HomeViewController {
         if let btn = viewState.multiSelectState.parentButton, viewState.multiSelectState.contextMenuView != nil {
             // we have to create it again (changed colors, icons etc.)
             hideMenuAndExecuteWhenVanished(animated: false) {
-                self.showMenu(button: btn, animated: false)
+                self.showMenu(from: btn, animated: false)
             }
         }
     }
 
     // MARK: private helper
 
-    private func showMenu(button: UIButton?, animated: Bool) {
+    private func showMenu(from button: UIButton, animated: Bool) {
         AssertIsOnMainThread()
 
         guard viewState.multiSelectState.contextMenuView == nil else {
             return
         }
+        guard let window = button.window else {
+            return
+        }
 
         var contextMenuActions: [ContextMenuAction] = []
         if renderState.inboxCount > 0 {
@@ -154,16 +157,12 @@ extension HomeViewController {
         v.delegate = self
 
         viewState.multiSelectState.contextMenuView = ContextMenuActionsViewContainer(v)
-        view.addSubview(viewState.multiSelectState.contextMenuView!)
-        let completion = { [weak self] (_: Bool) in
-            self?.viewState.multiSelectState.contextMenuView!.addGestureRecognizer(TapToCloseGestureRecognizer(target: self))
-            self?.navigationController?.navigationBar.addGestureRecognizer(TapToCloseGestureRecognizer(target: self))
-        }
+        viewState.multiSelectState.contextMenuView?.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(hideMenu)))
+        window.addSubview(viewState.multiSelectState.contextMenuView!)
+        viewState.multiSelectState.contextMenuView!.frame = window.bounds
+
         if animated {
-            animateIn(menu: viewState.multiSelectState.contextMenuView!, from: button, completion: completion)
-        } else {
-            viewState.multiSelectState.contextMenuView?.autoPinEdgesToSuperviewSafeArea()
-            completion(true)
+            animateIn(menu: viewState.multiSelectState.contextMenuView?.menuContainer, from: button)
         }
     }
 
@@ -182,28 +181,25 @@ extension HomeViewController {
     private func hideMenuAndExecuteWhenVanished(animated: Bool = true, completion handler: (() -> Void)? = nil) {
         AssertIsOnMainThread()
 
-        if let navBar = navigationController?.navigationBar {
-            for recognizer in navBar.gestureRecognizers ?? [] {
-                if let tapper = recognizer as? TapToCloseGestureRecognizer {
-                    navBar.removeGestureRecognizer(tapper)
-                }
-            }
-        }
-
         let completion = { [weak self] (_: Bool) in
             self?.viewState.multiSelectState.contextMenuView?.removeFromSuperview()
+            self?.viewState.multiSelectState.parentButton?.alpha = 1
             self?.viewState.multiSelectState.parentButton = nil
             self?.viewState.multiSelectState.contextMenuView = nil
             handler?()
         }
         if animated {
-            animateOut(menu: viewState.multiSelectState.contextMenuView, from: viewState.multiSelectState.parentButton, completion: completion)
+            animateOut(menu: viewState.multiSelectState.contextMenuView?.menuContainer, from: viewState.multiSelectState.parentButton, completion: completion)
         } else {
             completion(true)
         }
     }
 
-    private func animateIn(menu: UIView, from: UIView?, completion: ((Bool) -> Void)? = nil) {
+    private func animateIn(menu: UIView?, from: UIView?, completion: ((Bool) -> Void)? = nil) {
+        guard let menu = menu else {
+            return
+        }
+
         let oldAnchor = menu.layer.anchorPoint
         let frame = menu.frame
         menu.layer.anchorPoint = .zero
@@ -219,7 +215,7 @@ extension HomeViewController {
             menu.transform = .identity
         }) { (result) in
             menu.layer.anchorPoint = oldAnchor
-            menu.autoPinEdgesToSuperviewSafeArea()
+            menu.frame = frame
             from?.isUserInteractionEnabled = true
             completion?(result)
         }
@@ -438,13 +434,6 @@ extension HomeViewController {
         }
         updateCaptions()
     }
-
-    // private tagging interface
-    private class TapToCloseGestureRecognizer: UITapGestureRecognizer {
-        init(target: Any?) {
-            super.init(target: target, action: #selector(hideMenu))
-        }
-    }
 }
 
 // MARK: - implementation of ContextMenuActionsViewDelegate
@@ -457,21 +446,30 @@ extension HomeViewController: ContextMenuActionsViewDelegate {
 // MARK: - view helper class (providing a rounded view *with* a shadow)
 private class ContextMenuActionsViewContainer: UIView {
     static let offset = CGPoint(x: 8, y: 0)
+    fileprivate let menuContainer: UIView
 
     required init(_ target: UIView) {
-        super.init(frame: target.frame)
         var frame = target.bounds
-        frame.origin = ContextMenuActionsViewContainer.offset
+        frame.origin.x = Self.offset.x + target.frame.origin.x
+        frame.origin.y = Self.offset.y + target.frame.origin.y
+        let container = UIView(frame: frame)
+        container.autoresizingMask = [.flexibleRightMargin, .flexibleBottomMargin]
+        self.menuContainer = container
+
+        super.init(frame: .zero)
+
         let radius = target.layer.cornerRadius
-        let shadowView = UIView(frame: CGRect(x: ContextMenuActionsViewContainer.offset.x + radius,
-                                              y: ContextMenuActionsViewContainer.offset.y + radius,
+        let shadowView = UIView(frame: CGRect(x: radius,
+                                              y: radius,
                                               width: frame.width - 2 * radius,
                                               height: frame.height - 2 * radius))
         shadowView.backgroundColor = Theme.isDarkThemeEnabled ? .black : .white
-        shadowView.setShadow(radius: 40, opacity: 0.3, offset: CGSize(width: 8, height: 20))
-        target.frame = frame
-        self.addSubview(shadowView)
-        self.addSubview(target)
+        shadowView.setShadow(radius: 40, opacity: 0.8, offset: CGSize(width: 8, height: 20))
+        target.frame = target.bounds
+        container.addSubview(shadowView)
+        container.addSubview(target)
+        self.addSubview(container)
+        self.autoresizingMask = [.flexibleWidth, .flexibleHeight]
     }
 
     required init?(coder: NSCoder) {
@@ -495,6 +493,14 @@ public class MultiSelectState: NSObject {
     @objc
     var isActive: Bool { return _isActive }
 
+    @objc
+    func moveContextMenu(to topLeft: CGPoint) {
+        guard let menu = contextMenuView?.menuContainer else {
+            return
+        }
+        menu.frame.origin = topLeft + ContextMenuActionsViewContainer.offset
+    }
+
     fileprivate func setIsActive(_ active: Bool, tableView: UITableView? = nil) {
         if active != _isActive {
             AssertIsOnMainThread()
diff --git a/Signal/src/ViewControllers/HomeView/HomeViewController.m b/Signal/src/ViewControllers/HomeView/HomeViewController.m
index 797ed78d059..75ec8e94556 100644
--- a/Signal/src/ViewControllers/HomeView/HomeViewController.m
+++ b/Signal/src/ViewControllers/HomeView/HomeViewController.m
@@ -154,6 +154,8 @@ - (void)viewWillTransitionToSize:(CGSize)size
             } else {
                 self.getStartedBanner.view.alpha = 1;
             }
+            [self.viewState.multiSelectState
+                moveContextMenuTo:CGPointMake(self.view.safeAreaInsets.left, self.view.safeAreaInsets.top)];
         }
                         completion:nil];
 }
diff --git a/SignalMessaging/categories/UIColor+OWS.swift b/SignalMessaging/categories/UIColor+OWS.swift
index 8201cd6bc48..9c8cff2b4d0 100644
--- a/SignalMessaging/categories/UIColor+OWS.swift
+++ b/SignalMessaging/categories/UIColor+OWS.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -129,6 +129,11 @@ public extension UIColor {
         return UIColor(rgbHex: 0xf0f0f0)
     }
 
+    @objc(ows_gray12Color)
+    class var ows_gray12: UIColor {
+        return UIColor(rgbHex: 0xe0e0e0)
+    }
+
     @objc(ows_gray15Color)
     class var ows_gray15: UIColor {
         return UIColor(rgbHex: 0xD4D4D4)
@@ -139,6 +144,11 @@ public extension UIColor {
         return UIColor(rgbHex: 0xCCCCCC)
     }
 
+    @objc(ows_gray22Color)
+    class var ows_gray22: UIColor {
+        return UIColor(rgbHex: 0xC6C6C6)
+    }
+
     @objc(ows_gray25Color)
     class var ows_gray25: UIColor {
         return UIColor(rgbHex: 0xB9B9B9)
