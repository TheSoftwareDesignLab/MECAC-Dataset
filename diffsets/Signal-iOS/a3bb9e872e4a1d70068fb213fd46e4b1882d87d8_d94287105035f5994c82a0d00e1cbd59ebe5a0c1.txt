diff --git a/Signal/src/ViewControllers/LongTextViewController.swift b/Signal/src/ViewControllers/LongTextViewController.swift
index 5407f1c1bb5..604d18f8253 100644
--- a/Signal/src/ViewControllers/LongTextViewController.swift
+++ b/Signal/src/ViewControllers/LongTextViewController.swift
@@ -114,21 +114,7 @@ public class LongTextViewController: OWSViewController {
 
             // Mentions have a custom style on the long-text view
             // that differs from the message, so we re-color them here.
-            mutableText.enumerateAttribute(
-                .mention,
-                in: NSRange(location: 0, length: mutableText.length),
-                options: []
-            ) { mention, subrange, _ in
-                guard mention != nil else { return }
-
-                mutableText.addAttributes(
-                    [
-                        .backgroundColor: Theme.isDarkThemeEnabled ? UIColor.ows_signalBlueDark : UIColor.ows_blackAlpha20,
-                        .foregroundColor: Theme.primaryTextColor
-                    ],
-                    range: subrange
-                )
-            }
+            Mention.updateWithStyle(.longMessageView, in: mutableText)
 
             messageTextView.attributedText = mutableText
             messageTextView.textAlignment = displayableText.fullTextNaturalAlignment
diff --git a/SignalMessaging/Views/Mentions/Mention.swift b/SignalMessaging/Views/Mentions/Mention.swift
index f77845a96da..51d6bf20a78 100644
--- a/SignalMessaging/Views/Mentions/Mention.swift
+++ b/SignalMessaging/Views/Mentions/Mention.swift
@@ -23,6 +23,7 @@ public class Mention: NSObject {
         case outgoing
         case composingAttachment
         case quotedReply
+        case longMessageView
 
         public static var composing: Self = .incoming
     }
@@ -36,10 +37,22 @@ public class Mention: NSObject {
         }
     }
 
-    public init(address: SignalServiceAddress, style: Style, transaction: GRDBReadTransaction) {
+    public convenience init(address: SignalServiceAddress, style: Style, transaction: GRDBReadTransaction) {
+        let displayName = Environment.shared.contactsManager.displayName(
+            for: address,
+            transaction: transaction.asAnyRead
+        ).bidirectionallyBalancedAndIsolated
+        self.init(
+            address: address,
+            style: style,
+            text: Self.mentionPrefix + displayName
+        )
+    }
+
+    private init(address: SignalServiceAddress, style: Style, text: String) {
         self.address = address
         self.style = style
-        self.text = (Self.mentionPrefix + Environment.shared.contactsManager.displayName(for: address, transaction: transaction.asAnyRead)).bidirectionallyBalancedAndIsolated
+        self.text = text
     }
 
     public var attributedString: NSAttributedString { NSAttributedString(string: text, attributes: attributes) }
@@ -63,6 +76,9 @@ public class Mention: NSObject {
         case .quotedReply:
             attributes[.backgroundColor] = Theme.isDarkThemeEnabled ? UIColor.ows_blackAlpha40 : UIColor.ows_blackAlpha20
             attributes[.foregroundColor] = Theme.primaryTextColor
+        case .longMessageView:
+            attributes[.backgroundColor] = Theme.isDarkThemeEnabled ? UIColor.ows_signalBlueDark : UIColor.ows_blackAlpha20
+            attributes[.foregroundColor] = Theme.primaryTextColor
         }
 
         return attributes
@@ -79,6 +95,23 @@ public class Mention: NSObject {
         guard let groupThread = thread as? TSGroupThread else { return false }
         return groupThread.groupModel.groupsVersion == .V2
     }
+
+    @objc(refreshAttributedInMutableAttributedString:)
+    public class func refreshAttributes(in mutableAttributedString: NSMutableAttributedString) {
+        mutableAttributedString.enumerateMentions { mention, subrange, _ in
+            guard let mention = mention else { return }
+            mutableAttributedString.addAttributes(mention.attributes, range: subrange)
+        }
+    }
+
+    @objc(updateWithStyle:inMutableAttributedString:)
+    public class func updateWithStyle(_ style: Style, in mutableAttributedString: NSMutableAttributedString) {
+        mutableAttributedString.enumerateMentions { mention, subrange, _ in
+            guard let mention = mention else { return }
+            let restyledMention = Mention(address: mention.address, style: style, text: mention.text)
+            mutableAttributedString.addAttributes(restyledMention.attributes, range: subrange)
+        }
+    }
 }
 
 extension NSAttributedString.Key {
@@ -92,12 +125,8 @@ extension MessageBody {
         let filteredAttributedString = attributedString.filterForDisplay
         let mutableAttributedString = NSMutableAttributedString(attributedString: filteredAttributedString)
 
-        mutableAttributedString.enumerateAttribute(
-            .mention,
-            in: NSRange(location: 0, length: mutableAttributedString.length),
-            options: []
-        ) { mention, subrange, _ in
-            guard let mention = mention as? Mention else { return }
+        mutableAttributedString.enumerateMentions { mention, subrange, _ in
+            guard let mention = mention else { return }
 
             // This string may not be a full mention, for example we may
             // have copied a string that only selects part of a mention.
@@ -170,9 +199,20 @@ extension MessageBodyRanges {
     }
 }
 
-private extension NSAttributedString {
+extension NSAttributedString {
+    public func enumerateMentions(
+        in range: NSRange? = nil,
+        handler: (Mention?, NSRange, UnsafeMutablePointer<ObjCBool>) -> Void
+    ) {
+        enumerateAttribute(
+            .mention,
+            in: range ?? NSRange(location: 0, length: length),
+            options: []
+        ) { handler($0 as? Mention, $1, $2) }
+    }
+
     // This is private because it's *only* safe to use on mention attributed strings.
-    var filterForDisplay: NSAttributedString {
+    fileprivate var filterForDisplay: NSAttributedString {
         guard length > 0 else { return self }
 
         if string.ows_stripped().isEmpty { return NSAttributedString(string: "") }
@@ -185,11 +225,7 @@ private extension NSAttributedString {
         // this method of filtering will fall down. For now, we can safely
         // filter all the text before/after/between mentions and treat it
         // as having the same set of attributes.
-        mutableString.enumerateAttribute(
-            .mention,
-            in: NSRange(location: 0, length: length),
-            options: []
-        ) { mention, subrange, _ in
+        mutableString.enumerateMentions { mention, subrange, _ in
             guard mention == nil else { return }
 
             let string = mutableString.attributedSubstring(from: subrange).string
diff --git a/SignalMessaging/Views/Mentions/MentionTextView.swift b/SignalMessaging/Views/Mentions/MentionTextView.swift
index 82913daca9d..cd87d24b788 100644
--- a/SignalMessaging/Views/Mentions/MentionTextView.swift
+++ b/SignalMessaging/Views/Mentions/MentionTextView.swift
@@ -321,12 +321,8 @@ open class MentionTextView: OWSTextView {
 
         if range.length > 0 {
             // Locate any mentions in the edited range.
-            textStorage.enumerateAttribute(
-                .mention,
-                in: range,
-                options: []
-            ) { mention, subrange, _ in
-                guard let mention = mention as? Mention else { return }
+            textStorage.enumerateMentions(in: range) { mention, subrange, _ in
+                guard let mention = mention else { return }
 
                 // Get the full range of the mention, we may only be editing a part of it.
                 var uniqueMentionRange = NSRange()
@@ -343,7 +339,11 @@ open class MentionTextView: OWSTextView {
                 deletedMentions[uniqueMentionRange] = mention
             }
         } else if range.location > 0,
-            let leftMention = textStorage.attribute(.mention, at: range.location - 1, effectiveRange: nil) as? Mention {
+            let leftMention = textStorage.attribute(
+                .mention,
+                at: range.location - 1,
+                effectiveRange: nil
+            ) as? Mention {
             // If there is a mention to the left, the typing attributes will
             // be the mention's attributes. We don't want that, so we need
             // to reset them here.
diff --git a/SignalMessaging/utils/DisplayableText.swift b/SignalMessaging/utils/DisplayableText.swift
index 0b709322b17..d7228fcbc9d 100644
--- a/SignalMessaging/utils/DisplayableText.swift
+++ b/SignalMessaging/utils/DisplayableText.swift
@@ -11,8 +11,8 @@ import Foundation
         let naturalAlignment: NSTextAlignment
     }
 
-    private let fullContent: Content
-    private let truncatedContent: Content?
+    private var fullContent: Content
+    private var truncatedContent: Content?
 
     @objc
     public var fullAttributedText: NSAttributedString {
@@ -56,6 +56,34 @@ import Foundation
         self.fullContent = fullContent
         self.truncatedContent = truncatedContent
         self.jumbomojiCount = DisplayableText.jumbomojiCount(in: fullContent.attributedText.string)
+
+        super.init()
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(themeDidChange),
+            name: .ThemeDidChange,
+            object: nil
+        )
+    }
+
+    @objc private func themeDidChange() {
+        // When the theme changes, we must refresh any mention attributes.
+        let mutableFullText = NSMutableAttributedString(attributedString: fullAttributedText)
+        Mention.refreshAttributes(in: mutableFullText)
+        fullContent = Content(
+            attributedText: mutableFullText,
+            naturalAlignment: fullContent.naturalAlignment
+        )
+
+        if let truncatedContent = truncatedContent {
+            let mutableTruncatedText = NSMutableAttributedString(attributedString: truncatedContent.attributedText)
+            Mention.refreshAttributes(in: mutableTruncatedText)
+            self.truncatedContent = Content(
+                attributedText: mutableTruncatedText,
+                naturalAlignment: truncatedContent.naturalAlignment
+            )
+        }
     }
 
     // MARK: Emoji
