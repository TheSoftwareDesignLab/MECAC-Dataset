diff --git a/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift b/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift
index 60daf8dc185..7f98cb23eb9 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift
@@ -171,31 +171,36 @@ public class ConversationMessageMapping: NSObject {
         Logger.debug("fetching set: \(unfetchedSet), nsRange: \(nsRange)")
         let newItems = try fetchInteractions(nsRange: nsRange, transaction: transaction)
 
-        switch direction {
-        case .before:
-            self.loadedIndexSet = loadedIndexSet.union(requestSet)
-            let items = (newItems + self.loadedInteractions)
-            let trimmedItems = items.prefix(maxInteractionLimit)
-            if (items.count != trimmedItems.count) {
-                let trimCount = items.count - trimmedItems.count
-                let trimmedSet = loadedIndexSet.suffix(trimCount)
-                loadedIndexSet.subtract(IndexSet(trimmedSet))
-                Logger.verbose("trimmed newest \(trimCount) items")
-            }
-            self.loadedInteractions = Array(trimmedItems)
-        case .after:
-            self.loadedIndexSet = loadedIndexSet.union(requestSet)
-            let items = (self.loadedInteractions + newItems)
-            let trimmedItems = items.suffix(maxInteractionLimit)
-            if (items.count != trimmedItems.count) {
-                let trimCount = items.count - trimmedItems.count
-                let trimmedSet = loadedIndexSet.prefix(trimCount)
-                loadedIndexSet.subtract(IndexSet(trimmedSet))
-                Logger.verbose("trimmed oldest \(trimCount) items")
+        let isFetchContiguousWithAlreadyLoadedItems = requestSet.union(loadedIndexSet).isContiguous
+        if isFetchContiguousWithAlreadyLoadedItems, let minLoaded = loadedIndexSet.min() {
+            // If fetched items are just before the already loaded ones...
+            if unfetchedSet.max()! < minLoaded {
+                self.loadedIndexSet = loadedIndexSet.union(requestSet)
+                let items = (newItems + self.loadedInteractions)
+                let trimmedItems = items.prefix(maxInteractionLimit)
+                if items.count != trimmedItems.count {
+                    let trimCount = items.count - trimmedItems.count
+                    let trimmedSet = loadedIndexSet.suffix(trimCount)
+                    loadedIndexSet.subtract(IndexSet(trimmedSet))
+                    Logger.verbose("trimmed newest \(trimCount) items")
+                }
+                self.loadedInteractions = Array(trimmedItems)
+
+            // If fetched items are just after the already loaded ones...
+            } else {
+                self.loadedIndexSet = loadedIndexSet.union(requestSet)
+                let items = (self.loadedInteractions + newItems)
+                let trimmedItems = items.suffix(maxInteractionLimit)
+                if items.count != trimmedItems.count {
+                    let trimCount = items.count - trimmedItems.count
+                    let trimmedSet = loadedIndexSet.prefix(trimCount)
+                    loadedIndexSet.subtract(IndexSet(trimmedSet))
+                    Logger.verbose("trimmed oldest \(trimCount) items")
+                }
+                self.loadedInteractions = Array(trimmedItems)
             }
-            self.loadedInteractions = Array(trimmedItems)
-        case .around, .newest:
-            // replace, rather than append, because the new results might not be contiguous
+        } else {
+            // replace, rather than append, because the fetched records are not contiguous
             // with the existing loadedIndexSet
             self.loadedIndexSet = requestSet
             self.loadedInteractions = newItems
@@ -382,3 +387,21 @@ public class ConversationScrollState: NSObject {
         self.contentOffset = contentOffset
     }
 }
+
+extension IndexSet {
+    var isContiguous: Bool {
+        guard !self.isEmpty else {
+            return true
+        }
+        guard let min = self.min() else {
+            owsFailDebug("min was unexpectedly nil")
+            return true
+        }
+        guard let max = self.max() else {
+            owsFailDebug("min was unexpectedly nil")
+            return true
+        }
+
+        return self == IndexSet(min..<(max+1))
+    }
+}
diff --git a/Signal/test/ViewControllers/ConversationMessageMappingTest.swift b/Signal/test/ViewControllers/ConversationMessageMappingTest.swift
index b6e03976b1b..bdf90e9587c 100644
--- a/Signal/test/ViewControllers/ConversationMessageMappingTest.swift
+++ b/Signal/test/ViewControllers/ConversationMessageMappingTest.swift
@@ -215,4 +215,30 @@ class ConversationMessageMappingTest: SignalBaseTest {
         XCTAssertEqual([], diff.updatedItemIds)
         XCTAssertEqual(Set(initiallyLoadedInteractions.map { $0.uniqueId }), diff.removedItemIds)
     }
+
+    func test_loadAroundEdge() throws {
+        let initialMessages: [TSIncomingMessage] = write { transaction in
+            // create more messages than the initial load window can fit
+            let createdMessages = self.messageFactory.create(count: UInt(self.mapping.initialLoadCount * 2), transaction: transaction)
+
+            // mark as read so that we initially load the bottom of the conversation
+            for message in createdMessages {
+                message.debugonly_markAsReadNow(transaction: transaction)
+            }
+
+            return createdMessages
+        }
+
+        for message in initialMessages {
+            self.mapping = ConversationMessageMapping(thread: thread)
+            try read { transaction in
+                try self.mapping.loadInitialMessagePage(focusMessageId: nil, transaction: transaction)
+                try self.mapping.loadMessagePage(aroundInteractionId: message.uniqueId, transaction: transaction)
+            }
+            guard (mapping.loadedInteractions.map { $0.uniqueId }.contains(message.uniqueId)) else {
+                XCTFail("message not loaded: \(message)")
+                return
+            }
+        }
+    }
 }
