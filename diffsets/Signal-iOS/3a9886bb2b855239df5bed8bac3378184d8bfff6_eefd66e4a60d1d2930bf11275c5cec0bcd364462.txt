diff --git a/Signal/src/ViewControllers/DebugUI/DebugUIMisc.m b/Signal/src/ViewControllers/DebugUI/DebugUIMisc.m
index beaec9be274..9a46423df9d 100644
--- a/Signal/src/ViewControllers/DebugUI/DebugUIMisc.m
+++ b/Signal/src/ViewControllers/DebugUI/DebugUIMisc.m
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2017 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
 //
 
 #import "DebugUIMisc.h"
@@ -22,12 +22,22 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-@interface TSAccountManager (Debug)
+@interface TSAccountManager (DebugUI)
 
 - (void)resetForRegistration;
 
 @end
 
+#pragma mark -
+
+@interface OWSStorage (DebugUI)
+
+- (NSData *)databasePassword;
+
+@end
+
+#pragma mark -
+
 @implementation DebugUIMisc
 
 #pragma mark - Factory Methods
@@ -72,6 +82,18 @@ - (nullable OWSTableSection *)sectionForThread:(nullable TSThread *)thread
                                                     }];
                            }]];
 
+
+    if (thread) {
+        [items addObject:[OWSTableItem itemWithTitle:@"Send Encrypted Database"
+                                         actionBlock:^{
+                                             [DebugUIMisc sendEncryptedDatabase:thread];
+                                         }]];
+        [items addObject:[OWSTableItem itemWithTitle:@"Send Unencrypted Database"
+                                         actionBlock:^{
+                                             [DebugUIMisc sendUnencryptedDatabase:thread];
+                                         }]];
+    }
+
     return [OWSTableSection sectionWithTitle:self.name items:items];
 }
 
@@ -140,6 +162,67 @@ + (void)clearHasDismissedOffers
         }];
 }
 
++ (void)sendEncryptedDatabase:(TSThread *)thread
+{
+    NSString *temporaryDirectory = NSTemporaryDirectory();
+    NSString *fileName = [[NSUUID UUID].UUIDString stringByAppendingString:@".sqlite"];
+    NSString *filePath = [temporaryDirectory stringByAppendingPathComponent:fileName];
+
+    __block BOOL success;
+    [TSStorageManager.sharedManager.newDatabaseConnection
+        readWriteWithBlock:^(YapDatabaseReadWriteTransaction *transaction) {
+            NSError *error;
+            success = [[NSFileManager defaultManager] copyItemAtPath:TSStorageManager.databaseFilePath
+                                                              toPath:filePath
+                                                               error:&error];
+            if (!success || error) {
+                OWSFail(@"%@ Could not copy database file: %@.", self.logTag, error);
+                success = NO;
+            }
+        }];
+
+    if (!success) {
+        return;
+    }
+
+    OWSMessageSender *messageSender = [Environment current].messageSender;
+    NSString *utiType = [MIMETypeUtil utiTypeForFileExtension:fileName.pathExtension];
+    DataSource *_Nullable dataSource = [DataSourcePath dataSourceWithFilePath:filePath];
+    [dataSource setSourceFilename:fileName];
+    SignalAttachment *attachment = [SignalAttachment attachmentWithDataSource:dataSource dataUTI:utiType];
+    NSData *databasePassword = [TSStorageManager.sharedManager databasePassword];
+    attachment.captionText = [databasePassword hexadecimalString];
+    if (!attachment || [attachment hasError]) {
+        OWSFail(@"%@ attachment[%@]: %@", self.logTag, [attachment sourceFilename], [attachment errorName]);
+        return;
+    }
+    [ThreadUtil sendMessageWithAttachment:attachment inThread:thread messageSender:messageSender completion:nil];
+}
+
++ (void)sendUnencryptedDatabase:(TSThread *)thread
+{
+    NSString *temporaryDirectory = NSTemporaryDirectory();
+    NSString *fileName = [[NSUUID UUID].UUIDString stringByAppendingString:@".sqlite"];
+    NSString *filePath = [temporaryDirectory stringByAppendingPathComponent:fileName];
+
+    NSError *error = [TSStorageManager.sharedManager.newDatabaseConnection backupToPath:filePath];
+    if (error) {
+        OWSFail(@"%@ Could not copy database file: %@.", self.logTag, error);
+        return;
+    }
+
+    OWSMessageSender *messageSender = [Environment current].messageSender;
+    NSString *utiType = [MIMETypeUtil utiTypeForFileExtension:fileName.pathExtension];
+    DataSource *_Nullable dataSource = [DataSourcePath dataSourceWithFilePath:filePath];
+    [dataSource setSourceFilename:fileName];
+    SignalAttachment *attachment = [SignalAttachment attachmentWithDataSource:dataSource dataUTI:utiType];
+    if (!attachment || [attachment hasError]) {
+        OWSFail(@"%@ attachment[%@]: %@", self.logTag, [attachment sourceFilename], [attachment errorName]);
+        return;
+    }
+    [ThreadUtil sendMessageWithAttachment:attachment inThread:thread messageSender:messageSender completion:nil];
+}
+
 @end
 
 NS_ASSUME_NONNULL_END
