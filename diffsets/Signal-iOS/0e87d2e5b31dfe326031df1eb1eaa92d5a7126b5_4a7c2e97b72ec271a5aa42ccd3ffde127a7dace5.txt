diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index a5f9b69e18d..5c09f4e3e46 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -2595,7 +2595,7 @@ - (void)updateScrollDownButtonLayout
 {
     CGFloat inset = -(self.collectionView.contentInset.bottom + self.bottomLayoutGuide.length);
     self.scrollDownButtonButtomConstraint.constant = inset;
-    [self.view setNeedsLayout];
+    [self.scrollDownButton setNeedsLayout];
 }
 
 - (void)setHasUnreadMessages:(BOOL)hasUnreadMessages
@@ -3886,16 +3886,14 @@ - (void)handleKeyboardNotification:(NSNotification *)notification
         // RADAR: #36297652
         [self updateScrollDownButtonLayout];
 
-        [self.scrollDownButton setNeedsLayout];
-        [self.scrollDownButton layoutIfNeeded];
         // HACK: I've made the assumption that we are already in the context of an animation, in which case the
         // above should be sufficient to smoothly move the scrollDown button in step with the keyboard presentation
         // animation. Yet, setting the constraint doesn't animate the movement of the button - it "jumps" to it's final
         // position. So here we manually lay out the scroll down button frame (seemingly redundantly), which allows it
         // to be smoothly animated.
         CGRect newButtonFrame = self.scrollDownButton.frame;
-        newButtonFrame.origin.y
-            = self.scrollDownButton.superview.height - (newInsets.bottom + self.scrollDownButton.height);
+        newButtonFrame.origin.y = self.scrollDownButton.superview.height
+            - (newInsets.bottom + self.scrollDownButton.height + self.bottomLayoutGuide.length);
         self.scrollDownButton.frame = newButtonFrame;
 
         // Adjust content offset to prevent the presented keyboard from obscuring content.
