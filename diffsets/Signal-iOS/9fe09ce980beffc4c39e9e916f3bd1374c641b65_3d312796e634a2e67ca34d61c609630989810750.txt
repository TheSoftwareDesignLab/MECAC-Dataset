diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index f591a226455..5a984c16421 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -768,13 +768,13 @@
 		5075004628B09CE6001922C9 /* ContactDiscoveryOperationTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4C4BC6C22102D697004040C9 /* ContactDiscoveryOperationTest.swift */; };
 		50CF28F02829C94800752AB3 /* CVComponentGiftBadge.swift in Sources */ = {isa = PBXBuildFile; fileRef = 50CF28EF2829C94800752AB3 /* CVComponentGiftBadge.swift */; };
 		641CECC436F5F3EE2AC07EE9 /* Pods_SignalShareExtension.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 6657FDE7B91C2845BB3BEAB5 /* Pods_SignalShareExtension.framework */; };
-		661396AB28BD53EF00E0C4DF /* HiddenStoryHeaderView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661396AA28BD53EF00E0C4DF /* HiddenStoryHeaderView.swift */; };
+		661396AB28BD53EF00E0C4DF /* HiddenStoryHeaderCell.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661396AA28BD53EF00E0C4DF /* HiddenStoryHeaderCell.swift */; };
 		661396AD28BE74DC00E0C4DF /* ChainedPromise.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661396AC28BE74DC00E0C4DF /* ChainedPromise.swift */; };
 		661396AF28BE881E00E0C4DF /* ChainedPromiseTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661396AE28BE881E00E0C4DF /* ChainedPromiseTest.swift */; };
 		661602A428BEB94400C1932D /* StoryListDataSource.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661602A328BEB94400C1932D /* StoryListDataSource.swift */; };
 		668CAB3E289983520085A2C3 /* AudioMessagePlaybackRateView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668CAB3D289983520085A2C3 /* AudioMessagePlaybackRateView.swift */; };
 		668FE09B28B923A4008B9071 /* Bool+SSK.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668FE09A28B923A4008B9071 /* Bool+SSK.swift */; };
-		668FE09F28B947ED008B9071 /* StoryHidingManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668FE09E28B947ED008B9071 /* StoryHidingManager.swift */; };
+		668FE09F28B947ED008B9071 /* StoryContextMenuGenerator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668FE09E28B947ED008B9071 /* StoryContextMenuGenerator.swift */; };
 		669E8FE828B4153C00043D28 /* OWSURLSession.swift in Sources */ = {isa = PBXBuildFile; fileRef = 669E8FE728B4153B00043D28 /* OWSURLSession.swift */; };
 		669E8FE928B415C000043D28 /* OWSURLBuilderUtil.swift in Sources */ = {isa = PBXBuildFile; fileRef = 669E8FDB28B02CC400043D28 /* OWSURLBuilderUtil.swift */; };
 		669E8FED28B4177900043D28 /* OWSSignalServiceMock.swift in Sources */ = {isa = PBXBuildFile; fileRef = 669E8FEC28B4177800043D28 /* OWSSignalServiceMock.swift */; };
@@ -786,6 +786,7 @@
 		669E900728B43F5B00043D28 /* SystemStoryManagerProtocol.swift in Sources */ = {isa = PBXBuildFile; fileRef = 669E900628B43F5B00043D28 /* SystemStoryManagerProtocol.swift */; };
 		669E901028B57D6300043D28 /* SystemStoryManagerMock.swift in Sources */ = {isa = PBXBuildFile; fileRef = 669E900F28B57D6300043D28 /* SystemStoryManagerMock.swift */; };
 		66A22C0928A18D49007CD4F5 /* RingerSwitch.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66A22C0828A18D49007CD4F5 /* RingerSwitch.swift */; };
+		66B8B28028C94C0F005EAFE0 /* DelegatingContextMenuButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */; };
 		760D93AB27A0E28600F351AC /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 760D93AA27A0E28600F351AC /* CoreServices.framework */; };
 		7628DDBE2807505D009AA53D /* ImageEditorCropView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7628DDBC28075056009AA53D /* ImageEditorCropView.swift */; };
 		7628DDBF2807505D009AA53D /* RotationControl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7628DDBD2807505D009AA53D /* RotationControl.swift */; };
@@ -3024,7 +3025,7 @@
 		50CF28EF2829C94800752AB3 /* CVComponentGiftBadge.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CVComponentGiftBadge.swift; sourceTree = "<group>"; };
 		55D83291ED67EE1A7FC96E60 /* Pods-SignalNSE.testable release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalNSE.testable release.xcconfig"; path = "Pods/Target Support Files/Pods-SignalNSE/Pods-SignalNSE.testable release.xcconfig"; sourceTree = "<group>"; };
 		63BAA38DC365EE44110A6BD1 /* Pods-SignalTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalTests.debug.xcconfig"; path = "Pods/Target Support Files/Pods-SignalTests/Pods-SignalTests.debug.xcconfig"; sourceTree = "<group>"; };
-		661396AA28BD53EF00E0C4DF /* HiddenStoryHeaderView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HiddenStoryHeaderView.swift; sourceTree = "<group>"; };
+		661396AA28BD53EF00E0C4DF /* HiddenStoryHeaderCell.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HiddenStoryHeaderCell.swift; sourceTree = "<group>"; };
 		661396AC28BE74DC00E0C4DF /* ChainedPromise.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChainedPromise.swift; sourceTree = "<group>"; };
 		661396AE28BE881E00E0C4DF /* ChainedPromiseTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChainedPromiseTest.swift; sourceTree = "<group>"; };
 		661602A328BEB94400C1932D /* StoryListDataSource.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryListDataSource.swift; sourceTree = "<group>"; };
@@ -3032,7 +3033,7 @@
 		668AB0CB28AD610600B31984 /* StoryUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryUtil.swift; sourceTree = "<group>"; };
 		668CAB3D289983520085A2C3 /* AudioMessagePlaybackRateView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AudioMessagePlaybackRateView.swift; sourceTree = "<group>"; };
 		668FE09A28B923A4008B9071 /* Bool+SSK.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Bool+SSK.swift"; sourceTree = "<group>"; };
-		668FE09E28B947ED008B9071 /* StoryHidingManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryHidingManager.swift; sourceTree = "<group>"; };
+		668FE09E28B947ED008B9071 /* StoryContextMenuGenerator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryContextMenuGenerator.swift; sourceTree = "<group>"; };
 		669E8FDB28B02CC400043D28 /* OWSURLBuilderUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSURLBuilderUtil.swift; sourceTree = "<group>"; };
 		669E8FE528B4149200043D28 /* OWSURLSessionMock.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OWSURLSessionMock.swift; sourceTree = "<group>"; };
 		669E8FE728B4153B00043D28 /* OWSURLSession.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OWSURLSession.swift; sourceTree = "<group>"; };
@@ -3043,6 +3044,7 @@
 		669E900628B43F5B00043D28 /* SystemStoryManagerProtocol.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SystemStoryManagerProtocol.swift; sourceTree = "<group>"; };
 		669E900F28B57D6300043D28 /* SystemStoryManagerMock.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SystemStoryManagerMock.swift; sourceTree = "<group>"; };
 		66A22C0828A18D49007CD4F5 /* RingerSwitch.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RingerSwitch.swift; sourceTree = "<group>"; };
+		66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DelegatingContextMenuButton.swift; sourceTree = "<group>"; };
 		70377AAA1918450100CAF501 /* MobileCoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = MobileCoreServices.framework; path = System/Library/Frameworks/MobileCoreServices.framework; sourceTree = SDKROOT; };
 		748A5CAEDD7C919FC64C6807 /* Pods_SignalTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_SignalTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		760D93AA27A0E28600F351AC /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = System/Library/Frameworks/CoreServices.framework; sourceTree = SDKROOT; };
@@ -6061,8 +6063,8 @@
 			isa = PBXGroup;
 			children = (
 				8864072F27F21AA7009916B6 /* Group Reply Sheet */,
+				668FE09E28B947ED008B9071 /* StoryContextMenuGenerator.swift */,
 				88423A51280A171E007D2918 /* StoryDirectReplySheet.swift */,
-				668FE09E28B947ED008B9071 /* StoryHidingManager.swift */,
 				88B00D4E28A33B5800BC9CA0 /* StoryPrivateViewsSheet.swift */,
 				8864073027F21AD7009916B6 /* StoryReplyInputToolbar.swift */,
 				88423A53280A2675007D2918 /* StoryReplyPreviewView.swift */,
@@ -6100,7 +6102,7 @@
 				88423A50280A1703007D2918 /* Replies & Views Sheets */,
 				8878B2D4286636BC008368F2 /* Settings */,
 				88863A4C280CADDC00977F69 /* Transitions */,
-				661396AA28BD53EF00E0C4DF /* HiddenStoryHeaderView.swift */,
+				661396AA28BD53EF00E0C4DF /* HiddenStoryHeaderCell.swift */,
 				8840B6E1283F16650036BA4C /* MyStoriesViewController.swift */,
 				886292112835606D00AA0C3B /* MyStoryCell.swift */,
 				8862920F28355B8000AA0C3B /* MyStoryViewModel.swift */,
@@ -6823,6 +6825,7 @@
 				F0FB6B1F269E625A00AC2A41 /* ContextMenuController.swift */,
 				F0B872B5269CF6D900D26481 /* ContextMenuInteraction.swift */,
 				F0EE4DB526A7AC18001DE4ED /* ContextMenuReactionBarAccessory.swift */,
+				66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */,
 			);
 			path = "Context Menus";
 			sourceTree = "<group>";
@@ -10127,6 +10130,7 @@
 				343A65951FC47D5E000477A1 /* DebugUISyncMessages.m in Sources */,
 				34D8C0281ED3673300188D7C /* DebugUITableViewController.m in Sources */,
 				88DBDFB9263731C800C2101C /* DefaultDisappearingMessageTimerInteraction.swift in Sources */,
+				66B8B28028C94C0F005EAFE0 /* DelegatingContextMenuButton.swift in Sources */,
 				887B6DC925F6C3E900E677D4 /* DeleteAccountConfirmationViewController.swift in Sources */,
 				3498AC892513896400B1F315 /* Dependencies+MainApp.swift in Sources */,
 				88A4CC19246CE6810082211F /* DeviceTransferInitialViewController.swift in Sources */,
@@ -10202,7 +10206,7 @@
 				347B83F724367EC10019A52C /* GroupViewHelper+MemberActionSheet.swift in Sources */,
 				347B83F92436820C0019A52C /* GroupViewHelper.swift in Sources */,
 				32ECD08824BFBF8000EDDED0 /* HelpViewController.swift in Sources */,
-				661396AB28BD53EF00E0C4DF /* HiddenStoryHeaderView.swift in Sources */,
+				661396AB28BD53EF00E0C4DF /* HiddenStoryHeaderCell.swift in Sources */,
 				8852572C27DD40870032073C /* HomeTabBarController.swift in Sources */,
 				3496955C219B605E00DCFE74 /* ImagePickerController.swift in Sources */,
 				4CD4E7D523E8CCFE00834B1B /* IndividualCall.swift in Sources */,
@@ -10375,6 +10379,7 @@
 				349767E425B8744700ECE1B0 /* StickerPackViewController.swift in Sources */,
 				8852572927DD366D0032073C /* StoriesViewController.swift in Sources */,
 				884DB94727DD754700C6A309 /* StoryCell.swift in Sources */,
+				668FE09F28B947ED008B9071 /* StoryContextMenuGenerator.swift in Sources */,
 				884DB95027DE67BB00C6A309 /* StoryContextViewController.swift in Sources */,
 				88423A52280A171E007D2918 /* StoryDirectReplySheet.swift in Sources */,
 				88B00D5128A341D000BC9CA0 /* StoryGroupRepliesAndViewsSheet.swift in Sources */,
@@ -10383,7 +10388,6 @@
 				8864072827EEA658009916B6 /* StoryGroupReplySheet.swift in Sources */,
 				88B00D4B28A32DB600BC9CA0 /* StoryGroupReplyViewController.swift in Sources */,
 				8864072C27F0DA38009916B6 /* StoryGroupReplyViewItem.swift in Sources */,
-				668FE09F28B947ED008B9071 /* StoryHidingManager.swift in Sources */,
 				88863A52280CAE6A00977F69 /* StoryInteractiveTransitionCoordinator.swift in Sources */,
 				884DB95227DE67D900C6A309 /* StoryItemMediaView.swift in Sources */,
 				661602A428BEB94400C1932D /* StoryListDataSource.swift in Sources */,
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuButton.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuButton.swift
index e403b5e2e4d..cb4a0d44ed3 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuButton.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuButton.swift	
@@ -6,7 +6,11 @@ import Foundation
 import UIKit
 import SignalCoreKit
 
-public class ContextMenuButton: UIButton {
+/// This class exists to be a drop-in replacement for the Context-menu related APIs available on UIButton
+/// in iOS 14 and above.
+/// When we drop iOS 13, we can remove this class and replace all usages with a vanilla UIButton.
+/// As such, its exposed API should remain identical to what UIButton exposes in iOS 14.
+public class ContextMenuButton: UIButton, ContextMenuInteractionDelegate {
     public var contextMenu: ContextMenu? {
         didSet { updateHandlers() }
     }
@@ -29,12 +33,26 @@ public class ContextMenuButton: UIButton {
         fatalError("init(coder:) has not been implemented")
     }
 
+    // Note: fake value used just to mimic UIButton iOS 14+ behavior
+    private lazy var _contextMenuInteraction = ContextMenuInteraction(delegate: self)
+
     public var isShowingContextMenu: Bool { contextMenuController != nil }
 
+    private var contextMenuConfiguration: ContextMenuConfiguration?
     private var contextMenuController: ContextMenuController?
+
     public func showContextMenu(initiatingGestureRecognizer: UIGestureRecognizer? = nil) {
         guard !isShowingContextMenu else { return }
-        guard let window = window, let contextMenu = contextMenu else { return }
+        guard
+            let window = window,
+            let contextMenuConfiguration = self.contextMenuInteraction(
+                _contextMenuInteraction,
+                configurationForMenuAtLocation: initiatingGestureRecognizer?.location(in: self) ?? bounds.center
+            ),
+            let contextMenu = contextMenuConfiguration.actionProvider?([])
+        else {
+            return
+        }
 
         let menuPosition = ContextMenuPosition(
             rect: window.bounds,
@@ -43,19 +61,13 @@ public class ContextMenuButton: UIButton {
 
         guard let preview = contextMenuTargetedPreview(menuPosition: menuPosition) else { return }
 
-        let configuration = ContextMenuConfiguration(
-            identifier: NSUUID(),
-            forceDarkTheme: forceDarkTheme,
-            actionProvider: { _ in contextMenu }
-        )
-
         let menuAccessory = contextMenuActionsAccessory(
             menuPosition: menuPosition,
             menu: contextMenu
         )
 
         let controller = ContextMenuController(
-            configuration: configuration,
+            configuration: contextMenuConfiguration,
             preview: preview,
             initiatingGestureRecognizer: initiatingGestureRecognizer,
             menuAccessory: menuAccessory,
@@ -65,11 +77,14 @@ public class ContextMenuButton: UIButton {
         )
         contextMenuController = controller
         controller.delegate = self
+        self.contextMenuConfiguration = contextMenuConfiguration
 
         ImpactHapticFeedback.impactOccured(style: .medium, intensity: 0.8)
 
         window.addSubview(controller.view)
         controller.view.frame = window.bounds
+
+        self.contextMenuInteraction(_contextMenuInteraction, willDisplayMenuForConfiguration: contextMenuConfiguration)
     }
 
     public func dismissContextMenu(animated: Bool, completion: (() -> Void)? = nil) {
@@ -77,8 +92,19 @@ public class ContextMenuButton: UIButton {
             contextMenuController?.view?.removeFromSuperview()
             contextMenuController = nil
             completion?()
+            if let contextMenuConfiguration = contextMenuConfiguration {
+                self.contextMenuInteraction(_contextMenuInteraction, didEndForConfiguration: contextMenuConfiguration)
+                self.contextMenuConfiguration = nil
+            } else {
+                owsFailDebug("Dismissing context menu with no configuration present")
+            }
         }
 
+        if let contextMenuConfiguration = contextMenuConfiguration {
+            self.contextMenuInteraction(_contextMenuInteraction, willEndForConfiguration: contextMenuConfiguration)
+        } else {
+            owsFailDebug("Dismissing context menu with no configuration present")
+        }
         if animated {
             contextMenuController?.animateOut(dismiss)
         } else {
@@ -187,6 +213,40 @@ public class ContextMenuButton: UIButton {
         accessory.delegate = self
         return accessory
     }
+
+    /// Note: If you override this method on UIButton on iOS 14 or later, whatever is returned is used for the
+    /// context menu that is ultimately displayed.
+    /// This class is meant to be a perfect replacement for UIButton to get context menu functionality prior to
+    /// iOS 14, so we mimic that behavior and use this method as the source of truth, allowing it to be overriden.
+    public func contextMenuInteraction(
+        _ interaction: ContextMenuInteraction,
+        configurationForMenuAtLocation location: CGPoint
+    ) -> ContextMenuConfiguration? {
+        return self.contextMenu.map { contextMenu in
+            return .init(identifier: nil, actionProvider: { _ in
+                return contextMenu
+            })
+        }
+    }
+
+    public func contextMenuInteraction(
+        _ interaction: ContextMenuInteraction,
+        previewForHighlightingMenuWithConfiguration configuration: ContextMenuConfiguration
+    ) -> ContextMenuTargetedPreview? {
+        return nil
+    }
+
+    public func contextMenuInteraction(_ interaction: ContextMenuInteraction, willDisplayMenuForConfiguration: ContextMenuConfiguration) {
+        // Do nothing
+    }
+
+    public func contextMenuInteraction(_ interaction: ContextMenuInteraction, willEndForConfiguration: ContextMenuConfiguration) {
+        // Do nothing
+    }
+
+    public func contextMenuInteraction(_ interaction: ContextMenuInteraction, didEndForConfiguration: ContextMenuConfiguration) {
+        // Do nothing
+    }
 }
 
 extension ContextMenuButton: ContextMenuControllerDelegate {
diff --git a/Signal/src/ViewControllers/Context Menus/DelegatingContextMenuButton.swift b/Signal/src/ViewControllers/Context Menus/DelegatingContextMenuButton.swift
new file mode 100644
index 00000000000..760ffdec9b1
--- /dev/null
+++ b/Signal/src/ViewControllers/Context Menus/DelegatingContextMenuButton.swift	
@@ -0,0 +1,64 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public protocol ContextMenuButtonDelegate: AnyObject {
+
+    func contextMenuConfiguration(for contextMenuButton: DelegatingContextMenuButton) -> ContextMenuConfiguration?
+
+    func contextMenuWillDisplay(from contextMenuButton: DelegatingContextMenuButton)
+    /// Note: called _after_ action handlers if dismissed by tapping a context menu action.
+    func contextMenuDidDismiss(from contextMenuButton: ContextMenuButton)
+}
+
+extension ContextMenuButtonDelegate {
+
+    func contextMenuWillDisplay(from contextMenuButton: DelegatingContextMenuButton) {}
+
+    func contextMenuDidDismiss(from contextMenuButton: ContextMenuButton) {}
+}
+
+/// This class exists to keep ContextMenuButton as clean and close to iOS 14+ APIs on UIButton as possible.
+/// Eventually, we will drop iOS 13 support, get rid of ContextMenuButton, and have this subclass UIButton
+/// instead. Hence, it is structured to not get any special access to the internals of ContextMenuButton it
+/// wouldn't have if it was an iOS 14+ UIButton instead.
+public class DelegatingContextMenuButton: ContextMenuButton {
+
+    public weak var delegate: ContextMenuButtonDelegate?
+
+    public init(delegate: ContextMenuButtonDelegate? = nil) {
+        self.delegate = delegate
+
+        // UIButton's native implementation of context menu handling won't show
+        // a context menu unless provided one in its `menu` var, or equivalently in
+        // its menu initializer. As long as we override the context menu configuration
+        // method, it doesn't matter what gets set, as long as something is set.
+        // So we set a dummy value.
+        super.init(contextMenu: ContextMenu([ContextMenuAction(handler: { _ in })]))
+    }
+
+    @available(*, unavailable)
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    public override func contextMenuInteraction(
+        _ interaction: ContextMenuInteraction,
+        configurationForMenuAtLocation location: CGPoint
+    ) -> ContextMenuConfiguration? {
+        return delegate?.contextMenuConfiguration(for: self)
+    }
+
+    public override func contextMenuInteraction(
+        _ interaction: ContextMenuInteraction,
+        willDisplayMenuForConfiguration: ContextMenuConfiguration
+    ) {
+        delegate?.contextMenuWillDisplay(from: self)
+    }
+
+    public override func contextMenuInteraction(_ interaction: ContextMenuInteraction, didEndForConfiguration: ContextMenuConfiguration) {
+        delegate?.contextMenuDidDismiss(from: self)
+    }
+}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift
index dcb8fb499d5..a7e9a324bbd 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift	
@@ -56,6 +56,8 @@ class StoryContextViewController: OWSViewController {
     }
     private(set) var loadPositionIfRead: LoadPosition
 
+    private(set) lazy var contextMenuGenerator = StoryContextMenuGenerator(presentingController: self, delegate: self)
+
     required init(context: StoryContext, loadPositionIfRead: LoadPosition = .default, delegate: StoryContextViewControllerDelegate) {
         self.context = context
         self.loadPositionIfRead = loadPositionIfRead
@@ -681,6 +683,39 @@ extension StoryContextViewController: DatabaseChangeDelegate {
 }
 
 extension StoryContextViewController: StoryItemMediaViewDelegate {
+
+    func contextMenuConfiguration(for contextMenuButton: DelegatingContextMenuButton) -> ContextMenuConfiguration? {
+        guard let item = currentItem else {
+            return nil
+        }
+        let attachment: StoryThumbnailView.Attachment
+        switch item.attachment {
+        case .pointer(let pointer):
+            attachment = .file(pointer)
+        case .stream(let stream):
+            attachment = .file(stream)
+        case .text(let textAttachment):
+            attachment = .text(textAttachment)
+        }
+        return .init(identifier: nil, actionProvider: { [weak self, weak contextMenuButton] _ in
+            guard
+                let self  = self,
+                let contextMenuButton = contextMenuButton
+            else {
+                return .init([])
+            }
+            return Self.databaseStorage.read {
+                return ContextMenu(self.contextMenuGenerator.contextMenuActions(
+                    for: item.message,
+                    in: item.message.context.thread(transaction: $0),
+                    attachment: attachment,
+                    sourceView: contextMenuButton,
+                    transaction: $0
+                ))
+            }
+        })
+    }
+
     func storyItemMediaViewWantsToPlay(_ storyItemMediaView: StoryItemMediaView) {
         play()
     }
@@ -692,4 +727,32 @@ extension StoryContextViewController: StoryItemMediaViewDelegate {
     func storyItemMediaViewShouldBeMuted(_ storyItemMediaView: StoryItemMediaView) -> Bool {
         return delegate?.storyContextViewControllerShouldBeMuted(self) ?? false
     }
+
+    func contextMenuWillDisplay(from contextMenuButton: DelegatingContextMenuButton) {
+        pause()
+    }
+
+    func contextMenuDidDismiss(from contextMenuButton: ContextMenuButton) {
+        guard !contextMenuGenerator.isDisplayingFollowup else {
+            return
+        }
+        play()
+    }
+}
+
+extension StoryContextViewController: StoryContextMenuDelegate {
+
+    func storyContextMenuWillNavigateToConversation(_ completion: @escaping () -> Void) {
+        // Dismiss the viewer before navigating.
+        self.dismiss(animated: true, completion: completion)
+    }
+
+    func storyContextMenuWillDelete(_ completion: @escaping () -> Void) {
+        // Dismiss the viewer before deleting otherwise things get messed up.
+        self.dismiss(animated: true, completion: completion)
+    }
+
+    func storyContextMenuDidFinishDisplayingFollowups() {
+        play()
+    }
 }
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift
index 94c2286021e..511a6a820fe 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift	
@@ -10,11 +10,13 @@ import SignalUI
 import SafariServices
 import CoreMedia
 
-protocol StoryItemMediaViewDelegate: AnyObject {
+protocol StoryItemMediaViewDelegate: ContextMenuButtonDelegate {
     func storyItemMediaViewWantsToPause(_ storyItemMediaView: StoryItemMediaView)
     func storyItemMediaViewWantsToPlay(_ storyItemMediaView: StoryItemMediaView)
 
     func storyItemMediaViewShouldBeMuted(_ storyItemMediaView: StoryItemMediaView) -> Bool
+
+    var contextMenuGenerator: StoryContextMenuGenerator { get }
 }
 
 class StoryItemMediaView: UIView {
@@ -114,6 +116,10 @@ class StoryItemMediaView: UIView {
             return didHandle
         }
 
+        if contextButton.bounds.contains(gesture.location(in: contextButton)) {
+            return true
+        }
+
         return false
     }
 
@@ -250,11 +256,18 @@ class StoryItemMediaView: UIView {
             nameLabel,
             .spacer(withWidth: nameTrailingSpacing),
             nameTrailingView,
-            .hStretchingSpacer()
+            .hStretchingSpacer(),
+            .spacer(withWidth: Self.contextButtonSize)
         ])
         authorRow.axis = .horizontal
         authorRow.alignment = .center
 
+        authorRow.addSubview(contextButton)
+        contextButton.autoPinEdge(toSuperviewEdge: .trailing)
+        NSLayoutConstraint.activate([
+            contextButton.centerYAnchor.constraint(equalTo: authorRow.centerYAnchor)
+        ])
+
         timestampLabel.setCompressionResistanceHorizontalHigh()
         timestampLabel.setContentHuggingHorizontalHigh()
         timestampLabel.font = .ows_dynamicTypeFootnote
@@ -332,6 +345,20 @@ class StoryItemMediaView: UIView {
         return label
     }
 
+    static let contextButtonSize: CGFloat = 42
+
+    private lazy var contextButton: DelegatingContextMenuButton = {
+        let contextButton = DelegatingContextMenuButton(delegate: delegate)
+        contextButton.showsContextMenuAsPrimaryAction = true
+        contextButton.tintColor = Theme.darkThemePrimaryColor
+        contextButton.setImage(Theme.iconImage(.more24), for: .normal)
+        contextButton.contentMode = .center
+
+        contextButton.autoSetDimensions(to: .square(Self.contextButtonSize))
+
+        return contextButton
+    }()
+
     // MARK: - Caption
 
     private lazy var captionLabel: UILabel = {
diff --git a/Signal/src/ViewControllers/HomeView/Stories/HiddenStoryHeaderView.swift b/Signal/src/ViewControllers/HomeView/Stories/HiddenStoryHeaderCell.swift
similarity index 80%
rename from Signal/src/ViewControllers/HomeView/Stories/HiddenStoryHeaderView.swift
rename to Signal/src/ViewControllers/HomeView/Stories/HiddenStoryHeaderCell.swift
index ffe15953cb8..c62332622eb 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/HiddenStoryHeaderView.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/HiddenStoryHeaderCell.swift
@@ -5,18 +5,19 @@
 import Foundation
 import UIKit
 
-class HiddenStoryHeaderView: UITableViewHeaderFooterView {
+class HiddenStoryHeaderCell: UITableViewCell {
 
-    static let reuseIdentifier = "HiddenStoryHeaderView"
+    static let reuseIdentifier = "HiddenStoryHeaderCell"
 
     private let label = UILabel()
     private let iconView = UIImageView(image: .init(named: "chevron-right-20")?.withRenderingMode(.alwaysTemplate))
 
-    override init(reuseIdentifier: String?) {
-        super.init(reuseIdentifier: reuseIdentifier)
+    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
+        super.init(style: style, reuseIdentifier: reuseIdentifier)
 
         backgroundView = UIView()
         backgroundView?.backgroundColor = .clear
+        selectionStyle = .none
 
         contentView.addSubview(label)
         contentView.addSubview(iconView)
@@ -31,8 +32,6 @@ class HiddenStoryHeaderView: UITableViewHeaderFooterView {
 
         iconView.autoPinEdge(toSuperviewMargin: .trailing)
         iconView.autoVCenterInSuperview()
-
-        addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(didTap)))
     }
 
     @available(*, unavailable, message: "use other constructor instead.")
@@ -62,10 +61,4 @@ class HiddenStoryHeaderView: UITableViewHeaderFooterView {
         }
         UIView.animate(withDuration: 0.2, animations: applyIconRotation)
     }
-
-    public var tapHandler: (() -> Void)?
-
-    @objc private func didTap() {
-        tapHandler?()
-    }
 }
diff --git a/Signal/src/ViewControllers/HomeView/Stories/MyStoriesViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/MyStoriesViewController.swift
index 71513eeff02..4e3cc5894d2 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/MyStoriesViewController.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/MyStoriesViewController.swift
@@ -28,6 +28,8 @@ class MyStoriesViewController: OWSViewController {
 
     private lazy var contextMenu = ContextMenuInteraction(delegate: self)
 
+    private lazy var contextMenuGenerator = StoryContextMenuGenerator(presentingController: self)
+
     override init() {
         super.init()
         hidesBottomBarWhenPushed = true
@@ -153,13 +155,13 @@ extension MyStoriesViewController: UITableViewDataSource {
     }
 
     func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
-        guard let item = item(for: indexPath), let contextMenu = contextMenu(for: indexPath) else {
+        guard let item = item(for: indexPath) else {
             owsFailDebug("Missing item for row at indexPath \(indexPath)")
             return UITableViewCell()
         }
 
         let cell = tableView.dequeueReusableCell(withIdentifier: SentStoryCell.reuseIdentifier, for: indexPath) as! SentStoryCell
-        cell.configure(with: item, contextMenu: contextMenu)
+        cell.configure(with: item, contextMenuButtonDelegate: self, indexPath: indexPath)
         return cell
     }
 
@@ -205,112 +207,35 @@ extension MyStoriesViewController: DatabaseChangeDelegate {
 }
 
 extension MyStoriesViewController: ContextMenuInteractionDelegate {
-    func contextMenu(for indexPath: IndexPath) -> ContextMenu? {
-        guard let item = item(for: indexPath) else { return nil }
-
-        var actions = [ContextMenuAction]()
-
-        actions.append(.init(
-            title: NSLocalizedString(
-                "STORIES_DELETE_STORY_ACTION",
-                comment: "Context menu action to delete the selected story"),
-            image: Theme.iconImage(.trash24),
-            attributes: .destructive,
-            handler: { [weak self] _ in
-                self?.tryToDeleteMessage(for: item)
-            }))
-
-        func appendSaveAction() {
-            actions.append(.init(
-                title: NSLocalizedString(
-                    "STORIES_SAVE_STORY_ACTION",
-                    comment: "Context menu action to save the selected story"),
-                image: Theme.iconImage(.messageActionSave),
-                handler: { _ in item.save() }))
-        }
-
-        func appendForwardAction() {
-            actions.append(.init(
-                title: NSLocalizedString(
-                    "STORIES_FORWARD_STORY_ACTION",
-                    comment: "Context menu action to forward the selected story"),
-                image: Theme.iconImage(.messageActionForward),
-                handler: { [weak self] _ in
-                    guard let self = self else { return }
-                    switch item.attachment {
-                    case .file(let attachment):
-                        ForwardMessageViewController.present([attachment], from: self, delegate: self)
-                    case .text:
-                        OWSActionSheets.showActionSheet(title: LocalizationNotNeeded("Forwarding text stories is not yet implemented."))
-                    case .missing:
-                        owsFailDebug("Unexpectedly missing attachment for story.")
-                    }
-                }))
-        }
-
-        func appendShareAction() {
-            actions.append(.init(
-                title: NSLocalizedString(
-                    "STORIES_SHARE_STORY_ACTION",
-                    comment: "Context menu action to share the selected story"),
-                image: Theme.iconImage(.messageActionShare),
-                handler: { [weak self] _ in
-                    guard let self = self else { return }
-                    guard let cell = self.tableView.cellForRow(at: indexPath) else { return }
-
-                    switch item.attachment {
-                    case .file(let attachment):
-                        guard let attachment = attachment as? TSAttachmentStream else {
-                            return owsFailDebug("Unexpectedly tried to share undownloaded attachment")
-                        }
-                        AttachmentSharing.showShareUI(forAttachment: attachment, sender: cell)
-                    case .text(let attachment):
-                        if let url = attachment.preview?.urlString {
-                            AttachmentSharing.showShareUI(for: URL(string: url)!, sender: cell)
-                        } else if let text = attachment.text {
-                            AttachmentSharing.showShareUI(forText: text, sender: cell)
-                        }
-                    case .missing:
-                        owsFailDebug("Unexpectedly missing attachment for story.")
-                    }
-                }))
+    fileprivate func contextMenu(
+        for cell: SentStoryCell,
+        at indexPath: IndexPath
+    ) -> ContextMenu? {
+        guard let item = item(for: indexPath) else {
+            return nil
         }
 
-        if item.isSaveable { appendSaveAction() }
-
-        switch item.attachment {
-        case .file(let attachment):
-            guard attachment is TSAttachmentStream else { break }
-            appendForwardAction()
-            appendShareAction()
-        case .text:
-            appendForwardAction()
-            appendShareAction()
-        case .missing:
-            owsFailDebug("Unexpectedly missing attachment for story.")
+        let actions = Self.databaseStorage.read { transaction in
+            return self.contextMenuGenerator.contextMenuActions(
+                for: item.message,
+                in: item.thread,
+                attachment: item.attachment,
+                sourceView: cell,
+                transaction: transaction
+            )
         }
 
         return .init(actions)
     }
 
-    private func tryToDeleteMessage(for item: OutgoingStoryItem) {
-        let actionSheet = ActionSheetController(
-            message: NSLocalizedString(
-                "STORIES_DELETE_STORY_ACTION_SHEET_TITLE",
-                comment: "Title asking the user if they are sure they want to delete their story"
-            )
-        )
-        actionSheet.addAction(.init(title: CommonStrings.deleteButton, style: .destructive, handler: { _ in
-            Self.databaseStorage.write { transaction in
-                item.message.remotelyDelete(for: item.thread, transaction: transaction)
-            }
-        }))
-        actionSheet.addAction(OWSActionSheets.cancelAction)
-        presentActionSheet(actionSheet, animated: true)
-    }
-
     func contextMenuInteraction(_ interaction: ContextMenuInteraction, configurationForMenuAtLocation location: CGPoint) -> ContextMenuConfiguration? {
-        guard let indexPath = tableView.indexPathForRow(at: location), let contextMenu = contextMenu(for: indexPath) else { return nil }
+        guard
+            let indexPath = tableView.indexPathForRow(at: location),
+            let cell = tableView.cellForRow(at: indexPath) as? SentStoryCell,
+            let contextMenu = contextMenu(for: cell, at: indexPath)
+        else {
+            return nil
+        }
         return .init(identifier: indexPath as NSCopying) { _ in contextMenu }
     }
 
@@ -351,6 +276,22 @@ extension MyStoriesViewController: ContextMenuInteractionDelegate {
     func contextMenuInteraction(_ interaction: ContextMenuInteraction, didEndForConfiguration configuration: ContextMenuConfiguration) {}
 }
 
+extension MyStoriesViewController: ContextMenuButtonDelegate {
+
+    func contextMenuConfiguration(for contextMenuButton: DelegatingContextMenuButton) -> ContextMenuConfiguration? {
+        guard
+            let indexPath = (contextMenuButton as? IndexPathContextMenuButton)?.indexPath,
+            let cell = tableView.dequeueReusableCell(withIdentifier: SentStoryCell.reuseIdentifier, for: indexPath) as? SentStoryCell,
+            let contextMenu = self.contextMenu(for: cell, at: indexPath)
+        else {
+            return nil
+        }
+        return .init(identifier: nil, actionProvider: { _ in
+            return contextMenu
+        })
+    }
+}
+
 extension MyStoriesViewController: ForwardMessageDelegate {
     public func forwardMessageFlowDidComplete(items: [ForwardMessageItem], recipientThreads: [TSThread]) {
         AssertIsOnMainThread()
@@ -387,53 +328,6 @@ private struct OutgoingStoryItem {
             )
         }
     }
-
-    var isSaveable: Bool {
-        guard case .file(let attachment) = attachment, attachment is TSAttachmentStream, attachment.isVisualMedia else { return false }
-        return true
-    }
-
-    func save() {
-        switch attachment {
-        case .file(let attachment):
-            guard
-                let attachment = attachment as? TSAttachmentStream,
-                attachment.isVisualMedia,
-                let mediaURL = attachment.originalMediaURL,
-                let vc = CurrentAppContext().frontmostViewController()
-            else { break }
-
-            vc.ows_askForMediaLibraryPermissions { isGranted in
-                guard isGranted else {
-                    return
-                }
-
-                PHPhotoLibrary.shared().performChanges({
-                    if attachment.isImage {
-                        PHAssetCreationRequest.creationRequestForAssetFromImage(atFileURL: mediaURL)
-                    } else if attachment.isVideo {
-                        PHAssetCreationRequest.creationRequestForAssetFromVideo(atFileURL: mediaURL)
-                    }
-                }, completionHandler: { didSucceed, error in
-                    DispatchQueue.main.async {
-                        if didSucceed {
-                            let toastController = ToastController(text: OWSLocalizedString("STORIES_DID_SAVE",
-                                                                                           comment: "toast alert shown after user taps the 'save' button"))
-                            toastController.presentToastView(from: .bottom, of: vc.view, inset: 16)
-                        } else {
-                            owsFailDebug("error: \(String(describing: error))")
-                            OWSActionSheets.showErrorAlert(message: OWSLocalizedString("STORIES_SAVE_FAILED",
-                                                                                       comment: "alert notifying that the 'save' operation failed"))
-                        }
-                    }
-                })
-            }
-        case .text:
-            owsFailDebug("Saving text stories is not supported")
-        case .missing:
-            owsFailDebug("Unexpectedly missing attachment for story.")
-        }
-    }
 }
 
 private class SentStoryCell: UITableViewCell {
@@ -444,7 +338,7 @@ private class SentStoryCell: UITableViewCell {
     let subtitleLabel = UILabel()
     let thumbnailContainer = UIView()
     let saveButton = OWSButton()
-    let contextButton = ContextMenuButton()
+    let contextButton = IndexPathContextMenuButton()
 
     let failedIconContainer = UIView()
     let failedIconView = UIImageView()
@@ -510,7 +404,11 @@ private class SentStoryCell: UITableViewCell {
         fatalError("init(coder:) has not been implemented")
     }
 
-    func configure(with item: OutgoingStoryItem, contextMenu: ContextMenu) {
+    func configure(
+        with item: OutgoingStoryItem,
+        contextMenuButtonDelegate: ContextMenuButtonDelegate,
+        indexPath: IndexPath
+    ) {
         let thumbnailView = StoryThumbnailView(attachment: item.attachment)
         thumbnailContainer.removeAllSubviews()
         thumbnailContainer.addSubview(thumbnailView)
@@ -545,9 +443,9 @@ private class SentStoryCell: UITableViewCell {
         saveButton.setImage(Theme.iconImage(.messageActionSave), for: .normal)
         saveButton.setBackgroundImage(UIImage(color: Theme.secondaryBackgroundColor), for: .normal)
 
-        if item.isSaveable {
+        if item.attachment.isSaveable {
             saveButton.isHiddenInStackView = false
-            saveButton.block = { item.save() }
+            saveButton.block = { item.attachment.save() }
         } else {
             saveButton.isHiddenInStackView = true
             saveButton.block = {}
@@ -556,6 +454,12 @@ private class SentStoryCell: UITableViewCell {
         contextButton.tintColor = Theme.primaryIconColor
         contextButton.setImage(Theme.iconImage(.more24), for: .normal)
         contextButton.setBackgroundImage(UIImage(color: Theme.secondaryBackgroundColor), for: .normal)
-        contextButton.contextMenu = contextMenu
+        contextButton.delegate = contextMenuButtonDelegate
+        contextButton.indexPath = indexPath
     }
 }
+
+private class IndexPathContextMenuButton: DelegatingContextMenuButton {
+
+    var indexPath: IndexPath?
+}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift
new file mode 100644
index 00000000000..fbb38caa670
--- /dev/null
+++ b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift	
@@ -0,0 +1,559 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import Photos
+import UIKit
+import SignalServiceKit
+
+protocol StoryContextMenuDelegate: AnyObject {
+
+    /// Delegates should dismiss any context and call the completion block to proceed with navigation.
+    func storyContextMenuWillNavigateToConversation(_ completion: @escaping () -> Void)
+
+    /// Delegates should handle any required actions prior to deletion (such as dismissing a viewer)
+    /// and call the completion block to proceed with deletion.
+    func storyContextMenuWillDelete(_ completion: @escaping () -> Void)
+
+    func storyContextMenuDidFinishDisplayingFollowups()
+}
+
+class StoryContextMenuGenerator: Dependencies {
+
+    private weak var presentingController: UIViewController?
+
+    weak var delegate: StoryContextMenuDelegate?
+
+    private(set) var isDisplayingFollowup = false {
+        didSet {
+            if oldValue && !isDisplayingFollowup {
+                delegate?.storyContextMenuDidFinishDisplayingFollowups()
+            }
+        }
+    }
+
+    init(presentingController: UIViewController, delegate: StoryContextMenuDelegate? = nil) {
+        self.presentingController = presentingController
+        self.delegate = delegate
+    }
+
+    public func contextMenuActions(
+        for model: StoryViewModel,
+        sourceView: UIView
+    ) -> [ContextMenuAction] {
+        return Self.databaseStorage.read {
+            let thread = model.context.thread(transaction: $0)
+            return self.contextMenuActions(
+                for: model.latestMessage,
+                in: thread,
+                attachment: model.latestMessageAttachment,
+                sourceView: sourceView,
+                transaction: $0
+            )
+        }
+    }
+
+    public func contextMenuActions(
+        for message: StoryMessage,
+        in thread: TSThread?,
+        attachment: StoryThumbnailView.Attachment,
+        sourceView: UIView,
+        transaction: SDSAnyReadTransaction
+    ) -> [ContextMenuAction] {
+        return [
+            deleteAction(for: message, in: thread),
+            hideAction(for: message, in: thread, transaction: transaction),
+            saveAction(message: message, attachment: attachment),
+            forwardAction(message: message, attachment: attachment),
+            shareAction(message: message, attachment: attachment, sourceView: sourceView),
+            goToChatAction(thread: thread)
+        ].compactMap({ $0 })
+    }
+}
+
+// MARK: - Hide Action
+
+extension StoryContextMenuGenerator {
+
+    private func hideAction(
+        for message: StoryMessage,
+        in thread: TSThread?,
+        transaction: SDSAnyReadTransaction
+    ) -> ContextMenuAction? {
+        if
+            message.authorAddress.isLocalAddress,
+            case .authorUuid = message.context
+        {
+            // Can't hide your own stories unless sent to a group context
+            return nil
+        }
+
+        // Refresh the hidden state, it might be stale.
+        let isHidden: Bool = {
+            if let threadUniqueId = thread?.uniqueId {
+                return message.context.isHidden(threadUniqueId: threadUniqueId, transaction: transaction)
+            } else {
+                return message.context.isHidden(transaction: transaction)
+            }
+        }()
+        let title: String
+        let image: UIImage
+        if isHidden {
+            title = NSLocalizedString(
+                "STORIES_UNHIDE_STORY_ACTION",
+                comment: "Context menu action to unhide the selected story"
+            )
+            image = Theme.iconImage(.checkCircle)
+        } else {
+            title = NSLocalizedString(
+                "STORIES_HIDE_STORY_ACTION",
+                comment: "Context menu action to hide the selected story"
+            )
+            image = Theme.iconImage(.xCircle24)
+        }
+        return .init(
+            title: title,
+            image: image,
+            handler: { [weak self] _ in
+                self?.showHidingActionSheetIfNeeded(for: message, in: thread, shouldHide: !isHidden)
+            }
+        )
+    }
+
+    // MARK: Hide action sheet
+
+    private func showHidingActionSheetIfNeeded(
+        for message: StoryMessage,
+        in thread: TSThread?,
+        shouldHide: Bool
+    ) {
+        guard shouldHide else {
+            // No need to show anything if unhiding, hide right away
+            setHideStateAndShowToast(for: message, in: thread, shouldHide: shouldHide)
+            return
+        }
+
+        let actionSheet = createHidingActionSheetWithSneakyTransaction(context: message.context)
+
+        let actionTitle: String
+        if shouldHide {
+            actionTitle = NSLocalizedString(
+                "STORIES_HIDE_STORY_ACTION",
+                comment: "Context menu action to hide the selected story"
+            )
+        } else {
+            actionTitle = NSLocalizedString(
+                "STORIES_UNHIDE_STORY_ACTION",
+                comment: "Context menu action to unhide the selected story"
+            )
+        }
+
+        actionSheet.addAction(ActionSheetAction(
+            title: actionTitle,
+            style: .default,
+            handler: { [weak self] _ in
+                self?.setHideStateAndShowToast(for: message, in: thread, shouldHide: shouldHide)
+                self?.isDisplayingFollowup = false
+            }
+        ))
+        actionSheet.addAction(ActionSheetAction(
+            title: CommonStrings.cancelButton,
+            style: .cancel
+        ) { [weak self] _ in
+            self?.isDisplayingFollowup = false
+        })
+        isDisplayingFollowup = true
+        presentingController?.presentActionSheet(actionSheet)
+    }
+
+    private func createHidingActionSheetWithSneakyTransaction(context: StoryContext) -> ActionSheetController {
+        return ActionSheetController(
+            title: NSLocalizedString(
+                "STORIES_HIDE_STORY_ACTION_SHEET_TITLE",
+                comment: "Title asking the user if they are sure they want to hide stories from another user"
+            ),
+            message: loadThreadDisplayNameWithSneakyTransaction(context: context).map {
+                String(
+                    format: NSLocalizedString(
+                        "STORIES_HIDE_STORY_ACTION_SHEET_MESSAGE",
+                        comment: "Message asking the user if they are sure they want to hide stories from {{other user's name}}"
+                    ),
+                    $0
+                )
+            }
+        )
+    }
+
+    private func loadThreadDisplayNameWithSneakyTransaction(context: StoryContext) -> String? {
+        return Self.databaseStorage.read { transaction -> String? in
+            switch context {
+            case .groupId(let groupId):
+                return TSGroupThread.fetch(groupId: groupId, transaction: transaction)?.groupNameOrDefault
+            case .authorUuid(let authorUuid):
+                if authorUuid.asSignalServiceAddress().isSystemStoryAddress {
+                    return NSLocalizedString(
+                        "SYSTEM_ADDRESS_NAME",
+                        comment: "Name to display for the 'system' sender, e.g. for release notes and the onboarding story"
+                    )
+                }
+                return Self.contactsManager.shortDisplayName(
+                    for: authorUuid.asSignalServiceAddress(),
+                    transaction: transaction
+                )
+            case .privateStory:
+                owsFailDebug("Unexpectedly had private story when hiding")
+                return nil
+            case .none:
+                owsFailDebug("Unexpectedly missing context for story when hiding")
+                return nil
+            }
+        }
+    }
+
+    // MARK: Issuing hide changes
+
+    private func setHideStateAndShowToast(
+        for message: StoryMessage,
+        in thread: TSThread?,
+        shouldHide: Bool
+    ) {
+        Self.databaseStorage.write { transaction in
+            guard !message.authorAddress.isSystemStoryAddress else {
+                // System stories go through SystemStoryManager
+                Self.systemStoryManager.setSystemStoriesHidden(shouldHide, transaction: transaction)
+                return
+            }
+            guard let thread = thread ?? message.context.thread(transaction: transaction) else {
+                owsFailDebug("Cannot hide a story without specifying its thread!")
+                return
+            }
+            let threadAssociatedData = ThreadAssociatedData.fetchOrDefault(for: thread, transaction: transaction)
+            threadAssociatedData.updateWith(
+                hideStory: shouldHide,
+                updateStorageService: true,
+                transaction: transaction
+            )
+        }
+        let toastText: String
+        if shouldHide {
+            toastText = NSLocalizedString(
+                "STORIES_HIDE_STORY_CONFIRMATION_TOAST",
+                comment: "Toast shown when a story is successfuly hidden"
+            )
+        } else {
+            toastText = NSLocalizedString(
+                "STORIES_UNHIDE_STORY_CONFIRMATION_TOAST",
+                comment: "Toast shown when a story is successfuly unhidden"
+            )
+        }
+        presentingController?.presentToast(text: toastText)
+    }
+}
+
+// MARK: - Go To Chat Action
+
+extension StoryContextMenuGenerator {
+
+    private func goToChatAction(
+        thread: TSThread?
+    ) -> ContextMenuAction? {
+        guard
+            let thread = thread,
+            !(thread is TSPrivateStoryThread)
+        else {
+            return nil
+        }
+
+        return .init(
+            title: NSLocalizedString(
+                "STORIES_GO_TO_CHAT_ACTION",
+                comment: "Context menu action to open the chat associated with the selected story"
+            ),
+            image: Theme.iconImage(.open24),
+            handler: { [weak self] _ in
+                if let delegate = self?.delegate {
+                    delegate.storyContextMenuWillNavigateToConversation {
+                        Self.signalApp.presentConversation(for: thread, action: .compose, animated: true)
+                    }
+                } else {
+                    Self.signalApp.presentConversation(for: thread, action: .compose, animated: true)
+                }
+            }
+        )
+    }
+}
+
+// MARK: - Delete Action
+
+extension StoryContextMenuGenerator {
+
+    private func deleteAction(
+        for message: StoryMessage,
+        in thread: TSThread?
+    ) -> ContextMenuAction? {
+        guard message.authorAddress.isLocalAddress else {
+            // Can only delete one's own stories.
+            return nil
+        }
+        guard let thread = thread else {
+            owsFailDebug("Cannot delete a message without specifying its thread!")
+            return nil
+        }
+
+        return .init(
+            title: NSLocalizedString(
+                "STORIES_DELETE_STORY_ACTION",
+                comment: "Context menu action to delete the selected story"
+            ),
+            image: Theme.iconImage(.trash24),
+            attributes: .destructive,
+            handler: { [weak self] _ in
+                self?.tryToDelete(message, in: thread)
+            }
+        )
+    }
+
+    private func tryToDelete(
+        _ message: StoryMessage,
+        in thread: TSThread
+    ) {
+        let actionSheet = ActionSheetController(
+            message: NSLocalizedString(
+                "STORIES_DELETE_STORY_ACTION_SHEET_TITLE",
+                comment: "Title asking the user if they are sure they want to delete their story"
+            )
+        )
+        actionSheet.addAction(.init(title: CommonStrings.deleteButton, style: .destructive, handler: { [weak self] _ in
+            let performDelete = { [weak self] in
+                self?.isDisplayingFollowup = false
+                Self.databaseStorage.write { transaction in
+                    message.remotelyDelete(for: thread, transaction: transaction)
+                }
+            }
+
+            if let delegate = self?.delegate {
+                delegate.storyContextMenuWillDelete(performDelete)
+            } else {
+                performDelete()
+            }
+        }))
+        actionSheet.addAction(ActionSheetAction(
+            title: CommonStrings.cancelButton,
+            style: .cancel
+        ) { [weak self] _ in
+            self?.isDisplayingFollowup = false
+        })
+        isDisplayingFollowup = true
+        presentingController?.presentActionSheet(actionSheet, animated: true)
+    }
+}
+
+// MARK: - Save Action
+
+extension StoryContextMenuGenerator {
+
+    private func saveAction(
+        message: StoryMessage,
+        attachment: StoryThumbnailView.Attachment
+    ) -> ContextMenuAction? {
+        guard
+            message.authorAddress.isLocalAddress
+        else {
+            // Can only save one's own stories.
+            return nil
+        }
+        guard attachment.isSaveable else {
+            return nil
+        }
+        return .init(
+            title: NSLocalizedString(
+                "STORIES_SAVE_STORY_ACTION",
+                comment: "Context menu action to save the selected story"
+            ),
+            image: Theme.iconImage(.messageActionSave),
+            handler: { _ in attachment.save() }
+        )
+    }
+}
+
+extension StoryThumbnailView.Attachment {
+
+    var isSaveable: Bool {
+        switch self {
+        case .missing, .text:
+            return false
+        case .file(let attachment):
+            return (attachment as? TSAttachmentStream)?.isVisualMedia ?? false
+        }
+    }
+
+    func save() {
+        switch self {
+        case .file(let attachment):
+            guard
+                let attachment = attachment as? TSAttachmentStream,
+                attachment.isVisualMedia,
+                let mediaURL = attachment.originalMediaURL,
+                let vc = CurrentAppContext().frontmostViewController()
+            else { break }
+
+            vc.ows_askForMediaLibraryPermissions { isGranted in
+                guard isGranted else {
+                    return
+                }
+
+                PHPhotoLibrary.shared().performChanges({
+                    if attachment.isImage {
+                        PHAssetCreationRequest.creationRequestForAssetFromImage(atFileURL: mediaURL)
+                    } else if attachment.isVideo {
+                        PHAssetCreationRequest.creationRequestForAssetFromVideo(atFileURL: mediaURL)
+                    }
+                }, completionHandler: { didSucceed, error in
+                    DispatchQueue.main.async {
+                        if didSucceed {
+                            let toastController = ToastController(
+                                text: OWSLocalizedString(
+                                    "STORIES_DID_SAVE",
+                                    comment: "toast alert shown after user taps the 'save' button"
+                                )
+                            )
+                            toastController.presentToastView(from: .bottom, of: vc.view, inset: 16)
+                        } else {
+                            owsFailDebug("error: \(String(describing: error))")
+                            OWSActionSheets.showErrorAlert(
+                                message: OWSLocalizedString(
+                                    "STORIES_SAVE_FAILED",
+                                    comment: "alert notifying that the 'save' operation failed"
+                                )
+                            )
+                        }
+                    }
+                })
+            }
+        case .text:
+            owsFailDebug("Saving text stories is not supported")
+        case .missing:
+            owsFailDebug("Unexpectedly missing attachment for story.")
+        }
+    }
+}
+
+// MARK: - Forward Action
+
+extension StoryContextMenuGenerator: ForwardMessageDelegate {
+
+    private func forwardAction(
+        message: StoryMessage,
+        attachment: StoryThumbnailView.Attachment
+    ) -> ContextMenuAction? {
+        guard message.authorAddress.isLocalAddress else {
+            // Can only forward one's own stories.
+            return nil
+        }
+        return .init(
+            title: NSLocalizedString(
+                "STORIES_FORWARD_STORY_ACTION",
+                comment: "Context menu action to forward the selected story"
+            ),
+            image: Theme.iconImage(.messageActionForward),
+            handler: { [weak self] _ in
+                guard
+                    let self = self,
+                    let presentingController = self.presentingController
+                else {
+                    return
+                }
+                switch attachment {
+                case .file(let attachment):
+                    self.isDisplayingFollowup = true
+                    ForwardMessageViewController.present([attachment], from: presentingController, delegate: self)
+                case .text:
+                    // TODO: support forwarding text stories. Don't remember to set isDisplayingFollowup and
+                    // call the delegate when complete.
+                    OWSActionSheets.showActionSheet(title: LocalizationNotNeeded("Forwarding text stories is not yet implemented."))
+                case .missing:
+                    owsFailDebug("Unexpectedly missing attachment for story.")
+                }
+            }
+        )
+    }
+
+    func forwardMessageFlowDidComplete(items: [ForwardMessageItem], recipientThreads: [TSThread]) {
+        AssertIsOnMainThread()
+
+        guard let presentingController = presentingController else {
+            return
+        }
+
+        presentingController.dismiss(animated: true) {
+            ForwardMessageViewController.finalizeForward(
+                items: items,
+                recipientThreads: recipientThreads,
+                fromViewController: presentingController
+            )
+            self.isDisplayingFollowup = false
+        }
+    }
+
+    func forwardMessageFlowDidCancel() {
+        presentingController?.dismiss(animated: true) {
+            self.isDisplayingFollowup = false
+        }
+    }
+}
+
+// MARK: - Share Action
+
+extension StoryContextMenuGenerator {
+
+    private func shareAction(
+        message: StoryMessage,
+        attachment: StoryThumbnailView.Attachment,
+        sourceView: UIView
+    ) -> ContextMenuAction? {
+        guard message.authorAddress.isLocalAddress else {
+            // Can only share one's own stories.
+            return nil
+        }
+        return .init(
+            title: NSLocalizedString(
+                "STORIES_SHARE_STORY_ACTION",
+                comment: "Context menu action to share the selected story"
+            ),
+            image: Theme.iconImage(.messageActionShare),
+            handler: { [weak sourceView, weak self] _ in
+                guard let sourceView = sourceView else {
+                    return
+                }
+                switch attachment {
+                case .file(let attachment):
+                    guard let attachment = attachment as? TSAttachmentStream else {
+                        return owsFailDebug("Unexpectedly tried to share undownloaded attachment")
+                    }
+                    self?.isDisplayingFollowup = true
+                    AttachmentSharing.showShareUI(forAttachment: attachment, sender: sourceView) { [weak self] in
+                        self?.isDisplayingFollowup = false
+                    }
+                case .text(let attachment):
+                    if
+                        let urlString = attachment.preview?.urlString,
+                        let url = URL(string: urlString)
+                    {
+                        self?.isDisplayingFollowup = true
+                        AttachmentSharing.showShareUI(for: url, sender: sourceView) { [weak self] in
+                            self?.isDisplayingFollowup = false
+                        }
+                    } else if let text = attachment.text {
+                        self?.isDisplayingFollowup = true
+                        AttachmentSharing.showShareUI(forText: text, sender: sourceView) { [weak self] in
+                            self?.isDisplayingFollowup = false
+                        }
+                    }
+                case .missing:
+                    owsFailDebug("Unexpectedly missing attachment for story.")
+                }
+            }
+        )
+    }
+}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryHidingManager.swift b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryHidingManager.swift
deleted file mode 100644
index f317ceb60f7..00000000000
--- a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryHidingManager.swift	
+++ /dev/null
@@ -1,190 +0,0 @@
-//
-//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
-//
-
-import Foundation
-import UIKit
-
-class StoryHidingManager: Dependencies {
-
-    private let model: StoryViewModel
-
-    init(model: StoryViewModel) {
-        self.model = model
-    }
-
-    public func contextMenuAction(
-        forPresentingController presentingController: UIViewController
-    ) -> ContextMenuAction {
-        let isHidden = model.isHidden
-        let title: String
-        let image: UIImage
-        if isHidden {
-            title = NSLocalizedString(
-                "STORIES_UNHIDE_STORY_ACTION",
-                comment: "Context menu action to unhide the selected story"
-            )
-            image = Theme.iconImage(.checkCircle)
-        } else {
-            title = NSLocalizedString(
-                "STORIES_HIDE_STORY_ACTION",
-                comment: "Context menu action to hide the selected story"
-            )
-            image = Theme.iconImage(.xCircle24)
-        }
-        return .init(
-            title: title,
-            image: image,
-            handler: { [self, weak presentingController] _ in
-                guard let presentingController = presentingController else {
-                    return
-                }
-                if isHidden {
-                    self.setHideStateAndShowToast(shouldHide: !isHidden, presentingController: presentingController)
-                } else {
-                    self.showActionSheetIfNeeded(shouldHide: !isHidden, on: presentingController)
-                }
-            }
-        )
-    }
-
-    private func showActionSheetIfNeeded(shouldHide: Bool, on presentingController: UIViewController) {
-        guard shouldHide else {
-            // No need to show anything if unhiding, hide right away
-            setHideStateAndShowToast(shouldHide: shouldHide, presentingController: presentingController)
-            return
-        }
-
-        let actionSheet = createHidingActionSheetWithSneakyTransaction()
-
-        let actionTitle: String
-        if shouldHide {
-            actionTitle = NSLocalizedString(
-                "STORIES_HIDE_STORY_ACTION",
-                comment: "Context menu action to hide the selected story"
-            )
-        } else {
-            actionTitle = NSLocalizedString(
-                "STORIES_UNHIDE_STORY_ACTION",
-                comment: "Context menu action to unhide the selected story"
-            )
-        }
-
-        actionSheet.addAction(ActionSheetAction(
-            title: actionTitle,
-            style: .default,
-            handler: { [self, weak presentingController] _ in
-                guard let presentingController = presentingController else {
-                    return
-                }
-                self.setHideStateAndShowToast(shouldHide: shouldHide, presentingController: presentingController)
-            }
-        ))
-        actionSheet.addAction(OWSActionSheets.cancelAction)
-        presentingController.presentActionSheet(actionSheet)
-    }
-
-    // MARK: - Loading data
-
-    private func loadThread(_ transaction: SDSAnyReadTransaction) -> TSThread? {
-        switch model.context {
-        case .groupId(let groupId):
-            return TSGroupThread.fetch(groupId: groupId, transaction: transaction)
-        case .authorUuid(let authorUuid):
-            return TSContactThread.getWithContactAddress(
-                authorUuid.asSignalServiceAddress(),
-                transaction: transaction
-            )
-        case .privateStory:
-            owsFailDebug("Unexpectedly had private story when hiding")
-            return nil
-        case .none:
-            owsFailDebug("Unexpectedly missing context for story when hiding")
-            return nil
-        }
-    }
-
-    // MARK: - Header configuration
-
-    private func createHidingActionSheetWithSneakyTransaction() -> ActionSheetController {
-        return ActionSheetController(
-            title: NSLocalizedString(
-                "STORIES_HIDE_STORY_ACTION_SHEET_TITLE",
-                comment: "Title asking the user if they are sure they want to hide stories from another user"
-            ),
-            message: loadThreadDisplayNameWithSneakyTransaction().map {
-                String(
-                    format: NSLocalizedString(
-                        "STORIES_HIDE_STORY_ACTION_SHEET_MESSAGE",
-                        comment: "Message asking the user if they are sure they want to hide stories from {{other user's name}}"
-                    ),
-                    $0
-                )
-            }
-        )
-    }
-
-    private func loadThreadDisplayNameWithSneakyTransaction() -> String? {
-        return Self.databaseStorage.read { transaction -> String? in
-            switch self.model.context {
-            case .groupId(let groupId):
-                return TSGroupThread.fetch(groupId: groupId, transaction: transaction)?.groupNameOrDefault
-            case .authorUuid(let authorUuid):
-                if authorUuid.asSignalServiceAddress().isSystemStoryAddress {
-                    return NSLocalizedString(
-                        "SYSTEM_ADDRESS_NAME",
-                        comment: "Name to display for the 'system' sender, e.g. for release notes and the onboarding story"
-                    )
-                }
-                return Self.contactsManager.shortDisplayName(
-                    for: authorUuid.asSignalServiceAddress(),
-                    transaction: transaction
-                )
-            case .privateStory:
-                owsFailDebug("Unexpectedly had private story when hiding")
-                return nil
-            case .none:
-                owsFailDebug("Unexpectedly missing context for story when hiding")
-                return nil
-            }
-        }
-    }
-
-    // MARK: - Issuing changes
-
-    private func setHideStateAndShowToast(
-        shouldHide: Bool,
-        presentingController: UIViewController
-    ) {
-        Self.databaseStorage.write { transaction in
-            guard self.model.messages.first?.authorAddress.isSystemStoryAddress != true else {
-                // System stories go through SystemStoryManager
-                Self.systemStoryManager.setSystemStoriesHidden(shouldHide, transaction: transaction)
-                return
-            }
-            guard let thread = self.model.context.thread(transaction: transaction) else {
-                owsFailDebug("Hiding a story without a thread")
-                return
-            }
-            let threadAssociatedData = ThreadAssociatedData.fetchOrDefault(for: thread, transaction: transaction)
-            threadAssociatedData.updateWith(
-                hideStory: shouldHide,
-                updateStorageService: true,
-                transaction: transaction
-            )
-        }
-        let toastText: String
-        if shouldHide {
-            toastText = NSLocalizedString(
-                "STORIES_HIDE_STORY_CONFIRMATION_TOAST",
-                comment: "Toast shown when a story is successfuly hidden"
-            )
-        } else {
-            toastText = NSLocalizedString(
-                "STORIES_UNHIDE_STORY_CONFIRMATION_TOAST",
-                comment: "Toast shown when a story is successfuly unhidden"
-            )
-        }
-        presentingController.presentToast(text: toastText)
-    }
-}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift
index 1b6b07523b8..988e9fa274e 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift
@@ -3,6 +3,7 @@
 //
 
 import Foundation
+import Photos
 import SignalServiceKit
 import UIKit
 import SignalUI
@@ -27,6 +28,8 @@ class StoriesViewController: OWSViewController, StoryListDataSourceDelegate {
 
     private lazy var dataSource = StoryListDataSource(delegate: self)
 
+    private lazy var contextMenuGenerator = StoryContextMenuGenerator(presentingController: self)
+
     override init() {
         super.init()
         // Want to start loading right away to prevent cases where things aren't loaded
@@ -54,7 +57,7 @@ class StoriesViewController: OWSViewController, StoryListDataSourceDelegate {
 
         tableView.register(MyStoryCell.self, forCellReuseIdentifier: MyStoryCell.reuseIdentifier)
         tableView.register(StoryCell.self, forCellReuseIdentifier: StoryCell.reuseIdentifier)
-        tableView.register(HiddenStoryHeaderView.self, forHeaderFooterViewReuseIdentifier: HiddenStoryHeaderView.reuseIdentifier)
+        tableView.register(HiddenStoryHeaderCell.self, forCellReuseIdentifier: HiddenStoryHeaderCell.reuseIdentifier)
         tableView.separatorStyle = .none
         tableView.rowHeight = UITableView.automaticDimension
         tableView.estimatedRowHeight = 116
@@ -131,20 +134,27 @@ class StoriesViewController: OWSViewController, StoryListDataSourceDelegate {
                 guard let cell = self.tableView.cellForRow(at: indexPath) as? MyStoryCell else { continue }
                 guard let model = dataSource.myStory else { continue }
                 cell.configure(with: model) { [weak self] in self?.showCameraView() }
-            case .visibleStories, .hiddenStories:
+            case .visibleStories:
                 guard let cell = self.tableView.cellForRow(at: indexPath) as? StoryCell else { continue }
                 guard let model = self.model(for: indexPath) else { continue }
                 cell.configure(with: model)
+            case .hiddenStories:
+                let cell = self.tableView.cellForRow(at: indexPath)
+                if
+                    let storyCell = cell as? StoryCell,
+                    let model = self.model(for: indexPath)
+                {
+                    storyCell.configure(with: model)
+                } else if
+                    let headerCell = cell as? HiddenStoryHeaderCell
+                {
+                    headerCell.configure(isCollapsed: dataSource.isHiddenStoriesSectionCollapsed)
+                }
             case .none:
                 owsFailDebug("Unexpected story type")
             }
         }
 
-        // No easy way to get visible headers, but just update the header view since theres only one.
-        (
-            tableView.headerView(forSection: Section.hiddenStories.rawValue) as? HiddenStoryHeaderView
-        )?.configure(isCollapsed: dataSource.isHiddenStoriesSectionCollapsed)
-
         if splitViewController?.isCollapsed == true {
             view.backgroundColor = Theme.backgroundColor
             tableView.backgroundColor = Theme.backgroundColor
@@ -237,7 +247,14 @@ extension StoriesViewController: UITableViewDelegate {
         switch Section(rawValue: indexPath.section) {
         case .myStory:
             navigationController?.pushViewController(MyStoriesViewController(), animated: true)
-        case .visibleStories, .hiddenStories:
+        case .hiddenStories:
+            if indexPath.row == 0 {
+                // Tapping the collapsing header.
+                dataSource.isHiddenStoriesSectionCollapsed = !dataSource.isHiddenStoriesSectionCollapsed
+            } else {
+                fallthrough
+            }
+        case .visibleStories:
             guard let model = model(for: indexPath) else {
                 owsFailDebug("Missing model for story")
                 return
@@ -286,7 +303,8 @@ extension StoriesViewController: UITableViewDataSource {
         case .visibleStories:
             return dataSource.visibleStories[safe: indexPath.row]
         case .hiddenStories:
-            return dataSource.hiddenStories[safe: indexPath.row]
+            // Offset by 1 to account for the header cell.
+            return dataSource.hiddenStories[safe: indexPath.row - 1]
         case .myStory, .none:
             return nil
         }
@@ -303,7 +321,8 @@ extension StoriesViewController: UITableViewDataSource {
         } else if
             !dataSource.isHiddenStoriesSectionCollapsed,
             let hiddenRow = dataSource.hiddenStories.firstIndex(where: { $0.context == context }) {
-            indexPath = IndexPath(row: hiddenRow, section: Section.hiddenStories.rawValue)
+            // Offset by 1 to account for the header cell.
+            indexPath = IndexPath(row: hiddenRow + 1, section: Section.hiddenStories.rawValue)
         } else {
             return nil
         }
@@ -321,7 +340,18 @@ extension StoriesViewController: UITableViewDataSource {
             }
             cell.configure(with: myStoryModel) { [weak self] in self?.showCameraView() }
             return cell
-        case .visibleStories, .hiddenStories:
+        case .hiddenStories:
+            if indexPath.row == 0 {
+                let cell = tableView.dequeueReusableCell(
+                    withIdentifier: HiddenStoryHeaderCell.reuseIdentifier,
+                    for: indexPath
+                ) as! HiddenStoryHeaderCell
+                cell.configure(isCollapsed: dataSource.isHiddenStoriesSectionCollapsed)
+                return cell
+            } else {
+                fallthrough
+            }
+        case .visibleStories:
             let cell = tableView.dequeueReusableCell(withIdentifier: StoryCell.reuseIdentifier) as! StoryCell
             guard let model = model(for: indexPath) else {
                 owsFailDebug("Missing model for story")
@@ -335,37 +365,6 @@ extension StoriesViewController: UITableViewDataSource {
         }
     }
 
-    func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -> UIView? {
-        switch Section(rawValue: section) {
-        case .myStory, .visibleStories, .none:
-            return nil
-        case .hiddenStories:
-            guard !dataSource.hiddenStories.isEmpty else {
-                return nil
-            }
-            let header = tableView.dequeueReusableHeaderFooterView(
-                withIdentifier: HiddenStoryHeaderView.reuseIdentifier
-            ) as! HiddenStoryHeaderView
-            header.configure(isCollapsed: dataSource.isHiddenStoriesSectionCollapsed)
-            header.tapHandler = { [weak self] in
-                guard let strongSelf = self else {
-                    return
-                }
-                strongSelf.dataSource.isHiddenStoriesSectionCollapsed = !strongSelf.dataSource.isHiddenStoriesSectionCollapsed
-            }
-            return header
-        }
-    }
-
-    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
-        switch Section(rawValue: section) {
-        case .myStory, .visibleStories, .none:
-            return 0
-        case .hiddenStories:
-            return dataSource.hiddenStories.isEmpty ? 0 : 44
-        }
-    }
-
     func numberOfSections(in tableView: UITableView) -> Int {
         return 3
     }
@@ -379,7 +378,10 @@ extension StoriesViewController: UITableViewDataSource {
         case .visibleStories:
             return dataSource.visibleStories.count
         case .hiddenStories:
-            return dataSource.isHiddenStoriesSectionCollapsed ? 0 : dataSource.hiddenStories.count
+            guard !dataSource.hiddenStories.isEmpty else {
+                return 0
+            }
+            return dataSource.isHiddenStoriesSectionCollapsed ? 1 : dataSource.hiddenStories.count + 1
         case .none:
             owsFailDebug("Unexpected section \(section)")
             return 0
@@ -397,118 +399,17 @@ extension StoriesViewController: ContextMenuInteractionDelegate {
     func contextMenuInteraction(_ interaction: ContextMenuInteraction, configurationForMenuAtLocation location: CGPoint) -> ContextMenuConfiguration? {
         guard
             let indexPath = tableView.indexPathForRow(at: location),
-            let model = model(for: indexPath)
+            let model = model(for: indexPath),
+            let cell = tableView.cellForRow(at: indexPath)
         else {
             return nil
         }
 
-        return .init(identifier: indexPath as NSCopying) { _ in
-
-            var actions = [ContextMenuAction]()
-
-            actions.append(StoryHidingManager(model: model).contextMenuAction(forPresentingController: self))
-
-            func appendForwardAction() {
-                actions.append(.init(
-                    title: NSLocalizedString(
-                        "STORIES_FORWARD_STORY_ACTION",
-                        comment: "Context menu action to forward the selected story"),
-                    image: Theme.iconImage(.messageActionForward),
-                    handler: { [weak self] _ in
-                        guard let self = self else { return }
-                        switch model.latestMessageAttachment {
-                        case .file(let attachment):
-                            ForwardMessageViewController.present([attachment], from: self, delegate: self)
-                        case .text:
-                            OWSActionSheets.showActionSheet(title: LocalizationNotNeeded("Forwarding text stories is not yet implemented."))
-                        case .missing:
-                            owsFailDebug("Unexpectedly missing attachment for story.")
-                        }
-                    }))
-            }
-
-            func appendShareAction() {
-                actions.append(.init(
-                    title: NSLocalizedString(
-                        "STORIES_SHARE_STORY_ACTION",
-                        comment: "Context menu action to share the selected story"),
-                    image: Theme.iconImage(.messageActionShare),
-                    handler: { [weak self] _ in
-                        guard let self = self else { return }
-                        guard let cell = self.tableView.cellForRow(at: indexPath) else { return }
-
-                        switch model.latestMessageAttachment {
-                        case .file(let attachment):
-                            guard let attachment = attachment as? TSAttachmentStream else {
-                                return owsFailDebug("Unexpectedly tried to share undownloaded attachment")
-                            }
-                            AttachmentSharing.showShareUI(forAttachment: attachment, sender: cell)
-                        case .text(let attachment):
-                            if let url = attachment.preview?.urlString {
-                                AttachmentSharing.showShareUI(for: URL(string: url)!, sender: cell)
-                            } else if let text = attachment.text {
-                                AttachmentSharing.showShareUI(forText: text, sender: cell)
-                            }
-                        case .missing:
-                            owsFailDebug("Unexpectedly missing attachment for story.")
-                        }
-                    }))
-            }
-
-            // Don't add sharing and forwarding actions for system stories.
-            if model.messages.first?.authorAddress.isSystemStoryAddress != true {
-                switch model.latestMessageAttachment {
-                case .file(let attachment):
-                    guard attachment is TSAttachmentStream else { break }
-                    appendForwardAction()
-                    appendShareAction()
-                case .text:
-                    appendForwardAction()
-                    appendShareAction()
-                case .missing:
-                    owsFailDebug("Unexpectedly missing attachment for story.")
-                }
-            }
-
-            let goToChatAction: ContextMenuActionHandler?
-            switch model.context {
-            case .groupId(let groupId):
-                goToChatAction = { _ in
-                    guard let thread = Self.databaseStorage.read(block: { TSGroupThread.fetch(groupId: groupId, transaction: $0) }) else {
-                        return owsFailDebug("Unexpectedly missing thread for group story")
-                    }
-                    Self.signalApp.presentConversation(for: thread, action: .compose, animated: true)
-                }
-            case .authorUuid(let authorUuid):
-                guard !authorUuid.asSignalServiceAddress().isSystemStoryAddress else {
-                    goToChatAction = nil
-                    break
-                }
-                goToChatAction = { _ in
-                    guard let thread = Self.databaseStorage.read(
-                        block: { TSContactThread.getWithContactAddress(SignalServiceAddress(uuid: authorUuid), transaction: $0) }
-                    ) else {
-                        return owsFailDebug("Unexpectedly missing thread for 1:1 story")
-                    }
-                    Self.signalApp.presentConversation(for: thread, action: .compose, animated: true)
-                }
-            case .privateStory:
-                owsFailDebug("Unexpectedly had private story on stories list")
-                goToChatAction = nil
-            case .none:
-                owsFailDebug("Unexpectedly missing context for story")
-                goToChatAction = nil
-            }
-            if let goToChatAction = goToChatAction {
-                actions.append(.init(
-                    title: NSLocalizedString(
-                        "STORIES_GO_TO_CHAT_ACTION",
-                        comment: "Context menu action to open the chat associated with the selected story"),
-                    image: Theme.iconImage(.open24),
-                    handler: goToChatAction
-                ))
-            }
-
+        return .init(identifier: indexPath as NSCopying) { [weak self] _ in
+            let actions = self?.contextMenuGenerator.contextMenuActions(
+                for: model,
+                sourceView: cell
+            ) ?? []
             return .init(actions)
         }
     }
@@ -549,20 +450,3 @@ extension StoriesViewController: ContextMenuInteractionDelegate {
 
     func contextMenuInteraction(_ interaction: ContextMenuInteraction, didEndForConfiguration configuration: ContextMenuConfiguration) {}
 }
-
-extension StoriesViewController: ForwardMessageDelegate {
-    public func forwardMessageFlowDidComplete(items: [ForwardMessageItem],
-                                              recipientThreads: [TSThread]) {
-        AssertIsOnMainThread()
-
-        self.dismiss(animated: true) {
-            ForwardMessageViewController.finalizeForward(items: items,
-                                                         recipientThreads: recipientThreads,
-                                                         fromViewController: self)
-        }
-    }
-
-    public func forwardMessageFlowDidCancel() {
-        self.dismiss(animated: true)
-    }
-}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/StoryListDataSource.swift b/Signal/src/ViewControllers/HomeView/Stories/StoryListDataSource.swift
index 0ac0d00c9be..b95b8dad55e 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/StoryListDataSource.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/StoryListDataSource.swift
@@ -368,10 +368,19 @@ class StoryListDataSource: NSObject, Dependencies {
             return changedModels + modelsFromNewContexts
         }.sorted(by: Self.sortStoryModels)
 
+        let newIsHiddenStoriesSectionCollapsed: Bool
+        if !oldViewModel.isHiddenStoriesSectionCollapsed {
+            newIsHiddenStoriesSectionCollapsed = false
+        } else if oldViewModel.hiddenStories.isEmpty && newModels.contains(where: \.isHidden) {
+            newIsHiddenStoriesSectionCollapsed = false
+        } else {
+            newIsHiddenStoriesSectionCollapsed = true
+        }
+
         let newViewModel = StoryListViewModel(
             myStory: myStoryModel ?? oldViewModel.myStory,
             stories: newModels,
-            isHiddenStoriesSectionCollapsed: oldViewModel.isHiddenStoriesSectionCollapsed
+            isHiddenStoriesSectionCollapsed: newIsHiddenStoriesSectionCollapsed
         )
 
         let visibleBatchUpdates = try BatchUpdate.build(
@@ -453,10 +462,10 @@ class StoryListDataSource: NSObject, Dependencies {
         }
 
         if changes.oldModel.myStory == nil, changes.newModel.myStory != nil {
-            tableView.insertRows(at: [IndexPath(row: 0, section: Section.myStory.rawValue)], with: .automatic)
+            tableView.insertRows(at: [IndexPath(row: 0, section: Section.myStory.rawValue)], with: .fade)
         } else if changes.oldModel.myStory != nil, changes.newModel.myStory == nil {
             // My story should never go away after being loaded, but for the sake of completeness...
-            tableView.deleteRows(at: [IndexPath(row: 0, section: Section.myStory.rawValue)], with: .automatic)
+            tableView.deleteRows(at: [IndexPath(row: 0, section: Section.myStory.rawValue)], with: .fade)
         } else if changes.myStoryChanged {
             tableView.reloadRows(at: [IndexPath(row: 0, section: Section.myStory.rawValue)], with: .none)
         }
@@ -473,37 +482,71 @@ class StoryListDataSource: NSObject, Dependencies {
             return
         }
 
+        switch (changes.oldModel.hiddenStories.isEmpty, changes.newModel.hiddenStories.isEmpty) {
+        case (false, false), (true, true):
+            // Just reload if we have to.
+            if changes.oldModel.isHiddenStoriesSectionCollapsed != changes.newModel.isHiddenStoriesSectionCollapsed {
+                // If the cell is visible, reconfigure it directly without reloading.
+                let path = IndexPath(row: 0, section: Section.hiddenStories.rawValue)
+                if
+                    (tableView.indexPathsForVisibleRows ?? []).contains(path),
+                    let visibleCell = tableView.cellForRow(at: path) as? HiddenStoryHeaderCell
+                {
+                    visibleCell.configure(isCollapsed: changes.newModel.isHiddenStoriesSectionCollapsed)
+                } else {
+                    tableView.reloadRows(at: [path], with: .none)
+                }
+            }
+        case (true, false):
+            tableView.insertRows(at: [IndexPath(row: 0, section: Section.hiddenStories.rawValue)], with: .fade)
+        case (false, true):
+            tableView.deleteRows(at: [IndexPath(row: 0, section: Section.hiddenStories.rawValue)], with: .fade)
+        }
+
         switch (changes.oldModel.isHiddenStoriesSectionCollapsed, changes.newModel.isHiddenStoriesSectionCollapsed) {
 
         case (false, false):
             // Update the hidden section, it was expanded before and after
-            applyTableViewBatchUpdates(changes.hiddenStoryUpdates, toSection: .hiddenStories, models: changes.newModel.hiddenStories)
+            applyTableViewBatchUpdates(
+                changes.hiddenStoryUpdates.map {
+                    // Offset by 1 to account for the header cell.
+                    switch $0.updateType {
+                    case let .update(oldIndex, newIndex):
+                        return .init(value: $0.value, updateType: .update(oldIndex: oldIndex + 1, newIndex: newIndex + 1))
+                    case let .move(oldIndex, newIndex):
+                        return .init(value: $0.value, updateType: .move(oldIndex: oldIndex + 1, newIndex: newIndex + 1))
+                    case let .insert(newIndex):
+                        return .init(value: $0.value, updateType: .insert(newIndex: newIndex + 1))
+                    case let .delete(oldIndex):
+                        return .init(value: $0.value, updateType: .delete(oldIndex: oldIndex + 1))
+                    }
+                },
+                toSection: .hiddenStories,
+                // Offset by 1 to account for the header cell.
+                models: [changes.newModel.hiddenStories.first].compactMap({ $0 }) + changes.newModel.hiddenStories
+            )
 
         case (true, false):
             // Was collapsed and is now expanded, reload.
             applyTableViewBatchUpdates(
                 changes.newModel.hiddenStories.lazy.enumerated().map {
-                    return .init(value: $1.context, updateType: .insert(newIndex: $0))
+                    // Offset by 1 to account for the header cell.
+                    return .init(value: $1.context, updateType: .insert(newIndex: $0 + 1))
                 },
                 toSection: .hiddenStories,
                 models: changes.newModel.hiddenStories
             )
-            // Unfortunately have to just update the header view directly.
-            (tableView.headerView(forSection: Section.hiddenStories.rawValue) as? HiddenStoryHeaderView)?
-                .configure(isCollapsed: changes.newModel.isHiddenStoriesSectionCollapsed)
 
         case (false, true):
             // Was expanded and is now collapsed, everything counts as a delete.
             applyTableViewBatchUpdates(
                 changes.oldModel.hiddenStories.lazy.enumerated().map {
-                    return .init(value: $1.context, updateType: .delete(oldIndex: $0))
+                    // Offset by 1 to account for the header cell.
+                    return .init(value: $1.context, updateType: .delete(oldIndex: $0 + 1))
                 },
                 toSection: .hiddenStories,
                 models: changes.oldModel.hiddenStories
             )
-            // Unfortunately have to just update the header view directly.
-            (tableView.headerView(forSection: Section.hiddenStories.rawValue) as? HiddenStoryHeaderView)?
-                .configure(isCollapsed: changes.newModel.isHiddenStoriesSectionCollapsed)
 
         case (true, true):
             // Was collapsed and is collapsed, so can just ignore any updates.
@@ -524,12 +567,12 @@ class StoryListDataSource: NSObject, Dependencies {
         for update in updates {
             switch update.updateType {
             case .delete(let oldIndex):
-                tableView.deleteRows(at: [IndexPath(row: oldIndex, section: section.rawValue)], with: .automatic)
+                tableView.deleteRows(at: [IndexPath(row: oldIndex, section: section.rawValue)], with: .fade)
             case .insert(let newIndex):
-                tableView.insertRows(at: [IndexPath(row: newIndex, section: section.rawValue)], with: .automatic)
+                tableView.insertRows(at: [IndexPath(row: newIndex, section: section.rawValue)], with: .fade)
             case .move(let oldIndex, let newIndex):
-                tableView.deleteRows(at: [IndexPath(row: oldIndex, section: section.rawValue)], with: .automatic)
-                tableView.insertRows(at: [IndexPath(row: newIndex, section: section.rawValue)], with: .automatic)
+                tableView.deleteRows(at: [IndexPath(row: oldIndex, section: section.rawValue)], with: .fade)
+                tableView.insertRows(at: [IndexPath(row: newIndex, section: section.rawValue)], with: .fade)
             case .update(_, let newIndex):
                 // If the cell is visible, reconfigure it directly without reloading.
                 let path = IndexPath(row: newIndex, section: section.rawValue)
diff --git a/Signal/src/ViewControllers/HomeView/Stories/StoryViewModel.swift b/Signal/src/ViewControllers/HomeView/Stories/StoryViewModel.swift
index 661eff20e58..94403b4065e 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/StoryViewModel.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/StoryViewModel.swift
@@ -15,6 +15,7 @@ struct StoryViewModel: Dependencies {
     // just in a separate section thats collapsed by default.
     let isHidden: Bool
 
+    let latestMessage: StoryMessage
     let latestMessageAttachment: StoryThumbnailView.Attachment
     let hasReplies: Bool
     let latestMessageName: String
@@ -43,6 +44,7 @@ struct StoryViewModel: Dependencies {
             throw OWSAssertionError("At least one message is required.")
         }
 
+        self.latestMessage = latestMessage
         self.context = latestMessage.context
         self.hasReplies = InteractionFinder.hasReplies(for: sortedFilteredMessages, transaction: transaction)
 
diff --git a/SignalUI/UI/AttachmentSharing.h b/SignalUI/UI/AttachmentSharing.h
index 16da81b4d7c..b3880b98974 100644
--- a/SignalUI/UI/AttachmentSharing.h
+++ b/SignalUI/UI/AttachmentSharing.h
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 #import <UIKit/UIKit.h>
@@ -15,6 +15,14 @@ typedef void (^AttachmentSharingCompletion)(void);
 + (void)showShareUIForAttachment:(TSAttachmentStream *)stream sender:(nullable id)sender;
 + (void)showShareUIForAttachments:(NSArray<TSAttachmentStream *> *)attachments sender:(nullable id)sender;
 
++ (void)showShareUIForAttachment:(TSAttachmentStream *)stream
+                          sender:(nullable id)sender
+                      completion:(nullable AttachmentSharingCompletion)completion;
+
++ (void)showShareUIForAttachments:(NSArray<TSAttachmentStream *> *)attachments
+                           sender:(nullable id)sender
+                       completion:(nullable AttachmentSharingCompletion)completion;
+
 + (void)showShareUIForURL:(NSURL *)url sender:(nullable id)sender;
 
 + (void)showShareUIForURL:(NSURL *)url
diff --git a/SignalUI/UI/AttachmentSharing.m b/SignalUI/UI/AttachmentSharing.m
index 5eda56791ed..c54b3520d4f 100644
--- a/SignalUI/UI/AttachmentSharing.m
+++ b/SignalUI/UI/AttachmentSharing.m
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 #import "AttachmentSharing.h"
@@ -21,6 +21,15 @@ + (void)showShareUIForAttachment:(TSAttachmentStream *)stream sender:(nullable i
     [self showShareUIForAttachments:@[ stream ] sender:sender];
 }
 
++ (void)showShareUIForAttachment:(TSAttachmentStream *)stream
+                          sender:(nullable id)sender
+                      completion:(nullable AttachmentSharingCompletion)completion
+{
+    OWSAssertDebug(stream);
+
+    [self showShareUIForAttachments:@[ stream ] sender:sender completion:completion];
+}
+
 + (void)showShareUIForAttachments:(NSArray<TSAttachmentStream *> *)attachments sender:(nullable id)sender
 {
     OWSAssertDebug(attachments.count > 0);
@@ -28,6 +37,15 @@ + (void)showShareUIForAttachments:(NSArray<TSAttachmentStream *> *)attachments s
     [self showShareUIForActivityItems:attachments sender:sender completion:nil];
 }
 
++ (void)showShareUIForAttachments:(NSArray<TSAttachmentStream *> *)attachments
+                           sender:(nullable id)sender
+                       completion:(nullable AttachmentSharingCompletion)completion
+{
+    OWSAssertDebug(attachments.count > 0);
+
+    [self showShareUIForActivityItems:attachments sender:sender completion:completion];
+}
+
 + (void)showShareUIForURL:(NSURL *)url sender:(nullable id)sender
 {
     [self showShareUIForURL:url sender:sender completion:nil];
