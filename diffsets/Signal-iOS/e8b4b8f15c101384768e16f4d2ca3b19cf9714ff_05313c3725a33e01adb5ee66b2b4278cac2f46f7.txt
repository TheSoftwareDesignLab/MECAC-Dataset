diff --git a/Scripts/bump_build_tag.py b/Scripts/bump_build_tag.py
index 67604bc03a0..36753f08270 100755
--- a/Scripts/bump_build_tag.py
+++ b/Scripts/bump_build_tag.py
@@ -8,19 +8,20 @@
 import feature_flags_common
 from datetime import date
 
+
 def fail(message):
     file_name = __file__
     current_line_no = inspect.stack()[1][2]
     current_function_name = inspect.stack()[1][3]
-    print('Failure in:', file_name, current_line_no, current_function_name)
+    print("Failure in:", file_name, current_line_no, current_function_name)
     print(message)
     sys.exit(1)
 
 
 def execute_command(command):
     try:
-        print(' '.join(command))
-        output = subprocess.check_output(command)
+        print(" ".join(command))
+        output = subprocess.check_output(command, text=True)
         if output:
             print(output)
     except subprocess.CalledProcessError as e:
@@ -35,7 +36,7 @@ def find_project_root():
         # print 'path', path
         if not os.path.exists(path):
             break
-        git_path = os.path.join(path, '.git')
+        git_path = os.path.join(path, ".git")
         if os.path.exists(git_path):
             return path
         new_path = os.path.abspath(os.path.dirname(path))
@@ -43,36 +44,36 @@ def find_project_root():
             break
         path = new_path
 
-    fail('Could not find project root path')
+    fail("Could not find project root path")
 
 
 def is_valid_version_1(value):
-    regex = re.compile(r'^(\d+)$')
+    regex = re.compile(r"^(\d+)$")
     match = regex.search(value)
     return match is not None
 
 
 def is_valid_version_3(value):
-    regex = re.compile(r'^(\d+)\.(\d+)\.(\d+)$')
+    regex = re.compile(r"^(\d+)\.(\d+)\.(\d+)$")
     match = regex.search(value)
     return match is not None
 
 
 def is_valid_version_4(value):
-    regex = re.compile(r'^(\d+)\.(\d+)\.(\d+).(\d+)$')
+    regex = re.compile(r"^(\d+)\.(\d+)\.(\d+).(\d+)$")
     match = regex.search(value)
     return match is not None
 
 
 def set_versions(plist_file_path, release_version, build_version_1, build_version_4):
     if not is_valid_version_3(release_version):
-        fail('Invalid release version: %s' % release_version)
+        fail("Invalid release version: %s" % release_version)
     if not is_valid_version_1(build_version_1):
-        fail('Invalid build version 1: %s' % build_version_1)
+        fail("Invalid build version 1: %s" % build_version_1)
     if not is_valid_version_4(build_version_4):
-        fail('Invalid build version 4: %s' % build_version_4)
+        fail("Invalid build version 4: %s" % build_version_4)
 
-    with open(plist_file_path, 'rt') as f:
+    with open(plist_file_path, "rt") as f:
         text = f.read()
     # print 'text', text
 
@@ -80,36 +81,43 @@ def set_versions(plist_file_path, release_version, build_version_1, build_versio
     #
     # <key>CFBundleShortVersionString</key>
     # <string>2.20.0</string>
-    file_regex = re.compile(r'<key>CFBundleShortVersionString</key>\s*<string>([\d\.]+)</string>', re.MULTILINE)
+    file_regex = re.compile(
+        r"<key>CFBundleShortVersionString</key>\s*<string>([\d\.]+)</string>",
+        re.MULTILINE,
+    )
     file_match = file_regex.search(text)
     # print 'match', match
     if not file_match:
-        fail('Could not parse .plist')
-    text = text[:file_match.start(1)] + release_version + text[file_match.end(1):]
+        fail("Could not parse .plist")
+    text = text[: file_match.start(1)] + release_version + text[file_match.end(1) :]
 
     # CFBundleVersion is the build version 1.
     #
     # <key>CFBundleVersion</key>
     # <string>3</string>
-    file_regex = re.compile(r'<key>CFBundleVersion</key>\s*<string>([\d\.]+)</string>', re.MULTILINE)
+    file_regex = re.compile(
+        r"<key>CFBundleVersion</key>\s*<string>([\d\.]+)</string>", re.MULTILINE
+    )
     file_match = file_regex.search(text)
     # print 'match', match
     if not file_match:
-        fail('Could not parse .plist')
-    text = text[:file_match.start(1)] + build_version_1 + text[file_match.end(1):]
+        fail("Could not parse .plist")
+    text = text[: file_match.start(1)] + build_version_1 + text[file_match.end(1) :]
 
     # The build version 4.
     #
     # <key>OWSBundleVersion4</key>
     # <string>2.20.0.3</string>
-    file_regex = re.compile(r'<key>OWSBundleVersion4</key>\s*<string>([\d\.]+)</string>', re.MULTILINE)
+    file_regex = re.compile(
+        r"<key>OWSBundleVersion4</key>\s*<string>([\d\.]+)</string>", re.MULTILINE
+    )
     file_match = file_regex.search(text)
     # print 'match', match
     if not file_match:
-        fail('Could not parse .plist')
-    text = text[:file_match.start(1)] + build_version_4 + text[file_match.end(1):]
+        fail("Could not parse .plist")
+    text = text[: file_match.start(1)] + build_version_4 + text[file_match.end(1) :]
 
-    with open(plist_file_path, 'wt') as f:
+    with open(plist_file_path, "wt") as f:
         f.write(text)
 
 
@@ -117,19 +125,18 @@ def set_versions(plist_file_path, release_version, build_version_1, build_versio
 class Version1:
     def __init__(self, build):
         self.build = build
-        
+
     def formatted(self):
         return str(self.build)
 
 
-
 # Represents a version string with 3 dotted values, e.g. 1.2.3.
 class Version3:
     def __init__(self, major, minor, patch):
         self.major = major
         self.minor = minor
         self.patch = patch
-        
+
     def formatted(self):
         return str(self.major) + "." + str(self.minor) + "." + str(self.patch)
 
@@ -141,59 +148,67 @@ def __init__(self, major, minor, patch, build):
         self.minor = minor
         self.patch = patch
         self.build = build
-        
+
     def formatted(self):
-        return str(self.major) + "." + str(self.minor) + "." + str(self.patch) + "." + str(self.build)
+        return (
+            str(self.major)
+            + "."
+            + str(self.minor)
+            + "."
+            + str(self.patch)
+            + "."
+            + str(self.build)
+        )
 
     def asVersion3(self):
         return Version3(self.major, self.minor, self.patch)
 
 
 def parse_version_4(text):
-   # print 'text', text
-   regex = re.compile(r'^(\d+)\.(\d+)\.(\d+)\.?(\d+)?$')
-   match = regex.search(text)
-   # print 'match', match
-   if not match:
-       fail('Could not parse .plist')
-   if len(match.groups()) < 3 or len(match.groups()) > 4:
-       fail('Could not parse .plist')
-   major = int(match.group(1))
-   minor = int(match.group(2))
-   patch = int(match.group(3))
-   if match.group(4) != None:
-       build = int(match.group(4))
-   else:
-       build = 0
-
-   version = Version4(major, minor, patch, build)
-   # Verify that roundtripping yields the same value (or a version3 equivalent)
-   if version.formatted() != text and version.asVersion3().formatted() != text:
-       fail('Could not parse .plist')
-   
-   return version
+    # print 'text', text
+    regex = re.compile(r"^(\d+)\.(\d+)\.(\d+)\.?(\d+)?$")
+    match = regex.search(text)
+    # print 'match', match
+    if not match:
+        fail("Could not parse .plist")
+    if len(match.groups()) < 3 or len(match.groups()) > 4:
+        fail("Could not parse .plist")
+    major = int(match.group(1))
+    minor = int(match.group(2))
+    patch = int(match.group(3))
+    if match.group(4) != None:
+        build = int(match.group(4))
+    else:
+        build = 0
+
+    version = Version4(major, minor, patch, build)
+    # Verify that roundtripping yields the same value (or a version3 equivalent)
+    if version.formatted() != text and version.asVersion3().formatted() != text:
+        fail("Could not parse .plist")
+
+    return version
 
 
 def parse_version_1(text):
-   build = int(text)
+    build = int(text)
+
+    version = Version1(build)
 
-   version = Version1(build)
-   
-   # Verify that roundtripping yields the same value.
-   if version.formatted() != text:
-       fail('Could not parse .plist')
-   
-   return version
+    # Verify that roundtripping yields the same value.
+    if version.formatted() != text:
+        fail("Could not parse .plist")
+
+    return version
 
 
 def get_versions(plist_file_path):
-    with open(plist_file_path, 'rt') as f:
+    with open(plist_file_path, "rt") as f:
         text = f.read()
     # print 'text', text
 
     # CFBundleShortVersionString identifies the release track.
     # CFBundleVersion uniqely identifies the build within the release track.
-    #  
+    #
     # Previously, we used version strings like this:
     #
     # <key>CFBundleShortVersionString</key>
@@ -215,30 +230,36 @@ def get_versions(plist_file_path):
     # * https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundleshortversionstring
     # * https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundleversion
     # * https://developer.apple.com/library/archive/technotes/tn2420/_index.html
-    release_version_regex = re.compile(r'<key>CFBundleShortVersionString</key>\s*<string>(\d+\.\d+\.\d+)</string>', re.MULTILINE)
+    release_version_regex = re.compile(
+        r"<key>CFBundleShortVersionString</key>\s*<string>(\d+\.\d+\.\d+)</string>",
+        re.MULTILINE,
+    )
     release_version_match = release_version_regex.search(text)
     # print 'match', match
     if not release_version_match:
-        fail('Could not parse .plist')
+        fail("Could not parse .plist")
 
-    build_version_1_regex = re.compile(r'<key>CFBundleVersion</key>\s*<string>(\d+)</string>', re.MULTILINE)
+    build_version_1_regex = re.compile(
+        r"<key>CFBundleVersion</key>\s*<string>(\d+)</string>", re.MULTILINE
+    )
     build_version_1_match = build_version_1_regex.search(text)
     # print 'match', match
     if not build_version_1_match:
-        fail('Could not parse .plist')
+        fail("Could not parse .plist")
 
     release_version_str = release_version_match.group(1)
-    print('CFBundleShortVersionString:', release_version_str)
+    print("CFBundleShortVersionString:", release_version_str)
     release_version = parse_version_4(release_version_str).asVersion3()
-    print('old_release_version:', release_version.formatted())
+    print("old_release_version:", release_version.formatted())
 
     build_version_1_str = build_version_1_match.group(1)
-    print('CFBundleVersion:', build_version_1_str)
+    print("CFBundleVersion:", build_version_1_str)
     build_version_1 = parse_version_1(build_version_1_str)
-    print('old_build_version_1:', build_version_1.formatted())
+    print("old_build_version_1:", build_version_1.formatted())
 
     return release_version, build_version_1
 
+
 def get_tag_variant(args):
     is_internal = args.internal
     is_nightly = args.nightly
@@ -263,7 +284,6 @@ def get_tag_variant(args):
         print("Unrecognized feature flag: " + current_flag)
         feature_flag_tag = None
 
-
     if is_nightly or feature_flag_tag == None:
         # Just trust the tag variant specified via argument if:
         # - It's a nightly build. Those are automated and we shouldn't bug a script with interactive input requests
@@ -275,24 +295,41 @@ def get_tag_variant(args):
         # A mismatch! Let's check with the user to see if they really wanted
         # a tag variant that matched the current feature flag.
         argument_tag_string = argument_tag if len(argument_tag) > 0 else "production"
-        feature_flag_tag_string = feature_flag_tag if len(feature_flag_tag) > 0 else "production"
+        feature_flag_tag_string = (
+            feature_flag_tag if len(feature_flag_tag) > 0 else "production"
+        )
 
-        print("Feature flag mismatch! Arguments specify a " + argument_tag_string + " tag but the current feature flag indicates a " + feature_flag_tag_string + " tag may be more appropriate.")
-        prefer_feature_flag = input("Proceed with a " + feature_flag_tag_string + " instead? (Y/n) ")
+        print(
+            "Feature flag mismatch! Arguments specify a "
+            + argument_tag_string
+            + " tag but the current feature flag indicates a "
+            + feature_flag_tag_string
+            + " tag may be more appropriate."
+        )
+        prefer_feature_flag = input(
+            "Proceed with a " + feature_flag_tag_string + " instead? (Y/n) "
+        )
 
         if len(prefer_feature_flag) == 0 or prefer_feature_flag[0] in "Yy":
             return feature_flag_tag
         else:
             return argument_tag
 
-if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Precommit cleanup script.')
-    parser.add_argument('--version', help='used for starting a new version.')
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="Precommit cleanup script.")
+    parser.add_argument("--version", help="used for starting a new version.")
 
     type_group = parser.add_mutually_exclusive_group()
-    type_group.add_argument('--internal', action='store_true', help='used to indicate throwaway builds.')
-    type_group.add_argument('--nightly', action='store_true', help='used to indicate nightly builds.')
-    type_group.add_argument('--beta', action='store_true', help='used to indicate beta builds.')
+    type_group.add_argument(
+        "--internal", action="store_true", help="used to indicate throwaway builds."
+    )
+    type_group.add_argument(
+        "--nightly", action="store_true", help="used to indicate nightly builds."
+    )
+    type_group.add_argument(
+        "--beta", action="store_true", help="used to indicate beta builds."
+    )
 
     args = parser.parse_args()
     tag_variant = get_tag_variant(args)
@@ -300,26 +337,28 @@ def get_tag_variant(args):
     project_root_path = find_project_root()
     # print 'project_root_path', project_root_path
     # plist_path
-    main_plist_path = os.path.join(project_root_path, 'Signal', 'Signal-Info.plist')
+    main_plist_path = os.path.join(project_root_path, "Signal", "Signal-Info.plist")
     if not os.path.exists(main_plist_path):
-        fail('Could not find main app info .plist')
+        fail("Could not find main app info .plist")
 
-    sae_plist_path = os.path.join(project_root_path, 'SignalShareExtension', 'Info.plist')
+    sae_plist_path = os.path.join(
+        project_root_path, "SignalShareExtension", "Info.plist"
+    )
     if not os.path.exists(sae_plist_path):
-        fail('Could not find share extension info .plist')
+        fail("Could not find share extension info .plist")
 
-    nse_plist_path = os.path.join(project_root_path, 'SignalNSE', 'Info.plist')
+    nse_plist_path = os.path.join(project_root_path, "SignalNSE", "Info.plist")
     if not os.path.exists(nse_plist_path):
-        fail('Could not find NSE info .plist')
+        fail("Could not find NSE info .plist")
 
-    output = subprocess.check_output(['git', 'status', '--porcelain'])
+    output = subprocess.check_output(["git", "status", "--porcelain"], text=True)
     if len(output.strip()) > 0:
         print(output)
-        fail('Git repository has untracked files.')
-    output = subprocess.check_output(['git', 'diff', '--shortstat'])
+        fail("Git repository has untracked files.")
+    output = subprocess.check_output(["git", "diff", "--shortstat"], text=True)
     if len(output.strip()) > 0:
         print(output)
-        fail('Git repository has untracked files.')
+        fail("Git repository has untracked files.")
 
     # Ensure .plist is in xml format, not binary.
     plist_paths = [
@@ -328,9 +367,11 @@ def get_tag_variant(args):
         nse_plist_path,
     ]
     for plist_path in plist_paths:
-        print('plist_path:', plist_path)
-            
-        output = subprocess.check_output(['plutil', '-convert', 'xml1', plist_path])
+        print("plist_path:", plist_path)
+
+        output = subprocess.check_output(
+            ["plutil", "-convert", "xml1", plist_path], text=True
+        )
         # print 'output', output
 
     # ---------------
@@ -347,7 +388,7 @@ def get_tag_variant(args):
         new_build_version_1 = Version1(new_build_version_4.build)
         new_release_version_3 = new_build_version_4.asVersion3()
         # print 'new_release_version_3:', new_release_version_3.formatted()
-        
+
     else:
         # Bump patch.
         new_release_version_3 = old_release_version
@@ -355,10 +396,10 @@ def get_tag_variant(args):
         new_build_version_4 = Version4(
             new_release_version_3.major,
             new_release_version_3.minor,
-            new_release_version_3.patch, 
-            old_build_version_1.build + 1
+            new_release_version_3.patch,
+            old_build_version_1.build + 1,
         )
-        
+
     new_release_version_3 = new_release_version_3.formatted()
     new_build_version_1 = new_build_version_1.formatted()
     new_build_version_4 = new_build_version_4.formatted()
@@ -370,17 +411,19 @@ def get_tag_variant(args):
     # new_release_version_3: 5.19.0
     # new_build_version_1: 43
     # new_build_version_4: 5.19.0.43
-    print('new_release_version_3:', new_release_version_3)
-    print('new_build_version_1:', new_build_version_1)
-    print('new_build_version_4:', new_build_version_4)
+    print("new_release_version_3:", new_release_version_3)
+    print("new_build_version_1:", new_build_version_1)
+    print("new_build_version_4:", new_build_version_4)
 
     for plist_path in plist_paths:
-        set_versions(plist_path, new_release_version_3, new_build_version_1, new_build_version_4)
-    
+        set_versions(
+            plist_path, new_release_version_3, new_build_version_1, new_build_version_4
+        )
+
     # ---------------
     # Git
     # ---------------
-    command = ['git', 'add', '.']
+    command = ["git", "add", "."]
     execute_command(command)
 
     if tag_variant == "internal":
@@ -388,17 +431,18 @@ def get_tag_variant(args):
     elif tag_variant == "beta":
         commit_message = '"Bump build to %s." (Beta)' % new_build_version_4
     elif tag_variant == "nightly":
-        commit_message = '"Bump build to %s." (nightly-%s)' % ( new_build_version_4, date.today().strftime("%m-%d-%Y") )
+        commit_message = '"Bump build to %s." (nightly-%s)' % (
+            new_build_version_4,
+            date.today().strftime("%m-%d-%Y"),
+        )
     else:
         commit_message = '"Bump build to %s."' % new_build_version_4
-    command = ['git', 'commit', '-m', commit_message]
+    command = ["git", "commit", "-m", commit_message]
     execute_command(command)
 
     tag_name = new_build_version_4
     if len(tag_variant) > 0:
-        tag_name += ("-" + tag_variant)
+        tag_name += "-" + tag_variant
 
-    command = ['git', 'tag', tag_name]
+    command = ["git", "tag", tag_name]
     execute_command(command)
-
-
diff --git a/Scripts/debug_log_upload.py b/Scripts/debug_log_upload.py
index b088b69b89f..8fb353e37c2 100755
--- a/Scripts/debug_log_upload.py
+++ b/Scripts/debug_log_upload.py
@@ -4,69 +4,73 @@
 import re
 import subprocess
 import argparse
-import inspect    
+import inspect
 import urllib.request, urllib.error, urllib.parse
 import json
 
+
 def fail(message):
     file_name = __file__
     current_line_no = inspect.stack()[1][2]
     current_function_name = inspect.stack()[1][3]
-    print('Failure in:', file_name, current_line_no, current_function_name)
+    print("Failure in:", file_name, current_line_no, current_function_name)
     print(message)
     sys.exit(1)
 
 
 def execute_command(command):
     try:
-        print(' '.join(command))
-        output = subprocess.check_output(command)
+        print(" ".join(command))
+        output = subprocess.check_output(command, text=True)
         if output:
             print(output)
     except subprocess.CalledProcessError as e:
         print(e.output)
         sys.exit(1)
 
+
 def add_field(curl_command, form_key, form_value):
-    curl_command.append('-F')
+    curl_command.append("-F")
     curl_command.append("%s=%s" % (form_key, form_value))
 
-if __name__ == '__main__':
-    parser = argparse.ArgumentParser(description='Precommit cleanup script.')
-    parser.add_argument('--file', required=True, help='used for starting a new version.')
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description="Precommit cleanup script.")
+    parser.add_argument(
+        "--file", required=True, help="used for starting a new version."
+    )
 
     args = parser.parse_args()
-    
+
     params_response = urllib.request.urlopen("https://debuglogs.org/").read()
-    
+
     params = json.loads(params_response)
-    
-    upload_url = params['url']
-    upload_fields = params['fields']
 
-    upload_key = upload_fields.pop('key')
+    upload_url = params["url"]
+    upload_fields = params["fields"]
+
+    upload_key = upload_fields.pop("key")
     upload_key = upload_key + os.path.splitext(args.file)[1]
-    
-    download_url = 'https://debuglogs.org/' + upload_key
-    print('download_url:', download_url)
-    
-    curl_command = ['curl', '-v', '-i', '-X', 'POST']
+
+    download_url = "https://debuglogs.org/" + upload_key
+    print("download_url:", download_url)
+
+    curl_command = ["curl", "-v", "-i", "-X", "POST"]
 
     # key must appear before other fields
-    add_field(curl_command, 'key', upload_key)
+    add_field(curl_command, "key", upload_key)
     for field_name in upload_fields:
         add_field(curl_command, field_name, upload_fields[field_name])
 
     add_field(curl_command, "content-type", "application/octet-stream")
- 
-    curl_command.append('-F')
+
+    curl_command.append("-F")
     curl_command.append("file=@%s" % (args.file,))
     curl_command.append(upload_url)
-    
-    print(' '.join(curl_command))
 
-    print('Running...')
+    print(" ".join(curl_command))
+
+    print("Running...")
     execute_command(curl_command)
 
-    print('download_url:', download_url)
-    
+    print("download_url:", download_url)
diff --git a/Scripts/feature_flags_common.py b/Scripts/feature_flags_common.py
index 84823aad2e8..865a1224cbf 100755
--- a/Scripts/feature_flags_common.py
+++ b/Scripts/feature_flags_common.py
@@ -3,72 +3,78 @@
 import os
 import re
 import subprocess
-import inspect    
+import inspect
+
 
 def fail(message):
     file_name = __file__
     current_line_no = inspect.stack()[1][2]
     current_function_name = inspect.stack()[1][3]
-    print('Failure in:', file_name, current_line_no, current_function_name)
+    print("Failure in:", file_name, current_line_no, current_function_name)
     print(message)
     sys.exit(1)
 
 
 def execute_command(command):
     try:
-        print(' '.join(command))
-        output = subprocess.check_output(command)
+        print(" ".join(command))
+        output = subprocess.check_output(command, text=True)
         if output:
             print(output)
     except subprocess.CalledProcessError as e:
         print(e.output)
         sys.exit(1)
 
+
 def get_feature_flag():
-    flags_path = 'SignalServiceKit/src/Util/FeatureFlags.swift'
-    fd = open(flags_path, 'rt')
-    regex = re.compile(r'([^\.\s]+)$')
+    flags_path = "SignalServiceKit/src/Util/FeatureFlags.swift"
+    fd = open(flags_path, "rt")
+    regex = re.compile(r"([^\.\s]+)$")
 
     for line in fd:
-        if line.strip().startswith('private let build: FeatureBuild'):
+        if line.strip().startswith("private let build: FeatureBuild"):
             match = regex.search(line)
             if match and match.group(1):
                 return match.group(1)
 
+
 def set_feature_flags(new_flags_level):
-    output = subprocess.check_output(['git', 'status', '--porcelain'])
+    output = subprocess.check_output(["git", "status", "--porcelain"], text=True)
     if len(output.strip()) > 0:
         print(output)
-        fail('Git repository has untracked files.')
-    output = subprocess.check_output(['git', 'diff', '--shortstat'])
+        fail("Git repository has untracked files.")
+    output = subprocess.check_output(["git", "diff", "--shortstat"], text=True)
     if len(output.strip()) > 0:
         print(output)
-        fail('Git repository has untracked files.')
+        fail("Git repository has untracked files.")
 
-    flags_path = 'SignalServiceKit/src/Util/FeatureFlags.swift'
-    with open(flags_path, 'rt') as f:
+    flags_path = "SignalServiceKit/src/Util/FeatureFlags.swift"
+    with open(flags_path, "rt") as f:
         text = f.read()
-    lines = text.split('\n')
+    lines = text.split("\n")
     # lines = [line.strip() for line in lines]
     new_lines = []
     for line in lines:
-        if line.strip().startswith('private let build: FeatureBuild'):
-            line = "private let build: FeatureBuild = OWSIsDebugBuild() ? .dev : .%s" % ( new_flags_level, )
+        if line.strip().startswith("private let build: FeatureBuild"):
+            line = (
+                "private let build: FeatureBuild = OWSIsDebugBuild() ? .dev : .%s"
+                % (new_flags_level,)
+            )
             new_lines.append(line)
         else:
             new_lines.append(line)
-    text = '\n'.join(new_lines)
-    with open(flags_path, 'wt') as f:
+    text = "\n".join(new_lines)
+    with open(flags_path, "wt") as f:
         f.write(text)
 
-    output = subprocess.check_output(['git', 'status', '--porcelain'])
+    output = subprocess.check_output(["git", "status", "--porcelain"], text=True)
     if len(output.strip()) > 0:
         # git add .
-        cmds = ['git', 'add', '.']
+        cmds = ["git", "add", "."]
         execute_command(cmds)
 
         # git commit -m "Feature flags for .beta."
-        cmds = ['git', 'commit', '-m', '"Feature flags for .%s."' % ( new_flags_level, )]
+        cmds = ["git", "commit", "-m", '"Feature flags for .%s."' % (new_flags_level,)]
         execute_command(cmds)
     else:
         print("Feature flags already set to %s, nothing to do" % new_flags_level)
diff --git a/Scripts/reverse_integration_check.py b/Scripts/reverse_integration_check.py
index 8058c7cef04..22adad08617 100755
--- a/Scripts/reverse_integration_check.py
+++ b/Scripts/reverse_integration_check.py
@@ -10,14 +10,22 @@
 
 # logging.basicConfig(level=logging.DEBUG)
 
+
 def is_on_master():
-    output = subprocess.check_output(["git", "rev-parse", "--abbrev-ref", "HEAD"]).strip()
+    output = subprocess.check_output(
+        ["git", "rev-parse", "--abbrev-ref", "HEAD"], text=True
+    ).strip()
     logging.debug("branch output: %s" % output)
     return output == "master"
 
+
 def main():
-    parser = argparse.ArgumentParser(description='Check for unmerged tags.')
-    parser.add_argument('--current-branch', action='store_true', help='if unspecified, the check is only run when on the master branch')
+    parser = argparse.ArgumentParser(description="Check for unmerged tags.")
+    parser.add_argument(
+        "--current-branch",
+        action="store_true",
+        help="if unspecified, the check is only run when on the master branch",
+    )
 
     args = parser.parse_args()
 
@@ -29,105 +37,124 @@ def main():
     else:
         logging.debug("on master branch")
 
-    unmerged_tags_output = subprocess.check_output(["git", "tag", "--no-merged", "HEAD"])
-    unmerged_tags = [line.strip() for line in unmerged_tags_output.split("\n") if len(line) > 0]
+    unmerged_tags_output = subprocess.check_output(
+        ["git", "tag", "--no-merged", "HEAD"], text=True
+    )
+    unmerged_tags = [
+        line.strip() for line in unmerged_tags_output.split("\n") if len(line) > 0
+    ]
 
     logging.debug("All unmerged tags: %s" % unmerged_tags)
 
     # Before this point we weren't always reverse integrating our tags.  As we
     # audit old tags, we can ratchet this version number back.
-    epoch_tag="2.21.0"
+    epoch_tag = "2.21.0"
 
     logging.debug("ignoring tags before epoch_tag: %s" % epoch_tag)
 
-    tags_of_concern = [tag for tag in unmerged_tags if LooseVersion(tag) > LooseVersion(epoch_tag)]
+    tags_of_concern = [
+        tag for tag in unmerged_tags if LooseVersion(tag) > LooseVersion(epoch_tag)
+    ]
 
     # Don't reverse integrate tags for adhoc builds
     tags_of_concern = [tag for tag in tags_of_concern if "adhoc" not in tag]
 
     tags_to_ignore = [
-        '2.23.3.0',
-        '2.23.3.1',
-        '2.26.0.6',
-        '2.26.0.7',
-        '2.26.0.15',
-        '2.26.0.16',
-        '2.29.0.7',
-        '2.29.0.8',
-        '2.29.0.9',
-        '2.29.0.11',
-        '2.30.0.0',
-        '2.30.0.1',
-        '2.30.2.0',
-        '2.46.0.26',
-        '3.0',
-        '3.0.1',
-        '3.0.2',
-        '3.3.1.0',
+        "2.23.3.0",
+        "2.23.3.1",
+        "2.26.0.6",
+        "2.26.0.7",
+        "2.26.0.15",
+        "2.26.0.16",
+        "2.29.0.7",
+        "2.29.0.8",
+        "2.29.0.9",
+        "2.29.0.11",
+        "2.30.0.0",
+        "2.30.0.1",
+        "2.30.2.0",
+        "2.46.0.26",
+        "3.0",
+        "3.0.1",
+        "3.0.2",
+        "3.3.1.0",
         # These tags were from unmerged branches investigating an issue that only reproduced when installed from TF.
-        '2.34.0.10', '2.34.0.11', '2.34.0.12', '2.34.0.13', '2.34.0.15', '2.34.0.16', '2.34.0.17', '2.34.0.18', '2.34.0.19', '2.34.0.20', '2.34.0.6', '2.34.0.7', '2.34.0.8', '2.34.0.9',
-        '2.37.3.0',
-        '2.37.4.0',
+        "2.34.0.10",
+        "2.34.0.11",
+        "2.34.0.12",
+        "2.34.0.13",
+        "2.34.0.15",
+        "2.34.0.16",
+        "2.34.0.17",
+        "2.34.0.18",
+        "2.34.0.19",
+        "2.34.0.20",
+        "2.34.0.6",
+        "2.34.0.7",
+        "2.34.0.8",
+        "2.34.0.9",
+        "2.37.3.0",
+        "2.37.4.0",
         # these were internal release only tags, now we include "-internal" in the tag name to avoid this
-        '2.38.0.2.1',
-        '2.38.0.3.1',
-        '2.38.0.4.1',
+        "2.38.0.2.1",
+        "2.38.0.3.1",
+        "2.38.0.4.1",
         # the work in these tags was moved to the 2.38.1 release instead
-        '2.38.0.12',
-        '2.38.0.13',
-        '2.38.0.14',
-        '2.38.1.3',
+        "2.38.0.12",
+        "2.38.0.13",
+        "2.38.0.14",
+        "2.38.1.3",
         # Looks like this tag was erroneously applied before rebasing.
         # After rebasing, HEAD was retagged with 2.40.0.20
-        '2.40.0.19',
+        "2.40.0.19",
         # Looks like this tag was erroneously applied before rebasing.
         # After rebasing, HEAD was retagged with 2.41.0.2
-        '2.41.0.1',
+        "2.41.0.1",
         # internal builds, not marked as such
-        '2.44.0.0',
-        '2.44.0.3',
-        '2.42.0.6',
-        '2.43.1.0',
-        '2.43.1.1',
-        '2.44.0.1',
-        '2.44.0.2',
-        '2.44.1.1',
-        '3.4.0.8',
-        '2.42.2.1',
-        '2.44.0.14',
-        '2.44.0.4',
-        '2.46.0.22',
-        '2.46.0.23',
-        '2.46.0.24',
-        '2.46.0.5',
-        '3.13.3.11',
-        '3.13.3.4',
-        '3.13.4.0',
-        '3.14.0.26',
-        '3.14.3.0',
-        '3.17.0.3',
-        '3.17.0.5',
-        '3.21.3.0',
-        '3.21.3.1',
-        '3.22.2.0',
-        '3.8.0.10',
-        '3.8.0.29',
-        '3.8.0.31',
-        '3.8.0.32',
-        '3.8.0.9',
-        '3.8.2.2',
-        '3.8.2.4',
-        '5.0.0.29',
-        '5.0.0.73',
-        '5.6.0.10',
-        '3.1.1.0',
-        '3.13.3.6',
-        '3.13.3.8',
-        '5.7.0.0',
-        '5.1.0.0',
-        '5.13.0.14',
-        '5.20.0.27-nightly',
-        '5.21.0.59-beta',
+        "2.44.0.0",
+        "2.44.0.3",
+        "2.42.0.6",
+        "2.43.1.0",
+        "2.43.1.1",
+        "2.44.0.1",
+        "2.44.0.2",
+        "2.44.1.1",
+        "3.4.0.8",
+        "2.42.2.1",
+        "2.44.0.14",
+        "2.44.0.4",
+        "2.46.0.22",
+        "2.46.0.23",
+        "2.46.0.24",
+        "2.46.0.5",
+        "3.13.3.11",
+        "3.13.3.4",
+        "3.13.4.0",
+        "3.14.0.26",
+        "3.14.3.0",
+        "3.17.0.3",
+        "3.17.0.5",
+        "3.21.3.0",
+        "3.21.3.1",
+        "3.22.2.0",
+        "3.8.0.10",
+        "3.8.0.29",
+        "3.8.0.31",
+        "3.8.0.32",
+        "3.8.0.9",
+        "3.8.2.2",
+        "3.8.2.4",
+        "5.0.0.29",
+        "5.0.0.73",
+        "5.6.0.10",
+        "3.1.1.0",
+        "3.13.3.6",
+        "3.13.3.8",
+        "5.7.0.0",
+        "5.1.0.0",
+        "5.13.0.14",
+        "5.20.0.27-nightly",
+        "5.21.0.59-beta",
     ]
     tags_of_concern = [tag for tag in tags_of_concern if tag not in tags_to_ignore]
 
@@ -153,5 +180,6 @@ def main():
     else:
         logging.debug("No unmerged tags newer than epoch. All good!")
 
+
 if __name__ == "__main__":
-        main()
+    main()
