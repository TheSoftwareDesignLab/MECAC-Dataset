diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index b0088b3b3a0..1be5a27576e 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -442,15 +442,6 @@ public class CVLoadCoordinator: NSObject {
 
         firstly { () -> Promise<CVUpdate> in
             loader.loadPromise()
-        }.then { [weak self] (update: CVUpdate) -> Promise<CVUpdate> in
-            firstly { () -> Promise<Void> in
-                guard let self = self else {
-                    throw OWSGenericError("Missing self.")
-                }
-                return self.viewState.waitUntilCanLandLoad()
-            }.map { () -> CVUpdate in
-                update
-            }
         }.then { [weak self] (update: CVUpdate) -> Promise<Void> in
             guard let self = self else {
                 throw OWSGenericError("Missing self.")
@@ -458,21 +449,53 @@ public class CVLoadCoordinator: NSObject {
             guard let delegate = self.delegate else {
                 throw OWSGenericError("Missing delegate.")
             }
-
-            let renderState = update.renderState
-            let oldItemCount = update.lastRenderState.items.count
-            let newItemCount = renderState.items.count
-
-            let updateToken = delegate.willUpdateWithNewRenderState(renderState)
-
-            self.renderState = renderState
-
-            let (promise, resolver) = Promise<Void>.pending()
-            self.loadDidLandResolver = resolver
-            delegate.updateWithNewRenderState(update: update,
-                                              scrollAction: loadRequest.scrollAction,
-                                              updateToken: updateToken)
-            return promise
+            return self.loadLandWhenSafePromise(update: update, delegate: delegate)
+//            return self.loadLandWhenSafePromise {
+//                let renderState = update.renderState
+//                let oldItemCount = update.lastRenderState.items.count
+//                let newItemCount = renderState.items.count
+//
+//                let updateToken = delegate.willUpdateWithNewRenderState(renderState)
+//
+//                self.renderState = renderState
+//
+//                let (promise, resolver) = Promise<Void>.pending()
+//                self.loadDidLandResolver = resolver
+//                delegate.updateWithNewRenderState(update: update,
+//                                                  scrollAction: loadRequest.scrollAction,
+//                                                  updateToken: updateToken)
+//            }
+
+//            firstly { () -> Promise<Void> in
+//                guard let self = self else {
+//                    throw OWSGenericError("Missing self.")
+//                }
+//                return self.viewState.waitUntilCanLandLoad()
+//            }.map { () -> CVUpdate in
+//                update
+//            }
+//        }.then { [weak self] (update: CVUpdate) -> Promise<Void> in
+//            guard let self = self else {
+//                throw OWSGenericError("Missing self.")
+//            }
+//            guard let delegate = self.delegate else {
+//                throw OWSGenericError("Missing delegate.")
+//            }
+//
+//            let renderState = update.renderState
+//            let oldItemCount = update.lastRenderState.items.count
+//            let newItemCount = renderState.items.count
+//
+//            let updateToken = delegate.willUpdateWithNewRenderState(renderState)
+//
+//            self.renderState = renderState
+//
+//            let (promise, resolver) = Promise<Void>.pending()
+//            self.loadDidLandResolver = resolver
+//            delegate.updateWithNewRenderState(update: update,
+//                                              scrollAction: loadRequest.scrollAction,
+//                                              updateToken: updateToken)
+//            return promise
         }.done { [weak self] () -> Void in
             guard let self = self else {
                 throw OWSGenericError("Missing self.")
@@ -497,6 +520,87 @@ public class CVLoadCoordinator: NSObject {
         }
     }
 
+    // MARK: - Safe Landing
+
+    private func loadLandWhenSafePromise(update: CVUpdate,
+                                         delegate: CVLoadCoordinatorDelegate) -> Promise<Void> {
+        AssertIsOnMainThread()
+
+        let (loadPromise, loadResolver) = Promise<Void>.pending()
+
+        let viewState = self.viewState
+        func canLoad() -> Bool {
+            !viewState.isScrollingToTop && !viewState.isUserScrolling
+        }
+
+        func tryToResolve() {
+            guard canLoad() else {
+                // TODO: async() or asyncAfter()?
+                Logger.verbose("Waiting to land load.")
+                DispatchQueue.main.asyncAfter(deadline: .now() + 0.001) {
+//                DispatchQueue.main.async {
+                    tryToResolve()
+                }
+                return
+            }
+
+            let renderState = update.renderState
+//            let oldItemCount = update.lastRenderState.items.count
+//            let newItemCount = renderState.items.count
+
+            let updateToken = delegate.willUpdateWithNewRenderState(renderState)
+
+            self.renderState = renderState
+
+            let (loadDidLandPromise, loadDidLandResolver) = Promise<Void>.pending()
+            self.loadDidLandResolver = loadDidLandResolver
+
+            let loadRequest = update.loadRequest
+            delegate.updateWithNewRenderState(update: update,
+                                              scrollAction: loadRequest.scrollAction,
+                                              updateToken: updateToken)
+
+            firstly { () -> Promise<Void> in
+                loadDidLandPromise
+            }.done(on: .global()) {
+                loadResolver.fulfill(())
+            }.catch(on: .global()) { error in
+                loadResolver.reject(error)
+            }
+        }
+
+        tryToResolve()
+
+        return loadPromise
+    }
+    //    public func waitUntilCanLandLoad() -> Promise<Void> {
+    //        AssertIsOnMainThread()
+    //
+    //        guard let canLandLoadPromise = canLandLoadPromise else {
+    //            return Promise.value(())
+    //        }
+    //        return canLandLoadPromise.promise
+    //    }
+    //    private func tryToFireCanLandLoad() {
+    //        AssertIsOnMainThread()
+    //
+    //        guard let canLandLoadPromise = canLandLoadPromise else {
+    //            return
+    //        }
+    //        guard !isScrollingToTop else {
+    //            return
+    //        }
+    //        canLandLoadPromise.resolver.fulfill(())
+    //        self.canLandLoadPromise = nil
+    //    }
+    //    private struct PromiseAndResolver {
+    //        let promise: Promise<Void>
+    //        let resolver: Resolver<Void>
+    //    }
+    //    private var canLandLoadPromise: PromiseAndResolver?
+
+    // -
+
     public func loadDidLand() {
         AssertIsOnMainThread()
         guard let loadDidLandResolver = loadDidLandResolver else {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index 3e9a8934685..7b35a0bafaa 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -100,7 +100,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                                   scrollAction: CVScrollAction,
                                   updateToken: CVUpdateToken) {
         AssertIsOnMainThread()
-        owsAssertDebug(layout.hasLayout)
 
         owsAssertDebug(self.viewState.scrollContinuityMap != nil)
 
@@ -456,7 +455,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                                 threadInteractionCount: UInt,
                                 updateToken: CVUpdateToken) {
         owsAssertDebug(!items.isEmpty)
-        owsAssertDebug(layout.hasLayout)
 
         Logger.verbose("")
 
@@ -592,7 +590,6 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             }
         }
 
-        owsAssertDebug(layout.hasLayout)
         self.performBatchUpdates(batchUpdatesBlock,
                                  completion: completion,
                                  logFailureBlock: logFailureBlock,
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift
index 9cb3a74e0ed..f10c3d3d9ea 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+LastVisibleSortId.swift
@@ -15,7 +15,32 @@ extension ConversationViewController {
     }
 
     /// The index path of the last item in the collection view's visible rect
-    @objc var lastVisibleIndexPath: IndexPath? {
+    @objc
+    var firstVisibleIndexPath: IndexPath? {
+        // For people looking at this in the future, UICollectionView has a very similar looking
+        // property: -indexPathsForVisibleItems. Why aren't we using that?
+        //
+        // That property *almost* gives us what we want, but UIKit ordering isn't favorable. That property
+        // gets updated after -scrollViewDidScroll: returns. But sometimes we want to know what cells are visible
+        // with the updated -contentOffset in -scrollViewDidScroll:. So instead, we'll just see what layoutAttributes
+        // are now in the collection view's visible content rect. This should be safe, since it's computed from the
+        // already updated -contentOffset.
+        layout.prepare()
+        let visibleLayoutAttributes = layout.layoutAttributesForElements(in: visibleContentRect) ?? []
+
+        let firstVisibleIndexPath = visibleLayoutAttributes
+            .map { $0.indexPath }
+            .min { $0.row < $1.row }
+
+        if let firstVisibleIndexPath = firstVisibleIndexPath {
+             assert(percentOfIndexPathVisibleAboveBottom(firstVisibleIndexPath) > 0)
+        }
+        return firstVisibleIndexPath
+    }
+
+    /// The index path of the last item in the collection view's visible rect
+    @objc
+    var lastVisibleIndexPath: IndexPath? {
         // For people looking at this in the future, UICollectionView has a very similar looking
         // property: -indexPathsForVisibleItems. Why aren't we using that?
         //
@@ -33,7 +58,7 @@ extension ConversationViewController {
 
         if let lastVisibleIndexPath = lastVisibleIndexPath {
             // TODO: Fix this assert.
-            // assert(percentOfIndexPathVisibleAboveBottom(lastVisibleIndexPath) > 0)
+             assert(percentOfIndexPathVisibleAboveBottom(lastVisibleIndexPath) > 0)
         }
         return lastVisibleIndexPath
     }
@@ -91,6 +116,28 @@ extension ConversationViewController {
         }
     }
 
+    @objc
+    func logFirstAndLastVisibleItems() {
+        AssertIsOnMainThread()
+
+        if let firstVisibleIndexPath = firstVisibleIndexPath,
+           let reference = firstRenderItemReferenceWithSortId(atOrBeforeIndexPath: firstVisibleIndexPath) {
+
+            let onScreenPercentage = percentOfIndexPathVisibleAboveBottom(reference.indexPath)
+            let bodyText: String = (reference.interaction as? TSMessage)?.body ?? "none"
+            Logger.verbose("---- first visible item: sortId: \(reference.sortId), indexPath: \(reference.indexPath), bodyText: \(bodyText), onScreenPercentage: \(onScreenPercentage), ")
+        }
+
+        if let lastVisibleIndexPath = lastVisibleIndexPath,
+           let reference = firstRenderItemReferenceWithSortId(atOrBeforeIndexPath: lastVisibleIndexPath) {
+
+            let onScreenPercentage = percentOfIndexPathVisibleAboveBottom(reference.indexPath)
+            let bodyText: String = (reference.interaction as? TSMessage)?.body ?? "none"
+            Logger.verbose("---- last visible item: sortId: \(reference.sortId), indexPath: \(reference.indexPath), bodyText: \(bodyText), onScreenPercentage: \(onScreenPercentage)")
+        }
+
+    }
+
     private func percentOfIndexPathVisibleAboveBottom(_ indexPath: IndexPath) -> CGFloat {
         layout.prepare()
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 0c0996fc0c0..89ebb252b90 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -3753,7 +3753,13 @@ - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
 {
     @try {
         void (^updateBlock)(void) = ^{
-            [self.collectionView performBatchUpdates:batchUpdates completion:completion];
+            [self.layout willPerformBatchUpdates];
+            [self.collectionView
+                performBatchUpdates:^{
+                    batchUpdates();
+                }
+                         completion:completion];
+            [self.layout didPerformBatchUpdates];
 
             // AFAIK the collection view layout should reflect the old layout
             // until performBatchUpdates(), then we need to invalidate and prepare
@@ -3766,8 +3772,6 @@ - (void)performBatchUpdates:(void (^_Nonnull)(void))batchUpdates
             // Otherwise UICollectionView can throw (crashing) exceptions like this:
             //
             // UICollectionView received layout attributes for a cell with an index path that does not exist...
-            [self.layout invalidateLayout];
-            [self.layout prepareLayout];
             [BenchManager completeEventWithEventId:@"message-send"];
         };
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index 0cdb4781257..c9bb3333ad7 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -32,30 +32,92 @@ public class ConversationViewLayout: UICollectionViewLayout {
     @objc
     public weak var delegate: ConversationViewLayoutDelegate?
 
-    // This dirty flag may be redundant with logic in UICollectionViewLayout,
-    // but it can't hurt and it ensures that we can safely & cheaply call
-    // prepareLayout from view logic to ensure that we always have aÂ¸valid
-    // layout without incurring any of the (great) expense of performing an
-    // unnecessary layout pass.
-    public private(set) var hasLayout = false {
-        didSet {
-            AssertIsOnMainThread()
-
-            if hasLayout {
-                hasEverHadLayout = true
+    private var conversationStyle: ConversationStyle
+
+    private struct LayoutInfo {
+        let viewWidth: CGFloat
+        let contentSize: CGSize
+        let itemAttributesMap: [Int: UICollectionViewLayoutAttributes]
+        let headerLayoutAttributes: UICollectionViewLayoutAttributes?
+        let footerLayoutAttributes: UICollectionViewLayoutAttributes?
+
+        func layoutAttributesForItem(at indexPath: IndexPath, assertIfMissing: Bool) -> UICollectionViewLayoutAttributes? {
+            if assertIfMissing {
+                owsAssertDebug(indexPath.row >= 0 && indexPath.row < itemAttributesMap.count)
+            }
+            return itemAttributesMap[indexPath.row]
+        }
+
+        func layoutAttributesForSupplementaryElement(ofKind elementKind: String,
+                                                     at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+
+            if elementKind == UICollectionView.elementKindSectionHeader,
+               let headerLayoutAttributes = headerLayoutAttributes,
+               headerLayoutAttributes.indexPath == indexPath {
+                return headerLayoutAttributes
+            }
+            if elementKind == UICollectionView.elementKindSectionFooter,
+               let footerLayoutAttributes = footerLayoutAttributes,
+               footerLayoutAttributes.indexPath == indexPath {
+                return footerLayoutAttributes
             }
+            return nil
         }
     }
+
     private var hasEverHadLayout = false
 
-    private var lastViewWidth: CGFloat = 0
-    private var contentSize: CGSize = .zero
+    private var currentLayoutInfo: LayoutInfo?
 
-    private var conversationStyle: ConversationStyle
+    private func ensureCurrentLayoutInfo() -> LayoutInfo {
+        AssertIsOnMainThread()
 
-    private var itemAttributesMap = [Int: UICollectionViewLayoutAttributes]()
-    private var headerLayoutAttributes: UICollectionViewLayoutAttributes?
-    private var footerLayoutAttributes: UICollectionViewLayoutAttributes?
+        if let layoutInfo = currentLayoutInfo {
+            return layoutInfo
+        }
+
+        let layoutInfo = Self.buildLayoutInfo(delegate: delegate, conversationStyle: conversationStyle)
+        currentLayoutInfo = layoutInfo
+        hasEverHadLayout = true
+        return layoutInfo
+    }
+
+    private var lastViewWidth: CGFloat? { currentLayoutInfo?.viewWidth }
+    private var contentSize: CGSize { ensureCurrentLayoutInfo().contentSize }
+    private var itemAttributesMap: [Int: UICollectionViewLayoutAttributes] { ensureCurrentLayoutInfo().itemAttributesMap }
+    private var headerLayoutAttributes: UICollectionViewLayoutAttributes? { ensureCurrentLayoutInfo().headerLayoutAttributes }
+    private var footerLayoutAttributes: UICollectionViewLayoutAttributes? { ensureCurrentLayoutInfo().footerLayoutAttributes }
+    private var hasLayout: Bool { currentLayoutInfo != nil }
+
+    // This is used during performBatchUpdates() to determine
+    // the initial (last) layout state for items.
+    private var lastLayoutInfo: LayoutInfo?
+
+    @objc
+    public func willPerformBatchUpdates() {
+        AssertIsOnMainThread()
+        owsAssertDebug(currentLayoutInfo != nil)
+        owsAssertDebug(lastLayoutInfo == nil)
+
+        lastLayoutInfo = ensureCurrentLayoutInfo()
+        invalidateLayout()
+    }
+
+    @objc
+    public func didPerformBatchUpdates() {
+        AssertIsOnMainThread()
+        owsAssertDebug(lastLayoutInfo != nil)
+
+        lastLayoutInfo = nil
+    }
+
+//    private var currentAttributes: AttributeSet?
+//    private var lastAttributes: AttributeSet?
+//
+//    private var contentSize: CGSize = .zero
+//    private var itemAttributesMap = [Int: UICollectionViewLayoutAttributes]()
+//    private var headerLayoutAttributes: UICollectionViewLayoutAttributes?
+//    private var footerLayoutAttributes: UICollectionViewLayoutAttributes?
 
     @objc
     public required init(conversationStyle: ConversationStyle) {
@@ -95,62 +157,87 @@ public class ConversationViewLayout: UICollectionViewLayout {
     }
 
     private func clearState() {
-        contentSize = .zero
-        itemAttributesMap.removeAll()
-        headerLayoutAttributes = nil
-        footerLayoutAttributes = nil
-        hasLayout = false
-        lastViewWidth = 0
+        AssertIsOnMainThread()
+
+        currentLayoutInfo = nil
     }
 
     @objc
     public override func prepare() {
         super.prepare()
 
-        guard let delegate = delegate else {
-            owsFailDebug("Missing delegate")
-            clearState()
-            return
-        }
-        guard let collectionView = collectionView else {
-            owsFailDebug("Missing collectionView")
-            clearState()
-            return
-        }
-        guard collectionView.width > 0, collectionView.height > 0 else {
-            owsFailDebug("Collection view has invalid size: \(collectionView.bounds)")
-            clearState()
-            return
-        }
-        guard !hasLayout else {
-            return
-        }
-
-        clearState()
-        hasLayout = true
-
-        prepareLayoutOfItems(delegate: delegate)
+        _ = ensureCurrentLayoutInfo()
     }
 
+//    private func func prepare() {
+//        super.prepare()
+//
+//        guard let delegate = delegate else {
+//            owsFailDebug("Missing delegate")
+//            clearState()
+//            return
+//        }
+//        guard let collectionView = collectionView else {
+//            owsFailDebug("Missing collectionView")
+//            clearState()
+//            return
+//        }
+//        guard collectionView.width > 0, collectionView.height > 0 else {
+//            owsFailDebug("Collection view has invalid size: \(collectionView.bounds)")
+//            clearState()
+//            return
+//        }
+//        guard !hasLayout else {
+//            return
+//        }
+//
+//        clearState()
+//        hasLayout = true
+//
+//        prepareLayoutOfItems(delegate: delegate)
+//    }
+
     // TODO: We need to eventually audit this and make sure we're not
     //       invalidating our layout unnecessarily.  Having said that,
     //       doing layout should be pretty cheap now.
-    private func prepareLayoutOfItems(delegate: ConversationViewLayoutDelegate) {
+    private static func buildLayoutInfo(delegate: ConversationViewLayoutDelegate?,
+                                        conversationStyle: ConversationStyle) -> LayoutInfo {
+
+        func buildEmptyLayoutInfo() -> LayoutInfo {
+            return LayoutInfo(viewWidth: 0,
+                              contentSize: .zero,
+                              itemAttributesMap: [:],
+                              headerLayoutAttributes: nil,
+                              footerLayoutAttributes: nil)
+        }
+
+        guard let delegate = delegate else {
+            owsFailDebug("Missing delegate")
+            return buildEmptyLayoutInfo()
+        }
+
         let viewWidth: CGFloat = conversationStyle.viewWidth
+        guard viewWidth > 0 else {
+            return buildEmptyLayoutInfo()
+        }
         let layoutItems = delegate.layoutItems
 
         var y: CGFloat = 0
 
+        var itemAttributesMap = [Int: UICollectionViewLayoutAttributes]()
+        var headerLayoutAttributes: UICollectionViewLayoutAttributes?
+        var footerLayoutAttributes: UICollectionViewLayoutAttributes?
+
         let layoutHeaderHeight = delegate.layoutHeaderHeight
         if layoutItems.isEmpty || layoutHeaderHeight <= 0 {
-            headerLayoutAttributes = nil
+            // Do nothing.
         } else {
             let headerIndexPath = IndexPath(row: 0, section: 0)
-            let headerLayoutAttributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader,
+            let layoutAttributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionHeader,
                                                                           with: headerIndexPath)
 
-            headerLayoutAttributes.frame = CGRect(x: 0, y: y, width: viewWidth, height: layoutHeaderHeight)
-            self.headerLayoutAttributes = headerLayoutAttributes
+            layoutAttributes.frame = CGRect(x: 0, y: y, width: viewWidth, height: layoutHeaderHeight)
+            headerLayoutAttributes = layoutAttributes
 
             y += layoutHeaderHeight
         }
@@ -180,7 +267,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
             let indexPath = IndexPath(row: row, section: 0)
             let itemAttributes = UICollectionViewLayoutAttributes(forCellWith: indexPath)
             itemAttributes.frame = itemFrame
-            self.itemAttributesMap[row] = itemAttributes
+            itemAttributesMap[row] = itemAttributes
 
             contentBottom = itemFrame.origin.y + itemFrame.size.height
             y = contentBottom
@@ -188,28 +275,32 @@ public class ConversationViewLayout: UICollectionViewLayout {
             previousLayoutItem = layoutItem
         }
 
-        contentBottom += self.conversationStyle.contentMarginBottom
+        contentBottom += conversationStyle.contentMarginBottom
 
         let layoutFooterHeight = delegate.layoutFooterHeight
         let footerIndexPath = IndexPath(row: row, section: 0)
         if layoutItems.isEmpty || layoutFooterHeight <= 0 || headerLayoutAttributes?.indexPath == footerIndexPath {
-            footerLayoutAttributes = nil
+            // Do nothing.
         } else {
-            let footerLayoutAttributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionFooter,
+            let layoutAttributes = UICollectionViewLayoutAttributes(forSupplementaryViewOfKind: UICollectionView.elementKindSectionFooter,
                                                                           with: footerIndexPath)
 
-            footerLayoutAttributes.frame = CGRect(x: 0, y: contentBottom, width: viewWidth, height: layoutFooterHeight)
-            self.footerLayoutAttributes = footerLayoutAttributes
+            layoutAttributes.frame = CGRect(x: 0, y: contentBottom, width: viewWidth, height: layoutFooterHeight)
+            footerLayoutAttributes = layoutAttributes
             contentBottom += layoutFooterHeight
         }
 
-        self.contentSize = CGSize(width: viewWidth, height: contentBottom)
-        self.lastViewWidth = viewWidth
+        let contentSize = CGSize(width: viewWidth, height: contentBottom)
+
+        return LayoutInfo(viewWidth: viewWidth,
+                          contentSize: contentSize,
+                          itemAttributesMap: itemAttributesMap,
+                          headerLayoutAttributes: headerLayoutAttributes,
+                          footerLayoutAttributes: footerLayoutAttributes)
     }
 
     @objc
     public override func layoutAttributesForElements(in rect: CGRect) -> [UICollectionViewLayoutAttributes]? {
-        owsAssertDebug(hasLayout)
 
         var result = [UICollectionViewLayoutAttributes]()
         if let headerLayoutAttributes = headerLayoutAttributes {
@@ -224,26 +315,18 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func layoutAttributesForItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
-        owsAssertDebug(hasLayout)
+        AssertIsOnMainThread()
 
-        guard let attributes = itemAttributesMap[indexPath.row] else {
-            Logger.verbose("Missing attributes: \(itemAttributesMap.keys)")
-            return nil
-        }
-        return attributes
+        return ensureCurrentLayoutInfo().layoutAttributesForItem(at: indexPath, assertIfMissing: true)
     }
 
     @objc
-    public override func layoutAttributesForSupplementaryView(ofKind elementKind: String, at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
-        owsAssertDebug(hasLayout)
+    public override func layoutAttributesForSupplementaryView(ofKind elementKind: String,
+                                                              at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+        AssertIsOnMainThread()
 
-        if elementKind == UICollectionView.elementKindSectionHeader {
-            return headerLayoutAttributes
-        } else if elementKind == UICollectionView.elementKindSectionFooter {
-            return footerLayoutAttributes
-        } else {
-            return nil
-        }
+        return ensureCurrentLayoutInfo().layoutAttributesForSupplementaryElement(ofKind: elementKind,
+                                                                                 at: indexPath)
     }
 
     @objc
@@ -256,6 +339,73 @@ public class ConversationViewLayout: UICollectionViewLayout {
         lastViewWidth != newBounds.width
     }
 
+//    // A layout can return the content offset to be applied during transition or update animations.
+//    public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint,
+//                                             withScrollingVelocity velocity: CGPoint) -> CGPoint {
+//        guard let delegate = delegate else {
+//            return super.targetContentOffset(forProposedContentOffset: proposedContentOffset,
+//                                             withScrollingVelocity: velocity)
+//        }
+//        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+//    }
+//
+//    // A layout can return the content offset to be applied during transition or update animations.
+//    public override func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
+//        guard let delegate = delegate else {
+//            return super.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+//        }
+//        return delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+//    }
+
+//    private var initialLayoutInfo: LayoutInfo {
+//        guard let lastLayoutInfo = lastLayoutInfo else {
+//            owsFailDebug("Missing lastLayoutInfo.")
+//            return ensureCurrentLayoutInfo()
+//        }
+//        return lastLayoutInfo
+//    }
+
+    private var initialLayoutInfo: LayoutInfo? {
+        lastLayoutInfo
+    }
+
+    private var finalLayoutInfo: LayoutInfo {
+        ensureCurrentLayoutInfo()
+    }
+
+    // This set of methods is called when the collection view undergoes an animated
+    // transition such as a batch update block or an animated bounds change.
+    //
+    // For each element on screen before the invalidation, finalLayoutAttributesForDisappearingXXX
+    // will be called and an animation setup from what is on screen to those final attributes.
+    //
+    // For each element on screen after the invalidation, initialLayoutAttributesForAppearingXXX
+    // will be called and an animation setup from those initial attributes to what ends up on screen.
+    public override func initialLayoutAttributesForAppearingItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+        lastLayoutInfo?.layoutAttributesForItem(at: indexPath,
+                                                assertIfMissing: false)
+            ?? finalLayoutInfo.layoutAttributesForItem(at: indexPath,
+                                                       assertIfMissing: true)
+    }
+
+    public override func finalLayoutAttributesForDisappearingItem(at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+        finalLayoutInfo.layoutAttributesForItem(at: indexPath,
+                                                assertIfMissing: false)
+            ?? lastLayoutInfo?.layoutAttributesForItem(at: indexPath,
+                                                       assertIfMissing: true)
+    }
+
+    public override func initialLayoutAttributesForAppearingSupplementaryElement(ofKind elementKind: String,
+                                                                                 at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+        lastLayoutInfo?.layoutAttributesForSupplementaryElement(ofKind: elementKind, at: indexPath)
+            ?? finalLayoutInfo.layoutAttributesForSupplementaryElement(ofKind: elementKind, at: indexPath)
+    }
+
+    public override func finalLayoutAttributesForDisappearingSupplementaryElement(ofKind elementKind: String,
+                                                                                  at indexPath: IndexPath) -> UICollectionViewLayoutAttributes? {
+        finalLayoutInfo.layoutAttributesForSupplementaryElement(ofKind: elementKind, at: indexPath)
+    }
+
     @objc
     public override var debugDescription: String {
         var result = "["
