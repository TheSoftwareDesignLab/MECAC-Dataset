diff --git a/Signal/src/ViewControllers/Attachment Keyboard/AttachmentFormatPickerView.swift b/Signal/src/ViewControllers/Attachment Keyboard/AttachmentFormatPickerView.swift
index e1352be5502..3dc4004915f 100644
--- a/Signal/src/ViewControllers/Attachment Keyboard/AttachmentFormatPickerView.swift	
+++ b/Signal/src/ViewControllers/Attachment Keyboard/AttachmentFormatPickerView.swift	
@@ -17,191 +17,339 @@ protocol AttachmentFormatPickerDelegate: AnyObject {
     func didTapPayment()
 }
 
-class AttachmentFormatPickerView: UICollectionView {
+class AttachmentFormatPickerView: UIView {
+
     weak var attachmentFormatPickerDelegate: AttachmentFormatPickerDelegate?
 
-    static let itemSize = CGSize(width: 76, height: 122)
+    private let scrollView: UIScrollView = {
+        let scrollView = UIScrollView()
+        scrollView.showsHorizontalScrollIndicator = false
+        scrollView.contentInsetAdjustmentBehavior = .never
+        return scrollView
+    }()
 
-    private let collectionViewFlowLayout: UICollectionViewFlowLayout = {
-        let layout = RTLEnabledCollectionViewFlowLayout()
-        layout.itemSize = AttachmentFormatPickerView.itemSize
-        layout.scrollDirection = .horizontal
-        layout.minimumLineSpacing = 12
-        return layout
+    private lazy var contentView: UIStackView = {
+        let buttons = AttachmentType.cases(isGroup: isGroup).map {
+            let button = AttachmentTypeButton(attachmentType: $0)
+            button.isVerticallyCompactAppearance = traitCollection.verticalSizeClass == .compact
+            button.addTarget(self, action: #selector(didTapAttachmentButton), for: .touchUpInside)
+            return button
+        }
+        let stackView = UIStackView(arrangedSubviews: buttons)
+        stackView.spacing = 12
+        stackView.axis = .horizontal
+        stackView.alignment = .top
+        stackView.translatesAutoresizingMaskIntoConstraints = false
+        return stackView
     }()
 
     private let isGroup: Bool
 
+    @objc
+    private func didTapAttachmentButton(sender: Any) {
+        guard
+            let delegate = attachmentFormatPickerDelegate,
+            let attachmentTypeButton = sender as? AttachmentTypeButton
+        else {
+            return
+        }
+        // Delay event handling a bit so that pressed state of the button is visible.
+        DispatchQueue.main.async {
+            switch attachmentTypeButton.attachmentType {
+            case .photo:
+                delegate.didTapPhotos()
+            case .gif:
+                delegate.didTapGif()
+            case .file:
+                delegate.didTapFile()
+            case .payment:
+                delegate.didTapPayment()
+            case .contact:
+                delegate.didTapContact()
+            case .location:
+                delegate.didTapLocation()
+            }
+        }
+    }
+
     init(isGroup: Bool) {
         self.isGroup = isGroup
 
-        super.init(frame: .zero, collectionViewLayout: collectionViewFlowLayout)
-
-        delegate = self
-        dataSource = self
+        super.init(frame: .zero)
 
         backgroundColor = .clear
-        showsHorizontalScrollIndicator = false
-        let horizontalInset = OWSTableViewController2.defaultHOuterMargin
-        contentInset = UIEdgeInsets(top: 0, leading: horizontalInset, bottom: 0, trailing: horizontalInset)
-        register(AttachmentFormatCell.self, forCellWithReuseIdentifier: AttachmentFormatCell.reuseIdentifier)
+
+        addSubview(scrollView)
+        scrollView.autoPinEdgesToSuperviewEdges()
+
+        scrollView.addSubview(contentView)
+        NSLayoutConstraint.activate([
+            contentView.leadingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.leadingAnchor),
+            contentView.topAnchor.constraint(equalTo: scrollView.contentLayoutGuide.topAnchor),
+            contentView.trailingAnchor.constraint(equalTo: scrollView.contentLayoutGuide.trailingAnchor),
+            contentView.bottomAnchor.constraint(equalTo: scrollView.contentLayoutGuide.bottomAnchor)
+        ])
     }
 
     required init?(coder aDecoder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
-}
-
-private enum AttachmentType: String, CaseIterable, Dependencies {
-    case photo
-    case gif
-    case file
-    case payment
-    case contact
-    case location
 
-    private static var contactCases: [AttachmentType] {
-        if payments.shouldShowPaymentsUI {
-            return allCases
-        } else {
-            return everythingExceptPayments
+    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
+        super.traitCollectionDidChange(previousTraitCollection)
+        let isLandscapeLayout = traitCollection.verticalSizeClass == .compact
+        contentView.arrangedSubviews.forEach { subview in
+            guard let button = subview as? AttachmentTypeButton else { return }
+            button.isVerticallyCompactAppearance = isLandscapeLayout
         }
+        invalidateIntrinsicContentSize()
     }
 
-    private static var groupCases: [AttachmentType] {
-        everythingExceptPayments
+    override var intrinsicContentSize: CGSize {
+        let height: CGFloat = traitCollection.verticalSizeClass == .compact ? 86 : 122
+        return CGSize(width: UIView.noIntrinsicMetric, height: height)
     }
 
-    private static var everythingExceptPayments: [AttachmentType] {
-        return allCases.filter { (value: AttachmentType) in
-            value != .payment
+    override func layoutSubviews() {
+        super.layoutSubviews()
+
+        // Dispatch async is needed for the subviews to have their final frames.
+        DispatchQueue.main.async {
+            self.updateScrollViewContentInsets()
         }
     }
 
-    static func cases(isGroup: Bool) -> [AttachmentType] {
-        return isGroup ? groupCases : contactCases
+    private func updateScrollViewContentInsets() {
+        // Center button row horizontally and vertically in the scroll view.
+        let scrollViewSize = scrollView.frame.size
+        let contentSize = contentView.bounds.size
+        guard scrollViewSize.isNonEmpty, contentSize.isNonEmpty else { return }
+        let horizontalInset = max(OWSTableViewController2.defaultHOuterMargin, 0.5 * (scrollViewSize.width - contentSize.width))
+        let verticalInset = max(0, 0.5 * (scrollViewSize.height - contentSize.height))
+        let contentInset = UIEdgeInsets(hMargin: horizontalInset, vMargin: verticalInset)
+        guard scrollView.contentInset != contentInset else { return }
+        scrollView.contentInset = contentInset
+        scrollView.contentOffset = CGPoint(x: -contentInset.leading, y: -contentInset.top)
     }
-}
 
-// MARK: - UICollectionViewDelegate
-
-extension AttachmentFormatPickerView: UICollectionViewDelegate {
-    public func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
-        switch AttachmentType.cases(isGroup: isGroup)[indexPath.row] {
-        case .photo:
-            attachmentFormatPickerDelegate?.didTapPhotos()
-        case .contact:
-            attachmentFormatPickerDelegate?.didTapContact()
-        case .file:
-            attachmentFormatPickerDelegate?.didTapFile()
-        case .gif:
-            attachmentFormatPickerDelegate?.didTapGif()
-        case .location:
-            attachmentFormatPickerDelegate?.didTapLocation()
-        case .payment:
-            attachmentFormatPickerDelegate?.didTapPayment()
+    // Set initial state for all buttons - get them ready to be animated in.
+    func prepareForPresentation() {
+        let buttons = contentView.arrangedSubviews
+        guard !buttons.isEmpty else { return }
+
+        UIView.performWithoutAnimation {
+            buttons.forEach { button in
+                button.alpha = 0
+                button.transform = .scale(0.5)
+            }
         }
     }
-}
 
-// MARK: - UICollectionViewDataSource
+    func performPresentationAnimation() {
+        let buttons = contentView.arrangedSubviews
+        guard !buttons.isEmpty else { return }
+
+        // Chain animations for buttons.
+        let delay = 1 / CGFloat(buttons.count)
+        let animator = UIViewPropertyAnimator(duration: 0.5, springDamping: 1, springResponse: 0.2)
+        for (index, button) in buttons.enumerated() {
+            animator.addAnimations({
+                button.alpha = 1
+                button.transform = .identity
+            }, delayFactor: CGFloat(index) * delay)
+        }
+        animator.startAnimation()
+    }
 
-extension AttachmentFormatPickerView: UICollectionViewDataSource {
+    private enum AttachmentType: String, CaseIterable, Dependencies {
+        case photo
+        case gif
+        case file
+        case payment
+        case contact
+        case location
+
+        private static var contactCases: [AttachmentType] {
+            if payments.shouldShowPaymentsUI {
+                return allCases
+            } else {
+                return everythingExceptPayments
+            }
+        }
 
-    public func numberOfSections(in collectionView: UICollectionView) -> Int {
-        return 1
-    }
+        private static var groupCases: [AttachmentType] {
+            everythingExceptPayments
+        }
+
+        private static var everythingExceptPayments: [AttachmentType] {
+            return allCases.filter { (value: AttachmentType) in
+                value != .payment
+            }
+        }
 
-    public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection sectionIdx: Int) -> Int {
-        return AttachmentType.cases(isGroup: isGroup).count
+        static func cases(isGroup: Bool) -> [AttachmentType] {
+            return isGroup ? groupCases : contactCases
+        }
     }
 
-    public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
-        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: AttachmentFormatCell.reuseIdentifier, for: indexPath) as? AttachmentFormatCell else {
-            owsFail("cell was unexpectedly nil")
+    private class AttachmentTypeButton: UIControl {
+
+        private class DimmablePillView: PillView {
+
+            private let dimmerView: UIView = {
+                let view = UIView()
+                view.backgroundColor = Theme.isDarkThemeEnabled ? .ows_whiteAlpha10 : .ows_blackAlpha10
+                view.alpha = 0
+                return view
+            }()
+
+            // Implicitly animatable.
+            var isDimmed: Bool = false {
+                didSet {
+                    dimmerView.alpha = isDimmed ? 1 : 0
+                }
+            }
+
+            override init(frame: CGRect) {
+                super.init(frame: frame)
+                addSubview(dimmerView)
+            }
+
+            required init?(coder aDecoder: NSCoder) {
+                fatalError("init(coder:) has not been implemented")
+            }
+
+            override func layoutSubviews() {
+                super.layoutSubviews()
+                dimmerView.frame = bounds
+            }
         }
 
-        let type = AttachmentType.cases(isGroup: isGroup)[indexPath.item]
-        cell.configure(type: type)
-        return cell
-    }
-}
+        let attachmentType: AttachmentType
 
-private class AttachmentFormatCell: UICollectionViewCell {
+        var isVerticallyCompactAppearance = false {
+            didSet {
+                imageViewPillBoxHeightConstraint.constant = isVerticallyCompactAppearance ? 40 : 50
+            }
+        }
 
-    static let reuseIdentifier = "AttachmentFormatCell"
+        private let imageViewPillBox: DimmablePillView = {
+            let pillView = DimmablePillView()
+            pillView.isUserInteractionEnabled = false
+            pillView.backgroundColor = Theme.isDarkThemeEnabled ? UIColor(white: 1, alpha: 0.16) : UIColor(white: 0, alpha: 0.08)
+            return pillView
+        }()
+
+        private lazy var imageViewPillBoxHeightConstraint: NSLayoutConstraint = {
+            imageViewPillBox.heightAnchor.constraint(equalToConstant: 50)
+        }()
+
+        private let iconImageView: UIImageView = {
+            let imageView = UIImageView()
+            imageView.contentMode = .center
+            imageView.tintColor = Theme.isDarkThemeEnabled ? .white : .black
+            return imageView
+        }()
+
+        private let textLabel: UILabel = {
+            let label = UILabel()
+            label.font = .dynamicTypeFootnoteClamped.medium()
+            label.textColor = Theme.secondaryTextAndIconColor
+            label.textAlignment = .center
+            label.numberOfLines = 2
+            label.adjustsFontSizeToFitWidth = true
+            label.lineBreakMode = .byCharWrapping
+            return label
+        }()
+
+        init(attachmentType: AttachmentType) {
+            self.attachmentType = attachmentType
+
+            super.init(frame: .zero)
+
+            translatesAutoresizingMaskIntoConstraints = false
+
+            imageViewPillBox.addSubview(iconImageView)
+            iconImageView.autoPinEdgesToSuperviewEdges()
+
+            addSubview(imageViewPillBox)
+            NSLayoutConstraint.activate([
+                imageViewPillBox.widthAnchor.constraint(equalToConstant: 76),
+                imageViewPillBoxHeightConstraint
+            ])
+            imageViewPillBox.autoPinEdges(toSuperviewEdgesExcludingEdge: .bottom)
+
+            addSubview(textLabel)
+            textLabel.autoPinEdge(.top, to: .bottom, of: imageViewPillBox, withOffset: 8)
+            textLabel.autoPinEdges(toSuperviewEdgesExcludingEdge: .top)
+
+            configure()
+        }
 
-    private lazy var imageViewPillBox: UIView = {
-        let pillView = PillView()
-        pillView.backgroundColor = UIColor(dynamicProvider: { _ in
-            Theme.isDarkThemeEnabled ? UIColor(white: 1, alpha: 0.16) : UIColor(white: 0, alpha: 0.08)
-        })
-        pillView.autoSetDimension(.height, toSize: 50)
-        return pillView
-    }()
-    private lazy var imageView: UIImageView = {
-        let imageView = UIImageView()
-        imageView.contentMode = .center
-        return imageView
-    }()
-    private lazy var textLabel: UILabel = {
-        let label = UILabel()
-        label.font = .dynamicTypeFootnoteClamped.semibold()
-        label.textColor = Theme.secondaryTextAndIconColor
-        label.textAlignment = .center
-        label.adjustsFontSizeToFitWidth = true
-        return label
-    }()
+        override var isHighlighted: Bool {
+            didSet {
+                setIsPressed(isHighlighted, animated: window != nil)
+            }
+        }
 
-    override init(frame: CGRect) {
-        super.init(frame: frame)
+        private var _isPressed = false
 
-        imageViewPillBox.addSubview(imageView)
-        imageView.autoPinEdgesToSuperviewEdges()
+        private var isPressed: Bool {
+            get { _isPressed }
+            set { setIsPressed(newValue, animated: false) }
+        }
 
-        let stackView = UIStackView(arrangedSubviews: [imageViewPillBox, textLabel])
-        stackView.axis = .vertical
-        stackView.spacing = 8
+        private func setIsPressed(_ isPressed: Bool, animated: Bool) {
+            _isPressed = isPressed
+
+            let changes = {
+                self.imageViewPillBox.isDimmed = isPressed
+                self.imageViewPillBox.transform = isPressed ? .scale(0.9) : .identity
+            }
+            guard animated else {
+                changes()
+                return
+            }
+
+            let animator = UIViewPropertyAnimator(duration: 0.15, springDamping: 0.64, springResponse: 0.25)
+            animator.addAnimations(changes)
+            animator.startAnimation()
+        }
 
-        contentView.addSubview(stackView)
-        stackView.autoPinWidthToSuperview()
-        stackView.autoPinHeightToSuperview(relation: .lessThanOrEqual)
-        stackView.autoAlignAxis(toSuperviewAxis: .horizontal)
-    }
+        @available(*, unavailable, message: "Unimplemented")
+        required public init?(coder aDecoder: NSCoder) {
+            fatalError("init(coder:) has not been implemented")
+        }
 
-    @available(*, unavailable, message: "Unimplemented")
-    required public init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
+        private func configure() {
+            let imageName: String
+            let text: String
+
+            switch attachmentType {
+            case .photo:
+                text = OWSLocalizedString("ATTACHMENT_KEYBOARD_PHOTOS", comment: "A button to open the photo picker from the Attachment Keyboard")
+                imageName = "album-tilt-28"
+            case .contact:
+                text = OWSLocalizedString("ATTACHMENT_KEYBOARD_CONTACT", comment: "A button to select a contact from the Attachment Keyboard")
+                imageName = "person-circle-28"
+            case .file:
+                text = OWSLocalizedString("ATTACHMENT_KEYBOARD_FILE", comment: "A button to select a file from the Attachment Keyboard")
+                imageName = "file-28"
+            case .gif:
+                text = OWSLocalizedString("ATTACHMENT_KEYBOARD_GIF", comment: "A button to select a GIF from the Attachment Keyboard")
+                imageName = "gif-28"
+            case .location:
+                text = OWSLocalizedString("ATTACHMENT_KEYBOARD_LOCATION", comment: "A button to select a location from the Attachment Keyboard")
+                imageName = "location-28"
+            case .payment:
+                text = OWSLocalizedString("ATTACHMENT_KEYBOARD_PAYMENT", comment: "A button to select a payment from the Attachment Keyboard")
+                imageName = "payment-28"
+            }
+
+            textLabel.text = text
+            iconImageView.image = UIImage(imageLiteralResourceName: imageName)
+            accessibilityIdentifier = UIView.accessibilityIdentifier(in: self, name: "format-\(attachmentType.rawValue)")
+        }
     }
 
-    func configure(type: AttachmentType) {
-        let imageName: String
-        let text: String
-
-        switch type {
-        case .photo:
-            text = OWSLocalizedString("ATTACHMENT_KEYBOARD_PHOTOS", comment: "A button to open the photo picker from the Attachment Keyboard")
-            imageName = "album-tilt-28"
-        case .contact:
-            text = OWSLocalizedString("ATTACHMENT_KEYBOARD_CONTACT", comment: "A button to select a contact from the Attachment Keyboard")
-            imageName = "person-circle-28"
-        case .file:
-            text = OWSLocalizedString("ATTACHMENT_KEYBOARD_FILE", comment: "A button to select a file from the Attachment Keyboard")
-            imageName = "file-28"
-        case .gif:
-            text = OWSLocalizedString("ATTACHMENT_KEYBOARD_GIF", comment: "A button to select a GIF from the Attachment Keyboard")
-            imageName = "gif-28"
-        case .location:
-            text = OWSLocalizedString("ATTACHMENT_KEYBOARD_LOCATION", comment: "A button to select a location from the Attachment Keyboard")
-            imageName = "location-28"
-        case .payment:
-            text = OWSLocalizedString("ATTACHMENT_KEYBOARD_PAYMENT", comment: "A button to select a payment from the Attachment Keyboard")
-            imageName = "payment-28"
-        }
-
-        textLabel.text = text
-        imageView.image = UIImage(imageLiteralResourceName: imageName)
-        imageView.tintColor = Theme.isDarkThemeEnabled ? .white : .black
-        accessibilityIdentifier = UIView.accessibilityIdentifier(in: self, name: "format-\(type.rawValue)")
-    }
 }
diff --git a/Signal/src/ViewControllers/Attachment Keyboard/AttachmentKeyboard.swift b/Signal/src/ViewControllers/Attachment Keyboard/AttachmentKeyboard.swift
index 067651875fa..de434a9a48b 100644
--- a/Signal/src/ViewControllers/Attachment Keyboard/AttachmentKeyboard.swift	
+++ b/Signal/src/ViewControllers/Attachment Keyboard/AttachmentKeyboard.swift	
@@ -27,12 +27,11 @@ class AttachmentKeyboard: CustomKeyboard {
         collectionView.recentPhotosDelegate = self
         return collectionView
     }()
-    private lazy var attachmentFormatPickerView: UIView = {
+    private lazy var attachmentFormatPickerView: AttachmentFormatPickerView = {
         let pickerView = AttachmentFormatPickerView(isGroup: delegate?.isGroup ?? false)
         pickerView.attachmentFormatPickerDelegate = self
-        NSLayoutConstraint.autoSetPriority(.defaultLow) {
-            pickerView.autoSetDimension(.height, toSize: AttachmentFormatPickerView.itemSize.height)
-        }
+        pickerView.setContentHuggingVerticalHigh()
+        pickerView.setCompressionResistanceVerticalHigh()
         return pickerView
     }()
 
@@ -63,6 +62,14 @@ class AttachmentKeyboard: CustomKeyboard {
     override func willPresent() {
         super.willPresent()
         checkPermissions()
+        recentPhotosCollectionView.prepareForPresentation()
+        attachmentFormatPickerView.prepareForPresentation()
+    }
+
+    override func wasPresented() {
+        super.wasPresented()
+        recentPhotosCollectionView.performPresentationAnimation()
+        attachmentFormatPickerView.performPresentationAnimation()
     }
 
     override func layoutSubviews() {
diff --git a/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift b/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift
index 9dd0b83483f..a61e7c742ed 100644
--- a/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift	
+++ b/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift	
@@ -98,6 +98,22 @@ class RecentPhotosCollectionView: UICollectionView {
         fatalError("init(coder:) has not been implemented")
     }
 
+    // Presentation Animations
+
+    func prepareForPresentation() {
+        UIView.performWithoutAnimation {
+            self.alpha = 0
+        }
+    }
+
+    func performPresentationAnimation() {
+        let animator = UIViewPropertyAnimator(duration: 0.3, springDamping: 1, springResponse: 0.3)
+        animator.addAnimations({
+            self.alpha = 1
+        })
+        animator.startAnimation()
+    }
+
     // Background view
 
     private var hasPhotos: Bool {
diff --git a/SignalMessaging/categories/UIColor+OWS.swift b/SignalMessaging/categories/UIColor+OWS.swift
index 750d7c23016..69b23e360ea 100644
--- a/SignalMessaging/categories/UIColor+OWS.swift
+++ b/SignalMessaging/categories/UIColor+OWS.swift
@@ -178,6 +178,10 @@ public extension UIColor {
         return UIColor(white: 1.0, alpha: 0)
     }
 
+    class var ows_whiteAlpha10: UIColor {
+        return UIColor(white: 1.0, alpha: 0.1)
+    }
+
     class var ows_whiteAlpha20: UIColor {
         return UIColor(white: 1.0, alpha: 0.2)
     }
