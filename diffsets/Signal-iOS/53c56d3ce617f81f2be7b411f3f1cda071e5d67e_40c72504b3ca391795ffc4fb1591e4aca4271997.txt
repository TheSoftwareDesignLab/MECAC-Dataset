diff --git a/Signal/test/ViewControllers/CVTextTest.swift b/Signal/test/ViewControllers/CVTextTest.swift
index 213c4214d57..e0ed946ee7f 100644
--- a/Signal/test/ViewControllers/CVTextTest.swift
+++ b/Signal/test/ViewControllers/CVTextTest.swift
@@ -29,6 +29,17 @@ class CVTextTest: SignalBaseTest {
                 font: .ows_dynamicTypeBody,
                 textColor: .black
             ),
+            CVTextViewConfig(
+                text: """
+                لكن لا بد أن أوضح لك أن كل هذه الأفكار المغلوطة حول استنكار  النشوة وتمجيد الألم نشأت بالفعل، وسأعرض لك التفاصيل لتكتشف حقيقة وأساس تلك السعادة البشرية، فلا أحد يرفض أو يكره أو يتجنب الشعور بالسعادة، ولكن بفضل هؤلاء الأشخاص الذين لا يدركون بأن السعادة لا بد أن نستشعرها بصورة أكثر عقلانية ومنطقية فيعرضهم هذا لمواجهة الظروف الأليمة، وأكرر بأنه لا يوجد من يرغب في الحب ونيل المنال ويتلذذ بالآلام، الألم هو الألم ولكن نتيجة لظروف ما قد تكمن السعاده فيما نتحمله من كد وأسي.
+
+                و سأعرض مثال حي لهذا، من منا لم يتحمل جهد بدني شاق إلا من أجل الحصول على ميزة أو فائدة؟ ولكن من لديه الحق أن ينتقد شخص ما أراد أن يشعر بالسعادة التي لا تشوبها عواقب أليمة أو آخر أراد أن يتجنب الألم الذي ربما تنجم عنه بعض المتعة ؟
+                علي الجانب الآخر نشجب ونستنكر هؤلاء الرجال المفتونون بنشوة اللحظة الهائمون في رغباتهم فلا يدركون ما يعقبها من الألم والأسي المحتم، واللوم كذلك يشمل هؤلاء الذين أخفقوا في واجباتهم نتيجة لضعف إرادتهم فيتساوي مع هؤلاء الذين يتجنبون وينأون عن تحمل الكدح والألم .
+
+                """,
+                font: .ows_dynamicTypeBody,
+                textColor: .black
+            ),
             CVTextViewConfig(
                 text: """
                 東沢族応同市総暮見送軟因旧野声。療名岡無会婚必文政職産首堪。原馬果制前興禁出部医保機出。賞響子恵横大厳著美無新殺常芸観載。上属力一本彰料必転指影未税廟赤府研。読煙責負力異寺先発事製量情停並。国圏場権電別新力際営測進必。事藤着人体存止作月玉社英題写予者。間引内一強客透人戦一家万暮読。種扱報崎若陣加府大姿平問写提化針離定。
@@ -70,15 +81,7 @@ class CVTextTest: SignalBaseTest {
                 let viewSize = CVText.measureTextView(mode: .view, config: config, maxWidth: possibleWidth)
                 let defaultSize = CVText.measureTextView(config: config, maxWidth: possibleWidth)
                 XCTAssertEqual(viewSize.width, defaultSize.width)
-
-                if config.containsCJKCharacters {
-                    // TODO: In rare instances, measurement of CJK can be off by a lot, but
-                    // always in the "too big" direction, so nothing will clip. We should try
-                    // and fix this, but in simple cases it generally seems OK.
-                    XCTAssertLessThanOrEqual(viewSize.height, defaultSize.height)
-                } else {
-                    XCTAssertEqual(viewSize.height, defaultSize.height)
-                }
+                XCTAssertEqual(viewSize.height, defaultSize.height)
             }
         }
     }
@@ -109,6 +112,18 @@ class CVTextTest: SignalBaseTest {
                 numberOfLines: 0
 
             ),
+            CVLabelConfig(
+                text: """
+                لكن لا بد أن أوضح لك أن كل هذه الأفكار المغلوطة حول استنكار  النشوة وتمجيد الألم نشأت بالفعل، وسأعرض لك التفاصيل لتكتشف حقيقة وأساس تلك السعادة البشرية، فلا أحد يرفض أو يكره أو يتجنب الشعور بالسعادة، ولكن بفضل هؤلاء الأشخاص الذين لا يدركون بأن السعادة لا بد أن نستشعرها بصورة أكثر عقلانية ومنطقية فيعرضهم هذا لمواجهة الظروف الأليمة، وأكرر بأنه لا يوجد من يرغب في الحب ونيل المنال ويتلذذ بالآلام، الألم هو الألم ولكن نتيجة لظروف ما قد تكمن السعاده فيما نتحمله من كد وأسي.
+
+                و سأعرض مثال حي لهذا، من منا لم يتحمل جهد بدني شاق إلا من أجل الحصول على ميزة أو فائدة؟ ولكن من لديه الحق أن ينتقد شخص ما أراد أن يشعر بالسعادة التي لا تشوبها عواقب أليمة أو آخر أراد أن يتجنب الألم الذي ربما تنجم عنه بعض المتعة ؟
+                علي الجانب الآخر نشجب ونستنكر هؤلاء الرجال المفتونون بنشوة اللحظة الهائمون في رغباتهم فلا يدركون ما يعقبها من الألم والأسي المحتم، واللوم كذلك يشمل هؤلاء الذين أخفقوا في واجباتهم نتيجة لضعف إرادتهم فيتساوي مع هؤلاء الذين يتجنبون وينأون عن تحمل الكدح والألم .
+
+                """,
+                font: .ows_dynamicTypeBody,
+                textColor: .black,
+                numberOfLines: 0
+            ),
             CVLabelConfig(
                 text: """
                 東沢族応同市総暮見送軟因旧野声。療名岡無会婚必文政職産首堪。原馬果制前興禁出部医保機出。賞響子恵横大厳著美無新殺常芸観載。上属力一本彰料必転指影未税廟赤府研。読煙責負力異寺先発事製量情停並。国圏場権電別新力際営測進必。事藤着人体存止作月玉社英題写予者。間引内一強客透人戦一家万暮読。種扱報崎若陣加府大姿平問写提化針離定。
@@ -150,22 +165,9 @@ class CVTextTest: SignalBaseTest {
             for possibleWidth: CGFloat in stride(from: 100, to: 2000, by: 50) {
                 let viewSize = CVText.measureLabel(mode: .view, config: config, maxWidth: possibleWidth)
                 let defaultSize = CVText.measureLabel(config: config, maxWidth: possibleWidth)
-                AssertLessThanUpToLimitOrEqualTo(viewSize.width, defaultSize.width, limit: 5)
-
-                if config.containsCJKCharacters {
-                    // TODO: In rare instances, measurement of CJK can be off by a lot, but
-                    // always in the "too big" direction, so nothing will clip. We should try
-                    // and fix this, but in simple cases it generally seems OK.
-                    XCTAssertLessThanOrEqual(viewSize.height, defaultSize.height)
-                } else {
-                    AssertLessThanUpToLimitOrEqualTo(viewSize.height, defaultSize.height, limit: 2)
-                }
+                XCTAssertEqual(viewSize.width, defaultSize.width)
+                XCTAssertEqual(viewSize.height, defaultSize.height)
             }
         }
     }
-
-    public func AssertLessThanUpToLimitOrEqualTo<T>(_ expression1: @autoclosure () throws -> T, _ expression2: @autoclosure () throws -> T, limit: T, _ message: @autoclosure () -> String = "", file: StaticString = #filePath, line: UInt = #line) where T: Comparable & Numeric {
-        XCTAssertLessThanOrEqual(try expression1(), try expression2(), message(), file: file, line: line)
-        XCTAssertGreaterThanOrEqual(try expression1() + limit, try expression2(), message(), file: file, line: line)
-    }
 }
diff --git a/SignalMessaging/Views/CVText.swift b/SignalMessaging/Views/CVText.swift
index 7a2e68dea69..b4899ecae6a 100644
--- a/SignalMessaging/Views/CVText.swift
+++ b/SignalMessaging/Views/CVText.swift
@@ -61,7 +61,6 @@ public enum CVTextValue: Equatable, Hashable {
 public struct CVLabelConfig {
 
     fileprivate let text: CVTextValue
-    public let containsCJKCharacters: Bool
     public let font: UIFont
     public let textColor: UIColor
     public let numberOfLines: Int
@@ -76,14 +75,7 @@ public struct CVLabelConfig {
                 textAlignment: NSTextAlignment? = nil) {
 
         self.text = .text(text: text)
-        self.containsCJKCharacters = text.containsCJKCharacters
-
-        if containsCJKCharacters {
-            self.font = font.cjkCompatibleVariant
-        } else {
-            self.font = font
-        }
-
+        self.font = font
         self.textColor = textColor
         self.numberOfLines = numberOfLines
         self.lineBreakMode = lineBreakMode
@@ -97,16 +89,8 @@ public struct CVLabelConfig {
                 lineBreakMode: NSLineBreakMode = .byWordWrapping,
                 textAlignment: NSTextAlignment? = nil) {
 
-        self.containsCJKCharacters = attributedText.string.containsCJKCharacters
-
-        if containsCJKCharacters {
-            self.text = .attributedText(attributedText: attributedText.withCJKCompatibleFonts)
-            self.font = font.cjkCompatibleVariant
-        } else {
-            self.text = .attributedText(attributedText: attributedText)
-            self.font = font
-        }
-
+        self.text = .attributedText(attributedText: attributedText)
+        self.font = font
         self.textColor = textColor
         self.numberOfLines = numberOfLines
         self.lineBreakMode = lineBreakMode
@@ -164,7 +148,6 @@ public struct CVLabelConfig {
 public struct CVTextViewConfig {
 
     fileprivate let text: CVTextValue
-    public let containsCJKCharacters: Bool
     public let font: UIFont
     public let textColor: UIColor
     public let textAlignment: NSTextAlignment?
@@ -177,14 +160,7 @@ public struct CVTextViewConfig {
                 linkTextAttributes: [NSAttributedString.Key: Any]? = nil) {
 
         self.text = .text(text: text)
-        self.containsCJKCharacters = text.containsCJKCharacters
-
-        if containsCJKCharacters {
-            self.font = font.cjkCompatibleVariant
-        } else {
-            self.font = font
-        }
-
+        self.font = font
         self.textColor = textColor
         self.textAlignment = textAlignment
         self.linkTextAttributes = linkTextAttributes
@@ -196,16 +172,8 @@ public struct CVTextViewConfig {
                 textAlignment: NSTextAlignment? = nil,
                 linkTextAttributes: [NSAttributedString.Key: Any]? = nil) {
 
-        self.containsCJKCharacters = attributedText.string.containsCJKCharacters
-
-        if containsCJKCharacters {
-            self.text = .attributedText(attributedText: attributedText.withCJKCompatibleFonts)
-            self.font = font.cjkCompatibleVariant
-        } else {
-            self.text = .attributedText(attributedText: attributedText)
-            self.font = font
-        }
-
+        self.text = .attributedText(attributedText: attributedText)
+        self.font = font
         self.textColor = textColor
         self.textAlignment = textAlignment
         self.linkTextAttributes = linkTextAttributes
@@ -265,7 +233,7 @@ public struct CVTextViewConfig {
 // MARK: -
 
 public class CVText {
-    public enum MeasurementMode { case view, layoutManager, boundingRect }
+    public enum MeasurementMode { case view, layoutManager }
 
     public static var measurementQueue: DispatchQueue { CVUtils.workQueue }
 
@@ -328,8 +296,6 @@ public class CVText {
 
         let result: CGSize
         switch mode {
-        case .boundingRect:
-            result = measureLabelUsingBoundingRect(config: config, maxWidth: maxWidth)
         case .layoutManager:
             result = measureLabelUsingLayoutManager(config: config, maxWidth: maxWidth)
         case .view:
@@ -355,16 +321,6 @@ public class CVText {
     }
 
     private static func measureLabelUsingLayoutManager(config: CVLabelConfig, maxWidth: CGFloat) -> CGSize {
-        let textStorage: NSTextStorage
-        switch config.text {
-        case .attributedText(let text):
-            textStorage = NSTextStorage(attributedString: text)
-        case .text(let text):
-            textStorage = NSTextStorage(string: text)
-        }
-
-        textStorage.addAttribute(.font, value: config.font, range: textStorage.entireRange)
-
         let textContainer = NSTextContainer(size: CGSize(width: maxWidth, height: .greatestFiniteMagnitude))
         textContainer.maximumNumberOfLines = config.numberOfLines
         textContainer.lineBreakMode = config.lineBreakMode
@@ -373,7 +329,22 @@ public class CVText {
         let layoutManager = NSLayoutManager()
         layoutManager.addTextContainer(textContainer)
 
-        textStorage.addLayoutManager(layoutManager)
+        // NSTextStorage *must* be initialized with `NSOriginalFont` defined,
+        // otherwise measurement of character sets that San Francisco doesn't
+        // support (CJK, Arabic, etc.) will not measure correctly.
+        let textStorage: NSTextStorage
+        switch config.text {
+        case .attributedText(let text):
+            // In order for the `NSOriginalFont` attribute to be retained,
+            // the text must be assigned to the NSTextStorage *after* it
+            // has been associated with a layout manager.
+            textStorage = NSTextStorage(string: "", attributes: [.font: config.font, .originalFont: config.font])
+            textStorage.addLayoutManager(layoutManager)
+            textStorage.setAttributedString(text)
+        case .text(let text):
+            textStorage = NSTextStorage(string: text, attributes: [.font: config.font, .originalFont: config.font])
+            textStorage.addLayoutManager(layoutManager)
+        }
 
         let size = layoutManager.usedRect(for: textContainer).size
 
@@ -389,39 +360,6 @@ public class CVText {
         return size.ceil
     }
 
-    private static func measureLabelUsingBoundingRect(config: CVLabelConfig, maxWidth: CGFloat) -> CGSize {
-        let attributedText: NSMutableAttributedString
-        switch config.text {
-        case .attributedText(let text):
-            attributedText = NSMutableAttributedString(attributedString: text)
-        case .text(let text):
-            attributedText = NSMutableAttributedString(string: text)
-        }
-
-        attributedText.addAttribute(.font, value: config.font, range: attributedText.entireRange)
-
-        let maxHeight: CGFloat
-        if config.numberOfLines > 0 {
-            maxHeight = config.font.lineHeight * CGFloat(config.numberOfLines)
-        } else {
-            maxHeight = .greatestFiniteMagnitude
-        }
-
-        var size = attributedText.boundingRect(
-            with: CGSize(width: maxWidth, height: .greatestFiniteMagnitude),
-            options: [.usesLineFragmentOrigin, .usesFontLeading],
-            context: nil
-        ).size
-
-        // We can't pass max height to the measurement, because it results
-        // in the final width being way off.
-        size.height = min(maxHeight, size.height)
-
-        owsAssertDebug(size.width <= maxWidth)
-
-        return size.ceil
-    }
-
     // MARK: - UITextView
 
     private static let textView_main = {
@@ -467,8 +405,6 @@ public class CVText {
 
         let result: CGSize
         switch mode {
-        case .boundingRect:
-            result = measureTextViewUsingBoundingRect(config: config, maxWidth: maxWidth)
         case .layoutManager:
             result = measureTextViewUsingLayoutManager(config: config, maxWidth: maxWidth)
         case .view:
@@ -491,23 +427,28 @@ public class CVText {
     }
 
     private static func measureTextViewUsingLayoutManager(config: CVTextViewConfig, maxWidth: CGFloat) -> CGSize {
-        let textStorage: NSTextStorage
-        switch config.text {
-        case .attributedText(let text):
-            textStorage = NSTextStorage(attributedString: text)
-        case .text(let text):
-            textStorage = NSTextStorage(string: text)
-        }
-
-        textStorage.addAttribute(.font, value: config.font, range: textStorage.entireRange)
-
         let textContainer = NSTextContainer(size: CGSize(width: maxWidth, height: .greatestFiniteMagnitude))
         textContainer.lineFragmentPadding = 0
 
         let layoutManager = NSLayoutManager()
         layoutManager.addTextContainer(textContainer)
 
-        textStorage.addLayoutManager(layoutManager)
+        // NSTextStorage *must* be initialized with `NSOriginalFont` defined,
+        // otherwise measurement of character sets that San Francisco doesn't
+        // support (CJK, Arabic, etc.) will not measure correctly.
+        let textStorage: NSTextStorage
+        switch config.text {
+        case .attributedText(let text):
+            // In order for the `NSOriginalFont` attribute to be retained,
+            // the text must be assigned to the NSTextStorage *after* it
+            // has been associated with a layout manager.
+            textStorage = NSTextStorage(string: "", attributes: [.font: config.font, .originalFont: config.font])
+            textStorage.addLayoutManager(layoutManager)
+            textStorage.setAttributedString(text)
+        case .text(let text):
+            textStorage = NSTextStorage(string: text, attributes: [.font: config.font, .originalFont: config.font])
+            textStorage.addLayoutManager(layoutManager)
+        }
 
         let size = layoutManager.usedRect(for: textContainer).size
 
@@ -523,50 +464,6 @@ public class CVText {
         return size.ceil
     }
 
-    private static func measureTextViewUsingBoundingRect(config: CVTextViewConfig, maxWidth: CGFloat) -> CGSize {
-        let attributedText: NSMutableAttributedString
-        switch config.text {
-        case .attributedText(let text):
-            attributedText = NSMutableAttributedString(attributedString: text)
-        case .text(let text):
-            attributedText = NSMutableAttributedString(string: text)
-        }
-
-        attributedText.addAttribute(.font, value: config.font, range: attributedText.entireRange)
-
-        // TODO: We might need to do something with linkTextAttributes, but in
-        // general since these don't have an impact on line height hopefully it
-        // should be unnecessary.
-
-        // In order to match `sizeThatFits` semantics on UITextView, we have to
-        // do some adjustments to the bounding box we try and measure in. Note,
-        // this will break if we change certain parameters of the UITextView
-        // like the textContainerInset or the contentInset. Right now we don't
-        // allow changing those paramters (they're hard coded in `buildTextView`)
-        // so we should be safe, but if that were ever to change we'd need to
-        // re-evaluate this measurement strategy. Ideally, we'd get these numbers
-        // from UIKit directly, but I have not found any good way to find them.
-        // If things don't work on certain iOS versions, this is also almost
-        // certainly the culprit (tested on iOS 13 + iOS 14 so far)
-        let textViewHeightAdjustment: CGFloat
-        if #available(iOS 14, *) {
-            textViewHeightAdjustment = 1
-        } else {
-            textViewHeightAdjustment = 1.7
-        }
-
-        var size = attributedText.boundingRect(
-            with: CGSize(width: maxWidth, height: CGFloat.greatestFiniteMagnitude),
-            options: [.usesLineFragmentOrigin],
-            context: nil
-        ).size
-        size.height += textViewHeightAdjustment
-
-        owsAssertDebug(size.width <= maxWidth)
-
-        return size.ceil
-    }
-
     public static func buildTextView() -> OWSMessageTextView {
         let textView = OWSMessageTextView()
 
@@ -583,59 +480,6 @@ public class CVText {
     }
 }
 
-private extension String {
-    // TODO: Figure out if this check is too expensive to do
-    // as frequently as we are. It seems okay in initial examination.
-    var containsCJKCharacters: Bool {
-        range(of: "\\p{Han}", options: .regularExpression) != nil
-    }
-}
-
-private extension NSAttributedString {
-    var withCJKCompatibleFonts: NSAttributedString {
-        let mutableAttributedString = NSMutableAttributedString(attributedString: self)
-        mutableAttributedString.enumerateAttribute(
-            .font,
-            in: mutableAttributedString.entireRange,
-            options: []
-        ) { font, subrange, _ in
-            guard let font = font as? UIFont else { return }
-            mutableAttributedString.addAttribute(
-                .font,
-                value: font.cjkCompatibleVariant,
-                range: subrange
-            )
-        }
-        return NSAttributedString(attributedString: mutableAttributedString)
-    }
-}
-
-private extension UIFont {
-    // The San Francisco font (as of iOS 14) does not allow for correct
-    // measurement of CJK characters. In order to work around this, when
-    // a string is detected to contain a CJK character we replace its font
-    // with HelveticaNeue, which handles measurement correctly.
-    // For more details see: http://www.openradar.me/43337516
-    var cjkCompatibleVariant: UIFont {
-        guard let weight = fontDescriptor.object(forKey: .face) as? String else {
-            owsFailDebug("Missing font weight for font \(self)")
-            return self
-        }
-
-        let replacementFontName: String
-
-        switch weight {
-        case "Regular": replacementFontName = "HelveticaNeue"
-        case "Regular Italic": replacementFontName = "HelveticaNeue-Italic"
-        case "Semibold": replacementFontName = "HelveticaNeue-Medium"
-        default: replacementFontName = "HelveticaNeue-\(weight.replacingOccurrences(of: " ", with: ""))"
-        }
-
-        guard let replacementFont = UIFont(name: replacementFontName, size: pointSize) else {
-            owsFailDebug("Missing cjk compatible font for name \(replacementFontName)")
-            return self
-        }
-
-        return replacementFont
-    }
+private extension NSAttributedString.Key {
+    static var originalFont = Self("NSOriginalFont")
 }
