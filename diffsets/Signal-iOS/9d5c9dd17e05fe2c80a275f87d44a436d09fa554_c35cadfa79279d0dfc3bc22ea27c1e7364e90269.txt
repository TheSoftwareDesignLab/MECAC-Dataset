diff --git a/Signal/src/Calls/CallService.swift b/Signal/src/Calls/CallService.swift
index e9174c226d2..91b65b9f8bf 100644
--- a/Signal/src/Calls/CallService.swift
+++ b/Signal/src/Calls/CallService.swift
@@ -340,13 +340,14 @@ public final class CallService: NSObject {
         guard AppReadiness.isAppReady else { return }
         guard let currentCall = currentCall else { return }
 
-        let useLowBandwidth = Self.useLowBandwidthWithSneakyTransaction()
-        Logger.info("Configuring call for \(useLowBandwidth ? "low" : "standard") bandwidth")
-
         switch currentCall.mode {
         case let .group(call):
+            let useLowBandwidth = Self.shouldUseLowBandwidthWithSneakyTransaction(for: call.localDeviceState.networkRoute)
+            Logger.info("Configuring call for \(useLowBandwidth ? "low" : "standard") bandwidth")
             call.updateBandwidthMode(bandwidthMode: useLowBandwidth ? .low : .normal)
         case let .individual(call) where call.state == .connected:
+            let useLowBandwidth = Self.shouldUseLowBandwidthWithSneakyTransaction(for: call.networkRoute)
+            Logger.info("Configuring call for \(useLowBandwidth ? "low" : "standard") bandwidth")
             callManager.udpateBandwidthMode(bandwidthMode: useLowBandwidth ? .low : .normal)
         default:
             // Do nothing. We'll reapply the bandwidth mode once connected
@@ -354,10 +355,16 @@ public final class CallService: NSObject {
         }
     }
 
-    static func useLowBandwidthWithSneakyTransaction() -> Bool {
+    static func shouldUseLowBandwidthWithSneakyTransaction(for networkRoute: NetworkRoute) -> Bool {
         let highBandwidthInterfaces = databaseStorage.read { readTx in
             Self.highBandwidthNetworkInterfaces(readTx: readTx)
         }
+        if let allowsHighBandwidth = highBandwidthInterfaces.includes(networkRoute.localAdapterType) {
+            return !allowsHighBandwidth
+        }
+        // If we aren't sure whether the current route's high-bandwidth, fall back to checking reachability.
+        // This also handles the situation where WebRTC doesn't know what interface we're on,
+        // which is always true on iOS 11.
         return !Self.reachabilityManager.isReachable(with: highBandwidthInterfaces)
     }
 
@@ -1115,6 +1122,8 @@ extension CallService: CallManagerDelegate {
         networkRoute: NetworkRoute
     ) {
         Logger.info("Network route changed for call: \(call): \(networkRoute.localAdapterType.rawValue)")
+        call.individualCall.networkRoute = networkRoute
+        configureBandwidthMode()
     }
 
     public func callManager(
@@ -1270,3 +1279,23 @@ extension CallMessageUrgency {
     }
     }
 }
+
+extension NetworkInterfaceSet {
+    func includes(_ ringRtcAdapter: NetworkAdapterType) -> Bool? {
+        switch ringRtcAdapter {
+        case .unknown, .vpn, .anyAddress:
+            if self.isEmpty {
+                return false
+            } else if self.inverted.isEmpty {
+                return true
+            } else {
+                // We don't know the underlying interface, so we can't assume anything.
+                return nil
+            }
+        case .cellular, .cellular2G, .cellular3G, .cellular4G, .cellular5G:
+            return self.contains(.cellular)
+        case .ethernet, .wifi, .loopback:
+            return self.contains(.wifi)
+        }
+    }
+}
diff --git a/Signal/src/Calls/Individual/IndividualCall.swift b/Signal/src/Calls/Individual/IndividualCall.swift
index 25fc850872b..e03628728ed 100644
--- a/Signal/src/Calls/Individual/IndividualCall.swift
+++ b/Signal/src/Calls/Individual/IndividualCall.swift
@@ -103,6 +103,8 @@ public class IndividualCall: NSObject, IndividualCallNotificationInfo {
         }
     }
 
+    var networkRoute: NetworkRoute = NetworkRoute(localAdapterType: .unknown)
+
     // MARK: -
 
     // tracking cleanup
diff --git a/Signal/src/Calls/Individual/IndividualCallService.swift b/Signal/src/Calls/Individual/IndividualCallService.swift
index babf04d38dd..e76106f3859 100644
--- a/Signal/src/Calls/Individual/IndividualCallService.swift
+++ b/Signal/src/Calls/Individual/IndividualCallService.swift
@@ -546,7 +546,7 @@ import CallKit
 
             let useTurnOnly = isUnknownCaller || Self.preferences.doCallsHideIPAddress()
 
-            let useLowBandwidth = CallService.useLowBandwidthWithSneakyTransaction()
+            let useLowBandwidth = CallService.shouldUseLowBandwidthWithSneakyTransaction(for: NetworkRoute(localAdapterType: .unknown))
             Logger.info("Configuring call for \(useLowBandwidth ? "low" : "standard") bandwidth")
 
             // Tell the Call Manager to proceed with its active call.
