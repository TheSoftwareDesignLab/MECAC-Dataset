diff --git a/Signal/ConversationView/CVViewState.swift b/Signal/ConversationView/CVViewState.swift
index 1c9f5eaa3fe..b4a1d5be8e6 100644
--- a/Signal/ConversationView/CVViewState.swift
+++ b/Signal/ConversationView/CVViewState.swift
@@ -106,6 +106,7 @@ public class CVViewState: NSObject {
     public var isHidingScrollToNextMentionButton = false
     public var scrollUpdateTimer: Timer?
     public var isWaitingForDeceleration = false
+    public var highlightedMessageId: String?
 
     public var actionOnOpen: ConversationViewAction = .none
 
diff --git a/Signal/ConversationView/CellViews/CVColorOrGradientView.swift b/Signal/ConversationView/CellViews/CVColorOrGradientView.swift
index d65dd827df4..f7e77a7fab2 100644
--- a/Signal/ConversationView/CellViews/CVColorOrGradientView.swift
+++ b/Signal/ConversationView/CellViews/CVColorOrGradientView.swift
@@ -38,6 +38,7 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
     private let gradientLayer = CAGradientLayer()
     private let shapeLayer = CAShapeLayer()
     private let maskLayer = CAShapeLayer()
+    private var dimmerLayer: CALayer?
 
     public var ensureSubviewsFillBounds = false
     public var animationsEnabled = false
@@ -94,6 +95,7 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
               let referenceView = self.referenceView else {
             self.backgroundColor = nil
             gradientLayer.removeFromSuperlayer()
+            dimmerLayer?.removeFromSuperlayer()
             return
         }
 
@@ -101,6 +103,7 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
         case .transparent:
             backgroundColor = nil
             gradientLayer.removeFromSuperlayer()
+            dimmerLayer?.removeFromSuperlayer()
         case .solidColor(let color):
             backgroundColor = color
             gradientLayer.removeFromSuperlayer()
@@ -108,7 +111,7 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
 
             if gradientLayer.superlayer != self.layer {
                 gradientLayer.removeFromSuperlayer()
-                layer.addSublayer(gradientLayer)
+                layer.insertSublayer(gradientLayer, at: 0)
             }
 
             gradientLayer.frame = self.bounds
@@ -275,6 +278,7 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
         self.hasPillRounding = false
         shapeLayer.removeFromSuperlayer()
         gradientLayer.removeFromSuperlayer()
+        dimmerLayer?.removeFromSuperlayer()
     }
 
     // MARK: - CALayerDelegate
@@ -288,6 +292,71 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
         }
 
     }
+
+    // MARK: - DimmableView
+
+    // Layer is not created until it's needed so storing color in a variable is necessary.
+    var dimmingColor: UIColor? {
+        didSet {
+            dimmerLayer?.backgroundColor = dimmingColor?.cgColor
+        }
+    }
+
+    var dimmerDimsBackgroundOnly = true
+
+    private var sublayerIndexForDimmerLayer: UInt32 {
+        if dimmerDimsBackgroundOnly {
+            // As deep as possible but above the gradient layer.
+            if gradientLayer.superlayer == self.layer {
+                return 1
+            } else {
+                return 0
+            }
+        } else {
+            return UInt32(layer.sublayers?.count ?? 0)
+        }
+    }
+
+    func performDimmingAnimation(stepDuration: TimeInterval) {
+        guard let dimmingColor else { return }
+
+        var dimmerLayer: CALayer
+        if let existingDimmerLayer = self.dimmerLayer {
+            dimmerLayer = existingDimmerLayer
+        } else {
+            dimmerLayer = CALayer()
+            dimmerLayer.opacity = 0
+            dimmerLayer.backgroundColor = dimmingColor.cgColor
+            self.dimmerLayer = dimmerLayer
+        }
+
+        // Move dimmer layer to a correct z-index.
+        dimmerLayer.removeFromSuperlayer()
+        dimmerLayer.frame = layer.bounds
+        layer.insertSublayer(dimmerLayer, at: sublayerIndexForDimmerLayer)
+
+        dimmerLayer.removeAllAnimations()
+
+        // Animate fade-in.
+        let fadeIn = CABasicAnimation(keyPath: #keyPath(CALayer.opacity))
+        fadeIn.fromValue = 0
+        fadeIn.toValue = 1
+        fadeIn.duration = stepDuration
+        fadeIn.fillMode = .forwards
+        fadeIn.isRemovedOnCompletion = false
+        dimmerLayer.add(fadeIn, forKey: "fadeIn")
+
+        // Schedule fade-out after delay.
+        DispatchQueue.main.asyncAfter(deadline: .now() + 2 * stepDuration) {
+            let fadeOut = CABasicAnimation(keyPath: #keyPath(CALayer.opacity))
+            fadeOut.fromValue = 1
+            fadeOut.toValue = 0
+            fadeOut.duration = stepDuration
+            fadeOut.fillMode = .forwards
+            fadeOut.isRemovedOnCompletion = false
+            dimmerLayer.add(fadeOut, forKey: "fadeOut")
+        }
+    }
 }
 
 // MARK: -
diff --git a/Signal/ConversationView/Components/CVComponentMessage.swift b/Signal/ConversationView/Components/CVComponentMessage.swift
index ce1b4faa367..c86dc3695ab 100644
--- a/Signal/ConversationView/Components/CVComponentMessage.swift
+++ b/Signal/ConversationView/Components/CVComponentMessage.swift
@@ -466,6 +466,7 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
             chatColorView.configure(value: self.bubbleChatColor,
                                     referenceView: componentDelegate.view,
                                     bubbleConfig: bubbleConfig)
+            chatColorView.dimmerDimsBackgroundOnly = true
             outerBubbleView = chatColorView
         }
 
@@ -525,6 +526,7 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
                             // to reflect the bubble view state.
                             bubbleViewPartner.updateLayers()
                         }
+                        outerBubbleView?.dimmerDimsBackgroundOnly = false
                     }
                 } else {
                     owsFailDebug("Invalid component.")
@@ -2225,6 +2227,13 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
                 swipeToReplyWrapper.layer.removeAllAnimations()
             }
         }
+
+        // MARK: - Flashing Message Bubble
+
+        func performMessageBubbleHighlightAnimation() {
+            chatColorView.dimmingColor = Theme.isDarkThemeEnabled ? .ows_whiteAlpha25 : .ows_blackAlpha25
+            chatColorView.performDimmingAnimation(stepDuration: 0.4)
+        }
     }
 
     // MARK: - Swipe To Reply
diff --git a/Signal/ConversationView/ConversationViewController+CVC.swift b/Signal/ConversationView/ConversationViewController+CVC.swift
index 243d484a6cd..f5127ab2d00 100644
--- a/Signal/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/ConversationView/ConversationViewController+CVC.swift
@@ -59,6 +59,37 @@ extension ConversationViewController {
     }
 }
 
+// MARK: - Message Highlighting
+//
+// The purpose of the code below is to briefly dim message bubble to indicate the message of interest to the user.
+// Because bubble highlighting is designed to be very brief, all the logic operates exclusively with the
+// presentation layer and no state is saved or restored.
+
+extension ConversationViewController {
+
+    func performMessageHighlightAnimationIfNeeded() {
+        if let messageId = viewState.highlightedMessageId {
+            performHighlightAnimationSequenceFor(messageId: messageId)
+            viewState.highlightedMessageId = nil
+        }
+    }
+
+    private func performHighlightAnimationSequenceFor(messageId: String) {
+        if let indexPath = indexPath(forInteractionUniqueId: messageId) {
+            guard let cell = collectionView.cellForItem(at: indexPath) as? CVCell,
+                  let componentViewMessage = cell.componentView as? CVComponentMessage.CVComponentViewMessage
+            else {
+                owsFailDebug("Could not find CVComponentViewMessage")
+                return
+            }
+
+            componentViewMessage.performMessageBubbleHighlightAnimation()
+        } else {
+            owsFailDebug("Unable to find a message to highlight. [\(messageId)]")
+        }
+    }
+}
+
 // MARK: -
 
 extension ConversationViewController: CVLoadCoordinatorDelegate {
diff --git a/Signal/ConversationView/ConversationViewController+Delegates.swift b/Signal/ConversationView/ConversationViewController+Delegates.swift
index 632c9c44e1c..02252426825 100644
--- a/Signal/ConversationView/ConversationViewController+Delegates.swift
+++ b/Signal/ConversationView/ConversationViewController+Delegates.swift
@@ -460,7 +460,9 @@ extension ConversationViewController {
         scrollingAnimationCompletionTimer = nil
 
         autoLoadMoreIfNecessary()
-    }
+
+        performMessageHighlightAnimationIfNeeded()
+   }
 
     func resetForSizeOrOrientationChange() {
         AssertIsOnMainThread()
diff --git a/Signal/ConversationView/ConversationViewController+Scroll.swift b/Signal/ConversationView/ConversationViewController+Scroll.swift
index 99cc5e35430..0f5c1a82989 100644
--- a/Signal/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/ConversationView/ConversationViewController+Scroll.swift
@@ -88,6 +88,8 @@ extension ConversationViewController {
             break
         case .scrollTo(let interactionId, let onScreenPercentage, let alignment):
             if let indexPath = self.indexPath(forInteractionUniqueId: interactionId) {
+                viewState.highlightedMessageId = interactionId
+
                 // TODO: Set position and animated.
                 scrollToInteraction(
                     indexPath: indexPath,
@@ -233,11 +235,17 @@ extension ConversationViewController {
             && attributes.frame.maxY < currentMaximumVisibleOffset
 
         // If the collection view contents aren't scrollable, do nothing.
-        guard safeContentHeight > collectionViewHeightUnobscuredByBottomBar else { return }
+        guard safeContentHeight > collectionViewHeightUnobscuredByBottomBar else {
+            performMessageHighlightAnimationIfNeeded()
+            return
+        }
 
         // If the destination row is entirely visible AND the desired position
         // is only valid for when the view is not on screen, do nothing.
-        guard !alignment.scrollsOnlyIfNotEntirelyOnScreen || !rowIsEntirelyOnScreen else { return }
+        guard !alignment.scrollsOnlyIfNotEntirelyOnScreen || !rowIsEntirelyOnScreen else {
+            performMessageHighlightAnimationIfNeeded()
+            return
+        }
 
         guard indexPath != lastIndexPathInLoadedWindow || !onScreenPercentage.isEqual(to: 1) else {
             // If we're scrolling to the last index AND we want it entirely on screen,
@@ -335,10 +343,11 @@ extension ConversationViewController {
                                                         alignment: ScrollAlignment,
                                                         isAnimated: Bool = true) {
         if let indexPath = self.indexPath(forInteractionUniqueId: interactionId) {
-            self.scrollToInteraction(indexPath: indexPath,
-                                     onScreenPercentage: onScreenPercentage,
-                                     alignment: alignment,
-                                     animated: isAnimated)
+            viewState.highlightedMessageId = interactionId
+            scrollToInteraction(indexPath: indexPath,
+                                onScreenPercentage: onScreenPercentage,
+                                alignment: alignment,
+                                animated: isAnimated)
         } else {
             loadCoordinator.enqueueLoadAndScrollToInteraction(interactionId: interactionId,
                                                               onScreenPercentage: onScreenPercentage,
