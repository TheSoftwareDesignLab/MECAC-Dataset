diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 9df6ef371a8..d49286971c1 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -810,6 +810,7 @@
 		76A2EB1028B578B800A29C24 /* MediaTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 76A2EB0F28B578B800A29C24 /* MediaTextView.swift */; };
 		76A2EB1228B57AEE00A29C24 /* ColorPickerBar.swift in Sources */ = {isa = PBXBuildFile; fileRef = 76A2EB1128B57AEE00A29C24 /* ColorPickerBar.swift */; };
 		76C87F19181EFCE600C4ACAB /* MediaPlayer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 76C87F18181EFCE600C4ACAB /* MediaPlayer.framework */; };
+		76C87FE128BE8E2400BD8709 /* LinkPreviewAttachmentViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 76C87FE028BE8E2400BD8709 /* LinkPreviewAttachmentViewController.swift */; };
 		76EB054018170B33006006FC /* AppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C318170B33006006FC /* AppDelegate.m */; };
 		76FCCDBC27AB8FBE00BAA7F0 /* MediaControls.swift in Sources */ = {isa = PBXBuildFile; fileRef = 76FCCDBB27AB8FBE00BAA7F0 /* MediaControls.swift */; };
 		83B9573927C9A1FA00A678FD /* CaptchaView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 83B9573827C9A1FA00A678FD /* CaptchaView.swift */; };
@@ -3074,6 +3075,7 @@
 		76A2EB0F28B578B800A29C24 /* MediaTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaTextView.swift; sourceTree = "<group>"; };
 		76A2EB1128B57AEE00A29C24 /* ColorPickerBar.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ColorPickerBar.swift; sourceTree = "<group>"; };
 		76C87F18181EFCE600C4ACAB /* MediaPlayer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = MediaPlayer.framework; path = System/Library/Frameworks/MediaPlayer.framework; sourceTree = SDKROOT; };
+		76C87FE028BE8E2400BD8709 /* LinkPreviewAttachmentViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LinkPreviewAttachmentViewController.swift; sourceTree = "<group>"; };
 		76EB03C218170B33006006FC /* AppDelegate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AppDelegate.h; sourceTree = "<group>"; };
 		76EB03C318170B33006006FC /* AppDelegate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AppDelegate.m; sourceTree = "<group>"; };
 		76FCCDBB27AB8FBE00BAA7F0 /* MediaControls.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaControls.swift; sourceTree = "<group>"; };
@@ -5521,6 +5523,7 @@
 				340D8FFF24FEE6A9007B5504 /* GroupInviteLinksUI.swift */,
 				3490D57C25ADDC2900F5F96C /* GroupLinkPromotionActionSheet.swift */,
 				3405C0652541C3E6008B24EF /* GroupMigrationActionSheet.swift */,
+				76C87FE028BE8E2400BD8709 /* LinkPreviewAttachmentViewController.swift */,
 				4542DF53208D40AC007B4E76 /* LoadingViewController.swift */,
 				88A9729322FB4D02004B4FBF /* LocationPicker.swift */,
 				3496744E2076ACCE00080B5F /* LongTextViewController.swift */,
@@ -10231,6 +10234,7 @@
 				88A505FA23DBA1360005C012 /* IntroducingPINs.swift in Sources */,
 				32AC5CE7255B51E900829BD8 /* JoinGroupCallPill.swift in Sources */,
 				3437F63A2512835300AC1767 /* LinkedDevicesTableViewController.swift in Sources */,
+				76C87FE128BE8E2400BD8709 /* LinkPreviewAttachmentViewController.swift in Sources */,
 				4542DF54208D40AC007B4E76 /* LoadingViewController.swift in Sources */,
 				4C25768A23AD510800E0398D /* LoadMoreMessagesView.swift in Sources */,
 				88238EA224E9DDB700F28079 /* LocalVideoView.swift in Sources */,
diff --git a/Signal/Images.xcassets/error-outline-24.imageset/Contents.json b/Signal/Images.xcassets/error-outline-24.imageset/Contents.json
index d3edbd5cfbb..a82457a9229 100644
--- a/Signal/Images.xcassets/error-outline-24.imageset/Contents.json
+++ b/Signal/Images.xcassets/error-outline-24.imageset/Contents.json
@@ -8,5 +8,8 @@
   "info" : {
     "author" : "xcode",
     "version" : 1
+  },
+  "properties" : {
+    "template-rendering-intent" : "template"
   }
 }
diff --git a/Signal/Images.xcassets/link-diagonal.imageset/Contents.json b/Signal/Images.xcassets/link-diagonal.imageset/Contents.json
new file mode 100644
index 00000000000..fbac2f7a074
--- /dev/null
+++ b/Signal/Images.xcassets/link-diagonal.imageset/Contents.json
@@ -0,0 +1,15 @@
+{
+  "images" : [
+    {
+      "filename" : "link-diagonal.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/link-diagonal.imageset/link-diagonal.pdf b/Signal/Images.xcassets/link-diagonal.imageset/link-diagonal.pdf
new file mode 100644
index 00000000000..171f006af35
Binary files /dev/null and b/Signal/Images.xcassets/link-diagonal.imageset/link-diagonal.pdf differ
diff --git a/Signal/Images.xcassets/x-24.imageset/Contents.json b/Signal/Images.xcassets/x-24.imageset/Contents.json
index 1f25af162c2..c099446330c 100644
--- a/Signal/Images.xcassets/x-24.imageset/Contents.json
+++ b/Signal/Images.xcassets/x-24.imageset/Contents.json
@@ -1,23 +1,15 @@
 {
   "images" : [
     {
-      "idiom" : "universal",
-      "filename" : "x-24@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "x-24@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "x-24@3x.png",
-      "scale" : "3x"
+      "filename" : "x-24.pdf",
+      "idiom" : "universal"
     }
   ],
   "info" : {
-    "version" : 1,
-    "author" : "xcode"
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "template-rendering-intent" : "template"
   }
-}
\ No newline at end of file
+}
diff --git a/Signal/Images.xcassets/x-24.imageset/x-24.pdf b/Signal/Images.xcassets/x-24.imageset/x-24.pdf
new file mode 100644
index 00000000000..b5cffcd04a2
Binary files /dev/null and b/Signal/Images.xcassets/x-24.imageset/x-24.pdf differ
diff --git a/Signal/Images.xcassets/x-24.imageset/x-24@1x.png b/Signal/Images.xcassets/x-24.imageset/x-24@1x.png
deleted file mode 100644
index ee6d0b88744..00000000000
Binary files a/Signal/Images.xcassets/x-24.imageset/x-24@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/x-24.imageset/x-24@2x.png b/Signal/Images.xcassets/x-24.imageset/x-24@2x.png
deleted file mode 100644
index ea502285caf..00000000000
Binary files a/Signal/Images.xcassets/x-24.imageset/x-24@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/x-24.imageset/x-24@3x.png b/Signal/Images.xcassets/x-24.imageset/x-24@3x.png
deleted file mode 100644
index cbb9bb263d5..00000000000
Binary files a/Signal/Images.xcassets/x-24.imageset/x-24@3x.png and /dev/null differ
diff --git a/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift b/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
index ce4a443f11e..b1e84370588 100644
--- a/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
+++ b/Signal/src/ViewControllers/CameraFirstCaptureSendFlow.swift
@@ -12,11 +12,12 @@ protocol CameraFirstCaptureDelegate: AnyObject {
 
 @objc
 class CameraFirstCaptureSendFlow: NSObject {
-    @objc
-    weak var delegate: CameraFirstCaptureDelegate?
+
+    private weak var delegate: CameraFirstCaptureDelegate?
 
     private var approvedAttachments: [SignalAttachment]?
     private var approvalMessageBody: MessageBody?
+    private var textAttachment: TextAttachment?
 
     private var mentionCandidates: [SignalServiceAddress] = []
 
@@ -24,8 +25,9 @@ class CameraFirstCaptureSendFlow: NSObject {
     private var selectedConversations: [ConversationItem] { selection.conversations }
 
     private let storiesOnly: Bool
-    init(storiesOnly: Bool) {
+    init(storiesOnly: Bool, delegate: CameraFirstCaptureDelegate?) {
         self.storiesOnly = storiesOnly
+        self.delegate = delegate
         super.init()
     }
 
@@ -79,6 +81,16 @@ extension CameraFirstCaptureSendFlow: SendMediaNavDelegate {
         sendMediaNavigationController.pushViewController(pickerVC, animated: true)
     }
 
+    func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didFinishWithTextAttachment textAttachment: TextAttachment) {
+        self.textAttachment = textAttachment
+
+        let pickerVC = ConversationPickerViewController(selection: selection)
+        pickerVC.pickerDelegate = self
+        pickerVC.isStorySectionExpanded = true
+        pickerVC.sectionOptions = .stories
+        sendMediaNavigationController.pushViewController(pickerVC, animated: true)
+    }
+
     func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didChangeMessageBody newMessageBody: MessageBody?) {
         self.approvalMessageBody = newMessageBody
     }
@@ -110,6 +122,25 @@ extension CameraFirstCaptureSendFlow: ConversationPickerDelegate {
     }
 
     public func conversationPickerDidCompleteSelection(_ conversationPickerViewController: ConversationPickerViewController) {
+        if let textAttachment = textAttachment {
+            let selectedStoryItems = selectedConversations.filter { $0 is StoryConversationItem }
+            guard !selectedStoryItems.isEmpty else {
+                owsFailDebug("Selection was unexpectedly empty.")
+                delegate?.cameraFirstCaptureSendFlowDidCancel(self)
+                return
+            }
+
+            firstly {
+                AttachmentMultisend.sendTextAttachment(textAttachment, to: selectedStoryItems)
+            }.done { _ in
+                self.delegate?.cameraFirstCaptureSendFlowDidComplete(self)
+            }.catch { error in
+                owsFailDebug("Error: \(error)")
+            }
+
+            return
+        }
+
         guard let approvedAttachments = self.approvedAttachments else {
             owsFailDebug("approvedAttachments was unexpectedly nil")
             delegate?.cameraFirstCaptureSendFlowDidCancel(self)
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
index 5c6fe9effe5..7cae239cd39 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
@@ -821,6 +821,11 @@ extension ConversationViewController: SendMediaNavDelegate {
         self.dismiss(animated: true, completion: nil)
     }
 
+    func sendMediaNav(_ sendMediaNavifationController: SendMediaNavigationController,
+                      didFinishWithTextAttachment textAttachment: TextAttachment) {
+        owsFailDebug("Can not post text stories to chat.")
+    }
+
     func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController,
                       didChangeMessageBody newMessageBody: MessageBody?) {
         guard hasViewWillAppearEverBegun else {
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.m b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.m
index 178c36a2c59..7069f360c53 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.m	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController.m	
@@ -675,8 +675,7 @@ - (void)showCameraView
             }
 
             CameraFirstCaptureNavigationController *cameraModal =
-                [CameraFirstCaptureNavigationController cameraFirstModalWithStoriesOnly:NO];
-            cameraModal.cameraFirstCaptureSendFlow.delegate = self;
+                [CameraFirstCaptureNavigationController cameraFirstModalWithStoriesOnly:NO delegate:self];
             cameraModal.modalPresentationStyle = UIModalPresentationOverFullScreen;
 
             // Defer hiding status bar until modal is fully onscreen
diff --git a/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift
index 69ab8954309..94fb2a8c47f 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/StoriesViewController.swift
@@ -224,8 +224,7 @@ class StoriesViewController: OWSViewController, StoryListDataSourceDelegate {
                     Logger.warn("proceeding, though mic permission denied.")
                 }
 
-                let modal = CameraFirstCaptureNavigationController.cameraFirstModal(storiesOnly: true)
-                modal.cameraFirstCaptureSendFlow.delegate = self
+                let modal = CameraFirstCaptureNavigationController.cameraFirstModal(storiesOnly: true, delegate: self)
                 self.presentFullScreen(modal, animated: true)
             }
         }
diff --git a/Signal/src/ViewControllers/LinkPreviewAttachmentViewController.swift b/Signal/src/ViewControllers/LinkPreviewAttachmentViewController.swift
new file mode 100644
index 00000000000..8e2354ae36b
--- /dev/null
+++ b/Signal/src/ViewControllers/LinkPreviewAttachmentViewController.swift
@@ -0,0 +1,382 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import SignalUI
+import UIKit
+
+protocol LinkPreviewAttachmentViewControllerDelegate: AnyObject {
+    func linkPreviewAttachmentViewController(_ viewController: LinkPreviewAttachmentViewController,
+                                             didFinishWith linkPreview: OWSLinkPreviewDraft)
+}
+
+class LinkPreviewAttachmentViewController: InteractiveSheetViewController {
+
+    weak var delegate: LinkPreviewAttachmentViewControllerDelegate?
+
+    init(_ linkPreview: OWSLinkPreviewDraft?) {
+        super.init()
+        self.linkPreview = linkPreview
+        self.currentPreviewUrl = linkPreview?.url
+    }
+
+    convenience required init() {
+        self.init(nil)
+    }
+
+    private let linkPreviewPanel = LinkPreviewPanel()
+
+    private let textField: UITextField = {
+        let textField = UITextField()
+        textField.autocapitalizationType = .none
+        textField.autocorrectionType = .no
+        textField.font = .ows_dynamicTypeBodyClamped
+        textField.keyboardAppearance = .dark
+        textField.keyboardType = .URL
+        textField.textColor = .ows_gray05
+        textField.textContentType = .URL
+        textField.attributedPlaceholder = NSAttributedString(
+            string: NSLocalizedString("STORY_COMPOSER_URL_FIELD_PLACEHOLDER",
+                                      value: "Type or paste a URL",
+                                      comment: "Placeholder text for URL input field in Text Story composer UI."),
+            attributes: [ .foregroundColor: UIColor.ows_gray25 ])
+        return textField
+    }()
+    private lazy var textFieldContainer: UIView = {
+        let view = PillView()
+        view.backgroundColor = .ows_gray80
+        view.layoutMargins = UIEdgeInsets(top: 0, left: 16, bottom: 0, right: 16)
+        view.addSubview(textField)
+        textField.autoPinEdgesToSuperviewMargins()
+        return view
+    }()
+    private let doneButton: UIButton = {
+        let button = RoundMediaButton(image: UIImage(imageLiteralResourceName: "check-24"),
+                                      backgroundStyle: .solid(.ows_accentBlue))
+        button.layoutMargins = .zero
+        button.contentEdgeInsets = UIEdgeInsets(margin: 10)
+        button.setContentHuggingHigh()
+        return button
+    }()
+    private lazy var inputFieldContainer: UIView = {
+        let stackView = UIStackView(arrangedSubviews: [ textFieldContainer, doneButton ])
+        stackView.axis = .horizontal
+        stackView.spacing = 10
+        return stackView
+    }()
+    private var bottomContentMarginConstraint: NSLayoutConstraint?
+
+    override func viewDidLoad() {
+        super.viewDidLoad()
+
+        contentView.preservesSuperviewLayoutMargins = true
+        contentView.superview?.preservesSuperviewLayoutMargins = true
+
+        let stackView = UIStackView(arrangedSubviews: [ linkPreviewPanel, inputFieldContainer ])
+        stackView.axis = .vertical
+        stackView.spacing = 24
+        contentView.addSubview(stackView)
+        stackView.autoPinEdges(toSuperviewMarginsExcludingEdge: .bottom)
+
+        // Bottom margin is flexible so that text field is positioned above the onscreen keyboard.
+        bottomContentMarginConstraint = contentView.bottomAnchor.constraint(equalTo: stackView.bottomAnchor, constant: 12)
+        bottomContentMarginConstraint?.priority = .defaultLow
+        bottomContentMarginConstraint?.isActive = true
+
+        textField.addTarget(self, action: #selector(textDidChange), for: .editingChanged)
+        doneButton.addTarget(self, action: #selector(doneButtonPressed), for: .touchUpInside)
+
+        if let linkPreview = linkPreview {
+            textField.text = linkPreview.urlString
+            linkPreviewPanel.setState(.draft(linkPreview), animated: false)
+        }
+
+        updateUIOnLinkPreviewStateChange()
+   }
+
+    override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        // Resize the view to it's final bounds so that resizing
+        // isn't animated with keyboard.
+        UIView.performWithoutAnimation {
+            self.view.bounds = UIScreen.main.bounds
+            self.updateSheetHeight()
+            self.view.setNeedsLayout()
+            self.view.layoutIfNeeded()
+        }
+
+        textField.becomeFirstResponder()
+        startObservingKeyboardNotifications()
+    }
+
+    override var canBecomeFirstResponder: Bool { true }
+
+    override var sheetBackgroundColor: UIColor { .ows_gray95 }
+
+    private var sheetHeight: CGFloat = 0
+    private func updateSheetHeight() {
+        guard let sheetView = contentView.superview else { return }
+
+        let sheetSize = sheetView.systemLayoutSizeFitting(.init(width: maxWidth, height: .greatestFiniteMagnitude),
+                                                          withHorizontalFittingPriority: .required,
+                                                          verticalFittingPriority: .fittingSizeLevel)
+        if sheetHeight != sheetSize.height {
+            sheetHeight = sheetSize.height
+            heightConstraint.constant = sheetHeight
+        }
+    }
+
+    override var minHeight: CGFloat {
+        guard sheetHeight > 0 else { return super.minHeight }
+        return sheetHeight
+    }
+
+    override var maximizedHeight: CGFloat {
+        guard sheetHeight > 0 else { return super.maximizedHeight }
+        return sheetHeight
+    }
+
+    private func updateUIOnLinkPreviewStateChange() {
+        doneButton.isEnabled = linkPreview != nil
+        updateSheetHeight()
+    }
+
+    @objc
+    private func textDidChange() {
+        updateLinkPreviewIfNecessary()
+    }
+
+    @objc
+    private func doneButtonPressed() {
+        guard let linkPreview = linkPreview else { return }
+        delegate?.linkPreviewAttachmentViewController(self, didFinishWith: linkPreview)
+    }
+
+    // MARK: - Keyboard Handling
+
+    private func startObservingKeyboardNotifications() {
+        NotificationCenter.default.addObserver(self,
+                                               selector: #selector(handleKeyboardNotification(_:)),
+                                               name: UIResponder.keyboardWillShowNotification,
+                                               object: nil)
+        NotificationCenter.default.addObserver(self,
+                                               selector: #selector(handleKeyboardNotification(_:)),
+                                               name: UIResponder.keyboardWillHideNotification,
+                                               object: nil)
+        NotificationCenter.default.addObserver(self,
+                                               selector: #selector(handleKeyboardNotification(_:)),
+                                               name: UIResponder.keyboardWillChangeFrameNotification,
+                                               object: nil)
+    }
+
+    @objc
+    private func handleKeyboardNotification(_ notification: Notification) {
+        guard
+            let userInfo = notification.userInfo,
+            let beginFrame = userInfo[UIResponder.keyboardFrameBeginUserInfoKey] as? CGRect,
+            let endFrame = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect else { return }
+
+        guard beginFrame.height != endFrame.height || beginFrame.minY == UIScreen.main.bounds.height else { return }
+
+        let layoutUpdateBlock = {
+            self.bottomContentMarginConstraint?.constant = endFrame.height + 12
+            self.updateSheetHeight()
+        }
+        if
+            let animationDuration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? TimeInterval,
+            let rawAnimationCurve = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? Int,
+            let animationCurve = UIView.AnimationCurve(rawValue: rawAnimationCurve)
+        {
+            UIView.beginAnimations("sheetResize", context: nil)
+            UIView.setAnimationBeginsFromCurrentState(true)
+            UIView.setAnimationCurve(animationCurve)
+            UIView.setAnimationDuration(animationDuration)
+            layoutUpdateBlock()
+            view.setNeedsLayout()
+            view.layoutIfNeeded()
+            UIView.commitAnimations()
+        } else {
+            UIView.performWithoutAnimation {
+                layoutUpdateBlock()
+            }
+        }
+    }
+
+    // MARK: - Link Preview fetching
+
+    private var linkPreview: OWSLinkPreviewDraft?
+
+    private var currentPreviewUrl: URL? {
+        didSet {
+            guard currentPreviewUrl != oldValue else { return }
+            guard let previewUrl = currentPreviewUrl else { return }
+
+            linkPreviewManager.fetchLinkPreview(for: previewUrl).done(on: .main) { [weak self] draft in
+                guard let self = self else { return }
+                guard self.currentPreviewUrl == previewUrl else { return }
+                self.displayLinkPreview(draft)
+            }.catch(on: .main) { [weak self] error in
+                guard let self = self else { return }
+                guard self.currentPreviewUrl == previewUrl else { return }
+                self.clearLinkPreview(withError: error)
+            }
+        }
+    }
+
+    private func updateLinkPreviewIfNecessary() {
+        guard let trimmedText = textField.text?.ows_stripped(), !trimmedText.isEmpty else {
+            clearLinkPreview()
+            return
+        }
+        guard let previewUrl = linkPreviewManager.findFirstValidUrl(in: trimmedText) else { return clearLinkPreview() }
+        currentPreviewUrl = previewUrl
+    }
+
+    private func displayLinkPreview(_ linkPreview: OWSLinkPreviewDraft) {
+        self.linkPreview = linkPreview
+        linkPreviewPanel.setState(.draft(linkPreview), animated: true)
+        updateUIOnLinkPreviewStateChange()
+    }
+
+    private func clearLinkPreview(withError error: Error? = nil) {
+        currentPreviewUrl = nil
+        linkPreview = nil
+        if let error = error, case LinkPreviewError.fetchFailure = error {
+            linkPreviewPanel.setState(.error, animated: true)
+        } else {
+            linkPreviewPanel.setState(.placeholder, animated: true)
+        }
+        updateUIOnLinkPreviewStateChange()
+    }
+
+    private class LinkPreviewPanel: UIView {
+
+        enum State: Equatable {
+            case placeholder
+            case loading
+            case draft(OWSLinkPreviewDraft)
+            case error
+        }
+        private var _internalState: State = .placeholder
+        var state: State {
+            get { _internalState }
+            set { setState(newValue, animated: false) }
+        }
+        func setState(_ state: State, animated: Bool) {
+            guard _internalState != state else { return }
+            _internalState = state
+            updateContentViewForCurrentState(animated: animated)
+        }
+
+        override init(frame: CGRect) {
+            super.init(frame: frame)
+            updateContentViewForCurrentState(animated: false)
+        }
+
+        required init?(coder: NSCoder) {
+            fatalError("init(coder:) has not been implemented")
+        }
+
+        override var intrinsicContentSize: CGSize { CGSize(width: UIView.noIntrinsicMetric, height: 100) }
+
+        // MARK: - Layout
+
+        private lazy var placeholderView: UIView = {
+            let icon = UIImageView(image: UIImage(imageLiteralResourceName: "link-diagonal"))
+            icon.tintColor = .ows_gray45
+            icon.setContentHuggingHigh()
+
+            let label = UILabel()
+            label.font = .ows_dynamicTypeBody2Clamped
+            label.lineBreakMode = .byWordWrapping
+            label.numberOfLines = 0
+            label.textAlignment = .center
+            label.textColor = .ows_gray45
+            label.text = NSLocalizedString("STORY_COMPOSER_LINK_PREVIEW_PLACEHOLDER",
+                                           value: "Share a link with viewers of your story",
+                                           comment: "Displayed in text story composer when user is about to attach a link with preview")
+
+            let stackView = UIStackView(arrangedSubviews: [ icon, label ])
+            stackView.axis = .vertical
+            stackView.alignment = .center
+            stackView.spacing = 8
+            return stackView
+        }()
+
+        private lazy var activityIndicatorView = UIActivityIndicatorView(style: .whiteLarge)
+        private lazy var loadingView: UIView = {
+            let view = UIView()
+            view.addSubview(activityIndicatorView)
+            activityIndicatorView.autoCenterInSuperview()
+            return view
+        }()
+
+        private var linkPreviewView: TextAttachmentView.LinkPreviewView?
+
+        private lazy var errorView: UIView = {
+            let exclamationMark = UIImageView(image: UIImage(imageLiteralResourceName: "error-outline-24"))
+            exclamationMark.tintColor = .ows_gray15
+            exclamationMark.setContentHuggingHigh()
+
+            let label = UILabel()
+            label.font = .ows_dynamicTypeBody2Clamped
+            label.lineBreakMode = .byWordWrapping
+            label.numberOfLines = 0
+            label.textAlignment = .center
+            label.textColor = .ows_gray05
+            label.text = NSLocalizedString("STORY_COMPOSER_LINK_PREVIEW_ERROR",
+                                           value: "Couldn't load link. Check your connection and try again.",
+                                           comment: "Displayed when failed to fetch link preview in Text Story composer.")
+
+            let stackView = UIStackView(arrangedSubviews: [ exclamationMark, label ])
+            stackView.axis = .vertical
+            stackView.alignment = .center
+            stackView.spacing = 8
+            return stackView
+        }()
+
+        private var contentViews = Set<UIView>()
+
+        private func loadContentView(forState state: State) -> UIView {
+            if let linkPreviewView = linkPreviewView {
+                linkPreviewView.removeFromSuperview()
+                contentViews.remove(linkPreviewView)
+                self.linkPreviewView = nil
+            }
+
+            let view: UIView = {
+                switch state {
+                case .placeholder:
+                    return placeholderView
+                case .loading:
+                    return loadingView
+                case .draft(let linkPreviewDraft):
+                    return TextAttachmentView.LinkPreviewView(linkPreview: LinkPreviewDraft(linkPreviewDraft: linkPreviewDraft))
+                case .error:
+                    return errorView
+                }
+            }()
+            guard !contentViews.contains(view) else { return view }
+
+            view.isHidden = true
+            contentViews.insert(view)
+            addSubview(view)
+            view.autoPinWidthToSuperview()
+            view.autoVCenterInSuperview()
+            view.autoPinHeightToSuperview(relation: .lessThanOrEqual)
+            return view
+        }
+
+        private func updateContentViewForCurrentState(animated: Bool) {
+            let viewToMakeVisible = loadContentView(forState: state)
+            viewToMakeVisible.setIsHidden(false, animated: animated)
+            if case .draft = state {
+                linkPreviewView = viewToMakeVisible as? TextAttachmentView.LinkPreviewView
+            }
+
+            let viewsToHide = contentViews.subtracting([viewToMakeVisible])
+            viewsToHide.forEach { $0.setIsHidden(true, animated: animated) }
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/Photos/MediaControls.swift b/Signal/src/ViewControllers/Photos/MediaControls.swift
index ffc658e3302..1e32bfcfd3f 100644
--- a/Signal/src/ViewControllers/Photos/MediaControls.swift
+++ b/Signal/src/ViewControllers/Photos/MediaControls.swift
@@ -1169,11 +1169,7 @@ class FlashModeButton: RoundMediaButton {
     private var flashMode: AVCaptureDevice.FlashMode = .auto
 
     required init() {
-        super.init(image: FlashModeButton.flashAuto, backgroundStyle: .blur)
-    }
-
-    required init(image: UIImage?, backgroundStyle: RoundMediaButton.BackgroundStyle) {
-        fatalError("init(image:backgroundStyle:) has not been implemented")
+        super.init(image: FlashModeButton.flashAuto, backgroundStyle: .blur, customView: nil)
     }
 
     func setFlashMode(_ flashMode: AVCaptureDevice.FlashMode, animated: Bool) {
@@ -1201,12 +1197,8 @@ class CameraChooserButton: RoundMediaButton {
 
     var isFrontCameraActive = false
 
-    required init(backgroundStyle: RoundMediaButton.BackgroundStyle) {
-        super.init(image: UIImage(named: "media-composer-switch-camera"), backgroundStyle: backgroundStyle)
-    }
-
-    required init(image: UIImage?, backgroundStyle: RoundMediaButton.BackgroundStyle) {
-        fatalError("init(image:backgroundStyle:) has not been implemented")
+    init(backgroundStyle: RoundMediaButton.BackgroundStyle) {
+        super.init(image: UIImage(named: "media-composer-switch-camera"), backgroundStyle: backgroundStyle, customView: nil)
     }
 
     func performSwitchAnimation() {
@@ -1222,12 +1214,8 @@ class CaptureModeButton: RoundMediaButton {
     private static let batchModeOn = UIImage(named: "media-composer-create-album-solid")
     private static let batchModeOff = UIImage(named: "media-composer-create-album-outline")
 
-    required init() {
-        super.init(image: CaptureModeButton.batchModeOff, backgroundStyle: .blur)
-    }
-
-    required init(image: UIImage?, backgroundStyle: RoundMediaButton.BackgroundStyle) {
-        fatalError("init(image:backgroundStyle:) has not been implemented")
+    init() {
+        super.init(image: CaptureModeButton.batchModeOff, backgroundStyle: .blur, customView: nil)
     }
 
     private var captureMode = PhotoCaptureViewController.CaptureMode.single
@@ -1416,18 +1404,33 @@ class CameraBottomBar: UIView {
         }
     }
 
-    var isRecordingVideo = false {
-        didSet {
-            photoLibraryButton.isHidden = isRecordingVideo
-            switchCameraButton.isHidden = isRecordingVideo
-            if isContentTypeSelectionControlAvailable {
-                contentTypeSelectionControl.isHidden = isRecordingVideo
-            }
+    enum Mode {
+        case camera
+        case videoRecording
+        case text
+    }
+    private var _internalMode: Mode = .camera
+    var mode: Mode { _internalMode }
+    func setMode(_ mode: Mode, animated: Bool) {
+        guard _internalMode != mode else { return }
+        _internalMode = mode
+
+        let hideBottomButtons = mode != .camera
+        photoLibraryButton.setIsHidden(hideBottomButtons, animated: animated)
+        switchCameraButton.setIsHidden(hideBottomButtons, animated: animated)
+
+        let hideCameraCaptureControl = mode == .text
+        captureControl.setIsHidden(hideCameraCaptureControl, animated: animated)
+
+        if isContentTypeSelectionControlAvailable {
+            contentTypeSelectionControl.setIsHidden(mode == .videoRecording, animated: animated)
+            proceedButton.setIsHidden(mode != .text, animated: animated)
         }
     }
 
     let photoLibraryButton = MediaPickerThumbnailButton()
     let switchCameraButton = CameraChooserButton(backgroundStyle: .solid(RoundMediaButton.defaultBackgroundColor))
+    let proceedButton = RoundMediaButton(image: UIImage(imageLiteralResourceName: "arrow-right-24"), backgroundStyle: .solid(.ows_accentBlue))
     let controlButtonsLayoutGuide = UILayoutGuide() // area encompassing Photo Library and Switch Camera buttons.
 
     let captureControl = CameraCaptureControl(axis: .horizontal)
@@ -1445,6 +1448,7 @@ class CameraBottomBar: UIView {
 
         preservesSuperviewLayoutMargins = true
 
+        controlButtonsLayoutGuide.identifier = "ControlButtonsLayoutGuide"
         addLayoutGuide(controlButtonsLayoutGuide)
         addConstraints([ controlButtonsLayoutGuide.leadingAnchor.constraint(equalTo: layoutMarginsGuide.leadingAnchor),
                          controlButtonsLayoutGuide.topAnchor.constraint(greaterThanOrEqualTo: topAnchor),
@@ -1465,37 +1469,49 @@ class CameraBottomBar: UIView {
         switchCameraButton.translatesAutoresizingMaskIntoConstraints = false
         addSubview(switchCameraButton)
         addConstraints([ switchCameraButton.layoutMarginsGuide.trailingAnchor.constraint(equalTo: controlButtonsLayoutGuide.trailingAnchor),
-                         switchCameraButton.topAnchor.constraint(greaterThanOrEqualTo: controlButtonsLayoutGuide.topAnchor),
+                         switchCameraButton.topAnchor.constraint(equalTo: controlButtonsLayoutGuide.topAnchor),
                          switchCameraButton.centerYAnchor.constraint(equalTo: controlButtonsLayoutGuide.centerYAnchor) ])
 
         if isContentTypeSelectionControlAvailable {
             contentTypeSelectionControl.translatesAutoresizingMaskIntoConstraints = false
             addSubview(contentTypeSelectionControl)
-            addConstraints([ contentTypeSelectionControl.centerXAnchor.constraint(equalTo: layoutMarginsGuide.centerXAnchor) ])
+            addConstraints([ contentTypeSelectionControl.centerXAnchor.constraint(equalTo: layoutMarginsGuide.centerXAnchor),
+                             contentTypeSelectionControl.centerYAnchor.constraint(equalTo: controlButtonsLayoutGuide.centerYAnchor) ])
+
+            proceedButton.isHidden = true
+            proceedButton.isEnabled = false
+            proceedButton.contentEdgeInsets = UIEdgeInsets(margin: proceedButton.layoutMargins.leading + 9) // image is 24x24 and we want 42x42 button.
+            proceedButton.accessibilityValue = NSLocalizedString("CAMERA_VO_ARROW_RIGHT_PROCEED",
+                                                                 value: "Proceed",
+                                                                 comment: "VoiceOver label for -> button in text story composer.")
+            proceedButton.translatesAutoresizingMaskIntoConstraints = false
+            addSubview(proceedButton)
+            addConstraints([ proceedButton.layoutMarginsGuide.trailingAnchor.constraint(equalTo: controlButtonsLayoutGuide.trailingAnchor),
+                             proceedButton.centerYAnchor.constraint(equalTo: controlButtonsLayoutGuide.centerYAnchor) ])
         }
 
         // Compact Height:
-        // • control buttons are vertically centered with the shutter button.
-        // • shutter button control takes entire view height.
         // With this layout owner of this view should be able to just define vertical position of the bar.
-        compactHeightLayoutConstraints.append(contentsOf: [ captureControl.shutterButtonLayoutGuide.centerYAnchor.constraint(equalTo: controlButtonsLayoutGuide.centerYAnchor) ])
         if isContentTypeSelectionControlAvailable {
-            compactHeightLayoutConstraints.append(contentsOf: [ contentTypeSelectionControl.topAnchor.constraint(equalTo: captureControl.bottomAnchor, constant: 8),
-                                                                contentTypeSelectionControl.bottomAnchor.constraint(equalTo: bottomAnchor) ])
+            // • control buttons are located below shutter button with a fixed spacing and are pinned to the bottom.
+           compactHeightLayoutConstraints.append(
+                contentsOf: [ controlButtonsLayoutGuide.topAnchor.constraint(equalTo: captureControl.bottomAnchor, constant: 8),
+                              controlButtonsLayoutGuide.bottomAnchor.constraint(equalTo: bottomAnchor) ])
         } else {
-            compactHeightLayoutConstraints.append(captureControl.bottomAnchor.constraint(equalTo: bottomAnchor))
+            // • control buttons are vertically centered with the shutter button.
+            // • shutter button control takes the entire view height.
+            compactHeightLayoutConstraints.append(
+                contentsOf: [ controlButtonsLayoutGuide.centerYAnchor.constraint(equalTo: captureControl.shutterButtonLayoutGuide.centerYAnchor),
+                              captureControl.bottomAnchor.constraint(equalTo: bottomAnchor) ])
         }
 
         // Regular Height:
-        // • controls are located below the shutter button.
+        // • controls are located below the shutter button but exact spacing is to be defined by view controller.
         // • area with the controls is pinned to the bottom edge of the view.
         // With this layout owner of this view is supposed to add additional constraints
         // to top and bottom anchors of controlButtonsLayoutGuide thus positioning buttons properly.
         regularHeightLayoutConstraints.append(contentsOf: [ controlButtonsLayoutGuide.topAnchor.constraint(greaterThanOrEqualTo: captureControl.bottomAnchor),
                                                             controlButtonsLayoutGuide.bottomAnchor.constraint(equalTo: bottomAnchor) ])
-        if isContentTypeSelectionControlAvailable {
-            regularHeightLayoutConstraints.append(contentTypeSelectionControl.centerYAnchor.constraint(equalTo: controlButtonsLayoutGuide.centerYAnchor))
-        }
 
         updateCompactHeightLayoutConstraints()
     }
@@ -1525,6 +1541,13 @@ class CameraBottomBar: UIView {
         }
     }
 
+    // Override to allow touches that hit empty area of the toobar to pass through to views underneath.
+    override func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {
+        let view = super.hitTest(point, with: event)
+        guard view != self else { return nil }
+        return view
+    }
+
     private func updateContentTypePickerAccessibilityFrame() {
         guard isContentTypeSelectionControlAvailable else { return }
 
diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index 85c27bafe1e..1ae3dd8eeca 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -8,10 +8,13 @@ import Lottie
 import Photos
 import UIKit
 import SignalMessaging
+import SignalServiceKit
 import SignalUI
 
 protocol PhotoCaptureViewControllerDelegate: AnyObject {
     func photoCaptureViewControllerDidFinish(_ photoCaptureViewController: PhotoCaptureViewController)
+    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController,
+                                    didFinishWithTextAttachment textAttachment: TextAttachment)
     func photoCaptureViewControllerDidCancel(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerDidTryToCaptureTooMany(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerViewWillAppear(_ photoCaptureViewController: PhotoCaptureViewController)
@@ -35,7 +38,30 @@ class PhotoCaptureViewController: OWSViewController {
     private var interactiveDismiss: PhotoCaptureInteractiveDismiss?
 
     public lazy var photoCapture = PhotoCapture()
-    private var hasCaptureStarted = false
+    private var isCaptureReady = false {
+        didSet {
+            guard isCaptureReady != oldValue else { return }
+
+            if isCaptureReady {
+                BenchEventComplete(eventId: "Show-Camera")
+                VolumeButtons.shared?.addObserver(observer: photoCapture)
+                UIApplication.shared.isIdleTimerDisabled = true
+            } else {
+                VolumeButtons.shared?.removeObserver(photoCapture)
+                UIApplication.shared.isIdleTimerDisabled = false
+            }
+        }
+    }
+    private var hasCaptureStarted = false {
+        didSet {
+            isCaptureReady = isViewVisible && hasCaptureStarted
+        }
+    }
+    private var isViewVisible = false {
+        didSet {
+            isCaptureReady = isViewVisible && hasCaptureStarted
+        }
+    }
 
     deinit {
         photoCapture.stopCapture().done {
@@ -56,12 +82,6 @@ class PhotoCaptureViewController: OWSViewController {
         initializeUI()
 
         setupPhotoCapture()
-        // If the view is already visible, setup the volume button listener
-        // now that the capture UI is ready. Otherwise, we'll wait until
-        // we're visible.
-        if isVisible {
-            VolumeButtons.shared?.addObserver(observer: photoCapture)
-        }
 
         updateFlashModeControl(animated: false)
 
@@ -78,14 +98,11 @@ class PhotoCaptureViewController: OWSViewController {
         }
     }
 
-    private var isVisible = false
-
     override func viewWillAppear(_ animated: Bool) {
         super.viewWillAppear(animated)
 
         delegate?.photoCaptureViewControllerViewWillAppear(self)
 
-        isVisible = true
         let previewOrientation: AVCaptureVideoOrientation
         if UIDevice.current.isIPad {
             previewOrientation = AVCaptureVideoOrientation(interfaceOrientation: CurrentAppContext().interfaceOrientation)  ?? .portrait
@@ -95,6 +112,7 @@ class PhotoCaptureViewController: OWSViewController {
         UIViewController.attemptRotationToDeviceOrientation()
         photoCapture.updateVideoPreviewConnection(toOrientation: previewOrientation)
         updateIconOrientations(isAnimated: false, captureOrientation: previewOrientation)
+
         resumePhotoCapture()
 
         if let dataSource = dataSource, dataSource.numberOfMediaItems > 0 {
@@ -105,21 +123,14 @@ class PhotoCaptureViewController: OWSViewController {
 
     override func viewDidAppear(_ animated: Bool) {
         super.viewDidAppear(animated)
-
-        if hasCaptureStarted {
-            BenchEventComplete(eventId: "Show-Camera")
-            VolumeButtons.shared?.addObserver(observer: photoCapture)
-        }
-        UIApplication.shared.isIdleTimerDisabled = true
+        isViewVisible = true
     }
 
     override func viewWillDisappear(_ animated: Bool) {
         super.viewWillDisappear(animated)
 
-        isVisible = false
-        VolumeButtons.shared?.removeObserver(photoCapture)
+        isViewVisible = false
         pausePhotoCapture()
-        UIApplication.shared.isIdleTimerDisabled = false
     }
 
     override var prefersStatusBarHidden: Bool {
@@ -184,8 +195,66 @@ class PhotoCaptureViewController: OWSViewController {
     private let contentLayoutGuide = UILayoutGuide()
     private var contentLayoutGuideTop: NSLayoutConstraint? // controls vertical position of `contentLayoutGuide` on iPhones.
 
-    private var isRecordingVideo: Bool = false {
-        didSet { updateUIOnVideoRecordingStateChange() }
+    private enum ComposerMode {
+        case camera
+        case text
+    }
+    private var _internalComposerMode: ComposerMode = .camera
+    private var composerMode: ComposerMode { _internalComposerMode }
+    private func setComposerMode(_ composerMode: ComposerMode, animated: Bool) {
+        owsAssertDebug(!isRecordingVideo, "Invalid state - should not be recording video")
+
+        guard _internalComposerMode != composerMode else { return }
+        _internalComposerMode = composerMode
+
+        topBar.setMode(composerMode == .text ? .closeButton : .cameraControls, animated: animated)
+        bottomBar.setMode(composerMode == .text ? .text : .camera, animated: animated)
+        // TODO: Side bar on iPads
+
+        let hideZoomControl = composerMode == .text
+        let isFrontCamera = photoCapture.desiredPosition == .front
+        frontCameraZoomControl?.setIsHidden(hideZoomControl || !isFrontCamera, animated: animated)
+        rearCameraZoomControl?.setIsHidden(hideZoomControl || isFrontCamera, animated: animated)
+
+        if textEditorUIInitialized {
+            textViewContainerToolbar.setIsHidden(composerMode != .text, animated: animated)
+        }
+    }
+
+    private var _internalIsRecordingVideo = false
+    private var isRecordingVideo: Bool { _internalIsRecordingVideo }
+    private func setIsRecordingVideo(_ isRecordingVideo: Bool, animated: Bool) {
+        guard _internalIsRecordingVideo != isRecordingVideo else { return }
+        _internalIsRecordingVideo = isRecordingVideo
+
+        if isRecordingVideo {
+            topBar.setMode(.videoRecording, animated: animated)
+            topBar.recordingTimerView.startCounting()
+
+            let captureControlState: CameraCaptureControl.State = UIAccessibility.isVoiceOverRunning ? .recordingUsingVoiceOver : .recording
+            let animationDuration: TimeInterval = animated ? 0.4 : 0
+            bottomBar.captureControl.setState(captureControlState, animationDuration: animationDuration)
+            if let sideBar = sideBar {
+                sideBar.cameraCaptureControl.setState(captureControlState, animationDuration: animationDuration)
+            }
+        } else {
+            topBar.setMode(isIPadUIInRegularMode ? .closeButton : .cameraControls, animated: animated)
+            topBar.recordingTimerView.stopCounting()
+
+            let animationDuration: TimeInterval = animated ? 0.2 : 0
+            bottomBar.captureControl.setState(.initial, animationDuration: animationDuration)
+            if let sideBar = sideBar {
+                sideBar.cameraCaptureControl.setState(.initial, animationDuration: animationDuration)
+            }
+        }
+
+        bottomBar.setMode(isRecordingVideo ? .videoRecording : .camera, animated: animated)
+        if let sideBar = sideBar {
+            sideBar.isRecordingVideo = isRecordingVideo
+        }
+
+        let hideDoneButton = isRecordingVideo || doneButton.badgeNumber == 0
+        doneButton.setIsHidden(hideDoneButton, animated: animated)
     }
 
     enum CaptureMode {
@@ -212,6 +281,8 @@ class PhotoCaptureViewController: OWSViewController {
 
     private var sideBar: CameraSideBar? // Optional because most devices are iPhones and will never need this.
 
+    // MARK: - Camera Controls
+
     private var frontCameraZoomControl: CameraZoomSelectionControl?
     private var rearCameraZoomControl: CameraZoomSelectionControl?
     private var cameraZoomControlIPhoneConstraints: [NSLayoutConstraint]?
@@ -235,6 +306,129 @@ class PhotoCaptureViewController: OWSViewController {
         photoCapture.previewView
     }
 
+    // MARK: - Text Editor
+
+    private var textEditorUIInitialized = false
+    private lazy var textViewContentLayoutGuide = UILayoutGuide()
+    private lazy var textViewContainer: UIView = {
+        let view = UIView()
+        view.translatesAutoresizingMaskIntoConstraints = false
+        view.preservesSuperviewLayoutMargins = true
+        view.layer.masksToBounds = true
+
+        view.addSubview(textViewContainerBackgroundView)
+        textViewContainerBackgroundView.autoPinEdgesToSuperviewEdges()
+
+        // Choose Background and Attach Link buttons.
+        // Vertical position of textViewContainerToolbar isn't defined here because
+        // is depends on views outside of textViewContainer.
+        view.addSubview(textViewContainerToolbar)
+        textViewContainerToolbar.autoPinEdge(toSuperviewMargin: .leading)
+
+        // This defines bounds for text content: text view and link preview.
+        view.addLayoutGuide(textViewContentLayoutGuide)
+        view.addConstraints([
+            textViewContentLayoutGuide.leadingAnchor.constraint(equalTo: view.layoutMarginsGuide.leadingAnchor),
+            textViewContentLayoutGuide.topAnchor.constraint(equalTo: view.layoutMarginsGuide.topAnchor, constant: 8),
+            textViewContentLayoutGuide.trailingAnchor.constraint(equalTo: view.layoutMarginsGuide.trailingAnchor)
+        ])
+        view.addConstraint({
+            let constraint = textViewContentLayoutGuide.bottomAnchor.constraint(equalTo: textViewContainerToolbar.topAnchor, constant: -16)
+            constraint.priority = .defaultHigh
+            return constraint
+        }())
+
+        // textViewWrapperView contains text view and link preview - these two are grouped together
+        // and are centered vertically in text content area.
+        textViewWrapperView.translatesAutoresizingMaskIntoConstraints = false
+        view.addSubview(textViewWrapperView)
+        view.addConstraints([
+            textViewWrapperView.leadingAnchor.constraint(equalTo: textViewContentLayoutGuide.leadingAnchor),
+            textViewWrapperView.topAnchor.constraint(greaterThanOrEqualTo: textViewContentLayoutGuide.topAnchor),
+            textViewWrapperView.trailingAnchor.constraint(equalTo: textViewContentLayoutGuide.trailingAnchor),
+            textViewWrapperView.bottomAnchor.constraint(lessThanOrEqualTo: textViewContentLayoutGuide.bottomAnchor),
+            textViewWrapperView.centerYAnchor.constraint(equalTo: textViewContentLayoutGuide.centerYAnchor)
+        ])
+
+        // Placeholder text is centered in "text content area".
+        textViewPlaceholderLabel.translatesAutoresizingMaskIntoConstraints = false
+        view.addSubview(textViewPlaceholderLabel)
+        view.addConstraints([
+            textViewPlaceholderLabel.leadingAnchor.constraint(equalTo: textViewContentLayoutGuide.leadingAnchor),
+            textViewPlaceholderLabel.topAnchor.constraint(equalTo: textViewContentLayoutGuide.topAnchor),
+            textViewPlaceholderLabel.trailingAnchor.constraint(equalTo: textViewContentLayoutGuide.trailingAnchor),
+            textViewPlaceholderLabel.bottomAnchor.constraint(equalTo: textViewContentLayoutGuide.bottomAnchor)
+        ])
+
+        return view
+    }()
+    private lazy var textViewContainerBackgroundView = GradientView(colors: [])
+    private lazy var textViewContainerToolbar: UIView = {
+        let stackView = UIStackView(arrangedSubviews: [ textBackgroundSelectionButton, textViewAttachLinkButton ])
+        stackView.axis = .horizontal
+        stackView.spacing = 16
+        return stackView
+    }()
+    private var textBackgroundIndex = 0
+    private lazy var textBackgroundSelectionButton = RoundGradientButton()
+    private lazy var textViewAttachLinkButton: UIButton = {
+        let button = RoundMediaButton(image: UIImage(imageLiteralResourceName: "link-diagonal"), backgroundStyle: .blur)
+        button.contentEdgeInsets = UIEdgeInsets(margin: 3)
+        button.layoutMargins = .zero
+        return button
+    }()
+    private lazy var textViewWrapperView: UIView = {
+        let wrapperView = UIStackView(arrangedSubviews: [ textView, linkPreviewWrapperView ])
+        wrapperView.axis = .vertical
+        return wrapperView
+    }()
+    private lazy var textView: MediaTextView = {
+        let textView = MediaTextView()
+        textView.delegate = self
+        textView.autoSetDimension(.height, toSize: 32, relation: .greaterThanOrEqual)
+        return textView
+    }()
+    private lazy var textViewAccessoryToolbar: TextStylingToolbar = {
+        let toolbar = TextStylingToolbar(layout: .textStory)
+        toolbar.preservesSuperviewLayoutMargins = true
+        toolbar.colorPickerView.delegate = self
+        toolbar.textStyleButton.addTarget(self, action: #selector(didTapTextStyleButton), for: .touchUpInside)
+        toolbar.decorationStyleButton.addTarget(self, action: #selector(didTapDecorationStyleButton), for: .touchUpInside)
+        toolbar.doneButton.addTarget(self, action: #selector(didTapTextViewDoneButton), for: .touchUpInside)
+        return toolbar
+    }()
+    private lazy var textViewPlaceholderLabel: UILabel = {
+        let label = UILabel()
+        label.textAlignment = .center
+        label.numberOfLines = 0
+        label.textColor = .ows_whiteAlpha60
+        label.font = .ows_dynamicTypeLargeTitle1Clamped
+        label.isUserInteractionEnabled = true
+        label.text = NSLocalizedString("STORY_COMPOSER_TAP_ADD_TEXT",
+                                       value: "Tap to add text",
+                                       comment: "Placeholder text in text stories compose UI")
+        return label
+    }()
+
+    // This constraint gets updated when onscreen keyboard appears/disappears.
+    private var textViewBottomToScreenBottomConstraint: NSLayoutConstraint?
+    private var observingKeyboardNotifications = false
+
+    private var linkPreview: OWSLinkPreviewDraft?
+    private var linkPreviewView: UIView?
+    private lazy var linkPreviewWrapperView: UIView = {
+        let view = UIView()
+        view.layoutMargins = UIEdgeInsets(margin: 20)
+        return view
+    }()
+    private lazy var deleteLinkPreviewButton: UIButton = {
+        let button = RoundMediaButton(image: UIImage(imageLiteralResourceName: "x-24"), backgroundStyle: .blur)
+        button.contentEdgeInsets = UIEdgeInsets(margin: 8)
+        button.layoutMargins = UIEdgeInsets(margin: 2)
+        button.translatesAutoresizingMaskIntoConstraints = false
+        return button
+    }()
+
     private lazy var doneButton: MediaDoneButton = {
         let button = MediaDoneButton(type: .custom)
         button.badgeNumber = 0
@@ -456,7 +650,7 @@ class PhotoCaptureViewController: OWSViewController {
         sideBar?.isHidden = !isIPadUIInRegularMode
     }
 
-    func updateDoneButtonAppearance() {
+    private func updateDoneButtonAppearance() {
         if captureMode == .multi, let badgeNumber = dataSource?.numberOfMediaItems, badgeNumber > 0 {
             doneButton.badgeNumber = badgeNumber
             doneButton.isHidden = false
@@ -478,34 +672,6 @@ class PhotoCaptureViewController: OWSViewController {
         }
     }
 
-    private func updateUIOnVideoRecordingStateChange() {
-        if isRecordingVideo {
-            topBar.setMode(.videoRecording, animated: true)
-            topBar.recordingTimerView.startCounting()
-
-            let captureControlState: CameraCaptureControl.State = UIAccessibility.isVoiceOverRunning ? .recordingUsingVoiceOver : .recording
-            bottomBar.captureControl.setState(captureControlState, animationDuration: 0.4)
-            if let sideBar = sideBar {
-                sideBar.cameraCaptureControl.setState(captureControlState, animationDuration: 0.4)
-            }
-        } else {
-            topBar.setMode(isIPadUIInRegularMode ? .closeButton : .cameraControls, animated: true)
-            topBar.recordingTimerView.stopCounting()
-
-            bottomBar.captureControl.setState(.initial, animationDuration: 0.2)
-            if let sideBar = sideBar {
-                sideBar.cameraCaptureControl.setState(.initial, animationDuration: 0.2)
-            }
-        }
-
-        bottomBar.isRecordingVideo = isRecordingVideo
-        if let sideBar = sideBar {
-            sideBar.isRecordingVideo = isRecordingVideo
-        }
-
-        doneButton.isHidden = isRecordingVideo || doneButton.badgeNumber == 0
-    }
-
     private func updateIconOrientations(isAnimated: Bool, captureOrientation: AVCaptureVideoOrientation) {
         guard !UIDevice.current.isIPad else { return }
 
@@ -549,6 +715,390 @@ class PhotoCaptureViewController: OWSViewController {
     }
 }
 
+// MARK: - Text Editor
+
+extension PhotoCaptureViewController {
+
+    private func initializeTextEditorUIIfNecessary() {
+        guard !textEditorUIInitialized else { return }
+
+        // Connect button actions.
+        bottomBar.proceedButton.addTarget(self, action: #selector(didTapTextStoryProceedButton), for: .touchUpInside)
+        textBackgroundSelectionButton.addTarget(self, action: #selector(didTapTextBackgroundButton), for: .touchUpInside)
+        textViewAttachLinkButton.addTarget(self, action: #selector(didTapAttachLinkPreviewButton), for: .touchUpInside)
+        textViewPlaceholderLabel.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(textViewPlaceholderTapped)))
+
+        // Prepare text styling toolbar (only visible when editing text).
+        let toolbarSize = textViewAccessoryToolbar.systemLayoutSizeFitting(CGSize(width: view.width, height: .greatestFiniteMagnitude),
+                                                                           withHorizontalFittingPriority: .required,
+                                                                           verticalFittingPriority: .fittingSizeLevel)
+        textViewAccessoryToolbar.bounds.size = toolbarSize
+        textView.inputAccessoryView = textViewAccessoryToolbar
+        updateTextViewAttributes(using: textViewAccessoryToolbar)
+
+        // Set up text view container.
+        textViewContainer.layer.cornerRadius = previewView.previewLayer.cornerRadius
+        view.insertSubview(textViewContainer, aboveSubview: previewView)
+        view.addConstraints([ textViewContainer.leadingAnchor.constraint(equalTo: contentLayoutGuide.leadingAnchor),
+                              textViewContainer.topAnchor.constraint(equalTo: contentLayoutGuide.topAnchor),
+                              textViewContainer.trailingAnchor.constraint(equalTo: contentLayoutGuide.trailingAnchor),
+                              textViewContainer.bottomAnchor.constraint(equalTo: contentLayoutGuide.bottomAnchor) ])
+
+        // This constraint would allow to resize textView to clear onscreen keyboard.
+        textViewBottomToScreenBottomConstraint = view.bottomAnchor.constraint(greaterThanOrEqualTo: textViewContentLayoutGuide.bottomAnchor)
+        textViewBottomToScreenBottomConstraint?.isActive = true
+
+        // Vertical position for panel with Background Color and Attach Link buttons.
+        if bottomBar.isCompactHeightLayout {
+            view.addConstraint(textViewContainerToolbar.bottomAnchor.constraint(equalTo: bottomBar.controlButtonsLayoutGuide.topAnchor, constant: 0))
+        } else {
+            view.addConstraint(textViewContainerToolbar.bottomAnchor.constraint(equalTo: textViewContainer.bottomAnchor, constant: -16))
+        }
+
+        updateTextBackground()
+
+        view.setNeedsLayout()
+        UIView.performWithoutAnimation {
+            self.view.layoutIfNeeded()
+        }
+
+        textEditorUIInitialized = true
+    }
+
+    private var strippedTextViewText: String { textView.text.stripped }
+
+    private var isTextViewContentEmpty: Bool {
+        strippedTextViewText.isEmpty && linkPreview == nil
+    }
+
+    private static func desiredAttributes(forText text: String) -> (fontPointSize: CGFloat, textAlignment: NSTextAlignment) {
+        switch text.count {
+        case ..<50: return (34, .center)
+        case 50...199: return (24, .center)
+        default: return (18, .natural)
+        }
+    }
+
+    private func updateTextViewAttributes(using textToolbar: TextStylingToolbar) {
+        let (fontPointSize, textAlignment) = PhotoCaptureViewController.desiredAttributes(forText: strippedTextViewText)
+        textView.update(using: textToolbar, fontPointSize: fontPointSize, textAlignment: textAlignment)
+    }
+
+    private func adjustFontSizeIfNecessary() {
+        guard let currentFontSize = textView.font?.pointSize else { return }
+        let desiredFontSize = PhotoCaptureViewController.desiredAttributes(forText: strippedTextViewText).fontPointSize
+        guard desiredFontSize != currentFontSize else { return }
+        updateTextViewAttributes(using: textViewAccessoryToolbar)
+    }
+
+    private func updateLinkPreviewAppearance() {
+        if let linkPreviewView = linkPreviewView {
+            linkPreviewView.removeFromSuperview()
+            self.linkPreviewView = nil
+        }
+
+        guard let linkPreview = linkPreview else {
+            linkPreviewWrapperView.isHiddenInStackView = true
+            return
+        }
+
+        linkPreviewWrapperView.isHiddenInStackView = false
+
+        let linkPreviewView = TextAttachmentView.LinkPreviewView(linkPreview: LinkPreviewDraft(linkPreviewDraft: linkPreview))
+        linkPreviewWrapperView.addSubview(linkPreviewView)
+        linkPreviewView.autoPinEdgesToSuperviewMargins()
+        self.linkPreviewView = linkPreviewView
+
+        if deleteLinkPreviewButton.superview == nil {
+            linkPreviewWrapperView.addSubview(deleteLinkPreviewButton)
+            deleteLinkPreviewButton.addTarget(self, action: #selector(didTapDeleteLinkPreviewButton), for: .touchUpInside)
+        }
+        linkPreviewWrapperView.addConstraints([
+            deleteLinkPreviewButton.centerXAnchor.constraint(equalTo: linkPreviewView.trailingAnchor, constant: -5),
+            deleteLinkPreviewButton.centerYAnchor.constraint(equalTo: linkPreviewView.topAnchor, constant: 5)
+        ])
+        linkPreviewWrapperView.bringSubviewToFront(deleteLinkPreviewButton)
+    }
+
+    private func updateTextEditorUI(animated: Bool) {
+        let isPlaceholderHidden = textView.isFirstResponder || textView.hasText || linkPreview != nil
+        textViewPlaceholderLabel.setIsHidden(isPlaceholderHidden, animated: animated)
+
+        bottomBar.proceedButton.isEnabled = !isTextViewContentEmpty
+    }
+
+    // MARK: - Keyboard Handling
+
+    private func startObservingKeyboardNotifications() {
+        guard !observingKeyboardNotifications else { return }
+
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardWillShowNotification,
+            object: nil
+        )
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardWillHideNotification,
+            object: nil
+        )
+        NotificationCenter.default.addObserver(
+            self,
+            selector: #selector(handleKeyboardNotification(_:)),
+            name: UIResponder.keyboardWillChangeFrameNotification,
+            object: nil
+        )
+        observingKeyboardNotifications = true
+    }
+
+    @objc
+    private func handleKeyboardNotification(_ notification: Notification) {
+        guard composerMode == .text else { return }
+
+        guard let constraint = textViewBottomToScreenBottomConstraint else { return }
+
+        guard let userInfo = notification.userInfo,
+              let endFrame = userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect else { return }
+
+        let convertedEndFrame = view.convert(endFrame, from: nil)
+        let inset = view.bounds.maxY - convertedEndFrame.minY
+
+        let layoutUpdateBlock = {
+            constraint.constant = inset + 16
+        }
+        if let animationDuration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? TimeInterval,
+           let rawAnimationCurve = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? Int,
+           let animationCurve = UIView.AnimationCurve(rawValue: rawAnimationCurve) {
+            UIView.beginAnimations("sheetResize", context: nil)
+            UIView.setAnimationBeginsFromCurrentState(true)
+            UIView.setAnimationCurve(animationCurve)
+            UIView.setAnimationDuration(animationDuration)
+            layoutUpdateBlock()
+            view.setNeedsLayout()
+            view.layoutIfNeeded()
+            UIView.commitAnimations()
+        } else {
+            UIView.performWithoutAnimation {
+                layoutUpdateBlock()
+            }
+        }
+    }
+
+    // MARK: - Background
+
+    private static var textBackgrounds: [TextAttachment.Background] =
+    [ .gradient(.init(startColor: UIColor(rgbHex: 0xF53844), endColor: UIColor(rgbHex: 0x42378F), angle: 191)),
+      .gradient(.init(startColor: UIColor(rgbHex: 0xF04CE6), endColor: UIColor(rgbHex: 0x0E2FDD), angle: 192)),
+      .gradient(.init(startColor: UIColor(rgbHex: 0xFFC044), endColor: UIColor(rgbHex: 0xFE5C38), angle: 175)),
+      .gradient(.init(startColor: UIColor(rgbHex: 0x0093E9), endColor: UIColor(rgbHex: 0x80D0C7), angle: 180)),
+      .gradient(.init(startColor: UIColor(rgbHex: 0x65CDAC), endColor: UIColor(rgbHex: 0x0A995A), angle: 180)),
+      .color(.init(rgbHex: 0xFFC153)),
+      .color(.init(rgbHex: 0xCCBD33)),
+      .color(.init(rgbHex: 0x84712E)),
+      .color(.init(rgbHex: 0x09B37B)),
+      .color(.init(rgbHex: 0x8B8BF9)),
+      .color(.init(rgbHex: 0x5151F6)),
+      .color(.init(rgbHex: 0xF76E6E)),
+      .color(.init(rgbHex: 0xC84641)),
+      .color(.init(rgbHex: 0xC6C4A5)),
+      .color(.init(rgbHex: 0xA49595)),
+      .color(.init(rgbHex: 0x292929)) ]
+
+    private class RoundGradientButton: RoundMediaButton {
+
+        let gradientView = GradientView(colors: [])
+
+        init() {
+            let gradientCircleView = PillView()
+            gradientCircleView.isUserInteractionEnabled = false
+            gradientCircleView.layer.borderWidth = 2
+            gradientCircleView.layer.borderColor = UIColor.white.cgColor
+            gradientCircleView.addSubview(gradientView)
+            gradientCircleView.autoSetDimensions(to: CGSize(square: 28))
+            gradientView.autoPinEdgesToSuperviewEdges()
+
+            super.init(image: nil, backgroundStyle: .blur, customView: gradientCircleView)
+
+            contentEdgeInsets = .zero
+            layoutMargins = .zero
+        }
+
+        override var intrinsicContentSize: CGSize { CGSize(square: 44) }
+    }
+
+    private func switchToNextBackground() {
+        textBackgroundIndex += 1
+        if textBackgroundIndex > PhotoCaptureViewController.textBackgrounds.count - 1 {
+            textBackgroundIndex = 0
+        }
+        updateTextBackground()
+    }
+
+    private func updateTextBackground() {
+        let textBackground = PhotoCaptureViewController.textBackgrounds[textBackgroundIndex]
+        switch textBackground {
+        case .color(let color):
+            textViewContainerBackgroundView.colors = [ color, color ]
+            textBackgroundSelectionButton.gradientView.colors = [ color, color ]
+
+        case .gradient(let gradient):
+            textViewContainerBackgroundView.colors = [ gradient.startColor, gradient.endColor ]
+            textViewContainerBackgroundView.setAngle(gradient.angle)
+
+            textBackgroundSelectionButton.gradientView.colors = [ gradient.startColor, gradient.endColor ]
+            textBackgroundSelectionButton.gradientView.setAngle(gradient.angle)
+        }
+    }
+
+    // MARK: - Button Actions
+
+    @objc
+    private func textViewPlaceholderTapped() {
+        textView.becomeFirstResponder()
+    }
+
+    @objc
+    private func didTapTextStyleButton() {
+        let currentTextStyle = textViewAccessoryToolbar.textStyle
+        let nextTextStyle = MediaTextView.TextStyle(rawValue: currentTextStyle.rawValue + 1) ?? .regular
+
+        // Update toolbar.
+        textViewAccessoryToolbar.textStyle = nextTextStyle
+
+        // Update text view.
+        if textView.isFirstResponder {
+            updateTextViewAttributes(using: textViewAccessoryToolbar)
+        }
+    }
+
+    @objc
+    private func didTapDecorationStyleButton() {
+        // Switch between colored text with no background and white text over colored background.
+        let currentDecorationStyle = textViewAccessoryToolbar.decorationStyle
+        let nextDecorationStyle: MediaTextView.DecorationStyle = currentDecorationStyle == .none ? .inverted : .none
+
+        // Update toolbar.
+        textViewAccessoryToolbar.decorationStyle = nextDecorationStyle
+
+        // Update text view.
+        if textView.isFirstResponder {
+            updateTextViewAttributes(using: textViewAccessoryToolbar)
+        }
+    }
+
+    @objc
+    private func didTapTextBackgroundButton() {
+        switchToNextBackground()
+    }
+
+    @objc
+    private func didTapAttachLinkPreviewButton() {
+        let linkPreviewViewController = LinkPreviewAttachmentViewController(linkPreview)
+        linkPreviewViewController.delegate = self
+        present(linkPreviewViewController, animated: true)
+    }
+
+    @objc
+    private func didTapDeleteLinkPreviewButton() {
+        linkPreview = nil
+        updateLinkPreviewAppearance()
+        updateTextEditorUI(animated: true)
+    }
+
+    @objc
+    private func didTapTextViewDoneButton() {
+        Logger.verbose("")
+
+        textView.acceptAutocorrectSuggestion()
+        textView.resignFirstResponder()
+    }
+
+    @objc
+    private func didTapTextStoryProceedButton() {
+        Logger.verbose("")
+
+        let textForegroundColor: UIColor
+        let textBackgroundColor: UIColor?
+        switch textViewAccessoryToolbar.decorationStyle {
+        case .inverted:
+            textForegroundColor = .white
+            textBackgroundColor = textViewAccessoryToolbar.colorPickerView.color
+        default:
+            textForegroundColor = textViewAccessoryToolbar.colorPickerView.color
+            textBackgroundColor = nil
+        }
+
+        let textStyle: TextAttachment.TextStyle = {
+            switch textViewAccessoryToolbar.textStyle {
+            case .regular: return .regular
+            case .bold: return .bold
+            case .condensed: return .condensed
+            case .script: return .script
+            case .serif: return .serif
+            }
+        }()
+        let background = PhotoCaptureViewController.textBackgrounds[textBackgroundIndex]
+
+        var validatedLinkPreview: OWSLinkPreview?
+        if let linkPreview = linkPreview {
+            self.databaseStorage.write { transaction in
+                validatedLinkPreview = try? OWSLinkPreview.buildValidatedLinkPreview(fromInfo: linkPreview, transaction: transaction)
+            }
+        }
+
+        let textAttachment = TextAttachment(
+            text: strippedTextViewText,
+            textStyle: textStyle,
+            textForegroundColor: textForegroundColor,
+            textBackgroundColor: textBackgroundColor,
+            background: background,
+            linkPreview: validatedLinkPreview)
+        delegate?.photoCaptureViewController(self, didFinishWithTextAttachment: textAttachment)
+    }
+}
+
+extension PhotoCaptureViewController: UITextViewDelegate {
+
+    func textViewDidBeginEditing(_ textView: UITextView) {
+        bottomBar.setIsHidden(true, animated: true)
+        textViewContainerToolbar.setIsHidden(true, animated: true)
+        linkPreviewWrapperView.setIsHidden(true, animated: true)
+        updateTextEditorUI(animated: true)
+    }
+
+    func textViewDidEndEditing(_ textView: UITextView) {
+        bottomBar.setIsHidden(isIPadUIInRegularMode, animated: true)
+        textViewContainerToolbar.setIsHidden(false, animated: true)
+        linkPreviewWrapperView.setIsHidden(false, animated: true)
+        updateTextEditorUI(animated: true)
+    }
+
+    func textViewDidChange(_ textView: UITextView) {
+        adjustFontSizeIfNecessary()
+        updateTextEditorUI(animated: false)
+    }
+}
+
+extension PhotoCaptureViewController: ColorPickerBarViewDelegate {
+
+    func colorPickerBarView(_ pickerView: ColorPickerBarView, didSelectColor color: ColorPickerBarColor) {
+        updateTextViewAttributes(using: textViewAccessoryToolbar)
+    }
+}
+
+extension PhotoCaptureViewController: LinkPreviewAttachmentViewControllerDelegate {
+
+    func linkPreviewAttachmentViewController(_ viewController: LinkPreviewAttachmentViewController,
+                                             didFinishWith linkPreview: OWSLinkPreviewDraft) {
+        self.linkPreview = linkPreview
+        updateLinkPreviewAppearance()
+        updateTextEditorUI(animated: false)
+        viewController.dismiss(animated: true)
+    }
+}
+
 // MARK: - Button Actions
 
 extension PhotoCaptureViewController {
@@ -617,6 +1167,33 @@ extension PhotoCaptureViewController {
     @objc
     private func contentTypeChanged() {
         Logger.verbose("")
+        let newComposerMode: ComposerMode = {
+            switch bottomBar.contentTypeSelectionControl.selectedSegmentIndex {
+            case 0:
+                return .camera
+
+            case 1:
+                return .text
+
+            default:
+                owsFailDebug("Invalid segment index")
+                return composerMode
+            }
+        }()
+        setComposerMode(newComposerMode, animated: true)
+
+        // Stop / start camera as necessary.
+        switch newComposerMode {
+        case .camera:
+            resumePhotoCapture()
+            textViewContainer.setIsHidden(true, animated: true)
+
+        case .text:
+            startObservingKeyboardNotifications()
+            initializeTextEditorUIIfNecessary()
+            textViewContainer.setIsHidden(false, animated: true)
+            pausePhotoCapture()
+        }
     }
 }
 
@@ -707,14 +1284,6 @@ extension PhotoCaptureViewController {
 
 extension PhotoCaptureViewController {
 
-    private func captureReady() {
-        self.hasCaptureStarted = true
-        BenchEventComplete(eventId: "Show-Camera")
-        if isVisible {
-            VolumeButtons.shared?.addObserver(observer: photoCapture)
-        }
-    }
-
     private func setupPhotoCapture() {
         photoCapture.delegate = self
         bottomBar.captureControl.delegate = photoCapture
@@ -724,7 +1293,8 @@ extension PhotoCaptureViewController {
 
         // If the session is already running, we're good to go.
         guard !photoCapture.session.isRunning else {
-            return self.captureReady()
+            self.hasCaptureStarted = true
+            return
         }
 
         firstly {
@@ -751,7 +1321,7 @@ extension PhotoCaptureViewController {
         firstly {
             photoCapture.resumeCapture()
         }.done { [weak self] in
-            self?.captureReady()
+            self?.hasCaptureStarted = true
         }.catch { [weak self] error in
             self?.showFailureUI(error: error)
         }
@@ -835,7 +1405,7 @@ extension PhotoCaptureViewController: PhotoCaptureDelegate {
     }
 
     func photoCapture(_ photoCapture: PhotoCapture, didFailProcessing error: Error) {
-        isRecordingVideo = false
+        setIsRecordingVideo(false, animated: true)
 
         if case PhotoCaptureError.invalidVideo = error {
             // Don't show an error if the user aborts recording before video
@@ -857,7 +1427,7 @@ extension PhotoCaptureViewController: PhotoCaptureDelegate {
 
     func photoCaptureWillBeginRecording(_ photoCapture: PhotoCapture) {
         Logger.verbose("")
-        isRecordingVideo = true
+        setIsRecordingVideo(true, animated: true)
     }
 
     func photoCaptureDidBeginRecording(_ photoCapture: PhotoCapture) {
@@ -866,12 +1436,12 @@ extension PhotoCaptureViewController: PhotoCaptureDelegate {
 
     func photoCaptureDidFinishRecording(_ photoCapture: PhotoCapture) {
         Logger.verbose("")
-        isRecordingVideo = false
+        setIsRecordingVideo(false, animated: true)
     }
 
     func photoCaptureDidCancelRecording(_ photoCapture: PhotoCapture) {
         Logger.verbose("")
-        isRecordingVideo = false
+        setIsRecordingVideo(false, animated: true)
     }
 
     // MARK: -
diff --git a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
index 369eb6559de..32b1c6d99b5 100644
--- a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
+++ b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
@@ -6,17 +6,17 @@ import Foundation
 import Photos
 import SignalUI
 
-@objc
 protocol SendMediaNavDelegate: AnyObject {
 
     func sendMediaNavDidCancel(_ sendMediaNavigationController: SendMediaNavigationController)
 
     func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didApproveAttachments attachments: [SignalAttachment], messageBody: MessageBody?)
 
+    func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didFinishWithTextAttachment textAttachment: TextAttachment)
+
     func sendMediaNav(_ sendMediaNavigationController: SendMediaNavigationController, didChangeMessageBody newMessageBody: MessageBody?)
 }
 
-@objc
 protocol SendMediaNavDataSource: AnyObject {
 
     func sendMediaNavInitialMessageBody(_ sendMediaNavigationController: SendMediaNavigationController) -> MessageBody?
@@ -28,7 +28,6 @@ protocol SendMediaNavDataSource: AnyObject {
     var sendMediaNavMentionableAddresses: [SignalServiceAddress] { get }
 }
 
-@objc
 class CameraFirstCaptureNavigationController: SendMediaNavigationController {
 
     override var requiresContactPickerToProceed: Bool {
@@ -37,15 +36,14 @@ class CameraFirstCaptureNavigationController: SendMediaNavigationController {
 
     override var canSendToStories: Bool { StoryManager.areStoriesEnabled }
 
-    @objc
-    private(set) var cameraFirstCaptureSendFlow: CameraFirstCaptureSendFlow!
+    private var cameraFirstCaptureSendFlow: CameraFirstCaptureSendFlow!
 
     @objc
-    class func cameraFirstModal(storiesOnly: Bool = false) -> CameraFirstCaptureNavigationController {
+    class func cameraFirstModal(storiesOnly: Bool = false, delegate: CameraFirstCaptureDelegate?) -> CameraFirstCaptureNavigationController {
         let navController = CameraFirstCaptureNavigationController()
         navController.setViewControllers([navController.captureViewController], animated: false)
 
-        let cameraFirstCaptureSendFlow = CameraFirstCaptureSendFlow(storiesOnly: storiesOnly)
+        let cameraFirstCaptureSendFlow = CameraFirstCaptureSendFlow(storiesOnly: storiesOnly, delegate: delegate)
         navController.cameraFirstCaptureSendFlow = cameraFirstCaptureSendFlow
         navController.sendMediaNavDelegate = cameraFirstCaptureSendFlow
         navController.sendMediaNavDataSource = cameraFirstCaptureSendFlow
@@ -54,7 +52,6 @@ class CameraFirstCaptureNavigationController: SendMediaNavigationController {
     }
 }
 
-@objc
 class SendMediaNavigationController: OWSNavigationController {
 
     fileprivate var requiresContactPickerToProceed: Bool {
@@ -290,6 +287,11 @@ extension SendMediaNavigationController: PhotoCaptureViewControllerDelegate {
         showApprovalAfterProcessingAnyMediaLibrarySelections()
     }
 
+    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController,
+                                    didFinishWithTextAttachment textAttachment: TextAttachment) {
+        sendMediaNavDelegate?.sendMediaNav(self, didFinishWithTextAttachment: textAttachment)
+    }
+
     func photoCaptureViewControllerDidCancel(_ photoCaptureViewController: PhotoCaptureViewController) {
         let dontAbandonText = NSLocalizedString("SEND_MEDIA_RETURN_TO_CAMERA", comment: "alert action when the user decides not to cancel the media flow after all.")
         didRequestExit(dontAbandonText: dontAbandonText)
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index f574c6e2f93..8ffbebaceba 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -784,6 +784,9 @@
 /* Accessibility label for camera button. */
 "CAMERA_BUTTON_LABEL" = "Camera";
 
+/* VoiceOver label for -> button in text story composer. */
+"CAMERA_VO_ARROW_RIGHT_PROCEED" = "Proceed";
+
 /* VoiceOver label for Flash button in camera. */
 "CAMERA_VO_CAMERA_ALBUM_MODE" = "Album mode";
 
@@ -6241,9 +6244,21 @@
 /* One of two possible sources when composing a new story. Displayed at the bottom in in-app camera. */
 "STORY_COMPOSER_CAMERA" = "Camera";
 
+/* Displayed when failed to fetch link preview in Text Story composer. */
+"STORY_COMPOSER_LINK_PREVIEW_ERROR" = "Couldn't load link. Check your connection and try again.";
+
+/* Displayed in text story composer when user is about to attach a link with preview */
+"STORY_COMPOSER_LINK_PREVIEW_PLACEHOLDER" = "Share a link with viewers of your story";
+
+/* Placeholder text in text stories compose UI */
+"STORY_COMPOSER_TAP_ADD_TEXT" = "Tap to add text";
+
 /* One of two possible sources when composing a new story. Displayed at the bottom in in-app camera. */
 "STORY_COMPOSER_TEXT" = "Text";
 
+/* Placeholder text for URL input field in Text Story composer UI. */
+"STORY_COMPOSER_URL_FIELD_PLACEHOLDER" = "Type or paste a URL";
+
 /* Tooltip prompting the user to visit a story link. */
 "STORY_LINK_PREVIEW_VISIT_LINK_TOOLTIP" = "Visit link";
 
diff --git a/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift b/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift
index 65f3704fd7e..cf4d73ca0c2 100644
--- a/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift
+++ b/SignalServiceKit/src/Messages/Interactions/OWSLinkPreview.swift
@@ -216,6 +216,41 @@ public class OWSLinkPreview: MTLModel, Codable {
         return linkPreview
     }
 
+    public func buildProto(transaction: SDSAnyReadTransaction) throws -> SSKProtoPreview {
+        guard isValid() else {
+            Logger.error("Preview has neither title nor image.")
+            throw LinkPreviewError.invalidPreview
+        }
+
+        guard let urlString = urlString else {
+            Logger.error("Preview does not have url.")
+            throw LinkPreviewError.invalidPreview
+        }
+
+        let builder = SSKProtoPreview.builder(url: urlString)
+
+        if let title = title {
+            builder.setTitle(title)
+        }
+
+        if let previewDescription = previewDescription {
+            builder.setPreviewDescription(previewDescription)
+        }
+
+        if
+            let imageAttachmentId = imageAttachmentId,
+            let attachmentProto = TSAttachmentStream.buildProto(forAttachmentId: imageAttachmentId, transaction: transaction)
+        {
+            builder.setImage(attachmentProto)
+        }
+
+        if let date = date {
+            builder.setDate(date.ows_millisecondsSince1970)
+        }
+
+        return try builder.build()
+    }
+
     private class func saveAttachmentIfPossible(imageData: Data?,
                                                 imageMimeType: String?,
                                                 transaction: SDSAnyWriteTransaction) -> String? {
diff --git a/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift b/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift
index 3bf1a565449..f8dd8ffb7d7 100644
--- a/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift
+++ b/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift
@@ -27,6 +27,7 @@ public class OutgoingStoryMessage: TSOutgoingMessage {
         self.skipSyncTranscript = NSNumber(value: skipSyncTranscript)
         let builder = TSOutgoingMessageBuilder(thread: thread)
         builder.timestamp = storyMessage.timestamp
+        builder.attachmentIds = storyMessage.allAttachmentIds
         super.init(outgoingMessageWithBuilder: builder, transaction: transaction)
     }
 
@@ -60,7 +61,7 @@ public class OutgoingStoryMessage: TSOutgoingMessage {
     }
 
     public class func createUnsentMessage(
-        attachment: TSAttachmentStream,
+        attachment: StoryMessageAttachment,
         thread: TSThread,
         transaction: SDSAnyWriteTransaction
     ) throws -> OutgoingStoryMessage {
@@ -84,7 +85,7 @@ public class OutgoingStoryMessage: TSOutgoingMessage {
             authorUuid: tsAccountManager.localUuid!,
             groupId: (thread as? TSGroupThread)?.groupId,
             manifest: storyManifest,
-            attachment: .file(attachmentId: attachment.uniqueId)
+            attachment: attachment
         )
         storyMessage.anyInsert(transaction: transaction)
 
@@ -179,8 +180,11 @@ public class OutgoingStoryMessage: TSOutgoingMessage {
             }
             builder.setFileAttachment(attachmentProto)
         case .text(let attachment):
-            // TODO: Sending text attachments
-            break
+            guard let attachmentProto = try? attachment.buildProto(transaction: transaction) else {
+                owsFailDebug("Missing attachment for outgoing story message")
+                return nil
+            }
+            builder.setTextAttachment(attachmentProto)
         }
 
         builder.setAllowsReplies((thread as? TSPrivateStoryThread)?.allowsReplies ?? true)
diff --git a/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift b/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift
index ba1dd00e3b5..4657608ca8d 100644
--- a/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift
+++ b/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift
@@ -109,8 +109,11 @@ public class OutgoingStorySentMessageTranscript: OWSOutgoingSyncMessage {
             }
             builder.setFileAttachment(attachmentProto)
         case .text(let attachment):
-            // TODO: Sending text attachments
-            break
+            guard let attachmentProto = try? attachment.buildProto(transaction: transaction) else {
+                owsFailDebug("Missing attachment for outgoing story message")
+                return nil
+            }
+            builder.setTextAttachment(attachmentProto)
         }
 
         builder.setAllowsReplies(true)
diff --git a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
index 43347c5e02c..941e2973fe6 100644
--- a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
+++ b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
@@ -671,6 +671,14 @@ public struct TextAttachment: Codable {
             let startColorHex: UInt32
             let endColorHex: UInt32
             let angle: UInt32
+
+            func buildProto() throws -> SSKProtoTextAttachmentGradient {
+                let builder = SSKProtoTextAttachmentGradient.builder()
+                builder.setStartColor(startColorHex)
+                builder.setEndColor(endColorHex)
+                builder.setAngle(angle)
+                return try builder.build()
+            }
         }
     }
     private let rawBackground: RawBackground
@@ -752,6 +760,70 @@ public struct TextAttachment: Codable {
             self.preview = try OWSLinkPreview.buildValidatedLinkPreview(proto: preview, transaction: transaction)
         }
     }
+
+    public func buildProto(transaction: SDSAnyReadTransaction) throws -> SSKProtoTextAttachment {
+        let builder = SSKProtoTextAttachment.builder()
+
+        if let text = text {
+            builder.setText(text)
+        }
+
+        let textStyle: SSKProtoTextAttachmentStyle = {
+            switch self.textStyle {
+            case .regular: return .regular
+            case .bold: return .bold
+            case .serif: return .serif
+            case .script: return .script
+            case .condensed: return .condensed
+            }
+        }()
+        builder.setTextStyle(textStyle)
+
+        if let textForegroundColorHex = textForegroundColorHex {
+            builder.setTextForegroundColor(textForegroundColorHex)
+        }
+
+        if let textBackgroundColorHex = textBackgroundColorHex {
+            builder.setTextBackgroundColor(textBackgroundColorHex)
+        }
+
+        switch rawBackground {
+        case .color(let hex):
+            builder.setColor(hex)
+        case .gradient(let raw):
+            builder.setGradient(try raw.buildProto())
+        }
+
+        if let preview = preview {
+            builder.setPreview(try preview.buildProto(transaction: transaction))
+        }
+
+        return try builder.build()
+    }
+
+    public init(text: String,
+                textStyle: TextStyle,
+                textForegroundColor: UIColor,
+                textBackgroundColor: UIColor?,
+                background: Background,
+                linkPreview: OWSLinkPreview?) {
+        self.text = text
+        self.textStyle = textStyle
+        self.textForegroundColorHex = textForegroundColor.argbHex
+        self.textBackgroundColorHex = textBackgroundColor?.argbHex
+        self.rawBackground = {
+            switch background {
+            case .color(let color):
+                return .color(hex: color.argbHex)
+
+            case .gradient(let gradient):
+                return .gradient(raw: .init(startColorHex: gradient.startColor.argbHex,
+                                            endColorHex: gradient.endColor.argbHex,
+                                            angle: gradient.angle))
+            }
+        }()
+        self.preview = linkPreview
+    }
 }
 
 extension SignalServiceAddress {
diff --git a/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift
index d6685ef2217..d03ffb3b740 100644
--- a/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift	
@@ -61,7 +61,7 @@ public class AttachmentMultisend: Dependencies {
         }
     }
 
-    private struct PreparedMultisend {
+    private struct PreparedMediaMultisend {
         let attachmentIdMap: [String: [String]]
         let messages: [TSOutgoingMessage]
         let unsavedMessages: [TSOutgoingMessage]
@@ -85,7 +85,7 @@ public class AttachmentMultisend: Dependencies {
         conversations: [ConversationItem],
         approvalMessageBody: MessageBody?,
         approvedAttachments: [SignalAttachment]
-    ) throws -> PreparedMultisend {
+    ) throws -> PreparedMediaMultisend {
         var attachmentsByMessageType = [TypeWrapper: [(ConversationItem, [SignalAttachment])]]()
 
         // If we're sending to any stories, limit all attachments to the standard quality level.
@@ -126,7 +126,7 @@ public class AttachmentMultisend: Dependencies {
                     guard let thread = conversation.getOrCreateThread(transaction: transaction) else {
                         throw OWSAssertionError("Missing thread for conversation")
                     }
-                    return .init(thread: thread, attachments: attachments)
+                    return .init(thread: thread, content: .media(attachments))
                 }
 
                 try wrapper.type.prepareForMultisending(destinations: destinations, state: state, transaction: transaction)
@@ -151,7 +151,7 @@ public class AttachmentMultisend: Dependencies {
             }
         }
 
-        return PreparedMultisend(
+        return PreparedMediaMultisend(
             attachmentIdMap: state.attachmentIdMap,
             messages: state.messages,
             unsavedMessages: state.unsavedMessages,
@@ -159,18 +159,69 @@ public class AttachmentMultisend: Dependencies {
     }
 }
 
-@objc
+public extension AttachmentMultisend {
+
+    class func sendTextAttachment(
+        _ textAttachment: TextAttachment,
+        to conversations: [ConversationItem]
+    ) -> Promise<[TSThread]> {
+        return firstly(on: ThreadUtil.enqueueSendQueue) {
+            let preparedSend = try self.prepareForSending(conversations: conversations, textAttachment: textAttachment)
+            self.databaseStorage.write { transaction in
+                for message in preparedSend.messages {
+                    self.messageSenderJobQueue.add(message: message.asPreparer, transaction: transaction)
+                }
+            }
+            return preparedSend.threads
+        }
+    }
+
+    private struct PreparedTextMultisend {
+        let messages: [TSOutgoingMessage]
+        let threads: [TSThread]
+    }
+
+    private class func prepareForSending(
+        conversations: [ConversationItem],
+        textAttachment: TextAttachment
+    ) throws -> PreparedTextMultisend {
+
+        let state = MultisendState(approvalMessageBody: nil)
+        let conversationsByMessageType = Dictionary(grouping: conversations, by: { TypeWrapper(type: $0.outgoingMessageClass) })
+        try self.databaseStorage.write { transaction in
+            for (wrapper, conversations) in conversationsByMessageType {
+                let destinations = try conversations.lazy.map { conversation -> MultisendDestination in
+                    guard let thread = conversation.getOrCreateThread(transaction: transaction) else {
+                        throw OWSAssertionError("Missing thread for conversation")
+                    }
+                    return .init(thread: thread, content: .text(textAttachment))
+                }
+
+                try wrapper.type.prepareForMultisending(destinations: destinations, state: state, transaction: transaction)
+            }
+        }
+
+        return PreparedTextMultisend(
+            messages: state.unsavedMessages,
+            threads: state.threads)
+    }
+}
+
+enum MultisendContent {
+    case media([SignalAttachment])
+    case text(TextAttachment)
+}
+
 class MultisendDestination: NSObject {
     let thread: TSThread
-    let attachments: [SignalAttachment]
+    let content: MultisendContent
 
-    init(thread: TSThread, attachments: [SignalAttachment]) {
+    init(thread: TSThread, content: MultisendContent) {
         self.thread = thread
-        self.attachments = attachments
+        self.content = content
     }
 }
 
-@objc
 class MultisendState: NSObject {
     let approvalMessageBody: MessageBody?
     var messages: [TSOutgoingMessage] = []
diff --git a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift
index fd2a7b497e5..6a21ab66097 100644
--- a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
@@ -13,37 +13,50 @@ extension OutgoingStoryMessage {
         var privateStoryMessageIds: [String] = []
 
         for destination in destinations {
-            for (idx, attachment) in destination.attachments.enumerated() {
-                attachment.captionText = state.approvalMessageBody?.plaintextBody(transaction: transaction.unwrapGrdbRead)
-                let attachmentStream = try attachment
-                    .buildOutgoingAttachmentInfo()
-                    .asStreamConsumingDataSource(withIsVoiceMessage: attachment.isVoiceMessage)
-                attachmentStream.anyInsert(transaction: transaction)
-
-                if state.correspondingAttachmentIds.count > idx {
-                    state.correspondingAttachmentIds[idx] += [attachmentStream.uniqueId]
-                } else {
-                    state.correspondingAttachmentIds.append([attachmentStream.uniqueId])
-                }
+            switch destination.content {
+            case .media(let attachments):
+                for (idx, attachment) in attachments.enumerated() {
+                    attachment.captionText = state.approvalMessageBody?.plaintextBody(transaction: transaction.unwrapGrdbRead)
+                    let attachmentStream = try attachment
+                        .buildOutgoingAttachmentInfo()
+                        .asStreamConsumingDataSource(withIsVoiceMessage: attachment.isVoiceMessage)
+                    attachmentStream.anyInsert(transaction: transaction)
+
+                    if state.correspondingAttachmentIds.count > idx {
+                        state.correspondingAttachmentIds[idx] += [attachmentStream.uniqueId]
+                    } else {
+                        state.correspondingAttachmentIds.append([attachmentStream.uniqueId])
+                    }
 
-                let message: OutgoingStoryMessage
-                if destination.thread is TSPrivateStoryThread, let privateStoryMessageId = privateStoryMessageIds[safe: idx] {
-                    message = try OutgoingStoryMessage.createUnsentMessage(
-                        thread: destination.thread,
-                        storyMessageId: privateStoryMessageId,
-                        transaction: transaction
-                    )
-                } else {
-                    message = try OutgoingStoryMessage.createUnsentMessage(
-                        attachment: attachmentStream,
-                        thread: destination.thread,
-                        transaction: transaction
-                    )
-                    if destination.thread is TSPrivateStoryThread {
-                        privateStoryMessageIds.append(message.storyMessageId)
+                    let message: OutgoingStoryMessage
+                    if destination.thread is TSPrivateStoryThread, let privateStoryMessageId = privateStoryMessageIds[safe: idx] {
+                        message = try OutgoingStoryMessage.createUnsentMessage(
+                            thread: destination.thread,
+                            storyMessageId: privateStoryMessageId,
+                            transaction: transaction
+                        )
+                    } else {
+                        message = try OutgoingStoryMessage.createUnsentMessage(
+                            attachment: .file(attachmentId: attachmentStream.uniqueId),
+                            thread: destination.thread,
+                            transaction: transaction
+                        )
+                        if destination.thread is TSPrivateStoryThread {
+                            privateStoryMessageIds.append(message.storyMessageId)
+                        }
                     }
+
+                    state.messages.append(message)
+                    state.unsavedMessages.append(message)
                 }
 
+            case .text(let textAttachment):
+                let message = try OutgoingStoryMessage.createUnsentMessage(
+                    attachment: .text(attachment: textAttachment),
+                    thread: destination.thread,
+                    transaction: transaction
+                )
+
                 state.messages.append(message)
                 state.unsavedMessages.append(message)
             }
diff --git a/SignalUI/Utils/Attachment Multisend/TSOutgoingMessage+AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/TSOutgoingMessage+AttachmentMultisend.swift
index 76181e1cb71..824f797f84a 100644
--- a/SignalUI/Utils/Attachment Multisend/TSOutgoingMessage+AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/TSOutgoingMessage+AttachmentMultisend.swift	
@@ -23,12 +23,20 @@ extension TSOutgoingMessage {
                 transaction: transaction.unwrapGrdbRead
             )
 
-            let message = try ThreadUtil.createUnsentMessage(
-                body: messageBodyForContext,
-                mediaAttachments: destination.attachments,
-                thread: destination.thread,
-                transaction: transaction
-            )
+            let message: TSOutgoingMessage
+            switch destination.content {
+            case .media(let attachments):
+                message = try ThreadUtil.createUnsentMessage(
+                    body: messageBodyForContext,
+                    mediaAttachments: attachments,
+                    thread: destination.thread,
+                    transaction: transaction
+                )
+
+            case .text:
+                owsFailDebug("Cannot send TextAttachment to chats.")
+                continue
+            }
 
             state.messages.append(message)
             state.threads.append(destination.thread)
diff --git a/SignalUI/Views/ColorPickerBar.swift b/SignalUI/Views/ColorPickerBar.swift
index 83827924f44..d1b38673b9c 100644
--- a/SignalUI/Views/ColorPickerBar.swift
+++ b/SignalUI/Views/ColorPickerBar.swift
@@ -33,6 +33,10 @@ public class ColorPickerBarColor {
         return ColorPickerBarColor(color: UIColor(rgbHex: 0xff0000), palettePhase: 1/9)
     }
 
+    class var white: ColorPickerBarColor {
+        ColorPickerBarColor(color: UIColor(rgbHex: 0xffffff), palettePhase: 1)
+    }
+
     static var gradientUIColors: [UIColor] {
         return [
             UIColor(rgbHex: 0x000000),
@@ -166,19 +170,18 @@ private class ColorPreviewView: OWSLayerView {
 
 public class ColorPickerBarView: UIView {
 
-    weak var delegate: ColorPickerBarViewDelegate?
+    public weak var delegate: ColorPickerBarViewDelegate?
 
+    public var color: UIColor { selectedValue.color }
     var selectedValue: ColorPickerBarColor {
         didSet {
             updateState()
         }
     }
 
-    required init(currentColor: ColorPickerBarColor) {
-        self.selectedValue = currentColor
-
+    required init(currentColor: ColorPickerBarColor? = nil) {
+        selectedValue = currentColor ?? ColorPickerBarColor.defaultColor()
         super.init(frame: .zero)
-
         createContents()
     }
 
diff --git a/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift b/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift
index 580cafe49c7..cbe2e966e60 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorViewController+Text.swift
@@ -93,9 +93,7 @@ extension ImageEditorViewController {
     // in order to reflect the changes right away.
     func updateTextViewAttributes(using textToolbar: TextStylingToolbar) {
         let fontPointSize = textView.font?.pointSize ?? ImageEditorTextItem.defaultFontSize
-        textView.update(withColor: textToolbar.colorPickerView.selectedValue.color,
-                        font: MediaTextView.font(forTextStyle: textToolbar.textStyle, pointSize: fontPointSize),
-                        decorationStyle: textToolbar.decorationStyle)
+        textView.update(using: textToolbar, fontPointSize: fontPointSize)
     }
 
     override func updateBottomLayoutConstraint(fromInset before: CGFloat, toInset after: CGFloat) {
diff --git a/SignalUI/Views/ImageEditor/ImageEditorViewController.swift b/SignalUI/Views/ImageEditor/ImageEditorViewController.swift
index 40f222a0133..f76b7e2b415 100644
--- a/SignalUI/Views/ImageEditor/ImageEditorViewController.swift
+++ b/SignalUI/Views/ImageEditor/ImageEditorViewController.swift
@@ -199,7 +199,7 @@ class ImageEditorViewController: OWSViewController {
         return textView
     }()
     lazy var textToolbar: TextStylingToolbar = {
-        let toolbar = TextStylingToolbar(currentColor: currentTextItem?.textItem.color ?? model.color)
+        let toolbar = TextStylingToolbar(layout: .photoOverlay, currentColor: currentTextItem?.textItem.color ?? model.color)
         toolbar.preservesSuperviewLayoutMargins = true
         toolbar.colorPickerView.delegate = self
         toolbar.textStyleButton.addTarget(self, action: #selector(didTapTextStyleButton(sender:)), for: .touchUpInside)
@@ -207,7 +207,7 @@ class ImageEditorViewController: OWSViewController {
         return toolbar
     }()
     lazy var textViewAccessoryToolbar: TextStylingToolbar = {
-        let toolbar = TextStylingToolbar(currentColor: currentTextItem?.textItem.color ?? model.color)
+        let toolbar = TextStylingToolbar(layout: .photoOverlay, currentColor: currentTextItem?.textItem.color ?? model.color)
         toolbar.preservesSuperviewLayoutMargins = true
         toolbar.colorPickerView.delegate = self
         toolbar.textStyleButton.addTarget(self, action: #selector(didTapTextStyleButton(sender:)), for: .touchUpInside)
diff --git a/SignalUI/Views/MediaTextView.swift b/SignalUI/Views/MediaTextView.swift
index 5b99cd6acb3..3f494f705b1 100644
--- a/SignalUI/Views/MediaTextView.swift
+++ b/SignalUI/Views/MediaTextView.swift
@@ -6,14 +6,14 @@ import UIKit
 
 public class MediaTextView: UITextView {
 
-    enum DecorationStyle: Int {
+    public enum DecorationStyle: Int {
         case none = 0
         case inverted
         case underline
         case outline
     }
 
-    enum TextStyle: Int {
+    public enum TextStyle: Int {
         case regular = 0
         case bold
         case serif
@@ -77,7 +77,20 @@ public class MediaTextView: UITextView {
         // TODO: Figure out correct way to handle long text and implement it.
     }
 
-    func update(withColor color: UIColor, font: UIFont, decorationStyle: MediaTextView.DecorationStyle) {
+    public func update(using textStylingToolbar: TextStylingToolbar,
+                       fontPointSize: CGFloat,
+                       textAlignment: NSTextAlignment = .center) {
+        let font = MediaTextView.font(forTextStyle: textStylingToolbar.textStyle, pointSize: fontPointSize)
+        update(withColor: textStylingToolbar.colorPickerView.color,
+               font: font,
+               textAlignment: textAlignment,
+               decorationStyle: textStylingToolbar.decorationStyle)
+    }
+
+    public func update(withColor color: UIColor,
+                       font: UIFont,
+                       textAlignment: NSTextAlignment = .center,
+                       decorationStyle: MediaTextView.DecorationStyle) {
         var attributes: [NSAttributedString.Key: Any] = [ .font: font]
 
         let textColor: UIColor = {
@@ -89,7 +102,7 @@ public class MediaTextView: UITextView {
         attributes[.foregroundColor] = textColor
 
         if let paragraphStyle = NSParagraphStyle.default.mutableCopy() as? NSMutableParagraphStyle {
-            paragraphStyle.alignment = .center
+            paragraphStyle.alignment = textAlignment
             attributes[.paragraphStyle] = paragraphStyle
         }
 
@@ -137,20 +150,39 @@ public class MediaTextView: UITextView {
 
 public class TextStylingToolbar: UIView {
 
-    let colorPickerView: ColorPickerBarView
+    public enum Layout {
+        case photoOverlay
+        case textStory
+    }
+    let layout: Layout
+
+    public let colorPickerView: ColorPickerBarView
+
+    private static func defaultColor(forLayout layout: Layout) -> ColorPickerBarColor {
+        switch layout {
+        case .photoOverlay:
+            return ColorPickerBarColor.defaultColor()
+        case .textStory:
+            return ColorPickerBarColor.white
+        }
+    }
 
-    let textStyleButton = RoundMediaButton(image: #imageLiteral(resourceName: "media-editor-text-font"), backgroundStyle: .blur)
-    var textStyle: MediaTextView.TextStyle = .regular
+    public let textStyleButton = RoundMediaButton(image: #imageLiteral(resourceName: "media-editor-text-font"), backgroundStyle: .blur)
+    public var textStyle: MediaTextView.TextStyle = .regular
 
-    let decorationStyleButton = RoundMediaButton(image: #imageLiteral(resourceName: "media-editor-text-style-1"), backgroundStyle: .blur)
-    var decorationStyle: MediaTextView.DecorationStyle = .none {
+    public let decorationStyleButton = RoundMediaButton(image: #imageLiteral(resourceName: "media-editor-text-style-1"), backgroundStyle: .blur)
+    public var decorationStyle: MediaTextView.DecorationStyle = .none {
         didSet {
             decorationStyleButton.isSelected = (decorationStyle != .none)
         }
     }
 
-    init(currentColor: ColorPickerBarColor) {
-        self.colorPickerView = ColorPickerBarView(currentColor: currentColor)
+    public lazy var doneButton = RoundMediaButton(image: UIImage(imageLiteralResourceName: "check-24"), backgroundStyle: .blur)
+
+    public init(layout: Layout, currentColor: ColorPickerBarColor? = nil) {
+        self.layout = layout
+        colorPickerView = ColorPickerBarView(currentColor: currentColor ?? TextStylingToolbar.defaultColor(forLayout: layout))
+
         super.init(frame: .zero)
 
         decorationStyleButton.setContentCompressionResistancePriority(.required, for: .vertical)
@@ -173,16 +205,34 @@ public class TextStylingToolbar: UIView {
 
         // I had to use a custom layout guide because stack view isn't centered
         // but instead has slight offset towards the trailing edge.
-        let stackView = UIStackView(arrangedSubviews: [ colorPickerView, textStyleButton, decorationStyleButton ])
+        let stackViewSubviews: [UIView] = {
+            switch layout {
+            case .photoOverlay:
+                return [ colorPickerView, textStyleButton, decorationStyleButton ]
+            case .textStory:
+                return [ textStyleButton, decorationStyleButton, colorPickerView, doneButton ]
+            }
+        }()
+        let stackView = UIStackView(arrangedSubviews: stackViewSubviews)
         stackView.translatesAutoresizingMaskIntoConstraints = false
         stackView.alignment = .center
         stackView.spacing = 8
         stackView.setCustomSpacing(0, after: textStyleButton)
         addSubview(stackView)
+
+        // Round buttons have no-zero layout margins. Use values of those margins
+        // to offset button positions so that they appear properly aligned.
+        var leadingMargin: CGFloat = 0
+        var trailingMargin: CGFloat = 0
+        if let button = stackViewSubviews.first as? RoundMediaButton {
+            leadingMargin = button.layoutMargins.leading
+        }
+        if let button = stackViewSubviews.last as? RoundMediaButton {
+            trailingMargin = button.layoutMargins.trailing
+        }
         addConstraints([
-            stackView.leadingAnchor.constraint(equalTo: stackViewLayoutGuide.leadingAnchor),
-            stackView.trailingAnchor.constraint(equalTo: stackViewLayoutGuide.trailingAnchor,
-                                                constant: decorationStyleButton.layoutMargins.trailing),
+            stackView.leadingAnchor.constraint(equalTo: stackViewLayoutGuide.leadingAnchor, constant: -leadingMargin),
+            stackView.trailingAnchor.constraint(equalTo: stackViewLayoutGuide.trailingAnchor, constant: trailingMargin),
             stackView.topAnchor.constraint(equalTo: stackViewLayoutGuide.topAnchor),
             stackView.bottomAnchor.constraint(equalTo: stackViewLayoutGuide.bottomAnchor) ])
     }
diff --git a/SignalUI/Views/RoundMediaButton.swift b/SignalUI/Views/RoundMediaButton.swift
index c70f5a5a596..88946f97b4c 100644
--- a/SignalUI/Views/RoundMediaButton.swift
+++ b/SignalUI/Views/RoundMediaButton.swift
@@ -15,14 +15,22 @@ open class RoundMediaButton: UIButton {
 
     let backgroundStyle: BackgroundStyle
     private var backgroundContainerView: UIView?
-    let backgroundView: UIView?
+    private let backgroundView: UIView?
     private var backgroundDimmerView: UIView?
     public static let defaultBackgroundColor = UIColor.ows_gray80
     static let visibleButtonSize: CGFloat = 42
     private static let defaultInset: CGFloat = 8
     private static let defaultContentInset: CGFloat = 15
 
-    public required init(image: UIImage?, backgroundStyle: BackgroundStyle) {
+    public convenience init(image: UIImage?, backgroundStyle: BackgroundStyle) {
+        self.init(image: image, backgroundStyle: backgroundStyle, customView: nil)
+    }
+
+    public convenience init(customView: UIView, backgroundStyle: BackgroundStyle) {
+        self.init(image: nil, backgroundStyle: backgroundStyle, customView: customView)
+    }
+
+    public init(image: UIImage?, backgroundStyle: BackgroundStyle, customView: UIView?) {
         self.backgroundStyle = backgroundStyle
         self.backgroundView = {
             switch backgroundStyle {
@@ -44,22 +52,23 @@ open class RoundMediaButton: UIButton {
         tintColor = Theme.darkThemePrimaryColor
         insetsLayoutMarginsFromSafeArea = false
 
-        switch backgroundStyle {
-        case .solid, .blur:
-            backgroundContainerView = PillView()
-
-        case .none:
-            break
-        }
-
-        if let backgroundContainerView = backgroundContainerView, let backgroundView = backgroundView {
+        if backgroundView != nil || customView != nil {
+            let backgroundContainerView = PillView()
             backgroundContainerView.isUserInteractionEnabled = false
             addSubview(backgroundContainerView)
             backgroundContainerView.autoPinEdgesToSuperviewMargins()
+            self.backgroundContainerView = backgroundContainerView
 
-            backgroundView.isUserInteractionEnabled = false
-            backgroundContainerView.addSubview(backgroundView)
-            backgroundView.autoPinEdgesToSuperviewEdges()
+            if let backgroundView = backgroundView {
+                backgroundView.isUserInteractionEnabled = false
+                backgroundContainerView.addSubview(backgroundView)
+                backgroundView.autoPinEdgesToSuperviewEdges()
+            }
+
+            if let customView = customView {
+                backgroundContainerView.addSubview(customView)
+                customView.autoCenterInSuperview()
+            }
 
             let backgroundDimmerView = UIView(frame: backgroundContainerView.bounds)
             // Match color of the highlighted white button image.
