diff --git a/Signal/src/ViewControllers/ConversationView/CVViewState.swift b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
index 1072e2339d5..a997c62b2cc 100644
--- a/Signal/src/ViewControllers/ConversationView/CVViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -64,9 +64,9 @@ public class CVViewState: NSObject {
     @objc
     public var isUserScrolling = false
     @objc
-    public var scrollingAnimationStartDate: Date?
+    public var scrollingAnimationCompletionTimer: Timer?
     @objc
-    public var hasScrollingAnimation: Bool { scrollingAnimationStartDate != nil }
+    public var hasScrollingAnimation: Bool { scrollingAnimationCompletionTimer != nil }
     @objc
     public var scrollContinuity: ScrollContinuity = .bottom
     public var scrollContinuityMap: CVScrollContinuityMap?
@@ -204,9 +204,9 @@ public extension ConversationViewController {
         set { viewState.isUserScrolling = newValue }
     }
 
-    var scrollingAnimationStartDate: Date? {
-        get { viewState.scrollingAnimationStartDate }
-        set { viewState.scrollingAnimationStartDate = newValue }
+    var scrollingAnimationCompletionTimer: Timer? {
+        get { viewState.scrollingAnimationCompletionTimer }
+        set { viewState.scrollingAnimationCompletionTimer = newValue }
     }
 
     var hasScrollingAnimation: Bool { viewState.hasScrollingAnimation }
diff --git a/Signal/src/ViewControllers/ConversationView/Cells/CVMediaAlbumView.swift b/Signal/src/ViewControllers/ConversationView/Cells/CVMediaAlbumView.swift
index 67187cdfb6d..9514deacee2 100644
--- a/Signal/src/ViewControllers/ConversationView/Cells/CVMediaAlbumView.swift
+++ b/Signal/src/ViewControllers/ConversationView/Cells/CVMediaAlbumView.swift
@@ -71,7 +71,6 @@ public class CVMediaAlbumView: UIStackView {
                                 maxMessageWidth: CGFloat) {
 
         if let measuredSize = cellMeasurement.size(key: Self.measurementKey) {
-            Logger.verbose("---- measuredSize.1: \(measuredSize), aspect: \(measuredSize.aspectRatio)")
             layoutConstraints.append(self.autoSetDimension(.height, toSize: measuredSize.height))
         } else {
             owsFailDebug("Missing measuredSize.")
@@ -79,8 +78,6 @@ public class CVMediaAlbumView: UIStackView {
 
         for (index, itemView) in itemViews.enumerated() {
             if let measuredSize = cellMeasurement.size(key: Self.measurementKey(imageIndex: index)) {
-                Logger.verbose("---- measuredSize.2: \(measuredSize), aspect: \(measuredSize.aspectRatio)")
-                itemView.logFrameLater(withLabel: "---- itemView")
                 // The item heights should always exactly match the layout.
                 layoutConstraints.append(itemView.autoSetDimension(.height, toSize: measuredSize.height))
                 // The media album view's width might be larger than
@@ -96,8 +93,6 @@ public class CVMediaAlbumView: UIStackView {
             }
         }
 
-        logFrameLater(withLabel: "---- media album view")
-
         switch itemViews.count {
         case 0:
             owsFailDebug("No item views.")
@@ -293,12 +288,9 @@ public class CVMediaAlbumView: UIStackView {
 
                 let mediaSize = mediaAlbumItem.mediaSize
                 guard mediaSize.width > 0 && mediaSize.height > 0 else {
-//                    owsFailDebug("Invalid mediaSize.")
+                    owsFailDebug("Invalid mediaSize.")
                     return nil
                 }
-                Logger.verbose("---- maxWidth: \(maxWidth)")
-                Logger.verbose("---- mediaSize: \(mediaSize), aspect: \(mediaSize.width / mediaSize.height)")
-
                 // Honor the content aspect ratio for single media.
                 var contentAspectRatio = mediaSize.width / mediaSize.height
                 // Clamp the aspect ratio so that very thin/wide content is presented
@@ -335,9 +327,6 @@ public class CVMediaAlbumView: UIStackView {
             }
 
             let size = buildSingleMediaSize() ?? CGSize(square: maxWidth)
-
-            Logger.verbose("---- size: \(size), aspect: \(size.aspectRatio)")
-
             measurementBuilder.setSize(key: measurementKey(imageIndex: 0),
                                        size: size)
             measurementBuilder.setSize(key: measurementKey, size: size)
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 9591b946768..a941c408716 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -3228,33 +3228,36 @@ - (void)scrollingAnimationDidStart
 {
     OWSAssertIsOnMainThread();
 
-    NSDate *startDate = [NSDate new];
-    self.scrollingAnimationStartDate = startDate;
-
     // scrollingAnimationStartDate blocks landing of loads, so we must ensure
     // that it is always cleared in a timely way, even if the animation
     // is cancelled. Wait no more than N seconds.
-    __weak ConversationViewController *weakSelf = self;
-    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)5.f * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
-        ConversationViewController *_Nullable strongSelf = weakSelf;
-        if (!strongSelf) {
-            return;
-        }
+    [self.scrollingAnimationCompletionTimer invalidate];
+    self.scrollingAnimationCompletionTimer =
+        [NSTimer weakScheduledTimerWithTimeInterval:5
+                                             target:self
+                                           selector:@selector(scrollingAnimationCompletionTimerDidFire:)
+                                           userInfo:nil
+                                            repeats:NO];
+}
 
-        // scrollingAnimationStartDate should already have been cleared,
-        // but we need to ensure that it is cleared in a timely way.
-        if ([NSObject isNullableObject:strongSelf.scrollingAnimationStartDate equalTo:startDate]) {
-            OWSFailDebug(@"Scrolling animation did not complete in a timely way.");
-            [strongSelf scrollingAnimationDidComplete];
-        }
-    });
+- (void)scrollingAnimationCompletionTimerDidFire:(NSTimer *)timer
+{
+    OWSAssertIsOnMainThread();
+
+    OWSFailDebug(@"Scrolling animation did not complete in a timely way.");
+
+    // scrollingAnimationCompletionTimer should already have been cleared,
+    // but we need to ensure that it is cleared in a timely way.
+    [self scrollingAnimationDidComplete];
 }
 
 - (void)scrollingAnimationDidComplete
 {
     OWSAssertIsOnMainThread();
 
-    self.scrollingAnimationStartDate = nil;
+    [self.scrollingAnimationCompletionTimer invalidate];
+    self.scrollingAnimationCompletionTimer = nil;
+
     [self autoLoadMoreIfNecessary];
 }
 
