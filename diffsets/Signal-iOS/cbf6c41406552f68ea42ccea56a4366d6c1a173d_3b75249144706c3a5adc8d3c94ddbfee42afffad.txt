diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
index 48f2e901112..0dc7b9ae7ed 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
@@ -149,7 +149,7 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
 
             // Add mentions.
             if let attributedString = attributedString {
-                attributedString.enumerateMentions { mention, range, _ in
+                attributedString.enumerateMentionsAndStyles { mention, _, range, _ in
                     guard let mention = mention else { return }
                     let mentionItem = CVTextLabel.MentionItem(mention: mention, range: range)
                     let item: CVTextLabel.Item = .mention(mentionItem: mentionItem)
@@ -739,6 +739,17 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             }
         }
 
+        if FeatureFlags.textFormattingReceiveSupport {
+            // Styles take precedence over everything else, so apply them last.
+            // TODO[TextFormatting]: spoilers in search results should change both
+            // the highlight and the text color to yellow.
+            MessageBodyRanges.applyStyleAttributes(
+                on: attributedText,
+                baseFont: textMessageFont,
+                textColor: bodyTextColor
+            )
+        }
+
         var extraCacheKeyFactors = [String]()
         if hasPendingMessageRequest {
             extraCacheKeyFactors.append("hasPendingMessageRequest")
diff --git a/Signal/src/util/DisplayableText.swift b/Signal/src/util/DisplayableText.swift
index e3fca76871d..851d8ea7fbd 100644
--- a/Signal/src/util/DisplayableText.swift
+++ b/Signal/src/util/DisplayableText.swift
@@ -136,6 +136,9 @@ public class DisplayableText: NSObject {
         }
 
         // When the theme changes, we must refresh any mention attributes.
+        // Note that text formatting styles are also theme dependent but
+        // get set along with the rest of the properties applied to the
+        // whole text body (e.g. CVComponentBodyText.textViewConfig).
         fullContent = updateContent(fullContent)
 
         if let truncatedContent = truncatedContent {
diff --git a/SignalServiceKit/src/Messages/MessageBody.swift b/SignalServiceKit/src/Messages/MessageBody.swift
index 830de4ba5d2..8021c37b5e9 100644
--- a/SignalServiceKit/src/Messages/MessageBody.swift
+++ b/SignalServiceKit/src/Messages/MessageBody.swift
@@ -50,10 +50,13 @@ public class MessageBody: NSObject, NSCopying, NSSecureCoding {
     // want to apply some styles.
     public func plaintextBody(transaction: GRDBReadTransaction) -> String {
         let hydratedMessageBody = hydratingMentions(hydrator: { mentionUUID in
-            return .hydrate(displayName: Self.contactsManager.displayName(
-                for: SignalServiceAddress(uuid: mentionUUID),
-                transaction: transaction.asAnyRead
-            ))
+            return .hydrate(
+                Self.contactsManager.displayName(
+                    for: SignalServiceAddress(uuid: mentionUUID),
+                    transaction: transaction.asAnyRead
+                ),
+                alreadyIncludesPrefix: false
+            )
         })
         return (hydratedMessageBody.text as NSString).filterStringForDisplay()
     }
@@ -90,159 +93,22 @@ public class MessageBody: NSObject, NSCopying, NSSecureCoding {
                     for: address,
                     transaction: transaction.asAnyRead
                 )
-                return .hydrate(displayName: displayName)
+                return .hydrate(displayName, alreadyIncludesPrefix: false)
             }
         })
     }
 
-    enum HydrationOption {
-        /// Do not hydrate the mention; this leaves the string as it was in the original,
-        /// which we want to do e.g. when forwarding a message with mentions from one
-        /// thread context to another, where we hydrate the mentions of members not in
-        /// the destination, but preserve mentions of shared members fully intact.
-        case preserveMention
-        /// Replace the mention range with the populated display name.
-        case hydrate(displayName: String)
-    }
-
     internal func hydratingMentions(
-        hydrator: (UUID) -> HydrationOption,
+        hydrator: (UUID) -> MessageBodyRanges.MentionHydrationOption,
         isRTL: Bool = CurrentAppContext().isRTL
     ) -> MessageBody {
-        guard hasMentions else {
-            return self
-        }
-
-        let finalText = NSMutableString(string: text)
-        var finalMentions = [NSRange: UUID]()
-        var finalStyles = [(NSRange, Style)]()
-
-        var mentionsInOriginal = ranges.orderedMentions
-        var stylesInOriginal = ranges.styles
-
-        var rangeOffset = 0
-
-        struct ProcessingStyle {
-            let originalRange: NSRange
-            let newRange: NSRange
-            let style: Style
-        }
-        var styleAtCurrentIndex: ProcessingStyle?
-
-        let nsString = text as NSString
-        for currentIndex in 0..<nsString.length {
-            // If we are past the end, apply the active style to the final result
-            // and drop.
-            if
-                let style = styleAtCurrentIndex,
-                currentIndex >= style.originalRange.upperBound
-            {
-                finalStyles.append((style.newRange, style.style))
-                styleAtCurrentIndex = nil
-            }
-            // Check for any new styles starting at the current index.
-            if stylesInOriginal.first?.0.contains(currentIndex) == true {
-                let (originalRange, style) = stylesInOriginal.removeFirst()
-                styleAtCurrentIndex = .init(
-                    originalRange: originalRange,
-                    newRange: NSRange(
-                        location: originalRange.location + rangeOffset,
-                        length: originalRange.length
-                    ),
-                    style: style
-                )
-            }
-
-            // Check for any mentions at the current index.
-            // Mentions can't overlap, so we don't need a while loop to check for multiple.
-            guard
-                let (originalMentionRange, mentionUuid) = mentionsInOriginal.first,
-                (
-                    originalMentionRange.contains(currentIndex)
-                    || originalMentionRange.location == currentIndex
-                )
-            else {
-                // No mentions, so no additional logic needed, just go to the next index.
-                continue
-            }
-            mentionsInOriginal.removeFirst()
-
-            let newMentionRange = NSRange(
-                location: originalMentionRange.location + rangeOffset,
-                length: originalMentionRange.length
-            )
-
-            switch hydrator(mentionUuid) {
-            case .preserveMention:
-                // Preserve the mention without replacement and proceed.
-                finalMentions[newMentionRange] = mentionUuid
-                continue
-            case .hydrate(let displayName):
-                let mentionPlaintext: String
-                if isRTL {
-                    mentionPlaintext = displayName + MessageBodyRanges.mentionPrefix
-                } else {
-                    mentionPlaintext = MessageBodyRanges.mentionPrefix + displayName
-                }
-                let finalMentionLength = (mentionPlaintext as NSString).length
-                let extraOffset = finalMentionLength - originalMentionRange.length
-                finalText.replaceCharacters(in: newMentionRange, with: mentionPlaintext)
-                rangeOffset += extraOffset
-
-                // We have to adjust style ranges for the active style
-                if let style = styleAtCurrentIndex {
-                    if style.originalRange.upperBound <= originalMentionRange.upperBound {
-                        // If the style ended inside (or right at the end of) the mention,
-                        // it should now end at the end of the replacement text.
-
-                        let finalLength = (newMentionRange.location + finalMentionLength) - style.newRange.location
-                        let finalStyle = (
-                            NSRange(
-                                location: style.newRange.location,
-                                length: finalLength
-                            ),
-                            style.style
-                        )
-                        finalStyles.append(finalStyle)
-
-                        // We are done with it, now.
-                        styleAtCurrentIndex = nil
-                    } else {
-                        // The original style ends past the mention; extend its
-                        // length by the right amount, but keep it in
-                        // the current styles being walked through.
-                        styleAtCurrentIndex = .init(
-                            originalRange: style.originalRange,
-                            newRange: NSRange(
-                                location: style.newRange.location,
-                                length: style.newRange.length + extraOffset
-                            ),
-                            style: style.style
-                        )
-                    }
-                }
-            }
-        }
-
-        if let style = styleAtCurrentIndex {
-            // Styles that ran right to the end (or overran) should be finalized.
-            let finalStyle = (
-                NSRange(
-                    location: style.newRange.location,
-                    length: finalText.length - style.newRange.location
-                ),
-                style.style
-            )
-            finalStyles.append(finalStyle)
-        }
-
-        return MessageBody(
-            text: String(finalText),
-            ranges: MessageBodyRanges(
-                mentions: finalMentions,
-                styles: finalStyles
-            )
+        let text = NSMutableAttributedString(string: self.text)
+        let ranges = ranges.hydratingMentions(
+            in: text,
+            hydrator: hydrator,
+            isRTL: isRTL
         )
+        return MessageBody(text: text.string, ranges: ranges)
     }
 
     override public func isEqual(_ object: Any?) -> Bool {
@@ -289,6 +155,8 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         static let spoiler = Style(rawValue: 1 << 2)
         static let strikethrough = Style(rawValue: 1 << 3)
         static let monospace = Style(rawValue: 1 << 4)
+
+        static let attributedStringKey = NSAttributedString.Key("OWSStyle")
     }
 
     /// Sorted from lowest location to highest location.
@@ -511,6 +379,285 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         return MessageBody(text: text, ranges: self).plaintextBody(transaction: transaction)
     }
 
+    public enum MentionHydrationOption {
+        /// Do not hydrate the mention; this leaves the string as it was in the original,
+        /// which we want to do e.g. when forwarding a message with mentions from one
+        /// thread context to another, where we hydrate the mentions of members not in
+        /// the destination, but preserve mentions of shared members fully intact.
+        case preserveMention
+        /// Replace the mention range with the populated display name.
+        case hydrate(String, alreadyIncludesPrefix: Bool)
+        /// Replace the mention range with the populated display name and attributes.
+        case hydrateAttributed(NSAttributedString, alreadyIncludesPrefix: Bool)
+    }
+
+    /// Hydrates mentions (as determined by the hydrator) and sets the `.owsStyle` attribute
+    /// on the string for any styles but *does not* actually apply the styles. (e.g. no font attribute)
+    /// `.owsStyle` attributes can be converted to attributes just before display, when the font
+    /// and text color are available.
+    public func hydrateMentionsAndSetStyleAttributes(
+        on string: NSMutableAttributedString,
+        hydrator: (UUID) -> MentionHydrationOption,
+        isRTL: Bool = CurrentAppContext().isRTL
+    ) {
+        let newStyles = hydratingMentions(
+            in: string,
+            hydrator: hydrator,
+            isRTL: isRTL
+        )
+        newStyles.setStyleAttributesWithoutApplying(on: string)
+    }
+
+    /// Applies hydrations to the provided `NSMutableAttributedString`, and returns any
+    /// ranges left over (styles and preserved mentions) with ranges updated to reflect the new string.
+    public func hydratingMentions(
+        in text: NSMutableAttributedString,
+        hydrator: (UUID) -> MentionHydrationOption,
+        isRTL: Bool = CurrentAppContext().isRTL
+    ) -> MessageBodyRanges {
+        guard hasMentions else {
+            return self
+        }
+
+        let finalText = text
+        var finalMentions = [NSRange: UUID]()
+        var finalStyles = [(NSRange, Style)]()
+
+        var mentionsInOriginal = orderedMentions
+        var stylesInOriginal = styles
+
+        var rangeOffset = 0
+
+        struct ProcessingStyle {
+            let originalRange: NSRange
+            let newRange: NSRange
+            let style: Style
+        }
+        var styleAtCurrentIndex: ProcessingStyle?
+
+        let startLength = text.length
+        for currentIndex in 0..<startLength {
+            // If we are past the end, apply the active style to the final result
+            // and drop.
+            if
+                let style = styleAtCurrentIndex,
+                currentIndex >= style.originalRange.upperBound
+            {
+                finalStyles.append((style.newRange, style.style))
+                styleAtCurrentIndex = nil
+            }
+            // Check for any new styles starting at the current index.
+            if stylesInOriginal.first?.0.contains(currentIndex) == true {
+                let (originalRange, style) = stylesInOriginal.removeFirst()
+                styleAtCurrentIndex = .init(
+                    originalRange: originalRange,
+                    newRange: NSRange(
+                        location: originalRange.location + rangeOffset,
+                        length: originalRange.length
+                    ),
+                    style: style
+                )
+            }
+
+            // Check for any mentions at the current index.
+            // Mentions can't overlap, so we don't need a while loop to check for multiple.
+            guard
+                let (originalMentionRange, mentionUuid) = mentionsInOriginal.first,
+                (
+                    originalMentionRange.contains(currentIndex)
+                    || originalMentionRange.location == currentIndex
+                )
+            else {
+                // No mentions, so no additional logic needed, just go to the next index.
+                continue
+            }
+            mentionsInOriginal.removeFirst()
+
+            let newMentionRange = NSRange(
+                location: originalMentionRange.location + rangeOffset,
+                length: originalMentionRange.length
+            )
+
+            let finalMentionLength: Int
+            let mentionOffsetDelta: Int
+            switch hydrator(mentionUuid) {
+            case .preserveMention:
+                // Preserve the mention without replacement and proceed.
+                finalMentions[newMentionRange] = mentionUuid
+                continue
+            case let .hydrate(displayName, alreadyIncludesPrefix):
+                let mentionPlaintext: String
+                if alreadyIncludesPrefix {
+                    mentionPlaintext = displayName
+                } else {
+                    if isRTL {
+                        mentionPlaintext = displayName + MessageBodyRanges.mentionPrefix
+                    } else {
+                        mentionPlaintext = MessageBodyRanges.mentionPrefix + displayName
+                    }
+                }
+                finalMentionLength = (mentionPlaintext as NSString).length
+                mentionOffsetDelta = finalMentionLength - originalMentionRange.length
+                finalText.replaceCharacters(in: newMentionRange, with: mentionPlaintext)
+            case let .hydrateAttributed(displayName, alreadyIncludesPrefix):
+                let mentionString: NSAttributedString
+                if alreadyIncludesPrefix {
+                    mentionString = displayName
+                } else {
+                    let base = NSMutableAttributedString(attributedString: displayName)
+                    let replacement = NSAttributedString(string: MessageBodyRanges.mentionPrefix)
+                    if isRTL {
+                        base.replaceCharacters(in: NSRange(location: 0, length: 0), with: replacement)
+                    } else {
+                        base.replaceCharacters(in: NSRange(location: base.length, length: 0), with: replacement)
+                    }
+                    mentionString = base
+                }
+                finalMentionLength = mentionString.length
+                mentionOffsetDelta = finalMentionLength - originalMentionRange.length
+                finalText.replaceCharacters(in: newMentionRange, with: mentionString)
+            }
+            rangeOffset += mentionOffsetDelta
+
+            // We have to adjust style ranges for the active style
+            if let style = styleAtCurrentIndex {
+                if style.originalRange.upperBound <= originalMentionRange.upperBound {
+                    // If the style ended inside (or right at the end of) the mention,
+                    // it should now end at the end of the replacement text.
+
+                    let finalLength = (newMentionRange.location + finalMentionLength) - style.newRange.location
+                    let finalStyle = (
+                        NSRange(
+                            location: style.newRange.location,
+                            length: finalLength
+                        ),
+                        style.style
+                    )
+                    finalStyles.append(finalStyle)
+
+                    // We are done with it, now.
+                    styleAtCurrentIndex = nil
+                } else {
+                    // The original style ends past the mention; extend its
+                    // length by the right amount, but keep it in
+                    // the current styles being walked through.
+                    styleAtCurrentIndex = .init(
+                        originalRange: style.originalRange,
+                        newRange: NSRange(
+                            location: style.newRange.location,
+                            length: style.newRange.length + mentionOffsetDelta
+                        ),
+                        style: style.style
+                    )
+                }
+            }
+        }
+
+        if let style = styleAtCurrentIndex {
+            // Styles that ran right to the end (or overran) should be finalized.
+            let finalStyle = (
+                NSRange(
+                    location: style.newRange.location,
+                    length: finalText.length - style.newRange.location
+                ),
+                style.style
+            )
+            finalStyles.append(finalStyle)
+        }
+
+        return MessageBodyRanges(
+            mentions: finalMentions,
+            styles: finalStyles
+        )
+    }
+
+    /// Sets the `.owsStyle` attribute on the string for any styles but
+    /// *does not* actually apply the styles. (e.g. no font attribute)
+    /// `.owsStyle` attributes can be converted to attributes just before display,
+    /// when the font and text color are available.
+    public func setStyleAttributesWithoutApplying(on string: NSMutableAttributedString) {
+        for (range, style) in styles {
+            string.addAttributes([.owsStyle: style], range: range)
+        }
+    }
+
+    /// Applies styles to the provided string (sets attributes for font, strikethrough, etc).
+    /// Font and colors for styles are based on the provided base font and color.
+    public func applyStyles(
+        to string: NSMutableAttributedString,
+        baseFont: UIFont,
+        textColor: UIColor
+    ) {
+        for (range, style) in styles {
+            Self.applyStyle(
+                style: style,
+                to: string,
+                range: range,
+                baseFont: baseFont,
+                textColor: textColor
+            )
+        }
+    }
+
+    /// Applies any `.owsStyle` attributes on the string (sets attributes for font, strikethrough, etc).
+    /// Font and colors for styles are based on the provided base font and color.
+    public static func applyStyleAttributes(
+        on string: NSMutableAttributedString,
+        baseFont: UIFont,
+        textColor: UIColor
+    ) {
+        let copy = NSAttributedString(attributedString: string)
+        copy.enumerateAttributes(
+            in: string.entireRange,
+            using: { attrs, range, stop in
+                guard let style = attrs[.owsStyle] as? Style else {
+                    return
+                }
+                applyStyle(
+                    style: style,
+                    to: string,
+                    range: range,
+                    baseFont: baseFont,
+                    textColor: textColor
+                )
+            }
+        )
+    }
+
+    private static func applyStyle(
+        style: Style,
+        to string: NSMutableAttributedString,
+        range: NSRange,
+        baseFont: UIFont,
+        textColor: UIColor
+    ) {
+        var fontTraits: UIFontDescriptor.SymbolicTraits = []
+        var attributes: [NSAttributedString.Key: Any] = [
+            .owsStyle: style
+        ]
+        if style.contains(.bold) {
+            fontTraits.insert(.traitBold)
+        }
+        if style.contains(.italic) {
+            fontTraits.insert(.traitItalic)
+        }
+        if style.contains(.monospace) {
+            fontTraits.insert(.traitMonoSpace)
+        }
+        if style.contains(.strikethrough) {
+            attributes[.strikethroughStyle] = NSUnderlineStyle.single.rawValue
+            attributes[.strikethroughColor] = textColor
+        }
+        if style.contains(.spoiler) {
+            // TODO[TextFormatting]: we need different representations of spoiler.
+            attributes[.backgroundColor] = textColor
+        }
+        if !fontTraits.isEmpty {
+            attributes[.font] = baseFont.withTraits(fontTraits)
+        }
+        string.addAttributes(attributes, range: range)
+    }
+
     override public func isEqual(_ object: Any?) -> Bool {
         guard let other = object as? MessageBodyRanges else {
             return false
@@ -534,3 +681,22 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         return true
     }
 }
+
+extension UIFont {
+
+    func withTraits(_ traits: UIFontDescriptor.SymbolicTraits) -> UIFont {
+
+        // create a new font descriptor with the given traits
+        guard let fd = fontDescriptor.withSymbolicTraits(traits) else {
+            // the given traits couldn't be applied, return self
+            return self
+        }
+
+        // return a new font with the created font descriptor
+        return UIFont(descriptor: fd, size: pointSize)
+    }
+}
+
+extension NSAttributedString.Key {
+    public static let owsStyle = MessageBodyRanges.Style.attributedStringKey
+}
diff --git a/SignalServiceKit/src/Util/FeatureFlags.swift b/SignalServiceKit/src/Util/FeatureFlags.swift
index c5d77be1631..7a8ff82035d 100644
--- a/SignalServiceKit/src/Util/FeatureFlags.swift
+++ b/SignalServiceKit/src/Util/FeatureFlags.swift
@@ -104,6 +104,8 @@ public class FeatureFlags: BaseFlags {
 
     public static let canRequestAccountDataReport: Bool = build.includes(.internal)
 
+    public static let textFormattingReceiveSupport: Bool = build.includes(.internal)
+
     @objc
     public static func logFlags() {
         let logFlag = { (prefix: String, key: String, value: Any?) in
diff --git a/SignalServiceKit/tests/Messages/MessageBodyTests.swift b/SignalServiceKit/tests/Messages/MessageBodyTests.swift
index 3d03b881efe..97ec09d7b6c 100644
--- a/SignalServiceKit/tests/Messages/MessageBodyTests.swift
+++ b/SignalServiceKit/tests/Messages/MessageBodyTests.swift
@@ -770,7 +770,7 @@ final class MessageBodyTests: XCTestCase {
         let hydrated = input.hydratingMentions(
             hydrator: { uuid in
                 if let displayName = names[uuid] {
-                    return .hydrate(displayName: displayName)
+                    return .hydrate(displayName, alreadyIncludesPrefix: false)
                 } else {
                     return .preserveMention
                 }
diff --git a/SignalUI/Views/Mentions/Mention.swift b/SignalUI/Views/Mentions/Mention.swift
index 2239805814b..9a79782393f 100644
--- a/SignalUI/Views/Mentions/Mention.swift
+++ b/SignalUI/Views/Mentions/Mention.swift
@@ -102,7 +102,7 @@ public class Mention: NSObject {
 
     @objc(refreshAttributedInMutableAttributedString:)
     public class func refreshAttributes(in mutableAttributedString: NSMutableAttributedString) {
-        mutableAttributedString.enumerateMentions { mention, subrange, _ in
+        mutableAttributedString.enumerateMentionsAndStyles { mention, _, subrange, _ in
             guard let mention = mention else { return }
             mutableAttributedString.addAttributes(mention.attributes, range: subrange)
         }
@@ -110,7 +110,7 @@ public class Mention: NSObject {
 
     @objc(updateWithStyle:inMutableAttributedString:)
     public class func updateWithStyle(_ style: Style, in mutableAttributedString: NSMutableAttributedString) {
-        mutableAttributedString.enumerateMentions { mention, subrange, _ in
+        mutableAttributedString.enumerateMentionsAndStyles { mention, _, subrange, _ in
             guard let mention = mention else { return }
             let restyledMention = Mention(address: mention.address, style: style, text: mention.text)
             mutableAttributedString.addAttributes(restyledMention.attributes, range: subrange)
@@ -125,30 +125,33 @@ extension NSAttributedString.Key {
 extension MessageBody {
     public convenience init(attributedString: NSAttributedString) {
         var mentions = [NSRange: UUID]()
+        var styles = [(NSRange, MessageBodyRanges.Style)]()
 
         let filteredAttributedString = attributedString.filterForDisplay
         let mutableAttributedString = NSMutableAttributedString(attributedString: filteredAttributedString)
 
-        // TODO[TextFormatting]: parse out styles as well
-        mutableAttributedString.enumerateMentions { mention, subrange, _ in
-            guard let mention = mention else { return }
-
-            // This string may not be a full mention, for example we may
-            // have copied a string that only selects part of a mention.
-            // We only want to treat it as a mention if we have the full
-            // thing.
-            guard subrange.length == mention.length else { return }
-
-            mutableAttributedString.replaceCharacters(in: subrange, with: Self.mentionPlaceholder)
-
-            let placeholderRange = NSRange(
-                location: subrange.location,
-                length: (Self.mentionPlaceholder as NSString).length
-            )
-            mentions[placeholderRange] = mention.address.uuid
+        mutableAttributedString.enumerateMentionsAndStyles { mention, style, subrange, _ in
+            if let mention {
+                // This string may not be a full mention, for example we may
+                // have copied a string that only selects part of a mention.
+                // We only want to treat it as a mention if we have the full
+                // thing.
+                guard subrange.length == mention.length else { return }
+
+                mutableAttributedString.replaceCharacters(in: subrange, with: Self.mentionPlaceholder)
+
+                let placeholderRange = NSRange(
+                    location: subrange.location,
+                    length: (Self.mentionPlaceholder as NSString).length
+                )
+                mentions[placeholderRange] = mention.address.uuid
+            }
+            if let style {
+                styles.append((subrange, style))
+            }
         }
 
-        self.init(text: mutableAttributedString.string, ranges: .init(mentions: mentions, styles: []))
+        self.init(text: mutableAttributedString.string, ranges: .init(mentions: mentions, styles: styles))
     }
 
     public func textValue(style: Mention.Style,
@@ -187,7 +190,7 @@ extension MessageBodyRanges {
                           shouldResolveAddress: (SignalServiceAddress) -> Bool,
                           transaction: GRDBReadTransaction) -> CVTextValue {
 
-        guard hasMentions || !attributes.isEmpty else {
+        guard hasRanges || !attributes.isEmpty else {
             return .text(text: text)
         }
         let attributedText = attributedBody(text: text,
@@ -198,6 +201,9 @@ extension MessageBodyRanges {
         return .attributedText(attributedText: attributedText)
     }
 
+    /// Note: this method does _not_ apply styles; instead it just sets the `.owsStyle`
+    /// attribute for any styles, and it is up to callers to apply those styles using
+    /// `MessageBodyRanges.applyStyleAttributes` with the appropriate font and themed color.
     @objc
     public func attributedBody(
         text: String,
@@ -206,48 +212,52 @@ extension MessageBodyRanges {
         shouldResolveAddress: (SignalServiceAddress) -> Bool,
         transaction: GRDBReadTransaction
     ) -> NSAttributedString {
-        // TODO[TextFormatting]: this drives the text we display in message bubbles.
-        // update it to render styles as well.
-        guard hasMentions else { return NSAttributedString(string: text, attributes: attributes) }
-
-        let mutableText = NSMutableAttributedString(string: text, attributes: attributes)
-
-        for (range, uuid) in orderedMentions.reversed() {
-            guard range.location >= 0 && range.location + range.length <= (text as NSString).length else {
-                owsFailDebug("Ignoring invalid range in body ranges \(range)")
-                continue
-            }
+        guard hasRanges else { return NSAttributedString(string: text, attributes: attributes) }
 
-            let mention = Mention(
+        var mentions = [UUID: Mention]()
+        for (_, uuid) in orderedMentions {
+            mentions[uuid] = mentions[uuid] ?? Mention(
                 address: SignalServiceAddress(uuid: uuid),
                 style: style,
                 transaction: transaction
             )
+        }
 
-            if shouldResolveAddress(mention.address) {
-                mutableText.replaceCharacters(in: range, with: mention.attributedString)
-            } else {
-                mutableText.replaceCharacters(in: range, with: mention.text)
+        let mutableText = NSMutableAttributedString(string: text, attributes: attributes)
+        self.hydrateMentionsAndSetStyleAttributes(
+            on: mutableText,
+            hydrator: { mentionUuid in
+                guard let mention = mentions[mentionUuid] else {
+                    return .preserveMention
+                }
+                if shouldResolveAddress(mention.address) {
+                    return .hydrateAttributed(mention.attributedString, alreadyIncludesPrefix: true)
+                } else {
+                    return .hydrate(mention.text, alreadyIncludesPrefix: true)
+                }
             }
-        }
+        )
 
-        return NSAttributedString(attributedString: mutableText).filterForDisplay
+        return NSAttributedString(attributedString: mutableText)
     }
 }
 
 extension NSAttributedString {
-    public func enumerateMentions(
+    public func enumerateMentionsAndStyles(
         in range: NSRange? = nil,
-        handler: (Mention?, NSRange, UnsafeMutablePointer<ObjCBool>) -> Void
+        handler: (Mention?, MessageBodyRanges.Style?, NSRange, UnsafeMutablePointer<ObjCBool>) -> Void
     ) {
-        enumerateAttribute(
-            .mention,
+        enumerateAttributes(
             in: range ?? NSRange(location: 0, length: length),
             options: []
-        ) { handler($0 as? Mention, $1, $2) }
+        ) { attributes, range, stop in
+            let mention = attributes[.mention] as? Mention
+            let style = attributes[.owsStyle] as? MessageBodyRanges.Style
+            handler(mention, style, range, stop)
+        }
     }
 
-    // This is private because it's *only* safe to use on mention attributed strings.
+    // This is private because it's *only* safe to use on mention/style attributed strings.
     fileprivate var filterForDisplay: NSAttributedString {
         guard length > 0 else { return self }
 
@@ -255,14 +265,10 @@ extension NSAttributedString {
 
         let mutableString = NSMutableAttributedString(attributedString: self)
 
-        // Filter each non-mention substring
+        // Filter each non-mention, non-style substring
 
-        // TODO: If we ever start supporting other styling than mentions,
-        // this method of filtering will fall down. For now, we can safely
-        // filter all the text before/after/between mentions and treat it
-        // as having the same set of attributes.
-        mutableString.enumerateMentions { mention, subrange, _ in
-            guard mention == nil else { return }
+        mutableString.enumerateMentionsAndStyles { mention, style, subrange, _ in
+            guard mention == nil && style == nil else { return }
 
             let string = mutableString.attributedSubstring(from: subrange).string
             let attributes = mutableString.attributes(at: subrange.location, effectiveRange: nil)
diff --git a/SignalUI/Views/Mentions/MentionTextView.swift b/SignalUI/Views/Mentions/MentionTextView.swift
index 0a1adca7483..ba1bec553c9 100644
--- a/SignalUI/Views/Mentions/MentionTextView.swift
+++ b/SignalUI/Views/Mentions/MentionTextView.swift
@@ -316,7 +316,8 @@ open class MentionTextView: OWSTextView {
 
         if range.length > 0 {
             // Locate any mentions in the edited range.
-            textStorage.enumerateMentions(in: range) { mention, subrange, _ in
+            // TODO[TextFormatting]: update styles as needed
+            textStorage.enumerateMentionsAndStyles(in: range) { mention, _, subrange, _ in
                 guard let mention = mention else { return }
 
                 // Get the full range of the mention, we may only be editing a part of it.
