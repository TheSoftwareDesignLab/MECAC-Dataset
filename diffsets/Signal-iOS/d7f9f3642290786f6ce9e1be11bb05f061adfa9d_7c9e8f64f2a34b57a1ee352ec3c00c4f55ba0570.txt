diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index db670dc0b1d..196948bee3d 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -727,7 +727,7 @@
 		4C9D349B2369F11F006A4307 /* notificationPermission1.png in Resources */ = {isa = PBXBuildFile; fileRef = 4C9D34982369F11E006A4307 /* notificationPermission1.png */; };
 		4C9D349C2369F11F006A4307 /* notificationPermission0.png in Resources */ = {isa = PBXBuildFile; fileRef = 4C9D34992369F11E006A4307 /* notificationPermission0.png */; };
 		4C9D349D2369F11F006A4307 /* notificationPermission2.png in Resources */ = {isa = PBXBuildFile; fileRef = 4C9D349A2369F11F006A4307 /* notificationPermission2.png */; };
-		4CA46F4C219CCC630038ABDE /* CaptionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4CA46F4B219CCC630038ABDE /* CaptionView.swift */; };
+		4CA46F4C219CCC630038ABDE /* MediaCaptionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4CA46F4B219CCC630038ABDE /* MediaCaptionView.swift */; };
 		4CA485BB2232339F004B9E7D /* PhotoCaptureViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4CA485BA2232339F004B9E7D /* PhotoCaptureViewController.swift */; };
 		4CB5F26720F6E1E2004D1B42 /* MessageActionsToolbar.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4CFF4C0920F55BBA005DA313 /* MessageActionsToolbar.swift */; };
 		4CB5F26920F7D060004D1B42 /* MessageActions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4CB5F26820F7D060004D1B42 /* MessageActions.swift */; };
@@ -3167,7 +3167,7 @@
 		4C9D34982369F11E006A4307 /* notificationPermission1.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = notificationPermission1.png; sourceTree = "<group>"; };
 		4C9D34992369F11E006A4307 /* notificationPermission0.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = notificationPermission0.png; sourceTree = "<group>"; };
 		4C9D349A2369F11F006A4307 /* notificationPermission2.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = notificationPermission2.png; sourceTree = "<group>"; };
-		4CA46F4B219CCC630038ABDE /* CaptionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CaptionView.swift; sourceTree = "<group>"; };
+		4CA46F4B219CCC630038ABDE /* MediaCaptionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaCaptionView.swift; sourceTree = "<group>"; };
 		4CA485BA2232339F004B9E7D /* PhotoCaptureViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PhotoCaptureViewController.swift; sourceTree = "<group>"; };
 		4CB5F26820F7D060004D1B42 /* MessageActions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageActions.swift; sourceTree = "<group>"; };
 		4CB93DC12180FF07004B9764 /* ProximityMonitoringManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ProximityMonitoringManager.swift; sourceTree = "<group>"; };
@@ -6313,6 +6313,7 @@
 				4CD675BF22E7BE47008010D2 /* Transitions */,
 				45D49114296F69AA00B92BB1 /* AllMediaViewController.swift */,
 				45C845AC291466C0005F6EA5 /* JournalingOrderedDictionary.swift */,
+				4CA46F4B219CCC630038ABDE /* MediaCaptionView.swift */,
 				452EC6DE205E9E30000E787C /* MediaGallery.swift */,
 				45DDD06629C1365100FD9670 /* MediaGalleryAccessoriesHelper.swift */,
 				4585B4A2291B2BFB003A8F8E /* MediaGalleryCollectionViewUpdater.swift */,
@@ -6728,7 +6729,6 @@
 				32E958A925C12B3800BF12AD /* AnimatedProgressView.swift */,
 				4C2F454E214C00E1004871FF /* AvatarTableViewCell.swift */,
 				14E4A33F278EE999008408FD /* BlurredToolbarContainer.swift */,
-				4CA46F4B219CCC630038ABDE /* CaptionView.swift */,
 				32A9E22524C11B3F00C43518 /* EmojiMoodPickerView.swift */,
 				88905E9D229CCA96004E4234 /* ExpirationNagView.swift */,
 				329D42A125AD65C400DCB449 /* GetStartedBannerCell.swift */,
@@ -10992,7 +10992,6 @@
 				88D23D2623CEC0C700B0E74B /* CallUIAdapter.swift in Sources */,
 				4C21D5D8223AC60F00EF8A77 /* CameraCaptureSession.swift in Sources */,
 				4C46361122EB98EC00185951 /* CameraFirstCaptureSendFlow.swift in Sources */,
-				4CA46F4C219CCC630038ABDE /* CaptionView.swift in Sources */,
 				34546F502649989D007C4958 /* ChatColorViewController.swift in Sources */,
 				346E09012662FBBE0042375E /* ChatListCell.swift in Sources */,
 				34E95C27269F6096004807EC /* ChatListViewController+Actions.swift in Sources */,
@@ -11311,6 +11310,7 @@
 				34B0796D1FCF46B100E248C2 /* MainAppContext.m in Sources */,
 				349767E325B8744700ECE1B0 /* ManageStickersViewController.swift in Sources */,
 				45E5A6991F61E6DE001E4A8A /* MarqueeLabel.swift in Sources */,
+				4CA46F4C219CCC630038ABDE /* MediaCaptionView.swift in Sources */,
 				76FCCDBC27AB8FBE00BAA7F0 /* MediaControls.swift in Sources */,
 				4CD675BE22E7BE35008010D2 /* MediaDismissAnimationController.swift in Sources */,
 				346C19E125ACE9AE00061D3A /* MediaDownloadSettingsViewController.swift in Sources */,
diff --git a/Signal/src/ViewControllers/MediaGallery/MediaCaptionView.swift b/Signal/src/ViewControllers/MediaGallery/MediaCaptionView.swift
new file mode 100644
index 00000000000..efc83703834
--- /dev/null
+++ b/Signal/src/ViewControllers/MediaGallery/MediaCaptionView.swift
@@ -0,0 +1,275 @@
+//
+// Copyright 2018 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import SignalUI
+
+class MediaCaptionView: UIView {
+
+    var text: String? {
+        get { captionTextView.text }
+        set { captionTextView.text = newValue }
+    }
+
+    var canBeExpanded: Bool {
+        captionTextView.canBeExpanded
+    }
+
+    var isExpanded: Bool {
+        get { captionTextView.isExpanded }
+        set { captionTextView.isExpanded = newValue }
+    }
+
+    // MARK: Interactive Transition
+
+    private(set) var isTransitionInProgress: Bool = false
+
+    func beginInteractiveTransition(text: String?) {
+        // Do not start the transition if next item's caption is the same as current one's.
+        guard self.text != text else {
+            owsAssertDebug(!isTransitionInProgress)
+            isTransitionInProgress = false
+            return
+        }
+
+        isTransitionInProgress = true
+        heightConstraint.isActive = true
+        pendingCaptionTextView.text = text
+        updateTransitionProgress(0)
+    }
+
+    func updateTransitionProgress(_ progress: CGFloat) {
+        // Do nothing until transition has been started explicitly.
+        // This tweak fixes minor UI imperfections when quickly scrolling between items.
+        guard isTransitionInProgress else { return }
+
+        captionTextView.alpha = 1 - progress
+        pendingCaptionTextView.alpha = progress
+
+        // This constraint defines height of `MediaCaptionView` during
+        // an interactive transition from one caption to another.
+        // The constraint has a `required` priority and will
+        // override constraint on the bottom edge of the `currentCaptionView`,
+        // making "current" text slide up or down while being attached to
+        // the top edge of `MediaCaptionView`.
+        let currentViewHeight = captionTextView.intrinsicContentSize.height
+        let pendingViewHeight = pendingCaptionTextView.intrinsicContentSize.height
+        heightConstraint.constant = CGFloatLerp(currentViewHeight, pendingViewHeight, progress)
+    }
+
+    func finishInteractiveTransition(_ isTransitionComplete: Bool) {
+        guard isTransitionInProgress else { return }
+
+        captionTextView.alpha = 1
+        if isTransitionComplete {
+            captionTextView.isExpanded = false
+            captionTextView.text = pendingCaptionTextView.text
+        }
+
+        pendingCaptionTextView.alpha = 0
+        pendingCaptionTextView.text = nil
+
+        heightConstraint.isActive = false
+
+        isTransitionInProgress = false
+    }
+
+    private lazy var heightConstraint = heightAnchor.constraint(equalToConstant: 0)
+
+    // MARK: Initializers
+
+    override init(frame: CGRect) {
+        super.init(frame: frame)
+
+        preservesSuperviewLayoutMargins = true
+        clipsToBounds = true
+
+        addSubview(captionTextView)
+        captionTextView.autoPinWidthToSuperviewMargins()
+        captionTextView.autoPinEdge(toSuperviewEdge: .top)
+        // This constraint is designed to be overriden by `heightConstraint`
+        // during interactive transition between captions.
+        // At the same time it must have a priority high enough
+        // so that `currentCaptionView` defines height of the `MediaCaptionView`.
+        NSLayoutConstraint.autoSetPriority(.defaultHigh) {
+            captionTextView.autoPinEdge(toSuperviewEdge: .bottom)
+        }
+
+        pendingCaptionTextView.alpha = 0
+        addSubview(pendingCaptionTextView)
+        pendingCaptionTextView.autoPinWidthToSuperviewMargins()
+        pendingCaptionTextView.autoPinEdge(toSuperviewEdge: .top)
+        // `pendingCaptionView` does not have constraint for the bottom edge
+        // because we want the "pending" text to have its final height
+        // while we slide it up during interactive transition between captions.
+    }
+
+    required init?(coder aDecoder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    // MARK: Subviews
+
+    private class func buildCaptionTextView() -> CaptionTextView {
+        let textView = CaptionTextView()
+        textView.font = UIFont.ows_dynamicTypeBodyClamped
+        textView.textColor = .white
+        textView.backgroundColor = .clear
+        textView.textContainerInset = .zero
+        return textView
+    }
+    private var captionTextView = MediaCaptionView.buildCaptionTextView()
+    private var pendingCaptionTextView = MediaCaptionView.buildCaptionTextView()
+
+    private class CaptionTextView: UITextView {
+
+        override init(frame: CGRect, textContainer: NSTextContainer?) {
+            super.init(frame: frame, textContainer: textContainer)
+
+            isEditable = false
+            isSelectable = false
+            self.textContainer.lineBreakMode = .byTruncatingTail
+            updateIsScrollEnabled()
+        }
+
+        required init?(coder: NSCoder) {
+            fatalError("init(coder:) has not been implemented")
+        }
+
+        override var text: String! {
+            didSet {
+                invalidateCachedSizes()
+            }
+        }
+
+        override var font: UIFont? {
+            didSet {
+                invalidateCachedSizes()
+            }
+        }
+
+        override var bounds: CGRect {
+            didSet {
+                if oldValue.width != bounds.width {
+                    invalidateCachedSizes()
+                }
+            }
+        }
+
+        override var frame: CGRect {
+            didSet {
+                if oldValue.width != bounds.width {
+                    invalidateCachedSizes()
+                }
+            }
+        }
+
+        // MARK: -
+
+        var canBeExpanded: Bool {
+            collapsedSize.height != expandedSize.height
+        }
+
+        private var _isExpanded: Bool = false
+        var isExpanded: Bool {
+            get {
+                guard canBeExpanded else { return false }
+                return _isExpanded
+            }
+            set {
+                guard _isExpanded != newValue else { return }
+                _isExpanded = canBeExpanded ? newValue : false
+                invalidateIntrinsicContentSize()
+                updateIsScrollEnabled()
+            }
+        }
+
+        private func updateIsScrollEnabled() {
+            isScrollEnabled = isExpanded
+        }
+
+        // MARK: Layout metrics
+
+        private static let maxHeight: CGFloat = ScaleFromIPhone5(200)
+        private static let collapsedNumberOfLines = 3
+
+        private var collapsedSize: CGSize = .zero // 3 lines of text
+        private var expandedSize: CGSize = .zero  // height is limited to `maxHeight`
+        private var fullSize: CGSize = .zero
+
+        override var intrinsicContentSize: CGSize {
+            guard !text.isEmptyOrNil else {
+                return CGSize(width: UIView.noIntrinsicMetric, height: 0)
+            }
+
+            calculateSizesIfNecessary()
+
+            let textSize = isExpanded ? expandedSize : collapsedSize
+            return CGSize(
+                width: textContainerInset.left + textSize.width + textContainerInset.right,
+                height: textContainerInset.top + textSize.height + textContainerInset.bottom
+            )
+        }
+
+        private func invalidateCachedSizes() {
+            collapsedSize = .zero
+            expandedSize = .zero
+            fullSize = .zero
+
+            invalidateIntrinsicContentSize()
+        }
+
+        private func calculateSizesIfNecessary() {
+            guard !collapsedSize.isNonEmpty else { return }
+            guard !text.isEmptyOrNil else { return }
+
+            let maxWidth: CGFloat
+            if frame.width > 0 {
+                maxWidth = frame.width - textContainerInset.left - textContainerInset.right
+            } else {
+                maxWidth = .greatestFiniteMagnitude
+            }
+
+            // 3 lines of text.
+            let collapsedTextConfig = CVTextLabel.Config(
+                attributedString: attributedText,
+                font: font ?? .ows_dynamicTypeBodyClamped,
+                textColor: textColor ?? .white,
+                selectionStyling: [:],
+                textAlignment: textAlignment,
+                lineBreakMode: .byWordWrapping,
+                numberOfLines: Self.collapsedNumberOfLines,
+                items: []
+            )
+            collapsedSize = CVTextLabel.measureSize(config: collapsedTextConfig, maxWidth: maxWidth).size
+
+            // 9 lines of text or `maxHeight`, whichever is smaller.
+            let expandedTextConfig = CVTextLabel.Config(
+                attributedString: attributedText,
+                font: font ?? .ows_dynamicTypeBodyClamped,
+                textColor: textColor ?? .white,
+                selectionStyling: [:],
+                textAlignment: textAlignment,
+                lineBreakMode: .byWordWrapping,
+                numberOfLines: 3 * Self.collapsedNumberOfLines,
+                items: []
+            )
+            let expandedTextSize = CVTextLabel.measureSize(config: expandedTextConfig, maxWidth: maxWidth).size
+            expandedSize = CGSize(width: expandedTextSize.width, height: min(expandedTextSize.height, Self.maxHeight))
+
+            // Unrestricted text height is necessary so that we could enable scrolling in the text view.
+            let fullTextConfig = CVTextLabel.Config(
+                attributedString: attributedText,
+                font: font ?? .ows_dynamicTypeBodyClamped,
+                textColor: textColor ?? .white,
+                selectionStyling: [:],
+                textAlignment: textAlignment,
+                lineBreakMode: .byWordWrapping,
+                numberOfLines: 0,
+                items: []
+            )
+            fullSize = CVTextLabel.measureSize(config: fullTextConfig, maxWidth: maxWidth).size
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift b/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift
index b3134ec9b56..a7043501fbf 100644
--- a/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift
+++ b/Signal/src/ViewControllers/MediaGallery/MediaPageViewController.swift
@@ -80,11 +80,7 @@ class MediaPageViewController: UIPageViewController {
     private var footerBarHeight: CGFloat { topBarHeight }
     private var footerBarHeightConstraint: NSLayoutConstraint?
 
-    private lazy var captionContainerView: CaptionContainerView = {
-        let view = CaptionContainerView()
-        view.delegate = self
-        return view
-    }()
+    private lazy var captionView = MediaCaptionView()
     private lazy var galleryRailView: GalleryRailView = {
         let view = GalleryRailView()
         view.delegate = self
@@ -189,7 +185,7 @@ class MediaPageViewController: UIPageViewController {
         footerBar.tintColor = Theme.darkThemePrimaryColor
         footerBarHeightConstraint = footerBar.autoSetDimension(.height, toSize: footerBarHeight)
 
-        let bottomStack = UIStackView(arrangedSubviews: [captionContainerView, galleryRailView, footerBar])
+        let bottomStack = UIStackView(arrangedSubviews: [captionView, galleryRailView, footerBar])
         bottomStack.axis = .vertical
         bottomStack.preservesSuperviewLayoutMargins = true
         bottomPanel.addSubview(bottomStack)
@@ -197,9 +193,8 @@ class MediaPageViewController: UIPageViewController {
         bottomStack.autoPinEdge(toSuperviewEdge: .top, withInset: 16)
         bottomStack.autoPin(toBottomLayoutGuideOf: self, withInset: 0)
 
-        updateCaption(item: currentItem)
-        updateCaptionContainerVisibility()
         updateTitle()
+        updateCaption(item: currentItem)
         updateMediaRail(animated: false)
         updateContextMenuActions()
         updateBottomPanelControls(isPlayingVideo: true)
@@ -208,6 +203,8 @@ class MediaPageViewController: UIPageViewController {
         let verticalSwipe = UISwipeGestureRecognizer(target: self, action: #selector(didSwipeView))
         verticalSwipe.direction = [.up, .down]
         view.addGestureRecognizer(verticalSwipe)
+
+        captionView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(toggleCaptionBoxIsExpanded)))
     }
 
     override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
@@ -290,12 +287,12 @@ class MediaPageViewController: UIPageViewController {
             return
         }
 
-        let width = pagerScrollView.frame.size.width
-        guard width > 0 else {
-            return
-        }
+        guard pagerScrollView.isTracking || pagerScrollView.isDecelerating else { return }
+
+        let width = pagerScrollView.frame.width
+        guard width > 0 else { return }
         let ratioComplete = abs((newValue.x - width) / width)
-        captionContainerView.updatePagerTransition(ratioComplete: ratioComplete)
+        captionView.updateTransitionProgress(ratioComplete)
     }
 
     // MARK: View Helpers
@@ -727,10 +724,6 @@ class MediaPageViewController: UIPageViewController {
         updateTitle(item: currentItem)
     }
 
-    private func updateCaption(item: MediaGalleryItem) {
-        captionContainerView.currentText = item.captionForDisplay
-    }
-
     private func updateTitle(item: MediaGalleryItem) {
         let name = senderName(message: item.message)
         headerNameLabel.text = name
@@ -739,10 +732,31 @@ class MediaPageViewController: UIPageViewController {
         let date = Date(timeIntervalSince1970: Double(item.message.timestamp) / 1000)
         headerDateLabel.text = dateFormatter.string(from: date)
     }
+
+    // MARK: Caption Box
+
+    private func updateCaption(item: MediaGalleryItem) {
+        captionView.text = item.captionForDisplay
+    }
+
+    @objc
+    private func toggleCaptionBoxIsExpanded(_ gestureRecognizer: UITapGestureRecognizer) {
+        guard !captionView.isTransitionInProgress, captionView.canBeExpanded else { return }
+
+        let animator = UIViewPropertyAnimator(duration: 0.25, springDamping: 0.645, springResponse: 0.25)
+        animator.addAnimations {
+            self.captionView.isExpanded = !self.captionView.isExpanded
+            self.view.layoutIfNeeded()
+        }
+        animator.startAnimation()
+    }
 }
 
 extension MediaPageViewController: UIPageViewControllerDelegate {
-    func pageViewController(_ pageViewController: UIPageViewController, willTransitionTo pendingViewControllers: [UIViewController]) {
+    func pageViewController(
+        _ pageViewController: UIPageViewController,
+        willTransitionTo pendingViewControllers: [UIViewController]
+    ) {
         Logger.debug("")
 
         owsAssert(pendingViewControllers.count == 1)
@@ -751,7 +765,7 @@ extension MediaPageViewController: UIPageViewControllerDelegate {
             return
         }
 
-        captionContainerView.pendingText = pendingViewController.galleryItem.captionForDisplay?.nilIfEmpty
+        captionView.beginInteractiveTransition(text: pendingViewController.galleryItem.captionForDisplay?.nilIfEmpty)
 
         // Ensure upcoming page respects current toolbar status
         pendingViewController.setShouldHideToolbars(shouldHideToolbars)
@@ -771,22 +785,15 @@ extension MediaPageViewController: UIPageViewControllerDelegate {
             return
         }
 
-        // Do any cleanup for the no-longer visible view controller
-        if transitionCompleted {
-            // This can happen when trying to page past the last (or first) view controller
-            // In that case, we don't want to change the captionView.
-            if previousPage != currentViewController {
-                captionContainerView.completePagerTransition()
-            }
+        captionView.finishInteractiveTransition(transitionCompleted)
 
+        if transitionCompleted {
             updateTitle()
             updateMediaRail(animated: true)
             previousPage.zoomOut(animated: false)
             previousPage.stopVideoIfPlaying()
             updateContextMenuActions()
             updateBottomPanelControls(isPlayingVideo: false)
-        } else {
-            captionContainerView.pendingText = nil
         }
     }
 }
@@ -959,26 +966,6 @@ extension MediaPageViewController: GalleryRailViewDelegate {
     }
 }
 
-extension MediaPageViewController: CaptionContainerViewDelegate {
-    func captionContainerViewDidUpdateText(_ captionContainerView: CaptionContainerView) {
-        updateCaptionContainerVisibility()
-    }
-
-    fileprivate func updateCaptionContainerVisibility() {
-        if let currentText = captionContainerView.currentText, !currentText.isEmpty {
-            captionContainerView.isHidden = false
-            return
-        }
-
-        if let pendingText = captionContainerView.pendingText, !pendingText.isEmpty {
-            captionContainerView.isHidden = false
-            return
-        }
-
-        captionContainerView.isHidden = true
-    }
-}
-
 extension MediaPageViewController: MediaPresentationContextProvider {
     func mediaPresentationContext(item: Media, in coordinateSpace: UICoordinateSpace) -> MediaPresentationContext? {
         guard let mediaView = currentViewController?.mediaView else { return nil }
diff --git a/Signal/src/views/CaptionView.swift b/Signal/src/views/CaptionView.swift
deleted file mode 100644
index 8a6ab44ddd3..00000000000
--- a/Signal/src/views/CaptionView.swift
+++ /dev/null
@@ -1,177 +0,0 @@
-//
-// Copyright 2018 Signal Messenger, LLC
-// SPDX-License-Identifier: AGPL-3.0-only
-//
-
-public protocol CaptionContainerViewDelegate: AnyObject {
-    func captionContainerViewDidUpdateText(_ captionContainerView: CaptionContainerView)
-}
-
-public class CaptionContainerView: UIView {
-
-    weak var delegate: CaptionContainerViewDelegate?
-
-    var currentText: String? {
-        get { return currentCaptionView.text }
-        set {
-            currentCaptionView.text = newValue
-            delegate?.captionContainerViewDidUpdateText(self)
-        }
-    }
-
-    var pendingText: String? {
-        get { return pendingCaptionView.text }
-        set {
-            pendingCaptionView.text = newValue
-            delegate?.captionContainerViewDidUpdateText(self)
-        }
-    }
-
-    func updatePagerTransition(ratioComplete: CGFloat) {
-        if let currentText = self.currentText, !currentText.isEmpty {
-            currentCaptionView.alpha = 1 - ratioComplete
-        } else {
-            currentCaptionView.alpha = 0
-        }
-
-        if let pendingText = self.pendingText, !pendingText.isEmpty {
-            pendingCaptionView.alpha = ratioComplete
-        } else {
-            pendingCaptionView.alpha = 0
-        }
-    }
-
-    func completePagerTransition() {
-        updatePagerTransition(ratioComplete: 1)
-
-        // promote "pending" to "current" caption view.
-        let oldCaptionView = self.currentCaptionView
-        self.currentCaptionView = self.pendingCaptionView
-        self.pendingCaptionView = oldCaptionView
-        self.pendingText = nil
-    }
-
-    // MARK: Initializers
-
-    override init(frame: CGRect) {
-        super.init(frame: frame)
-
-        setContentHuggingHigh()
-        setCompressionResistanceHigh()
-
-        addSubview(currentCaptionView)
-        currentCaptionView.autoPinEdgesToSuperviewEdges(with: .zero, excludingEdge: .top)
-        currentCaptionView.autoPinEdge(toSuperviewEdge: .top, withInset: 0, relation: .greaterThanOrEqual)
-
-        pendingCaptionView.alpha = 0
-        addSubview(pendingCaptionView)
-        pendingCaptionView.autoPinEdgesToSuperviewEdges(with: .zero, excludingEdge: .top)
-        pendingCaptionView.autoPinEdge(toSuperviewEdge: .top, withInset: 0, relation: .greaterThanOrEqual)
-    }
-
-    public required init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
-
-    // MARK: Subviews
-
-    private var pendingCaptionView: CaptionView = CaptionView()
-    private var currentCaptionView: CaptionView = CaptionView()
-}
-
-private class CaptionView: UIView {
-
-    var text: String? {
-        get { return textView.text }
-
-        set {
-            if let captionText = newValue, !captionText.isEmpty {
-                textView.text = captionText
-            } else {
-                textView.text = nil
-            }
-        }
-    }
-
-    // MARK: Subviews
-
-    let textView: CaptionTextView = {
-        let textView = CaptionTextView()
-
-        textView.font = UIFont.ows_dynamicTypeBody
-        textView.textColor = .white
-        textView.backgroundColor = .clear
-        textView.isEditable = false
-        textView.isSelectable = false
-
-        return textView
-    }()
-
-    let scrollFadeView = GradientView(from: .clear, to: .black)
-
-    // MARK: Initializers
-
-    override init(frame: CGRect) {
-        super.init(frame: frame)
-
-        addSubview(textView)
-        textView.autoPinEdgesToSuperviewMargins()
-
-        addSubview(scrollFadeView)
-        scrollFadeView.autoPinEdgesToSuperviewEdges(with: .zero, excludingEdge: .top)
-        scrollFadeView.autoSetDimension(.height, toSize: 20)
-    }
-
-    required init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
-
-    // MARK: UIView overrides
-
-    override func layoutSubviews() {
-        super.layoutSubviews()
-        scrollFadeView.isHidden = !textView.doesContentNeedScroll
-    }
-
-    // MARK: -
-
-    class CaptionTextView: UITextView {
-
-        var kMaxHeight: CGFloat = ScaleFromIPhone5(200)
-
-        override var text: String! {
-            didSet {
-                invalidateIntrinsicContentSize()
-            }
-        }
-
-        override var font: UIFont? {
-            didSet {
-                invalidateIntrinsicContentSize()
-            }
-        }
-
-        var doesContentNeedScroll: Bool {
-            return self.bounds.height == kMaxHeight
-        }
-
-        override func layoutSubviews() {
-            super.layoutSubviews()
-
-            // Enable/disable scrolling depending on whether we've clipped
-            // content in `intrinsicContentSize`
-            isScrollEnabled = doesContentNeedScroll
-        }
-
-        override var intrinsicContentSize: CGSize {
-            var size = super.intrinsicContentSize
-
-            if size.height == UIView.noIntrinsicMetric {
-                size.height = layoutManager.usedRect(for: textContainer).height + textContainerInset.top + textContainerInset.bottom
-            }
-            size.height = min(kMaxHeight, size.height)
-
-            return size
-        }
-    }
-}
