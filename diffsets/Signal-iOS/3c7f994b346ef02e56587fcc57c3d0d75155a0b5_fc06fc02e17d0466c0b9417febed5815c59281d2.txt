diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index a6774e3589e..aa99c54da3a 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -386,7 +386,6 @@
 		4521C3C01F59F3BA00B4C582 /* TextFieldHelper.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4521C3BF1F59F3BA00B4C582 /* TextFieldHelper.swift */; };
 		452B999020A34B6B006F2F9E /* AddContactShareToExistingContactViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 452B998F20A34B6B006F2F9E /* AddContactShareToExistingContactViewController.swift */; };
 		452C468F1E427E200087B011 /* OutboundCallInitiator.swift in Sources */ = {isa = PBXBuildFile; fileRef = 452C468E1E427E200087B011 /* OutboundCallInitiator.swift */; };
-		452C7CA72037628B003D51A5 /* Weak.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45F170D51E315310003FC1F2 /* Weak.swift */; };
 		452D1AF12081059C00A67F7F /* StringAdditionsTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 452D1AF02081059C00A67F7F /* StringAdditionsTest.swift */; };
 		452EC6DF205E9E30000E787C /* MediaGalleryViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 452EC6DE205E9E30000E787C /* MediaGalleryViewController.swift */; };
 		452ECA4D1E087E7200E2F016 /* MessageFetcherJob.swift in Sources */ = {isa = PBXBuildFile; fileRef = 452ECA4C1E087E7200E2F016 /* MessageFetcherJob.swift */; };
@@ -1246,7 +1245,6 @@
 		45E7A6A61E71CA7E00D44FB5 /* DisplayableTextFilterTest.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = DisplayableTextFilterTest.swift; sourceTree = "<group>"; };
 		45F170AB1E2F0351003FC1F2 /* OWSAudioSession.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = OWSAudioSession.swift; sourceTree = "<group>"; };
 		45F170BA1E2FC5D3003FC1F2 /* CallAudioService.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CallAudioService.swift; sourceTree = "<group>"; };
-		45F170D51E315310003FC1F2 /* Weak.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Weak.swift; sourceTree = "<group>"; };
 		45F32C1D205718B000A300D5 /* MediaPageViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = MediaPageViewController.swift; path = Signal/src/ViewControllers/MediaPageViewController.swift; sourceTree = SOURCE_ROOT; };
 		45F59A092029140500E8D2B0 /* OWSVideoPlayer.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSVideoPlayer.swift; sourceTree = "<group>"; };
 		45F659721E1BD99C00444429 /* CallKitCallUIAdaptee.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = CallKitCallUIAdaptee.swift; sourceTree = "<group>"; };
@@ -1708,7 +1706,6 @@
 				4C858A51212DC5E1001B45D3 /* UIImage+OWS.swift */,
 				B97940251832BD2400BD66CB /* UIUtil.h */,
 				B97940261832BD2400BD66CB /* UIUtil.m */,
-				45F170D51E315310003FC1F2 /* Weak.swift */,
 			);
 			path = utils;
 			sourceTree = "<group>";
@@ -3533,7 +3530,6 @@
 				4C9B4F23225025F100DD5B9A /* OWS115GRDBMigration.swift in Sources */,
 				340872CA2239563500CB25B0 /* AttachmentApprovalViewController.swift in Sources */,
 				346129AD1FD1F34E00532771 /* ImageCache.swift in Sources */,
-				452C7CA72037628B003D51A5 /* Weak.swift in Sources */,
 				34D5872F208E2C4200D2255A /* OWS109OutgoingMessageState.m in Sources */,
 				340872D02239787F00CB25B0 /* AttachmentTextToolbar.swift in Sources */,
 				3416BCAE2277A24000E761B4 /* StickerPackDataSource.swift in Sources */,
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift b/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift
index 146aa96698c..497b60d418c 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationMessageMapping.swift
@@ -234,7 +234,7 @@ public class ConversationMessageMapping: NSObject {
     // Updates and then calculates which items were inserted, removed or modified.
     @objc
     public func updateAndCalculateDiff(transaction: SDSAnyReadTransaction,
-                                       notifications: [NSNotification]) throws -> ConversationMessageMappingDiff {
+                                       updatedInteractionIds: Set<String>) throws -> ConversationMessageMappingDiff {
         let oldItemIds = Set(self.itemIds)
         try self.update(transaction: transaction)
         let newItemIds = Set(self.itemIds)
@@ -242,21 +242,21 @@ public class ConversationMessageMapping: NSObject {
         let removedItemIds = oldItemIds.subtracting(newItemIds)
         let addedItemIds = newItemIds.subtracting(oldItemIds)
         // We only notify for updated items that a) were previously loaded b) weren't also inserted or removed.
-        let updatedItemIds = (self.updatedItemIds(for: notifications)
-            .subtracting(addedItemIds)
+        let exclusivelyUpdatedInteractionIds = updatedInteractionIds.subtracting(addedItemIds)
             .subtracting(removedItemIds)
-            .intersection(oldItemIds))
+            .intersection(oldItemIds)
 
         return ConversationMessageMappingDiff(addedItemIds: addedItemIds,
                                               removedItemIds: removedItemIds,
-                                              updatedItemIds: updatedItemIds)
+                                              updatedItemIds: exclusivelyUpdatedInteractionIds)
     }
 
     // For performance reasons, the database modification notifications are used
     // to determine which items were modified.  If YapDatabase ever changes the
     // structure or semantics of these notifications, we'll need to update this
     // code to reflect that.
-    private func updatedItemIds(for notifications: [NSNotification]) -> Set<String> {
+    @objc
+    public func updatedItemIds(for notifications: [NSNotification]) -> Set<String> {
         // We'll move this into the Yap adapter when addressing updates/observation
         let viewName: String = TSMessageDatabaseViewExtensionName
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewModel.m b/Signal/src/ViewControllers/ConversationView/ConversationViewModel.m
index 622dc654c1d..065558ac0c3 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewModel.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewModel.m
@@ -174,7 +174,7 @@ + (ConversationUpdate *)diffUpdateWithUpdateItems:(nullable NSArray<Conversation
 
 #pragma mark -
 
-@interface ConversationViewModel ()
+@interface ConversationViewModel () <ConversationViewDatabaseSnapshotDelegate>
 
 @property (nonatomic, weak) id<ConversationViewModelDelegate> delegate;
 
@@ -368,18 +368,22 @@ - (void)configure
         }
     }];
 
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(uiDatabaseDidUpdateExternally:)
-                                                 name:OWSUIDatabaseConnectionDidUpdateExternallyNotification
-                                               object:self.primaryStorage.dbNotificationObject];
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(uiDatabaseWillUpdate:)
-                                                 name:OWSUIDatabaseConnectionWillUpdateNotification
-                                               object:self.primaryStorage.dbNotificationObject];
-    [[NSNotificationCenter defaultCenter] addObserver:self
-                                             selector:@selector(uiDatabaseDidUpdate:)
-                                                 name:OWSUIDatabaseConnectionDidUpdateNotification
-                                               object:self.primaryStorage.dbNotificationObject];
+    if (SSKFeatureFlags.useGRDB) {
+        [self.dbStorage.grdbStorage.conversationViewDatabaseObserver appendSnapshotDelegate:self];
+    } else {
+        [[NSNotificationCenter defaultCenter] addObserver:self
+                                                 selector:@selector(uiDatabaseDidUpdateExternally:)
+                                                     name:OWSUIDatabaseConnectionDidUpdateExternallyNotification
+                                                   object:self.primaryStorage.dbNotificationObject];
+        [[NSNotificationCenter defaultCenter] addObserver:self
+                                                 selector:@selector(uiDatabaseWillUpdate:)
+                                                     name:OWSUIDatabaseConnectionWillUpdateNotification
+                                                   object:self.primaryStorage.dbNotificationObject];
+        [[NSNotificationCenter defaultCenter] addObserver:self
+                                                 selector:@selector(uiDatabaseDidUpdate:)
+                                                     name:OWSUIDatabaseConnectionDidUpdateNotification
+                                                   object:self.primaryStorage.dbNotificationObject];
+    }
     [[NSNotificationCenter defaultCenter] addObserver:self
                                              selector:@selector(applicationWillEnterForeground:)
                                                  name:OWSApplicationWillEnterForegroundNotification
@@ -583,21 +587,51 @@ - (void)clearUnreadMessagesIndicator
     }
 }
 
-#pragma mark - Storage access
+#pragma mark - GRDB Updates
 
-- (void)uiDatabaseDidUpdateExternally:(NSNotification *)notification
+- (void)conversationViewDatabaseSnapshotWillUpdate
 {
-    OWSAssertIsOnMainThread();
+    [self anyDBWillUpdate];
+}
 
-    OWSLogVerbose(@"");
+- (void)conversationViewDatabaseSnapshotDidUpdateWithTransactionChanges:
+    (ConversationViewDatabaseTransactionChanges *)transactionChanges
+{
+    __block NSError *dbError;
+    __block NSError *updateError;
+    __block NSSet<NSString *> *updatedInteractionIds;
+    [self.dbStorage.grdbStorage uiReadAndReturnError:&dbError
+                                               block:^(GRDBReadTransaction *transaction) {
+                                                   updatedInteractionIds = [transactionChanges
+                                                       updatedInteractionIdsForThreadId:self.thread.uniqueId
+                                                                            transaction:transaction
+                                                                                  error:&updateError];
+                                               }];
+
+    if (dbError || updateError || !updatedInteractionIds) {
+        OWSFailDebug(@"failure: %@, %@", dbError, updateError);
+        [self resetMappingWithSneakyTransaction];
+        return;
+    }
 
-    // External database modifications (e.g. changes from another process such as the SAE)
-    // are "flushed" using touchDbAsync when the app re-enters the foreground.
+    [self anyDBDidUpdateWithUpdatedInteractionIds:updatedInteractionIds];
+}
+
+- (void)conversationViewDatabaseSnapshotDidUpdateExternally
+{
+    [self anyDBDidUpdateExternally];
 }
 
+- (void)conversationViewDatabaseSnapshotDidReset
+{
+    [self resetMappingWithSneakyTransaction];
+}
+
+#pragma mark - YapDB Updates
+
 - (void)uiDatabaseWillUpdate:(NSNotification *)notification
 {
-    [self.delegate conversationViewModelWillUpdate];
+    [self anyDBWillUpdate];
 }
 
 - (void)uiDatabaseDidUpdate:(NSNotification *)notification
@@ -617,11 +651,17 @@ - (void)uiDatabaseDidUpdate:(NSNotification *)notification
         return;
     }
 
+    NSSet<NSString *> *updatedInteractionIds = [self.messageMapping updatedItemIdsFor:notifications];
+    [self anyDBDidUpdateWithUpdatedInteractionIds:updatedInteractionIds];
+}
+
+- (void)anyDBDidUpdateWithUpdatedInteractionIds:(NSSet<NSString *> *)updatedInteractionIds
+{
     __block ConversationMessageMappingDiff *_Nullable diff = nil;
     __block NSError *error;
     [self.dbStorage uiReadSwallowingErrorsWithBlock:^(SDSAnyReadTransaction *_Nonnull transaction) {
         diff = [self.messageMapping updateAndCalculateDiffWithTransaction:transaction
-                                                            notifications:notifications
+                                                    updatedInteractionIds:updatedInteractionIds
                                                                     error:&error];
     }];
     if (error != nil || diff == nil) {
@@ -714,6 +754,31 @@ - (void)uiDatabaseDidUpdate:(NSNotification *)notification
     [self updateViewWithOldItemIdList:oldItemIdList updatedItemSet:updatedItemSet];
 }
 
+- (void)uiDatabaseDidUpdateExternally:(NSNotification *)notification
+{
+    [self anyDBDidUpdateExternally];
+}
+
+#pragma mark - AnyDB Update
+
+- (void)anyDBWillUpdate
+{
+    [self.delegate conversationViewModelWillUpdate];
+}
+
+- (void)anyDBDidUpdateExternally
+{
+    OWSAssertIsOnMainThread();
+
+    OWSLogVerbose(@"");
+
+    // External database modifications (e.g. changes from another process such as the SAE)
+    // are "flushed" using touchDbAsync when the app re-enters the foreground.
+    // GRDB TODO - remove touchDbAsync
+}
+
+#pragma mark -
+
 // A simpler version of the update logic we use when
 // only transient items have changed.
 - (void)updateForTransientItems
diff --git a/Signal/src/ViewControllers/HomeView/HomeViewController.m b/Signal/src/ViewControllers/HomeView/HomeViewController.m
index 8a3124abd28..aaa21da48e7 100644
--- a/Signal/src/ViewControllers/HomeView/HomeViewController.m
+++ b/Signal/src/ViewControllers/HomeView/HomeViewController.m
@@ -60,6 +60,7 @@ @interface HomeViewController () <UITableViewDelegate,
     UIViewControllerPreviewingDelegate,
     UISearchBarDelegate,
     ConversationSearchViewDelegate,
+    HomeViewDatabaseSnapshotDelegate,
     OWSBlockListCacheDelegate>
 
 @property (nonatomic) UITableView *tableView;
@@ -175,7 +176,9 @@ - (void)observeNotifications
                                              selector:@selector(applicationWillResignActive:)
                                                  name:OWSApplicationWillResignActiveNotification
                                                object:nil];
-    if (!SSKFeatureFlags.useGRDB) {
+    if (SSKFeatureFlags.useGRDB) {
+        [self.dbStorage.grdbStorage.homeViewDatabaseObserver appendSnapshotDelegate:self];
+    } else {
         [[NSNotificationCenter defaultCenter] addObserver:self
                                                  selector:@selector(uiDatabaseDidUpdateExternally:)
                                                      name:OWSUIDatabaseConnectionDidUpdateExternallyNotification
@@ -1318,9 +1321,7 @@ - (void)deleteThread:(TSThread *)thread
             }
         }
 
-        if (transaction.transitional_yapWriteTransaction) {
-            [thread removeWithTransaction:transaction.transitional_yapWriteTransaction];
-        }
+        [thread anyRemoveWithTransaction:transaction];
     }];
 
     [self updateViewState];
@@ -1338,14 +1339,10 @@ - (void)archiveIndexPath:(NSIndexPath *)indexPath
     [self.dbStorage writeSwallowingErrorsWithBlock:^(SDSAnyWriteTransaction *transaction) {
         switch (self.homeViewMode) {
             case HomeViewMode_Inbox:
-                if (transaction.transitional_yapWriteTransaction) {
-                    [thread archiveThreadWithTransaction:transaction.transitional_yapWriteTransaction];
-                }
+                [thread archiveThreadWithTransaction:transaction];
                 break;
             case HomeViewMode_Archive:
-                if (transaction.transitional_yapWriteTransaction) {
-                    [thread unarchiveThreadWithTransaction:transaction.transitional_yapWriteTransaction];
-                }
+                [thread unarchiveThreadWithTransaction:transaction];
                 break;
         }
     }];
@@ -1434,26 +1431,48 @@ - (NSString *)currentGrouping
 
 #pragma mark - Database delegates
 
-- (void)uiDatabaseDidUpdateExternally:(NSNotification *)notification
+#pragma mark GRDB Update
+
+- (void)homeViewDatabaseSnapshotWillUpdate
 {
     OWSAssertIsOnMainThread();
+    [self anyUIDBWillUpdate];
+}
 
-    OWSLogVerbose(@"");
+- (void)homeViewDatabaseSnapshotDidUpdateWithUpdatedThreadIds:(NSSet<NSString *> *)updatedThreadIds
+{
+    OWSAssertIsOnMainThread();
+    OWSAssertDebug(SSKFeatureFlags.useGRDB);
+
+    if (!self.shouldObserveDBModifications) {
+        return;
+    }
 
+    [self anyUIDBDidUpdateWithUpdatedThreadIds:updatedThreadIds];
+}
+
+- (void)homeViewDatabaseSnapshotDidUpdateExternally
+{
+    OWSAssertIsOnMainThread();
+    [self anyUIDBDidUpdateExternally];
+}
+
+- (void)homeViewDatabaseSnapshotDidReset
+{
+    OWSAssertIsOnMainThread();
     if (self.shouldObserveDBModifications) {
-        // External database modifications can't be converted into incremental updates,
-        // so rebuild everything.  This is expensive and usually isn't necessary, but
-        // there's no alternative.
-        //
         // We don't need to do this if we're not observing db modifications since we'll
         // do it when we resume.
         [self resetMappings];
     }
 }
 
+#pragma mark YapDB Update
+
 - (void)uiDatabaseWillUpdate:(NSNotification *)notification
 {
-    [BenchManager startEventWithTitle:@"uiDatabaseUpdate" eventId:@"uiDatabaseUpdate"];
+    OWSAssertIsOnMainThread();
+    [self anyUIDBWillUpdate];
 }
 
 - (void)uiDatabaseDidUpdate:(NSNotification *)notification
@@ -1480,15 +1499,34 @@ - (void)uiDatabaseDidUpdate:(NSNotification *)notification
         return;
     }
 
-    __block ThreadMappingDiff *mappingDiff;
-    [uiDatabaseConnection readWithBlock:^(YapDatabaseReadTransaction *transaction) {
-        NSSet<NSString *> *updatedItemIds = [self.threadMapping updatedYapItemIdsForNotifications:notifications];
+    NSSet<NSString *> *updatedThreadIds = [self.threadMapping updatedYapItemIdsForNotifications:notifications];
+    [self anyUIDBDidUpdateWithUpdatedThreadIds:updatedThreadIds];
+}
 
-        SDSAnyReadTransaction *anyReadTransaction = transaction.asAnyRead;
+- (void)uiDatabaseDidUpdateExternally:(NSNotification *)notification
+{
+    OWSAssertIsOnMainThread();
+    [self anyUIDBDidUpdateExternally];
+}
+
+#pragma mark AnyDB Update
+
+- (void)anyUIDBWillUpdate
+{
+    OWSAssertIsOnMainThread();
+    [BenchManager startEventWithTitle:@"uiDatabaseUpdate" eventId:@"uiDatabaseUpdate"];
+}
+
+- (void)anyUIDBDidUpdateWithUpdatedThreadIds:(NSSet<NSString *> *)updatedItemIds
+{
+    OWSAssertIsOnMainThread();
+
+    __block ThreadMappingDiff *mappingDiff;
+    [self.dbStorage uiReadSwallowingErrorsWithBlock:^(SDSAnyReadTransaction *_Nonnull transaction) {
         mappingDiff =
             [self.threadMapping updateAndCalculateDiffSwallowingErrorsWithIsViewingArchive:self.isViewingArchive
                                                                             updatedItemIds:updatedItemIds
-                                                                               transaction:anyReadTransaction];
+                                                                               transaction:transaction];
     }];
 
     // We want this regardless of if we're currently viewing the archive.
@@ -1542,6 +1580,24 @@ - (void)uiDatabaseDidUpdate:(NSNotification *)notification
     [BenchManager completeEventWithEventId:@"uiDatabaseUpdate"];
 }
 
+- (void)anyUIDBDidUpdateExternally
+{
+    OWSLogVerbose(@"");
+    OWSAssertIsOnMainThread();
+
+    if (self.shouldObserveDBModifications) {
+        // External database modifications can't be converted into incremental updates,
+        // so rebuild everything.  This is expensive and usually isn't necessary, but
+        // there's no alternative.
+        //
+        // We don't need to do this if we're not observing db modifications since we'll
+        // do it when we resume.
+        [self resetMappings];
+    }
+}
+
+#pragma mark -
+
 - (NSUInteger)numberOfInboxThreads
 {
     return self.threadMapping.inboxCount;
diff --git a/SignalMessaging/environment/migrations/OWS110SortIdMigration.swift b/SignalMessaging/environment/migrations/OWS110SortIdMigration.swift
index 3d9df150c33..54bebc6dd64 100644
--- a/SignalMessaging/environment/migrations/OWS110SortIdMigration.swift
+++ b/SignalMessaging/environment/migrations/OWS110SortIdMigration.swift
@@ -106,7 +106,7 @@ public class OWS110SortIdMigration: OWSDatabaseMigration {
 
             Logger.info("re-archiving \(archivedThreads.count) threads which were previously archived")
             for archivedThread in archivedThreads {
-                archivedThread.archiveThread(with: transaction)
+                archivedThread.archiveThread(with: transaction.asAnyWrite)
             }
 
             self.save(with: transaction)
diff --git a/SignalServiceKit/src/Contacts/TSThread.h b/SignalServiceKit/src/Contacts/TSThread.h
index da1de71290b..2fd2d218ad3 100644
--- a/SignalServiceKit/src/Contacts/TSThread.h
+++ b/SignalServiceKit/src/Contacts/TSThread.h
@@ -10,6 +10,7 @@ BOOL IsNoteToSelfEnabled(void);
 
 @class OWSDisappearingMessagesConfiguration;
 @class SDSAnyReadTransaction;
+@class SDSAnyWriteTransaction;
 @class TSInteraction;
 @class TSInvalidIdentityKeyReceivingErrorMessage;
 
@@ -146,14 +147,14 @@ NS_SWIFT_NAME(init(uniqueId:archivalDate:archivedAsOfMessageSortId:conversationC
  *
  *  @param transaction Database transaction.
  */
-- (void)archiveThreadWithTransaction:(YapDatabaseReadWriteTransaction *)transaction;
+- (void)archiveThreadWithTransaction:(SDSAnyWriteTransaction *)transaction;
 
 /**
  *  Unarchives a thread
  *
  *  @param transaction Database transaction.
  */
-- (void)unarchiveThreadWithTransaction:(YapDatabaseReadWriteTransaction *)transaction;
+- (void)unarchiveThreadWithTransaction:(SDSAnyWriteTransaction *)transaction;
 
 - (void)removeAllThreadInteractionsWithTransaction:(YapDatabaseReadWriteTransaction *)transaction;
 
diff --git a/SignalServiceKit/src/Contacts/TSThread.m b/SignalServiceKit/src/Contacts/TSThread.m
index 8e853769995..d1dbb822417 100644
--- a/SignalServiceKit/src/Contacts/TSThread.m
+++ b/SignalServiceKit/src/Contacts/TSThread.m
@@ -499,22 +499,24 @@ + (BOOL)legacyIsArchivedWithLastMessageDate:(nullable NSDate *)lastMessageDate
     return [archivalDate compare:lastMessageDate] != NSOrderedAscending;
 }
 
-- (void)archiveThreadWithTransaction:(YapDatabaseReadWriteTransaction *)transaction
+- (void)archiveThreadWithTransaction:(SDSAnyWriteTransaction *)transaction
 {
-    [self applyChangeToSelfAndLatestCopy:transaction
-                             changeBlock:^(TSThread *thread) {
-                                 uint64_t latestId = [SSKIncrementingIdFinder previousIdWithKey:TSInteraction.collection
-                                                                                    transaction:transaction];
+
+    [self anyUpdateWithTransaction:transaction
+                             block:^(TSThread *thread) {
+                                 uint64_t latestId = [InteractionFinder mostRecentSortIdWithTransaction:transaction];
                                  thread.archivedAsOfMessageSortId = @(latestId);
                              }];
 
-    [self markAllAsReadWithTransaction:transaction];
+    if (transaction.transitional_yapWriteTransaction) {
+        [self markAllAsReadWithTransaction:transaction.transitional_yapWriteTransaction];
+    }
 }
 
-- (void)unarchiveThreadWithTransaction:(YapDatabaseReadWriteTransaction *)transaction
+- (void)unarchiveThreadWithTransaction:(SDSAnyWriteTransaction *)transaction
 {
-    [self applyChangeToSelfAndLatestCopy:transaction
-                             changeBlock:^(TSThread *thread) {
+    [self anyUpdateWithTransaction:transaction
+                             block:^(TSThread *thread) {
                                  thread.archivedAsOfMessageSortId = nil;
                              }];
 }
diff --git a/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift b/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift
index 2083ac6c91f..4c9cba8f4d5 100644
--- a/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift
+++ b/SignalServiceKit/src/Storage/Database/Records/InteractionFinder.swift
@@ -10,6 +10,8 @@ protocol InteractionFinderAdapter {
 
     static func fetch(uniqueId: String, transaction: ReadTransaction) throws -> TSInteraction?
 
+    static func mostRecentSortId(transaction: ReadTransaction) -> UInt64
+
     func mostRecentInteraction(transaction: ReadTransaction) -> TSInteraction?
     func mostRecentInteractionForInbox(transaction: ReadTransaction) -> TSInteraction?
 
@@ -54,6 +56,16 @@ public class InteractionFinder: NSObject, InteractionFinderAdapter {
         }
     }
 
+    @objc
+    public class func mostRecentSortId(transaction: SDSAnyReadTransaction) -> UInt64 {
+        switch transaction.readTransaction {
+        case .yapRead(let yapRead):
+            return YAPDBInteractionFinderAdapter.mostRecentSortId(transaction: yapRead)
+        case .grdbRead(let grdbRead):
+            return GRDBInteractionFinderAdapter.mostRecentSortId(transaction: grdbRead)
+        }
+    }
+
     // MARK: - instance methods
 
     @objc
@@ -92,7 +104,7 @@ public class InteractionFinder: NSObject, InteractionFinderAdapter {
         case .yapRead(let yapRead):
             return yapAdapter.count(transaction: yapRead)
         case .grdbRead(let grdbRead):
-            return try! grdbAdapter.count(transaction: grdbRead)
+            return try grdbAdapter.count(transaction: grdbRead)
         }
     }
 
@@ -125,6 +137,7 @@ public class InteractionFinder: NSObject, InteractionFinderAdapter {
 }
 
 struct YAPDBInteractionFinderAdapter: InteractionFinderAdapter {
+
     private let threadUniqueId: String
 
     init(threadUniqueId: String) {
@@ -137,6 +150,10 @@ struct YAPDBInteractionFinderAdapter: InteractionFinderAdapter {
         return transaction.object(forKey: uniqueId, inCollection: TSInteraction.collection()) as? TSInteraction
     }
 
+    static func mostRecentSortId(transaction: YapDatabaseReadTransaction) -> UInt64 {
+        return SSKIncrementingIdFinder.previousId(key: TSInteraction.collection(), transaction: transaction)
+    }
+
     // MARK: - instance methods
 
     func mostRecentInteraction(transaction: YapDatabaseReadTransaction) -> TSInteraction? {
@@ -256,6 +273,15 @@ struct GRDBInteractionFinderAdapter: InteractionFinderAdapter {
         return TSInteraction.fromRecord(interactionRecord)
     }
 
+    static func mostRecentSortId(transaction: GRDBReadTransaction) -> UInt64 {
+        let sql = """
+            SELECT seq
+            FROM sqlite_sequence
+            WHERE name = ?
+        """
+        return try! UInt64.fetchOne(transaction.database, sql: sql, arguments: [InteractionRecord.databaseTableName])!
+    }
+
     // MARK: - instance methods
 
     func mostRecentInteraction(transaction: GRDBReadTransaction) -> TSInteraction? {
diff --git a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
index fd78020bb47..f9bb2d47432 100644
--- a/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSDatabaseStorage.swift
@@ -10,48 +10,28 @@ public class SDSDatabaseStorage: NSObject {
 
     // TODO hoist to environment
     @objc
-    public static let shared: SDSDatabaseStorage = try! SDSDatabaseStorage(raisingErrors: ())
+    public static let shared: SDSDatabaseStorage = SDSDatabaseStorage()
 
     static public var shouldLogDBQueries: Bool = false
 
-    @available(*, unavailable, message:"use other constructor instead.")
-    override init() {
-        fatalError("unavailable")
-    }
-
     private var hasPendingCrossProcessWrite = false
 
     private let crossProcess = SDSCrossProcess()
 
     // MARK: - Initialization / Setup
 
-    let adapter: SDSDatabaseStorageAdapter
+    lazy var yapStorage = type(of: self).createYapStorage()
 
     @objc
-    required init(raisingErrors: ()) throws {
-        adapter = SDSDatabaseStorage.createDefaultStorage()
-
-        super.init()
-
-        addObservers()
-    }
-
-    required init(adapter: SDSDatabaseStorageAdapter, raisingErrors: ()) throws {
-        self.adapter = adapter
+    public lazy var grdbStorage = type(of: self).createGrdbStorage()
 
+    @objc
+    override init() {
         super.init()
 
         addObservers()
     }
 
-    class func createDefaultStorage() -> SDSDatabaseStorageAdapter {
-        if FeatureFlags.useGRDB {
-            return createGrdbStorage()
-        } else {
-            return createYapStorage()
-        }
-    }
-
     private func addObservers() {
         // Cross process writes
         if FeatureFlags.useGRDB {
@@ -75,6 +55,8 @@ public class SDSDatabaseStorage: NSObject {
     }
 
     class func createGrdbStorage() -> GRDBDatabaseStorageAdapter {
+        assert(FeatureFlags.useGRDB)
+
         let baseDir: URL
 
         if FeatureFlags.grdbMigratesFreshDBEveryLaunch {
@@ -92,25 +74,42 @@ public class SDSDatabaseStorage: NSObject {
         return YAPDBStorageAdapter()
     }
 
-    // `grdbStorage` is useful as an "escape hatch" while we're migrating to GRDB.
-    // When an adapter needs to access the backing grdb store directly.
-    public var grdbStorage: GRDBDatabaseStorageAdapter {
-        assert(FeatureFlags.useGRDB)
-        return adapter as! GRDBDatabaseStorageAdapter
-    }
-
     // MARK: -
 
     public func uiRead(block: @escaping (SDSAnyReadTransaction) -> Void) throws {
-        try adapter.uiRead(block: block)
+        if FeatureFlags.useGRDB {
+            try grdbStorage.uiRead { transaction in
+                block(transaction.asAnyRead)
+            }
+        } else {
+            yapStorage.uiRead { transaction in
+                block(transaction.asAnyRead)
+            }
+        }
     }
 
     public func read(block: @escaping (SDSAnyReadTransaction) -> Void) throws {
-        try adapter.read(block: block)
+        if FeatureFlags.useGRDB {
+            try grdbStorage.read { transaction in
+                block(transaction.asAnyRead)
+            }
+        } else {
+            yapStorage.read { transaction in
+                block(transaction.asAnyRead)
+            }
+        }
     }
 
     public func write(block: @escaping (SDSAnyWriteTransaction) -> Void) throws {
-        try adapter.write(block: block)
+        if FeatureFlags.useGRDB {
+            try grdbStorage.write { transaction in
+                block(transaction.asAnyWrite)
+            }
+        } else {
+            yapStorage.write { transaction in
+                block(transaction.asAnyWrite)
+            }
+        }
 
         self.notifyCrossProcessWrite()
     }
@@ -215,9 +214,11 @@ public class SDSDatabaseStorage: NSObject {
 }
 
 protocol SDSDatabaseStorageAdapter {
-    func uiRead(block: @escaping (SDSAnyReadTransaction) -> Void) throws
-    func read(block: @escaping (SDSAnyReadTransaction) -> Void) throws
-    func write(block: @escaping (SDSAnyWriteTransaction) -> Void) throws
+    associatedtype ReadTransaction
+    associatedtype WriteTransaction
+    func uiRead(block: @escaping (ReadTransaction) -> Void) throws
+    func read(block: @escaping (ReadTransaction) -> Void) throws
+    func write(block: @escaping (WriteTransaction) -> Void) throws
 }
 
 struct YAPDBStorageAdapter {
@@ -227,26 +228,27 @@ struct YAPDBStorageAdapter {
 }
 
 extension YAPDBStorageAdapter: SDSDatabaseStorageAdapter {
-    func uiRead(block: @escaping (SDSAnyReadTransaction) -> Void) {
+    func uiRead(block: @escaping (YapDatabaseReadTransaction) -> Void) {
         storage.uiDatabaseConnection.read { yapTransaction in
-            block(SDSAnyReadTransaction(.yapRead(yapTransaction)))
+            block(yapTransaction)
         }
     }
 
-    func read(block: @escaping (SDSAnyReadTransaction) -> Void) {
+    func read(block: @escaping (YapDatabaseReadTransaction) -> Void) {
         storage.dbReadConnection.read { yapTransaction in
-            block(SDSAnyReadTransaction(.yapRead(yapTransaction)))
+            block(yapTransaction)
         }
     }
 
-    func write(block: @escaping (SDSAnyWriteTransaction) -> Void) {
+    func write(block: @escaping (YapDatabaseReadWriteTransaction) -> Void) {
         storage.dbReadWriteConnection.readWrite { yapTransaction in
-            block(SDSAnyWriteTransaction(.yapWrite(yapTransaction)))
+            block(yapTransaction)
         }
     }
 }
 
-public struct GRDBDatabaseStorageAdapter {
+@objc
+public class GRDBDatabaseStorageAdapter: NSObject {
 
     private let keyServiceName: String = "TSKeyChainService"
     private let keyName: String = "OWSDatabaseCipherKeySpec"
@@ -263,30 +265,21 @@ public struct GRDBDatabaseStorageAdapter {
         let dbURL = dbDir.appendingPathComponent("signal.sqlite", isDirectory: false)
         storage = try Storage(dbURL: dbURL, keyServiceName: keyServiceName, keyName: keyName)
 
+        super.init()
+
         // Schema migrations are currently simple and fast. If they grow to become long-running,
         // we'll want to ensure that it doesn't block app launch to avoid 0x8badfood.
         try migrator.migrate(pool)
 
-        let mutatingSelf = self
-        AppReadiness.runNowOrWhenAppDidBecomeReady {
+        AppReadiness.runNowOrWhenAppWillBecomeReady {
             do {
-                try mutatingSelf.verify()
+                try self.setupUIDatabase()
             } catch {
-                owsFailDebug("error: \(error)")
+                owsFail("unable to setup database: \(error)")
             }
         }
     }
 
-    func verify() throws {
-        try storage.pool.read { db in
-            guard let someCount = try UInt.fetchOne(db, sql: "SELECT COUNT(*) FROM sqlite_master") else {
-                owsFailDebug("failed to verify storage")
-                return
-            }
-            Logger.debug("verified storage: \(someCount)")
-        }
-    }
-
     lazy var migrator: DatabaseMigrator = {
         var migrator = DatabaseMigrator()
         migrator.registerMigration("create initial schema") { db in
@@ -307,25 +300,71 @@ public struct GRDBDatabaseStorageAdapter {
         }
         return migrator
     }()
+
+    // MARK: - Database Snapshot
+
+    private var latestSnapshot: DatabaseSnapshot! {
+        return uiDatabaseObserver!.latestSnapshot
+    }
+
+    @objc
+    var uiDatabaseObserver: UIDatabaseObserver?
+
+    @objc
+    var homeViewDatabaseObserver: HomeViewDatabaseObserver?
+
+    @objc
+    var conversationViewDatabaseObserver: ConversationViewDatabaseObserver?
+
+    func setupUIDatabase() throws {
+        // UIDatabaseObserver is a general purpose observer, whose delegates
+        // are notified when things change, but are not given any specific details
+        // about the changes.
+        let uiDatabaseObserver = try UIDatabaseObserver(pool: pool)
+        self.uiDatabaseObserver = uiDatabaseObserver
+
+        // HomeViewDatabaseObserver is built on top of UIDatabaseObserver
+        // but includes the details necessary for rendering collection view
+        // batch updates.
+        let homeViewDatabaseObserver = HomeViewDatabaseObserver()
+        self.homeViewDatabaseObserver = homeViewDatabaseObserver
+        uiDatabaseObserver.appendSnapshotDelegate(homeViewDatabaseObserver)
+
+        // ConversationViewDatabaseObserver is built on top of UIDatabaseObserver
+        // but includes the details necessary for rendering collection view
+        // batch updates.
+        let conversationViewDatabaseObserver = ConversationViewDatabaseObserver()
+        self.conversationViewDatabaseObserver = conversationViewDatabaseObserver
+        uiDatabaseObserver.appendSnapshotDelegate(conversationViewDatabaseObserver)
+
+        return try pool.write { db in
+            db.add(transactionObserver: homeViewDatabaseObserver, extent: Database.TransactionObservationExtent.observerLifetime)
+            db.add(transactionObserver: conversationViewDatabaseObserver, extent: Database.TransactionObservationExtent.observerLifetime)
+        }
+    }
 }
 
 extension GRDBDatabaseStorageAdapter: SDSDatabaseStorageAdapter {
-    func uiRead(block: @escaping (SDSAnyReadTransaction) -> Void) throws {
-        // TODO this should be based on a snapshot
-        try pool.read { database in
-            block(SDSAnyReadTransaction(.grdbRead(GRDBReadTransaction(database: database))))
+
+    @objc
+    func uiRead(block: @escaping (GRDBReadTransaction) -> Void) throws {
+        AssertIsOnMainThread()
+        latestSnapshot.read { database in
+            block(GRDBReadTransaction(database: database))
         }
     }
 
-    func read(block: @escaping (SDSAnyReadTransaction) -> Void) throws {
+    @objc
+    func read(block: @escaping (GRDBReadTransaction) -> Void) throws {
         try pool.read { database in
-            block(SDSAnyReadTransaction(.grdbRead(GRDBReadTransaction(database: database))))
+            block(GRDBReadTransaction(database: database))
         }
     }
 
-    func write(block: @escaping (SDSAnyWriteTransaction) -> Void) throws {
+    @objc
+    func write(block: @escaping (GRDBWriteTransaction) -> Void) throws {
         try pool.write { database in
-            block(SDSAnyWriteTransaction(.grdbWrite(GRDBWriteTransaction(database: database))))
+            block(GRDBWriteTransaction(database: database))
         }
     }
 }
diff --git a/SignalServiceKit/src/Storage/Database/SDSTransaction.swift b/SignalServiceKit/src/Storage/Database/SDSTransaction.swift
index 02bea2649de..175ca4e136c 100644
--- a/SignalServiceKit/src/Storage/Database/SDSTransaction.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSTransaction.swift
@@ -14,12 +14,19 @@ public class GRDBReadTransaction: NSObject {
     init(database: Database) {
         self.database = database
     }
+
+    var asAnyRead: SDSAnyReadTransaction {
+        return SDSAnyReadTransaction(.grdbRead(self))
+    }
 }
 
 // MARK: -
 
 @objc
 public class GRDBWriteTransaction: GRDBReadTransaction {
+    var asAnyWrite: SDSAnyWriteTransaction {
+        return SDSAnyWriteTransaction(.grdbWrite(self))
+    }
 }
 
 // MARK: -
@@ -132,7 +139,6 @@ public class SDSAnyWriteTransaction: SDSAnyReadTransaction {
 
 @objc
 public extension YapDatabaseReadTransaction {
-    @objc
     var asAnyRead: SDSAnyReadTransaction {
         return SDSAnyReadTransaction(transitional_yapReadTransaction: self)
     }
@@ -142,7 +148,6 @@ public extension YapDatabaseReadTransaction {
 
 @objc
 public extension YapDatabaseReadWriteTransaction {
-    @objc
     var asAnyWrite: SDSAnyWriteTransaction {
         return SDSAnyWriteTransaction(transitional_yapWriteTransaction: self)
     }
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/ConversationViewDatabaseSnapshot.swift b/SignalServiceKit/src/Storage/Database/Snapshots/ConversationViewDatabaseSnapshot.swift
new file mode 100644
index 00000000000..849fadbb5e6
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/ConversationViewDatabaseSnapshot.swift
@@ -0,0 +1,183 @@
+//
+//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDBCipher
+
+@objc
+public protocol ConversationViewDatabaseSnapshotDelegate: AnyObject {
+    func conversationViewDatabaseSnapshotWillUpdate()
+    func conversationViewDatabaseSnapshotDidUpdate(transactionChanges: ConversationViewDatabaseTransactionChanges)
+    func conversationViewDatabaseSnapshotDidUpdateExternally()
+    func conversationViewDatabaseSnapshotDidReset()
+}
+
+@objc
+public class ConversationViewDatabaseObserver: NSObject {
+
+    private var _snapshotDelegates: [Weak<ConversationViewDatabaseSnapshotDelegate>] = []
+    private var snapshotDelegates: [ConversationViewDatabaseSnapshotDelegate] {
+        return _snapshotDelegates.compactMap { $0.value }
+    }
+
+    @objc
+    public func appendSnapshotDelegate(_ snapshotDelegate: ConversationViewDatabaseSnapshotDelegate) {
+        _snapshotDelegates = _snapshotDelegates.filter { $0.value != nil} + [Weak(value: snapshotDelegate)]
+    }
+
+    private typealias RowId = Int64
+
+    private var _pendingInteractionChanges: Set<RowId> = Set()
+    private var pendingInteractionChanges: Set<RowId> {
+        get {
+            AssertIsOnUIDatabaseObserverSerialQueue()
+            return _pendingInteractionChanges
+        }
+        set {
+            AssertIsOnUIDatabaseObserverSerialQueue()
+            _pendingInteractionChanges = newValue
+        }
+    }
+
+    private var _committedInteractionChanges: Set<RowId>?
+    private var committedInteractionChanges: Set<RowId>? {
+        get {
+            AssertIsOnMainThread()
+            return _committedInteractionChanges
+        }
+        set {
+            AssertIsOnMainThread()
+            _committedInteractionChanges = newValue
+        }
+    }
+}
+
+extension ConversationViewDatabaseObserver: TransactionObserver {
+
+    public func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {
+        return eventKind.tableName == InteractionRecord.databaseTableName
+    }
+
+    public func databaseDidChange(with event: DatabaseEvent) {
+        Logger.verbose("")
+        assert(event.tableName == InteractionRecord.databaseTableName)
+        UIDatabaseObserver.serialQueue.sync {
+            _ = pendingInteractionChanges.insert(event.rowID)
+        }
+    }
+
+    public func databaseDidCommit(_ db: Database) {
+        // no - op
+
+        // Although this class is a TransactionObserver, it is also a delegate
+        // (DatabaseSnapshotDelegate) of another TransactionObserver, the UIDatabaseObserver.
+        //
+        // We use our own TransactionObserver methods to collect details about the changes,
+        // but we wait for the UIDatabaseObserver's TransactionObserver methods to inform our own
+        // delegate of these details in sync with when the UI DB Snapshot is updated
+        // (via DatabaseSnapshotDelegate).
+    }
+
+    public func databaseDidRollback(_ db: Database) {
+        owsFailDebug("we should verify this works if we ever start to use rollbacks")
+        UIDatabaseObserver.serialQueue.sync {
+            pendingInteractionChanges = Set()
+        }
+    }
+}
+
+@objc
+public class ConversationViewDatabaseTransactionChanges: NSObject {
+    private let updatedRowIds: Set<Int64>
+
+    init(updatedRowIds: Set<Int64>) throws {
+        guard updatedRowIds.count < UIDatabaseObserver.kMaxIncrementalRowChanges else {
+            throw DatabaseObserverError.changeTooLarge
+        }
+
+        self.updatedRowIds = updatedRowIds
+    }
+
+    @objc
+    public func updatedInteractionIds(forThreadId threadUniqueId: String, transaction: GRDBReadTransaction) throws -> Set<String> {
+        guard updatedRowIds.count > 0 else {
+            return Set()
+        }
+
+        guard updatedRowIds.count < UIDatabaseObserver.kMaxIncrementalRowChanges else {
+            owsFailDebug("updatedRowIds count should be enforced in initializer")
+            throw DatabaseObserverError.changeTooLarge
+        }
+
+        let commaSeparatedRowIds = updatedRowIds.map { String($0) }.joined(separator: ", ")
+        let rowIdsSQL = "(\(commaSeparatedRowIds))"
+        let sql = """
+        SELECT \(interactionColumn: .uniqueId)
+        FROM \(InteractionRecord.databaseTableName)
+        WHERE rowid IN \(rowIdsSQL)
+        AND \(interactionColumn: .threadUniqueId) = ?
+        """
+
+        let uniqueIds = try String.fetchAll(transaction.database, sql: sql, arguments: [threadUniqueId])
+
+        return Set(uniqueIds)
+    }
+}
+
+extension ConversationViewDatabaseObserver: DatabaseSnapshotDelegate {
+    public func databaseSnapshotSourceDidCommit(db: Database) {
+        AssertIsOnUIDatabaseObserverSerialQueue()
+        do {
+            let pendingInteractionChanges = self.pendingInteractionChanges
+            self.pendingInteractionChanges = Set()
+
+            DispatchQueue.main.async {
+                self.committedInteractionChanges = pendingInteractionChanges
+            }
+        } catch {
+            owsFailDebug("error: \(error)")
+            DispatchQueue.main.async {
+                self.committedInteractionChanges = nil
+            }
+        }
+    }
+
+    public func databaseSnapshotWillUpdate() {
+        AssertIsOnMainThread()
+        for delegate in snapshotDelegates {
+            delegate.conversationViewDatabaseSnapshotWillUpdate()
+        }
+    }
+
+    public func databaseSnapshotDidUpdate() {
+        AssertIsOnMainThread()
+        do {
+            guard let committedInteractionChanges = self.committedInteractionChanges else {
+                throw OWSErrorMakeAssertionError("committedInteractionChanges were unexpectedly nil")
+            }
+            self.committedInteractionChanges = nil
+
+            let transactionChanges = try ConversationViewDatabaseTransactionChanges(updatedRowIds: committedInteractionChanges)
+            for delegate in snapshotDelegates {
+                delegate.conversationViewDatabaseSnapshotDidUpdate(transactionChanges: transactionChanges)
+            }
+        } catch DatabaseObserverError.changeTooLarge {
+            for delegate in snapshotDelegates {
+                delegate.conversationViewDatabaseSnapshotDidReset()
+            }
+        } catch {
+            owsFailDebug("unknown error: \(error)")
+            for delegate in snapshotDelegates {
+                delegate.conversationViewDatabaseSnapshotDidReset()
+            }
+        }
+    }
+
+    public func databaseSnapshotDidUpdateExternally() {
+        AssertIsOnMainThread()
+        for delegate in snapshotDelegates {
+            delegate.conversationViewDatabaseSnapshotDidUpdateExternally()
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/HomeViewDatabaseSnapshot.swift b/SignalServiceKit/src/Storage/Database/Snapshots/HomeViewDatabaseSnapshot.swift
new file mode 100644
index 00000000000..136dfe70732
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/HomeViewDatabaseSnapshot.swift
@@ -0,0 +1,168 @@
+//
+//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDBCipher
+
+@objc
+public protocol HomeViewDatabaseSnapshotDelegate: AnyObject {
+    func homeViewDatabaseSnapshotWillUpdate()
+    func homeViewDatabaseSnapshotDidUpdate(updatedThreadIds: Set<String>)
+    func homeViewDatabaseSnapshotDidUpdateExternally()
+    func homeViewDatabaseSnapshotDidReset()
+}
+
+@objc
+public class HomeViewDatabaseObserver: NSObject {
+
+    private var _snapshotDelegates: [Weak<HomeViewDatabaseSnapshotDelegate>] = []
+    private var snapshotDelegates: [HomeViewDatabaseSnapshotDelegate] {
+        AssertIsOnMainThread()
+        return _snapshotDelegates.compactMap { $0.value }
+    }
+
+    @objc
+    public func appendSnapshotDelegate(_ snapshotDelegate: HomeViewDatabaseSnapshotDelegate) {
+        AssertIsOnMainThread()
+        _snapshotDelegates = _snapshotDelegates.filter { $0.value != nil} + [Weak(value: snapshotDelegate)]
+    }
+
+    private typealias RowId = Int64
+    private var _pendingThreadChanges: Set<RowId> = Set()
+    private var pendingThreadChanges: Set<RowId> {
+        get {
+            AssertIsOnUIDatabaseObserverSerialQueue()
+            return _pendingThreadChanges
+        }
+        set {
+            AssertIsOnUIDatabaseObserverSerialQueue()
+            _pendingThreadChanges = newValue
+        }
+    }
+
+    private typealias ThreadUniqueId = String
+    private var _committedThreadChanges: Set<ThreadUniqueId>?
+    private var committedThreadChanges: Set<ThreadUniqueId>? {
+        get {
+            AssertIsOnMainThread()
+            return _committedThreadChanges
+        }
+
+        set {
+            AssertIsOnMainThread()
+            _committedThreadChanges = newValue
+        }
+    }
+
+    private func threadUniqueIds(forRowIds rowIds: Set<RowId>, db: Database) throws -> Set<String> {
+        guard rowIds.count > 0 else {
+            return Set()
+        }
+
+        guard rowIds.count < UIDatabaseObserver.kMaxIncrementalRowChanges else {
+            throw DatabaseObserverError.changeTooLarge
+        }
+
+        let commaSeparatedRowIds = rowIds.map { String($0) }.joined(separator: ", ")
+        let rowIdsSQL = "(\(commaSeparatedRowIds))"
+
+        let sql = """
+        SELECT \(threadColumn: .uniqueId)
+        FROM \(ThreadRecord.databaseTableName)
+        WHERE rowid IN \(rowIdsSQL)
+        """
+
+        let threadUniqueIds = try String.fetchAll(db, sql: sql)
+        return Set(threadUniqueIds)
+    }
+}
+
+extension HomeViewDatabaseObserver: TransactionObserver {
+
+    public func observes(eventsOfKind eventKind: DatabaseEventKind) -> Bool {
+        return eventKind.tableName == ThreadRecord.databaseTableName
+    }
+
+    public func databaseDidChange(with event: DatabaseEvent) {
+        Logger.verbose("")
+        UIDatabaseObserver.serialQueue.sync {
+            _ = pendingThreadChanges.insert(event.rowID)
+        }
+    }
+
+    public func databaseDidCommit(_ db: Database) {
+        // no - op
+
+        // Although this class is a TransactionObserver, it is also a delegate
+        // (DatabaseSnapshotDelegate) of another TransactionObserver, the UIDatabaseObserver.
+        //
+        // We use our own TransactionObserver methods to collect details about the changes,
+        // but we wait for the UIDatabaseObserver's TransactionObserver methods to inform our own
+        // delegate of these details in sync with when the UI DB Snapshot is updated
+        // (via DatabaseSnapshotDelegate).
+    }
+
+    public func databaseDidRollback(_ db: Database) {
+        owsFailDebug("test this if we ever use it")
+        UIDatabaseObserver.serialQueue.sync {
+            pendingThreadChanges = Set()
+        }
+    }
+}
+
+extension HomeViewDatabaseObserver: DatabaseSnapshotDelegate {
+    public func databaseSnapshotSourceDidCommit(db: Database) {
+        AssertIsOnUIDatabaseObserverSerialQueue()
+        do {
+            let pendingThreadChanges = self.pendingThreadChanges
+            self.pendingThreadChanges = Set()
+
+            let committedThreadChanges = try threadUniqueIds(forRowIds: pendingThreadChanges, db: db)
+            DispatchQueue.main.async {
+                self.committedThreadChanges = committedThreadChanges
+            }
+        } catch {
+            DispatchQueue.main.async {
+                self.committedThreadChanges = nil
+            }
+        }
+    }
+
+    public func databaseSnapshotWillUpdate() {
+        AssertIsOnMainThread()
+        for delegate in snapshotDelegates {
+            delegate.homeViewDatabaseSnapshotWillUpdate()
+        }
+    }
+
+    public func databaseSnapshotDidUpdate() {
+        AssertIsOnMainThread()
+        do {
+            guard let commitedThreadChanges = self.committedThreadChanges else {
+                throw OWSErrorMakeAssertionError("committedThreadChanges was unexpectedly nil")
+            }
+            self.committedThreadChanges = nil
+
+            for delegate in snapshotDelegates {
+                delegate.homeViewDatabaseSnapshotDidUpdate(updatedThreadIds: commitedThreadChanges)
+            }
+        } catch DatabaseObserverError.changeTooLarge {
+            for delegate in snapshotDelegates {
+                delegate.homeViewDatabaseSnapshotDidReset()
+            }
+        } catch {
+            owsFailDebug("unknown error: \(error)")
+            for delegate in snapshotDelegates {
+                delegate.homeViewDatabaseSnapshotDidReset()
+            }
+        }
+    }
+
+    public func databaseSnapshotDidUpdateExternally() {
+        AssertIsOnMainThread()
+        for delegate in snapshotDelegates {
+            delegate.homeViewDatabaseSnapshotDidUpdateExternally()
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Storage/Database/Snapshots/UIDatabaseSnapshot.swift b/SignalServiceKit/src/Storage/Database/Snapshots/UIDatabaseSnapshot.swift
new file mode 100644
index 00000000000..5007250dd5f
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Database/Snapshots/UIDatabaseSnapshot.swift
@@ -0,0 +1,143 @@
+//
+//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDBCipher
+
+/// Anything 
+public protocol DatabaseSnapshotDelegate: AnyObject {
+    // Called on the Database serial write queue before `databaseSnapshotWillUpdate`
+    //
+    // Use this callback to prepare state from the just-committed
+    // database which will be passed along in your DidUpdate hooks
+    func databaseSnapshotSourceDidCommit(db: Database)
+
+    // The following are called on the Main Thread
+    func databaseSnapshotWillUpdate()
+    func databaseSnapshotDidUpdate()
+    func databaseSnapshotDidUpdateExternally()
+}
+
+@objc
+public protocol ObjCDatabaseSnapshotDelegate: AnyObject {
+    func databaseSnapshotWillUpdate()
+    func databaseSnapshotDidUpdate()
+    func databaseSnapshotDidUpdateExternally()
+}
+
+enum DatabaseObserverError: Error {
+    case changeTooLarge
+}
+
+func AssertIsOnUIDatabaseObserverSerialQueue() {
+    #if DEBUG
+    assertOnQueue(UIDatabaseObserver.serialQueue)
+    #endif
+}
+
+@objc
+public class UIDatabaseObserver: NSObject {
+
+    public static let kMaxIncrementalRowChanges = 200
+    public static let serialQueue = DispatchQueue(label: "UIDatabaseObserver.serialQueue")
+
+    private var _snapshotDelegates: [Weak<DatabaseSnapshotDelegate>] = []
+    private var snapshotDelegates: [DatabaseSnapshotDelegate] {
+        return _snapshotDelegates.compactMap { $0.value }
+    }
+
+    @objc
+    public func appendSnapshotDelegate(_ snapshotDelegate: ObjCDatabaseSnapshotDelegate) {
+        let wrapper: DatabaseSnapshotDelegate = ObjCDatabaseSnapshotDelegateWrapper(snapshotDelegate)
+        _snapshotDelegates = _snapshotDelegates.filter { $0.value != nil} + [Weak(value: wrapper)]
+    }
+
+    public func appendSnapshotDelegate(_ snapshotDelegate: DatabaseSnapshotDelegate) {
+        _snapshotDelegates = _snapshotDelegates.filter { $0.value != nil} + [Weak(value: snapshotDelegate)]
+    }
+
+    private var observer: TransactionObserver?
+    internal var latestSnapshot: DatabaseSnapshot {
+        didSet {
+            AssertIsOnMainThread()
+        }
+    }
+
+    init(pool: DatabasePool) throws {
+        self.latestSnapshot = try pool.makeSnapshot()
+        super.init()
+
+        let observation = DatabaseRegionObservation(tracking: DatabaseRegion.fullDatabase)
+        self.observer = try observation.start(in: pool) { [weak self] (database: Database) in
+            guard let self = self else { return }
+
+            UIDatabaseObserver.serialQueue.sync {
+                for delegate in self.snapshotDelegates {
+                    delegate.databaseSnapshotSourceDidCommit(db: database)
+                }
+            }
+
+            let newSnapshot = try! pool.makeSnapshot()
+
+            DispatchQueue.main.async {
+                Logger.verbose("databaseSnapshotWillUpdate")
+                for delegate in self.snapshotDelegates {
+                    delegate.databaseSnapshotWillUpdate()
+                }
+
+                self.latestSnapshot = newSnapshot
+
+                Logger.verbose("databaseSnapshotDidUpdate")
+                for delegate in self.snapshotDelegates {
+                    delegate.databaseSnapshotDidUpdate()
+                }
+            }
+        }
+
+        NotificationCenter.default.addObserver(self,
+                                               selector: #selector(didReceiveCrossProcessNotification),
+                                               name: SDSDatabaseStorage.didReceiveCrossProcessNotification,
+                                               object: nil)
+    }
+
+    @objc
+    func didReceiveCrossProcessNotification(_ notification: Notification) {
+        AssertIsOnMainThread()
+        Logger.verbose("")
+
+        for delegate in snapshotDelegates {
+            delegate.databaseSnapshotDidUpdateExternally()
+        }
+    }
+}
+
+private class ObjCDatabaseSnapshotDelegateWrapper {
+    let objCDatabaseSnapshotDelegate: ObjCDatabaseSnapshotDelegate
+    init(_ objCDatabaseSnapshotDelegate: ObjCDatabaseSnapshotDelegate) {
+        self.objCDatabaseSnapshotDelegate = objCDatabaseSnapshotDelegate
+    }
+}
+
+extension ObjCDatabaseSnapshotDelegateWrapper: DatabaseSnapshotDelegate {
+    func databaseSnapshotSourceDidCommit(db: Database) {
+        // Currently no objc delegates will need to handle the commit
+        // Doing so would be slightly complicated since `Database` is Swift only.
+        owsFailDebug("not implemented.")
+    }
+
+    func databaseSnapshotWillUpdate() {
+        AssertIsOnMainThread()
+        objCDatabaseSnapshotDelegate.databaseSnapshotWillUpdate()
+    }
+
+    func databaseSnapshotDidUpdate() {
+        AssertIsOnMainThread()
+        objCDatabaseSnapshotDelegate.databaseSnapshotDidUpdate()
+    }
+
+    func databaseSnapshotDidUpdateExternally() {
+        AssertIsOnMainThread()
+        objCDatabaseSnapshotDelegate.databaseSnapshotDidUpdateExternally()
+    }
+}
diff --git a/SignalMessaging/utils/Weak.swift b/SignalServiceKit/src/Util/Weak.swift
similarity index 100%
rename from SignalMessaging/utils/Weak.swift
rename to SignalServiceKit/src/Util/Weak.swift
