diff --git a/Signal/src/ViewControllers/Call/CallViewController.swift b/Signal/src/ViewControllers/Call/CallViewController.swift
index ad42367e5fa..69211d17a1a 100644
--- a/Signal/src/ViewControllers/Call/CallViewController.swift
+++ b/Signal/src/ViewControllers/Call/CallViewController.swift
@@ -274,11 +274,10 @@ class CallViewController: OWSViewController, CallObserver, CallServiceObserver,
     func createViews() {
         view.isUserInteractionEnabled = true
 
-        tapGesture.delegate = self
         view.addGestureRecognizer(tapGesture)
-
+        localVideoView.addGestureRecognizer(panGesture)
         panGesture.delegate = self
-        view.addGestureRecognizer(panGesture)
+        tapGesture.require(toFail: panGesture)
 
         // The callee's avatar is rendered behind the blurred background.
         backgroundAvatarView.contentMode = .scaleAspectFill
@@ -598,48 +597,7 @@ class CallViewController: OWSViewController, CallObserver, CallServiceObserver,
         return [.idle, .dialing, .remoteRinging].contains(call.state) && !localVideoView.isHidden
     }
 
-    private func nearestValidLocalVideoFrame(for origin: CGPoint) -> CGRect {
-        var newFrame = CGRect(
-            origin: origin,
-            size: ReturnToCallViewController.pipSize
-        )
-
-        let boundingRect = localVideoBoundingRect
-
-        // If the origin is zero, we always want to position
-        // the pip in the top right
-        let hasZeroOrigin = newFrame.origin == .zero
-
-        // If we're positioned outside of the vertical bounds, we
-        // want to position the pip at the nearest bound
-        let positionedOutOfVerticalBounds = newFrame.minY < boundingRect.minY || newFrame.maxY > boundingRect.maxY
-
-        // If we're position anywhere but exactly at the horizontal
-        // edges, we want to position the pip at the nearest edge
-        let positionedAwayFromHorizontalEdges = boundingRect.minX != newFrame.minX && boundingRect.maxX != newFrame.maxX
-
-        if positionedOutOfVerticalBounds {
-            if newFrame.minY < boundingRect.minY || hasZeroOrigin {
-                newFrame.origin.y = boundingRect.minY
-            } else {
-                newFrame.origin.y = boundingRect.maxY - newFrame.height
-            }
-        }
-
-        if positionedAwayFromHorizontalEdges {
-            let distanceFromLeading = newFrame.minX - boundingRect.minX
-            let distanceFromTrailing = boundingRect.maxX - newFrame.maxX
-
-            if distanceFromLeading > distanceFromTrailing || hasZeroOrigin {
-                newFrame.origin.x = boundingRect.maxX - newFrame.width
-            } else {
-                newFrame.origin.x = boundingRect.minX
-            }
-        }
-
-        return newFrame
-    }
-
+    private var previousOrigin: CGPoint!
     private func updateLocalVideoLayout() {
         guard localVideoView.superview == view else { return }
 
@@ -649,13 +607,22 @@ class CallViewController: OWSViewController, CallObserver, CallServiceObserver,
             return
         }
 
-        let newFrame: CGRect
-        if !localVideoView.isHidden {
-            newFrame = nearestValidLocalVideoFrame(for: localVideoView.frame.origin)
-        } else {
-            newFrame = .zero
+        guard !localVideoView.isHidden else { return }
+
+        // Prefer to start in the top right
+        if previousOrigin == nil {
+            previousOrigin = CGPoint(
+                x: localVideoBoundingRect.maxX - ReturnToCallViewController.pipSize.width,
+                y: localVideoBoundingRect.minY
+            )
         }
 
+        let newFrame = CGRect(
+            origin: previousOrigin,
+            size: ReturnToCallViewController.pipSize
+        ).pinnedToVerticalEdge(of: localVideoBoundingRect)
+        previousOrigin = newFrame.origin
+
         UIView.animate(withDuration: 0.25) { self.localVideoView.frame = newFrame }
     }
 
@@ -663,31 +630,17 @@ class CallViewController: OWSViewController, CallObserver, CallServiceObserver,
     @objc func handleLocalVideoPan(sender: UIPanGestureRecognizer) {
         switch sender.state {
         case .began, .changed:
-            let translation = sender.translation(in: view)
-            sender.setTranslation(.zero, in: view)
+            let translation = sender.translation(in: localVideoView)
+            sender.setTranslation(.zero, in: localVideoView)
 
             localVideoView.frame.origin.y += translation.y
             localVideoView.frame.origin.x += translation.x
         case .ended, .cancelled, .failed:
-            let velocity = sender.velocity(in: view)
-
-            // TODO: maybe do more sophisticated deceleration
-
-            let duration: CGFloat = 0.35
-
-            let additionalDistanceX = velocity.x * duration
-            let additionalDistanceY = velocity.y * duration
-
-            let finalDestination = CGPoint(
-                x: localVideoView.frame.origin.x + additionalDistanceX,
-                y: localVideoView.frame.origin.y + additionalDistanceY
-            )
-
-            let finalFrame = nearestValidLocalVideoFrame(for: finalDestination)
-
-            UIView.animate(withDuration: TimeInterval(duration)) {
-                self.localVideoView.frame = finalFrame
-            }
+            localVideoView.animateDecelerationToVerticalEdge(
+                withDuration: 0.35,
+                velocity: sender.velocity(in: localVideoView),
+                boundingRect: localVideoBoundingRect
+            ) { _ in self.previousOrigin = self.localVideoView.frame.origin }
         default:
             break
         }
@@ -1433,14 +1386,7 @@ private class CallButton: UIButton {
 
 extension CallViewController: UIGestureRecognizerDelegate {
     func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
-        let isInLocalVideoView = localVideoView.bounds.contains(gestureRecognizer.location(in: localVideoView))
-
-        if gestureRecognizer == panGesture {
-            guard !localVideoView.isHidden, call.state == .connected else { return false }
-            return isInLocalVideoView
-        } else {
-            return !isInLocalVideoView
-        }
+        return !localVideoView.isHidden && localVideoView.superview == view && call.state == .connected
     }
 }
 
@@ -1470,6 +1416,8 @@ extension CallViewController: CallViewControllerWindowReference {
 
         view.insertSubview(localVideoView, aboveSubview: contactAvatarContainerView)
 
+        updateLocalVideoLayout()
+
         shouldRemoteVideoControlsBeHidden = false
 
         animateReturnFromPip(pipSnapshot: pipSnapshot, pipFrame: pipWindow.frame, splitViewSnapshot: splitViewSnapshot)
diff --git a/SignalMessaging/ViewControllers/ReturnToCallViewController.swift b/SignalMessaging/ViewControllers/ReturnToCallViewController.swift
index c6bac648ec3..c135e58ad6d 100644
--- a/SignalMessaging/ViewControllers/ReturnToCallViewController.swift
+++ b/SignalMessaging/ViewControllers/ReturnToCallViewController.swift
@@ -9,7 +9,7 @@ public protocol CallViewControllerWindowReference: class {
     var localVideoViewReference: UIView { get }
     var remoteVideoViewReference: UIView { get }
     var thread: TSContactThread { get }
-    var view: UIView { get }
+    var view: UIView! { get }
 
     func returnFromPip(pipWindow: UIWindow)
 }
@@ -110,7 +110,10 @@ public class ReturnToCallViewController: UIViewController {
 
         UIView.animate(withDuration: 0.2, animations: {
             snapshot.alpha = 0
-            window.frame = self.nearestValidPipFrame(for: previousOrigin)
+            window.frame = CGRect(
+                origin: previousOrigin,
+                size: Self.pipSize
+            ).pinnedToVerticalEdge(of: self.pipBoundingRect)
             window.layoutIfNeeded()
         }) { _ in
             snapshot.removeFromSuperview()
@@ -136,52 +139,15 @@ public class ReturnToCallViewController: UIViewController {
         return rect
     }
 
-    private func nearestValidPipFrame(for origin: CGPoint) -> CGRect {
-        var newFrame = CGRect(origin: origin, size: Self.pipSize)
-
-        let boundingRect = pipBoundingRect
-
-        // If the origin is zero, we always want to position
-        // the pip in the top right
-        let hasZeroOrigin = newFrame.origin == .zero
-
-        // If we're positioned outside of the vertical bounds, we
-        // want to position the pip at the nearest bound
-        let positionedOutOfVerticalBounds = newFrame.minY < boundingRect.minY || newFrame.maxY > boundingRect.maxY
-
-        // If we're position anywhere but exactly at the horizontal
-        // edges, we want to position the pip at the nearest edge
-        let positionedAwayFromHorizontalEdges = boundingRect.minX != newFrame.minX && boundingRect.maxX != newFrame.maxX
-
-        if positionedOutOfVerticalBounds {
-            if newFrame.minY < boundingRect.minY || hasZeroOrigin {
-                newFrame.origin.y = boundingRect.minY
-            } else {
-                newFrame.origin.y = boundingRect.maxY - newFrame.height
-            }
-        }
-
-        if positionedAwayFromHorizontalEdges {
-            let distanceFromLeading = newFrame.minX - boundingRect.minX
-            let distanceFromTrailing = boundingRect.maxX - newFrame.maxX
-
-            if distanceFromLeading > distanceFromTrailing || hasZeroOrigin {
-                newFrame.origin.x = boundingRect.maxX - newFrame.width
-            } else {
-                newFrame.origin.x = boundingRect.minX
-            }
-        }
-
-        return newFrame
-    }
-
     private func updatePipLayout() {
         guard let window = view.window else { return owsFailDebug("missing window") }
-        let newFrame = nearestValidPipFrame(for: window.frame.origin)
+        let newFrame = CGRect(
+            origin: window.frame.origin,
+            size: Self.pipSize
+        ).pinnedToVerticalEdge(of: pipBoundingRect)
         UIView.animate(withDuration: 0.25) { window.frame = newFrame }
     }
 
-    private var startingTranslation: CGPoint?
     @objc func handlePan(sender: UIPanGestureRecognizer) {
         guard let window = view.window else { return owsFailDebug("missing window") }
 
@@ -193,23 +159,11 @@ public class ReturnToCallViewController: UIViewController {
             window.frame.origin.y += translation.y
             window.frame.origin.x += translation.x
         case .ended, .cancelled, .failed:
-            let velocity = sender.velocity(in: window)
-
-            // TODO: maybe do more sophisticated deceleration
-
-            let duration: CGFloat = 0.35
-
-            let additionalDistanceX = velocity.x * duration
-            let additionalDistanceY = velocity.y * duration
-
-            let finalDestination = CGPoint(
-                x: window.frame.origin.x + additionalDistanceX,
-                y: window.frame.origin.y + additionalDistanceY
+            window.animateDecelerationToVerticalEdge(
+                withDuration: 0.35,
+                velocity: sender.velocity(in: window),
+                boundingRect: pipBoundingRect
             )
-
-            let finalFrame = nearestValidPipFrame(for: finalDestination)
-
-            UIView.animate(withDuration: TimeInterval(duration)) { window.frame = finalFrame }
         default:
             break
         }
diff --git a/SignalMessaging/categories/UIView+OWS.swift b/SignalMessaging/categories/UIView+OWS.swift
index 4b98547b815..4fa2f3b7838 100644
--- a/SignalMessaging/categories/UIView+OWS.swift
+++ b/SignalMessaging/categories/UIView+OWS.swift
@@ -161,6 +161,81 @@ public extension UIView {
     func setAccessibilityIdentifier(in container: NSObject, name: String) {
         self.accessibilityIdentifier = UIView.accessibilityIdentifier(in: container, name: name)
     }
+
+    func animateDecelerationToVerticalEdge(
+        withDuration duration: TimeInterval,
+        velocity: CGPoint,
+        velocityThreshold: CGFloat = 500,
+        boundingRect: CGRect,
+        completion: ((Bool) -> Void)? = nil
+    ) {
+        var velocity = velocity
+        if abs(velocity.x) < velocityThreshold { velocity.x = 0 }
+        if abs(velocity.y) < velocityThreshold { velocity.y = 0 }
+
+        let currentPosition = frame.origin
+
+        let referencePoint: CGPoint
+        if velocity != .zero {
+            // Calculate the time until we intersect with each edge with
+            // a constant velocity.
+
+            // time = (end position - start positon) / velocity
+
+            let timeUntilVerticalEdge: CGFloat
+            if velocity.x > 0 {
+                timeUntilVerticalEdge = ((boundingRect.maxX - width) - currentPosition.x) / velocity.x
+            } else if velocity.x < 0 {
+                timeUntilVerticalEdge = (boundingRect.minX - currentPosition.x) / velocity.x
+            } else {
+                timeUntilVerticalEdge = .greatestFiniteMagnitude
+            }
+
+            let timeUntilHorizontalEdge: CGFloat
+            if velocity.y > 0 {
+                timeUntilHorizontalEdge = ((boundingRect.maxY - height) - currentPosition.y) / velocity.y
+            } else if velocity.y < 0 {
+                timeUntilHorizontalEdge = (boundingRect.minY - currentPosition.y) / velocity.y
+            } else {
+                timeUntilHorizontalEdge = .greatestFiniteMagnitude
+            }
+
+            // See which edge we intersect with first and calculate the position
+            // on the other axis when we reach that intersection point.
+
+            // end position = (time * velocity) + start position
+
+            let intersectPoint: CGPoint
+            if timeUntilHorizontalEdge > timeUntilVerticalEdge {
+                intersectPoint = CGPoint(
+                    x: velocity.x > 0 ? (boundingRect.maxX - width) : boundingRect.minX,
+                    y: (timeUntilVerticalEdge * velocity.y) + currentPosition.y
+                )
+            } else {
+                intersectPoint = CGPoint(
+                    x: (timeUntilHorizontalEdge * velocity.x) + currentPosition.x,
+                    y: velocity.y > 0 ? (boundingRect.maxY - height) : boundingRect.minY
+                )
+            }
+
+            referencePoint = intersectPoint
+        } else {
+            referencePoint = currentPosition
+        }
+
+        let destinationFrame = CGRect(origin: referencePoint, size: frame.size).pinnedToVerticalEdge(of: boundingRect)
+        let distance = destinationFrame.origin.distance(currentPosition)
+
+        UIView.animate(
+            withDuration: duration,
+            delay: 0,
+            usingSpringWithDamping: 1,
+            initialSpringVelocity: abs(velocity.length / distance),
+            options: .curveEaseOut,
+            animations: { self.frame = destinationFrame },
+            completion: completion
+        )
+    }
 }
 
 // MARK: -
@@ -346,6 +421,43 @@ public extension CGRect {
     var bottomRight: CGPoint {
         return CGPoint(x: maxX, y: maxY)
     }
+
+    func pinnedToVerticalEdge(of boundingRect: CGRect) -> CGRect {
+        var newRect = self
+
+        // If we're positioned outside of the vertical bounds,
+        // we need to move to the nearest bound
+        let positionedOutOfVerticalBounds = newRect.minY < boundingRect.minY || newRect.maxY > boundingRect.maxY
+
+        // If we're position anywhere but exactly at the vertical
+        // edges (left and right of bounding rect), we need to
+        // move to the nearest edge
+        let positionedAwayFromVerticalEdges = boundingRect.minX != newRect.minX && boundingRect.maxX != newRect.maxX
+
+        if positionedOutOfVerticalBounds {
+            let distanceFromTop = newRect.minY - boundingRect.minY
+            let distanceFromBottom = boundingRect.maxY - newRect.maxY
+
+            if distanceFromTop > distanceFromBottom {
+                newRect.origin.y = boundingRect.maxY - newRect.height
+            } else {
+                newRect.origin.y = boundingRect.minY
+            }
+        }
+
+        if positionedAwayFromVerticalEdges {
+            let distanceFromLeading = newRect.minX - boundingRect.minX
+            let distanceFromTrailing = boundingRect.maxX - newRect.maxX
+
+            if distanceFromLeading > distanceFromTrailing {
+                newRect.origin.x = boundingRect.maxX - newRect.width
+            } else {
+                newRect.origin.x = boundingRect.minX
+            }
+        }
+
+        return newRect
+    }
 }
 
 // MARK: -
