diff --git a/Pods b/Pods
index 907abdd7b64..ee280dcf4e4 160000
--- a/Pods
+++ b/Pods
@@ -1 +1 @@
-Subproject commit 907abdd7b64e0a303ce4951c16bb1836808722a1
+Subproject commit ee280dcf4e454f9d3f78651e8756ad3ae964f847
diff --git a/Scripts/sds_codegen/sds_config/sds-property_order.json b/Scripts/sds_codegen/sds_config/sds-property_order.json
index 49654aa78e7..f3e0d7e63f4 100644
--- a/Scripts/sds_codegen/sds_config/sds-property_order.json
+++ b/Scripts/sds_codegen/sds_config/sds-property_order.json
@@ -141,6 +141,9 @@
     "JobRecordRecord.isMediaMessage": 12,
     "JobRecordRecord.label": 2,
     "JobRecordRecord.messageId": 8,
+    "JobRecordRecord.messageText": 27,
+    "JobRecordRecord.paymentIntentClientSecret": 28,
+    "JobRecordRecord.paymentMethodId": 29,
     "JobRecordRecord.priorSubscriptionLevel": 18,
     "JobRecordRecord.receiptCredentailRequest": 16,
     "JobRecordRecord.receiptCredentailRequestContext": 17,
@@ -266,4 +269,4 @@
     "UserProfileRecord.recipientPhoneNumber": 5,
     "UserProfileRecord.recipientUUID": 6,
     "UserProfileRecord.username": 7
-}
\ No newline at end of file
+}
diff --git a/Scripts/sds_codegen/sds_config/sds_record_type_map.json b/Scripts/sds_codegen/sds_config/sds_record_type_map.json
index d7896e653fc..904d815f04c 100644
--- a/Scripts/sds_codegen/sds_config/sds_record_type_map.json
+++ b/Scripts/sds_codegen/sds_config/sds_record_type_map.json
@@ -35,6 +35,7 @@
     "OWSRecipientIdentity": 38,
     "OWSRecoverableDecryptionPlaceholder": 70,
     "OWSResaveCollectionDBMigration": 49,
+    "OWSSendGiftBadgeJobRecord": 73,
     "OWSSessionResetJobRecord": 52,
     "OWSUnknownContactBlockOfferMessage": 5,
     "OWSUnknownDBObject": 37,
diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 9e2b84cae49..40143f7452c 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -1047,6 +1047,7 @@
 		F973DFBA0991C967C4934B08 /* Pods_SignalUITests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = BD0D81F9D93CB5BADE6B9709 /* Pods_SignalUITests.framework */; };
 		F97A2EEA282578C000610669 /* BadgeExpirationSheetStateTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F97A2EE828247C1300610669 /* BadgeExpirationSheetStateTest.swift */; };
 		F9844C492867936400B16DD4 /* SignalMeTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9844C482867936400B16DD4 /* SignalMeTest.swift */; };
+		F98EA265286A469100791EB4 /* SendGiftBadgeJobQueue.swift in Sources */ = {isa = PBXBuildFile; fileRef = F98EA264286A469100791EB4 /* SendGiftBadgeJobQueue.swift */; };
 		F9A335CA282F0BF700B5F5FA /* BadgeGiftingChooseBadgeViewControllerStateTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9A335C9282F0BF700B5F5FA /* BadgeGiftingChooseBadgeViewControllerStateTest.swift */; };
 		F9A335CC282F0DEC00B5F5FA /* BadgeGiftingChooseRecipientViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9A335CB282F0DEC00B5F5FA /* BadgeGiftingChooseRecipientViewController.swift */; };
 		F9A8ACC7280A175E00AFC6A7 /* DonationViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = F9A8ACC6280A175E00AFC6A7 /* DonationViewController.swift */; };
@@ -2498,6 +2499,7 @@
 		F965C5B87BFDF8F86556C04C /* Pods-SignalNSE.profiling.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalNSE.profiling.xcconfig"; path = "Pods/Target Support Files/Pods-SignalNSE/Pods-SignalNSE.profiling.xcconfig"; sourceTree = "<group>"; };
 		F97A2EE828247C1300610669 /* BadgeExpirationSheetStateTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeExpirationSheetStateTest.swift; sourceTree = "<group>"; };
 		F9844C482867936400B16DD4 /* SignalMeTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SignalMeTest.swift; sourceTree = "<group>"; };
+		F98EA264286A469100791EB4 /* SendGiftBadgeJobQueue.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SendGiftBadgeJobQueue.swift; sourceTree = "<group>"; };
 		F9A335C9282F0BF700B5F5FA /* BadgeGiftingChooseBadgeViewControllerStateTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeGiftingChooseBadgeViewControllerStateTest.swift; sourceTree = "<group>"; };
 		F9A335CB282F0DEC00B5F5FA /* BadgeGiftingChooseRecipientViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BadgeGiftingChooseRecipientViewController.swift; sourceTree = "<group>"; };
 		F9A8ACC6280A175E00AFC6A7 /* DonationViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DonationViewController.swift; sourceTree = "<group>"; };
@@ -3860,6 +3862,7 @@
 				3461293F1FD1D74B00532771 /* environment */,
 				34BB3C5723C6644B001651FC /* groups */,
 				453518951FC63DBF00210559 /* Info.plist */,
+				F98EA263286A464500791EB4 /* Donations */,
 				88D23D0823CEBF4400B0E74B /* Notifications */,
 				3474C56526111605006723D2 /* Payments */,
 				346129B01FD1F7E800532771 /* profiles */,
@@ -4858,6 +4861,14 @@
 			path = "Context Menus";
 			sourceTree = "<group>";
 		};
+		F98EA263286A464500791EB4 /* Donations */ = {
+			isa = PBXGroup;
+			children = (
+				F98EA264286A469100791EB4 /* SendGiftBadgeJobQueue.swift */,
+			);
+			path = Donations;
+			sourceTree = "<group>";
+		};
 		F9C5BC5F282E98D4001EB3BF /* Donations */ = {
 			isa = PBXGroup;
 			children = (
@@ -6173,6 +6184,7 @@
 				454A965A1FD6017E008D2A0E /* SignalAttachment.swift in Sources */,
 				3461295B1FD1D74C00532771 /* Environment.m in Sources */,
 				883A7FD2269F642F00841DF9 /* AvatarModel.swift in Sources */,
+				F98EA265286A469100791EB4 /* SendGiftBadgeJobQueue.swift in Sources */,
 				34BB3C5D23C6644B001651FC /* GroupsV2Utils.swift in Sources */,
 				34BB3C6023C6644B001651FC /* GroupV2Params.swift in Sources */,
 				3474C57526111605006723D2 /* PaymentsCurrenciesImpl.swift in Sources */,
diff --git a/Signal/src/ViewControllers/AppSettings/Donations/BadgeGiftingConfirmationViewController.swift b/Signal/src/ViewControllers/AppSettings/Donations/BadgeGiftingConfirmationViewController.swift
index 76167ff4d05..602181c938a 100644
--- a/Signal/src/ViewControllers/AppSettings/Donations/BadgeGiftingConfirmationViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/Donations/BadgeGiftingConfirmationViewController.swift
@@ -5,8 +5,6 @@
 import Foundation
 import UIKit
 import PassKit
-import SignalUI
-import LibSignalClient
 
 class BadgeGiftingConfirmationViewController: OWSTableViewController2 {
     // MARK: - View state
@@ -387,81 +385,188 @@ extension BadgeGiftingConfirmationViewController: TextViewWithPlaceholderDelegat
 // MARK: - Apple Pay delegate
 
 extension BadgeGiftingConfirmationViewController: PKPaymentAuthorizationControllerDelegate {
+    private struct PreparedPayment {
+        let paymentIntent: Stripe.PaymentIntent
+        let paymentMethodId: String
+    }
+
+    enum SendGiftBadgeError: Error {
+        case failedAndUserNotCharged
+        case failedAndUserMaybeCharged
+        case userClosedBeforeChargeCompleted
+    }
+
+    private func prepareToPay(authorizedPayment: PKPayment) -> Promise<PreparedPayment> {
+        firstly {
+            Stripe.createBoostPaymentIntent(for: NSDecimalNumber(value: self.price), in: self.currencyCode, level: .giftBadge)
+        }.then { paymentIntent in
+            Stripe.createPaymentMethod(with: authorizedPayment).map { paymentMethodId in
+                PreparedPayment(paymentIntent: paymentIntent, paymentMethodId: paymentMethodId)
+            }
+        }
+    }
+
     func paymentAuthorizationController(
         _ controller: PKPaymentAuthorizationController,
         didAuthorizePayment payment: PKPayment,
         handler completion: @escaping (PKPaymentAuthorizationResult) -> Void
     ) {
-        var hasChargeCompleted = false
-
-        let priceAsDecimal = NSDecimalNumber(value: price)
-
-        firstly(on: .global()) {
-            Stripe.boost(amount: priceAsDecimal, in: self.currencyCode, level: .giftBadge, for: payment)
-        }.then { (intentId: String) -> Promise<ReceiptCredentialPresentation> in
-            hasChargeCompleted = true
-
-            // TODO (GB): Make this operation durable.
-            let (receiptCredentialRequestContext, receiptCredentialRequest) = try SubscriptionManager.generateReceiptRequest()
-            return try SubscriptionManager.requestBoostReceiptCredentialPresentation(
-                for: intentId,
-                context: receiptCredentialRequestContext,
-                request: receiptCredentialRequest,
-                expectedBadgeLevel: .giftBadge
-            )
-        }.then { (receiptCredentialPresentation: ReceiptCredentialPresentation) -> Promise<Void> in
-            self.databaseStorage.write { transaction -> Promise<Void> in
-                func send(_ preparer: OutgoingMessagePreparer) -> Promise<Void> {
-                    preparer.insertMessage(transaction: transaction)
-                    return ThreadUtil.enqueueMessagePromise(message: preparer.unpreparedMessage,
-                                                            transaction: transaction)
+        var hasCalledCompletion = false
+        func wrappedCompletion(_ result: PKPaymentAuthorizationResult) {
+            guard !hasCalledCompletion else { return }
+            hasCalledCompletion = true
+            completion(result)
+        }
+
+        firstly(on: .global()) { () -> Promise<PreparedPayment> in
+            // Bail if the user is already sending a gift to this person. This unusual case can happen if:
+            //
+            // 1. The user enqueues a "send gift badge" job for this recipient
+            // 2. The app is terminated (e.g., due to a crash)
+            // 3. Before the job finishes, the user restarts the app and tries to gift another badge to the same person
+            //
+            // This *could* happen without a Signal developer making a mistake, if the app is terminated at the right time.
+            let isAlreadyGifting = self.databaseStorage.read {
+                DonationUtilities.sendGiftBadgeJobQueue.alreadyHasJob(for: self.thread, transaction: $0)
+            }
+            guard !isAlreadyGifting else {
+                Logger.warn("Already sending a gift to this recipient")
+                throw SendGiftBadgeError.failedAndUserNotCharged
+            }
+
+            // Prepare to pay. We haven't charged the user yet, so we don't need to do anything durably,
+            // e.g. a job.
+            return firstly { () -> Promise<PreparedPayment> in
+                self.prepareToPay(authorizedPayment: payment)
+            }.timeout(seconds: 30) {
+                Logger.warn("Timed out after preparing gift badge payment")
+                return SendGiftBadgeError.failedAndUserNotCharged
+            }.recover(on: .global()) { error -> Promise<PreparedPayment> in
+                if !(error is SendGiftBadgeError) { owsFailDebugUnlessNetworkFailure(error) }
+                throw SendGiftBadgeError.failedAndUserNotCharged
+            }
+        }.then { [weak self] preparedPayment -> Promise<Void> in
+            guard let self = self else { throw SendGiftBadgeError.userClosedBeforeChargeCompleted }
+
+            // Durably enqueue a job to (1) do the charge (2) redeem the receipt credential (3) enqueue
+            // a gift badge message (and optionally a text message) to the recipient. We also want to
+            // update the UI partway through the job's execution, and when it completes.
+            let jobRecord = SendGiftBadgeJobQueue.createJob(receiptRequest: try SubscriptionManager.generateReceiptRequest(),
+                                                            amount: self.price,
+                                                            currencyCode: self.currencyCode,
+                                                            paymentIntent: preparedPayment.paymentIntent,
+                                                            paymentMethodId: preparedPayment.paymentMethodId,
+                                                            thread: self.thread,
+                                                            messageText: self.messageText)
+            let jobId = jobRecord.uniqueId
+
+            let (promise, future) = Promise<Void>.pending()
+
+            var modalActivityIndicatorViewController: ModalActivityIndicatorViewController?
+            var shouldDismissActivityIndicator = false
+            var hasCharged = false
+
+            // The happy path is two steps: payment method is charged (showing a spinner), then job finishes (opening the chat).
+            //
+            // The valid sad paths are:
+            // 1. We started charging the card but we don't know whether it succeeded before the job failed
+            // 2. The card is "definitively" charged, but then the job fails
+            //
+            // There are some invalid sad paths that we try to handle, but those indicate Signal bugs.
+            let observer = NotificationCenter.default.addObserver(forName: SendGiftBadgeJobQueue.JobEventNotification,
+                                                                  object: nil,
+                                                                  queue: .main) { notification in
+                guard let userInfo = notification.userInfo,
+                      let notificationJobId = userInfo["jobId"] as? String,
+                      let rawJobEvent = userInfo["jobEvent"] as? Int,
+                      let jobEvent = SendGiftBadgeJobQueue.JobEvent(rawValue: rawJobEvent) else {
+                    owsFail("Received a gift badge job event with invalid user data")
+                }
+                guard notificationJobId == jobId else {
+                    // This can happen if:
+                    //
+                    // 1. The user enqueues a "send gift badge" job
+                    // 2. The app terminates before it can complete (e.g., due to a crash)
+                    // 3. Before the job finishes, the user restarts the app and tries to gift another badge
+                    //
+                    // This is unusual and may indicate a bug, so we log, but we don't error/crash because it can happen under "normal" circumstances.
+                    Logger.warn("Received an event for a different badge gifting job.")
+                    return
                 }
 
-                let giftMessagePromise = send(OutgoingMessagePreparer(
-                    giftBadgeReceiptCredentialPresentation: receiptCredentialPresentation,
-                    thread: self.thread,
-                    transaction: transaction
-                ))
+                switch jobEvent {
+                case .jobFailed:
+                    future.reject(SendGiftBadgeError.failedAndUserMaybeCharged)
+                case .chargeSucceeded:
+                    guard !hasCharged else {
+                        // This job event can be emitted twice if the job fails (e.g., due to network) after the payment method is charged, and then it's restarted.
+                        // That's unusual, but isn't necessarily a bug.
+                        Logger.warn("Received a \"charge succeeded\" event more than once")
+                        break
+                    }
+                    hasCharged = true
+                    wrappedCompletion(.init(status: .success, errors: nil))
+                    controller.dismiss()
+                    ModalActivityIndicatorViewController.present(fromViewController: self, canCancel: false) { modal in
+                        DispatchQueue.main.async {
+                            modalActivityIndicatorViewController = modal
+                            // Depending on how things are dispatched, we could need the modal closed immediately.
+                            if shouldDismissActivityIndicator {
+                                modal.dismiss {}
+                            }
+                        }
+                    }
+                case .jobSucceeded:
+                    future.resolve(())
+                }
+            }
+
+            self.databaseStorage.write { transaction in
+                DonationUtilities.sendGiftBadgeJobQueue.addJob(jobRecord, transaction: transaction)
+            }
 
-                let messagesPromise: Promise<Void>
-                if self.messageText.isEmpty {
-                    messagesPromise = giftMessagePromise
+            func finish() {
+                NotificationCenter.default.removeObserver(observer)
+                if let modalActivityIndicatorViewController = modalActivityIndicatorViewController {
+                    modalActivityIndicatorViewController.dismiss {}
                 } else {
-                    let textMessagePromise = send(OutgoingMessagePreparer(
-                        messageBody: MessageBody(text: self.messageText, ranges: .empty),
-                        thread: self.thread,
-                        transaction: transaction
-                    ))
-                    messagesPromise = giftMessagePromise.then { textMessagePromise }
+                    shouldDismissActivityIndicator = true
                 }
+            }
 
-                return messagesPromise.asVoid()
+            return promise.done(on: .main) {
+                owsAssertDebug(hasCharged, "Expected \"charge succeeded\" event")
+                // We shouldn't need to dismiss the Apple Pay sheet here, but if the `chargeSucceeded` event was missed, we do our best.
+                wrappedCompletion(.init(status: .success, errors: nil))
+                finish()
+            }.recover(on: .main) { error in
+                wrappedCompletion(.init(status: .failure, errors: [error]))
+                finish()
+                throw error
             }
-        }.done(on: .main) {
-            completion(.init(status: .success, errors: nil))
+        }.done { [weak self] in
+            guard let self = self else { return }
             SignalApp.shared().presentConversation(for: self.thread, action: .none, animated: false)
             self.dismiss(animated: true)
-            controller.dismiss()
-        }.catch(on: .main) { error in
-            owsFailDebugUnlessNetworkFailure(error)
-
-            completion(.init(status: .failure, errors: [error]))
-
-            let title: String
-            let message: String
-            if hasChargeCompleted {
-                title = NSLocalizedString("BADGE_GIFTING_PAYMENT_SUCCEEDED_BUT_GIFTING_FAILED_TITLE",
-                                          comment: "Title for the action sheet when you try to send a gift badge. They were charged but the badge could not be sent. They should contact support.")
-                message = NSLocalizedString("BADGE_GIFTING_PAYMENT_SUCCEEDED_BUT_GIFTING_FAILED_BODY",
-                                            comment: "Text in the action sheet when you try to send a gift badge. They were charged but the badge could not be sent. They should contact support.")
-            } else {
-                title = NSLocalizedString("BADGE_GIFTING_PAYMENT_FAILED_TITLE",
-                                          comment: "Title for the action sheet when you try to send a gift badge but the payment failed")
-                message = NSLocalizedString("BADGE_GIFTING_PAYMENT_FAILED_BODY",
-                                            comment: "Text in the action sheet when you try to send a gift badge but the payment failed. Tells the user that they have not been charged")
+        }.catch { error in
+            guard let error = error as? SendGiftBadgeError else {
+                owsFail("\(error)")
             }
 
-            OWSActionSheets.showActionSheet(title: title, message: message)
+            switch error {
+            case .userClosedBeforeChargeCompleted:
+                break
+            case .failedAndUserNotCharged:
+                OWSActionSheets.showActionSheet(title: NSLocalizedString("BADGE_GIFTING_PAYMENT_FAILED_TITLE",
+                                                                         comment: "Title for the action sheet when you try to send a gift badge but the payment failed"),
+                                                message: NSLocalizedString("BADGE_GIFTING_PAYMENT_FAILED_BODY",
+                                                                           comment: "Text in the action sheet when you try to send a gift badge but the payment failed. Tells the user that they have not been charged"))
+            case .failedAndUserMaybeCharged:
+                OWSActionSheets.showActionSheet(title: NSLocalizedString("BADGE_GIFTING_PAYMENT_SUCCEEDED_BUT_GIFTING_FAILED_TITLE",
+                                                                         comment: "Title for the action sheet when you try to send a gift badge. They were charged but the badge could not be sent. They should contact support."),
+                                                message: NSLocalizedString("BADGE_GIFTING_PAYMENT_SUCCEEDED_BUT_GIFTING_FAILED_BODY",
+                                                                           comment: "Text in the action sheet when you try to send a gift badge. They were charged but the badge could not be sent. They should contact support."))
+            }
         }
     }
 
@@ -469,19 +574,3 @@ extension BadgeGiftingConfirmationViewController: PKPaymentAuthorizationControll
         controller.dismiss()
     }
 }
-
-// MARK: - Outgoing message preparer
-
-extension OutgoingMessagePreparer {
-    public convenience init(giftBadgeReceiptCredentialPresentation: ReceiptCredentialPresentation,
-                            thread: TSThread,
-                            transaction: SDSAnyReadTransaction) {
-        let message = TSOutgoingMessageBuilder(
-            thread: thread,
-            expiresInSeconds: thread.disappearingMessagesDuration(with: transaction),
-            giftBadge: OWSGiftBadge(redemptionCredential: Data(giftBadgeReceiptCredentialPresentation.serialize()))
-        ).build(transaction: transaction)
-
-        self.init(message)
-    }
-}
diff --git a/SignalMessaging/Donations/SendGiftBadgeJobQueue.swift b/SignalMessaging/Donations/SendGiftBadgeJobQueue.swift
new file mode 100644
index 00000000000..1e0164f6a56
--- /dev/null
+++ b/SignalMessaging/Donations/SendGiftBadgeJobQueue.swift
@@ -0,0 +1,296 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDB
+import SignalServiceKit
+import LibSignalClient
+
+// MARK: - Job queue
+
+public class SendGiftBadgeJobQueue: NSObject, JobQueue {
+    public typealias DurableOperationType = SendGiftBadgeOperation
+
+    @objc
+    public static let jobRecordLabel: String = "SendGiftBadge"
+    public var jobRecordLabel: String { Self.jobRecordLabel }
+
+    public static let maxRetries: UInt = 110
+    public let requiresInternet: Bool = true
+    public var isEnabled: Bool { CurrentAppContext().isMainApp }
+    public var runningOperations = AtomicArray<SendGiftBadgeOperation>()
+    public var isSetup = AtomicBool(false)
+
+    public enum JobEvent: Int {
+        case chargeSucceeded
+        case jobFailed
+        case jobSucceeded
+    }
+
+    public static let JobEventNotification = NSNotification.Name("SendGiftBadgeJobQueueJobEventNotification")
+
+    @objc
+    public override init() {
+        super.init()
+
+        AppReadiness.runNowOrWhenAppDidBecomeReadySync {
+            self.setup()
+        }
+    }
+
+    @objc
+    public func setup() {
+        defaultSetup()
+    }
+
+    public func didMarkAsReady(oldJobRecord: JobRecordType, transaction: SDSAnyWriteTransaction) {
+        // no special handling
+    }
+
+    let operationQueue: OperationQueue = {
+        let operationQueue = OperationQueue()
+        operationQueue.name = "SendGiftBadge.OperationQueue"
+        return operationQueue
+    }()
+
+    public func operationQueue(jobRecord: OWSSendGiftBadgeJobRecord) -> OperationQueue {
+        return self.operationQueue
+    }
+
+    public func buildOperation(jobRecord: OWSSendGiftBadgeJobRecord, transaction: SDSAnyReadTransaction) throws -> SendGiftBadgeOperation {
+        return try SendGiftBadgeOperation(jobRecord)
+    }
+
+    public static func createJob(receiptRequest: (context: ReceiptCredentialRequestContext, request: ReceiptCredentialRequest),
+                                 amount: UInt,
+                                 currencyCode: Currency.Code,
+                                 paymentIntent: Stripe.PaymentIntent,
+                                 paymentMethodId: String,
+                                 thread: TSContactThread,
+                                 messageText: String) -> OWSSendGiftBadgeJobRecord {
+        OWSSendGiftBadgeJobRecord(
+            receiptCredentialRequestContext: receiptRequest.context.serialize().asData,
+            receiptCredentialRequest: receiptRequest.request.serialize().asData,
+            amount: NSDecimalNumber(value: amount),
+            currencyCode: currencyCode,
+            paymentIntentClientSecret: paymentIntent.clientSecret,
+            paymentIntentId: paymentIntent.id,
+            paymentMethodId: paymentMethodId,
+            threadId: thread.uniqueId,
+            messageText: messageText,
+            label: self.jobRecordLabel
+        )
+    }
+
+    public func addJob(_ jobRecord: OWSSendGiftBadgeJobRecord, transaction: SDSAnyWriteTransaction) {
+        self.add(jobRecord: jobRecord, transaction: transaction)
+    }
+
+    public func alreadyHasJob(for thread: TSContactThread, transaction: SDSAnyReadTransaction) -> Bool {
+        SendGiftBadgeJobFinder.jobExists(forThreadId: thread.uniqueId, transaction: transaction)
+    }
+}
+
+// MARK: - Job finder
+
+private class SendGiftBadgeJobFinder {
+    public class func jobExists(forThreadId threadId: String, transaction: SDSAnyReadTransaction) -> Bool {
+        assert(!threadId.isEmpty)
+
+        switch transaction.readTransaction {
+        case .grdbRead(let grdbTransaction):
+            let sql = """
+                SELECT EXISTS (
+                    SELECT 1 FROM \(JobRecordRecord.databaseTableName)
+                    WHERE \(jobRecordColumn: .threadId) IS ?
+                    AND \(jobRecordColumn: .recordType) IS ?
+                    AND \(jobRecordColumn: .status) NOT IN (?, ?)
+                )
+            """
+            let arguments: StatementArguments = [
+                threadId,
+                SDSRecordType.sendGiftBadgeJobRecord.rawValue,
+                SSKJobRecordStatus.permanentlyFailed,
+                SSKJobRecordStatus.obsolete
+            ]
+            return try! Bool.fetchOne(grdbTransaction.database, sql: sql, arguments: arguments) ?? false
+        }
+    }
+}
+
+// MARK: - Operation
+
+public final class SendGiftBadgeOperation: OWSOperation, DurableOperation {
+    public var jobRecord: OWSSendGiftBadgeJobRecord
+
+    public typealias JobRecordType = OWSSendGiftBadgeJobRecord
+
+    public typealias DurableOperationDelegateType = SendGiftBadgeJobQueue
+
+    weak public var durableOperationDelegate: SendGiftBadgeJobQueue?
+
+    public var operation: OWSOperation { self }
+
+    private let receiptCredentialRequestContext: ReceiptCredentialRequestContext
+    private let receiptCredentialRequest: ReceiptCredentialRequest
+    private let amount: Decimal
+    private let currencyCode: Currency.Code
+    private let paymentIntentClientSecret: String
+    private let paymentIntentId: String
+    private let paymentMethodId: String
+    private let threadId: String
+    private let messageText: String
+
+    @objc
+    public required init(_ jobRecord: OWSSendGiftBadgeJobRecord) throws {
+        self.jobRecord = jobRecord
+        receiptCredentialRequestContext = try ReceiptCredentialRequestContext(contents: [UInt8](jobRecord.receiptCredentailRequestContext))
+        receiptCredentialRequest = try ReceiptCredentialRequest(contents: [UInt8](jobRecord.receiptCredentailRequest))
+        amount = jobRecord.amount as Decimal
+        currencyCode = jobRecord.currencyCode
+        paymentIntentClientSecret = jobRecord.paymentIntentClientSecret
+        paymentIntentId = jobRecord.boostPaymentIntentID
+        paymentMethodId = jobRecord.paymentMethodId
+        threadId = jobRecord.threadId
+        messageText = jobRecord.messageText
+    }
+
+    private func getValidatedThread(transaction: SDSAnyReadTransaction) throws -> TSContactThread {
+        guard let thread = TSThread.anyFetch(uniqueId: threadId, transaction: transaction) as? TSContactThread else {
+            throw JobError.obsolete(description: "Thread for gift badge sending no longer exists")
+        }
+        guard !blockingManager.isThreadBlocked(thread, transaction: transaction) else {
+            throw JobError.obsolete(description: "Thread for gift badge sending is blocked")
+        }
+        return thread
+    }
+
+    private func ensureThatWeCanStillMessageRecipient(transaction: SDSAnyReadTransaction) throws {
+        _ = try getValidatedThread(transaction: transaction)
+    }
+
+    private func postJobEventNotification(_ jobEvent: SendGiftBadgeJobQueue.JobEvent) {
+        NotificationCenter.default.postNotificationNameAsync(
+            SendGiftBadgeJobQueue.JobEventNotification,
+            object: nil,
+            userInfo: ["jobId": jobRecord.uniqueId, "jobEvent": jobEvent.rawValue]
+        )
+    }
+
+    private func confirmPaymentIntent() throws -> Promise<Void> {
+        try Stripe.confirmPaymentIntent(paymentIntentClientSecret: self.paymentIntentClientSecret,
+                                        paymentIntentId: self.paymentIntentId,
+                                        paymentMethodId: self.paymentMethodId,
+                                        idempotencyKey: self.jobRecord.uniqueId).asVoid()
+    }
+
+    private func getReceiptCredentialPresentation() throws -> Promise<ReceiptCredentialPresentation> {
+        try SubscriptionManager.requestBoostReceiptCredentialPresentation(
+            for: self.paymentIntentId,
+            context: self.receiptCredentialRequestContext,
+            request: self.receiptCredentialRequest,
+            expectedBadgeLevel: .giftBadge
+        )
+    }
+
+    private func enqueueMessages(receiptCredentialPresentation: ReceiptCredentialPresentation,
+                                 transaction: SDSAnyWriteTransaction) throws {
+        func send(_ preparer: OutgoingMessagePreparer) {
+            preparer.insertMessage(transaction: transaction)
+            self.messageSenderJobQueue.add(message: preparer, transaction: transaction)
+        }
+
+        let thread = try getValidatedThread(transaction: transaction)
+
+        send(OutgoingMessagePreparer(
+            giftBadgeReceiptCredentialPresentation: receiptCredentialPresentation,
+            thread: thread,
+            transaction: transaction
+        ))
+
+        if !self.messageText.isEmpty {
+            send(OutgoingMessagePreparer(
+                messageBody: self.messageText,
+                thread: thread,
+                transaction: transaction
+            ))
+        }
+    }
+
+    override public func run() {
+        assert(self.durableOperationDelegate != nil)
+
+        firstly(on: .global()) { () -> Promise<Void> in
+            // We also do this check right before sending the message, but we might be able to prevent
+            // charging the payment method (and some extra work) if we check now.
+            try self.databaseStorage.read { try self.ensureThatWeCanStillMessageRecipient(transaction: $0) }
+            return Promise.value(())
+        }.then { () -> Promise<Void> in
+            try self.confirmPaymentIntent()
+        }.then { () -> Promise<ReceiptCredentialPresentation> in
+            self.postJobEventNotification(.chargeSucceeded)
+            return try self.getReceiptCredentialPresentation()
+        }.done(on: .global()) { receiptCredentialPresentation in
+            try self.databaseStorage.write { transaction in
+                try self.enqueueMessages(receiptCredentialPresentation: receiptCredentialPresentation,
+                                         transaction: transaction)
+            }
+            self.didSucceed()
+        }.catch(on: .global()) { error in
+            self.reportError(error)
+        }
+    }
+
+    override public func didSucceed() {
+        databaseStorage.write { transaction in
+            self.durableOperationDelegate?.durableOperationDidSucceed(self, transaction: transaction)
+        }
+        postJobEventNotification(.jobSucceeded)
+    }
+
+    override public func retryInterval() -> TimeInterval {
+        OWSOperation.retryIntervalForExponentialBackoff(failureCount: jobRecord.failureCount)
+    }
+
+    override public func didFail(error: Error) {
+        self.databaseStorage.write { transaction in
+            self.durableOperationDelegate?.durableOperation(self, didFailWithError: error, transaction: transaction)
+        }
+        postJobEventNotification(.jobFailed)
+    }
+}
+
+// MARK: - Outgoing message preparer
+
+extension OutgoingMessagePreparer {
+    fileprivate convenience init(giftBadgeReceiptCredentialPresentation: ReceiptCredentialPresentation,
+                                 thread: TSThread,
+                                 transaction: SDSAnyReadTransaction) {
+        self.init(
+            builder: TSOutgoingMessageBuilder(
+                thread: thread,
+                expiresInSeconds: thread.disappearingMessagesDuration(with: transaction),
+                giftBadge: OWSGiftBadge(redemptionCredential: Data(giftBadgeReceiptCredentialPresentation.serialize()))
+            ),
+            transaction: transaction
+        )
+    }
+
+    fileprivate convenience init(messageBody: String,
+                                 thread: TSThread,
+                                 transaction: SDSAnyReadTransaction) {
+        self.init(
+            builder: TSOutgoingMessageBuilder(
+                thread: thread,
+                messageBody: messageBody,
+                expiresInSeconds: thread.disappearingMessagesDuration(with: transaction)
+            ),
+            transaction: transaction
+        )
+    }
+
+    private convenience init(builder: TSOutgoingMessageBuilder, transaction: SDSAnyReadTransaction) {
+        self.init(builder.build(transaction: transaction))
+    }
+}
diff --git a/SignalMessaging/Subscriptions/DonationUtilities.swift b/SignalMessaging/Subscriptions/DonationUtilities.swift
index bf990df2808..edf81004823 100644
--- a/SignalMessaging/Subscriptions/DonationUtilities.swift
+++ b/SignalMessaging/Subscriptions/DonationUtilities.swift
@@ -7,6 +7,8 @@ import PassKit
 import SignalCoreKit
 
 public class DonationUtilities: NSObject {
+    public static let sendGiftBadgeJobQueue = SendGiftBadgeJobQueue()
+
     public static var isApplePayAvailable: Bool {
         PKPaymentAuthorizationController.canMakePayments()
     }
diff --git a/SignalMessaging/Subscriptions/Stripe.swift b/SignalMessaging/Subscriptions/Stripe.swift
index fd384f953ee..09c57b16aed 100644
--- a/SignalMessaging/Subscriptions/Stripe.swift
+++ b/SignalMessaging/Subscriptions/Stripe.swift
@@ -7,11 +7,21 @@ import PassKit
 import SignalServiceKit
 
 public struct Stripe: Dependencies {
+    public struct PaymentIntent {
+        let id: String
+        let clientSecret: String
+
+        fileprivate init(clientSecret: String) throws {
+            self.id = try API.id(for: clientSecret)
+            self.clientSecret = clientSecret
+        }
+    }
+
     public static func donate(amount: NSDecimalNumber, in currencyCode: Currency.Code, for payment: PKPayment) -> Promise<Void> {
-        firstly { () -> Promise<API.PaymentIntent> in
+        firstly { () -> Promise<PaymentIntent> in
             API.createPaymentIntent(for: amount, in: currencyCode)
         }.then { intent in
-            API.confirmPaymentIntent(for: payment, clientSecret: intent.clientSecret, paymentIntentId: intent.id)
+            confirmPaymentIntent(for: payment, clientSecret: intent.clientSecret, paymentIntentId: intent.id)
         }
     }
 
@@ -19,10 +29,50 @@ public struct Stripe: Dependencies {
                              in currencyCode: Currency.Code,
                              level: OneTimeBadgeLevel,
                              for payment: PKPayment) -> Promise<String> {
-        firstly { () -> Promise<API.PaymentIntent> in
-            API.createBoostPaymentIntent(for: amount, in: currencyCode, level: level)
+        firstly { () -> Promise<PaymentIntent> in
+            createBoostPaymentIntent(for: amount, in: currencyCode, level: level)
         }.then { intent in
-            API.confirmPaymentIntent(for: payment, clientSecret: intent.clientSecret, paymentIntentId: intent.id).map { intent.id }
+            confirmPaymentIntent(for: payment, clientSecret: intent.clientSecret, paymentIntentId: intent.id).map { intent.id }
+        }
+    }
+
+    public static func createBoostPaymentIntent(
+        for amount: NSDecimalNumber,
+        in currencyCode: Currency.Code,
+        level: OneTimeBadgeLevel
+    ) -> Promise<PaymentIntent> {
+        firstly(on: .sharedUserInitiated) { () -> Promise<HTTPResponse> in
+            guard !isAmountTooSmall(amount, in: currencyCode) else {
+                throw OWSAssertionError("Amount too small")
+            }
+
+            guard !isAmountTooLarge(amount, in: currencyCode) else {
+                throw OWSAssertionError("Amount too large")
+            }
+
+            guard supportedCurrencyCodes.contains(currencyCode.uppercased()) else {
+                throw OWSAssertionError("Unexpected currency code")
+            }
+
+            // The description is never translated as it's populated into an
+            // english only receipt by Stripe.
+            let request = OWSRequestFactory.boostCreatePaymentIntent(
+                withAmount: integralAmount(amount, in: currencyCode),
+                inCurrencyCode: currencyCode,
+                level: level.rawValue
+            )
+
+            return networkManager.makePromise(request: request)
+        }.map(on: .sharedUserInitiated) { response in
+            guard let json = response.responseBodyJson else {
+                throw OWSAssertionError("Missing or invalid JSON")
+            }
+            guard let parser = ParamParser(responseObject: json) else {
+                throw OWSAssertionError("Failed to decode JSON response")
+            }
+            return try PaymentIntent(
+                clientSecret: try parser.required(key: "clientSecret")
+            )
         }
     }
 
@@ -44,6 +94,32 @@ public struct Stripe: Dependencies {
         }
     }
 
+    static func confirmPaymentIntent(for payment: PKPayment, clientSecret: String, paymentIntentId: String) -> Promise<Void> {
+        firstly(on: .sharedUserInitiated) { () -> Promise<String> in
+            createPaymentMethod(with: payment)
+        }.then(on: .sharedUserInitiated) { paymentMethodId -> Promise<HTTPResponse> in
+            guard !SubscriptionManager.terminateTransactionIfPossible else {
+                throw OWSGenericError("Boost transaction chain cancelled")
+            }
+
+            return try confirmPaymentIntent(paymentIntentClientSecret: clientSecret,
+                                            paymentIntentId: paymentIntentId,
+                                            paymentMethodId: paymentMethodId)
+        }.asVoid()
+    }
+
+    public static func confirmPaymentIntent(paymentIntentClientSecret: String,
+                                            paymentIntentId: String,
+                                            paymentMethodId: String,
+                                            idempotencyKey: String? = nil) throws -> Promise<HTTPResponse> {
+        try API.postForm(endpoint: "payment_intents/\(paymentIntentId)/confirm",
+                         parameters: [
+                            "payment_method": paymentMethodId,
+                            "client_secret": paymentIntentClientSecret
+                         ],
+                         idempotencyKey: idempotencyKey)
+    }
+
     public static func confirmSetupIntent(for paymentIntentID: String, clientSecret: String, payment: PKPayment) throws -> Promise<HTTPResponse> {
         firstly(on: .sharedUserInitiated) { () -> Promise<HTTPResponse> in
             let setupIntentId = try API.id(for: clientSecret)
@@ -98,16 +174,6 @@ fileprivate extension Stripe {
     )
 
     struct API {
-        struct PaymentIntent {
-            let id: String
-            let clientSecret: String
-
-            init(clientSecret: String) throws {
-                self.id = try API.id(for: clientSecret)
-                self.clientSecret = clientSecret
-            }
-        }
-
         static func id(for clientSecret: String) throws -> String {
             let components = clientSecret.components(separatedBy: "_secret_")
             if components.count >= 2, !components[0].isEmpty {
@@ -156,63 +222,6 @@ fileprivate extension Stripe {
             }
         }
 
-        static func createBoostPaymentIntent(
-            for amount: NSDecimalNumber,
-            in currencyCode: Currency.Code,
-            level: OneTimeBadgeLevel
-        ) -> Promise<(PaymentIntent)> {
-            firstly(on: .sharedUserInitiated) { () -> Promise<HTTPResponse> in
-                guard !isAmountTooSmall(amount, in: currencyCode) else {
-                    throw OWSAssertionError("Amount too small")
-                }
-
-                guard !isAmountTooLarge(amount, in: currencyCode) else {
-                    throw OWSAssertionError("Amount too large")
-                }
-
-                guard supportedCurrencyCodes.contains(currencyCode.uppercased()) else {
-                    throw OWSAssertionError("Unexpected currency code")
-                }
-
-                // The description is never translated as it's populated into an
-                // english only receipt by Stripe.
-                let request = OWSRequestFactory.boostCreatePaymentIntent(
-                    withAmount: integralAmount(amount, in: currencyCode),
-                    inCurrencyCode: currencyCode,
-                    level: level.rawValue
-                )
-
-                return networkManager.makePromise(request: request)
-            }.map(on: .sharedUserInitiated) { response in
-                guard let json = response.responseBodyJson else {
-                    throw OWSAssertionError("Missing or invalid JSON")
-                }
-                guard let parser = ParamParser(responseObject: json) else {
-                    throw OWSAssertionError("Failed to decode JSON response")
-                }
-                return try PaymentIntent(
-                    clientSecret: try parser.required(key: "clientSecret")
-                )
-            }
-        }
-
-        static func confirmPaymentIntent(for payment: PKPayment, clientSecret: String, paymentIntentId: String) -> Promise<Void> {
-            firstly(on: .sharedUserInitiated) { () -> Promise<String> in
-                createPaymentMethod(with: payment)
-            }.then(on: .sharedUserInitiated) { paymentMethodId -> Promise<HTTPResponse> in
-
-                guard !SubscriptionManager.terminateTransactionIfPossible else {
-                    throw OWSGenericError("Boost transaction chain cancelled")
-                }
-
-                let parameters = [
-                    "payment_method": paymentMethodId,
-                    "client_secret": clientSecret
-                ]
-                return try postForm(endpoint: "payment_intents/\(paymentIntentId)/confirm", parameters: parameters)
-            }.asVoid()
-        }
-
         // MARK: Common Stripe integrations
 
         static func parameters(for payment: PKPayment) -> [String: Any] {
@@ -277,15 +286,25 @@ fileprivate extension Stripe {
             }
         }
 
-        static func postForm(endpoint: String, parameters: [String: Any]) throws -> Promise<HTTPResponse> {
+        static func postForm(endpoint: String,
+                             parameters: [String: Any],
+                             idempotencyKey: String? = nil) throws -> Promise<HTTPResponse> {
             guard let formData = AFQueryStringFromParameters(parameters).data(using: .utf8) else {
                 throw OWSAssertionError("Failed to generate post body data")
             }
 
+            var headers: [String: String] = [
+                "Content-Type": "application/x-www-form-urlencoded",
+                "Authorization": authorizationHeader
+            ]
+            if let idempotencyKey = idempotencyKey {
+                headers["Idempotency-Key"] = idempotencyKey
+            }
+
             return urlSession.dataTaskPromise(
                 endpoint,
                 method: .post,
-                headers: ["Content-Type": "application/x-www-form-urlencoded", "Authorization": authorizationHeader],
+                headers: headers,
                 body: formData
             )
         }
diff --git a/SignalServiceKit/Resources/schema.sql b/SignalServiceKit/Resources/schema.sql
index df65c4edfe2..0ad25cdfafd 100644
--- a/SignalServiceKit/Resources/schema.sql
+++ b/SignalServiceKit/Resources/schema.sql
@@ -264,6 +264,9 @@ CREATE
             ,"amount" NUMERIC
             ,"currencyCode" TEXT
             ,"unsavedMessagesToSend" BLOB
+            ,"messageText" TEXT
+            ,"paymentIntentClientSecret" TEXT
+            ,"paymentMethodId" TEXT
         )
 ;
 
diff --git a/SignalServiceKit/src/Network/Receiving/SSKMessageDecryptJobRecord+SDS.swift b/SignalServiceKit/src/Network/Receiving/SSKMessageDecryptJobRecord+SDS.swift
index a784974ba80..11337e6ef4d 100644
--- a/SignalServiceKit/src/Network/Receiving/SSKMessageDecryptJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Network/Receiving/SSKMessageDecryptJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class SSKMessageDecryptJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
diff --git a/SignalServiceKit/src/SignalServiceKit.h b/SignalServiceKit/src/SignalServiceKit.h
index 7115771aaa0..89855465aa5 100644
--- a/SignalServiceKit/src/SignalServiceKit.h
+++ b/SignalServiceKit/src/SignalServiceKit.h
@@ -47,6 +47,7 @@
 #import <SignalServiceKit/OWSRecipientIdentity.h>
 #import <SignalServiceKit/OWSRecoverableDecryptionPlaceholder.h>
 #import <SignalServiceKit/OWSRequestFactory.h>
+#import <SignalServiceKit/OWSSendGiftBadgeJobRecord.h>
 #import <SignalServiceKit/OWSSessionResetJobRecord.h>
 #import <SignalServiceKit/OWSSignalService.h>
 #import <SignalServiceKit/OWSStaticOutgoingMessage.h>
diff --git a/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift b/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
index d0ea52859b2..5565f79e445 100644
--- a/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
+++ b/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
@@ -164,6 +164,7 @@ public class GRDBSchemaMigrator: NSObject {
         case addCanReceiveGiftBadgesToUserProfiles
         case addStoryThreadColumns
         case addUnsavedMessagesToSendToJobRecord
+        case addColumnsForSendGiftBadgeDurableJob
 
         // NOTE: Every time we add a migration id, consider
         // incrementing grdbSchemaVersionLatest.
@@ -1811,6 +1812,18 @@ public class GRDBSchemaMigrator: NSObject {
             }
         }
 
+        migrator.registerMigration(.addColumnsForSendGiftBadgeDurableJob) { db in
+            do {
+                try db.alter(table: "model_SSKJobRecord") { (table: TableAlteration) -> Void in
+                    table.add(column: "messageText", .text)
+                    table.add(column: "paymentIntentClientSecret", .text)
+                    table.add(column: "paymentMethodId", .text)
+                }
+            } catch {
+                owsFail("Error: \(error)")
+            }
+        }
+
         // MARK: - Schema Migration Insertion Point
     }
 
diff --git a/SignalServiceKit/src/Storage/Database/SDSRecordType.swift b/SignalServiceKit/src/Storage/Database/SDSRecordType.swift
index 139e487214d..28afe3128bf 100644
--- a/SignalServiceKit/src/Storage/Database/SDSRecordType.swift
+++ b/SignalServiceKit/src/Storage/Database/SDSRecordType.swift
@@ -82,4 +82,5 @@ public enum SDSRecordType: UInt, CaseIterable {
     case recoverableDecryptionPlaceholder = 70
     case receiptCredentialRedemptionJobRecord = 71
     case privateStoryThread = 72
+    case sendGiftBadgeJobRecord = 73
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSBroadcastMediaMessageJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/OWSBroadcastMediaMessageJobRecord+SDS.swift
index 0c22ac96cd2..fad122307e0 100644
--- a/SignalServiceKit/src/Storage/Jobs/OWSBroadcastMediaMessageJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/OWSBroadcastMediaMessageJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class OWSBroadcastMediaMessageJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = optionalArchive(model.unsavedMessagesToSend)
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSIncomingContactSyncJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/OWSIncomingContactSyncJobRecord+SDS.swift
index 5524ffa95e1..f54c5504446 100644
--- a/SignalServiceKit/src/Storage/Jobs/OWSIncomingContactSyncJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/OWSIncomingContactSyncJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class OWSIncomingContactSyncJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSIncomingGroupSyncJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/OWSIncomingGroupSyncJobRecord+SDS.swift
index 2164e34ad20..faced8f4ede 100644
--- a/SignalServiceKit/src/Storage/Jobs/OWSIncomingGroupSyncJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/OWSIncomingGroupSyncJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class OWSIncomingGroupSyncJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSReceiptCredentialRedemptionJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/OWSReceiptCredentialRedemptionJobRecord+SDS.swift
index 2849750080b..6bbe636c8e2 100644
--- a/SignalServiceKit/src/Storage/Jobs/OWSReceiptCredentialRedemptionJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/OWSReceiptCredentialRedemptionJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class OWSReceiptCredentialRedemptionJobRecordSerializer: SDSSerializer {
         let amount: Data? = optionalArchive(model.amount)
         let currencyCode: String? = model.currencyCode
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord+SDS.swift
new file mode 100644
index 00000000000..d2eb6b78fca
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord+SDS.swift
@@ -0,0 +1,96 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import GRDB
+import SignalCoreKit
+
+// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
+// Do not manually edit it, instead run `sds_codegen.sh`.
+
+// MARK: - Typed Convenience Methods
+
+@objc
+public extension OWSSendGiftBadgeJobRecord {
+    // NOTE: This method will fail if the object has unexpected type.
+    class func anyFetchSendGiftBadgeJobRecord(uniqueId: String,
+                                   transaction: SDSAnyReadTransaction) -> OWSSendGiftBadgeJobRecord? {
+        assert(uniqueId.count > 0)
+
+        guard let object = anyFetch(uniqueId: uniqueId,
+                                    transaction: transaction) else {
+                                        return nil
+        }
+        guard let instance = object as? OWSSendGiftBadgeJobRecord else {
+            owsFailDebug("Object has unexpected type: \(type(of: object))")
+            return nil
+        }
+        return instance
+    }
+
+    // NOTE: This method will fail if the object has unexpected type.
+    func anyUpdateSendGiftBadgeJobRecord(transaction: SDSAnyWriteTransaction, block: (OWSSendGiftBadgeJobRecord) -> Void) {
+        anyUpdate(transaction: transaction) { (object) in
+            guard let instance = object as? OWSSendGiftBadgeJobRecord else {
+                owsFailDebug("Object has unexpected type: \(type(of: object))")
+                return
+            }
+            block(instance)
+        }
+    }
+}
+
+// MARK: - SDSSerializer
+
+// The SDSSerializer protocol specifies how to insert and update the
+// row that corresponds to this model.
+class OWSSendGiftBadgeJobRecordSerializer: SDSSerializer {
+
+    private let model: OWSSendGiftBadgeJobRecord
+    public required init(model: OWSSendGiftBadgeJobRecord) {
+        self.model = model
+    }
+
+    // MARK: - Record
+
+    func asRecord() throws -> SDSRecord {
+        let id: Int64? = model.sortId > 0 ? Int64(model.sortId) : model.grdbId?.int64Value
+
+        let recordType: SDSRecordType = .sendGiftBadgeJobRecord
+        let uniqueId: String = model.uniqueId
+
+        // Properties
+        let failureCount: UInt = model.failureCount
+        let label: String = model.label
+        let status: SSKJobRecordStatus = model.status
+        let attachmentIdMap: Data? = nil
+        let contactThreadId: String? = nil
+        let envelopeData: Data? = nil
+        let invisibleMessage: Data? = nil
+        let messageId: String? = nil
+        let removeMessageAfterSending: Bool? = nil
+        let threadId: String? = model.threadId
+        let attachmentId: String? = nil
+        let isMediaMessage: Bool? = nil
+        let serverDeliveryTimestamp: UInt64? = nil
+        let exclusiveProcessIdentifier: String? = model.exclusiveProcessIdentifier
+        let isHighPriority: Bool? = nil
+        let receiptCredentailRequest: Data? = model.receiptCredentailRequest
+        let receiptCredentailRequestContext: Data? = model.receiptCredentailRequestContext
+        let priorSubscriptionLevel: UInt? = nil
+        let subscriberID: Data? = nil
+        let targetSubscriptionLevel: UInt? = nil
+        let boostPaymentIntentID: String? = model.boostPaymentIntentID
+        let isBoost: Bool? = nil
+        let receiptCredentialPresentation: Data? = nil
+        let amount: Data? = optionalArchive(model.amount)
+        let currencyCode: String? = model.currencyCode
+        let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = model.messageText
+        let paymentIntentClientSecret: String? = model.paymentIntentClientSecret
+        let paymentMethodId: String? = model.paymentMethodId
+
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
+    }
+}
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord.h b/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord.h
new file mode 100644
index 00000000000..9816bc92304
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord.h
@@ -0,0 +1,79 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+#import <SignalServiceKit/SSKJobRecord.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class SDSAnyWriteTransaction;
+
+@interface OWSSendGiftBadgeJobRecord : SSKJobRecord
+
+// These are deliberately misspelled ("credentail" instead of "credential") to match
+// misspelled database columns. In the long term, we should fix this.
+@property (nonatomic, readonly) NSData *receiptCredentailRequestContext;
+@property (nonatomic, readonly) NSData *receiptCredentailRequest;
+@property (nonatomic, readonly) NSDecimalNumber *amount;
+@property (nonatomic, readonly) NSString *currencyCode;
+@property (nonatomic, readonly) NSString *paymentIntentClientSecret;
+@property (nonatomic, readonly) NSString *boostPaymentIntentID;
+@property (nonatomic, readonly) NSString *paymentMethodId;
+@property (nonatomic, readonly) NSString *threadId;
+@property (nonatomic, readonly) NSString *messageText;
+
+- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;
+
+- (instancetype)initWithReceiptCredentialRequestContext:(NSData *)receiptCredentailRequestContext
+                               receiptCredentialRequest:(NSData *)receiptCredentialRequest
+                                                 amount:(NSDecimalNumber *)amount
+                                           currencyCode:(NSString *)currencyCode
+                              paymentIntentClientSecret:(NSString *)paymentIntentClientSecret
+                                        paymentIntentId:(NSString *)paymentIntentId
+                                        paymentMethodId:(NSString *)paymentMethodId
+                                               threadId:(NSString *)threadId
+                                            messageText:(NSString *)messageText
+                                                  label:(NSString *)label NS_DESIGNATED_INITIALIZER;
+
+- (nullable)initWithLabel:(NSString *)label NS_UNAVAILABLE;
+
+- (instancetype)initWithGrdbId:(int64_t)grdbId
+                      uniqueId:(NSString *)uniqueId
+    exclusiveProcessIdentifier:(nullable NSString *)exclusiveProcessIdentifier
+                  failureCount:(NSUInteger)failureCount
+                         label:(NSString *)label
+                        sortId:(unsigned long long)sortId
+                        status:(SSKJobRecordStatus)status NS_UNAVAILABLE;
+
+// --- CODE GENERATION MARKER
+
+// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run
+// `sds_codegen.sh`.
+
+// clang-format off
+
+- (instancetype)initWithGrdbId:(int64_t)grdbId
+                      uniqueId:(NSString *)uniqueId
+      exclusiveProcessIdentifier:(nullable NSString *)exclusiveProcessIdentifier
+                    failureCount:(NSUInteger)failureCount
+                           label:(NSString *)label
+                          sortId:(unsigned long long)sortId
+                          status:(SSKJobRecordStatus)status
+                          amount:(NSDecimalNumber *)amount
+            boostPaymentIntentID:(NSString *)boostPaymentIntentID
+                    currencyCode:(NSString *)currencyCode
+                     messageText:(NSString *)messageText
+       paymentIntentClientSecret:(NSString *)paymentIntentClientSecret
+                 paymentMethodId:(NSString *)paymentMethodId
+        receiptCredentailRequest:(NSData *)receiptCredentailRequest
+ receiptCredentailRequestContext:(NSData *)receiptCredentailRequestContext
+                        threadId:(NSString *)threadId
+NS_DESIGNATED_INITIALIZER NS_SWIFT_NAME(init(grdbId:uniqueId:exclusiveProcessIdentifier:failureCount:label:sortId:status:amount:boostPaymentIntentID:currencyCode:messageText:paymentIntentClientSecret:paymentMethodId:receiptCredentailRequest:receiptCredentailRequestContext:threadId:));
+
+// clang-format on
+
+// --- CODE GENERATION MARKER
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord.m b/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord.m
new file mode 100644
index 00000000000..6cbe3a594ba
--- /dev/null
+++ b/SignalServiceKit/src/Storage/Jobs/OWSSendGiftBadgeJobRecord.m
@@ -0,0 +1,97 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+#import "OWSSendGiftBadgeJobRecord.h"
+#import <SignalServiceKit/SignalServiceKit-Swift.h>
+
+@interface OWSSendGiftBadgeJobRecord ()
+@end
+
+@implementation OWSSendGiftBadgeJobRecord
+
+- (instancetype)initWithReceiptCredentialRequestContext:(NSData *)receiptCredentialRequestContext
+                               receiptCredentialRequest:(NSData *)receiptCredentialRequest
+                                                 amount:(NSDecimalNumber *)amount
+                                           currencyCode:(NSString *)currencyCode
+                              paymentIntentClientSecret:(NSString *)paymentIntentClientSecret
+                                        paymentIntentId:(NSString *)paymentIntentId
+                                        paymentMethodId:(NSString *)paymentMethodId
+                                               threadId:(NSString *)threadId
+                                            messageText:(NSString *)messageText
+                                                  label:(NSString *)label
+{
+    self = [super initWithLabel:label];
+    if (self) {
+        _receiptCredentailRequestContext = receiptCredentialRequestContext;
+        _receiptCredentailRequest = receiptCredentialRequest;
+        _amount = amount;
+        _currencyCode = currencyCode;
+        _paymentIntentClientSecret = paymentIntentClientSecret;
+        _boostPaymentIntentID = paymentIntentId;
+        _paymentMethodId = paymentMethodId;
+        _threadId = threadId;
+        _messageText = messageText;
+    }
+    return self;
+}
+
+- (nullable instancetype)initWithCoder:(NSCoder *)coder
+{
+    return [super initWithCoder:coder];
+}
+
+// --- CODE GENERATION MARKER
+
+// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run
+// `sds_codegen.sh`.
+
+// clang-format off
+
+- (instancetype)initWithGrdbId:(int64_t)grdbId
+                      uniqueId:(NSString *)uniqueId
+      exclusiveProcessIdentifier:(nullable NSString *)exclusiveProcessIdentifier
+                    failureCount:(NSUInteger)failureCount
+                           label:(NSString *)label
+                          sortId:(unsigned long long)sortId
+                          status:(SSKJobRecordStatus)status
+                          amount:(NSDecimalNumber *)amount
+            boostPaymentIntentID:(NSString *)boostPaymentIntentID
+                    currencyCode:(NSString *)currencyCode
+                     messageText:(NSString *)messageText
+       paymentIntentClientSecret:(NSString *)paymentIntentClientSecret
+                 paymentMethodId:(NSString *)paymentMethodId
+        receiptCredentailRequest:(NSData *)receiptCredentailRequest
+ receiptCredentailRequestContext:(NSData *)receiptCredentailRequestContext
+                        threadId:(NSString *)threadId
+{
+    self = [super initWithGrdbId:grdbId
+                        uniqueId:uniqueId
+        exclusiveProcessIdentifier:exclusiveProcessIdentifier
+                      failureCount:failureCount
+                             label:label
+                            sortId:sortId
+                            status:status];
+
+    if (!self) {
+        return self;
+    }
+
+    _amount = amount;
+    _boostPaymentIntentID = boostPaymentIntentID;
+    _currencyCode = currencyCode;
+    _messageText = messageText;
+    _paymentIntentClientSecret = paymentIntentClientSecret;
+    _paymentMethodId = paymentMethodId;
+    _receiptCredentailRequest = receiptCredentailRequest;
+    _receiptCredentailRequestContext = receiptCredentailRequestContext;
+    _threadId = threadId;
+
+    return self;
+}
+
+// clang-format on
+
+// --- CODE GENERATION MARKER
+
+@end
diff --git a/SignalServiceKit/src/Storage/Jobs/OWSSessionResetJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/OWSSessionResetJobRecord+SDS.swift
index 3849914e5f4..8736279adcd 100644
--- a/SignalServiceKit/src/Storage/Jobs/OWSSessionResetJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/OWSSessionResetJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class OWSSessionResetJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
diff --git a/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift b/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift
index 69260b54fd6..106558bfc2c 100644
--- a/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/Jobs/SSKJobRecord+SDS.swift
@@ -56,6 +56,9 @@ public struct JobRecordRecord: SDSRecord {
     public let amount: Data?
     public let currencyCode: String?
     public let unsavedMessagesToSend: Data?
+    public let messageText: String?
+    public let paymentIntentClientSecret: String?
+    public let paymentMethodId: String?
 
     public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
         case id
@@ -87,6 +90,9 @@ public struct JobRecordRecord: SDSRecord {
         case amount
         case currencyCode
         case unsavedMessagesToSend
+        case messageText
+        case paymentIntentClientSecret
+        case paymentMethodId
     }
 
     public static func columnName(_ column: JobRecordRecord.CodingKeys, fullyQualified: Bool = false) -> String {
@@ -139,6 +145,9 @@ public extension JobRecordRecord {
         amount = row[26]
         currencyCode = row[27]
         unsavedMessagesToSend = row[28]
+        messageText = row[29]
+        paymentIntentClientSecret = row[30]
+        paymentMethodId = row[31]
     }
 }
 
@@ -266,6 +275,42 @@ extension SSKJobRecord {
                                                            subscriberID: subscriberID,
                                                            targetSubscriptionLevel: targetSubscriptionLevel)
 
+        case .sendGiftBadgeJobRecord:
+
+            let uniqueId: String = record.uniqueId
+            let exclusiveProcessIdentifier: String? = record.exclusiveProcessIdentifier
+            let failureCount: UInt = record.failureCount
+            let label: String = record.label
+            let sortId: UInt64 = UInt64(recordId)
+            let status: SSKJobRecordStatus = record.status
+            let amountSerialized: Data? = record.amount
+            let amount: NSDecimalNumber = try SDSDeserialization.unarchive(amountSerialized, name: "amount")
+            let boostPaymentIntentID: String = try SDSDeserialization.required(record.boostPaymentIntentID, name: "boostPaymentIntentID")
+            let currencyCode: String = try SDSDeserialization.required(record.currencyCode, name: "currencyCode")
+            let messageText: String = try SDSDeserialization.required(record.messageText, name: "messageText")
+            let paymentIntentClientSecret: String = try SDSDeserialization.required(record.paymentIntentClientSecret, name: "paymentIntentClientSecret")
+            let paymentMethodId: String = try SDSDeserialization.required(record.paymentMethodId, name: "paymentMethodId")
+            let receiptCredentailRequest: Data = try SDSDeserialization.required(record.receiptCredentailRequest, name: "receiptCredentailRequest")
+            let receiptCredentailRequestContext: Data = try SDSDeserialization.required(record.receiptCredentailRequestContext, name: "receiptCredentailRequestContext")
+            let threadId: String = try SDSDeserialization.required(record.threadId, name: "threadId")
+
+            return OWSSendGiftBadgeJobRecord(grdbId: recordId,
+                                             uniqueId: uniqueId,
+                                             exclusiveProcessIdentifier: exclusiveProcessIdentifier,
+                                             failureCount: failureCount,
+                                             label: label,
+                                             sortId: sortId,
+                                             status: status,
+                                             amount: amount,
+                                             boostPaymentIntentID: boostPaymentIntentID,
+                                             currencyCode: currencyCode,
+                                             messageText: messageText,
+                                             paymentIntentClientSecret: paymentIntentClientSecret,
+                                             paymentMethodId: paymentMethodId,
+                                             receiptCredentailRequest: receiptCredentailRequest,
+                                             receiptCredentailRequestContext: receiptCredentailRequestContext,
+                                             threadId: threadId)
+
         case .sessionResetJobRecord:
 
             let uniqueId: String = record.uniqueId
@@ -377,6 +422,9 @@ extension SSKJobRecord: SDSModel {
         case let model as OWSSessionResetJobRecord:
             assert(type(of: model) == OWSSessionResetJobRecord.self)
             return OWSSessionResetJobRecordSerializer(model: model)
+        case let model as OWSSendGiftBadgeJobRecord:
+            assert(type(of: model) == OWSSendGiftBadgeJobRecord.self)
+            return OWSSendGiftBadgeJobRecordSerializer(model: model)
         case let model as OWSReceiptCredentialRedemptionJobRecord:
             assert(type(of: model) == OWSReceiptCredentialRedemptionJobRecord.self)
             return OWSReceiptCredentialRedemptionJobRecordSerializer(model: model)
@@ -503,6 +551,44 @@ extension SSKJobRecord: DeepCopyable {
                                             contactThreadId: contactThreadId)
         }
 
+        if let modelToCopy = self as? OWSSendGiftBadgeJobRecord {
+            assert(type(of: modelToCopy) == OWSSendGiftBadgeJobRecord.self)
+            let uniqueId: String = modelToCopy.uniqueId
+            let exclusiveProcessIdentifier: String? = modelToCopy.exclusiveProcessIdentifier
+            let failureCount: UInt = modelToCopy.failureCount
+            let label: String = modelToCopy.label
+            let sortId: UInt64 = modelToCopy.sortId
+            let status: SSKJobRecordStatus = modelToCopy.status
+            // NOTE: If this generates build errors, you made need to
+            // implement DeepCopyable for this type in DeepCopy.swift.
+            let amount: NSDecimalNumber = try DeepCopies.deepCopy(modelToCopy.amount)
+            let boostPaymentIntentID: String = modelToCopy.boostPaymentIntentID
+            let currencyCode: String = modelToCopy.currencyCode
+            let messageText: String = modelToCopy.messageText
+            let paymentIntentClientSecret: String = modelToCopy.paymentIntentClientSecret
+            let paymentMethodId: String = modelToCopy.paymentMethodId
+            let receiptCredentailRequest: Data = modelToCopy.receiptCredentailRequest
+            let receiptCredentailRequestContext: Data = modelToCopy.receiptCredentailRequestContext
+            let threadId: String = modelToCopy.threadId
+
+            return OWSSendGiftBadgeJobRecord(grdbId: id,
+                                             uniqueId: uniqueId,
+                                             exclusiveProcessIdentifier: exclusiveProcessIdentifier,
+                                             failureCount: failureCount,
+                                             label: label,
+                                             sortId: sortId,
+                                             status: status,
+                                             amount: amount,
+                                             boostPaymentIntentID: boostPaymentIntentID,
+                                             currencyCode: currencyCode,
+                                             messageText: messageText,
+                                             paymentIntentClientSecret: paymentIntentClientSecret,
+                                             paymentMethodId: paymentMethodId,
+                                             receiptCredentailRequest: receiptCredentailRequest,
+                                             receiptCredentailRequestContext: receiptCredentailRequestContext,
+                                             threadId: threadId)
+        }
+
         if let modelToCopy = self as? OWSReceiptCredentialRedemptionJobRecord {
             assert(type(of: modelToCopy) == OWSReceiptCredentialRedemptionJobRecord.self)
             let uniqueId: String = modelToCopy.uniqueId
@@ -687,6 +773,9 @@ extension SSKJobRecordSerializer {
     static var amountColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "amount", columnType: .blob, isOptional: true) }
     static var currencyCodeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "currencyCode", columnType: .unicodeString, isOptional: true) }
     static var unsavedMessagesToSendColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unsavedMessagesToSend", columnType: .blob, isOptional: true) }
+    static var messageTextColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageText", columnType: .unicodeString, isOptional: true) }
+    static var paymentIntentClientSecretColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "paymentIntentClientSecret", columnType: .unicodeString, isOptional: true) }
+    static var paymentMethodIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "paymentMethodId", columnType: .unicodeString, isOptional: true) }
 
     // TODO: We should decide on a naming convention for
     //       tables that store models.
@@ -722,7 +811,10 @@ extension SSKJobRecordSerializer {
         receiptCredentialPresentationColumn,
         amountColumn,
         currencyCodeColumn,
-        unsavedMessagesToSendColumn
+        unsavedMessagesToSendColumn,
+        messageTextColumn,
+        paymentIntentClientSecretColumn,
+        paymentMethodIdColumn
         ])
     }
 }
@@ -1137,8 +1229,11 @@ class SSKJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
 
diff --git a/SignalServiceKit/src/Storage/SSKMessageSenderJobRecord+SDS.swift b/SignalServiceKit/src/Storage/SSKMessageSenderJobRecord+SDS.swift
index 945844247a2..0c91d26acc3 100644
--- a/SignalServiceKit/src/Storage/SSKMessageSenderJobRecord+SDS.swift
+++ b/SignalServiceKit/src/Storage/SSKMessageSenderJobRecord+SDS.swift
@@ -87,7 +87,10 @@ class SSKMessageSenderJobRecordSerializer: SDSSerializer {
         let amount: Data? = nil
         let currencyCode: String? = nil
         let unsavedMessagesToSend: Data? = nil
+        let messageText: String? = nil
+        let paymentIntentClientSecret: String? = nil
+        let paymentMethodId: String? = nil
 
-        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend)
+        return JobRecordRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, failureCount: failureCount, label: label, status: status, attachmentIdMap: attachmentIdMap, contactThreadId: contactThreadId, envelopeData: envelopeData, invisibleMessage: invisibleMessage, messageId: messageId, removeMessageAfterSending: removeMessageAfterSending, threadId: threadId, attachmentId: attachmentId, isMediaMessage: isMediaMessage, serverDeliveryTimestamp: serverDeliveryTimestamp, exclusiveProcessIdentifier: exclusiveProcessIdentifier, isHighPriority: isHighPriority, receiptCredentailRequest: receiptCredentailRequest, receiptCredentailRequestContext: receiptCredentailRequestContext, priorSubscriptionLevel: priorSubscriptionLevel, subscriberID: subscriberID, targetSubscriptionLevel: targetSubscriptionLevel, boostPaymentIntentID: boostPaymentIntentID, isBoost: isBoost, receiptCredentialPresentation: receiptCredentialPresentation, amount: amount, currencyCode: currencyCode, unsavedMessagesToSend: unsavedMessagesToSend, messageText: messageText, paymentIntentClientSecret: paymentIntentClientSecret, paymentMethodId: paymentMethodId)
     }
 }
