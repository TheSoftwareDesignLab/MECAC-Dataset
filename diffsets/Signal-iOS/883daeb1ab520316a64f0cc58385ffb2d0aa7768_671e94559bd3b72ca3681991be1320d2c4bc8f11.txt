diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift
index 3bfef11cad9..f7333d60b90 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponentState.swift
@@ -19,25 +19,47 @@ public class CVComponentState: Equatable {
     }
     let senderAvatar: SenderAvatar?
 
-    struct BodyText: Equatable {
-        enum State: Equatable {
-            case bodyText(displayableBodyText: DisplayableText)
+    enum BodyText: Equatable {
+        case bodyText(displayableText: DisplayableText)
 
-            // TODO: Should we have oversizeTextFailed?
-            case oversizeTextDownloading
+        // TODO: Should we have oversizeTextFailed?
+        case oversizeTextDownloading
 
-            // We use the "body text" component to
-            // render the "remotely deleted" indicator.
-            case remotelyDeleted
-        }
-        var state: State
+        // We use the "body text" component to
+        // render the "remotely deleted" indicator.
+        case remotelyDeleted
 
-        var displayableBodyText: DisplayableText? {
-            if case .bodyText(let displayableBodyText) = state {
-                return displayableBodyText
+        var displayableText: DisplayableText? {
+            if case .bodyText(let displayableText) = self {
+                return displayableText
             }
             return nil
         }
+
+        func textValue(isTextExpanded: Bool) -> CVTextValue? {
+            switch self {
+            case .bodyText(let displayableText):
+                return displayableText.textValue(isTextExpanded: isTextExpanded)
+            default:
+                return nil
+            }
+        }
+
+        var jumbomojiCount: UInt? {
+            switch self {
+            case .bodyText(let displayableText):
+                return displayableText.jumbomojiCount
+            default:
+                return nil
+            }
+        }
+
+        var isJumbomojiMessage: Bool {
+            guard let jumbomojiCount = jumbomojiCount else {
+                return false
+            }
+            return jumbomojiCount > 0
+        }
     }
     let bodyText: BodyText?
 
@@ -501,13 +523,7 @@ public class CVComponentState: Equatable {
     }()
 
     lazy var isJumbomojiMessage: Bool = {
-        if isTextOnlyMessage,
-           let bodyText = bodyText,
-           let displayableBodyText = bodyText.displayableBodyText,
-           displayableBodyText.jumbomojiCount > 0 {
-            return true
-        }
-        return false
+        isTextOnlyMessage && (bodyText?.isJumbomojiMessage == true)
     }()
 
     lazy var isBodyMediaOnlyMessage: Bool = {
@@ -667,7 +683,7 @@ fileprivate extension CVComponentState.Builder {
 
         if message.wasRemotelyDeleted {
             // If the message has been remotely deleted, suppress everything else.
-            self.bodyText = BodyText(state: .remotelyDeleted)
+            self.bodyText = .remotelyDeleted
             return build()
         }
 
@@ -894,10 +910,10 @@ fileprivate extension CVComponentState.Builder {
         var displayableQuotedText: DisplayableText?
         if let quotedBody = quotedReplyModel.body,
            !quotedBody.isEmpty {
-            displayableQuotedText = Self.displayableQuotedText(text: quotedBody,
-                                                               ranges: quotedReplyModel.bodyRanges,
-                                                               interaction: message,
-                                                               transaction: transaction)
+            displayableQuotedText = CVComponentState.displayableQuotedText(text: quotedBody,
+                                                                           ranges: quotedReplyModel.bodyRanges,
+                                                                           interaction: message,
+                                                                           transaction: transaction)
         }
         let viewState = QuotedMessageView.stateForConversation(quotedReplyModel: quotedReplyModel,
                                                                displayableQuotedText: displayableQuotedText,
@@ -908,32 +924,8 @@ fileprivate extension CVComponentState.Builder {
     }
 
     mutating func buildBodyText(message: TSMessage) throws {
-        // TODO: We might want to treat text that is completely stripped
-        // as not present.
-        if let oversizeTextAttachment = message.oversizeTextAttachment(with: transaction.unwrapGrdbRead) {
-            if let oversizeTextAttachmentStream = oversizeTextAttachment as? TSAttachmentStream {
-                let displayableBodyText = Self.displayableBodyText(oversizeTextAttachment: oversizeTextAttachmentStream,
-                                                                   ranges: message.bodyRanges,
-                                                                   interaction: message,
-                                                                   transaction: transaction)
-                self.bodyText = BodyText(state: .bodyText(displayableBodyText: displayableBodyText))
-            } else if nil != oversizeTextAttachment as? TSAttachmentPointer {
-                // TODO: Handle backup restore.
-                // TODO: If there's media, should we display that while the oversize text is downloading?
-                self.bodyText = BodyText(state: .oversizeTextDownloading)
-            } else {
-                throw OWSAssertionError("Invalid oversizeTextAttachment.")
-            }
-        } else if let body = message.body, !body.isEmpty {
-            let displayableBodyText = Self.displayableBodyText(text: body,
-                                                               ranges: message.bodyRanges,
-                                                               interaction: message,
+        bodyText = try CVComponentBodyText.buildComponentState(message: message,
                                                                transaction: transaction)
-            self.bodyText = BodyText(state: .bodyText(displayableBodyText: displayableBodyText))
-        } else {
-            // No body text.
-            return
-        }
     }
 
     // MARK: -
@@ -952,9 +944,9 @@ fileprivate extension CVComponentState.Builder {
 
             var caption: String?
             if let rawCaption = attachment.caption {
-                caption = Self.displayableCaption(text: rawCaption,
-                                                  attachmentId: attachment.uniqueId,
-                                                  transaction: transaction).displayAttributedText.string
+                caption = CVComponentState.displayableCaption(text: rawCaption,
+                                                              attachmentId: attachment.uniqueId,
+                                                              transaction: transaction).displayTextValue.stringValue
             }
 
             guard let attachmentStream = attachment as? TSAttachmentStream else {
@@ -1082,7 +1074,7 @@ fileprivate extension CVComponentState.Builder {
 
 // MARK: - DisplayableText
 
-fileprivate extension CVComponentState.Builder {
+public extension CVComponentState {
 
     static func displayableBodyText(text: String,
                                     ranges: MessageBodyRanges?,
@@ -1130,6 +1122,11 @@ fileprivate extension CVComponentState.Builder {
             return MessageBody(text: text, ranges: ranges ?? .empty)
         }
     }
+}
+
+// MARK: -
+
+fileprivate extension CVComponentState {
 
     static func displayableQuotedText(text: String,
                                       ranges: MessageBodyRanges?,
@@ -1153,9 +1150,9 @@ fileprivate extension CVComponentState.Builder {
         let cacheKey = "attachment-caption-\(attachmentId)"
 
         let mentionStyle: Mention.Style = .incoming
-        return Self.displayableText(cacheKey: cacheKey,
-                                    mentionStyle: mentionStyle,
-                                    transaction: transaction) {
+        return CVComponentState.displayableText(cacheKey: cacheKey,
+                                                mentionStyle: mentionStyle,
+                                                transaction: transaction) {
             MessageBody(text: text, ranges: .empty)
         }
     }
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
index 070b26021e7..f4d779d841d 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentBodyText.swift
@@ -9,15 +9,16 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
 
     struct State: Equatable {
         let bodyText: CVComponentState.BodyText
-        let isTruncatedTextVisible: Bool
+        let isTextExpanded: Bool
         let searchText: String?
         let hasTapForMore: Bool
+        let shouldUseAttributedText: Bool
 
         public var canUseDedicatedCell: Bool {
             if hasTapForMore || searchText != nil {
                 return false
             }
-            switch bodyText.state {
+            switch bodyText {
             case .bodyText:
                 return true
             case .oversizeTextDownloading:
@@ -26,14 +27,21 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
                 return false
             }
         }
+
+        var textValue: CVTextValue? {
+            bodyText.textValue(isTextExpanded: isTextExpanded)
+        }
     }
     private let bodyTextState: State
 
     private var bodyText: CVComponentState.BodyText {
         bodyTextState.bodyText
     }
-    private var isTruncatedTextVisible: Bool {
-        bodyTextState.isTruncatedTextVisible
+    private var textValue: CVTextValue? {
+        bodyTextState.textValue
+    }
+    private var isTextExpanded: Bool {
+        bodyTextState.isTextExpanded
     }
     private var searchText: String? {
         bodyTextState.searchText
@@ -41,16 +49,8 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
     private var hasTapForMore: Bool {
         bodyTextState.hasTapForMore
     }
-
-    private var displayableBodyText: DisplayableText? {
-        switch bodyText.state {
-        case .bodyText(let displayableBodyText):
-            return displayableBodyText
-        case .oversizeTextDownloading:
-            return nil
-        case .remotelyDeleted:
-            return nil
-        }
+    public var shouldUseAttributedText: Bool {
+        bodyTextState.shouldUseAttributedText
     }
 
     init(itemModel: CVItemModel, bodyTextState: State) {
@@ -64,12 +64,43 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
     }
 
     private var isJumbomoji: Bool {
-        guard isTextOnlyMessage,
-              let displayableBodyText = self.displayableBodyText,
-              displayableBodyText.jumbomojiCount > 0 else {
-            return false
+        componentState.isJumbomojiMessage
+    }
+
+    private static func buildDataDetectorWithLinks(shouldAllowLinkification: Bool) -> NSDataDetector? {
+        let uiDataDetectorTypes: UIDataDetectorTypes = (shouldAllowLinkification
+                                                            ? kOWSAllowedDataDetectorTypes
+                                                            : kOWSAllowedDataDetectorTypesExceptLinks)
+        var nsDataDetectorTypes: NSTextCheckingTypes = 0
+        if uiDataDetectorTypes.contains(UIDataDetectorTypes.link) {
+            nsDataDetectorTypes |= NSTextCheckingResult.CheckingType.link.rawValue
+        }
+        if uiDataDetectorTypes.contains(UIDataDetectorTypes.address) {
+            nsDataDetectorTypes |= NSTextCheckingResult.CheckingType.address.rawValue
+        }
+        // TODO: There doesn't seem to be an equivalent to UIDataDetectorTypes.calendarEvent.
+
+        do {
+            return try NSDataDetector(types: nsDataDetectorTypes)
+        } catch {
+            owsFailDebug("Error: \(error)")
+            return nil
         }
-        return true
+    }
+
+    private static var dataDetectorWithLinks: NSDataDetector? = {
+        buildDataDetectorWithLinks(shouldAllowLinkification: true)
+    }()
+
+    private static var dataDetectorWithoutLinks: NSDataDetector? = {
+        buildDataDetectorWithLinks(shouldAllowLinkification: false)
+    }()
+
+    // DataDetectors are expensive to build, so we reuse them.
+    private static func dataDetector(shouldAllowLinkification: Bool) -> NSDataDetector? {
+        assertOnQueue(CVUtils.workQueue)
+
+        return shouldAllowLinkification ? dataDetectorWithLinks : dataDetectorWithoutLinks
     }
 
     static func buildState(interaction: TSInteraction,
@@ -78,21 +109,91 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
                            hasTapForMore: Bool) -> State {
         let textExpansion = viewStateSnapshot.textExpansion
         let searchText = viewStateSnapshot.searchText
+        let isTextExpanded = textExpansion.isTextExpanded(interactionId: interaction.uniqueId)
+
+        var shouldUseAttributedText = false
+        if let displayableText = bodyText.displayableText,
+           let textValue = bodyText.textValue(isTextExpanded: isTextExpanded) {
+            switch textValue {
+            case .text(let text):
+                // UILabels are much cheaper than UITextViews, and we can
+                // usually use them for rendering body text.
+                //
+                // We need to use attributed text in a UITextViews if:
+                //
+                // * We're displaying search results (and need to highlight matches).
+                // * The text value is an attributed string (has mentions).
+                // * The text value should be linkified.
+                if searchText != nil {
+                    shouldUseAttributedText = true
+                } else {
+                    // NSDataDetector and UIDataDetector behavior should be aligned.
+                    //
+                    // TODO: We might want to move this detection logic into
+                    // DisplayableText so that we can leverage caching.
+                    if let detector = dataDetector(shouldAllowLinkification: displayableText.shouldAllowLinkification) {
+                        shouldUseAttributedText = !detector.matches(in: text, options: [], range: text.entireRange).isEmpty
+                    } else {
+                        // If the data detectors can't be built, default to using attributed text.
+                        shouldUseAttributedText = true
+                    }
+                }
+            case .attributedText:
+                shouldUseAttributedText = true
+            }
+        }
 
-        let isTruncatedTextVisible = textExpansion.isTextExpanded(interactionId: interaction.uniqueId)
         return State(bodyText: bodyText,
-                     isTruncatedTextVisible: isTruncatedTextVisible,
+                     isTextExpanded: isTextExpanded,
                      searchText: searchText,
-                     hasTapForMore: hasTapForMore)
+                     hasTapForMore: hasTapForMore,
+                     shouldUseAttributedText: shouldUseAttributedText)
+    }
+
+    static func buildComponentState(message: TSMessage,
+                                    transaction: SDSAnyReadTransaction) throws -> CVComponentState.BodyText? {
+
+        func build(displayableText: DisplayableText) -> CVComponentState.BodyText? {
+            guard !displayableText.fullTextValue.stringValue.isEmpty else {
+                return nil
+            }
+            return .bodyText(displayableText: displayableText)
+        }
+
+        // TODO: We might want to treat text that is completely stripped
+        // as not present.
+        if let oversizeTextAttachment = message.oversizeTextAttachment(with: transaction.unwrapGrdbRead) {
+            if let oversizeTextAttachmentStream = oversizeTextAttachment as? TSAttachmentStream {
+                let displayableText = CVComponentState.displayableBodyText(oversizeTextAttachment: oversizeTextAttachmentStream,
+                                                                           ranges: message.bodyRanges,
+                                                                           interaction: message,
+                                                                           transaction: transaction)
+                return build(displayableText: displayableText)
+            } else if nil != oversizeTextAttachment as? TSAttachmentPointer {
+                // TODO: Handle backup restore.
+                // TODO: If there's media, should we display that while the oversize text is downloading?
+                return .oversizeTextDownloading
+            } else {
+                throw OWSAssertionError("Invalid oversizeTextAttachment.")
+            }
+        } else if let body = message.body, !body.isEmpty {
+            let displayableText = CVComponentState.displayableBodyText(text: body,
+                                                                       ranges: message.bodyRanges,
+                                                                       interaction: message,
+                                                                       transaction: transaction)
+            return build(displayableText: displayableText)
+        } else {
+            // No body text.
+            return nil
+        }
     }
 
     private var textMessageFont: UIFont {
         owsAssertDebug(DisplayableText.kMaxJumbomojiCount == 5)
 
-        if let displayableBodyText = self.displayableBodyText,
-           isJumbomoji {
+        if isJumbomoji, let jumbomojiCount = bodyText.jumbomojiCount {
             let basePointSize = UIFont.ows_dynamicTypeBodyClamped.pointSize
-            switch displayableBodyText.jumbomojiCount {
+            switch jumbomojiCount {
             case 0:
                 break
             case 1:
@@ -106,7 +207,7 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             case 5:
                 return UIFont.ows_regularFont(withSize: basePointSize * 2.25)
             default:
-                owsFailDebug("Unexpected jumbomoji count: \(displayableBodyText.jumbomojiCount)")
+                owsFailDebug("Unexpected jumbomoji count: \(jumbomojiCount)")
                 break
             }
         }
@@ -132,10 +233,9 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
         let hStackView = componentView.hStackView
         hStackView.apply(config: stackViewConfig)
 
-        switch bodyText.state {
-        case .bodyText(let displayableBodyText):
-            configureForBodyText(componentView: componentView,
-                                 displayableBodyText: displayableBodyText)
+        switch bodyText {
+        case .bodyText(let displayableText):
+            configureForBodyText(componentView: componentView, displayableText: displayableText)
         case .oversizeTextDownloading:
             owsAssertDebug(!componentView.isDedicatedCellView)
 
@@ -148,51 +248,64 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
     }
 
     private func configureForRemotelyDeleted(componentView: CVComponentViewBodyText) {
-        // TODO: The border, foreground and background colors are wrong.
-        configureForLabel(componentView: componentView,
+        // TODO: Set accessibilityLabel.
+        _ = configureForLabel(componentView: componentView,
                           labelConfig: labelConfigForRemotelyDeleted)
     }
 
     private func configureForOversizeTextDownloading(componentView: CVComponentViewBodyText) {
-        configureForLabel(componentView: componentView,
+        // TODO: Set accessibilityLabel.
+        _ = configureForLabel(componentView: componentView,
                           labelConfig: labelConfigForOversizeTextDownloading)
     }
 
     private func configureForLabel(componentView: CVComponentViewBodyText,
-                                   labelConfig: CVLabelConfig) {
-        let label = componentView.label
+                                   labelConfig: CVLabelConfig) -> UILabel {
+        let label = componentView.ensuredLabel
         labelConfig.applyForRendering(label: label)
-        label.setCompressionResistanceVerticalHigh()
 
-        let hStackView = componentView.hStackView
-        hStackView.addArrangedSubview(label)
+        label.isHidden = false
+        if label.superview == nil {
+            let hStackView = componentView.hStackView
+            hStackView.addArrangedSubview(label)
+            label.setCompressionResistanceVerticalHigh()
+        }
+        componentView.possibleTextView?.isHidden = true
+
+        return label
     }
 
     public func configureForBodyText(componentView: CVComponentViewBodyText,
-                                     displayableBodyText: DisplayableText) {
+                                     displayableText: DisplayableText) {
+
+        switch textConfig(displayableText: displayableText) {
+        case .labelConfig(let labelConfig):
+            let label = configureForLabel(componentView: componentView, labelConfig: labelConfig)
+            label.accessibilityLabel = accessibilityLabel(description: labelConfig.stringValue)
+        case .textViewConfig(let textViewConfig):
+            let textView = componentView.ensuredTextView
+
+            var shouldIgnoreEvents = false
+            if let outgoingMessage = interaction as? TSOutgoingMessage {
+                // Ignore taps on links in outgoing messages that haven't been sent yet, as
+                // this interferes with "tap to retry".
+                shouldIgnoreEvents = outgoingMessage.messageState != .sent
+            }
+            textView.shouldIgnoreEvents = shouldIgnoreEvents
 
-        let hStackView = componentView.hStackView
-        let textView = componentView.textView
+            textView.ensureShouldLinkifyText(displayableText.shouldAllowLinkification)
 
-        var shouldIgnoreEvents = false
-        if let outgoingMessage = interaction as? TSOutgoingMessage {
-            // Ignore taps on links in outgoing messages that haven't been sent yet, as
-            // this interferes with "tap to retry".
-            shouldIgnoreEvents = outgoingMessage.messageState != .sent
-        }
-        textView.shouldIgnoreEvents = shouldIgnoreEvents
+            textViewConfig.applyForRendering(textView: textView)
 
-        textView.ensureShouldLinkifyText(displayableBodyText.shouldAllowLinkification)
+            textView.accessibilityLabel = accessibilityLabel(description: textViewConfig.stringValue)
 
-        let textViewConfig = self.textViewConfig(displayableBodyText: displayableBodyText)
-        textViewConfig.applyForRendering(textView: textView)
-        let isReusing = componentView.rootView.superview != nil
-        if !isReusing {
-            hStackView.addArrangedSubview(textView)
+            textView.isHidden = false
+            if textView.superview == nil {
+                let hStackView = componentView.hStackView
+                hStackView.addArrangedSubview(textView)
+            }
+            componentView.possibleLabel?.isHidden = true
         }
-
-        let accessibilityDescription = displayableBodyText.displayAttributedText.string
-        textView.accessibilityLabel = accessibilityLabel(description: accessibilityDescription)
     }
 
     private var stackViewConfig: CVStackViewConfig {
@@ -221,7 +334,35 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
                              textAlignment: .center)
     }
 
-    private func textViewConfig(displayableBodyText: DisplayableText) -> CVTextViewConfig {
+    private enum TextConfig {
+        case labelConfig(labelConfig: CVLabelConfig)
+        case textViewConfig(textViewConfig: CVTextViewConfig)
+    }
+
+    private func textConfig(displayableText: DisplayableText) -> TextConfig {
+
+        let textValue = displayableText.textValue(isTextExpanded: isTextExpanded)
+
+        switch textValue {
+        case .text(let text):
+            if shouldUseAttributedText {
+                let attributedText = NSAttributedString(string: text)
+                let textViewConfig = self.textViewConfig(displayableText: displayableText,
+                                                         attributedText: attributedText)
+                return .textViewConfig(textViewConfig: textViewConfig)
+            } else {
+                let labelConfig = CVLabelConfig(text: text, font: textMessageFont, textColor: bodyTextColor)
+                return .labelConfig(labelConfig: labelConfig)
+            }
+        case .attributedText(let attributedText):
+            let textViewConfig = self.textViewConfig(displayableText: displayableText,
+                                                     attributedText: attributedText)
+            return .textViewConfig(textViewConfig: textViewConfig)
+        }
+    }
+
+    private func textViewConfig(displayableText: DisplayableText,
+                                attributedText attributedTextParam: NSAttributedString) -> CVTextViewConfig {
 
         // Honor dynamic type in the message bodies.
         let linkTextAttributes: [NSAttributedString.Key: Any] = [
@@ -229,21 +370,14 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             NSAttributedString.Key.underlineStyle: NSUnderlineStyle.single.rawValue
         ]
 
-        let displayableAttributedText: NSAttributedString
-        let displayableTextAlignment: NSTextAlignment
-        if displayableBodyText.isTextTruncated && isTruncatedTextVisible {
-            displayableAttributedText = displayableBodyText.fullAttributedText
-            displayableTextAlignment = displayableBodyText.fullTextNaturalAlignment
-        } else {
-            owsAssertDebug(!isTruncatedTextVisible)
-            displayableAttributedText = displayableBodyText.displayAttributedText
-            displayableTextAlignment = displayableBodyText.displayTextNaturalAlignment
-        }
+        let textAlignment = (isTextExpanded
+                                ? displayableText.fullTextNaturalAlignment
+                                : displayableText.displayTextNaturalAlignment)
 
         let paragraphStyle = NSMutableParagraphStyle()
-        paragraphStyle.alignment = displayableTextAlignment
+        paragraphStyle.alignment = textAlignment
 
-        let attributedText = displayableAttributedText.mutableCopy() as! NSMutableAttributedString
+        let attributedText = attributedTextParam.mutableCopy() as! NSMutableAttributedString
         attributedText.addAttributes(
             [
                 .font: textMessageFont,
@@ -280,11 +414,14 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
     public func measure(maxWidth: CGFloat, measurementBuilder: CVCellMeasurement.Builder) -> CGSize {
         owsAssertDebug(maxWidth > 0)
 
-        switch bodyText.state {
-        case .bodyText(let displayableBodyText):
-            let textViewConfig = self.textViewConfig(displayableBodyText: displayableBodyText)
-            let bodyTextSize = CVText.measureTextView(config: textViewConfig, maxWidth: maxWidth)
-            return bodyTextSize.ceil
+        switch bodyText {
+        case .bodyText(let displayableText):
+            switch textConfig(displayableText: displayableText) {
+            case .labelConfig(let labelConfig):
+                return CVText.measureLabel(config: labelConfig, maxWidth: maxWidth).ceil
+            case .textViewConfig(let textViewConfig):
+                return CVText.measureTextView(config: textViewConfig, maxWidth: maxWidth).ceil
+            }
         case .oversizeTextDownloading:
             return CVText.measureLabel(config: labelConfigForOversizeTextDownloading, maxWidth: maxWidth).ceil
         case .remotelyDeleted:
@@ -325,7 +462,7 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
             owsFailDebug("Unexpected componentView.")
             return nil
         }
-        let textView = componentView.textView
+        let textView = componentView.ensuredTextView
         let location = sender.location(in: textView)
         guard textView.bounds.contains(location) else {
             return nil
@@ -357,8 +494,29 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
         public weak var componentDelegate: CVComponentDelegate?
 
         fileprivate let hStackView = OWSStackView(name: "bodyText")
-        fileprivate let textView: OWSMessageTextView
-        fileprivate let label = UILabel()
+
+        private var _textView: OWSMessageTextView?
+        fileprivate var possibleTextView: OWSMessageTextView? { _textView }
+        fileprivate var ensuredTextView: OWSMessageTextView {
+            if let textView = _textView {
+                return textView
+            }
+            let textView = Self.buildTextView()
+            textView.delegate = self
+            _textView = textView
+            return textView
+        }
+
+        private var _label: UILabel?
+        fileprivate var possibleLabel: UILabel? { _label }
+        fileprivate var ensuredLabel: UILabel {
+            if let label = _label {
+                return label
+            }
+            let label = UILabel()
+            _label = label
+            return label
+        }
 
         public var isDedicatedCellView = false
 
@@ -368,11 +526,8 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
 
         required init(componentDelegate: CVComponentDelegate) {
             self.componentDelegate = componentDelegate
-            textView = Self.buildTextView()
 
             super.init()
-
-            textView.delegate = self
         }
 
         public func setIsCellVisible(_ isCellVisible: Bool) {}
@@ -388,8 +543,8 @@ public class CVComponentBodyText: CVComponentBase, CVComponent {
                 hStackView.reset()
             }
 
-            textView.text = nil
-            label.text = nil
+            _textView?.text = nil
+            _label?.text = nil
         }
 
         // MARK: - UITextViewDelegate
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewModel.swift b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewModel.swift
index 46ba3847de9..9c98c711b62 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewModel.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewModel.swift
@@ -73,15 +73,7 @@ extension CVItemViewModelImpl: CVItemViewModel {
     public var displayableBodyText: DisplayableText? {
         AssertIsOnMainThread()
 
-        guard let bodyText = componentState.bodyText else {
-            return nil
-        }
-        switch bodyText.state {
-        case .bodyText(let displayableBodyText):
-            return displayableBodyText
-        case .oversizeTextDownloading, .remotelyDeleted:
-            return nil
-        }
+        return componentState.bodyText?.displayableText
     }
 
     public var isViewOnce: Bool {
@@ -155,8 +147,7 @@ extension CVItemViewModelImpl: CVItemViewModel {
 
     public var hasUnloadedAttachments: Bool {
 
-        if let bodyText = componentState.bodyText,
-           bodyText.state == .oversizeTextDownloading {
+        if componentState.bodyText == .oversizeTextDownloading {
             return true
         }
         if componentState.audioAttachment?.attachment as? TSAttachmentPointer != nil {
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
index a907b15347e..fd8b5744d96 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
@@ -211,10 +211,10 @@ struct CVItemModelBuilder: CVItemBuilding {
 
         let hasTapForMore: Bool = {
             guard let bodyText = item.componentState.bodyText,
-                  let displayableBodyText = bodyText.displayableBodyText else {
+                  let displayableText = bodyText.displayableText else {
                 return false
             }
-            guard displayableBodyText.isTextTruncated else {
+            guard displayableText.isTextTruncated else {
                 return false
             }
             let interactionId = item.interaction.uniqueId
diff --git a/SignalMessaging/Views/CVText.swift b/SignalMessaging/Views/CVText.swift
index abf625485e4..c226d0dfd03 100644
--- a/SignalMessaging/Views/CVText.swift
+++ b/SignalMessaging/Views/CVText.swift
@@ -6,7 +6,7 @@ import Foundation
 
 private typealias CacheKey = String
 
-private enum CVTextValue: Equatable, Hashable {
+public enum CVTextValue: Equatable, Hashable {
     case text(text: String)
     case attributedText(attributedText: NSAttributedString)
 
@@ -28,6 +28,15 @@ private enum CVTextValue: Equatable, Hashable {
         }
     }
 
+    public var stringValue: String {
+        switch self {
+        case .text(let text):
+            return text
+        case .attributedText(let attributedText):
+            return attributedText.string
+        }
+    }
+
     var debugDescription: String {
         switch self {
         case .text(let text):
@@ -136,6 +145,10 @@ public struct CVLabelConfig {
         CVText.measureLabel(config: self, maxWidth: maxWidth)
     }
 
+    public var stringValue: String {
+        text.stringValue
+    }
+
     public var debugDescription: String {
         "CVLabelConfig: \(text.debugDescription)"
     }
@@ -234,6 +247,10 @@ public struct CVTextViewConfig {
         CVText.measureTextView(config: self, maxWidth: maxWidth)
     }
 
+    public var stringValue: String {
+        text.stringValue
+    }
+
     public var debugDescription: String {
         "CVTextViewConfig: \(text.debugDescription)"
     }
diff --git a/SignalMessaging/Views/Mentions/Mention.swift b/SignalMessaging/Views/Mentions/Mention.swift
index 37085c46507..b60f82aae38 100644
--- a/SignalMessaging/Views/Mentions/Mention.swift
+++ b/SignalMessaging/Views/Mentions/Mention.swift
@@ -145,6 +145,17 @@ extension MessageBody {
         self.init(text: mutableAttributedString.string, ranges: .init(mentions: mentions))
     }
 
+    public func textValue(style: Mention.Style,
+                          attributes: [NSAttributedString.Key: Any],
+                          shouldResolveAddress: (SignalServiceAddress) -> Bool,
+                          transaction: GRDBReadTransaction) -> CVTextValue {
+        ranges.textValue(text: text,
+                         style: style,
+                         attributes: attributes,
+                         shouldResolveAddress: shouldResolveAddress,
+                         transaction: transaction)
+    }
+
     @objc
     public func attributedBody(
         style: Mention.Style,
@@ -163,6 +174,24 @@ extension MessageBody {
 }
 
 extension MessageBodyRanges {
+
+    public func textValue(text: String,
+                          style: Mention.Style,
+                          attributes: [NSAttributedString.Key: Any],
+                          shouldResolveAddress: (SignalServiceAddress) -> Bool,
+                          transaction: GRDBReadTransaction) -> CVTextValue {
+
+        guard hasMentions || !attributes.isEmpty else {
+            return .text(text: text)
+        }
+        let attributedText = attributedBody(text: text,
+                                            style: style,
+                                            attributes: attributes,
+                                            shouldResolveAddress: shouldResolveAddress,
+                                            transaction: transaction)
+        return .attributedText(attributedText: attributedText)
+    }
+
     @objc
     public func attributedBody(
         text: String,
diff --git a/SignalMessaging/Views/OWSTextView.h b/SignalMessaging/Views/OWSTextView.h
index 0e63c7f7a0c..eae7f412ac0 100644
--- a/SignalMessaging/Views/OWSTextView.h
+++ b/SignalMessaging/Views/OWSTextView.h
@@ -1,10 +1,11 @@
 //
-//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
 //
 
 NS_ASSUME_NONNULL_BEGIN
 
 extern const UIDataDetectorTypes kOWSAllowedDataDetectorTypes;
+extern const UIDataDetectorTypes kOWSAllowedDataDetectorTypesExceptLinks;
 
 @interface OWSTextView : UITextView
 
diff --git a/SignalMessaging/utils/DisplayableText.swift b/SignalMessaging/utils/DisplayableText.swift
index 5f9553d9792..6a9b2761d7f 100644
--- a/SignalMessaging/utils/DisplayableText.swift
+++ b/SignalMessaging/utils/DisplayableText.swift
@@ -4,19 +4,56 @@
 
 import Foundation
 
-@objc public class DisplayableText: NSObject {
+@objc
+public class DisplayableText: NSObject {
 
     private struct Content {
-        let attributedText: NSAttributedString
+        let textValue: CVTextValue
         let naturalAlignment: NSTextAlignment
+
+        var stringValue: String { textValue.stringValue }
+    }
+
+    private let _fullContent: AtomicValue<Content>
+    private var fullContent: Content {
+        get { _fullContent.get() }
+        set { _fullContent.set(newValue) }
+    }
+
+    private let _truncatedContent = AtomicOptional<Content>(nil)
+    private var truncatedContent: Content? {
+        get { _truncatedContent.get() }
+        set { _truncatedContent.set(newValue) }
+    }
+
+    public var fullTextValue: CVTextValue {
+        fullContent.textValue
     }
 
-    private var fullContent: Content
-    private var truncatedContent: Content?
+    public var truncatedTextValue: CVTextValue? {
+        truncatedContent?.textValue
+    }
+
+    public var displayTextValue: CVTextValue {
+        return truncatedContent?.textValue ?? fullContent.textValue
+    }
+
+    public func textValue(isTextExpanded: Bool) -> CVTextValue {
+        if isTextExpanded {
+            return fullTextValue
+        } else {
+            return displayTextValue
+        }
+    }
 
     @objc
     public var fullAttributedText: NSAttributedString {
-        return fullContent.attributedText
+        switch fullContent.textValue {
+        case .text(let text):
+            return NSAttributedString(string: text)
+        case .attributedText(let attributedText):
+            return attributedText
+        }
     }
 
     @objc
@@ -26,7 +63,13 @@ import Foundation
 
     @objc
     public var displayAttributedText: NSAttributedString {
-        return truncatedContent?.attributedText ?? fullContent.attributedText
+        let content = truncatedContent ?? fullContent
+        switch content.textValue {
+        case .text(let text):
+            return NSAttributedString(string: text)
+        case .attributedText(let attributedText):
+            return attributedText
+        }
     }
 
     @objc
@@ -63,10 +106,10 @@ import Foundation
     // MARK: Initializers
 
     private init(fullContent: Content, truncatedContent: Content?) {
-        self.fullContent = fullContent
-        self.truncatedContent = truncatedContent
-        self.jumbomojiCount = DisplayableText.jumbomojiCount(in: fullContent.attributedText.string)
-        self.fullLengthWithNewLineScalar = DisplayableText.fullLengthWithNewLineScalar(in: fullContent.attributedText.string)
+        self._fullContent = AtomicValue(fullContent)
+        self._truncatedContent.set(truncatedContent)
+        self.jumbomojiCount = DisplayableText.jumbomojiCount(in: fullContent.stringValue)
+        self.fullLengthWithNewLineScalar = DisplayableText.fullLengthWithNewLineScalar(in: fullContent.stringValue)
 
         super.init()
 
@@ -78,22 +121,27 @@ import Foundation
         )
     }
 
-    @objc private func themeDidChange() {
+    @objc
+    private func themeDidChange() {
         // When the theme changes, we must refresh any mention attributes.
-        let mutableFullText = NSMutableAttributedString(attributedString: fullAttributedText)
-        Mention.refreshAttributes(in: mutableFullText)
-        fullContent = Content(
-            attributedText: mutableFullText,
-            naturalAlignment: fullContent.naturalAlignment
-        )
+        func updateContent(_ content: Content) -> Content {
+            switch content.textValue {
+            case .text:
+                // We only need to update attributedText.
+                return content
+            case .attributedText(let attributedText):
+                let mutableFullText = NSMutableAttributedString(attributedString: attributedText)
+                Mention.refreshAttributes(in: mutableFullText)
+                return Content(textValue: .attributedText(attributedText: mutableFullText),
+                               naturalAlignment: content.naturalAlignment)
+            }
+        }
+
+        // When the theme changes, we must refresh any mention attributes.
+        fullContent = updateContent(fullContent)
 
         if let truncatedContent = truncatedContent {
-            let mutableTruncatedText = NSMutableAttributedString(attributedString: truncatedContent.attributedText)
-            Mention.refreshAttributes(in: mutableTruncatedText)
-            self.truncatedContent = Content(
-                attributedText: mutableTruncatedText,
-                naturalAlignment: truncatedContent.naturalAlignment
-            )
+            self.truncatedContent = updateContent(truncatedContent)
         }
     }
 
@@ -166,7 +214,7 @@ import Foundation
             }
         }
 
-        let rawText = fullAttributedText.string
+        let rawText = fullContent.stringValue
 
         for match in linkDetector.matches(in: rawText, options: [], range: rawText.entireRange) {
             guard let matchURL: URL = match.url else {
@@ -203,7 +251,7 @@ import Foundation
     @objc
     public class var empty: DisplayableText {
         return DisplayableText(
-            fullContent: .init(attributedText: .init(string: ""), naturalAlignment: .natural),
+            fullContent: .init(textValue: .text(text: ""), naturalAlignment: .natural),
             truncatedContent: nil
         )
     }
@@ -211,22 +259,21 @@ import Foundation
     @objc
     public class func displayableTextForTests(_ text: String) -> DisplayableText {
         return DisplayableText(
-            fullContent: .init(attributedText: .init(string: text), naturalAlignment: text.naturalTextAlignment),
+            fullContent: .init(textValue: .text(text: text),
+                               naturalAlignment: text.naturalTextAlignment),
             truncatedContent: nil
         )
     }
 
     @objc
     public class func displayableText(withMessageBody messageBody: MessageBody, mentionStyle: Mention.Style, transaction: SDSAnyReadTransaction) -> DisplayableText {
-        let fullAttributedText = messageBody.attributedBody(
-            style: mentionStyle,
-            attributes: [:],
-            shouldResolveAddress: { _ in true }, // Resolve all mentions in messages.
-            transaction: transaction.unwrapGrdbRead
-        )
+        let textValue = messageBody.textValue(style: mentionStyle,
+                                              attributes: [:],
+                                              shouldResolveAddress: { _ in true }, // Resolve all mentions in messages.
+                                              transaction: transaction.unwrapGrdbRead)
         let fullContent = Content(
-            attributedText: fullAttributedText,
-            naturalAlignment: fullAttributedText.string.naturalTextAlignment
+            textValue: textValue,
+            naturalAlignment: textValue.stringValue.naturalTextAlignment
         )
 
         // Only show up to N characters of text.
@@ -234,13 +281,13 @@ import Foundation
         let kMaxSnippetNewLines = 15
         let truncatedContent: Content?
 
-        if fullAttributedText.string.count > kMaxTextDisplayLength {
+        if fullContent.stringValue.count > kMaxTextDisplayLength {
             var snippetLength = kMaxTextDisplayLength
 
             // Message bubbles by default should be short. We don't ever
-            // want to show more than X new lines in the truncated text.po
+            // want to show more than X new lines in the truncated text.
             let newLineMatches = newLineRegex.matches(
-                in: fullAttributedText.string,
+                in: fullContent.stringValue,
                 options: [],
                 range: NSRange(location: 0, length: kMaxTextDisplayLength)
             )
@@ -248,30 +295,35 @@ import Foundation
                 snippetLength = newLineMatches[kMaxSnippetNewLines - 1].range.location
             }
 
-            var mentionRange = NSRange()
-            let possibleOverlappingMention = fullAttributedText.attribute(
-                .mention,
-                at: snippetLength,
-                longestEffectiveRange: &mentionRange,
-                in: fullAttributedText.entireRange
-            )
-
-            // There's a mention overlapping our normal truncate point, we want to truncate sooner
-            // so we don't "split" the mention.
-            if possibleOverlappingMention != nil && mentionRange.location < snippetLength {
-                snippetLength = mentionRange.location
+            switch textValue {
+            case .text(let text):
+                let truncatedText = text.substring(to: snippetLength)
+                truncatedContent = Content(textValue: .text(text: truncatedText),
+                                           naturalAlignment: truncatedText.naturalTextAlignment)
+            case .attributedText(let attributedText):
+                var mentionRange = NSRange()
+                let possibleOverlappingMention = attributedText.attribute(
+                    .mention,
+                    at: snippetLength,
+                    longestEffectiveRange: &mentionRange,
+                    in: attributedText.entireRange
+                )
+
+                // There's a mention overlapping our normal truncate point, we want to truncate sooner
+                // so we don't "split" the mention.
+                if possibleOverlappingMention != nil && mentionRange.location < snippetLength {
+                    snippetLength = mentionRange.location
+                }
+
+                // Trim whitespace before _AND_ after slicing the snipper from the string.
+                let truncatedAttributedText = attributedText
+                    .attributedSubstring(from: NSRange(location: 0, length: snippetLength))
+                    .ows_stripped()
+                    .stringByAppendingString("…")
+
+                truncatedContent = Content(textValue: .attributedText(attributedText: truncatedAttributedText),
+                                           naturalAlignment: truncatedAttributedText.string.naturalTextAlignment)
             }
-
-            // Trim whitespace before _AND_ after slicing the snipper from the string.
-            let truncatedAttributedText = fullAttributedText
-                .attributedSubstring(from: NSRange(location: 0, length: snippetLength))
-                .ows_stripped()
-                .stringByAppendingString("…")
-
-            truncatedContent = Content(
-                attributedText: truncatedAttributedText,
-                naturalAlignment: truncatedAttributedText.string.naturalTextAlignment
-            )
         } else {
             truncatedContent = nil
         }
