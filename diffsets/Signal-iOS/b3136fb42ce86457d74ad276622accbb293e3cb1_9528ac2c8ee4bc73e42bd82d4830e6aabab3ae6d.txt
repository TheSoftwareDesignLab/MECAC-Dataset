diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index a85b5e976f1..3763e0fa757 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -771,12 +771,16 @@
 		661396AD28BE74DC00E0C4DF /* ChainedPromise.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661396AC28BE74DC00E0C4DF /* ChainedPromise.swift */; };
 		661396AF28BE881E00E0C4DF /* ChainedPromiseTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661396AE28BE881E00E0C4DF /* ChainedPromiseTest.swift */; };
 		661602A428BEB94400C1932D /* StoryListDataSource.swift in Sources */ = {isa = PBXBuildFile; fileRef = 661602A328BEB94400C1932D /* StoryListDataSource.swift */; };
+		662ABF3329510F8300518D90 /* OutgoingCallEventSyncMessage.h in Headers */ = {isa = PBXBuildFile; fileRef = 6640639A294D1F8D00997E0B /* OutgoingCallEventSyncMessage.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		663D6A7C292319BC00CABC49 /* ConversationPickerFailedRecipientsSheet.swift in Sources */ = {isa = PBXBuildFile; fileRef = 663D6A7B292319BC00CABC49 /* ConversationPickerFailedRecipientsSheet.swift */; };
+		6640639C294D201F00997E0B /* OutgoingCallEventSyncMessage.m in Sources */ = {isa = PBXBuildFile; fileRef = 6640639B294D201F00997E0B /* OutgoingCallEventSyncMessage.m */; };
+		6640639E294D20A900997E0B /* OutgoingCallEventSyncMessage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6640639D294D20A900997E0B /* OutgoingCallEventSyncMessage.swift */; };
 		66586D3729005A1B00DDA9B9 /* story_viewer_onboarding_2.json in Resources */ = {isa = PBXBuildFile; fileRef = 66586D3429005A1B00DDA9B9 /* story_viewer_onboarding_2.json */; };
 		66586D3829005A1B00DDA9B9 /* story_viewer_onboarding_1.json in Resources */ = {isa = PBXBuildFile; fileRef = 66586D3529005A1B00DDA9B9 /* story_viewer_onboarding_1.json */; };
 		66586D3929005A1B00DDA9B9 /* story_viewer_onboarding_3.json in Resources */ = {isa = PBXBuildFile; fileRef = 66586D3629005A1B00DDA9B9 /* story_viewer_onboarding_3.json */; };
 		66586D4129009C0000DDA9B9 /* TextAttachment.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66586D4029009C0000DDA9B9 /* TextAttachment.swift */; };
 		665EF86D290C385B00F490D2 /* OWSNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 665EF86C290C385B00F490D2 /* OWSNavigationController.swift */; };
+		6675F64929258CA4007A311E /* CallRecord.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6675F64829258CA4007A311E /* CallRecord.swift */; };
 		6675F64D2925C012007A311E /* APNSRotationStore.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6675F64C2925C012007A311E /* APNSRotationStore.swift */; };
 		6675F64F29261C39007A311E /* SyncPushTokensJob.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6675F64E29261C39007A311E /* SyncPushTokensJob.swift */; };
 		6675F65129261E0C007A311E /* APNSRotationStoreTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6675F65029261E0C007A311E /* APNSRotationStoreTest.swift */; };
@@ -3079,12 +3083,16 @@
 		661396AE28BE881E00E0C4DF /* ChainedPromiseTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChainedPromiseTest.swift; sourceTree = "<group>"; };
 		661602A328BEB94400C1932D /* StoryListDataSource.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryListDataSource.swift; sourceTree = "<group>"; };
 		663D6A7B292319BC00CABC49 /* ConversationPickerFailedRecipientsSheet.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ConversationPickerFailedRecipientsSheet.swift; sourceTree = "<group>"; };
+		6640639A294D1F8D00997E0B /* OutgoingCallEventSyncMessage.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = OutgoingCallEventSyncMessage.h; sourceTree = "<group>"; };
+		6640639B294D201F00997E0B /* OutgoingCallEventSyncMessage.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = OutgoingCallEventSyncMessage.m; sourceTree = "<group>"; };
+		6640639D294D20A900997E0B /* OutgoingCallEventSyncMessage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OutgoingCallEventSyncMessage.swift; sourceTree = "<group>"; };
 		6657FDE7B91C2845BB3BEAB5 /* Pods_SignalShareExtension.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_SignalShareExtension.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		66586D3429005A1B00DDA9B9 /* story_viewer_onboarding_2.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = story_viewer_onboarding_2.json; sourceTree = "<group>"; };
 		66586D3529005A1B00DDA9B9 /* story_viewer_onboarding_1.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = story_viewer_onboarding_1.json; sourceTree = "<group>"; };
 		66586D3629005A1B00DDA9B9 /* story_viewer_onboarding_3.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = story_viewer_onboarding_3.json; sourceTree = "<group>"; };
 		66586D4029009C0000DDA9B9 /* TextAttachment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TextAttachment.swift; sourceTree = "<group>"; };
 		665EF86C290C385B00F490D2 /* OWSNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSNavigationController.swift; sourceTree = "<group>"; };
+		6675F64829258CA4007A311E /* CallRecord.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CallRecord.swift; sourceTree = "<group>"; };
 		6675F64C2925C012007A311E /* APNSRotationStore.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = APNSRotationStore.swift; sourceTree = "<group>"; };
 		6675F64E29261C39007A311E /* SyncPushTokensJob.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SyncPushTokensJob.swift; sourceTree = "<group>"; };
 		6675F65029261E0C007A311E /* APNSRotationStoreTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = APNSRotationStoreTest.swift; sourceTree = "<group>"; };
@@ -7402,6 +7410,7 @@
 				F9C5C968289453B100548EEE /* Stories */,
 				F9C5C95F289453B100548EEE /* UD */,
 				F9C5C940289453B100548EEE /* BlockingManager.swift */,
+				6675F64829258CA4007A311E /* CallRecord.swift */,
 				F9C5C943289453B100548EEE /* DeliveryReceiptContext.swift */,
 				F925A3AA29493D0C009024D0 /* DisappearingMessagesFinder.swift */,
 				F9C5C99D289453B100548EEE /* EarlyMessageManager.swift */,
@@ -7492,6 +7501,9 @@
 		F9C5C8B7289453B100548EEE /* DeviceSyncing */ = {
 			isa = PBXGroup;
 			children = (
+				6640639A294D1F8D00997E0B /* OutgoingCallEventSyncMessage.h */,
+				6640639B294D201F00997E0B /* OutgoingCallEventSyncMessage.m */,
+				6640639D294D20A900997E0B /* OutgoingCallEventSyncMessage.swift */,
 				F9C5C8D1289453B100548EEE /* OutgoingPaymentSyncMessage.h */,
 				F9C5C8C4289453B100548EEE /* OutgoingPaymentSyncMessage.m */,
 				F9C5C8BF289453B100548EEE /* OutgoingPaymentSyncMessage.swift */,
@@ -8560,6 +8572,7 @@
 				F9C5CE3D289453B400548EEE /* NSString+SSK.h in Headers */,
 				F9C5CE15289453B400548EEE /* NSTimer+OWS.h in Headers */,
 				F9C5CDE9289453B400548EEE /* NSUserDefaults+OWS.h in Headers */,
+				662ABF3329510F8300518D90 /* OutgoingCallEventSyncMessage.h in Headers */,
 				F9C5CBC6289453B300548EEE /* OutgoingPaymentSyncMessage.h in Headers */,
 				F9C5CE2C289453B400548EEE /* OWS2FAManager.h in Headers */,
 				F9C5CC1E289453B300548EEE /* OWSAddToContactsOfferMessage.h in Headers */,
@@ -10768,6 +10781,7 @@
 				E7D7C93F28B580AC003F043B /* Bundle+OWS.swift in Sources */,
 				F9C5CDE1289453B400548EEE /* ByteParser.m in Sources */,
 				F9C5CD32289453B300548EEE /* CallKitIdStore.m in Sources */,
+				6675F64929258CA4007A311E /* CallRecord.swift in Sources */,
 				17EC850C29133CDB00319C82 /* CancelledGroupRing.swift in Sources */,
 				F9C5CD8D289453B300548EEE /* CaptchaChallenge.swift in Sources */,
 				76387BF028F4ED73002C7BA5 /* CaseIterable.swift in Sources */,
@@ -10930,6 +10944,8 @@
 				F9C5CE43289453B400548EEE /* OrderedDictionary.swift in Sources */,
 				F9C5CE1E289453B400548EEE /* OrderedSet.swift in Sources */,
 				F9C5CD9F289453B400548EEE /* OutageDetection.swift in Sources */,
+				6640639C294D201F00997E0B /* OutgoingCallEventSyncMessage.m in Sources */,
+				6640639E294D20A900997E0B /* OutgoingCallEventSyncMessage.swift in Sources */,
 				F96A534328A1AE7C003262D4 /* OutgoingGroupUpdateMessage.swift in Sources */,
 				F9C5CC08289453B300548EEE /* OutgoingMessagePreparer.swift in Sources */,
 				F9C5CBB9289453B300548EEE /* OutgoingPaymentSyncMessage.m in Sources */,
diff --git a/Signal/src/Calls/Individual/IndividualCall.swift b/Signal/src/Calls/Individual/IndividualCall.swift
index d436b63eb7d..6ddf87b6024 100644
--- a/Signal/src/Calls/Individual/IndividualCall.swift
+++ b/Signal/src/Calls/Individual/IndividualCall.swift
@@ -72,7 +72,12 @@ public class IndividualCall: NSObject {
         didSet {
             AssertIsOnMainThread()
 
-            Logger.info("")
+            Logger.info("CallId added for call")
+            Self.databaseStorage.asyncWrite { transaction in
+                if let callInteraction = self.callInteraction {
+                    self.createOrUpdateCallRecordIfNeeded(for: callInteraction, transaction: transaction)
+                }
+            }
         }
     }
 
@@ -127,12 +132,25 @@ public class IndividualCall: NSObject {
 
     public let sentAtTimestamp: UInt64
 
-    public var callRecord: TSCall? {
+    /// Used by IndividualCallService to make decisions about what actions to take.
+    /// Not guaranteed to be up-to-date with what is in the database, but
+    /// is up to date with CallKit callbacks on the main thread.
+    /// Can be accessed from the main thread.
+    public private(set) var callType: RPRecentCallType?
+
+    /// Used internally for caching only.
+    /// Can be accessed only within write transactions.
+    private var callInteraction: TSCall? {
         didSet {
-            AssertIsOnMainThread()
             assert(oldValue == nil)
+        }
+    }
 
-            updateCallRecordType()
+    /// Used internally for caching only.
+    /// Can be accessed only within write transactions.
+    private var callRecord: CallRecord? {
+        didSet {
+            assert(oldValue == nil)
         }
     }
 
@@ -155,8 +173,22 @@ public class IndividualCall: NSObject {
             AssertIsOnMainThread()
             Logger.debug("state changed: \(oldValue) -> \(self.state) for call: \(self)")
 
-            updateCallRecordType()
-
+            let state = self.state
+            if let callType = self.callType {
+                Self.databaseStorage.asyncWrite {
+                    if
+                        let callInteraction = self.callInteraction,
+                        let newCallType = self.validateCallType(
+                            callType,
+                            state: state,
+                            for: callInteraction,
+                            transaction: $0
+                        )
+                    {
+                        self.createOrUpdateCallInteraction(callType: newCallType, transaction: $0)
+                    }
+                }
+            }
             delegate?.individualCallStateDidChange(self, state: state)
         }
     }
@@ -218,21 +250,177 @@ public class IndividualCall: NSObject {
         return "IndividualCall: {\(remoteAddress), signalingId: \(callId as Optional)))}"
     }
 
-    private func updateCallRecordType() {
-        AssertIsOnMainThread()
+    // MARK: - Fetching and updating db objects
+
+    public func createOrUpdateCallInteractionAsync(
+        callType: RPRecentCallType
+    ) {
+        // Set the call type immediately; additional CallKit callbacks might come in
+        // before we get the lock to write, and they may make decisions based on the
+        // last callType they tried to set.
+        // They _should not_ rely on the callType actually being set on the TSCall; TSCall fields
+        // should be read within write transactions if they will be used as inputs when determining
+        // what new state to write to TSCall.
+        // Write transactions should almost always be asyncWrite, which puts them in a queue and
+        // enforces FIFO ordering; sync writes skip the line and can cause older state to get
+        // written later. A sync write is used only for the initial call offer handling, as that
+        // is always the first write for any given call, anyway.
+        self.callType = callType
+        // Snapshot the state at the time we enqueued the write.
+        let state = self.state
+        Self.databaseStorage.asyncWrite {
+            self._createOrUpdateCallInteraction(
+                callType: callType,
+                state: state,
+                transaction: $0
+            )
+        }
+    }
+
+    public func createOrUpdateCallInteraction(
+        callType: RPRecentCallType,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        // We have to set this as soon as we can; see comment in async version above.
+        self.callType = callType
+        _createOrUpdateCallInteraction(
+            callType: callType,
+            state: self.state,
+            transaction: transaction
+        )
+    }
+
+    /// Finds any existing TSCalls if they exist, or creates a new one and inserts it into
+    /// the db if not.
+    ///
+    /// Looks for TSCalls in the following order:
+    /// * Cached in memory on IndividualCall (i.e. this call service already has dealt with it)
+    /// * On the interactions table, using the CallRecord table to bridge by callId
+    /// If the existing interaction needs updating to the new call type, updates it.
+    /// *WILL NOT* write other fields, as they are assumed to come from a linked device
+    /// that triggered the TSCall to be created and are therefore canonical.
+    private func _createOrUpdateCallInteraction(
+        callType: RPRecentCallType,
+        state: CallState,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        if let existingCall = self.callInteraction {
+            if let newCallType = self.validateCallType(callType, state: state, for: existingCall, transaction: transaction) {
+                existingCall.updateCallType(newCallType, transaction: transaction)
+            }
+            return
+        }
 
-        guard let callRecord = self.callRecord else {
+        if
+            // find a matching existing call interaction via call records.
+            // this happens if a call event sync message creates the record and
+            // interaction before callkit callbacks.
+            let callRecord = self.fetchCallRecord(transaction: transaction),
+            let existingCall = TSCall.anyFetchCall(
+                uniqueId: callRecord.interactionUniqueId,
+                transaction: transaction
+            )
+        {
+            self.callInteraction = existingCall
+            if let newCallType = self.validateCallType(callType, state: state, for: existingCall, transaction: transaction) {
+                existingCall.updateCallType(newCallType, transaction: transaction)
+            }
             return
         }
 
+        // Validation might modify the call type, but ignore if it tries to say we
+        // shouldn't update and fall back to the original value since we are creating,
+        // not updating.
+        let callType = self.validateCallType(callType, state: state, for: nil, transaction: transaction) ?? callType
+        // If we found nothing, create a new interaction.
+        let callInteraction = TSCall(
+            callType: callType,
+            offerType: self.offerMediaType,
+            thread: self.thread,
+            sentAtTimestamp: self.sentAtTimestamp
+        )
+        callInteraction.anyInsert(transaction: transaction)
+        self.callInteraction = callInteraction
+        createOrUpdateCallRecordIfNeeded(for: callInteraction, transaction: transaction)
+    }
+
+    private func fetchCallRecord(
+        transaction: SDSAnyReadTransaction
+    ) -> CallRecord? {
+        if let callRecord = callRecord {
+            return callRecord
+        }
+        guard let callId = callId else {
+            // Without a callId we can't look up a record.
+            return nil
+        }
+        let callRecord = CallRecord.fetch(forCallId: callId, transaction: transaction)
+        self.callRecord = callRecord
+        return callRecord
+    }
+
+    /// Takes a call type to apply to a TSCall, and returns nil if the update is illegal (should not be applied)
+    /// or the call type that should actually be applied, which can be the same or different.
+    /// Pass nil for the TSCall if creating a new one.
+    ///
+    /// We can't blindly update the TSCall's status based on CallKit callbacks.
+    /// The status might be set by a linked device via call event syncs, so we should
+    /// check that the transition is valid and only update if so.
+    /// (e.g. if a linked device picks up as we decline, we should leave it as accepted)
+    private func validateCallType(
+        _ callType: RPRecentCallType,
+        state: CallState,
+        for callInteraction: TSCall?,
+        transaction: SDSAnyReadTransaction
+    ) -> RPRecentCallType? {
+        var callType = callType
         // Mark incomplete calls as completed if call has connected.
-        if state == .connected &&
-            callRecord.callType == .outgoingIncomplete {
-            callRecord.updateCallType(.outgoing)
+        if state == .connected, callType == .outgoingIncomplete {
+            callType = .outgoing
         }
-        if state == .connected &&
-            callRecord.callType == .incomingIncomplete {
-            callRecord.updateCallType(.incoming)
+        if state == .connected, callType == .incomingIncomplete {
+            callType = .incoming
+        }
+
+        guard let callInteraction = callInteraction else {
+            // No further checks if we are creating a new one.
+            return callType
+        }
+        // Otherwise we are updated and need to check if transition
+        // is valid.
+        guard callInteraction.callType != callType else {
+            return nil
+        }
+        guard
+            let callRecord = fetchCallRecord(transaction: transaction),
+            let newStatus = callType.callRecordStatus
+        else {
+            return callType
+        }
+        // Multiple RPRecentCallTypes can map to the same CallRecord.Status,
+        // but transitioning from a CallRecord.Status to itself is invalid.
+        // Catch this case by letting the RPRecentCallType through if
+        // it is different (checked above) but the mapped status is the same.
+        guard callRecord.status == newStatus
+                || CallRecord.isAllowedTransition(from: callRecord.status, to: newStatus)
+        else {
+            return nil
+        }
+        return callType
+    }
+
+    private func createOrUpdateCallRecordIfNeeded(
+        for callInteraction: TSCall,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        guard let callId = self.callId else {
+            return
         }
+        CallRecord.createOrUpdate(
+            interaction: callInteraction,
+            thread: thread,
+            callId: callId,
+            transaction: transaction
+        )
     }
 }
diff --git a/Signal/src/Calls/Individual/IndividualCallService.swift b/Signal/src/Calls/Individual/IndividualCallService.swift
index 5c3a4e035e3..eb334cde4f7 100644
--- a/Signal/src/Calls/Individual/IndividualCallService.swift
+++ b/Signal/src/Calls/Individual/IndividualCallService.swift
@@ -47,17 +47,8 @@ final public class IndividualCallService: NSObject {
             return
         }
 
-        // Create a callRecord for outgoing calls immediately.
-        let callRecord = TSCall(
-            callType: .outgoingIncomplete,
-            offerType: call.individualCall.offerMediaType,
-            thread: call.individualCall.thread,
-            sentAtTimestamp: call.individualCall.sentAtTimestamp
-        )
-        databaseStorage.asyncWrite { transaction in
-            callRecord.anyInsert(transaction: transaction)
-        }
-        call.individualCall.callRecord = callRecord
+        // Create a call interaction for outgoing calls immediately.
+        call.individualCall.createOrUpdateCallInteractionAsync(callType: .outgoingIncomplete)
 
         // Get the current local device Id, must be valid for lifetime of the call.
         let localDeviceId = tsAccountManager.storedDeviceId()
@@ -94,16 +85,7 @@ final public class IndividualCallService: NSObject {
             return
         }
 
-        let callRecord = TSCall(
-            callType: .incomingIncomplete,
-            offerType: call.individualCall.offerMediaType,
-            thread: call.individualCall.thread,
-            sentAtTimestamp: call.individualCall.sentAtTimestamp
-        )
-        databaseStorage.asyncWrite { transaction in
-            callRecord.anyInsert(transaction: transaction)
-        }
-        call.individualCall.callRecord = callRecord
+        call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingIncomplete)
 
         // It's key that we configure the AVAudioSession for a call *before* we fulfill the
         // CXAnswerCallAction.
@@ -137,21 +119,12 @@ final public class IndividualCallService: NSObject {
             return
         }
 
-        if let callRecord = call.individualCall.callRecord {
-            if callRecord.callType == .outgoingIncomplete {
-                callRecord.updateCallType(.outgoingMissed)
+        if let callType = call.individualCall.callType {
+            if callType == .outgoingIncomplete {
+                call.individualCall.createOrUpdateCallInteractionAsync(callType: .outgoingMissed)
             }
         } else if [.localRinging_Anticipatory, .localRinging_ReadyToAnswer, .accepting].contains(call.individualCall.state) {
-            let callRecord = TSCall(
-                callType: .incomingDeclined,
-                offerType: call.individualCall.offerMediaType,
-                thread: call.individualCall.thread,
-                sentAtTimestamp: call.individualCall.sentAtTimestamp
-            )
-            databaseStorage.asyncWrite { transaction in
-                callRecord.anyInsert(transaction: transaction)
-            }
-            call.individualCall.callRecord = callRecord
+            call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingDeclined)
         } else {
             owsFailDebug("missing call record")
         }
@@ -188,8 +161,8 @@ final public class IndividualCallService: NSObject {
     }
 
     private struct CallIdentityKeys {
-      let localIdentityKey: Data
-      let contactIdentityKey: Data
+        let localIdentityKey: Data
+        let contactIdentityKey: Data
     }
 
     private func getIdentityKeys(thread: TSContactThread) -> CallIdentityKeys? {
@@ -247,15 +220,7 @@ final public class IndividualCallService: NSObject {
 
         guard tsAccountManager.isOnboarded(with: transaction) else {
             Logger.warn("user is not onboarded, skipping call.")
-            let callRecord = TSCall(
-                callType: .incomingMissed,
-                offerType: newCall.individualCall.offerMediaType,
-                thread: thread,
-                sentAtTimestamp: sentAtTimestamp
-            )
-            assert(newCall.individualCall.callRecord == nil)
-            newCall.individualCall.callRecord = callRecord
-            callRecord.anyInsert(transaction: transaction)
+            newCall.individualCall.createOrUpdateCallInteraction(callType: .incomingMissed, transaction: transaction)
 
             newCall.individualCall.state = .localFailure
             callService.terminate(call: newCall)
@@ -283,15 +248,7 @@ final public class IndividualCallService: NSObject {
                     caller: thread.contactAddress)
             }
 
-            let callRecord = TSCall(
-                callType: .incomingMissedBecauseOfChangedIdentity,
-                offerType: newCall.individualCall.offerMediaType,
-                thread: thread,
-                sentAtTimestamp: sentAtTimestamp
-            )
-            assert(newCall.individualCall.callRecord == nil)
-            newCall.individualCall.callRecord = callRecord
-            callRecord.anyInsert(transaction: transaction)
+            newCall.individualCall.createOrUpdateCallInteraction(callType: .incomingMissedBecauseOfChangedIdentity, transaction: transaction)
 
             newCall.individualCall.state = .localFailure
             callService.terminate(call: newCall)
@@ -301,15 +258,7 @@ final public class IndividualCallService: NSObject {
 
         guard let identityKeys = getIdentityKeys(thread: thread, transaction: transaction) else {
             owsFailDebug("missing identity keys, skipping call.")
-            let callRecord = TSCall(
-                callType: .incomingMissed,
-                offerType: newCall.individualCall.offerMediaType,
-                thread: thread,
-                sentAtTimestamp: sentAtTimestamp
-            )
-            assert(newCall.individualCall.callRecord == nil)
-            newCall.individualCall.callRecord = callRecord
-            callRecord.anyInsert(transaction: transaction)
+            newCall.individualCall.createOrUpdateCallInteraction(callType: .incomingMissed, transaction: transaction)
 
             newCall.individualCall.state = .localFailure
             callService.terminate(call: newCall)
@@ -334,15 +283,7 @@ final public class IndividualCallService: NSObject {
             // Store the call as a missed call for the local user. They will see it in the conversation
             // along with the message request dialog. When they accept the dialog, they can call back
             // or the caller can try again.
-            let callRecord = TSCall(
-                callType: .incomingMissed,
-                offerType: newCall.individualCall.offerMediaType,
-                thread: thread,
-                sentAtTimestamp: sentAtTimestamp
-            )
-            assert(newCall.individualCall.callRecord == nil)
-            newCall.individualCall.callRecord = callRecord
-            callRecord.anyInsert(transaction: transaction)
+            newCall.individualCall.createOrUpdateCallInteraction(callType: .incomingMissed, transaction: transaction)
 
             newCall.individualCall.state = .localFailure
             callService.terminate(call: newCall)
@@ -692,11 +633,7 @@ final public class IndividualCallService: NSObject {
             }
 
             assert(call.individualCall.direction == .outgoing)
-            if let callRecord = call.individualCall.callRecord {
-                callRecord.updateCallType(.outgoingMissed)
-            } else {
-                owsFailDebug("outgoing call should have call record")
-            }
+            call.individualCall.createOrUpdateCallInteractionAsync(callType: .outgoingMissed)
 
             call.individualCall.state = .remoteBusy
 
@@ -711,33 +648,26 @@ final public class IndividualCallService: NSObject {
                 return
             }
 
-            if let callRecord = call.individualCall.callRecord {
-                switch callRecord.callType {
+            if let callType = call.individualCall.callType {
+                switch callType {
                 case .outgoingMissed, .incomingDeclined, .incomingMissed, .incomingMissedBecauseOfChangedIdentity, .incomingAnsweredElsewhere, .incomingDeclinedElsewhere, .incomingBusyElsewhere, .incomingMissedBecauseOfDoNotDisturb:
                     // already handled and ended, don't update the call record.
                     break
                 case .incomingIncomplete, .incoming:
-                    callRecord.updateCallType(.incomingMissed)
+                    call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingMissed)
                     callService.callUIAdapter.reportMissedCall(call)
                 case .outgoingIncomplete:
-                    callRecord.updateCallType(.outgoingMissed)
+                    call.individualCall.createOrUpdateCallInteractionAsync(callType: .outgoingMissed)
                     callService.callUIAdapter.remoteBusy(call)
                 case .outgoing:
-                    callRecord.updateCallType(.outgoingMissed)
+                    call.individualCall.createOrUpdateCallInteractionAsync(callType: .outgoingMissed)
                     callService.callUIAdapter.reportMissedCall(call)
                 @unknown default:
-                    owsFailDebug("unknown RPRecentCallType: \(callRecord.callType)")
+                    owsFailDebug("unknown RPRecentCallType: \(callType)")
                 }
             } else {
                 assert(call.individualCall.direction == .incoming)
-                let callRecord = TSCall(
-                    callType: .incomingMissed,
-                    offerType: call.individualCall.offerMediaType,
-                    thread: call.individualCall.thread,
-                    sentAtTimestamp: call.individualCall.sentAtTimestamp
-                )
-                databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
-                call.individualCall.callRecord = callRecord
+                call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingMissed)
                 callService.callUIAdapter.reportMissedCall(call)
             }
             call.individualCall.state = .localHangup
@@ -1065,60 +995,25 @@ final public class IndividualCallService: NSObject {
             }
         }
 
-        let callRecord: TSCall
-        if let existingCallRecord = call.individualCall.callRecord {
-            callRecord = existingCallRecord
-        } else {
-            callRecord = TSCall(
-                callType: .incomingMissed,
-                offerType: call.individualCall.offerMediaType,
-                thread: call.individualCall.thread,
-                sentAtTimestamp: call.individualCall.sentAtTimestamp
-            )
-            call.individualCall.callRecord = callRecord
-        }
+        let oldCallType = call.individualCall.callType
+        call.individualCall.createOrUpdateCallInteractionAsync(callType: callType)
 
-        switch callRecord.callType {
-        case .incomingMissed:
-            databaseStorage.asyncWrite { transaction in
-                callRecord.updateCallType(callType, transaction: transaction)
-                callRecord.anyUpsert(transaction: transaction)
-            }
+        switch oldCallType {
+        case .incomingMissed, .none:
             callService.callUIAdapter.reportMissedCall(call)
         case .incomingIncomplete, .incoming:
-            callRecord.updateCallType(callType)
             callService.callUIAdapter.reportMissedCall(call)
-        case .outgoingIncomplete:
-            callRecord.updateCallType(callType)
-        case .incomingMissedBecauseOfChangedIdentity, .incomingDeclined, .outgoingMissed, .outgoing, .incomingAnsweredElsewhere, .incomingDeclinedElsewhere, .incomingBusyElsewhere, .incomingMissedBecauseOfDoNotDisturb:
-            owsFailDebug("unexpected RPRecentCallType: \(callRecord.callType)")
-            databaseStorage.asyncWrite { transaction in
-                callRecord.anyUpsert(transaction: transaction)
-            }
+        case .outgoingIncomplete, .incomingDeclined, .incomingDeclinedElsewhere, .incomingAnsweredElsewhere:
+            break
+        case .incomingMissedBecauseOfChangedIdentity, .outgoingMissed, .outgoing, .incomingBusyElsewhere, .incomingMissedBecauseOfDoNotDisturb:
+            owsFailDebug("unexpected RPRecentCallType: \(String(describing: oldCallType))")
         @unknown default:
-            databaseStorage.asyncWrite { transaction in
-                callRecord.anyUpsert(transaction: transaction)
-            }
-            owsFailDebug("unknown RPRecentCallType: \(callRecord.callType)")
+            owsFailDebug("unknown RPRecentCallType: \(String(describing: oldCallType))")
         }
     }
 
     func handleAnsweredElsewhere(call: SignalCall) {
-        if let existingCallRecord = call.individualCall.callRecord {
-            // There should only be an existing call record due to a race where the call is answered
-            // simultaneously on multiple devices, and the caller is proceeding with the *other*
-            // devices call.
-            existingCallRecord.updateCallType(.incomingAnsweredElsewhere)
-        } else {
-            let callRecord = TSCall(
-                callType: .incomingAnsweredElsewhere,
-                offerType: call.individualCall.offerMediaType,
-                thread: call.individualCall.thread,
-                sentAtTimestamp: call.individualCall.sentAtTimestamp
-            )
-            call.individualCall.callRecord = callRecord
-            databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
-        }
+        call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingAnsweredElsewhere)
 
         call.individualCall.state = .answeredElsewhere
 
@@ -1129,21 +1024,7 @@ final public class IndividualCallService: NSObject {
     }
 
     func handleDeclinedElsewhere(call: SignalCall) {
-        if let existingCallRecord = call.individualCall.callRecord {
-            // There should only be an existing call record due to a race where the call is answered
-            // simultaneously on multiple devices, and the caller is proceeding with the *other*
-            // devices call.
-            existingCallRecord.updateCallType(.incomingDeclinedElsewhere)
-        } else {
-            let callRecord = TSCall(
-                callType: .incomingDeclinedElsewhere,
-                offerType: call.individualCall.offerMediaType,
-                thread: call.individualCall.thread,
-                sentAtTimestamp: call.individualCall.sentAtTimestamp
-            )
-            call.individualCall.callRecord = callRecord
-            databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
-        }
+        call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingDeclinedElsewhere)
 
         call.individualCall.state = .declinedElsewhere
 
@@ -1154,21 +1035,7 @@ final public class IndividualCallService: NSObject {
     }
 
     func handleBusyElsewhere(call: SignalCall) {
-        if let existingCallRecord = call.individualCall.callRecord {
-            // There should only be an existing call record due to a race where the call is answered
-            // simultaneously on multiple devices, and the caller is proceeding with the *other*
-            // devices call.
-            existingCallRecord.updateCallType(.incomingBusyElsewhere)
-        } else {
-            let callRecord = TSCall(
-                callType: .incomingBusyElsewhere,
-                offerType: call.individualCall.offerMediaType,
-                thread: call.individualCall.thread,
-                sentAtTimestamp: call.individualCall.sentAtTimestamp
-            )
-            call.individualCall.callRecord = callRecord
-            databaseStorage.asyncWrite { callRecord.anyInsert(transaction: $0) }
-        }
+        call.individualCall.createOrUpdateCallInteractionAsync(callType: .incomingBusyElsewhere)
 
         call.individualCall.state = .busyElsewhere
 
@@ -1370,11 +1237,11 @@ final public class IndividualCallService: NSObject {
 
         switch failedCall.individualCall.state {
         case .answering, .localRinging_Anticipatory, .localRinging_ReadyToAnswer, .accepting:
-            assert(failedCall.individualCall.callRecord == nil)
+            assert(failedCall.individualCall.callType == nil)
             // call failed before any call record could be created, make one now.
             handleMissedCall(failedCall, error: callError)
         default:
-            assert(failedCall.individualCall.callRecord != nil)
+            assert(failedCall.individualCall.callType != nil)
         }
 
         guard !failedCall.individualCall.isEnded else {
@@ -1475,6 +1342,11 @@ final public class IndividualCallService: NSObject {
         self.activeCallTimer?.invalidate()
         self.activeCallTimer = nil
     }
+
+    enum InteractionUpdateMethod {
+        case writeAsync
+        case inTransaction(SDSAnyWriteTransaction)
+    }
 }
 
 extension RPRecentCallType: CustomStringConvertible {
diff --git a/Signal/src/Calls/SignalCall.swift b/Signal/src/Calls/SignalCall.swift
index a51215e0b28..f5f172d5730 100644
--- a/Signal/src/Calls/SignalCall.swift
+++ b/Signal/src/Calls/SignalCall.swift
@@ -415,7 +415,11 @@ public class SignalCall: NSObject, CallManagerCallReference {
     }
 
     func markRemovedFromSystem() {
-        owsAssertDebug(systemState == .reported, "call \(localId) had unexpected system state: \(systemState)")
+        // This was an assert that was firing when coming back online after missing
+        // a call while offline. See IOS-3416
+        if systemState != .reported {
+            Logger.warn("call \(localId) had unexpected system state: \(systemState)")
+        }
         systemState = .removed
     }
 }
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index db100663356..e6fe999102a 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -1648,6 +1648,12 @@
 /* Accessibility label for the ? vector asset used to get info about debug logs */
 "DEBUG_LOG_INFO_BUTTON" = "Info about debug logs";
 
+/* info message text in conversation view */
+"DECLINED_AUDIO_CALL" = "You declined a voice call";
+
+/* info message text in conversation view */
+"DECLINED_VIDEO_CALL" = "You declined a video call";
+
 /* Title for the action sheet 'delete' action of the 'delete account confirmation' view controller. */
 "DELETE_ACCOUNT_CONFIRMATION_ACTION_SHEEET_ACTION" = "Delete Account";
 
@@ -3307,8 +3313,11 @@
 /* Message shown in the conversation list when the inbox is empty. */
 "INBOX_VIEW_EMPTY_INBOX" = "No chats yet.\nGet started by messaging a friend.";
 
-/* info message text in conversation view. {embeds callee name} */
-"INCOMING_CALL_FORMAT" = "%@ called you";
+/* info message text in conversation view */
+"INCOMING_AUDIO_CALL" = "Incoming voice call";
+
+/* info message text in conversation view */
+"INCOMING_VIDEO_CALL" = "Incoming video call";
 
 /* Shown in inbox and conversation after syncing as a placeholder indicating why your message history is missing. */
 "INFO_MESSAGE_SYNCED_THREAD" = "You can send or receive synchronized messages from your phone or iPad. â€¨For your security, chat history isn't transferred to new linked devices.";
@@ -3833,7 +3842,7 @@
 "MESSAGES_VIEW_UNREAD_INDICATOR" = "New Messages";
 
 /* info message text in conversation view */
-"MISSED_CALL" = "Missed call";
+"MISSED_AUDIO_CALL" = "Missed voice call";
 
 /* info message text in conversation view (use Apple's name for 'Do Not Disturb' on iOS 14 and older) */
 "MISSED_CALL_DO_NOT_DISTURB" = "Missed call while on Do Not Disturb";
@@ -3841,6 +3850,9 @@
 /* info message text in conversation view (use Apple's name for 'Focus') */
 "MISSED_CALL_FOCUS_MODE" = "Missed call while using Focus";
 
+/* info message text in conversation view */
+"MISSED_VIDEO_CALL" = "Missed video call";
+
 /* Alert body */
 "MISSING_CAMERA_PERMISSION_MESSAGE" = "You can enable camera access in the iOS Settings app to make video calls in Signal.";
 
@@ -4249,8 +4261,17 @@
 /* Label warning the user that they should update Signal to continue using payments. */
 "OUTDATED_PAYMENT_CLIENT_REMINDER_TEXT" = "Update Signal to continue using payments. Your balance may not be up-to-date.";
 
-/* info message text in conversation view. {embeds callee name} */
-"OUTGOING_CALL_FORMAT" = "You called %@";
+/* info message text in conversation view */
+"OUTGOING_AUDIO_CALL" = "Outgoing voice call";
+
+/* info message text in conversation view */
+"OUTGOING_MISSED_AUDIO_CALL" = "Unanswered voice call";
+
+/* info message text in conversation view */
+"OUTGOING_MISSED_VIDEO_CALL" = "Unanswered video call";
+
+/* info message text in conversation view */
+"OUTGOING_VIDEO_CALL" = "Outgoing video call";
 
 /* Button used to decline a payment request. */
 "PAYMENTS_ACTION_DECLINE_REQUEST" = "Decline Request";
diff --git a/SignalServiceKit/Resources/schema.sql b/SignalServiceKit/Resources/schema.sql
index ee7b001630a..209f009545d 100644
--- a/SignalServiceKit/Resources/schema.sql
+++ b/SignalServiceKit/Resources/schema.sql
@@ -1410,3 +1410,28 @@ CREATE
             ,"e164" TEXT NOT NULL
         )
 ;
+
+CREATE
+    TABLE
+        IF NOT EXISTS "model_CallRecord" (
+            "id" INTEGER PRIMARY KEY NOT NULL
+            ,"uniqueId" TEXT NOT NULL UNIQUE
+                ON CONFLICT FAIL
+            ,"callId" TEXT NOT NULL UNIQUE
+                ON CONFLICT IGNORE
+            ,"interactionUniqueId" TEXT NOT NULL REFERENCES "model_TSInteraction"("uniqueId"
+        )
+            ON DELETE
+                CASCADE
+                ,"peerUuid" TEXT NOT NULL
+                ,"type" INTEGER NOT NULL
+                ,"direction" INTEGER NOT NULL
+                ,"status" INTEGER NOT NULL
+)
+;
+
+CREATE
+    INDEX "index_call_record_on_interaction_unique_id"
+        ON "model_CallRecord"("interactionUniqueId"
+)
+;
diff --git a/SignalServiceKit/SignalServiceKit.h b/SignalServiceKit/SignalServiceKit.h
index 1438dd92aa9..245c5cc9750 100644
--- a/SignalServiceKit/SignalServiceKit.h
+++ b/SignalServiceKit/SignalServiceKit.h
@@ -155,6 +155,7 @@ FOUNDATION_EXPORT const unsigned char SignalServiceKitVersionString[];
 #import <SignalServiceKit/OWSVerificationStateSyncMessage.h>
 #import <SignalServiceKit/OWSViewOnceMessageReadSyncMessage.h>
 #import <SignalServiceKit/OWSViewedReceiptsForLinkedDevicesMessage.h>
+#import <SignalServiceKit/OutgoingCallEventSyncMessage.h>
 #import <SignalServiceKit/OutgoingPaymentSyncMessage.h>
 #import <SignalServiceKit/PhoneNumber.h>
 #import <SignalServiceKit/PhoneNumberUtil.h>
diff --git a/SignalServiceKit/protobuf/SignalService.proto b/SignalServiceKit/protobuf/SignalService.proto
index 437fece1994..5dc43d02cee 100644
--- a/SignalServiceKit/protobuf/SignalService.proto
+++ b/SignalServiceKit/protobuf/SignalService.proto
@@ -621,6 +621,33 @@ message SyncMessage {
     // }
   }
 
+  message CallEvent {
+    enum Type {
+      UNKNOWN_TYPE = 0;
+      AUDIO_CALL   = 1;
+      VIDEO_CALL   = 2;
+    }
+
+    enum Direction {
+      UNKNOWN_DIRECTION = 0;
+      INCOMING          = 1;
+      OUTGOING          = 2;
+    }
+
+    enum Event {
+      UNKNOWN_ACTION = 0;
+      ACCEPTED       = 1;
+      NOT_ACCEPTED   = 2;
+    }
+
+    optional bytes     peerUuid  = 1;
+    optional uint64    id        = 2;
+    optional uint64    timestamp = 3;
+    optional Type      type      = 4;
+    optional Direction direction = 5;
+    optional Event     event     = 6;
+  }
+
   optional Sent                   sent                   = 1;
   optional Contacts               contacts               = 2;
   optional Groups                 groups                 = 3;
@@ -638,6 +665,7 @@ message SyncMessage {
   optional OutgoingPayment        outgoingPayment        = 15;
   repeated Viewed                 viewed                 = 16;
   optional PniIdentity            pniIdentity            = 17;
+  optional CallEvent              callEvent              = 19;
 }
 
 message AttachmentPointer {
diff --git a/SignalServiceKit/src/Messages/CallRecord.swift b/SignalServiceKit/src/Messages/CallRecord.swift
new file mode 100644
index 00000000000..df625c8add8
--- /dev/null
+++ b/SignalServiceKit/src/Messages/CallRecord.swift
@@ -0,0 +1,565 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+import GRDB
+import LibSignalClient
+import UIKit
+
+/// Record of an incoming or outgoing 1:1 call that keeps track of events that occurred
+/// across linked devices. (Doesn't apply for group calls!)
+/// Also creates an association between a `TSCall` and the `callId` that generated it.
+///
+/// When calls start locally, CallRecord rows are inserted to serve as a bridge and allow us to
+/// look up TSCall instances via a callId. Incoming call sync messages only have a callId, so
+/// this lets us associate them with this device's ongoing calls. The CallRecord also holds
+/// other metadata like call status to allow us to update the state of the TSCall accordingly.
+@objc
+public final class CallRecord: NSObject, SDSCodableModel {
+    public static let databaseTableName = "model_CallRecord"
+
+    public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
+        case id
+        case uniqueId
+        case callIdString = "callId"
+        case interactionUniqueId
+        case peerUuid
+        case type
+        case direction
+        case status
+    }
+
+    public var id: Int64?
+
+    @objc
+    public let uniqueId: String
+
+    /// The unique ID of the call the event occurred in.
+    /// SQLite uses unsigned Int64, so while these values are normally
+    /// UInt64 we convert back and forth to string for DB serialization.
+    private let callIdString: String
+
+    public var callId: UInt64 {
+        return UInt64(callIdString)!
+    }
+
+    /// The id of the call in the interaction table. (TSCall.uniqueId)
+    /// Every CallRecord has an associated TSCall, this is how we render
+    /// call events in chats as TSCalls are types of TSInteraction.
+    ///
+    /// We sync state written to CallRecords over to TSCalls, but in general
+    /// metadata on CallRecord should be considered higher fidelity than
+    /// TSCall, as CallRecord is the source of truth for information from linked
+    /// device sync messages. e.g. if TSCall says the call was missed but an
+    /// associated CallRecord says it was answered, the call was answered on
+    /// a linked device and should render as such.
+    ///
+    /// If multiple TSCall instances are created for a given callId,
+    /// CallRecord will point to the latest one. (this shouldn't happen)
+    public var interactionUniqueId: String
+
+    /// UUID of the peer with which the call occurred.
+    /// We only send sync events for peers with UUIDs (not e164s).
+    /// NOTE: these events only apply to 1:1 calls.
+    public let peerUuid: String
+
+    public enum Direction: Int, Codable {
+        case incoming = 0, outgoing = 1
+    }
+
+    public let direction: Direction
+
+    public enum CallType: Int, Codable {
+        case audioCall = 0, videoCall = 1
+    }
+
+    public let type: CallType
+
+    /// Maps somewhat to `SSKProtoSyncMessageCallEventEvent`, but without
+    /// an unknown case (those are ignored and never written to the DB) and with client-only cases.
+    public enum Status: Int, Codable {
+        /// A call that has yet to be accepted/rejected.
+        /// Created so that if the current device is still ringing when a linked device
+        /// accepts/rejects the call, the incoming sync message has a `CallRecord` it
+        /// can look up by `callId` to bridge over to the existing `TSCall`.
+        /// (Because `TSCall` has no `callId` stored on it.)
+        /// State should eventually be updated to `accepted` or `notAccepted`.
+        /// If it isn't, the call can be treated as missed.
+        case pending = 0
+        /// For incoming calls, the current user accepted the call.
+        ///
+        /// For outgoing calls, the receiver accepted the call.
+        case accepted = 1
+        /// For incoming calls, the current user actively rejected the call.
+        /// (Will not keep any state if the call rings and just times out, is busy, or
+        /// otherwise ignores the call).
+        ///
+        /// For outgoing calls, the receiver never accepted.
+        /// (They could have rejected, never picked up, anything but accept)
+        case notAccepted = 2
+        /// For incoming calls, the call was marked missed on this device.
+        /// Note that if a linked device picks up, this state can get updated to
+        /// accepted (or not accepted), hence the need for this state so we can remember
+        /// and update.
+        /// Also used if the call was declined as busy.
+        ///
+        /// Unused for outgoing calls.
+        case missed = 3
+    }
+
+    public var status: Status
+
+    private init(
+        callId: UInt64,
+        interactionUniqueId: String,
+        peerUuid: String,
+        direction: Direction,
+        type: CallType,
+        status: Status
+    ) {
+        self.uniqueId = UUID().uuidString
+        self.callIdString = String(callId)
+        self.interactionUniqueId = interactionUniqueId
+        self.peerUuid = peerUuid
+        self.direction = direction
+        self.type = type
+        self.status = status
+    }
+
+    /// Creates a `CallRecord` and associates it with the provided `TSCall` if none
+    /// exists.
+    /// If one does exist, update it to match the status on the provided call.
+    @objc
+    public static func createOrUpdate(
+        interaction: TSCall,
+        thread: TSContactThread,
+        callId: UInt64,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        guard
+            let direction = interaction.callType.callRecordDirection,
+            let status = interaction.callType.callRecordStatus
+        else {
+            return
+        }
+        Self.createOrUpdate(
+            interaction: interaction,
+            thread: thread,
+            callId: callId,
+            direction: direction,
+            status: status,
+            shouldSendSyncMessage: true,
+            transaction: transaction
+        )
+    }
+
+    // shouldSendSyncMessage can be false if this is being created _from_ a sync message.
+    private static func createOrUpdate(
+        interaction: TSCall,
+        thread: TSContactThread,
+        callId: UInt64,
+        direction: Direction,
+        status: Status,
+        shouldSendSyncMessage: Bool,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        guard let peerUuid = thread.contactUUID
+        else {
+            return
+        }
+        if let callRecord = Self.fetch(forCallId: callId, transaction: transaction) {
+            var needsSync = false
+            callRecord.anyUpdate(transaction: transaction) {
+                if isAllowedTransition(from: $0.status, to: status) {
+                    $0.status = status
+                    needsSync = true
+                }
+                if $0.interactionUniqueId != interaction.uniqueId {
+                    Logger.warn("Have more than one TSCall for a single callID. This shouldn't happen, but recovering by linking CallRecord to the newer TSCall.")
+                    $0.interactionUniqueId = interaction.uniqueId
+                }
+            }
+
+            if needsSync, shouldSendSyncMessage {
+                Self.sendSyncMessage(forInteraction: interaction, record: callRecord, transaction: transaction)
+            }
+        } else if let callRecord = Self.fetch(for: interaction, transaction: transaction) {
+            Logger.error("A single TSCall has been associated with multiple callIds. This is super wrong and might result in misreported call events.")
+            var needsSync = false
+            callRecord.anyUpdate(transaction: transaction) {
+                if isAllowedTransition(from: $0.status, to: status) {
+                    $0.status = status
+                    needsSync = true
+                }
+            }
+
+            if needsSync, shouldSendSyncMessage {
+                Self.sendSyncMessage(forInteraction: interaction, record: callRecord, transaction: transaction)
+            }
+        } else {
+            let callRecord = CallRecord(
+                callId: callId,
+                interactionUniqueId: interaction.uniqueId,
+                peerUuid: peerUuid,
+                direction: direction,
+                type: interaction.offerType.recordCallType,
+                status: status
+            )
+            callRecord.anyInsert(transaction: transaction)
+
+            if shouldSendSyncMessage {
+                Self.sendSyncMessage(forInteraction: interaction, record: callRecord, transaction: transaction)
+            }
+        }
+    }
+
+    /// If we have a `CallRecord` associated with the provided `TSCall`,
+    /// update it to match the callType on the call.
+    /// If there is none or if the call status transition is illegal, do nothing.
+    @objc(updateIfExistsForInteraction:transaction:)
+    public static func updateIfExists(
+        for interaction: TSCall,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        if
+            let newStatus = interaction.callType.callRecordStatus,
+            let callRecord = Self.fetch(for: interaction, transaction: transaction),
+            isAllowedTransition(from: callRecord.status, to: newStatus)
+        {
+            callRecord.anyUpdate(transaction: transaction) {
+                $0.status = newStatus
+            }
+            // If we got past the above if statement checks, this should trigger a sync message.
+            Self.sendSyncMessage(forInteraction: interaction, record: callRecord, transaction: transaction)
+        }
+    }
+
+    @objc
+    public static func createOrUpdateForSyncMessage(
+        _ callEvent: SSKProtoSyncMessageCallEvent,
+        messageTimestamp: UInt64,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        guard let peerUUIDData = callEvent.peerUuid, let peerUUID = UUID(data: peerUUIDData) else {
+            Logger.warn("Got invalid peer UUID from call event sync message")
+            return
+        }
+
+        let newStatus: Status
+        let direction: Direction
+        let callType: RPRecentCallType
+        switch (callEvent.direction, callEvent.event) {
+        case (.none, _), (.unknownDirection, _):
+            Logger.info("Got unknown or null call sync direction")
+            return
+        case (_, .none), (_, .unknownAction):
+            Logger.info("Got unknown or null call sync event")
+            return
+        case (.incoming, .accepted):
+            newStatus = .accepted
+            direction = .incoming
+            callType = .incomingAnsweredElsewhere
+        case (.incoming, .notAccepted):
+            newStatus = .notAccepted
+            direction = .incoming
+            callType = .incomingDeclinedElsewhere
+        case (.outgoing, .accepted):
+            newStatus = .accepted
+            direction = .outgoing
+            callType = .outgoing
+        case (.outgoing, .notAccepted):
+            newStatus = .notAccepted
+            direction = .outgoing
+            callType = .outgoingMissed
+        }
+
+        let callId = callEvent.id
+        if let existingCallRecord = Self.fetch(forCallId: callId, transaction: transaction) {
+            if isAllowedTransition(from: existingCallRecord.status, to: newStatus) {
+                existingCallRecord.anyUpdate(transaction: transaction) {
+                    $0.status = newStatus
+                }
+                if
+                    let callInteraction = TSCall.anyFetchCall(
+                        uniqueId: existingCallRecord.interactionUniqueId,
+                        transaction: transaction
+                    )
+                {
+                    callInteraction.updateCallType(callType, transaction: transaction)
+                    if
+                        callInteraction.wasRead.negated,
+                        let thread = TSContactThread.anyFetch(
+                            uniqueId: callInteraction.uniqueThreadId,
+                            transaction: transaction
+                        )
+                    {
+                        callInteraction.markAsRead(
+                            atTimestamp: messageTimestamp,
+                            thread: thread,
+                            circumstance: .onLinkedDevice,
+                            shouldClearNotifications: true,
+                            transaction: transaction
+                        )
+                    }
+                }
+            }
+        } else {
+            // Create a new call record, and a TSCall interaction so it renders in chats.
+            guard let thread = AnyContactThreadFinder().contactThreadForUUID(peerUUID, transaction: transaction) else {
+                Logger.error("Got a call sync message for a contact without a thread, dropping.")
+                return
+            }
+            let callInteraction = TSCall(
+                callType: callType,
+                offerType: callEvent.type == .videoCall ? .video : .audio,
+                thread: thread,
+                sentAtTimestamp: callEvent.timestamp
+            )
+            callInteraction.anyInsert(transaction: transaction)
+
+            if callInteraction.wasRead.negated {
+                callInteraction.markAsRead(
+                    atTimestamp: messageTimestamp,
+                    thread: thread,
+                    circumstance: .onLinkedDevice,
+                    shouldClearNotifications: true,
+                    transaction: transaction
+                )
+            }
+            Self.createOrUpdate(
+                interaction: callInteraction,
+                thread: thread,
+                callId: callId,
+                direction: direction,
+                status: newStatus,
+                shouldSendSyncMessage: false,
+                transaction: transaction
+            )
+        }
+    }
+
+    private static func sendSyncMessage(
+        forInteraction callInteraction: TSCall,
+        record callRecord: CallRecord,
+        transaction: SDSAnyWriteTransaction
+    ) {
+        // This can get called before the app is finished launching, for example
+        // because IncompleteCallsJob runs right on launch and can modify
+        // call state in the database.
+        // That's fine; these sync messages can be slightly delayed without
+        // any effect on local state (and remote devices should be robust to
+        // out of order updates). Just send the message when we are ready.
+        guard AppReadiness.isAppReady else {
+            AppReadiness.runNowOrWhenAppDidBecomeReadyAsync {
+                Self.databaseStorage.asyncWrite {
+                    guard
+                        let callInteraction = TSCall.anyFetchCall(uniqueId: callInteraction.uniqueId, transaction: $0),
+                        let callId = UInt64(callRecord.callIdString),
+                        let callRecord = Self.fetch(forCallId: callId, transaction: $0)
+                    else {
+                        return
+                    }
+                    Self.sendSyncMessage(forInteraction: callInteraction, record: callRecord, transaction: $0)
+                }
+            }
+            return
+        }
+        guard let eventEnum = callRecord.status.objcEvent else {
+            return
+        }
+        guard let callId = UInt64(callRecord.callIdString) else {
+            owsFailDebug("failed to parse callId from string serialization")
+            return
+        }
+        guard let peerUuidData = UUID(uuidString: callRecord.peerUuid)?.data else {
+            owsFailDebug("Could not get peerUuid for sync message.")
+            return
+        }
+        guard let thread = TSAccountManager.getOrCreateLocalThread(transaction: transaction) else {
+            owsFailDebug("Missing local thread for sync message.")
+            return
+        }
+        let event = OutgoingCallEvent(
+            callId: callId,
+            type: callRecord.type.objcCallType,
+            direction: callRecord.direction.objcDirection,
+            event: eventEnum,
+            timestamp: callInteraction.timestamp,
+            peerUuid: peerUuidData
+        )
+        let message = OutgoingCallEventSyncMessage(thread: thread, event: event, transaction: transaction)
+        Self.sskJobQueues.messageSenderJobQueue.add(message: message.asPreparer, transaction: transaction)
+    }
+
+    public static func fetch(for interaction: TSCall, transaction: SDSAnyReadTransaction) -> Self? {
+        return fetch(forInteractionUniqueId: interaction.uniqueId, transaction: transaction)
+    }
+
+    /// Takes the `uniqueId` field of the `TSCall` row in the `TSInteraction` table.
+    public static func fetch(forInteractionUniqueId uniqueId: String, transaction: SDSAnyReadTransaction) -> Self? {
+        do {
+            return try Self.filter(Column(CodingKeys.interactionUniqueId.rawValue) == uniqueId).fetchOne(transaction.unwrapGrdbRead.database)
+        } catch {
+            Logger.error("Error fetching CallRecord by interaction uniqueId: \(error)")
+            return nil
+        }
+    }
+
+    public static func fetch(forCallId callId: UInt64, transaction: SDSAnyReadTransaction) -> Self? {
+        do {
+            return try Self.filter(Column(CodingKeys.callIdString.rawValue) == String(callId)).fetchOne(transaction.unwrapGrdbRead.database)
+        } catch {
+            Logger.error("Error fetching CallRecord by callId: \(error)")
+            return nil
+        }
+    }
+
+    /// Not all transitions are allowed (e.g. if we decline on this device while picking
+    /// up on a linked device, reagrdless of ordering we want to count that as accepted).
+    public static func isAllowedTransition(from: Status, to: Status) -> Bool {
+        guard from != to else {
+            return false
+        }
+        switch (from, to) {
+        case (.pending, _):
+            // Can go from pending to anything.
+            return true
+        case (_, .pending):
+            // Can't go to pending once out of it.
+            return false
+        case (.missed, _):
+            // A missed call on this device might've been picked up
+            // or explicitly declined on a linked device.
+            // (.missed, .pending) is false but caught in above case.
+            return true
+        case (.accepted, _):
+            // If we accept anywhere that trumps everything.
+            return false
+        case (.notAccepted, .accepted):
+            // If we declined on this device but picked up on
+            // another device, that counts as accepted.
+            return true
+        case (.notAccepted, _):
+            // Otherwise a decline can't transition to anything else.
+            return false
+        }
+    }
+}
+
+extension RPRecentCallType {
+
+    var callRecordDirection: CallRecord.Direction? {
+        switch self {
+        case .incoming,
+             .incomingMissed,
+             .incomingDeclined,
+             .incomingIncomplete,
+             .incomingBusyElsewhere,
+             .incomingDeclinedElsewhere,
+             .incomingAnsweredElsewhere,
+             .incomingMissedBecauseOfDoNotDisturb,
+             .incomingMissedBecauseOfChangedIdentity:
+            return .incoming
+        case .outgoing,
+             .outgoingIncomplete,
+             .outgoingMissed:
+            return .outgoing
+        @unknown default:
+            Logger.warn("Unknown call type in CallRecord")
+            return nil
+        }
+    }
+
+    public var callRecordStatus: CallRecord.Status? {
+        switch self {
+        case .outgoing:
+            return .accepted
+        case .outgoingMissed:
+            return .notAccepted
+        case .outgoingIncomplete:
+            return .pending
+        case .incoming:
+            return .accepted
+        case .incomingDeclined:
+            return .notAccepted
+        case .incomingIncomplete:
+            return .pending
+        case .incomingMissed,
+             .incomingMissedBecauseOfChangedIdentity,
+             .incomingMissedBecauseOfDoNotDisturb,
+             .incomingBusyElsewhere:
+            // Note "busy elsewhere" means we should display the call
+            // as missed, but the linked device that was busy _won't_
+            // send a sync message.
+            return .missed
+        case .incomingAnsweredElsewhere:
+            // The "elsewhere" is a linked device that should send us a
+            // sync message. But anyways, treat the call status as accepted,
+            // this races with the sync message and this way the later of
+            // the two will no-op.
+            return .accepted
+        case .incomingDeclinedElsewhere:
+            // The "elsewhere" is a linked device that should send us a
+            // sync message. But anyways, treat the call status as declined,
+            // this races with the sync message and this way the later of
+            // the two will no-op.
+            return .notAccepted
+        @unknown default:
+            Logger.warn("Got unknown callType")
+            return nil
+        }
+    }
+}
+
+extension TSRecentCallOfferType {
+
+    var recordCallType: CallRecord.CallType {
+        switch self {
+        case .audio: return .audioCall
+        case .video: return .videoCall
+        }
+    }
+}
+
+// MARK: - Objc type converters
+
+extension CallRecord.CallType {
+
+    var objcCallType: OWSSyncCallEventType {
+        switch self {
+        case .audioCall:
+            return .audioCall
+        case .videoCall:
+            return .videoCall
+        }
+    }
+}
+
+extension CallRecord.Direction {
+
+    var objcDirection: OWSSyncCallEventDirection {
+        switch self {
+        case .incoming:
+            return .incoming
+        case .outgoing:
+            return .outgoing
+        }
+    }
+}
+
+extension CallRecord.Status {
+
+    var objcEvent: OWSSyncCallEventEvent? {
+        switch self {
+        case .pending, .missed:
+            // These events are local-only, not sent in syncs.
+            return nil
+        case .accepted:
+            return .accepted
+        case .notAccepted:
+            return .notAccepted
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.h b/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.h
new file mode 100644
index 00000000000..86fc2aceb29
--- /dev/null
+++ b/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.h
@@ -0,0 +1,62 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+#import <SignalServiceKit/OWSOutgoingSyncMessage.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+typedef NS_CLOSED_ENUM(NSUInteger, OWSSyncCallEventType) {
+    OWSSyncCallEventType_AudioCall,
+    OWSSyncCallEventType_VideoCall
+};
+
+typedef NS_CLOSED_ENUM(NSUInteger, OWSSyncCallEventDirection) {
+    OWSSyncCallEventDirection_Incoming,
+    OWSSyncCallEventDirection_Outgoing
+};
+
+// Enum name brought to you by the Department of Redundancy Department.
+typedef NS_CLOSED_ENUM(NSUInteger, OWSSyncCallEventEvent) {
+    OWSSyncCallEventEvent_Accepted,
+    OWSSyncCallEventEvent_NotAccepted
+};
+
+@interface OutgoingCallEvent : MTLModel
+
+@property (nonatomic, readonly) uint64_t callId;
+@property (nonatomic, readonly) OWSSyncCallEventType type;
+@property (nonatomic, readonly) OWSSyncCallEventDirection direction;
+@property (nonatomic, readonly) OWSSyncCallEventEvent event;
+@property (nonatomic, readonly) uint64_t timestamp;
+@property (nonatomic, readonly) NSData *peerUuid;
+
+- (instancetype)initWithCallId:(uint64_t)callId
+                          type:(OWSSyncCallEventType)type
+                     direction:(OWSSyncCallEventDirection)direction
+                         event:(OWSSyncCallEventEvent)event
+                     timestamp:(uint64_t)timestamp
+                      peerUuid:(NSData *)peerUuid;
+
+@end
+
+#pragma mark -
+
+@interface OutgoingCallEventSyncMessage : OWSOutgoingSyncMessage
+
++ (instancetype)new NS_UNAVAILABLE;
+- (instancetype)init NS_UNAVAILABLE;
+- (instancetype)initWithThread:(TSThread *)thread transaction:(SDSAnyReadTransaction *)transaction NS_UNAVAILABLE;
+- (instancetype)initWithThread:(TSThread *)thread
+                         event:(OutgoingCallEvent *)event
+                   transaction:(SDSAnyReadTransaction *)transaction NS_DESIGNATED_INITIALIZER;
+- (instancetype)initWithTimestamp:(uint64_t)timestamp
+                           thread:(TSThread *)thread
+                      transaction:(SDSAnyReadTransaction *)transaction NS_UNAVAILABLE;
+
+- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.m b/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.m
new file mode 100644
index 00000000000..11b27fbf89a
--- /dev/null
+++ b/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.m
@@ -0,0 +1,80 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+#import "OutgoingCallEventSyncMessage.h"
+#import <SignalServiceKit/SignalServiceKit-Swift.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@implementation OutgoingCallEvent
+
+- (instancetype)initWithCallId:(uint64_t)callId
+                          type:(OWSSyncCallEventType)type
+                     direction:(OWSSyncCallEventDirection)direction
+                         event:(OWSSyncCallEventEvent)event
+                     timestamp:(uint64_t)timestamp
+                      peerUuid:(NSData *)peerUuid
+{
+    self = [super init];
+    if (!self) {
+        return nil;
+    }
+
+    _callId = callId;
+    _type = type;
+    _direction = direction;
+    _event = event;
+    _timestamp = timestamp;
+    _peerUuid = peerUuid;
+
+    return self;
+}
+
+@end
+
+#pragma mark -
+
+@interface OutgoingCallEventSyncMessage ()
+
+@property (nonatomic, readonly) OutgoingCallEvent *event;
+
+@end
+
+#pragma mark -
+
+@implementation OutgoingCallEventSyncMessage
+
+- (instancetype)initWithThread:(TSThread *)thread
+                         event:(OutgoingCallEvent *)event
+                   transaction:(SDSAnyReadTransaction *)transaction
+{
+    self = [super initWithThread:thread transaction:transaction];
+    if (!self) {
+        return nil;
+    }
+
+    _event = event;
+
+    return self;
+}
+
+- (nullable instancetype)initWithCoder:(NSCoder *)coder
+{
+    return [super initWithCoder:coder];
+}
+
+- (nullable SSKProtoSyncMessageBuilder *)syncMessageBuilderWithTransaction:(SDSAnyReadTransaction *)transaction
+{
+    return [self syncMessageBuilderWithCallEvent:self.event transaction:transaction];
+}
+
+- (BOOL)isUrgent
+{
+    return NO;
+}
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.swift b/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.swift
new file mode 100644
index 00000000000..a39ebca028a
--- /dev/null
+++ b/SignalServiceKit/src/Messages/DeviceSyncing/OutgoingCallEventSyncMessage.swift
@@ -0,0 +1,69 @@
+//
+// Copyright 2022 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+@objc
+public extension OutgoingCallEventSyncMessage {
+
+    @objc(syncMessageBuilderWithCallEvent:transaction:)
+    func syncMessageBuilder(
+        event: OutgoingCallEvent,
+        transaction: SDSAnyReadTransaction
+    ) -> SSKProtoSyncMessageBuilder? {
+        do {
+            let callEventBuilder = SSKProtoSyncMessageCallEvent.builder()
+            callEventBuilder.setId(event.callId)
+            callEventBuilder.setType(event.type.protoValue)
+            callEventBuilder.setDirection(event.direction.protoValue)
+            callEventBuilder.setEvent(event.event.protoValue)
+            callEventBuilder.setTimestamp(event.timestamp)
+            callEventBuilder.setPeerUuid(event.peerUuid)
+
+            let builder = SSKProtoSyncMessage.builder()
+            builder.setCallEvent(try callEventBuilder.build())
+            return builder
+        } catch {
+            owsFailDebug("Error: \(error)")
+            return nil
+        }
+    }
+}
+
+fileprivate extension OWSSyncCallEventType {
+
+    var protoValue: SSKProtoSyncMessageCallEventType {
+        switch self {
+        case .audioCall:
+            return .audioCall
+        case .videoCall:
+            return .videoCall
+        }
+    }
+}
+
+fileprivate extension OWSSyncCallEventDirection {
+
+    var protoValue: SSKProtoSyncMessageCallEventDirection {
+        switch self {
+        case .incoming:
+            return .incoming
+        case .outgoing:
+            return .outgoing
+        }
+    }
+}
+
+fileprivate extension OWSSyncCallEventEvent {
+
+    var protoValue: SSKProtoSyncMessageCallEventEvent {
+        switch self {
+        case .accepted:
+            return .accepted
+        case .notAccepted:
+            return .notAccepted
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Messages/OWSMessageManager.m b/SignalServiceKit/src/Messages/OWSMessageManager.m
index 569e1084617..016183adade 100644
--- a/SignalServiceKit/src/Messages/OWSMessageManager.m
+++ b/SignalServiceKit/src/Messages/OWSMessageManager.m
@@ -1866,6 +1866,11 @@ - (void)throws_handleIncomingEnvelope:(SSKProtoEnvelope *)envelope
     } else if (syncMessage.pniIdentity) {
         OWSLogInfo(@"Received PNI identity");
         [self.identityManager processIncomingPniIdentityProto:syncMessage.pniIdentity transaction:transaction];
+    } else if (syncMessage.callEvent) {
+        OWSLogInfo(@"Received call event sync message.");
+        [CallRecord createOrUpdateForSyncMessage:syncMessage.callEvent
+                                messageTimestamp:envelope.timestamp
+                                     transaction:transaction];
     } else {
         OWSLogWarn(@"Ignoring unsupported sync message.");
     }
diff --git a/SignalServiceKit/src/Messages/OWSMessageManager.swift b/SignalServiceKit/src/Messages/OWSMessageManager.swift
index bc7cad641e4..318806cc0c7 100644
--- a/SignalServiceKit/src/Messages/OWSMessageManager.swift
+++ b/SignalServiceKit/src/Messages/OWSMessageManager.swift
@@ -546,6 +546,9 @@ extension SSKProtoSyncMessage {
         if pniIdentity != nil {
             return "PniIdentity"
         }
+        if callEvent != nil {
+            return "CallDispositionEvent"
+        }
         owsFailDebug("Unknown sync message type")
         return "Unknown"
 
diff --git a/SignalServiceKit/src/Messages/TSCall.h b/SignalServiceKit/src/Messages/TSCall.h
index 70e9cb37fd9..c7ea33a3e98 100644
--- a/SignalServiceKit/src/Messages/TSCall.h
+++ b/SignalServiceKit/src/Messages/TSCall.h
@@ -35,6 +35,9 @@ NSString *NSStringFromCallType(RPRecentCallType callType);
 
 @interface TSCall : TSInteraction <OWSReadTracking, OWSPreviewText>
 
+/// Encodes both what kind of call it is, and the state of that call (pending, answered, missed, etc.)
+/// Written to by CallKit callbacks, but also by incoming call event sync messages from linked
+/// devices, by way of `CallRecord`.
 @property (nonatomic, readonly) RPRecentCallType callType;
 @property (nonatomic, readonly) TSRecentCallOfferType offerType;
 
diff --git a/SignalServiceKit/src/Messages/TSCall.m b/SignalServiceKit/src/Messages/TSCall.m
index 352bf9abccb..a3b936219d2 100644
--- a/SignalServiceKit/src/Messages/TSCall.m
+++ b/SignalServiceKit/src/Messages/TSCall.m
@@ -149,34 +149,54 @@ - (OWSInteractionType)interactionType
 
 - (NSString *)previewTextWithTransaction:(SDSAnyReadTransaction *)transaction
 {
-    TSThread *thread = [self threadWithTransaction:transaction];
-    OWSAssertDebug([thread isKindOfClass:[TSContactThread class]]);
-    TSContactThread *contactThread = (TSContactThread *)thread;
-    NSString *shortName = [SSKEnvironment.shared.contactsManager shortDisplayNameForAddress:contactThread.contactAddress
-                                                                                transaction:transaction];
-
     // We don't actually use the `transaction` but other sibling classes do.
     switch (_callType) {
         case RPRecentCallTypeIncoming:
         case RPRecentCallTypeIncomingIncomplete:
         case RPRecentCallTypeIncomingAnsweredElsewhere: {
-            NSString *format = OWSLocalizedString(
-                @"INCOMING_CALL_FORMAT", @"info message text in conversation view. {embeds callee name}");
-            return [NSString stringWithFormat:format, shortName];
+            switch (_offerType) {
+                case TSRecentCallOfferTypeAudio:
+                    return OWSLocalizedString(@"INCOMING_AUDIO_CALL", @"info message text in conversation view");
+                case TSRecentCallOfferTypeVideo:
+                    return OWSLocalizedString(@"INCOMING_VIDEO_CALL", @"info message text in conversation view");
+            }
         }
         case RPRecentCallTypeOutgoing:
-        case RPRecentCallTypeOutgoingIncomplete:
+        case RPRecentCallTypeOutgoingIncomplete: {
+            switch (_offerType) {
+                case TSRecentCallOfferTypeAudio:
+                    return OWSLocalizedString(@"OUTGOING_AUDIO_CALL", @"info message text in conversation view");
+                case TSRecentCallOfferTypeVideo:
+                    return OWSLocalizedString(@"OUTGOING_VIDEO_CALL", @"info message text in conversation view");
+            }
+        }
         case RPRecentCallTypeOutgoingMissed: {
-            NSString *format = OWSLocalizedString(
-                @"OUTGOING_CALL_FORMAT", @"info message text in conversation view. {embeds callee name}");
-            return [NSString stringWithFormat:format, shortName];
+            switch (_offerType) {
+                case TSRecentCallOfferTypeAudio:
+                    return OWSLocalizedString(@"OUTGOING_MISSED_AUDIO_CALL", @"info message text in conversation view");
+                case TSRecentCallOfferTypeVideo:
+                    return OWSLocalizedString(@"OUTGOING_MISSED_VIDEO_CALL", @"info message text in conversation view");
+            }
         }
         case RPRecentCallTypeIncomingMissed:
         case RPRecentCallTypeIncomingMissedBecauseOfChangedIdentity:
-        case RPRecentCallTypeIncomingBusyElsewhere:
+        case RPRecentCallTypeIncomingBusyElsewhere: {
+            switch (_offerType) {
+                case TSRecentCallOfferTypeAudio:
+                    return OWSLocalizedString(@"MISSED_AUDIO_CALL", @"info message text in conversation view");
+                case TSRecentCallOfferTypeVideo:
+                    return OWSLocalizedString(@"MISSED_VIDEO_CALL", @"info message text in conversation view");
+            }
+        }
         case RPRecentCallTypeIncomingDeclined:
-        case RPRecentCallTypeIncomingDeclinedElsewhere:
-            return OWSLocalizedString(@"MISSED_CALL", @"info message text in conversation view");
+        case RPRecentCallTypeIncomingDeclinedElsewhere: {
+            switch (_offerType) {
+                case TSRecentCallOfferTypeAudio:
+                    return OWSLocalizedString(@"DECLINED_AUDIO_CALL", @"info message text in conversation view");
+                case TSRecentCallOfferTypeVideo:
+                    return OWSLocalizedString(@"DECLINED_VIDEO_CALL", @"info message text in conversation view");
+            }
+        }
         case RPRecentCallTypeIncomingMissedBecauseOfDoNotDisturb:
             if (@available(iOS 15, *)) {
                 return OWSLocalizedString(@"MISSED_CALL_FOCUS_MODE",
@@ -228,9 +248,8 @@ - (void)markAsReadAtTimestamp:(uint64_t)readTimestamp
 
 - (void)updateCallType:(RPRecentCallType)callType
 {
-    DatabaseStorageAsyncWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
-        [self updateCallType:callType transaction:transaction];
-    });
+    DatabaseStorageAsyncWrite(self.databaseStorage,
+        ^(SDSAnyWriteTransaction *transaction) { [self updateCallType:callType transaction:transaction]; });
 }
 
 - (void)updateCallType:(RPRecentCallType)callType transaction:(SDSAnyWriteTransaction *)transaction
@@ -247,6 +266,8 @@ - (void)updateCallType:(RPRecentCallType)callType transaction:(SDSAnyWriteTransa
                                  block:^(TSCall *call) {
                                      call.callType = callType;
                                  }];
+
+    [CallRecord updateIfExistsForInteraction:self transaction:transaction];
 }
 
 @end
diff --git a/SignalServiceKit/src/Protos/Generated/SSKProto.swift b/SignalServiceKit/src/Protos/Generated/SSKProto.swift
index 6bf94ddcf05..9e583107498 100644
--- a/SignalServiceKit/src/Protos/Generated/SSKProto.swift
+++ b/SignalServiceKit/src/Protos/Generated/SSKProto.swift
@@ -14308,6 +14308,357 @@ extension SSKProtoSyncMessageOutgoingPaymentBuilder {
 
 #endif
 
+// MARK: - SSKProtoSyncMessageCallEventType
+
+@objc
+public enum SSKProtoSyncMessageCallEventType: Int32 {
+    case unknownType = 0
+    case audioCall = 1
+    case videoCall = 2
+}
+
+private func SSKProtoSyncMessageCallEventTypeWrap(_ value: SignalServiceProtos_SyncMessage.CallEvent.TypeEnum) -> SSKProtoSyncMessageCallEventType {
+    switch value {
+    case .unknownType: return .unknownType
+    case .audioCall: return .audioCall
+    case .videoCall: return .videoCall
+    }
+}
+
+private func SSKProtoSyncMessageCallEventTypeUnwrap(_ value: SSKProtoSyncMessageCallEventType) -> SignalServiceProtos_SyncMessage.CallEvent.TypeEnum {
+    switch value {
+    case .unknownType: return .unknownType
+    case .audioCall: return .audioCall
+    case .videoCall: return .videoCall
+    }
+}
+
+// MARK: - SSKProtoSyncMessageCallEventDirection
+
+@objc
+public enum SSKProtoSyncMessageCallEventDirection: Int32 {
+    case unknownDirection = 0
+    case incoming = 1
+    case outgoing = 2
+}
+
+private func SSKProtoSyncMessageCallEventDirectionWrap(_ value: SignalServiceProtos_SyncMessage.CallEvent.Direction) -> SSKProtoSyncMessageCallEventDirection {
+    switch value {
+    case .unknownDirection: return .unknownDirection
+    case .incoming: return .incoming
+    case .outgoing: return .outgoing
+    }
+}
+
+private func SSKProtoSyncMessageCallEventDirectionUnwrap(_ value: SSKProtoSyncMessageCallEventDirection) -> SignalServiceProtos_SyncMessage.CallEvent.Direction {
+    switch value {
+    case .unknownDirection: return .unknownDirection
+    case .incoming: return .incoming
+    case .outgoing: return .outgoing
+    }
+}
+
+// MARK: - SSKProtoSyncMessageCallEventEvent
+
+@objc
+public enum SSKProtoSyncMessageCallEventEvent: Int32 {
+    case unknownAction = 0
+    case accepted = 1
+    case notAccepted = 2
+}
+
+private func SSKProtoSyncMessageCallEventEventWrap(_ value: SignalServiceProtos_SyncMessage.CallEvent.Event) -> SSKProtoSyncMessageCallEventEvent {
+    switch value {
+    case .unknownAction: return .unknownAction
+    case .accepted: return .accepted
+    case .notAccepted: return .notAccepted
+    }
+}
+
+private func SSKProtoSyncMessageCallEventEventUnwrap(_ value: SSKProtoSyncMessageCallEventEvent) -> SignalServiceProtos_SyncMessage.CallEvent.Event {
+    switch value {
+    case .unknownAction: return .unknownAction
+    case .accepted: return .accepted
+    case .notAccepted: return .notAccepted
+    }
+}
+
+// MARK: - SSKProtoSyncMessageCallEvent
+
+@objc
+public class SSKProtoSyncMessageCallEvent: NSObject, Codable, NSSecureCoding {
+
+    fileprivate let proto: SignalServiceProtos_SyncMessage.CallEvent
+
+    @objc
+    public var peerUuid: Data? {
+        guard hasPeerUuid else {
+            return nil
+        }
+        return proto.peerUuid
+    }
+    @objc
+    public var hasPeerUuid: Bool {
+        return proto.hasPeerUuid && !proto.peerUuid.isEmpty
+    }
+
+    @objc
+    public var id: UInt64 {
+        return proto.id
+    }
+    @objc
+    public var hasID: Bool {
+        return proto.hasID
+    }
+
+    @objc
+    public var timestamp: UInt64 {
+        return proto.timestamp
+    }
+    @objc
+    public var hasTimestamp: Bool {
+        return proto.hasTimestamp
+    }
+
+    public var type: SSKProtoSyncMessageCallEventType? {
+        guard hasType else {
+            return nil
+        }
+        return SSKProtoSyncMessageCallEventTypeWrap(proto.type)
+    }
+    // This "unwrapped" accessor should only be used if the "has value" accessor has already been checked.
+    @objc
+    public var unwrappedType: SSKProtoSyncMessageCallEventType {
+        if !hasType {
+            // TODO: We could make this a crashing assert.
+            owsFailDebug("Unsafe unwrap of missing optional: CallEvent.type.")
+        }
+        return SSKProtoSyncMessageCallEventTypeWrap(proto.type)
+    }
+    @objc
+    public var hasType: Bool {
+        return proto.hasType
+    }
+
+    public var direction: SSKProtoSyncMessageCallEventDirection? {
+        guard hasDirection else {
+            return nil
+        }
+        return SSKProtoSyncMessageCallEventDirectionWrap(proto.direction)
+    }
+    // This "unwrapped" accessor should only be used if the "has value" accessor has already been checked.
+    @objc
+    public var unwrappedDirection: SSKProtoSyncMessageCallEventDirection {
+        if !hasDirection {
+            // TODO: We could make this a crashing assert.
+            owsFailDebug("Unsafe unwrap of missing optional: CallEvent.direction.")
+        }
+        return SSKProtoSyncMessageCallEventDirectionWrap(proto.direction)
+    }
+    @objc
+    public var hasDirection: Bool {
+        return proto.hasDirection
+    }
+
+    public var event: SSKProtoSyncMessageCallEventEvent? {
+        guard hasEvent else {
+            return nil
+        }
+        return SSKProtoSyncMessageCallEventEventWrap(proto.event)
+    }
+    // This "unwrapped" accessor should only be used if the "has value" accessor has already been checked.
+    @objc
+    public var unwrappedEvent: SSKProtoSyncMessageCallEventEvent {
+        if !hasEvent {
+            // TODO: We could make this a crashing assert.
+            owsFailDebug("Unsafe unwrap of missing optional: CallEvent.event.")
+        }
+        return SSKProtoSyncMessageCallEventEventWrap(proto.event)
+    }
+    @objc
+    public var hasEvent: Bool {
+        return proto.hasEvent
+    }
+
+    public var hasUnknownFields: Bool {
+        return !proto.unknownFields.data.isEmpty
+    }
+    public var unknownFields: SwiftProtobuf.UnknownStorage? {
+        guard hasUnknownFields else { return nil }
+        return proto.unknownFields
+    }
+
+    private init(proto: SignalServiceProtos_SyncMessage.CallEvent) {
+        self.proto = proto
+    }
+
+    @objc
+    public func serializedData() throws -> Data {
+        return try self.proto.serializedData()
+    }
+
+    @objc
+    public convenience init(serializedData: Data) throws {
+        let proto = try SignalServiceProtos_SyncMessage.CallEvent(serializedData: serializedData)
+        try self.init(proto)
+    }
+
+    fileprivate convenience init(_ proto: SignalServiceProtos_SyncMessage.CallEvent) throws {
+        // MARK: - Begin Validation Logic for SSKProtoSyncMessageCallEvent -
+
+        // MARK: - End Validation Logic for SSKProtoSyncMessageCallEvent -
+
+        self.init(proto: proto)
+    }
+
+    public required convenience init(from decoder: Swift.Decoder) throws {
+        let singleValueContainer = try decoder.singleValueContainer()
+        let serializedData = try singleValueContainer.decode(Data.self)
+        try self.init(serializedData: serializedData)
+    }
+    public func encode(to encoder: Swift.Encoder) throws {
+        var singleValueContainer = encoder.singleValueContainer()
+        try singleValueContainer.encode(try serializedData())
+    }
+
+    public static var supportsSecureCoding: Bool { true }
+
+    public required convenience init?(coder: NSCoder) {
+        guard let serializedData = coder.decodeData() else { return nil }
+        do {
+            try self.init(serializedData: serializedData)
+        } catch {
+            owsFailDebug("Failed to decode serialized data \(error)")
+            return nil
+        }
+    }
+
+    public func encode(with coder: NSCoder) {
+        do {
+            coder.encode(try serializedData())
+        } catch {
+            owsFailDebug("Failed to encode serialized data \(error)")
+        }
+    }
+
+    @objc
+    public override var debugDescription: String {
+        return "\(proto)"
+    }
+}
+
+extension SSKProtoSyncMessageCallEvent {
+    @objc
+    public static func builder() -> SSKProtoSyncMessageCallEventBuilder {
+        return SSKProtoSyncMessageCallEventBuilder()
+    }
+
+    // asBuilder() constructs a builder that reflects the proto's contents.
+    @objc
+    public func asBuilder() -> SSKProtoSyncMessageCallEventBuilder {
+        let builder = SSKProtoSyncMessageCallEventBuilder()
+        if let _value = peerUuid {
+            builder.setPeerUuid(_value)
+        }
+        if hasID {
+            builder.setId(id)
+        }
+        if hasTimestamp {
+            builder.setTimestamp(timestamp)
+        }
+        if let _value = type {
+            builder.setType(_value)
+        }
+        if let _value = direction {
+            builder.setDirection(_value)
+        }
+        if let _value = event {
+            builder.setEvent(_value)
+        }
+        if let _value = unknownFields {
+            builder.setUnknownFields(_value)
+        }
+        return builder
+    }
+}
+
+@objc
+public class SSKProtoSyncMessageCallEventBuilder: NSObject {
+
+    private var proto = SignalServiceProtos_SyncMessage.CallEvent()
+
+    @objc
+    fileprivate override init() {}
+
+    @objc
+    @available(swift, obsoleted: 1.0)
+    public func setPeerUuid(_ valueParam: Data?) {
+        guard let valueParam = valueParam else { return }
+        proto.peerUuid = valueParam
+    }
+
+    public func setPeerUuid(_ valueParam: Data) {
+        proto.peerUuid = valueParam
+    }
+
+    @objc
+    public func setId(_ valueParam: UInt64) {
+        proto.id = valueParam
+    }
+
+    @objc
+    public func setTimestamp(_ valueParam: UInt64) {
+        proto.timestamp = valueParam
+    }
+
+    @objc
+    public func setType(_ valueParam: SSKProtoSyncMessageCallEventType) {
+        proto.type = SSKProtoSyncMessageCallEventTypeUnwrap(valueParam)
+    }
+
+    @objc
+    public func setDirection(_ valueParam: SSKProtoSyncMessageCallEventDirection) {
+        proto.direction = SSKProtoSyncMessageCallEventDirectionUnwrap(valueParam)
+    }
+
+    @objc
+    public func setEvent(_ valueParam: SSKProtoSyncMessageCallEventEvent) {
+        proto.event = SSKProtoSyncMessageCallEventEventUnwrap(valueParam)
+    }
+
+    public func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
+        proto.unknownFields = unknownFields
+    }
+
+    @objc
+    public func build() throws -> SSKProtoSyncMessageCallEvent {
+        return try SSKProtoSyncMessageCallEvent(proto)
+    }
+
+    @objc
+    public func buildSerializedData() throws -> Data {
+        return try SSKProtoSyncMessageCallEvent(proto).serializedData()
+    }
+}
+
+#if TESTABLE_BUILD
+
+extension SSKProtoSyncMessageCallEvent {
+    @objc
+    public func serializedDataIgnoringErrors() -> Data? {
+        return try! self.serializedData()
+    }
+}
+
+extension SSKProtoSyncMessageCallEventBuilder {
+    @objc
+    public func buildIgnoringErrors() -> SSKProtoSyncMessageCallEvent? {
+        return try! self.build()
+    }
+}
+
+#endif
+
 // MARK: - SSKProtoSyncMessage
 
 @objc
@@ -14363,6 +14714,9 @@ public class SSKProtoSyncMessage: NSObject, Codable, NSSecureCoding {
     @objc
     public let pniIdentity: SSKProtoSyncMessagePniIdentity?
 
+    @objc
+    public let callEvent: SSKProtoSyncMessageCallEvent?
+
     @objc
     public var padding: Data? {
         guard hasPadding else {
@@ -14399,7 +14753,8 @@ public class SSKProtoSyncMessage: NSObject, Codable, NSSecureCoding {
                  messageRequestResponse: SSKProtoSyncMessageMessageRequestResponse?,
                  outgoingPayment: SSKProtoSyncMessageOutgoingPayment?,
                  viewed: [SSKProtoSyncMessageViewed],
-                 pniIdentity: SSKProtoSyncMessagePniIdentity?) {
+                 pniIdentity: SSKProtoSyncMessagePniIdentity?,
+                 callEvent: SSKProtoSyncMessageCallEvent?) {
         self.proto = proto
         self.sent = sent
         self.contacts = contacts
@@ -14417,6 +14772,7 @@ public class SSKProtoSyncMessage: NSObject, Codable, NSSecureCoding {
         self.outgoingPayment = outgoingPayment
         self.viewed = viewed
         self.pniIdentity = pniIdentity
+        self.callEvent = callEvent
     }
 
     @objc
@@ -14505,6 +14861,11 @@ public class SSKProtoSyncMessage: NSObject, Codable, NSSecureCoding {
             pniIdentity = try SSKProtoSyncMessagePniIdentity(proto.pniIdentity)
         }
 
+        var callEvent: SSKProtoSyncMessageCallEvent?
+        if proto.hasCallEvent {
+            callEvent = try SSKProtoSyncMessageCallEvent(proto.callEvent)
+        }
+
         // MARK: - Begin Validation Logic for SSKProtoSyncMessage -
 
         // MARK: - End Validation Logic for SSKProtoSyncMessage -
@@ -14525,7 +14886,8 @@ public class SSKProtoSyncMessage: NSObject, Codable, NSSecureCoding {
                   messageRequestResponse: messageRequestResponse,
                   outgoingPayment: outgoingPayment,
                   viewed: viewed,
-                  pniIdentity: pniIdentity)
+                  pniIdentity: pniIdentity,
+                  callEvent: callEvent)
     }
 
     public required convenience init(from decoder: Swift.Decoder) throws {
@@ -14619,6 +14981,9 @@ extension SSKProtoSyncMessage {
         if let _value = pniIdentity {
             builder.setPniIdentity(_value)
         }
+        if let _value = callEvent {
+            builder.setCallEvent(_value)
+        }
         if let _value = unknownFields {
             builder.setUnknownFields(_value)
         }
@@ -14818,6 +15183,17 @@ public class SSKProtoSyncMessageBuilder: NSObject {
         proto.pniIdentity = valueParam.proto
     }
 
+    @objc
+    @available(swift, obsoleted: 1.0)
+    public func setCallEvent(_ valueParam: SSKProtoSyncMessageCallEvent?) {
+        guard let valueParam = valueParam else { return }
+        proto.callEvent = valueParam.proto
+    }
+
+    public func setCallEvent(_ valueParam: SSKProtoSyncMessageCallEvent) {
+        proto.callEvent = valueParam.proto
+    }
+
     public func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
         proto.unknownFields = unknownFields
     }
diff --git a/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift b/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
index dc6176be57f..503739d847d 100644
--- a/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
+++ b/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
@@ -2809,6 +2809,15 @@ struct SignalServiceProtos_SyncMessage {
   /// Clears the value of `pniIdentity`. Subsequent reads from it will return its default value.
   mutating func clearPniIdentity() {_uniqueStorage()._pniIdentity = nil}
 
+  var callEvent: SignalServiceProtos_SyncMessage.CallEvent {
+    get {return _storage._callEvent ?? SignalServiceProtos_SyncMessage.CallEvent()}
+    set {_uniqueStorage()._callEvent = newValue}
+  }
+  /// Returns true if `callEvent` has been explicitly set.
+  var hasCallEvent: Bool {return _storage._callEvent != nil}
+  /// Clears the value of `callEvent`. Subsequent reads from it will return its default value.
+  mutating func clearCallEvent() {_uniqueStorage()._callEvent = nil}
+
   var unknownFields = SwiftProtobuf.UnknownStorage()
 
   struct Sent {
@@ -3669,6 +3678,164 @@ struct SignalServiceProtos_SyncMessage {
     fileprivate var _mobileCoin: SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin? = nil
   }
 
+  struct CallEvent {
+    // SwiftProtobuf.Message conformance is added in an extension below. See the
+    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
+    // methods supported on all messages.
+
+    var peerUuid: Data {
+      get {return _peerUuid ?? Data()}
+      set {_peerUuid = newValue}
+    }
+    /// Returns true if `peerUuid` has been explicitly set.
+    var hasPeerUuid: Bool {return self._peerUuid != nil}
+    /// Clears the value of `peerUuid`. Subsequent reads from it will return its default value.
+    mutating func clearPeerUuid() {self._peerUuid = nil}
+
+    var id: UInt64 {
+      get {return _id ?? 0}
+      set {_id = newValue}
+    }
+    /// Returns true if `id` has been explicitly set.
+    var hasID: Bool {return self._id != nil}
+    /// Clears the value of `id`. Subsequent reads from it will return its default value.
+    mutating func clearID() {self._id = nil}
+
+    var timestamp: UInt64 {
+      get {return _timestamp ?? 0}
+      set {_timestamp = newValue}
+    }
+    /// Returns true if `timestamp` has been explicitly set.
+    var hasTimestamp: Bool {return self._timestamp != nil}
+    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
+    mutating func clearTimestamp() {self._timestamp = nil}
+
+    var type: SignalServiceProtos_SyncMessage.CallEvent.TypeEnum {
+      get {return _type ?? .unknownType}
+      set {_type = newValue}
+    }
+    /// Returns true if `type` has been explicitly set.
+    var hasType: Bool {return self._type != nil}
+    /// Clears the value of `type`. Subsequent reads from it will return its default value.
+    mutating func clearType() {self._type = nil}
+
+    var direction: SignalServiceProtos_SyncMessage.CallEvent.Direction {
+      get {return _direction ?? .unknownDirection}
+      set {_direction = newValue}
+    }
+    /// Returns true if `direction` has been explicitly set.
+    var hasDirection: Bool {return self._direction != nil}
+    /// Clears the value of `direction`. Subsequent reads from it will return its default value.
+    mutating func clearDirection() {self._direction = nil}
+
+    var event: SignalServiceProtos_SyncMessage.CallEvent.Event {
+      get {return _event ?? .unknownAction}
+      set {_event = newValue}
+    }
+    /// Returns true if `event` has been explicitly set.
+    var hasEvent: Bool {return self._event != nil}
+    /// Clears the value of `event`. Subsequent reads from it will return its default value.
+    mutating func clearEvent() {self._event = nil}
+
+    var unknownFields = SwiftProtobuf.UnknownStorage()
+
+    enum TypeEnum: SwiftProtobuf.Enum {
+      typealias RawValue = Int
+      case unknownType // = 0
+      case audioCall // = 1
+      case videoCall // = 2
+
+      init() {
+        self = .unknownType
+      }
+
+      init?(rawValue: Int) {
+        switch rawValue {
+        case 0: self = .unknownType
+        case 1: self = .audioCall
+        case 2: self = .videoCall
+        default: return nil
+        }
+      }
+
+      var rawValue: Int {
+        switch self {
+        case .unknownType: return 0
+        case .audioCall: return 1
+        case .videoCall: return 2
+        }
+      }
+
+    }
+
+    enum Direction: SwiftProtobuf.Enum {
+      typealias RawValue = Int
+      case unknownDirection // = 0
+      case incoming // = 1
+      case outgoing // = 2
+
+      init() {
+        self = .unknownDirection
+      }
+
+      init?(rawValue: Int) {
+        switch rawValue {
+        case 0: self = .unknownDirection
+        case 1: self = .incoming
+        case 2: self = .outgoing
+        default: return nil
+        }
+      }
+
+      var rawValue: Int {
+        switch self {
+        case .unknownDirection: return 0
+        case .incoming: return 1
+        case .outgoing: return 2
+        }
+      }
+
+    }
+
+    enum Event: SwiftProtobuf.Enum {
+      typealias RawValue = Int
+      case unknownAction // = 0
+      case accepted // = 1
+      case notAccepted // = 2
+
+      init() {
+        self = .unknownAction
+      }
+
+      init?(rawValue: Int) {
+        switch rawValue {
+        case 0: self = .unknownAction
+        case 1: self = .accepted
+        case 2: self = .notAccepted
+        default: return nil
+        }
+      }
+
+      var rawValue: Int {
+        switch self {
+        case .unknownAction: return 0
+        case .accepted: return 1
+        case .notAccepted: return 2
+        }
+      }
+
+    }
+
+    init() {}
+
+    fileprivate var _peerUuid: Data? = nil
+    fileprivate var _id: UInt64? = nil
+    fileprivate var _timestamp: UInt64? = nil
+    fileprivate var _type: SignalServiceProtos_SyncMessage.CallEvent.TypeEnum? = nil
+    fileprivate var _direction: SignalServiceProtos_SyncMessage.CallEvent.Direction? = nil
+    fileprivate var _event: SignalServiceProtos_SyncMessage.CallEvent.Event? = nil
+  }
+
   init() {}
 
   fileprivate var _storage = _StorageClass.defaultInstance
@@ -3692,6 +3859,18 @@ extension SignalServiceProtos_SyncMessage.MessageRequestResponse.TypeEnum: CaseI
   // Support synthesized by the compiler.
 }
 
+extension SignalServiceProtos_SyncMessage.CallEvent.TypeEnum: CaseIterable {
+  // Support synthesized by the compiler.
+}
+
+extension SignalServiceProtos_SyncMessage.CallEvent.Direction: CaseIterable {
+  // Support synthesized by the compiler.
+}
+
+extension SignalServiceProtos_SyncMessage.CallEvent.Event: CaseIterable {
+  // Support synthesized by the compiler.
+}
+
 #endif  // swift(>=4.2)
 
 struct SignalServiceProtos_AttachmentPointer {
@@ -4667,6 +4846,10 @@ extension SignalServiceProtos_SyncMessage.MessageRequestResponse: @unchecked Sen
 extension SignalServiceProtos_SyncMessage.MessageRequestResponse.TypeEnum: @unchecked Sendable {}
 extension SignalServiceProtos_SyncMessage.OutgoingPayment: @unchecked Sendable {}
 extension SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin: @unchecked Sendable {}
+extension SignalServiceProtos_SyncMessage.CallEvent: @unchecked Sendable {}
+extension SignalServiceProtos_SyncMessage.CallEvent.TypeEnum: @unchecked Sendable {}
+extension SignalServiceProtos_SyncMessage.CallEvent.Direction: @unchecked Sendable {}
+extension SignalServiceProtos_SyncMessage.CallEvent.Event: @unchecked Sendable {}
 extension SignalServiceProtos_AttachmentPointer: @unchecked Sendable {}
 extension SignalServiceProtos_AttachmentPointer.Flags: @unchecked Sendable {}
 extension SignalServiceProtos_GroupContext: @unchecked Sendable {}
@@ -7411,6 +7594,7 @@ extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf.
     15: .same(proto: "outgoingPayment"),
     16: .same(proto: "viewed"),
     17: .same(proto: "pniIdentity"),
+    19: .same(proto: "callEvent"),
   ]
 
   fileprivate class _StorageClass {
@@ -7431,6 +7615,7 @@ extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf.
     var _outgoingPayment: SignalServiceProtos_SyncMessage.OutgoingPayment? = nil
     var _viewed: [SignalServiceProtos_SyncMessage.Viewed] = []
     var _pniIdentity: SignalServiceProtos_SyncMessage.PniIdentity? = nil
+    var _callEvent: SignalServiceProtos_SyncMessage.CallEvent? = nil
 
     static let defaultInstance = _StorageClass()
 
@@ -7454,6 +7639,7 @@ extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf.
       _outgoingPayment = source._outgoingPayment
       _viewed = source._viewed
       _pniIdentity = source._pniIdentity
+      _callEvent = source._callEvent
     }
   }
 
@@ -7489,6 +7675,7 @@ extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf.
         case 15: try { try decoder.decodeSingularMessageField(value: &_storage._outgoingPayment) }()
         case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._viewed) }()
         case 17: try { try decoder.decodeSingularMessageField(value: &_storage._pniIdentity) }()
+        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._callEvent) }()
         default: break
         }
       }
@@ -7552,6 +7739,9 @@ extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf.
       try { if let v = _storage._pniIdentity {
         try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
       } }()
+      try { if let v = _storage._callEvent {
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
+      } }()
     }
     try unknownFields.traverse(visitor: &visitor)
   }
@@ -7578,6 +7768,7 @@ extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf.
         if _storage._outgoingPayment != rhs_storage._outgoingPayment {return false}
         if _storage._viewed != rhs_storage._viewed {return false}
         if _storage._pniIdentity != rhs_storage._pniIdentity {return false}
+        if _storage._callEvent != rhs_storage._callEvent {return false}
         return true
       }
       if !storagesAreEqual {return false}
@@ -8509,6 +8700,96 @@ extension SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin: SwiftProto
   }
 }
 
+extension SignalServiceProtos_SyncMessage.CallEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
+  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".CallEvent"
+  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
+    1: .same(proto: "peerUuid"),
+    2: .same(proto: "id"),
+    3: .same(proto: "timestamp"),
+    4: .same(proto: "type"),
+    5: .same(proto: "direction"),
+    6: .same(proto: "event"),
+  ]
+
+  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
+    while let fieldNumber = try decoder.nextFieldNumber() {
+      // The use of inline closures is to circumvent an issue where the compiler
+      // allocates stack space for every case branch when no optimizations are
+      // enabled. https://github.com/apple/swift-protobuf/issues/1034
+      switch fieldNumber {
+      case 1: try { try decoder.decodeSingularBytesField(value: &self._peerUuid) }()
+      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
+      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
+      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
+      case 5: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
+      case 6: try { try decoder.decodeSingularEnumField(value: &self._event) }()
+      default: break
+      }
+    }
+  }
+
+  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
+    // The use of inline closures is to circumvent an issue where the compiler
+    // allocates stack space for every if/case branch local when no optimizations
+    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
+    // https://github.com/apple/swift-protobuf/issues/1182
+    try { if let v = self._peerUuid {
+      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
+    } }()
+    try { if let v = self._id {
+      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
+    } }()
+    try { if let v = self._timestamp {
+      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
+    } }()
+    try { if let v = self._type {
+      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
+    } }()
+    try { if let v = self._direction {
+      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
+    } }()
+    try { if let v = self._event {
+      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
+    } }()
+    try unknownFields.traverse(visitor: &visitor)
+  }
+
+  static func ==(lhs: SignalServiceProtos_SyncMessage.CallEvent, rhs: SignalServiceProtos_SyncMessage.CallEvent) -> Bool {
+    if lhs._peerUuid != rhs._peerUuid {return false}
+    if lhs._id != rhs._id {return false}
+    if lhs._timestamp != rhs._timestamp {return false}
+    if lhs._type != rhs._type {return false}
+    if lhs._direction != rhs._direction {return false}
+    if lhs._event != rhs._event {return false}
+    if lhs.unknownFields != rhs.unknownFields {return false}
+    return true
+  }
+}
+
+extension SignalServiceProtos_SyncMessage.CallEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
+  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
+    0: .same(proto: "UNKNOWN_TYPE"),
+    1: .same(proto: "AUDIO_CALL"),
+    2: .same(proto: "VIDEO_CALL"),
+  ]
+}
+
+extension SignalServiceProtos_SyncMessage.CallEvent.Direction: SwiftProtobuf._ProtoNameProviding {
+  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
+    0: .same(proto: "UNKNOWN_DIRECTION"),
+    1: .same(proto: "INCOMING"),
+    2: .same(proto: "OUTGOING"),
+  ]
+}
+
+extension SignalServiceProtos_SyncMessage.CallEvent.Event: SwiftProtobuf._ProtoNameProviding {
+  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
+    0: .same(proto: "UNKNOWN_ACTION"),
+    1: .same(proto: "ACCEPTED"),
+    2: .same(proto: "NOT_ACCEPTED"),
+  ]
+}
+
 extension SignalServiceProtos_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
   static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
   static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
diff --git a/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift b/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift
index 07c6cebd834..a94d3b934eb 100644
--- a/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift
+++ b/SignalServiceKit/src/Storage/Database/DatabaseRecovery.swift
@@ -408,7 +408,9 @@ public extension DatabaseRecovery {
             InstalledSticker.table.tableName,
             TestModel.table.tableName,
             CancelledGroupRing.databaseTableName,
-            CdsPreviousE164.databaseTableName
+            CdsPreviousE164.databaseTableName,
+            // Used to update data for active calls, useless retroactively.
+            CallRecord.databaseTableName
         ]
 
         /// Log the tables we're explicitly skipping.
diff --git a/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift b/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift
index 389e965576e..f0fda791bb8 100644
--- a/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift
+++ b/SignalServiceKit/src/Storage/Database/GRDBDatabaseStorageAdapter.swift
@@ -181,7 +181,8 @@ public class GRDBDatabaseStorageAdapter: NSObject {
             TSMention.self,
             ExperienceUpgrade.self,
             CancelledGroupRing.self,
-            CdsPreviousE164.self
+            CdsPreviousE164.self,
+            CallRecord.self
         ]
     }
 
diff --git a/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift b/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
index 7ec6c74caa4..75ebe07a4ce 100644
--- a/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
+++ b/SignalServiceKit/src/Storage/Database/GRDBSchemaMigrator.swift
@@ -212,6 +212,7 @@ public class GRDBSchemaMigrator: NSObject {
         case addCancelledGroupRingsTable
         case addPaymentProcessorColumnToJobRecords
         case addCdsPreviousE164
+        case addCallRecordTable
 
         // NOTE: Every time we add a migration id, consider
         // incrementing grdbSchemaVersionLatest.
@@ -268,7 +269,7 @@ public class GRDBSchemaMigrator: NSObject {
     }
 
     public static let grdbSchemaVersionDefault: UInt = 0
-    public static let grdbSchemaVersionLatest: UInt = 53
+    public static let grdbSchemaVersionLatest: UInt = 54
 
     // An optimization for new users, we have the first migration import the latest schema
     // and mark any other migrations as "already run".
@@ -2061,6 +2062,30 @@ public class GRDBSchemaMigrator: NSObject {
             return .success(())
         } // end: .addCdsPreviousE164
 
+        migrator.registerMigration(.addCallRecordTable) { transaction in
+            /// Add the CallRecord table which from here on out is used to track when calls
+            /// are accepted/declined, missed, etc, across linked devices.
+            /// See `CallRecord`.
+            try transaction.database.create(table: "model_CallRecord") { (table: TableDefinition) in
+                table.column("id", .integer).primaryKey().notNull()
+                table.column("uniqueId", .text).unique(onConflict: .fail).notNull()
+                table.column("callId", .text).unique(onConflict: .ignore).notNull()
+                table.column("interactionUniqueId", .text)
+                    .notNull()
+                    .references("model_TSInteraction", column: "uniqueId", onDelete: .cascade)
+                table.column("peerUuid", .text).notNull()
+                table.column("type", .integer).notNull()
+                table.column("direction", .integer).notNull()
+                table.column("status", .integer).notNull()
+            }
+            try transaction.database.create(
+                index: "index_call_record_on_interaction_unique_id",
+                on: "model_CallRecord",
+                columns: ["interactionUniqueId"]
+            )
+            return .success(())
+        }
+
         // MARK: - Schema Migration Insertion Point
     }
 
