diff --git a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
index a6aad672f44..050559609d8 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
 //
 
 #import "ConversationCollectionView.h"
@@ -82,9 +82,78 @@ - (void)setContentOffset:(CGPoint)contentOffset
         return;
     }
 
+    if ([self shouldSkipAdjustmentDueToLoadingMoreWhileOverscrolledWithProposedContentOffset:contentOffset]) {
+        OWSLogInfo(@"Ignoring contentOffset");
+        return;
+    }
+
     [super setContentOffset:contentOffset];
 }
 
+- (BOOL)shouldSkipAdjustmentDueToLoadingMoreWhileOverscrolledWithProposedContentOffset:(CGPoint)proposedContentOffset
+{
+    // Fixes situation where the user is farther back in their conversation history than they expect
+    // when overscrolling while loading more.
+    //
+    // Our scrollView supports bounce - you can overscroll, and once you pick up your finger,
+    // it'll animate you back to the bounds of the scroll view content. e.g. if you overscroll
+    // the top of the content, UIKit will "bounce" back to the top bound of the content.
+    //
+    // Generally speaking, this is good UX, conventional for the platform, and something we want
+    // to support.
+    //
+    // However, in the case that we're scrolled to the top and there is more content to load, we
+    // can end up in this scenario:
+    //
+    // - user is overscrolled, and lets go of their finger, then these two things happen concurrently:
+    //   1. app loads more message cells and adjusts content offset so as to maintain the previous conversation
+    //      context
+    //   2. since the user *was* overscrolled at the time they released their finger, iOS completes the "bounce
+    //      back" and animates the content to the **new** top of the view port, which is above all the "just loaded"
+    //      messages.
+    //
+    //  Since we've inserted new content at the top, we're no longer actually "over scrolled", so we should avoid
+    //  adjusting the content offset back to the (new) top.
+    //
+    // If you set a breakpoint within this block, you'll see that we repeatedly have a stack frame
+    // like this, with a content-offset that reflects the NEW top, rather than the content that was
+    // at the OLD top, where we should be.
+    //
+    //     -[ConversationCollectionView setContentOffset:]
+    //     -[UIScrollView _smoothScrollWithUpdateTime:] ()
+    //     -[UIScrollView _smoothScrollDisplayLink:] ()
+    //     -[DYDisplayLinkInterposer forwardDisplayLinkCallback:] ()
+    //     CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long) ()
+    //     display_timer_callback(__CFMachPort*, void*, long, void*) ()
+    //     [...]
+    //
+    CGFloat heightDelta = self.contentOffset.y - proposedContentOffset.y;
+
+    // This number is somewhat arbitrary, but since this is "weird code" we want to limit the
+    // set of cirumstances where we apply it.
+    //
+    // During normal scrolling, contentOffset changes are small.
+    if (heightDelta < 1000) {
+        // If this is only a small change, it probably does not corresond to jumping across
+        // a newly loaded page.
+        return NO;
+    }
+
+    if (proposedContentOffset.y > 0) {
+        // The top content offset is actually less than 0 due to contentInset/safeArea
+        // If the new contentOffset is > 0, this doesn't reflect an attempt to scroll to top.
+        return NO;
+    }
+
+    if (!self.isDecelerating) {
+        // When "bouncing back" after overscrolling, isDecelerating will be true. If we're
+        // not decelerating, then we weren't overscrolled, and the fix need not apply.
+        return NO;
+    }
+
+    return YES;
+}
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 33b9be53dc5..dde0511241b 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -5177,6 +5177,35 @@ - (void)conversationViewModelDidLoadMoreItems
     CGFloat newDistance = newFrame.origin.y - previousDistance;
 
     CGPoint newContentOffset = CGPointMake(0, newDistance);
+
+    // Note: It's important that we call `setContentOffset:animated:NO` rather than `setContentOffset:`,
+    // even though `setContentOffset:` is, by default, not animated. UICollectionView does some
+    // other work in `setContentOffset:animated:NO`. Without that additional work, we see situations
+    // where contentOffset is incorrectly reset to the top - causing the user to inexplicably be
+    // farther back in their history than they expect.
+    //
+    // When using `[self.collectionView setContentOffset:newContentOffset]`, a trivial repro is:
+    //
+    //   - have enough messages that you can load in a couple pages (e.g. 100)
+    //   - tap the top of the navbar to hit UICollectionView's "scroll to top" tap gesture
+    //   - you see "loading more..." which is shortly replaced by the newly loaded messages
+    //   - At this point you would expect to maintain the conversation context, such that the messages
+    //     visible before loading are visible at the same screen coordinates.
+    //   - But instead, after the messages load in, you are immediately scrolled back even farther
+    //     to the *new* top of the conversation, causing *another* page of messages to be loaded.
+    //
+    // I'm unclear what the underlying issue is, but it may be related to:
+    //  - we set contentOffset here, but collectionView hasn't yet internally updated it's contentSize
+    //    to reflect the new layout. Maybe this triggers a "reset".
+    //  - Manually setting the collectionView.contentSize view [collectionView setContentSize:]` to
+    //    the new `[self safeContentHeight]` also did not remedy the issue, so it seems like there is
+    //    some other relevant state.
+    //  - I could find no public API to trigger collectionView to update it's own contentSize sync,
+    //    but a debugger shows it as happening as a result of `[collectionView layoutSubviews]`
+    //  - manually calling layout methods doesn't update the content size: e.g.
+    //    - [collectionView layoutIfNeeded]; // <- doesn't help
+    //    - [collectionView setNeedsLayout]; [collectionView layoutIfNeeded]; // <- doesn't help
+    //    - [collectionView layoutSubviews]; // <- doesn't help
     [self.collectionView setContentOffset:newContentOffset animated:NO];
 }
 
