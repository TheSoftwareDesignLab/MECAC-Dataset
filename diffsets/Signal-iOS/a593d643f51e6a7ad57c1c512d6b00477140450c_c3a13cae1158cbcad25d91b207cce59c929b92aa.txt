diff --git a/Signal/ConversationView/ConversationInputTextView.swift b/Signal/ConversationView/ConversationInputTextView.swift
index 5c725a8589d..d23596297a0 100644
--- a/Signal/ConversationView/ConversationInputTextView.swift
+++ b/Signal/ConversationView/ConversationInputTextView.swift
@@ -7,7 +7,7 @@ public import SignalServiceKit
 import SignalUI
 
 public protocol ConversationInputTextViewDelegate: AnyObject {
-    func didPasteAttachment(_ attachment: SignalAttachment?)
+    func didAttemptAttachmentPaste()
     func inputTextViewSendMessagePressed()
     func textViewDidChange(_ textView: UITextView)
 }
@@ -157,9 +157,7 @@ class ConversationInputTextView: BodyRangesTextView {
 
     override func paste(_ sender: Any?) {
         if pasteboardHasPossibleAttachment {
-            // Note: attachment might be nil or have an error at this point; that's fine.
-            let attachment = SignalAttachment.attachmentFromPasteboard()
-            inputTextViewDelegate?.didPasteAttachment(attachment)
+            inputTextViewDelegate?.didAttemptAttachmentPaste()
             return
         }
 
diff --git a/Signal/ConversationView/ConversationViewController+Delegates.swift b/Signal/ConversationView/ConversationViewController+Delegates.swift
index 67dfd01a665..51984407a17 100644
--- a/Signal/ConversationView/ConversationViewController+Delegates.swift
+++ b/Signal/ConversationView/ConversationViewController+Delegates.swift
@@ -201,7 +201,20 @@ extension ConversationViewController: ConversationHeaderViewDelegate {
 // MARK: -
 
 extension ConversationViewController: ConversationInputTextViewDelegate {
-    public func didPasteAttachment(_ attachment: SignalAttachment?) {
+    public func didAttemptAttachmentPaste() {
+        ModalActivityIndicatorViewController.present(fromViewController: self) { modal in
+            let attachment: SignalAttachment? = await SignalAttachment.attachmentFromPasteboard()
+
+            await MainActor.run {
+                modal.dismiss {
+                    // Note: attachment might be nil or have an error at this point; that's fine.
+                    self.didPasteAttachment(attachment)
+                }
+            }
+        }
+    }
+
+    func didPasteAttachment(_ attachment: SignalAttachment?) {
         AssertIsOnMainThread()
 
         guard let attachment = attachment else {
diff --git a/SignalServiceKit/Attachments/SignalAttachment.swift b/SignalServiceKit/Attachments/SignalAttachment.swift
index 0fb4fb397ce..36350adc8ef 100644
--- a/SignalServiceKit/Attachments/SignalAttachment.swift
+++ b/SignalServiceKit/Attachments/SignalAttachment.swift
@@ -242,21 +242,6 @@ public class SignalAttachment: NSObject {
         return errorDescription
     }
 
-    public func cloneAttachment() throws -> SignalAttachment {
-        guard let sourceUrl = dataUrl else {
-            owsFailDebug("Missing data URL for attachment!")
-            return SignalAttachment.empty()
-        }
-
-        let newUrl = OWSFileSystem.temporaryFileUrl(fileExtension: sourceUrl.pathExtension)
-        try FileManager.default.copyItem(at: sourceUrl, to: newUrl)
-
-        let clonedDataSource = try DataSourcePath(fileUrl: newUrl, shouldDeleteOnDeallocation: true)
-        clonedDataSource.sourceFilename = sourceFilename
-
-        return self.replacingDataSource(with: clonedDataSource)
-    }
-
     public func preparedForOutput(qualityLevel: ImageQualityLevel) -> SignalAttachment {
         owsAssertDebug(!Thread.isMainThread)
 
@@ -631,7 +616,7 @@ public class SignalAttachment: NSObject {
     ///
     /// NOTE: The attachment returned by this method may not be valid.
     ///       Check the attachment's error property.
-    public class func attachmentFromPasteboard() -> SignalAttachment? {
+    public class func attachmentFromPasteboard() async -> SignalAttachment? {
         guard UIPasteboard.general.numberOfItems >= 1 else {
             return nil
         }
@@ -673,12 +658,18 @@ public class SignalAttachment: NSObject {
         }
         for dataUTI in videoUTISet {
             if pasteboardUTISet.contains(dataUTI) {
-                guard let data = dataForFirstPasteboardItem(dataUTI: dataUTI) else {
-                    owsFailDebug("Missing expected pasteboard data for UTI: \(dataUTI)")
+                guard
+                    let data = dataForFirstPasteboardItem(dataUTI: dataUTI),
+                    let dataSource = DataSourceValue(data, utiType: dataUTI)
+                else {
+                    owsFailDebug("Failed to build data source from pasteboard data for UTI: \(dataUTI)")
                     return nil
                 }
-                let dataSource = DataSourceValue(data, utiType: dataUTI)
-                return videoAttachment(dataSource: dataSource, dataUTI: dataUTI)
+
+                return try? await SignalAttachment.compressVideoAsMp4(
+                    dataSource: dataSource,
+                    dataUTI: dataUTI
+                )
             }
         }
         for dataUTI in audioUTISet {
diff --git a/SignalShareExtension/ShareViewController.swift b/SignalShareExtension/ShareViewController.swift
index dc05d34c9ed..bba01019e81 100644
--- a/SignalShareExtension/ShareViewController.swift
+++ b/SignalShareExtension/ShareViewController.swift
@@ -710,8 +710,16 @@ public class ShareViewController: UIViewController, ShareViewDelegate, SAEFailed
             return try await self.buildFileAttachment(fromItemProvider: itemProvider, forTypeIdentifier: typedItemProvider.itemType.typeIdentifier)
         case .fileUrl, .json:
             let url: NSURL = try await Self.loadObjectWithKeyedUnarchiverFallback(fromItemProvider: itemProvider, forTypeIdentifier: TypedItemProvider.ItemType.fileUrl.typeIdentifier, cannotLoadError: .cannotLoadURLObject, failedLoadError: .loadURLObjectFailed)
-            let attachment = try Self.copyAttachment(fromUrl: url as URL)
-            return try await self.compressVideo(attachment: attachment)
+
+            let (dataSource, dataUTI) = try Self.copyFileUrl(
+                fileUrl: url as URL,
+                defaultTypeIdentifier: UTType.data.identifier
+            )
+
+            return try await compressVideoIfNecessary(
+                dataSource: dataSource,
+                dataUTI: dataUTI
+            )
         case .webUrl:
             let url: NSURL = try await Self.loadObjectWithKeyedUnarchiverFallback(fromItemProvider: itemProvider, forTypeIdentifier: typedItemProvider.itemType.typeIdentifier, cannotLoadError: .cannotLoadURLObject, failedLoadError: .loadURLObjectFailed)
             return try Self.createAttachment(withText: (url as URL).absoluteString)
@@ -739,41 +747,65 @@ public class ShareViewController: UIViewController, ShareViewDelegate, SAEFailed
         }
     }
 
-    nonisolated private static func copyAttachment(fromUrl url: URL, defaultTypeIdentifier: String = UTType.data.identifier) throws -> SignalAttachment {
-        guard let dataSource = try? DataSourcePath(fileUrl: url, shouldDeleteOnDeallocation: false) else {
-            throw ShareViewControllerError.nonFileUrl
-        }
-        dataSource.sourceFilename = url.lastPathComponent
-        let utiType = MimeTypeUtil.utiTypeForFileExtension(url.pathExtension) ?? defaultTypeIdentifier
-        let attachment = SignalAttachment.attachment(dataSource: dataSource, dataUTI: utiType)
-        if let attachmentError = attachment.error {
-            throw attachmentError
+    nonisolated private static func copyFileUrl(
+        fileUrl: URL,
+        defaultTypeIdentifier: String
+    ) throws -> (DataSource, dataUTI: String) {
+        guard fileUrl.isFileURL else {
+            throw OWSAssertionError("Unexpectedly not a file URL: \(fileUrl)")
         }
-        return try attachment.cloneAttachment()
+
+        let copiedUrl = OWSFileSystem.temporaryFileUrl(fileExtension: fileUrl.pathExtension)
+        try FileManager.default.copyItem(at: fileUrl, to: copiedUrl)
+
+        let dataSource = try DataSourcePath(fileUrl: copiedUrl, shouldDeleteOnDeallocation: true)
+        dataSource.sourceFilename = fileUrl.lastPathComponent
+
+        let dataUTI = MimeTypeUtil.utiTypeForFileExtension(fileUrl.pathExtension) ?? defaultTypeIdentifier
+
+        return (dataSource, dataUTI)
     }
 
-    nonisolated private func compressVideo(attachment: SignalAttachment) async throws -> SignalAttachment {
-        if attachment.isVideoThatNeedsCompression() {
+    nonisolated private func compressVideoIfNecessary(
+        dataSource: DataSource,
+        dataUTI: String
+    ) async throws -> SignalAttachment {
+        if SignalAttachment.isVideoThatNeedsCompression(
+            dataSource: dataSource,
+            dataUTI: dataUTI
+        ) {
             // TODO: Move waiting for this export to the end of the share flow rather than up front
-            let compressedAttachment = try await SignalAttachment.compressVideoAsMp4(dataSource: attachment.dataSource, dataUTI: attachment.dataUTI, sessionCallback: { exportSession in
-                let progressPoller = ProgressPoller(timeInterval: 0.1, ratioCompleteBlock: { return exportSession.progress })
+            let compressedAttachment = try await SignalAttachment.compressVideoAsMp4(
+                dataSource: dataSource,
+                dataUTI: dataUTI,
+                sessionCallback: { exportSession in
+                    let progressPoller = ProgressPoller(timeInterval: 0.1, ratioCompleteBlock: { return exportSession.progress })
 
-                self.progressPoller = progressPoller
-                progressPoller.startPolling()
+                    self.progressPoller = progressPoller
+                    progressPoller.startPolling()
+
+                    self.loadViewController.progress = progressPoller.progress
+                }
+            )
 
-                self.loadViewController.progress = progressPoller.progress
-            })
             if let attachmentError = compressedAttachment.error {
                 throw attachmentError
             }
+
             return compressedAttachment
         } else {
+            let attachment = SignalAttachment.attachment(dataSource: dataSource, dataUTI: dataUTI)
+
+            if let attachmentError = attachment.error {
+                throw attachmentError
+            }
+
             return attachment
         }
     }
 
     nonisolated private func buildFileAttachment(fromItemProvider itemProvider: NSItemProvider, forTypeIdentifier typeIdentifier: String) async throws -> SignalAttachment {
-        let attachment: SignalAttachment = try await withCheckedThrowingContinuation { continuation in
+        let (dataSource, dataUTI): (DataSource, String) = try await withCheckedThrowingContinuation { continuation in
             _ = itemProvider.loadInPlaceFileRepresentation(forTypeIdentifier: typeIdentifier, completionHandler: { fileUrl, _, error in
                 if let error {
                     continuation.resume(throwing: error)
@@ -783,7 +815,7 @@ public class ShareViewController: UIViewController, ShareViewDelegate, SAEFailed
                     } else {
                         do {
                             // NOTE: Compression here rather than creating an additional temp file would be nice but blocking this completion handler for video encoding is probably not a good way to go.
-                            continuation.resume(returning: try Self.copyAttachment(fromUrl: fileUrl, defaultTypeIdentifier: typeIdentifier))
+                            continuation.resume(returning: try Self.copyFileUrl(fileUrl: fileUrl, defaultTypeIdentifier: typeIdentifier))
                         } catch {
                             continuation.resume(throwing: error)
                         }
@@ -794,11 +826,7 @@ public class ShareViewController: UIViewController, ShareViewDelegate, SAEFailed
             })
         }
 
-        if let attachmentError = attachment.error {
-            throw attachmentError
-        }
-
-        return try await self.compressVideo(attachment: attachment)
+        return try await compressVideoIfNecessary(dataSource: dataSource, dataUTI: dataUTI)
     }
 
     nonisolated private static func loadDataRepresentation(fromItemProvider itemProvider: NSItemProvider, forTypeIdentifier typeIdentifier: String) async throws -> Data {
