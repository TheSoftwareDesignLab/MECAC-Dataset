diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift
index 5d1ff036c3c..68a921636b6 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
@@ -22,6 +22,7 @@ public class ContextMenuActionsAccessory: ContextMenuTargetedPreviewAccessory, C
         self.menu = menu
 
         menuView = ContextMenuActionsView(menu: menu)
+        menuView.isHidden = true
         super.init(accessoryView: menuView, accessoryAlignment: accessoryAlignment)
         menuView.delegate = self
         animateAccessoryPresentationAlongsidePreview = true
@@ -36,6 +37,7 @@ public class ContextMenuActionsAccessory: ContextMenuTargetedPreviewAccessory, C
         setMenuLayerAnchorPoint()
 
         menuView.transform = CGAffineTransform.scale(minimumScale)
+        menuView.isHidden = false
         UIView.animate(
             withDuration: duration,
             delay: 0,
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift
index 7bd61e61555..b62332db648 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift	
@@ -249,6 +249,8 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate, UIGestur
     private var animationState: ContextMenuAnimationState = .none
     private var animateOutPreviewFrame = CGRect.zero
     private let animationDuration = 0.4
+    private let springDamping: CGFloat = 0.8
+    private let springInitialVelocity: CGFloat = 1.0
 
     private var previewShadowVisible = false {
         didSet {
@@ -330,10 +332,14 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate, UIGestur
             self.previewShadowVisible = true
         }
 
-        previewView.isHidden = false
         let finalFrame = previewView.frame
         let initialFrame = previewSourceFrame()
         let shiftPreview = finalFrame != initialFrame
+
+        // Match initial transform
+        previewView.transform = CGAffineTransform.scale(0.95)
+        previewView.isHidden = false
+
         if shiftPreview {
             previewView.frame = initialFrame
 
@@ -347,8 +353,8 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate, UIGestur
             UIView.animate(
                 withDuration: animationDuration,
                 delay: 0,
-                usingSpringWithDamping: 0.8,
-                initialSpringVelocity: 1,
+                usingSpringWithDamping: springDamping,
+                initialSpringVelocity: springInitialVelocity,
                 options: [.curveEaseInOut, .beginFromCurrentState],
                 animations: {
                     for accessory in self.accessoryViews {
@@ -357,9 +363,21 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate, UIGestur
                         }
                     }
                     self.previewView?.frame = finalFrame
+                    self.previewView?.transform = CGAffineTransform.identity
                 }) { _ in
                     self.animationState = .none
             }
+        } else {
+            // Re-scale to match original size, on the original scaling curve
+            UIView.animate(
+                withDuration: 0.3,
+                delay: 0,
+                options: [.curveEaseInOut, .beginFromCurrentState],
+                animations: {
+                    self.previewView?.transform = CGAffineTransform.identity
+                },
+                completion: nil
+            )
         }
 
         // Animate in accessories
@@ -400,8 +418,8 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate, UIGestur
             UIView.animate(
                 withDuration: animationDuration,
                 delay: 0,
-                usingSpringWithDamping: 0.8,
-                initialSpringVelocity: 1,
+                usingSpringWithDamping: springDamping,
+                initialSpringVelocity: springInitialVelocity,
                 options: [.curveEaseInOut, .beginFromCurrentState],
                 animations: {
                     for accessory in self.accessoryViews {
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift
index f3353f47e28..413d19fd778 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift	
@@ -22,11 +22,31 @@ public class ContextMenuInteraction: NSObject, UIInteraction {
 
     weak var delegate: ContextMenuInteractionDelegate?
     fileprivate var contextMenuController: ContextMenuController?
-    var configuration: ContextMenuConfiguration?
+
+    private let sourceViewBounceDuration = 0.3
+    fileprivate var gestureEligibleForMenuPresentation: Bool {
+        didSet {
+            if !gestureEligibleForMenuPresentation {
+                // Animate back out
+                UIView.animate(
+                    withDuration: sourceViewBounceDuration,
+                    delay: 0,
+                    options: [.curveEaseInOut, .beginFromCurrentState],
+                    animations: {
+                        self.targetedPreview?.view?.transform = CGAffineTransform.identity
+                    },
+                    completion: nil
+                )
+            }
+        }
+    }
+    fileprivate var locationInView = CGPoint.zero
+    fileprivate var configuration: ContextMenuConfiguration?
+    fileprivate var targetedPreview: ContextMenuTargetedPreview?
 
     private var longPressGestureRecognizer: UIGestureRecognizer = {
         let recognizer = UILongPressGestureRecognizer(target: self, action: #selector(longPressRecognized(sender:)))
-        recognizer.minimumPressDuration = 0.3
+        recognizer.minimumPressDuration = 0.1
         return recognizer
     }()
 
@@ -50,10 +70,13 @@ public class ContextMenuInteraction: NSObject, UIInteraction {
         delegate: ContextMenuInteractionDelegate
     ) {
         self.delegate = delegate
+        gestureEligibleForMenuPresentation = false
         super.init()
     }
 
-    public func presentMenu(locationInView: CGPoint) {
+    public func initiateContextMenuGesture(locationInView: CGPoint) {
+        self.locationInView = locationInView
+        gestureEligibleForMenuPresentation = true
 
         guard let delegate = self.delegate else {
             owsFailDebug("Missing ContextMenuInteractionDelegate")
@@ -65,11 +88,6 @@ public class ContextMenuInteraction: NSObject, UIInteraction {
             return
         }
 
-        guard let window = view.window else {
-            owsFailDebug("View must be in a window!")
-            return
-        }
-
         guard let contextMenuConfiguration = delegate.contextMenuInteraction(self, configurationForMenuAtLocation: locationInView) else {
             owsFailDebug("Failed to get context menu configuration from delegate")
             return
@@ -83,7 +101,50 @@ public class ContextMenuInteraction: NSObject, UIInteraction {
             accessory.delegate = self
         }
 
-        presentMenu(window: window, contextMenuConfiguration: contextMenuConfiguration, targetedPreview: targetedPreview)
+        self.targetedPreview = targetedPreview
+
+        UIView.animate(
+            withDuration: sourceViewBounceDuration,
+            delay: 0,
+            options: [.curveEaseInOut, .beginFromCurrentState],
+            animations: {
+                targetedPreview.view?.transform = CGAffineTransform.scale(0.95)
+            },
+            completion: { finished in
+                let shouldPresent = finished && self.gestureEligibleForMenuPresentation
+
+                if shouldPresent {
+                    self.presentMenu(locationInView: self.locationInView)
+                    // Animate back out
+                    self.gestureEligibleForMenuPresentation = false
+                }
+            }
+        )
+
+    }
+
+    public func presentMenu(locationInView: CGPoint) {
+        guard let view = self.view else {
+            owsFailDebug("Missing view")
+            return
+        }
+
+        guard let window = view.window else {
+            owsFailDebug("View must be in a window!")
+            return
+        }
+
+        guard let configuration = self.configuration else {
+            owsFailDebug("Missing context menu configuration")
+            return
+        }
+
+        guard let targetedPreview = self.targetedPreview else {
+            owsFailDebug("Missing targeted preview")
+            return
+        }
+
+        presentMenu(window: window, contextMenuConfiguration: configuration, targetedPreview: targetedPreview)
     }
 
     public func presentMenu(window: UIWindow, contextMenuConfiguration: ContextMenuConfiguration, targetedPreview: ContextMenuTargetedPreview) {
@@ -126,6 +187,14 @@ public class ContextMenuInteraction: NSObject, UIInteraction {
     @objc
     private func longPressRecognized(sender: UIGestureRecognizer) {
         let locationInView = sender.location(in: self.view)
+        switch sender.state {
+        case .began:
+            initiateContextMenuGesture(locationInView: locationInView)
+        case .ended, .cancelled:
+            gestureEligibleForMenuPresentation = false
+        default:
+            break
+        }
         presentMenu(locationInView: locationInView)
     }
 }
@@ -195,6 +264,14 @@ public class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
     }
 
     public func initiatingGestureRecognizerDidEnd() {
+        gestureEligibleForMenuPresentation = false
+
+        if contextMenuController == nil {
+            if let configuarion = self.configuration {
+                delegate?.contextMenuInteraction(self, willEndForConfiguration: configuarion)
+            }
+        }
+
         contextMenuController?.gestureDidEnd()
     }
 
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift
index 606f32cda9f..b52feb4cca5 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuReactionBarAccessory.swift	
@@ -39,7 +39,7 @@ public class ContextMenuRectionBarAccessory: ContextMenuTargetedPreviewAccessory
 
         }
         if previewWillShift {
-            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { animateIn() }
+            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) { animateIn() }
         } else {
             animateIn()
         }
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVColorOrGradientView.swift b/Signal/src/ViewControllers/ConversationView/CV/CVColorOrGradientView.swift
index 71b2f750b85..12a128f7f1d 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVColorOrGradientView.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVColorOrGradientView.swift
@@ -38,6 +38,7 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
     private let maskLayer = CAShapeLayer()
 
     public var ensureSubviewsFillBounds = false
+    public var animationsEnabled = false
 
     public init() {
         super.init(name: "CVColorOrGradientView")
@@ -287,8 +288,13 @@ public class CVColorOrGradientView: ManualLayoutViewWithLayer {
     // MARK: - CALayerDelegate
 
     public override func action(for layer: CALayer, forKey event: String) -> CAAction? {
-        // Disable all implicit CALayer animations.
-        NSNull()
+        // Disable all implicit CALayer animations if needed
+        if animationsEnabled {
+            return super.action(for: layer, forKey: event)
+        } else {
+            return NSNull()
+        }
+
     }
 }
 
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift
index 6810a68a9d2..872884513c3 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponent.swift
@@ -291,7 +291,10 @@ public protocol CVComponentView {
 
     func reset()
 
+    // Allows component opportunity to configure and return a subview for context menu previews
     @objc optional func contextMenuContentView() -> UIView?
+    // Called when bounce in animation for context menu completes
+    @objc optional func contextMenuSourceAnimationComplete()
 }
 
 // MARK: -
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift
index d7003745093..e944533fc28 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift
@@ -1484,9 +1484,14 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
         }
 
         public func contextMenuContentView() -> UIView? {
+            chatColorView.animationsEnabled = true
             return chatColorView
         }
 
+        public func contextMenuSourceAnimationComplete() {
+            chatColorView.animationsEnabled = false
+        }
+
         fileprivate func removeSwipeActionAnimations() {
             for swipeToReplyWrapper in swipeToReplyWrappers {
                 swipeToReplyWrapper.layer.removeAllAnimations()
diff --git a/Signal/src/ViewControllers/ConversationView/CVViewState.swift b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
index 53a5e38c090..8954c210221 100644
--- a/Signal/src/ViewControllers/ConversationView/CVViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CVViewState.swift
@@ -122,6 +122,7 @@ public class CVViewState: NSObject {
 
     public let collectionViewTapGestureRecognizer = UITapGestureRecognizer()
     public let collectionViewLongPressGestureRecognizer = UILongPressGestureRecognizer()
+    public let collectionViewContextMenuGestureRecognizer = UILongPressGestureRecognizer()
     public let collectionViewPanGestureRecognizer = UIPanGestureRecognizer()
     public var collectionViewActiveContextMenuInteraction: ChatHistoryContextMenuInteraction?
     public var longPressHandler: CVLongPressHandler?
@@ -286,6 +287,9 @@ public extension ConversationViewController {
     var collectionViewLongPressGestureRecognizer: UILongPressGestureRecognizer {
         viewState.collectionViewLongPressGestureRecognizer
     }
+    var collectionViewContextMenuGestureRecognizer: UILongPressGestureRecognizer {
+        viewState.collectionViewContextMenuGestureRecognizer
+    }
     var collectionViewPanGestureRecognizer: UIPanGestureRecognizer {
         viewState.collectionViewPanGestureRecognizer
     }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift
index f6c0651e03b..f57b77814b1 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift
@@ -14,6 +14,13 @@ extension ConversationViewController: UIGestureRecognizerDelegate {
         collectionViewLongPressGestureRecognizer.delegate = self
         collectionView.addGestureRecognizer(collectionViewLongPressGestureRecognizer)
 
+        if FeatureFlags.contextMenus {
+            collectionViewContextMenuGestureRecognizer.addTarget(self, action: #selector(handleLongPressGesture))
+            collectionViewContextMenuGestureRecognizer.minimumPressDuration = 0.1
+            collectionViewContextMenuGestureRecognizer.delegate = self
+            collectionView.addGestureRecognizer(collectionViewContextMenuGestureRecognizer)
+        }
+
         collectionViewPanGestureRecognizer.addTarget(self, action: #selector(handlePanGesture))
         collectionViewPanGestureRecognizer.delegate = self
         collectionView.addGestureRecognizer(collectionViewPanGestureRecognizer)
@@ -63,6 +70,13 @@ extension ConversationViewController: UIGestureRecognizerDelegate {
         }
     }
 
+    public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
+        // Support standard long press recognizing for body text cases, and context menu long press recognizing for everything else 
+        let currentIsLongPress = (gestureRecognizer == collectionViewLongPressGestureRecognizer || gestureRecognizer == collectionViewContextMenuGestureRecognizer)
+        let otherIsLongPress = (otherGestureRecognizer == collectionViewLongPressGestureRecognizer || otherGestureRecognizer == collectionViewContextMenuGestureRecognizer)
+        return currentIsLongPress && otherIsLongPress
+    }
+
     // MARK: -
 
     private func findCell(forGesture sender: UIGestureRecognizer) -> CVCell? {
@@ -142,7 +156,11 @@ extension ConversationViewController: UIGestureRecognizerDelegate {
                                                                componentDelegate: componentDelegate) else {
             return nil
         }
-        longPressHandler.startGesture(cell: cell)
+        if sender == collectionViewContextMenuGestureRecognizer {
+            longPressHandler.startContextMenuGesture(cell: cell)
+        } else {
+            longPressHandler.startGesture(cell: cell)
+        }
         return longPressHandler
     }
 
@@ -238,7 +256,7 @@ public struct CVLongPressHandler {
         self.itemViewModel = CVItemViewModelImpl(renderItem: renderItem)
     }
 
-    func startGesture(cell: CVCell) {
+    func startContextMenuGesture(cell: CVCell) {
         guard let delegate = self.delegate else {
             owsFailDebug("Missing delegate.")
             return
@@ -266,9 +284,56 @@ public struct CVLongPressHandler {
                                            shouldAllowReply: shouldAllowReply)
         case .systemMessage:
             delegate.cvc_didLongPressSystemMessage(cell, itemViewModel: itemViewModel)
-        case .bodyText(let item):
-            delegate.cvc_didLongPressBodyTextItem(.init(item: item))
+        case .bodyText( _ ):
+            break
+        }
+    }
+
+    func startGesture(cell: CVCell) {
+        guard let delegate = self.delegate else {
+            owsFailDebug("Missing delegate.")
+            return
         }
+
+        let useContextMenu = FeatureFlags.contextMenus
+        let shouldAllowReply = delegate.cvc_shouldAllowReplyForItem(itemViewModel)
+
+        if !useContextMenu {
+            switch gestureLocation {
+            case .`default`:
+
+                // TODO: Rename from "Text view item" to "default"?
+                delegate.cvc_didLongPressTextViewItem(cell,
+                                                      itemViewModel: itemViewModel,
+                                                      shouldAllowReply: shouldAllowReply)
+            case .media:
+                delegate.cvc_didLongPressMediaViewItem(cell,
+                                                       itemViewModel: itemViewModel,
+                                                       shouldAllowReply: shouldAllowReply)
+            case .sticker:
+                delegate.cvc_didLongPressSticker(cell,
+                                                 itemViewModel: itemViewModel,
+                                                 shouldAllowReply: shouldAllowReply)
+            case .quotedReply:
+                delegate.cvc_didLongPressQuote(cell,
+                                               itemViewModel: itemViewModel,
+                                               shouldAllowReply: shouldAllowReply)
+            case .systemMessage:
+                delegate.cvc_didLongPressSystemMessage(cell, itemViewModel: itemViewModel)
+            case .bodyText(let item):
+                // TODO EB This one handles URLs, and data detectors
+                delegate.cvc_didLongPressBodyTextItem(.init(item: item))
+            }
+        } else {
+            switch gestureLocation {
+            case .bodyText(let item):
+                delegate.cvc_didLongPressBodyTextItem(.init(item: item))
+            default:
+                // Case will be handled by context menu gesture recognizer
+                break
+            }
+        }
+
     }
 
     func handleLongPress(_ sender: UILongPressGestureRecognizer) {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
index 8c06faf31d1..b8f3918a494 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
@@ -15,12 +15,12 @@ extension ConversationViewController {
             return
         }
         if FeatureFlags.contextMenus {
-            let interaction = ChatHistoryContextMenuInteraction(delegate: self, itemViewModel: itemViewModel, thread: thread, messageActions: messageActions, initiatingGestureRecognizer: collectionViewLongPressGestureRecognizer)
+            let interaction = ChatHistoryContextMenuInteraction(delegate: self, itemViewModel: itemViewModel, thread: thread, messageActions: messageActions, initiatingGestureRecognizer: collectionViewContextMenuGestureRecognizer)
             collectionViewActiveContextMenuInteraction = interaction
             cell.addInteraction(interaction)
             let cellCenterPoint = cell.frame.center
             let screenPoint = self.collectionView .convert(cellCenterPoint, from: cell)
-            interaction.presentMenu(locationInView: screenPoint)
+            interaction.initiateContextMenuGesture(locationInView: screenPoint)
         } else {
             let messageActionsViewController = MessageActionsViewController(itemViewModel: itemViewModel,
                                                                             focusedView: cell,
@@ -263,6 +263,10 @@ extension ConversationViewController: ContextMenuInteractionDelegate {
     }
 
     public func contextMenuInteraction(_ interaction: ContextMenuInteraction, willEndForConfiguration: ContextMenuConfiguration) {
+        if let contextInteraction = interaction as? ChatHistoryContextMenuInteraction, let cell = contextInteraction.view as? CVCell, let componentView = cell.componentView {
+            componentView.contextMenuSourceAnimationComplete?()
+        }
+
         collectionViewActiveContextMenuInteraction = nil
     }
 
