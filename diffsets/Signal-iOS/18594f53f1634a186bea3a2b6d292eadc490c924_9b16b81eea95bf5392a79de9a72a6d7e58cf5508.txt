diff --git a/Signal/Registration/RegistrationCoordinatorImpl.swift b/Signal/Registration/RegistrationCoordinatorImpl.swift
index 206f0095dd8..4b2f2d55a2c 100644
--- a/Signal/Registration/RegistrationCoordinatorImpl.swift
+++ b/Signal/Registration/RegistrationCoordinatorImpl.swift
@@ -43,14 +43,14 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
             // come back and pick up where they left off, probably on next app launch.
             return true
         case .changingNumber(let state):
-            if state.pniState != nil {
-                // Not allowed to exit once we have in progress pni state.
-                return false
-            } else {
+            if state.canExitRegistrationFlow {
                 // Wipe in progress state; presumably the user decided not
                 // to change number.
                 self.wipePersistedState()
                 return true
+            } else {
+                // Not allowed to exit once we have in progress pni state.
+                return false
             }
         }
     }
@@ -236,7 +236,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
                             canSkip: true,
                             remainingAttempts: remainingAttempts
                         ),
-                        error: .wrongPin(wrongPin: code)
+                        error: .wrongPin(wrongPin: code),
+                        exitConfiguration: pinCodeEntryExitConfiguration()
                     )))
                 }
             }
@@ -899,7 +900,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
             return .value(.pinEntry(RegistrationPinState(
                 // We can skip which will stop trying to use reg recovery.
                 operation: .enteringExistingPin(canSkip: true, remainingAttempts: nil),
-                error: nil
+                error: nil,
+                exitConfiguration: pinCodeEntryExitConfiguration()
             )))
         }
 
@@ -910,7 +912,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
             Logger.warn("PIN mismatch; should be prevented at submission time.")
             return .value(.pinEntry(RegistrationPinState(
                 operation: .enteringExistingPin(canSkip: true, remainingAttempts: nil),
-                error: .wrongPin(wrongPin: pinFromUser)
+                error: .wrongPin(wrongPin: pinFromUser),
+                exitConfiguration: pinCodeEntryExitConfiguration()
             )))
         }
 
@@ -1075,7 +1078,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
             // We don't have a pin at all, ask the user for it.
             return .value(.pinEntry(RegistrationPinState(
                 operation: .enteringExistingPin(canSkip: true, remainingAttempts: nil),
-                error: nil
+                error: nil,
+                exitConfiguration: pinCodeEntryExitConfiguration()
             )))
         }
 
@@ -1107,7 +1111,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
                             canSkip: true,
                             remainingAttempts: UInt(remainingAttempts)
                         ),
-                        error: .wrongPin(wrongPin: pin)
+                        error: .wrongPin(wrongPin: pin),
+                        exitConfiguration: self.pinCodeEntryExitConfiguration()
                     )))
                 case .backupMissing:
                     // If we are unable to talk to KBS, it got wiped and we can't
@@ -1264,7 +1269,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
             } else {
                 return .value(.pinEntry(RegistrationPinState(
                     operation: .enteringExistingPin(canSkip: false, remainingAttempts: nil),
-                    error: .none
+                    error: .none,
+                    exitConfiguration: pinCodeEntryExitConfiguration()
                 )))
             }
         case .waitingTimeout(let reglockExpirationDate):
@@ -2030,7 +2036,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
                             canSkip: false,
                             remainingAttempts: UInt(remainingAttempts)
                         ),
-                        error: .wrongPin(wrongPin: pin)
+                        error: .wrongPin(wrongPin: pin),
+                        exitConfiguration: self.pinCodeEntryExitConfiguration()
                     )))
                 case .backupMissing:
                     // If we are unable to talk to KBS, it got wiped, probably
@@ -2254,17 +2261,20 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
                 if isRestoringPinBackup {
                     return .value(.pinEntry(RegistrationPinState(
                         operation: .enteringExistingPin(canSkip: true, remainingAttempts: nil),
-                        error: nil
+                        error: nil,
+                        exitConfiguration: pinCodeEntryExitConfiguration()
                     )))
                 } else if let blob = inMemoryState.unconfirmedPinBlob {
                     return .value(.pinEntry(RegistrationPinState(
                         operation: .confirmingNewPin(blob),
-                        error: nil
+                        error: nil,
+                        exitConfiguration: pinCodeEntryExitConfiguration()
                     )))
                 } else {
                     return .value(.pinEntry(RegistrationPinState(
                         operation: .creatingNewPin,
-                        error: nil
+                        error: nil,
+                        exitConfiguration: pinCodeEntryExitConfiguration()
                     )))
                 }
             }
@@ -2318,7 +2328,8 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
                             canSkip: true,
                             remainingAttempts: UInt(remainingAttempts)
                         ),
-                        error: .wrongPin(wrongPin: pin)
+                        error: .wrongPin(wrongPin: pin),
+                        exitConfiguration: self.pinCodeEntryExitConfiguration()
                     )))
                 case .backupMissing:
                     // If we are unable to talk to KBS, it got wiped and we can't
@@ -2885,15 +2896,40 @@ public class RegistrationCoordinatorImpl: RegistrationCoordinator {
         nextVerificationAttemptDate: Date,
         validationError: RegistrationVerificationValidationError? = nil
     ) -> RegistrationVerificationState {
+        let exitConfiguration: RegistrationVerificationState.ExitConfiguration
+        switch mode {
+        case .registering:
+            exitConfiguration = .noExitAllowed
+        case .reRegistering:
+            exitConfiguration = .exitReRegistration
+        case .changingNumber:
+            exitConfiguration = .exitChangeNumber
+        }
         return RegistrationVerificationState(
             e164: session.e164,
             nextSMSDate: session.nextSMSDate,
             nextCallDate: session.nextCallDate,
             nextVerificationAttemptDate: nextVerificationAttemptDate,
-            validationError: validationError
+            validationError: validationError,
+            exitConfiguration: exitConfiguration
         )
     }
 
+    private func pinCodeEntryExitConfiguration() -> RegistrationPinState.ExitConfiguration {
+        switch mode {
+        case .registering:
+            return .noExitAllowed
+        case .reRegistering:
+            return .exitReRegistration
+        case .changingNumber(let state):
+            if state.canExitRegistrationFlow {
+                return .exitChangeNumber
+            } else {
+                return .noExitAllowed
+            }
+        }
+    }
+
     private var reglockTimeoutAcknowledgeAction: RegistrationReglockTimeoutAcknowledgeAction {
         switch mode {
         case .registering: return .resetPhoneNumber
@@ -2956,3 +2992,10 @@ private func unretainedSelfErrorStep() -> RegistrationStep {
     Logger.warn("Registration coordinator reference lost. Showing generic error")
     return .showErrorSheet(.genericError)
 }
+
+extension RegistrationCoordinatorLoaderImpl.Mode.ChangeNumberState {
+
+    var canExitRegistrationFlow: Bool {
+        return pniState == nil
+    }
+}
diff --git a/Signal/Registration/ViewControllers/RegistrationNavigationController.swift b/Signal/Registration/ViewControllers/RegistrationNavigationController.swift
index 5fdfc86c03b..ee3a536ba3d 100644
--- a/Signal/Registration/ViewControllers/RegistrationNavigationController.swift
+++ b/Signal/Registration/ViewControllers/RegistrationNavigationController.swift
@@ -328,6 +328,8 @@ extension RegistrationNavigationController: RegistrationSplashPresenter {
     }
 }
 
+extension RegistrationNavigationController: RegistrationChangeNumberSplashPresenter {}
+
 extension RegistrationNavigationController: RegistrationPermissionsPresenter {
 
     func requestPermissions() {
@@ -340,6 +342,15 @@ extension RegistrationNavigationController: RegistrationPhoneNumberPresenter {
     func goToNextStep(withE164 e164: E164) {
         pushNextController(coordinator.submitE164(e164), loadingMode: .submittingPhoneNumber(e164: e164.stringValue))
     }
+
+    func exitRegistration() {
+        guard coordinator.exitRegistration() else {
+            owsFailBeta("Unable to exit registration")
+            return
+        }
+        Logger.info("Early exiting registration")
+        SignalApp.shared().showConversationSplitView()
+    }
 }
 
 extension RegistrationNavigationController: RegistrationChangePhoneNumberPresenter {
diff --git a/Signal/src/ViewControllers/Registration/RegistrationChangeNumberSplashViewController.swift b/Signal/src/ViewControllers/Registration/RegistrationChangeNumberSplashViewController.swift
index ca7ef899ffa..6a20ea82c3f 100644
--- a/Signal/src/ViewControllers/Registration/RegistrationChangeNumberSplashViewController.swift
+++ b/Signal/src/ViewControllers/Registration/RegistrationChangeNumberSplashViewController.swift
@@ -8,11 +8,19 @@ import SignalServiceKit
 import UIKit
 import SignalMessaging
 
+// MARK: - RegistrationChangeNumberSplashPresenter
+
+protocol RegistrationChangeNumberSplashPresenter: AnyObject {
+    func continueFromSplash()
+
+    func exitRegistration()
+}
+
 class RegistrationChangeNumberSplashViewController: OWSViewController, OWSNavigationChildController {
 
-    private weak var presenter: RegistrationSplashPresenter?
+    private weak var presenter: RegistrationChangeNumberSplashPresenter?
 
-    public init(presenter: RegistrationSplashPresenter) {
+    public init(presenter: RegistrationChangeNumberSplashPresenter) {
         self.presenter = presenter
         super.init()
     }
@@ -37,6 +45,12 @@ class RegistrationChangeNumberSplashViewController: OWSViewController, OWSNaviga
     }
 
     private func createContents() {
+        navigationItem.leftBarButtonItem = UIBarButtonItem(
+            barButtonSystemItem: .cancel,
+            target: self,
+            action: #selector(didPressCancel)
+        )
+
         let scrollView = UIScrollView()
         view.addSubview(scrollView)
         scrollView.autoPinEdge(toSuperviewSafeArea: .leading)
@@ -131,6 +145,11 @@ class RegistrationChangeNumberSplashViewController: OWSViewController, OWSNaviga
         continueButton.autoPinEdgesToSuperviewMargins()
     }
 
+    @objc
+    private func didPressCancel() {
+        presenter?.exitRegistration()
+    }
+
     @objc
     private func didTapContinue(_ sender: UIButton) {
         presenter?.continueFromSplash()
diff --git a/Signal/src/ViewControllers/Registration/RegistrationChangePhoneNumberViewController.swift b/Signal/src/ViewControllers/Registration/RegistrationChangePhoneNumberViewController.swift
index 6f4e4a036d8..146c25c279b 100644
--- a/Signal/src/ViewControllers/Registration/RegistrationChangePhoneNumberViewController.swift
+++ b/Signal/src/ViewControllers/Registration/RegistrationChangePhoneNumberViewController.swift
@@ -11,6 +11,8 @@ import SignalServiceKit
 protocol RegistrationChangePhoneNumberPresenter: AnyObject {
 
     func submitProspectiveChangeNumberE164(newE164: E164)
+
+    func exitRegistration()
 }
 
 // MARK: - RegistrationChangePhoneNumberViewController
@@ -283,7 +285,7 @@ class RegistrationChangePhoneNumberViewController: OWSTableViewController2 {
     private func didPressCancel() {
         AssertIsOnMainThread()
 
-        // TODO
+        presenter?.exitRegistration()
     }
 
     @objc
diff --git a/Signal/src/ViewControllers/Registration/RegistrationPhoneNumberViewController.swift b/Signal/src/ViewControllers/Registration/RegistrationPhoneNumberViewController.swift
index 19289f08f3b..fc4303cc66f 100644
--- a/Signal/src/ViewControllers/Registration/RegistrationPhoneNumberViewController.swift
+++ b/Signal/src/ViewControllers/Registration/RegistrationPhoneNumberViewController.swift
@@ -11,6 +11,8 @@ import SignalMessaging
 
 protocol RegistrationPhoneNumberPresenter: AnyObject {
     func goToNextStep(withE164: E164)
+
+    func exitRegistration()
 }
 
 // MARK: - RegistrationPhoneNumberViewController
@@ -118,28 +120,16 @@ class RegistrationPhoneNumberViewController: OWSViewController {
 
     // MARK: Rendering
 
-    private lazy var proxyButton: UIButton = {
-        let result = ContextMenuButton(contextMenu: .init([
-            .init(
-                title: OWSLocalizedString(
-                    "USE_PROXY_BUTTON",
-                    comment: "Button to activate the signal proxy"
-                ),
-                handler: { [weak self] _ in
-                    guard let self else { return }
-                    let vc = ProxySettingsViewController()
-                    self.presentFormSheet(OWSNavigationController(rootViewController: vc), animated: true)
-                }
-            )
-        ]))
+    private lazy var contextButton: ContextMenuButton = {
+        let result = ContextMenuButton()
         result.showsContextMenuAsPrimaryAction = true
         result.autoSetDimensions(to: .square(40))
         return result
     }()
 
-    private lazy var proxyBarButton = UIBarButtonItem(
-        customView: proxyButton,
-        accessibilityIdentifier: "registration.phonenumber.proxyButton"
+    private lazy var contextBarButton = UIBarButtonItem(
+        customView: contextButton,
+        accessibilityIdentifier: "registration.verificationCode.contextButton"
     )
 
     private lazy var nextBarButton = UIBarButtonItem(
@@ -218,14 +208,20 @@ class RegistrationPhoneNumberViewController: OWSViewController {
         }
     }
 
+    public override func viewWillDisappear(_ animated: Bool) {
+        super.viewWillDisappear(animated)
+
+        if contextButton.isShowingContextMenu {
+            contextButton.dismissContextMenu(animated: animated)
+        }
+    }
+
     public override func themeDidChange() {
         super.themeDidChange()
         render()
     }
 
     private func initialRender() {
-        navigationItem.leftBarButtonItem = proxyBarButton
-
         let stackView = UIStackView()
 
         stackView.axis = .vertical
@@ -249,6 +245,39 @@ class RegistrationPhoneNumberViewController: OWSViewController {
     }
 
     private func render() {
+        var actions: [ContextMenuAction] = [
+            .init(
+                title: OWSLocalizedString(
+                    "USE_PROXY_BUTTON",
+                    comment: "Button to activate the signal proxy"
+                ),
+                handler: { [weak self] _ in
+                    guard let self else { return }
+                    let vc = ProxySettingsViewController()
+                    self.presentFormSheet(OWSNavigationController(rootViewController: vc), animated: true)
+                }
+            )
+        ]
+        switch state {
+        case .initialRegistration:
+            break
+        case .reregistration:
+            actions.append(.init(
+                title: OWSLocalizedString(
+                    "EXIT_REREGISTRATION",
+                    comment: "Button to exit re-registration, shown in context menu."
+                ),
+                handler: { [weak self] _ in
+                    self?.presenter?.exitRegistration()
+                }
+            ))
+        }
+        contextButton.contextMenu = ContextMenu(actions)
+        navigationItem.leftBarButtonItem = contextBarButton
+
+        contextButton.setImage(Theme.iconImage(.more24), for: .normal)
+        contextButton.tintColor = Theme.accentBlueColor
+
         navigationItem.rightBarButtonItem = canSubmit ? nextBarButton : nil
 
         phoneNumberInput.isEnabled = canChangePhoneNumber
@@ -269,8 +298,6 @@ class RegistrationPhoneNumberViewController: OWSViewController {
         }
 
         view.backgroundColor = Theme.backgroundColor
-        proxyButton.setImage(Theme.iconImage(.more24), for: .normal)
-        proxyButton.tintColor = Theme.accentBlueColor
         nextBarButton.tintColor = Theme.accentBlueColor
         titleLabel.textColor = .colorForRegistrationTitleLabel
         explanationLabel.textColor = .colorForRegistrationExplanationLabel
diff --git a/Signal/src/ViewControllers/Registration/RegistrationPinViewController.swift b/Signal/src/ViewControllers/Registration/RegistrationPinViewController.swift
index f6bd0295388..d88312268e6 100644
--- a/Signal/src/ViewControllers/Registration/RegistrationPinViewController.swift
+++ b/Signal/src/ViewControllers/Registration/RegistrationPinViewController.swift
@@ -48,6 +48,14 @@ public struct RegistrationPinState: Equatable {
     let operation: RegistrationPinOperation
     // TODO[Registration]: show error UI for this
     let error: RegistrationPinValidationError?
+
+    public enum ExitConfiguration: Equatable {
+        case noExitAllowed
+        case exitReRegistration
+        case exitChangeNumber
+    }
+
+    let exitConfiguration: ExitConfiguration
 }
 
 // MARK: - RegistrationPinPresenter
@@ -60,6 +68,8 @@ protocol RegistrationPinPresenter: AnyObject {
 
     func submitPinCode(_ code: String)
     func submitWithSkippedPin()
+
+    func exitRegistration()
 }
 
 // MARK: - RegistrationPinViewController
@@ -243,6 +253,30 @@ class RegistrationPinViewController: OWSViewController {
         return result
     }()
 
+    private func exitAction() -> ContextMenuAction? {
+        let exitTitle: String
+        switch state.exitConfiguration {
+        case .noExitAllowed:
+            return nil
+        case .exitReRegistration:
+            exitTitle = OWSLocalizedString(
+                "EXIT_REREGISTRATION",
+                comment: "Button to exit re-registration, shown in context menu."
+            )
+        case .exitChangeNumber:
+            exitTitle = OWSLocalizedString(
+                "EXIT_CHANGE_NUMBER",
+                comment: "Button to exit change number, shown in context menu."
+            )
+        }
+        return .init(
+            title: exitTitle,
+            handler: { [weak self] _ in
+                self?.presenter?.exitRegistration()
+            }
+        )
+    }
+
     public override func viewDidLoad() {
         super.viewDidLoad()
         initialRender()
@@ -258,6 +292,14 @@ class RegistrationPinViewController: OWSViewController {
         }
     }
 
+    public override func viewWillDisappear(_ animated: Bool) {
+        super.viewWillDisappear(animated)
+
+        if moreButton.isShowingContextMenu {
+            moreButton.dismissContextMenu(animated: animated)
+        }
+    }
+
     public override func themeDidChange() {
         super.themeDidChange()
         render()
@@ -325,23 +367,27 @@ class RegistrationPinViewController: OWSViewController {
                     handler: { [weak self] _ in
                         self?.showSkipCreatingNewPinUi()
                     }
-                )
-            ])
+                ),
+                exitAction()
+            ].compacted())
         case .confirmingNewPin:
             navigationItem.leftBarButtonItem = backBarButton
         case let .enteringExistingPin(canSkip, remainingAttempts):
             let showAttemptWarningsAt: Set<UInt>
             if canSkip {
                 navigationItem.leftBarButtonItem = moreBarButton
-                moreButton.contextMenu = ContextMenu([.init(
-                    title: OWSLocalizedString(
-                        "PIN_ENTER_EXISTING_SKIP",
-                        comment: "If the user is re-registering, they need to enter their PIN to restore all their data. In some cases, they can skip this entry and lose some data. This text is shown on a button that lets them begin to do this."
+                moreButton.contextMenu = ContextMenu([
+                    .init(
+                        title: OWSLocalizedString(
+                            "PIN_ENTER_EXISTING_SKIP",
+                            comment: "If the user is re-registering, they need to enter their PIN to restore all their data. In some cases, they can skip this entry and lose some data. This text is shown on a button that lets them begin to do this."
+                        ),
+                        handler: { [weak self] _ in
+                            self?.didRequestToSkipEnteringExistingPin()
+                        }
                     ),
-                    handler: { [weak self] _ in
-                        self?.didRequestToSkipEnteringExistingPin()
-                    }
-                )])
+                    exitAction()
+                ].compacted())
                 showAttemptWarningsAt = [3, 1]
             } else {
                 navigationItem.leftBarButtonItem = nil
diff --git a/Signal/src/ViewControllers/Registration/RegistrationVerificationViewController.swift b/Signal/src/ViewControllers/Registration/RegistrationVerificationViewController.swift
index 15d0ec61f66..73e39c28938 100644
--- a/Signal/src/ViewControllers/Registration/RegistrationVerificationViewController.swift
+++ b/Signal/src/ViewControllers/Registration/RegistrationVerificationViewController.swift
@@ -27,6 +27,14 @@ public struct RegistrationVerificationState: Equatable {
     // TODO[Registration]: use this state to render a countdown.
     let nextVerificationAttemptDate: Date
     let validationError: RegistrationVerificationValidationError?
+
+    public enum ExitConfiguration: Equatable {
+        case noExitAllowed
+        case exitReRegistration
+        case exitChangeNumber
+    }
+
+    let exitConfiguration: ExitConfiguration
 }
 
 // MARK: - RegistrationVerificationPresenter
@@ -36,6 +44,7 @@ protocol RegistrationVerificationPresenter: AnyObject {
     func requestSMSCode()
     func requestVoiceCode()
     func submitVerificationCode(_ code: String)
+    func exitRegistration()
 }
 
 // MARK: - RegistrationVerificationViewController
@@ -175,6 +184,14 @@ class RegistrationVerificationViewController: OWSViewController {
         verificationCodeView.becomeFirstResponder()
     }
 
+    public override func viewWillDisappear(_ animated: Bool) {
+        super.viewWillDisappear(animated)
+
+        if contextButton.isShowingContextMenu {
+            contextButton.dismissContextMenu(animated: animated)
+        }
+    }
+
     public override func themeDidChange() {
         super.themeDidChange()
         render()
@@ -213,6 +230,40 @@ class RegistrationVerificationViewController: OWSViewController {
     }
 
     private func render() {
+        switch state.exitConfiguration {
+        case .noExitAllowed:
+            navigationItem.leftBarButtonItem = nil
+        case .exitReRegistration:
+            navigationItem.leftBarButtonItem = contextBarButton
+            contextButton.contextMenu = ContextMenu([
+                .init(
+                    title: OWSLocalizedString(
+                        "EXIT_REREGISTRATION",
+                        comment: "Button to exit re-registration, shown in context menu."
+                    ),
+                    handler: { [weak self] _ in
+                        self?.presenter?.exitRegistration()
+                    }
+                )
+            ])
+        case .exitChangeNumber:
+            navigationItem.leftBarButtonItem = contextBarButton
+            contextButton.contextMenu = ContextMenu([
+                .init(
+                    title: OWSLocalizedString(
+                        "EXIT_CHANGE_NUMBER",
+                        comment: "Button to exit change number, shown in context menu."
+                    ),
+                    handler: { [weak self] _ in
+                        self?.presenter?.exitRegistration()
+                    }
+                )
+            ])
+        }
+
+        contextButton.setImage(Theme.iconImage(.more24), for: .normal)
+        contextButton.tintColor = Theme.accentBlueColor
+
         renderResendButton(
             button: resendSMSCodeButton,
             date: state.nextSMSDate,
@@ -359,6 +410,18 @@ class RegistrationVerificationViewController: OWSViewController {
             didRequestEdit: { [weak self] in self?.presenter?.returnToPhoneNumberEntry() }
         ))
     }
+
+    private lazy var contextButton: ContextMenuButton = {
+        let result = ContextMenuButton()
+        result.showsContextMenuAsPrimaryAction = true
+        result.autoSetDimensions(to: .square(40))
+        return result
+    }()
+
+    private lazy var contextBarButton = UIBarButtonItem(
+        customView: contextButton,
+        accessibilityIdentifier: "registration.verificationCode.contextButton"
+    )
 }
 
 // MARK: - RegistrationVerificationCodeViewDelegate
diff --git a/Signal/test/Registration/RegistrationCoordinatorTest.swift b/Signal/test/Registration/RegistrationCoordinatorTest.swift
index 827c093b577..5d67047500e 100644
--- a/Signal/test/Registration/RegistrationCoordinatorTest.swift
+++ b/Signal/test/Registration/RegistrationCoordinatorTest.swift
@@ -267,7 +267,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
         // Give it a phone number, which should show the PIN entry step.
         var nextStep = coordinator.submitE164(Stubs.e164).value
         // Now it should ask for the PIN to confirm the user knows it.
-        XCTAssertEqual(nextStep, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath()))
+        XCTAssertEqual(nextStep, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath(mode: self.mode)))
 
         // Give it the pin code, which should make it try and register.
         let expectedRequest = RegistrationRequestFactory.createAccountRequest(
@@ -393,13 +393,14 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // Give it a phone number, which should show the PIN entry step.
             var nextStep = coordinator.submitE164(Stubs.e164).value
             // Now it should ask for the PIN to confirm the user knows it.
-            XCTAssertEqual(nextStep, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath()))
+            XCTAssertEqual(nextStep, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath(mode: self.mode)))
 
             // Give it the wrong PIN, it should reject and give us the same step again.
             nextStep = coordinator.submitPINCode(wrongPinCode).value
             XCTAssertEqual(
                 nextStep,
                 .pinEntry(Stubs.pinEntryStateForRegRecoveryPath(
+                    mode: self.mode,
                     error: .wrongPin(wrongPin: wrongPinCode),
                     remainingAttempts: 9
                 ))
@@ -509,7 +510,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // Give it a phone number, which should show the PIN entry step.
             var nextStep = coordinator.submitE164(Stubs.e164)
             // Now it should ask for the PIN to confirm the user knows it.
-            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath()))
+            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath(mode: self.mode)))
 
             // Now we want to control timing so we can verify things happened in the right order.
             scheduler.stop()
@@ -569,7 +570,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(scheduler.currentTime, 4)
 
             // Now we should expect to be at verification code entry since we already set the phone number.
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
             // We want to have kept the master key; we failed the reg recovery pw check
             // but that could happen even if the key is valid. Once we finish session based
             // re-registration we want to be able to recover the key.
@@ -611,7 +612,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // Give it a phone number, which should show the PIN entry step.
             var nextStep = coordinator.submitE164(Stubs.e164)
             // Now it should ask for the PIN to confirm the user knows it.
-            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath()))
+            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath(mode: self.mode)))
 
             // Now we want to control timing so we can verify things happened in the right order.
             scheduler.stop()
@@ -674,7 +675,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(scheduler.currentTime, 4)
 
             // Now we should expect to be at verification code entry since we already set the phone number.
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
             // We want to have wiped our master key; we failed reglock, which means the key itself is
             // wrong.
             XCTAssertFalse(kbs.hasMasterKey)
@@ -715,7 +716,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // Give it a phone number, which should show the PIN entry step.
             var nextStep = coordinator.submitE164(Stubs.e164)
             // Now it should ask for the PIN to confirm the user knows it.
-            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath()))
+            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForRegRecoveryPath(mode: self.mode)))
 
             // Now we want to control timing so we can verify things happened in the right order.
             scheduler.stop()
@@ -874,7 +875,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
 
             // At this point, we should be asking for PIN entry so we can use the credential
             // to recover the KBS master key.
-            XCTAssertEqual(nextStep, .pinEntry(Stubs.pinEntryStateForKBSAuthCredentialPath()))
+            XCTAssertEqual(nextStep, .pinEntry(Stubs.pinEntryStateForKBSAuthCredentialPath(mode: self.mode)))
             // We should have wipted the invalid and unknown credentials.
             let remainingCredentials = kbsAuthCredentialStore.dict
             XCTAssertNotNil(remainingCredentials[Stubs.kbsAuthCredential.username])
@@ -1063,7 +1064,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(scheduler.currentTime, 4)
 
             // Now we should expect to be at verification code entry since we already set the phone number.
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
 
             // We should have wipted the invalid and unknown credentials.
             let remainingCredentials = kbsAuthCredentialStore.dict
@@ -1147,7 +1148,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(scheduler.currentTime, 4)
 
             // Now we should expect to be at verification code entry since we already set the phone number.
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
 
             // We should have wiped the invalid and unknown credentials.
             let remainingCredentials = kbsAuthCredentialStore.dict
@@ -1180,7 +1181,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
 
             // Now it should ask for PIN entry; we are on the kbs auth credential path.
             scheduler.runUntilIdle()
-            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForKBSAuthCredentialPath()))
+            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForKBSAuthCredentialPath(mode: self.mode)))
         }
     }
 
@@ -1267,12 +1268,12 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(scheduler.currentTime, 9)
 
             // Now we should ask to create a PIN.
-            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForPostRegCreate()))
+            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForPostRegCreate(mode: self.mode)))
 
             // Confirm the pin first.
             nextStep = coordinator.setPINCodeForConfirmation(.stub())
             scheduler.runUntilIdle()
-            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForPostRegConfirm()))
+            XCTAssertEqual(nextStep.value, .pinEntry(Stubs.pinEntryStateForPostRegConfirm(mode: self.mode)))
 
             scheduler.adjustTime(to: 0)
 
@@ -1555,7 +1556,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(
                 nextStep.value,
                 .verificationCodeEntry(
-                    Stubs.verificationCodeEntryState(e164: originalE164)
+                    Stubs.verificationCodeEntryState(mode: self.mode, e164: originalE164)
                 )
             )
 
@@ -1619,7 +1620,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(
                 nextStep.value,
                 .verificationCodeEntry(
-                    Stubs.verificationCodeEntryState(e164: changedE164)
+                    Stubs.verificationCodeEntryState(mode: self.mode, e164: changedE164)
                 )
             )
         }
@@ -1704,7 +1705,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // At t=7, we should get back the code entry step.
             scheduler.runUntilIdle()
             XCTAssertEqual(scheduler.currentTime, 7)
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
 
             // Now try and resend a code, which should hit us with the captcha challenge immediately.
             scheduler.start()
@@ -1769,7 +1770,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // given the new sms code date above.
             scheduler.runUntilIdle()
             XCTAssertEqual(scheduler.currentTime, 12)
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
         }
     }
 
@@ -1855,7 +1856,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
 
             XCTAssertEqual(
                 nextStep.value,
-                .verificationCodeEntry(Stubs.verificationCodeEntryState())
+                .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode))
             )
             XCTAssertEqual(
                 sessionManager.latestChallengeFulfillment,
@@ -2122,7 +2123,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
 
             XCTAssertEqual(
                 nextStep.value,
-                .verificationCodeEntry(Stubs.verificationCodeEntryState())
+                .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode))
             )
             XCTAssertEqual(
                 sessionManager.latestChallengeFulfillment,
@@ -2281,7 +2282,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // Once we get that session, we should wait a short time for the
             // push challenge token and fulfill it.
             scheduler.advance(to: receiveChallengeTokenTime + 2)
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
 
             scheduler.runUntilIdle()
             XCTAssertEqual(scheduler.currentTime, receiveChallengeTokenTime + 2)
@@ -2419,6 +2420,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(
                 nextStep.value,
                 .verificationCodeEntry(Stubs.verificationCodeEntryState(
+                    mode: self.mode,
                     validationError: .invalidVerificationCode(invalidCode: badCode)
                 ))
             )
@@ -2453,6 +2455,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(
                 nextStep.value,
                 .verificationCodeEntry(Stubs.verificationCodeEntryState(
+                    mode: self.mode,
                     nextVerificationAttempt: 10,
                     validationError: .submitCodeTimeout
                 ))
@@ -2482,6 +2485,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(
                 nextStep.value,
                 .verificationCodeEntry(Stubs.verificationCodeEntryState(
+                    mode: self.mode,
                     nextSMS: 7,
                     nextVerificationAttempt: 9,
                     validationError: .smsResendTimeout
@@ -2535,6 +2539,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(
                 nextStep.value,
                 .verificationCodeEntry(Stubs.verificationCodeEntryState(
+                    mode: self.mode,
                     nextSMS: 5,
                     nextCall: 4,
                     nextVerificationAttempt: 8,
@@ -2681,7 +2686,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             XCTAssertEqual(scheduler.currentTime, 3)
 
             // Now we should expect to be at verification code entry since we sent the code.
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
 
             scheduler.tick()
 
@@ -2823,7 +2828,7 @@ public class RegistrationCoordinatorTest: XCTestCase {
             // At t=3 we should get back the code entry step.
             scheduler.runUntilIdle()
             XCTAssertEqual(scheduler.currentTime, 3)
-            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState()))
+            XCTAssertEqual(nextStep.value, .verificationCodeEntry(Stubs.verificationCodeEntryState(mode: self.mode)))
         }
     }
 
@@ -2933,21 +2938,25 @@ public class RegistrationCoordinatorTest: XCTestCase {
         }
 
         static func pinEntryStateForRegRecoveryPath(
+            mode: RegistrationMode,
             error: RegistrationPinValidationError? = nil,
             remainingAttempts: UInt? = nil
         ) -> RegistrationPinState {
             return RegistrationPinState(
                 operation: .enteringExistingPin(canSkip: true, remainingAttempts: remainingAttempts),
-                error: error
+                error: error,
+                exitConfiguration: mode.pinExitConfig
             )
         }
 
         static func pinEntryStateForKBSAuthCredentialPath(
+            mode: RegistrationMode,
             error: RegistrationPinValidationError? = nil
         ) -> RegistrationPinState {
             return RegistrationPinState(
                 operation: .enteringExistingPin(canSkip: true, remainingAttempts: nil),
-                error: error
+                error: error,
+                exitConfiguration: mode.pinExitConfig
             )
         }
 
@@ -3012,49 +3021,60 @@ public class RegistrationCoordinatorTest: XCTestCase {
         }
 
         static func verificationCodeEntryState(
+            mode: RegistrationMode,
             e164: E164 = Stubs.e164,
             nextSMS: TimeInterval? = 0,
             nextCall: TimeInterval? = 0,
             nextVerificationAttempt: TimeInterval = 0,
             validationError: RegistrationVerificationValidationError? = nil
         ) -> RegistrationVerificationState {
+
             return RegistrationVerificationState(
                 e164: e164,
                 nextSMSDate: nextSMS.map { date.addingTimeInterval($0) },
                 nextCallDate: nextCall.map { date.addingTimeInterval($0) },
                 nextVerificationAttemptDate: date.addingTimeInterval(nextVerificationAttempt),
-                validationError: validationError
+                validationError: validationError,
+                exitConfiguration: mode.verificationExitConfig
             )
         }
 
         static func pinEntryStateForSessionPathReglock(
+            mode: RegistrationMode,
             error: RegistrationPinValidationError? = nil
         ) -> RegistrationPinState {
             return RegistrationPinState(
                 operation: .enteringExistingPin(canSkip: false, remainingAttempts: nil),
-                error: error
+                error: error,
+                exitConfiguration: mode.pinExitConfig
             )
         }
 
         static func pinEntryStateForPostRegRestore(
+            mode: RegistrationMode,
             error: RegistrationPinValidationError? = nil
         ) -> RegistrationPinState {
             return RegistrationPinState(
                 operation: .enteringExistingPin(canSkip: true, remainingAttempts: nil),
-                error: error
+                error: error,
+                exitConfiguration: mode.pinExitConfig
             )
         }
 
-        static func pinEntryStateForPostRegCreate() -> RegistrationPinState {
-            return RegistrationPinState(operation: .creatingNewPin, error: nil)
+        static func pinEntryStateForPostRegCreate(
+            mode: RegistrationMode
+        ) -> RegistrationPinState {
+            return RegistrationPinState(operation: .creatingNewPin, error: nil, exitConfiguration: mode.pinExitConfig)
         }
 
         static func pinEntryStateForPostRegConfirm(
+            mode: RegistrationMode,
             error: RegistrationPinValidationError? = nil
         ) -> RegistrationPinState {
             return RegistrationPinState(
                 operation: .confirmingNewPin(.stub()),
-                error: error
+                error: error,
+                exitConfiguration: mode.pinExitConfig
             )
         }
     }
@@ -3072,4 +3092,28 @@ extension RegistrationMode {
             return "changing number"
         }
     }
+
+    var pinExitConfig: RegistrationPinState.ExitConfiguration {
+        switch self {
+        case .registering:
+            return .noExitAllowed
+        case .reRegistering:
+            return .exitReRegistration
+        case .changingNumber:
+            // TODO[Registration]: test change number properly
+            return .exitChangeNumber
+        }
+    }
+
+    var verificationExitConfig: RegistrationVerificationState.ExitConfiguration {
+        switch self {
+        case .registering:
+            return .noExitAllowed
+        case .reRegistering:
+            return .exitReRegistration
+        case .changingNumber:
+            // TODO[Registration]: test change number properly
+            return .exitChangeNumber
+        }
+    }
 }
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 1e75e200fee..750db0c957b 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -2233,6 +2233,12 @@
 /* Format string for 'unregistered user' error. Embeds {{the unregistered user's name or signal id}}. */
 "ERROR_UNREGISTERED_USER_FORMAT" = "Unregistered User: %@";
 
+/* Button to exit change number, shown in context menu. */
+"EXIT_CHANGE_NUMBER" = "Exit Change Number";
+
+/* Button to exit re-registration, shown in context menu. */
+"EXIT_REREGISTRATION" = "Exit Registration";
+
 /* Label notifying the user that the app has expired. */
 "EXPIRATION_ERROR" = "Your version of Signal has expired! Tap to update to the most recent version.";
 
