diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index f52c939b2a6..3596b1194b4 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -431,7 +431,6 @@
 		34CF078A203E6B78005C4D61 /* end_call_tone_cept.caf in Resources */ = {isa = PBXBuildFile; fileRef = 34CF0786203E6B78005C4D61 /* end_call_tone_cept.caf */; };
 		34D1F0501F7D45A60066283D /* GifPickerCell.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34D1F04F1F7D45A60066283D /* GifPickerCell.swift */; };
 		34D1F0841F8678AA0066283D /* ConversationInputToolbar.m in Sources */ = {isa = PBXBuildFile; fileRef = 34D1F06A1F8678AA0066283D /* ConversationInputToolbar.m */; };
-		34D1F0861F8678AA0066283D /* ConversationViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 34D1F06E1F8678AA0066283D /* ConversationViewController.m */; };
 		34D1F0B41F86D31D0066283D /* ConversationCollectionView.m in Sources */ = {isa = PBXBuildFile; fileRef = 34D1F0B31F86D31D0066283D /* ConversationCollectionView.m */; };
 		34D1F0C01F8EC1760066283D /* MessageRecipientStatusUtils.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34D1F0BF1F8EC1760066283D /* MessageRecipientStatusUtils.swift */; };
 		34D2CCDA2062E7D000CB1A14 /* OWSScreenLockUI.m in Sources */ = {isa = PBXBuildFile; fileRef = 34D2CCD92062E7D000CB1A14 /* OWSScreenLockUI.m */; };
@@ -1492,7 +1491,6 @@
 		34D1F0691F8678AA0066283D /* ConversationInputToolbar.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConversationInputToolbar.h; sourceTree = "<group>"; };
 		34D1F06A1F8678AA0066283D /* ConversationInputToolbar.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ConversationInputToolbar.m; sourceTree = "<group>"; };
 		34D1F06D1F8678AA0066283D /* ConversationViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConversationViewController.h; sourceTree = "<group>"; };
-		34D1F06E1F8678AA0066283D /* ConversationViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ConversationViewController.m; sourceTree = "<group>"; };
 		34D1F0B21F86D31D0066283D /* ConversationCollectionView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConversationCollectionView.h; sourceTree = "<group>"; };
 		34D1F0B31F86D31D0066283D /* ConversationCollectionView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ConversationCollectionView.m; sourceTree = "<group>"; };
 		34D1F0BF1F8EC1760066283D /* MessageRecipientStatusUtils.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MessageRecipientStatusUtils.swift; sourceTree = "<group>"; };
@@ -2534,7 +2532,6 @@
 				343A65971FC4CFE7000477A1 /* ConversationScrollButton.h */,
 				343A65961FC4CFE6000477A1 /* ConversationScrollButton.m */,
 				34D1F06D1F8678AA0066283D /* ConversationViewController.h */,
-				34D1F06E1F8678AA0066283D /* ConversationViewController.m */,
 				34A4D88C267A363A00A794E7 /* ConversationViewController.swift */,
 				3405C06D25435048008B24EF /* ConversationViewController+Banners.swift */,
 				34E93F9126668F7500CE6FA5 /* ConversationViewController+BodyTextItems.swift */,
@@ -5854,7 +5851,6 @@
 				344DAEDF248A7526000AD4FA /* DebugUIStress.swift in Sources */,
 				329D42A225AD65C400DCB449 /* GetStartedBannerCell.swift in Sources */,
 				348815C9255346A500D4F4C4 /* CVComponent.swift in Sources */,
-				34D1F0861F8678AA0066283D /* ConversationViewController.m in Sources */,
 				32AC5CE7255B51E900829BD8 /* JoinGroupCallPill.swift in Sources */,
 				32ECD08A24BFBF9500EDDED0 /* ContactSupportViewController.swift in Sources */,
 				3448E15E221333F5004B052E /* OnboardingController.swift in Sources */,
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
index a3918c6bcca..efd647e5f9e 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVLoadCoordinator.swift
@@ -44,6 +44,7 @@ protocol CVLoadCoordinatorDelegate: UIScrollViewDelegate {
 struct CVUpdateToken {
     let isScrolledToBottom: Bool
     let lastMessageForInboxSortId: UInt64?
+    let scrollContinuityToken: CVScrollContinuityToken
 }
 
 @objc
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h
index 3f39ea32f78..5ce299182df 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h
+++ b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.h
@@ -1,9 +1,12 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 NS_ASSUME_NONNULL_BEGIN
 
+@class CVScrollContinuityToken;
+@class ConversationViewController;
+
 @protocol ConversationCollectionViewDelegate <NSObject>
 
 - (void)collectionViewWillChangeSizeFrom:(CGSize)oldSize to:(CGSize)newSize;
@@ -14,9 +17,30 @@ NS_ASSUME_NONNULL_BEGIN
 
 #pragma mark -
 
+typedef void (^CVCPerformBatchUpdatesBlock)(void);
+typedef void (^CVCPerformBatchUpdatesCompletion)(BOOL);
+typedef void (^CVCPerformBatchUpdatesFailure)(void);
+
 @interface ConversationCollectionView : UICollectionView
 
 @property (weak, nonatomic) id<ConversationCollectionViewDelegate> layoutDelegate;
+@property (nonatomic) BOOL shouldBreakOnContentOffsetChanges;
+
+- (void)reloadData NS_UNAVAILABLE;
+- (void)cvc_reloadDataWithAnimated:(BOOL)animated
+                               cvc:(ConversationViewController *)cvc NS_SWIFT_NAME(cvc_reloadData(animated:cvc:));
+
+- (void)performBatchUpdates:(void(NS_NOESCAPE ^ _Nullable)(void))updates
+                 completion:(void (^_Nullable)(BOOL finished))completion NS_UNAVAILABLE;
+- (void)cvc_performBatchUpdates:(CVCPerformBatchUpdatesBlock)batchUpdates
+                     completion:(CVCPerformBatchUpdatesCompletion)completion
+                        failure:(CVCPerformBatchUpdatesFailure)failure
+                       animated:(BOOL)animated
+          scrollContinuityToken:(nullable CVScrollContinuityToken *)scrollContinuityToken
+                            cvc:(ConversationViewController *)cvc NS_SWIFT_NAME(cvc_performBatchUpdates(_:completion:
+                                    failure:
+                                    scrollContinuityToken:
+                                    cvc:));
 
 @end
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
index 315fee3d629..41cfbc0dfe9 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationCollectionView.m
@@ -1,8 +1,9 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 #import "ConversationCollectionView.h"
+#import "Signal-Swift.h"
 
 NS_ASSUME_NONNULL_BEGIN
 
@@ -91,11 +92,6 @@ - (void)setContentOffset:(CGPoint)contentOffset
         return;
     }
 
-    if ([self shouldSkipAdjustmentDueToLoadingMoreWhileOverscrolledWithProposedContentOffset:contentOffset]) {
-        OWSLogInfo(@"Ignoring contentOffset");
-        return;
-    }
-
     [super setContentOffset:contentOffset];
 }
 
@@ -108,71 +104,86 @@ - (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated
     [super scrollRectToVisible:rect animated:animated];
 }
 
-- (BOOL)shouldSkipAdjustmentDueToLoadingMoreWhileOverscrolledWithProposedContentOffset:(CGPoint)proposedContentOffset
+- (void)cvc_reloadDataWithAnimated:(BOOL)animated cvc:(ConversationViewController *)cvc
 {
-    // Fixes situation where the user is farther back in their conversation history than they expect
-    // when overscrolling while loading more.
-    //
-    // Our scrollView supports bounce - you can overscroll, and once you pick up your finger,
-    // it'll animate you back to the bounds of the scroll view content. e.g. if you overscroll
-    // the top of the content, UIKit will "bounce" back to the top bound of the content.
-    //
-    // Generally speaking, this is good UX, conventional for the platform, and something we want
-    // to support.
-    //
-    // However, in the case that we're scrolled to the top and there is more content to load, we
-    // can end up in this scenario:
-    //
-    // - user is overscrolled, and lets go of their finger, then these two things happen concurrently:
-    //   1. app loads more message cells and adjusts content offset so as to maintain the previous conversation
-    //      context
-    //   2. since the user *was* overscrolled at the time they released their finger, iOS completes the "bounce
-    //      back" and animates the content to the **new** top of the view port, which is above all the "just loaded"
-    //      messages.
-    //
-    //  Since we've inserted new content at the top, we're no longer actually "over scrolled", so we should avoid
-    //  adjusting the content offset back to the (new) top.
-    //
-    // If you set a breakpoint within this block, you'll see that we repeatedly have a stack frame
-    // like this, with a content-offset that reflects the NEW top, rather than the content that was
-    // at the OLD top, where we should be.
-    //
-    //     -[ConversationCollectionView setContentOffset:]
-    //     -[UIScrollView _smoothScrollWithUpdateTime:] ()
-    //     -[UIScrollView _smoothScrollDisplayLink:] ()
-    //     -[DYDisplayLinkInterposer forwardDisplayLinkCallback:] ()
-    //     CA::Display::DisplayLink::dispatch_items(unsigned long long, unsigned long long, unsigned long long) ()
-    //     display_timer_callback(__CFMachPort*, void*, long, void*) ()
-    //     [...]
-    //
-    CGFloat heightDelta = self.contentOffset.y - proposedContentOffset.y;
-
-    // This number is somewhat arbitrary, but since this is "weird code" we want to limit the
-    // set of cirumstances where we apply it.
-    //
-    // During normal scrolling, contentOffset changes are small.
-    if (fabs(heightDelta) < 1000) {
-        // If this is only a small change, it probably does not corresond to jumping across
-        // a newly loaded page.
-        return NO;
-    }
-
-    // The top content offset is actually less than 0 due to contentInset/safeArea
-    // If the new contentOffset is > 0, this doesn't reflect an attempt to scroll to top.
-    BOOL isNearTop = proposedContentOffset.y < 0;
-    BOOL isNearBottom = self.contentSize.height - proposedContentOffset.y < self.bounds.size.height;
-    if (!(isNearTop || isNearBottom)) {
-        // If we're not near the top nor the bottom, then we're not overscrolled and the fix need not apply.
-        return NO;
+    @try {
+        if (animated) {
+            [cvc.layout willReloadData];
+            [UIView performWithoutAnimation:^{ [super reloadData]; }];
+            [cvc.layout invalidateLayout];
+            [cvc.layout didReloadData];
+        } else {
+            [cvc.layout willReloadData];
+            [super reloadData];
+            [cvc.layout invalidateLayout];
+            [cvc.layout didReloadData];
+        }
+    } @catch (NSException *exception) {
+        OWSLogWarn(@"currentRenderStateDebugDescription: %@", cvc.currentRenderStateDebugDescription);
+        OWSCFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
+            exception.description,
+            exception.name,
+            exception.reason,
+            exception.userInfo);
+        @throw exception;
     }
+}
 
-    if (!self.isDecelerating) {
-        // When "bouncing back" after overscrolling, isDecelerating will be true. If we're
-        // not decelerating, then we weren't overscrolled, and the fix need not apply.
-        return NO;
+- (void)cvc_performBatchUpdates:(CVCPerformBatchUpdatesBlock)batchUpdates
+                     completion:(CVCPerformBatchUpdatesCompletion)completion
+                        failure:(CVCPerformBatchUpdatesFailure)failure
+                       animated:(BOOL)animated
+          scrollContinuityToken:(nullable CVScrollContinuityToken *)scrollContinuityToken
+                            cvc:(ConversationViewController *)cvc
+{
+    @try {
+        void (^updateBlock)(void) = ^{
+            ConversationViewLayout *layout = cvc.layout;
+            layout.isApplyingUpdate = YES;
+            [layout willPerformBatchUpdatesWithScrollContinuityToken:scrollContinuityToken];
+            [cvc.collectionView
+                performBatchUpdates:^{ batchUpdates(); }
+                completion:^(BOOL finished) {
+                    [layout didCompleteBatchUpdates];
+
+                    layout.isApplyingUpdate = NO;
+
+                    completion(finished);
+                }];
+            [layout didPerformBatchUpdatesWithScrollContinuityToken:scrollContinuityToken];
+
+            [BenchManager completeEventWithEventId:@"message-send"];
+        };
+
+        if (animated) {
+            updateBlock();
+        } else {
+            // HACK: We use `UIView.animateWithDuration:0` rather than `UIView.performWithAnimation` to work around a
+            // UIKit Crash like:
+            //
+            //     *** Assertion failure in -[ConversationViewLayout prepareForCollectionViewUpdates:],
+            //     /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3600.7.47/UICollectionViewLayout.m:760
+            //     *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'While
+            //     preparing update a visible view at <NSIndexPath: 0xc000000011c00016> {length = 2, path = 0 - 142}
+            //     wasn't found in the current data model and was not in an update animation. This is an internal
+            //     error.'
+            //
+            // I'm unclear if this is a bug in UIKit, or if we're doing something crazy in
+            // ConversationViewLayout#prepareLayout. To reproduce, rapidily insert and delete items into the
+            // conversation. See `DebugUIMessages#thrashCellsInThread:`
+            [UIView animateWithDuration:0.0 animations:updateBlock];
+        }
+    } @catch (NSException *exception) {
+        OWSCFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
+            exception.description,
+            exception.name,
+            exception.reason,
+            exception.userInfo);
+
+        failure();
+
+        @throw exception;
     }
-
-    return YES;
 }
 
 @end
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
index daddcc351f5..64b8cc1d094 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+CVC.swift
@@ -100,8 +100,18 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
         collectionView.layoutIfNeeded()
         // ENDHACK to work around radar #28167779
 
+        // Snapshot CVC layout state before we land the load;
+        // we use this to ensure scroll continuity when landing the load.
+        let scrollContinuityToken = layout.buildScrollContinuityToken()
+
+        // CVC will often use this state to ensure scroll continuity
+        // when landing loads, so ensure the value is updated before
+        // landing loads.
+        self.updateLastKnownDistanceFromBottom()
+
         return CVUpdateToken(isScrolledToBottom: self.isScrolledToBottom,
-                             lastMessageForInboxSortId: threadViewModel.lastMessageForInbox?.sortId)
+                             lastMessageForInboxSortId: threadViewModel.lastMessageForInbox?.sortId,
+                             scrollContinuityToken: scrollContinuityToken)
     }
 
     func updateWithNewRenderState(update: CVUpdate,
@@ -340,12 +350,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
     private func reloadCollectionViewImmediately() {
         AssertIsOnMainThread()
 
-        layout.willReloadData()
-        UIView.performWithoutAnimation {
-            self.collectionView.reloadData()
-            self.layout.invalidateLayout()
-        }
-        layout.didReloadData()
+        self.collectionView.cvc_reloadData(animated: false, cvc: self)
     }
 
     private func updateForMinorUpdate(scrollAction: CVScrollAction) {
@@ -458,6 +463,7 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
                                 scrollAction scrollActionParam: CVScrollAction,
                                 threadInteractionCount: UInt,
                                 updateToken: CVUpdateToken) {
+        AssertIsOnMainThread()
         owsAssertDebug(!items.isEmpty)
 
         Logger.verbose("")
@@ -622,11 +628,18 @@ extension ConversationViewController: CVLoadCoordinatorDelegate {
             }
         }
 
-        self.performBatchUpdates(batchUpdatesBlock,
-                                 completion: completion,
-                                 logFailureBlock: logFailureBlock,
-                                 shouldAnimateUpdates: shouldAnimateUpdate,
-                                 isLoadAdjacent: isLoadAdjacent)
+        var scrollContinuityToken: CVScrollContinuityToken?
+        if isLoadAdjacent, hasScrollingAnimation {
+            scrollContinuityToken = updateToken.scrollContinuityToken
+        }
+
+        // We use an obj-c free function so that we can handle NSException.
+        self.collectionView.cvc_performBatchUpdates(batchUpdatesBlock,
+                                                    completion: completion,
+                                                    failure: logFailureBlock,
+                                                    animated: shouldAnimateUpdate,
+                                                    scrollContinuityToken: scrollContinuityToken,
+                                                    cvc: self)
     }
 
     private var scrolledToEdgeTolerancePoints: CGFloat {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index bd3fdf08520..b7ed054ecb2 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -516,10 +516,19 @@ extension ConversationViewController {
     @objc
     public func targetContentOffset(forProposedContentOffset proposedContentOffset: CGPoint) -> CGPoint {
 
+        // TODO: Remove logging in this method once scroll continuity
+        // issues are resolved.
         if !DebugFlags.reduceLogChatter {
             Logger.verbose("---- proposedContentOffset: \(proposedContentOffset)")
         }
 
+        guard !layout.isHandlingScrollContinuity else {
+            if !DebugFlags.reduceLogChatter {
+                Logger.verbose("---- layout.isHandlingScrollContinuity")
+            }
+            return proposedContentOffset
+        }
+
         if isPresentingMessageActions,
            let contentOffset = targetContentOffsetForMessageActionInteraction {
             if !DebugFlags.reduceLogChatter {
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+UI.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+UI.swift
index 5c00ac0c27d..d42f59c8136 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+UI.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+UI.swift
@@ -5,7 +5,6 @@
 import Foundation
 
 extension ConversationViewController {
-
     @objc
     public func updateNavigationTitle() {
         AssertIsOnMainThread()
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.h b/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
index 60547830dd3..d46c6120c35 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
@@ -4,8 +4,6 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-@class ConversationViewController;
-
 typedef NS_CLOSED_ENUM(NSUInteger, ConversationViewAction) {
     ConversationViewActionNone,
     ConversationViewActionCompose,
@@ -16,17 +14,4 @@ typedef NS_CLOSED_ENUM(NSUInteger, ConversationViewAction) {
     ConversationViewActionUpdateDraft
 };
 
-void CVCReloadCollectionViewForReset(ConversationViewController *cvc);
-
-typedef void (^CVCPerformBatchUpdatesBlock)(void);
-typedef void (^CVCPerformBatchUpdatesCompletion)(BOOL);
-typedef void (^CVCPerformBatchUpdatesFailure)(void);
-
-void CVCPerformBatchUpdates(ConversationViewController *cvc,
-                            CVCPerformBatchUpdatesBlock batchUpdates,
-                            CVCPerformBatchUpdatesCompletion completion,
-                            CVCPerformBatchUpdatesFailure logFailureBlock,
-                            BOOL shouldAnimateUpdates,
-                            BOOL isLoadAdjacent);
-
 NS_ASSUME_NONNULL_END
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
deleted file mode 100644
index 628ab6399e9..00000000000
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ /dev/null
@@ -1,82 +0,0 @@
-//
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
-//
-
-#import "ConversationViewController.h"
-#import "Signal-Swift.h"
-
-NS_ASSUME_NONNULL_BEGIN
-
-void CVCReloadCollectionViewForReset(ConversationViewController *cvc)
-{
-    @try {
-        [cvc.layout willReloadData];
-        [cvc.collectionView reloadData];
-        [cvc.layout invalidateLayout];
-        [cvc.layout didReloadData];
-    } @catch (NSException *exception) {
-        OWSLogWarn(@"currentRenderStateDebugDescription: %@", cvc.currentRenderStateDebugDescription);
-        OWSCFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
-                      exception.description,
-                      exception.name,
-                      exception.reason,
-                      exception.userInfo);
-        @throw exception;
-    }
-}
-
-void CVCPerformBatchUpdates(ConversationViewController *cvc,
-                            CVCPerformBatchUpdatesBlock batchUpdates,
-                            CVCPerformBatchUpdatesCompletion completion,
-                            CVCPerformBatchUpdatesFailure logFailureBlock,
-                            BOOL shouldAnimateUpdates,
-                            BOOL isLoadAdjacent)
-{
-    @try {
-        void (^updateBlock)(void) = ^{
-            ConversationViewLayout *layout = cvc.layout;
-            [layout willPerformBatchUpdatesWithAnimated:shouldAnimateUpdates
-                                         isLoadAdjacent:isLoadAdjacent];
-            [cvc.collectionView performBatchUpdates:batchUpdates
-                                         completion:^(BOOL finished) {
-                [layout didCompleteBatchUpdates];
-                
-                completion(finished);
-            }];
-            [layout didPerformBatchUpdatesWithAnimated:shouldAnimateUpdates];
-            
-            [BenchManager completeEventWithEventId:@"message-send"];
-        };
-        
-        if (shouldAnimateUpdates) {
-            updateBlock();
-        } else {
-            // HACK: We use `UIView.animateWithDuration:0` rather than `UIView.performWithAnimation` to work around a
-            // UIKit Crash like:
-            //
-            //     *** Assertion failure in -[ConversationViewLayout prepareForCollectionViewUpdates:],
-            //     /BuildRoot/Library/Caches/com.apple.xbs/Sources/UIKit_Sim/UIKit-3600.7.47/UICollectionViewLayout.m:760
-            //     *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'While
-            //     preparing update a visible view at <NSIndexPath: 0xc000000011c00016> {length = 2, path = 0 - 142}
-            //     wasn't found in the current data model and was not in an update animation. This is an internal
-            //     error.'
-            //
-            // I'm unclear if this is a bug in UIKit, or if we're doing something crazy in
-            // ConversationViewLayout#prepareLayout. To reproduce, rapidily insert and delete items into the
-            // conversation. See `DebugUIMessages#thrashCellsInThread:`
-            [UIView animateWithDuration:0.0 animations:updateBlock];
-        }
-    } @catch (NSException *exception) {
-        OWSCFailDebug(@"exception: %@ of type: %@ with reason: %@, user info: %@.",
-                     exception.description,
-                     exception.name,
-                     exception.reason,
-                     exception.userInfo);
-        
-        logFailureBlock();
-        
-        @throw exception;
-    }
-}
-
-NS_ASSUME_NONNULL_END
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift
index 5976af1d9f6..cad6f3c0895 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.swift
@@ -497,7 +497,7 @@ public class ConversationViewController: OWSViewController {
             return
         }
         // We use an obj-c free function so that we can handle NSException.
-        CVCReloadCollectionViewForReset(self)
+        self.collectionView.cvc_reloadData(animated: false, cvc: self)
     }
 
     var isViewVisible: Bool {
@@ -524,24 +524,6 @@ public class ConversationViewController: OWSViewController {
         self.updateScrollingContent()
     }
 
-    // MARK: - CollectionView updates
-
-    func performBatchUpdates(_ batchUpdates: @escaping () -> Void,
-                             completion: @escaping (Bool) -> Void,
-                             logFailureBlock: @escaping () -> Void,
-                             shouldAnimateUpdates: Bool,
-                             isLoadAdjacent: Bool) {
-        AssertIsOnMainThread()
-
-        // We use an obj-c free function so that we can handle NSException.
-        CVCPerformBatchUpdates(self,
-                               batchUpdates,
-                               completion,
-                               logFailureBlock,
-                               shouldAnimateUpdates,
-                               isLoadAdjacent)
-    }
-
     // MARK: - Orientation
 
     public override func viewWillTransition(to size: CGSize,
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
index 72702fefe55..174abdc200b 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewLayout.swift
@@ -76,9 +76,6 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
         func layoutAttributesForItem(at indexPath: IndexPath, assertIfMissing: Bool) -> UICollectionViewLayoutAttributes? {
             if assertIfMissing {
-                if !(indexPath.row >= 0 && indexPath.row < itemAttributesMap.count) {
-                    Logger.verbose("indexPath: \(indexPath.row) / \(itemAttributesMap.count)")
-                }
                 owsAssertDebug(indexPath.row >= 0 && indexPath.row < itemAttributesMap.count)
             }
             return itemAttributesMap[indexPath.row]
@@ -122,7 +119,21 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     private var hasEverHadLayout = false
 
-    private var currentLayoutInfo: LayoutInfo?
+    private var currentLayoutInfo: LayoutInfo? {
+        didSet {
+            if oldValue != nil, currentLayoutInfo == nil {
+                Logger.verbose("---- Clearing")
+            } else if oldValue == nil, currentLayoutInfo != nil {
+                Logger.verbose("---- Setting")
+            } else if oldValue != nil, currentLayoutInfo != nil {
+                Logger.verbose("---- Changing")
+            }
+        }
+    }
+    @objc
+    public var hasLayoutInfo: Bool { nil != currentLayoutInfo }
+    @objc
+    public var debugContentSize: CGSize { currentLayoutInfo?.contentSize ?? .zero }
 
     private func ensureCurrentLayoutInfo() -> LayoutInfo {
         AssertIsOnMainThread()
@@ -135,6 +146,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
         let layoutInfo = Self.buildLayoutInfo(state: currentState)
         currentLayoutInfo = layoutInfo
+
         hasEverHadLayout = true
         return layoutInfo
     }
@@ -167,16 +179,99 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     @objc
     public override func invalidateLayout() {
+        AssertIsOnMainThread()
+
         super.invalidateLayout()
 
+        // This method will call invalidateLayout(with:).
+        // We don't want to assume that, so we call ensureState() to be safe.
         ensureState()
     }
 
     @objc
     public override func invalidateLayout(with context: UICollectionViewLayoutInvalidationContext) {
-        super.invalidateLayout(with: context)
+        AssertIsOnMainThread()
 
         ensureState()
+
+        if let delegate = self.delegate,
+           let scrollContinuityToken = self.scrollContinuityMode.activeScrollContinuityToken {
+
+            // Clear the token to ensure that we only adjust the contentOffset once.
+            self.scrollContinuityMode = .none
+
+            let layoutInfoBeforeUpdate = scrollContinuityToken.layoutInfo
+            let layoutInfoAfterUpdate = ensureCurrentLayoutInfo()
+
+            Logger.verbose("---- status: " +
+                            "layoutInfoBeforeUpdate.contentSize: \(layoutInfoBeforeUpdate.contentSize), " +
+                            "layoutInfoAfterUpdate.contentSize: \(layoutInfoAfterUpdate.contentSize), " +
+                            "isPerformingBatchUpdates: \(isPerformingBatchUpdates), " +
+                            ""
+            )
+
+            if let contentOffsetAdjustment = Self.invalidationContentOffsetAdjustment(delegate: delegate,
+                                                                                      layoutInfoBeforeUpdate: layoutInfoBeforeUpdate,
+                                                                                      layoutInfoAfterUpdate: layoutInfoAfterUpdate),
+               contentOffsetAdjustment != .zero {
+                context.contentOffsetAdjustment = contentOffsetAdjustment
+            }
+
+            //            if let pendingContentOffsetAdjustment = self.pendingContentOffsetAdjustment {
+            //                context.contentOffsetAdjustment = pendingContentOffsetAdjustment
+            //                self.pendingContentOffsetAdjustment = nil
+            //            }
+        }
+
+        Logger.verbose("---- context with end 1: \(self.collectionView?.contentOffset ?? .zero)")
+
+        super.invalidateLayout(with: context)
+
+        Logger.verbose("---- context with end 2: \(self.collectionView?.contentOffset ?? .zero)")
+
+        if context.contentOffsetAdjustment != .zero,
+           let collectionView = self.collectionView as? ConversationCollectionView {
+            Logger.verbose("---- setting shouldBreakOnContentOffsetChanges")
+            collectionView.shouldBreakOnContentOffsetChanges = true
+        }
+    }
+
+    // We use this hook to ensure scroll state continuity.  As the collection
+    // view's content size changes, we want to keep the same cells in view.
+    private static func invalidationContentOffsetAdjustment(delegate: ConversationViewLayoutDelegate,
+                                                            layoutInfoBeforeUpdate: LayoutInfo,
+                                                            layoutInfoAfterUpdate: LayoutInfo) -> CGPoint? {
+        Logger.verbose("---- layoutInfoBeforeUpdate.contentSize: \(layoutInfoBeforeUpdate.contentSize)")
+        Logger.verbose("---- layoutInfoAfterUpdate.contentSize: \(layoutInfoAfterUpdate.contentSize)")
+
+        var beforeItemLayoutMap = [String: ItemLayout]()
+        for itemLayout in layoutInfoBeforeUpdate.itemLayouts {
+            beforeItemLayoutMap[itemLayout.interactionUniqueId] = itemLayout
+        }
+
+        // Honor the scroll continuity bias.
+        //
+        // If we prefer continuity with regard to the bottom
+        // of the conversation, start with the last items.
+        let afterItemLayouts = (delegate.scrollContinuity == .bottom
+                                    ? layoutInfoAfterUpdate.itemLayouts.reversed()
+                                    : layoutInfoAfterUpdate.itemLayouts)
+
+        for afterItemLayout in afterItemLayouts {
+            guard let beforeItemLayout = beforeItemLayoutMap[afterItemLayout.interactionUniqueId] else {
+                continue
+            }
+            let frameBeforeUpdate = beforeItemLayout.layoutAttributes.frame
+            let frameAfterUpdate = afterItemLayout.layoutAttributes.frame
+            let offset = frameAfterUpdate.origin - frameBeforeUpdate.origin
+            let contentOffsetAdjustment = CGPoint(x: 0, y: offset.y)
+            Logger.verbose("---- contentOffsetAdjustment: \(contentOffsetAdjustment)")
+            return contentOffsetAdjustment
+        }
+
+        Logger.verbose("No continuity match.")
+
+        return nil
     }
 
     private func ensureState() {
@@ -251,6 +346,9 @@ public class ConversationViewLayout: UICollectionViewLayout {
             owsFailDebug("Missing state")
             return buildEmptyLayoutInfo()
         }
+
+        Logger.verbose("---- Building")
+
         let conversationStyle = state.conversationStyle
         let layoutItems = state.layoutItems
         let layoutHeaderHeight = state.layoutHeaderHeight
@@ -398,56 +496,103 @@ public class ConversationViewLayout: UICollectionViewLayout {
 
     // MARK: - performBatchUpdates()
 
-    private struct UpdateScrollContinuity {
-        let layoutInfo: LayoutInfo
-        let contentOffset: CGPoint
-
-        private static let idCounter = AtomicUInt(0)
-        public let id: UInt = UpdateScrollContinuity.idCounter.increment()
+    @objc
+    public var isUpdating: Bool {
+        isPerformingBatchUpdates || isReloadingData
     }
-    private var updateScrollContinuity: UpdateScrollContinuity?
 
-    private var isAnimatingBoundsChange = false {
-        didSet {
-            if !isAnimatingBoundsChange {
-                updateScrollContinuity = nil
+    // Flag set before performBatchUpdates() and cleared in its completion.
+    @objc
+    public var isApplyingUpdate = false
+
+    // Flag set before performBatchUpdates() and cleared after it returns.
+    @objc
+    public private(set) var isPerformingBatchUpdates = false
+
+    private enum ScrollContinuityMode: Equatable, CustomStringConvertible {
+        case none
+        case pending(scrollContinuityToken: CVScrollContinuityToken)
+        case active(scrollContinuityToken: CVScrollContinuityToken)
+
+        var activeScrollContinuityToken: CVScrollContinuityToken? {
+            switch self {
+            case .none, .pending:
+                return nil
+            case .active(let scrollContinuityToken):
+                return scrollContinuityToken
             }
         }
-    }
 
-    @objc
-    public var isUpdating: Bool {
-        isPerformingBatchUpdates || isReloadingData
+        // MARK: - CustomStringConvertible
+
+        public var description: String {
+            switch self {
+            case .none:
+                return "none"
+            case .pending:
+                return "pending"
+            case .active:
+                return "active"
+            }
+        }
     }
+    private var scrollContinuityMode: ScrollContinuityMode = .none
 
     @objc
-    public var isApplyingUpdate: Bool {
-        updateScrollContinuity != nil
+    public var isHandlingScrollContinuity: Bool {
+        self.scrollContinuityMode != .none
     }
 
-    private var isPerformingBatchUpdates = false
-
     @objc
-    public func willPerformBatchUpdates(animated: Bool, isLoadAdjacent: Bool) {
+    public func willPerformBatchUpdates(scrollContinuityToken: CVScrollContinuityToken?) {
         AssertIsOnMainThread()
+        owsAssertDebug(self.scrollContinuityMode == .none)
+
+        Logger.verbose("---- 1")
+
         owsAssertDebug(currentLayoutInfo != nil)
 
         isPerformingBatchUpdates = true
-        if isLoadAdjacent {
-            captureUpdateScrollContinuity()
+        Logger.verbose("---- 2")
+
+        if let scrollContinuityToken = scrollContinuityToken {
+//        if isLoadAdjacent {
+            Logger.verbose("---- Setting scrollContinuityToken")
+            self.scrollContinuityMode = .pending(scrollContinuityToken: scrollContinuityToken)
+        } else {
+            self.scrollContinuityMode = .none
         }
+
+//        if isLoadAdjacent {
+//            Logger.verbose("---- Setting scrollContinuityToken")
+//            self.possibleScrollContinuityToken = scrollContinuityToken
+//        }
     }
 
     @objc
-    public func didPerformBatchUpdates(animated: Bool) {
+    public func didPerformBatchUpdates(scrollContinuityToken: CVScrollContinuityToken?) {
         AssertIsOnMainThread()
+//        owsAssertDebug(self.pendingScrollContinuityToken == nil)
+
+        Logger.verbose("----")
 
         isPerformingBatchUpdates = false
+
+//        if isLoadAdjacent {
+//            self.pendingScrollContinuityToken = scrollContinuityToken
+//        }
     }
 
     @objc
     public func didCompleteBatchUpdates() {
         AssertIsOnMainThread()
+
+        Logger.verbose("----")
+
+        invalidateLayout()
+
+        owsAssertDebug(self.scrollContinuityMode == .none)
+        self.scrollContinuityMode = .none
     }
 
     private var isReloadingData = false
@@ -466,26 +611,11 @@ public class ConversationViewLayout: UICollectionViewLayout {
         isReloadingData = false
     }
 
-    private func captureUpdateScrollContinuity() {
+    public func buildScrollContinuityToken() -> CVScrollContinuityToken {
         AssertIsOnMainThread()
 
-        if let collectionView = collectionView {
-            let updateScrollContinuity = UpdateScrollContinuity(layoutInfo: ensureCurrentLayoutInfo(),
-                                                                contentOffset: collectionView.contentOffset)
-            self.updateScrollContinuity = updateScrollContinuity
-
-            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { [weak self] in
-                guard let self = self else { return }
-                if let currentContinuity = self.updateScrollContinuity,
-                   currentContinuity.id == updateScrollContinuity.id {
-                    Logger.warn("UpdateScrollContinuity did not get cleaned up in a timely way.")
-                    self.updateScrollContinuity = nil
-                }
-            }
-        } else {
-            owsFailDebug("Missing collectionView.")
-            updateScrollContinuity = nil
-        }
+        let layoutInfo = ensureCurrentLayoutInfo()
+        return CVScrollContinuityToken(layoutInfo: layoutInfo)
     }
 
     // This method is called when there is an update with deletes/inserts to the collection view.
@@ -496,27 +626,41 @@ public class ConversationViewLayout: UICollectionViewLayout {
     // The updateItems parameter is an array of UICollectionViewUpdateItem instances for each
     // element that is moving to a new index path.
     public override func prepare(forCollectionViewUpdates updateItems: [UICollectionViewUpdateItem]) {
+        Logger.verbose("----")
+
         super.prepare(forCollectionViewUpdates: updateItems)
     }
 
     // Called inside an animation block after the update.
     public override func finalizeCollectionViewUpdates() {
+        Logger.verbose("----")
+
         super.finalizeCollectionViewUpdates()
+
+        switch scrollContinuityMode {
+        case .none:
+            break
+        case .pending(let scrollContinuityToken):
+            // Activate
+            self.scrollContinuityMode = .active(scrollContinuityToken: scrollContinuityToken)
+        case .active:
+            owsFailDebug("Unexpected scrollContinuityMode.")
+        }
     }
 
     // UICollectionView calls this when its bounds have changed inside an
     // animation block before displaying cells in its new bounds.
     public override func prepare(forAnimatedBoundsChange oldBounds: CGRect) {
-        super.prepare(forAnimatedBoundsChange: oldBounds)
+        Logger.verbose("----")
 
-        isAnimatingBoundsChange = true
+        super.prepare(forAnimatedBoundsChange: oldBounds)
     }
 
     // also called inside the animation block
     public override func finalizeAnimatedBoundsChange() {
-        super.finalizeAnimatedBoundsChange()
+        Logger.verbose("----")
 
-        isAnimatingBoundsChange = false
+        super.finalizeAnimatedBoundsChange()
     }
 
     private var debugInfo: String {
@@ -524,7 +668,7 @@ public class ConversationViewLayout: UICollectionViewLayout {
             owsFailDebug("Missing delegate.")
             return "Missing delegate"
         }
-        return "isUserScrolling: \(delegate.isUserScrolling), hasScrollingAnimation: \(delegate.hasScrollingAnimation), scrollContinuity: \(delegate.scrollContinuity), isPerformingBatchUpdates: \(isPerformingBatchUpdates), isReloadingData: \(isReloadingData), updateScrollContinuity: \(updateScrollContinuity != nil)"
+        return "isUserScrolling: \(delegate.isUserScrolling), hasScrollingAnimation: \(delegate.hasScrollingAnimation), scrollContinuity: \(delegate.scrollContinuity), isPerformingBatchUpdates: \(isPerformingBatchUpdates), isReloadingData: \(isReloadingData), scrollContinuityMode: \(scrollContinuityMode)"
     }
 
     // MARK: -
@@ -547,6 +691,13 @@ public class ConversationViewLayout: UICollectionViewLayout {
     private func targetContentOffset(proposedContentOffset: CGPoint,
                                      withScrollingVelocity velocity: CGPoint?) -> CGPoint {
 
+//        if isPerformingBatchUpdates, isLoadAdjacent {
+////            if !DebugFlags.reduceLogChatter {
+//                Logger.verbose("---- 0 isPerformingBatchUpdates, isLoadAdjacent")
+////            }
+//            return proposedContentOffset
+//        }
+
         guard let delegate = delegate else {
             owsFailDebug("Missing delegate.")
             if let velocity = velocity {
@@ -558,68 +709,34 @@ public class ConversationViewLayout: UICollectionViewLayout {
         }
 
         guard velocity == nil else {
+            Logger.verbose("---- 1 no velocity, returning proposedContentOffset, proposedContentOffset: \(proposedContentOffset), \(debugInfo)")
             return proposedContentOffset
         }
 
-        if let updateScrollContinuity = updateScrollContinuity {
-            let layoutInfoCurrent = ensureCurrentLayoutInfo()
-            if let targetContentOffset = Self.targetContentOffsetForUpdate(delegate: delegate,
-                                                                           updateScrollContinuity: updateScrollContinuity,
-                                                                           layoutInfoCurrent: layoutInfoCurrent) {
-                return targetContentOffset
-            } else {
-                Logger.warn("Could not ensure scroll continuity.")
-            }
-        }
-
         if isUpdating {
             let targetContentOffset = delegate.targetContentOffset(forProposedContentOffset: proposedContentOffset)
+            Logger.verbose("---- 3 isUpdating returning targetContentOffset, proposedContentOffset: \(proposedContentOffset), targetContentOffset: \(targetContentOffset), \(debugInfo)")
             return targetContentOffset
         } else {
+            Logger.verbose("---- 4 returning proposedContentOffset, proposedContentOffset: \(proposedContentOffset), \(debugInfo)")
             return proposedContentOffset
         }
     }
 
-    // We use this hook to ensure scroll state continuity.  As the collection
-    // view's content size changes, we want to keep the same cells in view.
-    private static func targetContentOffsetForUpdate(delegate: ConversationViewLayoutDelegate,
-                                                     updateScrollContinuity: UpdateScrollContinuity,
-                                                     layoutInfoCurrent layoutInfoAfterUpdate: LayoutInfo) -> CGPoint? {
-        let layoutInfoBeforeUpdate = updateScrollContinuity.layoutInfo
-        let contentOffsetBeforeUpdate = updateScrollContinuity.contentOffset
-
-        var beforeItemLayoutMap = [String: ItemLayout]()
-        for itemLayout in layoutInfoBeforeUpdate.itemLayouts {
-            beforeItemLayoutMap[itemLayout.interactionUniqueId] = itemLayout
-        }
-
-        // Honor the scroll continuity bias.
-        //
-        // If we prefer continuity with regard to the bottom
-        // of the conversation, start with the last items.
-        let afterItemLayouts = (delegate.scrollContinuity == .bottom
-                                    ? layoutInfoAfterUpdate.itemLayouts.reversed()
-                                    : layoutInfoAfterUpdate.itemLayouts)
-
-        for afterItemLayout in afterItemLayouts {
-            guard let beforeItemLayout = beforeItemLayoutMap[afterItemLayout.interactionUniqueId] else {
-                continue
-            }
-            let frameBeforeUpdate = beforeItemLayout.layoutAttributes.frame
-            let frameAfterUpdate = afterItemLayout.layoutAttributes.frame
-            let offset = frameAfterUpdate.origin - frameBeforeUpdate.origin
-            let updatedContentOffset = CGPoint(x: 0,
-                                               y: (contentOffsetBeforeUpdate + offset).y)
-            return updatedContentOffset
-        }
-
-        Logger.verbose("No continuity match.")
-
-        return nil
-    }
-
     @objc
     public override var debugDescription: String {
         ensureCurrentLayoutInfo().debugDescription
     }
 }
+
+// MARK: -
+
+// TODO: This might not have to be @objc after the CVC port.
+@objc
+public class CVScrollContinuityToken: NSObject {
+    fileprivate let layoutInfo: ConversationViewLayout.LayoutInfo
+
+    fileprivate init(layoutInfo: ConversationViewLayout.LayoutInfo) {
+        self.layoutInfo = layoutInfo
+    }
+}
