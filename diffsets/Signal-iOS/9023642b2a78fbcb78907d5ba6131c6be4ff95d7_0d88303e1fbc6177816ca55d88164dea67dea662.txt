diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index 3a893ffde38..b1924ee4659 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -492,10 +492,12 @@ extension ConversationViewController {
         let contentHeight = self.safeContentHeight
 
         let adjustedContentInset = collectionView.adjustedContentInset
+        let minContentOffsetY = -adjustedContentInset.top
+        let rawValue = contentHeight + adjustedContentInset.bottom - collectionView.bounds.size.height
         // Note the usage of MAX() to handle the case where there isn't enough
         // content to fill the collection view at its current size.
-        let maxContentOffsetY = contentHeight + adjustedContentInset.bottom - collectionView.bounds.size.height
-        return maxContentOffsetY
+        let clampedValue = max(minContentOffsetY, rawValue)
+        return clampedValue
     }
 
     // We use this hook to ensure scroll state continuity.  As the collection
diff --git a/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift b/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift
index 62934283a5d..03ac0f9962e 100644
--- a/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift
+++ b/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift
@@ -79,7 +79,8 @@ public class InputAccessoryViewPlaceholder: UIView {
             guard newValue != desiredHeight else { return }
             heightConstraint.constant = newValue
             heightConstraintView.layoutIfNeeded()
-            layoutIfNeeded()
+            self.layoutIfNeeded()
+            superview?.layoutIfNeeded()
         }
         get {
             return heightConstraint.constant
