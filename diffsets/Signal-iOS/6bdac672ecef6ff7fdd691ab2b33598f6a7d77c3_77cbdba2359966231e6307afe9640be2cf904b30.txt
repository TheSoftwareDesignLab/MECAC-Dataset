diff --git a/Signal/src/ViewControllers/HomeView/Chat List/CLVLoader.swift b/Signal/src/ViewControllers/HomeView/Chat List/CLVLoader.swift
index a3245b14fd2..253a834da37 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/CLVLoader.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/CLVLoader.swift	
@@ -138,6 +138,9 @@ public class CLVLoader: Dependencies {
         // NOTE: There's an upper bound on how long SQL queries should be.
         //       We use kMaxIncrementalRowChanges to limit query size.
         guard threadsToLoad.count <= DatabaseChangeObserver.kMaxIncrementalRowChanges else {
+            if DebugFlags.internalLogging {
+                Logger.info("[Scroll Perf Debug] Loading without cache because too many incremental row changes.")
+            }
             try loadWithoutCache()
             return buildRenderState()
         }
@@ -206,13 +209,19 @@ public class CLVLoader: Dependencies {
                 // Missing thread, it was deleted and should no longer be visible.
                 continue
             }
+            if DebugFlags.internalLogging {
+                Logger.info("[Scroll Perf Debug] Thread triggering update: \(thread.uniqueId), isGV1: \(thread.isGroupV1Thread), isGV2: \(thread.isGroupV2Thread)")
+            }
             if thread.shouldThreadBeVisible {
                 updatedItemIds.insert(threadId)
             }
         }
 
         let newRenderState = try Bench(title: "loadRenderState for diff (\(viewInfo.chatListMode))") {
-            try Self.loadRenderStateInternal(viewInfo: viewInfo, transaction: transaction)
+            if DebugFlags.internalLogging {
+                Logger.info("[Scroll Perf Debug] About to do loadRenderStateInternal")
+            }
+            return try Self.loadRenderStateInternal(viewInfo: viewInfo, transaction: transaction)
         }
 
         let oldPinnedThreadIds: [String] = lastRenderState.pinnedThreads.orderedKeys
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Loading.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Loading.swift
index f3a59680f38..1f3e83f024b 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Loading.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Loading.swift	
@@ -265,6 +265,9 @@ public class CLVLoadCoordinator: Dependencies {
         AssertIsOnMainThread()
         owsAssertDebug(!updatedThreadIds.isEmpty)
 
+        if DebugFlags.internalLogging {
+            Logger.info("[Scroll Perf Debug] 'Other' updateThreadIds to make union with (count \(loadInfoBuilder.updatedThreadIds.count)): \(loadInfoBuilder.updatedThreadIds)")
+        }
         loadInfoBuilder.updatedThreadIds.formUnion(updatedThreadIds)
 
         loadIfNecessary()
@@ -340,10 +343,16 @@ public class CLVLoadCoordinator: Dependencies {
             // NOTE: we might not receive the kind of load that we requested.
             switch loadInfo.loadType {
             case .resetAll:
+                if DebugFlags.internalLogging {
+                    Logger.info("[Scroll Perf Debug] About to do resetAll load")
+                }
                 return viewController.loadRenderStateForReset(viewInfo: loadInfo.viewInfo,
                                                               transaction: transaction)
             case .incrementalDiff(let updatedThreadIds):
                 owsAssertDebug(!updatedThreadIds.isEmpty)
+                if DebugFlags.internalLogging {
+                    Logger.info("[Scroll Perf Debug] About to do incrementalDiff load")
+                }
                 return viewController.loadNewRenderStateWithDiff(viewInfo: loadInfo.viewInfo,
                                                                  updatedThreadIds: updatedThreadIds,
                                                                  transaction: transaction)
diff --git a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift
index 47d56ba9171..92135f75c01 100644
--- a/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift	
+++ b/Signal/src/ViewControllers/HomeView/Chat List/ChatListViewController+Notifications.swift	
@@ -192,6 +192,7 @@ extension ChatListViewController {
         }
 
         if let threadId = changedThreadId {
+            Logger.info("[Scroll Perf Debug] Scheduling load for threadId \(threadId) because whitelist did change.")
             self.loadCoordinator.scheduleLoad(updatedThreadIds: Set([threadId]))
         }
     }
@@ -211,6 +212,9 @@ extension ChatListViewController {
         }
 
         if let changedThreadId = changedThreadId {
+            if DebugFlags.internalLogging {
+                Logger.info("[Scroll Perf Debug] Scheduling load for threadId \(changedThreadId) because other profile did change.")
+            }
             self.loadCoordinator.scheduleLoad(updatedThreadIds: Set([changedThreadId]))
         }
     }
@@ -248,10 +252,16 @@ extension ChatListViewController: DatabaseChangeDelegate {
         BenchManager.startEvent(title: "uiDatabaseUpdate", eventId: "uiDatabaseUpdate")
 
         if databaseChanges.didUpdateModel(collection: TSPaymentModel.collection()) {
+            if DebugFlags.internalLogging {
+                Logger.info("[Scroll Perf Debug] TSPaymentModel did update")
+            }
             updateUnreadPaymentNotificationsCountWithSneakyTransaction()
         }
 
         if !databaseChanges.threadUniqueIdsForChatListUpdate.isEmpty {
+            if DebugFlags.internalLogging {
+                Logger.info("[Scroll Perf Debug] Scheduling load for threadIds (count \(databaseChanges.threadUniqueIdsForChatListUpdate.count): \(databaseChanges.threadUniqueIdsForChatListUpdate)")
+            }
             self.loadCoordinator.scheduleLoad(updatedThreadIds: databaseChanges.threadUniqueIdsForChatListUpdate)
         }
     }
diff --git a/SignalMessaging/groups/GroupV2UpdatesImpl.swift b/SignalMessaging/groups/GroupV2UpdatesImpl.swift
index d040baac612..e5e953da256 100644
--- a/SignalMessaging/groups/GroupV2UpdatesImpl.swift
+++ b/SignalMessaging/groups/GroupV2UpdatesImpl.swift
@@ -276,6 +276,7 @@ extension GroupV2UpdatesImpl: GroupV2UpdatesSwift {
         groupModelOptions: TSGroupModelOptions
     ) -> Promise<TSGroupThread> {
 
+        if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] tryToRefreshV2GroupThread") }
         let isThrottled = { () -> Bool in
             guard groupUpdateMode.shouldThrottle else {
                 return false
diff --git a/SignalMessaging/groups/GroupsV2Impl.swift b/SignalMessaging/groups/GroupsV2Impl.swift
index 34b6e9d8923..ce2ececa9a8 100644
--- a/SignalMessaging/groups/GroupsV2Impl.swift
+++ b/SignalMessaging/groups/GroupsV2Impl.swift
@@ -643,6 +643,7 @@ public class GroupsV2Impl: GroupsV2Swift, GroupsV2, Dependencies {
     private func fetchCurrentGroupV2Snapshot(groupSecretParamsData: Data,
                                              justUploadedAvatars: GroupV2DownloadedAvatars?) -> Promise<GroupV2Snapshot> {
         return firstly(on: DispatchQueue.global()) { () -> GroupV2Params in
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] making GV2Params") }
             return try GroupV2Params(groupSecretParamsData: groupSecretParamsData)
         }.then(on: DispatchQueue.global()) { (groupV2Params: GroupV2Params) -> Promise<GroupV2Snapshot> in
             return self.fetchCurrentGroupV2Snapshot(groupV2Params: groupV2Params, justUploadedAvatars: justUploadedAvatars)
@@ -654,7 +655,8 @@ public class GroupsV2Impl: GroupsV2Swift, GroupsV2, Dependencies {
         justUploadedAvatars: GroupV2DownloadedAvatars?
     ) -> Promise<GroupV2Snapshot> {
         let requestBuilder: RequestBuilder = { (authCredential) in
-            firstly(on: DispatchQueue.global()) { () -> GroupsV2Request in
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] buildFetchCurrentGroupV2SnapshotRequest") }
+            return firstly(on: DispatchQueue.global()) { () -> GroupsV2Request in
                 try StorageService.buildFetchCurrentGroupV2SnapshotRequest(groupV2Params: groupV2Params,
                                                                            authCredential: authCredential)
             }
@@ -662,6 +664,7 @@ public class GroupsV2Impl: GroupsV2Swift, GroupsV2, Dependencies {
 
         return firstly { () -> Promise<HTTPResponse> in
             let groupId = try self.groupId(forGroupSecretParamsData: groupV2Params.groupSecretParamsData)
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] performServiceRequest") }
             return self.performServiceRequest(requestBuilder: requestBuilder,
                                               groupId: groupId,
                                               behavior400: .fail,
@@ -671,11 +674,13 @@ public class GroupsV2Impl: GroupsV2Swift, GroupsV2, Dependencies {
             guard let groupProtoData = response.responseBodyData else {
                 throw OWSAssertionError("Invalid responseObject.")
             }
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] make GroupsProtoGroup") }
             return try GroupsProtoGroup(serializedData: groupProtoData)
         }.then(on: DispatchQueue.global()) { (groupProto: GroupsProtoGroup) -> Promise<(GroupsProtoGroup, GroupV2DownloadedAvatars)> in
             return firstly {
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] fetchAllAvatarData") }
                 // We can ignoreSignature; these protos came from the service.
-                self.fetchAllAvatarData(groupProto: groupProto,
+                return self.fetchAllAvatarData(groupProto: groupProto,
                                         justUploadedAvatars: justUploadedAvatars,
                                         ignoreSignature: true,
                                         groupV2Params: groupV2Params)
@@ -683,6 +688,7 @@ public class GroupsV2Impl: GroupsV2Swift, GroupsV2, Dependencies {
                 return (groupProto, downloadedAvatars)
             }
         }.map(on: DispatchQueue.global()) { (groupProto: GroupsProtoGroup, downloadedAvatars: GroupV2DownloadedAvatars) -> GroupV2Snapshot in
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] parse it all") }
             return try GroupsV2Protos.parse(groupProto: groupProto, downloadedAvatars: downloadedAvatars, groupV2Params: groupV2Params)
         }
     }
diff --git a/SignalMessaging/groups/GroupsV2OutgoingChangesImpl.swift b/SignalMessaging/groups/GroupsV2OutgoingChangesImpl.swift
index 7ad81f0af0c..891c0be099c 100644
--- a/SignalMessaging/groups/GroupsV2OutgoingChangesImpl.swift
+++ b/SignalMessaging/groups/GroupsV2OutgoingChangesImpl.swift
@@ -790,6 +790,7 @@ public class GroupsV2OutgoingChangesImpl: Dependencies, GroupsV2OutgoingChanges
         /// _only_ when the local profile key update is the _sole_ change
         /// action in this proto.
         if shouldUpdateLocalProfileKey {
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] shouldUpdateLocalProfileKey in buildGroupChangesProto") }
             if !didChange && FeatureFlags.doNotSendGroupChangeMessagesOnProfileKeyRotation {
                 /// When the profile key rotation is the sole change action
                 /// in this proto, we skip the optimization of sending messages
diff --git a/SignalMessaging/groups/GroupsV2ProfileKeyUpdater.swift b/SignalMessaging/groups/GroupsV2ProfileKeyUpdater.swift
index 3d2bfe54b11..8a9ae1dd210 100644
--- a/SignalMessaging/groups/GroupsV2ProfileKeyUpdater.swift
+++ b/SignalMessaging/groups/GroupsV2ProfileKeyUpdater.swift
@@ -224,9 +224,11 @@ class GroupsV2ProfileKeyUpdater: Dependencies {
         }
 
         return firstly {
-            self.messageProcessor.fetchingAndProcessingCompletePromise()
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] fetchingAndProcessingCompletePromise") }
+            return self.messageProcessor.fetchingAndProcessingCompletePromise()
         }.map(on: DispatchQueue.global()) { () throws -> TSGroupThread in
-            try self.databaseStorage.read { transaction throws in
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] getting group thread") }
+            return try self.databaseStorage.read { transaction throws in
                 guard let groupThread = TSGroupThread.fetch(groupId: groupId, transaction: transaction) else {
                     throw GroupsV2Error.shouldDiscard
                 }
@@ -234,18 +236,22 @@ class GroupsV2ProfileKeyUpdater: Dependencies {
             }
         }.then(on: DispatchQueue.global()) { (groupThread: TSGroupThread) throws -> Promise<(TSGroupThread, UInt32)> in
             // Get latest group state from service and verify that this update is still necessary.
-            firstly { () throws -> Promise<GroupV2Snapshot> in
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] about to return promise for getting snapshot") }
+            return firstly { () throws -> Promise<GroupV2Snapshot> in
                 guard let groupModel = groupThread.groupModel as? TSGroupModelV2 else {
                     throw OWSAssertionError("Invalid group model.")
                 }
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] fetch snapshot") }
                 return self.groupsV2Impl.fetchCurrentGroupV2Snapshot(groupModel: groupModel)
             }.map(on: DispatchQueue.global()) { (groupV2Snapshot: GroupV2Snapshot) throws -> (TSGroupThread, UInt32) in
                 guard groupV2Snapshot.groupMembership.isFullMember(localAci) else {
                     // We're not a full member, no need to update profile key.
+                    if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] redundant change A") }
                     throw GroupsV2Error.redundantChange
                 }
                 guard !groupV2Snapshot.profileKeys.values.contains(profileKeyData) else {
                     // Group state already has our current key.
+                    if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] redundant change B") }
                     throw GroupsV2Error.redundantChange
                 }
                 let checkedRevision = groupV2Snapshot.revision
@@ -264,7 +270,8 @@ class GroupsV2ProfileKeyUpdater: Dependencies {
             }
 
             return firstly {
-                GroupManager.ensureLocalProfileHasCommitmentIfNecessary()
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] ensure local profile has commitment if necessary") }
+                return GroupManager.ensureLocalProfileHasCommitmentIfNecessary()
             }.then(on: DispatchQueue.global()) { () throws -> Promise<Void> in
                 // Before we can update the group state on the service,
                 // we need to ensure that the group state in the local
@@ -282,18 +289,22 @@ class GroupsV2ProfileKeyUpdater: Dependencies {
                 // above.
                 let groupId = groupModel.groupId
                 let groupSecretParamsData = groupModel.secretParamsData
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] try to refresh v2 group up to curr revision immed") }
                 return Self.groupV2Updates.tryToRefreshV2GroupUpToCurrentRevisionImmediately(groupId: groupId,
                                                                                              groupSecretParamsData: groupSecretParamsData).asVoid()
             }.then(on: DispatchQueue.global()) { () throws -> Promise<TSGroupThread> in
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] update profile key") }
                 return GroupManager.updateLocalProfileKey(
                     groupModel: groupModel
                 )
             }.then(on: DispatchQueue.global()) { (groupThread: TSGroupThread) -> Promise<TSGroupThread> in
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] check update really worked") }
                 // Confirm that the updated snapshot has the new profile key.
-                firstly(on: DispatchQueue.global()) { () -> Promise<GroupV2Snapshot> in
+                return firstly(on: DispatchQueue.global()) { () -> Promise<GroupV2Snapshot> in
                     guard let groupModel = groupThread.groupModel as? TSGroupModelV2 else {
                         throw OWSAssertionError("Invalid group model.")
                     }
+                    if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] fetch snapshot again") }
                     return self.groupsV2Impl.fetchCurrentGroupV2Snapshot(groupModel: groupModel)
                 }.map(on: DispatchQueue.global()) { (groupV2Snapshot: GroupV2Snapshot) throws -> Void in
                     guard groupV2Snapshot.groupMembership.isFullMember(localAci) else {
diff --git a/SignalServiceKit/src/Messages/MessageProcessor.swift b/SignalServiceKit/src/Messages/MessageProcessor.swift
index 742152dc8cd..65e78810998 100644
--- a/SignalServiceKit/src/Messages/MessageProcessor.swift
+++ b/SignalServiceKit/src/Messages/MessageProcessor.swift
@@ -143,9 +143,11 @@ public class MessageProcessor: NSObject {
         suspensionBehavior: SuspensionBehavior = .alwaysWait
     ) -> Promise<Void> {
         return firstly { () -> Promise<Void> in
-            Self.messageFetcherJob.fetchingCompletePromise()
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] fetchingCompletePromise") }
+            return Self.messageFetcherJob.fetchingCompletePromise()
         }.then { () -> Promise<Void> in
-            self.processingCompletePromise(suspensionBehavior: suspensionBehavior)
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] processingCompletePromise") }
+            return self.processingCompletePromise(suspensionBehavior: suspensionBehavior)
         }
     }
 
diff --git a/SignalServiceKit/src/groups/GroupManager+GenericGroupUpdates.swift b/SignalServiceKit/src/groups/GroupManager+GenericGroupUpdates.swift
index 710f1acdcb8..8cf63d18c79 100644
--- a/SignalServiceKit/src/groups/GroupManager+GenericGroupUpdates.swift
+++ b/SignalServiceKit/src/groups/GroupManager+GenericGroupUpdates.swift
@@ -100,6 +100,7 @@ extension GroupManager {
             changesBlock: changesBlock
         )
 
+        if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] add rotation to op queue") }
         operationQueue(forUpdatingGroup: groupModel).addOperation(operation)
 
         return operation.promise
diff --git a/SignalServiceKit/src/groups/GroupManager.swift b/SignalServiceKit/src/groups/GroupManager.swift
index 8db64fd093e..16e62acce21 100644
--- a/SignalServiceKit/src/groups/GroupManager.swift
+++ b/SignalServiceKit/src/groups/GroupManager.swift
@@ -1478,6 +1478,7 @@ public class GroupManager: NSObject {
         }
 
         return databaseStorage.read(.promise) { transaction -> Bool in
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] hasProfileKeyCredential") }
             return self.groupsV2Swift.hasProfileKeyCredential(for: localAddress,
                                                               transaction: transaction)
         }.then(on: DispatchQueue.global()) { hasLocalCredential -> Promise<Void> in
@@ -1488,6 +1489,7 @@ public class GroupManager: NSObject {
             // If we don't have a local profile key credential we should first
             // check if it is simply expired, by asking for a new one (which we
             // would get as part of fetching our local profile).
+            if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] fetch local user profile") }
             return self.profileManager.fetchLocalUsersProfilePromise(authedAccount: .implicit()).asVoid()
         }.then(on: DispatchQueue.global()) { () -> Promise<Void> in
             let hasProfileKeyCredentialAfterRefresh = databaseStorage.read { transaction in
@@ -1498,6 +1500,7 @@ public class GroupManager: NSObject {
                 // We successfully refreshed our profile key credential, which
                 // means we have previously uploaded a commitment, and all is
                 // well.
+                if DebugFlags.internalLogging { Logger.info("[Scroll Perf Debug] got profile key credential") }
                 return .value(())
             }
 
