diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 505d8c32d67..4035829e3ca 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -986,7 +986,7 @@
 		668A00E02C2B5ECF007B8808 /* DebuggerUtils.h in Headers */ = {isa = PBXBuildFile; fileRef = 668A00DE2C2B5ECF007B8808 /* DebuggerUtils.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		668A00E22C2B5F0C007B8808 /* OWSAssertionError.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668A00E12C2B5F0C007B8808 /* OWSAssertionError.swift */; };
 		668A00E42C2B5F35007B8808 /* OWSLocalizedString.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668A00E32C2B5F35007B8808 /* OWSLocalizedString.swift */; };
-		668A00E92C2B5F59007B8808 /* UnfairLock.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668A00E62C2B5F58007B8808 /* UnfairLock.swift */; };
+		668A00E92C2B5F59007B8808 /* TSMutex.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668A00E62C2B5F58007B8808 /* TSMutex.swift */; };
 		668A00F42C2B5F81007B8808 /* NSDate+OWS.m in Sources */ = {isa = PBXBuildFile; fileRef = 668A00EC2C2B5F80007B8808 /* NSDate+OWS.m */; };
 		668A00F52C2B5F81007B8808 /* NSObject+OWS.h in Headers */ = {isa = PBXBuildFile; fileRef = 668A00ED2C2B5F80007B8808 /* NSObject+OWS.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		668A00F82C2B5F81007B8808 /* NSDate+OWS.h in Headers */ = {isa = PBXBuildFile; fileRef = 668A00F02C2B5F81007B8808 /* NSDate+OWS.h */; settings = {ATTRIBUTES = (Public, ); }; };
@@ -4820,7 +4820,7 @@
 		668A00DE2C2B5ECF007B8808 /* DebuggerUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebuggerUtils.h; sourceTree = "<group>"; };
 		668A00E12C2B5F0C007B8808 /* OWSAssertionError.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSAssertionError.swift; sourceTree = "<group>"; };
 		668A00E32C2B5F35007B8808 /* OWSLocalizedString.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OWSLocalizedString.swift; sourceTree = "<group>"; };
-		668A00E62C2B5F58007B8808 /* UnfairLock.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = UnfairLock.swift; sourceTree = "<group>"; };
+		668A00E62C2B5F58007B8808 /* TSMutex.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = TSMutex.swift; sourceTree = "<group>"; };
 		668A00EC2C2B5F80007B8808 /* NSDate+OWS.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSDate+OWS.m"; sourceTree = "<group>"; };
 		668A00ED2C2B5F80007B8808 /* NSObject+OWS.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSObject+OWS.h"; sourceTree = "<group>"; };
 		668A00F02C2B5F81007B8808 /* NSDate+OWS.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSDate+OWS.h"; sourceTree = "<group>"; };
@@ -9690,7 +9690,7 @@
 		668A00E52C2B5F49007B8808 /* Locking */ = {
 			isa = PBXGroup;
 			children = (
-				668A00E62C2B5F58007B8808 /* UnfairLock.swift */,
+				668A00E62C2B5F58007B8808 /* TSMutex.swift */,
 			);
 			path = Locking;
 			sourceTree = "<group>";
@@ -18329,6 +18329,7 @@
 				F9C5CBD4289453B300548EEE /* TSMessage+SDS.swift in Sources */,
 				F9C5CBF7289453B300548EEE /* TSMessage.m in Sources */,
 				F9C5CBF4289453B300548EEE /* TSMessage.swift in Sources */,
+				668A00E92C2B5F59007B8808 /* TSMutex.swift in Sources */,
 				F9C5CBF3289453B300548EEE /* TSOutgoingDeleteMessage.m in Sources */,
 				D93086272C616391008E3A27 /* TSOutgoingMessage+Builder.swift in Sources */,
 				F9C5CBF6289453B300548EEE /* TSOutgoingMessage+SDS.swift in Sources */,
@@ -18390,7 +18391,6 @@
 				F9C5CE1F289453B400548EEE /* UIImage+OWS.swift in Sources */,
 				663D02DD2C06717900350632 /* UInt64SafeRecord.swift in Sources */,
 				7255A4CB2B98E04900E95368 /* UIView+OWS.swift in Sources */,
-				668A00E92C2B5F59007B8808 /* UnfairLock.swift in Sources */,
 				50D6A93F2AA9167400B7F093 /* UniqueObjectRecipientMerger.swift in Sources */,
 				6600F34C298C81CD00B1EDB7 /* UnknownEnumCodable.swift in Sources */,
 				664BA8472BB5CE1A005638E0 /* UnpreparedOutgoingMessage.swift in Sources */,
diff --git a/SignalServiceKit/Locking/UnfairLock.swift b/SignalServiceKit/Locking/TSMutex.swift
similarity index 51%
rename from SignalServiceKit/Locking/UnfairLock.swift
rename to SignalServiceKit/Locking/TSMutex.swift
index cc312c8f920..4ac6189e5b1 100644
--- a/SignalServiceKit/Locking/UnfairLock.swift
+++ b/SignalServiceKit/Locking/TSMutex.swift
@@ -3,7 +3,10 @@
 // SPDX-License-Identifier: AGPL-3.0-only
 //
 
-import Foundation
+internal import os.lock
+
+@available(iOS, obsoleted: 16.0, message: "Use OSAllocatedUnfairLock instead.")
+public typealias UnfairLock = TSMutex<Void>
 
 /// A wrapper around os_unfair_lock to contain the memory management required to properly handle
 /// allocating an instance of os_unfair_lock with a stable address in Swift.
@@ -13,74 +16,69 @@ import Foundation
 /// > Warning: Errors with unfair lock are fatal and will terminate the process.
 ///
 /// > Note: To be replaced with OSAllocatedUnfairLock once our underlying iOS version is â‰¥ 16.
-public final class UnfairLock: NSLocking, Sendable {
-    nonisolated(unsafe) private let _lock: os_unfair_lock_t
+@available(iOS, obsoleted: 16.0, message: "Use OSAllocatedUnfairLock instead.")
+public final class TSMutex<State: ~Copyable>: Sendable {
+    @usableFromInline
+    nonisolated(unsafe) let _lock: os_unfair_lock_t
+
+    @usableFromInline
+    nonisolated(unsafe) var _state: State
 
-    public init() {
+    public init(initialState state: consuming sending State) {
         _lock = .allocate(capacity: 1)
         _lock.initialize(to: os_unfair_lock_s())
+        _state = state
     }
 
     deinit {
-        _lock.deallocate()
+        _lock.deinitialize(count: 1).deallocate()
+    }
+
+    @inlinable
+    public func withLock<T: ~Copyable, E: Error>(_ body: @Sendable (inout State) throws(E) -> sending T) throws(E) -> sending T {
+        os_unfair_lock_lock(_lock)
+        defer { os_unfair_lock_unlock(_lock) }
+        return try body(&_state)
+    }
+}
+
+extension TSMutex where State == Void {
+    public convenience init() {
+        self.init(initialState: ())
+    }
+
+    @inlinable
+    public func withLock<T: ~Copyable, E: Error>(_ body: @Sendable () throws(E) -> sending T) throws(E) -> sending T {
+        try withLock { (_) throws(E) in
+            try body()
+        }
     }
 
     /// Locks the lock. Blocks if the lock is held by another thread.
     /// Forwards to os_unfair_lock_lock() defined in os/lock.h
+    @inlinable
     public final func lock() {
         os_unfair_lock_lock(_lock)
     }
 
     /// Unlocks the lock. Fatal error if the lock is owned by another thread.
     /// Forwards to os_unfair_lock_unlock() defined in os/lock.h
+    @inlinable
     public final func unlock() {
         os_unfair_lock_unlock(_lock)
     }
 
-    /// Attempts to lock the lock. Returns YES if the lock was successfully acquired.
-    /// Forwards to os_unfair_lock_trylock() defined in os/lock.h
-    public final func tryLock() -> Bool {
-        return os_unfair_lock_trylock(_lock)
-    }
-
     /// Fatal assert that the lock is owned by the current thread.
     /// Forwards to os_unfair_lock_assert_owner defined in os/lock.h
+    @inlinable
     public final func assertOwner() {
         os_unfair_lock_assert_owner(_lock)
     }
 
     /// Fatal assert that the lock is not owned by the current thread.
     /// Forwards to os_unfair_lock_assert_not_owner defined in os/lock.h
+    @inlinable
     public final func assertNotOwner() {
         os_unfair_lock_assert_not_owner(_lock)
     }
 }
-
-public extension UnfairLock {
-
-    /// Acquires and releases the lock around the provided closure. Returns without performing the closure if the lock
-    /// can not be acquired.
-    /// - Returns: `true` if the lock was acquired and the closure was invoked. `false` if the lock could not be
-    /// acquired.
-    @discardableResult
-    final func tryWithLock(_ criticalSection: () throws -> Void) rethrows -> Bool {
-        guard tryLock() else { return false }
-        defer { unlock() }
-
-        try criticalSection()
-        return true
-    }
-
-    /// Acquires and releases the lock around the provided closure. Returns without performing the closure if the lock
-    /// can not be acquired.
-    /// - Returns: nil if the lock could not be acquired. Otherwise, returns the returns the result of the provided
-    ///   closure
-    @discardableResult
-    final func tryWithLock<T>(_ criticalSection: () throws -> T) rethrows -> T? {
-        guard tryLock() else { return nil }
-        defer { unlock() }
-
-        return try criticalSection()
-    }
-
-}
diff --git a/SignalServiceKit/tests/Util/UnfairLockTest.swift b/SignalServiceKit/tests/Util/UnfairLockTest.swift
index b443600f95a..e79a178bf2a 100644
--- a/SignalServiceKit/tests/Util/UnfairLockTest.swift
+++ b/SignalServiceKit/tests/Util/UnfairLockTest.swift
@@ -3,29 +3,22 @@
 // SPDX-License-Identifier: AGPL-3.0-only
 //
 
-import Foundation
+import SignalServiceKit
 import XCTest
 
-@testable import SignalServiceKit
-
-class UnfairLockTest: XCTestCase {
-
-    private var dut: UnfairLock! = nil
-
-    override func setUp() {
-        dut = UnfairLock()
-    }
-
+final class UnfairLockTest: XCTestCase {
     // MARK: - Lock + Unlock
+
     func testSimpleLockAndUnlock() {
         // Setup
-        var sharedVal = 0
+        let dut = UnfairLock()
+        nonisolated(unsafe) var sharedVal = 0
 
         // Test
         fanout(1000) {
-            self.dut.lock()
+            dut.lock()
             sharedVal += 1
-            self.dut.unlock()
+            dut.unlock()
         }
 
         // Verify
@@ -34,11 +27,12 @@ class UnfairLockTest: XCTestCase {
 
     func testLockedClosure() {
         // Setup
-        var sharedVal = 0
+        let dut = UnfairLock()
+        nonisolated(unsafe) var sharedVal = 0
 
         // Test
         fanout(1000) {
-            self.dut.withLock {
+            dut.withLock {
                 sharedVal += 1
             }
         }
@@ -47,86 +41,11 @@ class UnfairLockTest: XCTestCase {
         XCTAssertEqual(sharedVal, 1000, "Lock failed to prevent data race.")
     }
 
-    // MARK: - Lock attempts
-
-    func testTryLock_guaranteedFailure() {
-        // Setup
-        let didLockOuter = dut.tryLock()
-        var didLockInner = false
-
-        // Test
-        fanout(1000) {
-            if self.dut.tryLock() {
-                didLockInner = true
-                self.dut.unlock()
-            }
-        }
-        dut.unlock()
-
-        // Verify
-        XCTAssertTrue(didLockOuter, "Failed to acquire the uncontended lock.")
-        XCTAssertFalse(didLockInner, "tryLock() acquired an already acquired lock.")
-    }
-
-    func testTryLock_contended() {
-        // Setup
-        var blockInvocationCount = 0
-
-        // Test
-        fanout(1000) {
-            guard self.dut.tryLock() else { return }
-            blockInvocationCount += 1
-            self.dut.unlock()
-        }
-
-        // Verify
-        XCTAssertGreaterThanOrEqual(blockInvocationCount, 1, "Invalid invocation count. Expected: [1, 1000]")
-        XCTAssertLessThanOrEqual(blockInvocationCount, 1000, "Invalid invocation count. Expected: [1, 1000]")
-    }
-
-    func testTryLockClosure_guaranteedFailure() {
-        // Setup
-        let didLockOuter = dut.tryLock()
-        var didLockInner = false
-
-        // Test
-        fanout(1000) {
-            didLockInner = didLockInner || self.dut.tryWithLock {
-                didLockInner = true
-            }
-        }
-        dut.unlock()
-
-        // Verify
-        XCTAssertTrue(didLockOuter, "Failed to acquire the uncontended lock.")
-        XCTAssertFalse(didLockInner, "tryLock() acquired an already acquired lock.")
-    }
-
-    func testTryLockClosure_contended() {
-        // Setup
-        var blockInvocationCount = 0
-
-        // Test
-        fanout(1000) {
-            var invokedLocally = false
-            let success = self.dut.tryWithLock {
-                blockInvocationCount += 1
-
-                // To catch any repeat invocations of the closure
-                XCTAssertFalse(invokedLocally)
-                invokedLocally = true
-            }
-            // If the lock was acquired, the closure should have run
-            XCTAssertEqual(invokedLocally, success)
-        }
-
-        // Verify
-        XCTAssertGreaterThanOrEqual(blockInvocationCount, 1, "Invalid invocation count. Expected: [1, 1000]")
-        XCTAssertLessThanOrEqual(blockInvocationCount, 1000, "Invalid invocation count. Expected: [1, 1000]")
-    }
+    // MARK: - Return Value
 
     func testPropagatedReturnValue() {
         // Setup
+        let dut = UnfairLock()
         let outerVal: String? = "Hello, this is an optional string"
 
         // Test
@@ -138,41 +57,14 @@ class UnfairLockTest: XCTestCase {
         XCTAssertEqual(returnedVal, "Hello, this is an optional string!")
     }
 
-    func testPropagatedReturnValue_tryLockSuccess() {
-        // Setup
-        let outerVal: String? = "Hello, this is an optional string"
-
-        // Test
-        let returnedVal: String?? = dut.tryWithLock {
-            return outerVal?.appending("!")
-        }
-
-        // Expect
-        XCTAssertEqual(returnedVal, "Hello, this is an optional string!")
-    }
-
-    func testPropagatedReturnValue_tryLockFailure() {
-        // Setup
-        let outerVal: String? = "Hello, this is an optional string"
-
-        // Test
-        let returnedVal: String?? = dut.tryWithLock {
-            return dut.tryWithLock {
-                return outerVal?.appending("!")
-            } ?? "oops nevermind"
-        }
-
-        // Expect
-        XCTAssertEqual(returnedVal, "oops nevermind")
-    }
-
     // MARK: - Throwing Inner Closure
 
     func testThrowingLockedClosure() {
         // Setup
-        var didAcquireLock = false
+        let dut = UnfairLock()
+        nonisolated(unsafe) var didAcquireLock = false
+        nonisolated(unsafe) var didReacquireLock = false
         var didCatchError = false
-        var didReacquireLock = false
 
         // Test
         let toThrow = NSError(domain: "UnfairLockTests", code: 2, userInfo: nil)
@@ -196,36 +88,9 @@ class UnfairLockTest: XCTestCase {
         XCTAssertTrue(didReacquireLock)
     }
 
-    func testThrowingTryLockedClosure() {
-        // Setup
-        var didAcquireLock = false
-        var didCatchError = false
-        var didReacquireLock = false
-
-        // Test
-        let toThrow = NSError(domain: "UnfairLockTests", code: 2, userInfo: nil)
-        do {
-            try dut.tryWithLock {
-                didAcquireLock = true
-                throw toThrow
-            }
-        } catch {
-            XCTAssertEqual(toThrow, (error as NSError))
-            didCatchError = true
-        }
-
-        didReacquireLock = dut.tryWithLock {}
-
-        // Verify
-        XCTAssertTrue(didAcquireLock)
-        XCTAssertTrue(didCatchError)
-        XCTAssertTrue(didReacquireLock)
-    }
-
     // MARK: - Test Helpers
 
-    func fanout(_ iterations: Int, _ block: () -> Void) {
-        DispatchQueue.concurrentPerform(iterations: iterations) { (_) in block() }
+    func fanout(_ iterations: Int, _ block: @Sendable () -> Void) {
+        DispatchQueue.concurrentPerform(iterations: iterations) { _ in block() }
     }
-
 }
diff --git a/SignalUI/Payments/PaymentsProcessor.swift b/SignalUI/Payments/PaymentsProcessor.swift
index 2f2c263d2cb..21c2aa637e6 100644
--- a/SignalUI/Payments/PaymentsProcessor.swift
+++ b/SignalUI/Payments/PaymentsProcessor.swift
@@ -120,7 +120,7 @@ public class PaymentsProcessor: NSObject {
         // Create a new operation for any payment that needs to be
         // processed that we're not already processing.
         let delegate: PaymentProcessingOperationDelegate = self
-        Self.unfairLock.withLock {
+        Self.unfairLock.withLock { [paymentModels] in
             for paymentModel in paymentModels {
                 let paymentId = paymentModel.uniqueId
                 // Don't add an operation if we're already processing this payment model.
