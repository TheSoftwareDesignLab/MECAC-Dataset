diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 204ece44f05..99f1b1e5dd7 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -1087,7 +1087,6 @@
 		88F5D78C2880ABF900CE4D2D /* NewPrivateStoryConfirmViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 88F5D78B2880ABF900CE4D2D /* NewPrivateStoryConfirmViewController.swift */; };
 		88F5FA9428EBD4CF007AA1BF /* StorySharing.swift in Sources */ = {isa = PBXBuildFile; fileRef = 88F5FA9228EBD484007AA1BF /* StorySharing.swift */; };
 		88F67A0C24E5126D00435A71 /* HapticFeedback.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4C090A1A210FD9C7001FD7F9 /* HapticFeedback.swift */; };
-		88F7EE93230253C5003ADF7D /* UsernameViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 88F7EE92230253C5003ADF7D /* UsernameViewController.swift */; };
 		88FE237E249C22080041670F /* ConversationViewController+Scroll.swift in Sources */ = {isa = PBXBuildFile; fileRef = 88FE237D249C22080041670F /* ConversationViewController+Scroll.swift */; };
 		954AEE6A1DF33E01002E5410 /* ContactsPickerTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = 954AEE681DF33D32002E5410 /* ContactsPickerTest.swift */; };
 		A10FDF79184FB4BB007FF963 /* MediaPlayer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 76C87F18181EFCE600C4ACAB /* MediaPlayer.framework */; };
@@ -1137,6 +1136,9 @@
 		D9517ABE292C596B00DDD37E /* Paypal+WebAuthentication.swift in Sources */ = {isa = PBXBuildFile; fileRef = D9517ABD292C596B00DDD37E /* Paypal+WebAuthentication.swift */; };
 		D9517AC0292C5A3900DDD37E /* Paypal+API.swift in Sources */ = {isa = PBXBuildFile; fileRef = D9517ABF292C5A3900DDD37E /* Paypal+API.swift */; };
 		D95C39E6296DE9E900A9DA23 /* OWSRequestFactory+BoostPayments.swift in Sources */ = {isa = PBXBuildFile; fileRef = D95C39E5296DE9E900A9DA23 /* OWSRequestFactory+BoostPayments.swift */; };
+		D95C39E8296DEBFB00A9DA23 /* OWSRequestFactory+Usernames.swift in Sources */ = {isa = PBXBuildFile; fileRef = D95C39E7296DEBFB00A9DA23 /* OWSRequestFactory+Usernames.swift */; };
+		D95C39EA296E108100A9DA23 /* UsernameSelectionViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = D95C39E9296E108100A9DA23 /* UsernameSelectionViewController.swift */; };
+		D95C39EC296E1BC600A9DA23 /* PrefixedLogger.swift in Sources */ = {isa = PBXBuildFile; fileRef = D95C39EB296E1BC600A9DA23 /* PrefixedLogger.swift */; };
 		D95DA7ED28B560D1003996BA /* ConversationViewController+SystemMessageItems.swift in Sources */ = {isa = PBXBuildFile; fileRef = D95DA7EC28B560D1003996BA /* ConversationViewController+SystemMessageItems.swift */; };
 		D9668B2F291AF63500665298 /* SSKJobQueues.swift in Sources */ = {isa = PBXBuildFile; fileRef = D9668B2E291AF63500665298 /* SSKJobQueues.swift */; };
 		D9668B33291B03C200665298 /* SessionResetJob.swift in Sources */ = {isa = PBXBuildFile; fileRef = 45D231761DC7E8F10034FA89 /* SessionResetJob.swift */; };
@@ -1149,6 +1151,12 @@
 		D98DD85F28EE53B00089333E /* RemoteMegaphoneFetcher.swift in Sources */ = {isa = PBXBuildFile; fileRef = D98DD85D28EE53B00089333E /* RemoteMegaphoneFetcher.swift */; };
 		D98DD86028EE53B00089333E /* RemoteMegaphoneModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = D98DD85E28EE53B00089333E /* RemoteMegaphoneModel.swift */; };
 		D997FA7628F8E3A2003C7B8B /* RemoteMegaphone.swift in Sources */ = {isa = PBXBuildFile; fileRef = D997FA7528F8E3A2003C7B8B /* RemoteMegaphone.swift */; };
+		D99840B32976227100F7ED6D /* UsernameSelectionViewController+UsernameTextField.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99840B22976227100F7ED6D /* UsernameSelectionViewController+UsernameTextField.swift */; };
+		D99840B829775A8300F7ED6D /* Usernames+NicknameValidatorTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99840B629775A0400F7ED6D /* Usernames+NicknameValidatorTests.swift */; };
+		D99840BD297A04DA00F7ED6D /* Usernames+NicknameValidator.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99840BC297A04DA00F7ED6D /* Usernames+NicknameValidator.swift */; };
+		D99840BF297A04EB00F7ED6D /* Usernames.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99840BE297A04EB00F7ED6D /* Usernames.swift */; };
+		D99840C4297A0ECE00F7ED6D /* Usernames+ParsedUsername.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99840C3297A0ECE00F7ED6D /* Usernames+ParsedUsername.swift */; };
+		D99840C6297A0F9500F7ED6D /* Usernames+API.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99840C5297A0F9500F7ED6D /* Usernames+API.swift */; };
 		D99D960F292871C600D5028B /* DonateViewController+OneTimePaypalDonation.swift in Sources */ = {isa = PBXBuildFile; fileRef = D99D960E292871C600D5028B /* DonateViewController+OneTimePaypalDonation.swift */; };
 		D9AB38D0283C38B10003C038 /* InteractionFinderPerformanceTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = D9AB38CE283C38640003C038 /* InteractionFinderPerformanceTests.swift */; };
 		D9AD1D9528B9955C00B42E6F /* TSInfoMessage+GroupUpdateCopy+NSAttributedStringTest.swift in Sources */ = {isa = PBXBuildFile; fileRef = D9AD1D9428B9955C00B42E6F /* TSInfoMessage+GroupUpdateCopy+NSAttributedStringTest.swift */; };
@@ -3466,7 +3474,6 @@
 		88F5D78B2880ABF900CE4D2D /* NewPrivateStoryConfirmViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NewPrivateStoryConfirmViewController.swift; sourceTree = "<group>"; };
 		88F5FA9228EBD484007AA1BF /* StorySharing.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StorySharing.swift; sourceTree = "<group>"; };
 		88F5FA9528EF7E02007AA1BF /* StorySharingTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StorySharingTests.swift; sourceTree = "<group>"; };
-		88F7EE92230253C5003ADF7D /* UsernameViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UsernameViewController.swift; sourceTree = "<group>"; };
 		88FE237D249C22080041670F /* ConversationViewController+Scroll.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ConversationViewController+Scroll.swift"; sourceTree = "<group>"; };
 		89095AC0DD065D55A4A5F8C6 /* Pods_SignalServiceKit.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_SignalServiceKit.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		8981C8F64D94D3C52EB67A2C /* Pods-SignalTests.test.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalTests.test.xcconfig"; path = "Pods/Target Support Files/Pods-SignalTests/Pods-SignalTests.test.xcconfig"; sourceTree = "<group>"; };
@@ -3547,6 +3554,9 @@
 		D9517ABD292C596B00DDD37E /* Paypal+WebAuthentication.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Paypal+WebAuthentication.swift"; sourceTree = "<group>"; };
 		D9517ABF292C5A3900DDD37E /* Paypal+API.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Paypal+API.swift"; sourceTree = "<group>"; };
 		D95C39E5296DE9E900A9DA23 /* OWSRequestFactory+BoostPayments.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "OWSRequestFactory+BoostPayments.swift"; sourceTree = "<group>"; };
+		D95C39E7296DEBFB00A9DA23 /* OWSRequestFactory+Usernames.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "OWSRequestFactory+Usernames.swift"; sourceTree = "<group>"; };
+		D95C39E9296E108100A9DA23 /* UsernameSelectionViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UsernameSelectionViewController.swift; sourceTree = "<group>"; };
+		D95C39EB296E1BC600A9DA23 /* PrefixedLogger.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PrefixedLogger.swift; sourceTree = "<group>"; };
 		D95DA7EC28B560D1003996BA /* ConversationViewController+SystemMessageItems.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "ConversationViewController+SystemMessageItems.swift"; sourceTree = "<group>"; };
 		D9668B2E291AF63500665298 /* SSKJobQueues.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SSKJobQueues.swift; sourceTree = "<group>"; };
 		D9668B34291B088200665298 /* SignalMessagingJobQueues.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SignalMessagingJobQueues.swift; sourceTree = "<group>"; };
@@ -3558,6 +3568,12 @@
 		D98DD85D28EE53B00089333E /* RemoteMegaphoneFetcher.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = RemoteMegaphoneFetcher.swift; sourceTree = "<group>"; };
 		D98DD85E28EE53B00089333E /* RemoteMegaphoneModel.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = RemoteMegaphoneModel.swift; sourceTree = "<group>"; };
 		D997FA7528F8E3A2003C7B8B /* RemoteMegaphone.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RemoteMegaphone.swift; sourceTree = "<group>"; };
+		D99840B22976227100F7ED6D /* UsernameSelectionViewController+UsernameTextField.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "UsernameSelectionViewController+UsernameTextField.swift"; sourceTree = "<group>"; };
+		D99840B629775A0400F7ED6D /* Usernames+NicknameValidatorTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Usernames+NicknameValidatorTests.swift"; sourceTree = "<group>"; };
+		D99840BC297A04DA00F7ED6D /* Usernames+NicknameValidator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Usernames+NicknameValidator.swift"; sourceTree = "<group>"; };
+		D99840BE297A04EB00F7ED6D /* Usernames.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Usernames.swift; sourceTree = "<group>"; };
+		D99840C3297A0ECE00F7ED6D /* Usernames+ParsedUsername.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Usernames+ParsedUsername.swift"; sourceTree = "<group>"; };
+		D99840C5297A0F9500F7ED6D /* Usernames+API.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Usernames+API.swift"; sourceTree = "<group>"; };
 		D99D960E292871C600D5028B /* DonateViewController+OneTimePaypalDonation.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "DonateViewController+OneTimePaypalDonation.swift"; sourceTree = "<group>"; };
 		D9AB38CE283C38640003C038 /* InteractionFinderPerformanceTests.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = InteractionFinderPerformanceTests.swift; sourceTree = "<group>"; };
 		D9AD1D9428B9955C00B42E6F /* TSInfoMessage+GroupUpdateCopy+NSAttributedStringTest.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "TSInfoMessage+GroupUpdateCopy+NSAttributedStringTest.swift"; sourceTree = "<group>"; };
@@ -6076,6 +6092,7 @@
 				457F3AC01D14A0F700C51351 /* Models */,
 				45CD81A41DBFF8CF004C9430 /* Storyboards */,
 				450DF2061E0DD28D003D14BE /* UserInterface */,
+				D99840BB297A04A300F7ED6D /* Usernames */,
 				76EB04C818170B33006006FC /* util */,
 				F909E27B293D0F78003B41D1 /* AppDelegate+Lifecycle.swift */,
 				F990FAD1293800EE006FB21B /* AppDelegate+Orientation.swift */,
@@ -6398,7 +6415,6 @@
 				34798A8625AF965300EC89B4 /* ProfileBioViewController.swift */,
 				8871B17025F0139D00D4E070 /* ProfileNameViewController.swift */,
 				8871B16E25F007DE00D4E070 /* ProfileSettingsViewController.swift */,
-				88F7EE92230253C5003ADF7D /* UsernameViewController.swift */,
 			);
 			path = Profile;
 			sourceTree = "<group>";
@@ -6797,6 +6813,7 @@
 				4C3EF8002109184A0007EBF7 /* SSKTests */,
 				E75DD3DC2810CD3500E32C36 /* subscriptions */,
 				B660F69D1C29868000687D6E /* Supporting Files */,
+				D99840C2297A0DC400F7ED6D /* Usernames */,
 				B660F6A21C29868000687D6E /* util */,
 				34B3F8951E8DF1B90035BE1A /* ViewControllers */,
 				34BEDB0F21C41E71007B0EAE /* views */,
@@ -7029,6 +7046,27 @@
 			path = "Remote Megaphone";
 			sourceTree = "<group>";
 		};
+		D99840BB297A04A300F7ED6D /* Usernames */ = {
+			isa = PBXGroup;
+			children = (
+				D99840C5297A0F9500F7ED6D /* Usernames+API.swift */,
+				D99840BC297A04DA00F7ED6D /* Usernames+NicknameValidator.swift */,
+				D99840C3297A0ECE00F7ED6D /* Usernames+ParsedUsername.swift */,
+				D99840BE297A04EB00F7ED6D /* Usernames.swift */,
+				D99840B22976227100F7ED6D /* UsernameSelectionViewController+UsernameTextField.swift */,
+				D95C39E9296E108100A9DA23 /* UsernameSelectionViewController.swift */,
+			);
+			path = Usernames;
+			sourceTree = "<group>";
+		};
+		D99840C2297A0DC400F7ED6D /* Usernames */ = {
+			isa = PBXGroup;
+			children = (
+				D99840B629775A0400F7ED6D /* Usernames+NicknameValidatorTests.swift */,
+			);
+			path = Usernames;
+			sourceTree = "<group>";
+		};
 		E75DD3DC2810CD3500E32C36 /* subscriptions */ = {
 			isa = PBXGroup;
 			children = (
@@ -8303,6 +8341,7 @@
 			children = (
 				D95C39E5296DE9E900A9DA23 /* OWSRequestFactory+BoostPayments.swift */,
 				F9D5BFCC2979A017001737E5 /* OWSRequestFactory+Spam.swift */,
+				D95C39E7296DEBFB00A9DA23 /* OWSRequestFactory+Usernames.swift */,
 				F9C5CAE4289453B200548EEE /* OWSRequestFactory.h */,
 				F9C5CAE6289453B200548EEE /* OWSRequestFactory.m */,
 				F9C5CAE2289453B200548EEE /* OWSRequestFactory.swift */,
@@ -8429,6 +8468,7 @@
 				F9C5CB1D289453B200548EEE /* PinnedThreadManager.swift */,
 				F9C5CB58289453B200548EEE /* Platform.swift */,
 				F908AA7928CB89CC00472E68 /* PngChunker.swift */,
+				D95C39EB296E1BC600A9DA23 /* PrefixedLogger.swift */,
 				F9C5CB4B289453B200548EEE /* Promise+OWS.swift */,
 				F9C5CB42289453B200548EEE /* ReadyFlag.swift */,
 				F9C5CB46289453B200548EEE /* Refinery.swift */,
@@ -10750,7 +10790,12 @@
 				342FFE7B271EF581000AC89F /* UIStoryboard+OWS.swift in Sources */,
 				346CD5C226306578004162D6 /* UnknownThreadWarningInteraction.swift in Sources */,
 				4CFF115323A9C2130007F9D7 /* UnreadIndicatorInteraction.swift in Sources */,
-				88F7EE93230253C5003ADF7D /* UsernameViewController.swift in Sources */,
+				D99840C6297A0F9500F7ED6D /* Usernames+API.swift in Sources */,
+				D99840BF297A04EB00F7ED6D /* Usernames.swift in Sources */,
+				D99840BD297A04DA00F7ED6D /* Usernames+NicknameValidator.swift in Sources */,
+				D99840C4297A0ECE00F7ED6D /* Usernames+ParsedUsername.swift in Sources */,
+				D99840B32976227100F7ED6D /* UsernameSelectionViewController+UsernameTextField.swift in Sources */,
+				D95C39EA296E108100A9DA23 /* UsernameSelectionViewController.swift in Sources */,
 				3434AE1C22AEDE7D002EE04E /* ViewOnceMessageViewController.swift in Sources */,
 				88928A7726419D6B009C9B30 /* VoiceMessageDraftView.swift in Sources */,
 				88928A7526418904009C9B30 /* VoiceMessageTooltip.swift in Sources */,
@@ -10824,6 +10869,7 @@
 				452D1AF12081059C00A67F7F /* StringAdditionsTest.swift in Sources */,
 				F992ACC428F8C9D900906038 /* StripeTest.swift in Sources */,
 				E75DD3E02810CDBD00E32C36 /* SubscriptionManagerTest.swift in Sources */,
+				D99840B829775A8300F7ED6D /* Usernames+NicknameValidatorTests.swift in Sources */,
 				45A3579827DAAC6A0051CE8B /* UserProfileTest.swift in Sources */,
 				B660F6E01C29868000687D6E /* UtilTest.m in Sources */,
 				5042EAA3287F96FB00C9B19F /* VisibleBadgeResolverTest.swift in Sources */,
@@ -11139,6 +11185,7 @@
 				F9C5CC85289453B300548EEE /* OWSRecoverableDecryptionPlaceholder.m in Sources */,
 				D95C39E6296DE9E900A9DA23 /* OWSRequestFactory+BoostPayments.swift in Sources */,
 				F9D5BFCD2979A017001737E5 /* OWSRequestFactory+Spam.swift in Sources */,
+				D95C39E8296DEBFB00A9DA23 /* OWSRequestFactory+Usernames.swift in Sources */,
 				F9C5CDB9289453B400548EEE /* OWSRequestFactory.m in Sources */,
 				F9C5CDB5289453B400548EEE /* OWSRequestFactory.swift in Sources */,
 				F9C5CC52289453B300548EEE /* OWSRequestMaker.swift in Sources */,
@@ -11200,6 +11247,7 @@
 				F9C5CDEF289453B400548EEE /* PinnedThreadManager.swift in Sources */,
 				F9C5CE2A289453B400548EEE /* Platform.swift in Sources */,
 				F97823F328CD0AA1005533BF /* PngChunker.swift in Sources */,
+				D95C39EC296E1BC600A9DA23 /* PrefixedLogger.swift in Sources */,
 				F9C5CBCB289453B300548EEE /* PreKeyBundle+jsonDict.m in Sources */,
 				F9C5CD50289453B300548EEE /* PreKeyBundle.m in Sources */,
 				F9C5CD4D289453B300548EEE /* PreKeyRecord.m in Sources */,
diff --git a/Signal/src/Usernames/UsernameSelectionViewController+UsernameTextField.swift b/Signal/src/Usernames/UsernameSelectionViewController+UsernameTextField.swift
new file mode 100644
index 00000000000..a393fe273e0
--- /dev/null
+++ b/Signal/src/Usernames/UsernameSelectionViewController+UsernameTextField.swift
@@ -0,0 +1,218 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+extension UsernameSelectionViewController {
+    class UsernameTextField: OWSTextField {
+        /// Presents state related to a username discriminator, such as the
+        /// discriminator itself and state indicators such as a spinner.
+        private class DiscriminatorView: OWSStackView {
+            private enum Constants {
+                static let spacing: CGFloat = 16
+                static let separatorWidth: CGFloat = 2
+            }
+
+            enum Mode {
+                case empty
+                case spinning
+                case spinningWithDiscriminator(value: String)
+                case discriminator(value: String)
+            }
+
+            /// The mode for which this view should be configured.
+            var mode: Mode {
+                didSet {
+                    AssertIsOnMainThread()
+
+                    configureForCurrentMode()
+                }
+            }
+
+            init(inMode mode: Mode) {
+                self.mode = mode
+
+                super.init(
+                    name: "Username discriminator view",
+                    arrangedSubviews: []
+                )
+
+                addArrangedSubviews([
+                    spinnerView,
+                    separatorView,
+                    discriminatorLabel
+                ])
+
+                spacing = Constants.spacing
+                isLayoutMarginsRelativeArrangement = true
+                layoutMargins.leading = Constants.spacing
+
+                configureForCurrentMode()
+            }
+
+            @available(*, unavailable, message: "Use other constructor")
+            required init(name: String, arrangedSubviews: [UIView]) {
+                fatalError("Use other constructor")
+            }
+
+            // MARK: Views
+
+            private lazy var spinnerView: UIActivityIndicatorView = {
+                let spinner: UIActivityIndicatorView = {
+                    if #available(iOS 13, *) {
+                        return .init(style: .medium)
+                    } else {
+                        return .init(style: .white)
+                    }
+                }()
+
+                spinner.startAnimating()
+
+                return spinner
+            }()
+
+            private lazy var separatorView: UIView = {
+                let lineView = UIView()
+
+                lineView.backgroundColor = .ows_gray15
+                lineView.layer.cornerRadius = Constants.separatorWidth / 2
+                lineView.widthAnchor.constraint(
+                    equalToConstant: Constants.separatorWidth
+                ).isActive = true
+
+                return lineView
+            }()
+
+            private lazy var discriminatorLabel: UILabel = {
+                let label = UILabel()
+
+                label.textColor = Theme.primaryTextColor
+                label.font = .ows_dynamicTypeBodyClamped
+
+                return label
+            }()
+
+            // MARK: Configure views
+
+            /// Configure which subviews to present based on the current mode.
+            private func configureForCurrentMode() {
+                AssertIsOnMainThread()
+
+                switch mode {
+                case .empty:
+                    isHidden = true
+                case .spinning:
+                    isHidden = false
+                    spinnerView.isHiddenInStackView = false
+                    separatorView.isHiddenInStackView = true
+                    discriminatorLabel.isHiddenInStackView = true
+                case let .spinningWithDiscriminator(discriminatorValue):
+                    isHidden = false
+                    spinnerView.isHiddenInStackView = false
+                    separatorView.isHiddenInStackView = false
+                    discriminatorLabel.isHiddenInStackView = false
+                    setDiscriminatorValue(to: discriminatorValue)
+                case let .discriminator(discriminatorValue):
+                    isHidden = false
+                    spinnerView.isHiddenInStackView = true
+                    separatorView.isHiddenInStackView = false
+                    discriminatorLabel.isHiddenInStackView = false
+                    setDiscriminatorValue(to: discriminatorValue)
+                }
+            }
+
+            private func setDiscriminatorValue(to value: String) {
+                discriminatorLabel.text = "\(ParsedUsername.separator)\(value)"
+            }
+        }
+
+        /// The last-known reserved/confirmed discriminator. While showing a
+        /// spinner for an in-progress reservation, we continue to show the
+        /// last-known-good discriminator value.
+        private var lastKnownGoodDiscriminator: String?
+
+        private let discriminatorView: DiscriminatorView = .init(inMode: .empty)
+
+        init(forUsername username: ParsedUsername?) {
+            if let username {
+                lastKnownGoodDiscriminator = username.discriminator
+                discriminatorView.mode = .discriminator(value: username.discriminator)
+            } else {
+                discriminatorView.mode = .empty
+            }
+
+            super.init(frame: .zero)
+
+            if let username {
+                text = username.nickname
+            }
+
+            font = .ows_dynamicTypeBodyClamped
+            textColor = Theme.primaryTextColor
+            placeholder = OWSLocalizedString(
+                "USERNAME_PLACEHOLDER",
+                comment: "The placeholder for the username text entry in the username view."
+            )
+
+            returnKeyType = .default
+            autocorrectionType = .no
+            spellCheckingType = .no
+            accessibilityIdentifier = "username_textfield"
+
+            rightView = discriminatorView
+            rightViewMode = .always
+        }
+
+        @available(*, unavailable, message: "Use other constructor")
+        required init?(coder: NSCoder) {
+            fatalError("Use other constructor!")
+        }
+
+        // MARK: - Configure
+
+        /// Configure the text field for an in-progress reservation.
+        func configureForReservationInProgress() {
+            if let lastKnownGoodDiscriminator {
+                discriminatorView.mode = .spinningWithDiscriminator(value: lastKnownGoodDiscriminator)
+            } else {
+                discriminatorView.mode = .spinning
+            }
+        }
+
+        /// Configure the text field for an error state.
+        func configureForError() {
+            if let lastKnownGoodDiscriminator {
+                discriminatorView.mode = .discriminator(value: lastKnownGoodDiscriminator)
+            } else {
+                discriminatorView.mode = .empty
+            }
+        }
+
+        /// Configure the text field for a confirmed username. If `nil`,
+        /// configures for the intentional absence of a username.
+        func configure(forConfirmedUsername confirmedUsername: ParsedUsername?) {
+            if let confirmedUsername {
+                lastKnownGoodDiscriminator = confirmedUsername.discriminator
+                discriminatorView.mode = .discriminator(value: confirmedUsername.discriminator)
+            } else {
+                lastKnownGoodDiscriminator = nil
+                discriminatorView.mode = .empty
+            }
+        }
+
+        // MARK: - Getters
+
+        /// Returns the user-visible nickname contents with normalizations
+        /// applied. Note that nicknames by definition do not contain the
+        /// discriminator.
+        ///
+        /// - Returns
+        /// The normalized contents of the text field. If the returned value
+        /// would be empty, returns `nil` instead.
+        var normalizedNickname: String? {
+            return text?.lowercased().nilIfEmpty
+        }
+    }
+}
diff --git a/Signal/src/Usernames/UsernameSelectionViewController.swift b/Signal/src/Usernames/UsernameSelectionViewController.swift
new file mode 100644
index 00000000000..38e14ef0b60
--- /dev/null
+++ b/Signal/src/Usernames/UsernameSelectionViewController.swift
@@ -0,0 +1,656 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import BonMot
+import Foundation
+import SignalMessaging
+
+/// Provides UX allowing a user to select or delete a username for their
+/// account.
+///
+/// Usernames consist of a user-chosen "nickname" and a programmatically-
+/// generated numeric "discriminator", which are then concatenated.
+class UsernameSelectionViewController: OWSTableViewController2 {
+
+    /// A wrapper for injected dependencies.
+    struct Context {
+        let networkManager: NetworkManager
+        let databaseStorage: SDSDatabaseStorage
+        let profileManager: ProfileManagerProtocol
+    }
+
+    enum Constants {
+        /// Minimum length for a nickname, in Unicode code points.
+        static let minNicknameCodepointLength: UInt = 3
+
+        /// Maximum length for a nickname, in Unicode code points.
+        static let maxNicknameCodepointLength: UInt = 32
+
+        /// Amount of time to wait after the username text field is edited
+        /// before kicking off a reservation attempt.
+        static let reservationDebounceTimeInternal: TimeInterval = 0.5
+    }
+
+    /// A logger for username-selection-related events.
+    private class UsernameLogger: PrefixedLogger {
+        static let shared: UsernameLogger = .init()
+
+        private init() {
+            super.init(prefix: "[Username Selection]")
+        }
+    }
+
+    private enum UsernameSelectionState: Equatable {
+        /// The user's existing username is unchanged.
+        case noChangesToExisting
+        /// The user's existing username should be deleted.
+        case shouldDelete
+        /// The username is pending reservation. Stores an attempt ID, to
+        /// disambiguate multiple potentially-overlapping reservation
+        /// attempts.
+        case reservationPending(attemptId: UUID)
+        /// The username has been successfully reserved.
+        case reservationSuccessful(reservation: API.SuccessfulReservation)
+        /// The username was rejected by the server during reservation.
+        case reservationRejected
+        /// The reservation failed, for an unknown reason.
+        case reservationFailed
+        /// The username is too short.
+        case tooShort
+        /// The username is too long.
+        case tooLong
+        /// The username contains invalid characters.
+        case invalidCharacters
+    }
+
+    typealias ParsedUsername = Usernames.ParsedUsername
+    typealias API = Usernames.API
+
+    // MARK: - Init
+
+    /// Backing value for ``currentUsernameState``. Do not access directly!
+    private var _currentUsernameState: UsernameSelectionState = .noChangesToExisting {
+        didSet {
+            AssertIsOnMainThread()
+
+            guard
+                oldValue != currentUsernameState,
+                isViewLoaded
+            else {
+                return
+            }
+
+            updateTableContents()
+            updateNavigation()
+        }
+    }
+
+    /// Represents the current state of username selection. Must only be
+    /// accessed on the main thread.
+    private var currentUsernameState: UsernameSelectionState {
+        get {
+            AssertIsOnMainThread()
+
+            return _currentUsernameState
+        }
+        set {
+            AssertIsOnMainThread()
+
+            _currentUsernameState = newValue
+        }
+    }
+
+    /// A pre-existing username this controller was seeded with.
+    private let existingUsername: ParsedUsername?
+
+    /// Injected dependencies.
+    private let context: Context
+
+    private let nicknameValidator: Usernames.NicknameValidator = .init(
+        minCodepoints: Constants.minNicknameCodepointLength,
+        maxCodepoints: Constants.maxNicknameCodepointLength
+    )
+
+    private lazy var apiManager: Usernames.API = {
+        .init(networkManager: context.networkManager)
+    }()
+
+    init(existingUsername: ParsedUsername?, context: Context) {
+        self.existingUsername = existingUsername
+        self.context = context
+
+        super.init()
+
+        usernameTextField.delegate = self
+        usernameTextField.addTarget(self, action: #selector(usernameTextFieldContentsDidChange), for: .editingChanged)
+
+        shouldAvoidKeyboard = true
+    }
+
+    /// Whether the user has edited the username to a value other than what we
+    /// started with.
+    var hasUnsavedEdits: Bool {
+        if case .noChangesToExisting = currentUsernameState {
+            return false
+        }
+
+        return true
+    }
+
+    // MARK: Views
+
+    /// Navbar button for finishing this view.
+    private lazy var doneBarButtonItem: UIBarButtonItem = {
+        UIBarButtonItem(
+            title: CommonStrings.doneButton,
+            style: .done,
+            target: self,
+            action: #selector(didTapDone),
+            accessibilityIdentifier: "done_button"
+        )
+    }()
+
+    /// Manages editing of the nickname and presents additional visual state
+    /// such as the current discriminator.
+    private lazy var usernameTextField: UsernameTextField = {
+        .init(forUsername: existingUsername)
+    }()
+
+    /// An ``NSAttributedString`` containing styled text to use as the footer
+    /// for the username text field. Dynamically assembled as appropriate for
+    /// the current internal state.
+    private var usernameFooterStyled: NSAttributedString {
+        var components = [Composable]()
+
+        let errorText: String? = {
+            switch currentUsernameState {
+            case
+                    .noChangesToExisting,
+                    .shouldDelete,
+                    .reservationPending,
+                    .reservationSuccessful:
+                return nil
+            case .reservationRejected:
+                // TODO: [Usernames] Verify copy
+                return "This username is not available"
+            case .reservationFailed:
+                // TODO: [Usernames] Verify copy
+                return "Unable to reserve username. Please try again later."
+            case .tooShort:
+                return OWSLocalizedString(
+                    "USERNAME_TOO_SHORT_ERROR",
+                    comment: "An error indicating that the supplied username is too short."
+                )
+            case .tooLong:
+                owsFail("This should be impossible from the UI, as we limit the text field length.")
+            case .invalidCharacters:
+                // TODO: [Usernames] Verify copy
+                return OWSLocalizedString(
+                    "USERNAME_INVALID_CHARACTERS_ERROR",
+                    comment: "An error indicating that the supplied username contains disallowed characters."
+                )
+            }
+        }()
+
+        if let errorText {
+            components.append(errorText.styled(with: .color(.ows_accentRed)))
+            components.append("\n\n")
+        }
+
+        components.append(OWSLocalizedString(
+            "USERNAME_DESCRIPTION",
+            comment: "An explanation of how usernames work on the username view."
+        ))
+
+        return NSAttributedString
+            .composed(of: components)
+            .styled(
+                with: .font(.ows_dynamicTypeCaption1Clamped),
+                .color(Theme.secondaryTextAndIconColor)
+            )
+    }
+
+    // MARK: View lifecycle
+
+    override func themeDidChange() {
+        super.themeDidChange()
+
+        updateTableContents()
+        updateNavigation()
+    }
+
+    /// Only allow gesture-based dismissal when there have been no edits.
+    override var isModalInPresentation: Bool {
+        get { hasUnsavedEdits }
+        set {}
+    }
+
+    override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = OWSLocalizedString(
+            "USERNAME_TITLE",
+            comment: "The title for the username view."
+        )
+
+        navigationItem.leftBarButtonItem = UIBarButtonItem(
+            barButtonSystemItem: .cancel,
+            target: self,
+            action: #selector(didTapCancel),
+            accessibilityIdentifier: "cancel_button"
+        )
+
+        navigationItem.rightBarButtonItem = doneBarButtonItem
+
+        updateTableContents()
+        updateNavigation()
+    }
+
+    override func viewWillAppear(_ animated: Bool) {
+        usernameTextField.becomeFirstResponder()
+    }
+}
+
+// MARK: - Configure views
+
+private extension UsernameSelectionViewController {
+    /// Update the table contents to reflect the current internal state.
+    private func updateTableContents() {
+        let contents = OWSTableContents()
+
+        let usernameTextFieldSection: OWSTableSection = {
+            let section = OWSTableSection()
+
+            section.add(.init(
+                customCellBlock: { [weak self] in
+                    guard let self else { return UITableViewCell() }
+                    let cell = OWSTableItem.newCell()
+
+                    cell.selectionStyle = .none
+                    cell.addSubview(self.usernameTextField)
+
+                    self.usernameTextField.autoPinEdgesToSuperviewMargins()
+                    switch self.currentUsernameState {
+                    case .noChangesToExisting:
+                        self.usernameTextField.configure(forConfirmedUsername: self.existingUsername)
+                    case .shouldDelete:
+                        self.usernameTextField.configure(forConfirmedUsername: nil)
+                    case .reservationPending:
+                        self.usernameTextField.configureForReservationInProgress()
+                    case let .reservationSuccessful(reservation):
+                        self.usernameTextField.configure(forConfirmedUsername: reservation.username)
+                    case
+                            .reservationRejected,
+                            .reservationFailed,
+                            .tooShort,
+                            .tooLong,
+                            .invalidCharacters:
+                        self.usernameTextField.configureForError()
+                    }
+
+                    return cell
+                },
+                actionBlock: nil
+            ))
+
+            section.footerAttributedTitle = usernameFooterStyled
+
+            return section
+        }()
+
+        contents.addSection(usernameTextFieldSection)
+
+        let usernameTextFieldIsFirstResponder = usernameTextField.isFirstResponder
+
+        self.contents = contents
+
+        if usernameTextFieldIsFirstResponder {
+            // By setting contents, we will steal first responder. We should
+            // give it back.
+            usernameTextField.becomeFirstResponder()
+        }
+    }
+
+    /// Update the nav bar items to reflect the current internal state.
+    private func updateNavigation() {
+        doneBarButtonItem.isEnabled = {
+            switch currentUsernameState {
+            case
+                    .reservationSuccessful,
+                    .shouldDelete:
+                return true
+            case
+                    .noChangesToExisting,
+                    .reservationPending,
+                    .reservationRejected,
+                    .reservationFailed,
+                    .tooShort,
+                    .tooLong,
+                    .invalidCharacters:
+                return false
+            }
+        }()
+    }
+}
+
+// MARK: - Nav bar events
+
+private extension UsernameSelectionViewController {
+    /// Called when the user cancels editing. Dismisses the view, discarding
+    /// unsaved changes.
+    @objc
+    private func didTapCancel() {
+        guard hasUnsavedEdits else {
+            dismiss(animated: true)
+            return
+        }
+
+        OWSActionSheets.showPendingChangesActionSheet(discardAction: { [weak self] in
+            guard let self else { return }
+            self.dismiss(animated: true)
+        })
+    }
+
+    /// Called when the user taps "Done". Attempts to finalize the new chosen
+    /// username.
+    @objc
+    private func didTapDone() {
+        let usernameState = self.currentUsernameState
+
+        switch usernameState {
+        case let .reservationSuccessful(reservation):
+            self.confirmReservationBehindModalActivityIndicator(
+                reservation: reservation
+            )
+        case .shouldDelete:
+            self.deleteCurrentUsernameBehindActivityIndicator()
+        case
+                .noChangesToExisting,
+                .reservationPending,
+                .reservationRejected,
+                .reservationFailed,
+                .tooShort,
+                .tooLong,
+                .invalidCharacters:
+            owsFail("Unexpected username state: \(usernameState). Should be impossible from the UI!")
+        }
+    }
+
+    /// Confirm the given reservation, with an activity indicator blocking the
+    /// UI.
+    private func confirmReservationBehindModalActivityIndicator(
+        reservation: API.SuccessfulReservation
+    ) {
+        ModalActivityIndicatorViewController.present(
+            fromViewController: self,
+            canCancel: false
+        ) { modal in
+            UsernameLogger.shared.info("Confirming username.")
+
+            firstly { () -> Promise<API.ConfirmationResult> in
+                self.apiManager.attemptToConfirm(reservation: reservation)
+            }.done(on: .main) { result -> Void in
+                switch result {
+                case let .success(confirmedUsername):
+                    UsernameLogger.shared.info("Confirmed username!")
+
+                    self.persistNewUsernameValueAndDismiss(
+                        usernameValue: confirmedUsername,
+                        presentedModalActivityIndicator: modal
+                    )
+                case .rejected:
+                    UsernameLogger.shared.error("Failed to confirm the username, server rejected.")
+
+                    // TODO: [Usernames] Verify copy
+                    let errorMessage = "Failed to set the username."
+                    self.dismiss(
+                        modalActivityIndicator: modal,
+                        andPresentErrorMessage: errorMessage
+                    )
+                case .rateLimited:
+                    UsernameLogger.shared.error("Failed to confirm the username, rate-limited.")
+
+                    // TODO: [Usernames] Verify copy
+                    let errorMessage = "Failed to set the username. Please try again later."
+                    self.dismiss(
+                        modalActivityIndicator: modal,
+                        andPresentErrorMessage: errorMessage
+                    )
+                }
+            }.catch(on: .main) { error in
+                UsernameLogger.shared.error("Error while confirming username: \(error)")
+
+                // TODO: [Usernames] Verify copy
+                let errorMessage = "Something went wrong, unable to set username."
+                self.dismiss(
+                    modalActivityIndicator: modal,
+                    andPresentErrorMessage: errorMessage
+                )
+            }
+        }
+    }
+
+    /// Delete the user's existing username, with an activity indicator
+    /// blocking the UI. Prompts the user first to confirm deletion.
+    private func deleteCurrentUsernameBehindActivityIndicator() {
+        // TODO: [Usernames] Verify copy
+        let confirmDeletionActionSheet = ActionSheetController(
+            title: "Are you sure you want to delete your username?"
+        )
+
+        // TODO: [Usernames] Verify copy
+        let confirmAction = ActionSheetAction(title: "Delete", style: .destructive) { _ in
+            ModalActivityIndicatorViewController.present(
+                fromViewController: self,
+                canCancel: false
+            ) { modal in
+                UsernameLogger.shared.warn("Deleting existing username.")
+
+                firstly {
+                    self.apiManager.attemptToDeleteCurrentUsername()
+                }.map(on: .main) {
+                    UsernameLogger.shared.info("Username deleted!")
+
+                    self.persistNewUsernameValueAndDismiss(
+                        usernameValue: nil,
+                        presentedModalActivityIndicator: modal
+                    )
+                }.catch(on: .main) { error in
+                    UsernameLogger.shared.error("Error while deleting username: \(error)")
+
+                    // TODO: [Usernames] Verify copy
+                    let errorMessage = "Something went wrong, unable to delete username."
+                    self.dismiss(
+                        modalActivityIndicator: modal,
+                        andPresentErrorMessage: errorMessage
+                    )
+                }
+            }
+        }
+
+        confirmDeletionActionSheet.addAction(confirmAction)
+        presentActionSheet(confirmDeletionActionSheet)
+    }
+
+    /// Persist the given username value, dismiss the given activity indicator,
+    /// then dismiss the current view.
+    /// - Parameter usernameValue
+    /// A new username value. `nil` if the username was deleted.
+    /// - Parameter presentedModalActivityIndicator
+    /// A currently-presented modal activity indicator to be dismissed.
+    private func persistNewUsernameValueAndDismiss(
+        usernameValue: String?,
+        presentedModalActivityIndicator modal: ModalActivityIndicatorViewController
+    ) {
+        self.context.databaseStorage.write { transaction in
+            self.context.profileManager.updateLocalUsername(
+                usernameValue,
+                userProfileWriter: .localUser,
+                transaction: transaction
+            )
+        }
+
+        modal.dismiss(animated: false) {
+            self.dismiss(animated: true)
+        }
+    }
+
+    /// Dismiss the given activity indicator and then present an error message
+    /// action sheet.
+    private func dismiss(
+        modalActivityIndicator modal: ModalActivityIndicatorViewController,
+        andPresentErrorMessage errorMessage: String
+    ) {
+        modal.dismiss(animated: false) {
+            OWSActionSheets.showErrorAlert(message: errorMessage)
+        }
+    }
+}
+
+// MARK: - Text field events
+
+private extension UsernameSelectionViewController {
+    /// Called when the contents of the username text field have changed, and
+    /// sets local state as appropriate. If the username is believed to be
+    /// valid, kicks off a reservation attempt.
+    @objc
+    private func usernameTextFieldContentsDidChange() {
+        AssertIsOnMainThread()
+
+        UsernameLogger.shared.debug("Username text field contents changed...")
+
+        let nicknameFromTextField: String? = usernameTextField.normalizedNickname
+
+        if existingUsername?.nickname == nicknameFromTextField {
+            currentUsernameState = .noChangesToExisting
+        } else if let desiredNickname = nicknameFromTextField {
+            // We have an entered nickname
+            switch nicknameValidator.validate(desiredNickname: desiredNickname) {
+            case .success:
+                attemptReservationAndUpdateValidationState(
+                    forDesiredNickname: desiredNickname
+                )
+            case .invalidCharacters:
+                currentUsernameState = .invalidCharacters
+            case .tooLong:
+                currentUsernameState = .tooLong
+            case .tooShort:
+                currentUsernameState = .tooShort
+            }
+        } else {
+            // We have an existing username, but no entered nickname.
+            currentUsernameState = .shouldDelete
+        }
+    }
+
+    /// Attempts to reserve the given nickname, and updates ``validationState``
+    /// as appropriate.
+    ///
+    /// The desired nickname might change while prior reservation attempts are
+    /// in-flight. In order to disambiguate between reservation attempts, we
+    /// track an "attempt ID" that represents the current reservation attempt.
+    /// If a reservation completes successfully but the current attempt ID does
+    /// not match the ID with which the reservation was initiated, we discard
+    /// the result (as we have moved on to another desired nickname).
+    private func attemptReservationAndUpdateValidationState(
+        forDesiredNickname desiredNickname: String
+    ) {
+        AssertIsOnMainThread()
+
+        struct ReservationNotAttemptedError: Error {
+            let attemptId: UUID
+        }
+
+        firstly { () -> Guarantee<UUID> in
+            let attemptId = UUID()
+
+            currentUsernameState = .reservationPending(attemptId: attemptId)
+
+            // Delay to detect multiple rapid consecutive edits.
+            return Guarantee
+                .after(wallInterval: Constants.reservationDebounceTimeInternal)
+                .map(on: .main) { attemptId }
+        }.then(on: .main) { thisAttemptId throws -> Promise<API.ReservationResult> in
+            // If this attempt is no longer current after debounce, we should
+            // bail out without firing a reservation.
+            guard
+                case let .reservationPending(currentAttemptId) = self.currentUsernameState,
+                thisAttemptId == currentAttemptId
+            else {
+                UsernameLogger.shared.debug("Not attempting to reserve, attempt is outdated. Attempt ID: \(thisAttemptId)")
+                throw ReservationNotAttemptedError(attemptId: thisAttemptId)
+            }
+
+            UsernameLogger.shared.info("Attempting to reserve username. Attempt ID: \(thisAttemptId)")
+
+            return self.apiManager.attemptToReserve(
+                desiredNickname: desiredNickname,
+                attemptId: thisAttemptId
+            )
+        }.done(on: .main) { [weak self] reservationResult -> Void in
+            guard let self else { return }
+
+            // If the reservation we just attempted is not current, we should
+            // drop it and bail out.
+            guard
+                case let .reservationPending(attemptId) = self.currentUsernameState,
+                reservationResult.attemptId == attemptId
+            else {
+                UsernameLogger.shared.info("Dropping reservation result, attempt is outdated. Attempt ID: \(reservationResult.attemptId)")
+                return
+            }
+
+            switch reservationResult.state {
+            case let .successful(reservation):
+                UsernameLogger.shared.info("Successfully reserved nickname! Attempt ID: \(attemptId)")
+
+                self.currentUsernameState = .reservationSuccessful(reservation: reservation)
+            case .rejected:
+                UsernameLogger.shared.warn("Reservation rejected. Attempt ID: \(attemptId)")
+
+                self.currentUsernameState = .reservationRejected
+            case .rateLimited:
+                UsernameLogger.shared.error("Reservation rate-limited. Attempt ID: \(attemptId)")
+
+                // Hides the rate-limited error, but not incorrect.
+                self.currentUsernameState = .reservationFailed
+            }
+        }.catch(on: .main) { [weak self] error in
+            guard let self else { return }
+
+            if let error = error as? ReservationNotAttemptedError {
+                UsernameLogger.shared.debug("Reservation was not attempted. Attempt ID: \(error.attemptId)")
+                return
+            }
+
+            self.currentUsernameState = .reservationFailed
+
+            if let error = error as? API.ReservationError {
+                UsernameLogger.shared.error("Reservation failed with error \(error.underlying). Attempt ID: \(error.attemptId)")
+            } else {
+                owsFailDebug("Reservation failed with unexpected error \(error)!")
+            }
+        }
+    }
+}
+
+// MARK: - UITextFieldDelegate
+
+extension UsernameSelectionViewController: UITextFieldDelegate {
+    /// Called when user action would result in changed contents in the text
+    /// field.
+    func textField(
+        _ textField: UITextField,
+        shouldChangeCharactersIn range: NSRange,
+        replacementString string: String
+    ) -> Bool {
+        return TextFieldHelper.textField(
+            textField,
+            shouldChangeCharactersInRange: range,
+            replacementString: string,
+            maxUnicodeScalarCount: Int(Constants.maxNicknameCodepointLength)
+        )
+    }
+}
diff --git a/Signal/src/Usernames/Usernames+API.swift b/Signal/src/Usernames/Usernames+API.swift
new file mode 100644
index 00000000000..84fbb01bb91
--- /dev/null
+++ b/Signal/src/Usernames/Usernames+API.swift
@@ -0,0 +1,232 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+extension Usernames {
+    /// Manages interactions with username-related APIs.
+    struct API {
+        private let networkManager: NetworkManager
+
+        init(networkManager: NetworkManager) {
+            self.networkManager = networkManager
+        }
+
+        private func performRequest<T>(
+            request: TSRequest,
+            onSuccess: @escaping (HTTPResponse) throws -> T,
+            onFailure: @escaping (Error) throws -> T
+        ) -> Promise<T> {
+            firstly {
+                networkManager.makePromise(request: request)
+            }.map(on: .sharedUserInitiated) { response throws in
+                try onSuccess(response)
+            }.recover(on: .sharedUserInitiated) { error throws -> Promise<T> in
+                .value(try onFailure(error))
+            }
+        }
+    }
+}
+
+// MARK: - Reservation
+
+extension Usernames.API {
+    struct SuccessfulReservation: Equatable {
+        /// The raw reserved username, including a numeric discriminator suffix.
+        fileprivate let rawUsername: String
+
+        /// The reserved username.
+        let username: Usernames.ParsedUsername
+
+        /// A token representing the reservation, which is used to later
+        /// confirm the username.
+        let reservationToken: String
+    }
+
+    struct ReservationResult {
+        enum State {
+            case successful(reservation: SuccessfulReservation)
+            case rejected
+            case rateLimited
+        }
+
+        let attemptId: UUID
+        let state: State
+    }
+
+    struct ReservationError: Error {
+        let attemptId: UUID
+        let underlying: Error
+    }
+
+    /// Attempts to reserve the given nickname.
+    ///
+    /// - Parameter desiredNickname
+    /// A non-discriminator-suffixed nickname that the client believes is valid.
+    /// - Parameter attemptId
+    /// An ID for this attempt, to later disambiguate between multiple
+    /// potentially-overlapping attempts.
+    func attemptToReserve(
+        desiredNickname: String,
+        attemptId: UUID
+    ) -> Promise<ReservationResult> {
+        let request = OWSRequestFactory.reserveUsernameRequest(
+            desiredNickname: desiredNickname
+        )
+
+        func makeReservationError(from error: Error) -> ReservationError {
+            .init(attemptId: attemptId, underlying: error)
+        }
+
+        func onRequestSuccess(response: HTTPResponse) throws -> ReservationResult {
+            guard response.responseStatusCode == 200 else {
+                throw makeReservationError(
+                    from: OWSAssertionError("Unexpected status code from successful request: \(response.responseStatusCode)")
+                )
+            }
+
+            guard let parser = ParamParser(responseObject: response.responseBodyJson) else {
+                throw makeReservationError(
+                    from: OWSAssertionError("Unexpectedly missing JSON response body!")
+                )
+            }
+
+            let usernameString: String = try parser.required(key: "username")
+            let reservationToken: String = try parser.required(key: "reservationToken")
+
+            guard let parsedUsername = Usernames.ParsedUsername(rawUsername: usernameString) else {
+                throw OWSAssertionError("Username string was not parseable!")
+            }
+
+            let successState: ReservationResult.State = .successful(reservation: SuccessfulReservation(
+                rawUsername: usernameString,
+                username: parsedUsername,
+                reservationToken: reservationToken
+            ))
+
+            return .init(attemptId: attemptId, state: successState)
+        }
+
+        func onRequestFailure(error: Error) throws -> ReservationResult {
+            guard let statusCode = error.httpStatusCode else {
+                throw makeReservationError(from: error)
+            }
+
+            let resultState = try { () throws -> ReservationResult.State in
+                switch statusCode {
+                case 422, 409:
+                    // 422 indicates a nickname that failed to validate.
+                    //
+                    // 409 indicates that either the server failed to generate a
+                    // discriminator, or the desired username is forbidden.
+                    //
+                    // Either way, the reservation has been rejected.
+                    return .rejected
+                case 413:
+                    return .rateLimited
+                default:
+                    throw makeReservationError(
+                        from: OWSAssertionError("Unexpected status code: \(statusCode)!")
+                    )
+                }
+            }()
+
+            return .init(attemptId: attemptId, state: resultState)
+        }
+
+        return performRequest(
+            request: request,
+            onSuccess: onRequestSuccess,
+            onFailure: onRequestFailure
+        )
+    }
+}
+
+// MARK: - Confirmation
+
+extension Usernames.API {
+    enum ConfirmationResult {
+        /// The reservation was successfully confirmed.
+        case success(confirmedUsername: String)
+        /// The reservation was rejected. This may be because we no longer hold
+        /// the reservation, the reservation lapsed, or something about the
+        /// reservation was invalid.
+        case rejected
+        /// The reservation failed because we have been rate-limited.
+        case rateLimited
+    }
+
+    func attemptToConfirm(
+        reservation: SuccessfulReservation
+    ) -> Promise<ConfirmationResult> {
+        let request = OWSRequestFactory.confirmReservedUsernameRequest(
+            previouslyReservedUsername: reservation.rawUsername,
+            reservationToken: reservation.reservationToken
+        )
+
+        func onRequestSuccess(response: HTTPResponse) throws -> ConfirmationResult {
+            guard response.responseStatusCode == 200 else {
+                throw OWSAssertionError("Unexpected status code from successful request: \(response.responseStatusCode)")
+            }
+
+            return .success(confirmedUsername: reservation.rawUsername)
+        }
+
+        func onRequestFailure(error: Error) throws -> ConfirmationResult {
+            guard let statusCode = error.httpStatusCode else {
+                owsFailDebug("Unexpectedly missing HTTP status code!")
+                throw error
+            }
+
+            switch statusCode {
+            case 409, 410:
+                // 409 indicates that we do not actually hold the reservation
+                // we thought we did, either because we never did or because we
+                // have made a different reservation since.
+                //
+                // 410 indicates that our reservation has lapsed, and another
+                // account has snagged the username - or that the reservation
+                // token is invalid.
+                //
+                // Either way, we've been rejected.
+                return .rejected
+            case 413:
+                return .rateLimited
+            default:
+                throw OWSAssertionError("Unexpected status code: \(statusCode)")
+            }
+        }
+
+        return performRequest(
+            request: request,
+            onSuccess: onRequestSuccess,
+            onFailure: onRequestFailure
+        )
+    }
+}
+
+// MARK: - Deletion
+
+extension Usernames.API {
+    func attemptToDeleteCurrentUsername() -> Promise<Void> {
+        let request = OWSRequestFactory.deleteExistingUsernameRequest()
+
+        func onRequestSuccess(response: HTTPResponse) throws {
+            guard response.responseStatusCode == 204 else {
+                throw OWSAssertionError("Unexpected status code from successful request: \(response.responseStatusCode)")
+            }
+        }
+
+        func onRequestFailure(error: Error) throws {
+            throw error
+        }
+
+        return performRequest(
+            request: request,
+            onSuccess: onRequestSuccess,
+            onFailure: onRequestFailure
+        )
+    }
+}
diff --git a/Signal/src/Usernames/Usernames+NicknameValidator.swift b/Signal/src/Usernames/Usernames+NicknameValidator.swift
new file mode 100644
index 00000000000..8e055ebf81c
--- /dev/null
+++ b/Signal/src/Usernames/Usernames+NicknameValidator.swift
@@ -0,0 +1,54 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+extension Usernames {
+    /// Provides validation for "nicknames", i.e. the user-generated portion of
+    /// a username (without the numeric discriminator).
+    struct NicknameValidator {
+        enum ValidationResult {
+            case tooShort
+            case tooLong
+            case invalidCharacters
+            case success
+        }
+
+        /// A regex to check the validity of a nickname. The first character may be
+        /// in [_a-zA-Z], and all subsequent characters may also be decimal digits.
+        private static let nicknameValidityRegex: NSRegularExpression = try! .init(pattern: "^[_a-zA-Z][_a-zA-Z0-9]*$")
+
+        /// Minimum number of Unicode codepoints for a nickname.
+        private let minCodepoints: UInt
+
+        /// Maximum number of Unicode codepoints for a nickname.
+        private let maxCodepoints: UInt
+
+        init(minCodepoints: UInt, maxCodepoints: UInt) {
+            self.minCodepoints = minCodepoints
+            self.maxCodepoints = maxCodepoints
+        }
+
+        /// Performs limited client-side validation on the given nickname. Any
+        /// normalization should be performed prior to calling this method.
+        func validate(desiredNickname nickname: String) -> ValidationResult {
+            let unicodePointsCount = nickname.unicodeScalars.count
+
+            guard unicodePointsCount >= minCodepoints else {
+                return .tooShort
+            }
+
+            guard unicodePointsCount <= maxCodepoints else {
+                return .tooLong
+            }
+
+            guard Self.nicknameValidityRegex.hasMatch(input: nickname) else {
+                return .invalidCharacters
+            }
+
+            return .success
+        }
+    }
+}
diff --git a/Signal/src/Usernames/Usernames+ParsedUsername.swift b/Signal/src/Usernames/Usernames+ParsedUsername.swift
new file mode 100644
index 00000000000..a6c39e67eda
--- /dev/null
+++ b/Signal/src/Usernames/Usernames+ParsedUsername.swift
@@ -0,0 +1,41 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+extension Usernames {
+    /// Represents a username parsed into its user-generated nickname and
+    /// programmatically-generated numeric discriminator.
+    struct ParsedUsername: Equatable {
+        static let separator: Character = "."
+
+        let nickname: String
+        let discriminator: String
+
+        init?(rawUsername: String?) {
+            guard let rawUsername else {
+                return nil
+            }
+
+            let components = rawUsername.split(separator: Self.separator)
+
+            guard components.count == 2 else {
+                owsFailDebug("Unexpected component count!")
+                return nil
+            }
+
+            guard
+                let nickname = String(components.first!).nilIfEmpty,
+                let discriminator = String(components.last!).nilIfEmpty
+            else {
+                owsFailDebug("Nickname or discriminator was empty!")
+                return nil
+            }
+
+            self.nickname = nickname
+            self.discriminator = discriminator
+        }
+    }
+}
diff --git a/Signal/src/Usernames/Usernames.swift b/Signal/src/Usernames/Usernames.swift
new file mode 100644
index 00000000000..5ce07e44322
--- /dev/null
+++ b/Signal/src/Usernames/Usernames.swift
@@ -0,0 +1,9 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+/// A namespace for username-related models.
+enum Usernames {}
diff --git a/Signal/src/ViewControllers/AppSettings/Profile/ProfileSettingsViewController.swift b/Signal/src/ViewControllers/AppSettings/Profile/ProfileSettingsViewController.swift
index 26d1aa2f26e..51bc90bd0c6 100644
--- a/Signal/src/ViewControllers/AppSettings/Profile/ProfileSettingsViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/Profile/ProfileSettingsViewController.swift
@@ -109,8 +109,18 @@ class ProfileSettingsViewController: OWSTableViewController2 {
                 ),
                 accessibilityIdentifier: UIView.accessibilityIdentifier(in: self, name: "username"),
                 actionBlock: { [weak self] in
-                    let vc = UsernameViewController(username: self?.username)
-                    self?.presentFormSheet(OWSNavigationController(rootViewController: vc), animated: true)
+                    guard let self else { return }
+
+                    let vc = UsernameSelectionViewController(
+                        existingUsername: .init(rawUsername: self.username),
+                        context: .init(
+                            networkManager: self.networkManager,
+                            databaseStorage: self.databaseStorage,
+                            profileManager: self.profileManager
+                        )
+                    )
+
+                    self.presentFormSheet(OWSNavigationController(rootViewController: vc), animated: true)
                 }
             ))
         }
diff --git a/Signal/src/ViewControllers/AppSettings/Profile/UsernameViewController.swift b/Signal/src/ViewControllers/AppSettings/Profile/UsernameViewController.swift
deleted file mode 100644
index 29d2590083a..00000000000
--- a/Signal/src/ViewControllers/AppSettings/Profile/UsernameViewController.swift
+++ /dev/null
@@ -1,327 +0,0 @@
-//
-// Copyright 2021 Signal Messenger, LLC
-// SPDX-License-Identifier: AGPL-3.0-only
-//
-
-import BonMot
-import Foundation
-import SignalMessaging
-import UIKit
-
-@objc
-class UsernameViewController: OWSTableViewController2 {
-    private let usernameTextField = OWSTextField()
-    private let originalUsername: String?
-
-    private static let minimumUsernameLength = 4
-    private static let maximumUsernameLength: Int = 26
-
-    private enum ValidationState {
-        case valid
-        case tooShort
-        case invalidCharacters
-        case inUse
-        case startsWithNumber
-    }
-    private var validationState: ValidationState = .valid {
-        didSet {
-            let didChange = oldValue != validationState
-            if didChange, isViewLoaded {
-                updateTableContents()
-            }
-        }
-    }
-
-    required init(username: String?) {
-        self.originalUsername = username
-
-        super.init()
-
-        self.usernameTextField.text = username
-
-        self.shouldAvoidKeyboard = true
-    }
-
-    // MARK: -
-
-    public override func loadView() {
-        view = UIView()
-        createViews()
-    }
-
-    override func viewDidLoad() {
-        super.viewDidLoad()
-
-        updateNavigation()
-        updateTableContents()
-    }
-
-    private var normalizedUsername: String? {
-        let normalizedName = usernameTextField.text?.stripped.lowercased()
-        if normalizedName?.isEmpty == true { return nil }
-        return normalizedName
-    }
-
-    private var hasUnsavedChanges: Bool {
-        normalizedUsername != originalUsername
-    }
-    // Don't allow interactive dismiss when there are unsaved changes.
-    override var isModalInPresentation: Bool {
-        get { hasUnsavedChanges }
-        set {}
-    }
-
-    private func updateNavigation() {
-        title = NSLocalizedString("USERNAME_TITLE", comment: "The title for the username view.")
-
-        navigationItem.leftBarButtonItem = UIBarButtonItem(
-            barButtonSystemItem: .cancel,
-            target: self,
-            action: #selector(didTapCancel),
-            accessibilityIdentifier: "cancel_button"
-        )
-
-        if hasUnsavedChanges {
-            navigationItem.rightBarButtonItem = UIBarButtonItem(
-                title: CommonStrings.setButton,
-                style: .done,
-                target: self,
-                action: #selector(didTapDone),
-                accessibilityIdentifier: "set_button"
-            )
-        } else {
-            navigationItem.rightBarButtonItem = nil
-        }
-    }
-
-    public override func viewWillAppear(_ animated: Bool) {
-        super.viewWillAppear(animated)
-
-        updateNavigation()
-    }
-
-    public override func viewDidAppear(_ animated: Bool) {
-        super.viewDidAppear(animated)
-
-        updateNavigation()
-
-        usernameTextField.becomeFirstResponder()
-    }
-
-    private func createViews() {
-        usernameTextField.returnKeyType = .done
-        usernameTextField.autocorrectionType = .no
-        usernameTextField.spellCheckingType = .no
-        usernameTextField.placeholder = NSLocalizedString(
-            "USERNAME_PLACEHOLDER",
-            comment: "The placeholder for the username text entry in the username view."
-        )
-        usernameTextField.delegate = self
-        usernameTextField.accessibilityIdentifier = "username_textfield"
-        usernameTextField.addTarget(self, action: #selector(textFieldDidChange), for: .editingChanged)
-    }
-
-    private static let bioButtonHeight: CGFloat = 28
-
-    private func updateTableContents() {
-        let contents = OWSTableContents()
-
-        let section = OWSTableSection()
-
-        var footerComponents = [Composable]()
-
-        if let errorText = errorText {
-            footerComponents.append(errorText.styled(with: .color(.ows_accentRed)))
-            footerComponents.append("\n\n")
-        }
-
-        footerComponents.append(NSLocalizedString(
-            "USERNAME_DESCRIPTION",
-            comment: "An explanation of how usernames work on the username view."
-        ))
-
-        section.footerAttributedTitle = NSAttributedString.composed(of: footerComponents).styled(
-            with: .font(.ows_dynamicTypeCaption1Clamped),
-            .color(Theme.secondaryTextAndIconColor)
-        )
-
-        section.add(.init(customCellBlock: { [weak self] in
-            guard let self = self else { return UITableViewCell() }
-            return self.nameCell(textField: self.usernameTextField)
-        },
-            actionBlock: { [weak self] in
-                self?.usernameTextField.becomeFirstResponder()
-            }
-        ))
-        contents.addSection(section)
-
-        let wasFirstResponder = usernameTextField.isFirstResponder
-
-        self.contents = contents
-
-        if wasFirstResponder {
-            usernameTextField.becomeFirstResponder()
-        }
-    }
-
-    override func themeDidChange() {
-        super.themeDidChange()
-        updateTableContents()
-    }
-
-    private var errorText: String? {
-        switch validationState {
-        case .valid:
-            return nil
-        case .tooShort:
-            return NSLocalizedString(
-                "USERNAME_TOO_SHORT_ERROR",
-                comment: "An error indicating that the supplied username is too short."
-            )
-        case .invalidCharacters:
-            return NSLocalizedString(
-                "USERNAME_INVALID_CHARACTERS_ERROR",
-                comment: "An error indicating that the supplied username contains disallowed characters."
-            )
-        case .inUse:
-            let unavailableErrorFormat = NSLocalizedString(
-                "USERNAME_UNAVAIALBE_ERROR_FORMAT",
-                comment: "An error indicating that the supplied username is in use by another user. Embeds {{requested username}}."
-            )
-
-            return String(format: unavailableErrorFormat, normalizedUsername ?? "")
-        case .startsWithNumber:
-            return NSLocalizedString(
-                "USERNAME_STARTS_WITH_NUMBER_ERROR",
-                comment: "An error indicating that the supplied username cannot start with a number."
-            )
-        }
-    }
-
-    private func nameCell(textField: UITextField) -> UITableViewCell {
-        let cell = OWSTableItem.newCell()
-
-        cell.selectionStyle = .none
-
-        textField.font = .ows_dynamicTypeBodyClamped
-        textField.textColor = Theme.primaryTextColor
-
-        cell.addSubview(textField)
-        textField.autoPinEdgesToSuperviewMargins()
-
-        return cell
-    }
-
-    @objc
-    func didTapCancel() {
-        guard hasUnsavedChanges else { return usernameSavedOrCanceled() }
-
-        OWSActionSheets.showPendingChangesActionSheet(discardAction: { [weak self] in
-            self?.usernameSavedOrCanceled()
-        })
-    }
-
-    @objc
-    func didTapDone() {
-        // If we're trying to save, but we have nothing to save, just dismiss immediately.
-        guard hasUnsavedChanges else { return usernameSavedOrCanceled() }
-
-        guard usernameIsValid() else { return }
-
-        var usernameToUse: String? = normalizedUsername
-        if usernameToUse?.isEmpty == true { usernameToUse = nil }
-
-        ModalActivityIndicatorViewController.present(fromViewController: self, canCancel: false) { modalView in
-            let usernameRequest: TSRequest
-            if let usernameToUse = usernameToUse {
-                usernameRequest = OWSRequestFactory.usernameSetRequest(usernameToUse)
-            } else {
-                usernameRequest = OWSRequestFactory.usernameDeleteRequest()
-            }
-
-            firstly(on: .global()) {
-                Self.networkManager.makePromise(request: usernameRequest)
-            }.done(on: .main) { _ in
-                self.databaseStorage.write { transaction in
-                    Self.profileManagerImpl.updateLocalUsername(usernameToUse,
-                                                                userProfileWriter: .localUser,
-                                                                transaction: transaction)
-                }
-                modalView.dismiss {
-                    self.usernameSavedOrCanceled()
-                }
-            }.catch { error in
-                if error.httpStatusCode == 409 {
-                    modalView.dismiss { self.validationState = .inUse }
-                    return
-                }
-
-                owsFailDebug("Unexpected username update error \(error)")
-
-                modalView.dismiss {
-                    OWSActionSheets.showErrorAlert(message: NSLocalizedString("USERNAME_VIEW_ERROR_UPDATE_FAILED",
-                                                                        comment: "Error message shown when a username update fails."))
-                }
-            }
-        }
-    }
-
-    func usernameIsValid() -> Bool {
-        // We allow empty usernames, as this is how you delete your username
-        guard let normalizedUsername = normalizedUsername, !normalizedUsername.isEmpty else {
-            return true
-        }
-
-        guard normalizedUsername.count >= UsernameViewController.minimumUsernameLength else {
-            validationState = .tooShort
-            return false
-        }
-
-        // Usernames only allow a-z, 0-9, and underscore
-        let validUsernameRegex = try! NSRegularExpression(pattern: "^[a-z0-9_]+$", options: [])
-        guard validUsernameRegex.hasMatch(input: normalizedUsername) else {
-            validationState = .invalidCharacters
-            return false
-        }
-
-        let startsWithNumberRegex = try! NSRegularExpression(pattern: "^[0-9]+", options: [])
-        guard !startsWithNumberRegex.hasMatch(input: normalizedUsername) else {
-            validationState = .startsWithNumber
-            return false
-        }
-
-        return true
-    }
-
-    func usernameSavedOrCanceled() {
-        usernameTextField.resignFirstResponder()
-
-        dismiss(animated: true)
-    }
-}
-
-// MARK: -
-
-extension UsernameViewController: UITextFieldDelegate {
-    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
-        didTapDone()
-        return false
-    }
-
-    func textField(_ textField: UITextField,
-                   shouldChangeCharactersIn range: NSRange,
-                   replacementString string: String) -> Bool {
-        TextFieldHelper.textField(
-            textField,
-            shouldChangeCharactersInRange: range,
-            replacementString: string,
-            maxByteCount: UsernameViewController.maximumUsernameLength
-        )
-    }
-
-    @objc
-    func textFieldDidChange() {
-        validationState = .valid
-        updateNavigation()
-    }
-}
diff --git a/Signal/src/util/TextHelper.swift b/Signal/src/util/TextHelper.swift
index 3cb0bff271e..a24a3f43aa5 100644
--- a/Signal/src/util/TextHelper.swift
+++ b/Signal/src/util/TextHelper.swift
@@ -23,16 +23,20 @@ public class TextFieldHelper: NSObject {
                        maxGlyphCount: nil)
     }
 
-    public class func textField(_ textField: UITextField,
-                                shouldChangeCharactersInRange editingRange: NSRange,
-                                replacementString: String,
-                                maxByteCount: Int? = nil,
-                                maxGlyphCount: Int? = nil) -> Bool {
+    public class func textField(
+        _ textField: UITextField,
+        shouldChangeCharactersInRange editingRange: NSRange,
+        replacementString: String,
+        maxByteCount: Int? = nil,
+        maxUnicodeScalarCount: Int? = nil,
+        maxGlyphCount: Int? = nil
+    ) -> Bool {
         let (shouldChange, changedString) = TextHelper.shouldChangeCharactersInRange(
             with: textField.text,
             editingRange: editingRange,
             replacementString: replacementString,
             maxByteCount: maxByteCount,
+            maxUnicodeScalarCount: maxUnicodeScalarCount,
             maxGlyphCount: maxGlyphCount
         )
 
@@ -91,10 +95,11 @@ public enum TextHelper {
         editingRange: NSRange,
         replacementString: String,
         maxByteCount: Int? = nil,
+        maxUnicodeScalarCount: Int? = nil,
         maxGlyphCount: Int? = nil
     ) -> (shouldChange: Bool, changedString: String?) {
         // At least one must be set.
-        owsAssertDebug(maxByteCount != nil || maxGlyphCount != nil)
+        owsAssertDebug(maxByteCount != nil || maxGlyphCount != nil || maxUnicodeScalarCount != nil)
 
         func hasValidLength(_ string: String) -> Bool {
             if let maxByteCount = maxByteCount {
@@ -103,6 +108,12 @@ public enum TextHelper {
                     return false
                 }
             }
+            if let maxUnicodeScalarCount {
+                let unicodeScalarCount = string.unicodeScalars.count
+                guard unicodeScalarCount <= maxUnicodeScalarCount else {
+                    return false
+                }
+            }
             if let maxGlyphCount = maxGlyphCount {
                 let glyphCount = string.glyphCount
                 guard glyphCount <= maxGlyphCount else {
diff --git a/Signal/test/Usernames/Usernames+NicknameValidatorTests.swift b/Signal/test/Usernames/Usernames+NicknameValidatorTests.swift
new file mode 100644
index 00000000000..fdecdcd1a1f
--- /dev/null
+++ b/Signal/test/Usernames/Usernames+NicknameValidatorTests.swift
@@ -0,0 +1,72 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import XCTest
+@testable import Signal
+
+final class UsernamesNicknameValidatorTests: XCTestCase {
+    private typealias NicknameValidator = Usernames.NicknameValidator
+
+    private static let usernameTestCases: [(String, NicknameValidator.ValidationResult)] = [
+        // MARK: Too short
+
+        ("", .tooShort),
+        ("a", .tooShort),
+        ("ab", .tooShort),
+
+        // MARK: Too long
+
+        ("longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglong", .tooLong),
+
+        // MARK: Invalid characters
+
+        ("abcdef" + "", .invalidCharacters),
+        ("abcdef" + "", .invalidCharacters),
+        ("abcdef" + "", .invalidCharacters),
+        ("abcdef" + "+", .invalidCharacters),
+        ("abcdef" + "-", .invalidCharacters),
+        ("abcdef" + "=", .invalidCharacters),
+        ("abcdef" + ",", .invalidCharacters),
+        ("abcdef" + ".", .invalidCharacters),
+        ("abcdef" + "{", .invalidCharacters),
+        ("abcdef" + "}", .invalidCharacters),
+        ("abcdef" + "[", .invalidCharacters),
+        ("abcdef" + "]", .invalidCharacters),
+        ("abcdef" + "\\", .invalidCharacters),
+        ("abcdef" + "\"", .invalidCharacters),
+        ("abcdef" + "\'", .invalidCharacters),
+
+        (.init(repeating: "", count: 100), .tooLong),
+
+        // MARK: Invalid first character
+
+        ("0" + "abcdef", .invalidCharacters),
+
+        // MARK: Valid
+
+        ("abc", .success),
+        ("abc123", .success),
+        ("_abc", .success),
+        ("abc_", .success),
+        ("abc_123", .success),
+        ("abc_cba321", .success)
+    ]
+
+    func testUsernames() {
+        let validator = NicknameValidator(minCodepoints: 3, maxCodepoints: 32)
+
+        for testCase in Self.usernameTestCases {
+            let (username, expectedResult) = testCase
+
+            let actualResult = validator.validate(desiredNickname: username)
+
+            XCTAssertEqual(
+                actualResult,
+                expectedResult,
+                "Username \(username) should have been reported as \(expectedResult), but instead reported as \(actualResult)."
+            )
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory+Usernames.swift b/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory+Usernames.swift
new file mode 100644
index 00000000000..9af5e5f7f3e
--- /dev/null
+++ b/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory+Usernames.swift
@@ -0,0 +1,69 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public extension OWSRequestFactory {
+    private enum UsernameApiPaths {
+        static let reserve = "v1/accounts/username/reserved"
+        static let confirm = "v1/accounts/username/confirm"
+        static let delete = "v1/accounts/username"
+    }
+
+    /// Attempt to reserve the given username. If successful, will return the
+    /// username plus a numeric discriminator, along with a reservation token
+    /// which can be subsequently used to confirm the reservation.
+    ///
+    /// A successful reservation is valid for 5 minutes.
+    static func reserveUsernameRequest(
+        desiredNickname: String
+    ) -> TSRequest {
+        let url = URL(string: UsernameApiPaths.reserve)!
+        let params: [String: Any] = [
+            "nickname": desiredNickname
+        ]
+
+        return TSRequest(
+            url: url,
+            method: HTTPMethod.put.methodName,
+            parameters: params
+        )
+    }
+
+    /// Confirm the given previously-reserved username.
+    ///
+    /// - Parameter previouslyReservedUsername
+    /// A username returned by a prior call to reserve a desired username,
+    /// which should include a numeric discriminator.
+    /// - Parameter reservationToken
+    /// A token returned by a prior call to reserve a username.
+    static func confirmReservedUsernameRequest(
+        previouslyReservedUsername reservedUsername: String,
+        reservationToken: String
+    ) -> TSRequest {
+        let url = URL(string: UsernameApiPaths.confirm)!
+        let params: [String: Any] = [
+            "usernameToConfirm": reservedUsername,
+            "reservationToken": reservationToken
+        ]
+
+        return TSRequest(
+            url: url,
+            method: HTTPMethod.put.methodName,
+            parameters: params
+        )
+    }
+
+    /// Delete the user's existing username.
+    static func deleteExistingUsernameRequest() -> TSRequest {
+        let url = URL(string: UsernameApiPaths.delete)!
+
+        return TSRequest(
+            url: url,
+            method: HTTPMethod.delete.methodName,
+            parameters: nil
+        )
+    }
+}
diff --git a/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.h b/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.h
index 9b5b716610b..eb9d51380c3 100644
--- a/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.h
+++ b/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.h
@@ -162,8 +162,7 @@ typedef NS_ENUM(uint8_t, OWSIdentity);
 
 #pragma mark - Usernames
 
-+ (TSRequest *)usernameSetRequest:(NSString *)username;
-+ (TSRequest *)usernameDeleteRequest;
+// TODO: [Usernames] Probably going to delete this
 + (TSRequest *)getProfileRequestWithUsername:(NSString *)username;
 
 #pragma mark - Profiles
diff --git a/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.m b/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.m
index 455308d8f25..0c051a9d955 100644
--- a/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.m
+++ b/SignalServiceKit/src/Network/API/Requests/OWSRequestFactory.m
@@ -707,19 +707,6 @@ + (void)useUDAuthWithRequest:(TSRequest *)request accessKey:(SMKUDAccessKey *)ud
 
 #pragma mark - Usernames
 
-+ (TSRequest *)usernameSetRequest:(NSString *)username
-{
-    OWSAssertDebug(username.length > 0);
-
-    NSString *path = [NSString stringWithFormat:@"v1/accounts/username/%@", username];
-    return [TSRequest requestWithUrl:[NSURL URLWithString:path] method:@"PUT" parameters:@{}];
-}
-
-+ (TSRequest *)usernameDeleteRequest
-{
-    return [TSRequest requestWithUrl:[NSURL URLWithString:@"v1/accounts/username"] method:@"DELETE" parameters:@{}];
-}
-
 + (TSRequest *)getProfileRequestWithUsername:(NSString *)username
 {
     OWSAssertDebug(username.length > 0);
diff --git a/SignalServiceKit/src/Protocols/ProfileManagerProtocol.h b/SignalServiceKit/src/Protocols/ProfileManagerProtocol.h
index 504afe4f0b3..4e7a3810a88 100644
--- a/SignalServiceKit/src/Protocols/ProfileManagerProtocol.h
+++ b/SignalServiceKit/src/Protocols/ProfileManagerProtocol.h
@@ -183,14 +183,21 @@ typedef NS_ENUM(NSUInteger, UserProfileWriter) {
 
 - (nullable ModelReadCacheSizeLease *)leaseCacheSize:(NSInteger)size;
 
+- (NSArray<SignalServiceAddress *> *)allWhitelistedRegisteredAddressesWithTransaction:
+    (SDSAnyReadTransaction *)transaction;
+
+#pragma mark - Usernames
+
+- (void)updateLocalUsername:(nullable NSString *)username
+          userProfileWriter:(UserProfileWriter)userProfileWriter
+                transaction:(SDSAnyWriteTransaction *)transaction;
+
 - (nullable NSString *)usernameForAddress:(SignalServiceAddress *)address
                               transaction:(SDSAnyReadTransaction *)transaction;
+
 - (NSArray<id<SSKMaybeString>> *)usernamesForAddresses:(NSArray<SignalServiceAddress *> *)addresses
                                            transaction:(SDSAnyReadTransaction *)transaction;
 
-- (NSArray<SignalServiceAddress *> *)allWhitelistedRegisteredAddressesWithTransaction:
-    (SDSAnyReadTransaction *)transaction;
-
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/SignalServiceKit/src/TestUtils/OWSFakeProfileManager.m b/SignalServiceKit/src/TestUtils/OWSFakeProfileManager.m
index d6363625a3e..82c2f0f5b03 100644
--- a/SignalServiceKit/src/TestUtils/OWSFakeProfileManager.m
+++ b/SignalServiceKit/src/TestUtils/OWSFakeProfileManager.m
@@ -386,6 +386,21 @@ - (void)migrateWhitelistedGroupsWithTransaction:(SDSAnyWriteTransaction *)transa
     // Do nothing.
 }
 
+- (NSArray<SignalServiceAddress *> *)allWhitelistedRegisteredAddressesWithTransaction:
+    (SDSAnyReadTransaction *)transaction
+{
+    return @[];
+}
+
+#pragma mark - Usernames
+
+- (void)updateLocalUsername:(nullable NSString *)username
+          userProfileWriter:(UserProfileWriter)userProfileWriter
+                transaction:(SDSAnyWriteTransaction *)transaction
+{
+    // Do nothing.
+}
+
 - (nullable NSString *)usernameForAddress:(SignalServiceAddress *)address
                               transaction:(SDSAnyReadTransaction *)transaction
 {
@@ -398,12 +413,6 @@ - (nullable NSString *)usernameForAddress:(SignalServiceAddress *)address
     return [addresses map:^(SignalServiceAddress *address) { return self.fakeUsernames[address] ?: [NSNull null]; }];
 }
 
-- (NSArray<SignalServiceAddress *> *)allWhitelistedRegisteredAddressesWithTransaction:
-    (SDSAnyReadTransaction *)transaction
-{
-    return @[];
-}
-
 @end
 
 #endif
diff --git a/SignalServiceKit/src/Util/PrefixedLogger.swift b/SignalServiceKit/src/Util/PrefixedLogger.swift
new file mode 100644
index 00000000000..53a1d4149cb
--- /dev/null
+++ b/SignalServiceKit/src/Util/PrefixedLogger.swift
@@ -0,0 +1,88 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+open class PrefixedLogger {
+    private let prefix: String
+
+    public init(prefix: String) {
+        self.prefix = prefix
+    }
+
+    open func verbose(
+        _ logString: @autoclosure () -> String,
+        file: String = #file,
+        function: String = #function,
+        line: Int = #line
+    ) {
+        Logger.verbose(
+            "\(prefix) \(logString())",
+            file: file,
+            function: function,
+            line: line
+        )
+    }
+
+    open func debug(
+        _ logString: @autoclosure () -> String,
+        file: String = #file,
+        function: String = #function,
+        line: Int = #line
+    ) {
+        Logger.debug(
+            "\(prefix) \(logString())",
+            file: file,
+            function: function,
+            line: line
+        )
+    }
+
+    open func info(
+        _ logString: @autoclosure () -> String,
+        file: String = #file,
+        function: String = #function,
+        line: Int = #line
+    ) {
+        Logger.info(
+            "\(prefix) \(logString())",
+            file: file,
+            function: function,
+            line: line
+        )
+    }
+
+    open func warn(
+        _ logString: @autoclosure () -> String,
+        file: String = #file,
+        function: String = #function,
+        line: Int = #line
+    ) {
+        Logger.warn(
+            "\(prefix) \(logString())",
+            file: file,
+            function: function,
+            line: line
+        )
+    }
+
+    open func error(
+        _ logString: @autoclosure () -> String,
+        file: String = #file,
+        function: String = #function,
+        line: Int = #line
+    ) {
+        Logger.error(
+            "\(prefix) \(logString())",
+            file: file,
+            function: function,
+            line: line
+        )
+    }
+
+    open func flush() {
+        Logger.flush()
+    }
+}
diff --git a/SignalServiceKit/tests/Network/OWSRequestFactoryTest.swift b/SignalServiceKit/tests/Network/OWSRequestFactoryTest.swift
index d5f34a4cb38..8ee5692da9f 100644
--- a/SignalServiceKit/tests/Network/OWSRequestFactoryTest.swift
+++ b/SignalServiceKit/tests/Network/OWSRequestFactoryTest.swift
@@ -205,4 +205,39 @@ class OWSRequestFactoryTest: SSKBaseTestSwift {
 
         XCTAssertEqual(request.parameters as! [String: String], ["token": "YWJj"])
     }
+
+    // MARK: - Usernames
+
+    func testReserveUsername() {
+        let request = OWSRequestFactory.reserveUsernameRequest(desiredNickname: "foobar")
+
+        XCTAssertEqual(request.url?.path, "v1/accounts/username/reserved")
+        XCTAssertEqual(request.httpMethod, "PUT")
+        XCTAssertEqual(request.parameters as! [String: String], ["nickname": "foobar"])
+        XCTAssertTrue(request.shouldHaveAuthorizationHeaders)
+    }
+
+    func testConfirmReservedUsername() {
+        let request = OWSRequestFactory.confirmReservedUsernameRequest(
+            previouslyReservedUsername: "foobar",
+            reservationToken: "d4a0efe9-6ffc-488a-b33d-6aa340279175"
+        )
+
+        XCTAssertEqual(request.url?.path, "v1/accounts/username/confirm")
+        XCTAssertEqual(request.httpMethod, "PUT")
+        XCTAssertEqual(request.parameters as! [String: String], [
+            "usernameToConfirm": "foobar",
+            "reservationToken": "d4a0efe9-6ffc-488a-b33d-6aa340279175"
+        ])
+        XCTAssertTrue(request.shouldHaveAuthorizationHeaders)
+    }
+
+    func testDeleteExistingUsername() {
+        let request = OWSRequestFactory.deleteExistingUsernameRequest()
+
+        XCTAssertEqual(request.url?.path, "v1/accounts/username")
+        XCTAssertEqual(request.httpMethod, "DELETE")
+        XCTAssertEqual(request.parameters as! [String: String], [:])
+        XCTAssertTrue(request.shouldHaveAuthorizationHeaders)
+    }
 }
diff --git a/SignalUI/Categories/UIView+SignalUI.swift b/SignalUI/Categories/UIView+SignalUI.swift
index 1fe3526064b..e6a39dfa60a 100644
--- a/SignalUI/Categories/UIView+SignalUI.swift
+++ b/SignalUI/Categories/UIView+SignalUI.swift
@@ -727,8 +727,8 @@ public extension UIStackView {
 
 // MARK: -
 
-// This works around a UIStackView bug where hidden subviews
-// sometimes re-appear.
+/// This works around a UIStackView bug where hidden subviews
+/// sometimes re-appear.
 @objc
 public extension UIView {
     var isHiddenInStackView: Bool {
diff --git a/SignalUI/ViewControllers/OWSTableViewController2.swift b/SignalUI/ViewControllers/OWSTableViewController2.swift
index 6e3ffd2c8c2..39143701f7c 100644
--- a/SignalUI/ViewControllers/OWSTableViewController2.swift
+++ b/SignalUI/ViewControllers/OWSTableViewController2.swift
@@ -56,6 +56,8 @@ open class OWSTableViewController2: OWSViewController {
         }
     }
 
+    /// Whether or not this table view should avoid being hidden behind the
+    /// keyboard.
     @objc
     public var shouldAvoidKeyboard = false
 
