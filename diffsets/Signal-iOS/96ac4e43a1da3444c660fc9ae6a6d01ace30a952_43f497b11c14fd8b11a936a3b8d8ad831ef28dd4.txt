diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index 765fa35d5e4..5100e9f2b13 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -602,7 +602,7 @@ extension CaptureButton: MovieLockViewDelegate {
 class CaptureButton: UIView {
 
     let innerButton = CircleView()
-    let movieLockView = MovieLockView()
+    let movieLockView = MovieLockView(swipeDirectionToLock: UIDevice.current.isIPad ? .leading : .trailing)
 
     var longPressGesture: UILongPressGestureRecognizer!
     let longPressDuration = 0.5
@@ -760,9 +760,8 @@ class CaptureButton: UIView {
             guard !movieLockView.isLocked else {
                 return
             }
-            let minDistanceBeforeActivatingLockSlider: CGFloat = 30
-            let xDistance = currentLocation.x - initialTouchLocation.x - minDistanceBeforeActivatingLockSlider
-            movieLockView.update(xDistance: xDistance)
+            let xOffset = currentLocation.x - initialTouchLocation.x
+            movieLockView.update(xOffset: xOffset)
         case .ended:
             endRecordingAnimation(duration: 0.2)
             touchTimer?.invalidate()
@@ -986,39 +985,77 @@ public class MovieLockView: UIView {
 
     weak var delegate: MovieLockViewDelegate?
 
-    @objc
-    public override init(frame: CGRect) {
-        super.init(frame: frame)
+    public enum SwipeDirection {
+        case trailing
+        case leading
+    }
+
+    public let swipeDirectionToLock: SwipeDirection
+
+    public init(swipeDirectionToLock: SwipeDirection) {
+        self.swipeDirectionToLock = swipeDirectionToLock
+        super.init(frame: .zero)
 
         addSubview(stopButton)
         stopButton.autoVCenterInSuperview()
-        stopButton.centerXAnchor.constraint(equalTo: leadingAnchor,
-                                            constant: highlightViewWidth/2).isActive = true
         self.stopButton.alpha = 0
 
         addSubview(highlightView)
         highlightView.autoVCenterInSuperview()
-        highlightLeadingConstraint = highlightView.autoPinEdge(toSuperviewEdge: .leading)
 
         addSubview(lockIconView)
         lockIconView.autoVCenterInSuperview()
-        lockIconView.centerXAnchor.constraint(equalTo: trailingAnchor,
+
+        let trailingView: UIView
+        let leadingView: UIView
+        switch swipeDirectionToLock {
+        case .trailing:
+            trailingView = lockIconView
+            leadingView = stopButton
+            highlightEdgeConstraint = highlightView.autoPinEdge(toSuperviewEdge: .leading)
+        case .leading:
+            trailingView = stopButton
+            leadingView = lockIconView
+            highlightEdgeConstraint = highlightView.autoPinEdge(toSuperviewEdge: .trailing)
+        }
+
+        trailingView.centerXAnchor.constraint(equalTo: trailingAnchor,
                                               constant: -highlightViewWidth/2).isActive = true
+        leadingView.centerXAnchor.constraint(equalTo: leadingAnchor,
+                                             constant: highlightViewWidth/2).isActive = true
+
     }
 
     required init?(coder aDecoder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
 
-    public func update(xDistance: CGFloat) {
-        let max = frame.width - highlightView.frame.width
-        let offset = xDistance.clamp(0, max)
-        let alpha = offset/max
+    public func update(xOffset: CGFloat) {
+        let effectiveDistance: CGFloat
+        let distanceToLock: CGFloat
+        let highlightOffset: CGFloat
+        switch swipeDirectionToLock {
+        case .trailing:
+            let minDistanceBeforeActivatingLockSlider: CGFloat = 30
+            effectiveDistance = xOffset - minDistanceBeforeActivatingLockSlider
+            distanceToLock = frame.width - highlightView.frame.width
+            highlightOffset = effectiveDistance.clamp(0, distanceToLock)
+        case .leading:
+            // On iPad, the gesture already feels right, without applying the additional
+            // minDistanceBeforeActivatingLockSlider padding.
+            effectiveDistance = xOffset
+            distanceToLock = -1 * (frame.width - highlightView.frame.width)
+            highlightOffset = effectiveDistance.clamp(distanceToLock, 0)
+        }
+        highlightEdgeConstraint.constant = highlightOffset
+
+        let alpha = (effectiveDistance/distanceToLock).clamp(0, 1)
         highlightView.alpha = alpha
-        highlightLeadingConstraint.constant = offset
-        if offset == max {
+
+        if alpha == 1.0 {
             lock(isAnimated: true)
         }
+        Logger.verbose("xOffset: \(xOffset), effectiveDistance: \(effectiveDistance),  distanceToLock: \(distanceToLock), highlightOffset: \(highlightOffset), alpha: \(alpha)")
     }
 
     // MARK: -
@@ -1077,7 +1114,7 @@ public class MovieLockView: UIView {
     }()
 
     let highlightViewWidth = SendMediaNavigationController.bottomButtonWidth
-    private var highlightLeadingConstraint: NSLayoutConstraint!
+    private var highlightEdgeConstraint: NSLayoutConstraint!
     private lazy var highlightView: UIView = {
         let view = CircleView(diameter: highlightViewWidth)
         view.backgroundColor = .white
