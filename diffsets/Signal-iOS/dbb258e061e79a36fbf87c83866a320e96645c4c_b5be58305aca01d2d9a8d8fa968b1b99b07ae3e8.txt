diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 50203b9c8a2..49a6c513cf5 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -946,6 +946,7 @@
 		D2AEACDC16C426DA00C364C0 /* CFNetwork.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D2AEACDB16C426DA00C364C0 /* CFNetwork.framework */; };
 		E1368CBE18A1C36B00109378 /* MessageUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = B9EB5ABC1884C002007CBB57 /* MessageUI.framework */; };
 		E44AD4E624E98F440035D7B8 /* PhotoCaptureDismiss.swift in Sources */ = {isa = PBXBuildFile; fileRef = E44AD4E524E98F430035D7B8 /* PhotoCaptureDismiss.swift */; };
+		F05F51C926A90D6B00861034 /* ContextMenuActionsAccessory.swift in Sources */ = {isa = PBXBuildFile; fileRef = F05F51C826A90D6B00861034 /* ContextMenuActionsAccessory.swift */; };
 		F0B872B6269CF6D900D26481 /* ContextMenuInteraction.swift in Sources */ = {isa = PBXBuildFile; fileRef = F0B872B5269CF6D900D26481 /* ContextMenuInteraction.swift */; };
 		F0B872B8269D079B00D26481 /* ContextMenuConfiguration.swift in Sources */ = {isa = PBXBuildFile; fileRef = F0B872B7269D079B00D26481 /* ContextMenuConfiguration.swift */; };
 		F0EE4DB626A7AC18001DE4ED /* ContextMenuReactionBarAccessory.swift in Sources */ = {isa = PBXBuildFile; fileRef = F0EE4DB526A7AC18001DE4ED /* ContextMenuReactionBarAccessory.swift */; };
@@ -2153,6 +2154,7 @@
 		E434E65F6E6E989A106307BA /* Pods-SignalTests.profiling.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalTests.profiling.xcconfig"; path = "Pods/Target Support Files/Pods-SignalTests/Pods-SignalTests.profiling.xcconfig"; sourceTree = "<group>"; };
 		E44AD4E524E98F430035D7B8 /* PhotoCaptureDismiss.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PhotoCaptureDismiss.swift; sourceTree = "<group>"; };
 		EBA1F323BC6D9256EF83C605 /* Pods-NotificationServiceExtension.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-NotificationServiceExtension.debug.xcconfig"; path = "Pods/Target Support Files/Pods-NotificationServiceExtension/Pods-NotificationServiceExtension.debug.xcconfig"; sourceTree = "<group>"; };
+		F05F51C826A90D6B00861034 /* ContextMenuActionsAccessory.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContextMenuActionsAccessory.swift; sourceTree = "<group>"; };
 		F0B872B5269CF6D900D26481 /* ContextMenuInteraction.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContextMenuInteraction.swift; sourceTree = "<group>"; };
 		F0B872B7269D079B00D26481 /* ContextMenuConfiguration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContextMenuConfiguration.swift; sourceTree = "<group>"; };
 		F0EE4DB526A7AC18001DE4ED /* ContextMenuReactionBarAccessory.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContextMenuReactionBarAccessory.swift; sourceTree = "<group>"; };
@@ -4193,6 +4195,7 @@
 				F0B872B5269CF6D900D26481 /* ContextMenuInteraction.swift */,
 				F0B872B7269D079B00D26481 /* ContextMenuConfiguration.swift */,
 				F0EE4DB526A7AC18001DE4ED /* ContextMenuReactionBarAccessory.swift */,
+				F05F51C826A90D6B00861034 /* ContextMenuActionsAccessory.swift */,
 				F0FB6B1F269E625A00AC2A41 /* ContextMenuController.swift */,
 			);
 			path = "Context Menus";
@@ -5845,6 +5848,7 @@
 				34DE9C02256575300080E4AF /* CVMessageMapping.swift in Sources */,
 				347C382C252CE69400F3D941 /* CVStackView.swift in Sources */,
 				4C5250D221E7BD7D00CE3D95 /* PhoneNumberValidator.swift in Sources */,
+				F05F51C926A90D6B00861034 /* ContextMenuActionsAccessory.swift in Sources */,
 				34B3F8771E8DF1700035BE1A /* ContactsPicker.swift in Sources */,
 				88BE44A626153E7B00AE8E33 /* SoundAndNotificationsSettingsViewController.swift in Sources */,
 				34E95C29269F6109004807EC /* HomeViewController+Helpers.swift in Sources */,
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift
new file mode 100644
index 00000000000..81cfe897143
--- /dev/null
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuActionsAccessory.swift	
@@ -0,0 +1,217 @@
+//
+//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public class ContextMenuActionsAccessory: ContextMenuTargetedPreviewAccessory, ContextMenuActionsViewDelegate {
+    
+    public let menu: ContextMenu
+    
+    private let menuView: ContextMenuActionsView
+    
+    public init(
+        menu: ContextMenu,
+        accessoryAlignment: AccessoryAlignment
+    ) {
+        self.menu = menu
+        
+        menuView = ContextMenuActionsView(menu: menu)
+        super.init(accessoryView: menuView, accessoryAlignment: accessoryAlignment)
+        menuView.delegate = self
+    }
+}
+
+protocol ContextMenuActionsViewDelegate: AnyObject {
+    
+}
+
+public class ContextMenuActionsView: UIView {
+    weak var delegate: ContextMenuActionsViewDelegate?
+    public let menu: ContextMenu
+    
+    private let actionViews: [ContextMenuActionRow]
+    private let backdropView: UIVisualEffectView
+    
+    let cornerRadius: CGFloat = 12
+    
+    private class ContextMenuActionRow: UIView {
+        let attributes: ContextMenuAction.Attributes
+        let hostEffect: UIBlurEffect
+        let titleLabel: UILabel
+        let iconView: UIImageView
+        let seperatorView: UIVisualEffectView
+        var highlightedView: UIView? = nil
+        var isHighlighted: Bool {
+            didSet {
+                if oldValue != isHighlighted {
+                    if isHighlighted {
+                        if highlightedView == nil {
+                            let vibrancyView = UIVisualEffectView(effect: UIVibrancyEffect(blurEffect: hostEffect))
+                            vibrancyView.frame = bounds
+                            let view = UIView(frame: bounds)
+                            view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
+                            view.backgroundColor = Theme.cellSelectedColor
+                            view.alpha = 0.3
+                            vibrancyView.contentView.addSubview(view)
+                            highlightedView = vibrancyView
+                        }
+                        
+                        if let view = highlightedView {
+                            addSubview(view)
+                        }
+                    } else {
+                        highlightedView?.removeFromSuperview()
+                    }
+                }
+            }
+        }
+
+        var maxWidth: CGFloat = 250
+        let margin: CGFloat = 16
+        let verticalPadding: CGFloat = 20
+        let iconSize: CGFloat = 18
+        
+        public init(
+            title: String,
+            icon: UIImage?,
+            attributes: ContextMenuAction.Attributes,
+            hostBlurEffect: UIBlurEffect
+        ) {
+            titleLabel = UILabel(frame: CGRect.zero)
+            titleLabel.text = title
+            titleLabel.font = UIFont.ows_dynamicTypeTitle3
+            
+            self.attributes = attributes
+            hostEffect = hostBlurEffect
+            
+            if attributes.contains(.destructive) {
+                titleLabel.textColor = Theme.ActionSheet.default.destructiveButtonTextColor
+            } else if attributes.contains(.disabled) {
+                titleLabel.textColor = Theme.secondaryTextAndIconColor
+            } else {
+                titleLabel.textColor = Theme.primaryTextColor
+            }
+            
+            iconView = UIImageView(image: icon)
+            iconView.contentMode = .scaleAspectFit
+            iconView.tintColor = titleLabel.textColor
+            
+            seperatorView = UIVisualEffectView(effect: UIVibrancyEffect(blurEffect: hostBlurEffect))
+            let seperator = UIView(frame: seperatorView.bounds)
+            seperator.backgroundColor = Theme.cellSeparatorColor
+            seperator.autoresizingMask = [.flexibleWidth, .flexibleHeight]
+            seperatorView.contentView.addSubview(seperator)
+            isHighlighted = false
+            
+            super.init(frame:CGRect.zero)
+            
+            addSubview(titleLabel)
+            addSubview(iconView)
+            addSubview(seperatorView)
+        }
+        
+        required init(coder: NSCoder) {
+            fatalError("init(coder:) has not been implemented")
+        }
+        
+        public override func layoutSubviews() {
+            super.layoutSubviews()
+            
+            isHighlighted = attributes.contains(.highlighted)
+            
+            let isRTL = CurrentAppContext().isRTL
+            titleLabel.sizeToFit()
+            var titleFrame = titleLabel.frame
+            var iconViewFrame = CGRect(x: 0, y: 0, width: iconSize, height: iconSize)
+            
+            titleFrame.y = ceil((bounds.height - titleFrame.height) / 2)
+            iconViewFrame.height = bounds.height
+            
+            if !isRTL {
+                titleFrame.x = margin
+                titleFrame.width = bounds.width - iconViewFrame.width - 3*margin
+                iconViewFrame.x = titleFrame.maxX + margin
+            } else {
+                iconViewFrame.x = margin
+                titleFrame.x = iconViewFrame.maxX + margin
+                titleFrame.width = bounds.width - iconViewFrame.width  - 3*margin
+            }
+            
+            titleLabel.frame = titleFrame
+            iconView.frame = iconViewFrame
+            
+            var seperatorFrame = bounds
+            seperatorFrame.height = 1.0 / UIScreen.main.scale
+            seperatorFrame.y = bounds.maxY - seperatorFrame.height
+            seperatorView.frame = seperatorFrame
+        }
+        
+        public override func sizeThatFits(
+            _ size: CGSize
+        ) -> CGSize {
+            let height = ceil(titleLabel.sizeThatFits(CGSize(width: 0, height: 0)).height) + verticalPadding
+            return CGSize(width: maxWidth, height: height)
+        }
+    }
+    
+    public init(
+        menu: ContextMenu
+    ) {
+        self.menu = menu
+        
+        let effect = UIBlurEffect(style: UIBlurEffect.Style.prominent)
+        backdropView = UIVisualEffectView(effect: effect)
+        
+        var actionViews: [ContextMenuActionRow] = []
+        for action in menu.children {
+            let actionView = ContextMenuActionRow(title: action.title, icon: action.image, attributes: action.attributes, hostBlurEffect: effect)
+            actionViews.append(actionView)
+        }
+        self.actionViews = actionViews
+        
+        super.init(frame: CGRect.zero)
+
+        layer.cornerRadius = cornerRadius
+        layer.masksToBounds = true
+        addSubview(backdropView)
+        
+        for actionView in actionViews {
+            backdropView.contentView.addSubview(actionView)
+        }
+        
+        actionViews.last?.seperatorView.isHidden = true
+    }
+    
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+    
+    //MARK: UIView
+    
+    public override func layoutSubviews() {
+        super.layoutSubviews()
+        
+        backdropView.frame = bounds
+        var yOffset: CGFloat = 0
+        let actionViewSize = actionViewSizeThatFits(bounds.size)
+        for actionView in actionViews {
+            actionView.frame = CGRect(x: 0, y: yOffset, width: actionViewSize.width, height: actionViewSize.height)
+            yOffset += actionViewSize.height
+        }
+    }
+    
+    public override func sizeThatFits(
+        _ size: CGSize
+    ) -> CGSize {
+        let actionViewSize = actionViewSizeThatFits(size)
+        return CGSize(width: actionViewSize.width, height: actionViewSize.height * CGFloat(actionViews.count))
+    }
+    
+    private func actionViewSizeThatFits(
+        _ size: CGSize)
+    -> CGSize {
+        return actionViews.first?.sizeThatFits(size) ?? CGSize.zero
+    }
+    
+}
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift
index 689f9303299..e4883f6f2cf 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuConfiguration.swift	
@@ -4,24 +4,28 @@
 
 import Foundation
 
-typealias ContextMenuActionHandler = (ContextMenuAction) -> Void
+public typealias ContextMenuActionHandler = (ContextMenuAction) -> Void
 
 // UIAction analog
-class ContextMenuAction {
+public class ContextMenuAction {
 
     public struct Attributes: OptionSet {
         public let rawValue: UInt
 
+        public init(rawValue: UInt) {
+            self.rawValue = rawValue
+        }
+
         public static let disabled = ContextMenuAction.Attributes(rawValue: 1 << 0)
         public static let destructive = ContextMenuAction.Attributes(rawValue: 1 << 1)
-        public static let hidden = ContextMenuAction.Attributes(rawValue: 1 << 2)
+        public static let highlighted = ContextMenuAction.Attributes(rawValue: 1 << 2)
     }
 
     public let title: String
     public let image: UIImage?
     public let attributes: Attributes
 
-    private let handler: ContextMenuActionHandler
+    public let handler: ContextMenuActionHandler
 
     public init (
         title: String = "",
@@ -38,8 +42,14 @@ class ContextMenuAction {
 }
 
 /// UIMenu analog, supports single depth menus only
-class ContextMenu {
-    public let children: [ContextMenuAction] = []
+public class ContextMenu {
+    public let children: [ContextMenuAction]
+
+    public init(
+        _ children: [ContextMenuAction]
+    ) {
+        self.children = children
+    }
 }
 
 protocol ContextMenuTargetedPreviewAccessoryInteractionDelegate: AnyObject {
@@ -150,12 +160,12 @@ public class ContextMenuTargetedPreview {
     }
 }
 
-typealias ContextMenuActionProvider = ([ContextMenuAction]) -> ContextMenu?
+public typealias ContextMenuActionProvider = ([ContextMenuAction]) -> ContextMenu?
 
 // UIContextMenuConfiguration analog
-class ContextMenuConfiguration {
+public class ContextMenuConfiguration {
     public let identifier: NSCopying
-    private let actionProvider: ContextMenuActionProvider?
+    public let actionProvider: ContextMenuActionProvider?
 
     public init (
         identifier: NSCopying?,
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift
index 94e29547b75..bd75480e308 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuController.swift	
@@ -114,7 +114,15 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
     weak var delegate: ContextMenuControllerDelegate?
 
     let contextMenuPreview: ContextMenuTargetedPreview
-    let contextMenuConfiguration: ContextMenuConfiguration // Do we want this or a UIMenu
+    let contextMenuConfiguration: ContextMenuConfiguration
+    let menuAccessory: ContextMenuActionsAccessory?
+    var accessoryViews: [ContextMenuTargetedPreviewAccessory] {
+        var accessories = contextMenuPreview.accessoryViews
+        if let menuAccessory = self.menuAccessory {
+            accessories.append(menuAccessory)
+        }
+        return accessories
+    }
 
     lazy var blurView: UIVisualEffectView = {
         let effect = UIBlurEffect(style: UIBlurEffect.Style.regular)
@@ -124,10 +132,13 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
     private var emojiPickerSheet: EmojiPickerSheet?
 
     init (
-        configuration: ContextMenuConfiguration, preview: ContextMenuTargetedPreview
+        configuration: ContextMenuConfiguration,
+        preview: ContextMenuTargetedPreview,
+        menuAccessory: ContextMenuActionsAccessory?
     ) {
         self.contextMenuConfiguration = configuration
         self.contextMenuPreview = preview
+        self.menuAccessory = menuAccessory
 
         super.init(nibName: nil, bundle: nil)
     }
@@ -146,7 +157,7 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
 
         contextMenuView.blurView = blurView
         contextMenuView.previewView = contextMenuPreview.snapshot
-        contextMenuView.accessoryViews = contextMenuPreview.accessoryViews
+        contextMenuView.accessoryViews = accessoryViews
 
         let tapGesture = UITapGestureRecognizer(target: self, action: #selector(tapGestureRecogznied(sender:)))
         view.addGestureRecognizer(tapGesture)
@@ -160,7 +171,7 @@ class ContextMenuController: UIViewController, ContextMenuViewDelegate {
     override func viewDidAppear(_ animated: Bool) {
         super.viewDidAppear(animated)
 
-        for accessory in contextMenuPreview.accessoryViews {
+        for accessory in accessoryViews {
             accessory.animateIn(duration: 0.2) { }
         }
     }
diff --git a/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift b/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift
index 80e12b68c10..035a3965a1d 100644
--- a/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift	
+++ b/Signal/src/ViewControllers/Context Menus/ContextMenuInteraction.swift	
@@ -76,13 +76,20 @@ class ContextMenuInteraction: NSObject, UIInteraction {
     }
 
     public func presentMenu(locationInView: CGPoint, contextMenuConfiguration: ContextMenuConfiguration, targetedPreview: ContextMenuTargetedPreview) {
-        let contextMenuController = ContextMenuController(configuration: contextMenuConfiguration, preview: targetedPreview)
+        let menuAccessory = menuAccessory(configuration: contextMenuConfiguration)
+        let contextMenuController = ContextMenuController(configuration: contextMenuConfiguration, preview: targetedPreview, menuAccessory: menuAccessory)
         contextMenuController.delegate = self
         self.contextMenuController = contextMenuController
         ImpactHapticFeedback.impactOccured(style: .light)
         OWSWindowManager.shared.presentContextMenu(contextMenuController)
     }
 
+    public func menuAccessory(configuration: ContextMenuConfiguration) -> ContextMenuActionsAccessory {
+        let menu = configuration.actionProvider?([]) ?? ContextMenu([])
+        let alignment = ContextMenuTargetedPreviewAccessory.AccessoryAlignment(alignments: [(.bottom, .exterior)], alignmentOffset: CGPoint(x: 0, y: 12))
+        return ContextMenuActionsAccessory(menu: menu, accessoryAlignment: alignment)
+    }
+
     public func dismissMenu() {
         OWSWindowManager.shared.dismissContextMenu()
         contextMenuController = nil
@@ -124,6 +131,7 @@ extension ContextMenuInteraction: ContextMenuControllerDelegate, ContextMenuTarg
 class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
 
     public let itemViewModel: CVItemViewModelImpl
+    public let thread: TSThread
     public let messageActions: [MessageAction]
 
     /// Default initializer
@@ -134,9 +142,11 @@ class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
     public init (
         delegate: ContextMenuInteractionDelegate,
         itemViewModel: CVItemViewModelImpl,
+        thread: TSThread,
         messageActions: [MessageAction]
     ) {
         self.itemViewModel = itemViewModel
+        self.thread = thread
         self.messageActions = messageActions
         super.init(delegate: delegate)
     }
@@ -146,4 +156,11 @@ class ChatHistoryContextMenuInteraction: ContextMenuInteraction {
     public override func didMove(to view: UIView?) {
         self.view = view
     }
+
+    public override func menuAccessory(configuration: ContextMenuConfiguration) -> ContextMenuActionsAccessory {
+        let menu = configuration.actionProvider?([]) ?? ContextMenu([])
+        let isIncomingMessage = itemViewModel.interaction.interactionType() == .incomingMessage
+        let alignment = ContextMenuTargetedPreviewAccessory.AccessoryAlignment(alignments: [(.bottom, .exterior), (isIncomingMessage ? .leading : .trailing, .interior)], alignmentOffset: CGPoint(x: 0, y: 12))
+        return ContextMenuActionsAccessory(menu: menu, accessoryAlignment: alignment)
+    }
 }
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
index a98cf14e407..17fd38d4140 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActions.swift
@@ -15,7 +15,7 @@ extension ConversationViewController {
             return
         }
         if FeatureFlags.contextMenus {
-            let interaction = ChatHistoryContextMenuInteraction(delegate: self, itemViewModel: itemViewModel, messageActions: messageActions)
+            let interaction = ChatHistoryContextMenuInteraction(delegate: self, itemViewModel: itemViewModel, thread: thread, messageActions: messageActions)
             cell.addInteraction(interaction)
             let cellCenterPoint = cell.frame.center
             let screenPoint = self.collectionView .convert(cellCenterPoint, from: cell)
@@ -188,7 +188,23 @@ extension ConversationViewController: ContextMenuInteractionDelegate {
         configurationForMenuAtLocation location: CGPoint) -> ContextMenuConfiguration? {
 
         return ContextMenuConfiguration.init(identifier: UUID() as NSCopying, actionProvider: { _ in
-            return ContextMenu.init()
+            let defaultState = ContextMenuAction.init(title: "Default", image: Theme.iconImage(.messageActionReply), attributes: [], handler: { _ in
+                Logger.debug("default state handler")
+            })
+
+            let disabled = ContextMenuAction.init(title: "Disabled", image: Theme.iconImage(.messageActionSave), attributes: [.disabled], handler: { _ in
+                Logger.debug("disabled state handler")
+            })
+
+            let highlighted = ContextMenuAction.init(title: "Highlighted", image: Theme.iconImage(.messageActionDelete), attributes: [.highlighted], handler: { _ in
+                Logger.debug("highlighted state handler")
+            })
+
+            let destructive = ContextMenuAction.init(title: "Destructive", image: Theme.iconImage(.messageActionDelete), attributes: [.destructive], handler: { _ in
+                Logger.debug("destructive state handler")
+            })
+
+            return ContextMenu([defaultState, disabled, highlighted, destructive])
         })
     }
 
