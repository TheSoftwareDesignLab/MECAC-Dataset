diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 31d839843b0..83f57363b7e 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -791,8 +791,10 @@
 		641CECC436F5F3EE2AC07EE9 /* Pods_SignalShareExtension.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 6657FDE7B91C2845BB3BEAB5 /* Pods_SignalShareExtension.framework */; };
 		760D93AB27A0E28600F351AC /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 760D93AA27A0E28600F351AC /* CoreServices.framework */; };
 		768A1A2B17FC9CD300E00ED8 /* libz.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 768A1A2A17FC9CD300E00ED8 /* libz.dylib */; };
+		76B90A0327B5B9220013D510 /* MediaDoneButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 76B90A0227B5B9220013D510 /* MediaDoneButton.swift */; };
 		76C87F19181EFCE600C4ACAB /* MediaPlayer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 76C87F18181EFCE600C4ACAB /* MediaPlayer.framework */; };
 		76EB054018170B33006006FC /* AppDelegate.m in Sources */ = {isa = PBXBuildFile; fileRef = 76EB03C318170B33006006FC /* AppDelegate.m */; };
+		76FCCDBC27AB8FBE00BAA7F0 /* CameraCaptureControl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 76FCCDBB27AB8FBE00BAA7F0 /* CameraCaptureControl.swift */; };
 		8806EF19248DBD7200E764C7 /* NotificationPermissionReminderMegaphone.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8806EF18248DBD7200E764C7 /* NotificationPermissionReminderMegaphone.swift */; };
 		8806EF1B248DBFC100E764C7 /* ContactPermissionReminderMegaphone.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8806EF1A248DBFC100E764C7 /* ContactPermissionReminderMegaphone.swift */; };
 		8809CE8722F8FE6D00D38867 /* AttachmentKeyboard.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8809CE8622F8FE6D00D38867 /* AttachmentKeyboard.swift */; };
@@ -1986,9 +1988,11 @@
 		748A5CAEDD7C919FC64C6807 /* Pods_SignalTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_SignalTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		760D93AA27A0E28600F351AC /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = System/Library/Frameworks/CoreServices.framework; sourceTree = SDKROOT; };
 		768A1A2A17FC9CD300E00ED8 /* libz.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libz.dylib; path = usr/lib/libz.dylib; sourceTree = SDKROOT; };
+		76B90A0227B5B9220013D510 /* MediaDoneButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MediaDoneButton.swift; sourceTree = "<group>"; };
 		76C87F18181EFCE600C4ACAB /* MediaPlayer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = MediaPlayer.framework; path = System/Library/Frameworks/MediaPlayer.framework; sourceTree = SDKROOT; };
 		76EB03C218170B33006006FC /* AppDelegate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AppDelegate.h; sourceTree = "<group>"; };
 		76EB03C318170B33006006FC /* AppDelegate.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = AppDelegate.m; sourceTree = "<group>"; };
+		76FCCDBB27AB8FBE00BAA7F0 /* CameraCaptureControl.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CameraCaptureControl.swift; sourceTree = "<group>"; };
 		7856A9F703AAD99E22B75A9B /* Pods-SignalShareExtension.profiling.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalShareExtension.profiling.xcconfig"; path = "Pods/Target Support Files/Pods-SignalShareExtension/Pods-SignalShareExtension.profiling.xcconfig"; sourceTree = "<group>"; };
 		7BB1CB6F2D7841356BE367EA /* Pods-Signal.testable release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Signal.testable release.xcconfig"; path = "Pods/Target Support Files/Pods-Signal/Pods-Signal.testable release.xcconfig"; sourceTree = "<group>"; };
 		7C5EABE2C09180BC71C4E097 /* Pods-SignalShareExtension.app store release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-SignalShareExtension.app store release.xcconfig"; path = "Pods/Target Support Files/Pods-SignalShareExtension/Pods-SignalShareExtension.app store release.xcconfig"; sourceTree = "<group>"; };
@@ -2977,14 +2981,16 @@
 			isa = PBXGroup;
 			children = (
 				32C584A725B81C6600256804 /* AvatarViewController.swift */,
+				76FCCDBB27AB8FBE00BAA7F0 /* CameraCaptureControl.swift */,
 				34969559219B605E00DCFE74 /* ImagePickerController.swift */,
 				4C21D5D7223AC60F00EF8A77 /* PhotoCapture.swift */,
+				E44AD4E524E98F430035D7B8 /* PhotoCaptureDismiss.swift */,
 				4CA485BA2232339F004B9E7D /* PhotoCaptureViewController.swift */,
 				3496955A219B605E00DCFE74 /* PhotoCollectionPickerController.swift */,
 				3496955B219B605E00DCFE74 /* PhotoLibrary.swift */,
 				4C4F5EBB22711EEB00F3DD01 /* SendMediaBottomButton.swift */,
 				4C4AE69F224AF21900D4AF6F /* SendMediaNavigationController.swift */,
-				E44AD4E524E98F430035D7B8 /* PhotoCaptureDismiss.swift */,
+				76B90A0227B5B9220013D510 /* MediaDoneButton.swift */,
 			);
 			path = Photos;
 			sourceTree = "<group>";
@@ -6317,6 +6323,7 @@
 				342FFE6B271EF502000AC89F /* OWSWindowManager.m in Sources */,
 				347C382E252CE69400F3D941 /* CVComponentState.swift in Sources */,
 				342FFE6A271EF502000AC89F /* ConversationSearch.swift in Sources */,
+				76B90A0327B5B9220013D510 /* MediaDoneButton.swift in Sources */,
 				340D900024FEE6A9007B5504 /* GroupInviteLinksUI.swift in Sources */,
 				34D2CCDA2062E7D000CB1A14 /* OWSScreenLockUI.m in Sources */,
 				887B381325F0681400685845 /* AdvancedPrivacySettingsViewController.swift in Sources */,
@@ -6359,6 +6366,7 @@
 				34ACA7DE2733159600E47AD4 /* OnboardingPhoneNumberDiscoverabilityViewController.swift in Sources */,
 				88A9729222FA5D4B004B4FBF /* AttachmentFormatPickerView.swift in Sources */,
 				346C19E125ACE9AE00061D3A /* MediaDownloadSettingsViewController.swift in Sources */,
+				76FCCDBC27AB8FBE00BAA7F0 /* CameraCaptureControl.swift in Sources */,
 				8827004E23208A1900F01C46 /* AppearanceSettingsTableViewController.swift in Sources */,
 				344A761324B36C8C009D69A5 /* TestingViewController.swift in Sources */,
 				3495FF0D25F934C500959D6E /* PaymentsRestoreWalletCompleteViewController.swift in Sources */,
diff --git a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/Contents.json b/Signal/Images.xcassets/ic_flash_mode_auto.imageset/Contents.json
deleted file mode 100644
index cb322d88de8..00000000000
--- a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/Contents.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-  "images" : [
-    {
-      "idiom" : "universal",
-      "filename" : "flash-auto-28@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "flash-auto-28@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "flash-auto-28@3x.png",
-      "scale" : "3x"
-    }
-  ],
-  "info" : {
-    "version" : 1,
-    "author" : "xcode"
-  }
-}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@1x.png b/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@1x.png
deleted file mode 100644
index 40e81ed9855..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@2x.png b/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@2x.png
deleted file mode 100644
index abe8e2f5d21..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@3x.png b/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@3x.png
deleted file mode 100644
index 38b6ffb80f5..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_auto.imageset/flash-auto-28@3x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_off.imageset/Contents.json b/Signal/Images.xcassets/ic_flash_mode_off.imageset/Contents.json
deleted file mode 100644
index 140ab9904a7..00000000000
--- a/Signal/Images.xcassets/ic_flash_mode_off.imageset/Contents.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-  "images" : [
-    {
-      "idiom" : "universal",
-      "filename" : "flash-outline-28@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "flash-outline-28@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "flash-outline-28@3x.png",
-      "scale" : "3x"
-    }
-  ],
-  "info" : {
-    "version" : 1,
-    "author" : "xcode"
-  }
-}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@1x.png b/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@1x.png
deleted file mode 100644
index a132c89e203..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@2x.png b/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@2x.png
deleted file mode 100644
index f0e8eef1745..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@3x.png b/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@3x.png
deleted file mode 100644
index ecfbb9bdee2..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_off.imageset/flash-outline-28@3x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_on.imageset/Contents.json b/Signal/Images.xcassets/ic_flash_mode_on.imageset/Contents.json
deleted file mode 100644
index 54632ce264b..00000000000
--- a/Signal/Images.xcassets/ic_flash_mode_on.imageset/Contents.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-  "images" : [
-    {
-      "idiom" : "universal",
-      "filename" : "flash-filled-28@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "flash-filled-28@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "flash-filled-28@3x.png",
-      "scale" : "3x"
-    }
-  ],
-  "info" : {
-    "version" : 1,
-    "author" : "xcode"
-  }
-}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@1x.png b/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@1x.png
deleted file mode 100644
index 55911ca8f1b..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@2x.png b/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@2x.png
deleted file mode 100644
index cf134711fc8..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@3x.png b/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@3x.png
deleted file mode 100644
index 48056f90a73..00000000000
Binary files a/Signal/Images.xcassets/ic_flash_mode_on.imageset/flash-filled-28@3x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_switch_camera.imageset/Contents.json b/Signal/Images.xcassets/ic_switch_camera.imageset/Contents.json
deleted file mode 100644
index c35436bc5b5..00000000000
--- a/Signal/Images.xcassets/ic_switch_camera.imageset/Contents.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-  "images" : [
-    {
-      "idiom" : "universal",
-      "filename" : "switch-camera-28@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "switch-camera-28@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "switch-camera-28@3x.png",
-      "scale" : "3x"
-    }
-  ],
-  "info" : {
-    "version" : 1,
-    "author" : "xcode"
-  }
-}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@1x.png b/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@1x.png
deleted file mode 100644
index a22cad61e2c..00000000000
Binary files a/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@2x.png b/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@2x.png
deleted file mode 100644
index 0fc0d562fb9..00000000000
Binary files a/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@3x.png b/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@3x.png
deleted file mode 100644
index 5729ca1ed95..00000000000
Binary files a/Signal/Images.xcassets/ic_switch_camera.imageset/switch-camera-28@3x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_x_with_shadow.imageset/Contents.json b/Signal/Images.xcassets/ic_x_with_shadow.imageset/Contents.json
deleted file mode 100644
index 1f25af162c2..00000000000
--- a/Signal/Images.xcassets/ic_x_with_shadow.imageset/Contents.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-  "images" : [
-    {
-      "idiom" : "universal",
-      "filename" : "x-24@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "x-24@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "x-24@3x.png",
-      "scale" : "3x"
-    }
-  ],
-  "info" : {
-    "version" : 1,
-    "author" : "xcode"
-  }
-}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@1x.png b/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@1x.png
deleted file mode 100644
index ee6d0b88744..00000000000
Binary files a/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@2x.png b/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@2x.png
deleted file mode 100644
index ea502285caf..00000000000
Binary files a/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@3x.png b/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@3x.png
deleted file mode 100644
index cbb9bb263d5..00000000000
Binary files a/Signal/Images.xcassets/ic_x_with_shadow.imageset/x-24@3x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/media-composer-close.imageset/Contents.json b/Signal/Images.xcassets/media-composer-close.imageset/Contents.json
new file mode 100644
index 00000000000..4c94f4f150d
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-close.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "media_composer_close.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-close.imageset/media_composer_close.pdf b/Signal/Images.xcassets/media-composer-close.imageset/media_composer_close.pdf
new file mode 100644
index 00000000000..122e40ab705
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-close.imageset/media_composer_close.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-create-album-outline-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-create-album-outline-24.imageset/Contents.json
new file mode 100644
index 00000000000..8899a572d90
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-create-album-outline-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "create-album-outline-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-create-album-outline-24.imageset/create-album-outline-24.pdf b/Signal/Images.xcassets/media-composer-create-album-outline-24.imageset/create-album-outline-24.pdf
new file mode 100644
index 00000000000..146295452b1
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-create-album-outline-24.imageset/create-album-outline-24.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-create-album-solid-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-create-album-solid-24.imageset/Contents.json
new file mode 100644
index 00000000000..4ecc8754458
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-create-album-solid-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "create-album-solid-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-create-album-solid-24.imageset/create-album-solid-24.pdf b/Signal/Images.xcassets/media-composer-create-album-solid-24.imageset/create-album-solid-24.pdf
new file mode 100644
index 00000000000..84845740557
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-create-album-solid-24.imageset/create-album-solid-24.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-flash-auto-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-flash-auto-24.imageset/Contents.json
new file mode 100644
index 00000000000..99ae7bab96a
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-flash-auto-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "media-composer-flash-auto-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-flash-auto-24.imageset/media-composer-flash-auto-24.pdf b/Signal/Images.xcassets/media-composer-flash-auto-24.imageset/media-composer-flash-auto-24.pdf
new file mode 100644
index 00000000000..784656ed6d0
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-flash-auto-24.imageset/media-composer-flash-auto-24.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-flash-filled-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-flash-filled-24.imageset/Contents.json
new file mode 100644
index 00000000000..53ade492419
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-flash-filled-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "media-composer-flash-filled-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-flash-filled-24.imageset/media-composer-flash-filled-24.pdf b/Signal/Images.xcassets/media-composer-flash-filled-24.imageset/media-composer-flash-filled-24.pdf
new file mode 100644
index 00000000000..1175799051e
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-flash-filled-24.imageset/media-composer-flash-filled-24.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-flash-outline-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-flash-outline-24.imageset/Contents.json
new file mode 100644
index 00000000000..973a9982195
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-flash-outline-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "media-composer-flash-outline-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-flash-outline-24.imageset/media-composer-flash-outline-24.pdf b/Signal/Images.xcassets/media-composer-flash-outline-24.imageset/media-composer-flash-outline-24.pdf
new file mode 100644
index 00000000000..38181245b33
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-flash-outline-24.imageset/media-composer-flash-outline-24.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-lock-outline-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-lock-outline-24.imageset/Contents.json
new file mode 100644
index 00000000000..2c04ad3cc93
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-lock-outline-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "media-composer-lock-outline-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-lock-outline-24.imageset/media-composer-lock-outline-24.pdf b/Signal/Images.xcassets/media-composer-lock-outline-24.imageset/media-composer-lock-outline-24.pdf
new file mode 100644
index 00000000000..ff0cfb7f232
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-lock-outline-24.imageset/media-composer-lock-outline-24.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-navbar-chevron.imageset/Contents.json b/Signal/Images.xcassets/media-composer-navbar-chevron.imageset/Contents.json
new file mode 100644
index 00000000000..475ad9106b6
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-navbar-chevron.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "media-composer-navbar-chevron.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-navbar-chevron.imageset/media-composer-navbar-chevron.pdf b/Signal/Images.xcassets/media-composer-navbar-chevron.imageset/media-composer-navbar-chevron.pdf
new file mode 100644
index 00000000000..0baa5fd89ad
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-navbar-chevron.imageset/media-composer-navbar-chevron.pdf differ
diff --git a/Signal/Images.xcassets/media-composer-switch-camera-24.imageset/Contents.json b/Signal/Images.xcassets/media-composer-switch-camera-24.imageset/Contents.json
new file mode 100644
index 00000000000..5ae7a11ef12
--- /dev/null
+++ b/Signal/Images.xcassets/media-composer-switch-camera-24.imageset/Contents.json
@@ -0,0 +1,16 @@
+{
+  "images" : [
+    {
+      "filename" : "switch-camera-24.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  },
+  "properties" : {
+    "preserves-vector-representation" : true,
+    "template-rendering-intent" : "template"
+  }
+}
diff --git a/Signal/Images.xcassets/media-composer-switch-camera-24.imageset/switch-camera-24.pdf b/Signal/Images.xcassets/media-composer-switch-camera-24.imageset/switch-camera-24.pdf
new file mode 100644
index 00000000000..b7c885ec3a3
Binary files /dev/null and b/Signal/Images.xcassets/media-composer-switch-camera-24.imageset/switch-camera-24.pdf differ
diff --git a/Signal/Images.xcassets/navbar_disclosure_down.imageset/Contents.json b/Signal/Images.xcassets/navbar_disclosure_down.imageset/Contents.json
deleted file mode 100644
index 3cfcd92ea06..00000000000
--- a/Signal/Images.xcassets/navbar_disclosure_down.imageset/Contents.json
+++ /dev/null
@@ -1,23 +0,0 @@
-{
-  "images" : [
-    {
-      "idiom" : "universal",
-      "filename" : "navbar_disclosure_down_small@1x.png",
-      "scale" : "1x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "navbar_disclosure_down_small@2x.png",
-      "scale" : "2x"
-    },
-    {
-      "idiom" : "universal",
-      "filename" : "navbar_disclosure_down_small@3x.png",
-      "scale" : "3x"
-    }
-  ],
-  "info" : {
-    "version" : 1,
-    "author" : "xcode"
-  }
-}
\ No newline at end of file
diff --git a/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@1x.png b/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@1x.png
deleted file mode 100644
index fe04a6e29fa..00000000000
Binary files a/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@1x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@2x.png b/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@2x.png
deleted file mode 100644
index 9e8d593127d..00000000000
Binary files a/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@2x.png and /dev/null differ
diff --git a/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@3x.png b/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@3x.png
deleted file mode 100644
index a8422b949fc..00000000000
Binary files a/Signal/Images.xcassets/navbar_disclosure_down.imageset/navbar_disclosure_down_small@3x.png and /dev/null differ
diff --git a/Signal/src/ViewControllers/Photos/CameraCaptureControl.swift b/Signal/src/ViewControllers/Photos/CameraCaptureControl.swift
new file mode 100644
index 00000000000..11e9d0256e8
--- /dev/null
+++ b/Signal/src/ViewControllers/Photos/CameraCaptureControl.swift
@@ -0,0 +1,424 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import UIKit
+import SignalUI
+
+protocol CameraCaptureControlDelegate: AnyObject {
+    // MARK: Photo
+    func cameraCaptureControlDidRequestCapturePhoto(_ control: CameraCaptureControl)
+
+    // MARK: Video
+    func cameraCaptureControlDidRequestStartVideoRecording(_ control: CameraCaptureControl)
+    func cameraCaptureControlDidRequestFinishVideoRecording(_ control: CameraCaptureControl)
+    func cameraCaptureControlDidRequestCancelVideoRecording(_ control: CameraCaptureControl)
+
+    // MARK: Zoom
+    var zoomScaleReferenceHeight: CGFloat? { get }
+    func cameraCaptureControl(_ control: CameraCaptureControl, didUpdate zoomAlpha: CGFloat)
+}
+
+class CameraCaptureControl: UIView {
+
+    private let shutterButtonOuterCircle = CircleBlurView(effect: UIBlurEffect(style: .light))
+    private let shutterButtonInnerCircle = CircleView()
+
+    private static let recordingLockControlSize: CGFloat = 36   // Stop button, swipe tracking circle, lock icon
+    private static let shutterButtonDefaultSize: CGFloat = 72
+    private static let shutterButtonRecordingSize: CGFloat = 122
+
+    private var outerCircleSizeConstraint: NSLayoutConstraint!
+    private var innerCircleSizeConstraint: NSLayoutConstraint!
+    private var slidingCirclePositionContstraint: NSLayoutConstraint!
+
+    private lazy var slidingCircleView: CircleView = {
+        let view = CircleView(diameter: CameraCaptureControl.recordingLockControlSize)
+        view.backgroundColor = .ows_white
+        return view
+    }()
+    private lazy var lockIconView = LockView(frame: CGRect(origin: .zero, size: .square(CameraCaptureControl.recordingLockControlSize)))
+    private lazy var stopButton: UIButton = {
+        let button = OWSButton { [weak self] in
+            guard let self = self else { return }
+            self.didTapStopButton()
+        }
+        button.backgroundColor = .white
+        button.dimsWhenHighlighted = true
+        button.layer.masksToBounds = true
+        button.layer.cornerRadius = 4
+        button.alpha = 0
+        return button
+    }()
+
+    weak var delegate: CameraCaptureControlDelegate?
+
+    override init(frame: CGRect) {
+        super.init(frame: frame)
+        commonInit()
+    }
+
+    required init?(coder: NSCoder) {
+        super.init(coder: coder)
+        commonInit()
+    }
+
+    private func commonInit() {
+        autoSetDimension(.height, toSize: CameraCaptureControl.shutterButtonDefaultSize)
+
+        // Round Shutter Button
+        addSubview(shutterButtonOuterCircle)
+        outerCircleSizeConstraint = shutterButtonOuterCircle.autoSetDimension(.width, toSize: CameraCaptureControl.shutterButtonDefaultSize)
+        shutterButtonOuterCircle.autoPin(toAspectRatio: 1)
+        shutterButtonOuterCircle.autoVCenterInSuperview()
+        shutterButtonOuterCircle.autoHCenterInSuperview()
+
+        addSubview(shutterButtonInnerCircle)
+        innerCircleSizeConstraint = shutterButtonInnerCircle.autoSetDimension(.width, toSize: CameraCaptureControl.shutterButtonDefaultSize)
+        shutterButtonInnerCircle.autoPin(toAspectRatio: 1)
+        shutterButtonInnerCircle.isUserInteractionEnabled = false
+        shutterButtonInnerCircle.backgroundColor = .clear
+        shutterButtonInnerCircle.layer.borderColor = UIColor.ows_white.cgColor
+        shutterButtonInnerCircle.layer.borderWidth = 5
+        shutterButtonInnerCircle.centerXAnchor.constraint(equalTo: shutterButtonOuterCircle.centerXAnchor).isActive = true
+        shutterButtonInnerCircle.centerYAnchor.constraint(equalTo: shutterButtonOuterCircle.centerYAnchor).isActive = true
+
+        // The long press handles both the tap and the hold interaction, as well as the animation
+        // the presents as the user begins to hold (and the button begins to grow prior to recording)
+        longPressGesture = UILongPressGestureRecognizer(target: self, action: #selector(handleLongPress))
+        longPressGesture.minimumPressDuration = 0
+        shutterButtonOuterCircle.addGestureRecognizer(longPressGesture)
+    }
+
+    // MARK: - UI State
+
+    enum State {
+        case initial
+        case recording
+        case recordingLocked
+    }
+
+    private var _internalState: State = .initial
+    var state: State {
+        set {
+            setState(newValue)
+        }
+        get {
+            _internalState
+        }
+    }
+
+    private var sliderTrackingProgress: CGFloat = 0 {
+        didSet {
+            if sliderTrackingProgress == 1 && state == .recording {
+                setState(.recordingLocked) // this will call updateUIForCurrentState()
+            } else {
+                updateUIForCurrentState()
+            }
+        }
+    }
+
+    func setState(_ state: State, animationDuration: TimeInterval = 0) {
+        guard _internalState != state else { return }
+
+        Logger.debug("New state: \(_internalState) -> \(state)")
+
+        _internalState = state
+        if animationDuration > 0 {
+            UIView.animate(withDuration: animationDuration,
+                           delay: 0,
+                           options: [ .beginFromCurrentState ],
+                           animations: {
+                self.updateUIForCurrentState()
+            })
+        } else {
+            updateUIForCurrentState()
+        }
+    }
+
+    private func updateUIForCurrentState() {
+        switch state {
+        case .initial:
+            // element visibility
+            if slidingCirclePositionContstraint != nil {
+                stopButton.alpha = 0
+                slidingCircleView.alpha = 0
+                lockIconView.alpha = 0
+                lockIconView.state = .unlocked
+            }
+            shutterButtonInnerCircle.alpha = 1
+            shutterButtonInnerCircle.backgroundColor = .clear
+            // element sizes
+            outerCircleSizeConstraint.constant = CameraCaptureControl.shutterButtonDefaultSize
+            innerCircleSizeConstraint.constant = CameraCaptureControl.shutterButtonDefaultSize
+
+        case .recording:
+            prepareRecordingControlsIfNecessary()
+            // element visibility
+            stopButton.alpha = sliderTrackingProgress > 0 ? 1 : 0
+            slidingCircleView.alpha = sliderTrackingProgress > 0 ? 1 : 0
+            lockIconView.alpha = 1
+            lockIconView.setState(sliderTrackingProgress > 0.5 ? .locking : .unlocked, animated: true)
+            shutterButtonInnerCircle.backgroundColor = .ows_white
+            // element sizes
+            outerCircleSizeConstraint.constant = CameraCaptureControl.shutterButtonRecordingSize
+            // Inner (white) circle gets smaller as user drags the slider and reveals stop button when the slider is halfway to the lock icon.
+            innerCircleSizeConstraint.constant = CameraCaptureControl.shutterButtonDefaultSize - 2 * sliderTrackingProgress * (CameraCaptureControl.shutterButtonDefaultSize - CameraCaptureControl.recordingLockControlSize)
+
+        case .recordingLocked:
+            prepareRecordingControlsIfNecessary()
+            // element visibility
+            stopButton.alpha = 1
+            slidingCircleView.alpha = 1
+            lockIconView.alpha = 1
+            lockIconView.setState(.locked, animated: true)
+            shutterButtonInnerCircle.alpha = 0
+            shutterButtonInnerCircle.backgroundColor = .ows_white
+            // element sizes
+            outerCircleSizeConstraint.constant = CameraCaptureControl.shutterButtonRecordingSize
+            innerCircleSizeConstraint.constant = CameraCaptureControl.recordingLockControlSize
+        }
+
+        setNeedsLayout()
+        layoutIfNeeded()
+    }
+
+    private func prepareRecordingControlsIfNecessary() {
+        guard slidingCirclePositionContstraint == nil else { return }
+
+        addSubview(stopButton)
+        stopButton.autoPin(toAspectRatio: 1)
+        stopButton.autoSetDimension(.width, toSize: CameraCaptureControl.recordingLockControlSize)
+        stopButton.centerXAnchor.constraint(equalTo: shutterButtonOuterCircle.centerXAnchor).isActive = true
+        stopButton.centerYAnchor.constraint(equalTo: shutterButtonOuterCircle.centerYAnchor).isActive = true
+
+        insertSubview(slidingCircleView, belowSubview: shutterButtonInnerCircle)
+        slidingCircleView.autoVCenterInSuperview()
+        slidingCirclePositionContstraint = slidingCircleView.centerXAnchor.constraint(equalTo: shutterButtonOuterCircle.centerXAnchor, constant: 0)
+        addConstraint(slidingCirclePositionContstraint)
+
+        addSubview(lockIconView)
+        lockIconView.autoVCenterInSuperview()
+        lockIconView.autoPinTrailing(toEdgeOf: self)
+
+        setNeedsLayout()
+        UIView.performWithoutAnimation {
+            self.layoutIfNeeded()
+        }
+    }
+
+    // MARK: - Gestures
+
+    private var longPressGesture: UILongPressGestureRecognizer!
+    private static let longPressDurationThreshold = 0.5
+    private var initialTouchLocation: CGPoint?
+    private var touchTimer: Timer?
+
+    @objc
+    private func handleLongPress(gesture: UILongPressGestureRecognizer) {
+        guard let gestureView = gesture.view else {
+            owsFailDebug("gestureView was unexpectedly nil")
+            return
+        }
+
+        switch gesture.state {
+        case .possible:
+            break
+
+        case .began:
+            guard state == .initial else { break }
+
+            initialTouchLocation = gesture.location(in: gesture.view)
+
+            touchTimer?.invalidate()
+            touchTimer = WeakTimer.scheduledTimer(
+                timeInterval: CameraCaptureControl.longPressDurationThreshold,
+                target: self,
+                userInfo: nil,
+                repeats: false
+            ) { [weak self] _ in
+                guard let self = self else { return }
+
+                self.setState(.recording, animationDuration: 0.4)
+                
+                self.delegate?.cameraCaptureControlDidRequestStartVideoRecording(self)
+            }
+
+        case .changed:
+            guard state == .recording else { break }
+
+            guard let referenceHeight = delegate?.zoomScaleReferenceHeight else {
+                owsFailDebug("referenceHeight was unexpectedly nil")
+                return
+            }
+
+            guard referenceHeight > 0 else {
+                owsFailDebug("referenceHeight was unexpectedly <= 0")
+                return
+            }
+
+            guard let initialTouchLocation = initialTouchLocation else {
+                owsFailDebug("initialTouchLocation was unexpectedly nil")
+                return
+            }
+
+            let currentLocation = gesture.location(in: gestureView)
+
+            // Zoom
+            let minDistanceBeforeActivatingZoom: CGFloat = 30
+            let yDistance = initialTouchLocation.y - currentLocation.y - minDistanceBeforeActivatingZoom
+            let distanceForFullZoom = referenceHeight / 4
+            let yRatio = yDistance / distanceForFullZoom
+            let yAlpha = yRatio.clamp(0, 1)
+            delegate?.cameraCaptureControl(self, didUpdate: yAlpha)
+
+            // Video Recording Lock
+            let xOffset = currentLocation.x - initialTouchLocation.x
+            updateTracking(xOffset: xOffset)
+
+        case .ended:
+            touchTimer?.invalidate()
+            touchTimer = nil
+
+            guard state != .recordingLocked else { return }
+
+            if state == .recording {
+                setState(.initial, animationDuration: 0.2)
+
+                delegate?.cameraCaptureControlDidRequestFinishVideoRecording(self)
+            } else {
+                delegate?.cameraCaptureControlDidRequestCapturePhoto(self)
+            }
+
+        case .cancelled, .failed:
+            if state == .recording {
+                setState(.initial, animationDuration: 0.2)
+
+                delegate?.cameraCaptureControlDidRequestCancelVideoRecording(self)
+            }
+
+            touchTimer?.invalidate()
+            touchTimer = nil
+
+        @unknown default:
+            owsFailDebug("unexpected gesture state: \(gesture.state.rawValue)")
+        }
+    }
+
+    private func updateTracking(xOffset: CGFloat) {
+        let minDistanceBeforeActivatingLockSlider: CGFloat = 30
+        let effectiveDistance = xOffset - minDistanceBeforeActivatingLockSlider
+        let distanceToLock = abs(lockIconView.center.x - stopButton.center.x)
+        let trackingPosition = effectiveDistance.clamp(0, distanceToLock)
+        slidingCirclePositionContstraint.constant = trackingPosition
+        sliderTrackingProgress = (effectiveDistance / distanceToLock).clamp(0, 1)
+
+        Logger.verbose("xOffset: \(xOffset), effectiveDistance: \(effectiveDistance),  distanceToLock: \(distanceToLock), trackingPosition: \(trackingPosition), progress: \(sliderTrackingProgress)")
+    }
+
+    // MARK: - Button Actions
+
+    private func didTapStopButton() {
+        delegate?.cameraCaptureControlDidRequestFinishVideoRecording(self)
+    }
+
+    // MARK: - LockView
+
+    private class LockView: UIView {
+
+        private var imageViewLock = UIImageView(image: UIImage(named: "media-composer-lock-outline-24"))
+        private var blurBackgroundView = CircleBlurView(effect: UIBlurEffect(style: .dark))
+        private var whiteBackgroundView = CircleView()
+        private var whiteCircleView = CircleView()
+
+        enum State {
+            case unlocked
+            case locking
+            case locked
+        }
+        private var _internalState: State = .unlocked
+        var state: State {
+            set {
+                guard _internalState != newValue else { return }
+                setState(newValue)
+            }
+            get {
+                _internalState
+            }
+        }
+
+        func setState(_ state: State, animated: Bool = false) {
+            _internalState = state
+            if animated {
+                UIView.animate(withDuration: 0.25,
+                               delay: 0,
+                               options: [ .beginFromCurrentState ]) {
+                    self.updateAppearance()
+                }
+            } else {
+                updateAppearance()
+            }
+        }
+
+        private func updateAppearance() {
+            switch state {
+            case .unlocked:
+                blurBackgroundView.alpha = 1
+                whiteCircleView.alpha = 0
+                whiteBackgroundView.alpha = 0
+                imageViewLock.alpha = 1
+                imageViewLock.tintColor = .ows_white
+
+            case .locking:
+                blurBackgroundView.alpha = 1
+                whiteCircleView.alpha = 1
+                whiteBackgroundView.alpha = 0
+                imageViewLock.alpha = 0
+
+            case .locked:
+                blurBackgroundView.alpha = 0
+                whiteCircleView.alpha = 0
+                whiteBackgroundView.alpha = 1
+                imageViewLock.alpha = 1
+                imageViewLock.tintColor = .ows_black
+            }
+        }
+
+        override init(frame: CGRect) {
+            super.init(frame: frame)
+            commonInit()
+        }
+
+        required init?(coder: NSCoder) {
+            super.init(coder: coder)
+            commonInit()
+        }
+
+        private func commonInit() {
+            isUserInteractionEnabled = false
+
+            addSubview(blurBackgroundView)
+            blurBackgroundView.autoPinEdgesToSuperviewEdges()
+
+            addSubview(whiteCircleView)
+            whiteCircleView.backgroundColor = .clear
+            whiteCircleView.layer.borderColor = UIColor.ows_white.cgColor
+            whiteCircleView.layer.borderWidth = 3
+            whiteCircleView.autoPinEdgesToSuperviewEdges()
+
+            addSubview(whiteBackgroundView)
+            whiteBackgroundView.backgroundColor = .ows_white
+            whiteBackgroundView.autoPinEdgesToSuperviewEdges()
+
+            addSubview(imageViewLock)
+            imageViewLock.tintColor = .ows_white
+            imageViewLock.autoCenterInSuperview()
+
+            updateAppearance()
+        }
+
+        override var intrinsicContentSize: CGSize {
+            CGSize(width: CameraCaptureControl.recordingLockControlSize, height: CameraCaptureControl.recordingLockControlSize)
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/Photos/ImagePickerController.swift b/Signal/src/ViewControllers/Photos/ImagePickerController.swift
index 8e1d2c3af98..4deb8995e27 100644
--- a/Signal/src/ViewControllers/Photos/ImagePickerController.swift
+++ b/Signal/src/ViewControllers/Photos/ImagePickerController.swift
@@ -6,14 +6,14 @@ import Foundation
 import Photos
 
 protocol ImagePickerGridControllerDelegate: AnyObject {
-    func imagePickerDidCompleteSelection(_ imagePicker: ImagePickerGridController)
+    func imagePickerDidRequestSendMedia(_ imagePicker: ImagePickerGridController)
+    func imagePickerDidRequestPresentCamera(_ imagePicker: ImagePickerGridController)
     func imagePickerDidCancel(_ imagePicker: ImagePickerGridController)
 
     func imagePicker(_ imagePicker: ImagePickerGridController, isAssetSelected asset: PHAsset) -> Bool
     func imagePicker(_ imagePicker: ImagePickerGridController, didSelectAsset asset: PHAsset, attachmentPromise: Promise<SignalAttachment>)
     func imagePicker(_ imagePicker: ImagePickerGridController, didDeselectAsset asset: PHAsset)
 
-    var isInBatchSelectMode: Bool { get }
     func imagePickerCanSelectMoreItems(_ imagePicker: ImagePickerGridController) -> Bool
     func imagePickerDidTryToSelectTooMany(_ imagePicker: ImagePickerGridController)
 }
@@ -61,30 +61,12 @@ class ImagePickerGridController: UICollectionViewController, PhotoLibraryDelegat
             owsFailDebug("collectionView was unexpectedly nil")
             return
         }
+        collectionView.allowsMultipleSelection = true
         collectionView.register(PhotoGridViewCell.self, forCellWithReuseIdentifier: PhotoGridViewCell.reuseIdentifier)
 
-        // ensure images at the end of the list can be scrolled above the bottom buttons
-        let bottomButtonInset = -1 * SendMediaNavigationController.bottomButtonsCenterOffset + SendMediaNavigationController.bottomButtonWidth / 2
-        collectionView.contentInset.bottom = bottomButtonInset + 8
-        view.backgroundColor = .ows_gray95
-
-        // The PhotoCaptureVC needs a shadow behind it's cancel button, so we use a custom icon.
-        // This VC has a visible navbar so doesn't need the shadow, but because the user can
-        // quickly toggle between the Capture and the Picker VC's, we use the same custom "X"
-        // icon here rather than the system "stop" icon so that the spacing matches exactly.
-        // Otherwise there's a noticable shift in the icon placement.
-        if UIDevice.current.isIPad {
-            let cancelButton = OWSButton.shadowedCancelButton { [weak self] in
-                self?.didPressCancel()
-            }
-            navigationItem.leftBarButtonItem = UIBarButtonItem(customView: cancelButton)
-        } else {
-            let cancelImage = UIImage(imageLiteralResourceName: "ic_x_with_shadow")
-            let cancelButton = UIBarButtonItem(image: cancelImage, style: .plain, target: self, action: #selector(didPressCancel))
-
-            cancelButton.tintColor = .ows_gray05
-            navigationItem.leftBarButtonItem = cancelButton
-        }
+        let cancelButton = UIBarButtonItem(barButtonSystemItem: .cancel, target: self, action: #selector(didPressCancel))
+        cancelButton.tintColor = .ows_gray05
+        navigationItem.leftBarButtonItem = cancelButton
 
         let titleView = TitleView()
         titleView.delegate = self
@@ -116,10 +98,6 @@ class ImagePickerGridController: UICollectionViewController, PhotoLibraryDelegat
             return
         }
 
-        guard delegate.isInBatchSelectMode else {
-            return
-        }
-
         switch selectionPanGesture.state {
         case .possible:
             break
@@ -180,11 +158,6 @@ class ImagePickerGridController: UICollectionViewController, PhotoLibraryDelegat
             return
         }
 
-        guard delegate.isInBatchSelectMode else {
-            owsFailDebug("isInBatchSelectMode was unexpectedly false")
-            return
-        }
-
         let asset = photoCollectionContents.asset(at: indexPath.item)
         switch selectionPanGestureMode {
         case .select:
@@ -258,7 +231,7 @@ class ImagePickerGridController: UICollectionViewController, PhotoLibraryDelegat
         }
     }
 
-    // MARK: 
+    // MARK:
 
     private var lastPageYOffset: CGFloat {
         let yOffset = collectionView.contentSize.height - collectionView.frame.height + collectionView.contentInset.bottom + view.safeAreaInsets.bottom
@@ -360,24 +333,6 @@ class ImagePickerGridController: UICollectionViewController, PhotoLibraryDelegat
         return selectedIndexPaths.contains(indexPath)
     }
 
-    func batchSelectModeDidChange() {
-        applyBatchSelectMode()
-    }
-
-    func applyBatchSelectMode() {
-        guard let delegate = delegate else {
-            return
-        }
-
-        guard let collectionView = collectionView else {
-            owsFailDebug("collectionView was unexpectedly nil")
-            return
-        }
-
-        collectionView.allowsMultipleSelection = delegate.isInBatchSelectMode
-        updateVisibleCells()
-    }
-
     // MARK: - PhotoLibraryDelegate
 
     func photoLibraryDidChange(_ photoLibrary: PhotoLibrary) {
@@ -482,12 +437,6 @@ class ImagePickerGridController: UICollectionViewController, PhotoLibraryDelegat
         let asset: PHAsset = photoCollectionContents.asset(at: indexPath.item)
         let attachmentPromise: Promise<SignalAttachment> = photoCollectionContents.outgoingAttachment(for: asset)
         delegate.imagePicker(self, didSelectAsset: asset, attachmentPromise: attachmentPromise)
-
-        if !delegate.isInBatchSelectMode {
-            // Don't show "selected" badge unless we're in batch mode
-            collectionView.deselectItem(at: indexPath, animated: false)
-            delegate.imagePickerDidCompleteSelection(self)
-        }
     }
 
     override func collectionView(_ collectionView: UICollectionView, didDeselectItemAt indexPath: IndexPath) {
@@ -593,7 +542,7 @@ private class TitleView: UIView {
         label.font = UIFont.ows_dynamicTypeBody.ows_semibold
 
         iconView.tintColor = .ows_gray05
-        iconView.image = UIImage(named: "navbar_disclosure_down")?.withRenderingMode(.alwaysTemplate)
+        iconView.image = UIImage(named: "media-composer-navbar-chevron")
 
         addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(titleTapped)))
     }
diff --git a/Signal/src/ViewControllers/Photos/MediaDoneButton.swift b/Signal/src/ViewControllers/Photos/MediaDoneButton.swift
new file mode 100644
index 00000000000..e6e7a6bf31c
--- /dev/null
+++ b/Signal/src/ViewControllers/Photos/MediaDoneButton.swift
@@ -0,0 +1,106 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import SignalUI
+import UIKit
+
+class MediaDoneButton: UIButton {
+
+    var badgeNumber: Int = 0 {
+        didSet {
+            textLabel.text = numberFormatter.string(for: badgeNumber)
+            invalidateIntrinsicContentSize()
+        }
+    }
+
+    override init(frame: CGRect) {
+        super.init(frame: frame)
+        commonInit()
+    }
+
+    required init?(coder: NSCoder) {
+        super.init(coder: coder)
+        commonInit()
+    }
+
+    private let numberFormatter: NumberFormatter = {
+        let numberFormatter = NumberFormatter()
+        numberFormatter.numberStyle = .decimal
+        return numberFormatter
+    }()
+
+    private let textLabel: UILabel = {
+        let label = UILabel()
+        label.textColor = .ows_white
+        label.textAlignment = .center
+        label.font = .ows_dynamicTypeSubheadline.ows_monospaced
+        return label
+    }()
+    private var pillView: PillView!
+    private var chevronImageView: UIImageView!
+    private var dimmerView: UIView!
+
+    private func commonInit() {
+        pillView = PillView(frame: bounds)
+        pillView.isUserInteractionEnabled = false
+        pillView.layoutMargins = UIEdgeInsets(hMargin: 8, vMargin: 7)
+        addSubview(pillView)
+        pillView.autoPinEdgesToSuperviewEdges()
+
+        let blurBackgroundView = UIVisualEffectView(effect: UIBlurEffect(style: .dark))
+        pillView.addSubview(blurBackgroundView)
+        blurBackgroundView.autoPinEdgesToSuperviewEdges()
+
+        let blueBadgeView = PillView(frame: bounds)
+        blueBadgeView.backgroundColor = .ows_accentBlue
+        blueBadgeView.layoutMargins = UIEdgeInsets(margin: 4)
+        blueBadgeView.addSubview(textLabel)
+        textLabel.autoPinEdgesToSuperviewMargins()
+
+        let image: UIImage?
+        if #available(iOS 13, *) {
+            image = CurrentAppContext().isRTL ? UIImage(systemName: "chevron.backward") : UIImage(systemName: "chevron.right")
+        } else {
+            image = CurrentAppContext().isRTL ? UIImage(named: "chevron-left-20") : UIImage(named: "chevron-right-20")
+        }
+        chevronImageView = UIImageView(image: image!.withRenderingMode(.alwaysTemplate))
+        chevronImageView.contentMode = .center
+        chevronImageView.tintColor = .ows_white
+        if #available(iOS 13, *) {
+            chevronImageView.preferredSymbolConfiguration = UIImage.SymbolConfiguration(pointSize: textLabel.font.pointSize)
+        }
+
+        let hStack = UIStackView(arrangedSubviews: [blueBadgeView, chevronImageView])
+        hStack.spacing = 6
+        pillView.addSubview(hStack)
+        hStack.autoPinEdgesToSuperviewMargins()
+    }
+
+    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
+        guard traitCollection.preferredContentSizeCategory != previousTraitCollection?.preferredContentSizeCategory else {
+            return
+        }
+        textLabel.font = .ows_dynamicTypeSubheadline.ows_monospaced
+        if #available(iOS 13, *) {
+            chevronImageView.preferredSymbolConfiguration = UIImage.SymbolConfiguration(pointSize: textLabel.font.pointSize)
+        }
+    }
+
+    override var isHighlighted: Bool {
+        didSet {
+            if isHighlighted {
+                if dimmerView == nil {
+                    dimmerView = UIView(frame: bounds)
+                    dimmerView.isUserInteractionEnabled = false
+                    dimmerView.backgroundColor = .ows_black
+                    pillView.addSubview(dimmerView)
+                    dimmerView.autoPinEdgesToSuperviewEdges()
+                }
+                dimmerView.alpha = 0.5
+            } else if let dimmerView = dimmerView {
+                dimmerView.alpha = 0
+            }
+        }
+    }
+}
diff --git a/Signal/src/ViewControllers/Photos/PhotoCapture.swift b/Signal/src/ViewControllers/Photos/PhotoCapture.swift
index ffc4cf97610..b54233a6810 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCapture.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCapture.swift
@@ -1,23 +1,23 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
-import Foundation
 import CoreServices
+import Foundation
 
 protocol PhotoCaptureDelegate: AnyObject {
 
     // MARK: Still Photo
 
-    func photoCaptureDidStartPhotoCapture(_ photoCapture: PhotoCapture)
-    func photoCapture(_ photoCapture: PhotoCapture, didFinishProcessingAttachment attachment: SignalAttachment)
-    func photoCapture(_ photoCapture: PhotoCapture, processingDidError error: Error)
+    func photoCaptureDidStart(_ photoCapture: PhotoCapture)
+    func photoCapture(_ photoCapture: PhotoCapture, didFinishProcessing attachment: SignalAttachment)
+    func photoCapture(_ photoCapture: PhotoCapture, didFailProcessing error: Error)
 
-    // MARK: Movie
+    // MARK: Video
 
-    func photoCaptureDidBeginMovie(_ photoCapture: PhotoCapture)
-    func photoCaptureDidCompleteMovie(_ photoCapture: PhotoCapture)
-    func photoCaptureDidCancelMovie(_ photoCapture: PhotoCapture)
+    func photoCaptureDidBeginRecording(_ photoCapture: PhotoCapture)
+    func photoCaptureDidFinishRecording(_ photoCapture: PhotoCapture)
+    func photoCaptureDidCancelRecording(_ photoCapture: PhotoCapture)
 
     // MARK: Utility
 
@@ -29,7 +29,7 @@ protocol PhotoCaptureDelegate: AnyObject {
     func beginCaptureButtonAnimation(_ duration: TimeInterval)
     func endCaptureButtonAnimation(_ duration: TimeInterval)
 
-    func photoCapture(_ photoCapture: PhotoCapture, didCompleteFocusingAtPoint focusPoint: CGPoint)
+    func photoCapture(_ photoCapture: PhotoCapture, didCompleteFocusing focusPoint: CGPoint)
 
 }
 
@@ -82,7 +82,7 @@ class PhotoCapture: NSObject {
         let focusPoint = currentCaptureInput.device.focusPointOfInterest
 
         DispatchQueue.main.async {
-            self.delegate?.photoCapture(self, didCompleteFocusingAtPoint: focusPoint)
+            self.delegate?.photoCapture(self, didCompleteFocusing: focusPoint)
         }
     }
 
@@ -292,20 +292,20 @@ class PhotoCapture: NSObject {
             focusObservation.invalidate()
         }
         self.focusObservation = newInput.observe(\.device.isAdjustingFocus,
-                                                 options: [.old, .new]) { [weak self] _, change in
-                                                    guard let self = self else { return }
+                                                  options: [.old, .new]) { [weak self] _, change in
+            guard let self = self else { return }
 
-                                                    guard let oldValue = change.oldValue else {
-                                                        return
-                                                    }
+            guard let oldValue = change.oldValue else {
+                return
+            }
 
-                                                    guard let newValue = change.newValue else {
-                                                        return
-                                                    }
+            guard let newValue = change.newValue else {
+                return
+            }
 
-                                                    if oldValue == true && newValue == false {
-                                                        self.didCompleteFocusing()
-                                                    }
+            if oldValue == true && newValue == false {
+                self.didCompleteFocusing()
+            }
         }
 
         currentCaptureInput = newInput
@@ -333,9 +333,9 @@ class PhotoCapture: NSObject {
     }
 
     public func focus(with focusMode: AVCaptureDevice.FocusMode,
-               exposureMode: AVCaptureDevice.ExposureMode,
-               at devicePoint: CGPoint,
-               monitorSubjectAreaChange: Bool) {
+                      exposureMode: AVCaptureDevice.ExposureMode,
+                      at devicePoint: CGPoint,
+                      monitorSubjectAreaChange: Bool) {
         sessionQueue.async {
             Logger.debug("focusMode: \(focusMode), exposureMode: \(exposureMode), devicePoint: \(devicePoint), monitorSubjectAreaChange:\(monitorSubjectAreaChange)")
             guard let device = self.captureDevice else {
@@ -460,7 +460,7 @@ class PhotoCapture: NSObject {
         }
 
         let captureRect = captureOutputPhotoRect
-        delegate.photoCaptureDidStartPhotoCapture(self)
+        delegate.photoCaptureDidStart(self)
         sessionQueue.async {
             self.captureOutput.takePhoto(delegate: self, captureRect: captureRect)
         }
@@ -516,7 +516,7 @@ class PhotoCapture: NSObject {
                     throw PhotoCaptureError.invalidVideo
                 }
 
-                self.delegate?.photoCaptureDidBeginMovie(self)
+                self.delegate?.photoCaptureDidBeginRecording(self)
             }
         }.catch { error in
             self.handleMovieCaptureError(error)
@@ -555,7 +555,7 @@ class PhotoCapture: NSObject {
 
             // Inform UI that capture is stopping.
             self.lastMovieRecordingEndDate = movieRecordingStartDate
-            self.delegate?.photoCaptureDidCompleteMovie(self)
+            self.delegate?.photoCaptureDidFinishRecording(self)
         }.catch { error in
             self.handleMovieCaptureError(error)
         }
@@ -573,7 +573,7 @@ class PhotoCapture: NSObject {
             self.shouldHaveAudioCapture = false
         }
         self.lastMovieRecordingEndDate = Date()
-        self.delegate?.photoCapture(self, processingDidError: error)
+        self.delegate?.photoCapture(self, didFailProcessing: error)
     }
 
     private func cancelMovieCapture() {
@@ -592,7 +592,7 @@ class PhotoCapture: NSObject {
 
             // Inform UI that capture is stopping.
             self.lastMovieRecordingEndDate = Date()
-            self.delegate?.photoCaptureDidCancelMovie(self)
+            self.delegate?.photoCaptureDidCancelRecording(self)
         }.catch { error in
             self.handleMovieCaptureError(error)
         }
@@ -668,24 +668,25 @@ extension PhotoCapture: VolumeButtonObserver {
 
 // MARK: -
 
-extension PhotoCapture: CaptureButtonDelegate {
-    func didTapCaptureButton(_ captureButton: CaptureButton) {
+extension PhotoCapture: CameraCaptureControlDelegate {
+
+    func cameraCaptureControlDidRequestCapturePhoto(_ control: CameraCaptureControl) {
         takePhoto()
     }
 
-    func didBeginLongPressCaptureButton(_ captureButton: CaptureButton) {
+    func cameraCaptureControlDidRequestStartVideoRecording(_ control: CameraCaptureControl) {
         beginMovieCapture()
     }
 
-    func didCompleteLongPressCaptureButton(_ captureButton: CaptureButton) {
+    func cameraCaptureControlDidRequestFinishVideoRecording(_ control: CameraCaptureControl) {
         completeMovieCapture()
     }
 
-    func didCancelLongPressCaptureButton(_ captureButton: CaptureButton) {
+    func cameraCaptureControlDidRequestCancelVideoRecording(_ control: CameraCaptureControl) {
         cancelMovieCapture()
     }
 
-    func didPressStopCaptureButton(_ captureButton: CaptureButton) {
+    func didPressStopCaptureButton(_ control: CameraCaptureControl) {
         completeMovieCapture()
     }
 
@@ -693,7 +694,7 @@ extension PhotoCapture: CaptureButtonDelegate {
         return delegate?.zoomScaleReferenceHeight
     }
 
-    func longPressCaptureButton(_ captureButton: CaptureButton, didUpdateZoomAlpha zoomAlpha: CGFloat) {
+    func cameraCaptureControl(_ control: CameraCaptureControl, didUpdate zoomAlpha: CGFloat) {
         updateZoom(alpha: zoomAlpha)
     }
 }
@@ -730,12 +731,12 @@ extension PhotoCapture: CaptureOutputDelegate {
 
         switch photoData {
         case .failure(let error):
-            delegate.photoCapture(self, processingDidError: error)
+            delegate.photoCapture(self, didFailProcessing: error)
         case .success(let photoData):
             let dataSource = DataSourceValue.dataSource(with: photoData, utiType: kUTTypeJPEG as String)
 
             let attachment = SignalAttachment.attachment(dataSource: dataSource, dataUTI: kUTTypeJPEG as String)
-            delegate.photoCapture(self, didFinishProcessingAttachment: attachment)
+            delegate.photoCapture(self, didFinishProcessing: attachment)
         }
     }
 
@@ -761,7 +762,7 @@ extension PhotoCapture: CaptureOutputDelegate {
             let attachment = SignalAttachment.attachment(dataSource: dataSource, dataUTI: kUTTypeMPEG4 as String)
 
             BenchEventComplete(eventId: "Movie Processing")
-            delegate.photoCapture(self, didFinishProcessingAttachment: attachment)
+            delegate.photoCapture(self, didFinishProcessing: attachment)
         }
     }
 
@@ -1165,7 +1166,7 @@ class PhotoCaptureOutputAdaptee: NSObject, ImageCaptureOutput {
         photoSettings.isHighResolutionPhotoEnabled = true
 
         photoSettings.isAutoStillImageStabilizationEnabled =
-            photoOutput.isStillImageStabilizationSupported
+        photoOutput.isStillImageStabilizationSupported
 
         return photoSettings
     }
diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index 55ec41721e6..90e233ce074 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -1,17 +1,26 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
-import Foundation
 import AVFoundation
+import Foundation
 import Lottie
+import Photos
+import UIKit
+import SignalMessaging
 
 protocol PhotoCaptureViewControllerDelegate: AnyObject {
-    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController, didFinishProcessingAttachment attachment: SignalAttachment)
+    func photoCaptureViewControllerDidFinish(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerDidCancel(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerDidTryToCaptureTooMany(_ photoCaptureViewController: PhotoCaptureViewController)
     func photoCaptureViewControllerCanCaptureMoreItems(_ photoCaptureViewController: PhotoCaptureViewController) -> Bool
-    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController, isRecordingMovie: Bool)
+    func photoCaptureViewControllerDidRequestPresentPhotoLibrary(_ photoCaptureViewController: PhotoCaptureViewController)
+    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController, didRequestSwitchBatchMode batchMode: Bool) -> Bool
+}
+
+protocol PhotoCaptureViewControllerDataSource: AnyObject {
+    var numberOfMediaItems: Int { get }
+    func addMedia(attachment: SignalAttachment)
 }
 
 enum PhotoCaptureError: Error {
@@ -38,12 +47,13 @@ extension PhotoCaptureError: LocalizedError, UserErrorDescriptionProvider {
 
 @objc
 class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate {
-
+    
     weak var delegate: PhotoCaptureViewControllerDelegate?
+    weak var dataSource: PhotoCaptureViewControllerDataSource?
     var interactiveDismiss: PhotoCaptureInteractiveDismiss!
-
+    
     @objc public lazy var photoCapture = PhotoCapture()
-
+    
     lazy var tapToFocusView: AnimationView = {
         let view = AnimationView(name: "tap_to_focus")
         view.animationSpeed = 1
@@ -53,85 +63,135 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
         view.setContentHuggingHigh()
         return view
     }()
-
+    
     deinit {
         UIDevice.current.endGeneratingDeviceOrientationNotifications()
         photoCapture.stopCapture().done {
             Logger.debug("stopCapture completed")
         }
     }
-
+    
     // MARK: - Overrides
-
+    
     override func loadView() {
-        self.view = UIView()
-        self.view.backgroundColor = Theme.darkThemeBackgroundColor
+        view = UIView()
+        view.backgroundColor = Theme.darkThemeBackgroundColor
+        view.preservesSuperviewLayoutMargins = true
+        
         definesPresentationContext = true
-
+        
         view.addSubview(previewView)
-
-        previewView.autoPinEdgesToSuperviewEdges()
-
-        view.addSubview(captureButton)
         if UIDevice.current.isIPad {
-            captureButton.autoVCenterInSuperview()
-            captureButton.centerXAnchor.constraint(equalTo: view.trailingAnchor, constant: SendMediaNavigationController.bottomButtonsCenterOffset).isActive = true
-            captureButton.movieLockView.autoSetDimension(.width, toSize: 120)
+            previewView.autoPinEdgesToSuperviewEdges()
+        }
+        
+        view.addSubview(topBar)
+        topBar.mode = .cameraControls
+        topBar.autoPinWidthToSuperview()
+        topBarOffsetFromTop = topBar.autoPinEdge(toSuperviewEdge: .top)
+        
+        view.addSubview(bottomBar)
+        bottomBar.autoPinWidthToSuperview()
+        bottomBarOffsetFromBottom = bottomBar.autoPinEdge(toSuperviewEdge: .bottom)
+        
+        view.addSubview(cameraCaptureControl)
+        if UIDevice.current.isIPad {
+            //            captureButton.autoVCenterInSuperview()
+            //            captureButton.autoPinTrailing(toEdgeOf: view, offset: -captureButtonMargin)
+            //            captureButton.movieLockView.autoSetDimension(.width, toSize: 120)
         } else {
-            captureButton.autoHCenterInSuperview()
-            // we pin to edges rather than margin, because on notched devices the margin changes
-            // as the device rotates *EVEN THOUGH* the interface is locked to portrait.
-            captureButton.centerYAnchor.constraint(equalTo: view.bottomAnchor,
-                                                   constant: SendMediaNavigationController.bottomButtonsCenterOffset).isActive = true
-            captureButton.movieLockView.autoPinEdge(.trailing, to: .trailing, of: view, withOffset: -16)
+            captureButtonVPositionConstraint = cameraCaptureControl.autoPinEdge(toSuperviewEdge: .bottom)
+            cameraCaptureControl.autoPinLeadingToSuperviewMargin()
+            cameraCaptureControl.autoPinTrailingToSuperviewMargin()
         }
-
+        
+        view.addSubview(doneButton)
+        doneButton.isHidden = true
+        doneButton.autoPinTrailingToSuperviewMargin()
+        doneButton.centerYAnchor.constraint(equalTo: cameraCaptureControl.centerYAnchor).isActive = true
+        doneButton.addTarget(self, action: #selector(didTapDoneButton), for: .touchUpInside)
+        
         // If the view is already visible, setup the volume button listener
         // now that the capture UI is ready. Otherwise, we'll wait until
         // we're visible.
         if isVisible {
             VolumeButtons.shared?.addObserver(observer: photoCapture)
         }
-
+        
         view.addSubview(tapToFocusView)
         tapToFocusView.isUserInteractionEnabled = false
         tapToFocusLeftConstraint = tapToFocusView.centerXAnchor.constraint(equalTo: view.leftAnchor)
         tapToFocusLeftConstraint.isActive = true
         tapToFocusTopConstraint = tapToFocusView.centerYAnchor.constraint(equalTo: view.topAnchor)
         tapToFocusTopConstraint.isActive = true
-
-        view.addSubview(topBar)
-        topBar.autoPinWidthToSuperview()
-        topBarOffset = topBar.autoPinEdge(toSuperviewEdge: .top)
-        topBar.autoSetDimension(.height, toSize: 44)
     }
-
-    var topBarOffset: NSLayoutConstraint!
-
+    
+    override func viewDidLayoutSubviews() {
+        super.viewDidLayoutSubviews()
+        
+        guard !UIDevice.current.isIPad else {
+            return
+        }
+        
+        // Clamp capture view to 16:9
+        var previewFrame = view.bounds
+        var cornerRadius: CGFloat = 0
+        let targetAspectRatio: CGFloat = 16/9
+        let currentAspectRatio: CGFloat = previewFrame.height / previewFrame.width
+        
+        if abs(currentAspectRatio - targetAspectRatio) > 0.001 {
+            previewFrame.y = view.safeAreaInsets.top
+            previewFrame.height = previewFrame.width * targetAspectRatio
+            cornerRadius = 18
+        }
+        previewView.frame = previewFrame
+        previewView.previewLayer.cornerRadius = cornerRadius
+        
+        // Bottom bar is pinned to the bottom of the screen, residing either directly above safe area
+        // or (for taller screens) floating in the center of the black area between the bottom of the capture view and safe area.
+        let bottomBarHeight = bottomBar.systemLayoutSizeFitting(UIView.layoutFittingCompressedSize,
+                                                                withHorizontalFittingPriority: .fittingSizeLevel,
+                                                                verticalFittingPriority: .fittingSizeLevel).height
+        let blackBarHeight = max(0, view.bounds.maxY - previewFrame.maxY - view.safeAreaInsets.bottom)
+        bottomBarOffsetFromBottom.constant = -(max(0, (blackBarHeight - bottomBarHeight) / 2) + view.safeAreaInsets.bottom)
+        
+        // Bottom edge of the capture button is 16pts above either bottom edge of the camera capture view
+        // or top of the bottom bar, whatever is higher.
+        let captureButtonBaseline = view.bounds.maxY - view.safeAreaInsets.bottom - max(blackBarHeight, bottomBarHeight)
+        captureButtonVPositionConstraint.constant = -(view.bounds.height - captureButtonBaseline + 16)
+    }
+    
+    private var topBarOffsetFromTop: NSLayoutConstraint!
+    private var bottomBarOffsetFromBottom: NSLayoutConstraint!
+    private var captureButtonVPositionConstraint: NSLayoutConstraint!
+    
     override func viewDidLoad() {
         super.viewDidLoad()
-
+        
         setupPhotoCapture()
-
-        updateNavigationItems()
+        
         updateFlashModeControl()
-
+        
         view.addGestureRecognizer(pinchZoomGesture)
         view.addGestureRecognizer(tapToFocusGesture)
         view.addGestureRecognizer(doubleTapToSwitchCameraGesture)
-
+        
         if let navController = self.navigationController {
             interactiveDismiss = PhotoCaptureInteractiveDismiss(viewController: navController)
             interactiveDismiss.interactiveDismissDelegate = self
             interactiveDismiss.addGestureRecognizer(to: view)
         }
-
+        
         tapToFocusGesture.require(toFail: doubleTapToSwitchCameraGesture)
+        
+        mediaPickerThumbnailButton.configure()
     }
-
+    
     private var isVisible = false
+    
     override func viewWillAppear(_ animated: Bool) {
         super.viewWillAppear(animated)
+        
         isVisible = true
         let previewOrientation: AVCaptureVideoOrientation
         if UIDevice.current.isIPad {
@@ -144,39 +204,44 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
         updateIconOrientations(isAnimated: false, captureOrientation: previewOrientation)
         resumePhotoCapture()
     }
-
+    
     override func viewDidAppear(_ animated: Bool) {
         super.viewDidAppear(animated)
+        
         if hasCaptureStarted {
             BenchEventComplete(eventId: "Show-Camera")
             VolumeButtons.shared?.addObserver(observer: photoCapture)
         }
         UIApplication.shared.isIdleTimerDisabled = true
     }
-
+    
     override func viewWillDisappear(_ animated: Bool) {
         super.viewWillDisappear(animated)
+        
         isVisible = false
         VolumeButtons.shared?.removeObserver(photoCapture)
         pausePhotoCapture()
         UIApplication.shared.isIdleTimerDisabled = false
     }
-
+    
     override var prefersStatusBarHidden: Bool {
         guard !CurrentAppContext().hasActiveCall else {
             return false
         }
-
         return true
     }
-
-    override var prefersHomeIndicatorAutoHidden: Bool {
-        return true
+    
+    override var preferredStatusBarStyle: UIStatusBarStyle {
+        return .lightContent
     }
-
+    
+    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
+        return .portrait
+    }
+    
     override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
         super.viewWillTransition(to: size, with: coordinator)
-
+        
         if UIDevice.current.isIPad {
             // Since we support iPad multitasking, we cannot *disable* rotation of our views.
             // Rotating the preview layer is really distracting, so we fade out the preview layer
@@ -189,176 +254,209 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             }
         }
     }
-
+    
     override func viewSafeAreaInsetsDidChange() {
         super.viewSafeAreaInsetsDidChange()
-        if !UIDevice.current.isIPad {
-            // we pin to a constant rather than margin, because on notched devices the
-            // safeAreaInsets/margins change as the device rotates *EVEN THOUGH* the interface
-            // is locked to portrait.
-            // Only grab this once -- otherwise when we swipe to dismiss this is updated and the top bar jumps to having zero offset
-            if topBarOffset.constant == 0 {
-                topBarOffset.constant = max(view.safeAreaInsets.top, view.safeAreaInsets.left, view.safeAreaInsets.bottom)
-            }
+        
+        // we pin to a constant rather than margin, because on notched devices the
+        // safeAreaInsets/margins change as the device rotates *EVEN THOUGH* the interface
+        // is locked to portrait.
+        // Only grab this once -- otherwise when we swipe to dismiss this is updated and the top bar jumps to having zero offset
+        if topBarOffsetFromTop.constant == 0 {
+            let maxInsetDimension = max(view.safeAreaInsets.top, view.safeAreaInsets.left, view.safeAreaInsets.bottom)
+            topBarOffsetFromTop.constant = max(maxInsetDimension, previewView.frame.minY)
         }
     }
-
+    
+    // MARK: - Interactive Dismiss
+    
     func interactiveDismissDidBegin(_ interactiveDismiss: UIPercentDrivenInteractiveTransition) {
     }
+    
     func interactiveDismissDidFinish(_ interactiveDismiss: UIPercentDrivenInteractiveTransition) {
         dismiss(animated: true)
     }
+    
     func interactiveDismissDidCancel(_ interactiveDismiss: UIPercentDrivenInteractiveTransition) {
     }
-
-    // MARK: -
-    var isRecordingMovie: Bool = false
-
+    
+    // MARK: - Top Bar
+    
+    private var isRecordingVideo: Bool = false {
+        didSet {
+            if isRecordingVideo {
+                topBar.mode = .videoRecording
+                topBar.recordingTimerView.startCounting()
+                
+                cameraCaptureControl.setState(.recording, animationDuration: 0.4)
+            } else {
+                topBar.mode = .cameraControls
+                topBar.recordingTimerView.stopCounting()
+                
+                cameraCaptureControl.setState(.initial, animationDuration: 0.2)
+            }
+            
+            doneButton.isHidden = isRecordingVideo || doneButton.badgeNumber == 0
+            bottomBar.isHidden = isRecordingVideo
+        }
+    }
+    private var isInBatchMode: Bool = false
+    
     private class TopBar: UIView {
-        let recordingTimerView = RecordingTimerView()
-        let navStack: UIStackView
-
+        let recordingTimerView = RecordingTimerView(frame: .zero)
+        private let navStack: UIStackView
+        
         init(navbarItems: [UIView]) {
             self.navStack = UIStackView(arrangedSubviews: navbarItems)
-            navStack.spacing = 16
-
+            
             super.init(frame: .zero)
-
+            
+            layoutMargins = UIEdgeInsets(hMargin: 8, vMargin: 4)
+            
             addSubview(navStack)
-            navStack.autoPinEdgesToSuperviewEdges(with: UIEdgeInsets(top: 4, leading: 0, bottom: 0, trailing: 16))
-
+            navStack.spacing = 16
+            navStack.autoPinEdgesToSuperviewMargins()
+            
             addSubview(recordingTimerView)
-            recordingTimerView.isHidden = true
-            recordingTimerView.autoCenterInSuperview()
+            recordingTimerView.autoPinHeightToSuperview(withMargin: 8)
+            recordingTimerView.autoHCenterInSuperview()
         }
-
-        required init?(coder aDecoder: NSCoder) {
+        
+        required init?(coder: NSCoder) {
             fatalError("init(coder:) has not been implemented")
         }
-
+        
         enum Mode {
-            case navigation, recordingMovie
+            case cameraControls, videoRecording
         }
-
-        var mode: Mode = .navigation {
+        
+        var mode: Mode = .cameraControls {
             didSet {
                 switch mode {
-                case .recordingMovie:
+                case .videoRecording:
                     navStack.isHidden = true
-                    recordingTimerView.sizeToFit()
                     recordingTimerView.isHidden = false
-                case .navigation:
+                case .cameraControls:
                     navStack.isHidden = false
                     recordingTimerView.isHidden = true
                 }
             }
         }
     }
-
+    
     private lazy var topBar: TopBar = {
-        let dismissButton: UIButton
-        if UIDevice.current.isIPad {
-            dismissButton = OWSButton.shadowedCancelButton { [weak self] in
-                self?.didTapClose()
-            }
-            dismissButton.contentEdgeInsets = UIEdgeInsets(top: 7, leading: 20, bottom: 6, trailing: 20)
-        } else {
-            dismissButton = dismissControl.button
-            dismissButton.contentEdgeInsets = UIEdgeInsets(top: 1, leading: 16, bottom: 6, trailing: 20)
-        }
-
-        return TopBar(navbarItems: [dismissButton,
+        return TopBar(navbarItems: [dismissControl,
                                     UIView.hStretchingSpacer(),
-                                    switchCameraControl.button,
-                                    flashModeControl.button])
+                                    batchModeControl,
+                                    flashModeControl])
     }()
-
-    func updateNavigationItems() {
-        if isRecordingMovie {
-            topBar.mode = .recordingMovie
-        } else {
-            topBar.mode = .navigation
+    
+    // MARK: - Bottom Bar
+    
+    private class BottomBar: UIView {
+        let buttonStack: UIStackView
+        
+        init(items: [UIView]) {
+            self.buttonStack = UIStackView(arrangedSubviews: items)
+            
+            super.init(frame: .zero)
+            
+            layoutMargins = UIEdgeInsets(top: 0, leading: 12, bottom: 0, trailing: 14)
+            
+            addSubview(buttonStack)
+            buttonStack.spacing = 16
+            buttonStack.autoPinEdgesToSuperviewMargins()
+        }
+        
+        required init?(coder aDecoder: NSCoder) {
+            fatalError("init(coder:) has not been implemented")
         }
     }
-
-    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
-        return .portrait
+    
+    private lazy var bottomBar: BottomBar = {
+        return BottomBar(items: [mediaPickerThumbnailButton.embeddedInContainerView(layoutMargins: UIEdgeInsets(margin: 4)),
+                                 UIView.hStretchingSpacer(),
+                                 switchCameraControl])
+    }()
+    
+    func updateBottomBarItems () {
+        
     }
-
+    
     // MARK: - Views
-
-    let captureButton = CaptureButton()
-
-    var previewView: CapturePreviewView {
+    
+    private let cameraCaptureControl = CameraCaptureControl()
+    
+    private var previewView: CapturePreviewView {
         return photoCapture.previewView
     }
-
-    class PhotoControl {
-        let button: OWSButton
-
-        init(imageName: String, block: @escaping () -> Void) {
-            self.button = OWSButton(imageName: imageName, tintColor: .ows_white, block: block)
-            button.setCompressionResistanceHigh()
-            button.layer.shadowOffset = CGSize.zero
-            button.layer.shadowOpacity = 0.35
-            button.layer.shadowRadius = 4
-            button.contentEdgeInsets = UIEdgeInsets(top: 6, leading: 4, bottom: 0, trailing: 4)
-        }
-
-        func setImage(imageName: String) {
-            button.setImage(imageName: imageName)
-        }
-    }
-
+    
+    private lazy var mediaPickerThumbnailButton: MediaPickerThumbnailButton = {
+        let button = MediaPickerThumbnailButton(frame: .zero)
+        button.addTarget(self, action: #selector(didTapPhotoLibrary), for: .touchUpInside)
+        return button
+    }()
+    
     private lazy var dismissControl: PhotoControl = {
-        return PhotoControl(imageName: "ic_x_with_shadow") { [weak self] in
+        return PhotoControl(imageName: "media-composer-close") { [weak self] in
             self?.didTapClose()
         }
     }()
-
+    
     private lazy var switchCameraControl: PhotoControl = {
-        return PhotoControl(imageName: "ic_switch_camera") { [weak self] in
+        return PhotoControl(imageName: "media-composer-switch-camera-24") { [weak self] in
             self?.didTapSwitchCamera()
         }
     }()
-
+    
     private lazy var flashModeControl: PhotoControl = {
-        return PhotoControl(imageName: "ic_flash_mode_auto") { [weak self] in
+        return PhotoControl(imageName: "media-composer-flash-auto-24") { [weak self] in
             self?.didTapFlashMode()
         }
     }()
-
+    
+    private lazy var batchModeControl: PhotoControl = {
+        let control = PhotoControl(imageName: "media-composer-create-album-outline-24") { [weak self] in
+            self?.didTapBatchMode()
+        }
+        return control
+    }()
+    
+    private lazy var doneButton: MediaDoneButton = {
+        let button = MediaDoneButton(type: .custom)
+        button.badgeNumber = 0
+        return button
+    }()
+    
     lazy var pinchZoomGesture: UIPinchGestureRecognizer = {
         return UIPinchGestureRecognizer(target: self, action: #selector(didPinchZoom(pinchGesture:)))
     }()
-
+    
     lazy var tapToFocusGesture: UITapGestureRecognizer = {
         return UITapGestureRecognizer(target: self, action: #selector(didTapFocusExpose(tapGesture:)))
     }()
-
+    
     lazy var doubleTapToSwitchCameraGesture: UITapGestureRecognizer = {
         let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didDoubleTapToSwitchCamera(tapGesture:)))
         tapGesture.numberOfTapsRequired = 2
         return tapGesture
     }()
-
+    
     // MARK: - Events
-
+    
     @objc
     func didTapClose() {
-        self.delegate?.photoCaptureViewControllerDidCancel(self)
+        delegate?.photoCaptureViewControllerDidCancel(self)
     }
-
+    
     @objc
     func didTapSwitchCamera() {
-        Logger.debug("")
         switchCamera()
     }
-
+    
     @objc
     func didDoubleTapToSwitchCamera(tapGesture: UITapGestureRecognizer) {
-        Logger.debug("")
-        guard !isRecordingMovie else {
+        guard !isRecordingVideo else {
             // - Orientation gets out of sync when switching cameras mid movie.
             // - Audio gets out of sync when switching cameras mid movie
             // https://stackoverflow.com/questions/13951182/audio-video-out-of-sync-after-switch-camera
@@ -366,20 +464,19 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
         }
         switchCamera()
     }
-
+    
     private func switchCamera() {
         UIView.animate(withDuration: 0.2) {
             let epsilonToForceCounterClockwiseRotation: CGFloat = 0.00001
-            self.switchCameraControl.button.transform = self.switchCameraControl.button.transform.rotate(.pi + epsilonToForceCounterClockwiseRotation)
+            self.switchCameraControl.transform = self.switchCameraControl.transform.rotate(.pi + epsilonToForceCounterClockwiseRotation)
         }
         photoCapture.switchCamera().catch { error in
             self.showFailureUI(error: error)
         }
     }
-
+    
     @objc
     func didTapFlashMode() {
-        Logger.debug("")
         firstly {
             photoCapture.switchFlashMode()
         }.done {
@@ -388,7 +485,27 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             owsFailDebug("Error: \(error)")
         }
     }
-
+    
+    @objc
+    func didTapBatchMode() {
+        guard let delegate = delegate else {
+            return
+        }
+        isInBatchMode = delegate.photoCaptureViewController(self, didRequestSwitchBatchMode: !isInBatchMode)
+        let imageName = isInBatchMode ? "media-composer-create-album-solid-24" : "media-composer-create-album-outline-24"
+        batchModeControl.setImage(imageName: imageName)
+    }
+    
+    @objc
+    func didTapPhotoLibrary() {
+        delegate?.photoCaptureViewControllerDidRequestPresentPhotoLibrary(self)
+    }
+    
+    @objc
+    func didTapDoneButton() {
+        delegate?.photoCaptureViewControllerDidFinish(self)
+    }
+    
     @objc
     func didPinchZoom(pinchGesture: UIPinchGestureRecognizer) {
         switch pinchGesture.state {
@@ -401,40 +518,40 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             break
         }
     }
-
+    
     @objc
     func didTapFocusExpose(tapGesture: UITapGestureRecognizer) {
         let viewLocation = tapGesture.location(in: view)
         let devicePoint = previewView.previewLayer.captureDevicePointConverted(fromLayerPoint: viewLocation)
-
+        
         photoCapture.focus(with: .autoFocus, exposureMode: .autoExpose, at: devicePoint, monitorSubjectAreaChange: true)
 
-        // If the user taps near the capture button, it's more likely a mis-tap than intentional.
-        // Skip the focus animation in that case, since it looks bad.
-        let captureButtonOrigin = captureButton.superview!.convert(captureButton.frame.origin, to: view)
-        if UIDevice.current.isIPad {
-            guard viewLocation.x < captureButtonOrigin.x else {
-                Logger.verbose("Skipping animation for right edge on iPad")
-
-                // Finish any outstanding focus animation, otherwise it will remain in an
-                // uncompleted state.
-                if let lastUserFocusTapPoint = lastUserFocusTapPoint {
-                    completeFocusAnimation(forFocusPoint: lastUserFocusTapPoint)
-                }
-                return
-            }
-        } else {
-            guard viewLocation.y < captureButtonOrigin.y else {
-                Logger.verbose("Skipping animation for bottom row on iPhone")
-
-                // Finish any outstanding focus animation, otherwise it will remain in an
-                // uncompleted state.
-                if let lastUserFocusTapPoint = lastUserFocusTapPoint {
-                    completeFocusAnimation(forFocusPoint: lastUserFocusTapPoint)
-                }
-                return
-            }
-        }
+//        // If the user taps near the capture button, it's more likely a mis-tap than intentional.
+//        // Skip the focus animation in that case, since it looks bad.
+//        let captureButtonOrigin = captureButton.superview!.convert(captureButton.frame.origin, to: view)
+//        if UIDevice.current.isIPad {
+//            guard viewLocation.x < captureButtonOrigin.x else {
+//                Logger.verbose("Skipping animation for right edge on iPad")
+//
+//                // Finish any outstanding focus animation, otherwise it will remain in an
+//                // uncompleted state.
+//                if let lastUserFocusTapPoint = lastUserFocusTapPoint {
+//                    completeFocusAnimation(forFocusPoint: lastUserFocusTapPoint)
+//                }
+//                return
+//            }
+//        } else {
+//            guard viewLocation.y < captureButtonOrigin.y else {
+//                Logger.verbose("Skipping animation for bottom row on iPhone")
+//
+//                // Finish any outstanding focus animation, otherwise it will remain in an
+//                // uncompleted state.
+//                if let lastUserFocusTapPoint = lastUserFocusTapPoint {
+//                    completeFocusAnimation(forFocusPoint: lastUserFocusTapPoint)
+//                }
+//                return
+//            }
+//        }
 
         lastUserFocusTapPoint = devicePoint
         do {
@@ -444,46 +561,44 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             startFocusAnimation()
         }
     }
-
+    
     // MARK: - Focus Animations
-
+    
     var tapToFocusLeftConstraint: NSLayoutConstraint!
     var tapToFocusTopConstraint: NSLayoutConstraint!
     func positionTapToFocusView(center: CGPoint) {
         tapToFocusLeftConstraint.constant = center.x
         tapToFocusTopConstraint.constant = center.y
     }
-
+    
     func startFocusAnimation() {
         tapToFocusView.stop()
         tapToFocusView.play(fromProgress: 0.0, toProgress: 0.9)
     }
-
+    
     var lastUserFocusTapPoint: CGPoint?
     func completeFocusAnimation(forFocusPoint focusPoint: CGPoint) {
         guard let lastUserFocusTapPoint = lastUserFocusTapPoint else {
             return
         }
-
+        
         guard lastUserFocusTapPoint.within(0.005, of: focusPoint) else {
             Logger.verbose("focus completed for obsolete focus point. User has refocused.")
             return
         }
-
+        
         tapToFocusView.play(toProgress: 1.0)
     }
-
+    
     // MARK: - Orientation
-
-    // MARK: -
-
+    
     private func updateIconOrientations(isAnimated: Bool, captureOrientation: AVCaptureVideoOrientation) {
         guard !UIDevice.current.isIPad else {
             return
         }
-
+        
         Logger.verbose("captureOrientation: \(captureOrientation)")
-
+        
         let transformFromOrientation: CGAffineTransform
         switch captureOrientation {
         case .portrait:
@@ -498,38 +613,40 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             owsFailDebug("unexpected captureOrientation: \(captureOrientation.rawValue)")
             transformFromOrientation = .identity
         }
-
+        
         // Don't "unrotate" the switch camera icon if the front facing camera had been selected.
         let tranformFromCameraType: CGAffineTransform = photoCapture.desiredPosition == .front ? CGAffineTransform(rotationAngle: -.pi) : .identity
-
+        
         let updateOrientation = {
-            self.flashModeControl.button.transform = transformFromOrientation
-            self.switchCameraControl.button.transform = transformFromOrientation.concatenating(tranformFromCameraType)
+            self.flashModeControl.transform = transformFromOrientation
+            self.switchCameraControl.transform = transformFromOrientation.concatenating(tranformFromCameraType)
         }
-
+        
         if isAnimated {
             UIView.animate(withDuration: 0.3, animations: updateOrientation)
         } else {
             updateOrientation()
         }
     }
-
+    
+    // MARK: - Photo Capture
+    
     var hasCaptureStarted = false
-
+    
     private func captureReady() {
-      self.hasCaptureStarted = true
-      BenchEventComplete(eventId: "Show-Camera")
+        self.hasCaptureStarted = true
+        BenchEventComplete(eventId: "Show-Camera")
     }
-
+    
     private func setupPhotoCapture() {
         photoCapture.delegate = self
-        captureButton.delegate = photoCapture
-
+        cameraCaptureControl.delegate = photoCapture
+        
         // If the session is already running, we're good to go.
         guard !photoCapture.session.isRunning else {
             return self.captureReady()
         }
-
+        
         firstly {
             photoCapture.prepareVideoCapture()
         }.catch { [weak self] error in
@@ -537,7 +654,7 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             self.showFailureUI(error: error)
         }
     }
-
+    
     private func pausePhotoCapture() {
         guard photoCapture.session.isRunning else { return }
         firstly {
@@ -548,7 +665,7 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             self?.showFailureUI(error: error)
         }
     }
-
+    
     private func resumePhotoCapture() {
         guard !photoCapture.session.isRunning else { return }
         firstly {
@@ -559,66 +676,72 @@ class PhotoCaptureViewController: OWSViewController, InteractiveDismissDelegate
             self?.showFailureUI(error: error)
         }
     }
-
+    
     private func showFailureUI(error: Error) {
         Logger.error("error: \(error)")
-
+        
         OWSActionSheets.showActionSheet(title: nil,
                                         message: error.userErrorDescription,
                                         buttonTitle: CommonStrings.dismissButton,
                                         buttonAction: { [weak self] _ in self?.dismiss(animated: true) })
     }
-
+    
     private func updateFlashModeControl() {
         let imageName: String
         switch photoCapture.flashMode {
         case .auto:
-            imageName = "ic_flash_mode_auto"
+            imageName = "media-composer-flash-auto-24"
         case .on:
-            imageName = "ic_flash_mode_on"
+            imageName = "media-composer-flash-filled-24"
         case .off:
-            imageName = "ic_flash_mode_off"
+            imageName = "media-composer-flash-outline-24"
         @unknown default:
             owsFailDebug("unexpected photoCapture.flashMode: \(photoCapture.flashMode.rawValue)")
-
-            imageName = "ic_flash_mode_auto"
+            
+            imageName = "media-composer-flash-auto-24"
         }
-
+        
         self.flashModeControl.setImage(imageName: imageName)
     }
 }
 
 extension PhotoCaptureViewController: PhotoCaptureDelegate {
-
+    
     // MARK: - Photo
-
-    func photoCaptureDidStartPhotoCapture(_ photoCapture: PhotoCapture) {
+    
+    func photoCaptureDidStart(_ photoCapture: PhotoCapture) {
         let captureFeedbackView = UIView()
         captureFeedbackView.backgroundColor = .black
         view.insertSubview(captureFeedbackView, aboveSubview: previewView)
         captureFeedbackView.autoPinEdgesToSuperviewEdges()
-
+        
         // Ensure the capture feedback is laid out before we remove it,
         // depending on where we're coming from a layout pass might not
         // trigger in 0.05 seconds otherwise.
         view.setNeedsLayout()
         view.layoutIfNeeded()
-
+        
         DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
             captureFeedbackView.removeFromSuperview()
         }
     }
-
-    func photoCapture(_ photoCapture: PhotoCapture, didFinishProcessingAttachment attachment: SignalAttachment) {
-        delegate?.photoCaptureViewController(self, didFinishProcessingAttachment: attachment)
+    
+    func photoCapture(_ photoCapture: PhotoCapture, didFinishProcessing attachment: SignalAttachment) {
+        dataSource?.addMedia(attachment: attachment)
+        
+        if isInBatchMode, let badgeNumber = dataSource?.numberOfMediaItems {
+            doneButton.badgeNumber = badgeNumber
+            doneButton.isHidden = false
+        } else {
+            doneButton.isHidden = true
+            
+            delegate?.photoCaptureViewControllerDidFinish(self)
+        }
     }
-
-    func photoCapture(_ photoCapture: PhotoCapture, processingDidError error: Error) {
-        isRecordingMovie = false
-        topBar.recordingTimerView.stopCounting()
-        updateNavigationItems()
-        delegate?.photoCaptureViewController(self, isRecordingMovie: isRecordingMovie)
-
+    
+    func photoCapture(_ photoCapture: PhotoCapture, didFailProcessing error: Error) {
+        isRecordingVideo = false
+        
         if case PhotoCaptureError.invalidVideo = error {
             // Don't show an error if the user aborts recording before video
             // recording has begun.
@@ -626,301 +749,146 @@ extension PhotoCaptureViewController: PhotoCaptureDelegate {
         }
         showFailureUI(error: error)
     }
-
+    
     func photoCaptureCanCaptureMoreItems(_ photoCapture: PhotoCapture) -> Bool {
-        guard let delegate = delegate else { return false }
-        return delegate.photoCaptureViewControllerCanCaptureMoreItems(self)
+        return delegate?.photoCaptureViewControllerCanCaptureMoreItems(self) ?? false
     }
-
+    
     func photoCaptureDidTryToCaptureTooMany(_ photoCapture: PhotoCapture) {
         delegate?.photoCaptureViewControllerDidTryToCaptureTooMany(self)
     }
-
-    // MARK: - Movie
-
-    func photoCaptureDidBeginMovie(_ photoCapture: PhotoCapture) {
-        isRecordingMovie = true
-        updateNavigationItems()
-        topBar.recordingTimerView.startCounting()
-        delegate?.photoCaptureViewController(self, isRecordingMovie: isRecordingMovie)
+    
+    // MARK: - Video
+    
+    func photoCaptureDidBeginRecording(_ photoCapture: PhotoCapture) {
+        isRecordingVideo = true
     }
-
-    func photoCaptureDidCompleteMovie(_ photoCapture: PhotoCapture) {
-        isRecordingMovie = false
-        topBar.recordingTimerView.stopCounting()
-        updateNavigationItems()
-        delegate?.photoCaptureViewController(self, isRecordingMovie: isRecordingMovie)
+    
+    func photoCaptureDidFinishRecording(_ photoCapture: PhotoCapture) {
+        isRecordingVideo = false
     }
-
-    func photoCaptureDidCancelMovie(_ photoCapture: PhotoCapture) {
-        isRecordingMovie = false
-        topBar.recordingTimerView.stopCounting()
-        updateNavigationItems()
-        delegate?.photoCaptureViewController(self, isRecordingMovie: isRecordingMovie)
+    
+    func photoCaptureDidCancelRecording(_ photoCapture: PhotoCapture) {
+        isRecordingVideo = false
     }
-
+    
     // MARK: -
-
+    
     var zoomScaleReferenceHeight: CGFloat? {
         return view.bounds.height
     }
-
+    
     func beginCaptureButtonAnimation(_ duration: TimeInterval) {
-        captureButton.beginRecordingAnimation(duration: duration)
+        cameraCaptureControl.setState(.recording, animationDuration: duration)
     }
-
+    
     func endCaptureButtonAnimation(_ duration: TimeInterval) {
-        captureButton.endRecordingAnimation(duration: duration)
+        cameraCaptureControl.setState(.initial, animationDuration: duration)
     }
-
+    
     func photoCapture(_ photoCapture: PhotoCapture, didChangeOrientation orientation: AVCaptureVideoOrientation) {
         updateIconOrientations(isAnimated: true, captureOrientation: orientation)
         if UIDevice.current.isIPad {
             photoCapture.updateVideoPreviewConnection(toOrientation: orientation)
         }
     }
-
-    func photoCapture(_ photoCapture: PhotoCapture, didCompleteFocusingAtPoint focusPoint: CGPoint) {
+    
+    func photoCapture(_ photoCapture: PhotoCapture, didCompleteFocusing focusPoint: CGPoint) {
         completeFocusAnimation(forFocusPoint: focusPoint)
     }
 }
 
 // MARK: - Views
 
-protocol CaptureButtonDelegate: AnyObject {
-    // MARK: Photo
-    func didTapCaptureButton(_ captureButton: CaptureButton)
-
-    // MARK: Video
-    func didBeginLongPressCaptureButton(_ captureButton: CaptureButton)
-    func didCompleteLongPressCaptureButton(_ captureButton: CaptureButton)
-    func didCancelLongPressCaptureButton(_ captureButton: CaptureButton)
-    func didPressStopCaptureButton(_ captureButton: CaptureButton)
-
-    var zoomScaleReferenceHeight: CGFloat? { get }
-    func longPressCaptureButton(_ captureButton: CaptureButton, didUpdateZoomAlpha zoomAlpha: CGFloat)
-}
-
-extension CaptureButton: MovieLockViewDelegate {
-    func videoLockViewDidTapStop(_ videoLockView: MovieLockView) {
-        assert(movieLockView.isLocked)
-        movieLockView.unlock(isAnimated: true)
-        UIView.animate(withDuration: 0.2) {
-            self.movieLockView.alpha = 0
-        }
-        delegate?.didPressStopCaptureButton(self)
-    }
-}
-
-class CaptureButton: UIView {
-
-    let innerButton = CircleView()
-    let movieLockView = MovieLockView(swipeDirectionToLock: UIDevice.current.isIPad ? .leading : .trailing)
-
-    var longPressGesture: UILongPressGestureRecognizer!
-    let longPressDuration = 0.5
-
-    let zoomIndicator = CircleView()
-
-    weak var delegate: CaptureButtonDelegate?
-
-    let defaultDiameter: CGFloat = min(ScaleFromIPhone5To7Plus(60, 80), 80)
-    static let recordingDiameter: CGFloat = min(ScaleFromIPhone5To7Plus(68, 120), 120)
-    var innerButtonSizeConstraints: [NSLayoutConstraint]!
-    var zoomIndicatorSizeConstraints: [NSLayoutConstraint]!
-
-    override init(frame: CGRect) {
-        super.init(frame: frame)
-
-        // The long press handles both the tap and the hold interaction, as well as the animation
-        // the presents as the user begins to hold (and the button begins to grow prior to recording)
-        longPressGesture = UILongPressGestureRecognizer(target: self, action: #selector(didLongPress))
-        longPressGesture.minimumPressDuration = 0
-        innerButton.addGestureRecognizer(longPressGesture)
-
-        addSubview(innerButton)
-        innerButtonSizeConstraints = autoSetDimensions(to: CGSize(square: defaultDiameter))
-        innerButton.backgroundColor = UIColor.ows_white.withAlphaComponent(0.33)
-        innerButton.layer.shadowOffset = .zero
-        innerButton.layer.shadowOpacity = 0.33
-        innerButton.layer.shadowRadius = 2
-        innerButton.autoPinEdgesToSuperviewEdges()
-
-        addSubview(zoomIndicator)
-        zoomIndicatorSizeConstraints = zoomIndicator.autoSetDimensions(to: CGSize(square: defaultDiameter))
-        zoomIndicator.isUserInteractionEnabled = false
-        zoomIndicator.layer.borderColor = UIColor.ows_white.cgColor
-        zoomIndicator.layer.borderWidth = 1.5
-        zoomIndicator.autoAlignAxis(.horizontal, toSameAxisOf: innerButton)
-        zoomIndicator.autoAlignAxis(.vertical, toSameAxisOf: innerButton)
-
-        addSubview(movieLockView)
-        movieLockView.autoSetDimension(.height, toSize: 50)
-        movieLockView.stopButton.autoAlignAxis(.horizontal, toSameAxisOf: self)
-        movieLockView.stopButton.autoAlignAxis(.vertical, toSameAxisOf: self)
-        movieLockView.alpha = 0
-        movieLockView.delegate = self
-    }
-
+private class PhotoControl: UIView {
+    let button: OWSButton
+    
+    private static let visibleButtonSize: CGFloat = 36  // both height and width
+    private static let layoutMargin: CGFloat = 4        // both horizontal and vertical
+    
+    init(imageName: String, block: @escaping () -> Void) {
+        self.button = OWSButton(imageName: imageName, tintColor: .ows_white, block: block)
+        
+        super.init(frame: CGRect(origin: .zero, size: CGSize(square: Self.visibleButtonSize + 2*Self.layoutMargin)))
+        
+        layoutMargins = UIEdgeInsets(margin: Self.layoutMargin)
+        
+        let blurView = CircleBlurView(effect: UIBlurEffect(style: .dark))
+        addSubview(blurView)
+        blurView.autoPinEdgesToSuperviewMargins()
+        
+        addSubview(button)
+        button.autoPinEdgesToSuperviewMargins()
+    }
+    
     required init?(coder aDecoder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
-
-    func beginRecordingAnimation(duration: TimeInterval, delay: TimeInterval = 0) {
-        UIView.animate(
-            withDuration: duration,
-            delay: delay,
-            options: [.beginFromCurrentState, .curveLinear],
-            animations: {
-                self.innerButtonSizeConstraints.forEach { $0.constant = type(of: self).recordingDiameter }
-                self.zoomIndicatorSizeConstraints.forEach { $0.constant = type(of: self).recordingDiameter }
-                self.superview?.layoutIfNeeded()
-        },
-            completion: nil
-        )
+    
+    override var intrinsicContentSize: CGSize {
+        return CGSize(width: Self.visibleButtonSize + layoutMargins.leading + layoutMargins.trailing,
+                      height: Self.visibleButtonSize + layoutMargins.top + layoutMargins.bottom)
     }
-
-    func endRecordingAnimation(duration: TimeInterval, delay: TimeInterval = 0) {
-        UIView.animate(
-            withDuration: duration,
-            delay: delay,
-            options: [.beginFromCurrentState, .curveEaseIn],
-            animations: {
-                self.innerButtonSizeConstraints.forEach { $0.constant = self.defaultDiameter }
-                self.zoomIndicatorSizeConstraints.forEach { $0.constant = self.defaultDiameter }
-                self.superview?.layoutIfNeeded()
-        },
-            completion: nil
-        )
+    
+    func setImage(imageName: String) {
+        button.setImage(imageName: imageName)
     }
+}
 
-    // MARK: - Gestures
-
-    var initialTouchLocation: CGPoint?
-    var touchTimer: Timer?
-    var isLongPressing = false
-
-    @objc
-    func didLongPress(_ gesture: UILongPressGestureRecognizer) {
-        guard let gestureView = gesture.view else {
-            owsFailDebug("gestureView was unexpectedly nil")
-            return
-        }
-
-        switch gesture.state {
-        case .possible: break
-        case .began:
-            guard !movieLockView.isLocked else {
-                return
-            }
-
-            initialTouchLocation = gesture.location(in: gesture.view)
-            beginRecordingAnimation(duration: 0.4, delay: 0.1)
-
-            isLongPressing = false
-
-            touchTimer?.invalidate()
-            touchTimer = WeakTimer.scheduledTimer(
-                timeInterval: longPressDuration,
-                target: self,
-                userInfo: nil,
-                repeats: false
-            ) { [weak self] _ in
-                guard let `self` = self else { return }
-                self.isLongPressing = true
-
-                self.movieLockView.unlock(isAnimated: false)
-                UIView.animate(withDuration: 0.2) {
-                    self.movieLockView.alpha = 1
-                }
-                self.delegate?.didBeginLongPressCaptureButton(self)
-            }
-        case .changed:
-            guard isLongPressing else { break }
-
-            guard let referenceHeight = delegate?.zoomScaleReferenceHeight else {
-                owsFailDebug("referenceHeight was unexpectedly nil")
-                return
-            }
-
-            guard referenceHeight > 0 else {
-                owsFailDebug("referenceHeight was unexpectedly <= 0")
-                return
-            }
-
-            guard let initialTouchLocation = initialTouchLocation else {
-                owsFailDebug("initialTouchLocation was unexpectedly nil")
-                return
-            }
-
-            let currentLocation = gesture.location(in: gestureView)
-
-            // Zoom
-            let minDistanceBeforeActivatingZoom: CGFloat = 30
-            let yDistance = initialTouchLocation.y - currentLocation.y - minDistanceBeforeActivatingZoom
-            let distanceForFullZoom = referenceHeight / 4
-            let yRatio = yDistance / distanceForFullZoom
-            let yAlpha = yRatio.clamp(0, 1)
-
-            let zoomIndicatorDiameter = CGFloatLerp(type(of: self).recordingDiameter, 3, yAlpha)
-            self.zoomIndicatorSizeConstraints.forEach { $0.constant = zoomIndicatorDiameter }
-            zoomIndicator.superview?.layoutIfNeeded()
-
-            delegate?.longPressCaptureButton(self, didUpdateZoomAlpha: yAlpha)
-
-            // Lock
-
-            guard !movieLockView.isLocked else {
-                return
-            }
-            let xOffset = currentLocation.x - initialTouchLocation.x
-            movieLockView.update(xOffset: xOffset)
-        case .ended:
-            endRecordingAnimation(duration: 0.2)
-            touchTimer?.invalidate()
-            touchTimer = nil
-
-            guard !movieLockView.isLocked else {
-                return
-            }
-
-            if isLongPressing {
-                UIView.animate(withDuration: 0.2) {
-                    self.movieLockView.alpha = 0
-                }
-                delegate?.didCompleteLongPressCaptureButton(self)
-            } else {
-                delegate?.didTapCaptureButton(self)
-            }
-        case .cancelled, .failed:
-            endRecordingAnimation(duration: 0.2)
-
-            if isLongPressing {
-                self.movieLockView.unlock(isAnimated: true)
-                UIView.animate(withDuration: 0.2) {
-                    self.movieLockView.alpha = 0
+private class MediaPickerThumbnailButton: UIButton {
+    
+    private static let visibleSize = CGSize(square: 36)
+    
+    func configure() {
+        layer.cornerRadius = 10
+        layer.borderWidth = 1.5
+        layer.borderColor = UIColor.ows_whiteAlpha80.cgColor
+        clipsToBounds = true
+        
+        let placeholderView = UIVisualEffectView(effect: UIBlurEffect(style: .light))
+        insertSubview(placeholderView, at: 0)
+        placeholderView.autoPinEdgesToSuperviewEdges()
+        
+        // Async Fetch last image
+        DispatchQueue.global(qos: .userInteractive).async {
+            let fetchOptions = PHFetchOptions()
+            fetchOptions.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: false)]
+            fetchOptions.fetchLimit = 1
+            
+            let fetchResult = PHAsset.fetchAssets(with: PHAssetMediaType.image, options: fetchOptions)
+            if fetchResult.count > 0, let asset = fetchResult.firstObject {
+                let targetImageSize = MediaPickerThumbnailButton.visibleSize
+                PHImageManager.default().requestImage(for: asset, targetSize: targetImageSize, contentMode: .aspectFill, options: nil) { (image, _) in
+                    DispatchQueue.main.async {
+                        self.setImage(image, for: .normal)
+                        placeholderView.alpha = 0
+                    }
                 }
-                delegate?.didCancelLongPressCaptureButton(self)
             }
-
-            touchTimer?.invalidate()
-            touchTimer = nil
-        @unknown default:
-            owsFailDebug("unexpected gesture state: \(gesture.state.rawValue)")
         }
     }
+    
+    override var intrinsicContentSize: CGSize {
+        return Self.visibleSize
+    }
 }
 
 class CapturePreviewView: UIView {
-
+    
     let previewLayer: AVCaptureVideoPreviewLayer
-
+    
     override var bounds: CGRect {
         didSet {
             previewLayer.frame = bounds
         }
     }
-
+    
+    override var frame: CGRect {
+        didSet {
+            previewLayer.frame = bounds
+        }
+    }
+    
     override var contentMode: UIView.ContentMode {
         set {
             switch newValue {
@@ -948,7 +916,7 @@ class CapturePreviewView: UIView {
             }
         }
     }
-
+    
     init(session: AVCaptureSession) {
         previewLayer = AVCaptureVideoPreviewLayer(session: session)
         if Platform.isSimulator {
@@ -960,66 +928,59 @@ class CapturePreviewView: UIView {
         previewLayer.frame = bounds
         layer.addSublayer(previewLayer)
     }
-
+    
     required init?(coder aDecoder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
 }
 
-class RecordingTimerView: UIView {
-
-    let stackViewSpacing: CGFloat = 4
-
+private class RecordingTimerView: PillView {
+    
     override init(frame: CGRect) {
         super.init(frame: frame)
-
+        
+        layoutMargins = UIEdgeInsets(hMargin: 16, vMargin: 0)
+        
+        let backgroundView = UIVisualEffectView(effect: UIBlurEffect(style: .dark))
+        addSubview(backgroundView)
+        backgroundView.autoPinEdgesToSuperviewEdges()
+        
         let stackView = UIStackView(arrangedSubviews: [icon, label])
         stackView.axis = .horizontal
         stackView.alignment = .center
-        stackView.spacing = stackViewSpacing
-
+        stackView.spacing = 5
         addSubview(stackView)
         stackView.autoPinEdgesToSuperviewMargins()
-
+        
         updateView()
     }
-
+    
     required init?(coder aDecoder: NSCoder) {
         fatalError("init(coder:) has not been implemented")
     }
-
+    
     // MARK: - Subviews
-
+    
     private lazy var label: UILabel = {
         let label = UILabel()
         label.font = UIFont.ows_monospacedDigitFont(withSize: 20)
         label.textAlignment = .center
         label.textColor = UIColor.white
-        label.layer.shadowOffset = CGSize.zero
-        label.layer.shadowOpacity = 0.35
-        label.layer.shadowRadius = 4
-
         return label
     }()
-
-    static let iconWidth: CGFloat = 6
-
+    
     private let icon: UIView = {
         let icon = CircleView()
-        icon.layer.shadowOffset = CGSize.zero
-        icon.layer.shadowOpacity = 0.35
-        icon.layer.shadowRadius = 4
-
         icon.backgroundColor = .red
-        icon.autoSetDimensions(to: CGSize(square: iconWidth))
+        icon.autoSetDimensions(to: CGSize(square: 6))
         icon.alpha = 0
-
         return icon
     }()
-
+    
     // MARK: -
+    
     var recordingStartTime: TimeInterval?
-
+    
     func startCounting() {
         recordingStartTime = CACurrentMediaTime()
         timer = Timer.weakScheduledTimer(withTimeInterval: 0.1, target: self, selector: #selector(updateView), userInfo: nil, repeats: true)
@@ -1028,7 +989,7 @@ class RecordingTimerView: UIView {
                        options: [.autoreverse, .repeat],
                        animations: { self.icon.alpha = 1 })
     }
-
+    
     func stopCounting() {
         timer?.invalidate()
         timer = nil
@@ -1038,28 +999,28 @@ class RecordingTimerView: UIView {
         }
         label.text = nil
     }
-
+    
     // MARK: -
-
+    
     private var timer: Timer?
-
+    
     private lazy var timeFormatter: DateFormatter = {
         let formatter = DateFormatter()
         formatter.dateFormat = "mm:ss"
         formatter.timeZone = TimeZone(identifier: "UTC")!
-
+        
         return formatter
     }()
-
+    
     // This method should only be called when the call state is "connected".
     var recordingDuration: TimeInterval {
         guard let recordingStartTime = recordingStartTime else {
             return 0
         }
-
+        
         return CACurrentMediaTime() - recordingStartTime
     }
-
+    
     @objc
     private func updateView() {
         let recordingDuration = self.recordingDuration
@@ -1068,164 +1029,16 @@ class RecordingTimerView: UIView {
     }
 }
 
-// MARK: Movie Lock
-
-protocol MovieLockViewDelegate: AnyObject {
-    func videoLockViewDidTapStop(_ videoLockView: MovieLockView)
-}
-
-@objc
-public class MovieLockView: UIView {
-
-    weak var delegate: MovieLockViewDelegate?
-
-    public enum SwipeDirection {
-        case trailing
-        case leading
-    }
-
-    public let swipeDirectionToLock: SwipeDirection
-
-    public init(swipeDirectionToLock: SwipeDirection) {
-        self.swipeDirectionToLock = swipeDirectionToLock
-        super.init(frame: .zero)
-
-        addSubview(stopButton)
-        stopButton.autoVCenterInSuperview()
-        stopButton.alpha = 0
-
-        addSubview(highlightView)
-        highlightView.autoVCenterInSuperview()
-        highlightView.alpha = 0
-
-        addSubview(lockIconView)
-        lockIconView.autoVCenterInSuperview()
-
-        let trailingView: UIView
-        let leadingView: UIView
-        switch swipeDirectionToLock {
-        case .trailing:
-            trailingView = lockIconView
-            leadingView = stopButton
-            highlightEdgeConstraint = highlightView.autoPinEdge(toSuperviewEdge: .leading)
-        case .leading:
-            trailingView = stopButton
-            leadingView = lockIconView
-            highlightEdgeConstraint = highlightView.autoPinEdge(toSuperviewEdge: .trailing)
-        }
-
-        trailingView.centerXAnchor.constraint(equalTo: trailingAnchor,
-                                              constant: -highlightViewWidth/2).isActive = true
-        leadingView.centerXAnchor.constraint(equalTo: leadingAnchor,
-                                             constant: highlightViewWidth/2).isActive = true
-
-    }
-
-    required init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
-
-    public func update(xOffset: CGFloat) {
-        let effectiveDistance: CGFloat
-        let distanceToLock: CGFloat
-        let highlightOffset: CGFloat
-        switch swipeDirectionToLock {
-        case .trailing:
-            let minDistanceBeforeActivatingLockSlider: CGFloat = 30
-            effectiveDistance = xOffset - minDistanceBeforeActivatingLockSlider
-            distanceToLock = frame.width - highlightView.frame.width
-            highlightOffset = effectiveDistance.clamp(0, distanceToLock)
-        case .leading:
-            // On iPad, the gesture already feels right, without applying the additional
-            // minDistanceBeforeActivatingLockSlider padding.
-            effectiveDistance = xOffset
-            distanceToLock = -1 * (frame.width - highlightView.frame.width)
-            highlightOffset = effectiveDistance.clamp(distanceToLock, 0)
-        }
-        highlightEdgeConstraint.constant = highlightOffset
-
-        let alpha = (effectiveDistance/distanceToLock).clamp(0, 1)
-        highlightView.alpha = alpha
-
-        if alpha == 1.0 {
-            lock(isAnimated: true)
-        }
-        Logger.verbose("xOffset: \(xOffset), effectiveDistance: \(effectiveDistance),  distanceToLock: \(distanceToLock), highlightOffset: \(highlightOffset), alpha: \(alpha)")
-    }
-
-    // MARK: -
-
-    private(set) var isLocked = false
-
-    public func unlock(isAnimated: Bool) {
-        Logger.debug("")
-        guard isLocked else {
-            Logger.debug("ignoring redundant request")
-            return
-        }
-        Logger.debug("unlocking")
-
-        isLocked = false
-        let changes = {
-            self.lockIconView.tintColor = .white
-            self.stopButton.alpha = 0
-            self.highlightView.alpha = 0
-        }
-
-        if isAnimated {
-            UIView.animate(withDuration: 0.2, animations: changes)
-        } else {
-            changes()
-        }
-    }
-
-    private func lock(isAnimated: Bool) {
-        guard !isLocked else {
-            Logger.debug("ignoring redundant request")
-            return
-        }
-        Logger.debug("locking")
-
-        isLocked = true
-        let changes = {
-            self.lockIconView.tintColor = .black
-            self.stopButton.alpha = 1.0
-        }
-
-        if isAnimated {
-            UIView.animate(withDuration: 0.2, animations: changes)
-        } else {
-            changes()
-        }
+private extension UIView {
+    
+    func embeddedInContainerView(layoutMargins: UIEdgeInsets = .zero) -> UIView {
+        var containerViewFrame = bounds
+        containerViewFrame.width += layoutMargins.leading + layoutMargins.trailing
+        containerViewFrame.height += layoutMargins.top + layoutMargins.bottom
+        let containerView = UIView(frame: containerViewFrame)
+        containerView.layoutMargins = layoutMargins
+        containerView.addSubview(self)
+        autoPinEdgesToSuperviewMargins()
+        return containerView
     }
-
-    // MARK: - Subviews
-
-    let lockIconWidth: CGFloat = 24
-    private lazy var lockIconView: UIImageView = {
-        let imageView = UIImageView.withTemplateImage(#imageLiteral(resourceName: "ic_lock_outline"), tintColor: .white)
-        imageView.autoSetDimensions(to: CGSize(square: lockIconWidth))
-        return imageView
-    }()
-
-    let highlightViewWidth = SendMediaNavigationController.bottomButtonWidth
-    private var highlightEdgeConstraint: NSLayoutConstraint!
-    private lazy var highlightView: UIView = {
-        let view = CircleView(diameter: highlightViewWidth)
-        view.backgroundColor = .white
-        return view
-    }()
-
-    let stopButtonWidth: CGFloat = 30
-    public lazy var stopButton: UIButton = {
-        let view = OWSButton { [weak self] in
-            guard let self = self else { return }
-            self.delegate?.videoLockViewDidTapStop(self)
-        }
-
-        view.backgroundColor = .white
-        view.autoSetDimensions(to: CGSize(square: stopButtonWidth))
-
-        return view
-    }()
 }
diff --git a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
index e476c8bd18e..294a2ba5441 100644
--- a/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
+++ b/Signal/src/ViewControllers/Photos/SendMediaNavigationController.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -38,23 +38,8 @@ class CameraFirstCaptureNavigationController: SendMediaNavigationController {
     }
 }
 
-public let fixedBottomSafeAreaInset: CGFloat = 20
-public let fixedHorizontalMargin: CGFloat = 16
-
 @objc
 class SendMediaNavigationController: OWSNavigationController {
-    static var bottomButtonsCenterOffset: CGFloat {
-        if UIDevice.current.hasIPhoneXNotch {
-            // we pin to a constant rather than margin, because on notched devices the
-            // safeAreaInsets/margins change as the device rotates *EVEN THOUGH* the interface
-            // is locked to portrait.
-            return -1 * (CaptureButton.recordingDiameter / 2 + 4) - fixedBottomSafeAreaInset
-        } else {
-            return -1 * (CaptureButton.recordingDiameter / 2 + 4)
-        }
-    }
-
-    static var trailingButtonsOffset: CGFloat = -28
 
     var attachmentCount: Int {
         return attachmentDraftCollection.count
@@ -66,7 +51,6 @@ class SendMediaNavigationController: OWSNavigationController {
         guard !CurrentAppContext().hasActiveCall else {
             return false
         }
-
         return true
     }
 
@@ -74,61 +58,12 @@ class SendMediaNavigationController: OWSNavigationController {
         super.viewDidLoad()
 
         self.delegate = self
-
-        let bottomButtonsCenterOffset = SendMediaNavigationController.bottomButtonsCenterOffset
-
-        view.addSubview(batchModeButton)
-        batchModeButton.setCompressionResistanceHigh()
-
-        view.addSubview(doneButton)
-        doneButton.setCompressionResistanceHigh()
-
-        view.addSubview(cameraModeButton)
-        cameraModeButton.setCompressionResistanceHigh()
-
-        view.addSubview(mediaLibraryModeButton)
-        mediaLibraryModeButton.setCompressionResistanceHigh()
-
-        if UIDevice.current.isIPad {
-            let buttonSpacing: CGFloat = 28
-            // `doneButton` is our widest button, so we position it relative to the superview
-            // margin, and position other buttons relative to `doneButton`. This ensures
-            // `donebutton` has a good distance from the edge *and* that all the buttons in the
-            // cluster are centered WRT eachother.
-            doneButton.autoPinEdge(toSuperviewMargin: .trailing)
-            doneButton.bottomAnchor.constraint(equalTo: view.layoutMarginsGuide.bottomAnchor, constant: -buttonSpacing).isActive = true
-
-            batchModeButton.autoAlignAxis(.vertical, toSameAxisOf: doneButton)
-            batchModeButton.autoAlignAxis(.horizontal, toSameAxisOf: doneButton)
-
-            cameraModeButton.autoAlignAxis(.vertical, toSameAxisOf: doneButton)
-            cameraModeButton.autoPinEdge(.bottom, to: .top, of: doneButton, withOffset: -buttonSpacing)
-
-            mediaLibraryModeButton.autoAlignAxis(.vertical, toSameAxisOf: cameraModeButton)
-            mediaLibraryModeButton.autoAlignAxis(.horizontal, toSameAxisOf: cameraModeButton)
-        } else {
-            // we pin to edges rather than margin, because on notched devices the safeAreaInsets/margins change
-            // as the device rotates *EVEN THOUGH* the interface is locked to portrait.
-
-            batchModeButton.centerYAnchor.constraint(equalTo: view.bottomAnchor, constant: bottomButtonsCenterOffset).isActive = true
-            batchModeButton.autoPinEdge(toSuperviewEdge: .trailing, withInset: 16)
-
-            doneButton.centerYAnchor.constraint(equalTo: view.bottomAnchor, constant: bottomButtonsCenterOffset).isActive = true
-            doneButton.autoPinEdge(toSuperviewEdge: .trailing, withInset: 16)
-
-            cameraModeButton.centerYAnchor.constraint(equalTo: view.bottomAnchor, constant: bottomButtonsCenterOffset).isActive = true
-            cameraModeButton.autoPinEdge(toSuperviewEdge: .leading, withInset: 16)
-
-            mediaLibraryModeButton.centerYAnchor.constraint(equalTo: view.bottomAnchor, constant: bottomButtonsCenterOffset).isActive = true
-            mediaLibraryModeButton.autoPinEdge(toSuperviewEdge: .leading, withInset: 16)
-        }
     }
 
     override func viewDidAppear(_ animated: Bool) {
         super.viewDidAppear(animated)
         DispatchQueue.main.async {
-            // pre-layout views for snappier response should the user
-            // decide to switch
+            // Pre-layout views for snappier response should the user decide to switch.
 
             if PHPhotoLibrary.authorizationStatus() == .authorized {
                 self.mediaLibraryViewController.view.layoutIfNeeded()
@@ -184,96 +119,6 @@ class SendMediaNavigationController: OWSNavigationController {
         return navController
     }
 
-    private var isForcingBatchSelectInMediaLibrary = true
-
-    private var isShowingMediaLibrary = false
-    private var isRecordingMovie = false
-
-    var isInBatchSelectMode: Bool {
-        get {
-            if isForcingBatchSelectInMediaLibrary && isShowingMediaLibrary {
-                return true
-            }
-            return self.batchModeButton.isSelected
-        }
-
-        set {
-            let didChange = newValue != isInBatchSelectMode
-            self.batchModeButton.isSelected = newValue
-
-            if didChange {
-                mediaLibraryViewController.batchSelectModeDidChange()
-                guard let topViewController = viewControllers.last else {
-                    return
-                }
-                updateViewState(topViewController: topViewController, animated: false)
-            }
-        }
-    }
-
-    func updateViewState(topViewController: UIViewController, animated: Bool) {
-        let changes: () -> Void
-        switch topViewController {
-        case is AttachmentApprovalViewController:
-            changes = {
-                self.isShowingMediaLibrary = false
-                self.batchModeButton.alpha = 0
-                self.doneButton.alpha = 0
-                self.cameraModeButton.alpha = 0
-                self.mediaLibraryModeButton.alpha = 0
-            }
-        case let mediaLibraryView as ImagePickerGridController:
-            changes = {
-                self.isShowingMediaLibrary = true
-                let showDoneButton = self.isInBatchSelectMode && self.attachmentCount > 0
-                self.doneButton.alpha = showDoneButton ? 1 : 0
-
-                self.batchModeButton.alpha = showDoneButton || self.isForcingBatchSelectInMediaLibrary ? 0 : 1
-                self.batchModeButton.isBeingPresentedOverPhotoCapture = false
-
-                self.cameraModeButton.alpha = 1
-                self.cameraModeButton.isBeingPresentedOverPhotoCapture = false
-
-                self.mediaLibraryModeButton.alpha = 0
-                self.mediaLibraryModeButton.isBeingPresentedOverPhotoCapture = false
-
-                mediaLibraryView.applyBatchSelectMode()
-            }
-        case is PhotoCaptureViewController:
-            changes = {
-                self.isShowingMediaLibrary = false
-                let showDoneButton = self.isInBatchSelectMode && self.attachmentCount > 0
-                self.doneButton.alpha = !showDoneButton || self.isRecordingMovie ? 0 : 1
-
-                self.batchModeButton.alpha = showDoneButton || self.isRecordingMovie ? 0 : 1
-                self.batchModeButton.isBeingPresentedOverPhotoCapture = true
-
-                self.cameraModeButton.alpha = 0
-                self.cameraModeButton.isBeingPresentedOverPhotoCapture = true
-
-                self.mediaLibraryModeButton.alpha = self.isRecordingMovie ? 0 : 1
-                self.mediaLibraryModeButton.isBeingPresentedOverPhotoCapture = true
-            }
-        case is ConversationPickerViewController:
-            changes = {
-                self.doneButton.alpha = 0
-                self.batchModeButton.alpha = 0
-                self.cameraModeButton.alpha = 0
-                self.mediaLibraryModeButton.alpha = 0
-            }
-        default:
-            owsFailDebug("unexpected topViewController: \(topViewController)")
-            changes = { }
-        }
-
-        if animated {
-            UIView.animate(withDuration: 0.3, animations: changes)
-        } else {
-            changes()
-        }
-        doneButton.updateCount()
-    }
-
     func fadeTo(viewControllers: [UIViewController], duration: CFTimeInterval) {
         AssertIsOnMainThread()
 
@@ -284,63 +129,6 @@ class SendMediaNavigationController: OWSNavigationController {
         setViewControllers(viewControllers, animated: false)
     }
 
-    // MARK: - Events
-
-    private func didTapBatchModeButton() {
-        isInBatchSelectMode = !isInBatchSelectMode
-        owsAssertDebug(isInBatchSelectMode || attachmentCount <= 1)
-    }
-
-    private func didTapCameraModeButton() {
-        self.ows_askForCameraPermissions { isGranted in
-            guard isGranted else { return }
-
-            BenchEventStart(title: "Show-Camera", eventId: "Show-Camera")
-            self.fadeTo(viewControllers: [self.captureViewController], duration: 0.08)
-        }
-    }
-
-    private func didTapMediaLibraryModeButton() {
-        self.ows_askForMediaLibraryPermissions { isGranted in
-            guard isGranted else { return }
-
-            BenchEventStart(title: "Show-Media-Library", eventId: "Show-Media-Library")
-            self.fadeTo(viewControllers: [self.mediaLibraryViewController], duration: 0.08)
-        }
-    }
-
-    // MARK: Views
-    public static let bottomButtonWidth: CGFloat = 44
-
-    private lazy var doneButton: DoneButton = {
-        let button = DoneButton()
-        button.delegate = self
-        button.setShadow()
-
-        return button
-    }()
-
-    private lazy var batchModeButton: SendMediaBottomButton = {
-        return SendMediaBottomButton(imageName: "create-album-filled-28",
-                                     tintColor: .ows_white,
-                                     diameter: type(of: self).bottomButtonWidth,
-                                     block: { [weak self] in self?.didTapBatchModeButton() })
-    }()
-
-    private lazy var cameraModeButton: SendMediaBottomButton = {
-        return SendMediaBottomButton(imageName: "camera-outline-28",
-                                     tintColor: .ows_white,
-                                     diameter: type(of: self).bottomButtonWidth,
-                                     block: { [weak self] in self?.didTapCameraModeButton() })
-    }()
-
-    private lazy var mediaLibraryModeButton: SendMediaBottomButton = {
-        return SendMediaBottomButton(imageName: "photo-outline-28",
-                                     tintColor: .ows_white,
-                                     diameter: type(of: self).bottomButtonWidth,
-                                     block: { [weak self] in self?.didTapMediaLibraryModeButton() })
-    }()
-
     // MARK: State
 
     private var attachmentDraftCollection: AttachmentDraftCollection = .empty
@@ -354,22 +142,19 @@ class SendMediaNavigationController: OWSNavigationController {
     fileprivate lazy var captureViewController: PhotoCaptureViewController = {
         let vc = PhotoCaptureViewController()
         vc.delegate = self
-
+        vc.dataSource = self
         return vc
     }()
 
     private lazy var mediaLibraryViewController: ImagePickerGridController = {
         let vc = ImagePickerGridController()
         vc.delegate = self
-
         return vc
     }()
 
-    private func pushApprovalViewController(
-        attachmentApprovalItems: [AttachmentApprovalItem],
-        options: AttachmentApprovalViewControllerOptions = .canAddMore,
-        animated: Bool
-    ) {
+    private func pushApprovalViewController(attachmentApprovalItems: [AttachmentApprovalItem],
+                                            options: AttachmentApprovalViewControllerOptions = .canAddMore,
+                                            animated: Bool) {
         guard let sendMediaNavDelegate = self.sendMediaNavDelegate else {
             owsFailDebug("sendMediaNavDelegate was unexpectedly nil")
             return
@@ -396,49 +181,44 @@ class SendMediaNavigationController: OWSNavigationController {
 
             let confirmAbandonText = NSLocalizedString("SEND_MEDIA_CONFIRM_ABANDON_ALBUM", comment: "alert action, confirming the user wants to exit the media flow and abandon any photos they've taken")
             let confirmAbandonAction = ActionSheetAction(title: confirmAbandonText,
-                                                     style: .destructive,
-                                                     handler: { [weak self] _ in
-                                                        guard let self = self else { return }
-                                                        self.sendMediaNavDelegate?.sendMediaNavDidCancel(self)
+                                                         style: .destructive,
+                                                         handler: { [weak self] _ in
+                guard let self = self else { return }
+                self.sendMediaNavDelegate?.sendMediaNavDidCancel(self)
             })
             alert.addAction(confirmAbandonAction)
             let dontAbandonAction = ActionSheetAction(title: dontAbandonText,
-                                                  style: .default,
-                                                  handler: { _ in  })
+                                                      style: .default,
+                                                      handler: { _ in  })
             alert.addAction(dontAbandonAction)
 
             self.presentActionSheet(alert)
         }
     }
+
 }
 
 extension SendMediaNavigationController: UINavigationControllerDelegate {
+
     func navigationController(_ navigationController: UINavigationController, willShow viewController: UIViewController, animated: Bool) {
         updateNavbarTheme(for: viewController, animated: animated)
 
         switch viewController {
         case is PhotoCaptureViewController:
-            if attachmentDraftCollection.count == 1 && !isInBatchSelectMode {
+            if attachmentDraftCollection.count == 1 {
                 // User is navigating "back" to the previous view, indicating
                 // they want to discard the previously captured item
                 discardDraft()
             }
-        case is ImagePickerGridController:
-            if attachmentDraftCollection.count == 1 && !isInBatchSelectMode {
-                isInBatchSelectMode = true
-                mediaLibraryViewController.reloadData()
-            }
+
         default:
             break
         }
-
-        updateViewState(topViewController: viewController, animated: false)
     }
 
     // In case back navigation was canceled, we re-apply whatever is showing.
     func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
         updateNavbarTheme(for: viewController, animated: animated)
-        updateViewState(topViewController: viewController, animated: false)
     }
 
     func navigationControllerSupportedInterfaceOrientations(_ navigationController: UINavigationController) -> UIInterfaceOrientationMask {
@@ -479,34 +259,23 @@ extension SendMediaNavigationController: UINavigationControllerDelegate {
     // MARK: - Too Many
 
     func showTooManySelectedToast() {
-        Logger.info("")
-
         let toastFormat = NSLocalizedString("IMAGE_PICKER_CAN_SELECT_NO_MORE_TOAST_FORMAT",
                                             comment: "Momentarily shown to the user when attempting to select more images than is allowed. Embeds {{max number of items}} that can be shared.")
 
         let toastText = String(format: toastFormat, NSNumber(value: SignalAttachment.maxAttachmentsAllowed))
-
         let toastController = ToastController(text: toastText)
-
-        let kToastInset: CGFloat = 10
-        let bottomInset = kToastInset + view.layoutMargins.bottom
-
-        toastController.presentToastView(fromBottomOfView: view, inset: bottomInset)
+        toastController.presentToastView(fromBottomOfView: view, inset: view.layoutMargins.bottom + 10)
     }
 }
 
 extension SendMediaNavigationController: PhotoCaptureViewControllerDelegate {
 
-    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController, didFinishProcessingAttachment attachment: SignalAttachment) {
-        guard let sendMediaNavDelegate = self.sendMediaNavDelegate else { return }
-        let cameraCaptureAttachment = CameraCaptureAttachment(signalAttachment: attachment, canSave: sendMediaNavDelegate.sendMediaNavCanSaveAttachments)
-        attachmentDraftCollection.append(.camera(attachment: cameraCaptureAttachment))
-        if isInBatchSelectMode {
-            updateViewState(topViewController: photoCaptureViewController, animated: false)
-        } else {
-            pushApprovalViewController(attachmentApprovalItems: [cameraCaptureAttachment.attachmentApprovalItem],
-                                       animated: true)
+    func photoCaptureViewControllerDidFinish(_ photoCaptureViewController: PhotoCaptureViewController) {
+        guard attachmentDraftCollection.count > 0 else {
+            owsFailDebug("No camera attachments found")
+            return
         }
+        showApprovalAfterProcessingAnyMediaLibrarySelections()
     }
 
     func photoCaptureViewControllerDidCancel(_ photoCaptureViewController: PhotoCaptureViewController) {
@@ -530,18 +299,53 @@ extension SendMediaNavigationController: PhotoCaptureViewControllerDelegate {
         owsAssertDebug(attachmentDraftCollection.attachmentDrafts.count == 0)
     }
 
-    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController, isRecordingMovie: Bool) {
-        self.isRecordingMovie = isRecordingMovie
-        updateViewState(topViewController: photoCaptureViewController, animated: true)
+    func photoCaptureViewControllerDidRequestPresentPhotoLibrary(_ photoCaptureViewController: PhotoCaptureViewController) {
+        self.ows_askForMediaLibraryPermissions { isGranted in
+            guard isGranted else { return }
+
+            BenchEventStart(title: "Show-Media-Library", eventId: "Show-Media-Library")
+            self.pushViewController(self.mediaLibraryViewController, animated: true)
+        }
+    }
+
+    func photoCaptureViewController(_ photoCaptureViewController: PhotoCaptureViewController, didRequestSwitchBatchMode batchMode: Bool) -> Bool {
+        if batchMode {
+            // Always can be enabled
+            return true
+        }
+        // Can only be disabled if there's one or less media item.
+        return attachmentCount > 1
+    }
+}
+
+extension SendMediaNavigationController: PhotoCaptureViewControllerDataSource {
+
+    var numberOfMediaItems: Int {
+        attachmentCount
+    }
+
+    func addMedia(attachment: SignalAttachment) {
+        guard let sendMediaNavDelegate = self.sendMediaNavDelegate else { return }
+        let cameraCaptureAttachment = CameraCaptureAttachment(signalAttachment: attachment, canSave: sendMediaNavDelegate.sendMediaNavCanSaveAttachments)
+        attachmentDraftCollection.append(.camera(attachment: cameraCaptureAttachment))
     }
 }
 
 extension SendMediaNavigationController: ImagePickerGridControllerDelegate {
 
-    func imagePickerDidCompleteSelection(_ imagePicker: ImagePickerGridController) {
+    func imagePickerDidRequestSendMedia(_ imagePicker: ImagePickerGridController) {
         showApprovalAfterProcessingAnyMediaLibrarySelections()
     }
 
+    func imagePickerDidRequestPresentCamera(_ imagePicker: ImagePickerGridController) {
+        if let cameraViewController = viewControllers.first as? PhotoCaptureViewController {
+            popToViewController(cameraViewController, animated: true)
+            return
+        }
+
+        fadeTo(viewControllers: [ captureViewController ], duration: 0.2)
+    }
+
     func imagePickerDidCancel(_ imagePicker: ImagePickerGridController) {
         let dontAbandonText = NSLocalizedString("SEND_MEDIA_RETURN_TO_MEDIA_LIBRARY", comment: "alert action when the user decides not to cancel the media flow after all.")
         didRequestExit(dontAbandonText: dontAbandonText)
@@ -600,8 +404,6 @@ extension SendMediaNavigationController: ImagePickerGridControllerDelegate {
 
         let libraryMedia = MediaLibraryAttachment(asset: asset, attachmentApprovalItemPromise: attachmentApprovalItemPromise)
         attachmentDraftCollection.append(.picker(attachment: libraryMedia))
-
-        updateViewState(topViewController: imagePicker, animated: false)
     }
 
     func imagePicker(_ imagePicker: ImagePickerGridController, didDeselectAsset asset: PHAsset) {
@@ -609,8 +411,6 @@ extension SendMediaNavigationController: ImagePickerGridControllerDelegate {
             return
         }
         attachmentDraftCollection.remove(.picker(attachment: draft))
-
-        updateViewState(topViewController: imagePicker, animated: false)
     }
 
     func imagePickerCanSelectMoreItems(_ imagePicker: ImagePickerGridController) -> Bool {
@@ -625,7 +425,6 @@ extension SendMediaNavigationController: ImagePickerGridControllerDelegate {
 extension SendMediaNavigationController: AttachmentApprovalViewControllerDelegate {
 
     func attachmentApprovalDidAppear(_ attachmentApproval: AttachmentApprovalViewController) {
-        updateViewState(topViewController: attachmentApproval, animated: true)
     }
 
     func attachmentApproval(_ attachmentApproval: AttachmentApprovalViewController, didChangeMessageBody newMessageBody: MessageBody?) {
@@ -653,9 +452,6 @@ extension SendMediaNavigationController: AttachmentApprovalViewControllerDelegat
         // Current design dicates we'll go "back" to the single thing before us.
         owsAssertDebug(viewControllers.count == 2)
 
-        // regardless of which VC we're going "back" to, we're in "batch" mode at this point.
-        isInBatchSelectMode = true
-
         popViewController(animated: true)
     }
 
@@ -796,98 +592,3 @@ private struct MediaLibraryAttachment: Hashable, Equatable {
         return lhs.asset == rhs.asset
     }
 }
-
-extension SendMediaNavigationController: DoneButtonDelegate {
-    var doneButtonCount: Int {
-        return attachmentCount
-    }
-
-    fileprivate func doneButtonWasTapped(_ doneButton: DoneButton) {
-        owsAssertDebug(attachmentDraftCollection.count > 0)
-        showApprovalAfterProcessingAnyMediaLibrarySelections()
-    }
-}
-
-private protocol DoneButtonDelegate: AnyObject {
-    func doneButtonWasTapped(_ doneButton: DoneButton)
-    var doneButtonCount: Int { get }
-}
-
-private class DoneButton: UIView {
-    weak var delegate: DoneButtonDelegate?
-
-    init() {
-        super.init(frame: .zero)
-        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(didTap(tapGesture:)))
-        addGestureRecognizer(tapGesture)
-
-        let container = PillView()
-        container.backgroundColor = .ows_white
-        container.layoutMargins = UIEdgeInsets(top: 7, leading: 8, bottom: 7, trailing: 8)
-
-        addSubview(container)
-        container.autoPinEdgesToSuperviewMargins()
-
-        let stackView = UIStackView(arrangedSubviews: [badge, chevron])
-        stackView.axis = .horizontal
-        stackView.alignment = .center
-        stackView.spacing = 9
-
-        container.addSubview(stackView)
-        stackView.autoPinEdgesToSuperviewMargins()
-    }
-
-    let numberFormatter: NumberFormatter = NumberFormatter()
-
-    func updateCount() {
-        guard let delegate = delegate else {
-            return
-        }
-
-        badgeLabel.text = numberFormatter.string(for: delegate.doneButtonCount)
-    }
-
-    required init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
-
-    // MARK: - Subviews
-
-    private lazy var badge: UIView = {
-        let badge = PillView()
-        badge.layoutMargins = UIEdgeInsets(top: 4, leading: 4, bottom: 4, trailing: 4)
-        badge.backgroundColor = .ows_accentBlue
-        badge.addSubview(badgeLabel)
-        badgeLabel.autoPinEdgesToSuperviewMargins()
-
-        return badge
-    }()
-
-    private lazy var badgeLabel: UILabel = {
-        let label = UILabel()
-        label.textColor = .ows_white
-        label.font = UIFont.ows_dynamicTypeSubheadline.ows_monospaced
-        label.textAlignment = .center
-        return label
-    }()
-
-    private lazy var chevron: UIView = {
-        let image: UIImage
-        if CurrentAppContext().isRTL {
-            image = #imageLiteral(resourceName: "small_chevron_left")
-        } else {
-            image = #imageLiteral(resourceName: "small_chevron_right")
-        }
-        let chevron = UIImageView(image: image.withRenderingMode(.alwaysTemplate))
-        chevron.contentMode = .scaleAspectFit
-        chevron.tintColor = .ows_gray60
-        chevron.autoSetDimensions(to: CGSize(width: 10, height: 18))
-
-        return chevron
-    }()
-
-    @objc
-    func didTap(tapGesture: UITapGestureRecognizer) {
-        delegate?.doneButtonWasTapped(self)
-    }
-}
diff --git a/SignalUI/Views/CircleView.swift b/SignalUI/Views/CircleView.swift
index cd3f84f060f..0fc874e036a 100644
--- a/SignalUI/Views/CircleView.swift
+++ b/SignalUI/Views/CircleView.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
 //
 
 import UIKit
