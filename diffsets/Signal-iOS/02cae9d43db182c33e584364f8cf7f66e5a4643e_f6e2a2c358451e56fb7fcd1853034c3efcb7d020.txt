diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift
index fa610df75e0..d3081bf49ba 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+OWS.swift
@@ -65,6 +65,87 @@ extension ConversationViewController {
         }
         return true
     }
+
+    // MARK: -
+
+    @objc(updateContentInsetsAnimated:)
+    public func updateContentInsets(animated: Bool) {
+        AssertIsOnMainThread()
+
+        guard !isMeasuringKeyboardHeight else {
+            return
+        }
+
+        // Don't update the content insets if an interactive pop is in progress
+        guard let navigationController = self.navigationController else {
+            return
+        }
+        if let interactivePopGestureRecognizer = navigationController.interactivePopGestureRecognizer {
+            switch interactivePopGestureRecognizer.state {
+            case .possible, .failed:
+                break
+            default:
+                return
+            }
+        }
+
+        view.layoutIfNeeded()
+
+        let oldInsets = collectionView.contentInset
+        var newInsets = oldInsets
+
+        let keyboardOverlap = inputAccessoryPlaceholder.keyboardOverlap
+        newInsets.bottom = (messageActionsExtraContentInsetPadding +
+                                keyboardOverlap +
+                                bottomBar.height -
+                                view.safeAreaInsets.bottom)
+        newInsets.top = messageActionsExtraContentInsetPadding
+
+        let wasScrolledToBottom = self.isScrolledToBottom
+        
+        // Changing the contentInset can change the contentOffset, so make sure we
+        // stash the current value before making any changes.
+        let oldYOffset = collectionView.contentOffset.y
+
+        let didChangeInsets = oldInsets != newInsets
+
+        UIView.performWithoutAnimation {
+            if didChangeInsets {
+                self.collectionView.contentInset = newInsets
+            }
+            self.collectionView.scrollIndicatorInsets = newInsets
+        }
+        
+        // Adjust content offset to prevent the presented keyboard from obscuring content.
+        if !didChangeInsets {
+            // Do nothing.
+            //
+            // If content inset didn't change, no need to update content offset.
+        } else if !hasAppearedAndHasAppliedFirstLoad {
+            // Do nothing.
+        } else if wasScrolledToBottom {
+            // If we were scrolled to the bottom, don't do any fancy math. Just stay at the bottom.
+            scrollToBottomOfLoadWindow(animated: false)
+        } else if isViewCompletelyAppeared {
+            // If we were scrolled away from the bottom, shift the content in lockstep with the
+            // keyboard, up to the limits of the content bounds.
+            let insetChange = newInsets.bottom - oldInsets.bottom
+
+            // Only update the content offset if the inset has changed.
+            if insetChange != 0 {
+                // The content offset can go negative, up to the size of the top layout guide.
+                // This accounts for the extended layout under the navigation bar.
+                owsAssertDebug(topLayoutGuide.length == view.safeAreaInsets.top)
+                let minYOffset = -view.safeAreaInsets.top
+                let newYOffset = (oldYOffset + insetChange).clamp(minYOffset, safeContentHeight)
+                let newOffset = CGPoint(x: 0, y: newYOffset)
+
+                UIView.performWithoutAnimation {
+                    collectionView.setContentOffset(newOffset, animated: false)
+                }
+            }
+        }
+    }
 }
 
 // MARK: - ForwardMessageDelegate
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
index f4932e5bbe9..43c530743fd 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+Scroll.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -129,10 +129,8 @@ extension ConversationViewController {
 
     @objc
     func scrollToBottomOfLoadWindow(animated: Bool) {
-        guard let interactionId = renderItems.last?.interactionUniqueId else {
-            return
-        }
-        scrollToInteraction(uniqueId: interactionId, alignment: .bottom, animated: animated)
+        let newContentOffset = CGPoint(x: 0, y: maxContentOffsetY)
+        collectionView.setContentOffset(newContentOffset, animated: animated)
     }
 
     @objc(scrollToInitialPositionAnimated:)
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.h b/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
index 9d673d1923c..f797164bd52 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.h
@@ -91,7 +91,6 @@ typedef NS_CLOSED_ENUM(NSUInteger, ConversationUIMode) {
 
 - (void)updateBarButtonItems;
 - (void)ensureBannerState;
-- (void)updateContentInsetsAnimated:(BOOL)animated;
 
 // TODO: Remove or rework method.
 - (void)reloadCollectionView;
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 4b6cf0f072b..9591b946768 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -3956,79 +3956,6 @@ - (void)handleKeyboardStateChange:(NSTimeInterval)animationDuration animationCur
     }
 }
 
-// MARK: -
-
-- (void)updateContentInsetsAnimated:(BOOL)animated
-{
-    OWSAssertIsOnMainThread();
-
-    if (self.isMeasuringKeyboardHeight) {
-        return;
-    }
-
-    // Don't update the content insets if an interactive pop is in progress
-    switch (self.navigationController.interactivePopGestureRecognizer.state) {
-        case UIGestureRecognizerStatePossible:
-        case UIGestureRecognizerStateFailed:
-            break;
-        default:
-            return;
-    }
-
-    [self.view layoutIfNeeded];
-
-    UIEdgeInsets oldInsets = self.collectionView.contentInset;
-    UIEdgeInsets newInsets = oldInsets;
-
-    newInsets.bottom = self.messageActionsExtraContentInsetPadding + self.inputAccessoryPlaceholder.keyboardOverlap
-        + self.bottomBar.height - self.view.safeAreaInsets.bottom;
-    newInsets.top = self.messageActionsExtraContentInsetPadding;
-
-    BOOL wasScrolledToBottom = [self isScrolledToBottom];
-
-    // Changing the contentInset can change the contentOffset, so make sure we
-    // stash the current value before making any changes.
-    CGFloat oldYOffset = self.collectionView.contentOffset.y;
-
-    BOOL didChangeInsets = !UIEdgeInsetsEqualToEdgeInsets(oldInsets, newInsets);
-
-    [UIView performWithoutAnimation:^{
-        if (didChangeInsets) {
-            self.collectionView.contentInset = newInsets;
-        }
-        self.collectionView.scrollIndicatorInsets = newInsets;
-    }];
-
-    // Adjust content offset to prevent the presented keyboard from obscuring content.
-    if (!didChangeInsets) {
-        // Do nothing.
-        //
-        // If content inset didn't change, no need to update content offset.
-    } else if (!self.hasAppearedAndHasAppliedFirstLoad) {
-        // Do nothing.
-    } else if (wasScrolledToBottom) {
-        // If we were scrolled to the bottom, don't do any fancy math. Just stay at the bottom.
-        [self scrollToBottomOfLoadWindowWithAnimated:NO];
-    } else if (self.isViewCompletelyAppeared) {
-        // If we were scrolled away from the bottom, shift the content in lockstep with the
-        // keyboard, up to the limits of the content bounds.
-        CGFloat insetChange = newInsets.bottom - oldInsets.bottom;
-
-        // Only update the content offset if the inset has changed.
-        if (insetChange != 0) {
-            // The content offset can go negative, up to the size of the top layout guide.
-            // This accounts for the extended layout under the navigation bar.
-            OWSAssertDebug(self.topLayoutGuide.length == self.view.safeAreaInsets.top);
-            CGFloat minYOffset = -self.view.safeAreaInsets.top;
-
-            CGFloat newYOffset = CGFloatClamp(oldYOffset + insetChange, minYOffset, self.safeContentHeight);
-            CGPoint newOffset = CGPointMake(0, newYOffset);
-
-            [UIView performWithoutAnimation:^{ [self.collectionView setContentOffset:newOffset animated:NO]; }];
-        }
-    }
-}
-
 #pragma mark - Keyboard Shortcuts
 
 - (void)focusInputToolbar
diff --git a/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift b/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift
index 9dd6e124580..dd8bf77822d 100644
--- a/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift
+++ b/SignalMessaging/Views/InputAccessoryViewPlaceholder.swift
@@ -209,7 +209,11 @@ public class InputAccessoryViewPlaceholder: UIView {
         // We only want to do an animated presentation if either a) the height changed or b) the view is
         // starting from off the bottom of the screen (a full presentation). This provides the best experience
         // when canceling an interactive dismissal or changing orientations.
-        guard beginFrame.height != endFrame.height || beginFrame.minY == UIScreen.main.bounds.height else { return }
+        guard beginFrame.height != endFrame.height || beginFrame.minY == UIScreen.main.bounds.height else {
+            delegate?.inputAccessoryPlaceholderKeyboardIsPresenting(animationDuration: 0,
+                                                                    animationCurve: .linear)
+            return
+        }
 
         keyboardState = .presenting(frame: endFrame)
 
