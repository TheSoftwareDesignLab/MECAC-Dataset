diff --git a/Signal/ConversationView/ConversationInputTextView.swift b/Signal/ConversationView/ConversationInputTextView.swift
index 472e23c3f0..0bdf187a7b 100644
--- a/Signal/ConversationView/ConversationInputTextView.swift
+++ b/Signal/ConversationView/ConversationInputTextView.swift
@@ -17,7 +17,6 @@ public protocol ConversationInputTextViewDelegate: AnyObject {
 protocol ConversationTextViewToolbarDelegate: AnyObject {
     func textViewDidChange(_ textView: UITextView)
     func textViewDidChangeSelection(_ textView: UITextView)
-    func textViewDidBecomeFirstResponder(_ textView: UITextView)
 }
 
 // MARK: -
@@ -140,19 +139,34 @@ class ConversationInputTextView: BodyRangesTextView {
         updateTextContainerInset()
     }
 
-    override func becomeFirstResponder() -> Bool {
-        let result = super.becomeFirstResponder()
-        if result { textViewToolbarDelegate?.textViewDidBecomeFirstResponder(self) }
-        return result
-    }
-
     var pasteboardHasPossibleAttachment: Bool {
         // We don't want to load/convert images more than once so we
         // only do a cursory validation pass at this time.
         SignalAttachment.pasteboardHasPossibleAttachment() && !SignalAttachment.pasteboardHasText()
     }
 
+    override var inputView: UIView? {
+        didSet {
+            reloadCaret()
+        }
+    }
+
+    // Force UITextView to redraw to make sure the caret is shown/hidden as necessary.
+    private func reloadCaret() {
+        let fullRange = NSRange(location: 0, length: textStorage.length)
+        layoutManager.invalidateLayout(forCharacterRange: fullRange, actualCharacterRange: nil)
+        layoutManager.invalidateDisplay(forCharacterRange: fullRange)
+        layoutManager.ensureLayout(for: textContainer)
+    }
+
+    private var isTextInputMode: Bool {
+        return inputView == nil
+    }
+
     override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
+        guard isTextInputMode else {
+            return false
+        }
         if action == #selector(paste(_:)) {
             if pasteboardHasPossibleAttachment && !super.disallowsAnyPasteAction() {
                 return true
@@ -161,6 +175,20 @@ class ConversationInputTextView: BodyRangesTextView {
         return super.canPerformAction(action, withSender: sender)
     }
 
+    override func caretRect(for position: UITextPosition) -> CGRect {
+        guard isTextInputMode else {
+            return .zero
+        }
+        return super.caretRect(for: position)
+    }
+
+    override func selectionRects(for range: UITextRange) -> [UITextSelectionRect] {
+        guard isTextInputMode else {
+            return []
+        }
+        return super.selectionRects(for: range)
+    }
+
     override func paste(_ sender: Any?) {
         if pasteboardHasPossibleAttachment {
             inputTextViewDelegate?.didAttemptAttachmentPaste()
diff --git a/Signal/ConversationView/ConversationInputToolbar.swift b/Signal/ConversationView/ConversationInputToolbar.swift
index 3a36171c12..47cb9e30b8 100644
--- a/Signal/ConversationView/ConversationInputToolbar.swift
+++ b/Signal/ConversationView/ConversationInputToolbar.swift
@@ -21,6 +21,10 @@ protocol ConversationInputToolbarDelegate: AnyObject {
 
     func isGroup() -> Bool
 
+    // Older iOS versions (<16.0) only have proper `keyboardLayoutGuide` on UIVC's root view,
+    // but might as well request root view for all iOS versions.
+    func viewForKeyboardLayoutGuide() -> UIView
+
     // MARK: Voice Memo
 
     func voiceMemoGestureDidStart()
@@ -1866,16 +1870,14 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
         set { setDesiredKeyboardType(newValue, animated: false) }
     }
 
-    private var stickerKeyboard: StickerKeyboard?
+    private var _stickerKeyboard: StickerKeyboard?
 
-    private func getOrCreateStickerKeyboard() -> StickerKeyboard {
-        if let stickerKeyboard {
+    private var stickerKeyboard: StickerKeyboard {
+        if let stickerKeyboard = _stickerKeyboard {
             return stickerKeyboard
         }
-        let stickerKeyboard = StickerKeyboard()
-        stickerKeyboard.delegate = self
-        stickerKeyboard.registerWithView(self)
-        self.stickerKeyboard = stickerKeyboard
+        let stickerKeyboard = StickerKeyboard(delegate: self)
+        _stickerKeyboard = stickerKeyboard
         return stickerKeyboard
     }
 
@@ -1892,13 +1894,10 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
             return attachmentKeyboard
         }
         let keyboard = AttachmentKeyboard(delegate: self)
-        keyboard.registerWithView(self)
         _attachmentKeyboard = keyboard
         return keyboard
     }
 
-    private var attachmentKeyboardIfLoaded: AttachmentKeyboard? { _attachmentKeyboard }
-
     func showAttachmentKeyboard() {
         AssertIsOnMainThread()
         guard desiredKeyboardType != .attachment else { return }
@@ -1906,7 +1905,7 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
     }
 
     private func toggleKeyboardType(_ keyboardType: KeyboardType, animated: Bool) {
-        guard let inputToolbarDelegate = inputToolbarDelegate else {
+        guard let inputToolbarDelegate else {
             owsFailDebug("inputToolbarDelegate is nil")
             return
         }
@@ -1933,17 +1932,41 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
     private func setDesiredKeyboardType(_ keyboardType: KeyboardType, animated: Bool) {
         guard _desiredKeyboardType != keyboardType else { return }
 
+        // Measure system keyboard size when switching away from it,
+        // but only if we don't know the height for this orientation yet.
+        if  desiredKeyboardType == .system,
+            inputTextView.isFirstResponder,
+            !CustomKeyboard.hasCachedHeight(forTraitCollection: traitCollection)
+        {
+            calculateCustomKeyboardHeight()
+        }
+
         _desiredKeyboardType = keyboardType
 
         ensureButtonVisibility(withAnimation: animated, doLayout: true)
 
-        if isInputViewFirstResponder {
-            // If any keyboard is presented, make sure the correct
-            // keyboard is presented.
-            beginEditingMessage()
+        inputTextView.inputView = desiredInputView
+        inputTextView.reloadInputViews()
+
+        // Add "Tap to switch to system keyboard" behavior.
+        if desiredKeyboardType == .system {
+            inputTextView.removeGestureRecognizer(textInputViewTapGesture)
+        } else if textInputViewTapGesture.view == nil {
+            inputTextView.addGestureRecognizer(textInputViewTapGesture)
+        }
+    }
+
+    private func calculateCustomKeyboardHeight() {
+        guard desiredKeyboardType == .system, inputTextView.isFirstResponder else { return }
+
+        let viewForKeyboardLayoutGuide = inputToolbarDelegate?.viewForKeyboardLayoutGuide() ?? self
+        let keyboardHeight = viewForKeyboardLayoutGuide.keyboardLayoutGuide.layoutFrame.height
+        if keyboardHeight > 100 {
+            Logger.debug("Keyboard height: \(keyboardHeight). Horizontal: \(traitCollection.horizontalSizeClass) Vertical: \(traitCollection.verticalSizeClass)")
+            stickerKeyboard.setSystemKeyboardHeight(keyboardHeight, forTraitCollection: traitCollection)
+            attachmentKeyboard.setSystemKeyboardHeight(keyboardHeight, forTraitCollection: traitCollection)
         } else {
-            // Make sure neither keyboard is presented.
-            endEditingMessage()
+            Logger.warn("Suspicious keyboard height: \(keyboardHeight)")
         }
     }
 
@@ -1954,49 +1977,68 @@ public class ConversationInputToolbar: UIView, LinkPreviewViewDraftDelegate, Quo
 
     private func restoreDesiredKeyboardIfNecessary() {
         AssertIsOnMainThread()
-        if desiredKeyboardType != .system && !desiredFirstResponder.isFirstResponder {
-            desiredFirstResponder.becomeFirstResponder()
+        if desiredKeyboardType != .system && !inputTextView.isFirstResponder {
+            beginEditingMessage()
         }
     }
 
     var isInputViewFirstResponder: Bool {
         return inputTextView.isFirstResponder
-        || stickerKeyboard?.isFirstResponder ?? false
-        || attachmentKeyboardIfLoaded?.isFirstResponder ?? false
     }
 
-    private func ensureFirstResponderState() {
-        restoreDesiredKeyboardIfNecessary()
-    }
-
-    private var desiredFirstResponder: UIResponder {
+    private var desiredInputView: UIInputView? {
         switch desiredKeyboardType {
-        case .system: return inputTextView
-        case .sticker: return getOrCreateStickerKeyboard()
+        case .system: return nil
+        case .sticker: return stickerKeyboard
         case .attachment: return attachmentKeyboard
         }
     }
 
     func beginEditingMessage() {
-        guard !desiredFirstResponder.isFirstResponder else { return }
-        desiredFirstResponder.becomeFirstResponder()
+        _ = inputTextView.becomeFirstResponder()
     }
 
     func endEditingMessage() {
         _ = inputTextView.resignFirstResponder()
-        _ = stickerKeyboard?.resignFirstResponder()
-        _ = attachmentKeyboardIfLoaded?.resignFirstResponder()
     }
 
     func viewDidAppear() {
         ensureButtonVisibility(withAnimation: false, doLayout: false)
     }
 
+    public override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
+        super.traitCollectionDidChange(previousTraitCollection)
+
+        // Starting with iOS 17 UIKit messes up keyboard layout guide on rotation if custom keyboard is up.
+        // That causes the keyboard to overlap text input field and become unaccessible.
+        // The workaround is to hide the keyboard on rotation.
+        guard #available(iOS 17, *) else { return }
+
+        // Require a custom keyboard to be up.
+        guard inputTextView.isFirstResponder, desiredKeyboardType != .system else { return }
+
+        // We only care about changes in size classes, which would be triggered by interface rotation.
+        guard
+            previousTraitCollection?.horizontalSizeClass != traitCollection.horizontalSizeClass ||
+            previousTraitCollection?.verticalSizeClass != traitCollection.verticalSizeClass
+        else { return }
+
+        // Dismiss keyboard.
+        endEditingMessage()
+    }
+
     @objc
     private func applicationDidBecomeActive(notification: Notification) {
         AssertIsOnMainThread()
         restoreDesiredKeyboardIfNecessary()
     }
+
+    private lazy var textInputViewTapGesture = UITapGestureRecognizer(target: self, action: #selector(textInputViewTapped))
+
+    @objc
+    private func textInputViewTapped() {
+        clearDesiredKeyboard()
+    }
 }
 
 // MARK: Button Actions
@@ -2116,6 +2158,17 @@ extension ConversationInputToolbar: ConversationTextViewToolbarDelegate {
         }
     }
 
+    public override func didMoveToSuperview() {
+        super.didMoveToSuperview()
+        // Probably because of a regression in iOS 26 `keyboardLayoutGuide`,
+        // if first accessed in `calculateCustomKeyboardHeight`, would have an
+        // incorrect height of 34 dp (amount of bottom safe area).
+        // Accessing the layout guide before somehow fixes that issue.
+        if #available(iOS 26, *), superview != nil {
+            _ = keyboardLayoutGuide
+        }
+    }
+
     func textViewDidChange(_ textView: UITextView) {
         owsAssertDebug(inputToolbarDelegate != nil)
 
@@ -2132,10 +2185,6 @@ extension ConversationInputToolbar: ConversationTextViewToolbarDelegate {
     }
 
     func textViewDidChangeSelection(_ textView: UITextView) { }
-
-    func textViewDidBecomeFirstResponder(_ textView: UITextView) {
-        setDesiredKeyboardType(.system, animated: true)
-    }
 }
 
 extension ConversationInputToolbar: StickerPickerDelegate {
diff --git a/Signal/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift b/Signal/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
index 435a24b146..8ccfc93107 100644
--- a/Signal/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
+++ b/Signal/ConversationView/ConversationViewController+ConversationInputToolbarDelegate.swift
@@ -19,6 +19,10 @@ extension ConversationViewController: ConversationInputToolbarDelegate {
         isGroupConversation
     }
 
+    public func viewForKeyboardLayoutGuide() -> UIView {
+        return view
+    }
+
     public func sendButtonPressed() {
         AssertIsOnMainThread()
 
diff --git a/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift b/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift
index 4525f7501d..e9fab46858 100644
--- a/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift	
+++ b/Signal/src/ViewControllers/Attachment Keyboard/RecentPhotoCollectionView.swift	
@@ -66,6 +66,7 @@ class RecentPhotosCollectionView: UICollectionView {
             // That delegate method is necessary to allow custom size for "manage access" helper UI.
             setCollectionViewLayout(RecentPhotosCollectionView.collectionViewLayout(itemSize: cellSize), animated: false)
             reloadData() // Needed in order to reload photos with better quality on size change.
+            scrollToFirstItem()
         }
     }
 
@@ -126,6 +127,7 @@ class RecentPhotosCollectionView: UICollectionView {
     func prepareForPresentation() {
         UIView.performWithoutAnimation {
             self.alpha = 0
+            self.scrollToFirstItem()
         }
     }
 
@@ -135,6 +137,11 @@ class RecentPhotosCollectionView: UICollectionView {
         }
     }
 
+    private func scrollToFirstItem() {
+        guard numberOfSections > 0, numberOfItems(inSection: 0) > 0 else { return }
+        scrollToItem(at: IndexPath(item: 0, section: 0), at: .centeredHorizontally, animated: false)
+    }
+
     // Background view
 
     private var hasPhotos: Bool {
diff --git a/SignalUI/Stickers/StickerPickerKeyboard.swift b/SignalUI/Stickers/StickerPickerKeyboard.swift
index fcb9bdefa9..720b198828 100644
--- a/SignalUI/Stickers/StickerPickerKeyboard.swift
+++ b/SignalUI/Stickers/StickerPickerKeyboard.swift
@@ -15,14 +15,15 @@ public class StickerKeyboard: CustomKeyboard {
     private let headerView = StickerPacksToolbar()
     private lazy var stickerPickerPageView = StickerPickerPageView(delegate: self)
 
-    public override init() {
+    public init(delegate: StickerKeyboardDelegate?) {
+        self.delegate = delegate
+
         super.init()
 
         var backgroundColor = UIColor.Signal.background
 #if compiler(>=6.2)
         if #available(iOS 26.0, *) {
             backgroundColor = .clear
-            headerView.layoutMargins.top = 0
         }
 #endif
         self.backgroundColor = backgroundColor
diff --git a/SignalUI/Views/CustomKeyboard.swift b/SignalUI/Views/CustomKeyboard.swift
index ceb52a5103..b7a24f7bc8 100644
--- a/SignalUI/Views/CustomKeyboard.swift
+++ b/SignalUI/Views/CustomKeyboard.swift
@@ -15,16 +15,8 @@ open class CustomKeyboard: UIInputView {
         addSubview(contentView)
         contentView.autoPinEdgesToSuperviewEdges()
 
-        NotificationCenter.default.addObserver(
-            self,
-            selector: #selector(orientationDidChange),
-            name: UIDevice.orientationDidChangeNotification,
-            object: UIDevice.current
-        )
-
         translatesAutoresizingMaskIntoConstraints = false
-        allowsSelfSizing = true
-        resizeToSystemKeyboard()
+        allowsSelfSizing = false
     }
 
     required public init?(coder aDecoder: NSCoder) {
@@ -33,23 +25,18 @@ open class CustomKeyboard: UIInputView {
 
     open func willPresent() {}
     open func wasPresented() {}
+    open func willDismiss() {}
     open func wasDismissed() {}
 
-    public func registerWithView(_ view: UIView) {
-        view.addSubview(responder)
-    }
-
-    private lazy var responder = CustomKeyboardResponder(customKeyboard: self)
-    override open var isFirstResponder: Bool { return responder.isFirstResponder }
-
-    open override func becomeFirstResponder() -> Bool {
-        let result = responder.becomeFirstResponder()
-        if result { willPresent() }
-        return result
-    }
-
-    open override func resignFirstResponder() -> Bool {
-        return responder.resignFirstResponder()
+    open override func willMove(toSuperview newSuperview: UIView?) {
+        DispatchQueue.main.async { [weak self] in
+            guard let self else { return }
+            if newSuperview != nil {
+                self.willPresent()
+            } else {
+                self.willDismiss()
+            }
+        }
     }
 
     open override func didMoveToSuperview() {
@@ -67,36 +54,50 @@ open class CustomKeyboard: UIInputView {
 
     // MARK: - Height Management
 
-    private lazy var heightConstraint = autoSetDimension(.height, toSize: 0)
+    public func setSystemKeyboardHeight(
+        _ height: CGFloat,
+        forTraitCollection traitCollection: UITraitCollection
+    ) {
+        // Only respect this height if it's reasonable, we don't want
+        // to have a tiny keyboard.
+        guard height > 170 else { return }
+
+        let key = SizeClassKey(horizontal: traitCollection.horizontalSizeClass,
+                               vertical: traitCollection.verticalSizeClass)
+        if CustomKeyboard.cachedKeyboardHeights[key] == nil {
+            CustomKeyboard.cachedKeyboardHeights[key] = height
+        }
+        updateHeightConstraint()
+    }
 
-    private struct SystemKeyboardHeight {
-        var landscape: CGFloat?
-        var portrait: CGFloat?
+    public class func hasCachedHeight(forTraitCollection traitCollection: UITraitCollection) -> Bool {
+        let key = SizeClassKey(horizontal: traitCollection.horizontalSizeClass,
+                               vertical: traitCollection.verticalSizeClass)
+        return CustomKeyboard.cachedKeyboardHeights[key] != nil
     }
-    private var cachedSystemKeyboardHeight = SystemKeyboardHeight()
 
-    private var currentSystemKeyboardHeight: CGFloat? {
-        get {
-            let interfaceOrientation = window?.windowScene?.interfaceOrientation ?? .unknown
-            return interfaceOrientation.isLandscape ? cachedSystemKeyboardHeight.landscape : cachedSystemKeyboardHeight.portrait
+    private lazy var heightConstraint = heightAnchor.constraint(equalToConstant: 0)
+
+    private struct SizeClassKey: Hashable {
+        let horizontal: UIUserInterfaceSizeClass
+        let vertical: UIUserInterfaceSizeClass
+
+        func hash(into hasher: inout Hasher) {
+            hasher.combine(horizontal.rawValue)
+            hasher.combine(vertical.rawValue)
         }
-        set {
-            let interfaceOrientation = window?.windowScene?.interfaceOrientation ?? .unknown
-            let orientationKey = interfaceOrientation.isLandscape ? \SystemKeyboardHeight.landscape : \.portrait
-            cachedSystemKeyboardHeight[keyPath: orientationKey] = newValue
+
+        static func == (lhs: SizeClassKey, rhs: SizeClassKey) -> Bool {
+            lhs.horizontal == rhs.horizontal && lhs.vertical == rhs.vertical
         }
     }
 
-    public func updateSystemKeyboardHeight(_ height: CGFloat) {
-        // Only respect this height if it's reasonable, we don't want
-        // to have a tiny keyboard.
-        guard height > 170 else { return }
-        currentSystemKeyboardHeight = height
-        resizeToSystemKeyboard()
-    }
+    private static var cachedKeyboardHeights = [SizeClassKey: CGFloat]()
 
-    open func resizeToSystemKeyboard() {
-        guard var keyboardHeight = currentSystemKeyboardHeight else {
+    private func updateHeightConstraint() {
+        let key = SizeClassKey(horizontal: traitCollection.horizontalSizeClass,
+                               vertical: traitCollection.verticalSizeClass)
+        guard let cachedHeight = CustomKeyboard.cachedKeyboardHeights[key] else {
             // We don't have a cached height for this orientation,
             // let the auto sizing do its best guess at what the
             // system keyboard height might be.
@@ -105,60 +106,25 @@ open class CustomKeyboard: UIInputView {
             return
         }
 
-        if let window {
-            // App frame height changes based on orientation (i.e. its the smaller dimension when landscape).
-            // Cap the height for custom keyboard because our layout breaks if we extend too tall.
-            let maxHeight = window.frame.height * 0.75
-            if keyboardHeight > maxHeight {
-                keyboardHeight = maxHeight
-            }
-        }
-
         // We have a cached height so we want to size ourself. The system
         // sizing isn't a 100% match to the system keyboard's size and
         // does not account for things like the quicktype toolbar.
         allowsSelfSizing = true
         heightConstraint.isActive = true
-        heightConstraint.constant = keyboardHeight
+        heightConstraint.constant = cachedHeight
     }
 
-    open override func layoutSubviews() {
-        super.layoutSubviews()
-        resizeToSystemKeyboard()
-    }
-
-    @objc
-    open func orientationDidChange() {
-        resizeToSystemKeyboard()
-    }
-}
-
-private class CustomKeyboardResponder: UITextView {
-
-    public weak var customKeyboard: CustomKeyboard?
+    open override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
+        super.traitCollectionDidChange(previousTraitCollection)
 
-    init(customKeyboard: CustomKeyboard) {
-        self.customKeyboard = customKeyboard
-        super.init(frame: .zero, textContainer: nil)
-
-        self.disableAiWritingTools()
-
-        autocorrectionType = .no
-        keyboardAppearance = Theme.keyboardAppearance
-        inputAssistantItem.leadingBarButtonGroups = []
-        inputAssistantItem.trailingBarButtonGroups = []
-    }
-
-    override var inputView: UIView? {
-        get { customKeyboard }
-        set {}
-    }
-
-    required init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
-    }
+        // We only care about changes in size classes, which would be triggered by interface rotation.
+        guard
+            previousTraitCollection?.horizontalSizeClass != traitCollection.horizontalSizeClass ||
+            previousTraitCollection?.verticalSizeClass != traitCollection.verticalSizeClass else
+        {
+            return
+        }
 
-    public override var canBecomeFirstResponder: Bool {
-        return true
+        updateHeightConstraint()
     }
 }
