diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryGroupReplyCell.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryGroupReplyCell.swift
index d9c99c53d7a..0193c859cf0 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryGroupReplyCell.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryGroupReplyCell.swift	
@@ -157,19 +157,17 @@ class StoryGroupReplyCell: UITableViewCell {
     }
 
     func configureTextAndTimestamp(for item: StoryGroupReplyViewItem) {
-        if let displayableText = item.displayableText {
-            messageLabel.attributedText = displayableText.displayAttributedText.styled(
-                with: .font(.ows_dynamicTypeBodyClamped),
-                .color(.ows_gray05),
-                .alignment(displayableText.displayTextNaturalAlignment)
-            )
-        }
+        guard let displayableText = item.displayableText else { return }
+
+        let messageText = displayableText.displayAttributedText.styled(
+            with: .font(.ows_dynamicTypeBodyClamped),
+            .color(.ows_gray05),
+            .alignment(displayableText.displayTextNaturalAlignment)
+        )
 
         switch cellType {
         case .standalone, .bottom:
             // Append timestamp to attributed text
-            guard let messageText = messageLabel.attributedText else { break }
-
             let timestampText = item.timeString.styled(
                 with: .font(.ows_dynamicTypeCaption1Clamped),
                 .color(.ows_gray25)
@@ -178,16 +176,31 @@ class StoryGroupReplyCell: UITableViewCell {
             let maxMessageWidth = min(512, CurrentAppContext().frame.width) - 92
             let timestampSpacer: CGFloat = 6
 
-            let (messageSize, messageLastLineSize) = size(for: messageText, maxWidth: maxMessageWidth)
-            let (timestampSize, _) = size(for: timestampText, maxWidth: maxMessageWidth)
+            let messageMeasurement = measure(messageText, maxWidth: maxMessageWidth)
+            let timestampMeasurement = measure(timestampText, maxWidth: maxMessageWidth)
+
+            let lastLineFreeSpace = maxMessageWidth - timestampSpacer - messageMeasurement.lastLineRect.width
+
+            let textDirectionMatchesAppDirection: Bool
+            switch displayableText.displayTextNaturalAlignment {
+            case .left:
+                textDirectionMatchesAppDirection = !CurrentAppContext().isRTL
+            case .right:
+                textDirectionMatchesAppDirection = CurrentAppContext().isRTL
+            case .natural:
+                textDirectionMatchesAppDirection = true
+            default:
+                owsFailDebug("Unexpected text alignment")
+                textDirectionMatchesAppDirection = true
+            }
 
-            let lastLineFreeSpace = maxMessageWidth - timestampSpacer - messageLastLineSize.width
-            let shouldRenderTimestampOnLastMessageLine = lastLineFreeSpace >= timestampSize.width
+            let hasSpacedForTimestampOnLastMessageLine = lastLineFreeSpace >= timestampMeasurement.rect.width
+            let shouldRenderTimestampOnLastMessageLine = hasSpacedForTimestampOnLastMessageLine && textDirectionMatchesAppDirection
 
             if shouldRenderTimestampOnLastMessageLine {
                 var possibleMessageBubbleWidths = [
-                    messageSize.width,
-                    messageLastLineSize.width + timestampSpacer + timestampSize.width
+                    messageMeasurement.rect.width,
+                    messageMeasurement.lastLineRect.width + timestampSpacer + timestampMeasurement.rect.width
                 ]
                 if cellType == .standalone {
                     contentView.layoutIfNeeded()
@@ -200,14 +213,14 @@ class StoryGroupReplyCell: UITableViewCell {
                     messageText,
                     "\n",
                     timestampText.styled(
-                        with: .paragraphSpacingBefore(-timestampSize.height),
-                        .firstLineHeadIndent(finalMessageLabelWidth - timestampSize.width)
+                        with: .paragraphSpacingBefore(-timestampMeasurement.rect.height),
+                        .firstLineHeadIndent(finalMessageLabelWidth - timestampMeasurement.rect.width)
                     )
                 ])
             } else {
                 var possibleMessageBubbleWidths = [
-                    messageSize.width,
-                    timestampSize.width
+                    messageMeasurement.rect.width,
+                    timestampMeasurement.rect.width
                 ]
                 if cellType == .standalone {
                     contentView.layoutIfNeeded()
@@ -220,19 +233,21 @@ class StoryGroupReplyCell: UITableViewCell {
                     messageText,
                     "\n",
                     timestampText.styled(
-                        with: .firstLineHeadIndent(finalMessageLabelWidth - timestampSize.width)
+                        with: textDirectionMatchesAppDirection
+                            ? .firstLineHeadIndent(finalMessageLabelWidth - timestampMeasurement.rect.width)
+                            : .alignment(.trailing)
                     )
                 ])
             }
             break
         case .top, .middle:
-            break // No timestamp
+            messageLabel.attributedText = messageText
         case .reaction:
             timestampLabel.text = item.timeString
         }
     }
 
-    private func size(for attributedString: NSAttributedString, maxWidth: CGFloat) -> (size: CGSize, lastLineSize: CGSize) {
+    private func measure(_ attributedString: NSAttributedString, maxWidth: CGFloat) -> (rect: CGRect, lastLineRect: CGRect) {
         guard !attributedString.isEmpty else { return (.zero, .zero) }
 
         let layoutManager = NSLayoutManager()
@@ -255,7 +270,7 @@ class StoryGroupReplyCell: UITableViewCell {
 
         let fullTextRect = layoutManager.usedRect(for: textContainer)
 
-        return (fullTextRect.size, lastLineFragmentRect.size)
+        return (fullTextRect, lastLineFragmentRect)
     }
 
     override func layoutSubviews() {
@@ -268,11 +283,11 @@ class StoryGroupReplyCell: UITableViewCell {
             // No special corner rounding to apply
             return
         case .middle:
-            sharpCorners = [.bottomLeft, .topLeft]
+            sharpCorners = CurrentAppContext().isRTL ? [.bottomRight, .topRight] : [.bottomLeft, .topLeft]
         case .top:
-            sharpCorners = .bottomLeft
+            sharpCorners = CurrentAppContext().isRTL ? .bottomRight : .bottomLeft
         case .bottom:
-            sharpCorners = .topLeft
+            sharpCorners = CurrentAppContext().isRTL ? .topRight : .topLeft
         }
 
         bubbleView.layoutIfNeeded()
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPlaybackProgressView.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPlaybackProgressView.swift
index edb775f2e02..cb2ad7851b5 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPlaybackProgressView.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPlaybackProgressView.swift	
@@ -3,6 +3,7 @@
 //
 
 import Foundation
+import UIKit
 
 class StoryPlaybackProgressView: UIView {
     var playedColor: UIColor = .ows_white {
@@ -102,32 +103,59 @@ class StoryPlaybackProgressView: UIView {
             unplayedShapeLayer.path = unplayedBezierPath.cgPath
         }
 
-        for x in 0..<numberOfItems {
-            if itemState.index == x, itemState.value < 1, itemState.value > 0 {
+        for idx in 0..<numberOfItems {
+            if itemState.index == idx, itemState.value < 1, itemState.value > 0 {
+                var playedXPosition = CGFloat(idx) * (itemWidth + itemSpacing)
+                let playedWidth = itemWidth * itemState.value
+                let playedRoundedCorners: UIRectCorner
+                var unplayedXPosition = playedXPosition + playedWidth
+                let unplayedRoundedCorners: UIRectCorner
+
+                if CurrentAppContext().isRTL {
+                    unplayedXPosition = rect.width - playedXPosition - itemWidth
+                    playedXPosition = unplayedXPosition + itemWidth - playedWidth
+                    playedRoundedCorners = [.topRight, .bottomRight]
+                    unplayedRoundedCorners = [.topLeft, .bottomLeft]
+                } else {
+                    playedRoundedCorners = [.topLeft, .bottomLeft]
+                    unplayedRoundedCorners = [.topRight, .bottomRight]
+                }
+
                 let playedItemFrame = CGRect(
-                    x: CGFloat(x) * (itemWidth + itemSpacing),
+                    x: playedXPosition,
                     y: 0,
-                    width: itemWidth * itemState.value,
+                    width: playedWidth,
                     height: itemHeight
                 )
-                playedBezierPath.append(UIBezierPath(roundedRect: playedItemFrame, byRoundingCorners: [.topLeft, .bottomLeft], cornerRadii: CGSize(square: itemHeight / 2)))
+                playedBezierPath.append(UIBezierPath(
+                    roundedRect: playedItemFrame,
+                    byRoundingCorners: playedRoundedCorners,
+                    cornerRadii: CGSize(square: itemHeight / 2)))
+
                 let unplayedItemFrame = CGRect(
-                    x: playedItemFrame.x + playedItemFrame.width,
+                    x: unplayedXPosition,
                     y: 0,
                     width: itemWidth * (1 - itemState.value),
                     height: itemHeight
                 )
-                unplayedBezierPath.append(UIBezierPath(roundedRect: unplayedItemFrame, byRoundingCorners: [.topRight, .bottomRight], cornerRadii: CGSize(square: itemHeight / 2)))
+                unplayedBezierPath.append(UIBezierPath(
+                    roundedRect: unplayedItemFrame,
+                    byRoundingCorners: unplayedRoundedCorners,
+                    cornerRadii: CGSize(square: itemHeight / 2)))
             } else {
                 let path: UIBezierPath
-                if itemState.index < x || (itemState.index == x && itemState.value <= 0) {
+                if itemState.index < idx || (itemState.index == idx && itemState.value <= 0) {
                     path = unplayedBezierPath
                 } else {
-                    owsAssertDebug(itemState.index > x || (itemState.index == x && itemState.value >= 1))
+                    owsAssertDebug(itemState.index > idx || (itemState.index == idx && itemState.value >= 1))
                     path = playedBezierPath
                 }
+
+                var xPosition = CGFloat(idx) * (itemWidth + itemSpacing)
+                if CurrentAppContext().isRTL { xPosition = rect.width - xPosition - itemWidth }
+
                 let itemFrame = CGRect(
-                    x: CGFloat(x) * (itemWidth + itemSpacing),
+                    x: xPosition,
                     y: 0,
                     width: itemWidth,
                     height: itemHeight
