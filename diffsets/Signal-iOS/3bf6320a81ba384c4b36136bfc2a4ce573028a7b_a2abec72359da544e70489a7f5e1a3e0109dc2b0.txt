diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 82444cb5cad..39d2f627102 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -974,6 +974,7 @@
 		668478FD2CAF364C00430D68 /* ChatItemContexts.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668478FC2CAF364800430D68 /* ChatItemContexts.swift */; };
 		668479012CB0A77C00430D68 /* OrphanedBackupAttachmentManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668479002CB0A77C00430D68 /* OrphanedBackupAttachmentManager.swift */; };
 		6685FEEE2DB06F7C0086CF3C /* BackupAttachmentDownloadEligibility.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6685FEED2DB06F740086CF3C /* BackupAttachmentDownloadEligibility.swift */; };
+		6685FEF02DB073FD0086CF3C /* BackupAttachmentDownloadProgress.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6685FEEF2DB073F60086CF3C /* BackupAttachmentDownloadProgress.swift */; };
 		66883A3A29D7630A00E898CF /* MessageBodyTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66883A3829D7630300E898CF /* MessageBodyTests.swift */; };
 		6688E602298232A4004467C8 /* PaymentActionSheets.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6688E601298232A4004467C8 /* PaymentActionSheets.swift */; };
 		6689B23A2C055F7C003D5B2F /* OrphanedAttachmentRecord.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6689B2392C055F7C003D5B2F /* OrphanedAttachmentRecord.swift */; };
@@ -4872,6 +4873,7 @@
 		668478FC2CAF364800430D68 /* ChatItemContexts.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ChatItemContexts.swift; sourceTree = "<group>"; };
 		668479002CB0A77C00430D68 /* OrphanedBackupAttachmentManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OrphanedBackupAttachmentManager.swift; sourceTree = "<group>"; };
 		6685FEED2DB06F740086CF3C /* BackupAttachmentDownloadEligibility.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BackupAttachmentDownloadEligibility.swift; sourceTree = "<group>"; };
+		6685FEEF2DB073F60086CF3C /* BackupAttachmentDownloadProgress.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BackupAttachmentDownloadProgress.swift; sourceTree = "<group>"; };
 		66883A3829D7630300E898CF /* MessageBodyTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageBodyTests.swift; sourceTree = "<group>"; };
 		6688E601298232A4004467C8 /* PaymentActionSheets.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PaymentActionSheets.swift; sourceTree = "<group>"; };
 		6689B2392C055F7C003D5B2F /* OrphanedAttachmentRecord.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OrphanedAttachmentRecord.swift; sourceTree = "<group>"; };
@@ -9599,6 +9601,7 @@
 			children = (
 				6685FEED2DB06F740086CF3C /* BackupAttachmentDownloadEligibility.swift */,
 				66E257022CA3860B00100A08 /* BackupAttachmentDownloadManager.swift */,
+				6685FEEF2DB073F60086CF3C /* BackupAttachmentDownloadProgress.swift */,
 				667BB2072C580C1400E79B57 /* BackupAttachmentDownloadStore.swift */,
 				66681CDE2C58174F00E50136 /* BackupAttachmentDownloadStoreTests.swift */,
 				66734F002CA1ED3A00558494 /* BackupAttachmentUploadManager.swift */,
@@ -17456,6 +17459,7 @@
 				D972E2FF2C542BCD001D7337 /* Backup.pb.swift in Sources */,
 				6685FEEE2DB06F7C0086CF3C /* BackupAttachmentDownloadEligibility.swift in Sources */,
 				66E257032CA3861200100A08 /* BackupAttachmentDownloadManager.swift in Sources */,
+				6685FEF02DB073FD0086CF3C /* BackupAttachmentDownloadProgress.swift in Sources */,
 				667BB2082C580C1400E79B57 /* BackupAttachmentDownloadStore.swift in Sources */,
 				66734F012CA1ED3F00558494 /* BackupAttachmentUploadManager.swift in Sources */,
 				66C7952D2C9B78E900C13937 /* BackupAttachmentUploadStore.swift in Sources */,
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift
index 4a5bf5191e8..a26f69e50b2 100644
--- a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadManager.swift
@@ -36,6 +36,8 @@ public protocol BackupAttachmentDownloadManager {
     /// Cancel any pending attachment downloads, e.g. when backups are disabled.
     /// Removes all enqueued downloads and attempts to cancel in progress ones.
     func cancelPendingDownloads() async throws
+
+    var progress: BackupAttachmentDownloadProgress { get }
 }
 
 public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManager {
@@ -51,6 +53,8 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
     private let taskQueue: TaskQueueLoader<TaskRunner>
     private let tsAccountManager: TSAccountManager
 
+    public let progress: BackupAttachmentDownloadProgress
+
     public init(
         appReadiness: AppReadiness,
         attachmentStore: AttachmentStore,
@@ -77,6 +81,14 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
         self.remoteConfigProvider = remoteConfigProvider
         self.tsAccountManager = tsAccountManager
 
+        self.progress = BackupAttachmentDownloadProgress(
+            appReadiness: appReadiness,
+            backupAttachmentDownloadStore: backupAttachmentDownloadStore,
+            dateProvider: dateProvider,
+            db: db,
+            remoteConfigProvider: remoteConfigProvider
+        )
+
         self.listMediaManager = ListMediaManager(
             attachmentStore: attachmentStore,
             attachmentUploadStore: attachmentUploadStore,
@@ -95,6 +107,7 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             db: db,
             mediaBandwidthPreferenceStore: mediaBandwidthPreferenceStore,
             messageBackupRequestManager: messageBackupRequestManager,
+            progress: progress,
             remoteConfigProvider: remoteConfigProvider,
             tsAccountManager: tsAccountManager
         )
@@ -155,6 +168,16 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             return
         }
 
+        // As we go enqueuing attachments, increment the total byte count we
+        // need to download.
+        if let byteCount = referencedAttachment.attachment.anyPointerFullsizeUnencryptedByteCount {
+            let totalPendingByteCount = backupAttachmentDownloadStore.getTotalPendingDownloadByteCount(tx: tx) ?? 0
+            backupAttachmentDownloadStore.setTotalPendingDownloadByteCount(
+                totalPendingByteCount + UInt64(byteCount),
+                tx: tx
+            )
+        }
+
         try backupAttachmentDownloadStore.enqueue(
             referencedAttachment.reference,
             tx: tx
@@ -180,6 +203,11 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
         if FeatureFlags.MessageBackup.remoteExportAlpha {
             try await listMediaManager.queryListMediaIfNeeded()
         }
+        do {
+            try await progress.beginObserving()
+        } catch {
+            owsFailDebug("Unable to observe download progres \(error.grdbErrorForLogging)")
+        }
         try await taskQueue.loadAndRunTasks()
     }
 
@@ -187,7 +215,11 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
         try await taskQueue.stop()
         try await db.awaitableWrite { tx in
             try self.backupAttachmentDownloadStore.removeAll(tx: tx)
+            backupAttachmentDownloadStore.setTotalPendingDownloadByteCount(nil, tx: tx)
+            backupAttachmentDownloadStore.setCachedRemainingPendingDownloadByteCount(nil, tx: tx)
         }
+        // Reset progress calculation
+        try? await progress.beginObserving()
     }
 
     // MARK: - Reachability
@@ -624,6 +656,7 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
         private let db: any DB
         private let mediaBandwidthPreferenceStore: MediaBandwidthPreferenceStore
         private let messageBackupRequestManager: MessageBackupRequestManager
+        private let progress: BackupAttachmentDownloadProgress
         private let remoteConfigProvider: RemoteConfigProvider
         private let tsAccountManager: TSAccountManager
 
@@ -639,6 +672,7 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             db: any DB,
             mediaBandwidthPreferenceStore: MediaBandwidthPreferenceStore,
             messageBackupRequestManager: MessageBackupRequestManager,
+            progress: BackupAttachmentDownloadProgress,
             remoteConfigProvider: RemoteConfigProvider,
             tsAccountManager: TSAccountManager
         ) {
@@ -649,6 +683,7 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             self.db = db
             self.mediaBandwidthPreferenceStore = mediaBandwidthPreferenceStore
             self.messageBackupRequestManager = messageBackupRequestManager
+            self.progress = progress
             self.remoteConfigProvider = remoteConfigProvider
             self.tsAccountManager = tsAccountManager
 
@@ -656,11 +691,11 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
         }
 
         func runTask(record: Store.Record, loader: TaskQueueLoader<TaskRunner>) async -> TaskRecordResult {
-            let eligibility = db.read { tx in
+            let (attachment, eligibility) = db.read { (tx) -> (Attachment?, BackupAttachmentDownloadEligibility?) in
                 return attachmentStore
                     .fetch(id: record.record.attachmentRowId, tx: tx)
                     .map { attachment in
-                        return BackupAttachmentDownloadEligibility.forAttachment(
+                        let eligibility = BackupAttachmentDownloadEligibility.forAttachment(
                             attachment,
                             attachmentTimestamp: record.record.timestamp,
                             dateProvider: dateProvider,
@@ -668,12 +703,20 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
                             remoteConfigProvider: remoteConfigProvider,
                             tx: tx
                         )
-                    }
+                        return (attachment, eligibility)
+                    } ?? (nil, nil)
             }
-            guard let eligibility, eligibility.canBeDownloadedAtAll else {
+            guard let attachment, let eligibility, eligibility.canBeDownloadedAtAll else {
                 return .cancelled
             }
 
+            /// Media and transit tier byte counts should be interchangeable.
+            /// Still, we shouldn't rely on this for anything other that progress tracking,
+            /// where its just a UI glitch if it turns out they are not.
+            let fullsizeByteCountForProgress = UInt64(
+                attachment.anyPointerFullsizeUnencryptedByteCount ?? 0
+            )
+
             // Separately from "eligibility" on a per-download basis, we check
             // network state level eligibility (require wifi). If not capable,
             // return a retryable error but stop running now. We will resume
@@ -699,10 +742,16 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             // Try media tier fullsize first.
             if eligibility.canDownloadMediaTierFullsize {
                 do {
+                    let progressSink = await progress.willBeginDownloadingAttachment(withId: record.record.attachmentRowId)
                     try await self.attachmentDownloadManager.downloadAttachment(
                         id: record.record.attachmentRowId,
                         priority: eligibility.downloadPriority,
-                        source: .mediaTierFullsize
+                        source: .mediaTierFullsize,
+                        progress: progressSink
+                    )
+                    await progress.didFinishDownloadOfAttachment(
+                        withId: record.record.attachmentRowId,
+                        byteCount: fullsizeByteCountForProgress
                     )
                     didDownloadFullsize = true
                 } catch let error {
@@ -714,10 +763,16 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
             // or because the download failed), try transit tier fullsize next.
             if !didDownloadFullsize, eligibility.canDownloadTransitTierFullsize {
                 do {
+                    let progressSink = await progress.willBeginDownloadingAttachment(withId: record.record.attachmentRowId)
                     try await self.attachmentDownloadManager.downloadAttachment(
                         id: record.record.attachmentRowId,
                         priority: eligibility.downloadPriority,
-                        source: .transitTier
+                        source: .transitTier,
+                        progress: progressSink
+                    )
+                    await progress.didFinishDownloadOfAttachment(
+                        withId: record.record.attachmentRowId,
+                        byteCount: fullsizeByteCountForProgress
                     )
                     didDownloadFullsize = true
                 } catch let error {
@@ -757,6 +812,10 @@ public class BackupAttachmentDownloadManagerImpl: BackupAttachmentDownloadManage
         func didCancel(record: Store.Record, tx: DBWriteTransaction) throws {
             Logger.warn("Cancelled restoring attachment \(record.id)")
         }
+
+        func didDrainQueue() async {
+            await progress.didEmptyDownloadQueue()
+        }
     }
 
     // MARK: - TaskRecordStore
@@ -812,6 +871,10 @@ open class BackupAttachmentDownloadManagerMock: BackupAttachmentDownloadManager
     public func cancelPendingDownloads() async throws {
         // Do nothing
     }
+
+    public var progress: BackupAttachmentDownloadProgress {
+        fatalError("Unimplemented")
+    }
 }
 
 #endif
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift
new file mode 100644
index 00000000000..4d39b8a6a70
--- /dev/null
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadProgress.swift
@@ -0,0 +1,290 @@
+//
+// Copyright 2025 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+public import GRDB
+
+public actor BackupAttachmentDownloadProgress {
+
+    // MARK: - Public API
+
+    public class Observer {
+        private weak var progress: BackupAttachmentDownloadProgress?
+        fileprivate let id: UUID = UUID()
+        fileprivate let block: (OWSProgress) -> Void
+
+        fileprivate init(progress: BackupAttachmentDownloadProgress? = nil, block: @escaping (OWSProgress) -> Void) {
+            self.progress = progress
+            self.block = block
+        }
+
+        deinit {
+            Task { [weak progress, id] in
+                await progress?.removeObserver(id)
+            }
+        }
+    }
+
+    /// Begin observing progress of all backup attachment downloads.
+    /// The observer will immediately be provided the current progress if any, and then updated with future progress state.
+    public func addObserver(_ block: @escaping (OWSProgress) -> Void) -> Observer {
+        let observer = Observer(block: block)
+        latestProgress.map(block)
+        observers.append(observer)
+        return observer
+    }
+
+    public func removeObserver(_ observer: Observer) {
+        self.removeObserver(observer.id)
+    }
+
+    // MARK: - BackupAttachmentDownloadManager API
+
+    /// Compute total pending bytes to download, and set up observation for attachments to be downloaded.
+    internal func beginObserving() async throws {
+        await initializationTask.value
+
+        let pendingByteCount: UInt64 = try computeRemainingUndownloadedByteCount()
+
+        let totalByteCount: UInt64 = db.read { tx in
+            backupAttachmentDownloadStore.getTotalPendingDownloadByteCount(tx: tx) ?? pendingByteCount
+        }
+
+        let sink = OWSProgress.createSink({ [weak self] progress in
+            await self?.updateObservers(progress)
+        })
+
+        let source = await sink.addSource(withLabel: "", unitCount: totalByteCount)
+        if totalByteCount > pendingByteCount {
+            source.incrementCompletedUnitCount(by: totalByteCount - pendingByteCount)
+        }
+        self.sink = sink
+        self.source = source
+    }
+
+    /// Create an OWSProgressSink for a single attachment to be downloaded.
+    /// Should be called prior to downloading any backup attachment.
+    internal func willBeginDownloadingAttachment(withId id: Attachment.IDType) async -> OWSProgressSink {
+        let sink = OWSProgress.createSink { [weak self] progress in
+            Task { await self?.didUpdateProgressForActiveDownload(
+                id: id,
+                completedByteCount: progress.completedUnitCount,
+                totalByteCount: progress.totalUnitCount
+            )
+            }
+        }
+        return sink
+    }
+
+    /// Stopgap to inform that an attachment finished downloading.
+    /// There are a couple edge cases (e.g. we already have a stream) that result in downloads
+    /// finishing without reporting any progress updates. This method ensures we always mark
+    /// attachments as finished in all cases.
+    internal func didFinishDownloadOfAttachment(
+        withId id: Attachment.IDType,
+        byteCount: UInt64
+    ) {
+        didUpdateProgressForActiveDownload(
+            id: id,
+            completedByteCount: byteCount,
+            totalByteCount: byteCount
+        )
+    }
+
+    /// Called when there are no more enqueued downloads.
+    /// As a final stopgap, in case we missed some bytes and counting got out of sync,
+    /// this should fully advance the downloaded byte count to the total byte count.
+    internal func didEmptyDownloadQueue() async {
+        activeDownloadByteCounts.keys.forEach {
+            recentlyCompletedDownloads.set(key: $0, value: ())
+        }
+        activeDownloadByteCounts = [:]
+        if let source {
+            source.incrementCompletedUnitCount(by: source.totalUnitCount - source.completedUnitCount)
+            await self.updateCache()
+        }
+    }
+
+    // MARK: - Private
+
+    private nonisolated let backupAttachmentDownloadStore: BackupAttachmentDownloadStore
+    private nonisolated let dateProvider: DateProvider
+    private nonisolated let db: DB
+    private nonisolated let remoteConfigProvider: RemoteConfigProvider
+
+    init(
+        appReadiness: AppReadiness,
+        backupAttachmentDownloadStore: BackupAttachmentDownloadStore,
+        dateProvider: @escaping DateProvider,
+        db: DB,
+        remoteConfigProvider: RemoteConfigProvider
+    ) {
+        self.backupAttachmentDownloadStore = backupAttachmentDownloadStore
+        self.dateProvider = dateProvider
+        self.db = db
+        self.remoteConfigProvider = remoteConfigProvider
+
+        var selfRef: BackupAttachmentDownloadProgress?
+        self.initializationTask = Task {
+            await withCheckedContinuation { continuation in
+                appReadiness.runNowOrWhenMainAppDidBecomeReadyAsync {
+                    Task {
+                        await selfRef?.initializeProgress()
+                        continuation.resume()
+                    }
+                }
+            }
+        }
+        selfRef = self
+    }
+
+    private let initializationTask: Task<Void, Never>
+
+    private func initializeProgress() {
+        // Initialize the `latestProgress` value using the on-disk cached values.
+        // Later we will (expensively) recompute the remaining byte count.
+        let (totalByteCount, remainingByteCount) = db.read { tx in
+            return (
+                backupAttachmentDownloadStore.getTotalPendingDownloadByteCount(tx: tx),
+                backupAttachmentDownloadStore.getCachedRemainingPendingDownloadByteCount(tx: tx)
+            )
+        }
+        if let totalByteCount {
+            self.latestProgress = OWSProgress(
+                completedUnitCount: totalByteCount - (remainingByteCount ?? totalByteCount),
+                totalUnitCount: totalByteCount,
+                sourceProgresses: [:]
+            )
+        }
+    }
+
+    private var observers = WeakArray<Observer>()
+
+    /// Initialized to cached values (if available) and updated as
+    /// downloads increment the completed byte count.
+    private var latestProgress: OWSProgress?
+
+    /// Set up in `beginObserving`
+    private var sink: OWSProgressSink?
+    private var source: OWSProgressSource?
+
+    /// Currently active downloads for which we update progress byte-by-byte.
+    private var activeDownloadByteCounts = [Attachment.IDType: UInt64]()
+    /// There is a race between receiving the final OWSProgress update for a given attachment
+    /// and being told the attachment finished downloading by BackupAttachmentDownloadManager.
+    /// To resolve this race, track recently completed downloads so we know not to double count.
+    /// There could be tens of thousands of attachments, so to minimize memory usage only keep
+    /// an LRUCache. In practice that will catch all races. Even if it doesn't, the downside
+    /// is we misreport progress until we hit 100%, big whoop.
+    private var recentlyCompletedDownloads = LRUCache<Attachment.IDType, Void>(maxSize: 100)
+
+    private func didUpdateProgressForActiveDownload(
+        id: Attachment.IDType,
+        completedByteCount: UInt64,
+        totalByteCount: UInt64
+    ) {
+        guard
+            totalByteCount != 0,
+            recentlyCompletedDownloads.get(key: id) == nil
+        else {
+            return
+        }
+        let prevByteCount = activeDownloadByteCounts[id] ?? 0
+        let diff = completedByteCount - prevByteCount
+        owsAssertDebug(self.source != nil, "Updating progress before setting up observation!")
+        if diff > 0 {
+            self.source?.incrementCompletedUnitCount(by: diff)
+        }
+        if completedByteCount >= totalByteCount {
+            recentlyCompletedDownloads.set(key: id, value: ())
+            // When some download completes, update the cache.
+            Task { [weak self] in
+                await self?.updateCache()
+            }
+        } else {
+            activeDownloadByteCounts[id] = completedByteCount
+        }
+    }
+
+    private func updateObservers(_ progress: OWSProgress) {
+        self.latestProgress = progress
+        observers.elements.forEach { $0.block(progress) }
+    }
+
+    func removeObserver(_ id: UUID) {
+        observers.removeAll(where: { $0.id == id })
+    }
+
+    private nonisolated func computeRemainingUndownloadedByteCount() throws -> UInt64 {
+        let remoteConfig = remoteConfigProvider.currentConfig()
+        let now = dateProvider()
+
+        return try db.read { tx in
+            let shouldStoreAllMediaLocally = backupAttachmentDownloadStore.getShouldStoreAllMediaLocally(tx: tx)
+
+            var totalByteCount: UInt64 = 0
+
+            struct JoinedRecord: Decodable, FetchableRecord {
+                var QueuedBackupAttachmentDownload: QueuedBackupAttachmentDownload
+                var Attachment: Attachment.Record
+            }
+
+            let cursor = try QueuedBackupAttachmentDownload
+                .including(required: QueuedBackupAttachmentDownload.attachment.self)
+                .asRequest(of: JoinedRecord.self)
+                .fetchCursor(tx.database)
+
+            while let joinedRecord = try cursor.next() {
+                guard let attachment = try? Attachment(record: joinedRecord.Attachment) else {
+                    continue
+                }
+                let eligibility = BackupAttachmentDownloadEligibility.forAttachment(
+                    attachment,
+                    attachmentTimestamp: joinedRecord.QueuedBackupAttachmentDownload.timestamp,
+                    now: now,
+                    shouldStoreAllMediaLocally: shouldStoreAllMediaLocally,
+                    remoteConfig: remoteConfig
+                )
+                if
+                    eligibility.canDownloadMediaTierFullsize,
+                    let byteCount = attachment.mediaTierInfo?.unencryptedByteCount
+                {
+                    totalByteCount += UInt64(byteCount)
+                } else if
+                    eligibility.canDownloadTransitTierFullsize,
+                    let byteCount = attachment.transitTierInfo?.unencryptedByteCount
+                {
+                    totalByteCount += UInt64(byteCount)
+                }
+                // We don't count thumbnail downloads towards the total
+                // download count we track the progress of.
+            }
+            return totalByteCount
+        }
+    }
+
+    private nonisolated func updateCache() async {
+        guard
+            // Ensure we've started observing
+            await self.sink != nil,
+            let latestProgress = await self.latestProgress
+        else {
+            return
+        }
+        let pendingByteCount = latestProgress.totalUnitCount - latestProgress.completedUnitCount
+        await db.awaitableWrite { tx in
+            backupAttachmentDownloadStore.setCachedRemainingPendingDownloadByteCount(
+                pendingByteCount,
+                tx: tx
+            )
+        }
+    }
+}
+
+extension QueuedBackupAttachmentDownload: TableRecord {
+    static let attachment = belongsTo(
+        Attachment.Record.self,
+        using: ForeignKey([QueuedBackupAttachmentDownload.CodingKeys.attachmentRowId.rawValue])
+    )
+}
diff --git a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadStore.swift b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadStore.swift
index ddebe525b77..04015ef73ab 100644
--- a/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadStore.swift
+++ b/SignalServiceKit/MessageBackup/Attachments/BackupAttachmentDownloadStore.swift
@@ -42,6 +42,31 @@ public protocol BackupAttachmentDownloadStore {
 
     /// Remove all enqueued downloads from the table.
     func removeAll(tx: DBWriteTransaction) throws
+
+    // MARK: Progress tracking cache
+
+    /// We display the total byte count of backup attachment downloads. We want this number to remain consistent
+    /// even as we download attachments and pop them off the queue. Once we do download an attachment, we
+    /// don't keep state that it was downloaded because of backups. So we have to compute the total count once
+    /// before downloading anything, and then use that cached value going forwards.
+    ///
+    /// Only set this value when scheduling a fresh batch of backup downloads, namely:
+    /// 1. When restoring from a backup
+    /// 2. When turning "media optimization" off (requires downloading older, previously offloaded, attachments)
+    /// 3. When disabling backups (and therefore downloading all attachments)
+    func setTotalPendingDownloadByteCount(_ byteCount: UInt64?, tx: DBWriteTransaction)
+
+    /// See documentation for `setTotalPendingDownloadByteCount`.
+    func getTotalPendingDownloadByteCount(tx: DBReadTransaction) -> UInt64?
+
+    /// Cached value for the remaining bytes to download of backup attachments. Updated as attachments
+    /// are downloaded.
+    /// Computing the remaining byte count is expensive (requires a table join) so we cache the latest value
+    /// to have it available immediately for UI population on app launch.
+    func setCachedRemainingPendingDownloadByteCount(_ byteCount: UInt64?, tx: DBWriteTransaction)
+
+    /// See documentation for `setCachedRemainingPendingDownloadByteCount`.
+    func getCachedRemainingPendingDownloadByteCount(tx: DBReadTransaction) -> UInt64?
 }
 
 public class BackupAttachmentDownloadStoreImpl: BackupAttachmentDownloadStore {
@@ -144,4 +169,31 @@ public class BackupAttachmentDownloadStoreImpl: BackupAttachmentDownloadStore {
     public func removeAll(tx: DBWriteTransaction) throws {
         try QueuedBackupAttachmentDownload.deleteAll(tx.database)
     }
+
+    private let totalPendingDownloadByteCountKey = "totalPendingDownloadByteCountKey"
+    private let cachedRemainingPendingDownloadByteCountKey = "cachedRemainingPendingDownloadByteCountKey"
+
+    public func setTotalPendingDownloadByteCount(_ byteCount: UInt64?, tx: DBWriteTransaction) {
+        if let byteCount {
+            kvStore.setUInt64(byteCount, key: totalPendingDownloadByteCountKey, transaction: tx)
+        } else {
+            kvStore.removeValue(forKey: totalPendingDownloadByteCountKey, transaction: tx)
+        }
+    }
+
+    public func getTotalPendingDownloadByteCount(tx: DBReadTransaction) -> UInt64? {
+        return kvStore.getUInt64(totalPendingDownloadByteCountKey, transaction: tx)
+    }
+
+    public func setCachedRemainingPendingDownloadByteCount(_ byteCount: UInt64?, tx: DBWriteTransaction) {
+        if let byteCount {
+            kvStore.setUInt64(byteCount, key: cachedRemainingPendingDownloadByteCountKey, transaction: tx)
+        } else {
+            kvStore.removeValue(forKey: cachedRemainingPendingDownloadByteCountKey, transaction: tx)
+        }
+    }
+
+    public func getCachedRemainingPendingDownloadByteCount(tx: DBReadTransaction) -> UInt64? {
+        return kvStore.getUInt64(cachedRemainingPendingDownloadByteCountKey, transaction: tx)
+    }
 }
diff --git a/SignalServiceKit/Messages/Attachments/V2/Attachment.swift b/SignalServiceKit/Messages/Attachments/V2/Attachment.swift
index 16d2ac834fb..c1029223ffd 100644
--- a/SignalServiceKit/Messages/Attachments/V2/Attachment.swift
+++ b/SignalServiceKit/Messages/Attachments/V2/Attachment.swift
@@ -287,6 +287,15 @@ public class Attachment {
         return Data(hasher.finalize()).base64EncodedString()
     }
 
+    /// Unencrypted byte count on CDN of the fullsize attachment _before_ encryption and padding,
+    /// as obtained either from the sender or ourselves.
+    /// Media and transit tier byte counts should be interchangeable.
+    /// Still, we shouldn't rely on this for anything critical; assume the value can be spoofed.
+    /// Safe to use for size estimation, UI progress display, etc.
+    public var anyPointerFullsizeUnencryptedByteCount: UInt32? {
+        return mediaTierInfo?.unencryptedByteCount ?? transitTierInfo?.unencryptedByteCount
+    }
+
     public enum TransitUploadStrategy {
         case reuseExistingUpload(Upload.ReusedUploadMetadata)
         case reuseStreamEncryption(Upload.LocalUploadMetadata)
diff --git a/SignalServiceKit/Util/TaskQueueLoader.swift b/SignalServiceKit/Util/TaskQueueLoader.swift
index 17c95318527..99a88a34c3d 100644
--- a/SignalServiceKit/Util/TaskQueueLoader.swift
+++ b/SignalServiceKit/Util/TaskQueueLoader.swift
@@ -123,6 +123,14 @@ public protocol TaskRecordRunner {
         record: Store.Record,
         tx: DBWriteTransaction
     ) throws
+
+    /// Called by ``TaskQueueLoader`` when all tasks have finished.
+    /// In other words, when ``TaskRecordStore`` peek returns an empty array.
+    func didDrainQueue() async
+}
+
+extension TaskRecordRunner {
+    public func didDrainQueue() async {}
 }
 
 /// Utility class that helps working with serialized queues for which each needs to run
@@ -213,6 +221,7 @@ public actor TaskQueueLoader<Runner: TaskRecordRunner> {
         }
         let task = Task {
             try await self._loadAndRunTasks()
+            await self.runner.didDrainQueue()
             self.runningTask = nil
         }
         self.runningTask = task
