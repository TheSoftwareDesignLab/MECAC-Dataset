diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
index 6693a52c328..66dbab78705 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVItemViewState.swift
@@ -269,9 +269,6 @@ struct CVItemModelBuilder: CVItemBuilding, Dependencies {
             let incomingSenderAddress: SignalServiceAddress = incomingMessage.authorAddress
             owsAssertDebug(incomingSenderAddress.isValid)
             let isDisappearingMessage = incomingMessage.hasPerConversationExpiration
-            let authorName = contactsManager.displayName(for: incomingSenderAddress,
-                                                         transaction: transaction)
-            itemViewState.accessibilityAuthorName = authorName
 
             if let nextItem = nextItem,
                let nextIncomingMessage = nextItem.interaction as? TSIncomingMessage {
@@ -311,6 +308,10 @@ struct CVItemModelBuilder: CVItemBuilding, Dependencies {
                 // the previous message has the same sender name and
                 // no "date break" separates us.
                 var shouldShowSenderName = true
+                let authorName = contactsManager.displayName(for: incomingSenderAddress,
+                                                             transaction: transaction)
+                itemViewState.accessibilityAuthorName = authorName
+
                 if let previousItem = previousItem,
                    let previousIncomingMessage = previousItem.interaction as? TSIncomingMessage {
                     let previousIncomingSenderAddress = previousIncomingMessage.authorAddress
@@ -331,7 +332,14 @@ struct CVItemModelBuilder: CVItemBuilding, Dependencies {
                     let nextIncomingSenderAddress: SignalServiceAddress = nextIncomingMessage.authorAddress
                     itemViewState.shouldShowSenderAvatar = incomingSenderAddress != nextIncomingSenderAddress
                 }
+            } else {
+                // In a 1:1 thread, we can avoid cluttering up voiceover string with the recipient's
+                // full name. Group thread's will continue to read off the full name.
+                itemViewState.accessibilityAuthorName = contactsManager.shortDisplayName(
+                    for: incomingSenderAddress,
+                    transaction: transaction)
             }
+
         } else if [.call, .info, .error].contains(interaction.interactionType()) {
             // clustering
 
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 5100b841b06..e6349f79c07 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -1027,9 +1027,21 @@
 /* Format string for a relative time, expressed as a certain number of hours in the past. Embeds {{The number of hours}}. */
 "DATE_HOURS_AGO_FORMAT" = "%@h";
 
+/* Full string for a relative time of one hour ago. */
+"DATE_ONE_HOUR_AGO_LONG" = "1 hour ago";
+
+/* Full format string for a relative time, expressed as a certain number of hours in the past. Embeds {{The number of hours}}. */
+"DATE_HOURS_AGO_LONG_FORMAT" = "%@ hours ago";
+
 /* Format string for a relative time, expressed as a certain number of minutes in the past. Embeds {{The number of minutes}}. */
 "DATE_MINUTES_AGO_FORMAT" = "%@m";
 
+/* Full string for a relative time of one minute ago. */
+"DATE_ONE_MINUTE_AGO_LONG" = "1 minute ago";
+
+/* Full format string for a relative time, expressed as a certain number of minutes in the past. Embeds {{The number of minutes}}. */
+"DATE_MINUTES_AGO_LONG_FORMAT" = "%@ minutes ago";
+
 /* The present; the current time. */
 "DATE_NOW" = "Now";
 
diff --git a/SignalMessaging/utils/DateUtil.m b/SignalMessaging/utils/DateUtil.m
index 352a2678daf..1ccd81471ef 100644
--- a/SignalMessaging/utils/DateUtil.m
+++ b/SignalMessaging/utils/DateUtil.m
@@ -398,35 +398,24 @@ + (NSString *)formatMessageTimestamp:(uint64_t)timestamp
     NSDateComponents *relativeDiffComponents =
         [calendar components:NSCalendarUnitMinute | NSCalendarUnitHour fromDate:date toDate:nowDate options:0];
 
-    NSInteger minutesDiff = MAX(0, [relativeDiffComponents minute]);
-    NSInteger hoursDiff = MAX(0, [relativeDiffComponents hour]);
-    if (hoursDiff < 1 && minutesDiff < 1) {
-        return NSLocalizedString(@"DATE_NOW", @"The present; the current time.");
-    }
-
-    if (hoursDiff < 1) {
-        NSString *minutesString = [OWSFormat formatInt:minutesDiff];
-        return [NSString stringWithFormat:NSLocalizedString(@"DATE_MINUTES_AGO_FORMAT",
-                                              @"Format string for a relative time, expressed as a certain number of "
-                                              @"minutes in the past. Embeds {{The number of minutes}}."),
-                         minutesString];
-    }
-
     // Note: we are careful to treat "future" dates as "now".
     NSInteger yearsDiff = [self yearsFromFirstDate:date toSecondDate:nowDate];
+    NSInteger daysDiff = [self daysFromFirstDate:date toSecondDate:nowDate];
+    NSInteger hoursDiff = MAX(0, [relativeDiffComponents hour]);
+    NSInteger minutesDiff = MAX(0, [relativeDiffComponents minute]);
+
     if (yearsDiff > 0) {
         // "Long date" + locale-specific "short" time format.
         NSString *dayOfWeek = [self.otherYearMessageFormatter stringFromDate:date];
         NSString *formattedTime = [[self timeFormatter] stringFromDate:date];
         return [[dayOfWeek stringByAppendingString:@" "] stringByAppendingString:formattedTime];
-    }
 
-    NSInteger daysDiff = [self daysFromFirstDate:date toSecondDate:nowDate];
-    if (daysDiff >= 7) {
+    } else if (daysDiff >= 7) {
         // "Short date" + locale-specific "short" time format.
         NSString *dayOfWeek = [self.thisYearMessageFormatter stringFromDate:date];
         NSString *formattedTime = [[self timeFormatter] stringFromDate:date];
         return [[dayOfWeek stringByAppendingString:@" "] stringByAppendingString:formattedTime];
+
     } else if (daysDiff > 0) {
         // "Day of week" + locale-specific "short" time format.
         NSDateFormatter *thisWeekMessageFormatter = (shouldUseLongFormat
@@ -435,12 +424,35 @@ + (NSString *)formatMessageTimestamp:(uint64_t)timestamp
         NSString *dayOfWeek = [thisWeekMessageFormatter stringFromDate:date];
         NSString *formattedTime = [[self timeFormatter] stringFromDate:date];
         return [[dayOfWeek stringByAppendingString:@" "] stringByAppendingString:formattedTime];
-    } else {
+
+    } else if (hoursDiff > 0) {
+        if (shouldUseLongFormat && hoursDiff == 1) {
+            // Long format has a distinction between singular and plural
+            return NSLocalizedString(@"DATE_ONE_HOUR_AGO_LONG", @"Full string for a relative time of one hour ago.");
+        }
+
+        NSString *shortFormat = NSLocalizedString(@"DATE_HOURS_AGO_FORMAT", @"Format string for a relative time, expressed as a certain number of hours in the past. Embeds {{The number of hours}}.");
+        NSString *longFormat = NSLocalizedString(@"DATE_HOURS_AGO_LONG_FORMAT", @"Full format string for a relative time, expressed as a certain number of hours in the past. Embeds {{The number of hours}}.");
+
+        NSString *formatString = shouldUseLongFormat ? longFormat : shortFormat;
         NSString *hoursString = [OWSFormat formatInt:hoursDiff];
-        return [NSString stringWithFormat:NSLocalizedString(@"DATE_HOURS_AGO_FORMAT",
-                                              @"Format string for a relative time, expressed as a certain number of "
-                                              @"hours in the past. Embeds {{The number of hours}}."),
-                         hoursString];
+        return [NSString stringWithFormat:formatString, hoursString];
+
+    } else if (minutesDiff > 0) {
+        if (shouldUseLongFormat && minutesDiff == 1) {
+            // Long format has a distinction between singular and plural
+            return NSLocalizedString(@"DATE_ONE_MINUTE_AGO_LONG", @"Full string for a relative time of one minute ago.");
+        }
+
+        NSString *shortFormat = NSLocalizedString(@"DATE_MINUTES_AGO_FORMAT", @"Format string for a relative time, expressed as a certain number of minutes in the past. Embeds {{The number of minutes}}.");
+        NSString *longFormat = NSLocalizedString(@"DATE_MINUTES_AGO_LONG_FORMAT", @"Full format string for a relative time, expressed as a certain number of minutes in the past. Embeds {{The number of minutes}}.");
+
+        NSString *formatString = shouldUseLongFormat ? longFormat : shortFormat;
+        NSString *minutesString = [OWSFormat formatInt:minutesDiff];
+        return [NSString stringWithFormat:formatString, minutesString];
+
+    } else {
+        return NSLocalizedString(@"DATE_NOW", @"The present; the current time.");
     }
 }
 
