diff --git a/Signal/Provisioning/ProvisioningCoordinatorImpl.swift b/Signal/Provisioning/ProvisioningCoordinatorImpl.swift
index 1c1dbab8403..363a7561a5b 100644
--- a/Signal/Provisioning/ProvisioningCoordinatorImpl.swift
+++ b/Signal/Provisioning/ProvisioningCoordinatorImpl.swift
@@ -247,6 +247,8 @@ class ProvisioningCoordinatorImpl: ProvisioningCoordinator {
             return .genericError(error)
         }
 
+        var didLinkNSync = false
+        var postLinkNSyncProgress: OWSProgressSource?
         if
             FeatureFlags.linkAndSync,
             let ephemeralBackupKey = BackupKey(provisioningMessage: provisionMessage)
@@ -256,6 +258,14 @@ class ProvisioningCoordinatorImpl: ProvisioningCoordinator {
                     progressViewModel.progress = progress.percentComplete
                 }
             }
+            let linkNSyncProgress = await progress.addChild(
+                withLabel: LocalizationNotNeeded("Link'n'sync"),
+                unitCount: 95
+            )
+            postLinkNSyncProgress = await progress.addSource(
+                withLabel: LocalizationNotNeeded("Post-link'n'sync"),
+                unitCount: 5
+            )
 
             let localIdentifiers = LocalIdentifiers(
                 aci: aci,
@@ -268,8 +278,9 @@ class ProvisioningCoordinatorImpl: ProvisioningCoordinator {
                     localIdentifiers: localIdentifiers,
                     auth: authedDevice.authedAccount.chatServiceAuth,
                     ephemeralBackupKey: ephemeralBackupKey,
-                    progress: progress
+                    progress: linkNSyncProgress
                 )
+                didLinkNSync = true
             } catch let firstAttemptError {
                 Logger.error("Failed link'n'sync \(firstAttemptError)")
 
@@ -281,8 +292,9 @@ class ProvisioningCoordinatorImpl: ProvisioningCoordinator {
                             localIdentifiers: localIdentifiers,
                             auth: authedDevice.authedAccount.chatServiceAuth,
                             ephemeralBackupKey: ephemeralBackupKey,
-                            progress: progress
+                            progress: linkNSyncProgress
                         )
+                        didLinkNSync = true
                         break
                     } catch {
                         currentError = error
@@ -317,22 +329,46 @@ class ProvisioningCoordinatorImpl: ProvisioningCoordinator {
             )
         }
 
-        return await performNecessarySyncsAndRestores(
-            authedDevice: authedDevice
-        )
+        if let postLinkNSyncProgress {
+            return await postLinkNSyncProgress.updatePeriodically(
+                timeInterval: 0.1,
+                estimatedTimeToCompletion: 5,
+                work: {
+                    return await self.performNecessarySyncsAndRestores(
+                        authedDevice: authedDevice,
+                        didLinkNSync: didLinkNSync
+                    )
+                }
+            )
+        } else {
+            return await performNecessarySyncsAndRestores(
+                authedDevice: authedDevice,
+                didLinkNSync: didLinkNSync
+            )
+        }
     }
 
     private func performNecessarySyncsAndRestores(
-        authedDevice: AuthedDevice
+        authedDevice: AuthedDevice,
+        didLinkNSync: Bool
     ) async -> CompleteProvisioningResult {
         async let storageServiceRestore: Void = self.performInitialStorageServiceRestore(
             authedDevice: authedDevice
         )
-        async let contactSync: Void = self.performInitialContactSync()
-        do {
-            _ = try await (storageServiceRestore, contactSync)
-        } catch {
-            return .genericError(error)
+        if didLinkNSync {
+            // Because link'n'sync gives us basic contact info, we don't
+            // block on a contact sync after doing one. We still do the
+            // contact sync in the background to get contact avatars.
+            Task {
+                try await performInitialContactSync()
+            }
+        } else {
+            async let contactSync: Void = self.performInitialContactSync()
+            do {
+                _ = try await (storageServiceRestore, contactSync)
+            } catch {
+                return .genericError(error)
+            }
         }
         return .success
     }
diff --git a/SignalServiceKit/MessageBackup/MessageBackupProgress.swift b/SignalServiceKit/MessageBackup/MessageBackupProgress.swift
index a66107a720b..6ca39bcea82 100644
--- a/SignalServiceKit/MessageBackup/MessageBackupProgress.swift
+++ b/SignalServiceKit/MessageBackup/MessageBackupProgress.swift
@@ -86,7 +86,9 @@ public struct MessageBackupImportProgress {
             owsFailDebug("How did we get such a huge byte length?")
             return
         }
-        progressSource.incrementCompletedUnitCount(by: byteLength)
+        if byteLength > 0 {
+            progressSource.incrementCompletedUnitCount(by: byteLength)
+        }
     }
 
     public func didFinishImport() {
diff --git a/SignalServiceKit/Util/OWSProgress.swift b/SignalServiceKit/Util/OWSProgress.swift
index 9a6a01dc322..2c3c7234f57 100644
--- a/SignalServiceKit/Util/OWSProgress.swift
+++ b/SignalServiceKit/Util/OWSProgress.swift
@@ -138,7 +138,7 @@ extension OWSProgressSource {
     /// on the current source periodically (every ``timeInterval`` seconds)
     /// until the work block completes.
     /// Returns with the result of the work block when it completes.
-    func updatePeriodically<T, E>(
+    public func updatePeriodically<T, E>(
         timeInterval: TimeInterval = 0.1,
         estimatedTimeToCompletion: TimeInterval,
         work: @escaping () async throws(E) -> T
