diff --git a/SignalServiceKit/src/Util/Atomics.swift b/SignalServiceKit/src/Util/Atomics.swift
index e62fca1b890..275c0aef80f 100644
--- a/SignalServiceKit/src/Util/Atomics.swift
+++ b/SignalServiceKit/src/Util/Atomics.swift
@@ -301,6 +301,12 @@ public class AtomicArray<T> {
         }
     }
 
+    public func append(contentsOf newElements: some Sequence<T>) {
+        lock.perform {
+            values.append(contentsOf: newElements)
+        }
+    }
+
     public var first: T? {
         lock.perform {
             values.first
diff --git a/SignalShareExtension/SharingThreadPickerViewController.swift b/SignalShareExtension/SharingThreadPickerViewController.swift
index 023ff3fa176..fd34c8aa9f5 100644
--- a/SignalShareExtension/SharingThreadPickerViewController.swift
+++ b/SignalShareExtension/SharingThreadPickerViewController.swift
@@ -59,7 +59,7 @@ class SharingThreadPickerViewController: ConversationPickerViewController {
     var approvalMessageBody: MessageBody?
     var approvalLinkPreviewDraft: OWSLinkPreviewDraft?
 
-    var outgoingMessages = [TSOutgoingMessage]()
+    var outgoingMessages = AtomicArray<TSOutgoingMessage>(lock: .init())
 
     var mentionCandidates: [SignalServiceAddress] = []
 
@@ -226,37 +226,38 @@ extension SharingThreadPickerViewController {
 
             let linkPreviewDraft = approvalLinkPreviewDraft
 
-            let outgoingMessageConversations = selectedConversations.filter { $0.outgoingMessageClass == TSOutgoingMessage.self }
-            let outgoingMessageSendPromise: Promise<Void>
-            if !outgoingMessageConversations.isEmpty {
-                outgoingMessageSendPromise = sendToOutgoingMessageThreads { thread in
-                    return firstly(on: DispatchQueue.global()) { () -> Promise<Void> in
-                        return self.databaseStorage.write { transaction in
-                            let preparer = OutgoingMessagePreparer(
-                                messageBody: body,
-                                thread: thread,
-                                transaction: transaction
-                            )
-                            preparer.insertMessage(linkPreviewDraft: linkPreviewDraft, transaction: transaction)
-                            self.outgoingMessages.append(preparer.unpreparedMessage)
-                            return ThreadUtil.enqueueMessagePromise(
-                                message: preparer.unpreparedMessage,
-                                isHighPriority: true,
-                                transaction: transaction
-                            )
-                        }
+            let nonStorySendPromise = sendToOutgoingMessageThreads { thread in
+                return firstly(on: DispatchQueue.global()) { () -> Promise<Void> in
+                    return self.databaseStorage.write { transaction in
+                        let preparer = OutgoingMessagePreparer(
+                            messageBody: body,
+                            thread: thread,
+                            transaction: transaction
+                        )
+                        preparer.insertMessage(linkPreviewDraft: linkPreviewDraft, transaction: transaction)
+                        self.outgoingMessages.append(preparer.unpreparedMessage)
+                        return ThreadUtil.enqueueMessagePromise(
+                            message: preparer.unpreparedMessage,
+                            isHighPriority: true,
+                            transaction: transaction
+                        )
                     }
                 }
-            } else {
-                outgoingMessageSendPromise = Promise.value(())
             }
 
             // Send the text message to any selected story recipients
             // as a text story with default styling.
             let storyConversations = selectedConversations.filter { $0.outgoingMessageClass == OutgoingStoryMessage.self }
-            let storySendPromise = StorySharing.sendTextStory(with: body, linkPreviewDraft: linkPreviewDraft, to: storyConversations)
+            let storySendPromise = StorySharing.sendTextStoryFromShareExtension(
+                with: body,
+                linkPreviewDraft: linkPreviewDraft,
+                to: storyConversations,
+                messagesReadyToSend: { messages in
+                    self.outgoingMessages.append(contentsOf: messages)
+                }
+            )
 
-            return Promise<Void>.when(fulfilled: [outgoingMessageSendPromise, storySendPromise])
+            return Promise<Void>.when(fulfilled: [nonStorySendPromise, storySendPromise])
         } else if isContactShare {
             guard let contactShare = approvedContactShare else {
                 return Promise(error: OWSAssertionError("Missing contactShare."))
@@ -290,7 +291,7 @@ extension SharingThreadPickerViewController {
                     approvalMessageBody: self.approvalMessageBody,
                     approvedAttachments: approvedAttachments,
                     messagesReadyToSend: { messages in
-                        DispatchQueue.main.async { self.outgoingMessages = messages }
+                        self.outgoingMessages.append(contentsOf: messages)
                     }
                 )
             }
@@ -421,19 +422,16 @@ extension SharingThreadPickerViewController {
 
     func threads(for conversationItems: [ConversationItem]) -> Promise<[TSThread]> {
         return firstly(on: DispatchQueue.sharedUserInteractive) {
-            guard conversationItems.count > 0 else {
-                throw OWSAssertionError("No recipients.")
-            }
-
             var threads: [TSThread] = []
-
-            self.databaseStorage.write { transaction in
-                for conversation in conversationItems {
-                    guard let thread = conversation.getOrCreateThread(transaction: transaction) else {
-                        owsFailDebug("Missing thread for conversation")
-                        continue
+            if !conversationItems.isEmpty {
+                self.databaseStorage.write { transaction in
+                    for conversation in conversationItems {
+                        guard let thread = conversation.getOrCreateThread(transaction: transaction) else {
+                            owsFailDebug("Missing thread for conversation")
+                            continue
+                        }
+                        threads.append(thread)
                     }
-                    threads.append(thread)
                 }
             }
             return threads
@@ -451,7 +449,7 @@ extension SharingThreadPickerViewController {
         ) { [weak self] _ in
             guard let self = self else { return }
             self.databaseStorage.write { transaction in
-                for message in self.outgoingMessages {
+                for message in self.outgoingMessages.get() {
                     // If we sent the message to anyone, mark it as failed
                     message.updateWithAllSendingRecipientsMarkedAsFailed(with: transaction)
                 }
@@ -531,11 +529,11 @@ extension SharingThreadPickerViewController {
 
     func resendMessages() {
         AssertIsOnMainThread()
-        owsAssertDebug(!outgoingMessages.isEmpty)
+        owsAssertDebug(outgoingMessages.count > 0)
 
         var promises = [Promise<Void>]()
         databaseStorage.write { transaction in
-            for message in outgoingMessages {
+            for message in outgoingMessages.get() {
                 promises.append(sskJobQueues.messageSenderJobQueue.add(
                     .promise,
                     message: message.asPreparer,
diff --git a/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift
index 2e165a86ccb..fd477fc5085 100644
--- a/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/AttachmentMultisend.swift	
@@ -9,32 +9,27 @@ import SignalServiceKit
 
 public class AttachmentMultisend: Dependencies {
 
+    private struct PreparedMultisend {
+        let attachmentIdMap: [String: [String]]
+        let messages: [TSOutgoingMessage]
+        let unsavedMessages: [OutgoingStoryMessage]
+        let threads: [TSThread]
+    }
+
     public class func sendApprovedMedia(
         conversations: [ConversationItem],
         approvalMessageBody: MessageBody?,
         approvedAttachments: [SignalAttachment]
     ) -> Promise<[TSThread]> {
-        return firstly(on: DispatchQueue.sharedUserInitiated) { () -> Promise<PreparedMediaMultisend> in
-            return self.prepareForSending(
+        return firstly(on: ThreadUtil.enqueueSendQueue) { () -> Promise<PreparedMultisend> in
+            self.prepareForSending(
                 conversations: conversations,
                 approvalMessageBody: approvalMessageBody,
                 approvedAttachments: approvedAttachments,
-                on: DispatchQueue.sharedUserInitiated
+                on: ThreadUtil.enqueueSendQueue
             )
-        }.map(on: ThreadUtil.enqueueSendQueue) { (preparedSend: PreparedMediaMultisend) -> [TSThread] in
-            self.databaseStorage.write { transaction in
-                // This will upload the TSAttachments whose IDs are the keys of attachmentIdMap
-                // and propagate their upload state to each of the TSAttachment unique IDs in the values.
-                // Each outgoing destination gets its own TSAttachment per attached media, but we upload only one,
-                // and propagate its upload state to each of these independent clones.
-                self.smJobQueues.broadcastMediaMessageJobQueue.add(
-                    attachmentIdMap: preparedSend.attachmentIdMap,
-                    unsavedMessagesToSend: preparedSend.unsavedMessages,
-                    transaction: transaction
-                )
-            }
-
-            return preparedSend.threads
+        }.then(on: ThreadUtil.enqueueSendQueue) { (preparedSend: PreparedMultisend) -> Promise<[TSThread]> in
+            self.sendAttachment(preparedSend: preparedSend)
         }
     }
 
@@ -42,42 +37,18 @@ public class AttachmentMultisend: Dependencies {
         conversations: [ConversationItem],
         approvalMessageBody: MessageBody?,
         approvedAttachments: [SignalAttachment],
-        messagesReadyToSend: (([TSOutgoingMessage]) -> Void)? = nil
+        messagesReadyToSend: @escaping ([TSOutgoingMessage]) -> Void
     ) -> Promise<[TSThread]> {
-        return firstly(on: DispatchQueue.sharedUserInitiated) { () -> Promise<PreparedMediaMultisend> in
-            return self.prepareForSending(
+        return firstly(on: ThreadUtil.enqueueSendQueue) { () -> Promise<PreparedMultisend> in
+            self.prepareForSending(
                 conversations: conversations,
                 approvalMessageBody: approvalMessageBody,
                 approvedAttachments: approvedAttachments,
-                on: DispatchQueue.sharedUserInitiated
+                on: ThreadUtil.enqueueSendQueue
             )
+        }.then(on: ThreadUtil.enqueueSendQueue) { (preparedSend: PreparedMultisend) -> Promise<[TSThread]> in
+            try self.sendAttachmentFromShareExtension(preparedSend: preparedSend, messagesReadyToSend: messagesReadyToSend)
         }
-        .then(on: DispatchQueue.sharedUserInitiated) { (preparedSend: PreparedMediaMultisend) -> Promise<[TSThread]> in
-
-            messagesReadyToSend?(preparedSend.messages)
-
-            let outgoingMessages = try BroadcastMediaUploader.upload(attachmentIdMap: preparedSend.attachmentIdMap) + preparedSend.unsavedMessages
-
-            var messageSendPromises = [Promise<Void>]()
-            databaseStorage.write { transaction in
-                for message in outgoingMessages {
-                    messageSendPromises.append(ThreadUtil.enqueueMessagePromise(
-                        message: message,
-                        isHighPriority: true,
-                        transaction: transaction
-                    ))
-                }
-            }
-
-            return Promise.when(fulfilled: messageSendPromises).map { preparedSend.threads }
-        }
-    }
-
-    private struct PreparedMediaMultisend {
-        let attachmentIdMap: [String: [String]]
-        let messages: [TSOutgoingMessage]
-        let unsavedMessages: [TSOutgoingMessage]
-        let threads: [TSThread]
     }
 
     // Used to allow a raw Type as the key of a dictionary
@@ -98,7 +69,7 @@ public class AttachmentMultisend: Dependencies {
         approvalMessageBody: MessageBody?,
         approvedAttachments: [SignalAttachment],
         on queue: DispatchQueue
-    ) -> Promise<PreparedMediaMultisend> {
+    ) -> Promise<PreparedMultisend> {
         if let segmentDuration = conversations.lazy.compactMap(\.videoAttachmentDurationLimit).min() {
             let attachmentPromises = approvedAttachments.map {
                 $0.preparedForOutput(qualityLevel: .standard)
@@ -130,7 +101,7 @@ public class AttachmentMultisend: Dependencies {
         conversations: [ConversationItem],
         approvalMessageBody: MessageBody?,
         approvedAttachments: [SignalAttachment.SegmentAttachmentResult]
-    ) throws -> PreparedMediaMultisend {
+    ) throws -> PreparedMultisend {
         struct IdentifiedSegmentedResult {
             let original: Identified<SignalAttachment>
             let segmented: [Identified<SignalAttachment>]?
@@ -234,47 +205,40 @@ public class AttachmentMultisend: Dependencies {
             }
         }
 
-        return PreparedMediaMultisend(
+        return PreparedMultisend(
             attachmentIdMap: state.attachmentIdMap,
             messages: state.messages,
             unsavedMessages: state.unsavedMessages,
-            threads: state.threads)
+            threads: state.threads
+        )
     }
-}
-
-public extension AttachmentMultisend {
 
-    class func sendTextAttachment(
+    public class func sendTextAttachment(
         _ textAttachment: UnsentTextAttachment,
         to conversations: [ConversationItem]
     ) -> Promise<[TSThread]> {
         return firstly(on: ThreadUtil.enqueueSendQueue) {
             let preparedSend = try self.prepareForSending(conversations: conversations, textAttachment: textAttachment)
-            self.databaseStorage.write { transaction in
-                // This will upload the TSAttachment at the key of attachmentIdMap (just one, you can
-                // only send one text attachment at a time) and propagate its upload state to each of the
-                // TSAttachment unique IDs in the value (an array). Each outgoing destination gets its own
-                // TSAttachment, but we upload only one, and propagate its upload state to each of them.
-                self.smJobQueues.broadcastMediaMessageJobQueue.add(
-                    attachmentIdMap: preparedSend.attachmentIdMap,
-                    unsavedMessagesToSend: preparedSend.messages,
-                    transaction: transaction
-                )
-            }
-            return preparedSend.threads
+            return self.sendAttachment(preparedSend: preparedSend)
         }
     }
 
-    private struct PreparedTextMultisend {
-        let attachmentIdMap: [String: [String]]
-        let messages: [TSOutgoingMessage]
-        let threads: [TSThread]
+    public class func sendTextAttachmentFromShareExtension(
+        _ textAttachment: UnsentTextAttachment,
+        to conversations: [ConversationItem],
+        messagesReadyToSend: @escaping ([TSOutgoingMessage]) -> Void
+    ) -> Promise<[TSThread]> {
+        return firstly(on: ThreadUtil.enqueueSendQueue) {
+            try self.prepareForSending(conversations: conversations, textAttachment: textAttachment)
+        }.then(on: ThreadUtil.enqueueSendQueue) { (preparedSend: PreparedMultisend) -> Promise<[TSThread]> in
+            try self.sendAttachmentFromShareExtension(preparedSend: preparedSend, messagesReadyToSend: messagesReadyToSend)
+        }
     }
 
     private class func prepareForSending(
         conversations: [ConversationItem],
         textAttachment: UnsentTextAttachment
-    ) throws -> PreparedTextMultisend {
+    ) throws -> PreparedMultisend {
 
         let state = MultisendState(approvalMessageBody: nil)
         let conversationsByMessageType = Dictionary(grouping: conversations, by: { TypeWrapper(type: $0.outgoingMessageClass) })
@@ -317,10 +281,51 @@ public extension AttachmentMultisend {
             }
         }
 
-        return PreparedTextMultisend(
+        return PreparedMultisend(
             attachmentIdMap: state.attachmentIdMap,
-            messages: state.unsavedMessages,
-            threads: state.threads)
+            messages: state.messages,
+            unsavedMessages: state.unsavedMessages,
+            threads: state.threads
+        )
+    }
+
+    // MARK: - Helpers
+
+    private class func sendAttachment(preparedSend: PreparedMultisend) -> Promise<[TSThread]> {
+        databaseStorage.write { transaction in
+            // This will upload the TSAttachments whose IDs are the keys of attachmentIdMap
+            // and propagate their upload state to each of the TSAttachment unique IDs in the values.
+            // Each outgoing destination gets its own TSAttachment per attached media, but we upload only one,
+            // and propagate its upload state to each of these independent clones.
+            smJobQueues.broadcastMediaMessageJobQueue.add(
+                attachmentIdMap: preparedSend.attachmentIdMap,
+                unsavedMessagesToSend: preparedSend.unsavedMessages,
+                transaction: transaction
+            )
+        }
+        return .value(preparedSend.threads)
+    }
+
+    private class func sendAttachmentFromShareExtension(
+        preparedSend: PreparedMultisend,
+        messagesReadyToSend: @escaping ([TSOutgoingMessage]) -> Void
+    ) throws -> Promise<[TSThread]> {
+        messagesReadyToSend(preparedSend.messages)
+
+        let outgoingMessages = try BroadcastMediaUploader.upload(attachmentIdMap: preparedSend.attachmentIdMap) + preparedSend.unsavedMessages
+
+        var messageSendPromises = [Promise<Void>]()
+        databaseStorage.write { transaction in
+            for message in outgoingMessages {
+                messageSendPromises.append(ThreadUtil.enqueueMessagePromise(
+                    message: message,
+                    isHighPriority: true,
+                    transaction: transaction
+                ))
+            }
+        }
+
+        return Promise.when(fulfilled: messageSendPromises).map { preparedSend.threads }
     }
 }
 
@@ -360,7 +365,7 @@ class MultisendDestination: NSObject {
 class MultisendState: NSObject {
     let approvalMessageBody: MessageBody?
     var messages: [TSOutgoingMessage] = []
-    var unsavedMessages: [TSOutgoingMessage] = []
+    var unsavedMessages: [OutgoingStoryMessage] = []
     var threads: [TSThread] = []
     var correspondingAttachmentIds: [UUID: [String]] = [:]
     var attachmentIdMap: [String: [String]] = [:]
diff --git a/SignalUI/Utils/StorySharing.swift b/SignalUI/Utils/StorySharing.swift
index 9feefc9d63d..12c2dd21404 100644
--- a/SignalUI/Utils/StorySharing.swift
+++ b/SignalUI/Utils/StorySharing.swift
@@ -11,14 +11,42 @@ public enum StorySharing: Dependencies {
         linkPreviewDraft: OWSLinkPreviewDraft?,
         to conversations: [ConversationItem]
     ) -> Promise<Void> {
-        // Send the text message to any selected story recipients
-        // as a text story with default styling.
         let storyConversations = conversations.filter { $0.outgoingMessageClass == OutgoingStoryMessage.self }
         owsAssertDebug(conversations.count == storyConversations.count)
 
         guard !storyConversations.isEmpty else { return Promise.value(()) }
 
-        let textAttachment = UnsentTextAttachment(
+        return AttachmentMultisend.sendTextAttachment(
+            buildTextAttachment(with: messageBody, linkPreviewDraft: linkPreviewDraft),
+            to: storyConversations
+        ).asVoid()
+    }
+
+    public static func sendTextStoryFromShareExtension(
+        with messageBody: MessageBody,
+        linkPreviewDraft: OWSLinkPreviewDraft?,
+        to conversations: [ConversationItem],
+        messagesReadyToSend: @escaping ([TSOutgoingMessage]) -> Void
+    ) -> Promise<Void> {
+        let storyConversations = conversations.filter { $0.outgoingMessageClass == OutgoingStoryMessage.self }
+        owsAssertDebug(conversations.count == storyConversations.count)
+
+        guard !storyConversations.isEmpty else { return Promise.value(()) }
+
+        return AttachmentMultisend.sendTextAttachmentFromShareExtension(
+            buildTextAttachment(with: messageBody, linkPreviewDraft: linkPreviewDraft),
+            to: storyConversations,
+            messagesReadyToSend: messagesReadyToSend
+        ).asVoid()
+    }
+
+    private static func buildTextAttachment(
+        with messageBody: MessageBody,
+        linkPreviewDraft: OWSLinkPreviewDraft?
+    ) -> UnsentTextAttachment {
+        // Send the text message to any selected story recipients
+        // as a text story with default styling.
+        return UnsentTextAttachment(
             text: text(for: messageBody, with: linkPreviewDraft),
             textStyle: .regular,
             textForegroundColor: .white,
@@ -26,8 +54,6 @@ public enum StorySharing: Dependencies {
             background: .color(.init(rgbHex: 0x688BD4)),
             linkPreviewDraft: linkPreviewDraft
         )
-
-        return AttachmentMultisend.sendTextAttachment(textAttachment, to: storyConversations).asVoid()
     }
 
     internal static func text(for messageBody: MessageBody, with linkPreview: OWSLinkPreviewDraft?) -> String? {
