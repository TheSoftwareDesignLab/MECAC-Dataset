diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index ccfd58f4802..96a12c6066c 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -835,6 +835,9 @@
 		6645F30829BF8D2000B58EBD /* AccountAttributes.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6645F30729BF8D2000B58EBD /* AccountAttributes.swift */; };
 		6645F30A29BF8DBC00B58EBD /* AccountAttributesRequestFactory.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6645F30929BF8DBC00B58EBD /* AccountAttributesRequestFactory.swift */; };
 		6645F30C29BFA28A00B58EBD /* AccountAttributes+Dependencies.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6645F30B29BFA28A00B58EBD /* AccountAttributes+Dependencies.swift */; };
+		6652DF672A04494200EF90E7 /* StyleOnlyMessageBody.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6652DF662A04494200EF90E7 /* StyleOnlyMessageBody.swift */; };
+		6652DF6A2A045EF000EF90E7 /* StyleOnlyMessageBodyTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6652DF682A045ED600EF90E7 /* StyleOnlyMessageBodyTests.swift */; };
+		6652DF6C2A04828800EF90E7 /* StoryMessageAttachment.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6652DF6B2A04828800EF90E7 /* StoryMessageAttachment.swift */; };
 		66533E3729B7B56000E8D928 /* WhoAmIRequestFactory.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66533E3629B7B56000E8D928 /* WhoAmIRequestFactory.swift */; };
 		66533E3A29B9502100E8D928 /* RegistrationMode.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66533E3929B9502100E8D928 /* RegistrationMode.swift */; };
 		66533E3C29BA8BB200E8D928 /* AuthedAccount.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66533E3B29BA8BB200E8D928 /* AuthedAccount.swift */; };
@@ -3330,6 +3333,9 @@
 		6645F30729BF8D2000B58EBD /* AccountAttributes.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AccountAttributes.swift; sourceTree = "<group>"; };
 		6645F30929BF8DBC00B58EBD /* AccountAttributesRequestFactory.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AccountAttributesRequestFactory.swift; sourceTree = "<group>"; };
 		6645F30B29BFA28A00B58EBD /* AccountAttributes+Dependencies.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AccountAttributes+Dependencies.swift"; sourceTree = "<group>"; };
+		6652DF662A04494200EF90E7 /* StyleOnlyMessageBody.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StyleOnlyMessageBody.swift; sourceTree = "<group>"; };
+		6652DF682A045ED600EF90E7 /* StyleOnlyMessageBodyTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StyleOnlyMessageBodyTests.swift; sourceTree = "<group>"; };
+		6652DF6B2A04828800EF90E7 /* StoryMessageAttachment.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryMessageAttachment.swift; sourceTree = "<group>"; };
 		66533E3629B7B56000E8D928 /* WhoAmIRequestFactory.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WhoAmIRequestFactory.swift; sourceTree = "<group>"; };
 		66533E3929B9502100E8D928 /* RegistrationMode.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RegistrationMode.swift; sourceTree = "<group>"; };
 		66533E3B29BA8BB200E8D928 /* AuthedAccount.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AuthedAccount.swift; sourceTree = "<group>"; };
@@ -6752,6 +6758,7 @@
 				66FC638529E4B9AF00F00DAC /* RecoveredHydratedMessageBody.swift */,
 				665FAE8B2A02C0D400FA298D /* SpoilerRevealState.swift */,
 				66FC637729DF8BEF00F00DAC /* StyleAttribute.swift */,
+				6652DF662A04494200EF90E7 /* StyleOnlyMessageBody.swift */,
 				66FC638B29E9E9D200F00DAC /* TextCheckingDataItem.swift */,
 			);
 			path = BodyRanges;
@@ -6762,6 +6769,7 @@
 			children = (
 				66FC637029DF79F400F00DAC /* MessageBodyRangesTests.swift */,
 				66883A3829D7630300E898CF /* MessageBodyTests.swift */,
+				6652DF682A045ED600EF90E7 /* StyleOnlyMessageBodyTests.swift */,
 			);
 			path = BodyRanges;
 			sourceTree = "<group>";
@@ -8657,6 +8665,7 @@
 				F9C5C96B289453B100548EEE /* StoryFinder.swift */,
 				F9C5C969289453B100548EEE /* StoryManager.swift */,
 				F9C5C96A289453B100548EEE /* StoryMessage.swift */,
+				6652DF6B2A04828800EF90E7 /* StoryMessageAttachment.swift */,
 				669E8FFF28B42B7A00043D28 /* SystemStoryManager.swift */,
 				669E900F28B57D6300043D28 /* SystemStoryManagerMock.swift */,
 				669E900628B43F5B00043D28 /* SystemStoryManagerProtocol.swift */,
@@ -12330,8 +12339,10 @@
 				F9C5CC59289453B300548EEE /* StoryFinder.swift in Sources */,
 				F9C5CC57289453B300548EEE /* StoryManager.swift in Sources */,
 				F9C5CC58289453B300548EEE /* StoryMessage.swift in Sources */,
+				6652DF6C2A04828800EF90E7 /* StoryMessageAttachment.swift in Sources */,
 				F9C5CDDB289453B400548EEE /* String+SSK.swift in Sources */,
 				66FC637829DF8BEF00F00DAC /* StyleAttribute.swift in Sources */,
+				6652DF672A04494200EF90E7 /* StyleOnlyMessageBody.swift in Sources */,
 				F9C5CCE8289453B300548EEE /* SubscriptionManager.swift in Sources */,
 				F9C5CE2F289453B400548EEE /* SwiftSingletons.swift in Sources */,
 				F9C5CE04289453B400548EEE /* SyncManagerProtocol.swift in Sources */,
@@ -12582,6 +12593,7 @@
 				F942628E289B1B5600460798 /* StickerPackInfoTest.swift in Sources */,
 				884BF73E28D37D5F00D94636 /* StoryManagerTest.swift in Sources */,
 				F9CAC77F29199B9200EEC1DE /* StringTest.swift in Sources */,
+				6652DF6A2A045EF000EF90E7 /* StyleOnlyMessageBodyTests.swift in Sources */,
 				884BF73D28D37D5F00D94636 /* SystemStoryManagerTest.swift in Sources */,
 				F9426249289B1B5500460798 /* TestModelTests.swift in Sources */,
 				F9426288289B1B5600460798 /* TestProtocolRunnerTest.swift in Sources */,
diff --git a/Signal/src/ViewControllers/ForwardMessageViewController.swift b/Signal/src/ViewControllers/ForwardMessageViewController.swift
index 8dbe3982d42..a6ef9e2e6a8 100644
--- a/Signal/src/ViewControllers/ForwardMessageViewController.swift
+++ b/Signal/src/ViewControllers/ForwardMessageViewController.swift
@@ -130,9 +130,9 @@ class ForwardMessageViewController: InteractiveSheetViewController {
     ) {
         let builder = Item.Builder()
         switch storyMessage.attachment {
-        case .file(let attachmentId):
+        case .file(let file):
             guard let attachmentStream = databaseStorage.read(block: {
-                TSAttachmentStream.anyFetchAttachmentStream(uniqueId: attachmentId, transaction: $0)
+                TSAttachmentStream.anyFetchAttachmentStream(uniqueId: file.attachmentId, transaction: $0)
             }) else {
                 ForwardMessageViewController.showAlertForForwardError(
                     error: OWSAssertionError("Missing attachment stream for forwarded story message"),
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift
index 999fb8120a6..0979a7f1bb0 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift	
@@ -320,8 +320,8 @@ class StoryContextViewController: OWSViewController {
         let replyCount = message.replyCount
 
         switch message.attachment {
-        case .file(let attachmentId):
-            guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) else {
+        case .file(let file):
+            guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: transaction) else {
                 owsFailDebug("Missing attachment for StoryMessage with timestamp \(message.timestamp)")
                 return nil
             }
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift
index 7bc188abeeb..f191e1eb6c8 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryItemMediaView.swift	
@@ -215,7 +215,14 @@ class StoryItemMediaView: UIView {
                 }
             }
         case .text(let attachment):
-            glyphCount = attachment.text?.glyphCount
+            switch attachment.textContent {
+            case .empty:
+                glyphCount = nil
+            case .styled(let text, _):
+                glyphCount = text.glyphCount
+            case .styledRanges(let body):
+                glyphCount = body.text.glyphCount
+            }
 
             // As a base, all text attachments play for at least 5s,
             // even if they have no text.
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift
index 596c5dc227d..cda598b4252 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift	
@@ -541,8 +541,8 @@ extension StoryPageViewController: UIViewControllerTransitioningDelegate {
 
     private func storyThumbnailSize(for presentingMessage: StoryMessage) throws -> CGSize? {
         switch presentingMessage.attachment {
-        case .file(let attachmentId):
-            guard let attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: attachmentId, transaction: $0) }) else {
+        case .file(let file):
+            guard let attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: $0) }) else {
                 throw OWSAssertionError("Unexpectedly missing attachment for story message")
             }
 
@@ -559,8 +559,8 @@ extension StoryPageViewController: UIViewControllerTransitioningDelegate {
     private func storyView(for presentingMessage: StoryMessage) -> UIView? {
         let storyView: UIView
         switch presentingMessage.attachment {
-        case .file(let attachmentId):
-            guard let attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: attachmentId, transaction: $0) }) else {
+        case .file(let file):
+            guard let attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: $0) }) else {
                 // Can happen if the story was deleted by the sender while in the viewer.
                 return nil
             }
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift
index fd3004c2289..8400391f032 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Replies & Views Sheets/StoryContextMenuGenerator.swift	
@@ -762,11 +762,22 @@ extension StoryContextMenuGenerator {
                             self?.isDisplayingFollowup = false
                             completion(true)
                         }
-                    } else if let text = attachment.text {
-                        self?.isDisplayingFollowup = true
-                        AttachmentSharing.showShareUI(forText: text, sender: sourceView) { [weak self] in
-                            self?.isDisplayingFollowup = false
-                            completion(true)
+                    } else {
+                        let text: String?
+                        switch attachment.textContent {
+                        case .empty:
+                            text = nil
+                        case .styled(let body, _):
+                            text = body
+                        case .styledRanges(let body):
+                            text = body.text
+                        }
+                        if let text {
+                            self?.isDisplayingFollowup = true
+                            AttachmentSharing.showShareUI(forText: text, sender: sourceView) { [weak self] in
+                                self?.isDisplayingFollowup = false
+                                completion(true)
+                            }
                         }
                     }
                 case .missing:
diff --git a/Signal/src/ViewControllers/HomeView/Stories/StoryInfoSheet.swift b/Signal/src/ViewControllers/HomeView/Stories/StoryInfoSheet.swift
index 5b8bff82301..16a1bb78c55 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/StoryInfoSheet.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/StoryInfoSheet.swift
@@ -101,8 +101,8 @@ class StoryInfoSheet: OWSTableSheetViewController {
 
         switch storyMessage.attachment {
         case .text: break
-        case .file(let attachmentId):
-            guard let attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: attachmentId, transaction: $0) }) else {
+        case .file(let file):
+            guard let attachment = databaseStorage.read(block: { TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: $0) }) else {
                 owsFailDebug("Missing attachment for story message")
                 break
             }
diff --git a/Signal/src/ViewControllers/HomeView/Stories/StoryThumbnailView.swift b/Signal/src/ViewControllers/HomeView/Stories/StoryThumbnailView.swift
index 6f788b91aed..a2b6745b8e8 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/StoryThumbnailView.swift
+++ b/Signal/src/ViewControllers/HomeView/Stories/StoryThumbnailView.swift
@@ -13,8 +13,8 @@ class StoryThumbnailView: UIView {
 
         static func from(_ attachment: StoryMessageAttachment, transaction: SDSAnyReadTransaction) -> Self {
             switch attachment {
-            case .file(let attachmentId):
-                guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) else {
+            case .file(let file):
+                guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: transaction) else {
                     owsFailDebug("Unexpectedly missing attachment for story")
                     return .missing
                 }
diff --git a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
index e0db85a2b99..699f2630fe2 100644
--- a/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
+++ b/Signal/src/ViewControllers/Photos/PhotoCaptureViewController.swift
@@ -940,14 +940,26 @@ extension PhotoCaptureViewController {
     private func didTapTextStoryProceedButton() {
         Logger.verbose("")
 
-        let text = textStoryComposerView.text ?? ""
+        let body: StyleOnlyMessageBody
+        let textStyle: TextAttachment.TextStyle
+        switch textStoryComposerView.textContent {
+        case .empty:
+            body = StyleOnlyMessageBody(plaintext: "")
+            textStyle = .regular
+        case .styledRanges(let contentBody):
+            body = contentBody
+            textStyle = .regular
+        case .styled(let text, let style):
+            body = StyleOnlyMessageBody(plaintext: text)
+            textStyle = style
+        }
         let textForegroundColor = textStoryComposerView.textForegroundColor
         let textBackgroundColor = textStoryComposerView.textBackgroundColor
-        let textStyle = textStoryComposerView.textStyle
         let background = textStoryComposerView.background
 
+        // Styles are used only when forwading; we only get plaintext here.
         let unsentTextAttachment = UnsentTextAttachment(
-            text: text,
+            body: body,
             textStyle: textStyle,
             textForegroundColor: textForegroundColor,
             textBackgroundColor: textBackgroundColor,
@@ -1378,8 +1390,7 @@ private class TextStoryComposerView: TextAttachmentView, UITextViewDelegate {
 
     init(text: String) {
         super.init(
-            text: text,
-            textStyle: .regular,
+            textContent: .styled(body: text, style: .regular),
             textForegroundColor: .white,
             textBackgroundColor: nil,
             background: TextStoryComposerView.defaultBackground,
@@ -1499,6 +1510,32 @@ private class TextStoryComposerView: TextAttachmentView, UITextViewDelegate {
 
     override var isEditing: Bool { textView.isFirstResponder }
 
+    private var text: String? {
+        get {
+            switch super.textContent {
+            case .empty:
+                return nil
+            case .styledRanges(let body):
+                owsFailDebug("Should not have styled ranges in story text composer")
+                return body.text
+            case .styled(let body, _):
+                return body
+            }
+        }
+        set {
+            super.textContent = .styled(body: newValue ?? "", style: textStyle)
+        }
+    }
+
+    private var textStyle: TextAttachment.TextStyle = .regular {
+        didSet {
+            guard let text = text else {
+                return
+            }
+            super.textContent = .styled(body: text, style: self.textStyle)
+        }
+    }
+
     var isEmpty: Bool {
         guard let text = text else { return true }
         return text.isEmpty && linkPreview == nil
diff --git a/Signal/test/util/StorySharingTests.swift b/Signal/test/util/StorySharingTests.swift
index 5ded4a07b56..9cc6b309a74 100644
--- a/Signal/test/util/StorySharingTests.swift
+++ b/Signal/test/util/StorySharingTests.swift
@@ -30,12 +30,11 @@ class StorySharingTests: SignalBaseTest {
                     url: URL(string: "https://signal.org")!,
                     title: nil
                 )
-            )
+            )?.text
             XCTAssertEqual(output, expectedOutput)
         }
     }
 
-    // TODO[TextFormatting]: test style application as well.
     func testMentionFlattening() {
         let mentionUuid = UUID()
         let range = NSRange(location: 0, length: MessageBody.mentionPlaceholder.utf16.count)
@@ -45,7 +44,7 @@ class StorySharingTests: SignalBaseTest {
                 ranges: .init(mentions: [range: mentionUuid], styles: [])
             ),
             with: nil
-        )
+        )?.text
 
         XCTAssertEqual(output, "@Fake name Some text")
     }
diff --git a/SignalServiceKit/protobuf/SignalService.proto b/SignalServiceKit/protobuf/SignalService.proto
index a42e64de229..5d5eff3fc18 100644
--- a/SignalServiceKit/protobuf/SignalService.proto
+++ b/SignalServiceKit/protobuf/SignalService.proto
@@ -67,6 +67,7 @@ message StoryMessage {
     optional TextAttachment textAttachment = 4;
   // }
   optional bool allowsReplies = 5;
+  repeated BodyRange bodyRanges = 6;
 }
 
 message Preview {
diff --git a/SignalServiceKit/src/Contacts/TextAttachment.swift b/SignalServiceKit/src/Contacts/TextAttachment.swift
index 55290c86ecf..cdff02a21da 100644
--- a/SignalServiceKit/src/Contacts/TextAttachment.swift
+++ b/SignalServiceKit/src/Contacts/TextAttachment.swift
@@ -6,23 +6,27 @@
 import Foundation
 
 public struct UnsentTextAttachment {
-    public let text: String?
-    public let textStyle: TextAttachment.TextStyle
+    private let body: StyleOnlyMessageBody?
+    private let textStyle: TextAttachment.TextStyle
     public let textForegroundColor: UIColor
     public let textBackgroundColor: UIColor?
     public let background: TextAttachment.Background
 
     public let linkPreviewDraft: OWSLinkPreviewDraft?
 
+    public var textContent: TextAttachment.TextContent {
+        return TextAttachment.textContent(body: body, textStyle: textStyle)
+    }
+
     public init(
-        text: String?,
+        body: StyleOnlyMessageBody?,
         textStyle: TextAttachment.TextStyle,
         textForegroundColor: UIColor,
         textBackgroundColor: UIColor?,
         background: TextAttachment.Background,
         linkPreviewDraft: OWSLinkPreviewDraft?
     ) {
-        self.text = text
+        self.body = body
         self.textStyle = textStyle
         self.textForegroundColor = textForegroundColor
         self.textBackgroundColor = textBackgroundColor
@@ -42,12 +46,12 @@ public struct UnsentTextAttachment {
             }
         }
 
-        guard validatedLinkPreview != nil || !(text?.isEmpty ?? true) else {
+        guard validatedLinkPreview != nil || !(body?.isEmpty ?? true) else {
             owsFailDebug("Empty content")
             return nil
         }
         return TextAttachment(
-            text: text,
+            body: body,
             textStyle: textStyle,
             textForegroundColor: textForegroundColor,
             textBackgroundColor: textBackgroundColor,
@@ -58,7 +62,7 @@ public struct UnsentTextAttachment {
 }
 
 public struct TextAttachment: Codable, Equatable {
-    public let text: String?
+    private let body: StyleOnlyMessageBody?
 
     public enum TextStyle: Int, Codable, Equatable {
         case regular = 0
@@ -67,7 +71,38 @@ public struct TextAttachment: Codable, Equatable {
         case script = 3
         case condensed = 4
     }
-    public let textStyle: TextStyle
+    private let textStyle: TextStyle
+
+    public enum TextContent {
+        case empty
+        case styled(body: String, style: TextStyle)
+        case styledRanges(StyleOnlyMessageBody)
+    }
+
+    public private(set) var preview: OWSLinkPreview?
+
+    public var textContent: TextContent {
+        return Self.textContent(body: body, textStyle: textStyle)
+    }
+
+    fileprivate static func textContent(
+        body: StyleOnlyMessageBody?,
+        textStyle: TextStyle
+    ) -> TextContent {
+        guard let body, body.isEmpty.negated else {
+            return .empty
+        }
+        switch textStyle {
+        case .regular:
+            if body.hasStyles {
+                return .styledRanges(body)
+            } else {
+                return .styled(body: body.text, style: .regular)
+            }
+        case .bold, .serif, .script, .condensed:
+            return .styled(body: body.text, style: textStyle)
+        }
+    }
 
     private let textForegroundColorHex: UInt32?
     public var textForegroundColor: UIColor? { textForegroundColorHex.map { UIColor(argbHex: $0) } }
@@ -146,10 +181,12 @@ public struct TextAttachment: Codable, Equatable {
         }
     }
 
-    public private(set) var preview: OWSLinkPreview?
-
-    init(from proto: SSKProtoTextAttachment, transaction: SDSAnyWriteTransaction) throws {
-        self.text = proto.text?.nilIfEmpty
+    init(
+        from proto: SSKProtoTextAttachment,
+        bodyRanges: [SSKProtoBodyRange],
+        transaction: SDSAnyWriteTransaction
+    ) throws {
+        self.body = proto.text?.nilIfEmpty.map { StyleOnlyMessageBody(text: $0, protos: bodyRanges) }
 
         guard let style = proto.textStyle else {
             throw OWSAssertionError("Missing style for attachment.")
@@ -206,11 +243,15 @@ public struct TextAttachment: Codable, Equatable {
         }
     }
 
-    public func buildProto(transaction: SDSAnyReadTransaction) throws -> SSKProtoTextAttachment {
+    public func buildProto(
+        bodyRangeHandler: ([SSKProtoBodyRange]) -> Void,
+        transaction: SDSAnyReadTransaction
+    ) throws -> SSKProtoTextAttachment {
         let builder = SSKProtoTextAttachment.builder()
 
-        if let text = text {
-            builder.setText(text)
+        if let body {
+            builder.setText(body.text)
+            bodyRangeHandler(body.toProtoBodyRanges())
         }
 
         let textStyle: SSKProtoTextAttachmentStyle = {
@@ -247,14 +288,14 @@ public struct TextAttachment: Codable, Equatable {
     }
 
     public init(
-        text: String?,
+        body: StyleOnlyMessageBody?,
         textStyle: TextStyle,
         textForegroundColor: UIColor,
         textBackgroundColor: UIColor?,
         background: Background,
         linkPreview: OWSLinkPreview?
     ) {
-        self.text = text
+        self.body = body
         self.textStyle = textStyle
         self.textForegroundColorHex = textForegroundColor.argbHex
         self.textBackgroundColorHex = textBackgroundColor?.argbHex
@@ -284,7 +325,7 @@ public struct TextAttachment: Codable, Equatable {
             linkPreviewDraft = OWSLinkPreviewDraft(url: url, title: preview.title)
         }
         return UnsentTextAttachment(
-            text: text,
+            body: body,
             textStyle: textStyle,
             textForegroundColor: textForegroundColor ?? .white,
             textBackgroundColor: textBackgroundColor,
@@ -292,4 +333,36 @@ public struct TextAttachment: Codable, Equatable {
             linkPreviewDraft: linkPreviewDraft
         )
     }
+
+    public enum CodingKeys: String, CodingKey {
+        // Backwards compatibility; originally this held a vanilla string.
+        case body = "text"
+        case textStyle
+        case textForegroundColorHex
+        case textBackgroundColorHex
+        case rawBackground
+        case preview
+    }
+
+    public init(from decoder: Decoder) throws {
+        let container = try decoder.container(keyedBy: CodingKeys.self)
+
+        do {
+            // Backwards compability; this used to contain just a raw string,
+            // which we now interpret as a style-less string.
+            if let rawText = try container.decodeIfPresent(String.self, forKey: .body) {
+                self.body = StyleOnlyMessageBody(plaintext: rawText)
+            } else {
+                self.body = nil
+            }
+        } catch {
+            self.body = try container.decodeIfPresent(StyleOnlyMessageBody.self, forKey: .body)
+        }
+
+        self.textStyle = try container.decode(TextStyle.self, forKey: .textStyle)
+        self.textForegroundColorHex = try container.decodeIfPresent(UInt32.self, forKey: .textForegroundColorHex)
+        self.textBackgroundColorHex = try container.decodeIfPresent(UInt32.self, forKey: .textBackgroundColorHex)
+        self.rawBackground = try container.decode(RawBackground.self, forKey: .rawBackground)
+        self.preview = try container.decodeIfPresent(OWSLinkPreview.self, forKey: .preview)
+    }
 }
diff --git a/SignalServiceKit/src/Messages/Attachments/OWSAttachmentDownloads.swift b/SignalServiceKit/src/Messages/Attachments/OWSAttachmentDownloads.swift
index 6e7c107dc47..b036cf8bf5c 100644
--- a/SignalServiceKit/src/Messages/Attachments/OWSAttachmentDownloads.swift
+++ b/SignalServiceKit/src/Messages/Attachments/OWSAttachmentDownloads.swift
@@ -1280,10 +1280,10 @@ public extension OWSAttachmentDownloads {
         }
 
         switch storyMessage.attachment {
-        case .file(let attachmentId):
-            guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId,
+        case .file(let file):
+            guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId,
                                                          transaction: transaction) else {
-                owsFailDebug("Missing attachment: \(attachmentId)")
+                owsFailDebug("Missing attachment: \(file.attachmentId)")
                 break
             }
             addJobRequest(attachment: attachment, category: attachment.downloadCategory)
diff --git a/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift b/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift
index e48dfe3bd8c..733c218972e 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/HydratedMessageBody.swift
@@ -19,6 +19,8 @@ extension NSRangedValue: Equatable where T: Equatable {}
 
 extension NSRangedValue: Hashable where T: Hashable {}
 
+extension NSRangedValue: Codable where T: Codable {}
+
 /// The result of stripping, filtering, and hydrating mentions in a `MessageBody`.
 /// This object can be held durably in memory as a way to cache mention hydrations
 /// and other expensive string operations, and can subsequently be transformed
@@ -391,6 +393,14 @@ public class HydratedMessageBody: Equatable, Hashable {
         return mutableString as String
     }
 
+    // MARK: - Style-only (for stories)
+
+    public func asStyleOnlyBody() -> StyleOnlyMessageBody {
+        return StyleOnlyMessageBody(text: self.hydratedText, styles: self.styleAttributes.map {
+            return .init($0.value.style, range: $0.range)
+        })
+    }
+
     // MARK: - Forwarding
 
     public func asMessageBodyForForwarding() -> MessageBody {
diff --git a/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift b/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift
index 0d4142637c5..bd2279689b5 100644
--- a/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift
+++ b/SignalServiceKit/src/Messages/BodyRanges/MessageBodyRanges.swift
@@ -27,7 +27,7 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
     /// Sorted from lowest location to highest location
     public let orderedMentions: [NSRangedValue<UUID>]
 
-    public struct Style: OptionSet, Equatable, Hashable {
+    public struct Style: OptionSet, Equatable, Hashable, Codable {
         public let rawValue: Int
 
         public init(rawValue: Int) {
@@ -40,7 +40,50 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         public static let strikethrough = Style(rawValue: 1 << 3)
         public static let monospace = Style(rawValue: 1 << 4)
 
+        public static let all: [Style] = [.bold, .italic, .spoiler, .strikethrough, .monospace]
+
         static let attributedStringKey = NSAttributedString.Key("OWSStyle")
+
+        public static func from(_ protoStyle: SSKProtoBodyRangeStyle) -> Style? {
+            switch protoStyle {
+            case .none:
+                return nil
+            case .bold:
+                return .bold
+            case .italic:
+                return .italic
+            case .spoiler:
+                return .spoiler
+            case .strikethrough:
+                return .strikethrough
+            case .monospace:
+                return .monospace
+            }
+        }
+
+        /// Note it is one to many; we collapse styles into this option set
+        /// in swift but in proto-land we fan out to one style per instance.
+        public func asProtoStyles() -> [SSKProtoBodyRangeStyle] {
+            return Self.all.compactMap {
+                guard self.contains($0) else {
+                    return nil
+                }
+                switch $0 {
+                case .bold:
+                    return .bold
+                case .italic:
+                    return .italic
+                case .spoiler:
+                    return .spoiler
+                case .strikethrough:
+                    return .strikethrough
+                case .monospace:
+                    return .monospace
+                default:
+                    return nil
+                }
+            }
+        }
     }
 
     /// Sorted from lowest location to highest location.
@@ -74,22 +117,10 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
                 let mentionUuid = UUID(uuidString: mentionUuidString)
             {
                 mentions[range] = mentionUuid
-            } else if let protoStyle = proto.style {
-                let style: Style
-                switch protoStyle {
-                case .none:
-                    continue
-                case .bold:
-                    style = .bold
-                case .italic:
-                    style = .italic
-                case .spoiler:
-                    style = .spoiler
-                case .strikethrough:
-                    style = .strikethrough
-                case .monospace:
-                    style = .monospace
-                }
+            } else if
+                let protoStyle = proto.style,
+                let style = Style.from(protoStyle)
+            {
                 styles.append(.init(style, range: range))
             }
         }
@@ -339,4 +370,85 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         }
         return true
     }
+
+    // MARK: Proto conversion
+
+    /// If bodyLength is provided (is nonnegative), drops any ranges that exceed the length.
+    func toProtoBodyRanges(bodyLength: Int = -1) -> [SSKProtoBodyRange] {
+        let maxBodyLength = bodyLength < 0 ? nil : bodyLength
+        var protos = [SSKProtoBodyRange]()
+
+        var mentionIndex = 0
+        var styleIndex = 0
+
+        func appendMention(_ mention: NSRangedValue<UUID>) {
+            guard let builder = self.protoBuilder(mention.range, maxBodyLength: maxBodyLength) else {
+                return
+            }
+            builder.setMentionUuid(mention.value.uuidString)
+            do {
+                try protos.append(builder.build())
+            } catch {
+                owsFailDebug("Failed to build body range proto: \(error)")
+            }
+        }
+
+        func appendStyle(_ style: NSRangedValue<Style>) {
+            for protoStyle in style.value.asProtoStyles() {
+                guard let builder = self.protoBuilder(style.range, maxBodyLength: maxBodyLength) else {
+                    continue
+                }
+                builder.setStyle(protoStyle)
+                do {
+                    try protos.append(builder.build())
+                } catch {
+                    owsFailDebug("Failed to build body range proto: \(error)")
+                }
+            }
+        }
+
+        while mentionIndex < orderedMentions.count || styleIndex < styles.count {
+            if mentionIndex >= orderedMentions.count {
+                appendStyle(styles[styleIndex])
+                styleIndex += 1
+                continue
+            }
+            if styleIndex >= styles.count {
+                appendMention(orderedMentions[mentionIndex])
+                mentionIndex += 1
+                continue
+            }
+            // Insert whichever is earlier.
+            let mention = orderedMentions[mentionIndex]
+            let style = styles[styleIndex]
+            if mention.range.location <= style.range.location {
+                appendMention(orderedMentions[mentionIndex])
+                mentionIndex += 1
+            } else {
+                appendStyle(styles[styleIndex])
+                styleIndex += 1
+            }
+        }
+        return protos
+    }
+
+    private func protoBuilder(
+        _ range: NSRange,
+        maxBodyLength: Int?
+    ) -> SSKProtoBodyRangeBuilder? {
+        var range = range
+        if let maxBodyLength {
+            if range.location >= maxBodyLength {
+                return nil
+            }
+            if range.upperBound > maxBodyLength {
+                range = NSRange(location: range.location, length: maxBodyLength - range.location)
+            }
+        }
+
+        let builder = SSKProtoBodyRange.builder()
+        builder.setStart(UInt32(truncatingIfNeeded: range.location))
+        builder.setLength(UInt32(truncatingIfNeeded: range.length))
+        return builder
+    }
 }
diff --git a/SignalServiceKit/src/Messages/BodyRanges/StyleOnlyMessageBody.swift b/SignalServiceKit/src/Messages/BodyRanges/StyleOnlyMessageBody.swift
new file mode 100644
index 00000000000..98e87dd55d2
--- /dev/null
+++ b/SignalServiceKit/src/Messages/BodyRanges/StyleOnlyMessageBody.swift
@@ -0,0 +1,137 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+/// Like MessageBody but with styles only, no mentions.
+@objcMembers
+public class StyleOnlyMessageBody: NSObject, Codable {
+    public typealias Style = MessageBodyRanges.Style
+
+    public let text: String
+    public let styles: [NSRangedValue<Style>]
+
+    public var isEmpty: Bool {
+        return text.isEmpty
+    }
+
+    public var hasStyles: Bool {
+        return styles.isEmpty.negated
+    }
+
+    public convenience init(messageBody: MessageBody) {
+        self.init(text: messageBody.text, styles: messageBody.ranges.styles)
+    }
+
+    public convenience init(text: String, protos: [SSKProtoBodyRange]) {
+        let bodyRanges = MessageBodyRanges(protos: protos)
+        // Drop any mentions; don't even hydrate them.
+        self.init(text: text, styles: bodyRanges.styles)
+    }
+
+    public convenience init(plaintext: String) {
+        self.init(text: plaintext, styles: [])
+    }
+
+    public static var empty: StyleOnlyMessageBody { return StyleOnlyMessageBody(plaintext: "") }
+
+    public init(text: String, styles: [NSRangedValue<Style>]) {
+        self.text = text
+        self.styles = styles
+    }
+
+    public func asMessageBody() -> MessageBody {
+        return MessageBody(
+            text: text,
+            ranges: MessageBodyRanges(mentions: [:], styles: styles)
+        )
+    }
+
+    public func asAttributedStringForDisplay(
+        config: StyleDisplayConfiguration,
+        baseAttributes: [NSAttributedString.Key: Any]? = nil,
+        isDarkThemeEnabled: Bool
+    ) -> NSAttributedString {
+        let string = NSMutableAttributedString(string: text, attributes: baseAttributes ?? [:])
+        return HydratedMessageBody.applyAttributes(
+            on: string,
+            mentionAttributes: [],
+            styleAttributes: self.styles.map {
+                return .init(.fromOriginalRange($0.range, style: $0.value), range: $0.range)
+            },
+            config: HydratedMessageBody.DisplayConfiguration(
+                // Mentions are impossible on this class, so this is just a stub.
+                mention: MentionDisplayConfiguration(
+                    font: config.baseFont,
+                    foregroundColor: config.textColor,
+                    backgroundColor: nil
+                ),
+                style: config,
+                searchRanges: nil
+            ),
+            isDarkThemeEnabled: isDarkThemeEnabled
+        )
+    }
+
+    public func toProtoBodyRanges() -> [SSKProtoBodyRange] {
+        // No need to validate length; all instances of this class are validated.
+        return MessageBodyRanges(mentions: [:], styles: styles).toProtoBodyRanges()
+    }
+
+    public func stripAndDropFirst(_ count: Int) -> StyleOnlyMessageBody {
+        stripAndPerformDrop(String.dropFirst, count)
+    }
+
+    public func stripAndDropLast(_ count: Int) -> StyleOnlyMessageBody {
+        stripAndPerformDrop(String.dropLast, count)
+    }
+
+    private func stripAndPerformDrop(
+        _ operation: (__owned String) -> (Int) -> Substring,
+        _ count: Int
+    ) -> StyleOnlyMessageBody {
+        let originalStripped = text.stripped
+        let finalText = String(operation(originalStripped)(count)).stripped
+        let finalSubrange = (text as NSString).range(of: finalText)
+        guard finalSubrange.location != NSNotFound, finalSubrange.length > 0 else {
+            return .empty
+        }
+        let finalStyles: [NSRangedValue<Style>] = styles.compactMap { style in
+            guard
+                let intersection = style.range.intersection(finalSubrange),
+                intersection.location != NSNotFound,
+                intersection.length > 0
+            else {
+                return nil
+            }
+            return .init(
+                style.value,
+                range: NSRange(
+                    location: intersection.location - finalSubrange.location,
+                    length: intersection.length
+                )
+            )
+        }
+        return .init(text: finalText, styles: finalStyles)
+    }
+
+    public override func isEqual(_ object: Any?) -> Bool {
+        guard let rhs = object as? StyleOnlyMessageBody else {
+            return false
+        }
+        guard text == rhs.text else {
+            return false
+        }
+        guard styles.count == rhs.styles.count else {
+            return false
+        }
+        for i in 0..<styles.count {
+            guard styles[i] == rhs.styles[i] else {
+                return false
+            }
+        }
+        return true
+    }
+}
diff --git a/SignalServiceKit/src/Messages/Interactions/TSOutgoingMessage.m b/SignalServiceKit/src/Messages/Interactions/TSOutgoingMessage.m
index b317f4d35d1..59dc962d919 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSOutgoingMessage.m
+++ b/SignalServiceKit/src/Messages/Interactions/TSOutgoingMessage.m
@@ -1052,8 +1052,8 @@ - (nullable SSKProtoDataMessageBuilder *)dataMessageBuilderWithThread:(TSThread
         [builder setBody:truncatedBody];
     }
 
-    NSArray<SSKProtoBodyRange *> *bodyRanges = [self bodyRangeProtosWithBodyText:self.body
-                                                                   andBodyRanges:self.bodyRanges];
+    NSArray<SSKProtoBodyRange *> *bodyRanges =
+        [self.bodyRanges toProtoBodyRangesWithBodyLength:(NSInteger)self.body.length];
     if (bodyRanges.count > 0) {
         [builder setBodyRanges:bodyRanges];
 
@@ -1356,40 +1356,6 @@ - (OutgoingGroupProtoResult)addGroupsV2ToDataMessageBuilder:(SSKProtoDataMessage
     return OutgoingGroupProtoResult_AddedWithoutGroupAvatar;
 }
 
-- (NSArray<SSKProtoBodyRange *> *)bodyRangeProtosWithBodyText:(NSString *)bodyText
-                                                andBodyRanges:(nullable MessageBodyRanges *)bodyRanges
-{
-    if (bodyText.length == 0 || bodyRanges == nil) {
-        return @[];
-    }
-
-    NSMutableArray<SSKProtoBodyRange *> *bodyRangeProtos = [NSMutableArray new];
-    for (NSValue *rangeValue in bodyRanges.mentions) {
-        NSRange range = [rangeValue rangeValue];
-        NSUUID *uuid = bodyRanges.mentions[rangeValue];
-
-        if (range.location + range.length > bodyText.length) {
-            OWSFailDebug(@"Skipping invalid range in body ranges.");
-            continue;
-        }
-
-        SSKProtoBodyRangeBuilder *bodyRangeBuilder = [SSKProtoBodyRange builder];
-        [bodyRangeBuilder setStart:(uint32_t)range.location];
-        [bodyRangeBuilder setLength:(uint32_t)range.length];
-        [bodyRangeBuilder setMentionUuid:uuid.UUIDString];
-
-        NSError *error;
-        SSKProtoBodyRange *_Nullable bodyRange = [bodyRangeBuilder buildAndReturnError:&error];
-        if (!bodyRange || error) {
-            OWSFailDebug(@"could not build protobuf: %@", error);
-            return nil;
-        }
-
-        [bodyRangeProtos addObject:bodyRange];
-    }
-    return [bodyRangeProtos copy];
-}
-
 - (nullable SSKProtoDataMessageQuoteBuilder *)quotedMessageBuilderWithTransaction:(SDSAnyReadTransaction *)transaction
 {
     if (!self.quotedMessage) {
@@ -1414,8 +1380,8 @@ - (nullable SSKProtoDataMessageQuoteBuilder *)quotedMessageBuilderWithTransactio
         hasQuotedText = YES;
         [quoteBuilder setText:quotedMessage.body];
 
-        NSArray<SSKProtoBodyRange *> *bodyRanges = [self bodyRangeProtosWithBodyText:self.quotedMessage.body
-                                                                       andBodyRanges:self.quotedMessage.bodyRanges];
+        NSArray<SSKProtoBodyRange *> *bodyRanges =
+            [self.bodyRanges toProtoBodyRangesWithBodyLength:(NSInteger)self.quotedMessage.body.length];
         if (bodyRanges.count > 0) {
             [quoteBuilder setBodyRanges:bodyRanges];
         }
diff --git a/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift b/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift
index 7b325ad16e2..0380b5cc5bc 100644
--- a/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift
+++ b/SignalServiceKit/src/Messages/Stories/OutgoingStoryMessage.swift
@@ -182,14 +182,18 @@ public class OutgoingStoryMessage: TSOutgoingMessage {
         }
 
         switch storyMessage.attachment {
-        case .file(let attachmentId):
-            guard let attachmentProto = TSAttachmentStream.buildProto(forAttachmentId: attachmentId, transaction: transaction) else {
+        case .file(let file):
+            guard let attachmentProto = TSAttachmentStream.buildProto(forAttachmentId: file.attachmentId, transaction: transaction) else {
                 owsFailDebug("Missing attachment for outgoing story message")
                 return nil
             }
             builder.setFileAttachment(attachmentProto)
+            builder.setBodyRanges(file.captionProtoBodyRanges())
         case .text(let attachment):
-            guard let attachmentProto = try? attachment.buildProto(transaction: transaction) else {
+            guard let attachmentProto = try? attachment.buildProto(
+                bodyRangeHandler: builder.setBodyRanges(_:),
+                transaction: transaction
+            ) else {
                 owsFailDebug("Missing attachment for outgoing story message")
                 return nil
             }
diff --git a/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift b/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift
index 7135127b7e5..7cf34a76238 100644
--- a/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift
+++ b/SignalServiceKit/src/Messages/Stories/OutgoingStorySentMessageTranscript.swift
@@ -103,14 +103,18 @@ public class OutgoingStorySentMessageTranscript: OWSOutgoingSyncMessage {
         let builder = SSKProtoStoryMessage.builder()
 
         switch storyMessage.attachment {
-        case .file(let attachmentId):
-            guard let attachmentProto = TSAttachmentStream.buildProto(forAttachmentId: attachmentId, transaction: transaction) else {
+        case .file(let file):
+            guard let attachmentProto = TSAttachmentStream.buildProto(forAttachmentId: file.attachmentId, transaction: transaction) else {
                 owsFailDebug("Missing attachment for outgoing story message")
                 return nil
             }
             builder.setFileAttachment(attachmentProto)
+            builder.setBodyRanges(file.captionProtoBodyRanges())
         case .text(let attachment):
-            guard let attachmentProto = try? attachment.buildProto(transaction: transaction) else {
+            guard let attachmentProto = try? attachment.buildProto(
+                bodyRangeHandler: builder.setBodyRanges(_:),
+                transaction: transaction
+            ) else {
                 owsFailDebug("Missing attachment for outgoing story message")
                 return nil
             }
diff --git a/SignalServiceKit/src/Messages/Stories/StoryManager.swift b/SignalServiceKit/src/Messages/Stories/StoryManager.swift
index 6cfae98ce6b..0be024325da 100644
--- a/SignalServiceKit/src/Messages/Stories/StoryManager.swift
+++ b/SignalServiceKit/src/Messages/Stories/StoryManager.swift
@@ -208,14 +208,14 @@ public class StoryManager: NSObject {
     /// * The context has been recently interacted with (sent message to group, 1:1, viewed story, etc), is associated with a pinned thread, or has been recently viewed
     /// * We have not already exceeded the limit for how many unviewed stories we should download for this context
     private class func startAutomaticDownloadIfNecessary(for message: StoryMessage, transaction: SDSAnyWriteTransaction) {
-        guard case .file(let attachmentId) = message.attachment else {
+        guard case .file(let file) = message.attachment else {
             // We always auto-download non-file story attachments, this will generally only be link preview thumbnails.
             Logger.info("Automatically enqueueing download of non-file based story with timestamp \(message.timestamp)")
             attachmentDownloads.enqueueDownloadOfAttachmentsForNewStoryMessage(message, transaction: transaction)
             return
         }
 
-        guard let attachmentPointer = TSAttachmentPointer.anyFetchAttachmentPointer(uniqueId: attachmentId, transaction: transaction) else {
+        guard let attachmentPointer = TSAttachmentPointer.anyFetchAttachmentPointer(uniqueId: file.attachmentId, transaction: transaction) else {
             // Already downloaded, nothing to do.
             return
         }
@@ -226,9 +226,9 @@ public class StoryManager: NSObject {
             switch otherMessage.attachment {
             case .text:
                 unviewedDownloadedStoriesForContext += 1
-            case .file(let attachmentId):
-                guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) else {
-                    owsFailDebug("Missing attachment for attachmentId \(attachmentId)")
+            case .file(let file):
+                guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: transaction) else {
+                    owsFailDebug("Missing attachment for attachmentId \(file.attachmentId)")
                     return
                 }
                 if let pointer = attachment as? TSAttachmentPointer, [.downloading, .enqueued].contains(pointer.state) {
diff --git a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
index 6a835b36bae..8e55eb1f920 100644
--- a/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
+++ b/SignalServiceKit/src/Messages/Stories/StoryMessage.swift
@@ -44,7 +44,10 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
     public let direction: Direction
 
     public private(set) var manifest: StoryManifest
-    public let attachment: StoryMessageAttachment
+    private let _attachment: SerializedStoryMessageAttachment
+    public var attachment: StoryMessageAttachment {
+        return _attachment.asPublicAttachment
+    }
 
     public var sendingState: TSOutgoingMessageState {
         switch manifest {
@@ -121,8 +124,8 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
     @objc
     public var allAttachmentIds: [String] {
         switch attachment {
-        case .file(let attachmentId):
-            return [attachmentId]
+        case .file(let file):
+            return [file.attachmentId]
         case .text(let attachment):
             if let preview = attachment.preview, let imageAttachmentId = preview.imageAttachmentId {
                 return [imageAttachmentId]
@@ -157,7 +160,7 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
             self.direction = .outgoing
         }
         self.manifest = manifest
-        self.attachment = attachment
+        self._attachment = attachment.asSerializable
         self.replyCount = replyCount
     }
 
@@ -202,9 +205,16 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
                 throw OWSAssertionError("Invalid file attachment for StoryMessage.")
             }
             attachmentPointer.anyInsert(transaction: transaction)
-            attachment = .file(attachmentId: attachmentPointer.uniqueId)
+            attachment = .file(StoryMessageFileAttachment(
+                attachmentId: attachmentPointer.uniqueId,
+                storyBodyRangeProtos: storyMessage.bodyRanges
+            ))
         } else if let textAttachmentProto = storyMessage.textAttachment {
-            attachment = .text(attachment: try TextAttachment(from: textAttachmentProto, transaction: transaction))
+            attachment = .text(try TextAttachment(
+                from: textAttachmentProto,
+                bodyRanges: storyMessage.bodyRanges,
+                transaction: transaction
+            ))
         } else {
             throw OWSAssertionError("Missing attachment for StoryMessage.")
         }
@@ -275,9 +285,16 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
                 throw OWSAssertionError("Invalid file attachment for StoryMessage.")
             }
             attachmentPointer.anyInsert(transaction: transaction)
-            attachment = .file(attachmentId: attachmentPointer.uniqueId)
+            attachment = .file(StoryMessageFileAttachment(
+                attachmentId: attachmentPointer.uniqueId,
+                storyBodyRangeProtos: storyMessage.bodyRanges
+            ))
         } else if let textAttachmentProto = storyMessage.textAttachment {
-            attachment = .text(attachment: try TextAttachment(from: textAttachmentProto, transaction: transaction))
+            attachment = .text(try TextAttachment(
+                from: textAttachmentProto,
+                bodyRanges: storyMessage.bodyRanges,
+                transaction: transaction
+            ))
         } else {
             throw OWSAssertionError("Missing attachment for StoryMessage.")
         }
@@ -337,7 +354,10 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
         )
 
         attachment.anyInsert(transaction: transaction)
-        let attachment: StoryMessageAttachment = .file(attachmentId: attachment.uniqueId)
+        let attachment: StoryMessageAttachment = .file(StoryMessageFileAttachment(
+            attachmentId: attachment.uniqueId,
+            captionStyles: [] /* If someday a system story caption has styles, they'd go here. */
+        ))
 
         let record = StoryMessage(
             // NOTE: As of now these only get created for the onboarding story, and that happens
@@ -617,13 +637,21 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
     }
 
     public func downloadIfNecessary(transaction: SDSAnyWriteTransaction) {
-        guard
-            case .file(let attachmentId) = attachment,
-            let pointer = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) as? TSAttachmentPointer,
-            ![.enqueued, .downloading].contains(pointer.state)
-        else { return }
-
-        attachmentDownloads.enqueueDownloadOfAttachmentsForNewStoryMessage(self, transaction: transaction)
+        switch attachment {
+        case .file(let file):
+            guard
+                let pointer = TSAttachment.anyFetch(
+                    uniqueId: file.attachmentId,
+                    transaction: transaction
+                ) as? TSAttachmentPointer,
+                ![.enqueued, .downloading].contains(pointer.state)
+            else {
+                return
+            }
+            attachmentDownloads.enqueueDownloadOfAttachmentsForNewStoryMessage(self, transaction: transaction)
+        case .text:
+            return
+        }
     }
 
     public func remotelyDeleteForAllRecipients(transaction: SDSAnyWriteTransaction) {
@@ -796,7 +824,7 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
         groupId = try container.decodeIfPresent(Data.self, forKey: .groupId)
         direction = try container.decode(Direction.self, forKey: .direction)
         manifest = try container.decode(StoryManifest.self, forKey: .manifest)
-        attachment = try container.decode(StoryMessageAttachment.self, forKey: .attachment)
+        _attachment = try container.decode(SerializedStoryMessageAttachment.self, forKey: .attachment)
         replyCount = try container.decode(UInt64.self, forKey: .replyCount)
     }
 
@@ -811,7 +839,7 @@ public final class StoryMessage: NSObject, SDSCodableModel, Decodable {
         if let groupId = groupId { try container.encode(groupId, forKey: .groupId) }
         try container.encode(direction, forKey: .direction)
         try container.encode(manifest, forKey: .manifest)
-        try container.encode(attachment, forKey: .attachment)
+        try container.encode(_attachment, forKey: .attachment)
         try container.encode(replyCount, forKey: .replyCount)
     }
 }
@@ -895,11 +923,6 @@ extension StoryRecipientState {
 
 extension OWSOutgoingMessageRecipientState: Codable {}
 
-public enum StoryMessageAttachment: Codable {
-    case file(attachmentId: String)
-    case text(attachment: TextAttachment)
-}
-
 extension SignalServiceAddress {
 
     public var isSystemStoryAddress: Bool {
diff --git a/SignalServiceKit/src/Messages/Stories/StoryMessageAttachment.swift b/SignalServiceKit/src/Messages/Stories/StoryMessageAttachment.swift
new file mode 100644
index 00000000000..f27708685dc
--- /dev/null
+++ b/SignalServiceKit/src/Messages/Stories/StoryMessageAttachment.swift
@@ -0,0 +1,71 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+
+public struct StoryMessageFileAttachment: Codable {
+    public let attachmentId: String
+    public let captionStyles: [NSRangedValue<MessageBodyRanges.Style>]
+
+    public init(
+        attachmentId: String,
+        storyBodyRangeProtos: [SSKProtoBodyRange]
+    ) {
+        let bodyRanges = MessageBodyRanges(protos: storyBodyRangeProtos)
+        // Drop mentions, don't even hydrate them.
+        self.init(attachmentId: attachmentId, captionStyles: bodyRanges.styles)
+    }
+
+    public init(attachmentId: String, captionStyles: [NSRangedValue<MessageBodyRanges.Style>]) {
+        self.attachmentId = attachmentId
+        self.captionStyles = captionStyles
+    }
+
+    public func captionProtoBodyRanges() -> [SSKProtoBodyRange] {
+        return MessageBodyRanges(mentions: [:], styles: captionStyles).toProtoBodyRanges()
+    }
+}
+
+/// Exists for backwards compatibility, and used whenever we want to read/write
+/// a StoryMessageAttachment to disk.
+/// Codable conformance for enums with associated values is messy and error prone;
+/// this allows us to take advantage of automatic synthesis by preserving cases
+/// exactly as they were defined, and only every adding new cases.
+internal enum SerializedStoryMessageAttachment: Codable {
+    // Original case. NEVER CHANGE THIS.
+    case file(attachmentId: String)
+    // Original case. NEVER CHANGE THIS.
+    case text(attachment: TextAttachment)
+
+    // V2 case. Same as file, but with added body ranges.
+    // original file case assumed to have empty body ranges
+    // but is otherwise perfectly convertible once decoded.
+    case fileV2(StoryMessageFileAttachment)
+
+    var asPublicAttachment: StoryMessageAttachment {
+        switch self {
+        case .file(let attachmentId):
+            return .file(StoryMessageFileAttachment(attachmentId: attachmentId, captionStyles: []))
+        case .fileV2(let storyMessageFileAttachment):
+            return .file(storyMessageFileAttachment)
+        case .text(let attachment):
+            return .text(attachment)
+        }
+    }
+}
+
+public enum StoryMessageAttachment {
+    case file(StoryMessageFileAttachment)
+    case text(TextAttachment)
+
+    internal var asSerializable: SerializedStoryMessageAttachment {
+        switch self {
+        case .file(let storyMessageFileAttachment):
+            return .fileV2(storyMessageFileAttachment)
+        case .text(let textAttachment):
+            return .text(attachment: textAttachment)
+        }
+    }
+}
diff --git a/SignalServiceKit/src/Protos/Generated/SSKProto.swift b/SignalServiceKit/src/Protos/Generated/SSKProto.swift
index 768d01e6fa2..edd73ef1733 100644
--- a/SignalServiceKit/src/Protos/Generated/SSKProto.swift
+++ b/SignalServiceKit/src/Protos/Generated/SSKProto.swift
@@ -716,6 +716,9 @@ public class SSKProtoStoryMessage: NSObject, Codable, NSSecureCoding {
     @objc
     public let textAttachment: SSKProtoTextAttachment?
 
+    @objc
+    public let bodyRanges: [SSKProtoBodyRange]
+
     @objc
     public var profileKey: Data? {
         guard hasProfileKey else {
@@ -748,11 +751,13 @@ public class SSKProtoStoryMessage: NSObject, Codable, NSSecureCoding {
     private init(proto: SignalServiceProtos_StoryMessage,
                  group: SSKProtoGroupContextV2?,
                  fileAttachment: SSKProtoAttachmentPointer?,
-                 textAttachment: SSKProtoTextAttachment?) {
+                 textAttachment: SSKProtoTextAttachment?,
+                 bodyRanges: [SSKProtoBodyRange]) {
         self.proto = proto
         self.group = group
         self.fileAttachment = fileAttachment
         self.textAttachment = textAttachment
+        self.bodyRanges = bodyRanges
     }
 
     @objc
@@ -782,10 +787,14 @@ public class SSKProtoStoryMessage: NSObject, Codable, NSSecureCoding {
             textAttachment = try SSKProtoTextAttachment(proto.textAttachment)
         }
 
+        var bodyRanges: [SSKProtoBodyRange] = []
+        bodyRanges = proto.bodyRanges.map { SSKProtoBodyRange($0) }
+
         self.init(proto: proto,
                   group: group,
                   fileAttachment: fileAttachment,
-                  textAttachment: textAttachment)
+                  textAttachment: textAttachment,
+                  bodyRanges: bodyRanges)
     }
 
     public required convenience init(from decoder: Swift.Decoder) throws {
@@ -849,6 +858,7 @@ extension SSKProtoStoryMessage {
         if hasAllowsReplies {
             builder.setAllowsReplies(allowsReplies)
         }
+        builder.setBodyRanges(bodyRanges)
         if let _value = unknownFields {
             builder.setUnknownFields(_value)
         }
@@ -913,6 +923,16 @@ public class SSKProtoStoryMessageBuilder: NSObject {
         proto.allowsReplies = valueParam
     }
 
+    @objc
+    public func addBodyRanges(_ valueParam: SSKProtoBodyRange) {
+        proto.bodyRanges.append(valueParam.proto)
+    }
+
+    @objc
+    public func setBodyRanges(_ wrappedItems: [SSKProtoBodyRange]) {
+        proto.bodyRanges = wrappedItems.map { $0.proto }
+    }
+
     public func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
         proto.unknownFields = unknownFields
     }
diff --git a/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift b/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
index 2bdd08bf456..b20f451e9ee 100644
--- a/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
+++ b/SignalServiceKit/src/Protos/Generated/SignalService.pb.swift
@@ -339,6 +339,11 @@ struct SignalServiceProtos_StoryMessage {
   /// Clears the value of `allowsReplies`. Subsequent reads from it will return its default value.
   mutating func clearAllowsReplies() {_uniqueStorage()._allowsReplies = nil}
 
+  var bodyRanges: [SignalServiceProtos_BodyRange] {
+    get {return _storage._bodyRanges}
+    set {_uniqueStorage()._bodyRanges = newValue}
+  }
+
   var unknownFields = SwiftProtobuf.UnknownStorage()
 
   init() {}
@@ -5183,6 +5188,7 @@ extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf
     3: .same(proto: "fileAttachment"),
     4: .same(proto: "textAttachment"),
     5: .same(proto: "allowsReplies"),
+    6: .same(proto: "bodyRanges"),
   ]
 
   fileprivate class _StorageClass {
@@ -5191,6 +5197,7 @@ extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf
     var _fileAttachment: SignalServiceProtos_AttachmentPointer? = nil
     var _textAttachment: SignalServiceProtos_TextAttachment? = nil
     var _allowsReplies: Bool? = nil
+    var _bodyRanges: [SignalServiceProtos_BodyRange] = []
 
     static let defaultInstance = _StorageClass()
 
@@ -5202,6 +5209,7 @@ extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf
       _fileAttachment = source._fileAttachment
       _textAttachment = source._textAttachment
       _allowsReplies = source._allowsReplies
+      _bodyRanges = source._bodyRanges
     }
   }
 
@@ -5225,6 +5233,7 @@ extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf
         case 3: try { try decoder.decodeSingularMessageField(value: &_storage._fileAttachment) }()
         case 4: try { try decoder.decodeSingularMessageField(value: &_storage._textAttachment) }()
         case 5: try { try decoder.decodeSingularBoolField(value: &_storage._allowsReplies) }()
+        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._bodyRanges) }()
         default: break
         }
       }
@@ -5252,6 +5261,9 @@ extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf
       try { if let v = _storage._allowsReplies {
         try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
       } }()
+      if !_storage._bodyRanges.isEmpty {
+        try visitor.visitRepeatedMessageField(value: _storage._bodyRanges, fieldNumber: 6)
+      }
     }
     try unknownFields.traverse(visitor: &visitor)
   }
@@ -5266,6 +5278,7 @@ extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf
         if _storage._fileAttachment != rhs_storage._fileAttachment {return false}
         if _storage._textAttachment != rhs_storage._textAttachment {return false}
         if _storage._allowsReplies != rhs_storage._allowsReplies {return false}
+        if _storage._bodyRanges != rhs_storage._bodyRanges {return false}
         return true
       }
       if !storagesAreEqual {return false}
diff --git a/SignalServiceKit/tests/Messages/BodyRanges/StyleOnlyMessageBodyTests.swift b/SignalServiceKit/tests/Messages/BodyRanges/StyleOnlyMessageBodyTests.swift
new file mode 100644
index 00000000000..7e126e68535
--- /dev/null
+++ b/SignalServiceKit/tests/Messages/BodyRanges/StyleOnlyMessageBodyTests.swift
@@ -0,0 +1,281 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+import Foundation
+import XCTest
+@testable import SignalServiceKit
+
+public class StyleOnlyMessageBodyTests: XCTestCase {
+
+    // MARK: - dropFirst
+
+    public func testStripAndDropFirst_droppedStyle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            ).stripAndDropFirst(6),
+            StyleOnlyMessageBody(
+                text: "World",
+                styles: []
+            )
+        )
+    }
+
+    public func testStripAndDropFirst_cutOffStyle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 11)
+                    )
+                ]
+            ).stripAndDropFirst(6),
+            StyleOnlyMessageBody(
+                text: "World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropFirst_includedStyle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 6, length: 5)
+                    )
+                ]
+            ).stripAndDropFirst(6),
+            StyleOnlyMessageBody(
+                text: "World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropFirst_stripMiddle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 11)
+                    )
+                ]
+            ).stripAndDropFirst(5),
+            StyleOnlyMessageBody(
+                text: "World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropFirst_stripLeading() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: " Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 1, length: 11)
+                    )
+                ]
+            ).stripAndDropFirst(5),
+            StyleOnlyMessageBody(
+                text: "World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropFirst_stripLeadingAndTrailing() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: " Hello World ",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 1, length: 11)
+                    )
+                ]
+            ).stripAndDropFirst(5),
+            StyleOnlyMessageBody(
+                text: "World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    // MARK: - dropLast
+
+    public func testStripAndDropLast_droppedStyle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 6, length: 5)
+                    )
+                ]
+            ).stripAndDropLast(6),
+            StyleOnlyMessageBody(
+                text: "Hello",
+                styles: []
+            )
+        )
+    }
+
+    public func testStripAndDropLast_cutOffStyle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 11)
+                    )
+                ]
+            ).stripAndDropLast(6),
+            StyleOnlyMessageBody(
+                text: "Hello",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropLast_includedStyle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            ).stripAndDropLast(6),
+            StyleOnlyMessageBody(
+                text: "Hello",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropLast_stripMiddle() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: "Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 11)
+                    )
+                ]
+            ).stripAndDropLast(5),
+            StyleOnlyMessageBody(
+                text: "Hello",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropLast_stripLeading() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: " Hello World",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 1, length: 11)
+                    )
+                ]
+            ).stripAndDropLast(5),
+            StyleOnlyMessageBody(
+                text: "Hello",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+
+    public func testStripAndDropLast_stripLeadingAndTrailing() {
+        XCTAssertEqual(
+            StyleOnlyMessageBody(
+                text: " Hello World ",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 1, length: 11)
+                    )
+                ]
+            ).stripAndDropLast(5),
+            StyleOnlyMessageBody(
+                text: "Hello",
+                styles: [
+                    .init(
+                        .bold,
+                        range: NSRange(location: 0, length: 5)
+                    )
+                ]
+            )
+        )
+    }
+}
diff --git a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift
index 787098f932e..1df5a801bec 100644
--- a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
@@ -18,10 +18,10 @@ extension OutgoingStoryMessage {
             case .media(let attachments):
                 for identifiedAttachment in attachments {
                     let attachment = identifiedAttachment.value
-                    // TODO[TextFormatting]: preserve styles on the story message proto but hydrate mentions
-                    attachment.captionText = state.approvalMessageBody?
+                    let captionBody = state.approvalMessageBody?
                         .hydrating(mentionHydrator: ContactsMentionHydrator.mentionHydrator(transaction: transaction.asV2Read))
-                        .asPlaintext()
+                        .asStyleOnlyBody()
+                    attachment.captionText = captionBody?.text
                     let attachmentStream = try attachment
                         .buildOutgoingAttachmentInfo()
                         .asStreamConsumingDataSource(withIsVoiceMessage: attachment.isVoiceMessage)
@@ -40,7 +40,10 @@ extension OutgoingStoryMessage {
                         )
                     } else {
                         message = try OutgoingStoryMessage.createUnsentMessage(
-                            attachment: .file(attachmentId: attachmentStream.uniqueId),
+                            attachment: .file(StoryMessageFileAttachment(
+                                attachmentId: attachmentStream.uniqueId,
+                                captionStyles: captionBody?.styles ?? []
+                            )),
                             thread: destination.thread,
                             transaction: transaction
                         )
@@ -73,7 +76,7 @@ extension OutgoingStoryMessage {
                     )
                 } else {
                     message = try OutgoingStoryMessage.createUnsentMessage(
-                        attachment: .text(attachment: finalTextAttachment),
+                        attachment: .text(finalTextAttachment),
                         thread: destination.thread,
                         transaction: transaction
                     )
diff --git a/SignalUI/Utils/StoryMessage+SignalUI.swift b/SignalUI/Utils/StoryMessage+SignalUI.swift
index dce569b6876..5d312660438 100644
--- a/SignalUI/Utils/StoryMessage+SignalUI.swift
+++ b/SignalUI/Utils/StoryMessage+SignalUI.swift
@@ -8,43 +8,69 @@ import Foundation
 extension StoryMessage {
 
     @objc
-    func quotedBody(transaction: SDSAnyReadTransaction) -> String? {
+    func quotedBody(transaction: SDSAnyReadTransaction) -> MessageBody? {
         switch attachment {
-        case .file(let attachmentId):
-            guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) else {
+        case .file(let file):
+            guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: transaction) else {
                 owsFailDebug("Missing attachment for story message \(timestamp)")
                 return nil
             }
-            return attachment.caption
+            guard let caption = attachment.caption else {
+                return nil
+            }
+            // Note: stripping any over-extended styles to the caption
+            // length will happen at hydration time, which is required
+            // to turn a MessageBody into something we can display.
+            return MessageBody(
+                text: caption,
+                ranges: MessageBodyRanges(mentions: [:], styles: file.captionStyles)
+            )
         case .text(let attachment):
-            return attachment.text ?? attachment.preview?.urlString
+            switch attachment.textContent {
+            case .styledRanges(let body):
+                return body.asMessageBody()
+            case .styled(let body, _):
+                return MessageBody(text: body, ranges: .empty)
+            case .empty:
+                guard let urlString = attachment.preview?.urlString else {
+                    return nil
+                }
+                return MessageBody(text: urlString, ranges: .empty)
+            }
         }
     }
 
     @objc
     func quotedAttachment(transaction: SDSAnyReadTransaction) -> TSAttachment? {
-        guard case .file(let attachmentId) = attachment else { return nil }
-        guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) else {
-            owsFailDebug("Missing attachment for story message \(timestamp)")
+        switch attachment {
+        case .file(let file):
+            guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: transaction) else {
+                owsFailDebug("Missing attachment for story message \(timestamp)")
+                return nil
+            }
+            return attachment
+        case .text:
             return nil
         }
-        return attachment
     }
 
     @objc
     func thumbnailImage(transaction: SDSAnyReadTransaction) -> UIImage? {
-        guard case .file(let attachmentId) = attachment else { return nil }
-
-        guard let attachment = TSAttachment.anyFetch(uniqueId: attachmentId, transaction: transaction) else {
-            owsFailDebug("Missing attachment for story message \(timestamp)")
-            return nil
-        }
-        if let stream = attachment as? TSAttachmentStream {
-            return stream.thumbnailImageSmallSync()
-        } else if let blurHash = attachment.blurHash {
-            return BlurHash.image(for: blurHash)
-        } else {
+        switch attachment {
+        case .text:
             return nil
+        case .file(let file):
+            guard let attachment = TSAttachment.anyFetch(uniqueId: file.attachmentId, transaction: transaction) else {
+                owsFailDebug("Missing attachment for story message \(timestamp)")
+                return nil
+            }
+            if let stream = attachment as? TSAttachmentStream {
+                return stream.thumbnailImageSmallSync()
+            } else if let blurHash = attachment.blurHash {
+                return BlurHash.image(for: blurHash)
+            } else {
+                return nil
+            }
         }
     }
 
diff --git a/SignalUI/Utils/StorySharing.swift b/SignalUI/Utils/StorySharing.swift
index 746ae1f6417..86985d517d1 100644
--- a/SignalUI/Utils/StorySharing.swift
+++ b/SignalUI/Utils/StorySharing.swift
@@ -47,7 +47,7 @@ public enum StorySharing: Dependencies {
         // Send the text message to any selected story recipients
         // as a text story with default styling.
         return UnsentTextAttachment(
-            text: text(for: messageBody, with: linkPreviewDraft),
+            body: text(for: messageBody, with: linkPreviewDraft),
             textStyle: .regular,
             textForegroundColor: .white,
             textBackgroundColor: nil,
@@ -56,52 +56,51 @@ public enum StorySharing: Dependencies {
         )
     }
 
-    internal static func text(for messageBody: MessageBody, with linkPreview: OWSLinkPreviewDraft?) -> String? {
-        // Turn any mentions in the message body to plaintext
-        // TODO[TextFormatting]: preserve styles on the story message proto but hydrate mentions
-        let plaintextMessageBody = databaseStorage.read {
+    internal static func text(for messageBody: MessageBody, with linkPreview: OWSLinkPreviewDraft?) -> StyleOnlyMessageBody? {
+        // Hydrate any mentions in the message body but preserve styles.
+        let hydratedBody = databaseStorage.read {
             return messageBody
                 .hydrating(
                     mentionHydrator: ContactsMentionHydrator.mentionHydrator(transaction: $0.asV2Read)
                 )
-                .asPlaintext()
+                .asStyleOnlyBody()
         }
 
-        let text: String?
-        if linkPreview != nil, let linkPreviewUrlString = linkPreview?.urlString, plaintextMessageBody.contains(linkPreviewUrlString) {
-            if plaintextMessageBody == linkPreviewUrlString {
+        let finalBody: StyleOnlyMessageBody?
+        if let linkPreviewUrlString = linkPreview?.urlString, hydratedBody.text.contains(linkPreviewUrlString) {
+            if hydratedBody.text == linkPreviewUrlString {
                 // If the only message text is the URL of the link preview, omit the message text
-                text = nil
+                finalBody = nil
             } else if
-                plaintextMessageBody.hasPrefix(linkPreviewUrlString),
+                hydratedBody.text.hasPrefix(linkPreviewUrlString),
                 CharacterSet.whitespacesAndNewlines.contains(
-                    plaintextMessageBody[plaintextMessageBody.index(
-                        plaintextMessageBody.startIndex,
+                    hydratedBody.text[hydratedBody.text.index(
+                        hydratedBody.text.startIndex,
                         offsetBy: linkPreviewUrlString.count
                     )]
                 )
             {
                 // If the URL is at the start of the message, strip it off
-                text = String(plaintextMessageBody.dropFirst(linkPreviewUrlString.count)).stripped
+                finalBody = hydratedBody.stripAndDropFirst((linkPreviewUrlString as NSString).length)
             } else if
-                plaintextMessageBody.hasSuffix(linkPreviewUrlString),
+                hydratedBody.text.hasSuffix(linkPreviewUrlString),
                 CharacterSet.whitespacesAndNewlines.contains(
-                    plaintextMessageBody[plaintextMessageBody.index(
-                        plaintextMessageBody.endIndex,
+                    hydratedBody.text[hydratedBody.text.index(
+                        hydratedBody.text.endIndex,
                         offsetBy: -(linkPreviewUrlString.count + 1)
                     )]
                 )
             {
                 // If the URL is at the end of the message, strip it off
-                text = String(plaintextMessageBody.dropLast(linkPreviewUrlString.count)).stripped
+                finalBody = hydratedBody.stripAndDropLast((linkPreviewUrlString as NSString).length)
             } else {
                 // If the URL is in the middle of the message, send the message as is
-                text = plaintextMessageBody
+                finalBody = hydratedBody
             }
         } else {
-            text = plaintextMessageBody
+            finalBody = hydratedBody
         }
-        return text
+        return finalBody
     }
 }
 
diff --git a/SignalUI/ViewModels/OWSQuotedReplyModel.m b/SignalUI/ViewModels/OWSQuotedReplyModel.m
index 36f1e1365c8..a42831aad66 100644
--- a/SignalUI/ViewModels/OWSQuotedReplyModel.m
+++ b/SignalUI/ViewModels/OWSQuotedReplyModel.m
@@ -181,10 +181,11 @@ + (nullable instancetype)quotedReplyFromStoryMessage:(StoryMessage *)storyMessag
         failedAttachmentPointer = (TSAttachmentPointer *)quotedAttachment;
     }
 
+    MessageBody *body = [storyMessage quotedBodyWithTransaction:transaction];
     return [[self alloc] initWithTimestamp:storyMessage.timestamp
                              authorAddress:storyMessage.authorAddress
-                                      body:[storyMessage quotedBodyWithTransaction:transaction]
-                                bodyRanges:MessageBodyRanges.empty
+                                      body:body.text
+                                bodyRanges:body.ranges
                                 bodySource:TSQuotedMessageContentSourceStory
                             thumbnailImage:thumbnailImage
                       thumbnailViewFactory:thumbnailImage == nil ? ^{ return [storyMessage thumbnailView]; } : nil
diff --git a/SignalUI/Views/TextAttachmentView.swift b/SignalUI/Views/TextAttachmentView.swift
index 7bba1bc987f..8e83bd34258 100644
--- a/SignalUI/Views/TextAttachmentView.swift
+++ b/SignalUI/Views/TextAttachmentView.swift
@@ -15,8 +15,7 @@ open class TextAttachmentView: UIView {
 
     convenience public init(attachment: TextAttachment) {
         self.init(
-            text: attachment.text,
-            textStyle: attachment.textStyle,
+            textContent: attachment.textContent,
             textForegroundColor: attachment.textForegroundColor,
             textBackgroundColor: attachment.textBackgroundColor,
             background: attachment.background,
@@ -26,8 +25,7 @@ open class TextAttachmentView: UIView {
 
     convenience public init(attachment: UnsentTextAttachment) {
         self.init(
-            text: attachment.text,
-            textStyle: attachment.textStyle,
+            textContent: attachment.textContent,
             textForegroundColor: attachment.textForegroundColor,
             textBackgroundColor: attachment.textBackgroundColor,
             background: attachment.background,
@@ -37,16 +35,14 @@ open class TextAttachmentView: UIView {
     }
 
     public init(
-        text: String?,
-        textStyle: TextAttachment.TextStyle,
+        textContent: TextAttachment.TextContent,
         textForegroundColor: UIColor?,
         textBackgroundColor: UIColor?,
         background: TextAttachment.Background,
         linkPreview: OWSLinkPreview?,
         linkPreviewDraft: OWSLinkPreviewDraft? = nil
     ) {
-        self.text = text
-        self.textStyle = textStyle
+        self.textContent = textContent
         self.textForegroundColor = textForegroundColor ?? Theme.darkThemePrimaryColor
         self.textBackgroundColor = textBackgroundColor
         self.background = background
@@ -227,11 +223,7 @@ open class TextAttachmentView: UIView {
 
     // MARK: - Attributes
 
-    public var text: String? {
-        didSet { updateTextAttributes() }
-    }
-
-    public var textStyle: TextAttachment.TextStyle = .regular {
+    public var textContent: TextAttachment.TextContent {
         didSet { updateTextAttributes() }
     }
 
@@ -258,27 +250,53 @@ open class TextAttachmentView: UIView {
     public func updateTextAttributes() {
         defer { updateVisibilityOfComponents(animated: false) }
 
-        guard let text = text else { return }
-
-        var textLabel: UILabel
-        if let existingLabel = self.textLabel {
-            textLabel = existingLabel
-        } else {
-            textLabel = UILabel()
-            textLabel.adjustsFontSizeToFitWidth = true
-            textLabel.allowsDefaultTighteningForTruncation = true
-            textLabel.lineBreakMode = .byWordWrapping
-            textLabel.minimumScaleFactor = 0.2
-            textLabel.numberOfLines = 0
-            addSubview(textLabel)
-            self.textLabel = textLabel
+        func loadTextLabel() -> UILabel {
+            if let existingLabel = self.textLabel {
+                return existingLabel
+            } else {
+                let textLabel = UILabel()
+                textLabel.adjustsFontSizeToFitWidth = true
+                textLabel.allowsDefaultTighteningForTruncation = true
+                textLabel.lineBreakMode = .byWordWrapping
+                textLabel.minimumScaleFactor = 0.2
+                textLabel.numberOfLines = 0
+                addSubview(textLabel)
+                self.textLabel = textLabel
+                return textLabel
+            }
         }
 
-        let (fontPointSize, textAlignment) = sizeAndAlignment(forText: text)
-        textLabel.text = transformedText(text, for: textStyle)
-        textLabel.textAlignment = textAlignment
-        textLabel.font = .font(for: textStyle, withPointSize: fontPointSize)
-        textLabel.textColor = textForegroundColor
+        let textLabel: UILabel
+        switch textContent {
+        case .empty:
+            return
+        case .styled(let text, let textStyle):
+            textLabel = loadTextLabel()
+            let (fontPointSize, textAlignment) = sizeAndAlignment(forText: text)
+            textLabel.text = transformedText(text, for: textStyle)
+            textLabel.textAlignment = textAlignment
+            textLabel.font = .font(for: textStyle, withPointSize: fontPointSize)
+            textLabel.textColor = textForegroundColor
+        case .styledRanges(let body):
+            textLabel = loadTextLabel()
+            let (fontPointSize, textAlignment) = sizeAndAlignment(forText: body.text)
+            let font = UIFont.font(for: .regular, withPointSize: fontPointSize)
+
+            // TODO[TextFormatting]: allow revealing spoilers
+            let attrText = body.asAttributedStringForDisplay(
+                config: StyleDisplayConfiguration(
+                    baseFont: font,
+                    textColor: .fixed(textForegroundColor),
+                    revealAllIds: false,
+                    revealedIds: Set()
+                ),
+                isDarkThemeEnabled: Theme.isDarkThemeEnabled
+            )
+            textLabel.font = font
+            textLabel.attributedText = attrText
+            textLabel.textAlignment = textAlignment
+            textLabel.textColor = textForegroundColor
+        }
 
         if let textBackgroundColor = textBackgroundColor {
             var textBackgroundView: UIView
@@ -303,10 +321,11 @@ open class TextAttachmentView: UIView {
 
     open func updateVisibilityOfComponents(animated: Bool) {
         let isEditing = isEditing
-        if text != nil {
+        switch textContent {
+        case .styledRanges, .styled:
             textLabel?.setIsHidden(isEditing, animated: animated)
             textBackgroundView?.setIsHidden(isEditing || textBackgroundColor == nil, animated: animated)
-        } else {
+        case .empty:
             textLabel?.setIsHidden(true, animated: animated)
             textBackgroundView?.setIsHidden(true, animated: animated)
         }
@@ -365,7 +384,16 @@ open class TextAttachmentView: UIView {
     private var forceCompactLayoutForLinkPreview = false
 
     private func shouldUseCompactLayoutForLinkPreview() -> Bool {
-        if let text = text, text.count >= 50 { return true }
+        let text: String
+        switch textContent {
+        case .empty:
+            return forceCompactLayoutForLinkPreview
+        case .styledRanges(let body):
+            text = body.text
+        case .styled(let body, _):
+            text = body
+        }
+        if text.count >= 50 { return true }
         return forceCompactLayoutForLinkPreview
     }
 
