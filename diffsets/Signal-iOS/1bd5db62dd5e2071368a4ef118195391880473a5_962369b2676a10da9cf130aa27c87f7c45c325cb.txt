diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponentDelegate.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponentDelegate.swift
index 3d6b080f452..0a85476ae4e 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponentDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponentDelegate.swift
@@ -99,6 +99,11 @@ public protocol CVComponentDelegate {
 
     func cvc_didTapMention(_ mention: Mention)
 
+    func cvc_didTapShowMessageDetail(_ itemViewModel: CVItemViewModelImpl)
+
+    @objc
+    var view: UIView { get }
+
     // MARK: - Selection
 
     @objc
diff --git a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift
index 20890c7c75e..9a2100f0e05 100644
--- a/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift
+++ b/Signal/src/ViewControllers/ConversationView/CV/CVComponents/CVComponentMessage.swift
@@ -1331,21 +1331,27 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
             return panHandler
         }
 
-        let itemViewModel = CVItemViewModelImpl(renderItem: renderItem)
-        guard componentDelegate.cvc_shouldAllowReplyForItem(itemViewModel) else {
-            return nil
-        }
-        tryToUpdateSwipeToReplyReference(componentView: componentView,
-                                         renderItem: renderItem,
-                                         swipeToReplyState: swipeToReplyState)
-        guard swipeToReplyReference != nil else {
-            owsFailDebug("Missing reference[\(renderItem.interactionUniqueId)].")
-            return nil
-        }
+        if isSwipingTowardsMessageDetails(sender: sender, componentDelegate: componentDelegate) {
+            // We're swiping left, present message details
+            return CVPanHandler(delegate: componentDelegate, panType: .messageDetails, renderItem: renderItem)
+        } else {
+            // We're doing a swipe-to-reply
+            let itemViewModel = CVItemViewModelImpl(renderItem: renderItem)
+            guard componentDelegate.cvc_shouldAllowReplyForItem(itemViewModel) else {
+                return nil
+            }
+            tryToUpdateSwipeToReplyReference(componentView: componentView,
+                                             renderItem: renderItem,
+                                             swipeToReplyState: swipeToReplyState)
+            guard swipeToReplyReference != nil else {
+                owsFailDebug("Missing reference[\(renderItem.interactionUniqueId)].")
+                return nil
+            }
 
-        return CVPanHandler(delegate: componentDelegate,
-                            panType: .swipeToReply,
-                            renderItem: renderItem)
+            return CVPanHandler(delegate: componentDelegate,
+                                panType: .swipeToReply,
+                                renderItem: renderItem)
+        }
     }
 
     public override func startPanGesture(sender: UIPanGestureRecognizer,
@@ -1387,6 +1393,10 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
                                        swipeToReplyState: swipeToReplyState,
                                        hasFinished: false)
             tryToApplySwipeToReply(componentView: componentView, isAnimated: false)
+        case .messageDetails:
+            panHandler.percentDrivenTransition = UIPercentDrivenInteractiveTransition()
+            let itemViewModel = CVItemViewModelImpl(renderItem: renderItem)
+            componentDelegate.cvc_didTapShowMessageDetail(itemViewModel)
         }
     }
 
@@ -1446,6 +1456,12 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
                                   swipeToReplyState: swipeToReplyState,
                                   isAnimated: true)
             }
+        case .messageDetails:
+            updateMessageDetailsPresentationProgress(
+                sender: sender,
+                panHandler: panHandler,
+                componentDelegate: componentDelegate
+            )
         }
     }
 
@@ -1540,22 +1556,22 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
 
         let swipeToReplyIconView = componentView.swipeToReplyIconView
 
-        let isReplyActive = xOffset >= swipeToReplyThreshold
+        let isActive = xOffset >= swipeToReplyThreshold
 
         // If we're transitioning to the active state, play haptic feedback.
-        if isReplyActive, !panHandler.isReplyActive {
+        if isActive, !panHandler.isActive {
             ImpactHapticFeedback.impactOccured(style: .light)
         }
 
         // Update the reply image styling to reflect active state
         let isStarting = sender.state == .began
-        let didChange = isReplyActive != panHandler.isReplyActive
+        let didChange = isActive != panHandler.isActive
         let shouldUpdateViews = isStarting || didChange
         if shouldUpdateViews {
             let shouldAnimate = didChange
             let transform: CGAffineTransform
             let tintColor: UIColor
-            if isReplyActive {
+            if isActive {
                 transform = CGAffineTransform(scaleX: 1.16, y: 1.16)
                 tintColor = isDarkThemeEnabled ? .ows_gray25 : .ows_gray75
             } else {
@@ -1579,9 +1595,9 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
             }
         }
 
-        panHandler.isReplyActive = isReplyActive
+        panHandler.isActive = isActive
 
-        if panHandler.isReplyActive && hasFinished {
+        if isActive && hasFinished {
             let itemViewModel = CVItemViewModelImpl(renderItem: renderItem)
             componentDelegate.cvc_didTapReplyToItem(itemViewModel)
         }
@@ -1684,6 +1700,70 @@ public class CVComponentMessage: CVComponentBase, CVRootComponent {
 
         self.swipeToReplyProgress = nil
     }
+
+    func isSwipingTowardsMessageDetails(sender: UIPanGestureRecognizer, componentDelegate: CVComponentDelegate) -> Bool {
+        if CurrentAppContext().isRTL {
+            return sender.velocity(in: componentDelegate.view).x > 0
+        } else {
+            return sender.velocity(in: componentDelegate.view).x < 0
+        }
+    }
+
+    func updateMessageDetailsPresentationProgress(
+        sender: UIPanGestureRecognizer,
+        panHandler: CVPanHandler,
+        componentDelegate: CVComponentDelegate
+    ) {
+        guard let percentDrivenTransition = panHandler.percentDrivenTransition else {
+            return owsFailDebug("Missing transition.")
+        }
+
+        let hasEnded = [.ended, .cancelled, .failed].contains(sender.state)
+        let percentThreshold: CGFloat = 0.2
+        let velocityThreshold: CGFloat = 500
+
+        let isSwipingTowardsMessagesDetails = self.isSwipingTowardsMessageDetails(
+            sender: sender,
+            componentDelegate: componentDelegate
+        )
+
+        let translationX = abs(sender.translation(in: componentDelegate.view).x)
+        let percent = translationX / componentDelegate.view.width
+        percentDrivenTransition.update(percent)
+
+        var isActive = percent >= percentThreshold && isSwipingTowardsMessagesDetails
+
+        if hasEnded {
+            // If the pan has ended, and we're moving quickly
+            // in the correct direction, assume we are active
+            // regardless of the percent threshold.
+
+            let velocityX = sender.velocity(in: componentDelegate.view).x
+            let isMovingQuicklyTowardsMessageDetails: Bool
+            if CurrentAppContext().isRTL {
+                isMovingQuicklyTowardsMessageDetails = velocityX >= velocityThreshold
+            } else {
+                isMovingQuicklyTowardsMessageDetails = velocityX <= -velocityThreshold
+            }
+
+            isActive = isActive || isMovingQuicklyTowardsMessageDetails
+        }
+
+        // If we're transitioning to the active state, play haptic feedback.
+        if isActive, !panHandler.isActive {
+            ImpactHapticFeedback.impactOccured(style: .light)
+        }
+
+        panHandler.isActive = isActive
+
+        if hasEnded {
+            if isActive {
+                percentDrivenTransition.finish()
+            } else {
+                percentDrivenTransition.cancel()
+            }
+        }
+    }
 }
 
 // MARK: -
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift
index d6c6b8bb79d..d6bd0ae3d60 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+GestureRecognizers.swift
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
 //
 
 import Foundation
@@ -176,6 +176,7 @@ extension ConversationViewController: UIGestureRecognizerDelegate {
                 return
             }
             self.panHandler = panHandler
+            startPanHandler(sender: sender)
         case .changed:
             updatePanGesture()
         case .ended, .failed, .cancelled, .possible:
@@ -196,11 +197,14 @@ extension ConversationViewController: UIGestureRecognizerDelegate {
                                                    swipeToReplyState: swipeToReplyState) else {
             return nil
         }
-        panHandler.startGesture(sender: sender,
-                                cell: cell,
-                                swipeToReplyState: swipeToReplyState)
         return panHandler
     }
+
+    private func startPanHandler(sender: UIPanGestureRecognizer) {
+        guard let panHandler = panHandler else { return }
+        guard let cell = findCell(forGesture: sender) else { return }
+        panHandler.startGesture(sender: sender, cell: cell, swipeToReplyState: viewState.swipeToReplyState)
+    }
 }
 
 // MARK: -
@@ -291,6 +295,7 @@ public class CVPanHandler {
     public enum PanType {
         case swipeToReply
         case scrubAudio
+        case messageDetails
     }
     public let panType: PanType
 
@@ -300,7 +305,9 @@ public class CVPanHandler {
     public var interactionId: String { renderItem.interactionUniqueId }
 
     // If the gesture ended now, would we perform a reply?
-    public var isReplyActive = false
+    public var isActive = false
+
+    public var percentDrivenTransition: UIPercentDrivenInteractiveTransition?
 
     required init(delegate: CVComponentDelegate, panType: PanType, renderItem: CVRenderItem) {
         self.delegate = delegate
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift
index f095ec8d84b..67948650eab 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController+MessageActionsDelegate.swift
@@ -7,6 +7,7 @@ extension ConversationViewController: MessageActionsDelegate {
         showDetailView(itemViewModel)
     }
 
+    @objc
     func showDetailView(_ itemViewModel: CVItemViewModelImpl) {
         AssertIsOnMainThread()
 
@@ -15,10 +16,13 @@ extension ConversationViewController: MessageActionsDelegate {
             return
         }
 
-        let detailVC = MessageDetailViewController(message: message,
-                                                   thread: thread,
-                                                   mode: .focusOnMetadata)
+        let detailVC = MessageDetailViewController(
+            message: message,
+            thread: thread,
+            percentDrivenTransition: viewState.panHandler?.percentDrivenTransition
+        )
         detailVC.delegate = self
+        conversationSplitViewController?.navigationTransitionDelegate = detailVC
         navigationController?.pushViewController(detailVC, animated: true)
     }
 
diff --git a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
index 064afbb78b2..2671fb696a4 100644
--- a/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
+++ b/Signal/src/ViewControllers/ConversationView/ConversationViewController.m
@@ -4446,6 +4446,11 @@ - (void)cvc_didTapMention:(Mention *)mention
     [actionSheet presentFromViewController:self];
 }
 
+- (void)cvc_didTapShowMessageDetail:(CVItemViewModelImpl *)itemViewModel
+{
+    [self showDetailView:itemViewModel];
+}
+
 #pragma mark - Selection
 
 // TODO: Move these methods to +Selection.swift
diff --git a/Signal/src/ViewControllers/HomeView/ConversationSplitViewController.swift b/Signal/src/ViewControllers/HomeView/ConversationSplitViewController.swift
index 64722e559e9..668b1cdb1ff 100644
--- a/Signal/src/ViewControllers/HomeView/ConversationSplitViewController.swift
+++ b/Signal/src/ViewControllers/HomeView/ConversationSplitViewController.swift
@@ -19,6 +19,8 @@ class ConversationSplitViewController: UISplitViewController, ConversationSplit
 
     @objc private(set) weak var selectedConversationViewController: ConversationViewController?
 
+    weak var navigationTransitionDelegate: UINavigationControllerDelegate?
+
     /// The thread, if any, that is currently presented in the view hieararchy. It may be currently
     /// covered by a modal presentation or a pushed view controller.
     @objc var selectedThread: TSThread? {
@@ -541,6 +543,22 @@ extension ConversationSplitViewController: UINavigationControllerDelegate {
         guard isCollapsed, viewController is ConversationListViewController else { return }
         selectedConversationViewController = nil
     }
+
+    func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
+        return navigationTransitionDelegate?.navigationController?(
+            navigationController,
+            interactionControllerFor: animationController
+        )
+    }
+
+    func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
+        return navigationTransitionDelegate?.navigationController?(
+            navigationController,
+            animationControllerFor: operation,
+            from: fromVC,
+            to: toVC
+        )
+    }
 }
 
 @objc extension ConversationListViewController {
diff --git a/Signal/src/ViewControllers/MessageDetailViewController.swift b/Signal/src/ViewControllers/MessageDetailViewController.swift
index f4a73e2909b..2724625006d 100644
--- a/Signal/src/ViewControllers/MessageDetailViewController.swift
+++ b/Signal/src/ViewControllers/MessageDetailViewController.swift
@@ -7,11 +7,6 @@ import QuickLook
 import SignalServiceKit
 import SignalMessaging
 
-enum MessageMetadataViewMode: UInt {
-    case focusOnMessage
-    case focusOnMetadata
-}
-
 protocol MessageDetailViewDelegate: AnyObject {
     func detailViewMessageWasDeleted(_ messageDetailViewController: MessageDetailViewController)
 }
@@ -22,9 +17,10 @@ class MessageDetailViewController: OWSViewController {
 
     // MARK: Properties
 
+    let percentDrivenTransition: UIPercentDrivenInteractiveTransition?
+
     var bubbleView: UIView?
 
-    let mode: MessageMetadataViewMode
     var message: TSMessage
     var wasDeleted: Bool = false
 
@@ -51,9 +47,9 @@ class MessageDetailViewController: OWSViewController {
 
     required init(message: TSMessage,
                   thread: TSThread,
-                  mode: MessageMetadataViewMode) {
+                  percentDrivenTransition: UIPercentDrivenInteractiveTransition?) {
         self.message = message
-        self.mode = mode
+        self.percentDrivenTransition = percentDrivenTransition
 
         super.init()
     }
@@ -89,35 +85,6 @@ class MessageDetailViewController: OWSViewController {
         })
     }
 
-    override func viewWillAppear(_ animated: Bool) {
-        super.viewWillAppear(animated)
-
-        if mode == .focusOnMetadata {
-            if let bubbleView = self.bubbleView {
-                // Force layout.
-                view.setNeedsLayout()
-                view.layoutIfNeeded()
-
-                let contentHeight = scrollView.contentSize.height
-                let scrollViewHeight = scrollView.frame.size.height
-                guard contentHeight >=  scrollViewHeight else {
-                    // All content is visible within the scroll view. No need to offset.
-                    return
-                }
-
-                // We want to include at least a little portion of the message, but scroll no farther than necessary.
-                let showAtLeast: CGFloat = 50
-                let bubbleViewBottom = bubbleView.superview!.convert(bubbleView.frame, to: scrollView).maxY
-                let maxOffset =  bubbleViewBottom - showAtLeast
-                let lastPage = contentHeight - scrollViewHeight
-
-                let offset = CGPoint(x: 0, y: min(maxOffset, lastPage))
-
-                scrollView.setContentOffset(offset, animated: false)
-            }
-        }
-    }
-
     // MARK: - Create Views
 
     private func createViews() {
@@ -884,6 +851,8 @@ extension MessageDetailViewController: CVComponentDelegate {
 
     func cvc_didTapMention(_ mention: Mention) {}
 
+    func cvc_didTapShowMessageDetail(_ itemViewModel: CVItemViewModelImpl) {}
+
     // MARK: - Selection
 
     // TODO:
@@ -964,3 +933,62 @@ extension MessageDetailViewController: CVComponentDelegate {
     // TODO:
     func cvc_didTapViewOnceExpired(_ interaction: TSInteraction) {}
 }
+
+extension MessageDetailViewController: UINavigationControllerDelegate {
+    func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -> UIViewControllerInteractiveTransitioning? {
+        return percentDrivenTransition
+    }
+
+    func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -> UIViewControllerAnimatedTransitioning? {
+        guard percentDrivenTransition != nil, operation == .push else { return nil }
+        return AnimationController()
+    }
+}
+
+private class AnimationController: NSObject, UIViewControllerAnimatedTransitioning {
+    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
+        0.35
+    }
+
+    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
+        guard let fromView = transitionContext.view(forKey: .from),
+              let toView = transitionContext.view(forKey: .to) else {
+            owsFailDebug("Missing view controllers.")
+            return transitionContext.completeTransition(false)
+        }
+
+        // Do our best to replicate the default nav controller push animation.
+
+        let containerView = transitionContext.containerView
+        let directionMultiplier: CGFloat = CurrentAppContext().isRTL ? -1 : 1
+
+        containerView.addSubview(fromView)
+        containerView.addSubview(toView)
+
+        let fromViewOverlay = UIView()
+        fromViewOverlay.backgroundColor = .ows_blackAlpha10
+        fromViewOverlay.alpha = 0
+
+        fromView.addSubview(fromViewOverlay)
+        fromViewOverlay.frame = fromView.bounds
+
+        toView.transform = CGAffineTransform(translationX: fromView.width * directionMultiplier, y: 0)
+
+        UIView.animate(withDuration: transitionDuration(using: transitionContext), delay: 0, options: .curveLinear) {
+            toView.transform = .identity
+            fromViewOverlay.alpha = 1
+            fromView.transform = CGAffineTransform(translationX: -(fromView.width / 3) * directionMultiplier, y: 0)
+        } completion: { _ in
+            fromView.transform = .identity
+            fromViewOverlay.removeFromSuperview()
+
+            if transitionContext.transitionWasCancelled {
+                toView.removeFromSuperview()
+            } else {
+                fromView.removeFromSuperview()
+            }
+
+            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
+        }
+    }
+}
diff --git a/Signal/src/views/MockConversationView.swift b/Signal/src/views/MockConversationView.swift
index 05a1dc3bbc9..5c5d63f1625 100644
--- a/Signal/src/views/MockConversationView.swift
+++ b/Signal/src/views/MockConversationView.swift
@@ -344,6 +344,10 @@ extension MockConversationView: CVComponentDelegate {
 
     func cvc_didTapMention(_ mention: Mention) {}
 
+    func cvc_didTapShowMessageDetail(_ itemViewModel: CVItemViewModelImpl) {}
+
+    var view: UIView { self }
+
     // MARK: - Selection
 
     var isShowingSelectionUI: Bool { false }
diff --git a/SignalMessaging/categories/UIColor+OWS.swift b/SignalMessaging/categories/UIColor+OWS.swift
index 5bc7c42a440..a6b5a4692f8 100644
--- a/SignalMessaging/categories/UIColor+OWS.swift
+++ b/SignalMessaging/categories/UIColor+OWS.swift
@@ -235,6 +235,11 @@ public extension UIColor {
         return UIColor(white: 0, alpha: 0.05)
     }
 
+    @objc(ows_blackAlpha10Color)
+    class var ows_blackAlpha10: UIColor {
+        return UIColor(white: 0, alpha: 0.10)
+    }
+
     @objc(ows_blackAlpha20Color)
     class var ows_blackAlpha20: UIColor {
         return UIColor(white: 0, alpha: 0.20)
