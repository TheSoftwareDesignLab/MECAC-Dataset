diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index d3156116c7c..0fb0d0ba30b 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -787,6 +787,7 @@
 		669E901028B57D6300043D28 /* SystemStoryManagerMock.swift in Sources */ = {isa = PBXBuildFile; fileRef = 669E900F28B57D6300043D28 /* SystemStoryManagerMock.swift */; };
 		66A22C0928A18D49007CD4F5 /* RingerSwitch.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66A22C0828A18D49007CD4F5 /* RingerSwitch.swift */; };
 		66B8B28028C94C0F005EAFE0 /* DelegatingContextMenuButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */; };
+		66BE544D28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66BE544C28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift */; };
 		760D93AB27A0E28600F351AC /* CoreServices.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 760D93AA27A0E28600F351AC /* CoreServices.framework */; };
 		7628DDBE2807505D009AA53D /* ImageEditorCropView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7628DDBC28075056009AA53D /* ImageEditorCropView.swift */; };
 		7628DDBF2807505D009AA53D /* RotationControl.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7628DDBD2807505D009AA53D /* RotationControl.swift */; };
@@ -3045,6 +3046,7 @@
 		669E900F28B57D6300043D28 /* SystemStoryManagerMock.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SystemStoryManagerMock.swift; sourceTree = "<group>"; };
 		66A22C0828A18D49007CD4F5 /* RingerSwitch.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RingerSwitch.swift; sourceTree = "<group>"; };
 		66B8B27F28C94C0F005EAFE0 /* DelegatingContextMenuButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DelegatingContextMenuButton.swift; sourceTree = "<group>"; };
+		66BE544C28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryContextOnboardingOverlayView.swift; sourceTree = "<group>"; };
 		70377AAA1918450100CAF501 /* MobileCoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = MobileCoreServices.framework; path = System/Library/Frameworks/MobileCoreServices.framework; sourceTree = SDKROOT; };
 		748A5CAEDD7C919FC64C6807 /* Pods_SignalTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_SignalTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
 		760D93AA27A0E28600F351AC /* CoreServices.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreServices.framework; path = System/Library/Frameworks/CoreServices.framework; sourceTree = SDKROOT; };
@@ -6077,6 +6079,7 @@
 		884DB94A27DE66E000C6A309 /* Context View */ = {
 			isa = PBXGroup;
 			children = (
+				66BE544C28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift */,
 				884DB94E27DE67BB00C6A309 /* StoryContextViewController.swift */,
 				884DB95127DE67D900C6A309 /* StoryItemMediaView.swift */,
 				884DB94D27DE67BB00C6A309 /* StoryPageViewController.swift */,
@@ -10380,6 +10383,7 @@
 				8852572927DD366D0032073C /* StoriesViewController.swift in Sources */,
 				884DB94727DD754700C6A309 /* StoryCell.swift in Sources */,
 				668FE09F28B947ED008B9071 /* StoryContextMenuGenerator.swift in Sources */,
+				66BE544D28CA4EC10021AFF1 /* StoryContextOnboardingOverlayView.swift in Sources */,
 				884DB95027DE67BB00C6A309 /* StoryContextViewController.swift in Sources */,
 				88423A52280A171E007D2918 /* StoryDirectReplySheet.swift in Sources */,
 				88B00D5128A341D000BC9CA0 /* StoryGroupRepliesAndViewsSheet.swift in Sources */,
diff --git a/Signal/Images.xcassets/story_viewer_onboarding_1.imageset/Contents.json b/Signal/Images.xcassets/story_viewer_onboarding_1.imageset/Contents.json
new file mode 100644
index 00000000000..08a10c91647
--- /dev/null
+++ b/Signal/Images.xcassets/story_viewer_onboarding_1.imageset/Contents.json
@@ -0,0 +1,12 @@
+{
+  "images" : [
+    {
+      "filename" : "story_viewer_onboarding_1.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Signal/Images.xcassets/story_viewer_onboarding_1.imageset/story_viewer_onboarding_1.pdf b/Signal/Images.xcassets/story_viewer_onboarding_1.imageset/story_viewer_onboarding_1.pdf
new file mode 100644
index 00000000000..f68199fddfc
Binary files /dev/null and b/Signal/Images.xcassets/story_viewer_onboarding_1.imageset/story_viewer_onboarding_1.pdf differ
diff --git a/Signal/Images.xcassets/story_viewer_onboarding_2.imageset/Contents.json b/Signal/Images.xcassets/story_viewer_onboarding_2.imageset/Contents.json
new file mode 100644
index 00000000000..ebd1e80b99d
--- /dev/null
+++ b/Signal/Images.xcassets/story_viewer_onboarding_2.imageset/Contents.json
@@ -0,0 +1,12 @@
+{
+  "images" : [
+    {
+      "filename" : "story_viewer_onboarding_2.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Signal/Images.xcassets/story_viewer_onboarding_2.imageset/story_viewer_onboarding_2.pdf b/Signal/Images.xcassets/story_viewer_onboarding_2.imageset/story_viewer_onboarding_2.pdf
new file mode 100644
index 00000000000..fc659cf2ee5
Binary files /dev/null and b/Signal/Images.xcassets/story_viewer_onboarding_2.imageset/story_viewer_onboarding_2.pdf differ
diff --git a/Signal/Images.xcassets/story_viewer_onboarding_3.imageset/Contents.json b/Signal/Images.xcassets/story_viewer_onboarding_3.imageset/Contents.json
new file mode 100644
index 00000000000..96da58a9713
--- /dev/null
+++ b/Signal/Images.xcassets/story_viewer_onboarding_3.imageset/Contents.json
@@ -0,0 +1,12 @@
+{
+  "images" : [
+    {
+      "filename" : "story_viewer_onboarding_3.pdf",
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Signal/Images.xcassets/story_viewer_onboarding_3.imageset/story_viewer_onboarding_3.pdf b/Signal/Images.xcassets/story_viewer_onboarding_3.imageset/story_viewer_onboarding_3.pdf
new file mode 100644
index 00000000000..4d020a1d9d2
Binary files /dev/null and b/Signal/Images.xcassets/story_viewer_onboarding_3.imageset/story_viewer_onboarding_3.pdf differ
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextOnboardingOverlayView.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextOnboardingOverlayView.swift
new file mode 100644
index 00000000000..047a40da53c
--- /dev/null
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextOnboardingOverlayView.swift	
@@ -0,0 +1,264 @@
+//
+//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import UIKit
+import SignalServiceKit
+
+protocol StoryContextOnboardingOverlayViewDelegate: AnyObject {
+
+    func storyContextOnboardingOverlayWillDisplay(_ : StoryContextOnboardingOverlayView)
+    func storyContextOnboardingOverlayDidDismiss(_ : StoryContextOnboardingOverlayView)
+}
+
+class StoryContextOnboardingOverlayView: UIView, Dependencies {
+
+    private let kvStore = SDSKeyValueStore(collection: "StoryViewerOnboardingOverlay")
+    static let kvStoreKey = "hasSeenStoryViewerOnboardingOverlay"
+
+    private weak var delegate: StoryContextOnboardingOverlayViewDelegate?
+
+    public init(delegate: StoryContextOnboardingOverlayViewDelegate) {
+        self.delegate = delegate
+        super.init(frame: .zero)
+
+        self.isHidden = true
+        setupSubviews()
+
+        // The simplest way to have this overlay block all gestures, especially those
+        // that would go to the parent UIPageViewController, is to give it no-op
+        // gesture recognizers of its own and make them override everything.
+        isUserInteractionEnabled = true
+        for captureRecognizer in [UIPanGestureRecognizer(), UITapGestureRecognizer(), UILongPressGestureRecognizer()] {
+            captureRecognizer.cancelsTouchesInView = true
+            captureRecognizer.delegate = self
+            addGestureRecognizer(captureRecognizer)
+        }
+    }
+
+    @available(*, unavailable)
+    required init?(coder: NSCoder) {
+        fatalError("init(coder:) has not been implemented")
+    }
+
+    // Static so multiple parallel instances stay in sync.
+    private static var shouldDisplay: Bool?
+
+    func checkIfShouldDisplay() {
+        Self.shouldDisplay = Self.databaseStorage.read { transaction in
+            if self.kvStore.getBool(Self.kvStoreKey, defaultValue: false, transaction: transaction) {
+                return false
+            }
+
+            if Self.systemStoryManager.isOnboardingStoryViewed(transaction: transaction) {
+                // We don't sync view state for the onboarding overlay. But we can use
+                // viewing of the onboarding story as an imperfect proxy; if they viewed it
+                // that means they also definitely saw the viewer overlay.
+                return false
+            }
+            return true
+        }
+    }
+
+    private(set) var isDisplaying: Bool = false {
+        didSet {
+            guard oldValue != isDisplaying else { return }
+            if isDisplaying {
+                delegate?.storyContextOnboardingOverlayWillDisplay(self)
+            } else {
+                delegate?.storyContextOnboardingOverlayDidDismiss(self)
+            }
+        }
+    }
+
+    /// Returns nil if no overlay needs to be shown.
+    func showIfNeeded() {
+        if Self.shouldDisplay == nil {
+            checkIfShouldDisplay()
+        }
+        guard Self.shouldDisplay ?? false else {
+            return
+        }
+
+        // Mark as viewed from now on.
+        Self.databaseStorage.write { transaction in
+            self.kvStore.setBool(true, key: Self.kvStoreKey, transaction: transaction)
+        }
+        Self.shouldDisplay = false
+
+        self.superview?.bringSubviewToFront(self)
+        isDisplaying = true
+        self.isHidden = false
+        blurView.effect = .none
+        blurView.contentView.alpha = 0
+        UIView.animate(withDuration: 0.35) {
+            self.blurView.effect = UIBlurEffect(style: .dark)
+            self.blurView.contentView.alpha = 1
+        }
+    }
+
+    func dismiss() {
+        UIView.animate(
+            withDuration: 0.2,
+            animations: {
+                self.blurView.effect = .none
+                self.blurView.contentView.alpha = 0
+            },
+            completion: { _ in
+                self.isHidden = true
+                self.isDisplaying = false
+            }
+        )
+    }
+
+    private lazy var blurView = UIVisualEffectView()
+
+    private func setupSubviews() {
+        addSubview(blurView)
+        blurView.autoPinEdgesToSuperviewEdges()
+
+        let vStack = UIStackView()
+        vStack.axis = .vertical
+        vStack.alignment = .center
+        vStack.distribution = .equalCentering
+
+        var prevHStack: UIView?
+        for asset in assets {
+            let imageContainer = UIView()
+
+            let imageView = UIImageView(image: asset.image?.withRenderingMode(.alwaysTemplate).asTintedImage(color: .ows_white))
+            imageView.setContentHuggingPriority(.defaultHigh, for: .horizontal)
+
+            imageContainer.addSubview(imageView)
+
+            imageContainer.autoPinHeight(toHeightOf: imageView)
+            imageContainer.autoPinWidth(toWidthOf: imageView)
+            imageView.autoVCenterInSuperview()
+            imageView.autoAlignAxis(.vertical, toSameAxisOf: imageContainer, withOffset: asset.imageXOffset)
+
+            let label = UILabel()
+            label.textColor = .ows_gray05
+            label.font = .ows_dynamicTypeBody
+            label.text = asset.text
+            label.setContentHuggingPriority(.defaultLow, for: .horizontal)
+
+            let hStack = UIStackView()
+            hStack.axis = .horizontal
+            hStack.alignment = .center
+            hStack.distribution = .equalSpacing
+            hStack.addArrangedSubviews([imageContainer, label])
+
+            if CurrentAppContext().isRTL {
+                label.autoConstrainAttribute(.trailing, to: .vertical, of: imageContainer, withOffset: -46)
+            } else {
+                label.autoConstrainAttribute(.leading, to: .vertical, of: imageContainer, withOffset: 46)
+            }
+
+            vStack.addArrangedSubview(hStack)
+
+            if let prevHStack = prevHStack {
+                hStack.autoPinWidth(toWidthOf: prevHStack)
+            }
+            prevHStack = hStack
+        }
+
+        let confirmButtonContainer = ManualLayoutView(name: "confirm_button")
+        confirmButtonContainer.shouldDeactivateConstraints = false
+
+        confirmButtonContainer.translatesAutoresizingMaskIntoConstraints = false
+        let confirmButton = OWSButton()
+        confirmButton.translatesAutoresizingMaskIntoConstraints = false
+        confirmButton.setTitle(
+            NSLocalizedString(
+                "STORY_VIEWER_ONBOARDING_CONFIRMATION",
+                comment: "Confirmation text shown the first time the user opens the story viewer to dismiss instructions."
+            ),
+            for: .normal
+        )
+        confirmButton.titleLabel?.font = .ows_dynamicTypeSubheadline.ows_semibold
+        confirmButton.backgroundColor = .ows_white
+        confirmButton.setTitleColor(.ows_black, for: .normal)
+        confirmButton.contentEdgeInsets = UIEdgeInsets(hMargin: 23, vMargin: 8)
+        confirmButton.block = { [weak self] in
+            self?.dismiss()
+        }
+
+        confirmButtonContainer.addSubview(confirmButton) { view in
+            confirmButton.layer.cornerRadius = confirmButton.height / 2
+        }
+        confirmButton.autoPinEdges(toEdgesOf: confirmButtonContainer)
+
+        vStack.addArrangedSubview(confirmButtonContainer)
+
+        blurView.contentView.addSubview(vStack)
+        vStack.autoPinHorizontalEdges(toEdgesOf: blurView.contentView)
+        vStack.autoVCenterInSuperview()
+        vStack.autoConstrainAttribute(.height, to: .height, of: blurView, withMultiplier: 0.6)
+
+        let closeButton = OWSButton()
+        closeButton.setImage(
+            UIImage(named: "x-24")?
+                .withRenderingMode(.alwaysTemplate)
+                .asTintedImage(color: .ows_white),
+            for: .normal
+        )
+        closeButton.contentMode = .center
+        closeButton.block = { [weak self] in
+            self?.dismiss()
+        }
+        blurView.contentView.addSubview(closeButton)
+
+        closeButton.autoSetDimensions(to: .square(42))
+        closeButton.autoPinEdge(toSuperviewEdge: .top, withInset: 20)
+        closeButton.autoPinEdge(toSuperviewEdge: .leading, withInset: 20)
+    }
+
+    private struct Asset {
+        let image: UIImage?
+        let imageXOffset: CGFloat
+        let text: String
+    }
+
+    private var assets: [Asset] {
+        [
+            Asset(
+                image: #imageLiteral(resourceName: "story_viewer_onboarding_1"),
+                imageXOffset: 0,
+                text: NSLocalizedString(
+                    "STORY_VIEWER_ONBOARDING_1",
+                    comment: "Text shown the first time the user opens the story viewer instructing them how to use it."
+                )
+            ),
+            Asset(
+                image: #imageLiteral(resourceName: "story_viewer_onboarding_2"),
+                imageXOffset: 0,
+                text: NSLocalizedString(
+                    "STORY_VIEWER_ONBOARDING_2",
+                    comment: "Text shown the first time the user opens the story viewer instructing them how to use it."
+                )
+            ),
+            Asset(
+                image: #imageLiteral(resourceName: "story_viewer_onboarding_3"),
+                // The asset is "centered" but the designs require misalignment of the
+                // assets frame to visually align a sub-part of its contents.
+                imageXOffset: -12,
+                text: NSLocalizedString(
+                    "STORY_VIEWER_ONBOARDING_3",
+                    comment: "Text shown the first time the user opens the story viewer instructing them how to use it."
+                )
+            )
+        ]
+    }
+}
+
+extension StoryContextOnboardingOverlayView: UIGestureRecognizerDelegate {
+
+    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool {
+        return false
+    }
+
+    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {
+        return true
+    }
+}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift
index 3eaf9d2c869..a0db7431c2e 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryContextViewController.swift	
@@ -112,6 +112,10 @@ class StoryContextViewController: OWSViewController {
         playbackProgressView.alpha = 1
         closeButton.alpha = 1
         repliesAndViewsButton.alpha = 1
+
+        if onboardingOverlay.isDisplaying {
+            pause(hideChrome: true)
+        }
     }
 
     func updateMuteState() {
@@ -147,6 +151,9 @@ class StoryContextViewController: OWSViewController {
     private lazy var closeButton = OWSButton(imageName: "x-24", tintColor: .ows_white)
 
     private lazy var mediaViewContainer = UIView()
+
+    private lazy var onboardingOverlay = StoryContextOnboardingOverlayView(delegate: self)
+
     private lazy var repliesAndViewsButton = OWSButton()
     override func viewDidLoad() {
         super.viewDidLoad()
@@ -164,6 +171,9 @@ class StoryContextViewController: OWSViewController {
         rightTapGestureRecognizer.require(toFail: pauseGestureRecognizer)
 
         view.addSubview(mediaViewContainer)
+        view.addSubview(onboardingOverlay)
+
+        onboardingOverlay.autoPinEdges(toEdgesOf: mediaViewContainer)
 
         repliesAndViewsButton.block = { [weak self] in self?.presentRepliesAndViewsSheet() }
         repliesAndViewsButton.autoSetDimension(.height, toSize: 64)
@@ -182,6 +192,8 @@ class StoryContextViewController: OWSViewController {
             // iPhone with notch or iPad (views/replies rendered below media, media is in a card)
             mediaViewContainer.layer.cornerRadius = 18
             mediaViewContainer.clipsToBounds = true
+            onboardingOverlay.layer.cornerRadius = 18
+            onboardingOverlay.clipsToBounds = true
             repliesAndViewsButton.autoPinEdge(.top, to: .bottom, of: mediaViewContainer)
             playbackProgressView.autoPinEdge(.bottom, to: .top, of: repliesAndViewsButton, withOffset: -OWSTableViewController2.defaultHOuterMargin)
         } else {
@@ -227,6 +239,20 @@ class StoryContextViewController: OWSViewController {
         }
     }
 
+    override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        // Precompute if it should display before we mark anything viewed.
+        onboardingOverlay.checkIfShouldDisplay()
+    }
+
+    /// This controller's view gets generated early to use for a zoom animation, which triggers
+    /// viewWill- and viewDidAppear before presentation has really finished.
+    /// The parent page controller calls this method when presentation actually finishes.
+    func pageControllerDidAppear() {
+        onboardingOverlay.showIfNeeded()
+    }
+
     private static let maxItemsToRender = 100
     private func loadStoryItems(completion: @escaping ([StoryItem]) -> Void) {
         var storyItems = [StoryItem]()
@@ -765,3 +791,14 @@ extension StoryContextViewController: StoryContextMenuDelegate {
         play()
     }
 }
+
+extension StoryContextViewController: StoryContextOnboardingOverlayViewDelegate {
+
+    func storyContextOnboardingOverlayWillDisplay(_: StoryContextOnboardingOverlayView) {
+        pause(hideChrome: true)
+    }
+
+    func storyContextOnboardingOverlayDidDismiss(_: StoryContextOnboardingOverlayView) {
+        play()
+    }
+}
diff --git a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift
index a46fc064474..e41ad90350a 100644
--- a/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift	
+++ b/Signal/src/ViewControllers/HomeView/Stories/Context View/StoryPageViewController.swift	
@@ -72,6 +72,12 @@ class StoryPageViewController: UIPageViewController {
         interactiveDismissCoordinator = StoryInteractiveTransitionCoordinator(pageViewController: self)
     }
 
+    private var isDisplayLinkPaused = false {
+        didSet {
+            displayLink?.isPaused = isDisplayLinkPaused
+        }
+    }
+
     private var displayLink: CADisplayLink?
 
     private var viewIsAppeared = false {
@@ -89,6 +95,7 @@ class StoryPageViewController: UIPageViewController {
             let displayLink = CADisplayLink(target: self, selector: #selector(displayLinkStep))
             displayLink.add(to: .main, forMode: .common)
             self.displayLink = displayLink
+            displayLink.isPaused = isDisplayLinkPaused
         }
         viewIsAppeared = true
     }
@@ -100,6 +107,8 @@ class StoryPageViewController: UIPageViewController {
         if !UIDevice.current.isIPad && CurrentAppContext().interfaceOrientation != .portrait {
             UIDevice.current.ows_setOrientation(.portrait)
         }
+
+        currentContextViewController.pageControllerDidAppear()
     }
 
     override func viewWillDisappear(_ animated: Bool) {
@@ -355,11 +364,11 @@ extension StoryPageViewController: StoryContextViewControllerDelegate {
         else {
             return
         }
-        displayLink?.isPaused = true
+        isDisplayLinkPaused = true
     }
 
     func storyContextViewControllerDidResume(_ storyContextViewController: StoryContextViewController) {
-        displayLink?.isPaused = false
+        isDisplayLinkPaused = false
     }
 
     func storyContextViewControllerShouldOnlyRenderMyStories(_ storyContextViewController: StoryContextViewController) -> Bool {
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index d6a885755a9..5e9e6e82f1a 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -6283,6 +6283,18 @@
 /* Text indicating that the story is currently sending */
 "STORY_SENDING" = "Sending...";
 
+/* Text shown the first time the user opens the story viewer instructing them how to use it. */
+"STORY_VIEWER_ONBOARDING_1" = "Tap to advance";
+
+/* Text shown the first time the user opens the story viewer instructing them how to use it. */
+"STORY_VIEWER_ONBOARDING_2" = "Swipe up to skip";
+
+/* Text shown the first time the user opens the story viewer instructing them how to use it. */
+"STORY_VIEWER_ONBOARDING_3" = "Swipe right to exit";
+
+/* Confirmation text shown the first time the user opens the story viewer to dismiss instructions. */
+"STORY_VIEWER_ONBOARDING_CONFIRMATION" = "Got it";
+
 /* Toast indicating that the user has copied their subscriber ID. */
 "SUBSCRIPTION_SUBSCRIBER_ID_COPIED_TO_CLIPBOARD" = "Copied subscriber id to clipboard";
 
diff --git a/SignalServiceKit/src/Messages/Stories/SystemStoryManager.swift b/SignalServiceKit/src/Messages/Stories/SystemStoryManager.swift
index e7592ee57a9..4eb82a4d394 100644
--- a/SignalServiceKit/src/Messages/Stories/SystemStoryManager.swift
+++ b/SignalServiceKit/src/Messages/Stories/SystemStoryManager.swift
@@ -132,6 +132,20 @@ public class SystemStoryManager: NSObject, Dependencies, SystemStoryManagerProto
         }
     }
 
+    public func isOnboardingStoryViewed(transaction: SDSAnyReadTransaction) -> Bool {
+        let status = downloadStatus(transaction: transaction)
+        guard status.isDownloaded, let messageUniqueIds = status.messageUniqueIds, !messageUniqueIds.isEmpty else {
+            return false
+        }
+        let stories = StoryFinder.listStoriesWithUniqueIds(messageUniqueIds, transaction: transaction)
+        guard !stories.isEmpty else {
+            // If they were deleted, we assume they were viewed and then deleted.
+            return true
+        }
+
+        return stories.contains(where: { $0.localUserViewedTimestamp != nil })
+    }
+
     // MARK: - Event Observation
 
     private var isObservingBackgrounding = false
@@ -218,12 +232,7 @@ public class SystemStoryManager: NSObject, Dependencies, SystemStoryManagerProto
         forceDeleteIfDownloaded: Bool,
         transaction: SDSAnyWriteTransaction
     ) -> DownloadStatus {
-        guard
-            let rawStatus = kvStore.getData(Constants.kvStoreOnboardingStoryStatusKey, transaction: transaction),
-            let status = try? JSONDecoder().decode(DownloadStatus.self, from: rawStatus)
-        else {
-            return .requiresDownload
-        }
+        let status = downloadStatus(transaction: transaction)
         if status.isDownloaded {
             // clean up opportunistically.
             try? self.cleanUpStoriesIfNeeded(
@@ -235,6 +244,16 @@ public class SystemStoryManager: NSObject, Dependencies, SystemStoryManagerProto
         return status
     }
 
+    private func downloadStatus(transaction: SDSAnyReadTransaction) -> DownloadStatus {
+        guard
+            let rawStatus = kvStore.getData(Constants.kvStoreOnboardingStoryStatusKey, transaction: transaction),
+            let status = try? JSONDecoder().decode(DownloadStatus.self, from: rawStatus)
+        else {
+            return .requiresDownload
+        }
+        return status
+    }
+
     private func cleanUpStoriesIfNeeded(
         messageUniqueIds: [String]?,
         forceDeleteIfDownloaded: Bool,
diff --git a/SignalServiceKit/src/Messages/Stories/SystemStoryManagerMock.swift b/SignalServiceKit/src/Messages/Stories/SystemStoryManagerMock.swift
index c2d02264767..789b2ddec36 100644
--- a/SignalServiceKit/src/Messages/Stories/SystemStoryManagerMock.swift
+++ b/SignalServiceKit/src/Messages/Stories/SystemStoryManagerMock.swift
@@ -25,6 +25,12 @@ public class SystemStoryManagerMock: NSObject, SystemStoryManagerProtocol {
         return cleanUpOnboardingStoryHandler()
     }
 
+    public var isOnboardingStoryViewed: Bool = false
+
+    public func isOnboardingStoryViewed(transaction: SDSAnyReadTransaction) -> Bool {
+        return isOnboardingStoryViewed
+    }
+
     public func addStateChangedObserver(_ observer: SystemStoryStateChangeObserver) {
         fatalError("Unimplemented for tests")
     }
diff --git a/SignalServiceKit/src/Messages/Stories/SystemStoryManagerProtocol.swift b/SignalServiceKit/src/Messages/Stories/SystemStoryManagerProtocol.swift
index 939da262c71..7175dd0413e 100644
--- a/SignalServiceKit/src/Messages/Stories/SystemStoryManagerProtocol.swift
+++ b/SignalServiceKit/src/Messages/Stories/SystemStoryManagerProtocol.swift
@@ -20,6 +20,8 @@ public protocol SystemStoryManagerProtocol: SystemStoryManagerProtocolObjc {
     /// Called on its own when the app is backgrounded.
     func cleanUpOnboardingStoryIfNeeded() -> Promise<Void>
 
+    func isOnboardingStoryViewed(transaction: SDSAnyReadTransaction) -> Bool
+
     // MARK: Hidden State
 
     func addStateChangedObserver(_ observer: SystemStoryStateChangeObserver)
