diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index b72917b0a78..8c124856b86 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -350,6 +350,7 @@
 		34DBF004206BD5A500025978 /* OWSBubbleView.m in Sources */ = {isa = PBXBuildFile; fileRef = 34DBF001206BD5A500025978 /* OWSBubbleView.m */; };
 		34DBF007206C3CB200025978 /* OWSBubbleShapeView.m in Sources */ = {isa = PBXBuildFile; fileRef = 34DBF006206C3CB200025978 /* OWSBubbleShapeView.m */; };
 		34DC9BD921543E0C00FDDCEC /* DebugContactsUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = 34DC9BD721543E0A00FDDCEC /* DebugContactsUtils.m */; };
+		34E0127423FDA960002D0D13 /* DebugUIGroupsV2.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34E0127323FDA960002D0D13 /* DebugUIGroupsV2.swift */; };
 		34E3EF0D1EFC235B007F6822 /* DebugUIDiskUsage.m in Sources */ = {isa = PBXBuildFile; fileRef = 34E3EF0C1EFC235B007F6822 /* DebugUIDiskUsage.m */; };
 		34E3EF101EFC2684007F6822 /* DebugUIPage.m in Sources */ = {isa = PBXBuildFile; fileRef = 34E3EF0F1EFC2684007F6822 /* DebugUIPage.m */; };
 		34E5DC8220D8050D00C08145 /* RegistrationUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = 34E5DC8120D8050D00C08145 /* RegistrationUtils.m */; };
@@ -1252,6 +1253,7 @@
 		34DBF006206C3CB200025978 /* OWSBubbleShapeView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = OWSBubbleShapeView.m; sourceTree = "<group>"; };
 		34DC9BD721543E0A00FDDCEC /* DebugContactsUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DebugContactsUtils.m; sourceTree = "<group>"; };
 		34DC9BD821543E0B00FDDCEC /* DebugContactsUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugContactsUtils.h; sourceTree = "<group>"; };
+		34E0127323FDA960002D0D13 /* DebugUIGroupsV2.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = DebugUIGroupsV2.swift; sourceTree = "<group>"; };
 		34E3EF0B1EFC235B007F6822 /* DebugUIDiskUsage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugUIDiskUsage.h; sourceTree = "<group>"; };
 		34E3EF0C1EFC235B007F6822 /* DebugUIDiskUsage.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = DebugUIDiskUsage.m; sourceTree = "<group>"; };
 		34E3EF0E1EFC2684007F6822 /* DebugUIPage.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugUIPage.h; sourceTree = "<group>"; };
@@ -2529,9 +2531,11 @@
 				45638BDB1F3DD0D400128435 /* DebugUICalling.swift */,
 				34D8C0291ED3685800188D7C /* DebugUIContacts.h */,
 				34D8C02A1ED3685800188D7C /* DebugUIContacts.m */,
+				4C68FDAD2385F5A4002576B1 /* DebugUIDataStoreViewController.swift */,
 				34E3EF0B1EFC235B007F6822 /* DebugUIDiskUsage.h */,
 				34E3EF0C1EFC235B007F6822 /* DebugUIDiskUsage.m */,
 				45B27B852037FFB400A539DF /* DebugUIFileBrowser.swift */,
+				34E0127323FDA960002D0D13 /* DebugUIGroupsV2.swift */,
 				34D8C0231ED3673300188D7C /* DebugUIMessages.h */,
 				34D8C0241ED3673300188D7C /* DebugUIMessages.m */,
 				4C19A0FB227B356F007A0C7F /* DebugUIMessages+OWS.swift */,
@@ -2555,7 +2559,6 @@
 				34D8C0251ED3673300188D7C /* DebugUITableViewController.h */,
 				34D8C0261ED3673300188D7C /* DebugUITableViewController.m */,
 				4CBBFE492306F5D300B37450 /* LogViewController.swift */,
-				4C68FDAD2385F5A4002576B1 /* DebugUIDataStoreViewController.swift */,
 			);
 			path = DebugUI;
 			sourceTree = "<group>";
@@ -4679,6 +4682,7 @@
 				340FC8BD204DAC8D007AEB0F /* ShowGroupMembersViewController.m in Sources */,
 				3496956F21A301A100DCFE74 /* OWSBackupLazyRestore.swift in Sources */,
 				4C9C510022F495F60054A33F /* BroadcastMediaMessageJob.swift in Sources */,
+				34E0127423FDA960002D0D13 /* DebugUIGroupsV2.swift in Sources */,
 				88D23D2423CEC0C700B0E74B /* CallKitCallManager.swift in Sources */,
 				459311FC1D75C948008DD4F0 /* OWSDeviceTableViewCell.m in Sources */,
 			);
diff --git a/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift b/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift
new file mode 100644
index 00000000000..abdb1ee95a3
--- /dev/null
+++ b/Signal/src/ViewControllers/DebugUI/DebugUIGroupsV2.swift
@@ -0,0 +1,489 @@
+//
+//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+import SignalServiceKit
+import SignalMessaging
+
+#if DEBUG
+
+class DebugUIGroupsV2: DebugUIPage {
+
+    // MARK: Dependencies
+
+    private var databaseStorage: SDSDatabaseStorage {
+        return SDSDatabaseStorage.shared
+    }
+
+    private var tsAccountManager: TSAccountManager {
+        return .sharedInstance()
+    }
+
+    private var contactsManager: OWSContactsManager {
+        return Environment.shared.contactsManager
+    }
+
+    // MARK: Overrides 
+
+    override func name() -> String {
+        return "Groups v2"
+    }
+
+    override func section(thread: TSThread?) -> OWSTableSection? {
+        var sectionItems = [OWSTableItem]()
+
+        if let groupThread = thread as? TSGroupThread {
+            sectionItems.append(OWSTableItem(title: "Make group update info messages.") { [weak self] in
+                self?.insertGroupUpdateInfoMessages(groupThread: groupThread)
+            })
+        }
+
+        return OWSTableSection(title: "Groups v2", items: sectionItems)
+    }
+
+    private func insertGroupUpdateInfoMessages(groupThread: TSGroupThread) {
+
+        databaseStorage.asyncWrite { transaction in
+            do {
+                try self.insertGroupUpdateInfoMessages(groupThread: groupThread,
+                                                       groupsVersion: .V1,
+                                                       isLocalUpdate: true,
+                                                       prefix: "V1 Group, Local Updater:",
+                                                       transaction: transaction)
+
+                try self.insertGroupUpdateInfoMessages(groupThread: groupThread,
+                                                       groupsVersion: .V1,
+                                                       isLocalUpdate: false,
+                                                       prefix: "V1 Group, Other Updater:",
+                                                       transaction: transaction)
+
+                try self.insertGroupUpdateInfoMessages(groupThread: groupThread,
+                                                       groupsVersion: .V1,
+                                                       isAnonymousUpdate: true,
+                                                       prefix: "V1 Group, Anon Updater:",
+                                                       transaction: transaction)
+
+                if FeatureFlags.groupsV2CreateGroups {
+                    try self.insertGroupUpdateInfoMessages(groupThread: groupThread,
+                                                           groupsVersion: .V2,
+                                                           isLocalUpdate: true,
+                                                           prefix: "V2 Group, Local Updater:",
+                                                           transaction: transaction)
+
+                    try self.insertGroupUpdateInfoMessages(groupThread: groupThread,
+                                                           groupsVersion: .V2,
+                                                           isLocalUpdate: false,
+                                                           prefix: "V2 Group, Other Updater:",
+                                                           transaction: transaction)
+
+                    try self.insertGroupUpdateInfoMessages(groupThread: groupThread,
+                                                           groupsVersion: .V2,
+                                                           isAnonymousUpdate: true,
+                                                           prefix: "V2 Group, Anon Updater:",
+                                                           transaction: transaction)
+
+                }
+            } catch {
+                owsFailDebug("Error: \(error)")
+            }
+        }
+    }
+
+    private func insertGroupUpdateInfoMessages(groupThread: TSGroupThread,
+                                               groupsVersion: GroupsVersion,
+                                               isLocalUpdate: Bool = false,
+                                               isAnonymousUpdate: Bool = false,
+                                               prefix: String,
+                                               transaction: SDSAnyWriteTransaction) throws {
+
+        let prefix = prefix + " "
+
+        // These will fail if you aren't registered or
+        // don't have some Signal users in your contacts.
+        let localAddress = tsAccountManager.localAddress!
+        var allAddresses = contactsManager.signalAccounts.map { $0.recipientAddress }
+        if groupsVersion == .V2 {
+            // V2 group members must have a uuid.
+            allAddresses = allAddresses.filter { $0.uuid != nil }
+        }
+        let updaterAddress: SignalServiceAddress?
+        if isAnonymousUpdate {
+            updaterAddress = nil
+        } else if isLocalUpdate {
+            updaterAddress = localAddress
+        } else {
+            updaterAddress = allAddresses[0]
+        }
+        let otherAddresses = allAddresses.filter { $0 != localAddress && $0 != updaterAddress }.shuffled()
+        let otherAddress0: SignalServiceAddress = otherAddresses[0]
+        let otherAddress1: SignalServiceAddress = otherAddresses[1]
+        let randoAddress = SignalServiceAddress(uuid: UUID())
+
+        let insertOutgoingMessage = { body in
+            TSOutgoingMessageBuilder(thread: groupThread, messageBody: body).build().anyInsert(transaction: transaction)
+        }
+
+        var defaultModelBuilder = TSGroupModelBuilder()
+        defaultModelBuilder.groupsVersion = groupsVersion
+        var defaultMembershipBuilder = GroupMembership.Builder()
+        defaultMembershipBuilder.addNonPendingMember(localAddress, role: .administrator)
+        defaultModelBuilder.groupMembership = defaultMembershipBuilder.build()
+        let defaultModel = try defaultModelBuilder.build(transaction: transaction)
+        let defaultDMToken = DisappearingMessageToken.disabledToken
+
+        do {
+            insertOutgoingMessage(prefix + "created, empty.")
+
+            let model1 = defaultModel
+            let dmToken1 = defaultDMToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: nil,
+                                                      newGroupModel: model1,
+                                                      oldDisappearingMessageToken: nil,
+                                                      newDisappearingMessageToken: dmToken1,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+            guard groupsVersion == .V2 else {
+                // We add a "revision = 1" variant for v2 only.
+                return
+            }
+
+            var modelBuilder2 = model1.asBuilder
+            modelBuilder2.groupV2Revision = 1
+            let model2 = try modelBuilder2.build(transaction: transaction)
+            let dmToken2 = defaultDMToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: nil,
+                                                      newGroupModel: model2,
+                                                      oldDisappearingMessageToken: nil,
+                                                      newDisappearingMessageToken: dmToken2,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            guard groupsVersion == .V1 else {
+                // Inserting info messages for no-op updates will
+                // trip an assert in v2 groups.
+                return
+            }
+
+            insertOutgoingMessage(prefix + "modified, empty.")
+
+            let model1 = defaultModel
+            let dmToken1 = defaultDMToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model1,
+                                                      newGroupModel: model1,
+                                                      oldDisappearingMessageToken: dmToken1,
+                                                      newDisappearingMessageToken: dmToken1,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            insertOutgoingMessage(prefix + "modified, empty -> complicated -> empty.")
+
+            let model1 = defaultModel
+            let dmToken1 = defaultDMToken
+
+            var modelBuilder2 = model1.asBuilder
+            modelBuilder2.name = "name 2"
+            modelBuilder2.avatarData = "avatar 2".data(using: .utf8)
+            var groupMembershipBuilder1 = model1.groupMembership.asBuilder
+            groupMembershipBuilder1.addNonPendingMember(otherAddress0, role: .normal)
+            if groupsVersion == .V2,
+                let updaterUuid = updaterAddress?.uuid {
+                groupMembershipBuilder1.addPendingMember(otherAddress1,
+                                                         role: .normal,
+                                                         addedByUuid: updaterUuid)
+            }
+
+            modelBuilder2.groupMembership = groupMembershipBuilder1.build()
+            modelBuilder2.groupAccess = .adminOnly
+
+            let model2 = try modelBuilder2.build(transaction: transaction)
+            let dmToken2 = DisappearingMessageToken(isEnabled: true, durationSeconds: 30)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model1,
+                                                      newGroupModel: model2,
+                                                      oldDisappearingMessageToken: dmToken1,
+                                                      newDisappearingMessageToken: dmToken2,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model2,
+                                                      newGroupModel: model1,
+                                                      oldDisappearingMessageToken: dmToken2,
+                                                      newDisappearingMessageToken: dmToken1,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            insertOutgoingMessage(prefix + "DMs off -> on -> changed -> off.")
+
+            let model = defaultModel
+
+            let dmToken0 = DisappearingMessageToken.disabledToken
+            let dmToken1 = DisappearingMessageToken(isEnabled: true, durationSeconds: 30)
+            let dmToken2 = DisappearingMessageToken(isEnabled: true, durationSeconds: 60)
+            let dmToken3 = DisappearingMessageToken.disabledToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model,
+                                                      newGroupModel: model,
+                                                      oldDisappearingMessageToken: dmToken0,
+                                                      newDisappearingMessageToken: dmToken1,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model,
+                                                      newGroupModel: model,
+                                                      oldDisappearingMessageToken: dmToken1,
+                                                      newDisappearingMessageToken: dmToken2,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model,
+                                                      newGroupModel: model,
+                                                      oldDisappearingMessageToken: dmToken2,
+                                                      newDisappearingMessageToken: dmToken3,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            guard groupsVersion == .V2 else {
+                return
+            }
+
+            insertOutgoingMessage(prefix + "access changes.")
+
+            var modelBuilder1 = TSGroupModelBuilder()
+            modelBuilder1.groupsVersion = groupsVersion
+            modelBuilder1.groupAccess = .defaultForV2
+            modelBuilder1.groupMembership = defaultMembershipBuilder.build()
+            let model1 = try modelBuilder1.build(transaction: transaction)
+
+            var modelBuilder2 = model1.asBuilder
+            modelBuilder2.groupAccess = .adminOnly
+            let model2 = try modelBuilder2.build(transaction: transaction)
+
+            var modelBuilder3 = model1.asBuilder
+            modelBuilder3.groupAccess = .allAccess
+            let model3 = try modelBuilder3.build(transaction: transaction)
+
+            let dmToken = defaultDMToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model1,
+                                                      newGroupModel: model2,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model2,
+                                                      newGroupModel: model3,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model3,
+                                                      newGroupModel: model1,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            guard groupsVersion == .V2 else {
+                return
+            }
+
+            insertOutgoingMessage(prefix + "role changes.")
+
+            var members = [localAddress, otherAddress0, randoAddress ]
+            if let updaterAddress = updaterAddress {
+                members.append(updaterAddress)
+            }
+            members = Array(Set(members)).shuffled()
+
+            var modelBuilder1 = defaultModel.asBuilder
+            var groupMembershipBuilder1 = defaultModel.groupMembership.asBuilder
+            for member in members {
+                groupMembershipBuilder1.remove(member)
+                groupMembershipBuilder1.addNonPendingMember(member, role: .normal)
+            }
+            modelBuilder1.groupMembership = groupMembershipBuilder1.build()
+            let model1 = try modelBuilder1.build(transaction: transaction)
+
+            var modelBuilder2 = defaultModel.asBuilder
+            var groupMembershipBuilder2 = defaultModel.groupMembership.asBuilder
+            for member in members {
+                groupMembershipBuilder2.remove(member)
+                groupMembershipBuilder2.addNonPendingMember(member, role: .administrator)
+            }
+            modelBuilder2.groupMembership = groupMembershipBuilder2.build()
+            let model2 = try modelBuilder2.build(transaction: transaction)
+
+            let dmToken = defaultDMToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model1,
+                                                      newGroupModel: model2,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model2,
+                                                      newGroupModel: model1,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            guard groupsVersion == .V2 else {
+                return
+            }
+
+            insertOutgoingMessage(prefix + "basic membership changes.")
+
+            var members = [localAddress, otherAddress0 ]
+            if let updaterAddress = updaterAddress {
+                members.append(updaterAddress)
+            }
+            members = Array(Set(members)).shuffled()
+
+            var modelBuilder1 = defaultModel.asBuilder
+            modelBuilder1.groupMembership = GroupMembership()
+            let model1 = try modelBuilder1.build(transaction: transaction)
+
+            var modelBuilder2 = defaultModel.asBuilder
+            var groupMembershipBuilder2 = defaultModel.groupMembership.asBuilder
+            for member in members {
+                groupMembershipBuilder2.remove(member)
+                groupMembershipBuilder2.addNonPendingMember(member, role: .administrator)
+            }
+            modelBuilder2.groupMembership = groupMembershipBuilder2.build()
+            let model2 = try modelBuilder2.build(transaction: transaction)
+
+            let dmToken = defaultDMToken
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model1,
+                                                      newGroupModel: model2,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+
+            GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                      oldGroupModel: model2,
+                                                      newGroupModel: model1,
+                                                      oldDisappearingMessageToken: dmToken,
+                                                      newDisappearingMessageToken: dmToken,
+                                                      groupUpdateSourceAddress: updaterAddress,
+                                                      transaction: transaction)
+        }
+
+        do {
+            guard groupsVersion == .V2 else {
+                return
+            }
+            guard !isAnonymousUpdate else {
+                return
+            }
+
+            insertOutgoingMessage(prefix + "invite variations.")
+
+            var members = [localAddress, otherAddress0, otherAddress1 ]
+            var inviters = [localAddress, otherAddress0 ]
+            if let updaterAddress = updaterAddress {
+                members.append(updaterAddress)
+                inviters.append(updaterAddress)
+            }
+            members = Array(Set(members)).shuffled()
+            inviters = Array(Set(inviters)).shuffled()
+
+            for inviter in inviters {
+                guard let inviterUuid = inviter.uuid else {
+                    continue
+                }
+
+                // Model 1: Empty.
+                var modelBuilder1 = defaultModel.asBuilder
+                modelBuilder1.groupMembership = GroupMembership()
+                let model1 = try modelBuilder1.build(transaction: transaction)
+
+                // Model 2: Invited.
+                var modelBuilder2 = defaultModel.asBuilder
+                var groupMembershipBuilder2 = defaultModel.groupMembership.asBuilder
+                for member in members {
+                    groupMembershipBuilder2.remove(member)
+                    groupMembershipBuilder2.addPendingMember(member, role: .normal, addedByUuid: inviterUuid)
+                }
+                modelBuilder2.groupMembership = groupMembershipBuilder2.build()
+                let model2 = try modelBuilder2.build(transaction: transaction)
+
+                // Model 3: Active members.
+                var modelBuilder3 = defaultModel.asBuilder
+                var groupMembershipBuilder3 = defaultModel.groupMembership.asBuilder
+                for member in members {
+                    groupMembershipBuilder3.remove(member)
+                    groupMembershipBuilder3.addNonPendingMember(member, role: .administrator)
+                }
+                modelBuilder3.groupMembership = groupMembershipBuilder3.build()
+                let model3 = try modelBuilder3.build(transaction: transaction)
+
+                let dmToken = defaultDMToken
+
+                // Invite: 1 -> 2
+                GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                          oldGroupModel: model1,
+                                                          newGroupModel: model2,
+                                                          oldDisappearingMessageToken: dmToken,
+                                                          newDisappearingMessageToken: dmToken,
+                                                          groupUpdateSourceAddress: updaterAddress,
+                                                          transaction: transaction)
+
+                // Invite Accepted: 2 -> 3
+                GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                          oldGroupModel: model2,
+                                                          newGroupModel: model3,
+                                                          oldDisappearingMessageToken: dmToken,
+                                                          newDisappearingMessageToken: dmToken,
+                                                          groupUpdateSourceAddress: updaterAddress,
+                                                          transaction: transaction)
+
+                // Invite Declined or Revoked: 2 -> 1
+                GroupManager.insertGroupUpdateInfoMessage(groupThread: groupThread,
+                                                          oldGroupModel: model2,
+                                                          newGroupModel: model1,
+                                                          oldDisappearingMessageToken: dmToken,
+                                                          newDisappearingMessageToken: dmToken,
+                                                          groupUpdateSourceAddress: updaterAddress,
+                                                          transaction: transaction)
+            }
+        }
+    }
+}
+
+#endif
diff --git a/Signal/src/ViewControllers/DebugUI/DebugUITableViewController.m b/Signal/src/ViewControllers/DebugUI/DebugUITableViewController.m
index ead0f9d9987..8c72c4fac97 100644
--- a/Signal/src/ViewControllers/DebugUI/DebugUITableViewController.m
+++ b/Signal/src/ViewControllers/DebugUI/DebugUITableViewController.m
@@ -1,5 +1,5 @@
 //
-//  Copyright (c) 2019 Open Whisper Systems. All rights reserved.
+//  Copyright (c) 2020 Open Whisper Systems. All rights reserved.
 //
 
 #import "DebugUITableViewController.h"
@@ -123,6 +123,9 @@ + (void)presentDebugUIForThread:(TSThread *)thread fromViewController:(UIViewCon
     [subsectionItems addObject:dataStoreItem];
     [subsectionItems
         addObject:[self itemForSubsection:[DebugUIBackup new] viewController:viewController thread:thread]];
+    [subsectionItems addObject:[self itemForSubsection:[DebugUIGroupsV2 new]
+                                        viewController:viewController
+                                                thread:thread]];
     [subsectionItems addObject:[self itemForSubsection:[DebugUIMisc new] viewController:viewController thread:thread]];
 
     [contents addSection:[OWSTableSection sectionWithTitle:@"Sections" items:subsectionItems]];
@@ -149,6 +152,7 @@ + (void)presentDebugUIFromViewController:(UIViewController *)fromViewController
     [subsectionItems
         addObject:[self itemForSubsection:[DebugUISyncMessages new] viewController:viewController thread:nil]];
     [subsectionItems addObject:[self itemForSubsection:[DebugUIBackup new] viewController:viewController thread:nil]];
+    [subsectionItems addObject:[self itemForSubsection:[DebugUIGroupsV2 new] viewController:viewController thread:nil]];
     [subsectionItems addObject:[self itemForSubsection:[DebugUIMisc new] viewController:viewController thread:nil]];
     [contents addSection:[OWSTableSection sectionWithTitle:@"Sections" items:subsectionItems]];
 
diff --git a/SignalServiceKit/src/Messages/Interactions/TSInfoMessage+GroupUpdateCopy.swift b/SignalServiceKit/src/Messages/Interactions/TSInfoMessage+GroupUpdateCopy.swift
index 510e84774a1..d461d2c4595 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSInfoMessage+GroupUpdateCopy.swift
+++ b/SignalServiceKit/src/Messages/Interactions/TSInfoMessage+GroupUpdateCopy.swift
@@ -35,6 +35,7 @@ struct GroupUpdateCopy {
         case accessAttributes
         case disappearingMessagesState
         case generic
+        case debug
     }
 
     // MARK: -
@@ -59,7 +60,11 @@ struct GroupUpdateCopy {
     let transaction: SDSAnyReadTransaction
 
     // The update items, in order.
-    private var itemMap = OrderedDictionary<UpdateItem, String>()
+    private var itemCopyList = [String]()
+    // We use this set to check for duplicate/conflicting items.
+    // It will not affect production UI, but yield asserts in
+    // debug builds and logging in production.
+    private var itemSet = Set<UpdateItem>()
 
     init(newGroupModel: TSGroupModel,
          oldGroupModel: TSGroupModel?,
@@ -79,7 +84,11 @@ struct GroupUpdateCopy {
         switch updater {
         case .unknown:
             if newGroupModel.groupsVersion == .V2 {
-                owsFailDebug("Missing inviter info.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("Missing updater info.")
+                } else {
+                    addItem(.debug, copy: "Error: Missing updater info.")
+                }
             }
         default:
             break
@@ -92,9 +101,9 @@ struct GroupUpdateCopy {
 
     // MARK: -
 
-    func populate(oldGroupModel: TSGroupModel?,
-                  oldDisappearingMessageToken: DisappearingMessageToken?,
-                  newDisappearingMessageToken: DisappearingMessageToken?) {
+    mutating func populate(oldGroupModel: TSGroupModel?,
+                           oldDisappearingMessageToken: DisappearingMessageToken?,
+                           newDisappearingMessageToken: DisappearingMessageToken?) {
 
         if let oldGroupModel = oldGroupModel {
             let oldGroupMembership = oldGroupModel.groupMembership
@@ -117,9 +126,13 @@ struct GroupUpdateCopy {
                                           newToken: newDisappearingMessageToken)
         }
 
-        if itemMap.count < 1 {
+        if itemCopyList.count < 1 {
             if newGroupModel.groupsVersion == .V2 {
-                owsFailDebug("Group update without any items.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("Group update without any items.")
+                } else {
+                    addItem(.debug, copy: "Error: Group update without any items.")
+                }
             }
             addItem(.generic, copy: defaultGroupUpdateDescription)
         }
@@ -127,30 +140,29 @@ struct GroupUpdateCopy {
 
     // MARK: -
 
-    func addItem(_ type: UpdateType,
-                 address: SignalServiceAddress? = nil,
-                 copy: String) {
+    mutating func addItem(_ type: UpdateType,
+                          address: SignalServiceAddress? = nil,
+                          copy: String) {
         let item = UpdateItem(type: type,
                               address: address)
-        assert(itemMap.value(forKey: item) == nil)
-        itemMap.append(key: item, value: copy)
+        if itemSet.contains(item),
+            item.type != .debug {
+            Logger.verbose("item: \(item)")
+            owsFailDebug("Duplicate items.")
+        }
+        itemSet.insert(item)
+        itemCopyList.append(copy)
     }
 
-    func addItem(_ type: UpdateType,
-                 address: SignalServiceAddress? = nil,
-                 format: String, _ formatArgs: CVarArg...) {
+    mutating func addItem(_ type: UpdateType,
+                          address: SignalServiceAddress? = nil,
+                          format: String, _ formatArgs: CVarArg...) {
         let copy = String(format: format, arguments: formatArgs)
         addItem(type, address: address, copy: copy)
     }
 
     var updateDescription: String {
-        var lines = [String]()
-
-        for (_, copy) in itemMap {
-            lines.append(copy)
-        }
-
-        return lines.joined(separator: "\n")
+        return itemCopyList.joined(separator: "\n")
     }
 
     func wasUpdaterSameAs(_ address: SignalServiceAddress) -> Bool {
@@ -203,7 +215,7 @@ extension GroupUpdateCopy {
 
     // MARK: - Attributes
 
-    func addAttributesUpdates(oldGroupModel: TSGroupModel) {
+    mutating func addAttributesUpdates(oldGroupModel: TSGroupModel) {
 
         let groupName = { (groupModel: TSGroupModel) -> String? in
             if let name = groupModel.groupName?.stripped, name.count > 0 {
@@ -278,10 +290,14 @@ extension GroupUpdateCopy {
 
     // MARK: - Access
 
-    func description(for access: GroupV2Access) -> String {
+    mutating func description(for access: GroupV2Access) -> String {
         switch access {
         case .unknown:
-            owsFailDebug("Unknown access level.")
+            if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                owsFailDebug("Unknown access level.")
+            } else {
+                addItem(.debug, copy: "Error: Unknown access level.")
+            }
             return NSLocalizedString("GROUP_ACCESS_LEVEL_UNKNOWN",
                                      comment: "Description of the 'unknown' access level.")
         case .any:
@@ -296,7 +312,7 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addAccessUpdates(oldGroupModel: TSGroupModel) {
+    mutating func addAccessUpdates(oldGroupModel: TSGroupModel) {
 
         let oldAccess = oldGroupModel.groupAccess
         let newAccess = newGroupModel.groupAccess
@@ -352,7 +368,7 @@ extension GroupUpdateCopy {
         var inviteRevokedCount: UInt = 0
     }
 
-    func addMembershipUpdates(oldGroupMembership: GroupMembership) {
+    mutating func addMembershipUpdates(oldGroupMembership: GroupMembership) {
         var membershipCounts = MembershipCounts()
 
         let allUsers = oldGroupMembership.allUsers.union(newGroupMembership.allUsers)
@@ -368,7 +384,11 @@ extension GroupUpdateCopy {
                     // Check for role changes.
                     addMemberRoleUpdates(for: address, oldGroupMembership: oldGroupMembership)
                 case .invited:
-                    owsFailDebug("Invalid membership status transition: \(oldMembershipStatus) -> \(newMembershipStatus).")
+                    if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                        owsFailDebug("Invalid membership status transition: \(oldMembershipStatus) -> \(newMembershipStatus).")
+                    } else {
+                        addItem(.debug, copy: "Error: Invalid membership status transition: \(oldMembershipStatus) -> \(newMembershipStatus).")
+                    }
                     break
                 case .none:
                     addUserLeftOrWasKickedOutOfGroup(for: address)
@@ -406,8 +426,8 @@ extension GroupUpdateCopy {
         addUnnamedUserInvitesWereRevoked(count: membershipCounts.inviteRevokedCount)
     }
 
-    func addMemberRoleUpdates(for address: SignalServiceAddress,
-                              oldGroupMembership: GroupMembership) {
+    mutating func addMemberRoleUpdates(for address: SignalServiceAddress,
+                                       oldGroupMembership: GroupMembership) {
 
         let oldIsAdministrator = oldGroupMembership.isAdministrator(address)
         let newIsAdministrator = newGroupMembership.isAdministrator(address)
@@ -424,19 +444,27 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserWasGrantedAdministrator(for address: SignalServiceAddress) {
+    mutating func addUserWasGrantedAdministrator(for address: SignalServiceAddress) {
         let isLocalUser = localAddress == address
         if isLocalUser {
             switch updater {
             case .localUser:
-                owsFailDebug("Local user made themself administrator.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("Local user made themself administrator.")
+                } else {
+                    addItem(.debug, copy: "Error: Local user made themself administrator.")
+                }
                 addItem(.userRole,
                         address: address,
                         copy: NSLocalizedString("GROUP_LOCAL_USER_GRANTED_ADMINISTRATOR",
                                                 comment: "Message indicating that the local user was granted administrator role."))
             case .otherUser(let updaterName, let updaterAddress):
                 if updaterAddress == address {
-                    owsFailDebug("Remote user made themself administrator.")
+                    if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                        owsFailDebug("Remote user made themself administrator.")
+                    } else {
+                        addItem(.debug, copy: "Error: Remote user made themself administrator.")
+                    }
                     addItem(.userRole,
                             address: address,
                             copy: NSLocalizedString("GROUP_LOCAL_USER_GRANTED_ADMINISTRATOR",
@@ -466,7 +494,11 @@ extension GroupUpdateCopy {
                         format: format, userName)
             case .otherUser(let updaterName, let updaterAddress):
                 if updaterAddress == address {
-                    owsFailDebug("Remote user made themself administrator.")
+                    if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                        owsFailDebug("Remote user made themself administrator.")
+                    } else {
+                        addItem(.debug, copy: "Error: Remote user made themself administrator.")
+                    }
                     let format = NSLocalizedString("GROUP_REMOTE_USER_GRANTED_ADMINISTRATOR",
                                                    comment: "Message indicating that a remote user was granted administrator role. Embeds {{remote user name}}.")
                     addItem(.userRole,
@@ -489,7 +521,7 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserWasRevokedAdministrator(for address: SignalServiceAddress) {
+    mutating func addUserWasRevokedAdministrator(for address: SignalServiceAddress) {
         let isLocalUser = localAddress == address
         if isLocalUser {
             switch updater {
@@ -551,7 +583,7 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserLeftOrWasKickedOutOfGroup(for address: SignalServiceAddress) {
+    mutating func addUserLeftOrWasKickedOutOfGroup(for address: SignalServiceAddress) {
 
         let isLocalUser = localAddress == address
         if isLocalUser {
@@ -608,8 +640,8 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserInviteWasAccepted(for address: SignalServiceAddress,
-                                  oldGroupMembership: GroupMembership) {
+    mutating func addUserInviteWasAccepted(for address: SignalServiceAddress,
+                                           oldGroupMembership: GroupMembership) {
 
         var inviterName: String?
         var inviterAddress: SignalServiceAddress?
@@ -630,14 +662,22 @@ extension GroupUpdateCopy {
                             address: address,
                             format: format, inviterName)
                 } else {
-                    owsFailDebug("Missing inviter name.")
+                    if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                        owsFailDebug("Missing inviter name.")
+                    } else {
+                        addItem(.debug, copy: "Error: Missing inviter name.")
+                    }
                     addItem(.userMembershipState,
                             address: address,
                             copy: NSLocalizedString("GROUP_LOCAL_USER_INVITE_ACCEPTED",
                                                     comment: "Message indicating that the local user accepted an invite to the group."))
                 }
             case .otherUser(let updaterName, _):
-                owsFailDebug("Invite accepted on our behalf.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("Invite accepted on our behalf.")
+                } else {
+                    addItem(.debug, copy: "Error: Invite accepted on our behalf.")
+                }
                 let format = NSLocalizedString("GROUP_LOCAL_USER_ADDED_TO_GROUP_BY_REMOTE_USER_FORMAT",
                                                comment: "Message indicating that the local user was added to the group by another user. Embeds {{remote user name}}.")
                 addItem(.userMembershipState,
@@ -654,7 +694,11 @@ extension GroupUpdateCopy {
 
             switch updater {
             case .localUser:
-                owsFailDebug("Invite not accepted by invitee.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("Invite not accepted by invitee.")
+                } else {
+                    addItem(.debug, copy: "Error: Invite not accepted by invitee.")
+                }
                 let format = NSLocalizedString("GROUP_REMOTE_USER_ADDED_TO_GROUP_BY_LOCAL_USER_FORMAT",
                                                comment: "Message indicating that a remote user was added to the group by the local user. Embeds {{remote user name}}.")
                 addItem(.userMembershipState,
@@ -675,7 +719,11 @@ extension GroupUpdateCopy {
                                 address: address,
                                 format: format, updaterName, inviterName)
                     } else {
-                        owsFailDebug("Missing inviter name.")
+                        if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                            owsFailDebug("Missing inviter name.")
+                        } else {
+                            addItem(.debug, copy: "Error: Missing inviter name.")
+                        }
                         let format = NSLocalizedString("GROUP_REMOTE_USER_ACCEPTED_INVITE_FORMAT",
                                                        comment: "Message indicating that a remote user has accepted their invite. Embeds {{remote user name}}.")
                         addItem(.userMembershipState,
@@ -683,7 +731,11 @@ extension GroupUpdateCopy {
                                 format: format, updaterName)
                     }
                 } else {
-                    owsFailDebug("Invite accepted by someone other than invitee.")
+                    if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                        owsFailDebug("Invite accepted by someone other than invitee.")
+                    } else {
+                        addItem(.debug, copy: "Error: Invite accepted by someone other than invitee.")
+                    }
                     let format = NSLocalizedString("GROUP_REMOTE_USER_ADDED_TO_GROUP_BY_REMOTE_USER_FORMAT",
                                                    comment: "Message indicating that a remote user was added to the group by another user. Embeds {{ %1$@ user who added the user, %2$@ user who was added}}.")
                     addItem(.userMembershipState,
@@ -700,9 +752,9 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserInviteWasDeclinedOrRevoked(for address: SignalServiceAddress,
-                                           oldGroupMembership: GroupMembership,
-                                           membershipCounts: inout MembershipCounts) {
+    mutating func addUserInviteWasDeclinedOrRevoked(for address: SignalServiceAddress,
+                                                    oldGroupMembership: GroupMembership,
+                                                    membershipCounts: inout MembershipCounts) {
 
         var inviterName: String?
         var inviterAddress: SignalServiceAddress?
@@ -723,14 +775,17 @@ extension GroupUpdateCopy {
                             address: address,
                             format: format, inviterName)
                 } else {
-                    owsFailDebug("Missing inviter name.")
+                    if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                        owsFailDebug("Missing inviter name.")
+                    } else {
+                        addItem(.debug, copy: "Error: Missing inviter name.")
+                    }
                     addItem(.userMembershipState,
                             address: address,
                             copy: NSLocalizedString("GROUP_LOCAL_USER_INVITE_DECLINED_BY_LOCAL_USER",
                                                     comment: "Message indicating that the local user declined an invite to the group."))
                 }
             case .otherUser(let updaterName, _):
-                owsFailDebug("Invite revoked.")
                 let format = NSLocalizedString("GROUP_LOCAL_USER_INVITE_REVOKED_BY_REMOTE_USER_FORMAT",
                                                comment: "Message indicating that the local user's invite was revoked by another user. Embeds {{remote user name}}.")
                 addItem(.userMembershipState,
@@ -781,7 +836,7 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUnnamedUserInvitesWereRevoked(count: UInt) {
+    mutating func addUnnamedUserInvitesWereRevoked(count: UInt) {
         guard count > 0 else {
             return
         }
@@ -789,7 +844,11 @@ extension GroupUpdateCopy {
 
         switch updater {
         case .localUser:
-            owsFailDebug("Unexpected updater.")
+            if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                owsFailDebug("Unexpected updater.")
+            } else {
+                addItem(.debug, copy: "Error: Unexpected updater.")
+            }
         case .otherUser(let updaterName, _):
             if count == 1 {
                 let format = NSLocalizedString("GROUP_REMOTE_USER_INVITE_REVOKED_BY_REMOTE_USER_1_FORMAT",
@@ -816,13 +875,17 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserWasAddedToTheGroup(for address: SignalServiceAddress) {
+    mutating func addUserWasAddedToTheGroup(for address: SignalServiceAddress) {
 
         let isLocalUser = localAddress == address
         if isLocalUser {
             switch updater {
             case .localUser:
-                owsFailDebug("User added themself to the group.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("User added themself to the group.")
+                } else {
+                    addItem(.debug, copy: "Error: User added themself to the group.")
+                }
                 addItem(.userMembershipState,
                         address: address,
                         copy: NSLocalizedString("GROUP_LOCAL_USER_JOINED_THE_GROUP",
@@ -852,7 +915,11 @@ extension GroupUpdateCopy {
             case .otherUser(let updaterName, let updaterAddress):
                 if address == updaterAddress {
                     if newGroupModel.groupsVersion == .V2 {
-                        owsFailDebug("Remote user added themself to the group.")
+                        if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                            owsFailDebug("Remote user added themself to the group.")
+                        } else {
+                            addItem(.debug, copy: "Error: Remote user added themself to the group.")
+                        }
                     }
                     let format = NSLocalizedString("GROUP_REMOTE_USER_ADDED_TO_GROUP_FORMAT",
                                                    comment: "Message indicating that a remote user was added to the group. Embeds {{remote user name}}.")
@@ -876,14 +943,18 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUserWasInvitedToTheGroup(for address: SignalServiceAddress,
-                                     membershipCounts: inout MembershipCounts) {
+    mutating func addUserWasInvitedToTheGroup(for address: SignalServiceAddress,
+                                              membershipCounts: inout MembershipCounts) {
 
         let isLocalUser = localAddress == address
         if isLocalUser {
             switch updater {
             case .localUser:
-                owsFailDebug("User invited themself to the group.")
+                if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                    owsFailDebug("User invited themself to the group.")
+                } else {
+                    addItem(.debug, copy: "Error: User invited themself to the group.")
+                }
                 addItem(.userMembershipState,
                         address: address,
                         copy: NSLocalizedString("GROUP_LOCAL_USER_INVITED_TO_THE_GROUP",
@@ -916,7 +987,7 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addUnnamedUsersWereInvited(count: UInt) {
+    mutating func addUnnamedUsersWereInvited(count: UInt) {
         guard count > 0 else {
             return
         }
@@ -924,13 +995,17 @@ extension GroupUpdateCopy {
 
         switch updater {
         case .localUser:
-            owsFailDebug("Unexpected updater.")
+            if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                owsFailDebug("Unexpected updater.")
+            } else {
+                addItem(.debug, copy: "Error: Unexpected updater.")
+            }
         case .otherUser(let updaterName, _):
             if count == 1 {
                 let format = NSLocalizedString("GROUP_REMOTE_USER_INVITED_BY_REMOTE_USER_1_FORMAT",
-                                                comment: "Message indicating that a single remote user was invited to the group by the local user. Embeds {{ user who invited the user }}.")
-                    addItem(.userMembershipState_invitesNew,
-                            format: format, updaterName, countString)
+                                               comment: "Message indicating that a single remote user was invited to the group by the local user. Embeds {{ user who invited the user }}.")
+                addItem(.userMembershipState_invitesNew,
+                        format: format, updaterName, countString)
             } else {
                 let format = NSLocalizedString("GROUP_REMOTE_USER_INVITED_BY_REMOTE_USER_N_FORMAT",
                                                comment: "Message indicating that a group of remote users were invited to the group by the local user. Embeds {{ %1$@ user who invited the user, %2$@ number of invited users }}.")
@@ -953,8 +1028,8 @@ extension GroupUpdateCopy {
 
     // MARK: - Disappearing Messages
 
-    func addDisappearingMessageUpdates(oldToken: DisappearingMessageToken?,
-                                       newToken: DisappearingMessageToken?) {
+    mutating func addDisappearingMessageUpdates(oldToken: DisappearingMessageToken?,
+                                                newToken: DisappearingMessageToken?) {
 
         guard let newToken = newToken else {
             // This info message was created before we embedded DM state.
@@ -1014,7 +1089,7 @@ extension GroupUpdateCopy {
         }
     }
 
-    func addGroupWasInserted() {
+    mutating func addGroupWasInserted() {
         guard newGroupModel.groupsVersion == .V2 else {
             // Group was just upserted.
             switch updater {
@@ -1068,7 +1143,11 @@ extension GroupUpdateCopy {
                     copy: NSLocalizedString("GROUP_LOCAL_USER_INVITED_TO_THE_GROUP",
                                             comment: "Message indicating that the local user was invited to the group."))
         case .none:
-            owsFailDebug("Learned of group without any membership status.")
+            if !DebugFlags.permissiveGroupUpdateInfoMessages {
+                owsFailDebug("Learned of group without any membership status.")
+            } else {
+                addItem(.debug, copy: "Error: Learned of group without any membership status.")
+            }
         }
     }
 
@@ -1124,13 +1203,13 @@ extension GroupUpdateCopy {
 
     var defaultGroupUpdateDescription: String {
         return GroupUpdateCopy.defaultGroupUpdateDescription(groupUpdateSourceAddress: groupUpdateSourceAddress,
-                                                         transaction: transaction)
+                                                             transaction: transaction)
     }
 
     static func defaultGroupUpdateDescription(groupUpdateSourceAddress: SignalServiceAddress?,
                                               transaction: SDSAnyReadTransaction) -> String {
         let updater = GroupUpdateCopy.updater(groupUpdateSourceAddress: groupUpdateSourceAddress,
-        transaction: transaction)
+                                              transaction: transaction)
         switch updater {
         case .localUser:
             return NSLocalizedString("GROUP_UPDATED_BY_LOCAL_USER",
diff --git a/SignalServiceKit/src/Util/FeatureFlags.swift b/SignalServiceKit/src/Util/FeatureFlags.swift
index 355d2ae2e5f..6a730ef0007 100644
--- a/SignalServiceKit/src/Util/FeatureFlags.swift
+++ b/SignalServiceKit/src/Util/FeatureFlags.swift
@@ -291,4 +291,10 @@ public class DebugFlags: NSObject {
     // * Places we make requests using tasks.
     @objc
     public static let logCurlOnSuccess = false
+
+    // Our "group update" info messages should be robust to
+    // various situations that shouldn't occur in production,
+    // bug we want to be able to test them using the debug UI.
+    @objc
+    public static let permissiveGroupUpdateInfoMessages = build.includes(.dev)
 }
diff --git a/SignalServiceKit/src/groups/GroupAccess.swift b/SignalServiceKit/src/groups/GroupAccess.swift
index 878be63b7f8..9c3c5aee8b0 100644
--- a/SignalServiceKit/src/groups/GroupAccess.swift
+++ b/SignalServiceKit/src/groups/GroupAccess.swift
@@ -65,15 +65,20 @@ public class GroupAccess: MTLModel {
     }
 
     @objc
-    public static var defaultV2Access: GroupAccess {
-        return GroupAccess(members: .member, attributes: .member)
+    public static var adminOnly: GroupAccess {
+        return GroupAccess(members: .administrator, attributes: .administrator)
     }
 
     @objc
-    public static var forV1: GroupAccess {
+    public static var defaultForV1: GroupAccess {
         return allAccess
     }
 
+    @objc
+    public static var defaultForV2: GroupAccess {
+        return GroupAccess(members: .member, attributes: .member)
+    }
+
     public class func groupV2Access(forProtoAccess value: GroupsProtoAccessControlAccessRequired) -> GroupV2Access {
         switch value {
         case .any:
diff --git a/SignalServiceKit/src/groups/GroupManager.swift b/SignalServiceKit/src/groups/GroupManager.swift
index 593d35eea8d..8d669a6946b 100644
--- a/SignalServiceKit/src/groups/GroupManager.swift
+++ b/SignalServiceKit/src/groups/GroupManager.swift
@@ -233,7 +233,7 @@ public class GroupManager: NSObject {
             }
         }.map(on: .global()) { (proposedGroupMembership: GroupMembership) throws -> TSGroupModel in
             // GroupsV2 TODO: Let users specify access levels in the "new group" view.
-            let groupAccess = GroupAccess.defaultV2Access
+            let groupAccess = GroupAccess.defaultForV2
             let groupModel = try self.databaseStorage.read { (transaction) throws -> TSGroupModel in
                 // Before we create a v2 group, we need to separate out the
                 // pending and non-pending members.  If we already know we're
@@ -598,7 +598,6 @@ public class GroupManager: NSObject {
                                                groupMembership: groupMembership,
                                                dmConfiguration: nil,
                                                transaction: transaction)
-
         } catch GroupsV2Error.redundantChange {
             guard let groupThread = TSGroupThread.fetch(groupId: groupId, transaction: transaction) else {
                 throw OWSAssertionError("Missing groupThread.")
@@ -1380,13 +1379,16 @@ public class GroupManager: NSObject {
         return UpsertGroupResult(action: .updated, groupThread: groupThread)
     }
 
-    private static func insertGroupUpdateInfoMessage(groupThread: TSGroupThread,
-                                                     oldGroupModel: TSGroupModel?,
-                                                     newGroupModel: TSGroupModel,
-                                                     oldDisappearingMessageToken: DisappearingMessageToken?,
-                                                     newDisappearingMessageToken: DisappearingMessageToken,
-                                                     groupUpdateSourceAddress: SignalServiceAddress?,
-                                                     transaction: SDSAnyWriteTransaction) {
+    // MARK: - Group Update Info Messages
+
+    // NOTE: This should only be called by GroupManager and by DebugUI.
+    public static func insertGroupUpdateInfoMessage(groupThread: TSGroupThread,
+                                                    oldGroupModel: TSGroupModel?,
+                                                    newGroupModel: TSGroupModel,
+                                                    oldDisappearingMessageToken: DisappearingMessageToken?,
+                                                    newDisappearingMessageToken: DisappearingMessageToken,
+                                                    groupUpdateSourceAddress: SignalServiceAddress?,
+                                                    transaction: SDSAnyWriteTransaction) {
 
         var userInfo: [InfoMessageUserInfoKey: Any] = [
             .newGroupModel: newGroupModel,
diff --git a/SignalServiceKit/src/groups/TSGroupModel.m b/SignalServiceKit/src/groups/TSGroupModel.m
index 7567df357f5..2d53cbd763d 100644
--- a/SignalServiceKit/src/groups/TSGroupModel.m
+++ b/SignalServiceKit/src/groups/TSGroupModel.m
@@ -98,7 +98,7 @@ - (GroupMembership *)groupMembership
 
 - (GroupAccess *)groupAccess
 {
-    return GroupAccess.forV1;
+    return GroupAccess.defaultForV1;
 }
 
 - (uint32_t)groupV2Revision
diff --git a/SignalServiceKit/src/groups/TSGroupModel.swift b/SignalServiceKit/src/groups/TSGroupModel.swift
index 24e009b836e..f5775d7f5a7 100644
--- a/SignalServiceKit/src/groups/TSGroupModel.swift
+++ b/SignalServiceKit/src/groups/TSGroupModel.swift
@@ -32,7 +32,7 @@ public class TSGroupModelV2: TSGroupModel {
     @objc
     var membership: GroupMembership = GroupMembership.empty
     @objc
-    var access: GroupAccess = .defaultV2Access
+    var access: GroupAccess = .defaultForV2
     @objc
     var secretParamsData: Data = Data()
     @objc
diff --git a/SignalServiceKit/src/groups/TSGroupModelBuilder.swift b/SignalServiceKit/src/groups/TSGroupModelBuilder.swift
index e81a79c69d4..43fcc3ec136 100644
--- a/SignalServiceKit/src/groups/TSGroupModelBuilder.swift
+++ b/SignalServiceKit/src/groups/TSGroupModelBuilder.swift
@@ -70,6 +70,9 @@ public struct TSGroupModelBuilder {
 
         switch groupsVersion {
         case .V1:
+            if groupMembership.pendingMembers.count > 0 {
+                owsFailDebug("v1 group has pending members.")
+            }
             return TSGroupModel(groupId: groupId,
                                 name: name,
                                 avatarData: avatarData,
@@ -126,9 +129,9 @@ public struct TSGroupModelBuilder {
 
         switch groupsVersion {
         case .V1:
-            return GroupAccess.forV1
+            return GroupAccess.defaultForV1
         case .V2:
-            return GroupAccess.defaultV2Access
+            return GroupAccess.defaultForV2
         }
     }
 
