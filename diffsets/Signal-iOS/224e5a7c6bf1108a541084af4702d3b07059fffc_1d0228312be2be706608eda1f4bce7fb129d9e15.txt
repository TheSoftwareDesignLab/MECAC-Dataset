diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index 41d3ed00aac..a2f3f70c287 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -856,6 +856,7 @@
 		667E90D028E799D1005FE603 /* MyStorySettingsLearnMoreSheetViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667E90CF28E799D1005FE603 /* MyStorySettingsLearnMoreSheetViewController.swift */; };
 		667EDE6428F8D6B7001FB487 /* YYAnimatedImage+Duration.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667EDE6328F8D6B7001FB487 /* YYAnimatedImage+Duration.swift */; };
 		667EDE6628FA0372001FB487 /* StoryBadgeCountManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 667EDE6528FA0372001FB487 /* StoryBadgeCountManager.swift */; };
+		66883A3A29D7630A00E898CF /* MessageBodyTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 66883A3829D7630300E898CF /* MessageBodyTests.swift */; };
 		6688E602298232A4004467C8 /* PaymentActionSheets.swift in Sources */ = {isa = PBXBuildFile; fileRef = 6688E601298232A4004467C8 /* PaymentActionSheets.swift */; };
 		668CAB3E289983520085A2C3 /* AudioMessagePlaybackRateView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668CAB3D289983520085A2C3 /* AudioMessagePlaybackRateView.swift */; };
 		668FE09B28B923A4008B9071 /* Bool+SSK.swift in Sources */ = {isa = PBXBuildFile; fileRef = 668FE09A28B923A4008B9071 /* Bool+SSK.swift */; };
@@ -3335,6 +3336,7 @@
 		667E90CF28E799D1005FE603 /* MyStorySettingsLearnMoreSheetViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = MyStorySettingsLearnMoreSheetViewController.swift; sourceTree = "<group>"; };
 		667EDE6328F8D6B7001FB487 /* YYAnimatedImage+Duration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "YYAnimatedImage+Duration.swift"; sourceTree = "<group>"; };
 		667EDE6528FA0372001FB487 /* StoryBadgeCountManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryBadgeCountManager.swift; sourceTree = "<group>"; };
+		66883A3829D7630300E898CF /* MessageBodyTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MessageBodyTests.swift; sourceTree = "<group>"; };
 		6688E601298232A4004467C8 /* PaymentActionSheets.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PaymentActionSheets.swift; sourceTree = "<group>"; };
 		668AB0CB28AD610600B31984 /* StoryUtil.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = StoryUtil.swift; sourceTree = "<group>"; };
 		668CAB3D289983520085A2C3 /* AudioMessagePlaybackRateView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AudioMessagePlaybackRateView.swift; sourceTree = "<group>"; };
@@ -7974,6 +7976,7 @@
 				F9426222289B1B5500460798 /* Stickers */,
 				F9426233289B1B5500460798 /* DeliveryReceiptContextTests.swift */,
 				F925A3AC29493D35009024D0 /* DisappearingMessageFinderTest.swift */,
+				66883A3829D7630300E898CF /* MessageBodyTests.swift */,
 				F942622A289B1B5500460798 /* MessageDecryptionTest.swift */,
 				F942622F289B1B5500460798 /* MessagePipelineSupervisorTest.swift */,
 				F9426234289B1B5500460798 /* MessageProcessingIntegrationTest.swift */,
@@ -12347,6 +12350,7 @@
 				50D5E2432980B53000899660 /* LinkValidatorTest.swift in Sources */,
 				F942625F289B1B5500460798 /* LRUCacheTest.swift in Sources */,
 				F9426269289B1B5500460798 /* MathOWSTests.swift in Sources */,
+				66883A3A29D7630A00E898CF /* MessageBodyTests.swift in Sources */,
 				F9426292289B1B5600460798 /* MessageDecryptionTest.swift in Sources */,
 				F9426297289B1B5600460798 /* MessagePipelineSupervisorTest.swift in Sources */,
 				F942629C289B1B5600460798 /* MessageProcessingIntegrationTest.swift in Sources */,
diff --git a/Signal/test/util/StorySharingTests.swift b/Signal/test/util/StorySharingTests.swift
index c51f2b2820a..5ded4a07b56 100644
--- a/Signal/test/util/StorySharingTests.swift
+++ b/Signal/test/util/StorySharingTests.swift
@@ -35,13 +35,14 @@ class StorySharingTests: SignalBaseTest {
         }
     }
 
+    // TODO[TextFormatting]: test style application as well.
     func testMentionFlattening() {
         let mentionUuid = UUID()
         let range = NSRange(location: 0, length: MessageBody.mentionPlaceholder.utf16.count)
         let output = StorySharing.text(
             for: .init(
                 text: "\(MessageBody.mentionPlaceholder) Some text",
-                ranges: .init(mentions: [range: mentionUuid])
+                ranges: .init(mentions: [range: mentionUuid], styles: [])
             ),
             with: nil
         )
diff --git a/SignalMessaging/Notifications/AppNotifications.swift b/SignalMessaging/Notifications/AppNotifications.swift
index 60c97b74573..c9c23534475 100644
--- a/SignalMessaging/Notifications/AppNotifications.swift
+++ b/SignalMessaging/Notifications/AppNotifications.swift
@@ -677,6 +677,7 @@ public class NotificationPresenter: NSObject, NotificationsProtocol {
 
         let notificationBody: String
         if let bodyDescription: String = {
+            // TODO[TextFormatting]: apply styles for notification
             if let messageBody = message.plaintextBody(with: transaction.unwrapGrdbRead), !messageBody.isEmpty {
                 return messageBody
             } else {
@@ -896,6 +897,7 @@ public class NotificationPresenter: NSObject, NotificationsProtocol {
         case .noNameNoPreview, .nameNoPreview:
             notificationBody = NotificationStrings.genericIncomingMessageNotification
         case .namePreview:
+            // TODO[TextFormatting]: apply styles (except spoiler which gets a special treatment in notifications)
             notificationBody = previewableInteraction.previewText(transaction: transaction)
         }
 
diff --git a/SignalServiceKit/src/Messages/Interactions/TSMessage.m b/SignalServiceKit/src/Messages/Interactions/TSMessage.m
index beb6cef130d..98831248b99 100644
--- a/SignalServiceKit/src/Messages/Interactions/TSMessage.m
+++ b/SignalServiceKit/src/Messages/Interactions/TSMessage.m
@@ -496,6 +496,7 @@ - (NSString *)previewTextWithTransaction:(SDSAnyReadTransaction *)transaction
     }
 
     if (self.bodyRanges) {
+        // TODO[TextFormatting]: apply styles (except spoiler which gets special treatment in notifications)
         bodyDescription = [self.bodyRanges plaintextBodyWithText:bodyDescription
                                                      transaction:transaction.unwrapGrdbRead];
     }
diff --git a/SignalServiceKit/src/Messages/MessageBody.swift b/SignalServiceKit/src/Messages/MessageBody.swift
index da9a68792b5..830de4ba5d2 100644
--- a/SignalServiceKit/src/Messages/MessageBody.swift
+++ b/SignalServiceKit/src/Messages/MessageBody.swift
@@ -7,12 +7,15 @@ import Foundation
 
 @objcMembers
 public class MessageBody: NSObject, NSCopying, NSSecureCoding {
+
+    typealias Style = MessageBodyRanges.Style
+
     public static var supportsSecureCoding = true
     public static let mentionPlaceholder = "\u{FFFC}" // Object Replacement Character
 
     public let text: String
     public let ranges: MessageBodyRanges
-    public var hasRanges: Bool { ranges.hasMentions }
+    public var hasMentions: Bool { ranges.hasMentions }
 
     public init(text: String, ranges: MessageBodyRanges) {
         self.text = text
@@ -43,50 +46,216 @@ public class MessageBody: NSObject, NSCopying, NSSecureCoding {
         coder.encode(ranges, forKey: "ranges")
     }
 
+    // TODO[TextFormatting]: "plaintext" here is misleading; depending on usage we may
+    // want to apply some styles.
     public func plaintextBody(transaction: GRDBReadTransaction) -> String {
-        return ranges.plaintextBody(text: text, transaction: transaction)
+        let hydratedMessageBody = hydratingMentions(hydrator: { mentionUUID in
+            return .hydrate(displayName: Self.contactsManager.displayName(
+                for: SignalServiceAddress(uuid: mentionUUID),
+                transaction: transaction.asAnyRead
+            ))
+        })
+        return (hydratedMessageBody.text as NSString).filterStringForDisplay()
     }
 
     public func forNewContext(
         _ context: TSThread,
         transaction: GRDBReadTransaction
     ) -> MessageBody {
-        guard hasRanges else { return self }
-        guard let groupThread = context as? TSGroupThread, groupThread.isGroupV2Thread else {
-            return MessageBody(text: plaintextBody(transaction: transaction), ranges: .empty)
+        guard hasMentions else {
+            return self
         }
 
-        let mutableText = NSMutableString(string: text)
-        var mentions = [NSRange: UUID]()
+        let isGroupThread: Bool
+        let recipientAddresses: Set<SignalServiceAddress>
+        if let groupThread = context as? TSGroupThread, groupThread.isGroupV2Thread {
+            isGroupThread = true
+            recipientAddresses = Set(groupThread.recipientAddresses(with: transaction.asAnyRead))
+        } else {
+            isGroupThread = false
+            recipientAddresses = .init()
+        }
+
+        return hydratingMentions(hydrator: { mentionUuid in
+            let address = SignalServiceAddress(uuid: mentionUuid)
+            if isGroupThread, recipientAddresses.contains(address) {
+                // We don't want to hydrate for mentions in the destination group;
+                // these can be hydrated on the fly with group member information.
+                // Those not in the group are hydrated with a snapshot of their
+                // contact info that we have; the other group members might not
+                // even know about them.
+                return .preserveMention
+            } else {
+                let displayName = Self.contactsManager.displayName(
+                    for: address,
+                    transaction: transaction.asAnyRead
+                )
+                return .hydrate(displayName: displayName)
+            }
+        })
+    }
+
+    enum HydrationOption {
+        /// Do not hydrate the mention; this leaves the string as it was in the original,
+        /// which we want to do e.g. when forwarding a message with mentions from one
+        /// thread context to another, where we hydrate the mentions of members not in
+        /// the destination, but preserve mentions of shared members fully intact.
+        case preserveMention
+        /// Replace the mention range with the populated display name.
+        case hydrate(displayName: String)
+    }
+
+    internal func hydratingMentions(
+        hydrator: (UUID) -> HydrationOption,
+        isRTL: Bool = CurrentAppContext().isRTL
+    ) -> MessageBody {
+        guard hasMentions else {
+            return self
+        }
+
+        let finalText = NSMutableString(string: text)
+        var finalMentions = [NSRange: UUID]()
+        var finalStyles = [(NSRange, Style)]()
+
+        var mentionsInOriginal = ranges.orderedMentions
+        var stylesInOriginal = ranges.styles
+
         var rangeOffset = 0
 
-        func shouldPreserveMention(_ address: SignalServiceAddress) -> Bool {
-            return groupThread.recipientAddresses(with: transaction.asAnyRead).contains(address)
+        struct ProcessingStyle {
+            let originalRange: NSRange
+            let newRange: NSRange
+            let style: Style
         }
+        var styleAtCurrentIndex: ProcessingStyle?
+
+        let nsString = text as NSString
+        for currentIndex in 0..<nsString.length {
+            // If we are past the end, apply the active style to the final result
+            // and drop.
+            if
+                let style = styleAtCurrentIndex,
+                currentIndex >= style.originalRange.upperBound
+            {
+                finalStyles.append((style.newRange, style.style))
+                styleAtCurrentIndex = nil
+            }
+            // Check for any new styles starting at the current index.
+            if stylesInOriginal.first?.0.contains(currentIndex) == true {
+                let (originalRange, style) = stylesInOriginal.removeFirst()
+                styleAtCurrentIndex = .init(
+                    originalRange: originalRange,
+                    newRange: NSRange(
+                        location: originalRange.location + rangeOffset,
+                        length: originalRange.length
+                    ),
+                    style: style
+                )
+            }
 
-        for (range, uuid) in ranges.orderedMentions {
-            guard range.location >= 0 && range.location + range.length <= (text as NSString).length else {
-                owsFailDebug("Ignoring invalid range in body ranges \(range)")
+            // Check for any mentions at the current index.
+            // Mentions can't overlap, so we don't need a while loop to check for multiple.
+            guard
+                let (originalMentionRange, mentionUuid) = mentionsInOriginal.first,
+                (
+                    originalMentionRange.contains(currentIndex)
+                    || originalMentionRange.location == currentIndex
+                )
+            else {
+                // No mentions, so no additional logic needed, just go to the next index.
                 continue
             }
+            mentionsInOriginal.removeFirst()
 
-            let mentionAddress = SignalServiceAddress(uuid: uuid)
-            let offsetRange = NSRange(location: range.location + rangeOffset, length: range.length)
+            let newMentionRange = NSRange(
+                location: originalMentionRange.location + rangeOffset,
+                length: originalMentionRange.length
+            )
 
-            if shouldPreserveMention(mentionAddress) {
-                mentions[offsetRange] = uuid
-            } else {
-                let displayName = Self.contactsManager.displayName(
-                    for: mentionAddress,
-                    transaction: transaction.asAnyRead
-                )
-                let mentionPlaintext = MessageBodyRanges.mentionPrefix + displayName
-                mutableText.replaceCharacters(in: offsetRange, with: mentionPlaintext)
-                rangeOffset += (mentionPlaintext as NSString).length - range.length
+            switch hydrator(mentionUuid) {
+            case .preserveMention:
+                // Preserve the mention without replacement and proceed.
+                finalMentions[newMentionRange] = mentionUuid
+                continue
+            case .hydrate(let displayName):
+                let mentionPlaintext: String
+                if isRTL {
+                    mentionPlaintext = displayName + MessageBodyRanges.mentionPrefix
+                } else {
+                    mentionPlaintext = MessageBodyRanges.mentionPrefix + displayName
+                }
+                let finalMentionLength = (mentionPlaintext as NSString).length
+                let extraOffset = finalMentionLength - originalMentionRange.length
+                finalText.replaceCharacters(in: newMentionRange, with: mentionPlaintext)
+                rangeOffset += extraOffset
+
+                // We have to adjust style ranges for the active style
+                if let style = styleAtCurrentIndex {
+                    if style.originalRange.upperBound <= originalMentionRange.upperBound {
+                        // If the style ended inside (or right at the end of) the mention,
+                        // it should now end at the end of the replacement text.
+
+                        let finalLength = (newMentionRange.location + finalMentionLength) - style.newRange.location
+                        let finalStyle = (
+                            NSRange(
+                                location: style.newRange.location,
+                                length: finalLength
+                            ),
+                            style.style
+                        )
+                        finalStyles.append(finalStyle)
+
+                        // We are done with it, now.
+                        styleAtCurrentIndex = nil
+                    } else {
+                        // The original style ends past the mention; extend its
+                        // length by the right amount, but keep it in
+                        // the current styles being walked through.
+                        styleAtCurrentIndex = .init(
+                            originalRange: style.originalRange,
+                            newRange: NSRange(
+                                location: style.newRange.location,
+                                length: style.newRange.length + extraOffset
+                            ),
+                            style: style.style
+                        )
+                    }
+                }
             }
         }
 
-        return MessageBody(text: String(mutableText), ranges: MessageBodyRanges(mentions: mentions))
+        if let style = styleAtCurrentIndex {
+            // Styles that ran right to the end (or overran) should be finalized.
+            let finalStyle = (
+                NSRange(
+                    location: style.newRange.location,
+                    length: finalText.length - style.newRange.location
+                ),
+                style.style
+            )
+            finalStyles.append(finalStyle)
+        }
+
+        return MessageBody(
+            text: String(finalText),
+            ranges: MessageBodyRanges(
+                mentions: finalMentions,
+                styles: finalStyles
+            )
+        )
+    }
+
+    override public func isEqual(_ object: Any?) -> Bool {
+        guard let other = object as? MessageBody else {
+            return false
+        }
+        guard text == other.text else {
+            return false
+        }
+        guard ranges == other.ranges else {
+            return false
+        }
+        return true
     }
 }
 
@@ -94,30 +263,83 @@ public class MessageBody: NSObject, NSCopying, NSSecureCoding {
 public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
     public static var supportsSecureCoding = true
     public static let mentionPrefix = "@"
-    public static var empty: MessageBodyRanges { MessageBodyRanges(mentions: [:]) }
+    public static var empty: MessageBodyRanges { MessageBodyRanges(mentions: [:], styles: []) }
 
+    // Styles are kept separate from mentions; mentions are not allowed to overlap,
+    // which is partially enforced by its structure (it enforces they at least can't have
+    // identical ranges) while styles can overlap with each other and
+    // with mentions.
+
+    /// Mentions can overlap with styles but not with each other.
     public let mentions: [NSRange: UUID]
     public var hasMentions: Bool { !mentions.isEmpty }
 
-    // Sorted from lowest location to highest location
-    public var orderedMentions: [(NSRange, UUID)] {
-        mentions.sorted(by: { $0.key.location < $1.key.location })
+    /// Sorted from lowest location to highest location
+    public let orderedMentions: [(NSRange, UUID)]
+
+    public struct Style: OptionSet, Equatable, Hashable {
+        public let rawValue: Int
+
+        public init(rawValue: Int) {
+            self.rawValue = rawValue
+        }
+
+        static let bold = Style(rawValue: 1 << 0)
+        static let italic = Style(rawValue: 1 << 1)
+        static let spoiler = Style(rawValue: 1 << 2)
+        static let strikethrough = Style(rawValue: 1 << 3)
+        static let monospace = Style(rawValue: 1 << 4)
+    }
+
+    /// Sorted from lowest location to highest location.
+    /// Styles can overlap with mentions but not with each other.
+    /// If a style overlaps with _any_ part of a mention, it applies
+    /// to the entire length of the mention.
+    public let styles: [(NSRange, Style)]
+
+    public var hasRanges: Bool {
+        return mentions.isEmpty.negated || styles.isEmpty.negated
     }
 
-    public init(mentions: [NSRange: UUID]) {
+    public init(mentions: [NSRange: UUID], styles: [(NSRange, Style)]) {
         self.mentions = mentions
+        let orderedMentions = mentions.sorted(by: { $0.key.location < $1.key.location })
+        self.orderedMentions = orderedMentions
+        self.styles = Self.processStylesForInitialization(styles, orderedMentions: orderedMentions)
 
         super.init()
     }
 
     public convenience init(protos: [SSKProtoBodyRange]) {
         var mentions = [NSRange: UUID]()
+        var styles = [(NSRange, Style)]()
         for proto in protos {
-            guard let mentionUuidString = proto.mentionUuid, let mentionUuid = UUID(uuidString: mentionUuidString) else { continue }
             let range = NSRange(location: Int(proto.start), length: Int(proto.length))
-            mentions[range] = mentionUuid
+            if
+                let mentionUuidString = proto.mentionUuid,
+                let mentionUuid = UUID(uuidString: mentionUuidString)
+            {
+                mentions[range] = mentionUuid
+            } else if let protoStyle = proto.style {
+                let style: Style
+                switch protoStyle {
+                case .none:
+                    continue
+                case .bold:
+                    style = .bold
+                case .italic:
+                    style = .italic
+                case .spoiler:
+                    style = .spoiler
+                case .strikethrough:
+                    style = .strikethrough
+                case .monospace:
+                    style = .monospace
+                }
+                styles.append((range, style))
+            }
         }
-        self.init(mentions: mentions)
+        self.init(mentions: mentions, styles: styles)
     }
 
     public required init?(coder: NSCoder) {
@@ -137,10 +359,137 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
         }
 
         self.mentions = mentions
+        let orderedMentions = mentions.sorted(by: { $0.key.location < $1.key.location })
+        self.orderedMentions = orderedMentions
+
+        let stylesCount: Int = {
+            let key = "stylesCount"
+            guard coder.containsValue(forKey: key) else {
+                // encoded values from before styles were added
+                // have no styles; that's fine.
+                return 0
+            }
+            return coder.decodeInteger(forKey: key)
+        }()
+
+        var styles = [(NSRange, Style)]()
+        for idx in 0..<stylesCount {
+            guard let range = coder.decodeObject(of: NSValue.self, forKey: "styles.range.\(idx)")?.rangeValue else {
+                owsFailDebug("Failed to decode style range key of MessageBody")
+                return nil
+            }
+            let style = Style(rawValue: coder.decodeInteger(forKey: "styles.style.\(idx)"))
+            styles.append((range, style))
+        }
+
+        self.styles = Self.processStylesForInitialization(styles, orderedMentions: orderedMentions)
+    }
+
+    private static func processStylesForInitialization(
+        _ styles: [(NSRange, Style)],
+        orderedMentions: [(NSRange, UUID)]
+    ) -> [(NSRange, Style)] {
+        guard !styles.isEmpty else {
+            return []
+        }
+        var maxUpperBound = orderedMentions.last?.0.upperBound ?? 0
+        var sortedStyles = styles
+            .lazy
+            .filter { (range, _) in
+                guard range.location >= 0 else {
+                    return false
+                }
+                maxUpperBound = max(maxUpperBound, range.upperBound)
+                return true
+            }
+            .sorted(by: { $0.0.location < $1.0.location })
+        var orderedMentions = orderedMentions
+
+        // Collapse all overlaps.
+        var finalStyles = [(NSRange, Style)]()
+        var collapsedStyleAtIndex: (start: Int, Style) = (start: 0, [])
+        var endIndexToStyle = [Int: Style]()
+        var styleToEndIndex = [Style: Int]()
+        for i in 0..<maxUpperBound {
+            var newStylesToApply: Style = []
+
+            func startApplyingStyles(at index: Int) {
+                while let (newRange, newStyle) = sortedStyles.first, newRange.location == index {
+                    sortedStyles.removeFirst()
+                    newStylesToApply.insert(newStyle)
+
+                    // A new style starts here. But we might overlap with
+                    // a style of the same type, in which case we should
+                    // join them by taking the further of the two endpoints
+                    let oldUpperBound = styleToEndIndex[newStyle]
+                    if newRange.upperBound > (oldUpperBound ?? -1) {
+                        styleToEndIndex[newStyle] = newRange.upperBound
+                        var stylesAtEnd = endIndexToStyle[newRange.upperBound] ?? []
+                        stylesAtEnd.insert(newStyle)
+                        endIndexToStyle[newRange.upperBound] = stylesAtEnd
+                        if let oldUpperBound {
+                            var stylesAtExistingEnd = endIndexToStyle[oldUpperBound] ?? []
+                            stylesAtExistingEnd.remove(newStyle)
+                            endIndexToStyle[oldUpperBound] = stylesAtExistingEnd
+                        }
+                    }
+                }
+            }
+
+            startApplyingStyles(at: i)
+            let stylesToRemove = endIndexToStyle.removeValue(forKey: i) ?? []
+            if stylesToRemove.isEmpty.negated {
+                styleToEndIndex[stylesToRemove] = nil
+            }
+
+            if let mention = orderedMentions.first, mention.0.location == i {
+                orderedMentions.removeFirst()
+                if mention.0.length > 0 {
+                    // Styles always apply to an entire mention. This means when we find
+                    // a mention we have to do two things:
+                    // 1) any styles that start later in the mention are treated as if they start now.
+                    for j in i+1..<mention.0.upperBound {
+                        startApplyingStyles(at: j)
+                    }
+                    // 2) make sure any active styles are extended to the end of the mention
+                    for j in i..<mention.0.upperBound {
+                        if let stylesEndingMidMention = endIndexToStyle.removeValue(forKey: j) {
+                            var stylesAtNewEnd = endIndexToStyle[mention.0.upperBound] ?? []
+                            stylesAtNewEnd.insert(stylesEndingMidMention)
+                            endIndexToStyle[mention.0.upperBound] = stylesAtNewEnd
+                        }
+                    }
+                }
+            }
+
+            if newStylesToApply.isEmpty.negated || stylesToRemove.isEmpty.negated {
+                // We have changes. End the previous style if any, and start a new one.
+                var (startIndex, currentCollapsedStyle) = collapsedStyleAtIndex
+                if currentCollapsedStyle.isEmpty.negated {
+                    finalStyles.append((NSRange(location: startIndex, length: i - startIndex), currentCollapsedStyle))
+                }
+
+                currentCollapsedStyle.remove(stylesToRemove)
+                currentCollapsedStyle.insert(newStylesToApply)
+                collapsedStyleAtIndex = (start: i, currentCollapsedStyle)
+            }
+        }
+
+        if collapsedStyleAtIndex.1.isEmpty.negated {
+            finalStyles.append((
+                NSRange(
+                    location: collapsedStyleAtIndex.start,
+                    length: maxUpperBound - collapsedStyleAtIndex.start
+                ),
+                collapsedStyleAtIndex.1
+            ))
+        }
+
+        return finalStyles
     }
 
     public func copy(with zone: NSZone? = nil) -> Any {
-        return MessageBodyRanges(mentions: mentions)
+        return MessageBodyRanges(mentions: mentions, styles: styles)
     }
 
     public func encode(with coder: NSCoder) {
@@ -149,26 +498,39 @@ public class MessageBodyRanges: NSObject, NSCopying, NSSecureCoding {
             coder.encode(NSValue(range: range), forKey: "mentions.range.\(idx)")
             coder.encode(uuid, forKey: "mentions.uuid.\(idx)")
         }
+        coder.encode(styles.count, forKey: "stylesCount")
+        for (idx, (range, style)) in styles.enumerated() {
+            coder.encode(NSValue(range: range), forKey: "styles.range.\(idx)")
+            coder.encode(style.rawValue, forKey: "styles.style.\(idx)")
+        }
     }
 
+    // TODO[TextFormatting]: "plaintext" here is misleading; depending on usage we may
+    // want to apply some styles.
     public func plaintextBody(text: String, transaction: GRDBReadTransaction) -> String {
-        guard hasMentions else { return text }
-
-        let mutableText = NSMutableString(string: text)
+        return MessageBody(text: text, ranges: self).plaintextBody(transaction: transaction)
+    }
 
-        for (range, uuid) in orderedMentions.reversed() {
-            guard range.location >= 0 && range.location + range.length <= (text as NSString).length else {
-                owsFailDebug("Ignoring invalid range in body ranges \(range)")
-                continue
+    override public func isEqual(_ object: Any?) -> Bool {
+        guard let other = object as? MessageBodyRanges else {
+            return false
+        }
+        guard mentions == other.mentions else {
+            return false
+        }
+        guard styles.count == other.styles.count else {
+            return false
+        }
+        for i in 0..<styles.count {
+            let style = styles[i]
+            let otherStyle = other.styles[i]
+            guard style.0 == otherStyle.0 else {
+                return false
+            }
+            guard style.1 == otherStyle.1 else {
+                return false
             }
-
-            let displayName = Self.contactsManager.displayName(
-                for: SignalServiceAddress(uuid: uuid),
-                transaction: transaction.asAnyRead
-            )
-            mutableText.replaceCharacters(in: range, with: Self.mentionPrefix + displayName)
         }
-
-        return mutableText.filterStringForDisplay()
+        return true
     }
 }
diff --git a/SignalServiceKit/tests/Messages/MessageBodyTests.swift b/SignalServiceKit/tests/Messages/MessageBodyTests.swift
new file mode 100644
index 00000000000..3d03b881efe
--- /dev/null
+++ b/SignalServiceKit/tests/Messages/MessageBodyTests.swift
@@ -0,0 +1,787 @@
+//
+// Copyright 2023 Signal Messenger, LLC
+// SPDX-License-Identifier: AGPL-3.0-only
+//
+
+@testable import SignalServiceKit
+import XCTest
+
+final class MessageBodyTests: XCTestCase {
+
+    typealias Style = MessageBodyRanges.Style
+
+    // MARK: - Style Collapsing
+
+    func testStyleCollapsing_sequential() {
+        // They don't overlap but they're out of order.
+        let styles: [(NSRange, Style)] = [
+            (NSRange(location: 11, length: 5), .strikethrough),
+            (NSRange(location: 0, length: 1), .bold),
+            (NSRange(location: 1, length: 2), .italic),
+            (NSRange(location: 120, length: 10), .bold.union(.italic)),
+            (NSRange(location: 3, length: 3), .monospace),
+            (NSRange(location: 6, length: 4), .spoiler)
+        ]
+        let expectedOutput: [(NSRange, Style)] = [
+            (NSRange(location: 0, length: 1), .bold),
+            (NSRange(location: 1, length: 2), .italic),
+            (NSRange(location: 3, length: 3), .monospace),
+            (NSRange(location: 6, length: 4), .spoiler),
+            (NSRange(location: 11, length: 5), .strikethrough),
+            (NSRange(location: 120, length: 10), .bold.union(.italic))
+        ]
+        let output = MessageBodyRanges(mentions: [:], styles: styles).styles
+        assertStylesEqual(expectedOutput, output)
+    }
+
+    func testStyleCollapsing_overlap() {
+        var styles: [(NSRange, Style)] = [
+            (NSRange(location: 0, length: 3), .bold),
+            (NSRange(location: 1, length: 3), .italic)
+        ]
+        var expectedOutput: [(NSRange, Style)] = [
+            (NSRange(location: 0, length: 1), .bold),
+            (NSRange(location: 1, length: 2), .bold.union(.italic)),
+            (NSRange(location: 3, length: 1), .italic)
+        ]
+        var output = MessageBodyRanges(mentions: [:], styles: styles).styles
+        assertStylesEqual(expectedOutput, output)
+
+        styles = [
+            (NSRange(location: 0, length: 5), .bold),
+            (NSRange(location: 1, length: 3), .italic)
+        ]
+        expectedOutput = [
+            (NSRange(location: 0, length: 1), .bold),
+            (NSRange(location: 1, length: 3), .bold.union(.italic)),
+            (NSRange(location: 4, length: 1), .bold)
+        ]
+        output = MessageBodyRanges(mentions: [:], styles: styles).styles
+        assertStylesEqual(expectedOutput, output)
+
+        styles = [
+            (NSRange(location: 0, length: 5), .bold),
+            (NSRange(location: 4, length: 5), .italic),
+            (NSRange(location: 8, length: 5), .spoiler)
+        ]
+        expectedOutput = [
+            (NSRange(location: 0, length: 4), .bold),
+            (NSRange(location: 4, length: 1), .bold.union(.italic)),
+            (NSRange(location: 5, length: 3), .italic),
+            (NSRange(location: 8, length: 1), .italic.union(.spoiler)),
+            (NSRange(location: 9, length: 4), .spoiler)
+        ]
+        output = MessageBodyRanges(mentions: [:], styles: styles).styles
+        assertStylesEqual(expectedOutput, output)
+
+        styles = [
+            (NSRange(location: 0, length: 6), .bold),
+            (NSRange(location: 1, length: 6), .italic),
+            (NSRange(location: 2, length: 6), .spoiler),
+            (NSRange(location: 3, length: 6), .strikethrough),
+            (NSRange(location: 4, length: 6), .monospace)
+        ]
+        expectedOutput = [
+            (NSRange(location: 0, length: 1), .bold),
+            (NSRange(location: 1, length: 1), .bold.union(.italic)),
+            (NSRange(location: 2, length: 1), .bold.union(.italic).union(.spoiler)),
+            (NSRange(location: 3, length: 1), .bold.union(.italic).union(.spoiler).union(.strikethrough)),
+            (NSRange(location: 4, length: 2), .bold.union(.italic).union(.spoiler).union(.strikethrough).union(.monospace)),
+            (NSRange(location: 6, length: 1), .italic.union(.spoiler).union(.strikethrough).union(.monospace)),
+            (NSRange(location: 7, length: 1), .spoiler.union(.strikethrough).union(.monospace)),
+            (NSRange(location: 8, length: 1), .strikethrough.union(.monospace)),
+            (NSRange(location: 9, length: 1), .monospace)
+        ]
+        output = MessageBodyRanges(mentions: [:], styles: styles).styles
+        assertStylesEqual(expectedOutput, output)
+    }
+
+    // MARK: - Hydration
+
+    let uuids = (0...5).map { _ in UUID() }
+
+    func testHydration_noMentions() {
+        runHydrationTest(
+            input: .init(
+                text: "Hello",
+                ranges: .init(
+                    mentions: [:],
+                    styles: []
+                )
+            ),
+            names: [:],
+            output: .init(
+                text: "Hello",
+                ranges: .init(
+                    mentions: [:],
+                    styles: []
+                )
+            )
+        )
+    }
+
+    func testHydration_singleMention() {
+        runHydrationTest(
+            input: .init(
+                text: "Hello @",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 6, length: 1): uuids[0]
+                    ],
+                    styles: []
+                )
+            ),
+            names: [uuids[0]: "Luke"],
+            output: .init(
+                text: "Hello @Luke",
+                ranges: .init(
+                    mentions: [:],
+                    styles: []
+                )
+            )
+        )
+    }
+
+    func testHydration_multipleMentions() {
+        runHydrationTest(
+            input: .init(
+                text: "Hello @ and @, how is @?",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 6, length: 1): uuids[0],
+                        NSRange(location: 12, length: 1): uuids[1],
+                        NSRange(location: 22, length: 1): uuids[2]
+                    ],
+                    styles: []
+                )
+            ),
+            names: [
+                uuids[0]: "Luke",
+                uuids[1]: "Leia",
+                uuids[2]: "Han"
+            ],
+            output: .init(
+                text: "Hello @Luke and @Leia, how is @Han?",
+                ranges: .init(
+                    mentions: [:],
+                    styles: []
+                )
+            )
+        )
+    }
+
+    /// Strictly speaking, mentions should always have length 1 when sent
+    /// in messages. But best not to crash due to an antagonistic sender.
+    func testHydration_nonSingularLengthMentions() {
+        runHydrationTest(
+            input: .init(
+                text: "Hello @wasd and @1, how is ?",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 6, length: 5): uuids[0],
+                        NSRange(location: 16, length: 2): uuids[1],
+                        NSRange(location: 27, length: 0): uuids[2]
+                    ],
+                    styles: []
+                )
+            ),
+            names: [
+                uuids[0]: "Luke",
+                uuids[1]: "Leia",
+                uuids[2]: "Han"
+            ],
+            output: .init(
+                text: "Hello @Luke and @Leia, how is @Han?",
+                ranges: .init(
+                    mentions: [:],
+                    styles: []
+                )
+            )
+        )
+    }
+
+    func testHydration_notAllHydrated() {
+        runHydrationTest(
+            input: .init(
+                text: "Hello @ and @, how is @?",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 6, length: 1): uuids[0],
+                        NSRange(location: 12, length: 1): uuids[1],
+                        NSRange(location: 22, length: 1): uuids[2]
+                    ],
+                    styles: []
+                )
+            ),
+            names: [
+                uuids[0]: "Luke",
+                uuids[2]: "Han"
+            ],
+            output: .init(
+                text: "Hello @Luke and @, how is @Han?",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 16, length: 1): uuids[1]
+                    ],
+                    styles: []
+                )
+            )
+        )
+    }
+
+    func testHydration_justStyles() {
+        runHydrationTest(
+            input: .init(
+                text: "This is bold, italic, and mono",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 8, length: 4), .bold),
+                        (NSRange(location: 14, length: 6), .italic),
+                        (NSRange(location: 26, length: 4), .monospace)
+                    ]
+                )
+            ),
+            names: [:],
+            output: .init(
+                text: "This is bold, italic, and mono",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 8, length: 4), .bold),
+                        (NSRange(location: 14, length: 6), .italic),
+                        (NSRange(location: 26, length: 4), .monospace)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testHydration_stylesAndTrailingMention() {
+        runHydrationTest(
+            input: .init(
+                text: "This is bold, italic, and mono, @.",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 32, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 8, length: 4), .bold),
+                        (NSRange(location: 14, length: 6), .italic),
+                        (NSRange(location: 26, length: 4), .monospace)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "Luke"],
+            output: .init(
+                text: "This is bold, italic, and mono, @Luke.",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 8, length: 4), .bold),
+                        (NSRange(location: 14, length: 6), .italic),
+                        (NSRange(location: 26, length: 4), .monospace)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testHydration_stylesAndLeadingMention() {
+        runHydrationTest(
+            input: .init(
+                text: "@, this is bold, italic, and mono",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 11, length: 4), .bold),
+                        (NSRange(location: 17, length: 6), .italic),
+                        (NSRange(location: 29, length: 4), .monospace)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "Luke"],
+            output: .init(
+                text: "@Luke, this is bold, italic, and mono",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 15, length: 4), .bold),
+                        (NSRange(location: 21, length: 6), .italic),
+                        (NSRange(location: 33, length: 4), .monospace)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testHydration_overlappingStyleAndMention() {
+        runHydrationTest(
+            input: .init(
+                text: "Use the force, @",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 15, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 0, length: 16), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "Luke"],
+            output: .init(
+                text: "Use the force, @Luke",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 20), .italic)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testHydration_overlappingStylesAndMentions() {
+        runHydrationTest(
+            input: .init(
+                text: "@, @@@, @@@@@@@@@@@@@@@ and @@@ are stylish people.",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 1): uuids[0],
+                        NSRange(location: 3, length: 3): uuids[1],
+                        NSRange(location: 8, length: 15): uuids[2],
+                        NSRange(location: 28, length: 3): uuids[3]
+                    ],
+                    styles: [
+                        (NSRange(location: 0, length: 51), .bold),
+                        (NSRange(location: 4, length: 1), .italic),
+                        (NSRange(location: 12, length: 15), .monospace),
+                        (NSRange(location: 24, length: 5), .spoiler)
+                    ]
+                )
+            ),
+            names: [
+                uuids[0]: "BoldGuy",
+                uuids[1]: "BoldItalicGuy",
+                uuids[2]: "BoldMonoGuy",
+                uuids[3]: "BoldSpoilerGuy"
+            ],
+            output: .init(
+                text: "@BoldGuy, @BoldItalicGuy, @BoldMonoGuy and @BoldSpoilerGuy are stylish people.",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 78), .bold),
+                        (NSRange(location: 10, length: 14), .italic),
+                        (NSRange(location: 26, length: 16), .monospace),
+                        (NSRange(location: 39, length: 19), .spoiler)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testHydration_overlappingStylesAndSomeUnhydratedMentions() {
+        let foo: MessageBodyRanges = .init(
+            mentions: [
+                NSRange(location: 10, length: 3): uuids[1],
+                NSRange(location: 15, length: 15): uuids[2]
+            ],
+            styles: [
+                (NSRange(location: 0, length: 10), .bold),
+                (NSRange(location: 10, length: 3), .bold.union(.italic)),
+                (NSRange(location: 13, length: 2), .bold),
+                (NSRange(location: 15, length: 16), .bold.union(.monospace)),
+                (NSRange(location: 31, length: 3), .bold.union(.monospace).union(.spoiler)),
+                (NSRange(location: 34, length: 16), .bold.union(.spoiler)),
+                (NSRange(location: 50, length: 20), .bold)
+            ]
+        )
+        runHydrationTest(
+            input: .init(
+                text: "@, @@@, @@@@@@@@@@@@@@@ and @@@ are stylish people.",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 1): uuids[0],
+                        NSRange(location: 3, length: 3): uuids[1],
+                        NSRange(location: 8, length: 15): uuids[2],
+                        NSRange(location: 28, length: 3): uuids[3]
+                    ],
+                    styles: [
+                        (NSRange(location: 0, length: 51), .bold),
+                        (NSRange(location: 4, length: 1), .italic),
+                        (NSRange(location: 12, length: 15), .monospace),
+                        (NSRange(location: 24, length: 5), .spoiler)
+                    ]
+                )
+            ),
+            names: [
+                uuids[0]: "BoldGuy",
+                uuids[3]: "BoldSpoilerGuy"
+            ],
+            output: .init(
+                text: "@BoldGuy, @@@, @@@@@@@@@@@@@@@ and @BoldSpoilerGuy are stylish people.",
+                ranges: foo
+            )
+        )
+    }
+
+    func testHydration_multipleMentions_RTL() {
+        runHydrationTest(
+            input: .init(
+                text: "שלום @. שלום @.",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 5, length: 1): uuids[0],
+                        NSRange(location: 13, length: 1): uuids[1]
+                    ],
+                    styles: []
+                )
+            ),
+            names: [
+                uuids[0]: "לוק",
+                uuids[1]: "ליאה"
+            ],
+            output: .init(
+                text: "שלום לוק@. שלום ליאה@.",
+                ranges: .init(
+                    mentions: [:],
+                    styles: []
+                )
+            ),
+            isRTL: true
+        )
+    }
+
+    func testHydration_styleAndMention_RTL() {
+        runHydrationTest(
+            input: .init(
+                text: "השתמש בכוח, @",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 12, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 5, length: 3), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "לוק"],
+            output: .init(
+                text: "השתמש בכוח, לוק@",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 5, length: 3), .italic)
+                    ]
+                )
+            ),
+            isRTL: true
+        )
+
+        runHydrationTest(
+            input: .init(
+                text: "@, השתמש בכוח",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 5, length: 3), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "לוק"],
+            output: .init(
+                text: "לוק@, השתמש בכוח",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 8, length: 3), .italic)
+                    ]
+                )
+            ),
+            isRTL: true
+        )
+    }
+
+    func testHydration_overlappingStyleAndMention_RTL() {
+        runHydrationTest(
+            input: .init(
+                text: "השתמש בכוח, @",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 12, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 0, length: 13), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "לוק"],
+            output: .init(
+                text: "השתמש בכוח, לוק@",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 16), .italic)
+                    ]
+                )
+            ),
+            isRTL: true
+        )
+
+        runHydrationTest(
+            input: .init(
+                text: "@, השתמש בכוח",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 1): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 0, length: 13), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "לוק"],
+            output: .init(
+                text: "לוק@, השתמש בכוח",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 16), .italic)
+                    ]
+                )
+            ),
+            isRTL: true
+        )
+    }
+
+    func testHydration_partlyOverlappingStyleAndMention_RTL() {
+        runHydrationTest(
+            input: .init(
+                text: "השתמש בכוח, @@@",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 12, length: 3): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 5, length: 8), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "לוק"],
+            output: .init(
+                text: "השתמש בכוח, לוק@",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 5, length: 11), .italic)
+                    ]
+                )
+            ),
+            isRTL: true
+        )
+        runHydrationTest(
+            input: .init(
+                text: "@@@, השתמש בכוח",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 3): uuids[0]
+                    ],
+                    styles: [
+                        (NSRange(location: 1, length: 8), .italic)
+                    ]
+                )
+            ),
+            names: [uuids[0]: "לוק"],
+            output: .init(
+                text: "לוק@, השתמש בכוח",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 10), .italic)
+                    ]
+                )
+            ),
+            isRTL: true
+        )
+    }
+
+    func testHydration_multipleMentions_accents() {
+        runHydrationTest(
+            input: .init(
+                text: "@@@ engaña a @@@",
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 3): uuids[0],
+                        NSRange(location: 13, length: 3): uuids[1]
+                    ],
+                    styles: [
+                        (NSRange(location: 1, length: 9), .bold),
+                        (NSRange(location: 4, length: 6), .italic),
+                        (NSRange(location: 11, length: 3), .monospace)
+                    ]
+                )
+            ),
+            names: [
+                uuids[0]: "José",
+                uuids[1]: "María"
+            ],
+            output: .init(
+                text: "@José engaña a @María",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 12), .bold),
+                        (NSRange(location: 6, length: 6), .italic),
+                        (NSRange(location: 13, length: 8), .monospace)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testHydration_multipleMentions_emoji() {
+        let firstMention = "@@@ "
+        let firstMentionHydrated = "@Luke "
+
+        let firstEmojiLocation = (firstMention as NSString).length
+        let firstEmojiLocationHydrated = (firstMentionHydrated as NSString).length
+        let firstEmojis = "🤗👨‍👨‍👧‍👦"
+        let firstEmojiLength = (firstEmojis as NSString).length
+
+        let middleWordLocation = firstEmojiLocation + firstEmojiLength
+        let middleWordLocationHydrated = firstEmojiLocationHydrated + firstEmojiLength
+        let middleWord = "hello"
+
+        let secondEmojiLocation = middleWordLocation + (middleWord as NSString).length
+        let secondEmojiLocationHydrated = middleWordLocationHydrated + (middleWord as NSString).length
+        let secondEmojis = "👩‍❤️‍👨🌗"
+        let secondEmojiLength = (secondEmojis as NSString).length
+
+        let secondMentionLocation = secondEmojiLocation + secondEmojiLength
+        let secondMention = " @@@"
+
+        runHydrationTest(
+            input: .init(
+                text: firstMention + firstEmojis + middleWord + secondEmojis + secondMention,
+                ranges: .init(
+                    mentions: [
+                        NSRange(location: 0, length: 3): uuids[0],
+                        NSRange(location: secondMentionLocation + 1, length: 3): uuids[1]
+                    ],
+                    styles: [
+                        (NSRange(location: 1, length: 3 + firstEmojiLength + 5), .bold),
+                        (NSRange(location: firstEmojiLocation, length: firstEmojiLength + 5 + secondEmojiLength), .italic),
+                        (NSRange(location: middleWordLocation, length: 5 + secondEmojiLength + 2), .monospace)
+                    ]
+                )
+            ),
+            names: [
+                uuids[0]: "Luke",
+                uuids[1]: "Leia"
+            ],
+            output: .init(
+                text: "@Luke 🤗👨‍👨‍👧‍👦hello👩‍❤️‍👨🌗 @Leia",
+                ranges: .init(
+                    mentions: [:],
+                    styles: [
+                        (NSRange(location: 0, length: 6 + firstEmojiLength + 5), .bold),
+                        (NSRange(location: firstEmojiLocationHydrated, length: firstEmojiLength + 5 + secondEmojiLength), .italic),
+                        (NSRange(location: middleWordLocationHydrated, length: 5 + secondEmojiLength + 6), .monospace)
+                    ]
+                )
+            )
+        )
+    }
+
+    func testDeserializeV1() throws {
+        let encodedDataBase64 = "YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9iamVjdHMSAAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVRyb290gAGvEBALDB0lJictMTQWODs/QEFEVSRudWxs2A0ODxAREhMUFRYXGBkaGxxfEBBtZW50aW9ucy5yYW5nZS4wXW1lbnRpb25zQ291bnRWJGNsYXNzXxAPbWVudGlvbnMudXVpZC4yXxAQbWVudGlvbnMucmFuZ2UuMV8QEG1lbnRpb25zLnJhbmdlLjJfEA9tZW50aW9ucy51dWlkLjFfEA9tZW50aW9ucy51dWlkLjCAAhADgA+ADoAIgAuACoAG1B4fIA8hIiMkXxASTlMucmFuZ2V2YWwubGVuZ3RoXxAUTlMucmFuZ2V2YWwubG9jYXRpb25aTlMuc3BlY2lhbIADgAQQBIAFEAEQANIoKSorWiRjbGFzc25hbWVYJGNsYXNzZXNXTlNWYWx1ZaIqLFhOU09iamVjdNIuDy8wXE5TLnV1aWRieXRlc08QEDRv6bLICE9hkgPhkjjFju2AB9IoKTIzVk5TVVVJRKIyLNQeHyAPITYjJIADgAmABdIuDzkwTxAQ4Vl38Lg2TAKkc40D+J1IxoAH1B4fIA88PSMkgAyADYAFEAcQBdIuD0IwTxAQhC0Fz6D1SSiY4rfoa5AXlIAH0igpRUZfECJTaWduYWxTZXJ2aWNlS2l0Lk1lc3NhZ2VCb2R5UmFuZ2VzokcsXxAiU2lnbmFsU2VydmljZUtpdC5NZXNzYWdlQm9keVJhbmdlcwAIABEAGgAkACkAMgA3AEkATABRAFMAZgBsAH0AkACeAKUAtwDKAN0A7wEBAQMBBQEHAQkBCwENAQ8BEQEaAS8BRgFRAVMBVQFXAVkBWwFdAWIBbQF2AX4BgQGKAY8BnAGvAbEBtgG9AcAByQHLAc0BzwHUAecB6QHyAfQB9gH4AfoB/AIBAhQCFgIbAkACQwAAAAAAAAIBAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAJo"
+        let expectedResult = MessageBodyRanges(
+            mentions: [
+                NSRange(location: 0, length: 1): UUID(uuidString: "346FE9B2-C808-4F61-9203-E19238C58EED")!,
+                NSRange(location: 3, length: 1): UUID(uuidString: "E15977F0-B836-4C02-A473-8D03F89D48C6")!,
+                NSRange(location: 5, length: 7): UUID(uuidString: "842D05CF-A0F5-4928-98E2-B7E86B901794")!
+            ],
+            styles: []
+        )
+
+        let data = Data(base64Encoded: encodedDataBase64)!
+        let decoded = try NSKeyedUnarchiver.unarchivedObject(
+            ofClass: MessageBodyRanges.self,
+            from: data
+        )
+        XCTAssertEqual(expectedResult, decoded)
+    }
+
+    func testDeserializeV2() throws {
+        let encodedDataBase64 = "YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9iamVjdHMSAAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVRyb290gAGvEBoLDDc+P0BGSk0iUVJVJVlcYDBkaCZscCd0dVUkbnVsbN8QFQ0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Nl5zdHlsZXMuc3R5bGUuMF5zdHlsZXMucmFuZ2UuNV5zdHlsZXMucmFuZ2UuMl1tZW50aW9uc0NvdW50XnN0eWxlcy5zdHlsZS41W3N0eWxlc0NvdW50ViRjbGFzc18QEG1lbnRpb25zLnJhbmdlLjFec3R5bGVzLnN0eWxlLjJfEA9tZW50aW9ucy51dWlkLjBec3R5bGVzLnJhbmdlLjRec3R5bGVzLnJhbmdlLjFec3R5bGVzLnN0eWxlLjRfEA9tZW50aW9ucy51dWlkLjFec3R5bGVzLnN0eWxlLjFfEBBtZW50aW9ucy5yYW5nZS4yXnN0eWxlcy5yYW5nZS4zXxAQbWVudGlvbnMucmFuZ2UuMF8QD21lbnRpb25zLnV1aWQuMl5zdHlsZXMucmFuZ2UuMF5zdHlsZXMuc3R5bGUuMxABgBaAEhADEAQQBoAZgAgQGoAGgBWAEBAUgAsQAoAMgBOAAoAOgA8QEtQ4OToTOzwmPV8QEk5TLnJhbmdldmFsLmxlbmd0aF8QFE5TLnJhbmdldmFsLmxvY2F0aW9uWk5TLnNwZWNpYWyAA4AEgAUQBxAF0kFCQ0RaJGNsYXNzbmFtZVgkY2xhc3Nlc1dOU1ZhbHVlokNFWE5TT2JqZWN00kcTSElcTlMudXVpZGJ5dGVzTxAQrp7/WnBvRr6+oaToYla4x4AH0kFCS0xWTlNVVUlEoktF1Dg5OhNOTyY9gAmACoAFEADSRxNTSU8QEK9AYjOzRE5Ame2tCAuLGs+AB9Q4OToTTlcmPYAJgA2ABdJHE1pJTxAQAXRH4MWkRWykwR7H+RrAcIAH1Dg5OhNOTyY9gAmACoAF1Dg5OhNOYiY9gAmAEYAF1Dg5OhNOVyY9gAmADYAF1Dg5OhNOaiY9gAmAFIAF1Dg5OhM7PCY9gAOABIAF1Dg5OhNxciY9gBeAGIAFEAzSQUJ2d18QIlNpZ25hbFNlcnZpY2VLaXQuTWVzc2FnZUJvZHlSYW5nZXOieEVfECJTaWduYWxTZXJ2aWNlS2l0Lk1lc3NhZ2VCb2R5UmFuZ2VzAAgAEQAaACQAKQAyADcASQBMAFEAUwBwAHYAowCyAMEA0ADeAO0A+QEAARMBIgE0AUMBUgFhAXMBggGVAaQBtwHJAdgB5wHpAesB7QHvAfEB8wH1AfcB+QH7Af0B/wIBAgMCBQIHAgkCCwINAg8CEQIaAi8CRgJRAlMCVQJXAlkCWwJgAmsCdAJ8An8CiAKNApoCrQKvArQCuwK+AscCyQLLAs0CzwLUAucC6QLyAvQC9gL4Av0DEAMSAxsDHQMfAyEDKgMsAy4DMAM5AzsDPQM/A0gDSgNMA04DVwNZA1sDXQNmA2gDagNsA24DcwOYA5sAAAAAAAACAQAAAAAAAAB5AAAAAAAAAAAAAAAAAAADwA=="
+
+        let expectedResult = MessageBodyRanges(
+            mentions: [
+                NSRange(location: 0, length: 1): UUID(uuidString: "AF406233-B344-4E40-99ED-AD080B8B1ACF")!,
+                NSRange(location: 3, length: 1): UUID(uuidString: "017447E0-C5A4-456C-A4C1-1EC7F91AC070")!,
+                NSRange(location: 5, length: 7): UUID(uuidString: "AE9EFF5A-706F-46BE-BEA1-A4E86256B8C7")!
+            ],
+            styles: [
+                (NSRange(location: 0, length: 1), .bold),
+                (NSRange(location: 2, length: 1), .italic),
+                (NSRange(location: 3, length: 1), .italic.union(.monospace).union(.strikethrough)),
+                (NSRange(location: 4, length: 1), .italic.union(.monospace)),
+                (NSRange(location: 5, length: 2), .monospace),
+                (NSRange(location: 8, length: 10), .spoiler)
+            ]
+        )
+
+        let data = Data(base64Encoded: encodedDataBase64)!
+        let decoded = try NSKeyedUnarchiver.unarchivedObject(
+            ofClass: MessageBodyRanges.self,
+            from: data
+        )
+        XCTAssertEqual(expectedResult, decoded)
+    }
+
+    // MARK: - Helpers
+
+    private func assertStylesEqual(
+        _ lhs: [(NSRange, Style)],
+        _ rhs: [(NSRange, Style)],
+        file: StaticString = #file,
+        line: UInt = #line
+    ) {
+        XCTAssertEqual(lhs.count, rhs.count, file: file, line: line)
+        for i in 0..<lhs.count {
+            XCTAssertEqual(lhs[i].0, rhs[i].0)
+            XCTAssertEqual(lhs[i].1, rhs[i].1)
+        }
+    }
+
+    private func runHydrationTest(
+        input: MessageBody,
+        names: [UUID: String],
+        output: MessageBody,
+        isRTL: Bool = false,
+        file: StaticString = #file,
+        line: UInt = #line
+    ) {
+        let hydrated = input.hydratingMentions(
+            hydrator: { uuid in
+                if let displayName = names[uuid] {
+                    return .hydrate(displayName: displayName)
+                } else {
+                    return .preserveMention
+                }
+            },
+            isRTL: isRTL
+        )
+        XCTAssertEqual(
+            output,
+            hydrated,
+            file: file,
+            line: line
+        )
+    }
+}
diff --git a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift
index 7ba61f61906..fb6a1e6afac 100644
--- a/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
+++ b/SignalUI/Utils/Attachment Multisend/OutgoingStoryMessage+AttachmentMultisend.swift	
@@ -18,6 +18,7 @@ extension OutgoingStoryMessage {
             case .media(let attachments):
                 for identifiedAttachment in attachments {
                     let attachment = identifiedAttachment.value
+                    // TODO[TextFormatting]: preserve styles on the story message proto but hydrate mentions
                     attachment.captionText = state.approvalMessageBody?.plaintextBody(transaction: transaction.unwrapGrdbRead)
                     let attachmentStream = try attachment
                         .buildOutgoingAttachmentInfo()
diff --git a/SignalUI/Utils/StorySharing.swift b/SignalUI/Utils/StorySharing.swift
index 12c2dd21404..88e7b216e2d 100644
--- a/SignalUI/Utils/StorySharing.swift
+++ b/SignalUI/Utils/StorySharing.swift
@@ -58,6 +58,7 @@ public enum StorySharing: Dependencies {
 
     internal static func text(for messageBody: MessageBody, with linkPreview: OWSLinkPreviewDraft?) -> String? {
         // Turn any mentions in the message body to plaintext
+        // TODO[TextFormatting]: preserve styles on the story message proto but hydrate mentions
         let plaintextMessageBody = databaseStorage.read { messageBody.plaintextBody(transaction: $0.unwrapGrdbRead) }
 
         let text: String?
diff --git a/SignalUI/ViewModels/ThreadViewModel.swift b/SignalUI/ViewModels/ThreadViewModel.swift
index 8d17f3757c0..d7fe76a80a5 100644
--- a/SignalUI/ViewModels/ThreadViewModel.swift
+++ b/SignalUI/ViewModels/ThreadViewModel.swift
@@ -145,6 +145,7 @@ public class ChatListInfo: Dependencies {
                                                              transaction: transaction) else {
                 return nil
             }
+            // TODO[TextFormatting]: apply styles to snippet
             return draftMessageBody.plaintextBody(transaction: transaction.unwrapGrdbRead)
         }
         func hasVoiceMemoDraft() -> Bool {
@@ -154,6 +155,7 @@ public class ChatListInfo: Dependencies {
             guard let previewable = lastMessageForInbox as? OWSPreviewText else {
                 return nil
             }
+            // TODO[TextFormatting]: apply styles to snippet
             return previewable.previewText(transaction: transaction).filterStringForDisplay()
         }
         func loadLastMessageSenderName() -> String? {
diff --git a/SignalUI/Views/Mentions/Mention.swift b/SignalUI/Views/Mentions/Mention.swift
index c3bd2a43888..2239805814b 100644
--- a/SignalUI/Views/Mentions/Mention.swift
+++ b/SignalUI/Views/Mentions/Mention.swift
@@ -129,6 +129,7 @@ extension MessageBody {
         let filteredAttributedString = attributedString.filterForDisplay
         let mutableAttributedString = NSMutableAttributedString(attributedString: filteredAttributedString)
 
+        // TODO[TextFormatting]: parse out styles as well
         mutableAttributedString.enumerateMentions { mention, subrange, _ in
             guard let mention = mention else { return }
 
@@ -147,7 +148,7 @@ extension MessageBody {
             mentions[placeholderRange] = mention.address.uuid
         }
 
-        self.init(text: mutableAttributedString.string, ranges: .init(mentions: mentions))
+        self.init(text: mutableAttributedString.string, ranges: .init(mentions: mentions, styles: []))
     }
 
     public func textValue(style: Mention.Style,
@@ -205,6 +206,8 @@ extension MessageBodyRanges {
         shouldResolveAddress: (SignalServiceAddress) -> Bool,
         transaction: GRDBReadTransaction
     ) -> NSAttributedString {
+        // TODO[TextFormatting]: this drives the text we display in message bubbles.
+        // update it to render styles as well.
         guard hasMentions else { return NSAttributedString(string: text, attributes: attributes) }
 
         let mutableText = NSMutableAttributedString(string: text, attributes: attributes)
diff --git a/SignalUI/Views/Mentions/MentionTextView.swift b/SignalUI/Views/Mentions/MentionTextView.swift
index 2445427ca98..0a1adca7483 100644
--- a/SignalUI/Views/Mentions/MentionTextView.swift
+++ b/SignalUI/Views/Mentions/MentionTextView.swift
@@ -530,7 +530,8 @@ extension MentionTextView {
 
         let messageBody = MessageBody(attributedString: attributedString)
 
-        if messageBody.hasRanges, let encodedMessageBody = try? NSKeyedArchiver.archivedData(withRootObject: messageBody, requiringSecureCoding: true) {
+        // TODO[TextFormatting]: apply text styles to copy pasted things?
+        if messageBody.hasMentions, let encodedMessageBody = try? NSKeyedArchiver.archivedData(withRootObject: messageBody, requiringSecureCoding: true) {
             UIPasteboard.general.setItems([[Self.pasteboardType: encodedMessageBody]], options: [.localOnly: true])
         } else {
             UIPasteboard.general.setItems([], options: [:])
