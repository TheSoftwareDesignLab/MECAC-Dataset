diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 01180e2d8e1..032f878475e 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -5131,9 +5131,6 @@
 /* A user-friendly description of the 'nobody' phone number sharing mode when phone number discovery is set to 'nobody'. */
 "PHONE_NUMBER_SHARING_NOBODY_DESCRIPTION_DISCOVERABILITY_NOBODY" = "Your phone number will not be visible to anyone.";
 
-/* Format for phone number label with an index. Embeds {{Phone number label (e.g. 'home')}} and {{index, e.g. 2}}. */
-"PHONE_NUMBER_TYPE_AND_INDEX_NAME_FORMAT" = "%@ %@";
-
 /* Label for 'Home' phone numbers. */
 "PHONE_NUMBER_TYPE_HOME" = "Home";
 
diff --git a/SignalServiceKit/Contacts/Contact.swift b/SignalServiceKit/Contacts/Contact.swift
index c23944c65f9..e4abe51991c 100644
--- a/SignalServiceKit/Contacts/Contact.swift
+++ b/SignalServiceKit/Contacts/Contact.swift
@@ -22,45 +22,15 @@ extension Contact {
     // MARK: - Phone Numbers
 
     public static func uniquePhoneNumberLabel(
-        for phoneNumber: CanonicalPhoneNumber,
-        relatedPhoneNumbers: [(phoneNumber: CanonicalPhoneNumber, userProvidedLabel: String)]
+        userProvidedLabel: String,
+        discoverablePhoneNumberCount: Int
     ) -> String? {
-        guard relatedPhoneNumbers.count > 1 else {
+        // If there's only one phone number for this contact, don't show the label.
+        if discoverablePhoneNumberCount <= 1 {
             return nil
+        } else {
+            return userProvidedLabel.filterForDisplay
         }
-
-        // 1. Find this phone number's type.
-        let phoneNumberLabel = relatedPhoneNumbers
-            .first(where: { $0.phoneNumber == phoneNumber })?
-            .userProvidedLabel
-            .filterForDisplay
-        guard let phoneNumberLabel else {
-            owsFailDebug("Couldn't find phoneNumber in relatedPhoneNumbers")
-            return nil
-        }
-
-        // 2. Find all phone numbers of this type.
-        let phoneNumbersWithTheSameLabel = relatedPhoneNumbers.lazy.filter {
-            return phoneNumberLabel == $0.userProvidedLabel.filterForDisplay
-        }.map { $0.phoneNumber }.sorted(by: { $0.rawValue.stringValue < $1.rawValue.stringValue })
-
-        // 3. Figure out if this is "Mobile 0" or "Mobile 1".
-        guard let thisPhoneNumberIndex = phoneNumbersWithTheSameLabel.firstIndex(of: phoneNumber) else {
-            owsFailDebug("Couldn't find the address we were trying to match.")
-            return phoneNumberLabel
-        }
-
-        // 4. If there's only one "Mobile", don't add the " 0" or " 1" suffix.
-        guard phoneNumbersWithTheSameLabel.count > 1 else {
-            return phoneNumberLabel
-        }
-
-        // 5. If there's two or more "Mobile" numbers, specify which this is.
-        let format = OWSLocalizedString(
-            "PHONE_NUMBER_TYPE_AND_INDEX_NAME_FORMAT",
-            comment: "Format for phone number label with an index. Embeds {{Phone number label (e.g. 'home')}} and {{index, e.g. 2}}."
-        )
-        return String(format: format, phoneNumberLabel, OWSFormat.formatInt(thisPhoneNumberIndex))
     }
 
     public convenience init(
diff --git a/SignalServiceKit/Contacts/OWSContactsManager.swift b/SignalServiceKit/Contacts/OWSContactsManager.swift
index c81d7d90bab..29e92c93149 100644
--- a/SignalServiceKit/Contacts/OWSContactsManager.swift
+++ b/SignalServiceKit/Contacts/OWSContactsManager.swift
@@ -605,7 +605,7 @@ extension OWSContactsManager: ContactManager {
         transaction: SDSAnyReadTransaction
     ) -> [SignalAccount] {
         var discoverableRecipients = [CanonicalPhoneNumber: (SignalRecipient, ServiceId)]()
-        var groupedDiscoverablePhoneNumbers = [String: [(phoneNumber: CanonicalPhoneNumber, userProvidedLabel: String)]]()
+        var discoverablePhoneNumberCounts = [String: Int]()
         for (phoneNumber, contactRef) in fetchedSystemContacts.phoneNumberToContactRef {
             guard let signalRecipient = discoverableRecipient(for: phoneNumber, tx: transaction) else {
                 // Not discoverable.
@@ -616,14 +616,14 @@ extension OWSContactsManager: ContactManager {
                 continue
             }
             discoverableRecipients[phoneNumber] = (signalRecipient, serviceId)
-            groupedDiscoverablePhoneNumbers[contactRef.uniqueId, default: []].append((phoneNumber, contactRef.userProvidedLabel))
+            discoverablePhoneNumberCounts[contactRef.uniqueId, default: 0] += 1
         }
         var signalAccounts = [SignalAccount]()
         for (phoneNumber, contactRef) in fetchedSystemContacts.phoneNumberToContactRef {
             guard let (signalRecipient, serviceId) = discoverableRecipients[phoneNumber] else {
                 continue
             }
-            guard let relatedPhoneNumbers = groupedDiscoverablePhoneNumbers[contactRef.uniqueId] else {
+            guard let discoverablePhoneNumberCount = discoverablePhoneNumberCounts[contactRef.uniqueId] else {
                 owsFailDebug("Couldn't find relatedPhoneNumbers")
                 continue
             }
@@ -632,8 +632,8 @@ extension OWSContactsManager: ContactManager {
                 continue
             }
             let multipleAccountLabelText = Contact.uniquePhoneNumberLabel(
-                for: phoneNumber,
-                relatedPhoneNumbers: relatedPhoneNumbers
+                userProvidedLabel: contactRef.userProvidedLabel,
+                discoverablePhoneNumberCount: discoverablePhoneNumberCount
             )
             let contactAvatarHash = buildContactAvatarHash(for: systemContact)
             let signalAccount = SignalAccount(
