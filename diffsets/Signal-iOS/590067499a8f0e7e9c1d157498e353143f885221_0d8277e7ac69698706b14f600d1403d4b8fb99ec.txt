diff --git a/Podfile b/Podfile
index 503b8cfb080..565fd932f49 100644
--- a/Podfile
+++ b/Podfile
@@ -12,8 +12,7 @@ source 'https://cdn.cocoapods.org/'
 
 pod 'SwiftProtobuf', ">= 1.14.0"
 
-pod 'SignalCoreKit', git: 'https://github.com/signalapp/SignalCoreKit.git', branch: 'charlesmchen/nilStrings', testspecs: ["Tests"]
-# pod 'SignalCoreKit', git: 'https://github.com/signalapp/SignalCoreKit.git', testspecs: ["Tests"]
+pod 'SignalCoreKit', git: 'https://github.com/signalapp/SignalCoreKit.git', testspecs: ["Tests"]
 # pod 'SignalCoreKit', path: '../SignalCoreKit', testspecs: ["Tests"]
 
 pod 'SignalClient', git: 'https://github.com/signalapp/libsignal-client.git', testspecs: ["Tests"]
diff --git a/Podfile.lock b/Podfile.lock
index 0cfe9023b8d..20d2879d3ad 100644
--- a/Podfile.lock
+++ b/Podfile.lock
@@ -242,8 +242,8 @@ DEPENDENCIES:
   - SignalArgon2/Tests (from `https://github.com/signalapp/Argon2.git`)
   - SignalClient (from `https://github.com/signalapp/libsignal-client.git`)
   - SignalClient/Tests (from `https://github.com/signalapp/libsignal-client.git`)
-  - SignalCoreKit (from `https://github.com/signalapp/SignalCoreKit.git`, branch `charlesmchen/nilStrings`)
-  - SignalCoreKit/Tests (from `https://github.com/signalapp/SignalCoreKit.git`, branch `charlesmchen/nilStrings`)
+  - SignalCoreKit (from `https://github.com/signalapp/SignalCoreKit.git`)
+  - SignalCoreKit/Tests (from `https://github.com/signalapp/SignalCoreKit.git`)
   - "SignalMetadataKit (from `ssh://git@github.com/signalapp/SignalMetadataKit`, branch `feature/SignalClient-adoption`)"
   - "SignalMetadataKit/Tests (from `ssh://git@github.com/signalapp/SignalMetadataKit`, branch `feature/SignalClient-adoption`)"
   - SignalRingRTC (from `ThirdParty/SignalRingRTC.podspec`)
@@ -320,7 +320,6 @@ EXTERNAL SOURCES:
   SignalClient:
     :git: https://github.com/signalapp/libsignal-client.git
   SignalCoreKit:
-    :branch: charlesmchen/nilStrings
     :git: https://github.com/signalapp/SignalCoreKit.git
   SignalMetadataKit:
     :branch: feature/SignalClient-adoption
@@ -366,7 +365,7 @@ CHECKOUT OPTIONS:
     :commit: a983a564ac58148cdd69dc69aaf45149db3dde63
     :git: https://github.com/signalapp/libsignal-client.git
   SignalCoreKit:
-    :commit: f3e87c511b4058f8b34b651911bef6e17f74aa84
+    :commit: 442e2d544a3fac6627ec941abbbd3ad37327874b
     :git: https://github.com/signalapp/SignalCoreKit.git
   SignalMetadataKit:
     :commit: af0c4d175384160946aca9d47247f80e26cb0625
@@ -436,6 +435,6 @@ SPEC CHECKSUMS:
   ZKGroup: 15a08eed5870a44b9dd14af0824ac95f6eed7380
   ZXingObjC: fdbb269f25dd2032da343e06f10224d62f537bdb
 
-PODFILE CHECKSUM: 6c0530c5768aafe0ad44303260f9db73e40f1e57
+PODFILE CHECKSUM: b9765e2bc1ac90c71ecfb8a54c0afd8a1b7281ca
 
 COCOAPODS: 1.9.2
diff --git a/Signal.xcodeproj/project.pbxproj b/Signal.xcodeproj/project.pbxproj
index bb2fcabc40e..ce756642fa1 100644
--- a/Signal.xcodeproj/project.pbxproj
+++ b/Signal.xcodeproj/project.pbxproj
@@ -280,6 +280,12 @@
 		349439D624360C30001045F7 /* AddGroupMembersViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349439D524360C30001045F7 /* AddGroupMembersViewController.swift */; };
 		349439D824360D63001045F7 /* BaseGroupMemberViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 349439D724360D63001045F7 /* BaseGroupMemberViewController.swift */; };
 		34955A73260A366600F3789A /* OnboardingDroppedYdbViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34955A72260A366600F3789A /* OnboardingDroppedYdbViewController.swift */; };
+		3495FF0325F908FE00959D6E /* PaymentsViewPassphraseConfirmViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3495FF0225F908FE00959D6E /* PaymentsViewPassphraseConfirmViewController.swift */; };
+		3495FF0525F9091400959D6E /* PaymentsViewPassphraseGridViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3495FF0425F9091400959D6E /* PaymentsViewPassphraseGridViewController.swift */; };
+		3495FF0A25F9276E00959D6E /* PaymentsRestoreWalletSplashViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3495FF0825F9276E00959D6E /* PaymentsRestoreWalletSplashViewController.swift */; };
+		3495FF0B25F9276E00959D6E /* PaymentsRestoreWalletWordViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3495FF0925F9276E00959D6E /* PaymentsRestoreWalletWordViewController.swift */; };
+		3495FF0D25F934C500959D6E /* PaymentsRestoreWalletCompleteViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3495FF0C25F934C500959D6E /* PaymentsRestoreWalletCompleteViewController.swift */; };
+		3495FF0F25F9538900959D6E /* PaymentsViewPassphraseSplashViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3495FF0E25F9538900959D6E /* PaymentsViewPassphraseSplashViewController.swift */; };
 		3496744F2076ACD000080B5F /* LongTextViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3496744E2076ACCE00080B5F /* LongTextViewController.swift */; };
 		3496955C219B605E00DCFE74 /* ImagePickerController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 34969559219B605E00DCFE74 /* ImagePickerController.swift */; };
 		3496955D219B605E00DCFE74 /* PhotoCollectionPickerController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3496955A219B605E00DCFE74 /* PhotoCollectionPickerController.swift */; };
@@ -1292,6 +1298,12 @@
 		3495BC911F1426B800B478F5 /* ar */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ar; path = translations/ar.lproj/Localizable.strings; sourceTree = "<group>"; };
 		3495FF1325F9A0C900959D6E /* ug */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ug; path = translations/ug.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		3495FF1425F9A0C900959D6E /* ug */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = ug; path = translations/ug.lproj/Localizable.strings; sourceTree = "<group>"; };
+		3495FF0225F908FE00959D6E /* PaymentsViewPassphraseConfirmViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PaymentsViewPassphraseConfirmViewController.swift; sourceTree = "<group>"; };
+		3495FF0425F9091400959D6E /* PaymentsViewPassphraseGridViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PaymentsViewPassphraseGridViewController.swift; sourceTree = "<group>"; };
+		3495FF0825F9276E00959D6E /* PaymentsRestoreWalletSplashViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PaymentsRestoreWalletSplashViewController.swift; sourceTree = "<group>"; };
+		3495FF0925F9276E00959D6E /* PaymentsRestoreWalletWordViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PaymentsRestoreWalletWordViewController.swift; sourceTree = "<group>"; };
+		3495FF0C25F934C500959D6E /* PaymentsRestoreWalletCompleteViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PaymentsRestoreWalletCompleteViewController.swift; sourceTree = "<group>"; };
+		3495FF0E25F9538900959D6E /* PaymentsViewPassphraseSplashViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PaymentsViewPassphraseSplashViewController.swift; sourceTree = "<group>"; };
 		3496744E2076ACCE00080B5F /* LongTextViewController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = LongTextViewController.swift; sourceTree = "<group>"; };
 		34969559219B605E00DCFE74 /* ImagePickerController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ImagePickerController.swift; sourceTree = "<group>"; };
 		3496955A219B605E00DCFE74 /* PhotoCollectionPickerController.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PhotoCollectionPickerController.swift; sourceTree = "<group>"; };
@@ -2703,10 +2715,16 @@
 				3498AC8E2518E92B00B1F315 /* PaymentsHistory.swift */,
 				3498AC8D2518E92B00B1F315 /* PaymentsHistoryViewController.swift */,
 				3406D32325DD4A8F00885B14 /* PaymentsQRScanViewController.swift */,
+				3495FF0C25F934C500959D6E /* PaymentsRestoreWalletCompleteViewController.swift */,
+				3495FF0825F9276E00959D6E /* PaymentsRestoreWalletSplashViewController.swift */,
+				3495FF0925F9276E00959D6E /* PaymentsRestoreWalletWordViewController.swift */,
 				3497971425D6D55400E99FA4 /* PaymentsSendRecipientViewController.swift */,
 				3498AC8F2518E92B00B1F315 /* PaymentsSettingsViewController.swift */,
 				34848D6225D44EBD00E5034B /* PaymentsTransferInViewController.swift */,
 				3406D32125DD40F000885B14 /* PaymentsTransferOutViewController.swift */,
+				3495FF0425F9091400959D6E /* PaymentsViewPassphraseGridViewController.swift */,
+				3495FF0225F908FE00959D6E /* PaymentsViewPassphraseConfirmViewController.swift */,
+				3495FF0E25F9538900959D6E /* PaymentsViewPassphraseSplashViewController.swift */,
 				34FB6A5225D2D10400E599B1 /* PaymentsViewUtils.swift */,
 			);
 			path = Payments;
@@ -5341,6 +5359,7 @@
 				34E3EF0D1EFC235B007F6822 /* DebugUIDiskUsage.m in Sources */,
 				887EEC1F23F0B20600F8C26D /* PinReminderMegaphone.swift in Sources */,
 				34D3E57B245A189D00F5E4A1 /* DebugUIScreenshots.swift in Sources */,
+				3495FF0B25F9276E00959D6E /* PaymentsRestoreWalletWordViewController.swift in Sources */,
 				454A84042059C787008B8C75 /* MediaTileViewController.swift in Sources */,
 				4CD675C722E7D393008010D2 /* MediaPresentationContext.swift in Sources */,
 				348815C02553291300D4F4C4 /* CVComponentViewOnce.swift in Sources */,
@@ -5366,6 +5385,7 @@
 				34B14D8D24F02A9600CC3A9A /* GroupLinkViewController.swift in Sources */,
 				34D2CCE0206939B400CB1A14 /* DebugUIMessagesAssetLoader.m in Sources */,
 				88ABB8B7253421F200229EAA /* GroupCallVideoGrid.swift in Sources */,
+				3495FF0525F9091400959D6E /* PaymentsViewPassphraseGridViewController.swift in Sources */,
 				88905E9E229CCA96004E4234 /* ExpirationNagView.swift in Sources */,
 				887889B2247F2E72001B5FCF /* Emoji.swift in Sources */,
 				3405C06E25435048008B24EF /* ConversationViewController+Banners.swift in Sources */,
@@ -5434,6 +5454,7 @@
 				88A4CC19246CE6810082211F /* DeviceTransferInitialViewController.swift in Sources */,
 				3406D32425DD4A8F00885B14 /* PaymentsQRScanViewController.swift in Sources */,
 				8835DE01230DBF7E00DC6B66 /* ComposeViewController.swift in Sources */,
+				3495FF0F25F9538900959D6E /* PaymentsViewPassphraseSplashViewController.swift in Sources */,
 				3406D32225DD40F000885B14 /* PaymentsTransferOutViewController.swift in Sources */,
 				34A17D81253F7237009F8C02 /* ConversationSettingsViewController+LegacyGroups.swift in Sources */,
 				452037D11EE84975004E4CDF /* DebugUISessionState.m in Sources */,
@@ -5515,6 +5536,7 @@
 				88A941992409A391000E9700 /* LottieToggleButton.swift in Sources */,
 				3448E15C22133274004B052E /* OnboardingPermissionsViewController.swift in Sources */,
 				88588D18252D312800405414 /* GroupCallViewController.swift in Sources */,
+				3495FF0325F908FE00959D6E /* PaymentsViewPassphraseConfirmViewController.swift in Sources */,
 				8837F74123DA0B0F00772A32 /* MegaphoneView.swift in Sources */,
 				88D23D2723CEC0C700B0E74B /* WebRTCCallMessageHandler.swift in Sources */,
 				348BB25D20A0C5530047AEC2 /* ContactShareViewHelper.swift in Sources */,
@@ -5588,6 +5610,7 @@
 				4539B5861F79348F007141FF /* PushRegistrationManager.swift in Sources */,
 				8851DB4524CCFB93001EACD2 /* ConversationViewController+Mentions.swift in Sources */,
 				45F32C232057297A00A300D5 /* MediaPageViewController.swift in Sources */,
+				3495FF0A25F9276E00959D6E /* PaymentsRestoreWalletSplashViewController.swift in Sources */,
 				8809CE8722F8FE6D00D38867 /* AttachmentKeyboard.swift in Sources */,
 				347C382E252CE69400F3D941 /* CVComponentState.swift in Sources */,
 				8810223722DF9C2300A7C44F /* OnboardingPinAttemptsExhaustedViewController.swift in Sources */,
@@ -5626,6 +5649,7 @@
 				88238EBA24F2130300F28079 /* EmojiWithSkinTones+String.swift in Sources */,
 				8827004E23208A1900F01C46 /* AppearanceSettingsTableViewController.swift in Sources */,
 				344A761324B36C8C009D69A5 /* TestingViewController.swift in Sources */,
+				3495FF0D25F934C500959D6E /* PaymentsRestoreWalletCompleteViewController.swift in Sources */,
 				34E88D262098C5AE00A608F4 /* ContactViewController.swift in Sources */,
 				88F7EE93230253C5003ADF7D /* UsernameViewController.swift in Sources */,
 				8851DB4324CCF0EB001EACD2 /* ConversationInputTextView.swift in Sources */,
diff --git a/Signal/Images.xcassets/recovery-phrase.imageset/Contents.json b/Signal/Images.xcassets/recovery-phrase.imageset/Contents.json
new file mode 100644
index 00000000000..ea94485e6cd
--- /dev/null
+++ b/Signal/Images.xcassets/recovery-phrase.imageset/Contents.json
@@ -0,0 +1,21 @@
+{
+  "images" : [
+    {
+      "filename" : "recovery-phrase.pdf",
+      "idiom" : "universal",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Signal/Images.xcassets/recovery-phrase.imageset/recovery-phrase.pdf b/Signal/Images.xcassets/recovery-phrase.imageset/recovery-phrase.pdf
new file mode 100644
index 00000000000..f0d6cc9aecb
Binary files /dev/null and b/Signal/Images.xcassets/recovery-phrase.imageset/recovery-phrase.pdf differ
diff --git a/Signal/src/ViewControllers/AppSettings/Internal/InternalSettingsViewController.swift b/Signal/src/ViewControllers/AppSettings/Internal/InternalSettingsViewController.swift
index 4b177f4a727..d7f8d8ec5a8 100644
--- a/Signal/src/ViewControllers/AppSettings/Internal/InternalSettingsViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/Internal/InternalSettingsViewController.swift
@@ -137,6 +137,7 @@ class InternalSettingsViewController: OWSTableViewController2 {
         infoSection.add(.label(withText: "Local Profile Key: \(profileManager.localProfileKey().keyData.hexadecimalString)"))
 
         infoSection.add(.label(withText: "Payments EnabledKey: \(payments.arePaymentsEnabled ? "Yes" : "No")"))
+        infoSection.add(.label(withText: "Payments Entropy: \(payments.paymentsEntropy?.hexadecimalString ?? "None")"))
         infoSection.add(.label(withText: "MobileCoin Root Entropy: \(payments.mcRootEntropy?.hexadecimalString ?? "None")"))
 
         contents.addSection(infoSection)
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsDeactivateViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsDeactivateViewController.swift
index 5d368ae76ae..11e1246986a 100644
--- a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsDeactivateViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsDeactivateViewController.swift
@@ -112,7 +112,7 @@ public class PaymentsDeactivateViewController: OWSViewController {
                                      ])
         explanationAttributed.append(CommonStrings.learnMore,
                                      attributes: [
-                                        .font: UIFont.ows_dynamicTypeBody2Clamped,
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped.ows_semibold,
                                         .foregroundColor: Theme.primaryTextColor
                                      ])
 
@@ -190,7 +190,7 @@ public class PaymentsDeactivateViewController: OWSViewController {
                         owsFailDebug("Missing navigationController.")
                         return
                     }
-                    let view = PaymentsTransferOutViewController(transferAmount: paymentBalance.amount)
+                    let view = PaymentsTransferOutViewController(transferAmount: transferAmount)
                     navigationController.pushViewController(view, animated: true)
                 }
             }.catch { error in
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletCompleteViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletCompleteViewController.swift
new file mode 100644
index 00000000000..c661ba51ff8
--- /dev/null
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletCompleteViewController.swift
@@ -0,0 +1,201 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public class PaymentsRestoreWalletCompleteViewController: OWSTableViewController2 {
+
+    private let passphrase: PaymentsPassphrase
+
+    private weak var restoreWalletDelegate: PaymentsRestoreWalletDelegate?
+
+    private let bottomStack = UIStackView()
+
+    open override var bottomFooter: UIView? { bottomStack }
+
+    public required init(restoreWalletDelegate: PaymentsRestoreWalletDelegate,
+                         passphrase: PaymentsPassphrase) {
+        self.passphrase = passphrase
+        self.restoreWalletDelegate = restoreWalletDelegate
+
+        super.init()
+
+        self.shouldAvoidKeyboard = true
+    }
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_TITLE",
+                                  comment: "Title for the 'restore payments wallet' view of the app settings.")
+
+        buildBottomView()
+        updateContents()
+    }
+
+    public override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        updateContents()
+    }
+
+    private func buildBottomView() {
+        let doneButton = OWSFlatButton.button(title: CommonStrings.doneButton,
+                                              font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                              titleColor: .white,
+                                              backgroundColor: .ows_accentBlue,
+                                              target: self,
+                                              selector: #selector(didTapDoneButton))
+        doneButton.autoSetHeightUsingFont()
+
+        let editButton = OWSFlatButton.button(title: CommonStrings.editButton,
+                                              font: .ows_dynamicTypeBody,
+                                              titleColor: .ows_accentBlue,
+                                              backgroundColor: .clear,
+                                              target: self,
+                                              selector: #selector(didTapEditButton))
+        editButton.autoSetHeightUsingFont()
+
+        bottomStack.axis = .vertical
+        bottomStack.alignment = .fill
+        bottomStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        bottomStack.layoutMargins = UIEdgeInsets(top: 8, leading: hMargin, bottom: 0, trailing: hMargin)
+        bottomStack.addArrangedSubviews([
+            doneButton,
+            UIView.spacer(withHeight: 8),
+            editButton
+        ])
+    }
+
+    private func updateContents() {
+        updateTableContents()
+    }
+
+    private func updateTableContents() {
+        AssertIsOnMainThread()
+
+        let contents = OWSTableContents()
+
+        let section = OWSTableSection()
+        section.customHeaderView = buildHeader()
+
+        let passphrase = self.passphrase
+        section.add(OWSTableItem(customCellBlock: {
+            let cell = OWSTableItem.newCell()
+            let passphraseGrid = PaymentsViewUtils.buildPassphraseGrid(passphrase: passphrase)
+            cell.contentView.addSubview(passphraseGrid)
+            passphraseGrid.autoPinEdgesToSuperviewMargins()
+            return cell
+        },
+        actionBlock: nil))
+        contents.addSection(section)
+
+        self.contents = contents
+    }
+
+    private func buildHeader() -> UIView {
+        let titleLabel = UILabel()
+        titleLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_COMPLETE_TITLE",
+                                            comment: "Title for the 'review payments passphrase' step of the 'restore payments wallet' views.")
+        titleLabel.font = UIFont.ows_dynamicTypeTitle2Clamped.ows_semibold
+        titleLabel.textColor = Theme.primaryTextColor
+        titleLabel.textAlignment = .center
+
+        let explanationLabel = UILabel()
+        explanationLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_COMPLETE_EXPLANATION",
+                                                  comment: "Explanation of the 'review payments passphrase' step of the 'restore payments wallet' views.")
+        explanationLabel.font = .ows_dynamicTypeBody2Clamped
+        explanationLabel.textColor = Theme.secondaryTextAndIconColor
+        explanationLabel.textAlignment = .center
+        explanationLabel.numberOfLines = 0
+        explanationLabel.lineBreakMode = .byWordWrapping
+
+        let topStack = UIStackView(arrangedSubviews: [
+            titleLabel,
+            UIView.spacer(withHeight: 10),
+            explanationLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        topStack.layoutMargins = UIEdgeInsets(top: 32, leading: hMargin, bottom: 40, trailing: hMargin)
+        return topStack
+    }
+
+    private func showInvalidPassphraseAlert() {
+        let actionSheet = ActionSheetController(title: NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_INVALID_PASSPHRASE_TITLE",
+                                                                         comment: "Title for the 'invalid payments wallet passphrase' error alert in the app payments settings."),
+                                                message: NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_INVALID_PASSPHRASE_MESSAGE",
+                                                                           comment: "Message for the 'invalid payments wallet passphrase' error alert in the app payments settings."))
+        actionSheet.addAction(ActionSheetAction(title: CommonStrings.okayButton,
+                                                style: .default) { [weak self] _ in
+            self?.returnToFirstWordView(shouldClearInput: true)
+        })
+
+        presentActionSheet(actionSheet)
+    }
+
+    private func showRestoreFailureAlert() {
+        OWSActionSheets.showErrorAlert(message: NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_FAILED",
+                                                                  comment: "Error indicating that 'restore payments wallet failed' in the app payments settings."))
+    }
+
+    // MARK: - Events
+
+    @objc
+    func didTapDoneButton() {
+        // TODO: Actually restore.
+        guard payments.paymentsEntropy == nil else {
+            owsFailDebug("paymentsEntropy already set.")
+            dismiss(animated: true, completion: nil)
+            showRestoreFailureAlert()
+            return
+        }
+        guard let paymentsEntropy = paymentsSwift.paymentsEntropy(forPassphrase: passphrase) else {
+            showInvalidPassphraseAlert()
+            return
+        }
+        let didSucceed = databaseStorage.write { transaction in
+            paymentsSwift.enablePayments(withPaymentsEntropy: paymentsEntropy,
+                                         transaction: transaction)
+        }
+        guard didSucceed else {
+            owsFailDebug("Could not restore payments entropy.")
+            dismiss(animated: true, completion: nil)
+            showRestoreFailureAlert()
+            return
+        }
+
+        let restoreWalletDelegate = self.restoreWalletDelegate
+        dismiss(animated: true, completion: {
+            restoreWalletDelegate?.restoreWalletDidComplete()
+        })
+    }
+
+    @objc
+    func didTapEditButton() {
+        returnToFirstWordView(shouldClearInput: false)
+    }
+
+    private func returnToFirstWordView(shouldClearInput: Bool) {
+        guard let navigationController = navigationController else {
+            return
+        }
+
+        // We want to pop back to the _first_ of the "enter wallet passphrase" views.
+        for viewController in navigationController.viewControllers {
+            guard let viewController = viewController as? PaymentsRestoreWalletWordViewController else {
+                continue
+            }
+            if shouldClearInput {
+                viewController.clearInput()
+            }
+            navigationController.popToViewController(viewController, animated: true)
+            return
+        }
+        owsFailDebug("Could not return to start of passphrase.")
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletSplashViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletSplashViewController.swift
new file mode 100644
index 00000000000..296facf6027
--- /dev/null
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletSplashViewController.swift
@@ -0,0 +1,139 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public protocol PaymentsRestoreWalletDelegate: class {
+    func restoreWalletDidComplete()
+}
+
+// MARK: -
+
+@objc
+public class PaymentsRestoreWalletSplashViewController: OWSViewController {
+
+    private weak var restoreWalletDelegate: PaymentsRestoreWalletDelegate?
+
+    public required init(restoreWalletDelegate: PaymentsRestoreWalletDelegate) {
+        self.restoreWalletDelegate = restoreWalletDelegate
+
+        super.init()
+    }
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_TITLE",
+                                  comment: "Title for the 'restore payments wallet' view of the app settings.")
+
+        navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .stop,
+                                                           target: self,
+                                                           action: #selector(didTapDismiss),
+                                                           accessibilityIdentifier: "dismiss")
+        createContents()
+    }
+
+    private func createContents() {
+
+        view.backgroundColor = Theme.tableViewBackgroundColor
+
+        let heroImage = UIImageView(image: UIImage(named: "recovery-phrase"))
+
+        let titleLabel = UILabel()
+        titleLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_SPLASH_TITLE",
+                                            comment: "Title for the first step of the 'restore payments wallet' views.")
+        titleLabel.font = UIFont.ows_dynamicTypeTitle2Clamped.ows_semibold
+        titleLabel.textColor = Theme.primaryTextColor
+        titleLabel.textAlignment = .center
+
+        let explanationAttributed = NSMutableAttributedString()
+        explanationAttributed.append(NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_SPLASH_EXPLANATION",
+                                                       comment: "Explanation of the 'restore payments wallet' process payments settings."),
+                                     attributes: [
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped,
+                                        .foregroundColor: Theme.secondaryTextAndIconColor
+                                     ])
+        explanationAttributed.append(" ",
+                                     attributes: [
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped
+                                     ])
+        explanationAttributed.append(CommonStrings.learnMore,
+                                     attributes: [
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped.ows_semibold,
+                                        .foregroundColor: Theme.primaryTextColor
+                                     ])
+
+        let explanationLabel = UILabel()
+        explanationLabel.attributedText = explanationAttributed
+        explanationLabel.textAlignment = .center
+        explanationLabel.numberOfLines = 0
+        explanationLabel.lineBreakMode = .byWordWrapping
+        explanationLabel.isUserInteractionEnabled = true
+        explanationLabel.addGestureRecognizer(UITapGestureRecognizer(target: self,
+                                                                     action: #selector(didTapExplanation)))
+
+        let topStack = UIStackView(arrangedSubviews: [
+            heroImage,
+            UIView.spacer(withHeight: 20),
+            titleLabel,
+            UIView.spacer(withHeight: 10),
+            explanationLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        topStack.layoutMargins = UIEdgeInsets(hMargin: 20, vMargin: 0)
+
+        let startButton = OWSFlatButton.button(title: CommonStrings.startButton,
+                                               font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                               titleColor: .white,
+                                               backgroundColor: .ows_accentBlue,
+                                               target: self,
+                                               selector: #selector(didTapStartButton))
+        startButton.autoSetHeightUsingFont()
+
+        let vSpacerFactory = VSpacerFactory()
+
+        let rootView = UIStackView(arrangedSubviews: [
+            vSpacerFactory.buildVSpacer(),
+            topStack,
+            vSpacerFactory.buildVSpacer(),
+            startButton
+        ])
+        rootView.axis = .vertical
+        rootView.alignment = .fill
+        view.addSubview(rootView)
+        rootView.autoPin(toTopLayoutGuideOf: self, withInset: 0)
+        rootView.autoPin(toBottomLayoutGuideOf: self, withInset: 0)
+        rootView.autoPinWidthToSuperviewMargins()
+
+        vSpacerFactory.finalizeSpacers()
+    }
+
+    // MARK: - Events
+
+    @objc
+    func didTapDismiss() {
+        dismiss(animated: true, completion: nil)
+    }
+
+    @objc
+    func didTapStartButton() {
+        guard let restoreWalletDelegate = restoreWalletDelegate else {
+            owsFailDebug("Missing restoreWalletDelegate.")
+            dismiss(animated: true, completion: nil)
+            return
+        }
+        // Start by entering the first word of the partial passphrase.
+        let view = PaymentsRestoreWalletWordViewController(restoreWalletDelegate: restoreWalletDelegate,
+                                                           partialPassphrase: PartialPaymentsPassphrase.empty,
+                                                           wordIndex: 0)
+        navigationController?.pushViewController(view, animated: true)
+    }
+
+    @objc
+    private func didTapExplanation() {
+        // TODO: Need a support article link.
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletWordViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletWordViewController.swift
new file mode 100644
index 00000000000..f3207687095
--- /dev/null
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsRestoreWalletWordViewController.swift
@@ -0,0 +1,258 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+@objc
+public class PaymentsRestoreWalletWordViewController: OWSViewController {
+
+    private weak var restoreWalletDelegate: PaymentsRestoreWalletDelegate?
+
+    private let partialPassphrase: PartialPaymentsPassphrase
+
+    private let wordIndex: Int
+
+    private let textfield = UITextField()
+
+    private var wordText: String? {
+        textfield.text?.stripped
+    }
+    private var hasValidWord: Bool {
+        isValidWord(wordText)
+    }
+    private func isValidWord(_ wordText: String?) -> Bool {
+        guard let wordText = wordText,
+              !wordText.isEmpty else {
+            return false
+        }
+        return Self.paymentsSwift.allPossiblePassphraseWords.contains(wordText)
+    }
+
+    private let warningLabel = UILabel()
+
+    public required init(restoreWalletDelegate: PaymentsRestoreWalletDelegate,
+                         partialPassphrase: PartialPaymentsPassphrase,
+                         wordIndex: Int) {
+        self.restoreWalletDelegate = restoreWalletDelegate
+        self.partialPassphrase = partialPassphrase
+        self.wordIndex = wordIndex
+
+        super.init()
+
+        textfield.text = partialPassphrase.getWord(atIndex: wordIndex)
+    }
+
+    public func clearInput() {
+        partialPassphrase.reset()
+        textfield.text = nil
+    }
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_TITLE",
+                                  comment: "Title for the 'restore payments wallet' view of the app settings.")
+        createContents()
+    }
+
+    public override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        textfield.becomeFirstResponder()
+    }
+
+    public override func viewDidAppear(_ animated: Bool) {
+        super.viewDidAppear(animated)
+
+        textfield.becomeFirstResponder()
+    }
+
+    private func createContents() {
+
+        view.backgroundColor = Theme.tableViewBackgroundColor
+
+        let titleLabel = UILabel()
+        titleLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_TITLE",
+                                            comment: "Title for the 'enter word' step of the 'restore payments wallet' views.")
+        titleLabel.font = UIFont.ows_dynamicTypeTitle2Clamped.ows_semibold
+        titleLabel.textColor = Theme.primaryTextColor
+        titleLabel.textAlignment = .center
+
+        let instructionsFormat = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_INSTRUCTIONS_FORMAT",
+                                                   comment: "Format for the instructions for the 'enter word' step of the 'restore payments wallet' views. Embeds {{ the index of the current word }}.")
+        let instructions = String(format: instructionsFormat, OWSFormat.formatInt(wordIndex + 1))
+
+        let instructionsLabel = UILabel()
+        instructionsLabel.text = instructions
+        instructionsLabel.textAlignment = .center
+        instructionsLabel.numberOfLines = 0
+        instructionsLabel.lineBreakMode = .byWordWrapping
+
+        let topStack = UIStackView(arrangedSubviews: [
+            titleLabel,
+            UIView.spacer(withHeight: 10),
+            instructionsLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        topStack.layoutMargins = UIEdgeInsets(hMargin: 20, vMargin: 0)
+
+        textfield.textColor = Theme.primaryTextColor
+        textfield.font = .ows_dynamicTypeBodyClamped
+        textfield.keyboardAppearance = Theme.keyboardAppearance
+        textfield.autocapitalizationType = .none
+        textfield.autocorrectionType = .no
+        textfield.spellCheckingType = .no
+        textfield.smartQuotesType = .no
+        textfield.smartDashesType = .no
+        textfield.returnKeyType = .done
+        textfield.accessibilityIdentifier = "payments.passphrase.restore.\(wordIndex)"
+        textfield.addTarget(self, action: #selector(textfieldDidChange), for: .editingChanged)
+        textfield.delegate = self
+
+        let placeholderFormat = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_PLACEHOLDER_FORMAT",
+                                                  comment: "Format for the placeholder text in the 'confirm payments passphrase' view of the app settings. Embeds: {{ the index of the word }}.")
+        textfield.placeholder = String(format: placeholderFormat, OWSFormat.formatInt(wordIndex + 1))
+
+        let textfieldStack = UIStackView(arrangedSubviews: [ textfield ])
+        textfieldStack.axis = .vertical
+        textfieldStack.alignment = .fill
+        textfieldStack.isLayoutMarginsRelativeArrangement = true
+        textfieldStack.layoutMargins = UIEdgeInsets(hMargin: OWSTableViewController2.cellHInnerMargin,
+                                                    vMargin: OWSTableViewController2.cellVInnerMargin)
+        textfieldStack.addBackgroundView(withBackgroundColor: Theme.backgroundColor, cornerRadius: 10)
+
+        warningLabel.text = " "
+        warningLabel.font = .ows_dynamicTypeCaption1
+        warningLabel.textColor = .ows_accentRed
+
+        let warningStack = UIStackView(arrangedSubviews: [ warningLabel ])
+        warningStack.axis = .vertical
+        warningStack.alignment = .fill
+        warningStack.isLayoutMarginsRelativeArrangement = true
+        warningStack.layoutMargins = UIEdgeInsets(hMargin: OWSTableViewController2.cellHInnerMargin,
+                                                  vMargin: 0)
+
+        let nextButton = OWSFlatButton.button(title: CommonStrings.nextButton,
+                                              font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                              titleColor: .white,
+                                              backgroundColor: .ows_accentBlue,
+                                              target: self,
+                                              selector: #selector(didTapNextButton))
+        nextButton.autoSetHeightUsingFont()
+
+        let rootView = UIStackView(arrangedSubviews: [
+            UIView.spacer(withHeight: 20),
+            topStack,
+            UIView.spacer(withHeight: 60),
+            textfieldStack,
+            UIView.spacer(withHeight: 8),
+            warningStack,
+            UIView.vStretchingSpacer(),
+            nextButton,
+            UIView.spacer(withHeight: 8)
+        ])
+        rootView.axis = .vertical
+        rootView.alignment = .fill
+        view.addSubview(rootView)
+        rootView.autoPin(toTopLayoutGuideOf: self, withInset: 0)
+        autoPinView(toBottomOfViewControllerOrKeyboard: rootView, avoidNotch: true)
+        rootView.autoPinWidthToSuperviewMargins()
+    }
+
+    // MARK: - Events
+
+    @objc
+    func didTapNextButton() {
+        guard let restoreWalletDelegate = restoreWalletDelegate else {
+            owsFailDebug("Missing restoreWalletDelegate.")
+            dismiss(animated: true, completion: nil)
+            return
+        }
+        guard let wordText = self.wordText,
+              isValidWord(wordText) else {
+            warningLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_INVALID_WORD",
+                                                  comment: "Error indicating that the user has entered an invalid word in the 'enter word' step of the 'restore payments wallet' views.")
+            return
+        }
+        partialPassphrase.set(word: wordText, index: wordIndex)
+        if partialPassphrase.isComplete {
+            guard let paymentsPassphrase = partialPassphrase.asPaymentsPassphrase() else {
+                OWSActionSheets.showErrorAlert(message: NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_INVALID_PASSPHRASE",
+                                                                          comment: "Error indicating that the user has entered an invalid payments passphrase in the 'restore payments wallet' views."))
+                return
+            }
+            let view = PaymentsRestoreWalletCompleteViewController(restoreWalletDelegate: restoreWalletDelegate,
+                                                                   passphrase: paymentsPassphrase)
+            navigationController?.pushViewController(view, animated: true)
+        } else {
+            let view = PaymentsRestoreWalletWordViewController(restoreWalletDelegate: restoreWalletDelegate,
+                                                               partialPassphrase: partialPassphrase,
+                                                               wordIndex: wordIndex + 1)
+            navigationController?.pushViewController(view, animated: true)
+        }
+    }
+
+    @objc
+    private func textfieldDidChange() {
+        // Clear any warning.
+        warningLabel.text = " "
+    }
+}
+
+// MARK: -
+
+public class PartialPaymentsPassphrase {
+
+    private var wordMap = [Int: String]()
+
+    public var isComplete: Bool {
+        wordMap.count == PaymentsConstants.passphraseWordCount
+    }
+
+    public init() {}
+
+    public static var empty: PartialPaymentsPassphrase { PartialPaymentsPassphrase() }
+
+    public func set(word: String, index: Int) {
+        let word = word.stripped
+        guard !word.isEmpty else {
+            owsFailDebug("Invalid word.")
+            return
+        }
+        wordMap[index] = word
+    }
+
+    public func getWord(atIndex index: Int) -> String? {
+        wordMap[index]
+    }
+
+    public func asPaymentsPassphrase() -> PaymentsPassphrase? {
+        var words = [String]()
+
+        for index in 0..<PaymentsConstants.passphraseWordCount {
+            guard let word = wordMap[index] else {
+                owsFailDebug("Missing word: \(index)")
+                return nil
+            }
+            words.append(word)
+        }
+
+        return PaymentsPassphrase(words: words)
+    }
+
+    public func reset() {
+        wordMap.removeAll()
+    }
+}
+
+// MARK: -
+
+extension PaymentsRestoreWalletWordViewController: UITextFieldDelegate {
+    public func textFieldShouldReturn(_ textField: UITextField) -> Bool {
+        didTapNextButton()
+        return false
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsSettingsViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsSettingsViewController.swift
index 6fa13bf7948..9607293ad12 100644
--- a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsSettingsViewController.swift
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsSettingsViewController.swift
@@ -320,7 +320,7 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
 
                 let label = UILabel()
                 label.text = NSLocalizedString("SETTINGS_PAYMENTS_NO_ACTIVITY_INDICATOR",
-                                                         comment: "Message indicating that there is no payment activity to display in the payment settings.")
+                                               comment: "Message indicating that there is no payment activity to display in the payment settings.")
                 label.textColor = Theme.secondaryTextAndIconColor
                 label.font = UIFont.ows_dynamicTypeBodyClamped
                 label.numberOfLines = 0
@@ -361,7 +361,7 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
             },
             actionBlock: { [weak self] in
                 self?.didTapPaymentItem(paymentItem: paymentItem)
-                    }))
+            }))
         }
 
         if hasMoreItems {
@@ -430,7 +430,7 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
 
         let bodyLabel = UILabel()
         bodyLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_OPT_IN_MESSAGE",
-                                            comment: "Message for the 'payments opt-in' view in the app settings.")
+                                           comment: "Message for the 'payments opt-in' view in the app settings.")
         bodyLabel.textColor = Theme.secondaryTextAndIconColor
         bodyLabel.font = UIFont.ows_dynamicTypeSubheadlineClamped
         bodyLabel.textAlignment = .center
@@ -438,13 +438,13 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
         bodyLabel.lineBreakMode = .byWordWrapping
 
         let buttonTitle = NSLocalizedString("SETTINGS_PAYMENTS_OPT_IN_ACTIVATE_BUTTON",
-                                              comment: "Label for 'activate' button in the 'payments opt-in' view in the app settings.")
+                                            comment: "Label for 'activate' button in the 'payments opt-in' view in the app settings.")
         let activateButton = OWSFlatButton.button(title: buttonTitle,
-                                                 font: UIFont.ows_dynamicTypeBody.ows_semibold,
-                                                 titleColor: .white,
-                                                 backgroundColor: .ows_accentBlue,
-                                                 target: self,
-                                                 selector: #selector(didTapEnablePaymentsButton))
+                                                  font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                                  titleColor: .white,
+                                                  backgroundColor: .ows_accentBlue,
+                                                  target: self,
+                                                  selector: #selector(didTapEnablePaymentsButton))
         activateButton.autoSetHeightUsingFont()
 
         let stack = UIStackView(arrangedSubviews: [
@@ -456,6 +456,23 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
             UIView.spacer(withHeight: 20),
             activateButton
         ])
+
+        if Self.payments.paymentsEntropy == nil {
+            let buttonTitle = NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_PAYMENTS_BUTTON",
+                                                comment: "Label for 'restore payments' button in the payments settings.")
+            let restorePaymentsButton = OWSFlatButton.button(title: buttonTitle,
+                                                             font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                                             titleColor: .ows_accentBlue,
+                                                             backgroundColor: .clear,
+                                                             target: self,
+                                                             selector: #selector(didTapRestorePaymentsButton))
+            restorePaymentsButton.autoSetHeightUsingFont()
+            stack.addArrangedSubviews([
+                UIView.spacer(withHeight: 8),
+                restorePaymentsButton
+            ])
+        }
+
         stack.axis = .vertical
         stack.alignment = .fill
         stack.layoutMargins = UIEdgeInsets(top: 20, leading: 0, bottom: 32, trailing: 0)
@@ -579,6 +596,14 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
             self?.didTapDeactivatePaymentsButton()
         })
 
+        actionSheet.addAction(ActionSheetAction(title: NSLocalizedString("SETTINGS_PAYMENTS_VIEW_RECOVERY_PASSPHRASE",
+                                                                         comment: "Label for 'view payments recovery passphrase' button in the app settings."),
+                                                accessibilityIdentifier: "payments.settings.view_recovery_passphrase",
+                                                style: .default) { [weak self] _ in
+            self?.didTapViewPaymentsPassphraseButton()
+        })
+
+        // TODO: Design: do we still need this?
         actionSheet.addAction(ActionSheetAction(title: CommonStrings.help,
                                                 accessibilityIdentifier: "payments.settings.help",
                                                 style: .default) { [weak self] _ in
@@ -619,29 +644,35 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
         AssertIsOnMainThread()
 
         databaseStorage.asyncWrite { transaction in
-            // We must preserve any existing mcRootEntropy.
-            let mcRootEntropy: Data
-            switch Self.paymentsSwift.paymentsState {
-            case .enabled(let oldMcRootEntropy):
-                mcRootEntropy = oldMcRootEntropy
-            case .disabled:
-                mcRootEntropy = Self.paymentsSwift.generateRandomMobileCoinRootEntropy()
-            case .disabledWithMCRootEntropy(let oldMcRootEntropy):
-                mcRootEntropy = oldMcRootEntropy
-            }
-            Self.paymentsSwift.setPaymentsState(.enabled(mcRootEntropy: mcRootEntropy),
-                                                transaction: transaction)
+            Self.paymentsSwift.enablePayments(transaction: transaction)
 
             transaction.addAsyncCompletion {
-                AssertIsOnMainThread()
-
-                let toastText = NSLocalizedString("SETTINGS_PAYMENTS_OPT_IN_ACTIVATED_TOAST",
-                                                    comment: "Message shown when payments rae activated in the 'payments opt-in' view in the app settings.")
-                self.presentToast(text: toastText)
+                self.showPaymentsActivatedToast()
             }
         }
     }
 
+    private func showPaymentsActivatedToast() {
+        AssertIsOnMainThread()
+        let toastText = NSLocalizedString("SETTINGS_PAYMENTS_OPT_IN_ACTIVATED_TOAST",
+                                          comment: "Message shown when payments rae activated in the 'payments opt-in' view in the app settings.")
+        self.presentToast(text: toastText)
+    }
+
+    @objc
+    func didTapRestorePaymentsButton() {
+        AssertIsOnMainThread()
+
+        guard Self.payments.paymentsEntropy == nil else {
+            owsFailDebug("paymentsEntropy already set.")
+            return
+        }
+
+        let view = PaymentsRestoreWalletSplashViewController(restoreWalletDelegate: self)
+        let navigationVC = OWSNavigationController(rootViewController: view)
+        present(navigationVC, animated: true)
+    }
+
     @objc
     func didTapSettings() {
         showSettingsActionSheet()
@@ -652,6 +683,19 @@ public class PaymentsSettingsViewController: OWSTableViewController2 {
         navigationController?.pushViewController(view, animated: true)
     }
 
+    private func didTapViewPaymentsPassphraseButton() {
+        guard let passphrase = paymentsSwift.passphrase else {
+            owsFailDebug("Missing passphrase.")
+            return
+        }
+        let shouldShowConfirm = !hasReviewedPassphraseWithSneakyTransaction()
+        let view = PaymentsViewPassphraseSplashViewController(passphrase: passphrase,
+                                                              shouldShowConfirm: shouldShowConfirm,
+                                                              viewPassphraseDelegate: self)
+        let navigationVC = OWSNavigationController(rootViewController: view)
+        present(navigationVC, animated: true)
+    }
+
     private func didTapDeactivatePaymentsButton() {
         showConfirmDeactivatePaymentsUI()
     }
@@ -741,3 +785,46 @@ extension PaymentsSettingsViewController: PaymentsHistoryDataSourceDelegate {
         updateTableContents()
     }
 }
+
+// MARK: -
+
+extension PaymentsSettingsViewController: PaymentsViewPassphraseDelegate {
+
+    private static let keyValueStore = SDSKeyValueStore(collection: "PaymentSettings")
+    private static let hasReviewedPassphraseKey = "hasReviewedPassphrase"
+
+    private func hasReviewedPassphraseWithSneakyTransaction() -> Bool {
+        databaseStorage.read { transaction in
+            Self.keyValueStore.getBool(Self.hasReviewedPassphraseKey,
+                                       defaultValue: false,
+                                       transaction: transaction)
+        }
+    }
+
+    private func setHasReviewedPassphraseWithSneakyTransaction() {
+        databaseStorage.write { transaction in
+            Self.keyValueStore.setBool(true,
+                                       key: Self.hasReviewedPassphraseKey,
+                                       transaction: transaction)
+        }
+    }
+
+    public func viewPassphraseDidComplete() {
+        if !hasReviewedPassphraseWithSneakyTransaction() {
+            setHasReviewedPassphraseWithSneakyTransaction()
+
+            presentToast(text: NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_COMPLETE_TOAST",
+                                                 comment: "Message indicating that 'payments passphrase review' is complete."))
+        }
+    }
+}
+
+// MARK: -
+
+extension PaymentsSettingsViewController: PaymentsRestoreWalletDelegate {
+
+    public func restoreWalletDidComplete() {
+        presentToast(text: NSLocalizedString("SETTINGS_PAYMENTS_RESTORE_WALLET_COMPLETE_TOAST",
+                                             comment: "Message indicating that 'restore payments wallet' is complete."))
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseConfirmViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseConfirmViewController.swift
new file mode 100644
index 00000000000..96b8080d060
--- /dev/null
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseConfirmViewController.swift
@@ -0,0 +1,315 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public class PaymentsViewPassphraseConfirmViewController: OWSTableViewController2 {
+
+    private let passphrase: PaymentsPassphrase
+
+    private weak var viewPassphraseDelegate: PaymentsViewPassphraseDelegate?
+
+    private let bottomStack = UIStackView()
+
+    open override var bottomFooter: UIView? { bottomStack }
+
+    private let warningLabel = UILabel()
+
+    private let wordIndices: [Int]
+    private var wordIndex0: Int { wordIndices[0] }
+    private var wordIndex1: Int { wordIndices[1] }
+    private var word0: String { passphrase.words[wordIndex0] }
+    private var word1: String { passphrase.words[wordIndex1] }
+
+    private let wordTextfield0 = UITextField()
+    private let wordTextfield1 = UITextField()
+
+    private var input0: String {
+        wordTextfield0.text?.stripped ?? ""
+    }
+
+    private var input1: String {
+        wordTextfield1.text?.stripped ?? ""
+    }
+
+    private var isWordCorrect0: Bool {
+        input0.lowercased() == word0.lowercased()
+    }
+
+    private var isWordCorrect1: Bool {
+        input1.lowercased() == word1.lowercased()
+    }
+    private var currentCorrectness: [Bool] = [false, false] {
+        didSet {
+            if isViewLoaded,
+               currentCorrectness != oldValue {
+                updateContents()
+
+                let oldCorrectCount = Self.correctnessCount(oldValue)
+                let newCorrectCount = Self.correctnessCount(currentCorrectness)
+                let didJustAddCorrect = newCorrectCount > oldCorrectCount
+                if didJustAddCorrect {
+                    updateFirstResponder()
+                }
+            }
+        }
+    }
+    private var areAllWordsCorrect: Bool {
+        Self.correctnessCount(currentCorrectness) == currentCorrectness.count
+    }
+    private var areAnyWordsCorrect: Bool {
+        Self.correctnessCount(currentCorrectness) > 0
+    }
+    private static func correctnessCount(_ correctness: [Bool]) -> Int {
+        correctness.filter { $0 }.count
+    }
+
+    public required init(passphrase: PaymentsPassphrase,
+                         viewPassphraseDelegate: PaymentsViewPassphraseDelegate) {
+        self.passphrase = passphrase
+        self.viewPassphraseDelegate = viewPassphraseDelegate
+        self.wordIndices = Self.buildWordIndices(forPassphrase: passphrase)
+
+        super.init()
+
+        self.shouldAvoidKeyboard = true
+    }
+
+    private static func buildWordIndices(forPassphrase passphrase: PaymentsPassphrase) -> [Int] {
+        let allIndices = 0..<PaymentsConstants.passphraseWordCount
+        let availableIndices = allIndices.shuffled()
+        let wordIndices = Array(availableIndices.prefix(2)).sorted()
+        return wordIndices
+    }
+
+    private func updateCorrectness() {
+        currentCorrectness = [ isWordCorrect0, isWordCorrect1 ]
+    }
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_TITLE",
+                                  comment: "Title for the 'view payments passphrase' view of the app settings.")
+
+        createViews()
+        buildBottomView()
+        updateContents()
+    }
+
+    public override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        updateContents()
+    }
+
+    public override func viewDidAppear(_ animated: Bool) {
+        super.viewDidAppear(animated)
+
+        updateFirstResponder()
+    }
+
+    private func updateFirstResponder() {
+        if !isWordCorrect0 {
+            wordTextfield0.becomeFirstResponder()
+        } else if !isWordCorrect1 {
+            wordTextfield1.becomeFirstResponder()
+        }
+    }
+
+    private func createViews() {
+        func configureTextfield(_ textfield: UITextField, wordIndex: Int) {
+            textfield.delegate = self
+            textfield.textColor = Theme.primaryTextColor
+            textfield.font = .ows_dynamicTypeBodyClamped
+            textfield.keyboardAppearance = Theme.keyboardAppearance
+            textfield.autocapitalizationType = .none
+            textfield.autocorrectionType = .no
+            textfield.spellCheckingType = .no
+            textfield.smartQuotesType = .no
+            textfield.smartDashesType = .no
+            textfield.returnKeyType = .done
+            textfield.accessibilityIdentifier = "payments.passphrase.confirm.\(wordIndex)"
+            textfield.addTarget(self, action: #selector(textfieldDidChange), for: .editingChanged)
+
+            let placeholderFormat = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_PLACEHOLDER_FORMAT",
+                                                      comment: "Format for the placeholder text in the 'confirm payments passphrase' view of the app settings. Embeds: {{ the index of the word }}.")
+            textfield.placeholder = String(format: placeholderFormat, OWSFormat.formatInt(wordIndex + 1))
+        }
+        configureTextfield(wordTextfield0, wordIndex: wordIndex0)
+        configureTextfield(wordTextfield1, wordIndex: wordIndex1)
+    }
+
+    private func buildBottomView() {
+        let confirmButton = OWSFlatButton.button(title: NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM",
+                                                                          comment: "Label for 'confirm' button in the 'view payments passphrase' view of the app settings."),
+                                                 font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                                 titleColor: .white,
+                                                 backgroundColor: .ows_accentBlue,
+                                                 target: self,
+                                                 selector: #selector(didTapConfirmButton))
+        confirmButton.autoSetHeightUsingFont()
+
+        let backButton = OWSFlatButton.button(title: NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_SEE_PASSPHRASE_AGAIN",
+                                                                       comment: "Label for 'see passphrase again' button in the 'view payments passphrase' view of the app settings."),
+                                              font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                              titleColor: .ows_accentBlue,
+                                              backgroundColor: .clear,
+                                              target: self,
+                                              selector: #selector(didTapSeePassphraseAgainButton))
+        backButton.autoSetHeightUsingFont()
+
+        bottomStack.axis = .vertical
+        bottomStack.alignment = .fill
+        bottomStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        bottomStack.layoutMargins = UIEdgeInsets(top: 8, leading: hMargin, bottom: 0, trailing: hMargin)
+        bottomStack.addArrangedSubviews([
+            confirmButton,
+            UIView.spacer(withHeight: 8),
+            backButton,
+            UIView.spacer(withHeight: 8)
+        ])
+    }
+
+    private func updateContents() {
+        updateTableContents()
+    }
+
+    private func updateTableContents() {
+        AssertIsOnMainThread()
+
+        let contents = OWSTableContents()
+
+        let section0 = OWSTableSection()
+        let section1 = OWSTableSection()
+        section0.customHeaderView = buildConfirmHeader()
+
+        func buildWordRow(wordIndex: Int,
+                          wordTextfield: UITextField,
+                          isCorrect: Bool) -> OWSTableItem {
+            OWSTableItem(customCellBlock: {
+                let cell = OWSTableItem.newCell()
+
+                let stack = UIStackView(arrangedSubviews: [ wordTextfield ])
+                stack.axis = .horizontal
+                stack.alignment = .center
+                stack.spacing = 8
+                cell.contentView.addSubview(stack)
+                stack.autoPinEdgesToSuperviewMargins()
+
+                let iconHeight: CGFloat = 24
+                if isCorrect {
+                    let correctView = UIImageView.withTemplateImageName("check-circle-outline-24",
+                                                                        tintColor: .ows_accentGreen)
+                    correctView.autoSetDimensions(to: .square(iconHeight))
+                    stack.addArrangedSubview(correctView)
+                } else {
+                    // Avoid layout jitter using a placeholder view.
+                    let spacerView = UIView.spacer(withHeight: iconHeight)
+                    stack.addArrangedSubview(spacerView)
+                }
+
+                return cell
+            },
+            actionBlock: nil)
+        }
+
+        section0.add(buildWordRow(wordIndex: wordIndex0,
+                                  wordTextfield: wordTextfield0,
+                                  isCorrect: isWordCorrect0))
+        section1.add(buildWordRow(wordIndex: wordIndex1,
+                                  wordTextfield: wordTextfield1,
+                                  isCorrect: isWordCorrect1))
+        contents.addSection(section0)
+        contents.addSection(section1)
+
+        warningLabel.text = " "
+        warningLabel.font = .ows_dynamicTypeCaption1
+        warningLabel.textColor = .ows_accentRed
+
+        let warningStack = UIStackView(arrangedSubviews: [ warningLabel ])
+        warningStack.axis = .vertical
+        warningStack.alignment = .fill
+        warningStack.isLayoutMarginsRelativeArrangement = true
+        warningStack.layoutMargins = UIEdgeInsets(hMargin: (OWSTableViewController2.cellHOuterMargin +
+                                                                OWSTableViewController2.cellHInnerMargin),
+                                              vMargin: 8)
+        section1.customFooterView = warningStack
+
+        self.contents = contents
+    }
+
+    private func buildConfirmHeader() -> UIView {
+        let titleLabel = UILabel()
+        titleLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_TITLE",
+                                            comment: "Title for the 'confirm words' step of the 'view payments passphrase' views.")
+        titleLabel.font = UIFont.ows_dynamicTypeTitle2Clamped.ows_semibold
+        titleLabel.textColor = Theme.primaryTextColor
+        titleLabel.textAlignment = .center
+
+        let explanationLabel = UILabel()
+        explanationLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_EXPLANATION",
+                                                  comment: "Explanation of the 'confirm payments passphrase word' step in the 'view payments passphrase' settings.")
+        explanationLabel.font = .ows_dynamicTypeBody2Clamped
+        explanationLabel.textColor = Theme.secondaryTextAndIconColor
+        explanationLabel.textAlignment = .center
+        explanationLabel.numberOfLines = 0
+        explanationLabel.lineBreakMode = .byWordWrapping
+
+        let topStack = UIStackView(arrangedSubviews: [
+            titleLabel,
+            UIView.spacer(withHeight: 10),
+            explanationLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        topStack.layoutMargins = UIEdgeInsets(top: 32, leading: hMargin, bottom: 40, trailing: hMargin)
+        return topStack
+    }
+
+    // MARK: - Events
+
+    @objc
+    func didTapConfirmButton() {
+        guard areAllWordsCorrect else {
+            if areAnyWordsCorrect {
+                warningLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_INVALID_WORD",
+                                                      comment: "Error indicating that at least one word of the payments passphrase is not correct in the 'view payments passphrase' views.")
+            } else {
+                warningLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_INVALID_WORDS",
+                                                      comment: "Error indicating that all words of the payments passphrase are not correct in the 'view payments passphrase' views.")
+            }
+            return
+        }
+
+        let viewPassphraseDelegate = self.viewPassphraseDelegate
+        dismiss(animated: true, completion: {
+            viewPassphraseDelegate?.viewPassphraseDidComplete()
+        })
+    }
+
+    @objc
+    func didTapSeePassphraseAgainButton() {
+        navigationController?.popViewController(animated: true)
+    }
+
+    @objc
+    private func textfieldDidChange() {
+        updateCorrectness()
+        // Clear any warning.
+        warningLabel.text = " "
+    }
+}
+
+// MARK: -
+
+// TODO:
+extension PaymentsViewPassphraseConfirmViewController: UITextFieldDelegate {
+    public func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -> Bool {
+        return true
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseGridViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseGridViewController.swift
new file mode 100644
index 00000000000..2ca9e2649df
--- /dev/null
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseGridViewController.swift
@@ -0,0 +1,143 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public class PaymentsViewPassphraseGridViewController: OWSTableViewController2 {
+
+    private let passphrase: PaymentsPassphrase
+
+    private weak var viewPassphraseDelegate: PaymentsViewPassphraseDelegate?
+
+    private let bottomStack = UIStackView()
+
+    open override var bottomFooter: UIView? { bottomStack }
+
+    public required init(passphrase: PaymentsPassphrase,
+                         viewPassphraseDelegate: PaymentsViewPassphraseDelegate) {
+        self.passphrase = passphrase
+        self.viewPassphraseDelegate = viewPassphraseDelegate
+
+        super.init()
+
+        self.shouldAvoidKeyboard = true
+    }
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_TITLE",
+                                  comment: "Title for the 'view payments passphrase' view of the app settings.")
+
+        buildBottomView()
+        updateContents()
+    }
+
+    public override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        updateContents()
+    }
+
+    private func buildBottomView() {
+        let nextButton = OWSFlatButton.button(title: CommonStrings.nextButton,
+                                              font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                              titleColor: .white,
+                                              backgroundColor: .ows_accentBlue,
+                                              target: self,
+                                              selector: #selector(didTapNextButton))
+        nextButton.autoSetHeightUsingFont()
+
+        bottomStack.axis = .vertical
+        bottomStack.alignment = .fill
+        bottomStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        bottomStack.layoutMargins = UIEdgeInsets(top: 8, leading: hMargin, bottom: 0, trailing: hMargin)
+        bottomStack.addArrangedSubviews([
+            nextButton
+        ])
+    }
+
+    private func updateContents() {
+        updateTableContents()
+    }
+
+    private func updateTableContents() {
+        AssertIsOnMainThread()
+
+        let contents = OWSTableContents()
+
+        let section = OWSTableSection()
+        section.customHeaderView = buildHeader()
+        section.customFooterView = buildFooter()
+
+        let passphrase = self.passphrase
+        section.add(OWSTableItem(customCellBlock: {
+            let cell = OWSTableItem.newCell()
+            let passphraseGrid = PaymentsViewUtils.buildPassphraseGrid(passphrase: passphrase)
+            cell.contentView.addSubview(passphraseGrid)
+            passphraseGrid.autoPinEdgesToSuperviewMargins()
+            return cell
+        },
+        actionBlock: nil))
+        contents.addSection(section)
+
+        self.contents = contents
+    }
+
+    private func buildHeader() -> UIView {
+        let explanationLabel = UILabel()
+        explanationLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_WORDS_EXPLANATION",
+                                                  comment: "Header text for the 'review payments passphrase words' step in the 'view payments passphrase' settings.")
+        explanationLabel.font = .ows_dynamicTypeBody2Clamped
+        explanationLabel.textColor = Theme.secondaryTextAndIconColor
+        explanationLabel.textAlignment = .center
+        explanationLabel.numberOfLines = 0
+        explanationLabel.lineBreakMode = .byWordWrapping
+
+        let topStack = UIStackView(arrangedSubviews: [
+            explanationLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        topStack.layoutMargins = UIEdgeInsets(top: 32, leading: hMargin, bottom: 40, trailing: hMargin)
+        return topStack
+    }
+
+    private func buildFooter() -> UIView {
+        let explanationLabel = UILabel()
+        explanationLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_WORDS_FOOTER",
+                                                  comment: "Footer text for the 'review payments passphrase words' step in the 'view payments passphrase' settings.")
+        explanationLabel.font = .ows_dynamicTypeSubheadlineClamped
+        explanationLabel.textColor = Theme.secondaryTextAndIconColor
+        explanationLabel.textAlignment = .center
+        explanationLabel.numberOfLines = 0
+        explanationLabel.lineBreakMode = .byWordWrapping
+
+        let topStack = UIStackView(arrangedSubviews: [
+            explanationLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        let hMargin = 20 + OWSTableViewController2.cellHOuterMargin
+        topStack.layoutMargins = UIEdgeInsets(top: 16, leading: hMargin, bottom: 16, trailing: hMargin)
+        return topStack
+    }
+
+    // MARK: - Events
+
+    @objc
+    func didTapNextButton() {
+        guard let viewPassphraseDelegate = viewPassphraseDelegate else {
+            dismiss(animated: false, completion: nil)
+            return
+        }
+        let view = PaymentsViewPassphraseConfirmViewController(passphrase: passphrase,
+                                                               viewPassphraseDelegate: viewPassphraseDelegate)
+        navigationController?.pushViewController(view, animated: true)
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseSplashViewController.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseSplashViewController.swift
new file mode 100644
index 00000000000..667ea0fcd35
--- /dev/null
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewPassphraseSplashViewController.swift
@@ -0,0 +1,169 @@
+//
+//  Copyright (c) 2021 Open Whisper Systems. All rights reserved.
+//
+
+import Foundation
+
+public protocol PaymentsViewPassphraseDelegate: class {
+    func viewPassphraseDidComplete()
+}
+
+// MARK: -
+
+@objc
+public class PaymentsViewPassphraseSplashViewController: OWSViewController {
+
+    private let passphrase: PaymentsPassphrase
+
+    private let shouldShowConfirm: Bool
+
+    private weak var viewPassphraseDelegate: PaymentsViewPassphraseDelegate?
+
+    private let rootView = UIStackView()
+
+    public required init(passphrase: PaymentsPassphrase,
+                         shouldShowConfirm: Bool,
+                         viewPassphraseDelegate: PaymentsViewPassphraseDelegate) {
+        self.passphrase = passphrase
+        self.shouldShowConfirm = shouldShowConfirm
+        self.viewPassphraseDelegate = viewPassphraseDelegate
+
+        super.init()
+    }
+
+    public override func viewDidLoad() {
+        super.viewDidLoad()
+
+        title = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_TITLE",
+                                  comment: "Title for the 'view payments passphrase' view of the app settings.")
+
+        rootView.axis = .vertical
+        rootView.alignment = .fill
+        view.addSubview(rootView)
+        rootView.autoPin(toTopLayoutGuideOf: self, withInset: 0)
+        rootView.autoPin(toBottomLayoutGuideOf: self, withInset: 0)
+        rootView.autoPinWidthToSuperviewMargins()
+
+        updateContents()
+        updateNavbar()
+    }
+
+    private func updateNavbar() {
+        navigationItem.leftBarButtonItem = UIBarButtonItem(barButtonSystemItem: .stop,
+                                                           target: self,
+                                                           action: #selector(didTapDismiss),
+                                                           accessibilityIdentifier: "dismiss")
+    }
+
+    public override func viewWillAppear(_ animated: Bool) {
+        super.viewWillAppear(animated)
+
+        updateContents()
+        updateNavbar()
+    }
+
+    @objc
+    private func updateContents() {
+        AssertIsOnMainThread()
+
+        view.backgroundColor = Theme.tableViewBackgroundColor
+
+        let heroImage = UIImageView(image: UIImage(named: "recovery-phrase"))
+
+        let titleLabel = UILabel()
+        titleLabel.text = NSLocalizedString("SETTINGS_PAYMENTS_VIEW_PASSPHRASE_START_TITLE",
+                                            comment: "Title for the first step of the 'view payments passphrase' views.")
+        titleLabel.font = UIFont.ows_dynamicTypeTitle2Clamped.ows_semibold
+        titleLabel.textColor = Theme.primaryTextColor
+        titleLabel.textAlignment = .center
+
+        let explanationAttributed = NSMutableAttributedString()
+        explanationAttributed.append(NSLocalizedString("SETTINGS_PAYMENTS_PASSPHRASE_EXPLANATION",
+                                                       comment: "Explanation of the 'payments passphrase' in the 'view payments passphrase' settings."),
+                                     attributes: [
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped,
+                                        .foregroundColor: Theme.secondaryTextAndIconColor
+                                     ])
+        explanationAttributed.append(" ",
+                                     attributes: [
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped
+                                     ])
+        explanationAttributed.append(CommonStrings.learnMore,
+                                     attributes: [
+                                        .font: UIFont.ows_dynamicTypeBody2Clamped.ows_semibold,
+                                        .foregroundColor: Theme.primaryTextColor
+                                     ])
+
+        let explanationLabel = UILabel()
+        explanationLabel.attributedText = explanationAttributed
+        explanationLabel.textAlignment = .center
+        explanationLabel.numberOfLines = 0
+        explanationLabel.lineBreakMode = .byWordWrapping
+        explanationLabel.isUserInteractionEnabled = true
+        explanationLabel.addGestureRecognizer(UITapGestureRecognizer(target: self,
+                                                                     action: #selector(didTapExplanation)))
+
+        let topStack = UIStackView(arrangedSubviews: [
+            heroImage,
+            UIView.spacer(withHeight: 20),
+            titleLabel,
+            UIView.spacer(withHeight: 10),
+            explanationLabel
+        ])
+        topStack.axis = .vertical
+        topStack.alignment = .center
+        topStack.isLayoutMarginsRelativeArrangement = true
+        topStack.layoutMargins = UIEdgeInsets(hMargin: 20, vMargin: 0)
+
+        let startButton = OWSFlatButton.button(title: CommonStrings.startButton,
+                                               font: UIFont.ows_dynamicTypeBody.ows_semibold,
+                                               titleColor: .white,
+                                               backgroundColor: .ows_accentBlue,
+                                               target: self,
+                                               selector: #selector(didTapStartButton))
+        startButton.autoSetHeightUsingFont()
+
+        let vSpacerFactory = VSpacerFactory()
+
+        rootView.removeAllSubviews()
+        rootView.addArrangedSubviews([
+            vSpacerFactory.buildVSpacer(),
+            topStack,
+            vSpacerFactory.buildVSpacer(),
+            startButton
+        ])
+
+        vSpacerFactory.finalizeSpacers()
+    }
+
+    // MARK: - Events
+
+    @objc
+    func didTapDismiss() {
+        dismiss(animated: true, completion: nil)
+    }
+
+    @objc
+    func didTapStartButton() {
+        didTapNextButton()
+    }
+
+    @objc
+    private func didTapExplanation() {
+        // TODO: Need a support article link.
+    }
+
+    @objc
+    func didTapNextButton() {
+        AssertIsOnMainThread()
+
+        guard let viewPassphraseDelegate = viewPassphraseDelegate else {
+            dismiss(animated: false, completion: nil)
+            return
+        }
+
+        let view = PaymentsViewPassphraseGridViewController(passphrase: passphrase,
+                                                            viewPassphraseDelegate: viewPassphraseDelegate)
+        navigationController?.pushViewController(view, animated: true)
+    }
+}
diff --git a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewUtils.swift b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewUtils.swift
index 628edc43afe..6e28bbc37d2 100644
--- a/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewUtils.swift
+++ b/Signal/src/ViewControllers/AppSettings/Payments/PaymentsViewUtils.swift
@@ -100,6 +100,78 @@ public class PaymentsViewUtils: NSObject {
             }
         }
     }
+
+    static func buildPassphraseGrid(passphrase: PaymentsPassphrase) -> UIView {
+
+        struct WordAndIndex {
+            let word: String
+            let index: Int
+        }
+
+        let wordsAndIndices = passphrase.words.enumerated().map { (index, word) in
+            WordAndIndex(word: word, index: index)
+        }
+
+        func buildVStack(words: [WordAndIndex]) -> UIStackView {
+            let stack = UIStackView()
+            stack.axis = .vertical
+            stack.alignment = .fill
+            stack.spacing = 10
+
+            for wordAndIndex in words {
+                let attributedText = NSMutableAttributedString()
+                attributedText.append(OWSFormat.formatInt(wordAndIndex.index + 1),
+                                      attributes: [
+                                        .font: UIFont.ows_dynamicTypeBodyClamped,
+                                        .foregroundColor: Theme.secondaryTextAndIconColor
+                                      ])
+                attributedText.append(":",
+                                      attributes: [
+                                        .font: UIFont.ows_dynamicTypeBodyClamped,
+                                        .foregroundColor: Theme.secondaryTextAndIconColor
+                                      ])
+                attributedText.append(" ",
+                                      attributes: [
+                                        .font: UIFont.ows_dynamicTypeBodyClamped,
+                                        .foregroundColor: Theme.secondaryTextAndIconColor
+                                      ])
+                attributedText.append(wordAndIndex.word,
+                                      attributes: [
+                                        .font: UIFont.ows_dynamicTypeBodyClamped.ows_semibold,
+                                        .foregroundColor: Theme.primaryTextColor
+                                      ])
+                let wordLabel = UILabel()
+                wordLabel.attributedText = attributedText
+                stack.addArrangedSubview(wordLabel)
+            }
+
+            return stack
+        }
+
+        // Half the words on the each side. If there's an odd number,
+        // we want more on the left.
+        let pivotIndex = wordsAndIndices.count - (wordsAndIndices.count / 2)
+        let leftWords = Array(wordsAndIndices.prefix(pivotIndex))
+        let rightWords = Array(wordsAndIndices.suffix(from: pivotIndex))
+        let leftWordsStack = buildVStack(words: leftWords)
+        let rightWordsStack = buildVStack(words: rightWords)
+        let allWordStack = UIStackView(arrangedSubviews: [ leftWordsStack, rightWordsStack ])
+        allWordStack.axis = .horizontal
+        allWordStack.alignment = .center
+        allWordStack.distribution = .fillEqually
+        allWordStack.spacing = 20
+
+        let stack = UIStackView(arrangedSubviews: [ allWordStack ])
+        stack.axis = .vertical
+        stack.alignment = .fill
+        stack.spacing = 24
+        stack.isLayoutMarginsRelativeArrangement = true
+        stack.layoutMargins = UIEdgeInsets(hMargin: 20, vMargin: 24)
+        stack.addBackgroundView(withBackgroundColor: Theme.backgroundColor,
+                                cornerRadius: 10)
+
+        return stack
+    }
 }
 
 // MARK: -
diff --git a/Signal/translations/en.lproj/Localizable.strings b/Signal/translations/en.lproj/Localizable.strings
index 6f134d05fa3..0af06dae300 100644
--- a/Signal/translations/en.lproj/Localizable.strings
+++ b/Signal/translations/en.lproj/Localizable.strings
@@ -400,6 +400,9 @@
 /* Label for generic done button. */
 "BUTTON_DONE" = "Done";
 
+/* Label for the 'edit' button. */
+"BUTTON_EDIT" = "Edit";
+
 /* Label for the 'next' button. */
 "BUTTON_NEXT" = "Next";
 
@@ -412,9 +415,15 @@
 /* Label for the 'okay' button. */
 "BUTTON_OKAY" = "Okay";
 
+/* Label for the 'previous' button. */
+"BUTTON_PREVIOUS" = "Previous";
+
 /* Button text to enable batch selection mode */
 "BUTTON_SELECT" = "Select";
 
+/* Label for the 'start' button. */
+"BUTTON_START" = "Start";
+
 /* Label for the 'submit' button. */
 "BUTTON_SUBMIT" = "Submit";
 
@@ -4837,6 +4846,9 @@
 /* Title for the 'payments opt-in' view in the app settings. */
 "SETTINGS_PAYMENTS_OPT_IN_TITLE" = "Introducing Payments";
 
+/* Explanation of the 'payments passphrase' in the 'view payments passphrase' settings. */
+"SETTINGS_PAYMENTS_PASSPHRASE_EXPLANATION" = "Your recovery phrase is a 12-word phrase unique to you. Write it down and store it in a safe place. You can use this phrase to restore your balance.";
+
 /* Label for the 'add money' button in the 'send payment' UI. */
 "SETTINGS_PAYMENTS_PAYMENT_ADD_MONEY" = "Add Money";
 
@@ -4891,6 +4903,48 @@
 /* Label for the 'remove payments details' button in the app settings. */
 "SETTINGS_PAYMENTS_REMOVE_BUTTON" = "Remove";
 
+/* Label for 'restore payments' button in the payments settings. */
+"SETTINGS_PAYMENTS_RESTORE_PAYMENTS_BUTTON" = "Restore a Payments Account";
+
+/* Explanation of the 'review payments passphrase' step of the 'restore payments wallet' views. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_COMPLETE_EXPLANATION" = "Make sure youve entered your phrase correctly.";
+
+/* Title for the 'review payments passphrase' step of the 'restore payments wallet' views. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_COMPLETE_TITLE" = "Confirm Recovery Phrase";
+
+/* Message indicating that 'restore payments wallet' is complete. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_COMPLETE_TOAST" = "Payments account restored.";
+
+/* Error indicating that 'restore payments wallet failed' in the app payments settings. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_FAILED" = "Recovery Failed";
+
+/* Message for the 'invalid payments wallet passphrase' error alert in the app payments settings. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_INVALID_PASSPHRASE_MESSAGE" = "This is not a valid recovery phrase.";
+
+/* Title for the 'invalid payments wallet passphrase' error alert in the app payments settings. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_INVALID_PASSPHRASE_TITLE" = "Invalid phrase";
+
+/* Explanation of the 'restore payments wallet' process payments settings. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_SPLASH_EXPLANATION" = "Your recovery phrase is a 12-word phrase unique to you. Use it to restore your payments account.";
+
+/* Title for the first step of the 'restore payments wallet' views. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_SPLASH_TITLE" = "Enter Recovery Phrase";
+
+/* Title for the 'restore payments wallet' view of the app settings. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_TITLE" = "Recovery Phrase";
+
+/* Format for the instructions for the 'enter word' step of the 'restore payments wallet' views. Embeds {{ the index of the current word }}. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_INSTRUCTIONS_FORMAT" = "Enter word %@";
+
+/* Error indicating that the user has entered an invalid payments passphrase in the 'restore payments wallet' views. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_INVALID_PASSPHRASE" = "Invalid phrase";
+
+/* Error indicating that the user has entered an invalid word in the 'enter word' step of the 'restore payments wallet' views. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_INVALID_WORD" = "Word is spelled incorrectly.";
+
+/* Title for the 'enter word' step of the 'restore payments wallet' views. */
+"SETTINGS_PAYMENTS_RESTORE_WALLET_WORD_TITLE" = "Enter Recovery Phrase";
+
 /* Instructions in the 'scan payment address QR code' view in the payment settings. */
 "SETTINGS_PAYMENTS_SCAN_QR_INSTRUCTIONS" = "Scan the QR Code for the transfer recipient.";
 
@@ -4930,6 +4984,45 @@
 /* Label for the 'transfer to exchange' button in the payment settings. */
 "SETTINGS_PAYMENTS_TRANSFER_TO_EXCHANGE" = "Transfer to Exchange";
 
+/* Message indicating that 'payments passphrase review' is complete. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_COMPLETE_TOAST" = "Recovery phrase setup complete.";
+
+/* Label for 'confirm' button in the 'view payments passphrase' view of the app settings. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM" = "Confirm";
+
+/* Explanation of the 'confirm payments passphrase word' step in the 'view payments passphrase' settings. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_EXPLANATION" = "Enter the following words from your recovery phase.";
+
+/* Error indicating that at least one word of the payments passphrase is not correct in the 'view payments passphrase' views. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_INVALID_WORD" = "A word is incorrect. Try again.";
+
+/* Error indicating that all words of the payments passphrase are not correct in the 'view payments passphrase' views. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_INVALID_WORDS" = "Both words are incorrect. Try again.";
+
+/* Format for the placeholder text in the 'confirm payments passphrase' view of the app settings. Embeds: {{ the index of the word }}. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_PLACEHOLDER_FORMAT" = "Word %@";
+
+/* Title for the 'confirm words' step of the 'view payments passphrase' views. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_CONFIRM_TITLE" = "Confirm Recovery Phrase";
+
+/* Label for 'see passphrase again' button in the 'view payments passphrase' view of the app settings. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_SEE_PASSPHRASE_AGAIN" = "See Phrase Again";
+
+/* Title for the first step of the 'view payments passphrase' views. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_START_TITLE" = "View Recovery Phrase";
+
+/* Title for the 'view payments passphrase' view of the app settings. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_TITLE" = "Recovery Phrase";
+
+/* Header text for the 'review payments passphrase words' step in the 'view payments passphrase' settings. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_WORDS_EXPLANATION" = "Write down the following 24 words in order. Store your list in a secure place.";
+
+/* Footer text for the 'review payments passphrase words' step in the 'view payments passphrase' settings. */
+"SETTINGS_PAYMENTS_VIEW_PASSPHRASE_WORDS_FOOTER" = "Do not screenshot or send by email.";
+
+/* Label for 'view payments recovery passphrase' button in the app settings. */
+"SETTINGS_PAYMENTS_VIEW_RECOVERY_PASSPHRASE" = "View Recovery Phrase";
+
 /* Label for the payments wallet address. */
 "SETTINGS_PAYMENTS_WALLET_ADDRESS_LABEL" = "Your Wallet Address";
 
diff --git a/SignalMessaging/Payments/PaymentsImpl.swift b/SignalMessaging/Payments/PaymentsImpl.swift
index 94bb6c5abf4..a8942a131f9 100644
--- a/SignalMessaging/Payments/PaymentsImpl.swift
+++ b/SignalMessaging/Payments/PaymentsImpl.swift
@@ -133,9 +133,9 @@ public class PaymentsImpl: NSObject, PaymentsSwift {
     // the service, so we cache and reuse instances.
     func getMobileCoinAPI() -> Promise<MobileCoinAPI> {
         switch paymentsState {
-        case .enabled(let mcRootEntropy):
+        case .enabled(_, let mcRootEntropy):
             return getOrBuildCurrentApi(mcRootEntropy: mcRootEntropy)
-        case .disabled, .disabledWithMCRootEntropy:
+        case .disabled, .disabledWithPaymentsEntropy:
             return Promise(error: PaymentsError.notEnabled)
         }
     }
@@ -174,7 +174,7 @@ public class PaymentsImpl: NSObject, PaymentsSwift {
     // MARK: - PaymentsState
 
     private static let arePaymentsEnabledKey = "isPaymentEnabled"
-    private static let mcRootEntropyKey = "rootEntropyBytes"
+    private static let paymentsEntropyKey = "paymentsEntropy"
 
     private let paymentStateCache = AtomicOptional<PaymentsState>(nil)
 
@@ -195,41 +195,104 @@ public class PaymentsImpl: NSObject, PaymentsSwift {
         paymentsState.isEnabled
     }
 
+    public var paymentsEntropy: Data? {
+        paymentsState.paymentsEntropy
+    }
+
     public var mcRootEntropy: Data? {
         paymentsState.mcRootEntropy
     }
 
+    public static var paymentsEntropyLength: UInt {
+        // TODO: This is wrong; pending SDK changes.
+        MobileCoinAPI.rootEntropyLength
+    }
+
+    public static var mcRootEntropyLength: UInt {
+        // PAYMENTS TODO: Confirm this is correct.
+        MobileCoinAPI.rootEntropyLength
+    }
+
+    public var paymentsEntropyLength: UInt {
+        Self.paymentsEntropyLength
+    }
+
+    public var mcRootEntropyLength: UInt {
+        Self.mcRootEntropyLength
+    }
+
+    public static func mcRootEntropy(forPaymentsEntropy paymentsEntropy: Data) -> Data? {
+        guard paymentsEntropy.count == paymentsEntropyLength else {
+            owsFailDebug("paymentsEntropy has invalid length: \(paymentsEntropy.count) != \(paymentsEntropyLength).")
+            return nil
+        }
+        // TODO: This is wrong; pending SDK changes.
+        return paymentsEntropy
+    }
+
+    public func mcRootEntropy(forPaymentsEntropy paymentsEntropy: Data) -> Data? {
+        Self.mcRootEntropy(forPaymentsEntropy: paymentsEntropy)
+    }
+
+    public func enablePayments(transaction: SDSAnyWriteTransaction) {
+        // We must preserve any existing paymentsEntropy.
+        let paymentsEntropy = self.paymentsEntropy ?? Self.generateRandomPaymentsEntropy()
+        _ = enablePayments(withPaymentsEntropy: paymentsEntropy, transaction: transaction)
+    }
+
+    public func enablePayments(withPaymentsEntropy newPaymentsEntropy: Data, transaction: SDSAnyWriteTransaction) -> Bool {
+        let oldPaymentsEntropy = Self.loadPaymentsState(transaction: transaction).paymentsEntropy
+        guard oldPaymentsEntropy == nil || oldPaymentsEntropy == newPaymentsEntropy else {
+            owsFailDebug("paymentsEntropy is already set.")
+            return false
+        }
+        let paymentsState = PaymentsState.build(arePaymentsEnabled: true,
+                                                paymentsEntropy: newPaymentsEntropy)
+        owsAssertDebug(paymentsState.isEnabled)
+        setPaymentsState(paymentsState, transaction: transaction)
+        owsAssertDebug(arePaymentsEnabled)
+        return true
+    }
+
     public func disablePayments(transaction: SDSAnyWriteTransaction) {
         switch paymentsState {
-        case .enabled(let mcRootEntropy):
-            setPaymentsState(.disabledWithMCRootEntropy(mcRootEntropy: mcRootEntropy),
+        case .enabled(let paymentsEntropy, _):
+            setPaymentsState(.disabledWithPaymentsEntropy(paymentsEntropy: paymentsEntropy),
                              transaction: transaction)
-        case .disabled, .disabledWithMCRootEntropy:
+        case .disabled, .disabledWithPaymentsEntropy:
             owsFailDebug("Payments already disabled.")
         }
         owsAssertDebug(!arePaymentsEnabled)
     }
 
-    public func setPaymentsState(_ paymentsState: PaymentsState, transaction: SDSAnyWriteTransaction) {
-        guard paymentsState.isEnabled || canEnablePayments else {
+    public func setPaymentsState(_ newPaymentsState: PaymentsState, transaction: SDSAnyWriteTransaction) {
+        let oldPaymentsState = self.paymentsState
+
+        guard oldPaymentsState.isEnabled || canEnablePayments else {
             owsFailDebug("Payments cannot be enabled.")
             return
         }
-        guard paymentsState != self.paymentsState else {
+        guard newPaymentsState != oldPaymentsState else {
             Logger.verbose("Ignoring redundant change.")
             return
         }
+        if let oldPaymentsEntropy = oldPaymentsState.paymentsEntropy,
+           let newPaymentsEntropy = newPaymentsState.paymentsEntropy,
+           oldPaymentsEntropy != newPaymentsEntropy {
+            Logger.verbose("oldPaymentsEntropy: \(oldPaymentsEntropy.hexadecimalString) != newPaymentsEntropy: \(newPaymentsEntropy.hexadecimalString).")
+            owsFailDebug("paymentsEntropy does not match.")
+        }
 
-        Self.keyValueStore.setBool(paymentsState.isEnabled,
+        Self.keyValueStore.setBool(newPaymentsState.isEnabled,
                                    key: Self.arePaymentsEnabledKey,
                                    transaction: transaction)
-        if let mcRootEntropy = paymentsState.mcRootEntropy {
-            Self.keyValueStore.setData(mcRootEntropy,
-                                       key: Self.mcRootEntropyKey,
+        if let paymentsEntropy = newPaymentsState.paymentsEntropy {
+            Self.keyValueStore.setData(paymentsEntropy,
+                                       key: Self.paymentsEntropyKey,
                                        transaction: transaction)
         }
 
-        self.paymentStateCache.set(paymentsState)
+        self.paymentStateCache.set(newPaymentsState)
 
         transaction.addAsyncCompletion {
             NotificationCenter.default.postNotificationNameAsync(Self.arePaymentsEnabledDidChange, object: nil)
@@ -246,7 +309,7 @@ public class PaymentsImpl: NSObject, PaymentsSwift {
         guard FeatureFlags.payments else {
             return .disabled
         }
-        func loadMCRootEntropy() -> Data? {
+        func loadPaymentsEntropy() -> Data? {
             guard storageCoordinator.isStorageReady else {
                 owsFailDebug("Storage is not ready.")
                 return nil
@@ -254,31 +317,28 @@ public class PaymentsImpl: NSObject, PaymentsSwift {
             guard tsAccountManager.isRegisteredAndReady else {
                 return nil
             }
+            // TODO: We'll need to revisit this once SDK supports entropy derivation.
             if DevFlags.useFakeRootEntropy_self,
                let localAddress = tsAccountManager.localAddress,
                hasFakeRootEntropy(forAddress: localAddress) {
                 return fakeRootEntropy(forAddress: localAddress)
             } else {
-                return keyValueStore.getData(mcRootEntropyKey, transaction: transaction)
+                return keyValueStore.getData(paymentsEntropyKey, transaction: transaction)
             }
         }
-
-        guard let mcRootEntropy = loadMCRootEntropy() else {
+        guard let paymentsEntropy = loadPaymentsEntropy() else {
             return .disabled
         }
-        let isEnabled = keyValueStore.getBool(Self.arePaymentsEnabledKey,
-                                              defaultValue: false,
-                                              transaction: transaction)
-        if isEnabled {
-            return .enabled(mcRootEntropy: mcRootEntropy)
-        } else {
-            return .disabledWithMCRootEntropy(mcRootEntropy: mcRootEntropy)
-        }
+        let arePaymentsEnabled = keyValueStore.getBool(Self.arePaymentsEnabledKey,
+                                                       defaultValue: false,
+                                                       transaction: transaction)
+        return PaymentsState.build(arePaymentsEnabled: arePaymentsEnabled,
+                                   paymentsEntropy: paymentsEntropy)
     }
 
-    public func generateRandomMobileCoinRootEntropy() -> Data {
+    public static func generateRandomPaymentsEntropy() -> Data {
         // PAYMENTS TODO: Confirm this is correct.
-        Cryptography.generateRandomBytes(MobileCoinAPI.rootEntropyLength)
+        Cryptography.generateRandomBytes(paymentsEntropyLength)
     }
 
     // MARK: - Public Keys
@@ -573,9 +633,6 @@ public extension PaymentsImpl {
                                                paymentRequestModel: TSPaymentRequestModel?,
                                                isOutgoingTransfer: Bool) -> Promise<TSPaymentModel> {
         firstly(on: .global()) {
-            guard recipientAddress != nil else {
-                throw OWSAssertionError("Missing recipient.")
-            }
             var addressUuidString: String?
             if let recipientAddress = recipientAddress {
                 guard recipientAddress.isValid else {
@@ -1302,6 +1359,88 @@ public extension PaymentsImpl {
     }
 }
 
+// MARK: - Passphrases
+
+public extension PaymentsImpl {
+
+    var passphrase: PaymentsPassphrase? {
+        guard let paymentsEntropy = paymentsEntropy else {
+            owsFailDebug("Missing paymentsEntropy.")
+            return nil
+        }
+        return passphrase(forPaymentsEntropy: paymentsEntropy)
+    }
+
+    // See: https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt
+    func passphrase(forPaymentsEntropy paymentsEntropy: Data) -> PaymentsPassphrase? {
+        // TODO: This is temporary until the SDK supports passphrases.
+        return PaymentsPassphrase(words: Array(allPossiblePassphraseWords.prefix(PaymentsConstants.passphraseWordCount)))
+    }
+
+    func paymentsEntropy(forPassphrase passphrase: PaymentsPassphrase) -> Data? {
+        // TODO: This is temporary until the SDK supports passphrases.
+        if passphrase == self.passphrase {
+            return self.paymentsEntropy
+        } else {
+            return Self.generateRandomPaymentsEntropy()
+        }
+    }
+
+    var allPossiblePassphraseWords: [String] {
+        // TODO: This is temporary until the SDK supports passphrases.
+        [
+            "abandon",
+            "ability",
+            "able",
+            "about",
+            "above",
+            "absent",
+            "absorb",
+            "abstract",
+            "absurd",
+            "abuse",
+            "access",
+            "accident",
+            "account",
+            "accuse",
+            "achieve",
+            "acid",
+            "acoustic",
+            "acquire",
+            "across",
+            "act",
+            "action",
+            "actor",
+            "actress",
+            "actual",
+            "adapt",
+            "add",
+            "addict",
+            "address",
+            "adjust",
+            "admit",
+            "adult",
+            "advance",
+            "advice",
+            "aerobic",
+            "affair",
+            "afford",
+            "afraid",
+            "again",
+            "age",
+            "agent",
+            "agree",
+            "ahead",
+            "aim",
+            "air",
+            "airport",
+            "aisle",
+            "alarm",
+            "album"
+        ]
+    }
+}
+
 // MARK: - Formatting
 
 public extension PaymentsImpl {
diff --git a/SignalMessaging/Payments/PaymentsProcessor.swift b/SignalMessaging/Payments/PaymentsProcessor.swift
index 73f5d26dbe2..b7b73147faa 100644
--- a/SignalMessaging/Payments/PaymentsProcessor.swift
+++ b/SignalMessaging/Payments/PaymentsProcessor.swift
@@ -331,7 +331,7 @@ extension PaymentsProcessor: UIDatabaseSnapshotDelegate {
 extension PaymentsProcessor: PaymentProcessingOperationDelegate {
 
     static func canBeProcessed(paymentModel: TSPaymentModel) -> Bool {
-        guard paymentModel.isIdentifiedPayment else {
+        guard paymentModel.isIdentifiedPayment || paymentModel.isOutgoingTransfer else {
             return false
         }
         guard !paymentModel.isComplete && !paymentModel.isFailed else {
diff --git a/SignalMessaging/Storage Service/StorageServiceManager.swift b/SignalMessaging/Storage Service/StorageServiceManager.swift
index 316db8e98ca..dfa1f7bb6f4 100644
--- a/SignalMessaging/Storage Service/StorageServiceManager.swift	
+++ b/SignalMessaging/Storage Service/StorageServiceManager.swift	
@@ -43,7 +43,8 @@ public class StorageServiceManager: NSObject, StorageServiceManagerProtocol {
         }
     }
 
-    @objc private func willResignActive() {
+    @objc
+    private func willResignActive() {
         // If we have any pending changes, start a back up immediately
         // to try and make sure the service doesn't get stale. If for
         // some reason we aren't able to successfully complete this backup
@@ -51,6 +52,16 @@ public class StorageServiceManager: NSObject, StorageServiceManagerProtocol {
         backupPendingChanges()
     }
 
+    public func hasEverBackedUpOrRestored(transaction: SDSAnyReadTransaction) -> Bool {
+        // If we don't have backup keys, we know we've never backed up or restored.
+        guard KeyBackupService.DerivedKey.storageService.isAvailable else {
+            return false
+        }
+        let state = StorageServiceOperation.State.current(transaction: transaction)
+        // TODO: Verify with Nora that this test is correct.
+        return state.manifestVersion > 0
+    }
+
     // MARK: -
 
     @objc
@@ -1515,7 +1526,7 @@ class StorageServiceOperation: OWSOperation {
 
     private static var maxConsecutiveConflicts = 3
 
-    private struct State: Codable {
+    fileprivate struct State: Codable {
         var manifestVersion: UInt64 = 0
         private var _refetchLatestManifest: Bool?
         var refetchLatestManifest: Bool {
diff --git a/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift b/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift
index 1fc44c46489..625d361c875 100644
--- a/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift	
+++ b/SignalMessaging/Storage Service/StorageServiceProto+Sync.swift	
@@ -553,10 +553,8 @@ extension StorageServiceProtoAccountRecord: Dependencies {
         let paymentsState = paymentsSwift.paymentsState
         var paymentsBuilder = StorageServiceProtoAccountRecordPayments.builder()
         paymentsBuilder.setEnabled(paymentsState.isEnabled)
-        if let mcRootEntropy = paymentsState.mcRootEntropy {
-            var mobileCoinBuilder = StorageServiceProtoAccountRecordPaymentsMobileCoin.builder()
-            mobileCoinBuilder.setRootEntropy(mcRootEntropy)
-            paymentsBuilder.setMobileCoin(try mobileCoinBuilder.build())
+        if let paymentsEntropy = paymentsState.paymentsEntropy {
+            paymentsBuilder.setPaymentsEntropy(paymentsEntropy)
         }
         builder.setPayments(try paymentsBuilder.build())
 
@@ -714,17 +712,17 @@ extension StorageServiceProtoAccountRecord: Dependencies {
 
         let localPaymentsState = Self.paymentsSwift.paymentsState
         let servicePaymentsState = PaymentsState.build(arePaymentsEnabled: self.payments?.enabled ?? false,
-                                                       mcRootEntropy: self.payments?.mobileCoin?.rootEntropy)
+                                                       paymentsEntropy: self.payments?.paymentsEntropy)
         if localPaymentsState != servicePaymentsState {
             // Merge with payments states.
             //
             // 1. Honor "arePaymentsEnabled" from the service.
             let arePaymentsEnabled = servicePaymentsState.isEnabled
-            // 2. Prefer mcRootEntropy from service, but try to retain local
-            //    mcRootEntropy otherwise.
-            let mcRootEntropy = servicePaymentsState.mcRootEntropy ?? localPaymentsState.mcRootEntropy
+            // 2. Prefer paymentsEntropy from service, but try to retain local
+            //    paymentsEntropy otherwise.
+            let paymentsEntropy = servicePaymentsState.paymentsEntropy ?? localPaymentsState.paymentsEntropy
             let mergedPaymentsState = PaymentsState.build(arePaymentsEnabled: arePaymentsEnabled,
-                                                          mcRootEntropy: mcRootEntropy)
+                                                          paymentsEntropy: paymentsEntropy)
 
             Self.paymentsSwift.setPaymentsState(mergedPaymentsState, transaction: transaction)
         }
diff --git a/SignalMessaging/ViewControllers/OWSTableViewController2.swift b/SignalMessaging/ViewControllers/OWSTableViewController2.swift
index 9d0a1efb0f8..45fbe0e9f1a 100644
--- a/SignalMessaging/ViewControllers/OWSTableViewController2.swift
+++ b/SignalMessaging/ViewControllers/OWSTableViewController2.swift
@@ -33,6 +33,9 @@ open class OWSTableViewController2: OWSViewController {
     @objc
     open var topHeader: UIView?
 
+    @objc
+    open var bottomFooter: UIView? { nil }
+
     // TODO: Remove.
     @objc
     public var tableViewStyle: UITableView.Style {
@@ -92,6 +95,7 @@ open class OWSTableViewController2: OWSViewController {
 
         view.addSubview(tableView)
 
+        // Pin top edge of tableView.
         if let topHeader = topHeader {
             view.addSubview(topHeader)
             topHeader.autoPin(toTopLayoutGuideOf: self, withInset: 0)
@@ -99,37 +103,50 @@ open class OWSTableViewController2: OWSViewController {
             topHeader.autoPinEdge(toSuperviewSafeArea: .trailing)
 
             tableView.autoPinEdge(.top, to: .bottom, of: topHeader)
-            tableView.autoPinEdge(toSuperviewEdge: .leading)
-            tableView.autoPinEdge(toSuperviewEdge: .trailing)
-
-            if shouldAvoidKeyboard {
-                autoPinView(toBottomOfViewControllerOrKeyboard: tableView, avoidNotch: true)
-            } else {
-                tableView.autoPinEdge(toSuperviewEdge: .bottom)
-            }
 
             topHeader.setContentHuggingVerticalHigh()
             topHeader.setCompressionResistanceVerticalHigh()
-            tableView.setContentHuggingVerticalLow()
-            tableView.setCompressionResistanceVerticalLow()
         } else if tableView.applyInsetsFix() {
             // if applyScrollViewInsetsFix disables contentInsetAdjustmentBehavior,
             // we need to pin to the top and bottom layout guides since UIKit
             // won't adjust our content insets.
             tableView.autoPin(toTopLayoutGuideOf: self, withInset: 0)
-            tableView.autoPin(toBottomLayoutGuideOf: self, withInset: 0)
-            tableView.autoPinEdge(toSuperviewSafeArea: .leading)
-            tableView.autoPinEdge(toSuperviewSafeArea: .trailing)
 
             // We don't need a top or bottom insets, since we pin to the top and bottom layout guides.
             automaticallyAdjustsScrollViewInsets = false
         } else {
+            tableView.autoPinEdge(toSuperviewEdge: .top)
+        }
+
+        // Pin leading & trailing edges of tableView.
+        tableView.autoPinEdge(toSuperviewEdge: .leading)
+        tableView.autoPinEdge(toSuperviewEdge: .trailing)
+        tableView.setContentHuggingVerticalLow()
+        tableView.setCompressionResistanceVerticalLow()
+
+        // Pin bottom edge of tableView.
+        if let bottomFooter = bottomFooter {
+            view.addSubview(bottomFooter)
+            bottomFooter.autoPinEdge(.top, to: .bottom, of: tableView)
+            bottomFooter.autoPinEdge(toSuperviewSafeArea: .leading)
+            bottomFooter.autoPinEdge(toSuperviewSafeArea: .trailing)
             if shouldAvoidKeyboard {
-                tableView.autoPinEdgesToSuperviewEdges(with: .zero, excludingEdge: .bottom)
-                autoPinView(toBottomOfViewControllerOrKeyboard: tableView, avoidNotch: true)
+                autoPinView(toBottomOfViewControllerOrKeyboard: bottomFooter, avoidNotch: true)
             } else {
-                tableView.autoPinEdgesToSuperviewEdges()
+                bottomFooter.autoPinEdge(toSuperviewEdge: .bottom)
             }
+
+            bottomFooter.setContentHuggingVerticalHigh()
+            bottomFooter.setCompressionResistanceVerticalHigh()
+        } else if tableView.applyInsetsFix() {
+            // if applyScrollViewInsetsFix disables contentInsetAdjustmentBehavior,
+            // we need to pin to the top and bottom layout guides since UIKit
+            // won't adjust our content insets.
+            tableView.autoPin(toBottomLayoutGuideOf: self, withInset: 0)
+        } else if shouldAvoidKeyboard {
+            autoPinView(toBottomOfViewControllerOrKeyboard: tableView, avoidNotch: true)
+        } else {
+            tableView.autoPinEdge(toSuperviewEdge: .bottom)
         }
 
         tableView.register(UITableViewCell.self, forCellReuseIdentifier: Self.cellIdentifier)
diff --git a/SignalMessaging/Views/CommonStrings.swift b/SignalMessaging/Views/CommonStrings.swift
index cbe912a2a0c..744a5284b68 100644
--- a/SignalMessaging/Views/CommonStrings.swift
+++ b/SignalMessaging/Views/CommonStrings.swift
@@ -31,6 +31,9 @@ import Foundation
     @objc
     static public let nextButton = NSLocalizedString("BUTTON_NEXT", comment: "Label for the 'next' button.")
 
+    @objc
+    static public let previousButton = NSLocalizedString("BUTTON_PREVIOUS", comment: "Label for the 'previous' button.")
+
     @objc
     static public let skipButton = NSLocalizedString("NAVIGATION_ITEM_SKIP_BUTTON", comment: "A button to skip a view.")
 
@@ -55,6 +58,9 @@ import Foundation
     @objc
     static public let copyButton = NSLocalizedString("BUTTON_COPY", comment: "Label for the 'copy' button.")
 
+    @objc
+    static public let editButton = NSLocalizedString("BUTTON_EDIT", comment: "Label for the 'edit' button.")
+
     @objc
     static public let help = NSLocalizedString("SETTINGS_HELP", comment: "Title for help button and help pages in app settings.")
 
@@ -115,6 +121,9 @@ import Foundation
     @objc
     static public let viewButton = NSLocalizedString("BUTTON_VIEW", comment: "Label for the 'view' button.")
 
+    @objc
+    static public let startButton = NSLocalizedString("BUTTON_START", comment: "Label for the 'start' button.")
+
     @objc
     static public let genericError = NSLocalizedString("ALERT_ERROR_TITLE", comment: "Generic error indicator.")
 
diff --git a/SignalMessaging/Views/Toast.swift b/SignalMessaging/Views/Toast.swift
index c93c7fc3331..b03f521db04 100644
--- a/SignalMessaging/Views/Toast.swift
+++ b/SignalMessaging/Views/Toast.swift
@@ -184,11 +184,11 @@ public extension UIView {
 
 @objc
 public extension UIViewController {
-    func presentToast(text: String) {
+    func presentToast(text: String, extraVInset: CGFloat = 0) {
         let toastController = ToastController(text: text)
         // TODO: There should be a better way to do this.
         // TODO: Take into account the keyboard height.
-        let bottomInset = bottomLayoutGuide.length + 8
+        let bottomInset = bottomLayoutGuide.length + 8 + extraVInset
         toastController.presentToastView(fromBottomOfView: view, inset: bottomInset)
     }
 }
diff --git a/SignalServiceKit/protobuf/StorageService.proto b/SignalServiceKit/protobuf/StorageService.proto
index cda9ef58374..48214f8d9c7 100644
--- a/SignalServiceKit/protobuf/StorageService.proto
+++ b/SignalServiceKit/protobuf/StorageService.proto
@@ -131,11 +131,8 @@ message AccountRecord {
   }
 
   message Payments {
-    message MobileCoin {
-      bytes rootEntropy = 1;
-    }
-    bool       enabled    = 1;
-    MobileCoin mobileCoin = 2;
+    bool  enabled         = 1;
+    bytes paymentsEntropy = 2;
   }
 
            bytes                  profileKey                   = 1;
diff --git a/SignalServiceKit/src/Payments/Payments.swift b/SignalServiceKit/src/Payments/Payments.swift
index 85b850390a2..5a5559f747a 100644
--- a/SignalServiceKit/src/Payments/Payments.swift
+++ b/SignalServiceKit/src/Payments/Payments.swift
@@ -47,8 +47,16 @@ public protocol Payments: AnyObject {
 
     var shouldShowPaymentsUI: Bool { get }
 
+    var paymentsEntropy: Data? { get }
+
     var mcRootEntropy: Data? { get }
 
+    var paymentsEntropyLength: UInt { get }
+
+    var mcRootEntropyLength: UInt { get }
+
+    func mcRootEntropy(forPaymentsEntropy paymentsEntropy: Data) -> Data?
+
     func isValidMobileCoinPublicAddress(_ publicAddressData: Data) -> Bool
 
     func setArePaymentsEnabled(for address: SignalServiceAddress, hasPaymentsEnabled: Bool, transaction: SDSAnyWriteTransaction)
@@ -113,8 +121,9 @@ public protocol PaymentsSwift: Payments {
 
     var paymentsState: PaymentsState { get }
     func setPaymentsState(_ value: PaymentsState, transaction: SDSAnyWriteTransaction)
+    func enablePayments(transaction: SDSAnyWriteTransaction)
+    func enablePayments(withPaymentsEntropy: Data, transaction: SDSAnyWriteTransaction) -> Bool
     func disablePayments(transaction: SDSAnyWriteTransaction)
-    func generateRandomMobileCoinRootEntropy() -> Data
 
     var currentPaymentBalance: PaymentBalance? { get }
     func updateCurrentPaymentBalance()
@@ -129,6 +138,14 @@ public protocol PaymentsSwift: Payments {
                                   isOutgoingTransfer: Bool) -> Promise<TSPaymentModel>
 
     func maximumPaymentAmount(forBalance balance: PaymentBalance) -> Promise<TSPaymentAmount>
+
+    var passphrase: PaymentsPassphrase? { get }
+
+    func passphrase(forPaymentsEntropy paymentsEntropy: Data) -> PaymentsPassphrase?
+
+    func paymentsEntropy(forPassphrase passphrase: PaymentsPassphrase) -> Data?
+
+    var allPossiblePassphraseWords: [String] { get }
 }
 
 // MARK: -
@@ -152,18 +169,53 @@ public struct PaymentBalance {
 // MARK: -
 
 public enum PaymentsState: Equatable {
+
+    // MARK: - Dependencies
+
+    private static var payments: Payments {
+        SSKEnvironment.shared.payments
+    }
+
+    // MARK: -
+
     case disabled
-    case enabled(mcRootEntropy: Data)
-    case disabledWithMCRootEntropy(mcRootEntropy: Data)
+    case disabledWithPaymentsEntropy(paymentsEntropy: Data)
+    case enabled(paymentsEntropy: Data, mcRootEntropy: Data)
 
-    public static func build(arePaymentsEnabled: Bool, mcRootEntropy: Data?) -> PaymentsState {
-        guard let mcRootEntropy = mcRootEntropy else {
+    // We should almost always construct instances of PaymentsState
+    // using this method.  It enforces important invariants.
+    //
+    // * paymentsEntropy is not discarded.
+    // * Payments are only enabled if mcRootEntropy can be derived from
+    //   paymentsEntropy.
+    // * Payments are only enabled if paymentsEntropy and mcRootEntropy
+    //   have valid length.
+    public static func build(arePaymentsEnabled: Bool,
+                             paymentsEntropy: Data?) -> PaymentsState {
+        guard let paymentsEntropy = paymentsEntropy else {
             return .disabled
         }
+        guard paymentsEntropy.count == payments.paymentsEntropyLength else {
+            owsFailDebug("paymentsEntropy has invalid length: \(paymentsEntropy.count) != \(payments.paymentsEntropyLength).")
+            return .disabled
+        }
+        guard let mcRootEntropy = payments.mcRootEntropy(forPaymentsEntropy: paymentsEntropy) else {
+            owsFailDebug("Could not derive mcRootEntropy from paymentsEntropy.")
+            // It's essential that we _not_ discard paymentsEntropy even if we
+            // can't derive a valid mcRootEntropy from it.
+            return .disabledWithPaymentsEntropy(paymentsEntropy: paymentsEntropy)
+        }
+        guard mcRootEntropy.count == payments.mcRootEntropyLength else {
+            owsFailDebug("mcRootEntropy has invalid length: \(mcRootEntropy.count) != \(payments.mcRootEntropyLength).")
+            // It's essential that we _not_ discard paymentsEntropy even if we
+            // can't derive a valid mcRootEntropy from it.
+            return .disabledWithPaymentsEntropy(paymentsEntropy: paymentsEntropy)
+        }
         if arePaymentsEnabled {
-            return .enabled(mcRootEntropy: mcRootEntropy)
+            return .enabled(paymentsEntropy: paymentsEntropy,
+                            mcRootEntropy: mcRootEntropy)
         } else {
-            return .disabledWithMCRootEntropy(mcRootEntropy: mcRootEntropy)
+            return .disabledWithPaymentsEntropy(paymentsEntropy: paymentsEntropy)
         }
     }
 
@@ -171,19 +223,30 @@ public enum PaymentsState: Equatable {
         switch self {
         case .enabled:
             return true
-        case .disabled, .disabledWithMCRootEntropy:
+        case .disabled, .disabledWithPaymentsEntropy:
             return false
         }
     }
 
+    public var paymentsEntropy: Data? {
+        switch self {
+        case .enabled(let paymentsEntropy, _):
+            return paymentsEntropy
+        case .disabled:
+            return nil
+        case .disabledWithPaymentsEntropy(let paymentsEntropy):
+            return paymentsEntropy
+        }
+    }
+
     public var mcRootEntropy: Data? {
         switch self {
-        case .enabled(let mcRootEntropy):
+        case .enabled(_, let mcRootEntropy):
             return mcRootEntropy
         case .disabled:
             return nil
-        case .disabledWithMCRootEntropy(let mcRootEntropy):
-            return mcRootEntropy
+        case .disabledWithPaymentsEntropy:
+            return nil
         }
     }
 
@@ -191,12 +254,30 @@ public enum PaymentsState: Equatable {
 
     public static func == (lhs: PaymentsState, rhs: PaymentsState) -> Bool {
         return (lhs.isEnabled == rhs.isEnabled &&
+                    lhs.paymentsEntropy == rhs.paymentsEntropy &&
                     lhs.mcRootEntropy == rhs.mcRootEntropy)
     }
 }
 
 // MARK: -
 
+public struct PaymentsPassphrase: Equatable {
+
+    public let words: [String]
+
+    public init(words: [String]) {
+        owsAssertDebug(words.count == PaymentsConstants.passphraseWordCount)
+
+        self.words = words
+    }
+
+    public var wordCount: Int { words.count }
+
+    public var debugDescription: String { words.joined(separator: " ") }
+}
+
+// MARK: -
+
 public class MockPayments: NSObject {
 }
 
@@ -210,11 +291,15 @@ extension MockPayments: PaymentsSwift {
         owsFail("Not implemented.")
     }
 
-    public func disablePayments(transaction: SDSAnyWriteTransaction) {
+    public func enablePayments(transaction: SDSAnyWriteTransaction) {
         owsFail("Not implemented.")
     }
 
-    public func generateRandomMobileCoinRootEntropy() -> Data {
+    public func enablePayments(withPaymentsEntropy: Data, transaction: SDSAnyWriteTransaction) -> Bool {
+        owsFail("Not implemented.")
+    }
+
+    public func disablePayments(transaction: SDSAnyWriteTransaction) {
         owsFail("Not implemented.")
     }
 
@@ -226,8 +311,18 @@ extension MockPayments: PaymentsSwift {
         owsFail("Not implemented.")
     }
 
+    public var paymentsEntropy: Data? { nil }
+
     public var mcRootEntropy: Data? { nil }
 
+    public var paymentsEntropyLength: UInt { 13 }
+
+    public var mcRootEntropyLength: UInt { 11 }
+
+    public func mcRootEntropy(forPaymentsEntropy paymentsEntropy: Data) -> Data? {
+        owsFail("Not implemented.")
+    }
+
     public func walletAddressBase58() -> String? {
         owsFail("Not implemented.")
     }
@@ -361,6 +456,20 @@ extension MockPayments: PaymentsSwift {
     public func maximumPaymentAmount(forBalance balance: PaymentBalance) -> Promise<TSPaymentAmount> {
         owsFail("Not implemented.")
     }
+
+    public var passphrase: PaymentsPassphrase? { nil }
+
+    public func passphrase(forPaymentsEntropy paymentsEntropy: Data) -> PaymentsPassphrase? {
+        owsFail("Not implemented.")
+    }
+
+    public func paymentsEntropy(forPassphrase passphrase: PaymentsPassphrase) -> Data? {
+        owsFail("Not implemented.")
+    }
+
+    public var allPossiblePassphraseWords: [String] {
+        owsFail("Not implemented.")
+    }
 }
 
 // MARK: -
@@ -428,6 +537,9 @@ public class PaymentsConstants {
     // Safe:    9,999,999.999,999,999,999.
     // Unsafe: 99,999,999.999,999,999,999.
     public static let maxMobNonDecimalDigits: UInt = 7
+
+    // TODO: Is this value final?
+    public static let passphraseWordCount: Int = 24
 }
 
 // MARK: -
diff --git a/SignalServiceKit/src/Payments/TSPaymentModels.swift b/SignalServiceKit/src/Payments/TSPaymentModels.swift
index 4c59bdf9aba..04a9daea9b9 100644
--- a/SignalServiceKit/src/Payments/TSPaymentModels.swift
+++ b/SignalServiceKit/src/Payments/TSPaymentModels.swift
@@ -459,11 +459,12 @@ extension TSPaymentModel: TSPaymentBaseModel {
         }
 
         let shouldHaveMCIncomingTransaction = isIncoming && !isFailed
+        let canHaveMCIncomingTransaction = shouldHaveMCIncomingTransaction || isUnidentified
         let hasMCIncomingTransaction = !(self.mobileCoin?.incomingTransactionPublicKeys ?? []).isEmpty
         if shouldHaveMCIncomingTransaction, !hasMCIncomingTransaction {
             owsFailDebug("Missing mcIncomingTransaction: \(formattedState).")
             isValid = false
-        } else if !shouldHaveMCIncomingTransaction, hasMCIncomingTransaction {
+        } else if !canHaveMCIncomingTransaction, hasMCIncomingTransaction {
             owsFailDebug("Unexpected mcIncomingTransaction: \(formattedState).")
             isValid = false
         }
diff --git a/SignalServiceKit/src/Protos/Generated/StorageService.pb.swift b/SignalServiceKit/src/Protos/Generated/StorageService.pb.swift
index 85fe084dc23..41b0a10f519 100644
--- a/SignalServiceKit/src/Protos/Generated/StorageService.pb.swift
+++ b/SignalServiceKit/src/Protos/Generated/StorageService.pb.swift
@@ -599,32 +599,11 @@ struct StorageServiceProtos_AccountRecord {
 
     var enabled: Bool = false
 
-    var mobileCoin: StorageServiceProtos_AccountRecord.Payments.MobileCoin {
-      get {return _mobileCoin ?? StorageServiceProtos_AccountRecord.Payments.MobileCoin()}
-      set {_mobileCoin = newValue}
-    }
-    /// Returns true if `mobileCoin` has been explicitly set.
-    var hasMobileCoin: Bool {return self._mobileCoin != nil}
-    /// Clears the value of `mobileCoin`. Subsequent reads from it will return its default value.
-    mutating func clearMobileCoin() {self._mobileCoin = nil}
+    var paymentsEntropy: Data = Data()
 
     var unknownFields = SwiftProtobuf.UnknownStorage()
 
-    struct MobileCoin {
-      // SwiftProtobuf.Message conformance is added in an extension below. See the
-      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
-      // methods supported on all messages.
-
-      var rootEntropy: Data = Data()
-
-      var unknownFields = SwiftProtobuf.UnknownStorage()
-
-      init() {}
-    }
-
     init() {}
-
-    fileprivate var _mobileCoin: StorageServiceProtos_AccountRecord.Payments.MobileCoin?
   }
 
   init() {}
@@ -1553,7 +1532,7 @@ extension StorageServiceProtos_AccountRecord.Payments: SwiftProtobuf.Message, Sw
   static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".Payments"
   static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
     1: .same(proto: "enabled"),
-    2: .same(proto: "mobileCoin")
+    2: .same(proto: "paymentsEntropy")
   ]
 
   mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
@@ -1563,7 +1542,7 @@ extension StorageServiceProtos_AccountRecord.Payments: SwiftProtobuf.Message, Sw
       // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
       case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
-      case 2: try { try decoder.decodeSingularMessageField(value: &self._mobileCoin) }()
+      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentsEntropy) }()
       default: break
       }
     }
@@ -1573,47 +1552,15 @@ extension StorageServiceProtos_AccountRecord.Payments: SwiftProtobuf.Message, Sw
     if self.enabled != false {
       try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
     }
-    if let v = self._mobileCoin {
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
+    if !self.paymentsEntropy.isEmpty {
+      try visitor.visitSingularBytesField(value: self.paymentsEntropy, fieldNumber: 2)
     }
     try unknownFields.traverse(visitor: &visitor)
   }
 
   static func ==(lhs: StorageServiceProtos_AccountRecord.Payments, rhs: StorageServiceProtos_AccountRecord.Payments) -> Bool {
     if lhs.enabled != rhs.enabled {return false}
-    if lhs._mobileCoin != rhs._mobileCoin {return false}
-    if lhs.unknownFields != rhs.unknownFields {return false}
-    return true
-  }
-}
-
-extension StorageServiceProtos_AccountRecord.Payments.MobileCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
-  static let protoMessageName: String = StorageServiceProtos_AccountRecord.Payments.protoMessageName + ".MobileCoin"
-  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
-    1: .same(proto: "rootEntropy")
-  ]
-
-  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
-    while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
-      switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBytesField(value: &self.rootEntropy) }()
-      default: break
-      }
-    }
-  }
-
-  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    if !self.rootEntropy.isEmpty {
-      try visitor.visitSingularBytesField(value: self.rootEntropy, fieldNumber: 1)
-    }
-    try unknownFields.traverse(visitor: &visitor)
-  }
-
-  static func ==(lhs: StorageServiceProtos_AccountRecord.Payments.MobileCoin, rhs: StorageServiceProtos_AccountRecord.Payments.MobileCoin) -> Bool {
-    if lhs.rootEntropy != rhs.rootEntropy {return false}
+    if lhs.paymentsEntropy != rhs.paymentsEntropy {return false}
     if lhs.unknownFields != rhs.unknownFields {return false}
     return true
   }
diff --git a/SignalServiceKit/src/Protos/Generated/StorageServiceProto.swift b/SignalServiceKit/src/Protos/Generated/StorageServiceProto.swift
index 3866805d678..68f8774c08b 100644
--- a/SignalServiceKit/src/Protos/Generated/StorageServiceProto.swift
+++ b/SignalServiceKit/src/Protos/Generated/StorageServiceProto.swift
@@ -2309,129 +2309,6 @@ extension StorageServiceProtoAccountRecordPinnedConversation.StorageServiceProto
 
 #endif
 
-// MARK: - StorageServiceProtoAccountRecordPaymentsMobileCoin
-
-public struct StorageServiceProtoAccountRecordPaymentsMobileCoin: Codable, CustomDebugStringConvertible {
-
-    // MARK: - StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder
-
-    public static func builder() -> StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder {
-        return StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder()
-    }
-
-    // asBuilder() constructs a builder that reflects the proto's contents.
-    public func asBuilder() -> StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder {
-        var builder = StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder()
-        if let _value = rootEntropy {
-            builder.setRootEntropy(_value)
-        }
-        if let _value = unknownFields {
-            builder.setUnknownFields(_value)
-        }
-        return builder
-    }
-
-    public struct StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder {
-
-        private var proto = StorageServiceProtos_AccountRecord.Payments.MobileCoin()
-
-        fileprivate init() {}
-
-        @available(swift, obsoleted: 1.0)
-        public mutating func setRootEntropy(_ valueParam: Data?) {
-            guard let valueParam = valueParam else { return }
-            proto.rootEntropy = valueParam
-        }
-
-        public mutating func setRootEntropy(_ valueParam: Data) {
-            proto.rootEntropy = valueParam
-        }
-
-        public mutating func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
-            proto.unknownFields = unknownFields
-        }
-
-        public func build() throws -> StorageServiceProtoAccountRecordPaymentsMobileCoin {
-            return try StorageServiceProtoAccountRecordPaymentsMobileCoin(proto)
-        }
-
-        public func buildSerializedData() throws -> Data {
-            return try StorageServiceProtoAccountRecordPaymentsMobileCoin(proto).serializedData()
-        }
-    }
-
-    fileprivate let proto: StorageServiceProtos_AccountRecord.Payments.MobileCoin
-
-    public var rootEntropy: Data? {
-        guard hasRootEntropy else {
-            return nil
-        }
-        return proto.rootEntropy
-    }
-    public var hasRootEntropy: Bool {
-        return !proto.rootEntropy.isEmpty
-    }
-
-    public var hasUnknownFields: Bool {
-        return !proto.unknownFields.data.isEmpty
-    }
-    public var unknownFields: SwiftProtobuf.UnknownStorage? {
-        guard hasUnknownFields else { return nil }
-        return proto.unknownFields
-    }
-
-    private init(proto: StorageServiceProtos_AccountRecord.Payments.MobileCoin) {
-        self.proto = proto
-    }
-
-    public func serializedData() throws -> Data {
-        return try self.proto.serializedData()
-    }
-
-    public init(serializedData: Data) throws {
-        let proto = try StorageServiceProtos_AccountRecord.Payments.MobileCoin(serializedData: serializedData)
-        try self.init(proto)
-    }
-
-    fileprivate init(_ proto: StorageServiceProtos_AccountRecord.Payments.MobileCoin) throws {
-        // MARK: - Begin Validation Logic for StorageServiceProtoAccountRecordPaymentsMobileCoin -
-
-        // MARK: - End Validation Logic for StorageServiceProtoAccountRecordPaymentsMobileCoin -
-
-        self.init(proto: proto)
-    }
-
-    public init(from decoder: Swift.Decoder) throws {
-        let singleValueContainer = try decoder.singleValueContainer()
-        let serializedData = try singleValueContainer.decode(Data.self)
-        try self.init(serializedData: serializedData)
-    }
-    public func encode(to encoder: Swift.Encoder) throws {
-        var singleValueContainer = encoder.singleValueContainer()
-        try singleValueContainer.encode(try serializedData())
-    }
-
-    public var debugDescription: String {
-        return "\(proto)"
-    }
-}
-
-#if DEBUG
-
-extension StorageServiceProtoAccountRecordPaymentsMobileCoin {
-    public func serializedDataIgnoringErrors() -> Data? {
-        return try! self.serializedData()
-    }
-}
-
-extension StorageServiceProtoAccountRecordPaymentsMobileCoin.StorageServiceProtoAccountRecordPaymentsMobileCoinBuilder {
-    public func buildIgnoringErrors() -> StorageServiceProtoAccountRecordPaymentsMobileCoin? {
-        return try! self.build()
-    }
-}
-
-#endif
-
 // MARK: - StorageServiceProtoAccountRecordPayments
 
 public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStringConvertible {
@@ -2448,8 +2325,8 @@ public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStri
         if hasEnabled {
             builder.setEnabled(enabled)
         }
-        if let _value = mobileCoin {
-            builder.setMobileCoin(_value)
+        if let _value = paymentsEntropy {
+            builder.setPaymentsEntropy(_value)
         }
         if let _value = unknownFields {
             builder.setUnknownFields(_value)
@@ -2468,13 +2345,13 @@ public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStri
         }
 
         @available(swift, obsoleted: 1.0)
-        public mutating func setMobileCoin(_ valueParam: StorageServiceProtoAccountRecordPaymentsMobileCoin?) {
+        public mutating func setPaymentsEntropy(_ valueParam: Data?) {
             guard let valueParam = valueParam else { return }
-            proto.mobileCoin = valueParam.proto
+            proto.paymentsEntropy = valueParam
         }
 
-        public mutating func setMobileCoin(_ valueParam: StorageServiceProtoAccountRecordPaymentsMobileCoin) {
-            proto.mobileCoin = valueParam.proto
+        public mutating func setPaymentsEntropy(_ valueParam: Data) {
+            proto.paymentsEntropy = valueParam
         }
 
         public mutating func setUnknownFields(_ unknownFields: SwiftProtobuf.UnknownStorage) {
@@ -2492,8 +2369,6 @@ public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStri
 
     fileprivate let proto: StorageServiceProtos_AccountRecord.Payments
 
-    public let mobileCoin: StorageServiceProtoAccountRecordPaymentsMobileCoin?
-
     public var enabled: Bool {
         return proto.enabled
     }
@@ -2501,6 +2376,16 @@ public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStri
         return true
     }
 
+    public var paymentsEntropy: Data? {
+        guard hasPaymentsEntropy else {
+            return nil
+        }
+        return proto.paymentsEntropy
+    }
+    public var hasPaymentsEntropy: Bool {
+        return !proto.paymentsEntropy.isEmpty
+    }
+
     public var hasUnknownFields: Bool {
         return !proto.unknownFields.data.isEmpty
     }
@@ -2509,10 +2394,8 @@ public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStri
         return proto.unknownFields
     }
 
-    private init(proto: StorageServiceProtos_AccountRecord.Payments,
-                 mobileCoin: StorageServiceProtoAccountRecordPaymentsMobileCoin?) {
+    private init(proto: StorageServiceProtos_AccountRecord.Payments) {
         self.proto = proto
-        self.mobileCoin = mobileCoin
     }
 
     public func serializedData() throws -> Data {
@@ -2525,17 +2408,11 @@ public struct StorageServiceProtoAccountRecordPayments: Codable, CustomDebugStri
     }
 
     fileprivate init(_ proto: StorageServiceProtos_AccountRecord.Payments) throws {
-        var mobileCoin: StorageServiceProtoAccountRecordPaymentsMobileCoin?
-        if proto.hasMobileCoin {
-            mobileCoin = try StorageServiceProtoAccountRecordPaymentsMobileCoin(proto.mobileCoin)
-        }
-
         // MARK: - Begin Validation Logic for StorageServiceProtoAccountRecordPayments -
 
         // MARK: - End Validation Logic for StorageServiceProtoAccountRecordPayments -
 
-        self.init(proto: proto,
-                  mobileCoin: mobileCoin)
+        self.init(proto: proto)
     }
 
     public init(from decoder: Swift.Decoder) throws {
diff --git a/SignalServiceKit/src/TestUtils/FakeStorageServiceManager.swift b/SignalServiceKit/src/TestUtils/FakeStorageServiceManager.swift
index 0c79f1e01d9..8ec1fafb3d5 100644
--- a/SignalServiceKit/src/TestUtils/FakeStorageServiceManager.swift
+++ b/SignalServiceKit/src/TestUtils/FakeStorageServiceManager.swift
@@ -23,4 +23,6 @@ public class FakeStorageServiceManager: NSObject, StorageServiceManagerProtocol
     public func restoreOrCreateManifestIfNecessary() -> AnyPromise { AnyPromise(Promise.value(())) }
 
     public func resetLocalData(transaction: SDSAnyWriteTransaction) {}
+
+    public func hasEverBackedUpOrRestored(transaction: SDSAnyReadTransaction) -> Bool { false }
 }
diff --git a/SignalServiceKit/src/Util/StorageService.swift b/SignalServiceKit/src/Util/StorageService.swift
index ebe016fe4f2..a9ef2041100 100644
--- a/SignalServiceKit/src/Util/StorageService.swift
+++ b/SignalServiceKit/src/Util/StorageService.swift
@@ -28,6 +28,8 @@ public protocol StorageServiceManagerProtocol {
     func restoreOrCreateManifestIfNecessary() -> AnyPromise
 
     func resetLocalData(transaction: SDSAnyWriteTransaction)
+
+    func hasEverBackedUpOrRestored(transaction: SDSAnyReadTransaction) -> Bool
 }
 
 // MARK: -
