diff --git a/main/src/main/java/com/google/android/apps/muzei/widget/AppWidgetUpdateTask.java b/main/src/main/java/com/google/android/apps/muzei/widget/AppWidgetUpdateTask.java
deleted file mode 100644
index da0da1dd0..000000000
--- a/main/src/main/java/com/google/android/apps/muzei/widget/AppWidgetUpdateTask.java
+++ /dev/null
@@ -1,244 +0,0 @@
-/*
- * Copyright 2014 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.android.apps.muzei.widget;
-
-import android.app.PendingIntent;
-import android.appwidget.AppWidgetManager;
-import android.content.ComponentName;
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Rect;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Build;
-import android.os.Bundle;
-import android.support.annotation.LayoutRes;
-import android.support.annotation.Nullable;
-import android.support.media.ExifInterface;
-import android.text.TextUtils;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.View;
-import android.widget.RemoteViews;
-
-import com.google.android.apps.muzei.event.WallpaperActiveStateChangedEvent;
-import com.google.android.apps.muzei.render.BitmapRegionLoader;
-import com.google.android.apps.muzei.render.ImageUtil;
-import com.google.android.apps.muzei.room.Artwork;
-import com.google.android.apps.muzei.room.MuzeiDatabase;
-import com.google.android.apps.muzei.room.Source;
-
-import net.nurik.roman.muzei.R;
-
-import org.greenrobot.eventbus.EventBus;
-
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Async operation used to update the widget or provide a preview for pinning the widget.
- */
-public class AppWidgetUpdateTask extends AsyncTask<Void,Void,Boolean> {
-    private static final String TAG = "AppWidgetUpdateTask";
-
-    private final Context mContext;
-    private final boolean mShowingPreview;
-
-    public AppWidgetUpdateTask(Context context, boolean showingPreview) {
-        mContext = context;
-        mShowingPreview = showingPreview;
-    }
-
-    @Override
-    protected Boolean doInBackground(Void... params) {
-        ComponentName widget = new ComponentName(mContext, MuzeiAppWidgetProvider.class);
-        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
-        int[] appWidgetIds = appWidgetManager.getAppWidgetIds(widget);
-        if (!mShowingPreview && appWidgetIds.length == 0) {
-            // No app widgets, nothing to do
-            return true;
-        } else if (mShowingPreview && (Build.VERSION.SDK_INT < Build.VERSION_CODES.O ||
-                !appWidgetManager.isRequestPinAppWidgetSupported())) {
-            // No preview to show
-            return false;
-        }
-        Source source = MuzeiDatabase.getInstance(mContext).sourceDao().getCurrentSourceBlocking();
-        Artwork artwork = MuzeiDatabase.getInstance(mContext).artworkDao().getCurrentArtworkBlocking();
-        if (source == null || artwork == null) {
-            Log.w(TAG, "No current artwork found");
-            return false;
-        }
-        String title = artwork.title;
-        String byline = artwork.byline;
-        String contentDescription = !TextUtils.isEmpty(title)
-                ? title
-                : byline;
-        Uri imageUri = artwork.getContentUri();
-        WallpaperActiveStateChangedEvent wasce = EventBus.getDefault().getStickyEvent(
-                WallpaperActiveStateChangedEvent.class);
-        boolean supportsNextArtwork = wasce != null && wasce.isActive() && source.supportsNextArtwork;
-
-        // Update the widget(s) with the new artwork information
-        PackageManager packageManager = mContext.getPackageManager();
-        Intent launchIntent = packageManager.getLaunchIntentForPackage(mContext.getPackageName());
-        PendingIntent launchPendingIntent = PendingIntent.getActivity(mContext,
-                0, launchIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-        Intent nextArtworkIntent = new Intent(mContext, MuzeiAppWidgetProvider.class);
-        nextArtworkIntent.setAction(MuzeiAppWidgetProvider.ACTION_NEXT_ARTWORK);
-        PendingIntent nextArtworkPendingIntent = PendingIntent.getBroadcast(mContext,
-                0, nextArtworkIntent, PendingIntent.FLAG_UPDATE_CURRENT);
-        if (mShowingPreview) {
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O &&
-                    appWidgetManager.isRequestPinAppWidgetSupported()) {
-                RemoteViews remoteViews = createRemoteViews(imageUri, contentDescription,
-                        launchPendingIntent, nextArtworkPendingIntent, supportsNextArtwork,
-                        mContext.getResources().getDimensionPixelSize(R.dimen.widget_min_width),
-                        mContext.getResources().getDimensionPixelSize(R.dimen.widget_min_height));
-                Bundle extras = new Bundle();
-                extras.putParcelable(AppWidgetManager.EXTRA_APPWIDGET_PREVIEW, remoteViews);
-                try {
-                    return appWidgetManager.requestPinAppWidget(widget, extras, null);
-                } catch (IllegalStateException ignored) {
-                    // The user exited out of the app before we could pop up the pin widget dialog
-                }
-            }
-            return false;
-        }
-        DisplayMetrics displayMetrics = mContext.getResources().getDisplayMetrics();
-        int minWidgetSize = mContext.getResources().getDimensionPixelSize(
-                R.dimen.widget_min_size);
-        for (int widgetId : appWidgetIds) {
-            Bundle extras = appWidgetManager.getAppWidgetOptions(widgetId);
-            int widgetWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
-                    extras.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH), displayMetrics);
-            widgetWidth = Math.max(Math.min(widgetWidth, displayMetrics.widthPixels), minWidgetSize);
-            int widgetHeight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
-                    extras.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT), displayMetrics);
-            widgetHeight = Math.max(Math.min(widgetHeight, displayMetrics.heightPixels), minWidgetSize);
-            boolean success = false;
-            while (!success) {
-                RemoteViews remoteViews = createRemoteViews(imageUri, contentDescription, launchPendingIntent,
-                        nextArtworkPendingIntent, supportsNextArtwork, widgetWidth, widgetHeight);
-                if (remoteViews == null) {
-                    return false;
-                }
-                try {
-                    appWidgetManager.updateAppWidget(widgetId, remoteViews);
-                    success = true;
-                } catch (IllegalArgumentException e) {
-                    Log.w(TAG, "App widget size " + widgetWidth + " x " + widgetHeight
-                            + " exceeded maximum memory, reducing quality");
-                    widgetWidth /= 2;
-                    widgetHeight /= 2;
-                }
-            }
-        }
-        return true;
-    }
-
-    @Nullable
-    private RemoteViews createRemoteViews(Uri imageUri, String contentDescription,
-            PendingIntent launchPendingIntent,
-            PendingIntent nextArtworkPendingIntent, boolean supportsNextArtwork,
-            int widgetWidth, int widgetHeight) {
-        ContentResolver contentResolver = mContext.getContentResolver();
-        int smallWidgetHeight = mContext.getResources().getDimensionPixelSize(
-                R.dimen.widget_small_height_breakpoint);
-        Bitmap image;
-        try {
-            // Check if there's rotation
-            int rotation = 0;
-            try (InputStream in = contentResolver.openInputStream(imageUri)) {
-                if (in == null) {
-                    return null;
-                }
-                ExifInterface exifInterface = new ExifInterface(in);
-                int orientation = exifInterface.getAttributeInt(
-                        ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
-                switch (orientation) {
-                    case ExifInterface.ORIENTATION_ROTATE_90: rotation = 90; break;
-                    case ExifInterface.ORIENTATION_ROTATE_180: rotation = 180; break;
-                    case ExifInterface.ORIENTATION_ROTATE_270: rotation = 270; break;
-                }
-            } catch (IOException |NumberFormatException|StackOverflowError e) {
-                Log.w(TAG, "Couldn't open EXIF interface on artwork", e);
-            }
-            BitmapRegionLoader regionLoader = BitmapRegionLoader.newInstance(
-                    contentResolver.openInputStream(imageUri), rotation);
-            if (regionLoader == null) {
-                throw new IOException("BitmapRegionLoader returned null: bad image format?");
-            }
-            int width = regionLoader.getWidth();
-            int height = regionLoader.getHeight();
-            BitmapFactory.Options options = new BitmapFactory.Options();
-            options.inSampleSize = Math.max(ImageUtil.sampleSize(width, widgetWidth / 2),
-                    ImageUtil.sampleSize(height, widgetHeight / 2));
-            image = regionLoader.decodeRegion(new Rect(0, 0, width, height), options);
-            regionLoader.destroy();
-        } catch (IOException e) {
-            Log.e(TAG, "Could not load current artwork image", e);
-            return null;
-        }
-        // Even after using sample size to scale an image down, it might be larger than the
-        // maximum bitmap memory usage for widgets
-        Bitmap scaledImage = scaleBitmap(image, widgetWidth, widgetHeight);
-        @LayoutRes int widgetLayout = widgetHeight < smallWidgetHeight
-                ? R.layout.widget_small
-                : R.layout.widget;
-        RemoteViews remoteViews = new RemoteViews(mContext.getPackageName(), widgetLayout);
-        remoteViews.setContentDescription(R.id.widget_background, contentDescription);
-        remoteViews.setImageViewBitmap(R.id.widget_background, scaledImage);
-        remoteViews.setOnClickPendingIntent(R.id.widget_background, launchPendingIntent);
-        remoteViews.setOnClickPendingIntent(R.id.widget_next_artwork, nextArtworkPendingIntent);
-        if (supportsNextArtwork) {
-            remoteViews.setViewVisibility(R.id.widget_next_artwork, View.VISIBLE);
-        } else {
-            remoteViews.setViewVisibility(R.id.widget_next_artwork, View.GONE);
-        }
-        return remoteViews;
-    }
-
-    private Bitmap scaleBitmap(Bitmap image, int widgetWidth, int widgetHeight) {
-        if (image == null || image.getWidth() == 0 || image.getHeight() == 0 ||
-                widgetWidth == 0 || widgetHeight == 0) {
-            return null;
-        }
-        int largestDimension = Math.max(widgetWidth, widgetHeight);
-        int width = image.getWidth();
-        int height = image.getHeight();
-        if (width > height) {
-            // landscape
-            float ratio = (float) width / largestDimension;
-            width = largestDimension;
-            height = (int) (height / ratio);
-        } else if (height > width) {
-            // portrait
-            float ratio = (float) height / largestDimension;
-            height = largestDimension;
-            width = (int) (width / ratio);
-        } else {
-            height = largestDimension;
-            width = largestDimension;
-        }
-        return Bitmap.createScaledBitmap(image, width, height, true);
-    }
-}
diff --git a/main/src/main/java/com/google/android/apps/muzei/widget/AppWidgetUpdateTask.kt b/main/src/main/java/com/google/android/apps/muzei/widget/AppWidgetUpdateTask.kt
new file mode 100644
index 000000000..9730b31fd
--- /dev/null
+++ b/main/src/main/java/com/google/android/apps/muzei/widget/AppWidgetUpdateTask.kt
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.apps.muzei.widget
+
+import android.annotation.SuppressLint
+import android.app.PendingIntent
+import android.appwidget.AppWidgetManager
+import android.content.ComponentName
+import android.content.Context
+import android.content.Intent
+import android.graphics.Bitmap
+import android.graphics.BitmapFactory
+import android.graphics.Rect
+import android.net.Uri
+import android.os.AsyncTask
+import android.os.Build
+import android.os.Bundle
+import android.support.annotation.LayoutRes
+import android.support.media.ExifInterface
+import android.util.Log
+import android.util.TypedValue
+import android.view.View
+import android.widget.RemoteViews
+import com.google.android.apps.muzei.event.WallpaperActiveStateChangedEvent
+import com.google.android.apps.muzei.render.BitmapRegionLoader
+import com.google.android.apps.muzei.render.sampleSize
+import com.google.android.apps.muzei.room.MuzeiDatabase
+import net.nurik.roman.muzei.R
+import org.greenrobot.eventbus.EventBus
+import java.io.IOException
+
+/**
+ * Async operation used to update the widget or provide a preview for pinning the widget.
+ */
+open class AppWidgetUpdateTask(@field:SuppressLint("StaticFieldLeak") private val context: Context,
+                               private val showingPreview: Boolean = false)
+    : AsyncTask<Void, Void, Boolean>() {
+
+    companion object {
+        private const val TAG = "AppWidgetUpdateTask"
+    }
+
+    override fun doInBackground(vararg params: Void): Boolean? {
+        val widget = ComponentName(context, MuzeiAppWidgetProvider::class.java)
+        val appWidgetManager = AppWidgetManager.getInstance(context)
+        val appWidgetIds = appWidgetManager.getAppWidgetIds(widget)
+        if (!showingPreview && appWidgetIds.isEmpty()) {
+            // No app widgets, nothing to do
+            return true
+        } else if (showingPreview && (Build.VERSION.SDK_INT < Build.VERSION_CODES.O || !appWidgetManager.isRequestPinAppWidgetSupported)) {
+            // No preview to show
+            return false
+        }
+        val source = MuzeiDatabase.getInstance(context).sourceDao().currentSourceBlocking
+        val artwork = MuzeiDatabase.getInstance(context).artworkDao().currentArtworkBlocking
+        if (source == null || artwork == null) {
+            Log.w(TAG, "No current artwork found")
+            return false
+        }
+        val contentDescription = artwork.title ?: artwork.byline
+        val imageUri = artwork.contentUri
+        val wasce = EventBus.getDefault().getStickyEvent(
+                WallpaperActiveStateChangedEvent::class.java)
+        val supportsNextArtwork = wasce?.isActive == true && source.supportsNextArtwork
+
+        // Update the widget(s) with the new artwork information
+        val launchIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
+        val launchPendingIntent = PendingIntent.getActivity(context,
+                0, launchIntent, PendingIntent.FLAG_UPDATE_CURRENT)
+        val nextArtworkIntent = Intent(context, MuzeiAppWidgetProvider::class.java).apply {
+            action = MuzeiAppWidgetProvider.ACTION_NEXT_ARTWORK
+        }
+        val nextArtworkPendingIntent = PendingIntent.getBroadcast(context,
+                0, nextArtworkIntent, PendingIntent.FLAG_UPDATE_CURRENT)
+        if (showingPreview) {
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && appWidgetManager.isRequestPinAppWidgetSupported) {
+                val remoteViews = createRemoteViews(imageUri, contentDescription,
+                        launchPendingIntent, nextArtworkPendingIntent, supportsNextArtwork,
+                        context.resources.getDimensionPixelSize(R.dimen.widget_min_width),
+                        context.resources.getDimensionPixelSize(R.dimen.widget_min_height))
+                val extras = Bundle()
+                extras.putParcelable(AppWidgetManager.EXTRA_APPWIDGET_PREVIEW, remoteViews)
+                try {
+                    return appWidgetManager.requestPinAppWidget(widget, extras, null)
+                } catch (ignored: IllegalStateException) {
+                    // The user exited out of the app before we could pop up the pin widget dialog
+                }
+
+            }
+            return false
+        }
+        val displayMetrics = context.resources.displayMetrics
+        val minWidgetSize = context.resources.getDimensionPixelSize(
+                R.dimen.widget_min_size)
+        for (widgetId in appWidgetIds) {
+            val extras = appWidgetManager.getAppWidgetOptions(widgetId)
+            var widgetWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
+                    extras.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH).toFloat(), displayMetrics).toInt()
+            widgetWidth = Math.max(Math.min(widgetWidth, displayMetrics.widthPixels), minWidgetSize)
+            var widgetHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
+                    extras.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT).toFloat(), displayMetrics).toInt()
+            widgetHeight = Math.max(Math.min(widgetHeight, displayMetrics.heightPixels), minWidgetSize)
+            var success = false
+            while (!success) {
+                val remoteViews = createRemoteViews(imageUri, contentDescription, launchPendingIntent,
+                        nextArtworkPendingIntent, supportsNextArtwork, widgetWidth, widgetHeight) ?: return false
+                try {
+                    appWidgetManager.updateAppWidget(widgetId, remoteViews)
+                    success = true
+                } catch (e: IllegalArgumentException) {
+                    Log.w(TAG, "App widget size $widgetWidth x $widgetHeight exceeded maximum memory, reducing quality")
+                    widgetWidth /= 2
+                    widgetHeight /= 2
+                }
+            }
+        }
+        return true
+    }
+
+    private fun createRemoteViews(imageUri: Uri, contentDescription: String,
+                                  launchPendingIntent: PendingIntent,
+                                  nextArtworkPendingIntent: PendingIntent,
+                                  supportsNextArtwork: Boolean,
+                                  widgetWidth: Int, widgetHeight: Int): RemoteViews? {
+        val contentResolver = context.contentResolver
+        val smallWidgetHeight = context.resources.getDimensionPixelSize(
+                R.dimen.widget_small_height_breakpoint)
+        val image: Bitmap?
+        try {
+            // Check if there's rotation
+            var rotation = 0
+            try {
+                contentResolver.openInputStream(imageUri)?.use { input ->
+                    val exifInterface = ExifInterface(input)
+                    val orientation = exifInterface.getAttributeInt(
+                            ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)
+                    when (orientation) {
+                        ExifInterface.ORIENTATION_ROTATE_90 -> rotation = 90
+                        ExifInterface.ORIENTATION_ROTATE_180 -> rotation = 180
+                        ExifInterface.ORIENTATION_ROTATE_270 -> rotation = 270
+                    }
+                }
+            } catch (e: IOException) {
+                Log.w(TAG, "Couldn't open EXIF interface on artwork", e)
+            } catch (e: NumberFormatException) {
+                Log.w(TAG, "Couldn't open EXIF interface on artwork", e)
+            } catch (e: StackOverflowError) {
+                Log.w(TAG, "Couldn't open EXIF interface on artwork", e)
+            }
+
+            val regionLoader = BitmapRegionLoader.newInstance(
+                    contentResolver.openInputStream(imageUri), rotation)
+                    ?: throw IOException("BitmapRegionLoader returned null: bad image format?")
+            val width = regionLoader.width
+            val height = regionLoader.height
+            val options = BitmapFactory.Options()
+            options.inSampleSize = Math.max(width.sampleSize(widgetWidth / 2),
+                    height.sampleSize(widgetHeight / 2))
+            image = regionLoader.decodeRegion(Rect(0, 0, width, height), options)
+            regionLoader.destroy()
+        } catch (e: IOException) {
+            Log.e(TAG, "Could not load current artwork image", e)
+            return null
+        }
+
+        // Even after using sample size to scale an image down, it might be larger than the
+        // maximum bitmap memory usage for widgets
+        val scaledImage = image?.scale(widgetWidth, widgetHeight)
+        @LayoutRes val widgetLayout = if (widgetHeight < smallWidgetHeight)
+            R.layout.widget_small
+        else
+            R.layout.widget
+        val remoteViews = RemoteViews(context.packageName, widgetLayout)
+        remoteViews.setContentDescription(R.id.widget_background, contentDescription)
+        remoteViews.setImageViewBitmap(R.id.widget_background, scaledImage)
+        remoteViews.setOnClickPendingIntent(R.id.widget_background, launchPendingIntent)
+        remoteViews.setOnClickPendingIntent(R.id.widget_next_artwork, nextArtworkPendingIntent)
+        if (supportsNextArtwork) {
+            remoteViews.setViewVisibility(R.id.widget_next_artwork, View.VISIBLE)
+        } else {
+            remoteViews.setViewVisibility(R.id.widget_next_artwork, View.GONE)
+        }
+        return remoteViews
+    }
+
+    private fun Bitmap.scale(widgetWidth: Int, widgetHeight: Int) : Bitmap? {
+        if (width == 0 || height == 0 ||
+                widgetWidth == 0 || widgetHeight == 0) {
+            return null
+        }
+        val largestDimension = Math.max(widgetWidth, widgetHeight)
+        var width = width
+        var height = height
+        when {
+            width > height -> {
+                // landscape
+                val ratio = width.toFloat() / largestDimension
+                width = largestDimension
+                height = (height / ratio).toInt()
+            }
+            height > width -> {
+                // portrait
+                val ratio = height.toFloat() / largestDimension
+                height = largestDimension
+                width = (width / ratio).toInt()
+            }
+            else -> {
+                height = largestDimension
+                width = largestDimension
+            }
+        }
+        return Bitmap.createScaledBitmap(this, width, height, true)
+    }
+}
diff --git a/main/src/main/java/com/google/android/apps/muzei/widget/MuzeiAppWidgetProvider.java b/main/src/main/java/com/google/android/apps/muzei/widget/MuzeiAppWidgetProvider.java
deleted file mode 100644
index 3a7d067c4..000000000
--- a/main/src/main/java/com/google/android/apps/muzei/widget/MuzeiAppWidgetProvider.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2014 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.google.android.apps.muzei.widget;
-
-import android.appwidget.AppWidgetManager;
-import android.appwidget.AppWidgetProvider;
-import android.content.Context;
-import android.content.Intent;
-import android.os.AsyncTask;
-import android.os.Bundle;
-
-import com.google.android.apps.muzei.api.MuzeiArtSource;
-import com.google.android.apps.muzei.sources.SourceManager;
-
-/**
- * AppWidgetProvider for Muzei. The actual updating is done asynchronously in
- * {@link AppWidgetUpdateTask}.
- */
-public class MuzeiAppWidgetProvider extends AppWidgetProvider {
-    static final String ACTION_NEXT_ARTWORK = "com.google.android.apps.muzei.action.WIDGET_NEXT_ARTWORK";
-
-    @Override
-    public void onReceive(Context context, Intent intent) {
-        super.onReceive(context, intent);
-        if (intent != null && ACTION_NEXT_ARTWORK.equals(intent.getAction())) {
-            SourceManager.sendAction(context.getApplicationContext(), MuzeiArtSource.BUILTIN_COMMAND_ID_NEXT_ARTWORK);
-        }
-    }
-
-    @Override
-    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
-        updateWidgets(context);
-    }
-
-
-    @Override
-    public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager,
-                                          int appWidgetId, Bundle newOptions) {
-        updateWidgets(context);
-    }
-
-    private void updateWidgets(final Context context) {
-        final PendingResult result = goAsync();
-        new PendingResultUpdateTask(context, result).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-    }
-
-    private static class PendingResultUpdateTask extends AppWidgetUpdateTask {
-        private final PendingResult mResult;
-
-        PendingResultUpdateTask(Context context, PendingResult result) {
-            super(context.getApplicationContext(), false);
-            mResult = result;
-        }
-
-        @Override
-        protected void onPostExecute(Boolean success) {
-            mResult.finish();
-        }
-    }
-}
diff --git a/main/src/main/java/com/google/android/apps/muzei/widget/MuzeiAppWidgetProvider.kt b/main/src/main/java/com/google/android/apps/muzei/widget/MuzeiAppWidgetProvider.kt
new file mode 100644
index 000000000..bed4a6442
--- /dev/null
+++ b/main/src/main/java/com/google/android/apps/muzei/widget/MuzeiAppWidgetProvider.kt
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.google.android.apps.muzei.widget
+
+import android.appwidget.AppWidgetManager
+import android.appwidget.AppWidgetProvider
+import android.content.Context
+import android.content.Intent
+import android.os.AsyncTask
+import android.os.Bundle
+
+import com.google.android.apps.muzei.api.MuzeiArtSource
+import com.google.android.apps.muzei.sources.SourceManager
+
+/**
+ * AppWidgetProvider for Muzei. The actual updating is done asynchronously in
+ * [AppWidgetUpdateTask].
+ */
+class MuzeiAppWidgetProvider : AppWidgetProvider() {
+
+    companion object {
+        internal const val ACTION_NEXT_ARTWORK = "com.google.android.apps.muzei.action.WIDGET_NEXT_ARTWORK"
+    }
+
+    override fun onReceive(context: Context, intent: Intent?) {
+        super.onReceive(context, intent)
+        if (intent?.action == ACTION_NEXT_ARTWORK) {
+            SourceManager.sendAction(context.applicationContext, MuzeiArtSource.BUILTIN_COMMAND_ID_NEXT_ARTWORK)
+        }
+    }
+
+    override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) {
+        updateWidgets(context)
+    }
+
+    override fun onAppWidgetOptionsChanged(context: Context, appWidgetManager: AppWidgetManager,
+                                           appWidgetId: Int, newOptions: Bundle) {
+        updateWidgets(context)
+    }
+
+    private fun updateWidgets(context: Context) {
+        val result = goAsync()
+        PendingResultUpdateTask(context, result).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)
+    }
+
+    private class PendingResultUpdateTask internal constructor(context: Context,
+                                                               private val result: PendingResult)
+        : AppWidgetUpdateTask(context.applicationContext) {
+
+        override fun onPostExecute(success: Boolean?) {
+            result.finish()
+        }
+    }
+}
diff --git a/main/src/main/java/com/google/android/apps/muzei/widget/WidgetUpdater.kt b/main/src/main/java/com/google/android/apps/muzei/widget/WidgetUpdater.kt
index 58df83715..fe8ecc010 100644
--- a/main/src/main/java/com/google/android/apps/muzei/widget/WidgetUpdater.kt
+++ b/main/src/main/java/com/google/android/apps/muzei/widget/WidgetUpdater.kt
@@ -29,12 +29,12 @@ import com.google.android.apps.muzei.api.MuzeiContract
 /**
  * LifecycleObserver which updates the widget when the artwork changes
  */
-class WidgetUpdater(private val mContext: Context) : DefaultLifecycleObserver {
+class WidgetUpdater(private val context: Context) : DefaultLifecycleObserver {
 
     private val widgetContentObserver: ContentObserver by lazy {
         object : ContentObserver(Handler()) {
             override fun onChange(selfChange: Boolean, uri: Uri) {
-                AppWidgetUpdateTask(mContext, false)
+                AppWidgetUpdateTask(context)
                         .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)
             }
         }
@@ -42,18 +42,18 @@ class WidgetUpdater(private val mContext: Context) : DefaultLifecycleObserver {
 
     override fun onCreate(owner: LifecycleOwner) {
         // Set up a ContentObserver to update widgets whenever the artwork changes
-        mContext.contentResolver.registerContentObserver(MuzeiContract.Artwork.CONTENT_URI,
+        context.contentResolver.registerContentObserver(MuzeiContract.Artwork.CONTENT_URI,
                 true, widgetContentObserver)
-        mContext.contentResolver.registerContentObserver(MuzeiContract.Sources.CONTENT_URI,
+        context.contentResolver.registerContentObserver(MuzeiContract.Sources.CONTENT_URI,
                 true, widgetContentObserver)
         // Update the widget now that the wallpaper is active to enable the 'Next' button if supported
         widgetContentObserver.onChange(true)
     }
 
     override fun onDestroy(owner: LifecycleOwner) {
-        mContext.contentResolver.unregisterContentObserver(widgetContentObserver)
+        context.contentResolver.unregisterContentObserver(widgetContentObserver)
         // Update the widget one last time to disable the 'Next' button until Muzei is reactivated
-        AppWidgetUpdateTask(mContext, false)
+        AppWidgetUpdateTask(context)
                 .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)
     }
 }
