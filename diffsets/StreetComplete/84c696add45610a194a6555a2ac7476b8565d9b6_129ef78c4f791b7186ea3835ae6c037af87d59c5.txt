diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.kt
index 0e2cce2dbe9..a70db0d6f6b 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.kt
@@ -11,6 +11,7 @@ import org.junit.Test
 
 open class ApplicationDbTestCase {
     protected lateinit var dbHelper: SQLiteOpenHelper
+    protected lateinit var database: Database
     protected lateinit var serializer: Serializer
 
     @Before fun setUpHelper() {
@@ -19,6 +20,7 @@ open class ApplicationDbTestCase {
             InstrumentationRegistry.getInstrumentation().targetContext,
             DATABASE_NAME
         )
+        database = AndroidDatabase(dbHelper)
     }
 
     @Test fun databaseAvailable() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDaoTest.kt
index e2e63d79495..79af625ecf9 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDaoTest.kt
@@ -13,7 +13,7 @@ class DownloadedTilesDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: DownloadedTilesDao
 
     @Before fun createDao() {
-        dao = DownloadedTilesDao(dbHelper)
+        dao = DownloadedTilesDao(database)
     }
 
     @Test fun putGetOne() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDaoTest.kt
index 34844867f2a..4d9ad46ecfd 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDaoTest.kt
@@ -10,7 +10,7 @@ class NewUserAchievementsDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: NewUserAchievementsDao
 
     @Before fun createDao() {
-        dao = NewUserAchievementsDao(dbHelper)
+        dao = NewUserAchievementsDao(database)
     }
 
     @Test fun addPopFirst() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDaoTest.kt
index 4fd65605e70..8d1da71dc62 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDaoTest.kt
@@ -22,7 +22,7 @@ class ElementEditsDaoTest : ApplicationDbTestCase() {
 
     @Before fun createDao() {
         val list = listOf<QuestType<*>>(TEST_QUEST_TYPE, TEST_QUEST_TYPE2)
-        dao = ElementEditsDao(dbHelper, QuestTypeRegistry(list), serializer)
+        dao = ElementEditsDao(database, QuestTypeRegistry(list), serializer)
     }
 
     @Test fun addGet_UpdateElementTagsEdit() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDaoTest.kt
index 2ceeeb2125a..e06fd64a6cb 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDaoTest.kt
@@ -9,7 +9,7 @@ class ElementIdProviderDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: ElementIdProviderDao
 
     @Before fun createDao() {
-        dao = ElementIdProviderDao(dbHelper)
+        dao = ElementIdProviderDao(database)
     }
 
     @Test fun assign_get() {
@@ -20,7 +20,7 @@ class ElementIdProviderDaoTest : ApplicationDbTestCase() {
         val relationIdSet = mutableSetOf<Long>()
 
         dao.assign(1L, 2, 3, 0)
-        val p1 = dao.get(1L)!!
+        val p1 = dao.get(1L)
 
         nodeIdSet.add(p1.nextNodeId())
         nodeIdSet.add(p1.nextNodeId())
@@ -34,7 +34,7 @@ class ElementIdProviderDaoTest : ApplicationDbTestCase() {
         assertThrows { p1.nextRelationId() }
 
         dao.assign(2L, 1, 1, 2)
-        val p2 = dao.get(2L)!!
+        val p2 = dao.get(2L)
 
         nodeIdSet.add(p2.nextNodeId())
         assertThrows { p2.nextNodeId() }
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDaoTest.kt
index 6093daca837..b3c20798fec 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDaoTest.kt
@@ -15,7 +15,7 @@ class OpenChangesetsDaoTest : ApplicationDbTestCase() {
     private val SOURCE = "test"
 
     @Before fun createDao() {
-        dao = OpenChangesetsDao(dbHelper)
+        dao = OpenChangesetsDao(database)
     }
 
     @Test fun deleteNonExistent() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDaoTest.kt
index 7f70a6ffb35..edf2852b1aa 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDaoTest.kt
@@ -16,7 +16,7 @@ class ElementGeometryDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: ElementGeometryDao
 
     @Before fun createDao() {
-        dao = ElementGeometryDao(dbHelper, serializer)
+        dao = ElementGeometryDao(database, serializer)
     }
 
     @Test fun testGetNull() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDaoTest.kt
index 47560746511..185a1f5bcb2 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDaoTest.kt
@@ -15,7 +15,7 @@ class NodeDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: NodeDao
 
     @Before fun createDao() {
-        dao = NodeDao(dbHelper, serializer)
+        dao = NodeDao(database, serializer)
     }
 
     @Test fun putGetNoTags() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDaoTest.kt
index 2e490e628a2..2aa4719108e 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDaoTest.kt
@@ -12,7 +12,7 @@ class RelationDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: RelationDao
 
     @Before fun createDao() {
-        dao = RelationDao(dbHelper, serializer)
+        dao = RelationDao(database, serializer)
     }
 
     @Test fun putGetNoTags() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDaoTest.kt
index 86af7073303..feb31cb272a 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDaoTest.kt
@@ -14,7 +14,7 @@ class WayDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: WayDao
 
     @Before fun createDao() {
-        dao = WayDao(dbHelper, serializer)
+        dao = WayDao(database, serializer)
     }
 
     @Test fun putGetNoTags() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDaoTest.kt
index c42f40bbe86..02b1af1b2c1 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDaoTest.kt
@@ -14,7 +14,7 @@ class OsmQuestDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: OsmQuestDao
 
     @Before fun createDao() {
-        dao = OsmQuestDao(dbHelper)
+        dao = OsmQuestDao(database)
     }
 
     @Test fun addGet() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDaoTest.kt
index cb8e4ab0249..67ea076090d 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDaoTest.kt
@@ -11,7 +11,7 @@ class OsmQuestsHiddenDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: OsmQuestsHiddenDao
 
     @Before fun createDao() {
-        dao = OsmQuestsHiddenDao(dbHelper)
+        dao = OsmQuestsHiddenDao(database)
     }
 
     @Test fun getButNothingIsThere() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/NoteDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/NoteDaoTest.kt
index 588774d6077..2db36a62540 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/NoteDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/NoteDaoTest.kt
@@ -19,7 +19,7 @@ class NoteDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: NoteDao
 
     @Before fun createDao() {
-        dao = NoteDao(dbHelper, serializer)
+        dao = NoteDao(database, serializer)
     }
 
     @Test fun putGetNoClosedDate() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDaoTest.kt
index 71988e86c76..1ba3ff34672 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDaoTest.kt
@@ -13,7 +13,7 @@ class NoteEditsDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: NoteEditsDao
 
     @Before fun createDao() {
-        dao = NoteEditsDao(dbHelper, serializer)
+        dao = NoteEditsDao(database, serializer)
     }
 
     @Test fun addGet() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDaoTest.kt
index d65caf49e97..25876ddddd0 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDaoTest.kt
@@ -10,7 +10,7 @@ class NoteQuestsHiddenDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: NoteQuestsHiddenDao
 
     @Before fun createDao() {
-        dao = NoteQuestsHiddenDao(dbHelper)
+        dao = NoteQuestsHiddenDao(database)
     }
 
     @Test fun getButNothingIsThere() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDaoTest.kt
index 493725b8b07..e3c72198cb1 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDaoTest.kt
@@ -9,7 +9,7 @@ class CountryStatisticsDaoTest  : ApplicationDbTestCase() {
     private lateinit var dao: CountryStatisticsDao
 
     @Before fun createDao() {
-        dao = CountryStatisticsDao(dbHelper)
+        dao = CountryStatisticsDao(database)
     }
 
     @Test fun addAndSubtract() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDaoTest.kt
index b6b797d7d39..96c0a0268ea 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDaoTest.kt
@@ -12,7 +12,7 @@ class QuestStatisticsDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: QuestStatisticsDao
 
     @Before fun createDao() {
-        dao = QuestStatisticsDao(dbHelper)
+        dao = QuestStatisticsDao(database)
     }
 
     @Test fun getZero() {
@@ -83,7 +83,7 @@ class QuestStatisticsDaoTest : ApplicationDbTestCase() {
         assertEquals(mapOf(
             ONE to 2,
             TWO to 1
-        ),dao.getAll())
+        ), dao.getAll())
     }
 }
 
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDaoTest.kt
index f92ef0c3a87..3f869eede23 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDaoTest.kt
@@ -9,7 +9,7 @@ class UserAchievementsDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: UserAchievementsDao
 
     @Before fun createDao() {
-        dao = UserAchievementsDao(dbHelper)
+        dao = UserAchievementsDao(database)
     }
 
     @Test fun putGetAll() {
@@ -19,7 +19,7 @@ class UserAchievementsDaoTest : ApplicationDbTestCase() {
         assertEquals(mapOf(
             ONE to 4,
             TWO to 2
-        ),dao.getAll())
+        ), dao.getAll())
     }
 }
 
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDaoTest.kt
index 3fc9a63f728..3dadde1ea33 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDaoTest.kt
@@ -9,7 +9,7 @@ class UserLinksDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: UserLinksDao
 
     @Before fun createDao() {
-        dao = UserLinksDao(dbHelper)
+        dao = UserLinksDao(database)
     }
 
     @Test fun putGetAll() {
@@ -21,7 +21,8 @@ class UserLinksDaoTest : ApplicationDbTestCase() {
 
     @Test fun addAll() {
         dao.add(ONE)
-        assertEquals(2, dao.addAll(listOf(ONE, TWO, THREE)))
+        dao.addAll(listOf(ONE, TWO, THREE))
+        assertEquals(listOf(ONE, TWO, THREE), dao.getAll())
     }
 }
 
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDaoTest.kt
index c759cfe3891..ff7df303d5f 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDaoTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDaoTest.kt
@@ -11,7 +11,7 @@ class VisibleQuestTypeDaoTest : ApplicationDbTestCase() {
     private lateinit var dao: VisibleQuestTypeDao
 
     @Before fun createDao() {
-        dao = VisibleQuestTypeDao(dbHelper)
+        dao = VisibleQuestTypeDao(database)
     }
 
     @Test fun defaultEnabledQuest() {
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/ktx/SQLiteDatabaseKtTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/ktx/SQLiteDatabaseKtTest.kt
index acbdf8254fd..754f37c907e 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/ktx/SQLiteDatabaseKtTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/ktx/SQLiteDatabaseKtTest.kt
@@ -15,9 +15,4 @@ class SQLiteDatabaseKtTest : ApplicationDbTestCase() {
     @After fun tearDown() {
         dbHelper.writableDatabase.execSQL("DROP TABLE t")
     }
-
-    @Test fun hasColumn() {
-        assertFalse(dbHelper.writableDatabase.hasColumn("t", "c"))
-        assertTrue(dbHelper.writableDatabase.hasColumn("t", "a"))
-    }
 }
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/quests/oneway_suspects/WayTrafficFlowSegmentsApiTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/quests/oneway_suspects/WayTrafficFlowSegmentsApiTest.kt
index b08670eaa71..53a531e6214 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/quests/oneway_suspects/WayTrafficFlowSegmentsApiTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/quests/oneway_suspects/WayTrafficFlowSegmentsApiTest.kt
@@ -14,7 +14,7 @@ class WayTrafficFlowSegmentsApiTest : ApplicationDbTestCase() {
     private lateinit var dao: WayTrafficFlowDao
 
     @Before fun createDao() {
-        dao = WayTrafficFlowDao(dbHelper)
+        dao = WayTrafficFlowDao(database)
     }
 
     @Test fun putGetTrue() {
@@ -44,7 +44,7 @@ class WayTrafficFlowSegmentsApiTest : ApplicationDbTestCase() {
     }
 
     @Test fun deleteUnreferenced() {
-        val wayDao = WayDao(dbHelper, KryoSerializer())
+        val wayDao = WayDao(database, KryoSerializer())
 
         wayDao.put(OsmWay(1, 0, mutableListOf(), null))
         wayDao.put(OsmWay(2, 0, mutableListOf(), null))
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/AndroidDatabase.kt b/app/src/main/java/de/westnordost/streetcomplete/data/AndroidDatabase.kt
new file mode 100644
index 00000000000..e3962131b11
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/AndroidDatabase.kt
@@ -0,0 +1,224 @@
+package de.westnordost.streetcomplete.data
+
+import android.annotation.SuppressLint
+import android.content.ContentValues
+import android.database.Cursor
+import android.database.sqlite.SQLiteDatabase.*
+import android.database.sqlite.SQLiteOpenHelper
+import android.database.sqlite.SQLiteStatement
+import de.westnordost.streetcomplete.data.ConflictAlgorithm.*
+import de.westnordost.streetcomplete.ktx.*
+import javax.inject.Inject
+
+@SuppressLint("Recycle")
+class AndroidDatabase @Inject constructor(private val dbHelper: SQLiteOpenHelper) : Database {
+    private val db get() = dbHelper.writableDatabase
+
+    override fun exec(sql: String, args: Array<Any>?) {
+        if (args == null) db.execSQL(sql) else db.execSQL(sql, args)
+    }
+
+    override fun <T> rawQuery(
+        sql: String,
+        args: Array<Any>?,
+        transform: (CursorPosition) -> T
+    ): List<T> {
+        val strArgs = args?.primitivesArrayToStringArray()
+        return db.rawQuery(sql, strArgs).toSequence(transform).toList()
+    }
+
+    override fun <T> queryOne(
+        table: String,
+        columns: Array<String>?,
+        where: String?,
+        args: Array<Any>?,
+        groupBy: String?,
+        having: String?,
+        orderBy: String?,
+        transform: (CursorPosition) -> T
+    ): T? {
+        val strArgs = args?.primitivesArrayToStringArray()
+        return db.query(false, table, columns, where, strArgs, groupBy, having, orderBy, "1").toSequence(transform).firstOrNull()
+    }
+
+    override fun <T> query(
+        table: String,
+        columns: Array<String>?,
+        where: String?,
+        args: Array<Any>?,
+        groupBy: String?,
+        having: String?,
+        orderBy: String?,
+        limit: String?,
+        distinct: Boolean,
+        transform: (CursorPosition) -> T
+    ): List<T> {
+        val strArgs = args?.primitivesArrayToStringArray()
+        return db.query(false, table, columns, where, strArgs, groupBy, having, orderBy, limit).toSequence(transform).toList()
+    }
+
+    override fun insert(
+        table: String,
+        values: Collection<Pair<String, Any?>>,
+        conflictAlgorithm: ConflictAlgorithm?
+    ): Long {
+        return db.insertWithOnConflict(
+            table,
+            null,
+            values.toContentValues(),
+            conflictAlgorithm.toConstant()
+        )
+    }
+
+    override fun insertMany(
+        table: String,
+        columnNames: Array<String>,
+        valuesList: Iterable<Array<Any?>>,
+        conflictAlgorithm: ConflictAlgorithm?
+    ): List<Long> {
+        val conflictStr = conflictAlgorithm.toSQL()
+        val columnNamesStr = columnNames.joinToString(",")
+        val placeholdersStr = Array(columnNames.size) { "?" }.joinToString(",")
+        val stmt = db.compileStatement("INSERT $conflictStr INTO $table ($columnNamesStr) VALUES ($placeholdersStr)")
+        val result = ArrayList<Long>()
+        transaction {
+            for (values in valuesList) {
+                require(values.size == columnNames.size)
+                for ((i, value) in values.withIndex()) {
+                    // Android SQLiteProgram.bind* indices are 1-based
+                    stmt.bind(i+1, value)
+                }
+                val rowId = stmt.executeInsert()
+                result.add(rowId)
+                stmt.clearBindings()
+            }
+            stmt.close()
+        }
+        return result
+    }
+
+    override fun update(
+        table: String,
+        values: Collection<Pair<String, Any?>>,
+        where: String?,
+        args: Array<Any>?,
+        conflictAlgorithm: ConflictAlgorithm?
+    ): Int {
+        return db.updateWithOnConflict(
+            table,
+            values.toContentValues(),
+            where,
+            args?.primitivesArrayToStringArray(),
+            conflictAlgorithm.toConstant()
+        )
+    }
+
+
+    override fun delete(table: String, where: String?, args: Array<Any>?): Int {
+        val strArgs = args?.primitivesArrayToStringArray()
+        return db.delete(table, where, strArgs)
+    }
+
+    override fun <T> transaction(block: () -> T): T {
+        db.beginTransaction()
+        try {
+            val result = block()
+            db.setTransactionSuccessful()
+            return result
+        } finally {
+            db.endTransaction()
+        }
+    }
+}
+
+private fun Array<Any>.primitivesArrayToStringArray() = Array(size) { i ->
+    primitiveToString(this[i])
+}
+
+private fun primitiveToString(any: Any): String = when (any) {
+    is Short, is Int, is Long, is Float, is Double -> any.toString()
+    is String -> any
+    else -> throw IllegalArgumentException("Cannot bind $any: Must be either Int, Long, Float, Double or String")
+}
+
+private inline fun <T> Cursor.toSequence(crossinline transform: (CursorPosition) -> T): List<T> = use { cursor ->
+    val c = AndroidCursorPosition(cursor)
+    cursor.moveToFirst()
+    val result = ArrayList<T>(cursor.count)
+    while(!cursor.isAfterLast) {
+        result.add(transform(c))
+        cursor.moveToNext()
+    }
+    return result
+}
+
+class AndroidCursorPosition(private val cursor: Cursor): CursorPosition {
+    override fun getShort(columnName: String): Short = cursor.getShort(columnName)
+    override fun getInt(columnName: String): Int = cursor.getInt(columnName)
+    override fun getLong(columnName: String): Long = cursor.getLong(columnName)
+    override fun getDouble(columnName: String): Double = cursor.getDouble(columnName)
+    override fun getFloat(columnName: String): Float = cursor.getFloat(columnName)
+    override fun getBlob(columnName: String): ByteArray = cursor.getBlob(columnName)
+    override fun getString(columnName: String): String = cursor.getString(columnName)
+    override fun getShortOrNull(columnName: String): Short? = cursor.getShortOrNull(columnName)
+    override fun getIntOrNull(columnName: String): Int? = cursor.getIntOrNull(columnName)
+    override fun getLongOrNull(columnName: String): Long? = cursor.getLongOrNull(columnName)
+    override fun getDoubleOrNull(columnName: String): Double? = cursor.getDoubleOrNull(columnName)
+    override fun getFloatOrNull(columnName: String): Float? = cursor.getFloatOrNull(columnName)
+    override fun getBlobOrNull(columnName: String): ByteArray? = cursor.getBlobOrNull(columnName)
+    override fun getStringOrNull(columnName: String): String? = cursor.getStringOrNull(columnName)
+}
+
+private fun Collection<Pair<String, Any?>>.toContentValues() = ContentValues(size).also {
+    for ((key, value) in this) {
+        when (value) {
+            null -> it.putNull(key)
+            is String -> it.put(key, value)
+            is Short -> it.put(key, value)
+            is Int -> it.put(key, value)
+            is Long -> it.put(key, value)
+            is Float -> it.put(key, value)
+            is Double -> it.put(key, value)
+            is ByteArray -> it.put(key, value)
+            else -> {
+                val valueType = value.javaClass.canonicalName
+                throw IllegalArgumentException("Illegal value type $valueType for key \"$key\"")
+            }
+        }
+    }
+}
+
+private fun ConflictAlgorithm?.toConstant() = when(this) {
+    ROLLBACK -> CONFLICT_ROLLBACK
+    ABORT -> CONFLICT_ABORT
+    FAIL -> CONFLICT_FAIL
+    IGNORE -> CONFLICT_IGNORE
+    REPLACE -> CONFLICT_REPLACE
+    null -> CONFLICT_NONE
+}
+
+private fun ConflictAlgorithm?.toSQL() = when(this) {
+    ROLLBACK -> " OR ROLLBACK "
+    ABORT -> " OR ABORT "
+    FAIL -> " OR FAIL "
+    IGNORE -> " OR IGNORE "
+    REPLACE -> " OR REPLACE "
+    null -> ""
+}
+
+private fun SQLiteStatement.bind(i: Int, value: Any?) {
+    when(value) {
+        null -> bindNull(i)
+        is String -> bindString(i, value)
+        is Double -> bindDouble(i, value)
+        is Long -> bindLong(i, value)
+        is ByteArray -> bindBlob(i, value)
+        is Int -> bindLong(i, value.toLong())
+        is Short -> bindLong(i, value.toLong())
+        is Float -> bindDouble(i, value.toDouble())
+        else -> {
+            val valueType = value.javaClass.canonicalName
+            throw IllegalArgumentException("Illegal value type $valueType at column $i")
+        }
+    }
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/Database.kt b/app/src/main/java/de/westnordost/streetcomplete/data/Database.kt
new file mode 100644
index 00000000000..77ab38c4c4e
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/Database.kt
@@ -0,0 +1,106 @@
+package de.westnordost.streetcomplete.data
+
+interface Database {
+
+    fun exec(sql: String, args: Array<Any>? = null)
+
+    fun <T> rawQuery(
+        sql: String,
+        args: Array<Any>? = null,
+        transform: (CursorPosition) -> T
+    ): List<T>
+
+    fun <T> queryOne(
+        table: String,
+        columns: Array<String>? = null,
+        where: String? = null,
+        args: Array<Any>? = null,
+        groupBy: String? = null,
+        having: String? = null,
+        orderBy: String? = null,
+        transform: (CursorPosition) -> T
+    ): T?
+
+    fun <T> query(
+        table: String,
+        columns: Array<String>? = null,
+        where: String? = null,
+        args: Array<Any>? = null,
+        groupBy: String? = null,
+        having: String? = null,
+        orderBy: String? = null,
+        limit: String? = null,
+        distinct: Boolean = false,
+        transform: (CursorPosition) -> T
+    ): List<T>
+
+    fun insert(
+        table: String,
+        values: Collection<Pair<String, Any?>>,
+        conflictAlgorithm: ConflictAlgorithm? = null
+    ): Long
+
+    fun insertOrIgnore(table: String, values: Collection<Pair<String, Any?>>): Long =
+        insert(table, values, ConflictAlgorithm.IGNORE)
+
+    fun replace(table: String, values: Collection<Pair<String, Any?>>): Long =
+        insert(table, values, ConflictAlgorithm.REPLACE)
+
+    fun insertMany(
+        table: String,
+        columnNames: Array<String>,
+        valuesList: Iterable<Array<Any?>>,
+        conflictAlgorithm: ConflictAlgorithm? = null
+    ): List<Long>
+
+    fun insertOrIgnoreMany(table: String, columnNames: Array<String>, valuesList: Iterable<Array<Any?>>) =
+        insertMany(table, columnNames, valuesList, ConflictAlgorithm.IGNORE)
+
+    fun replaceMany(table: String, columnNames: Array<String>, valuesList: Iterable<Array<Any?>>) =
+        insertMany(table, columnNames, valuesList, ConflictAlgorithm.REPLACE)
+
+    fun update(
+        table: String,
+        values: Collection<Pair<String, Any?>>,
+        where: String? = null,
+        args: Array<Any>? = null,
+        conflictAlgorithm: ConflictAlgorithm? = null
+    ): Int
+
+    fun delete(
+        table: String,
+        where: String? = null,
+        args: Array<Any>? = null
+    ): Int
+
+    fun <T> transaction(block: () -> T): T
+}
+
+enum class ConflictAlgorithm {
+    ROLLBACK,
+    ABORT,
+    FAIL,
+    IGNORE,
+    REPLACE
+}
+
+/** Data available at the current cursor position */
+interface CursorPosition {
+    /* It would be really nice if the interface would be just
+       operator fun <T> get(columnName: String): T
+       if T is one of the below types. But this is not possible right now in Kotlin AFAIK */
+    fun getShort(columnName: String): Short
+    fun getInt(columnName: String): Int
+    fun getLong(columnName: String): Long
+    fun getDouble(columnName: String): Double
+    fun getFloat(columnName: String): Float
+    fun getBlob(columnName: String): ByteArray
+    fun getString(columnName: String): String
+    fun getShortOrNull(columnName: String): Short?
+    fun getIntOrNull(columnName: String): Int?
+    fun getLongOrNull(columnName: String): Long?
+    fun getDoubleOrNull(columnName: String): Double?
+    fun getFloatOrNull(columnName: String): Float?
+    fun getBlobOrNull(columnName: String): ByteArray?
+    fun getStringOrNull(columnName: String): String?
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/DbModule.kt b/app/src/main/java/de/westnordost/streetcomplete/data/DbModule.kt
index d60189c5776..8b48e8f1d48 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/DbModule.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/DbModule.kt
@@ -17,5 +17,8 @@ object DbModule {
     fun sqLiteOpenHelper(ctx: Context, databaseName: String): SQLiteOpenHelper =
         StreetCompleteSQLiteOpenHelper(ctx, databaseName)
 
+    @Provides @Singleton fun database(sqLiteOpenHelper: SQLiteOpenHelper): Database =
+        AndroidDatabase(sqLiteOpenHelper)
+
 	@Provides @Singleton fun serializer(): Serializer = KryoSerializer()
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/WhereSelectionBuilder.kt b/app/src/main/java/de/westnordost/streetcomplete/data/WhereSelectionBuilder.kt
deleted file mode 100644
index ee5060411e2..00000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/data/WhereSelectionBuilder.kt
+++ /dev/null
@@ -1,14 +0,0 @@
-package de.westnordost.streetcomplete.data
-
-class WhereSelectionBuilder {
-    private val clauses = ArrayList<String>()
-    private val clausesArgs = ArrayList<String>()
-
-    val where: String get() = clauses.joinToString(" AND ") { it }
-    val args: Array<String> get() = clausesArgs.toTypedArray()
-
-    fun add(clause: String, vararg args: String) {
-        clauses.add(clause)
-        clausesArgs.addAll(args)
-    }
-}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDao.kt
index 12760930160..34d0c82d128 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/download/tiles/DownloadedTilesDao.kt
@@ -1,64 +1,59 @@
 package de.westnordost.streetcomplete.data.download.tiles
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.download.tiles.DownloadedTilesTable.Columns.X
 import de.westnordost.streetcomplete.data.download.tiles.DownloadedTilesTable.Columns.Y
 import de.westnordost.streetcomplete.data.download.tiles.DownloadedTilesTable.Columns.TYPE
 import de.westnordost.streetcomplete.data.download.tiles.DownloadedTilesTable.Columns.DATE
 import de.westnordost.streetcomplete.data.download.tiles.DownloadedTilesTable.NAME
-import de.westnordost.streetcomplete.ktx.query
-import de.westnordost.streetcomplete.ktx.transaction
 import de.westnordost.streetcomplete.util.TilePos
 import de.westnordost.streetcomplete.util.TilesRect
+import java.lang.System.currentTimeMillis
 
 import javax.inject.Inject
 
 /** Keeps info in which areas things have been downloaded already in a tile grid */
-class DownloadedTilesDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-
-    private val db get() = dbHelper.writableDatabase
+class DownloadedTilesDao @Inject constructor(private val db: Database) {
 
     /** Persist that the given type has been downloaded in every tile in the given tile range  */
     fun put(tilesRect: TilesRect, typeName: String) {
-        val time = System.currentTimeMillis()
-        db.transaction {
-            for (tile in tilesRect.asTilePosSequence()) {
-                db.replaceOrThrow(NAME, null, contentValuesOf(
-                    X to tile.x,
-                    Y to tile.y,
-                    TYPE to typeName,
-                    DATE to time
-                ))
-            }
-        }
+        val time = currentTimeMillis()
+        db.replaceMany(NAME,
+            arrayOf(X, Y, TYPE, DATE),
+            tilesRect.asTilePosSequence().map { arrayOf<Any?>(
+                it.x,
+                it.y,
+                typeName,
+                time
+            ) }.asIterable()
+        )
     }
 
     /** Invalidate all types within the given tile. (consider them as not-downloaded) */
     fun remove(tile: TilePos): Int =
         db.delete(NAME, "$X = ? AND $Y = ?", arrayOf(tile.x.toString(), tile.y.toString()))
 
-
     fun removeAll() {
-        db.execSQL("DELETE FROM $NAME")
+        db.exec("DELETE FROM $NAME")
     }
 
     /** @return a list of type names which have already been downloaded in every tile in the
      *  given tile range
      */
-    fun get(tilesRect: TilesRect, ignoreOlderThan: Long): List<String>  {
+    fun get(tilesRect: TilesRect, ignoreOlderThan: Long): List<String> {
         val tileCount = tilesRect.size
         return db.query(NAME,
             columns = arrayOf(TYPE),
-            selection = "$X BETWEEN ? AND ? AND $Y BETWEEN ? AND ? AND $DATE > ?",
-            selectionArgs = arrayOf(
-                tilesRect.left.toString(),
-                tilesRect.right.toString(),
-                tilesRect.top.toString(),
-                tilesRect.bottom.toString(),
-                ignoreOlderThan.toString()
+            where = "$X BETWEEN ? AND ? AND $Y BETWEEN ? AND ? AND $DATE > ?",
+            args = arrayOf(
+                tilesRect.left,
+                tilesRect.right,
+                tilesRect.top,
+                tilesRect.bottom,
+                ignoreOlderThan
             ),
             groupBy = TYPE,
-            having = "COUNT(*) >= $tileCount") { it.getString(0) }
+            having = "COUNT(*) >= $tileCount"
+        ) { it.getString(TYPE) }
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDao.kt
index 93d5e63546d..d16b9b20a03 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/notifications/NewUserAchievementsDao.kt
@@ -1,24 +1,19 @@
 package de.westnordost.streetcomplete.data.notifications
 
-import android.database.sqlite.SQLiteDatabase
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.notifications.NewUserAchievementsTable.Columns.ACHIEVEMENT
 import de.westnordost.streetcomplete.data.notifications.NewUserAchievementsTable.Columns.LEVEL
 import de.westnordost.streetcomplete.data.notifications.NewUserAchievementsTable.NAME
 import javax.inject.Inject
 
-import de.westnordost.streetcomplete.ktx.*
 import java.util.concurrent.CopyOnWriteArrayList
 import javax.inject.Singleton
 
 /** Stores which achievements have *newly* been unlocked by the user and which levels. */
-@Singleton class NewUserAchievementsDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
+@Singleton class NewUserAchievementsDao @Inject constructor(private val db: Database) {
     /* Must be a singleton because there is a listener that should respond to a change in the
      *  database table */
 
-    private val db get() = dbHelper.writableDatabase
-
     interface UpdateListener {
         fun onNewUserAchievementsUpdated()
     }
@@ -32,9 +27,10 @@ import javax.inject.Singleton
                 it.getString(ACHIEVEMENT) to it.getInt(LEVEL)
             }
             if (r != null) {
-                val query = "$ACHIEVEMENT = ? AND $LEVEL = ?"
-                val args = arrayOf(r.first, r.second.toString())
-                db.delete(NAME, query, args)
+                db.delete(NAME,
+                    where = "$ACHIEVEMENT = ? AND $LEVEL = ?",
+                    args = arrayOf(r.first, r.second)
+                )
                 onNewUserAchievementsChanged()
             }
             result = r
@@ -42,15 +38,14 @@ import javax.inject.Singleton
         return result
     }
 
-    fun getCount(): Int {
-        return db.queryOne(NAME, arrayOf("COUNT(*)")) { it.getInt(0) } ?: 0
-    }
+    fun getCount(): Int =
+        db.queryOne(NAME, arrayOf("COUNT(*) AS count")) { it.getInt("count") } ?: 0
 
     fun push(achievementAndLevel: Pair<String, Int>) {
-        val result = db.insertWithOnConflict(NAME, null, contentValuesOf(
+        val result = db.insertOrIgnore(NAME, listOf(
             ACHIEVEMENT to achievementAndLevel.first,
             LEVEL to achievementAndLevel.second
-        ), SQLiteDatabase.CONFLICT_IGNORE)
+        ))
         if (result != -1L) {
             onNewUserAchievementsChanged()
         }
@@ -68,4 +63,4 @@ import javax.inject.Singleton
             listener.onNewUserAchievementsUpdated()
         }
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDao.kt
index b310313cb17..1f2eb708a55 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementEditsDao.kt
@@ -1,11 +1,9 @@
 package de.westnordost.streetcomplete.data.osm.edits
 
-import android.content.ContentValues
-import android.database.Cursor
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.Element
 import de.westnordost.osmapi.map.data.OsmLatLon
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osm.edits.ElementEditsTable.Columns.ACTION
 import de.westnordost.streetcomplete.data.osm.edits.ElementEditsTable.Columns.CREATED_TIMESTAMP
 import de.westnordost.streetcomplete.data.osm.edits.ElementEditsTable.Columns.ELEMENT_ID
@@ -29,75 +27,73 @@ import de.westnordost.streetcomplete.util.Serializer
 import javax.inject.Inject
 
 class ElementEditsDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val questTypeRegistry: QuestTypeRegistry,
     private val serializer: Serializer
 ) {
-    private val db get() = dbHelper.writableDatabase
-
     fun add(edit: ElementEdit) {
-        val rowId = db.insertOrThrow(NAME, null, edit.toContentValues())
+        val rowId = db.insert(NAME, edit.toPairs())
         edit.id = rowId
     }
 
     fun get(id: Long): ElementEdit? =
-        db.queryOne(NAME, selection = "$ID = $id") { it.toElementEdit() }
+        db.queryOne(NAME, where = "$ID = $id") { it.toElementEdit() }
 
     fun getOldestUnsynced(): ElementEdit? =
-        db.queryOne(NAME, selection = "$IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toElementEdit() }
+        db.queryOne(NAME,
+            where = "$IS_SYNCED = 0",
+            orderBy = CREATED_TIMESTAMP
+        ) { it.toElementEdit() }
 
     fun getUnsyncedCount(): Int =
-        db.queryOne(NAME, arrayOf("COUNT(*)"), "$IS_SYNCED = 0") { it.getInt(0) } ?: 0
+        db.queryOne(NAME,
+            columns = arrayOf("COUNT(*) AS count"),
+            where = "$IS_SYNCED = 0"
+        ) { it.getInt("count") } ?: 0
 
     fun getAllUnsynced(): List<ElementEdit> =
-        db.query(NAME, selection = "$IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toElementEdit() }
+        db.query(NAME, where = "$IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toElementEdit() }
 
     fun getAll(): List<ElementEdit> =
         db.query(NAME, orderBy = "$IS_SYNCED, $CREATED_TIMESTAMP") { it.toElementEdit() }
 
     fun markSynced(id: Long): Boolean =
-        db.update(NAME, contentValuesOf(IS_SYNCED to 1), "$ID = $id", null) == 1
+        db.update(NAME, listOf(IS_SYNCED to 1), "$ID = $id") == 1
 
     fun delete(id: Long): Boolean =
-        db.delete(NAME, "$ID = $id", null) == 1
+        db.delete(NAME, "$ID = $id") == 1
 
     fun deleteSyncedOlderThan(timestamp: Long): Int =
-        db.delete(NAME, "$IS_SYNCED = 1 AND $CREATED_TIMESTAMP < $timestamp", null)
+        db.delete(NAME, "$IS_SYNCED = 1 AND $CREATED_TIMESTAMP < $timestamp")
 
     fun updateElementId(elementType: Element.Type, oldElementId: Long, newElementId: Long): Int =
         db.update(
             NAME,
-            contentValuesOf(ELEMENT_ID to newElementId),
-            "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?",
-            arrayOf(elementType.name, oldElementId.toString())
-        )
-
-    private fun ElementEdit.toContentValues(): ContentValues {
-        val values = contentValuesOf(
-            QUEST_TYPE to questType.name,
-            ELEMENT_TYPE to elementType.name,
-            ELEMENT_ID to elementId,
-            SOURCE to source,
-            LATITUDE to position.latitude,
-            LONGITUDE to position.longitude,
-            CREATED_TIMESTAMP to createdTimestamp,
-            IS_SYNCED to if (isSynced) 1 else 0,
-            TYPE to action::class.simpleName
+            values = listOf(ELEMENT_ID to newElementId),
+            where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?",
+            args = arrayOf(elementType.name, oldElementId)
         )
-        when(action) {
-            is UpdateElementTagsAction       -> values.put(ACTION, serializer.toBytes(action.createSerializable()))
-
-            is RevertUpdateElementTagsAction -> values.put(ACTION, serializer.toBytes(action))
 
-            is DeletePoiNodeAction           -> values.put(ACTION, serializer.toBytes(action))
-
-            is SplitWayAction                -> values.put(ACTION, serializer.toBytes(action))
+    private fun ElementEdit.toPairs(): List<Pair<String, Any?>> = listOf(
+        QUEST_TYPE to questType.name,
+        ELEMENT_TYPE to elementType.name,
+        ELEMENT_ID to elementId,
+        SOURCE to source,
+        LATITUDE to position.latitude,
+        LONGITUDE to position.longitude,
+        CREATED_TIMESTAMP to createdTimestamp,
+        IS_SYNCED to if (isSynced) 1 else 0,
+        TYPE to action::class.simpleName,
+        ACTION to when(action) {
+            is UpdateElementTagsAction       -> serializer.toBytes(action.createSerializable())
+            is RevertUpdateElementTagsAction -> serializer.toBytes(action)
+            is DeletePoiNodeAction           -> serializer.toBytes(action)
+            is SplitWayAction                -> serializer.toBytes(action)
+            else -> null
         }
+    )
 
-        return values
-    }
-
-    private fun Cursor.toElementEdit(): ElementEdit {
+    private fun CursorPosition.toElementEdit(): ElementEdit {
         val b = getBlobOrNull(ACTION)
         val type = getString(TYPE)
 
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDao.kt
index 4080d7139a4..633ece07059 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/ElementIdProviderDao.kt
@@ -1,48 +1,35 @@
 package de.westnordost.streetcomplete.data.osm.edits
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.Element
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osm.edits.ElementIdProviderTable.Columns.EDIT_ID
 import de.westnordost.streetcomplete.data.osm.edits.ElementIdProviderTable.Columns.ELEMENT_TYPE
 import de.westnordost.streetcomplete.data.osm.edits.ElementIdProviderTable.Columns.ID
 import de.westnordost.streetcomplete.data.osm.edits.ElementIdProviderTable.NAME
 import de.westnordost.streetcomplete.data.osm.mapdata.ElementKey
-import de.westnordost.streetcomplete.ktx.getLong
-import de.westnordost.streetcomplete.ktx.getString
-import de.westnordost.streetcomplete.ktx.query
-import de.westnordost.streetcomplete.ktx.transaction
 import javax.inject.Inject
 
 /** Assigns new element ids for ElementEditActions that create new elements */
-class ElementIdProviderDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper
-) {
-    private val db get() = dbHelper.writableDatabase
+class ElementIdProviderDao @Inject constructor(private val db: Database) {
 
     fun assign(editId: Long, nodeCount: Int, wayCount: Int, relationCount: Int) {
         if (nodeCount == 0 && wayCount == 0 && relationCount == 0) return
-        db.transaction {
-            repeat(nodeCount) { assign(editId, Element.Type.NODE) }
-            repeat(wayCount) { assign(editId, Element.Type.WAY) }
-            repeat(relationCount) { assign(editId, Element.Type.RELATION) }
-        }
-    }
 
-    private fun assign(editId: Long, elementType: Element.Type) {
-        db.insert(NAME, null, contentValuesOf(
-            EDIT_ID to editId,
-            ELEMENT_TYPE to elementType.name
-        ))
+        db.insertMany(NAME,
+            arrayOf(EDIT_ID, ELEMENT_TYPE),
+            sequence {
+                repeat(nodeCount) { yield(Element.Type.NODE) }
+                repeat(wayCount) { yield(Element.Type.WAY) }
+                repeat(relationCount) { yield(Element.Type.RELATION) }
+            }.map { arrayOf<Any?>(editId, it.name) }.asIterable()
+        )
     }
 
-    fun get(editId: Long): ElementIdProvider {
-        val elementKeys = db.query(NAME, selection = "$EDIT_ID = $editId") {
+    fun get(editId: Long) = ElementIdProvider(
+        db.query(NAME, where = "$EDIT_ID = $editId") {
             ElementKey(Element.Type.valueOf(it.getString(ELEMENT_TYPE)), -it.getLong(ID))
-        }
-        return ElementIdProvider(elementKeys)
-    }
+        })
 
     fun delete(editId: Long): Int =
-        db.delete(NAME, "$EDIT_ID = $editId", null)
+        db.delete(NAME, "$EDIT_ID = $editId")
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDao.kt
index 92e2f439f74..47959d13b09 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/edits/upload/changesets/OpenChangesetsDao.kt
@@ -1,8 +1,7 @@
 package de.westnordost.streetcomplete.data.osm.edits.upload.changesets
 
-import android.database.Cursor
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 
 import javax.inject.Inject
 
@@ -10,43 +9,37 @@ import de.westnordost.streetcomplete.data.osm.edits.upload.changesets.OpenChange
 import de.westnordost.streetcomplete.data.osm.edits.upload.changesets.OpenChangesetsTable.Columns.QUEST_TYPE
 import de.westnordost.streetcomplete.data.osm.edits.upload.changesets.OpenChangesetsTable.Columns.SOURCE
 import de.westnordost.streetcomplete.data.osm.edits.upload.changesets.OpenChangesetsTable.NAME
-import de.westnordost.streetcomplete.ktx.getLong
-import de.westnordost.streetcomplete.ktx.getString
-import de.westnordost.streetcomplete.ktx.query
-import de.westnordost.streetcomplete.ktx.queryOne
 
 /** Keep track of changesets and the date of the last change that has been made to them  */
-class OpenChangesetsDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+class OpenChangesetsDao @Inject constructor(private val db: Database) {
 
-    fun getAll(): Collection<OpenChangeset> {
-        return db.query(NAME) { it.toOpenChangeset() }
-    }
+    fun getAll(): Collection<OpenChangeset> =
+        db.query(NAME) { it.toOpenChangeset() }
 
     fun put(openChangeset: OpenChangeset) {
-        db.replaceOrThrow(NAME, null, openChangeset.toContentValues())
-    }
-
-    fun get(questType: String, source: String): OpenChangeset? {
-        val where = "$QUEST_TYPE = ? AND $SOURCE = ?"
-        val args = arrayOf(questType, source)
-        return db.queryOne(NAME, null, where, args) { it.toOpenChangeset()  }
+        db.replace(NAME, openChangeset.toPairs())
     }
 
-    fun delete(questType: String, source: String): Boolean {
-        val where = "$QUEST_TYPE = ? AND $SOURCE = ?"
-        val whereArgs = arrayOf(questType, source)
-        return db.delete(NAME, where, whereArgs) == 1
-    }
+    fun get(questType: String, source: String): OpenChangeset? =
+        db.queryOne(NAME,
+            where = "$QUEST_TYPE = ? AND $SOURCE = ?",
+            args = arrayOf(questType, source)
+        ) { it.toOpenChangeset()  }
+
+    fun delete(questType: String, source: String): Boolean =
+        db.delete(NAME,
+            where = "$QUEST_TYPE = ? AND $SOURCE = ?",
+            args = arrayOf(questType, source)
+        ) == 1
 }
 
-private fun OpenChangeset.toContentValues() = contentValuesOf(
+private fun OpenChangeset.toPairs() = listOf(
     QUEST_TYPE to questType,
     SOURCE to source,
     CHANGESET_ID to changesetId
 )
 
-private fun Cursor.toOpenChangeset() = OpenChangeset(
+private fun CursorPosition.toOpenChangeset() = OpenChangeset(
     getString(QUEST_TYPE),
     getString(SOURCE),
     getLong(CHANGESET_ID)
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDao.kt
index 026802e6ef2..44824072b07 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/geometry/ElementGeometryDao.kt
@@ -1,8 +1,5 @@
 package de.westnordost.streetcomplete.data.osm.geometry
 
-import android.database.Cursor
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.BoundingBox
 
 
@@ -11,7 +8,8 @@ import javax.inject.Inject
 import de.westnordost.streetcomplete.util.Serializer
 import de.westnordost.osmapi.map.data.Element
 import de.westnordost.osmapi.map.data.OsmLatLon
-import de.westnordost.streetcomplete.data.WhereSelectionBuilder
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osm.geometry.ElementGeometryTable.Columns.ELEMENT_ID
 import de.westnordost.streetcomplete.data.osm.geometry.ElementGeometryTable.Columns.ELEMENT_TYPE
 import de.westnordost.streetcomplete.data.osm.geometry.ElementGeometryTable.Columns.GEOMETRY_POLYGONS
@@ -32,69 +30,85 @@ import de.westnordost.streetcomplete.ktx.*
 
 /** Stores the geometry of elements */
 class ElementGeometryDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val serializer: Serializer
 ) {
-    private val db get() = dbHelper.writableDatabase
-
     fun put(entry: ElementGeometryEntry) {
-        db.replaceOrThrow(NAME, null, entry.toContentValues())
+        db.replace(NAME, entry.toPairs())
     }
 
-    fun get(type: Element.Type, id: Long): ElementGeometry? {
-        val where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?"
-        val args = arrayOf(type.name, id.toString())
-
-        return db.queryOne(NAME, null, where, args) { it.toElementGeometry() }
-    }
+    fun get(type: Element.Type, id: Long): ElementGeometry? =
+        db.queryOne(NAME,
+            where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?",
+            args = arrayOf(type.name, id)
+        ) { it.toElementGeometry() }
 
-    fun delete(type: Element.Type, id: Long): Boolean {
-        val where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?"
-        val args = arrayOf(type.name, id.toString())
-
-        return db.delete(NAME, where, args) == 1
-    }
+    fun delete(type: Element.Type, id: Long): Boolean =
+        db.delete(NAME,
+            where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?",
+            args = arrayOf(type.name, id)
+        ) == 1
 
     fun putAll(entries: Collection<ElementGeometryEntry>) {
-        db.transaction {
-            for (entry in entries) {
-                put(entry)
-            }
-        }
+        if (entries.isEmpty()) return
+
+        db.replaceMany(NAME,
+            arrayOf(
+                ELEMENT_TYPE,
+                ELEMENT_ID,
+                CENTER_LATITUDE,
+                CENTER_LONGITUDE,
+                GEOMETRY_POLYGONS,
+                GEOMETRY_POLYLINES,
+                MIN_LATITUDE,
+                MIN_LONGITUDE,
+                MAX_LATITUDE,
+                MAX_LONGITUDE
+            ),
+            entries.map {
+                val bbox = it.geometry.getBounds()
+                val g = it.geometry
+                arrayOf(
+                    it.elementType.name,
+                    it.elementId,
+                    g.center.latitude,
+                    g.center.longitude,
+                    if (g is ElementPolygonsGeometry) serializer.toBytes(g.polygons) else null,
+                    if (g is ElementPolylinesGeometry) serializer.toBytes(g.polylines) else null,
+                    bbox.minLatitude,
+                    bbox.minLongitude,
+                    bbox.maxLatitude,
+                    bbox.maxLongitude
+            ) }
+        )
     }
 
-    fun getAllKeys(bbox: BoundingBox): List<ElementKey> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bbox)
-        return db.query(NAME, arrayOf(ELEMENT_TYPE, ELEMENT_ID), builder.where, builder.args) {
-            ElementKey(
-                Element.Type.valueOf(it.getString(0)),
-                it.getLong(1)
-            )
-        }
-    }
+    fun getAllKeys(bbox: BoundingBox): List<ElementKey> =
+        db.query(NAME,
+            columns = arrayOf(ELEMENT_TYPE, ELEMENT_ID),
+            where = inBoundsSql(bbox)
+        ) { it.toElementKey() }
 
-    fun getAllEntries(bbox: BoundingBox): List<ElementGeometryEntry> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bbox)
-        return db.query(NAME, null, builder.where, builder.args) { it.toElementGeometryEntry() }
-    }
+    fun getAllEntries(bbox: BoundingBox): List<ElementGeometryEntry> =
+        db.query(NAME, where = inBoundsSql(bbox)) { it.toElementGeometryEntry() }
 
     fun getAllEntries(keys: Collection<ElementKey>): List<ElementGeometryEntry> {
         if (keys.isEmpty()) return emptyList()
-        val values = keys.joinToString(",") { "('${it.type.name}', ${it.id})" }
         return db.transaction {
             /* this looks a little complicated. Basically, this is a workaround for SQLite not
                supporting the "SELECT id FROM foo WHERE (a,b) IN ((1,2), (3,4), (5,6))" syntax:
                Instead, we insert the values into a temporary table and inner join on that table then
                https://stackoverflow.com/questions/18363276/how-do-you-do-an-in-query-that-has-multiple-columns-in-sqlite
              */
-            db.execSQL(TEMPORARY_LOOKUP_CREATE)
-            db.execSQL(TEMPORARY_LOOKUP_MERGED_VIEW_CREATE)
-            db.execSQL("INSERT OR IGNORE INTO $NAME_TEMPORARY_LOOKUP ($ELEMENT_TYPE, $ELEMENT_ID) VALUES $values;")
+            db.exec(TEMPORARY_LOOKUP_CREATE)
+            db.exec(TEMPORARY_LOOKUP_MERGED_VIEW_CREATE)
+            db.insertOrIgnoreMany(NAME_TEMPORARY_LOOKUP,
+                arrayOf(ELEMENT_TYPE, ELEMENT_ID),
+                keys.map { arrayOf(it.type.name, it.id) }
+            )
             val result = db.query(NAME_TEMPORARY_LOOKUP_MERGED_VIEW) { it.toElementGeometryEntry() }
-            db.execSQL("DROP VIEW $NAME_TEMPORARY_LOOKUP_MERGED_VIEW")
-            db.execSQL("DROP TABLE $NAME_TEMPORARY_LOOKUP")
+            db.exec("DROP VIEW $NAME_TEMPORARY_LOOKUP_MERGED_VIEW")
+            db.exec("DROP TABLE $NAME_TEMPORARY_LOOKUP")
             result
         }
     }
@@ -110,18 +124,18 @@ class ElementGeometryDao @Inject constructor(
         return deletedCount
     }
 
-    private fun ElementGeometryEntry.toContentValues() = contentValuesOf(
+    private fun ElementGeometryEntry.toPairs() = listOf(
         ELEMENT_TYPE to elementType.name,
         ELEMENT_ID to elementId
-    ) + geometry.toContentValues()
+    ) + geometry.toPairs()
 
-    private fun Cursor.toElementGeometryEntry() = ElementGeometryEntry(
+    private fun CursorPosition.toElementGeometryEntry() = ElementGeometryEntry(
         Element.Type.valueOf(getString(ELEMENT_TYPE)),
         getLong(ELEMENT_ID),
         toElementGeometry()
     )
 
-    private fun ElementGeometry.toContentValues() = contentValuesOf(
+    private fun ElementGeometry.toPairs() = listOf(
         CENTER_LATITUDE to center.latitude,
         CENTER_LONGITUDE to center.longitude,
         GEOMETRY_POLYGONS to if (this is ElementPolygonsGeometry) serializer.toBytes(polygons) else null,
@@ -132,7 +146,7 @@ class ElementGeometryDao @Inject constructor(
         MAX_LONGITUDE to getBounds().maxLongitude
     )
 
-    private fun Cursor.toElementGeometry(): ElementGeometry {
+    private fun CursorPosition.toElementGeometry(): ElementGeometry {
         val polylines = getBlobOrNull(GEOMETRY_POLYLINES)?.let { serializer.toObject<PolyLines>(it) }
         val polygons = getBlobOrNull(GEOMETRY_POLYGONS)?.let { serializer.toObject<PolyLines>(it) }
         val center = OsmLatLon(getDouble(CENTER_LATITUDE), getDouble(CENTER_LONGITUDE))
@@ -145,13 +159,17 @@ class ElementGeometryDao @Inject constructor(
     }
 }
 
-private fun WhereSelectionBuilder.appendBounds(bbox: BoundingBox): WhereSelectionBuilder {
-    add("$MAX_LONGITUDE >= ?", bbox.minLongitude.toString())
-    add("$MAX_LATITUDE >= ?", bbox.minLatitude.toString())
-    add("$MIN_LONGITUDE <= ?", bbox.maxLongitude.toString())
-    add("$MIN_LATITUDE <= ?", bbox.maxLatitude.toString())
-    return this
-}
+private fun inBoundsSql(bbox: BoundingBox) = """
+    $MAX_LONGITUDE >= ${bbox.minLongitude} AND
+    $MAX_LATITUDE >= ${bbox.minLatitude} AND
+    $MIN_LONGITUDE <= ${bbox.maxLongitude} AND
+    $MIN_LATITUDE <= ${bbox.maxLatitude}
+""".trimIndent()
+
+private fun CursorPosition.toElementKey() = ElementKey(
+    Element.Type.valueOf(getString(ELEMENT_TYPE)),
+    getLong(ELEMENT_ID)
+)
 
 data class ElementGeometryEntry(
     val elementType: Element.Type,
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDao.kt
index 0344a2ac40c..e59a6dd1153 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/NodeDao.kt
@@ -1,13 +1,11 @@
 package de.westnordost.streetcomplete.data.osm.mapdata
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
-
 import javax.inject.Inject
 
 import de.westnordost.osmapi.map.data.Node
 import de.westnordost.osmapi.map.data.OsmLatLon
 import de.westnordost.osmapi.map.data.OsmNode
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osm.mapdata.NodeTable.Columns.ID
 import de.westnordost.streetcomplete.data.osm.mapdata.NodeTable.Columns.LAST_UPDATE
 import de.westnordost.streetcomplete.data.osm.mapdata.NodeTable.Columns.LATITUDE
@@ -21,11 +19,9 @@ import java.lang.System.currentTimeMillis
 
 /** Stores OSM nodes */
 class NodeDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val serializer: Serializer
 ) {
-    private val db get() = dbHelper.writableDatabase
-
     fun put(node: Node) {
         putAll(listOf(node))
     }
@@ -38,24 +34,28 @@ class NodeDao @Inject constructor(
 
     fun putAll(nodes: Collection<Node>) {
         if (nodes.isEmpty()) return
-        db.transaction {
-            for (node in nodes) {
-                db.replaceOrThrow(NAME, null, contentValuesOf(
-                    ID to node.id,
-                    VERSION to node.version,
-                    LATITUDE to node.position.latitude,
-                    LONGITUDE to node.position.longitude,
-                    TAGS to node.tags?.let { serializer.toBytes(HashMap<String,String>(it)) },
-                    LAST_UPDATE to currentTimeMillis()
-                ))
+
+        val time = currentTimeMillis()
+
+        db.replaceMany(NAME,
+            arrayOf(ID, VERSION, LATITUDE, LONGITUDE, TAGS, LAST_UPDATE),
+            nodes.map { node ->
+                arrayOf(
+                    node.id,
+                    node.version,
+                    node.position.latitude,
+                    node.position.longitude,
+                    node.tags?.let { serializer.toBytes(HashMap<String,String>(it)) },
+                    time
+                )
             }
-        }
+        )
     }
 
     fun getAll(ids: Collection<Long>): List<Node> {
         if (ids.isEmpty()) return emptyList()
         val idsString = ids.joinToString(",")
-        return db.query(NAME, selection = "$ID IN ($idsString)") { cursor ->
+        return db.query(NAME, where = "$ID IN ($idsString)") { cursor ->
             OsmNode(
                 cursor.getLong(ID),
                 cursor.getInt(VERSION),
@@ -68,9 +68,9 @@ class NodeDao @Inject constructor(
     fun deleteAll(ids: Collection<Long>): Int {
         if (ids.isEmpty()) return 0
         val idsString = ids.joinToString(",")
-        return db.delete(NAME, "$ID IN ($idsString)", null)
+        return db.delete(NAME, "$ID IN ($idsString)")
     }
 
     fun getIdsOlderThan(timestamp: Long): List<Long> =
-        db.query(NAME, columns = arrayOf(ID), selection = "$LAST_UPDATE < $timestamp") { it.getLong(0) }
+        db.query(NAME, columns = arrayOf(ID), where = "$LAST_UPDATE < $timestamp") { it.getLong(ID) }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDao.kt
index d6c74c8419b..f802b47fb63 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/RelationDao.kt
@@ -1,8 +1,7 @@
 package de.westnordost.streetcomplete.data.osm.mapdata
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.*
+import de.westnordost.streetcomplete.data.Database
 
 import javax.inject.Inject
 
@@ -22,11 +21,9 @@ import java.lang.System.currentTimeMillis
 
 /** Stores OSM relations */
 class RelationDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val serializer: Serializer
 ) {
-    private val db get() = dbHelper.writableDatabase
-
     fun put(relation: Relation) {
         putAll(listOf(relation))
     }
@@ -35,30 +32,42 @@ class RelationDao @Inject constructor(
         getAll(listOf(id)).firstOrNull()
 
     fun delete(id: Long): Boolean =
-        deleteAll(listOf(id)) > 0
+        deleteAll(listOf(id)) == 1
 
     fun putAll(relations: Collection<Relation>) {
         if (relations.isEmpty()) return
         val idsString = relations.joinToString(",") { it.id.toString() }
+
+        val time = currentTimeMillis()
+
         db.transaction {
-            db.delete(NAME_MEMBERS, "$ID IN ($idsString)", null)
-            for (relation in relations) {
-                relation.members.forEachIndexed { index, member ->
-                    db.insertOrThrow(NAME_MEMBERS, null, contentValuesOf(
-                        ID to relation.id,
-                        INDEX to index,
-                        REF to member.ref,
-                        TYPE to member.type.name,
-                        ROLE to member.role.orEmpty()
-                    ))
+            db.delete(NAME_MEMBERS, "$ID IN ($idsString)")
+
+            db.insertMany(NAME_MEMBERS,
+                arrayOf(ID, INDEX, REF, TYPE, ROLE),
+                relations.flatMap { relation ->
+                    relation.members.mapIndexed { index, member ->
+                        arrayOf(
+                            relation.id,
+                            index,
+                            member.ref,
+                            member.type.name,
+                            member.role.orEmpty()
+                        )
+                    }
                 }
-                db.replaceOrThrow(NAME, null, contentValuesOf(
-                    ID to relation.id,
-                    VERSION to relation.version,
-                    TAGS to relation.tags?.let { serializer.toBytes(HashMap<String,String>(it)) },
-                    LAST_UPDATE to currentTimeMillis()
-                ))
-            }
+            )
+            db.replaceMany(NAME,
+                arrayOf(ID, VERSION, TAGS, LAST_UPDATE),
+                relations.map { relation ->
+                    arrayOf(
+                        relation.id,
+                        relation.version,
+                        relation.tags?.let { serializer.toBytes(HashMap<String,String>(it)) },
+                        time
+                    )
+                }
+            )
         }
     }
 
@@ -67,7 +76,7 @@ class RelationDao @Inject constructor(
         val idsString = ids.joinToString(",")
 
         val membersByRelationId = mutableMapOf<Long, MutableList<RelationMember>>()
-        db.query(NAME_MEMBERS, selection = "$ID IN ($idsString)", orderBy = "$ID, $INDEX") { c ->
+        db.query(NAME_MEMBERS, where = "$ID IN ($idsString)", orderBy = "$ID, $INDEX") { c ->
             val members = membersByRelationId.getOrPut(c.getLong(ID)) { ArrayList() }
             members.add(OsmRelationMember(
                 c.getLong(REF),
@@ -76,7 +85,7 @@ class RelationDao @Inject constructor(
             ))
         }
 
-        return db.query(NAME, selection = "$ID IN ($idsString)") { c ->
+        return db.query(NAME, where = "$ID IN ($idsString)") { c ->
             val id = c.getLong(ID)
             OsmRelation(
                 id,
@@ -91,8 +100,8 @@ class RelationDao @Inject constructor(
         if (ids.isEmpty()) return 0
         val idsString = ids.joinToString(",")
         return db.transaction {
-            db.delete(NAME_MEMBERS, "$ID IN ($idsString)", null)
-            db.delete(NAME, "ID IN ($idsString)", null)
+            db.delete(NAME_MEMBERS, "$ID IN ($idsString)")
+            db.delete(NAME, "$ID IN ($idsString)")
         }
     }
 
@@ -106,14 +115,14 @@ class RelationDao @Inject constructor(
         getAllForElement(Element.Type.RELATION, relationId)
 
     fun getIdsOlderThan(timestamp: Long): List<Long> =
-        db.query(NAME, columns = arrayOf(ID), selection = "$LAST_UPDATE < $timestamp") { it.getLong(0) }
+        db.query(NAME, columns = arrayOf(ID), where = "$LAST_UPDATE < $timestamp") { it.getLong(ID) }
 
     private fun getAllForElement(elementType: Element.Type, elementId: Long): List<Relation> {
         val ids = db.query(
             NAME_MEMBERS,
             columns = arrayOf(ID),
-            selection = "$REF = $elementId AND $TYPE = ?",
-            selectionArgs = arrayOf(elementType.name)) { it.getLong(0) }.toSet()
+            where = "$REF = $elementId AND $TYPE = ?",
+            args = arrayOf(elementType.name)) { it.getLong(ID) }.toSet()
         return getAll(ids)
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDao.kt
index 7b67287fb80..9ed209c0e6b 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/mapdata/WayDao.kt
@@ -1,8 +1,7 @@
 package de.westnordost.streetcomplete.data.osm.mapdata
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.*
+import de.westnordost.streetcomplete.data.Database
 
 import javax.inject.Inject
 
@@ -20,11 +19,9 @@ import java.lang.System.currentTimeMillis
 
 /** Stores OSM ways */
 class WayDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val serializer: Serializer
 ) {
-    private val db get() = dbHelper.writableDatabase
-
     fun put(way: Way) {
         putAll(listOf(way))
     }
@@ -38,23 +35,32 @@ class WayDao @Inject constructor(
     fun putAll(ways: Collection<Way>) {
         if (ways.isEmpty()) return
         val idsString = ways.joinToString(",") { it.id.toString() }
+
+        val time = currentTimeMillis()
+
         db.transaction {
-            db.delete(NAME_NODES, "$ID IN ($idsString)", null)
-            for (way in ways) {
-                way.nodeIds.forEachIndexed { index, nodeId ->
-                    db.insertOrThrow(NAME_NODES, null, contentValuesOf(
-                        ID to way.id,
-                        NODE_ID to nodeId,
-                        INDEX to index
-                    ))
+            db.delete(NAME_NODES, "$ID IN ($idsString)")
+
+            db.insertMany(NAME_NODES,
+                arrayOf(ID, NODE_ID, INDEX),
+                ways.flatMap { way ->
+                    way.nodeIds.mapIndexed { index, nodeId ->
+                        arrayOf(way.id, nodeId, index)
+                    }
                 }
-                db.replaceOrThrow(NAME, null, contentValuesOf(
-                    ID to way.id,
-                    VERSION to way.version,
-                    TAGS to way.tags?.let { serializer.toBytes(HashMap<String,String>(it)) },
-                    LAST_UPDATE to currentTimeMillis()
-                ))
-            }
+            )
+
+            db.replaceMany(NAME,
+                arrayOf(ID, VERSION, TAGS, LAST_UPDATE),
+                ways.map { way ->
+                    arrayOf(
+                        way.id,
+                        way.version,
+                        way.tags?.let { serializer.toBytes(HashMap<String,String>(it)) },
+                        time
+                    )
+                }
+            )
         }
     }
 
@@ -63,12 +69,12 @@ class WayDao @Inject constructor(
         val idsString = ids.joinToString(",")
 
         val nodeIdsByWayId = mutableMapOf<Long, MutableList<Long>>()
-        db.query(NAME_NODES, selection = "$ID IN ($idsString)", orderBy = "$ID, $INDEX") { c ->
+        db.query(NAME_NODES, where = "$ID IN ($idsString)", orderBy = "$ID, $INDEX") { c ->
             val nodeIds = nodeIdsByWayId.getOrPut(c.getLong(ID)) { ArrayList() }
             nodeIds.add(c.getLong(NODE_ID))
         }
 
-        return db.query(NAME, selection = "$ID IN ($idsString)") { c ->
+        return db.query(NAME, where = "$ID IN ($idsString)") { c ->
             val id = c.getLong(ID)
             OsmWay(
                 id,
@@ -83,8 +89,8 @@ class WayDao @Inject constructor(
         if (ids.isEmpty()) return 0
         val idsString = ids.joinToString(",")
         return db.transaction {
-            db.delete(NAME_NODES, "$ID IN ($idsString)", null)
-            db.delete(NAME, "$ID IN ($idsString)", null)
+            db.delete(NAME_NODES, "$ID IN ($idsString)")
+            db.delete(NAME, "$ID IN ($idsString)")
         }
     }
 
@@ -92,11 +98,11 @@ class WayDao @Inject constructor(
         val ids = db.query(
             NAME_NODES,
             columns = arrayOf(ID),
-            selection = "$NODE_ID = $nodeId"
-        ) { it.getLong(0) }.toSet()
+            where = "$NODE_ID = $nodeId"
+        ) { it.getLong(ID) }.toSet()
         return getAll(ids)
     }
 
     fun getIdsOlderThan(timestamp: Long): List<Long> =
-        db.query(NAME, columns = arrayOf(ID), selection = "$LAST_UPDATE < $timestamp") { it.getLong(0) }
+        db.query(NAME, columns = arrayOf(ID), where = "$LAST_UPDATE < $timestamp") { it.getLong(ID) }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDao.kt
index 4b738e6f73d..50bda01045a 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestDao.kt
@@ -1,14 +1,11 @@
 package de.westnordost.streetcomplete.data.osm.osmquests
 
-import android.database.Cursor
-import android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.BoundingBox
 import de.westnordost.osmapi.map.data.Element
 import de.westnordost.osmapi.map.data.LatLon
 import de.westnordost.osmapi.map.data.OsmLatLon
-import de.westnordost.streetcomplete.data.WhereSelectionBuilder
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.Columns.QUEST_ID
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.Columns.QUEST_TYPE
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.Columns.ELEMENT_TYPE
@@ -16,15 +13,13 @@ import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.Columns.EL
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.Columns.LATITUDE
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.Columns.LONGITUDE
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestTable.NAME
-import de.westnordost.streetcomplete.ktx.*
 import javax.inject.Inject
 
 /** Persists OsmQuest objects, or more specifically, OsmQuestEntry objects */
-class OsmQuestDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+class OsmQuestDao @Inject constructor(private val db: Database) {
 
     fun add(quest: OsmQuestDaoEntry): Boolean {
-        val rowId = db.insertWithOnConflict(NAME, null, quest.toContentValues(), CONFLICT_IGNORE)
+        val rowId = db.insertOrIgnore(NAME, quest.toPairs())
         if (rowId != -1L) {
             quest.id = rowId
             return true
@@ -36,73 +31,70 @@ class OsmQuestDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
         db.queryOne(NAME, null, "$QUEST_ID = $id") { it.toOsmQuestEntry() }
 
     fun getAllInBBoxCount(bounds: BoundingBox): Int {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bounds)
-        return db.queryOne(NAME, arrayOf("COUNT(*)"), builder.where, builder.args) { it.getInt(0) } ?: 0
+        return db.queryOne(NAME,
+            columns = arrayOf("COUNT(*) as count"),
+            where = inBoundsSql(bounds),
+        ) { it.getInt("count") } ?: 0
     }
 
-    fun delete(id: Long): Boolean {
-        return db.delete(NAME, "$QUEST_ID = $id", null) == 1
-    }
-
-    fun addAll(quests: Collection<OsmQuestDaoEntry>): Int {
-        if (quests.isEmpty()) return 0
-        var addedCount = 0
-        db.transaction {
-            for (quest in quests) {
-                if (add(quest)) addedCount++
-            }
+    fun delete(id: Long): Boolean =
+        db.delete(NAME, "$QUEST_ID = $id") == 1
+
+    fun addAll(quests: List<OsmQuestDaoEntry>) {
+        if (quests.isEmpty()) return
+        val rowIds = db.insertOrIgnoreMany(NAME,
+            arrayOf(QUEST_ID, QUEST_TYPE, ELEMENT_TYPE, ELEMENT_ID, LATITUDE, LONGITUDE),
+            quests.map { arrayOf(
+                it.id,
+                it.questTypeName,
+                it.elementType.name,
+                it.elementId,
+                it.position.latitude,
+                it.position.longitude
+            ) }
+        )
+        check(rowIds.size == quests.size)
+        val rowIdsIt = rowIds.iterator()
+        for (quest in quests) {
+            quest.id = rowIdsIt.next().takeIf { it != -1L }
         }
-        return addedCount
     }
 
-    fun getAllForElement(elementType: Element.Type, elementId: Long): List<OsmQuestDaoEntry> {
-        return db.query(NAME,
-            selection = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?",
-            selectionArgs = arrayOf(elementType.name, elementId.toString())
+    fun getAllForElement(elementType: Element.Type, elementId: Long): List<OsmQuestDaoEntry> =
+        db.query(NAME,
+            where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ?",
+            args = arrayOf(elementType.name, elementId)
         ) { it.toOsmQuestEntry() }
-    }
 
     fun getAllInBBox(bounds: BoundingBox, questTypes: Collection<String>? = null): List<OsmQuestDaoEntry> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bounds)
+        var builder = inBoundsSql(bounds)
         if (questTypes != null) {
-            builder.appendQuestTypes(questTypes)
+            if (questTypes.isEmpty()) return emptyList()
+            val questTypesStr = questTypes.joinToString(",") { "'$it'" }
+            builder += " AND $QUEST_TYPE IN (${questTypesStr})"
         }
-        return db.query(NAME, null, builder.where, builder.args) { it.toOsmQuestEntry() }
+        return db.query(NAME, where = builder) { it.toOsmQuestEntry() }
     }
 
     fun getAllIdsInBBox(bounds: BoundingBox): List<Long> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bounds)
-        return db.query(NAME, arrayOf(QUEST_ID), builder.where, builder.args) { it.getLong(0) }
+        return db.query(NAME,
+            columns = arrayOf(QUEST_ID),
+            where = inBoundsSql(bounds),
+        ) { it.getLong(QUEST_ID) }
     }
 
     fun deleteAll(ids: Collection<Long>): Int {
         if (ids.isEmpty()) return 0
-        return db.delete(NAME, "$QUEST_ID IN (${ids.joinToString(",")})", null)
+        return db.delete(NAME, "$QUEST_ID IN (${ids.joinToString(",")})")
     }
 }
 
-private fun WhereSelectionBuilder.appendBounds(bbox: BoundingBox) {
-    add("($LATITUDE BETWEEN ? AND ?)",
-        bbox.minLatitude.toString(),
-        bbox.maxLatitude.toString()
-    )
-    add(
-        "($LONGITUDE BETWEEN ? AND ?)",
-        bbox.minLongitude.toString(),
-        bbox.maxLongitude.toString()
-    )
-}
-
-private fun WhereSelectionBuilder.appendQuestTypes(questTypes: Collection<String>) {
-    require(questTypes.isNotEmpty()) { "questTypes must not be empty" }
-    val names = questTypes.joinToString(",") { "'$it'" }
-    add("$QUEST_TYPE IN ($names)")
-}
+private fun inBoundsSql(bbox: BoundingBox): String = """
+        ($LATITUDE BETWEEN ${bbox.minLatitude} AND ${bbox.maxLatitude}) AND
+        ($LONGITUDE BETWEEN ${bbox.minLongitude} AND ${bbox.maxLongitude})
+    """.trimIndent()
 
-private fun Cursor.toOsmQuestEntry(): OsmQuestDaoEntry = BasicOsmQuestDaoEntry(
+private fun CursorPosition.toOsmQuestEntry(): OsmQuestDaoEntry = BasicOsmQuestDaoEntry(
     getLong(QUEST_ID),
     getString(QUEST_TYPE),
     Element.Type.valueOf(getString(ELEMENT_TYPE)),
@@ -110,7 +102,7 @@ private fun Cursor.toOsmQuestEntry(): OsmQuestDaoEntry = BasicOsmQuestDaoEntry(
     OsmLatLon(getDouble(LATITUDE), getDouble(LONGITUDE))
 )
 
-private fun OsmQuestDaoEntry.toContentValues() = contentValuesOf(
+private fun OsmQuestDaoEntry.toPairs() = listOf(
     QUEST_ID to id,
     QUEST_TYPE to questTypeName,
     ELEMENT_TYPE to elementType.name,
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDao.kt
index 66b0512bac8..e42c052bfab 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/osmquests/OsmQuestsHiddenDao.kt
@@ -1,35 +1,29 @@
 package de.westnordost.streetcomplete.data.osm.osmquests
 
-import android.database.Cursor
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.Element
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestsHiddenTable.Columns.ELEMENT_ID
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestsHiddenTable.Columns.ELEMENT_TYPE
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestsHiddenTable.Columns.QUEST_TYPE
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestsHiddenTable.Columns.TIMESTAMP
 import de.westnordost.streetcomplete.data.osm.osmquests.OsmQuestsHiddenTable.NAME
-import de.westnordost.streetcomplete.ktx.getLong
-import de.westnordost.streetcomplete.ktx.getString
-import de.westnordost.streetcomplete.ktx.queryOne
-import de.westnordost.streetcomplete.ktx.query
 import java.lang.System.currentTimeMillis
 import javax.inject.Inject
 
 /** Persists which osm quests should be hidden (because the user selected so) */
-class OsmQuestsHiddenDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+class OsmQuestsHiddenDao @Inject constructor(private val db: Database) {
 
     fun add(osmQuestKey: OsmQuestKey) {
-        db.insert(NAME, null, osmQuestKey.toContentValues())
+        db.insert(NAME, osmQuestKey.toPairs())
     }
 
     fun contains(osmQuestKey: OsmQuestKey): Boolean =
         db.queryOne(NAME,
-            selection = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ? AND $QUEST_TYPE = ?",
-            selectionArgs = arrayOf(
-                osmQuestKey.elementType.toString(),
-                osmQuestKey.elementId.toString(),
+            where = "$ELEMENT_TYPE = ? AND $ELEMENT_ID = ? AND $QUEST_TYPE = ?",
+            args = arrayOf(
+                osmQuestKey.elementType.name,
+                osmQuestKey.elementId,
                 osmQuestKey.questTypeName
             )
         ) { true } ?: false
@@ -38,17 +32,17 @@ class OsmQuestsHiddenDao @Inject constructor(private val dbHelper: SQLiteOpenHel
         db.query(NAME) { it.toOsmQuestKey() }
 
     fun deleteAll(): Int =
-        db.delete(NAME, null, null)
+        db.delete(NAME)
 }
 
-private fun OsmQuestKey.toContentValues() = contentValuesOf(
+private fun OsmQuestKey.toPairs() = listOf(
     ELEMENT_TYPE to elementType.name,
     ELEMENT_ID to elementId,
     QUEST_TYPE to questTypeName,
     TIMESTAMP to currentTimeMillis()
 )
 
-private fun Cursor.toOsmQuestKey() = OsmQuestKey(
+private fun CursorPosition.toOsmQuestKey() = OsmQuestKey(
     Element.Type.valueOf(getString(ELEMENT_TYPE)),
     getLong(ELEMENT_ID),
     getString(QUEST_TYPE)
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/NoteDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/NoteDao.kt
index a58ae1c3542..ed68ff2b2c1 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/NoteDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/NoteDao.kt
@@ -1,9 +1,6 @@
 package de.westnordost.streetcomplete.data.osmnotes
 
 
-import android.database.Cursor
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
 import de.westnordost.osmapi.map.data.BoundingBox
 import de.westnordost.osmapi.map.data.LatLon
 
@@ -16,7 +13,8 @@ import de.westnordost.streetcomplete.util.Serializer
 import de.westnordost.osmapi.map.data.OsmLatLon
 import de.westnordost.osmapi.notes.Note
 import de.westnordost.osmapi.notes.NoteComment
-import de.westnordost.streetcomplete.data.WhereSelectionBuilder
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osmnotes.NoteTable.Columns.CLOSED
 import de.westnordost.streetcomplete.data.osmnotes.NoteTable.Columns.COMMENTS
 import de.westnordost.streetcomplete.data.osmnotes.NoteTable.Columns.CREATED
@@ -27,63 +25,64 @@ import de.westnordost.streetcomplete.data.osmnotes.NoteTable.Columns.LONGITUDE
 import de.westnordost.streetcomplete.data.osmnotes.NoteTable.Columns.STATUS
 import de.westnordost.streetcomplete.data.osmnotes.NoteTable.NAME
 import de.westnordost.streetcomplete.ktx.*
+import java.lang.System.currentTimeMillis
 
 /** Stores OSM notes */
 class NoteDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val serializer: Serializer
 ) {
-    private val db get() = dbHelper.writableDatabase
-
     fun put(note: Note) {
-        db.replaceOrThrow(NAME, null, note.toContentValues())
+        db.replace(NAME, note.toPairs())
     }
 
-    fun get(id: Long): Note? {
-        return db.queryOne(NAME, null, "$ID = $id") { it.toNote() }
-    }
+    fun get(id: Long): Note? =
+        db.queryOne(NAME, where = "$ID = $id") { it.toNote() }
 
-    fun delete(id: Long): Boolean {
-        return db.delete(NAME, "$ID = $id", null) == 1
-    }
+    fun delete(id: Long): Boolean =
+        db.delete(NAME, "$ID = $id") == 1
 
     fun putAll(notes: Collection<Note>) {
         if (notes.isEmpty()) return
-        db.transaction {
-            for (note in notes) {
-                put(note)
-            }
-        }
-    }
 
-    fun getAll(bbox: BoundingBox): List<Note> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bbox)
-        return db.query(NAME, null, builder.where, builder.args) { it.toNote() }
+        db.replaceMany(NAME,
+            arrayOf(ID, LATITUDE, LONGITUDE, STATUS, CREATED, CLOSED, COMMENTS, LAST_UPDATE),
+            notes.map { arrayOf(
+                it.id,
+                it.position.latitude,
+                it.position.longitude,
+                it.status.name,
+                it.dateCreated.time,
+                it.dateClosed?.time,
+                serializer.toBytes(ArrayList(it.comments)),
+                currentTimeMillis()
+            ) }
+        )
     }
 
-    fun getAllPositions(bbox: BoundingBox): List<LatLon> {
-        val cols = arrayOf(LATITUDE, LONGITUDE)
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bbox)
-        return db.query(NAME, cols, builder.where, builder.args) { OsmLatLon(it.getDouble(0), it.getDouble(1)) }
-    }
+    fun getAll(bbox: BoundingBox): List<Note> =
+        db.query(NAME, where = inBoundsSql(bbox)) { it.toNote() }
+
+    fun getAllPositions(bbox: BoundingBox): List<LatLon> =
+        db.query(NAME,
+            columns = arrayOf(LATITUDE, LONGITUDE),
+            where = inBoundsSql(bbox),
+        ) { OsmLatLon(it.getDouble(LATITUDE), it.getDouble(LONGITUDE)) }
 
     fun getAll(ids: Collection<Long>): List<Note> {
         if (ids.isEmpty()) return emptyList()
-        return db.query(NAME, null, "$ID IN (${ids.joinToString(",")})") { it.toNote() }
+        return db.query(NAME, where = "$ID IN (${ids.joinToString(",")})") { it.toNote() }
     }
 
-    fun getAllIdsOlderThan(timestamp: Long): List<Long> {
-        return db.query(NAME, arrayOf(ID), "$LAST_UPDATE < $timestamp", null) { it.getLong(0) }
-    }
+    fun getAllIdsOlderThan(timestamp: Long): List<Long> =
+        db.query(NAME, arrayOf(ID), "$LAST_UPDATE < $timestamp") { it.getLong(ID) }
 
     fun deleteAll(ids: Collection<Long>): Int {
         if (ids.isEmpty()) return 0
-        return db.delete(NAME, "$ID IN (${ids.joinToString(",")})", null)
+        return db.delete(NAME, "$ID IN (${ids.joinToString(",")})")
     }
 
-    private fun Note.toContentValues() = contentValuesOf(
+    private fun Note.toPairs() = listOf(
         ID to id,
         LATITUDE to position.latitude,
         LONGITUDE to position.longitude,
@@ -91,10 +90,10 @@ class NoteDao @Inject constructor(
         CREATED to dateCreated.time,
         CLOSED to dateClosed?.time,
         COMMENTS to serializer.toBytes(ArrayList(comments)),
-        LAST_UPDATE to Date().time
+        LAST_UPDATE to currentTimeMillis()
     )
 
-    private fun Cursor.toNote() = Note().also { n ->
+    private fun CursorPosition.toNote() = Note().also { n ->
         n.id = getLong(ID)
         n.position = OsmLatLon(getDouble(LATITUDE), getDouble(LONGITUDE))
         n.dateCreated = Date(getLong(CREATED))
@@ -103,17 +102,9 @@ class NoteDao @Inject constructor(
         n.comments = serializer.toObject<ArrayList<NoteComment>>(getBlob(COMMENTS))
     }
 
-}
+    private fun inBoundsSql(bbox: BoundingBox): String = """
+        ($LATITUDE BETWEEN ${bbox.minLatitude} AND ${bbox.maxLatitude}) AND
+        ($LONGITUDE BETWEEN ${bbox.minLongitude} AND ${bbox.maxLongitude})
+    """.trimIndent()
 
-private fun WhereSelectionBuilder.appendBounds(bbox: BoundingBox) {
-    add("($LATITUDE BETWEEN ? AND ?)",
-        bbox.minLatitude.toString(),
-        bbox.maxLatitude.toString()
-    )
-    add(
-        "($LONGITUDE BETWEEN ? AND ?)",
-        bbox.minLongitude.toString(),
-        bbox.maxLongitude.toString()
-    )
 }
-
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDao.kt
index 435dbd14855..c5d1909119b 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/edits/NoteEditsDao.kt
@@ -1,12 +1,11 @@
 package de.westnordost.streetcomplete.data.osmnotes.edits
 
-import android.database.Cursor
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+
 import de.westnordost.osmapi.map.data.BoundingBox
 import de.westnordost.osmapi.map.data.LatLon
 import de.westnordost.osmapi.map.data.OsmLatLon
-import de.westnordost.streetcomplete.data.WhereSelectionBuilder
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osmnotes.edits.NoteEditsTable.Columns.CREATED_TIMESTAMP
 import de.westnordost.streetcomplete.util.Serializer
 import javax.inject.Inject
@@ -23,102 +22,99 @@ import de.westnordost.streetcomplete.data.osmnotes.edits.NoteEditsTable.NAME
 import de.westnordost.streetcomplete.ktx.*
 
 class NoteEditsDao @Inject constructor(
-    private val dbHelper: SQLiteOpenHelper,
+    private val db: Database,
     private val serializer: Serializer
-){
-    private val db get() = dbHelper.writableDatabase
-
-    fun add(edit: NoteEdit): Boolean {
+) {
+    fun add(edit: NoteEdit): Boolean =
         db.transaction {
-            val rowId = db.insert(NAME, null, edit.toContentValues())
-            if (rowId == -1L) return false
+            val rowId = db.insert(NAME, edit.toPairs())
+            if (rowId == -1L) return@transaction false
             edit.id = rowId
             // if the note id is not set, set it to the negative of the row id
             if (edit.noteId == 0L) {
-                db.update(NAME, contentValuesOf(NOTE_ID to -rowId), "$ID = $rowId", null)
+                db.update(NAME, listOf(NOTE_ID to -rowId), "$ID = $rowId")
                 edit.noteId = -rowId
             }
+            return@transaction true
         }
-        return true
-    }
 
     fun get(id: Long): NoteEdit? =
-        db.queryOne(NAME, selection = "$ID = $id") { it.toNoteEdit() }
+        db.queryOne(NAME, where = "$ID = $id") { it.toNoteEdit() }
 
     fun getAll(): List<NoteEdit> =
         db.query(NAME, orderBy = "$IS_SYNCED, $CREATED_TIMESTAMP") { it.toNoteEdit() }
 
     fun getOldestUnsynced(): NoteEdit? =
-        db.queryOne(NAME, selection = "$IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toNoteEdit() }
+        db.queryOne(NAME,
+            where = "$IS_SYNCED = 0",
+            orderBy = CREATED_TIMESTAMP
+        ) { it.toNoteEdit() }
 
     fun getUnsyncedCount(): Int =
-        db.queryOne(NAME, arrayOf("COUNT(*)"), "$IS_SYNCED = 0") { it.getInt(0) } ?: 0
+        db.queryOne(NAME,
+            columns = arrayOf("COUNT(*) as count"),
+            where = "$IS_SYNCED = 0"
+        ) { it.getInt("count") } ?: 0
 
     fun getAllUnsynced(): List<NoteEdit> =
-        db.query(NAME, selection = "$IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toNoteEdit() }
+        db.query(NAME,
+            where = "$IS_SYNCED = 0",
+            orderBy = CREATED_TIMESTAMP
+        ) { it.toNoteEdit() }
 
     fun getAllUnsyncedForNote(noteId: Long): List<NoteEdit> =
-        db.query(NAME, selection = "$NOTE_ID = $noteId AND $IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toNoteEdit() }
+        db.query(NAME,
+            where = "$NOTE_ID = $noteId AND $IS_SYNCED = 0",
+            orderBy = CREATED_TIMESTAMP
+        ) { it.toNoteEdit() }
 
     fun getAllUnsyncedForNotes(noteIds: Collection<Long>): List<NoteEdit> {
         val notes = noteIds.joinToString(",")
-        return db.query(NAME, selection = "$NOTE_ID IN ($notes) AND $IS_SYNCED = 0", orderBy = CREATED_TIMESTAMP) { it.toNoteEdit() }
+        return db.query(NAME,
+            where = "$NOTE_ID IN ($notes) AND $IS_SYNCED = 0",
+            orderBy = CREATED_TIMESTAMP
+        ) { it.toNoteEdit() }
     }
 
     fun getAllUnsynced(bbox: BoundingBox): List<NoteEdit> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bbox)
-        builder.add("$IS_SYNCED = 0")
         return db.query(NAME,
-            selection = builder.where,
-            selectionArgs = builder.args,
+            where = "$IS_SYNCED = 0 AND " + inBoundsSql(bbox),
             orderBy = CREATED_TIMESTAMP
         ) { it.toNoteEdit() }
     }
 
     fun getAllUnsyncedPositions(bbox: BoundingBox): List<LatLon> {
-        val builder = WhereSelectionBuilder()
-        builder.appendBounds(bbox)
-        builder.add("$IS_SYNCED = 0")
         return db.query(NAME,
             columns = arrayOf(LATITUDE, LONGITUDE),
-            selection = builder.where,
-            selectionArgs = builder.args,
+            where = "$IS_SYNCED = 0 AND " + inBoundsSql(bbox),
             orderBy = CREATED_TIMESTAMP
-        ) { OsmLatLon(it.getDouble(0), it.getDouble(1)) }
+        ) { OsmLatLon(it.getDouble(LATITUDE), it.getDouble(LONGITUDE)) }
     }
 
     fun markSynced(id: Long): Boolean =
-        db.update(NAME, contentValuesOf(IS_SYNCED to 1), "$ID = $id", null) == 1
+        db.update(NAME, listOf(IS_SYNCED to 1), "$ID = $id", null) == 1
 
     fun delete(id: Long): Boolean =
-        db.delete(NAME, "$ID = $id", null) == 1
+        db.delete(NAME, "$ID = $id") == 1
 
     fun deleteSyncedOlderThan(timestamp: Long): Int =
-        db.delete(NAME, "$IS_SYNCED = 1 AND $CREATED_TIMESTAMP < $timestamp", null)
+        db.delete(NAME, "$IS_SYNCED = 1 AND $CREATED_TIMESTAMP < $timestamp")
 
     fun updateNoteId(oldNoteId: Long, newNoteId: Long): Int =
-        db.update(NAME, contentValuesOf(NOTE_ID to newNoteId), "$NOTE_ID = $oldNoteId", null)
+        db.update(NAME, listOf(NOTE_ID to newNoteId), "$NOTE_ID = $oldNoteId")
 
     fun getOldestNeedingImagesActivation(): NoteEdit? =
-        db.queryOne(NAME, selection = "$IS_SYNCED = 1 AND $IMAGES_NEED_ACTIVATION = 1", orderBy = CREATED_TIMESTAMP) { it.toNoteEdit() }
+        db.queryOne(NAME, where = "$IS_SYNCED = 1 AND $IMAGES_NEED_ACTIVATION = 1", orderBy = CREATED_TIMESTAMP) { it.toNoteEdit() }
 
     fun markImagesActivated(id: Long): Boolean =
-        db.update(NAME, contentValuesOf(IMAGES_NEED_ACTIVATION to 0), "$ID = $id", null) == 1
-
-    private fun WhereSelectionBuilder.appendBounds(bbox: BoundingBox) {
-        add("($LATITUDE BETWEEN ? AND ?)",
-            bbox.minLatitude.toString(),
-            bbox.maxLatitude.toString()
-        )
-        add(
-            "($LONGITUDE BETWEEN ? AND ?)",
-            bbox.minLongitude.toString(),
-            bbox.maxLongitude.toString()
-        )
-    }
+        db.update(NAME, listOf(IMAGES_NEED_ACTIVATION to 0), "$ID = $id") == 1
+
+    private fun inBoundsSql(bbox: BoundingBox): String = """
+        ($LATITUDE BETWEEN ${bbox.minLatitude} AND ${bbox.maxLatitude}) AND
+        ($LONGITUDE BETWEEN ${bbox.minLongitude} AND ${bbox.maxLongitude})
+    """.trimIndent()
 
-    private fun NoteEdit.toContentValues() = contentValuesOf(
+    private fun NoteEdit.toPairs() = listOf(
         NOTE_ID to noteId,
         LATITUDE to position.latitude,
         LONGITUDE to position.longitude,
@@ -130,7 +126,7 @@ class NoteEditsDao @Inject constructor(
         TYPE to action.name
     )
 
-    private fun Cursor.toNoteEdit() = NoteEdit(
+    private fun CursorPosition.toNoteEdit() = NoteEdit(
         getLong(ID),
         getLong(NOTE_ID),
         OsmLatLon(getDouble(LATITUDE), getDouble(LONGITUDE)),
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDao.kt
index abbcb9a1628..a31eed63395 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/notequests/NoteQuestsHiddenDao.kt
@@ -1,32 +1,28 @@
 package de.westnordost.streetcomplete.data.osmnotes.notequests
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.osmnotes.notequests.NoteQuestsHiddenTable.Columns.NOTE_ID
 import de.westnordost.streetcomplete.data.osmnotes.notequests.NoteQuestsHiddenTable.Columns.TIMESTAMP
 import de.westnordost.streetcomplete.data.osmnotes.notequests.NoteQuestsHiddenTable.NAME
-import de.westnordost.streetcomplete.ktx.queryOne
-import de.westnordost.streetcomplete.ktx.query
 import java.lang.System.currentTimeMillis
 import javax.inject.Inject
 
 /** Persists which note ids should be hidden (because the user selected so) in the note quest */
-class NoteQuestsHiddenDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+class NoteQuestsHiddenDao @Inject constructor(private val db: Database) {
 
     fun add(noteId: Long) {
-        db.insert(NAME, null, contentValuesOf(
+        db.insert(NAME, listOf(
             NOTE_ID to noteId,
             TIMESTAMP to currentTimeMillis()
         ))
     }
 
     fun contains(noteId: Long): Boolean =
-        db.queryOne(NAME, selection = "$NOTE_ID = $noteId") { true } ?: false
+        db.queryOne(NAME, where = "$NOTE_ID = $noteId") { true } ?: false
 
     fun getAll(): List<Long> =
-        db.query(NAME) { it.getLong(0) }
+        db.query(NAME) { it.getLong(NOTE_ID) }
 
     fun deleteAll(): Int =
-        db.delete(NAME, null, null)
+        db.delete(NAME)
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDao.kt
index 4f9214e2560..73f1c6b4662 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/user/CountryStatisticsDao.kt
@@ -1,8 +1,7 @@
 package de.westnordost.streetcomplete.data.user
 
-import android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.CursorPosition
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.user.CountryStatisticsTable.Columns.COUNTRY_CODE
 import de.westnordost.streetcomplete.data.user.CountryStatisticsTable.Columns.RANK
 import de.westnordost.streetcomplete.data.user.CountryStatisticsTable.Columns.SUCCEEDED
@@ -10,54 +9,53 @@ import de.westnordost.streetcomplete.data.user.CountryStatisticsTable.NAME
 
 import javax.inject.Inject
 
-import de.westnordost.streetcomplete.ktx.*
 import javax.inject.Singleton
 
 /** Stores how many quests the user solved in which country */
-@Singleton class CountryStatisticsDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+@Singleton class CountryStatisticsDao @Inject constructor(private val db: Database) {
 
-    fun getCountryWithBiggestSolvedCount(): CountryStatistics? {
-        return db.queryOne(NAME, orderBy = "$SUCCEEDED DESC") {
-            CountryStatistics(it.getString(COUNTRY_CODE), it.getInt(SUCCEEDED), it.getIntOrNull(RANK))
-        }
-    }
+    fun getCountryWithBiggestSolvedCount(): CountryStatistics? =
+        db.queryOne(NAME, orderBy = "$SUCCEEDED DESC") { it.toCountryStatistics() }
 
-    fun getAll(): List<CountryStatistics> {
-        return db.query(NAME) {
-            CountryStatistics(it.getString(COUNTRY_CODE), it.getInt(SUCCEEDED), it.getIntOrNull(RANK))
-        }
-    }
+    fun getAll(): List<CountryStatistics> =
+        db.query(NAME) { it.toCountryStatistics() }
 
     fun clear() {
-        db.delete(NAME, null, null)
+        db.delete(NAME)
     }
 
     fun replaceAll(countriesStatistics: Collection<CountryStatistics>) {
         db.transaction {
-            db.delete(NAME, null, null)
-            for (statistics in countriesStatistics) {
-                db.insert(NAME, null, contentValuesOf(
-                    COUNTRY_CODE to statistics.countryCode,
-                    SUCCEEDED to statistics.solvedCount,
-                    RANK to statistics.rank
-                ))
+            db.delete(NAME)
+            if (countriesStatistics.isNotEmpty()) {
+                db.replaceMany(NAME,
+                    arrayOf(COUNTRY_CODE, SUCCEEDED, RANK),
+                    countriesStatistics.map { arrayOf(it.countryCode, it.solvedCount, it.rank) }
+                )
             }
         }
     }
 
     fun addOne(countryCode: String) {
-        // first ensure the row exists
-        db.insertWithOnConflict(NAME, null, contentValuesOf(
-            COUNTRY_CODE to countryCode,
-            SUCCEEDED to 0
-        ), CONFLICT_IGNORE)
-
-        // then increase by one
-        db.execSQL("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED + 1 WHERE $COUNTRY_CODE = ?", arrayOf(countryCode))
+        db.transaction {
+            // first ensure the row exists
+            db.insertOrIgnore(NAME, listOf(
+                COUNTRY_CODE to countryCode,
+                SUCCEEDED to 0
+            ))
+
+            // then increase by one
+            db.exec("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED + 1 WHERE $COUNTRY_CODE = ?", arrayOf(countryCode))
+        }
     }
 
     fun subtractOne(countryCode: String) {
-        db.execSQL("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED - 1 WHERE $COUNTRY_CODE = ?", arrayOf(countryCode))
+        db.exec("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED - 1 WHERE $COUNTRY_CODE = ?", arrayOf(countryCode))
     }
-}
\ No newline at end of file
+}
+
+fun CursorPosition.toCountryStatistics() = CountryStatistics(
+    getString(COUNTRY_CODE),
+    getInt(SUCCEEDED),
+    getIntOrNull(RANK)
+)
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDao.kt
index 82dd9e87dd3..77145407754 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/user/QuestStatisticsDao.kt
@@ -1,21 +1,17 @@
 package de.westnordost.streetcomplete.data.user
 
-import android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 
 import javax.inject.Inject
 
 import de.westnordost.streetcomplete.data.user.QuestStatisticsTable.Columns.QUEST_TYPE
 import de.westnordost.streetcomplete.data.user.QuestStatisticsTable.Columns.SUCCEEDED
 import de.westnordost.streetcomplete.data.user.QuestStatisticsTable.NAME
-import de.westnordost.streetcomplete.ktx.*
 import java.util.concurrent.CopyOnWriteArrayList
 import javax.inject.Singleton
 
 /** Stores how many quests of which quest types the user solved */
-@Singleton class QuestStatisticsDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+@Singleton class QuestStatisticsDao @Inject constructor(private val db: Database) {
 
     interface Listener {
         fun onAddedOne(questType: String)
@@ -25,63 +21,64 @@ import javax.inject.Singleton
 
     private val listeners: MutableList<Listener> = CopyOnWriteArrayList()
 
-    fun getTotalAmount(): Int {
-        return db.queryOne(NAME, arrayOf("total($SUCCEEDED)")) { it.getInt(0) } ?: 0
-    }
+    fun getTotalAmount(): Int =
+        db.queryOne(NAME, arrayOf("total($SUCCEEDED) as count")) { it.getInt("count") } ?: 0
 
-    fun getAll(): Map<String, Int> {
-        return db.query(NAME) {
-            it.getString(QUEST_TYPE) to it.getInt(SUCCEEDED)
-        }.toMap()
-    }
+    fun getAll(): Map<String, Int> =
+        db.query(NAME) { it.getString(QUEST_TYPE) to it.getInt(SUCCEEDED) }.toMap()
 
     fun clear() {
-        db.delete(NAME, null, null)
+        db.delete(NAME)
         listeners.forEach { it.onReplacedAll() }
     }
 
     fun replaceAll(amounts: Map<String, Int>) {
         db.transaction {
-            db.delete(NAME, null, null)
-            for ((key, value) in amounts) {
-                db.insert(NAME, null, contentValuesOf(
-                    QUEST_TYPE to key,
-                    SUCCEEDED to value
-                ))
+            db.delete(NAME)
+            if (amounts.isNotEmpty()) {
+                db.replaceMany(NAME,
+                    arrayOf(QUEST_TYPE, SUCCEEDED),
+                    amounts.map { arrayOf(it.key, it.value) }
+                )
             }
         }
         listeners.forEach { it.onReplacedAll() }
     }
 
     fun addOne(questType: String) {
-        // first ensure the row exists
-        db.insertWithOnConflict(NAME, null, contentValuesOf(
-            QUEST_TYPE to questType,
-            SUCCEEDED to 0
-        ), CONFLICT_IGNORE)
-
-        // then increase by one
-        db.execSQL("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED + 1 WHERE $QUEST_TYPE = ?", arrayOf(questType))
+        db.transaction {
+            // first ensure the row exists
+            db.insertOrIgnore(NAME, listOf(
+                QUEST_TYPE to questType,
+                SUCCEEDED to 0
+            ))
+
+            // then increase by one
+            db.exec("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED + 1 WHERE $QUEST_TYPE = ?", arrayOf(questType))
+        }
+
         listeners.forEach { it.onAddedOne(questType) }
     }
 
     fun subtractOne(questType: String) {
-        db.execSQL("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED - 1 WHERE $QUEST_TYPE = ?", arrayOf(questType))
+        db.exec("UPDATE $NAME SET $SUCCEEDED = $SUCCEEDED - 1 WHERE $QUEST_TYPE = ?", arrayOf(questType))
         listeners.forEach { it.onSubtractedOne(questType) }
     }
 
-    fun getAmount(questType: String): Int {
-        return db.queryOne(NAME, arrayOf(SUCCEEDED), "$QUEST_TYPE = ?", arrayOf(questType)) {
-            it.getInt(0)
-        } ?: 0
-    }
+    fun getAmount(questType: String): Int =
+        db.queryOne(NAME,
+            columns = arrayOf(SUCCEEDED),
+            where = "$QUEST_TYPE = ?",
+            args = arrayOf(questType)
+        ) { it.getInt(SUCCEEDED) } ?: 0
 
     fun getAmount(questTypes: List<String>): Int {
         val questionMarks = Array(questTypes.size) { "?" }.joinToString(",")
-        val query = "$QUEST_TYPE in ($questionMarks)"
-        return db.queryOne(NAME, arrayOf("total($SUCCEEDED)"), query, questTypes.toTypedArray()) {
-            it.getInt(0)
-        } ?: 0
+        return db.queryOne(NAME,
+            columns = arrayOf("total($SUCCEEDED) as count"),
+            where = "$QUEST_TYPE in ($questionMarks)",
+            args = questTypes.toTypedArray()
+        ) { it.getInt("count") } ?: 0
     }
 
     fun addListener(listener: Listener) {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDao.kt
index 7c2c722dce1..b186ab86a16 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserAchievementsDao.kt
@@ -1,34 +1,26 @@
 package de.westnordost.streetcomplete.data.user.achievements
 
-import android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.user.achievements.UserAchievementsTable.Columns.ACHIEVEMENT
 import de.westnordost.streetcomplete.data.user.achievements.UserAchievementsTable.Columns.LEVEL
 import de.westnordost.streetcomplete.data.user.achievements.UserAchievementsTable.NAME
 
 import javax.inject.Inject
 
-import de.westnordost.streetcomplete.ktx.*
-
 /** Stores which achievement ids have been unlocked by the user and at which level */
-class UserAchievementsDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+class UserAchievementsDao @Inject constructor(private val db: Database) {
 
-    fun getAll(): Map<String, Int> {
-        return db.query(NAME) {
-            it.getString(ACHIEVEMENT) to it.getInt(LEVEL)
-        }.toMap()
-    }
+    fun getAll(): Map<String, Int> =
+        db.query(NAME) { it.getString(ACHIEVEMENT) to it.getInt(LEVEL) }.toMap()
 
     fun clear() {
-        db.delete(NAME, null, null)
+        db.delete(NAME)
     }
 
     fun put(achievement: String, level: Int) {
-        db.insertWithOnConflict(NAME, null, contentValuesOf(
+        db.replace(NAME, listOf(
             ACHIEVEMENT to achievement,
             LEVEL to level
-        ), CONFLICT_REPLACE)
+        ))
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDao.kt
index e4ed6163fac..03a7b48f049 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/user/achievements/UserLinksDao.kt
@@ -1,39 +1,30 @@
 package de.westnordost.streetcomplete.data.user.achievements
 
-import android.database.sqlite.SQLiteDatabase.CONFLICT_IGNORE
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 import de.westnordost.streetcomplete.data.user.achievements.UserLinksTable.Columns.LINK
 import de.westnordost.streetcomplete.data.user.achievements.UserLinksTable.NAME
 
 import javax.inject.Inject
 
-import de.westnordost.streetcomplete.ktx.*
-
 /** Stores which link ids have been unlocked by the user */
-class UserLinksDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-    private val db get() = dbHelper.writableDatabase
+class UserLinksDao @Inject constructor(private val db: Database) {
 
-    fun getAll(): List<String> {
-        return db.query(NAME) { it.getString(LINK) }
-    }
+    fun getAll(): List<String> =
+        db.query(NAME) { it.getString(LINK) }
 
     fun clear() {
-        db.delete(NAME, null, null)
+        db.delete(NAME)
     }
 
     fun add(link: String) {
-        db.insertWithOnConflict(NAME, null, contentValuesOf(LINK to link), CONFLICT_IGNORE)
+        db.insertOrIgnore(NAME, listOf(LINK to link))
     }
 
-    fun addAll(links: List<String>): Int {
-        var addedRows = 0
-        db.transaction {
-            for (link in links) {
-                val rowId = db.insertWithOnConflict(NAME, null, contentValuesOf(LINK to link), CONFLICT_IGNORE)
-                if (rowId != -1L) addedRows++
-            }
-        }
-        return addedRows
+    fun addAll(links: List<String>) {
+        if (links.isEmpty()) return
+        db.insertOrIgnoreMany(NAME,
+            arrayOf(LINK),
+            links.map { arrayOf(it) }
+        )
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDao.kt
index 811b0ee4a6b..6cc3c056d37 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/visiblequests/VisibleQuestTypeDao.kt
@@ -1,22 +1,15 @@
 package de.westnordost.streetcomplete.data.visiblequests
 
-import android.database.sqlite.SQLiteOpenHelper
-import androidx.core.content.contentValuesOf
+import de.westnordost.streetcomplete.data.Database
 
 import javax.inject.Inject
 
 import de.westnordost.streetcomplete.data.visiblequests.VisibleQuestTypeTable.Columns.QUEST_TYPE
 import de.westnordost.streetcomplete.data.visiblequests.VisibleQuestTypeTable.Columns.VISIBILITY
 import de.westnordost.streetcomplete.data.visiblequests.VisibleQuestTypeTable.NAME
-import de.westnordost.streetcomplete.ktx.getInt
-import de.westnordost.streetcomplete.ktx.getString
-import de.westnordost.streetcomplete.ktx.query
-import de.westnordost.streetcomplete.ktx.queryOne
 
 /** Stores which quest types are visible by user selection and which are not */
-class VisibleQuestTypeDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
-
-    private val db get() = dbHelper.writableDatabase
+class VisibleQuestTypeDao @Inject constructor(private val db: Database) {
 
     fun getAll(): MutableMap<String, Boolean> {
         val result = mutableMapOf<String,Boolean>()
@@ -29,19 +22,20 @@ class VisibleQuestTypeDao @Inject constructor(private val dbHelper: SQLiteOpenHe
     }
 
     fun put(questTypeName: String, visible: Boolean) {
-        db.replaceOrThrow(NAME, null, contentValuesOf(
+        db.replace(NAME, listOf(
             QUEST_TYPE to questTypeName,
             VISIBILITY to if (visible) 1 else 0
         ))
     }
 
-    fun get(questTypeName: String): Boolean {
-        return db.queryOne(NAME, arrayOf(VISIBILITY), "$QUEST_TYPE = ?", arrayOf(questTypeName)) {
-            it.getInt(0) != 0
-        } ?: true
-    }
+    fun get(questTypeName: String): Boolean =
+        db.queryOne(NAME,
+            columns = arrayOf(VISIBILITY),
+            where = "$QUEST_TYPE = ?",
+            args = arrayOf(questTypeName)
+        ) { it.getInt(VISIBILITY) != 0 } ?: true
 
     fun clear() {
-        db.delete(NAME, null, null)
+        db.delete(NAME)
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt b/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt
deleted file mode 100644
index 37f8c14eeeb..00000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt
+++ /dev/null
@@ -1,78 +0,0 @@
-package de.westnordost.streetcomplete.ktx
-
-import android.database.Cursor
-import android.database.sqlite.SQLiteDatabase
-import de.westnordost.streetcomplete.data.WhereSelectionBuilder
-
-/**
- * Run [body] in a transaction marking it as successful if it completes without exception.
- */
-inline fun <T> SQLiteDatabase.transaction(body: SQLiteDatabase.() -> T): T {
-    beginTransaction()
-    try {
-        val result = body()
-        setTransactionSuccessful()
-        return result
-    } finally {
-        endTransaction()
-    }
-}
-
-
-fun <R> SQLiteDatabase.query(
-    table: String,
-    columns: Array<String>? = null,
-    selection: String? = null,
-    selectionArgs: Array<String>? = null,
-    groupBy: String? = null,
-    having: String? = null,
-    orderBy: String? = null,
-    transform: (Cursor) -> R
-): List<R> = query(table, columns, selection, selectionArgs, groupBy, having, orderBy, null).use { cursor ->
-    val result = ArrayList<R>(cursor.count)
-    cursor.moveToFirst()
-    while(!cursor.isAfterLast) {
-        result.add(transform(cursor))
-        cursor.moveToNext()
-    }
-    result
-}
-
-fun <R> SQLiteDatabase.queryOne(
-    table: String,
-    columns: Array<String>? = null,
-    selection: String? = null,
-    selectionArgs: Array<String>? = null,
-    orderBy: String? = null,
-    transform: (Cursor) -> R?
-): R? = query(table, columns, selection, selectionArgs, null, null, orderBy, "1").use { cursor ->
-    if (cursor.moveToFirst()) transform(cursor) else null
-}
-
-fun <R> SQLiteDatabase.query(
-    table: String,
-    columns: Array<String>? = null,
-    selection: WhereSelectionBuilder? = null,
-    groupBy: String? = null,
-    having: String? = null,
-    orderBy: String? = null,
-    transform: (Cursor) -> R
-): List<R> = query(table, columns, selection?.where, selection?.args, groupBy, having, orderBy, transform)
-
-
-fun <R> SQLiteDatabase.queryOne(
-    table: String,
-    columns: Array<String>? = null,
-    selection: WhereSelectionBuilder? = null,
-    orderBy: String? = null,
-    transform: (Cursor) -> R
-): R? = queryOne(table, columns, selection?.where, selection?.args, orderBy, transform)
-
-
-fun SQLiteDatabase.hasColumn(tableName: String, columnName: String): Boolean {
-    return queryOne(
-        "pragma_table_info('$tableName')",
-        arrayOf("name"),
-        "name = ?",
-        arrayOf(columnName)) { it.getString(0) } != null
-}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/oneway_suspects/data/WayTrafficFlowDao.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/oneway_suspects/data/WayTrafficFlowDao.kt
index cd80e0afd46..48a968bcb42 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/oneway_suspects/data/WayTrafficFlowDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/oneway_suspects/data/WayTrafficFlowDao.kt
@@ -1,7 +1,5 @@
 package de.westnordost.streetcomplete.quests.oneway_suspects.data
 
-import android.database.sqlite.SQLiteOpenHelper
-
 import javax.inject.Inject
 
 import de.westnordost.streetcomplete.data.osm.mapdata.WayTables
@@ -9,43 +7,29 @@ import de.westnordost.streetcomplete.quests.oneway_suspects.data.WayTrafficFlowT
 import de.westnordost.streetcomplete.quests.oneway_suspects.data.WayTrafficFlowTable.Columns.WAY_ID
 import de.westnordost.streetcomplete.quests.oneway_suspects.data.WayTrafficFlowTable.Columns.IS_FORWARD
 
-import androidx.core.content.contentValuesOf
-import de.westnordost.streetcomplete.ktx.getInt
-import de.westnordost.streetcomplete.ktx.queryOne
-
-class WayTrafficFlowDao @Inject constructor(private val dbHelper: SQLiteOpenHelper) {
+import de.westnordost.streetcomplete.data.Database
 
-    private val db get() = dbHelper.writableDatabase
+class WayTrafficFlowDao @Inject constructor(private val db: Database) {
 
     fun put(wayId: Long, isForward: Boolean) {
-        val contentValues = contentValuesOf(
+        db.replace(NAME, listOf(
             WAY_ID to wayId,
             IS_FORWARD to if (isForward) 1 else 0
-        )
-
-        db.replaceOrThrow(NAME, null, contentValues)
+        ))
     }
 
-    /** returns whether the direction of road user flow is forward or null if unknown
-     */
-    fun isForward(wayId: Long): Boolean? {
-        val cols = arrayOf(IS_FORWARD)
-        val query = "$WAY_ID = ?"
-        val args = arrayOf(wayId.toString())
-
-        return db.queryOne(NAME, cols, query, args) { it.getInt(IS_FORWARD) != 0 }
-    }
+    /** returns whether the direction of road user flow is forward or null if unknown */
+    fun isForward(wayId: Long): Boolean? =
+        db.queryOne(NAME,
+            columns = arrayOf(IS_FORWARD),
+            where = "$WAY_ID = $wayId"
+        ) { it.getInt(IS_FORWARD) != 0 }
 
     fun delete(wayId: Long) {
-        val query = "$WAY_ID = ?"
-        val args = arrayOf(wayId.toString())
-
-        db.delete(NAME, query, args)
+        db.delete(NAME, "$WAY_ID = $wayId")
     }
 
     fun deleteUnreferenced() {
-        val query = "$WAY_ID NOT IN (SELECT ${WayTables.Columns.ID} AS $WAY_ID FROM ${WayTables.NAME});"
-
-        db.delete(NAME, query, null)
+        db.delete(NAME, "$WAY_ID NOT IN (SELECT ${WayTables.Columns.ID} AS $WAY_ID FROM ${WayTables.NAME});")
     }
 }
