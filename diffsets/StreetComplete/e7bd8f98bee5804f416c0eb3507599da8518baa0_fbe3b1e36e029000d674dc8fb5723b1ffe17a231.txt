diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/QuestPinsManager.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/QuestPinsManager.kt
index 5b7219a6047..dba8ed5a8c4 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/QuestPinsManager.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/QuestPinsManager.kt
@@ -6,6 +6,7 @@ import androidx.lifecycle.LifecycleOwner
 import org.maplibre.android.maps.MapLibreMap
 import de.westnordost.streetcomplete.data.download.tiles.TilesRect
 import de.westnordost.streetcomplete.data.download.tiles.enclosingTilesRect
+import de.westnordost.streetcomplete.data.osm.mapdata.BoundingBox
 import de.westnordost.streetcomplete.data.osm.mapdata.ElementType
 import de.westnordost.streetcomplete.data.quest.OsmNoteQuestKey
 import de.westnordost.streetcomplete.data.quest.OsmQuestKey
@@ -25,12 +26,10 @@ import kotlinx.coroutines.Job
 import kotlinx.coroutines.SupervisorJob
 import kotlinx.coroutines.cancel
 import kotlinx.coroutines.cancelChildren
-import kotlinx.coroutines.isActive
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.sync.Mutex
 import kotlinx.coroutines.sync.withLock
 import kotlinx.coroutines.withContext
-import kotlin.coroutines.coroutineContext
 
 /** Manages the layer of quest pins in the map view:
  *  Gets told by the QuestsMapFragment when a new area is in view and independently pulls the quests
@@ -52,6 +51,8 @@ class QuestPinsManager(
     private val questsInView: MutableMap<QuestKey, List<Pin>> = mutableMapOf()
     private val questsInViewMutex = Mutex()
 
+    private val visibleQuestsSourceMutex = Mutex()
+
     private val viewLifecycleScope: CoroutineScope = CoroutineScope(SupervisorJob())
 
     private var updateJob: Job? = null
@@ -157,45 +158,57 @@ class QuestPinsManager(
     }
 
     private fun onNewTilesRect(tilesRect: TilesRect) {
-        val bbox = tilesRect.asBoundingBox(TILES_ZOOM)
+        /* Imagine you are panning the map fast, many different tiles come into and vanish from view
+           again quickly. Suppose, that fetching the data from DB takes longer than panning through
+           and out of a tile - we would end up with a long queue of DB fetches (and subsequent
+           map updates) of which the data is discarded immediately after because it is out of view
+           again.
+           So, what we do here is to discard each such update except the last one. All jobs started
+           in potentially quick succession have to wait at for the DB fetch to complete and will
+           stop when they have been cancelled in the meantime. The same with if they have been
+           cancelled just after the DB fetch etc. (The coroutine can be cancelled at every place
+           where you see that arrow with that green squiggle in the IDE)
+           */
         updateJob?.cancel()
         updateJob = viewLifecycleScope.launch {
-            val quests = withContext(Dispatchers.IO) {
-                synchronized(visibleQuestsSource) {
-                    if (!coroutineContext.isActive) {
-                        null
-                    } else {
-                        visibleQuestsSource.getAllVisible(bbox)
-                    }
-                }
-            } ?: return@launch
-            setQuestPins(quests)
+            val bbox = tilesRect.asBoundingBox(TILES_ZOOM)
+            setQuestPins(bbox)
         }
     }
 
-    private suspend fun setQuestPins(quests: List<Quest>) {
+    private suspend fun setQuestPins(bbox: BoundingBox) {
+        val quests = visibleQuestsSourceMutex.withLock {
+            withContext(Dispatchers.IO) { visibleQuestsSource.getAllVisible(bbox) }
+        }
         questsInViewMutex.withLock {
             questsInView.clear()
             quests.forEach { questsInView[it.key] = createQuestPins(it) }
-            if (coroutineContext.isActive) {
-                withContext(Dispatchers.Main) { pinsMapComponent.set(questsInView.values.flatten()) }
-            }
+            val pins = questsInView.values.flatten()
+            withContext(Dispatchers.Main) { pinsMapComponent.set(pins) }
         }
     }
 
     private suspend fun updateQuestPins(added: Collection<Quest>, removed: Collection<QuestKey>) {
-        val displayedBBox = lastDisplayedRect?.asBoundingBox(TILES_ZOOM)
-        val addedInView = added.filter { displayedBBox?.contains(it.position) != false }
-        var deletedAny = false
         questsInViewMutex.withLock {
-            addedInView.forEach { questsInView[it.key] = createQuestPins(it) }
-            removed.forEach { if (questsInView.remove(it) != null) deletedAny = true }
+            val displayedBBox = lastDisplayedRect?.asBoundingBox(TILES_ZOOM) ?: return
+            var hasChanges = false
 
-            if (deletedAny || addedInView.isNotEmpty()) {
-                if (coroutineContext.isActive) {
-                    withContext(Dispatchers.Main) { pinsMapComponent.set(questsInView.values.flatten()) }
+            removed.forEach {
+                if (questsInView.remove(it) != null) hasChanges = true
+            }
+            added.forEach {
+                if (displayedBBox.contains(it.position)) {
+                    questsInView[it.key] = createQuestPins(it)
+                    hasChanges = true
+                } else {
+                    if (questsInView.remove(it.key) != null) hasChanges = true
                 }
             }
+
+            if (!hasChanges) return
+
+            val pins = questsInView.values.flatten()
+            withContext(Dispatchers.Main) { pinsMapComponent.set(pins) }
         }
     }
 
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/StyleableOverlayManager.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/StyleableOverlayManager.kt
index ffa02b95429..c7e81747254 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/StyleableOverlayManager.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/StyleableOverlayManager.kt
@@ -22,12 +22,10 @@ import kotlinx.coroutines.Job
 import kotlinx.coroutines.SupervisorJob
 import kotlinx.coroutines.cancel
 import kotlinx.coroutines.cancelChildren
-import kotlinx.coroutines.isActive
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.sync.Mutex
 import kotlinx.coroutines.sync.withLock
 import kotlinx.coroutines.withContext
-import kotlin.coroutines.coroutineContext
 
 /** Manages the layer of styled map data in the map view:
  *  Gets told by the MainMapFragment when a new area is in view and independently pulls the map
@@ -45,6 +43,8 @@ class StyleableOverlayManager(
     private val mapDataInView: MutableMap<ElementKey, StyledElement> = mutableMapOf()
     private val mapDataInViewMutex = Mutex()
 
+    private val mapDataSourceMutex = Mutex()
+
     private val viewLifecycleScope: CoroutineScope = CoroutineScope(SupervisorJob())
 
     private var updateJob: Job? = null
@@ -137,19 +137,12 @@ class StyleableOverlayManager(
     }
 
     private fun onNewTilesRect(tilesRect: TilesRect) {
-        val bbox = tilesRect.asBoundingBox(TILES_ZOOM)
+        // Check QuestPinsManager::onNewTilesRect for an explanation what this updateJob stuff is
+        // about.
         updateJob?.cancel()
         updateJob = viewLifecycleScope.launch {
-            val mapData = withContext(Dispatchers.IO) {
-                synchronized(mapDataSource) {
-                    if (!coroutineContext.isActive) {
-                        null
-                    } else {
-                        mapDataSource.getMapDataWithGeometry(bbox)
-                    }
-                }
-            } ?: return@launch
-            setStyledElements(mapData)
+            val bbox = tilesRect.asBoundingBox(TILES_ZOOM)
+            setStyledElements(bbox)
         }
     }
 
@@ -163,57 +156,51 @@ class StyleableOverlayManager(
         }
     }
 
-    private suspend fun setStyledElements(mapData: MapDataWithGeometry) {
-        val overlay = overlay ?: return
+    private suspend fun setStyledElements(bbox: BoundingBox) {
+        val mapData = mapDataSourceMutex.withLock {
+            withContext(Dispatchers.IO) { mapDataSource.getMapDataWithGeometry(bbox) }
+        }
         mapDataInViewMutex.withLock {
+            val overlay = overlay ?: return
             mapDataInView.clear()
             createStyledElementsByKey(overlay, mapData).forEach { (key, styledElement) ->
                 mapDataInView[key] = styledElement
             }
-            if (coroutineContext.isActive) {
-                withContext(Dispatchers.Main) { mapComponent.set(mapDataInView.values) }
-            }
+            val styledElements = mapDataInView.values
+            withContext(Dispatchers.Main) { mapComponent.set(styledElements) }
         }
     }
 
     private suspend fun updateStyledElements(updated: MapDataWithGeometry, deleted: Collection<ElementKey>) {
-        val overlay = overlay ?: return
-        val displayedBBox = lastDisplayedRect?.asBoundingBox(TILES_ZOOM) ?: return
-        var changedAnything = false
         mapDataInViewMutex.withLock {
+            val displayedBBox = lastDisplayedRect?.asBoundingBox(TILES_ZOOM) ?: return
+            var hasChanges = false
+            val overlay = overlay ?: return
+
             deleted.forEach {
-                if (mapDataInView.remove(it) != null) {
-                    changedAnything = true
-                }
+                if (mapDataInView.remove(it) != null) hasChanges = true
             }
             val styledElementsByKey = createStyledElementsByKey(overlay, updated).toMap()
             // elements that used to be displayed in the overlay but now not anymore
             updated.forEach {
                 if (!styledElementsByKey.containsKey(it.key)) {
-                    if (mapDataInView.remove(it.key) != null) {
-                        changedAnything = true
-                    }
+                    if (mapDataInView.remove(it.key) != null) hasChanges = true
                 }
             }
-            // elements that are either newly displayed or whose appearance was updated
+            // elements that are either newly displayed or which were updated
             styledElementsByKey.forEach { (key, styledElement) ->
-                val oldStyledElement = mapDataInView[key]
-                mapDataInView[key] = styledElement
-                if (!changedAnything) {
-                    // performance optimization: only update geojson if either the geometry of the
-                    // previous element or the current element are within the current view
-                    if (
-                        styledElement.geometry.getBounds().intersect(displayedBBox) ||
-                        oldStyledElement?.geometry?.getBounds()?.intersect(displayedBBox) == true
-                    ) {
-                        changedAnything = true
-                    }
+                if (displayedBBox.intersect(styledElement.geometry.getBounds())) {
+                    mapDataInView[key] = styledElement
+                    hasChanges = true
+                } else {
+                    if (mapDataInView.remove(key) != null) hasChanges = true
                 }
             }
 
-            if (changedAnything && coroutineContext.isActive) {
-                withContext(Dispatchers.Main) { mapComponent.set(mapDataInView.values) }
-            }
+            if (!hasChanges) return
+
+            val styledElements = mapDataInView.values
+            withContext(Dispatchers.Main) { mapComponent.set(styledElements) }
         }
     }
 
