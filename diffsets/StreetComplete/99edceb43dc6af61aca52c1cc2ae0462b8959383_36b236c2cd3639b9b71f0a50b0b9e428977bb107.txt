diff --git a/app/src/main/assets/map_theme/jawg/streetcomplete.yaml b/app/src/main/assets/map_theme/jawg/streetcomplete.yaml
index 88e7f75faac..ebf1a75cc5d 100644
--- a/app/src/main/assets/map_theme/jawg/streetcomplete.yaml
+++ b/app/src/main/assets/map_theme/jawg/streetcomplete.yaml
@@ -1,5 +1,6 @@
 global:
     geometry_color: '#44D14000' # accent color + alpha
+    location_dot_color: '#44536dfe'
 
 textures:
     pins:
@@ -40,6 +41,9 @@ styles:
     geometry-points:
         base: points
         blend: overlay
+    track-lines:
+        base: lines
+        blend: overlay
 
 layers:
     streetcomplete_selected_pins:
@@ -114,3 +118,21 @@ layers:
                     size: 32px
                     collide: false
                     order: 1000
+    streetcomplete_track:
+        data: { source: streetcomplete_track }
+        draw:
+            track-lines:
+                color: global.location_dot_color
+                width: [[14, 6px],[18, 12px]]
+                collide: false
+                join: round
+                order: 1000
+    streetcomplete_track2:
+      data: { source: streetcomplete_track2 }
+      draw:
+        track-lines:
+          color: global.location_dot_color
+          width: [[14, 6px],[18, 12px]]
+          collide: false
+          join: round
+          order: 1000
diff --git a/app/src/main/java/de/westnordost/streetcomplete/location/FineLocationManager.kt b/app/src/main/java/de/westnordost/streetcomplete/location/FineLocationManager.kt
index 0eb1e114cee..5921ec32065 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/location/FineLocationManager.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/location/FineLocationManager.kt
@@ -57,7 +57,7 @@ class FineLocationManager(private val mgr: LocationManager, private var location
 
 // taken from https://developer.android.com/guide/topics/location/strategies.html#kotlin
 
-private const val TWO_MINUTES: Long = 1000 * 60 * 2
+private const val TWO_MINUTES = 1000L * 60 * 2
 
 /** Determines whether one Location reading is better than the current Location fix
  * @param location The new Location that you want to evaluate
@@ -74,19 +74,19 @@ private fun isBetterLocation(location: Location, currentBestLocation: Location?)
     }
 
     // Check whether the new location fix is newer or older
-    val timeDelta: Long = location.time - currentBestLocation.time
-    val isSignificantlyNewer: Boolean = timeDelta > TWO_MINUTES
-    val isSignificantlyOlder:Boolean = timeDelta < -TWO_MINUTES
-    val isNewer: Boolean = timeDelta > 0L
+    val timeDelta = location.time - currentBestLocation.time
+    val isSignificantlyNewer = timeDelta > TWO_MINUTES
+    val isSignificantlyOlder = timeDelta < -TWO_MINUTES
+    val isNewer = timeDelta > 0L
 
     // Check whether the new location fix is more or less accurate
-    val accuracyDelta: Float = location.accuracy - currentBestLocation.accuracy
-    val isLessAccurate: Boolean = accuracyDelta > 0f
-    val isMoreAccurate: Boolean = accuracyDelta < 0f
-    val isSignificantlyLessAccurate: Boolean = accuracyDelta > 200f
+    val accuracyDelta = location.accuracy - currentBestLocation.accuracy
+    val isLessAccurate = accuracyDelta > 0f
+    val isMoreAccurate = accuracyDelta < 0f
+    val isSignificantlyLessAccurate = accuracyDelta > 200f
 
     // Check if the old and new location are from the same provider
-    val isFromSameProvider: Boolean = location.provider == currentBestLocation.provider
+    val isFromSameProvider = location.provider == currentBestLocation.provider
 
     // Determine location quality using a combination of timeliness and accuracy
     return when {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/Bearing.kt b/app/src/main/java/de/westnordost/streetcomplete/map/Bearing.kt
new file mode 100644
index 00000000000..d112ffab6e5
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/Bearing.kt
@@ -0,0 +1,51 @@
+package de.westnordost.streetcomplete.map
+
+import android.location.Location
+import kotlin.math.PI
+import kotlin.math.atan2
+import kotlin.math.cos
+import kotlin.math.sin
+
+/** Utility functions to estimate current bearing from a track. This is necessary because
+ *  Location.bearingAccuracy doesn't exist on Android versions below Android API 26, otherwise
+ *  a solution based on this would be less code. E.g. take bearing if accuracy < X */
+
+/** Return estimated bearing of a given track. The final result is a smoothing of the last few
+ *  bearings in the track. The bearing of the last point is taken into account the most etc. */
+fun getTrackBearing(track: List<Location>): Double? {
+    val angles = getRelevantBearings(track)
+    if (angles.isEmpty()) return null
+    var x = 0.0
+    var y = 0.0
+    var f = 1.0
+    for (angle in angles) {
+        x += cos(angle * PI / 180.0) * f
+        y += sin(angle * PI / 180.0) * f
+        f *= BEARING_SMOOTHING
+    }
+    return atan2(y, x) * 180.0 / PI
+}
+
+/** Return the last X bearings from the given track, i.e. those that are not too old and not too
+ *  close to each other */
+private fun getRelevantBearings(track: List<Location>): List<Float> {
+    var current = track.lastOrNull() ?: return emptyList()
+    val last = current
+    val result = ArrayList<Float>()
+    for(i in track.lastIndex downTo 0) {
+        val pos = track[i]
+        // ignore if too close to last position
+        if (pos.distanceTo(current) < MIN_TRACK_DISTANCE_FOR_BEARING) continue
+        // break when too old
+        if (last.time - pos.time > MAX_TRACK_AGE_FOR_BEARING) break
+
+        result.add(pos.bearingTo(current))
+
+        current = pos
+    }
+    return result
+}
+
+private const val MIN_TRACK_DISTANCE_FOR_BEARING = 10f // 10 meters
+private const val MAX_TRACK_AGE_FOR_BEARING = 20L * 1000 // 20 seconds
+private const val BEARING_SMOOTHING = 0.5 // (0..1) the lower the value, the less smoothing
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/LocationAwareMapFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/map/LocationAwareMapFragment.kt
index 727f8cf95bd..d7bee4e7c12 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/map/LocationAwareMapFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/LocationAwareMapFragment.kt
@@ -6,14 +6,20 @@ import android.content.Context
 import android.hardware.SensorManager
 import android.location.Location
 import android.location.LocationManager
+import android.os.Bundle
 import android.view.WindowManager
-import android.view.animation.DecelerateInterpolator
 import androidx.core.content.edit
 import androidx.core.content.getSystemService
+import androidx.lifecycle.lifecycleScope
 import de.westnordost.streetcomplete.data.osm.mapdata.LatLon
 import de.westnordost.streetcomplete.location.FineLocationManager
 import de.westnordost.streetcomplete.location.toLatLon
 import de.westnordost.streetcomplete.map.components.CurrentLocationMapComponent
+import de.westnordost.streetcomplete.map.components.TracksMapComponent
+import de.westnordost.streetcomplete.map.tangram.screenBottomToCenterDistance
+import de.westnordost.streetcomplete.util.translate
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.launch
 import kotlin.math.PI
 
 /** Manages a map that shows the device's GPS location and orientation as markers on the map with
@@ -24,10 +30,14 @@ open class LocationAwareMapFragment : MapFragment() {
     private lateinit var locationManager: FineLocationManager
 
     private var locationMapComponent: CurrentLocationMapComponent? = null
+    private var tracksMapComponent: TracksMapComponent? = null
 
+    /** The GPS position at which the user is displayed at */
     var displayedLocation: Location? = null
         private set
-    private var compassRotation: Double? = null
+
+    /** The GPS trackpoints the user has walked */
+    private var tracks: MutableList<ArrayList<Location>>
 
     /** Whether the view should automatically center on the GPS location */
     var isFollowingPosition = true
@@ -36,33 +46,30 @@ open class LocationAwareMapFragment : MapFragment() {
             centerCurrentPositionIfFollowing()
         }
 
-    /** When the view follows the GPS position, whether the view already zoomed to the location once*/
-    private var zoomedYet = false
-
-    /** Whether the view should automatically rotate with the compass (like during navigation) */
-    // Since the with-compass rotation happens with no animation, it's better to start the tilt
-    // animation abruptly and slide out, rather than sliding in and out (the default interpolator)
-    private val interpolator = DecelerateInterpolator()
-    var isCompassMode: Boolean = false
+    /** Whether the view should automatically rotate with bearing (like during navigation) */
+    var isNavigationMode: Boolean = false
         set(value) {
-            if (field != value) {
-                field = value
-                controller?.updateCameraPosition(300, interpolator) {
-                    tilt = if (value) PI.toFloat() / 5f else 0f
-                }
-            }
+            field = value
+            centerCurrentPositionIfFollowing()
         }
-    private var viewDirection: Float? = null
+
+    /** When the view follows the GPS position, whether the view already zoomed to the location once*/
+    private var zoomedYet = false
 
     interface Listener {
         /** Called after the map fragment updated its displayed location */
-        fun onLocationDidChange()
+        fun onDisplayedLocationDidChange()
     }
     private val listener: Listener? get() = parentFragment as? Listener ?: activity as? Listener
 
 
     /* ------------------------------------ Lifecycle ------------------------------------------- */
 
+    init {
+        tracks = ArrayList()
+        tracks.add(ArrayList())
+    }
+
     override fun onAttach(context: Context) {
         super.onAttach(context)
         compass = Compass(context.getSystemService<SensorManager>()!!,
@@ -76,6 +83,15 @@ open class LocationAwareMapFragment : MapFragment() {
         )
     }
 
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        displayedLocation = savedInstanceState?.getParcelable(DISPLAYED_LOCATION)
+        val nullTerminatedTracks = savedInstanceState?.getParcelableArrayList<Location?>(TRACKS) as ArrayList<Location?>?
+        if (nullTerminatedTracks != null) {
+            tracks = nullTerminatedTracks.unflattenNullTerminated()
+        }
+    }
+
     override fun onStop() {
         super.onStop()
         saveMapState()
@@ -93,6 +109,9 @@ open class LocationAwareMapFragment : MapFragment() {
         locationMapComponent = CurrentLocationMapComponent(ctx, ctrl)
         locationMapComponent?.location = displayedLocation
 
+        tracksMapComponent = TracksMapComponent(ctrl)
+        tracksMapComponent?.setTracks(tracks)
+
         centerCurrentPositionIfFollowing()
     }
 
@@ -106,14 +125,23 @@ open class LocationAwareMapFragment : MapFragment() {
     @SuppressLint("MissingPermission")
     fun startPositionTracking() {
         locationMapComponent?.isVisible = true
-        locationManager.requestUpdates(2000, 5f)
+        locationManager.requestUpdates(2000, 1f)
     }
 
     fun stopPositionTracking() {
         locationMapComponent?.isVisible = false
         locationManager.removeUpdates()
-        isCompassMode = false
+    }
+
+    fun clearPositionTracking() {
+        stopPositionTracking()
         displayedLocation = null
+        isNavigationMode = false
+
+        tracks = ArrayList()
+        tracks.add(ArrayList())
+
+        tracksMapComponent?.clear()
     }
 
     protected open fun shouldCenterCurrentPosition(): Boolean {
@@ -121,10 +149,28 @@ open class LocationAwareMapFragment : MapFragment() {
     }
 
     fun centerCurrentPosition() {
-        val controller = controller ?: return
-        val targetPosition = displayedLocation?.toLatLon() ?: return
-        controller.updateCameraPosition(600) {
-            position = targetPosition
+        val displayedPosition = displayedLocation?.toLatLon() ?: return
+        var centerPosition = displayedPosition
+
+        updateCameraPosition(1000) {
+            if (isNavigationMode) {
+                val bearing = getTrackBearing(tracks.last())
+                if (bearing != null) {
+                    rotation = -(bearing * PI / 180.0).toFloat()
+                    // move center position down a bit, so there is more space in front of than
+                    // behind user
+                    val distance = controller?.screenBottomToCenterDistance()
+                    if (distance != null) {
+                        centerPosition = centerPosition.translate(distance * 0.5, bearing)
+                    }
+                }
+                tilt = PI.toFloat() / 6f
+            } else {
+                tilt = 0f
+            }
+
+            position = centerPosition
+
             if (!zoomedYet) {
                 zoomedYet = true
                 zoom = 19f
@@ -137,33 +183,39 @@ open class LocationAwareMapFragment : MapFragment() {
     }
 
     private fun onLocationChanged(location: Location) {
-        this.displayedLocation = location
+        displayedLocation = location
         locationMapComponent?.location = location
+        addTrackLocation(location)
         compass.setLocation(location)
         centerCurrentPositionIfFollowing()
-        listener?.onLocationDidChange()
+        listener?.onDisplayedLocationDidChange()
     }
 
-    /* --------------------------------- Rotation tracking -------------------------------------- */
+    private fun addTrackLocation(location: Location) {
+        // ignore if too imprecise
+        if (location.accuracy > MIN_TRACK_ACCURACY) return
+        val lastLocation = tracks.last().lastOrNull()
 
-    private fun onCompassRotationChanged(rot: Float, tilt: Float) {
-        compassRotation = rot * 180 / PI
-        locationMapComponent?.rotation = compassRotation
-
-        if (isCompassMode) {
-            viewDirection =
-                if (viewDirection == null) -rot
-                else smoothenAngle(-rot, viewDirection ?: 0f, 0.05f)
+        // create new track if last position too old
+        if (lastLocation != null) {
+            if ((displayedLocation?.time ?: 0) - lastLocation.time > MAX_TIME_BETWEEN_LOCATIONS) {
+                tracks.add(ArrayList())
+                tracksMapComponent?.startNewTrack()
+            }
+        }
 
-            controller?.updateCameraPosition { rotation = viewDirection }
+        tracks.last().add(location)
+        // delay update by 1 second because the animation to the new location takes 1 second
+        lifecycleScope.launch {
+            delay(1000)
+            tracksMapComponent?.addToCurrentTrack(location)
         }
     }
 
-    private fun smoothenAngle( newValue: Float, oldValue: Float, factor: Float): Float {
-        var delta = newValue - oldValue
-        while (delta > +PI) delta -= 2 * PI.toFloat()
-        while (delta < -PI) delta += 2 * PI.toFloat()
-        return oldValue + factor * delta
+    /* --------------------------------- Rotation tracking -------------------------------------- */
+
+    private fun onCompassRotationChanged(rot: Float, tilt: Float) {
+        locationMapComponent?.rotation = rot * 180 / PI
     }
 
     /* -------------------------------- Save and Restore State ---------------------------------- */
@@ -171,18 +223,49 @@ open class LocationAwareMapFragment : MapFragment() {
     private fun restoreMapState() {
         val prefs = activity?.getPreferences(Activity.MODE_PRIVATE) ?: return
         isFollowingPosition = prefs.getBoolean(PREF_FOLLOWING, true)
-        isCompassMode = prefs.getBoolean(PREF_COMPASS_MODE, false)
+        isNavigationMode = prefs.getBoolean(PREF_NAVIGATION_MODE, false)
     }
 
     private fun saveMapState() {
         activity?.getPreferences(Activity.MODE_PRIVATE)?.edit {
             putBoolean(PREF_FOLLOWING, isFollowingPosition)
-            putBoolean(PREF_COMPASS_MODE, isCompassMode)
+            putBoolean(PREF_NAVIGATION_MODE, isNavigationMode)
         }
     }
 
+    override fun onSaveInstanceState(outState: Bundle) {
+        super.onSaveInstanceState(outState)
+        outState.putParcelable(DISPLAYED_LOCATION, displayedLocation)
+        outState.putParcelableArrayList(TRACKS, tracks.flattenToNullTerminated())
+    }
+
     companion object {
-        const val PREF_FOLLOWING = "map_following"
-        const val PREF_COMPASS_MODE = "map_compass_mode"
+        private const val PREF_FOLLOWING = "map_following"
+        private const val PREF_NAVIGATION_MODE = "map_navigation_mode"
+
+        private const val DISPLAYED_LOCATION = "displayed_location"
+        private const val TRACKS = "tracks"
+
+        private const val MIN_TRACK_ACCURACY = 20f
+        private const val MAX_TIME_BETWEEN_LOCATIONS = 60L * 1000 // 1 minute
+    }
+}
+
+private fun <T> List<List<T>>.flattenToNullTerminated(): ArrayList<T?> =
+    ArrayList(flatMap { it + null })
+
+private fun <T> List<T?>.unflattenNullTerminated(): ArrayList<ArrayList<T>> {
+    val result = ArrayList<ArrayList<T>>()
+    var current = ArrayList<T>()
+    for (it in this) {
+        if (it != null) {
+            current.add(it)
+        }
+        else {
+            result.add(current)
+            current = ArrayList()
+        }
     }
+    result.add(current)
+    return result
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/MainFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/map/MainFragment.kt
index 0c6e4b36b50..22da85924cd 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/map/MainFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/MainFragment.kt
@@ -97,7 +97,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
     private val binding by viewBinding(FragmentMainBinding::bind)
 
     private var wasFollowingPosition = true
-    private var wasCompassMode = false
+    private var wasNavigationMode = false
 
     private var locationWhenOpenedQuest: Location? = null
 
@@ -218,7 +218,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
     override fun onStop() {
         super.onStop()
         wasFollowingPosition = mapFragment?.isFollowingPosition ?: true
-        wasCompassMode = mapFragment?.isCompassMode ?: false
+        wasNavigationMode = mapFragment?.isNavigationMode ?: false
         visibleQuestsSource.removeListener(this)
         requireContext().unregisterReceiver(locationAvailabilityReceiver)
         LocalBroadcastManager.getInstance(requireContext()).unregisterReceiver(locationRequestFinishedReceiver)
@@ -282,7 +282,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
 
     /* ---------------------------- LocationAwareMapFragment.Listener --------------------------- */
 
-    override fun onLocationDidChange() {
+    override fun onDisplayedLocationDidChange() {
         updateLocationPointerPin()
     }
 
@@ -563,7 +563,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
         binding.gpsTrackingButton.state = if (requireContext().hasLocationPermission)
             LocationState.ALLOWED else LocationState.DENIED
         binding.locationPointerPin.visibility = View.GONE
-        mapFragment!!.stopPositionTracking()
+        mapFragment!!.clearPositionTracking()
         locationManager.removeUpdates()
     }
 
@@ -613,11 +613,11 @@ class MainFragment : Fragment(R.layout.fragment_main),
         val isFlat = mapFragment.cameraPosition?.tilt?.let { it <= margin } ?: false
 
         if (mapFragment.isFollowingPosition && mapFragment.displayedLocation != null) {
-            setIsCompassMode(!mapFragment.isCompassMode)
+            setIsNavigationMode(!mapFragment.isNavigationMode)
         } else {
             if (isNorthUp) {
                 mapFragment.updateCameraPosition(300) {
-                    tilt = if (isFlat) PI.toFloat() / 5f else 0f
+                    tilt = if (isFlat) PI.toFloat() / 6f else 0f
                 }
             } else {
                 mapFragment.updateCameraPosition(300) {
@@ -628,9 +628,9 @@ class MainFragment : Fragment(R.layout.fragment_main),
         }
     }
 
-    private fun setIsCompassMode(compassMode: Boolean) {
+    private fun setIsNavigationMode(compassMode: Boolean) {
         val mapFragment = mapFragment ?: return
-        mapFragment.isCompassMode = compassMode
+        mapFragment.isNavigationMode = compassMode
     }
 
     private fun onClickTrackingButton() {
@@ -650,7 +650,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
         binding.gpsTrackingButton.isActivated = follow
         val isPositionKnown = mapFragment.displayedLocation != null
         binding.gpsTrackingButton.visibility = if (isPositionKnown && follow) View.INVISIBLE else View.VISIBLE
-        if (!follow) setIsCompassMode(false)
+        if (!follow) setIsNavigationMode(false)
     }
 
     /* -------------------------------------- Context Menu -------------------------------------- */
@@ -839,9 +839,9 @@ class MainFragment : Fragment(R.layout.fragment_main),
         val mapFragment = mapFragment ?: return
 
         wasFollowingPosition = mapFragment.isFollowingPosition
-        wasCompassMode = mapFragment.isCompassMode
+        wasNavigationMode = mapFragment.isNavigationMode
         mapFragment.isFollowingPosition = false
-        mapFragment.isCompassMode = false
+        mapFragment.isNavigationMode = false
     }
 
     private fun resetFreezeMap() {
@@ -856,7 +856,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
         val mapFragment = mapFragment ?: return
 
         mapFragment.isFollowingPosition = wasFollowingPosition
-        mapFragment.isCompassMode = wasCompassMode
+        mapFragment.isNavigationMode = wasNavigationMode
         mapFragment.endFocusQuest()
         mapFragment.show3DBuildings = true
         mapFragment.pinMode = QuestsMapFragment.PinMode.QUESTS
@@ -931,7 +931,7 @@ class MainFragment : Fragment(R.layout.fragment_main),
 
     fun setCameraPosition(position: LatLon, zoom: Float) {
         mapFragment?.isFollowingPosition = false
-        mapFragment?.isCompassMode = false
+        mapFragment?.isNavigationMode = false
         mapFragment?.setInitialCameraPosition(CameraPosition(position, 0f, 0f, zoom))
         setIsFollowingPosition(false)
     }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/MapFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/map/MapFragment.kt
index bb8601afd20..9910500efdb 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/map/MapFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/MapFragment.kt
@@ -374,11 +374,11 @@ open class MapFragment : Fragment(),
     fun getDisplayedArea(): BoundingBox? = controller?.screenAreaToBoundingBox(RectF())
 
     companion object {
-        const val PREF_ROTATION = "map_rotation"
-        const val PREF_TILT = "map_tilt"
-        const val PREF_ZOOM = "map_zoom"
-        const val PREF_LAT = "map_lat"
-        const val PREF_LON = "map_lon"
+        private const val PREF_ROTATION = "map_rotation"
+        private const val PREF_TILT = "map_tilt"
+        private const val PREF_ZOOM = "map_zoom"
+        private const val PREF_LAT = "map_lat"
+        private const val PREF_LON = "map_lon"
     }
 
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/components/TracksMapComponent.kt b/app/src/main/java/de/westnordost/streetcomplete/map/components/TracksMapComponent.kt
new file mode 100644
index 00000000000..29c794ab278
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/components/TracksMapComponent.kt
@@ -0,0 +1,75 @@
+package de.westnordost.streetcomplete.map.components
+
+import android.location.Location
+import com.mapzen.tangram.LngLat
+import com.mapzen.tangram.geometry.Polyline
+import de.westnordost.streetcomplete.map.tangram.KtMapController
+import de.westnordost.streetcomplete.map.tangram.toLngLat
+import kotlin.math.max
+
+/** Takes care of showing the path(s) walked on the map */
+class TracksMapComponent(ctrl: KtMapController) {
+
+    /* There are two layers simply as a performance optimization: If there are thousands of
+       trackpoints, we don't want to update (=copy) the thousands of points each time a new
+       trackpoint is added. Instead, we only update a list of 100 trackpoints each time a new
+       trackpoint is added and every 100th time, we update the other layer.
+
+       So, the list of points updated ~per second doesn't grow too long.
+     */
+    private val activeLayer = ctrl.addDataLayer(LAYER1)
+    private val oldLayer = ctrl.addDataLayer(LAYER2)
+
+    private var index = 0
+    private var tracks: MutableList<MutableList<LngLat>>
+
+    init {
+        tracks = ArrayList()
+        tracks.add(ArrayList())
+    }
+
+    /** Add a point to the current track */
+    fun addToCurrentTrack(pos: Location) {
+        val track = tracks.last()
+        track.add(pos.toLngLat())
+
+        // every 100th trackpoint, move the index to the back
+        if (track.size - index > 100) {
+            putAllTracksInOldLayer()
+        } else {
+            activeLayer.setFeatures(listOf(track.subList(index, track.size).toPolyline()))
+        }
+    }
+
+    /** Start a new track. I.e. the points in that track will be drawn as an own polyline */
+    fun startNewTrack() {
+        tracks.add(ArrayList())
+        putAllTracksInOldLayer()
+    }
+
+    /** Set all the tracks (when re-initializing) */
+    fun setTracks(tracks: List<List<Location>>) {
+        this.tracks = tracks.map { track -> track.map { it.toLngLat() }.toMutableList() }.toMutableList()
+        putAllTracksInOldLayer()
+    }
+
+    private fun putAllTracksInOldLayer() {
+        index = max(0, tracks.last().lastIndex)
+        activeLayer.clear()
+        oldLayer.setFeatures(tracks.map { it.toPolyline() })
+    }
+
+    fun clear() {
+        tracks = ArrayList()
+        startNewTrack()
+    }
+
+    companion object {
+        // see streetcomplete.yaml for the definitions of the layer
+        private const val LAYER1 = "streetcomplete_track"
+        private const val LAYER2 = "streetcomplete_track2"
+
+    }
+}
+
+private fun List<LngLat>.toPolyline() = Polyline(this, mapOf("type" to "line"))
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/tangram/KtMapController.kt b/app/src/main/java/de/westnordost/streetcomplete/map/tangram/KtMapController.kt
index b653a1ddf78..f6af646211a 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/map/tangram/KtMapController.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/tangram/KtMapController.kt
@@ -19,7 +19,6 @@ import de.westnordost.streetcomplete.data.osm.mapdata.BoundingBox
 import de.westnordost.streetcomplete.data.osm.mapdata.LatLon
 import de.westnordost.streetcomplete.util.*
 import kotlinx.coroutines.*
-import java.util.Locale
 import java.util.concurrent.ConcurrentLinkedQueue
 import kotlin.coroutines.Continuation
 import kotlin.coroutines.resume
diff --git a/app/src/main/java/de/westnordost/streetcomplete/map/tangram/TangramExtensions.kt b/app/src/main/java/de/westnordost/streetcomplete/map/tangram/TangramExtensions.kt
index 95306418232..118e11aaae2 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/map/tangram/TangramExtensions.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/map/tangram/TangramExtensions.kt
@@ -2,6 +2,7 @@ package de.westnordost.streetcomplete.map.tangram
 
 import android.graphics.PointF
 import android.graphics.RectF
+import android.location.Location
 import com.mapzen.tangram.LngLat
 import com.mapzen.tangram.geometry.Geometry
 import com.mapzen.tangram.geometry.Point
@@ -12,6 +13,7 @@ import de.westnordost.streetcomplete.data.osm.geometry.ElementPointGeometry
 import de.westnordost.streetcomplete.data.osm.geometry.ElementPolygonsGeometry
 import de.westnordost.streetcomplete.data.osm.geometry.ElementPolylinesGeometry
 import de.westnordost.streetcomplete.data.osm.mapdata.LatLon
+import de.westnordost.streetcomplete.util.distanceTo
 
 fun ElementGeometry.toTangramGeometry(): List<Geometry> = when(this) {
     is ElementPolylinesGeometry -> {
@@ -38,6 +40,8 @@ fun LngLat.toLatLon(): LatLon = LatLon(latitude, longitude)
 
 fun LatLon.toLngLat(): LngLat = LngLat(longitude, latitude)
 
+fun Location.toLngLat(): LngLat = LngLat(longitude, latitude)
+
 fun KtMapController.screenAreaContains(g: ElementGeometry, offset: RectF): Boolean {
     val p = PointF()
     val mapView = glViewHolder!!.view
@@ -53,3 +57,14 @@ fun KtMapController.screenAreaContains(g: ElementGeometry, offset: RectF): Boole
             && p.y <= mapView.height - offset.bottom
     }
 }
+
+fun KtMapController.screenBottomToCenterDistance(): Double? {
+    val view = glViewHolder?.view ?: return null
+    val w = view.width
+    val h = view.height
+    if (w == 0 || h == 0) return null
+
+    val center = screenPositionToLatLon(PointF(w/2f, h/2f)) ?: return null
+    val bottom = screenPositionToLatLon(PointF(w/2f, h*1f)) ?: return null
+    return center.distanceTo(bottom)
+}
