diff --git a/app/build.gradle b/app/build.gradle
index 4c8a6289406..2a29c281563 100644
--- a/app/build.gradle
+++ b/app/build.gradle
@@ -83,6 +83,7 @@ dependencies {
     testImplementation 'junit:junit:4.12'
     testImplementation 'org.mockito:mockito-core:2.23.4'
     testImplementation 'org.assertj:assertj-core:2.8.0'
+    testImplementation ('de.westnordost:osmapi:3.4')
 
     androidTestImplementation 'androidx.test:runner:1.2.0'
     androidTestImplementation 'androidx.test:rules:1.2.0'
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.java b/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.java
index 1425af7c4c6..9f7e8694e54 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.java
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/ApplicationDbTestCase.java
@@ -6,9 +6,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import de.westnordost.streetcomplete.ApplicationConstants;
-import de.westnordost.streetcomplete.quests.localized_name.data.RoadNamesTablesHelper;
-import de.westnordost.streetcomplete.quests.oneway.data.WayTrafficFlowTablesHelper;
 import de.westnordost.streetcomplete.util.KryoSerializer;
 import de.westnordost.streetcomplete.util.Serializer;
 
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDaoTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDaoTest.kt
new file mode 100644
index 00000000000..4b08a779c65
--- /dev/null
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDaoTest.kt
@@ -0,0 +1,83 @@
+package de.westnordost.streetcomplete.data.osm.persist
+
+import de.westnordost.osmapi.map.data.OsmLatLon
+import de.westnordost.streetcomplete.data.ApplicationDbTestCase
+import de.westnordost.streetcomplete.data.QuestTypeRegistry
+import de.westnordost.streetcomplete.data.osm.OsmQuestSplitWay
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtLinePosition
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtPoint
+import de.westnordost.streetcomplete.data.osm.persist.test.*
+import org.junit.Test
+
+import org.junit.Assert.*
+import org.junit.Before
+
+class OsmQuestSplitWayDaoTest : ApplicationDbTestCase() {
+
+	private val questType = TestQuestType()
+	private lateinit var dao: OsmQuestSplitWayDao
+
+	@Before fun createDao() {
+		dao = OsmQuestSplitWayDao(dbHelper, serializer, QuestTypeRegistry(listOf(questType)))
+	}
+
+    @Test fun getButNothingIsThere() {
+	    assertNull(dao.get(1L))
+    }
+
+	@Test fun getAllButNothingIsThere() {
+		assertEquals(listOf<OsmQuestSplitWay>(), dao.getAll())
+	}
+
+    @Test fun putAndGet() {
+	    val id = 1L
+	    val input = createOsmQuestSplitWay(id)
+	    dao.put(input)
+	    val output = dao.get(id)!!
+
+	    assertEquals(input.questType, output.questType)
+	    assertEquals(input.wayId, output.wayId)
+	    assertEquals(input.id, output.id)
+	    assertEquals(input.splits.size, output.splits.size)
+	    val it = input.splits.listIterator()
+	    val ot = output.splits.listIterator()
+	    while(it.hasNext()) {
+		    val iSplit = it.next()
+		    val oSplit = ot.next()
+            assertEquals(iSplit, oSplit)
+	    }
+    }
+
+    @Test fun delete() {
+	    val id = 1L
+	    val input = createOsmQuestSplitWay(id)
+	    dao.put(input)
+	    dao.delete(id)
+	    assertNull(dao.get(id))
+    }
+
+	@Test fun putReplaces() {
+		val id = 1L
+		dao.put(createOsmQuestSplitWay(id, 1L))
+		dao.put(createOsmQuestSplitWay(id, 123L))
+		assertEquals(123L, dao.get(id)?.wayId)
+		assertEquals(1, dao.getAll().size)
+	}
+
+	@Test fun getAll() {
+		dao.put(createOsmQuestSplitWay(1L, 1L))
+		dao.put(createOsmQuestSplitWay(2L, 2L))
+		assertEquals(2, dao.getAll().size)
+	}
+
+	private fun createOsmQuestSplitWay(id: Long, wayId: Long = 1L): OsmQuestSplitWay {
+		val pos1 = OsmLatLon(0.0, 0.0)
+		val pos2 = OsmLatLon(1.0, 0.0)
+		return OsmQuestSplitWay(id, questType, wayId, "test", listOf(
+            SplitAtLinePosition(pos1, pos2, 0.3),
+            SplitAtPoint(pos2))
+		)
+	}
+}
+
+
diff --git a/app/src/androidTest/java/de/westnordost/streetcomplete/quests/QuestAnswerComponentTest.kt b/app/src/androidTest/java/de/westnordost/streetcomplete/quests/QuestAnswerComponentTest.kt
index 41d05bf2460..114df6fa3db 100644
--- a/app/src/androidTest/java/de/westnordost/streetcomplete/quests/QuestAnswerComponentTest.kt
+++ b/app/src/androidTest/java/de/westnordost/streetcomplete/quests/QuestAnswerComponentTest.kt
@@ -27,10 +27,8 @@ class QuestAnswerComponentTest {
 
         val expectQuestId = 3
         val expectGroup = QuestGroup.OSM_NOTE
-        val expectNote = "test"
         val expectQuestTitle = "What?"
         val expectObject = "jo"
-        val expectImagePaths = listOf("dings","dongs")
 
         c1.onAttach(object : OsmQuestAnswerListener {
             override fun onAnsweredQuest(questId: Long, group: QuestGroup, answer: Any) {
@@ -45,12 +43,9 @@ class QuestAnswerComponentTest {
                 assertEquals(expectQuestTitle, questTitle)
             }
 
-            override fun onLeaveNote(questId: Long, group: QuestGroup, questTitle: String, note: String, imagePaths: List<String>?) {
+            override fun onSplitWay(questId: Long, group: QuestGroup) {
                 assertEquals(expectQuestId.toLong(), questId)
                 assertEquals(expectGroup, group)
-                assertEquals(expectNote, note)
-                assertEquals(expectQuestTitle, questTitle)
-                assertEquals(expectImagePaths, imagePaths)
             }
 
             override fun onSkippedQuest(questId: Long, group: QuestGroup) {
@@ -61,8 +56,8 @@ class QuestAnswerComponentTest {
 
         c1.onCreate(QuestAnswerComponent.createArguments(expectQuestId.toLong(), expectGroup))
         c1.onComposeNote(expectQuestTitle)
-        c1.onLeaveNote(expectQuestTitle, expectNote, expectImagePaths)
-        c1.onAnswerQuest(expectObject)
+        c1.onSplitWay()
+        c1.onAnsweredQuest(expectObject)
         c1.onSkippedQuest()
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ApplicationComponent.java b/app/src/main/java/de/westnordost/streetcomplete/ApplicationComponent.java
index 62535fe919f..2b699575e03 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/ApplicationComponent.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/ApplicationComponent.java
@@ -1,5 +1,7 @@
 package de.westnordost.streetcomplete;
 
+import org.jetbrains.annotations.NotNull;
+
 import javax.inject.Singleton;
 
 import dagger.Component;
@@ -13,6 +15,7 @@
 import de.westnordost.streetcomplete.oauth.OsmOAuthDialogFragment;
 import de.westnordost.streetcomplete.quests.AbstractQuestAnswerFragment;
 import de.westnordost.streetcomplete.quests.QuestModule;
+import de.westnordost.streetcomplete.quests.SplitWayFragment;
 import de.westnordost.streetcomplete.quests.building_levels.AddBuildingLevelsForm;
 import de.westnordost.streetcomplete.quests.localized_name.AAddLocalizedNameForm;
 import de.westnordost.streetcomplete.quests.oneway.AddOnewayForm;
@@ -68,4 +71,5 @@ public interface ApplicationComponent
 	void inject(AddBuildingLevelsForm fragment);
 	void inject(ChangesetAutoCloserWorker worker);
 
+	void inject(@NotNull SplitWayFragment splitWayFragment);
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ApplicationModule.java b/app/src/main/java/de/westnordost/streetcomplete/ApplicationModule.java
index bc41bb39850..2fe2488df47 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/ApplicationModule.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/ApplicationModule.java
@@ -22,6 +22,7 @@
 import de.westnordost.streetcomplete.data.osm.persist.ElementGeometryDao;
 import de.westnordost.streetcomplete.data.osm.persist.MergedElementDao;
 import de.westnordost.streetcomplete.data.osm.persist.OsmQuestDao;
+import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayDao;
 import de.westnordost.streetcomplete.data.osm.persist.UndoOsmQuestDao;
 import de.westnordost.streetcomplete.data.osmnotes.CreateNoteDao;
 import de.westnordost.streetcomplete.data.osmnotes.OsmNoteQuestDao;
@@ -67,14 +68,14 @@ public ApplicationModule(Application application)
 	}
 
 	@Provides public QuestController questController(
-			OsmQuestDao osmQuestDB, UndoOsmQuestDao undoOsmQuestDB, MergedElementDao osmElementDB,
-			ElementGeometryDao geometryDB, OsmNoteQuestDao osmNoteQuestDB,
-			CreateNoteDao createNoteDB, OpenChangesetsDao manageChangesetsDB,
-			Provider<List<QuestType>> questTypesProvider)
+		OsmQuestDao osmQuestDB, UndoOsmQuestDao undoOsmQuestDB, MergedElementDao osmElementDB,
+		ElementGeometryDao geometryDB, OsmNoteQuestDao osmNoteQuestDB,
+		CreateNoteDao createNoteDB, OsmQuestSplitWayDao splitWayDB,
+		OpenChangesetsDao manageChangesetsDB, Provider<List<QuestType>> questTypesProvider)
 	{
 		return new QuestController(
-				osmQuestDB, undoOsmQuestDB, osmElementDB, geometryDB, osmNoteQuestDB, createNoteDB,
-				manageChangesetsDB,	questTypesProvider, appContext());
+			osmQuestDB, undoOsmQuestDB, osmElementDB, geometryDB, osmNoteQuestDB, splitWayDB,
+			createNoteDB, manageChangesetsDB, questTypesProvider, appContext());
 	}
 
 	@Provides public static MobileDataAutoDownloadStrategy mobileDataAutoDownloadStrategy(
diff --git a/app/src/main/java/de/westnordost/streetcomplete/MainActivity.java b/app/src/main/java/de/westnordost/streetcomplete/MainActivity.java
index d5a71c46717..05ff8a904fc 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/MainActivity.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/MainActivity.java
@@ -5,6 +5,7 @@
 import android.graphics.Point;
 import android.graphics.PointF;
 import androidx.annotation.DrawableRes;
+import androidx.annotation.NonNull;
 import androidx.fragment.app.Fragment;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
@@ -68,17 +69,18 @@
 import de.westnordost.osmapi.map.data.Element;
 import de.westnordost.osmapi.map.data.LatLon;
 import de.westnordost.osmapi.map.data.OsmElement;
+import de.westnordost.osmapi.map.data.Way;
 import de.westnordost.osmfeatures.FeatureDictionary;
 import de.westnordost.streetcomplete.about.AboutFragment;
 import de.westnordost.streetcomplete.data.Quest;
 import de.westnordost.streetcomplete.data.QuestAutoSyncer;
-import de.westnordost.streetcomplete.data.osmnotes.CreateNoteListener;
 import de.westnordost.streetcomplete.data.QuestController;
 import de.westnordost.streetcomplete.data.QuestGroup;
 import de.westnordost.streetcomplete.data.VisibleQuestListener;
 import de.westnordost.streetcomplete.data.download.QuestDownloadProgressListener;
 import de.westnordost.streetcomplete.data.download.QuestDownloadService;
 import de.westnordost.streetcomplete.data.osm.OsmQuest;
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition;
 import de.westnordost.streetcomplete.data.upload.QuestChangesUploadProgressListener;
 import de.westnordost.streetcomplete.data.upload.QuestChangesUploadService;
 import de.westnordost.streetcomplete.data.upload.VersionBannedException;
@@ -87,12 +89,13 @@
 import de.westnordost.streetcomplete.location.LocationState;
 import de.westnordost.streetcomplete.location.LocationUtil;
 import de.westnordost.streetcomplete.oauth.OAuthPrefs;
-import de.westnordost.streetcomplete.quests.AbstractBottomSheetFragment;
 import de.westnordost.streetcomplete.quests.AbstractQuestAnswerFragment;
+import de.westnordost.streetcomplete.quests.IsCloseableBottomSheet;
 import de.westnordost.streetcomplete.quests.LeaveNoteInsteadFragment;
 import de.westnordost.streetcomplete.quests.OsmQuestAnswerListener;
 import de.westnordost.streetcomplete.quests.QuestAnswerComponent;
 import de.westnordost.streetcomplete.quests.QuestUtilKt;
+import de.westnordost.streetcomplete.quests.SplitWayFragment;
 import de.westnordost.streetcomplete.settings.SettingsActivity;
 import de.westnordost.streetcomplete.sound.SoundFx;
 import de.westnordost.streetcomplete.statistics.AnswersCounter;
@@ -109,8 +112,9 @@
 import static de.westnordost.streetcomplete.ApplicationConstants.MANUAL_DOWNLOAD_QUEST_TYPE_COUNT;
 
 public class MainActivity extends AppCompatActivity implements
-		OsmQuestAnswerListener, CreateNoteListener, VisibleQuestListener,
-		QuestsMapFragment.Listener, MapFragment.Listener, MapControlsFragment.Listener
+		OsmQuestAnswerListener, CreateNoteFragment.Listener, VisibleQuestListener,
+		QuestsMapFragment.Listener, MapFragment.Listener, MapControlsFragment.Listener,
+		SplitWayFragment.Listener, LeaveNoteInsteadFragment.Listener
 {
 	@Inject CrashReportExceptionHandler crashReportExceptionHandler;
 
@@ -567,6 +571,21 @@ private void downloadAreaConfirmed(BoundingBox bbox)
 		questController.download(bbox, MANUAL_DOWNLOAD_QUEST_TYPE_COUNT, true);
 	}
 
+	private void triggerAutoUploadByUserInteraction()
+	{
+		if(questAutoSyncer.isAllowedByPreference())
+		{
+			if (!oAuth.isAuthorized()) {
+				// new users should not be immediately pestered to login after each change (#1446)
+				if(answersCounter.waitingForUpload() > 5) {
+					requestOAuthorized();
+				}
+			}
+			else {
+				questAutoSyncer.triggerAutoUpload();
+			}
+		}
+	}
 
 	/* ------------------------------ Upload progress listener ---------------------------------- */
 
@@ -733,33 +752,9 @@ else if(e instanceof OsmAuthorizationException)
 		}
 	};
 
-	/* ------------ Managing bottom sheet (quest details) and interaction with map  ------------- */
+	/* --------------------------------- OsmQuestAnswerListener --------------------------------- */
 
-	private final static String BOTTOM_SHEET = "bottom_sheet";
-
-	@Override public void onBackPressed()
-	{
-		AbstractBottomSheetFragment f = getBottomSheetFragment();
-		if(f != null)
-		{
-			f.onClickClose(() ->
-			{
-				mapFragment.removeQuestGeometry();
-				mapFragment.setIsFollowingPosition(isFollowingPosition);
-				mapFragment.setCompassMode(isCompassMode);
-				mapFragment.showMapControls();
-				MainActivity.super.onBackPressed();
-			});
-		}
-		else
-		{
-			super.onBackPressed();
-		}
-	}
-
-	/* ------------- OsmQuestAnswerListener ------------- */
-
-	@Override public void onAnsweredQuest(long questId, QuestGroup group, Object answer)
+	@Override public void onAnsweredQuest(long questId, @NonNull QuestGroup group, @NonNull Object answer)
 	{
 		questSource.findSource(questId, group, mapFragment.getDisplayedLocation(), source ->
 		{
@@ -773,24 +768,31 @@ else if(e instanceof OsmAuthorizationException)
 		});
 	}
 
-	@Override public void onComposeNote(long questId, QuestGroup group, String questTitle)
+	@Override public void onComposeNote(long questId, @NonNull QuestGroup group, @NonNull String questTitle)
 	{
-		LeaveNoteInsteadFragment f = new LeaveNoteInsteadFragment();
-		Bundle args = QuestAnswerComponent.Companion.createArguments(questId, group);
-		args.putString(LeaveNoteInsteadFragment.ARG_QUEST_TITLE, questTitle);
-		f.setArguments(args);
+		replaceInBottomSheet(LeaveNoteInsteadFragment.create(questId, group, questTitle));
+	}
 
-		getSupportFragmentManager().popBackStack(BOTTOM_SHEET, FragmentManager.POP_BACK_STACK_INCLUSIVE);
-		FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
-		ft.setCustomAnimations(
-			0, R.animator.quest_answer_form_disappear,
-			0, R.animator.quest_answer_form_disappear);
-		ft.add(R.id.map_bottom_sheet_container, f, BOTTOM_SHEET);
-		ft.addToBackStack(BOTTOM_SHEET);
-		ft.commit();
+	@Override public void onSplitWay(long osmQuestId)
+	{
+		Quest quest = questController.get(osmQuestId, QuestGroup.OSM);
+		if (quest == null) return;
+		OsmElement element = questController.getOsmElement((OsmQuest) quest);
+		if (!(element instanceof Way)) return;
+		replaceInBottomSheet(SplitWayFragment.create(osmQuestId, (Way) element, quest.getGeometry()));
 	}
 
-	@Override public void onLeaveNote(long questId, QuestGroup group, String questTitle, String note, @Nullable List<String> imagePaths)
+	@Override public void onSkippedQuest(long questId, @NonNull QuestGroup group)
+	{
+		closeQuestDetailsFor(questId, group);
+		questController.hide(questId, group);
+	}
+
+	/* --------------------------- LeaveNoteInsteadFragment.Listener ---------------------------- */
+
+	@Override public void onCreatedNoteInstead(
+		long questId, @NonNull QuestGroup group, @NonNull String questTitle, @NonNull String note,
+		@Nullable List<String> imagePaths)
 	{
 		closeBottomSheet();
 		// the quest is deleted from DB on creating a note, so need to fetch quest before
@@ -802,26 +804,54 @@ else if(e instanceof OsmAuthorizationException)
 		triggerAutoUploadByUserInteraction();
 	}
 
-	private void flingQuestMarkerTo(View quest, View target, Runnable onFinished)
+	/* ------------------------------ CreateNoteFragment.Listener ------------------------------- */
+
+
+	@Override public void onCreatedNote(
+		@NonNull String note, @Nullable List<String> imagePaths, @NonNull Point screenPosition)
 	{
-		int[] targetPos = new int[2];
-		target.getLocationOnScreen(targetPos);
+		showMarkerSolvedAnimation(R.drawable.ic_quest_create_note, new PointF(screenPosition), null);
+		closeBottomSheet();
 
-		quest.animate()
-			.scaleX(1.6f).scaleY(1.6f)
-			.setInterpolator(new OvershootInterpolator(8f))
-			.setDuration(250)
-			.withEndAction(() -> {
-				quest.animate()
-					.scaleX(0.2f).scaleY(0.2f)
-					.alpha(0.8f)
-					.x(targetPos[0]).y(targetPos[1])
-					.setDuration(250)
-					.setInterpolator(new AccelerateInterpolator())
-					.withEndAction(onFinished);
+		int[] mapPosition = new int[2];
+		View mapView = mapFragment.getView();
+		if(mapView == null) return;
+
+		mapView.getLocationInWindow(mapPosition);
+
+		PointF notePosition = new PointF(screenPosition);
+		notePosition.offset(-mapPosition[0], -mapPosition[1]);
+
+		LngLat position = mapFragment.getPositionAt(notePosition);
+		if(position == null) throw new NullPointerException();
+		questController.createNote(note, imagePaths, TangramConst.toLatLon(position));
+		triggerAutoUploadByUserInteraction();
+	}
+
+	/* ------------------------------- SplitWayFragment.Listener -------------------------------- */
+
+	@Override public void onSplittedWay(long osmQuestId, @NonNull List<? extends SplitPolylineAtPosition> splits)
+	{
+		questSource.findSource(osmQuestId, QuestGroup.OSM, mapFragment.getDisplayedLocation(), source ->
+		{
+			closeBottomSheet();
+			questController.splitWay(osmQuestId, splits, source);
+			triggerAutoUploadByUserInteraction();
 		});
 	}
 
+	@Override public void onAddSplit(@NonNull LatLon point)
+	{
+		mapFragment.putMarkerForCurrentQuest(point);
+	}
+
+	@Override public void onRemoveSplit(@NonNull LatLon point)
+	{
+		mapFragment.deleteMarkerForCurrentQuest(point);
+	}
+
+	/* ------------------------------------------------------------------------------------------ */
+
 	private void showQuestSolvedAnimation(Quest quest, String source)
 	{
 		if(quest == null) return;
@@ -852,21 +882,27 @@ private void showMarkerSolvedAnimation(@DrawableRes int iconResId, PointF startS
 		});
 	}
 
-	@Override public void onSkippedQuest(long questId, QuestGroup group)
+	private void flingQuestMarkerTo(View quest, View target, Runnable onFinished)
 	{
-		closeQuestDetailsFor(questId, group);
-		questController.hide(questId, group);
-	}
+		int[] targetPos = new int[2];
+		target.getLocationOnScreen(targetPos);
 
-	private void closeQuestDetailsFor(long questId, QuestGroup group)
-	{
-		if (isQuestDetailsCurrentlyDisplayedFor(questId, group))
-		{
-			closeBottomSheet();
-		}
+		quest.animate()
+			.scaleX(1.6f).scaleY(1.6f)
+			.setInterpolator(new OvershootInterpolator(8f))
+			.setDuration(250)
+			.withEndAction(() -> {
+				quest.animate()
+					.scaleX(0.2f).scaleY(0.2f)
+					.alpha(0.8f)
+					.x(targetPos[0]).y(targetPos[1])
+					.setDuration(250)
+					.setInterpolator(new AccelerateInterpolator())
+					.withEndAction(onFinished);
+			});
 	}
 
-	/* ------------- creating notes ------------- */
+	/* ------------------------------ MapControlsFragment.Listener ------------------------------ */
 
 	@Override public void onClickCreateNote()
 	{
@@ -876,7 +912,7 @@ private void closeQuestDetailsFor(long questId, QuestGroup group)
 			return;
 		}
 
-		AbstractBottomSheetFragment f = getBottomSheetFragment();
+		IsCloseableBottomSheet f = getBottomSheetFragment();
 		if (f != null)   f.onClickClose(this::composeNote);
 		else             composeNote();
 	}
@@ -886,43 +922,7 @@ private void composeNote()
 		showInBottomSheet(new CreateNoteFragment());
 	}
 
-	@Override public void onLeaveNote(String note, @Nullable List<String> imagePaths, Point screenPosition)
-	{
-		showMarkerSolvedAnimation(R.drawable.ic_quest_create_note, new PointF(screenPosition), null);
-		closeBottomSheet();
-
-		int[] mapPosition = new int[2];
-		View mapView = mapFragment.getView();
-		if(mapView == null) return;
-
-		mapView.getLocationInWindow(mapPosition);
-
-		PointF notePosition = new PointF(screenPosition);
-		notePosition.offset(-mapPosition[0], -mapPosition[1]);
-
-		LngLat position = mapFragment.getPositionAt(notePosition);
-		if(position == null) throw new NullPointerException();
-		questController.createNote(note, imagePaths, TangramConst.toLatLon(position));
-		triggerAutoUploadByUserInteraction();
-	}
-
-	private void triggerAutoUploadByUserInteraction()
-	{
-		if(questAutoSyncer.isAllowedByPreference())
-		{
-			if (!oAuth.isAuthorized()) {
-				// new users should not be immediately pestered to login after each change (#1446)
-				if(answersCounter.waitingForUpload() > 5) {
-					requestOAuthorized();
-				}
-			}
-			else {
-				questAutoSyncer.triggerAutoUpload();
-			}
-		}
-	}
-
-	/* ------------- VisibleQuestListener ------------- */
+	/* ---------------------------------- VisibleQuestListener ---------------------------------- */
 
 	@AnyThread @Override
 	public void onQuestsCreated(final Collection<? extends Quest> quests, final QuestGroup group)
@@ -966,6 +966,38 @@ public synchronized void onQuestsRemoved(Collection<Long> questIds, QuestGroup g
 		}
 	}
 
+	/* ------------ Managing bottom sheet (quest details) and interaction with map  ------------- */
+
+	private final static String BOTTOM_SHEET = "bottom_sheet";
+
+	@Override public void onBackPressed()
+	{
+		IsCloseableBottomSheet f = getBottomSheetFragment();
+		if(f != null)
+		{
+			f.onClickClose(() ->
+			{
+				mapFragment.removeQuestGeometry();
+				mapFragment.setIsFollowingPosition(isFollowingPosition);
+				mapFragment.setCompassMode(isCompassMode);
+				mapFragment.showMapControls();
+				MainActivity.super.onBackPressed();
+			});
+		}
+		else
+		{
+			super.onBackPressed();
+		}
+	}
+
+	private void closeQuestDetailsFor(long questId, QuestGroup group)
+	{
+		if (isQuestDetailsCurrentlyDisplayedFor(questId, group))
+		{
+			closeBottomSheet();
+		}
+	}
+
 	@UiThread private void closeBottomSheet()
 	{
 		// #285: This method may be called after the user tapped the home button from removeQuests().
@@ -1003,8 +1035,6 @@ private boolean isQuestDetailsCurrentlyDisplayedFor(long questId, QuestGroup gro
 
 	@UiThread private void showQuestDetails(Quest quest, QuestGroup group)
 	{
-		mapFragment.addQuestGeometry(quest.getGeometry());
-
 		if(isQuestDetailsCurrentlyDisplayedFor(quest.getId(), group)) return;
 
 		if(getBottomSheetFragment() != null)
@@ -1047,18 +1077,30 @@ private void showInBottomSheet(Fragment f)
 		ft.commit();
 	}
 
-	private AbstractBottomSheetFragment getBottomSheetFragment()
+	private void replaceInBottomSheet(Fragment f) {
+		FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
+		ft.setCustomAnimations(
+			0, R.animator.quest_answer_form_disappear,
+			0, R.animator.quest_answer_form_disappear);
+		ft.replace(R.id.map_bottom_sheet_container, f, BOTTOM_SHEET);
+		ft.commit();
+	}
+
+	private IsCloseableBottomSheet getBottomSheetFragment()
 	{
-		return (AbstractBottomSheetFragment) getSupportFragmentManager().findFragmentByTag(BOTTOM_SHEET);
+		Fragment f = getSupportFragmentManager().findFragmentByTag(BOTTOM_SHEET);
+		return f instanceof IsCloseableBottomSheet ? (IsCloseableBottomSheet) f : null;
 	}
 
 	private AbstractQuestAnswerFragment getQuestDetailsFragment()
 	{
-		AbstractBottomSheetFragment f = getBottomSheetFragment();
+		Fragment f = getSupportFragmentManager().findFragmentByTag(BOTTOM_SHEET);
 
 		return f instanceof AbstractQuestAnswerFragment ? (AbstractQuestAnswerFragment) f : null ;
 	}
 
+	/* ---------------------------------- MapFragment.Listener ---------------------------------- */
+
 	@AnyThread @Override public void onMapOrientation(float rotation, float tilt)
 	{
 		mapRotation = rotation;
@@ -1069,7 +1111,8 @@ private AbstractQuestAnswerFragment getQuestDetailsFragment()
 			f.onMapOrientation(rotation, tilt);
 		}
 	}
-	/* ---------- QuestsMapFragment.Listener ---------- */
+
+	/* ------------------------------- QuestsMapFragment.Listener ------------------------------- */
 
 	@Override public void onFirstInView(BoundingBox bbox)
 	{
@@ -1086,21 +1129,22 @@ private AbstractQuestAnswerFragment getQuestDetailsFragment()
 			if(quest != null) showQuestDetails(quest, questGroup);
 		};
 
-		AbstractBottomSheetFragment f = getBottomSheetFragment();
+		IsCloseableBottomSheet f = getBottomSheetFragment();
 		if (f != null)  f.onClickClose(retrieveQuest);
 		else            retrieveQuest.run();
 	}
 
-	@Override public void onClickedMapAt(@Nullable LatLon position)
+	@Override public void onClickedMapAt(LatLon position, double horizontalAccuracyInMeters)
 	{
-		AbstractBottomSheetFragment f = getBottomSheetFragment();
+		IsCloseableBottomSheet f = getBottomSheetFragment();
 		if(f != null)
 		{
-			f.onClickClose(this::closeBottomSheet);
+			if(!f.onClickMapAt(position, horizontalAccuracyInMeters))
+				f.onClickClose(this::closeBottomSheet);
 		}
 	}
 
-	/* ---------- Location listener ---------- */
+	/* ------------------------------------ Location listener ----------------------------------- */
 
 	private void updateLocationAvailability()
 	{
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/OsmModule.java b/app/src/main/java/de/westnordost/streetcomplete/data/OsmModule.java
index bd7ee37f133..ecdee6d4572 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/OsmModule.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/OsmModule.java
@@ -20,7 +20,7 @@
 import de.westnordost.streetcomplete.data.osm.persist.ElementGeometryDao;
 import de.westnordost.streetcomplete.data.osm.persist.MergedElementDao;
 import de.westnordost.streetcomplete.data.osm.persist.OsmQuestDao;
-import de.westnordost.streetcomplete.data.osm.persist.SplitWayDao;
+import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayDao;
 import de.westnordost.streetcomplete.data.osm.persist.UndoOsmQuestDao;
 import de.westnordost.streetcomplete.data.osm.upload.OpenQuestChangesetsManager;
 import de.westnordost.streetcomplete.data.osm.upload.OsmQuestsUpload;
@@ -148,7 +148,7 @@ statisticsDB, new ElementGeometryCreator(wayGeometrySource), questDB,
 		MergedElementDao elementDB, ElementGeometryDao elementGeometryDB,
 		OpenQuestChangesetsManager changesetManager, OsmQuestGiver questGiver,
 		QuestStatisticsDao statisticsDB, OsmApiWayGeometrySource wayGeometrySource,
-		SplitWayDao questDB, SplitSingleWayUpload singleUpload) {
+		OsmQuestSplitWayDao questDB, SplitSingleWayUpload singleUpload) {
 		return new SplitWaysUpload(elementDB, elementGeometryDB, changesetManager, questGiver,
 			statisticsDB, new ElementGeometryCreator(wayGeometrySource), questDB, singleUpload);
 	}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/QuestController.java b/app/src/main/java/de/westnordost/streetcomplete/data/QuestController.java
index c65cad3a9a5..c45904fa891 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/QuestController.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/QuestController.java
@@ -8,6 +8,8 @@
 import android.os.Handler;
 import android.os.HandlerThread;
 import android.os.IBinder;
+
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import android.util.Log;
 
@@ -24,12 +26,15 @@
 import de.westnordost.streetcomplete.data.changesets.OpenChangesetsDao;
 import de.westnordost.streetcomplete.data.download.QuestDownloadService;
 import de.westnordost.streetcomplete.data.osm.OsmQuest;
+import de.westnordost.streetcomplete.data.osm.OsmQuestSplitWay;
 import de.westnordost.streetcomplete.data.osm.UndoOsmQuest;
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition;
 import de.westnordost.streetcomplete.data.osm.changes.StringMapChanges;
 import de.westnordost.streetcomplete.data.osm.changes.StringMapChangesBuilder;
 import de.westnordost.streetcomplete.data.osm.persist.ElementGeometryDao;
 import de.westnordost.streetcomplete.data.osm.persist.MergedElementDao;
 import de.westnordost.streetcomplete.data.osm.persist.OsmQuestDao;
+import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayDao;
 import de.westnordost.streetcomplete.data.osm.persist.UndoOsmQuestDao;
 import de.westnordost.streetcomplete.data.osmnotes.CreateNote;
 import de.westnordost.streetcomplete.data.osmnotes.CreateNoteDao;
@@ -52,6 +57,7 @@ public class QuestController
 	private final MergedElementDao osmElementDB;
 	private final ElementGeometryDao geometryDB;
 	private final OsmNoteQuestDao osmNoteQuestDB;
+	private final OsmQuestSplitWayDao splitWayDB;
 	private final CreateNoteDao createNoteDB;
 	private final OpenChangesetsDao openChangesetsDao;
 	private final Context context;
@@ -94,8 +100,8 @@ public void onServiceDisconnected(ComponentName className)
 
 	@Inject public QuestController(OsmQuestDao osmQuestDB, UndoOsmQuestDao undoOsmQuestDB,
 								   MergedElementDao osmElementDB, ElementGeometryDao geometryDB,
-								   OsmNoteQuestDao osmNoteQuestDB, CreateNoteDao createNoteDB,
-								   OpenChangesetsDao openChangesetsDao,
+								   OsmNoteQuestDao osmNoteQuestDB, OsmQuestSplitWayDao splitWayDB,
+								   CreateNoteDao createNoteDB, OpenChangesetsDao openChangesetsDao,
 								   Provider<List<QuestType>> questTypesProvider, Context context)
 	{
 		this.osmQuestDB = osmQuestDB;
@@ -103,6 +109,7 @@ public void onServiceDisconnected(ComponentName className)
 		this.osmElementDB = osmElementDB;
 		this.geometryDB = geometryDB;
 		this.osmNoteQuestDB = osmNoteQuestDB;
+		this.splitWayDB = splitWayDB;
 		this.createNoteDB = createNoteDB;
 		this.openChangesetsDao = openChangesetsDao;
 		this.questTypesProvider = questTypesProvider;
@@ -166,8 +173,24 @@ public boolean createNote(long osmQuestId, String questTitle, String text, @Null
 		   creation for other users, so those quests should be removed from the user's
 		   own display as well. As soon as the note is resolved, the quests will be re-
 		   created next time they are downloaded */
+		removeQuestsForElement(q.getElementType(), q.getElementId());
+		return true;
+	}
+
+	public void createNote(String text, @Nullable List<String> imagePaths, LatLon position)
+	{
+		CreateNote createNote = new CreateNote();
+		createNote.position = position;
+		createNote.text = text;
+		createNote.imagePaths = imagePaths;
+		createNoteDB.add(createNote);
+	}
+
+	private void removeQuestsForElement(Element.Type elementType, long elementId) {
+
+		// TODO actually there should be a method in OsmQuestDB: deleteAllForElement or similar
 		List<OsmQuest> questsForThisOsmElement = osmQuestDB.getAll(null, QuestStatus.NEW, null,
-				q.getElementType(), q.getElementId());
+			elementType, elementId);
 		List<Long> questIdsForThisOsmElement = new ArrayList<>(questsForThisOsmElement.size());
 		for(OsmQuest quest : questsForThisOsmElement)
 		{
@@ -179,16 +202,26 @@ public boolean createNote(long osmQuestId, String questTitle, String text, @Null
 
 		osmElementDB.deleteUnreferenced();
 		geometryDB.deleteUnreferenced();
-		return true;
 	}
 
-	public void createNote(String text, @Nullable List<String> imagePaths, LatLon position)
+	/** Split a way for the given OSM Quest. The quest will turn invisible.
+	 *  @return true if successful */
+	public boolean splitWay(long osmQuestId, @NonNull List<? extends SplitPolylineAtPosition> splits, @NonNull String source)
 	{
-		CreateNote createNote = new CreateNote();
-		createNote.position = position;
-		createNote.text = text;
-		createNote.imagePaths = imagePaths;
-		createNoteDB.add(createNote);
+		OsmQuest q = osmQuestDB.get(osmQuestId);
+		// race condition: another thread may have removed the element already (#288)
+		if(q == null || q.getStatus() != QuestStatus.NEW) return false;
+
+		splitWayDB.put(new OsmQuestSplitWay(
+			osmQuestId,
+			q.getOsmElementQuestType(),
+			q.getElementId(),
+			source,
+			splits
+		));
+
+		removeQuestsForElement(q.getElementType(), q.getElementId());
+		return true;
 	}
 
 	/** Apply the user's answer to the given quest. (The quest will turn invisible.)
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/OsmQuestSplitWay.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/OsmQuestSplitWay.kt
index e707c729889..16bc0a55df4 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/OsmQuestSplitWay.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/OsmQuestSplitWay.kt
@@ -1,7 +1,7 @@
 package de.westnordost.streetcomplete.data.osm
 
 import de.westnordost.osmapi.map.data.Element
-import de.westnordost.streetcomplete.data.osm.changes.SplitWay
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition
 import de.westnordost.streetcomplete.data.osm.upload.UploadableInChangeset
 
 data class OsmQuestSplitWay(
@@ -9,7 +9,7 @@ data class OsmQuestSplitWay(
     val questType: OsmElementQuestType<*>,
     val wayId: Long,
     override val source: String,
-    val splits: List<SplitWay>) : UploadableInChangeset {
+    val splits: List<SplitPolylineAtPosition>) : UploadableInChangeset {
 
     override val osmElementQuestType get() = questType
     override val elementType get() = Element.Type.WAY
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/changes/SplitPolylineAtPosition.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/changes/SplitPolylineAtPosition.kt
new file mode 100644
index 00000000000..d3a99458355
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/changes/SplitPolylineAtPosition.kt
@@ -0,0 +1,23 @@
+package de.westnordost.streetcomplete.data.osm.changes
+
+import de.westnordost.osmapi.map.data.LatLon
+import de.westnordost.osmapi.map.data.OsmLatLon
+import de.westnordost.streetcomplete.util.SphericalEarthMath.distance
+import de.westnordost.streetcomplete.util.SphericalEarthMath.pointOnPolylineFromStart
+
+sealed class SplitPolylineAtPosition {
+    abstract val pos: LatLon
+}
+
+data class SplitAtPoint(override val pos: OsmLatLon) : SplitPolylineAtPosition()
+
+data class SplitAtLinePosition(val pos1: OsmLatLon, val pos2: OsmLatLon, val delta: Double) : SplitPolylineAtPosition() {
+    override val pos: LatLon get() {
+        val line = listOf(pos1, pos2)
+        return pointOnPolylineFromStart(line, distance(line) * delta)!!
+    }
+    init {
+        if(delta <= 0 || delta >= 1)
+            throw IllegalArgumentException("Delta must be between 0 and 1 (both exclusive)")
+    }
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/changes/SplitWay.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/changes/SplitWay.kt
deleted file mode 100644
index 437fd141fd5..00000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/changes/SplitWay.kt
+++ /dev/null
@@ -1,31 +0,0 @@
-package de.westnordost.streetcomplete.data.osm.changes
-
-import de.westnordost.osmapi.map.data.Node
-import de.westnordost.osmapi.map.data.Way
-
-/** data class that carries the information for one split to perform on a random position on a way. */
-class SplitWay(val firstNode: Node, val secondNode: Node, val delta: Double) {
-
-    constructor(way: Way, firstNode: Node, secondNode: Node, delta: Double)
-            : this(firstNode, secondNode, delta) { validate(way) }
-
-    fun validate(way: Way) {
-        if(delta < 0 || delta >= 1)
-            throw IllegalArgumentException("Delta must be between 0 (inclusive) and 1 (exclusive)")
-
-        if(delta == 0.0 && firstNode.id == way.nodeIds.first())
-            throw IllegalArgumentException("Cannot split a way at its very start")
-
-        val firstNodeIndex = way.nodeIds.indexOf(firstNode.id)
-        if (firstNodeIndex == -1)
-            throw IllegalArgumentException("Way #${way.id} does not contain node #${firstNode.id}")
-
-        val secondNodeIndex = way.nodeIds.indexOf(secondNode.id)
-        if (secondNodeIndex == -1)
-            throw IllegalArgumentException("Way #${way.id} does not contain node #${secondNode.id}")
-
-        if (firstNodeIndex + 1 != secondNodeIndex)
-            throw IllegalArgumentException("The position of the second node #${secondNode.id} is not exactly one after the first node #${firstNode.id} in way #${way.id}")
-    }
-}
-
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDao.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDao.kt
index 0f818b509a4..9a509add1b0 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDao.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/persist/OsmQuestSplitWayDao.kt
@@ -3,11 +3,10 @@ package de.westnordost.streetcomplete.data.osm.persist
 import android.content.ContentValues
 import android.database.Cursor
 import android.database.sqlite.SQLiteOpenHelper
-import de.westnordost.osmapi.map.data.*
 import de.westnordost.streetcomplete.data.QuestTypeRegistry
 import de.westnordost.streetcomplete.data.osm.OsmElementQuestType
 import de.westnordost.streetcomplete.data.osm.OsmQuestSplitWay
-import de.westnordost.streetcomplete.data.osm.changes.SplitWay
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition
 import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayTable.NAME
 import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayTable.Columns.QUEST_ID
 import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayTable.Columns.QUEST_TYPE
@@ -19,7 +18,7 @@ import de.westnordost.streetcomplete.util.Serializer
 import javax.inject.Inject
 import kotlin.collections.ArrayList
 
-class SplitWayDao @Inject constructor(
+class OsmQuestSplitWayDao @Inject constructor(
     private val dbHelper: SQLiteOpenHelper,
     private val serializer: Serializer,
     private val questTypeList: QuestTypeRegistry
@@ -30,12 +29,20 @@ class SplitWayDao @Inject constructor(
         }
     }
 
+    fun get(id: Long): OsmQuestSplitWay? {
+        val selection = "$QUEST_ID = ?"
+        val args = arrayOf(id.toString())
+        return dbHelper.readableDatabase.queryOne(NAME, null, selection, args).use { cursor ->
+            return cursor.createOsmQuestSplitWay()
+        }
+    }
+
     fun put(quest: OsmQuestSplitWay) {
         dbHelper.writableDatabase.insert(NAME, null, quest.createContentValues())
     }
 
-    fun delete(id: Long): Int {
-        return dbHelper.writableDatabase.delete(NAME, "$QUEST_ID = $id", null)
+    fun delete(id: Long) {
+        dbHelper.writableDatabase.delete(NAME, "$QUEST_ID = $id", null)
     }
 
     private fun OsmQuestSplitWay.createContentValues() = ContentValues().also { v ->
@@ -43,7 +50,7 @@ class SplitWayDao @Inject constructor(
         v.put(QUEST_TYPE, questType.javaClass.simpleName)
         v.put(WAY_ID, wayId)
         v.put(SOURCE, source)
-        v.put(SPLITS, serializer.toBytes(ArrayList(splits.map { it.toData() })))
+        v.put(SPLITS, serializer.toBytes(ArrayList(splits)))
     }
 
     private fun Cursor.createOsmQuestSplitWay() = OsmQuestSplitWay(
@@ -51,21 +58,6 @@ class SplitWayDao @Inject constructor(
         questTypeList.getByName(getString(QUEST_TYPE)) as OsmElementQuestType<*>,
         getLong(WAY_ID),
         getString(SOURCE),
-        (serializer.toObject(getBlob(SPLITS)) as List<SplitWayData>).map { it.toSplitWay() }
+        (serializer.toObject(getBlob(SPLITS)) as ArrayList<SplitPolylineAtPosition>)
     )
 }
-
-private fun SplitWay.toData() = SplitWayData(
-    firstNode.id, firstNode.version, firstNode.position.latitude, firstNode.position.longitude,
-    secondNode.id, secondNode.version, secondNode.position.latitude, secondNode.position.longitude,
-    delta)
-
-private fun SplitWayData.toSplitWay() = SplitWay(
-    OsmNode(firstId, firstVersion, firstLat, firstLon, null),
-    OsmNode(secondId, secondVersion, secondLat, secondLon, null),
-    delta)
-
-data class SplitWayData(
-    val firstId: Long, val firstVersion: Int, val firstLat: Double, val firstLon: Double,
-    val secondId: Long, val secondVersion: Int, val secondLat: Double, val secondLon: Double,
-    val delta: Double)
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUpload.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUpload.kt
index b83b837d59c..4ea02a45b9d 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUpload.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUpload.kt
@@ -3,61 +3,49 @@ package de.westnordost.streetcomplete.data.osm.upload
 import de.westnordost.osmapi.common.errors.OsmConflictException
 import de.westnordost.osmapi.map.MapDataDao
 import de.westnordost.osmapi.map.data.*
-import de.westnordost.streetcomplete.util.SphericalEarthMath
 import javax.inject.Inject
 import de.westnordost.osmapi.map.data.Element.Type.*
-import de.westnordost.streetcomplete.data.osm.changes.SplitWay
-import de.westnordost.streetcomplete.ktx.containsAny
-import de.westnordost.streetcomplete.ktx.findNext
-import de.westnordost.streetcomplete.ktx.findPrevious
-import de.westnordost.streetcomplete.ktx.firstAndLast
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtLinePosition
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtPoint
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition
+import de.westnordost.streetcomplete.ktx.*
+import de.westnordost.streetcomplete.util.SphericalEarthMath
+import kotlin.math.sign
 
 /** Uploads one split way
  *  Returns only the ways that have been updated or throws a ConflictException */
 class SplitSingleWayUpload @Inject constructor(private val osmDao: MapDataDao)  {
 
-    fun upload(changesetId: Long, way: Way, splits: List<SplitWay>): List<Way> {
-        if(way.isClosed() && splits.size < 2)
-            throw IllegalArgumentException("Must specify at least two split positions for a closed way")
-
+    fun upload(changesetId: Long, way: Way, splits: List<SplitPolylineAtPosition>): List<Way> {
         val updatedWay = way.fetchUpdated()
             ?: throw ElementDeletedException("Way #${way.id} has been deleted")
+        if(updatedWay.isClosed() && splits.size < 2)
+            throw ElementConflictException("Must specify at least two split positions for a closed way")
         checkForConflicts(way, updatedWay)
-        try {
-            for (split in splits) split.validate(updatedWay)
-        } catch (e: IllegalArgumentException) {
-            throw ElementConflictException(e.message)
-        }
-        val sortedSplits = splits.sortedWith(SplitWayAtComparator(updatedWay))
+
+        val nodes = updatedWay.fetchNodes()
+        val positions = nodes.map { it.position }
+        val sortedSplits = splits.map { it.toSplitWay(positions) }.sorted()
 
         val uploadElements = mutableListOf<Element>()
         var newNodeId = -1L
 
         val splitAtIndices = mutableListOf<Int>()
+        var insertedNodeCount = 0
         for (split in sortedSplits) {
-            val updatedFirstNode = split.firstNode.fetchUpdated()
-                ?: throw ElementConflictException("Node #${split.firstNode.id} has been deleted")
-            checkForConflicts(split.firstNode, updatedFirstNode)
-            val updatedSecondNode = split.secondNode.fetchUpdated()
-                ?: throw ElementConflictException("Node #${split.secondNode.id} has been deleted")
-            checkForConflicts(split.secondNode, updatedSecondNode)
-
-            if (split.delta == 0.0) {
-                val firstNodeIndex = updatedWay.nodeIds.indexOf(updatedFirstNode.id)
-                splitAtIndices.add(firstNodeIndex)
-            } else if (split.delta > 0.0) {
-                val splitPosition =
-                    createSplitPosition(
-                        updatedFirstNode.position,
-                        updatedSecondNode.position,
-                        split.delta
-                    )
-                val splitNode = OsmNode(newNodeId--, 1, splitPosition, null)
-                uploadElements.add(splitNode)
-
-                val secondNodeIndex = updatedWay.nodeIds.indexOf(updatedSecondNode.id)
-                updatedWay.nodeIds.add(secondNodeIndex, splitNode.id)
-                splitAtIndices.add(secondNodeIndex)
+            when(split) {
+                is SplitWayAtPoint -> {
+                    splitAtIndices.add(split.index + insertedNodeCount)
+                }
+                is SplitWayAtLinePosition -> {
+                    val splitNode = OsmNode(newNodeId--, 1, split.pos, null)
+                    uploadElements.add(splitNode)
+
+                    val nodeIndex = split.index2 + insertedNodeCount
+                    updatedWay.nodeIds.add(nodeIndex, splitNode.id)
+                    splitAtIndices.add(nodeIndex)
+                    ++insertedNodeCount
+                }
             }
         }
 
@@ -79,14 +67,6 @@ class SplitSingleWayUpload @Inject constructor(private val osmDao: MapDataDao)
         }
     }
 
-    private fun checkForConflicts(old: Node, new: Node) {
-        if(old.version != new.version) {
-            // unsolvable conflict if node has been moved
-            if(old.position.latitude != new.position.latitude || old.position.longitude != new.position.longitude)
-                throw ElementConflictException("Node #${old.id} has been moved and the conflict cannot be solved automatically")
-        }
-    }
-
     private fun splitWayAtIndices(originalWay: Way, splitIndices: List<Int>): List<Element> {
         val newWays = createSplitWays(originalWay, splitIndices)
         val updatedRelations = updateRelations(originalWay, newWays)
@@ -170,7 +150,7 @@ class SplitSingleWayUpload @Inject constructor(private val osmDao: MapDataDao)
         relation.members.addAll(indexOfWayInRelation, newRelationMembers)
     }
 
-    private fun Node.fetchUpdated(): Node? = osmDao.getNode(id)
+    private fun Way.fetchNodes(): List<Node> = osmDao.getNodes(nodeIds)
 
     private fun Way.fetchUpdated(): Way? = osmDao.getWay(id)
 
@@ -205,42 +185,89 @@ class SplitSingleWayUpload @Inject constructor(private val osmDao: MapDataDao)
     }
 }
 
-/** comparator that sorts all the splits from start to end in the way */
-private class SplitWayAtComparator(private val way: Way) : Comparator<SplitWay> {
-    override fun compare(split1: SplitWay, split2: SplitWay): Int {
-        val split1Index = way.nodeIds.indexOf(split1.secondNode.id)
-        val split2Index = way.nodeIds.indexOf(split2.secondNode.id)
-        val diffIndex = split1Index - split2Index
+/** data class that carries the information for one split to perform on a random position on a way.
+ *  So, same as SplitPolylineAtPosition, but additionally with the index of the split in the way. */
+private sealed class SplitWay : Comparable<SplitWay> {
+    abstract val pos: LatLon
+    protected abstract val index: Int
+    protected abstract val delta: Double
+
+    /** sort by index, then delta, ascending. The algorithm relies on this order! */
+    override fun compareTo(other: SplitWay): Int {
+        val diffIndex = index - other.index
         if (diffIndex != 0) return diffIndex
 
-        val diffDelta = split1.delta - split2.delta
-        return if (diffDelta < 0) -1 else if (diffDelta > 0) 1 else 0
+        val diffDelta = delta - other.delta
+        return diffDelta.sign.toInt()
     }
 }
 
-private fun createSplitPosition(firstPosition: LatLon, secondPosition: LatLon, delta: Double): LatLon {
-    val line = listOf(firstPosition, secondPosition)
-    return SphericalEarthMath.pointOnPolylineFromStart(line, SphericalEarthMath.distance(line) * delta)
+private data class SplitWayAtPoint(override val pos: LatLon, public override val index: Int) : SplitWay() {
+    override val delta get() = 0.0
 }
 
-/** returns the index of the first element yielding the largest value of the given function or -1 if there are no elements. */
-private inline fun <T, R : Comparable<R>> Iterable<T>.indexOfMaxBy(selector: (T) -> R): Int {
-    val iterator = iterator()
-    if (!iterator.hasNext()) return -1
-    var indexOfMaxElem = 0
-    var i = 0
-    var maxValue = selector(iterator.next())
-    while (iterator.hasNext()) {
-        ++i
-        val v = selector(iterator.next())
-        if (maxValue < v) {
-            indexOfMaxElem = i
-            maxValue = v
+private data class SplitWayAtLinePosition(
+    val pos1: LatLon, val index1: Int,
+    val pos2: LatLon, val index2: Int,
+    public override val delta: Double) : SplitWay() {
+    override val index get() = index1
+    override val pos: LatLon get() {
+        val line = listOf(pos1, pos2)
+        return SphericalEarthMath.pointOnPolylineFromStart(
+            line,
+            SphericalEarthMath.distance(line) * delta
+        )!!
+    }
+}
+
+/** creates a SplitWay from a SplitLineAtPosition, given the nodes of the way. So, basically it
+ *  simply finds the node index/indices at which the split should be made.
+ *  If the way changed significantly in the meantime, it will throw an ElementConflictException */
+private fun SplitPolylineAtPosition.toSplitWay(positions: List<LatLon>): SplitWay {
+    return when(this) {
+        is SplitAtPoint -> toSplitWay(positions)
+        is SplitAtLinePosition -> toSplitWay(positions)
+    }
+}
+
+private fun SplitAtPoint.toSplitWay(positions: List<LatLon>): SplitWayAtPoint {
+    // could be several indices, for example if the way has the shape of an 8.
+    var indicesOf = positions.osmIndicesOf(pos)
+    if (indicesOf.isEmpty()) throw ElementConflictException("To be split point has been moved")
+
+    indicesOf = indicesOf.filter { index -> index > 0 && index < positions.lastIndex }
+    if (indicesOf.isEmpty())
+        throw ElementConflictException("Split position is now at the very start or end of the way - can't split there")
+
+    return SplitWayAtPoint(pos, indicesOf.first())
+}
+
+private fun SplitAtLinePosition.toSplitWay(positions: List<LatLon>): SplitWayAtLinePosition {
+    // could be several indices, for example if the way has the shape of an 8...
+    val indicesOf1 = positions.osmIndicesOf(pos1)
+    if (indicesOf1.isEmpty()) throw ElementConflictException("To be split line has been moved")
+
+    val indicesOf2 = positions.osmIndicesOf(pos2)
+    if (indicesOf2.isEmpty()) throw ElementConflictException("To be split line has been moved")
+
+    // ...and we need to find out which of the lines is meant
+    for (i1 in indicesOf1) {
+        for (i2 in indicesOf2) {
+            /* For SplitAtLinePosition, the direction of the way does not matter. But for the
+               SplitWayAtLinePosition it must be in the same order as the OSM way. */
+            if (i1 + 1 == i2) return SplitWayAtLinePosition(pos1, i1, pos2, i2, delta)
+            if (i2 + 1 == i1) return SplitWayAtLinePosition(pos2, i2, pos1, i1, 1.0 - delta)
         }
     }
-    return indexOfMaxElem
+    throw ElementConflictException("End points of the to be split line are not directly successive anymore")
 }
 
+/** returns the indices at which the given pos is found in this list, taking into accound the limited
+ *  precision of positions in OSM. */
+private fun List<LatLon>.osmIndicesOf(pos: LatLon): List<Int> =
+    mapIndexedNotNull { i, p -> if (p.equalsInOsm(pos)) i else null }
+
+
 /** returns a copy of the list split at the given indices with each chunk sharing each the first and last element */
 private fun <E> List<E>.splitIntoChunks(indices: List<Int>): MutableList<MutableList<E>> {
     val result = mutableListOf<MutableList<E>>()
@@ -253,14 +280,12 @@ private fun <E> List<E>.splitIntoChunks(indices: List<Int>): MutableList<Mutable
     return result
 }
 
-private fun Way.isClosed() = nodeIds.size >= 3 && nodeIds.first() == nodeIds.last()
-
 /** returns whether this way immediately precedes the given way in a chain */
-private fun Way.isBeforeWayInChain(way:Way) =
+private fun Way.isBeforeWayInChain(way: Way) =
     nodeIds.last() == way.nodeIds.last() || nodeIds.last() == way.nodeIds.first()
 
 /** returns whether this way immediately follows the given way in a chain */
-private fun Way.isAfterWayInChain(way:Way) =
+private fun Way.isAfterWayInChain(way: Way) =
     nodeIds.first() == way.nodeIds.last() || nodeIds.first() == way.nodeIds.first()
 
 private fun Relation.findVia(relationType: String): RelationMember? {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUpload.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUpload.kt
index 6c697451381..1226d79efe0 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUpload.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUpload.kt
@@ -8,7 +8,7 @@ import de.westnordost.streetcomplete.data.osm.OsmQuestSplitWay
 import de.westnordost.streetcomplete.data.osm.download.ElementGeometryCreator
 import de.westnordost.streetcomplete.data.osm.persist.ElementGeometryDao
 import de.westnordost.streetcomplete.data.osm.persist.MergedElementDao
-import de.westnordost.streetcomplete.data.osm.persist.SplitWayDao
+import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayDao
 import de.westnordost.streetcomplete.data.statistics.QuestStatisticsDao
 import java.util.concurrent.atomic.AtomicBoolean
 import javax.inject.Inject
@@ -21,7 +21,7 @@ class SplitWaysUpload @Inject constructor(
     questGiver: OsmQuestGiver,
     statisticsDB: QuestStatisticsDao,
     elementGeometryCreator: ElementGeometryCreator,
-    private val splitWayDB: SplitWayDao,
+    private val splitWayDB: OsmQuestSplitWayDao,
     private val splitSingleOsmWayUpload: SplitSingleWayUpload
 ) : OsmInChangesetsUpload<OsmQuestSplitWay>(elementDB, elementGeometryDB, changesetManager,
     questGiver, statisticsDB, elementGeometryCreator) {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/AbstractCreateNoteFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/AbstractCreateNoteFragment.kt
index 4a2f971f87c..cea25c0e8d7 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/AbstractCreateNoteFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/AbstractCreateNoteFragment.kt
@@ -61,7 +61,7 @@ abstract class AbstractCreateNoteFragment : AbstractBottomSheetFragment() {
     }
 
     private fun onClickOk() {
-        onLeaveNote(noteText, attachPhotoFragment?.imagePaths)
+        onComposedNote(noteText, attachPhotoFragment?.imagePaths)
     }
 
     override fun onDiscard() {
@@ -75,5 +75,5 @@ abstract class AbstractCreateNoteFragment : AbstractBottomSheetFragment() {
         doneButton.isEnabled = !noteText.isEmpty()
     }
 
-    protected abstract fun onLeaveNote(text: String, imagePaths: List<String>?)
+    protected abstract fun onComposedNote(text: String, imagePaths: List<String>?)
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteFragment.kt
index f2104c357d3..1e7ad91c3a7 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteFragment.kt
@@ -1,6 +1,5 @@
 package de.westnordost.streetcomplete.data.osmnotes
 
-import android.content.Context
 import android.content.res.Configuration
 import android.graphics.Point
 import android.os.Bundle
@@ -21,9 +20,12 @@ import kotlinx.android.synthetic.main.marker_create_note.*
 
 class CreateNoteFragment : AbstractCreateNoteFragment() {
 
-    override val layoutResId = R.layout.fragment_create_note
+    interface Listener {
+        /** Called when the user wants to leave a note which is not related to a quest  */
+        fun onCreatedNote(note: String, imagePaths: List<String>?, screenPosition: Point)
+    }
 
-    private lateinit var callbackListener: CreateNoteListener
+    override val layoutResId = R.layout.fragment_create_note
 
     override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
         super.onViewCreated(view, savedInstanceState)
@@ -63,17 +65,12 @@ class CreateNoteFragment : AbstractCreateNoteFragment() {
         return a
     }
 
-    override fun onAttach(context: Context) {
-        super.onAttach(context)
-        callbackListener = context as CreateNoteListener
-    }
-
     override fun onDiscard() {
         super.onDiscard()
         markerLayoutContainer?.visibility = View.INVISIBLE
     }
 
-    override fun onLeaveNote(text: String, imagePaths: List<String>?) {
+    override fun onComposedNote(text: String, imagePaths: List<String>?) {
         if (closeKeyboard()) return
 
         val point = IntArray(2)
@@ -83,7 +80,7 @@ class CreateNoteFragment : AbstractCreateNoteFragment() {
 
         markerLayoutContainer?.visibility = View.INVISIBLE
 
-        callbackListener.onLeaveNote(text, imagePaths, screenPos)
+        (activity as Listener).onCreatedNote(text, imagePaths, screenPos)
     }
 
     private fun closeKeyboard(): Boolean {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteListener.java b/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteListener.java
deleted file mode 100644
index c993873d546..00000000000
--- a/app/src/main/java/de/westnordost/streetcomplete/data/osmnotes/CreateNoteListener.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package de.westnordost.streetcomplete.data.osmnotes;
-
-import android.graphics.Point;
-import androidx.annotation.Nullable;
-
-import java.util.List;
-
-public interface CreateNoteListener
-{
-	/** Called when the user wants to leave a note which is not related to a quest */
-	void onLeaveNote(String note, @Nullable List<String> imagePaths, Point screenPosition);
-}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ktx/Collections.kt b/app/src/main/java/de/westnordost/streetcomplete/ktx/Collections.kt
index 41b6ca9d32e..a4ca8a0a4a2 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/ktx/Collections.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/ktx/Collections.kt
@@ -31,3 +31,34 @@ inline fun <T> List<T>.findNext(index: Int, predicate: (T) -> Boolean): T? {
     }
     return null
 }
+
+/** Iterate through the given list in pairs */
+inline fun <T> Iterable<T>.forEachPair(predicate: (first: T, second: T) -> Unit) {
+    val it = iterator()
+    if (!it.hasNext()) return
+    var item1 = it.next()
+    while (it.hasNext()) {
+        val item2 = it.next()
+        predicate(item1, item2)
+        item1 = item2
+    }
+}
+
+/** returns the index of the first element yielding the largest value of the given function or -1
+ *  if there are no elements. Analogous to the maxBy extension function. */
+inline fun <T, R : Comparable<R>> Iterable<T>.indexOfMaxBy(selector: (T) -> R): Int {
+    val iterator = iterator()
+    if (!iterator.hasNext()) return -1
+    var indexOfMaxElem = 0
+    var i = 0
+    var maxValue = selector(iterator.next())
+    while (iterator.hasNext()) {
+        ++i
+        val v = selector(iterator.next())
+        if (maxValue < v) {
+            indexOfMaxElem = i
+            maxValue = v
+        }
+    }
+    return indexOfMaxElem
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ktx/Element.kt b/app/src/main/java/de/westnordost/streetcomplete/ktx/Element.kt
index 7dff40473dc..8b9715e1cb8 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/ktx/Element.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/ktx/Element.kt
@@ -12,3 +12,5 @@ fun Element.copy(newId: Long = id, newVersion: Int = version): Element {
         else -> throw RuntimeException()
     }
 }
+
+fun Way.isClosed() = nodeIds.size >= 3 && nodeIds.first() == nodeIds.last()
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ktx/LatLon.kt b/app/src/main/java/de/westnordost/streetcomplete/ktx/LatLon.kt
new file mode 100644
index 00000000000..397468ca740
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/ktx/LatLon.kt
@@ -0,0 +1,11 @@
+package de.westnordost.streetcomplete.ktx
+
+import de.westnordost.osmapi.map.data.LatLon
+import kotlin.math.abs
+
+/** OSM has limited precision of 7 decimals */
+fun LatLon.equalsInOsm(other: LatLon) =
+    !latitude.isDifferent(other.latitude, 1e-7) &&
+    !longitude.isDifferent(other.longitude, 1e-7)
+
+private fun Double.isDifferent(other: Double, delta: Double) = abs(this - other) > delta
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt b/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt
index 14aab2f2ff6..9883f51f885 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/ktx/SQLiteDatabase.kt
@@ -1,6 +1,5 @@
 package de.westnordost.streetcomplete.ktx
 
-import android.database.Cursor
 import android.database.sqlite.SQLiteDatabase
 
 /**
diff --git a/app/src/main/java/de/westnordost/streetcomplete/ktx/View.kt b/app/src/main/java/de/westnordost/streetcomplete/ktx/View.kt
new file mode 100644
index 00000000000..e9c70a6379a
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/ktx/View.kt
@@ -0,0 +1,22 @@
+package de.westnordost.streetcomplete.ktx
+
+import android.view.View
+import android.view.animation.AccelerateInterpolator
+import android.view.animation.DecelerateInterpolator
+
+fun View.popIn() {
+    visibility = View.VISIBLE
+    animate()
+        .alpha(1f).scaleX(1f).scaleY(1f)
+        .setDuration(100)
+        .setInterpolator(DecelerateInterpolator())
+        .withEndAction(null)
+}
+
+fun View.popOut() {
+    animate()
+        .alpha(0f).scaleX(0.5f).scaleY(0.5f)
+        .setDuration(100)
+        .setInterpolator(AccelerateInterpolator())
+        .withEndAction { visibility = View.GONE }
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractBottomSheetFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractBottomSheetFragment.kt
index 60f456cb30b..fe2e2aef089 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractBottomSheetFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractBottomSheetFragment.kt
@@ -19,8 +19,9 @@ import de.westnordost.streetcomplete.R
 
 import com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_COLLAPSED
 import com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_EXPANDED
+import de.westnordost.osmapi.map.data.LatLon
 
-abstract class AbstractBottomSheetFragment : Fragment() {
+abstract class AbstractBottomSheetFragment : Fragment(), IsCloseableBottomSheet {
     private lateinit var bottomSheet: LinearLayout
     private lateinit var bottomSheetBehavior: BottomSheetBehavior<*>
     private lateinit var closeButton: View
@@ -36,7 +37,7 @@ abstract class AbstractBottomSheetFragment : Fragment() {
         }
 
         closeButton = view.findViewById(R.id.closeButton)
-        closeButton.setOnClickListener { activity!!.onBackPressed() }
+        closeButton.setOnClickListener { activity?.onBackPressed() }
 
         bottomSheetBehavior = BottomSheetBehavior.from(bottomSheet)
 
@@ -88,9 +89,7 @@ abstract class AbstractBottomSheetFragment : Fragment() {
         bottomSheetBehavior.peekHeight = resources.getDimensionPixelSize(R.dimen.quest_form_peekHeight)
         view?.findViewById<View>(R.id.bottomSheetContainer)?.let {
 	        it.setBackgroundResource(R.drawable.speechbubbles_gradient_background)
-	        it.updateLayoutParams {
-		        width = resources.getDimensionPixelSize(R.dimen.quest_form_width)
-	        }
+	        it.updateLayoutParams { width = resources.getDimensionPixelSize(R.dimen.quest_form_width) }
         }
     }
 
@@ -104,9 +103,13 @@ abstract class AbstractBottomSheetFragment : Fragment() {
 	    closeButton.visibility = if (coversToolbar) View.VISIBLE else View.INVISIBLE
     }
 
+    @UiThread override fun onClickMapAt(position: LatLon, horizontalAccuracyInMeters: Double): Boolean {
+        return false
+    }
+
     /** Request to close the form through user interaction (back button, clicked other quest,..),
      * requires user confirmation if any changes have been made  */
-    @UiThread fun onClickClose(onConfirmed: Runnable) {
+    @UiThread override fun onClickClose(onConfirmed: Runnable) {
         if (!isRejectingClose()) {
             onDiscard()
             onConfirmed.run()
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestAnswerFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestAnswerFragment.kt
index e10883f4043..56d4e7b9166 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestAnswerFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestAnswerFragment.kt
@@ -220,7 +220,7 @@ abstract class AbstractQuestAnswerFragment<T> : AbstractBottomSheetFragment() {
     }
 
     protected fun onClickCantSay() {
-        AlertDialog.Builder(context!!)
+        context?.let { AlertDialog.Builder(it)
             .setTitle(R.string.quest_leave_new_note_title)
             .setMessage(R.string.quest_leave_new_note_description)
             .setNegativeButton(R.string.quest_leave_new_note_no) { _, _ -> skipQuest() }
@@ -229,10 +229,25 @@ abstract class AbstractQuestAnswerFragment<T> : AbstractBottomSheetFragment() {
                 questAnswerComponent.onComposeNote(questTitle)
             }
             .show()
+        }
+    }
+
+    protected fun createSplitWayAnswer() =
+        OtherAnswer(R.string.quest_generic_answer_differs_along_the_way) { onClickSplitWayAnswer() }
+
+    private fun onClickSplitWayAnswer() {
+        context?.let { AlertDialog.Builder(it)
+            .setMessage(R.string.quest_split_way_description)
+            .setNegativeButton(android.R.string.cancel, null)
+            .setPositiveButton(android.R.string.ok) { _, _ ->
+                questAnswerComponent.onSplitWay()
+            }
+            .show()
+        }
     }
 
     protected fun applyAnswer(data: T) {
-        questAnswerComponent.onAnswerQuest(data as Any)
+        questAnswerComponent.onAnsweredQuest(data as Any)
     }
 
     protected fun skipQuest() {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestFormAnswerFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestFormAnswerFragment.kt
index 6ede581908f..c5a65cc62e0 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestFormAnswerFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/AbstractQuestFormAnswerFragment.kt
@@ -2,10 +2,10 @@ package de.westnordost.streetcomplete.quests
 
 import android.os.Bundle
 import android.view.View
-import android.view.animation.AccelerateInterpolator
-import android.view.animation.DecelerateInterpolator
 
 import de.westnordost.streetcomplete.R
+import de.westnordost.streetcomplete.ktx.popIn
+import de.westnordost.streetcomplete.ktx.popOut
 import de.westnordost.streetcomplete.ktx.toast
 import kotlinx.android.synthetic.main.fragment_quest_answer.*
 
@@ -26,18 +26,9 @@ abstract class AbstractQuestFormAnswerFragment<T> : AbstractQuestAnswerFragment<
 
     protected fun checkIsFormComplete() {
         if (isFormComplete()) {
-            okButton.visibility = View.VISIBLE
-            okButton.animate()
-                .alpha(1f).scaleX(1f).scaleY(1f)
-                .setDuration(100)
-                .setInterpolator(DecelerateInterpolator())
-                .withEndAction(null)
+            okButton.popIn()
         } else {
-            okButton.animate()
-                .alpha(0f).scaleX(0.5f).scaleY(0.5f)
-                .setDuration(100)
-                .setInterpolator(AccelerateInterpolator())
-                .withEndAction { okButton?.visibility = View.GONE }
+            okButton.popOut()
         }
     }
 
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/IsCloseableBottomSheet.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/IsCloseableBottomSheet.kt
new file mode 100644
index 00000000000..1cfa97916c8
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/IsCloseableBottomSheet.kt
@@ -0,0 +1,9 @@
+package de.westnordost.streetcomplete.quests
+
+import de.westnordost.osmapi.map.data.LatLon
+
+interface IsCloseableBottomSheet {
+    /** Returns true if the bottom sheet shall consume the event */
+    fun onClickMapAt(position: LatLon, horizontalAccuracyInMeters: Double): Boolean
+    fun onClickClose(onConfirmed: Runnable)
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/LeaveNoteInsteadFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/LeaveNoteInsteadFragment.kt
index 681627fda5d..8284bdc69e5 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/LeaveNoteInsteadFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/LeaveNoteInsteadFragment.kt
@@ -1,25 +1,32 @@
 package de.westnordost.streetcomplete.quests
 
-import android.content.Context
 import android.os.Bundle
 import android.view.View
+import androidx.core.os.bundleOf
 
 import de.westnordost.streetcomplete.R
+import de.westnordost.streetcomplete.data.QuestGroup
 import de.westnordost.streetcomplete.data.osmnotes.AbstractCreateNoteFragment
 import kotlinx.android.synthetic.main.form_leave_note.*
 import kotlinx.android.synthetic.main.fragment_quest_answer.*
 
 class LeaveNoteInsteadFragment : AbstractCreateNoteFragment() {
 
+    interface Listener {
+        fun onCreatedNoteInstead(questId: Long, group: QuestGroup, questTitle: String, note: String, imagePaths: List<String>?)
+    }
+
     override val layoutResId = R.layout.fragment_quest_answer
 
-    private val questAnswerComponent: QuestAnswerComponent = QuestAnswerComponent()
     private lateinit var questTitle: String
+    private var questId: Long = 0L
+    private lateinit var questGroup: QuestGroup
 
     override fun onCreate(inState: Bundle?) {
         super.onCreate(inState)
-        questAnswerComponent.onCreate(arguments)
         questTitle = arguments!!.getString(ARG_QUEST_TITLE)!!
+        questId = arguments!!.getLong(ARG_QUEST_ID)
+        questGroup = QuestGroup.valueOf(arguments!!.getString(ARG_QUEST_GROUP)!!)
     }
 
     override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
@@ -29,16 +36,24 @@ class LeaveNoteInsteadFragment : AbstractCreateNoteFragment() {
         descriptionLabel.text = null
     }
 
-    override fun onAttach(context: Context) {
-        super.onAttach(context)
-        questAnswerComponent.onAttach(context as OsmQuestAnswerListener)
-    }
-
-    override fun onLeaveNote(text: String, imagePaths: List<String>?) {
-        questAnswerComponent.onLeaveNote(questTitle, text, imagePaths)
+    override fun onComposedNote(text: String, imagePaths: List<String>?) {
+        (activity as Listener).onCreatedNoteInstead(questId, questGroup, questTitle, text, imagePaths)
     }
 
     companion object {
-        const val ARG_QUEST_TITLE = "questTitle"
+        private const val ARG_QUEST_TITLE = "questTitle"
+        private const val ARG_QUEST_ID = "questId"
+        private const val ARG_QUEST_GROUP = "questGroup"
+
+        @JvmStatic
+        fun create(questId: Long, group: QuestGroup, questTitle: String): LeaveNoteInsteadFragment {
+            val f = LeaveNoteInsteadFragment()
+            f.arguments = bundleOf(
+                ARG_QUEST_GROUP to group.name,
+                ARG_QUEST_ID to questId,
+                ARG_QUEST_TITLE to questTitle
+            )
+            return f
+        }
     }
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/OsmQuestAnswerListener.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/OsmQuestAnswerListener.kt
index 65b2237c014..ec344951f54 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/OsmQuestAnswerListener.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/OsmQuestAnswerListener.kt
@@ -10,8 +10,8 @@ interface OsmQuestAnswerListener {
     /** Called when the user chose to leave a note instead  */
     fun onComposeNote(questId: Long, group: QuestGroup, questTitle: String)
 
-    /** Called when the user did not answer the quest with the given id but instead left a note  */
-    fun onLeaveNote(questId: Long, group: QuestGroup, questTitle: String, note: String, imagePaths: List<String>?)
+    /** Called when the user chose to split the way  */
+    fun onSplitWay(osmQuestId: Long)
 
     /** Called when the user chose to skip the quest  */
     fun onSkippedQuest(questId: Long, group: QuestGroup)
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/QuestAnswerComponent.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/QuestAnswerComponent.kt
index ad3d6cce56d..407dd309af2 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/QuestAnswerComponent.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/QuestAnswerComponent.kt
@@ -32,7 +32,7 @@ class QuestAnswerComponent {
         callbackListener = listener
     }
 
-    fun onAnswerQuest(answer: Any) {
+    fun onAnsweredQuest(answer: Any) {
         callbackListener.onAnsweredQuest(questId, questGroup, answer)
     }
 
@@ -40,8 +40,9 @@ class QuestAnswerComponent {
         callbackListener.onComposeNote(questId, questGroup, questTitle)
     }
 
-    fun onLeaveNote(questTitle: String, text: String, imagePaths: List<String>?) {
-        callbackListener.onLeaveNote(questId, questGroup, questTitle, text, imagePaths)
+    fun onSplitWay() {
+        if (questGroup != QuestGroup.OSM) throw IllegalStateException()
+        callbackListener.onSplitWay(questId)
     }
 
     fun onSkippedQuest() {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/SplitWayFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/SplitWayFragment.kt
new file mode 100644
index 00000000000..e3aa62f55b5
--- /dev/null
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/SplitWayFragment.kt
@@ -0,0 +1,193 @@
+package de.westnordost.streetcomplete.quests
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.view.animation.AnimationUtils
+import androidx.annotation.UiThread
+import androidx.appcompat.app.AlertDialog
+import androidx.core.os.bundleOf
+import androidx.fragment.app.Fragment
+import de.westnordost.osmapi.map.data.LatLon
+import de.westnordost.osmapi.map.data.OsmLatLon
+import de.westnordost.osmapi.map.data.Way
+import de.westnordost.streetcomplete.Injector
+
+import de.westnordost.streetcomplete.R
+import de.westnordost.streetcomplete.data.osm.ElementGeometry
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtLinePosition
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtPoint
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition
+import de.westnordost.streetcomplete.ktx.*
+import de.westnordost.streetcomplete.sound.SoundFx
+import de.westnordost.streetcomplete.util.SphericalEarthMath.*
+import kotlinx.android.synthetic.main.fragment_split_way.*
+import javax.inject.Inject
+
+class SplitWayFragment : Fragment(), IsCloseableBottomSheet {
+
+    interface Listener {
+        fun onAddSplit(point: LatLon)
+        fun onRemoveSplit(point: LatLon)
+        fun onSplittedWay(osmQuestId: Long, splits: List<SplitPolylineAtPosition>)
+    }
+    private val splits: MutableList<Pair<SplitPolylineAtPosition, LatLon>> = mutableListOf()
+
+    @Inject internal lateinit var soundFx: SoundFx
+
+    private var osmQuestId: Long = 0L
+    private lateinit var way: Way
+    private lateinit var positions: List<OsmLatLon>
+
+    private val hasChanges get() = splits.isNotEmpty()
+    private val isFormComplete get() = splits.size >= if (way.isClosed()) 2 else 1
+
+    init {
+        Injector.instance.applicationComponent.inject(this)
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        osmQuestId = arguments!!.getLong(ARG_QUEST_ID)
+        way = arguments!!.getSerializable(ARG_WAY) as Way
+        val elementGeometry = arguments!!.getSerializable(ARG_ELEMENT_GEOMETRY) as ElementGeometry
+        positions = elementGeometry.polylines.single().map { OsmLatLon(it.latitude, it.longitude) }
+    }
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        return inflater.inflate(R.layout.fragment_split_way, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        okButton.setOnClickListener { onClickOk() }
+        cancelButton.setOnClickListener { activity?.onBackPressed() }
+        undoButton.setOnClickListener { onClickUndo() }
+
+        undoButton.visibility = if (hasChanges) View.VISIBLE else View.INVISIBLE
+        okButton.visibility = if (isFormComplete) View.VISIBLE else View.INVISIBLE
+
+        if (savedInstanceState == null) {
+            view.findViewById<View>(R.id.speechbubbleContentContainer).startAnimation(
+                AnimationUtils.loadAnimation(context, R.anim.inflate_answer_bubble)
+            )
+        }
+    }
+
+    private fun onClickOk() {
+        (activity as Listener).onSplittedWay(osmQuestId, splits.map { it.first })
+    }
+
+    private fun onClickUndo() {
+        if (splits.isNotEmpty()) {
+            val item = splits.removeAt(splits.lastIndex)
+            animateButtonVisibilities()
+            (activity as? Listener)?.onRemoveSplit(item.second)
+        }
+    }
+
+    @UiThread
+    override fun onClickMapAt(position: LatLon, horizontalAccuracyInMeters: Double): Boolean {
+
+        val splitWayCandidates = createSplits(position, horizontalAccuracyInMeters)
+        // split point could be put on several places
+        if (splitWayCandidates.size > 1) {
+            context?.toast(R.string.quest_split_way_too_imprecise)
+        }
+        else if (splitWayCandidates.size == 1) {
+            val splitWay = splitWayCandidates.single()
+            val splitPosition = splitWay.pos
+
+            // new split point is too close to existing split points
+            if (splits.any { distance(it.second, splitPosition) < horizontalAccuracyInMeters } ) {
+                context?.toast(R.string.quest_split_way_too_imprecise)
+            } else {
+                splits.add(Pair(splitWay, splitPosition))
+                animateButtonVisibilities()
+                soundFx.play(R.raw.snip)
+                (activity as? Listener)?.onAddSplit(splitPosition)
+            }
+        }
+        // always consume event. User should press the cancel button to exit
+        return true
+    }
+
+    private fun createSplits(clickPosition: LatLon, horizontalAccuracyInMeters: Double): Set<SplitPolylineAtPosition> {
+        val splitWaysAtNodes = createSplitsAtNodes(clickPosition, horizontalAccuracyInMeters)
+        // if a split on a node is possible, do that and don't even check if a split on a way is also possible
+        if (splitWaysAtNodes.isNotEmpty()) return splitWaysAtNodes
+        return createSplitsForLines(clickPosition, horizontalAccuracyInMeters)
+    }
+
+    private fun createSplitsAtNodes(clickPosition: LatLon, horizontalAccuracyInMeters: Double): Set<SplitAtPoint> {
+        // ignore first and last node (cannot be split at the very start or end)
+        val result = mutableSetOf<SplitAtPoint>()
+        for (pos in positions.subList(1, positions.size - 1)) {
+            val nodeDistance = distance(clickPosition, pos)
+            if (horizontalAccuracyInMeters > nodeDistance) {
+                result.add(SplitAtPoint(pos))
+            }
+        }
+        return result
+    }
+
+    private fun createSplitsForLines(clickPosition: LatLon, horizontalAccuracyInMeters: Double): Set<SplitAtLinePosition> {
+        val result = mutableSetOf<SplitAtLinePosition>()
+        positions.forEachPair { first, second ->
+            val crossTrackDistance = crossTrackDistance(first, second, clickPosition)
+            if (horizontalAccuracyInMeters > crossTrackDistance) {
+                val alongTrackDistance = alongTrackDistance(first, second, clickPosition)
+                val distance = distance(first, second)
+                if (distance > alongTrackDistance && alongTrackDistance > 0) {
+                    val delta = alongTrackDistance / distance
+                    result.add(SplitAtLinePosition(first, second, delta))
+                }
+            }
+        }
+        return result
+    }
+
+    @UiThread override fun onClickClose(onConfirmed: Runnable) {
+        if (!hasChanges) {
+            onDiscard()
+            onConfirmed.run()
+        } else {
+            activity?.let {
+                AlertDialog.Builder(it)
+                    .setMessage(R.string.confirmation_discard_title)
+                    .setPositiveButton(R.string.confirmation_discard_positive) { _, _ ->
+                        onDiscard()
+                        onConfirmed.run()
+                    }
+                    .setNegativeButton(R.string.confirmation_discard_negative, null)
+                    .show()
+            }
+        }
+    }
+
+    private fun onDiscard() {}
+
+    private fun animateButtonVisibilities() {
+        if (isFormComplete) okButton.popIn() else okButton.popOut()
+        if (hasChanges) undoButton.popIn() else undoButton.popOut()
+    }
+
+    companion object {
+        private const val ARG_QUEST_ID = "questId"
+        private const val ARG_WAY = "way"
+        private const val ARG_ELEMENT_GEOMETRY = "elementGeometry"
+
+        @JvmStatic
+        fun create(osmQuestId: Long, way: Way, elementGeometry: ElementGeometry): SplitWayFragment {
+            val f = SplitWayFragment()
+            f.arguments = bundleOf(
+                ARG_QUEST_ID to osmQuestId,
+                ARG_WAY to way,
+                ARG_ELEMENT_GEOMETRY to elementGeometry
+            )
+            return f
+        }
+    }
+}
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/bikeway/AddCyclewayForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/bikeway/AddCyclewayForm.kt
index 7f3747e95d6..b0d8a281757 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/bikeway/AddCyclewayForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/bikeway/AddCyclewayForm.kt
@@ -28,13 +28,13 @@ class AddCyclewayForm : AbstractQuestFormAnswerFragment<CyclewayAnswer>() {
     override val contentLayoutResId = R.layout.quest_street_side_puzzle
     override val contentPadding = false
 
-    override val otherAnswers:List<OtherAnswer> get() {
+    override val otherAnswers: List<OtherAnswer> get() {
         val isNoRoundabout = osmElement!!.tags["junction"] != "roundabout"
-        return if (!isDefiningBothSides && isNoRoundabout) {
-            listOf(OtherAnswer(R.string.quest_cycleway_answer_contraflow_cycleway) { showBothSides() })
-        } else {
-            listOf()
+        val result = mutableListOf(createSplitWayAnswer())
+        if (!isDefiningBothSides && isNoRoundabout) {
+            result.add(OtherAnswer(R.string.quest_cycleway_answer_contraflow_cycleway) { showBothSides() })
         }
+        return result
     }
 
     private val likelyNoBicycleContraflow = FiltersParser().parse("""
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestrians.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestrians.kt
index 61cd1a35a2b..efc4231e9e2 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestrians.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestrians.kt
@@ -34,7 +34,7 @@ class AddProhibitedForPedestrians(o: OverpassMapDataDao) : SimpleOverpassQuestTy
 
     override fun getTitle(tags: Map<String, String>) = R.string.quest_accessible_for_pedestrians_title_prohibited
 
-    override fun createForm() = AddAccessibleForPedestriansForm()
+    override fun createForm() = AddProhibitedForPedestriansForm()
 
     override fun applyAnswerTo(answer: ProhibitedForPedestriansAnswer, changes: StringMapChangesBuilder) {
         when(answer) {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddAccessibleForPedestriansForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestriansForm.kt
similarity index 93%
rename from app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddAccessibleForPedestriansForm.kt
rename to app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestriansForm.kt
index 9069a7ae01d..89cc2a34d3c 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddAccessibleForPedestriansForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/foot/AddProhibitedForPedestriansForm.kt
@@ -5,13 +5,12 @@ import android.view.View
 import android.widget.ImageView
 import androidx.appcompat.app.AlertDialog
 import de.westnordost.streetcomplete.R
-import de.westnordost.streetcomplete.quests.AYesNoQuestAnswerFragment
 import de.westnordost.streetcomplete.quests.AbstractQuestAnswerFragment
 import de.westnordost.streetcomplete.quests.OtherAnswer
 import de.westnordost.streetcomplete.quests.foot.ProhibitedForPedestriansAnswer.*
 import kotlinx.android.synthetic.main.quest_buttonpanel_yes_no_sidewalk.*
 
-class AddAccessibleForPedestriansForm : AbstractQuestAnswerFragment<ProhibitedForPedestriansAnswer>() {
+class AddProhibitedForPedestriansForm : AbstractQuestAnswerFragment<ProhibitedForPedestriansAnswer>() {
 
     override val buttonsResId = R.layout.quest_buttonpanel_yes_no_sidewalk
 
@@ -27,7 +26,7 @@ class AddAccessibleForPedestriansForm : AbstractQuestAnswerFragment<ProhibitedFo
 
     // the living street answer stuff is copied from AddMaxSpeedForm
     override val otherAnswers: List<OtherAnswer> get() {
-        val result = mutableListOf<OtherAnswer>()
+        val result = mutableListOf(createSplitWayAnswer())
 
         val highwayTag = osmElement!!.tags["highway"]!!
         if (countryInfo.isLivingStreetKnown && MAYBE_LIVING_STREET.contains(highwayTag)) {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/localized_name/AddRoadNameForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/localized_name/AddRoadNameForm.kt
index 65833dc6aba..e8ffc4ef4e8 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/localized_name/AddRoadNameForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/localized_name/AddRoadNameForm.kt
@@ -20,6 +20,7 @@ import java.lang.IllegalStateException
 class AddRoadNameForm : AAddLocalizedNameForm<RoadNameAnswer>() {
 
     override val otherAnswers = listOf(
+        createSplitWayAnswer(),
         OtherAnswer(R.string.quest_name_answer_noName) { selectNoStreetNameReason() },
         OtherAnswer(R.string.quest_streetName_answer_cantType) { showKeyboardInfo() }
     )
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/max_speed/AddMaxSpeedForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/max_speed/AddMaxSpeedForm.kt
index 75cc2482a6b..bb5bb8c60c9 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/max_speed/AddMaxSpeedForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/max_speed/AddMaxSpeedForm.kt
@@ -23,7 +23,7 @@ class AddMaxSpeedForm : AbstractQuestFormAnswerFragment<MaxSpeedAnswer>() {
     override val contentLayoutResId = R.layout.quest_maxspeed
 
     override val otherAnswers: List<OtherAnswer> get() {
-        val result = mutableListOf<OtherAnswer>()
+        val result = mutableListOf(createSplitWayAnswer())
 
         val highwayTag = osmElement!!.tags["highway"]!!
         if (countryInfo.isLivingStreetKnown && MAYBE_LIVING_STREET.contains(highwayTag)) {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/oneway/AddOnewayForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/oneway/AddOnewayForm.kt
index 5d79108b099..815c2b73b8c 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/oneway/AddOnewayForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/oneway/AddOnewayForm.kt
@@ -17,6 +17,7 @@ class AddOnewayForm : AYesNoQuestAnswerFragment<OnewayAnswer>() {
 
     override val contentLayoutResId = R.layout.quest_street_side_puzzle
     override val contentPadding = false
+    override val otherAnswers = listOf(createSplitWayAnswer())
 
     private var streetSideRotater: StreetSideRotater? = null
 
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/segregated/AddCyclewaySegregationForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/segregated/AddCyclewaySegregationForm.kt
index 79d9654e0c1..a6a05f71923 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/segregated/AddCyclewaySegregationForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/segregated/AddCyclewaySegregationForm.kt
@@ -14,6 +14,8 @@ class AddCyclewaySegregationForm : AImageListQuestAnswerFragment<Boolean, Boolea
         Item(false, R.drawable.ic_path_segregated_no, R.string.quest_segregated_mixed)
     )
 
+    override val otherAnswers = listOf(createSplitWayAnswer())
+
     override val itemsPerRow = 2
 
     override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/sidewalk/AddSidewalkForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/sidewalk/AddSidewalkForm.kt
index 4556aba980b..3b04018bfe0 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/sidewalk/AddSidewalkForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/sidewalk/AddSidewalkForm.kt
@@ -21,6 +21,7 @@ class AddSidewalkForm : AbstractQuestFormAnswerFragment<SidewalkAnswer>() {
 
     override val contentLayoutResId = R.layout.quest_street_side_puzzle
     override val contentPadding = false
+    override val otherAnswers = listOf(createSplitWayAnswer())
 
     private var streetSideRotater: StreetSideRotater? = null
     private var leftSide: Sidewalk? = null
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddPathSurfaceForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddPathSurfaceForm.kt
index 591ac81957e..fba4a45e879 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddPathSurfaceForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddPathSurfaceForm.kt
@@ -7,6 +7,8 @@ import de.westnordost.streetcomplete.quests.surface.Surface.*
 
 class AddPathSurfaceForm : AGroupedImageListQuestAnswerFragment<String, String>() {
 
+    override val otherAnswers = listOf(createSplitWayAnswer())
+
     override val topItems get() =
         when (val pathType = determinePathType(osmElement!!.tags)) {
             "bridleway" -> listOf(
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddRoadSurfaceForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddRoadSurfaceForm.kt
index 7283dc31dc9..14d16b6b3e0 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddRoadSurfaceForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/surface/AddRoadSurfaceForm.kt
@@ -7,6 +7,8 @@ import de.westnordost.streetcomplete.quests.surface.Surface.*
 
 class AddRoadSurfaceForm : AGroupedImageListQuestAnswerFragment<String,String>() {
 
+    override val otherAnswers = listOf(createSplitWayAnswer())
+
     override val topItems get() =
         // tracks often have different surfaces than other roads
         if (osmElement!!.tags["highway"] == "track")
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/tracktype/AddTracktypeForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/tracktype/AddTracktypeForm.kt
index d8a78f398f7..45f84c5827c 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/tracktype/AddTracktypeForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/tracktype/AddTracktypeForm.kt
@@ -6,6 +6,8 @@ import de.westnordost.streetcomplete.view.Item
 
 class AddTracktypeForm : AImageListQuestAnswerFragment<String, String>() {
 
+    override val otherAnswers = listOf(createSplitWayAnswer())
+
     override val items = listOf(
         Item("grade1", R.drawable.tracktype_grade1, R.string.quest_tracktype_grade1),
         Item("grade2", R.drawable.tracktype_grade2, R.string.quest_tracktype_grade2),
diff --git a/app/src/main/java/de/westnordost/streetcomplete/quests/way_lit/WayLitForm.kt b/app/src/main/java/de/westnordost/streetcomplete/quests/way_lit/WayLitForm.kt
index 8f33950a638..c3285c3168a 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/quests/way_lit/WayLitForm.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/quests/way_lit/WayLitForm.kt
@@ -7,6 +7,7 @@ import de.westnordost.streetcomplete.quests.OtherAnswer
 class WayLitForm : AYesNoQuestAnswerFragment<String>() {
 
     override val otherAnswers = listOf(
+        createSplitWayAnswer(),
         OtherAnswer(R.string.quest_way_lit_24_7) { applyAnswer("24/7") },
         OtherAnswer(R.string.quest_way_lit_automatic) { applyAnswer("automatic") }
     )
diff --git a/app/src/main/java/de/westnordost/streetcomplete/sound/SoundFx.java b/app/src/main/java/de/westnordost/streetcomplete/sound/SoundFx.java
index 4715355c47a..434a4a0b954 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/sound/SoundFx.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/sound/SoundFx.java
@@ -29,12 +29,9 @@ public void prepare(@RawRes int resId)
 
 	public void play(@RawRes int resId)
 	{
+		if (soundIds.get(resId) == 0) prepare(resId);
 		boolean isTouchSoundsEnabled = Settings.System.getInt(context.getContentResolver(),
 			Settings.System.SOUND_EFFECTS_ENABLED, 1) != 0;
-		if(isTouchSoundsEnabled)
-		{
-			if (soundIds.get(resId) == 0) prepare(resId);
-			sounds.play(soundIds.get(resId), 1, 1, 1, 0, 1);
-		}
+		if(isTouchSoundsEnabled) sounds.play(soundIds.get(resId), 1, 1, 1, 0, 1);
 	}
 }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/tangram/QuestsMapFragment.java b/app/src/main/java/de/westnordost/streetcomplete/tangram/QuestsMapFragment.java
index ecdf837e820..c98e627f21f 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/tangram/QuestsMapFragment.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/tangram/QuestsMapFragment.java
@@ -8,13 +8,13 @@
 import android.os.Handler;
 
 import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
 import androidx.annotation.UiThread;
 
 import com.mapzen.tangram.LabelPickResult;
 import com.mapzen.tangram.LngLat;
 import com.mapzen.tangram.MapController;
 import com.mapzen.tangram.MapData;
+import com.mapzen.tangram.Marker;
 import com.mapzen.tangram.SceneError;
 import com.mapzen.tangram.SceneUpdate;
 import com.mapzen.tangram.TouchInput;
@@ -31,14 +31,17 @@
 import javax.inject.Provider;
 
 import de.westnordost.streetcomplete.Injector;
+import de.westnordost.streetcomplete.R;
 import de.westnordost.streetcomplete.data.Quest;
 import de.westnordost.streetcomplete.data.QuestGroup;
 import de.westnordost.streetcomplete.data.QuestType;
 import de.westnordost.streetcomplete.data.osm.ElementGeometry;
 import de.westnordost.streetcomplete.quests.bikeway.AddCycleway;
+import de.westnordost.streetcomplete.util.DpUtil;
 import de.westnordost.streetcomplete.util.SlippyMapMath;
 import de.westnordost.osmapi.map.data.BoundingBox;
 import de.westnordost.osmapi.map.data.LatLon;
+import de.westnordost.streetcomplete.util.SphericalEarthMath;
 
 public class QuestsMapFragment extends MapFragment implements TouchInput.TapResponder,
 		MapController.LabelPickListener
@@ -70,6 +73,9 @@ public class QuestsMapFragment extends MapFragment implements TouchInput.TapResp
 
 	private Rect questOffset;
 
+	// LatLon -> Marker Id
+	private final Map<LatLon, Long> markerIds = new HashMap<>();
+
 	@Inject Provider<List<QuestType>> questTypesProvider;
 	@Inject TangramQuestSpriteSheetCreator spriteSheetCreator;
 	private Map<QuestType, Integer> questTypeOrder;
@@ -77,7 +83,7 @@ public class QuestsMapFragment extends MapFragment implements TouchInput.TapResp
 	public interface Listener
 	{
 		void onClickedQuest(QuestGroup questGroup, Long questId);
-		void onClickedMapAt(@Nullable LatLon position);
+		void onClickedMapAt(LatLon position, double horizontalAccuracyInMeters);
 		/** Called once the given bbox comes into view first (listener should get quests there) */
 		void onFirstInView(BoundingBox bbox);
 	}
@@ -166,7 +172,12 @@ public QuestsMapFragment()
 
 	@Override public boolean onSingleTapConfirmed(float x, float y)
 	{
-		if(controller != null) controller.pickLabel(x,y);
+
+		if(controller != null) {
+			onClickedMap(x, y);
+
+			controller.pickLabel(x,y);
+		}
 		return true;
 	}
 
@@ -180,7 +191,6 @@ public void onLabelPick(LabelPickResult labelPickResult, float positionX, float
 				|| labelPickResult.getProperties() == null
 				|| labelPickResult.getProperties().get(MARKER_QUEST_ID) == null)
 		{
-			onClickedMap(positionX, positionY);
 			return;
 		}
 
@@ -264,7 +274,17 @@ private float getMaxZoomThatContains(ElementGeometry geometry)
 	private void onClickedMap(float positionX, float positionY)
 	{
 		LngLat pos = controller.screenPositionToLngLat(new PointF(positionX, positionY));
-		if(pos != null) listener.onClickedMapAt(TangramConst.toLatLon(pos));
+		if(pos != null) {
+			float fingerSize = DpUtil.toPx(11, getContext());
+			LngLat fingerEdge = controller.screenPositionToLngLat(new PointF(positionX + fingerSize, positionY));
+			if (fingerEdge != null)
+			{
+				LatLon clickPos = TangramConst.toLatLon(pos);
+				LatLon fingerEdgePos = TangramConst.toLatLon(fingerEdge);
+				double fingerRadiusInMeters = SphericalEarthMath.distance(clickPos, fingerEdgePos);
+				listener.onClickedMapAt(clickPos, fingerRadiusInMeters);
+			}
+		}
 	}
 
 	@Override protected boolean shouldCenterCurrentPosition()
@@ -361,12 +381,12 @@ else if(g.center != null)
 		}
 	}
 
-	@UiThread
-	public void removeQuestGeometry()
+	@UiThread public void removeQuestGeometry()
 	{
 		if(geometryLayer != null) geometryLayer.clear();
 		if(controller != null)
 		{
+			controller.removeAllMarkers();
 			if(zoomBeforeShowingQuest != null) controller.setZoomEased(zoomBeforeShowingQuest, 500);
 			if(positionBeforeShowingQuest != null) controller.setPositionEased(positionBeforeShowingQuest, 500);
 			zoomBeforeShowingQuest = null;
@@ -374,23 +394,28 @@ public void removeQuestGeometry()
 			followPosition();
 		}
 	}
-/*
-	public void addQuest(Quest quest, QuestGroup group)
-	{
-		// TODO: this method may also be called for quests that are already displayed on this map
-		if(questsLayer == null) return;
 
-		LngLat pos = TangramConst.toLngLat(quest.getMarkerLocation());
-		Map<String, String> props = new HashMap<>();
-		props.put("type", "point");
-		props.put("kind", quest.getType().getIconName());
-		props.put(MARKER_QUEST_GROUP, group.name());
-		props.put(MARKER_QUEST_ID, String.valueOf(quest.getId()));
-		questsLayer.addPoint(pos, props);
+	@UiThread public void putMarkerForCurrentQuest(LatLon pos) {
+		deleteMarkerForCurrentQuest(pos);
+		if (controller != null) {
+			Marker marker = controller.addMarker();
+			marker.setDrawable(R.drawable.crosshair_marker);
+			// TODO ugly!!
+			marker.setStylingFromString("{ style: 'points', color: 'white', size: [50px, 50px], order: 2000, collide: false }");
+			marker.setPoint(TangramConst.toLngLat(pos));
+			markerIds.put(pos, marker.getMarkerId());
+		}
+	}
 
-		controller.applySceneUpdates();
+	@UiThread public void deleteMarkerForCurrentQuest(LatLon pos) {
+		if (controller != null) {
+			Long markerId = markerIds.get(pos);
+			if (markerId != null) {
+				controller.removeMarker(markerId);
+				markerIds.remove(pos);
+			}
+		}
 	}
-*/
 
 	private int getQuestPriority(Quest quest){
 		// priority is decided by
diff --git a/app/src/main/java/de/westnordost/streetcomplete/util/KryoSerializer.java b/app/src/main/java/de/westnordost/streetcomplete/util/KryoSerializer.java
index 4f9bc5a118c..3de06c4dcd5 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/util/KryoSerializer.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/util/KryoSerializer.java
@@ -13,11 +13,13 @@
 import javax.inject.Singleton;
 
 import de.westnordost.osmapi.map.data.Fixed1E7LatLon;
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtLinePosition;
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtPoint;
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition;
 import de.westnordost.streetcomplete.data.osm.changes.StringMapChanges;
 import de.westnordost.streetcomplete.data.osm.changes.StringMapEntryAdd;
 import de.westnordost.streetcomplete.data.osm.changes.StringMapEntryDelete;
 import de.westnordost.streetcomplete.data.osm.changes.StringMapEntryModify;
-import de.westnordost.streetcomplete.data.osm.persist.SplitWayData;
 import de.westnordost.streetcomplete.quests.opening_hours.adapter.OpeningMonthsRow;
 import de.westnordost.streetcomplete.quests.opening_hours.adapter.OpeningWeekdaysRow;
 import de.westnordost.streetcomplete.quests.opening_hours.model.CircularSection;
@@ -60,7 +62,8 @@ public class KryoSerializer implements Serializer
 			LocalizedName.class,
 			WeekdaysTimesRow.class,
 			OsmLatLon.class,
-			SplitWayData.class
+			SplitAtPoint.class,
+			SplitAtLinePosition.class
 	};
 
 
diff --git a/app/src/main/java/de/westnordost/streetcomplete/util/SphericalEarthMath.java b/app/src/main/java/de/westnordost/streetcomplete/util/SphericalEarthMath.java
index 3772ceaba55..856190905f0 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/util/SphericalEarthMath.java
+++ b/app/src/main/java/de/westnordost/streetcomplete/util/SphericalEarthMath.java
@@ -71,9 +71,9 @@ public static BoundingBox enclosingBoundingBox(Iterable<LatLon> positions)
 	/** @return a new position in the given distance and angle from the original position */
 	public static LatLon translate(LatLon pos, double distance, double angle)
 	{
-		double 1 = Math.toRadians(pos.getLatitude());
-		double 1 = Math.toRadians(pos.getLongitude());
-		double 1 = Math.toRadians(angle);
+		double 1 = toRadians(pos.getLatitude());
+		double 1 = toRadians(pos.getLongitude());
+		double 1 = toRadians(angle);
 		double 12 = distance / EARTH_RADIUS;
 
 		double y = sin(1) * cos(12) + cos(1) * sin(12) * cos(1);
@@ -104,12 +104,43 @@ public static double enclosedArea(BoundingBox bbox)
 	 */
 	public static double distance(LatLon pos1, LatLon pos2)
 	{
-		return EARTH_RADIUS * distance(
-				Math.toRadians(pos1.getLatitude()),
-				Math.toRadians(pos1.getLongitude()),
-				Math.toRadians(pos2.getLatitude()),
-				Math.toRadians(pos2.getLongitude()
-				));
+		return distance(
+			toRadians(pos1.getLatitude()),
+			toRadians(pos1.getLongitude()),
+			toRadians(pos2.getLatitude()),
+			toRadians(pos2.getLongitude())
+		);
+	}
+// TODO test these two functions!
+	/**
+	 * @return the shortest distance of the arc between two points and another point in meters
+	 */
+	public static double crossTrackDistance(LatLon start, LatLon end, LatLon point)
+	{
+		return crossTrackDistance(
+			toRadians(start.getLatitude()),
+			toRadians(start.getLongitude()),
+			toRadians(end.getLatitude()),
+			toRadians(end.getLongitude()),
+			toRadians(point.getLatitude()),
+			toRadians(point.getLongitude())
+		);
+	}
+
+	/**
+	 * @return same as crossTrackDistance, only the distance returned here is the distance between
+	 * the start point and the point to where the perpendicular drawn from point crosses the path.
+	 */
+	public static double alongTrackDistance(LatLon start, LatLon end, LatLon point)
+	{
+		return alongTrackDistance(
+			toRadians(start.getLatitude()),
+			toRadians(start.getLongitude()),
+			toRadians(end.getLatitude()),
+			toRadians(end.getLongitude()),
+			toRadians(point.getLatitude()),
+			toRadians(point.getLongitude())
+		);
 	}
 
 	/**
@@ -155,10 +186,10 @@ public static boolean isWithinDistance(double distance, List<LatLon> line1, List
 	public static double bearing(LatLon pos1, LatLon pos2)
 	{
 		double bearing =  Math.toDegrees(bearing(
-				Math.toRadians(pos1.getLatitude()),
-				Math.toRadians(pos1.getLongitude()),
-				Math.toRadians(pos2.getLatitude()),
-				Math.toRadians(pos2.getLongitude())
+				toRadians(pos1.getLatitude()),
+				toRadians(pos1.getLongitude()),
+				toRadians(pos2.getLatitude()),
+				toRadians(pos2.getLongitude())
 		));
 
 		if(bearing < 0) bearing += 360;
@@ -173,10 +204,10 @@ public static double bearing(LatLon pos1, LatLon pos2)
 	public static double finalBearing(LatLon pos1, LatLon pos2)
 	{
 		double bearing =  Math.toDegrees(finalBearing(
-				Math.toRadians(pos1.getLatitude()),
-				Math.toRadians(pos1.getLongitude()),
-				Math.toRadians(pos2.getLatitude()),
-				Math.toRadians(pos2.getLongitude())
+				toRadians(pos1.getLatitude()),
+				toRadians(pos1.getLongitude()),
+				toRadians(pos2.getLatitude()),
+				toRadians(pos2.getLongitude())
 		));
 
 		if(bearing < 0) bearing += 360;
@@ -408,27 +439,48 @@ public static boolean isRingDefinedClockwise(List<LatLon> ring)
 		return sum > 0;
 	}
 
-	// https://en.wikipedia.org/wiki/Great-circle_navigation#cite_note-2
+	private static double crossTrackDistance(double 1, double 1, double 2, double 2, double 3, double 3)
+	{
+		double 12 = bearing(1, 1, 2, 2);
+		double 13 = bearing(1, 1, 3, 3);
+		double 13 = distance(1, 1, 3, 3) / EARTH_RADIUS;
+
+		double xt = asin(sin(13) * sin(13-12));
+		return abs(xt * EARTH_RADIUS);
+	}
+
+	private static double alongTrackDistance(double 1, double 1, double 2, double 2, double 3, double 3)
+	{
+		double 12 = bearing(1, 1, 2, 2);
+		double 13 = bearing(1, 1, 3, 3);
+		double 13 = distance(1, 1, 3, 3) / EARTH_RADIUS;
+
+		double xt = asin(sin(13) * sin(13-12));
+		double at = acos(cos(13) / abs(cos(xt)));
+		return at * signum(cos(12-13)) * EARTH_RADIUS;
+	}
+
+	// http://www.movable-type.co.uk/scripts/latlong.html
 	private static double distance(double 1, double 1, double 2, double 2)
 	{
 		double  = 2 - 1;
+		double  = 2 - 1;
 
-		double y = sqrt(sqr(cos(2)*sin()) + sqr(cos(1)*sin(2) - sin(1)*cos(2)*cos()));
-		double x = sin(1)*sin(2) + cos(1)*cos(2)*cos();
-		return atan2(y, x);
+		double a = sqr(sin(/2)) + cos(1) * cos(2) * sqr(sin(/2));
+		double c = 2 * atan2(sqrt(a), sqrt(1-a));
+		return c * EARTH_RADIUS;
 	}
 
-	//See https://en.wikipedia.org/wiki/Great-circle_navigation#Course_and_distance
 	private static double bearing(double 1, double 1, double 2, double 2)
 	{
 		double  = 2 - 1;
-		return Math.atan2(sin(), cos(1) * tan(2) - sin(1) * cos());
+		return Math.atan2(sin() * cos(2), cos(1) * sin(2) - sin(1) * cos(2) * cos());
 	}
 
 	private static double finalBearing(double 1, double 1, double 2, double 2)
 	{
 		double  = 2 - 1;
-		return Math.atan2(sin(), -cos(2)*tan(1) + sin(1)*cos());
+		return Math.atan2(sin() * cos(1), -cos(2) * sin(1) + sin(2) * cos(1) * cos());
 	}
 
 	private static double sqr(double x) { return Math.pow(x, 2); }
diff --git a/app/src/main/res/authors.txt b/app/src/main/res/authors.txt
index 3e48114e2d9..efb3725e242 100644
--- a/app/src/main/res/authors.txt
+++ b/app/src/main/res/authors.txt
@@ -103,6 +103,8 @@ produce_mate.jpg               CC-BY-SA 3.0      https://commons.wikimedia.org/w
 produce_jojoba.jpg             CC-BY 2.0         https://de.wikipedia.org/wiki/Datei:Jojoba_Nut_-_Flickr_-_treegrow.jpg
 produce_tomato.jpg             CC-BY-SA 3.0      https://commons.wikimedia.org/wiki/File:Solanum_lycopersicum_%27Cronos%27,_tomaat_%27Cronos%27.jpg
 
+snip.wav                       CC0               https://freesound.org/people/Godowan/sounds/240473/
+
 surface_asphalt.jpg            Public Domain     https://commons.wikimedia.org/wiki/File:Ground_frost_damages.JPG
 surface_cobblestone.jpg        CC-BY-SA 3.0      https://commons.wikimedia.org/wiki/File:Bad_Radkersburg_Murgasse_IMG_0583.jpg
 surface_compacted.jpg          CC-BY 2.0         https://www.flickr.com/photos/ian_munroe/3633361321
diff --git a/app/src/main/res/drawable-hdpi/crosshair_marker.png b/app/src/main/res/drawable-hdpi/crosshair_marker.png
new file mode 100644
index 00000000000..58aa0fed6c9
Binary files /dev/null and b/app/src/main/res/drawable-hdpi/crosshair_marker.png differ
diff --git a/app/src/main/res/drawable-mdpi/crosshair_marker.png b/app/src/main/res/drawable-mdpi/crosshair_marker.png
new file mode 100644
index 00000000000..1212d950aca
Binary files /dev/null and b/app/src/main/res/drawable-mdpi/crosshair_marker.png differ
diff --git a/app/src/main/res/drawable-xhdpi/crosshair_marker.png b/app/src/main/res/drawable-xhdpi/crosshair_marker.png
new file mode 100644
index 00000000000..79ea9a2737b
Binary files /dev/null and b/app/src/main/res/drawable-xhdpi/crosshair_marker.png differ
diff --git a/app/src/main/res/drawable-xxhdpi/crosshair_marker.png b/app/src/main/res/drawable-xxhdpi/crosshair_marker.png
new file mode 100644
index 00000000000..eae0d070a0f
Binary files /dev/null and b/app/src/main/res/drawable-xxhdpi/crosshair_marker.png differ
diff --git a/app/src/main/res/drawable/ic_undo_black_24dp.xml b/app/src/main/res/drawable/ic_undo_black_24dp.xml
new file mode 100644
index 00000000000..3f477a35272
--- /dev/null
+++ b/app/src/main/res/drawable/ic_undo_black_24dp.xml
@@ -0,0 +1,9 @@
+<vector xmlns:android="http://schemas.android.com/apk/res/android"
+        android:width="24dp"
+        android:height="24dp"
+        android:viewportWidth="24.0"
+        android:viewportHeight="24.0">
+    <path
+        android:fillColor="#000"
+        android:pathData="M12.5,8c-2.65,0 -5.05,0.99 -6.9,2.6L2,7v9h9l-3.62,-3.62c1.39,-1.16 3.16,-1.88 5.12,-1.88 3.54,0 6.55,2.31 7.6,5.5l2.37,-0.78C21.08,11.03 17.15,8 12.5,8z"/>
+</vector>
diff --git a/app/src/main/res/layout/fragment_split_way.xml b/app/src/main/res/layout/fragment_split_way.xml
new file mode 100644
index 00000000000..13e24e6d2ab
--- /dev/null
+++ b/app/src/main/res/layout/fragment_split_way.xml
@@ -0,0 +1,103 @@
+<?xml version="1.0" encoding="utf-8"?>
+<de.westnordost.streetcomplete.view.SlidingRelativeLayout
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="@dimen/quest_form_width"
+    android:layout_height="match_parent"
+    android:background="@drawable/speechbubbles_gradient_background"
+    android:id="@+id/bottomSheetContainer"
+    >
+
+    <RelativeLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:layout_alignParentBottom="true">
+
+        <ImageButton
+            android:id="@+id/undoButton"
+            android:layout_width="64dp"
+            android:layout_height="64dp"
+            android:scaleType="center"
+            style="@style/RoundWhiteButton"
+            android:src="@drawable/ic_undo_black_24dp"
+            android:layout_centerHorizontal="true"/>
+
+        <FrameLayout
+            android:id="@+id/speechbubbleContentContainer"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:background="@drawable/speech_bubble_none"
+            android:layout_marginStart="-2.5dp"
+            android:layout_marginEnd="-2.5dp"
+            android:layout_marginBottom="4dp"
+            android:layout_below="@id/undoButton">
+
+            <de.westnordost.streetcomplete.view.MaskSpeechbubbleCornersFrameLayout
+                android:layout_width="match_parent"
+                android:layout_height="wrap_content">
+
+                <LinearLayout
+                    android:layout_width="match_parent"
+                    android:layout_height="wrap_content"
+                    android:orientation="vertical"
+                    android:showDividers="middle"
+                    android:divider="@drawable/button_bar_divider">
+
+                    <FrameLayout
+                        android:id="@+id/content"
+                        android:layout_height="wrap_content"
+                        android:layout_width="match_parent"
+                        android:orientation="vertical"
+                        android:paddingStart="16dp"
+                        android:paddingEnd="16dp"
+                        android:paddingTop="10dp"
+                        android:paddingBottom="10dp">
+
+                        <TextView
+                            android:layout_width="match_parent"
+                            android:layout_height="wrap_content"
+                            android:text="@string/quest_split_way_tutorial" />
+
+                    </FrameLayout>
+
+                    <LinearLayout
+                        android:id="@+id/buttonPanel"
+                        android:layout_width="match_parent"
+                        android:layout_height="wrap_content"
+                        android:orientation="horizontal"
+                        android:layoutDirection="locale"
+                        style="@style/ButtonBar">
+
+                        <Button
+                            android:id="@+id/cancelButton"
+                            android:layout_width="wrap_content"
+                            android:layout_height="wrap_content"
+                            android:text="@android:string/cancel"
+                            style="@style/BottomSheetButtonBarItem"/>
+
+                    </LinearLayout>
+
+                </LinearLayout>
+
+            </de.westnordost.streetcomplete.view.MaskSpeechbubbleCornersFrameLayout>
+
+        </FrameLayout>
+
+    </RelativeLayout>
+
+    <Button
+        android:id="@+id/okButton"
+        android:text="@string/ok"
+        style="@style/RoundAccentButton"
+        android:layout_width="72dp"
+        android:layout_height="72dp"
+        android:layout_alignParentEnd="true"
+        android:layout_alignParentBottom="true"
+        android:layout_margin="8dp"
+        android:visibility="gone"
+        android:scaleX="0.5"
+        android:scaleY="0.5"
+        android:alpha="0"/>
+
+</de.westnordost.streetcomplete.view.SlidingRelativeLayout>
+
+
diff --git a/app/src/main/res/raw/snip.wav b/app/src/main/res/raw/snip.wav
new file mode 100644
index 00000000000..79d95330f7c
Binary files /dev/null and b/app/src/main/res/raw/snip.wav differ
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
index 7d909968891..c63c29f5534 100644
--- a/app/src/main/res/values/strings.xml
+++ b/app/src/main/res/values/strings.xml
@@ -665,4 +665,9 @@ Otherwise, you can download another keyboard in the app store. Popular keyboards
     <string name="about_contributing">Your answers are directly improving OpenStreetMap. Contributed data is open, everyone can use it. Many great projects are already using it.</string>
     <string name="about_missing_stars">Currently, the star count is not shared across devices, but answers are added directly to the OpenStreetMap database.</string>
     <string name="how_to_get_stars">Choose one of the markers on the map and answer the question. This way you will improve OpenStreetMap data and get stars. If you see no markers you may need to zoom out the map.</string>
+
+    <string name="quest_generic_answer_differs_along_the_way">"Differs along the way"</string>
+    <string name="quest_split_way_description">So, if it differs along the way, the way must be split up first before the question can be answered. Split it now?</string>
+    <string name="quest_split_way_tutorial">Tap on the way to split it at that point. You can split the way at several points if necessary. Try to be as precise as possible, you can zoom in as usual.</string>
+    <string name="quest_split_way_too_imprecise">"Please zoom in further"</string>
 </resources>
diff --git a/app/src/test/java/de/westnordost/streetcomplete/data/osm/changes/SplitWayTest.kt b/app/src/test/java/de/westnordost/streetcomplete/data/osm/changes/SplitWayTest.kt
deleted file mode 100644
index e465107c2c8..00000000000
--- a/app/src/test/java/de/westnordost/streetcomplete/data/osm/changes/SplitWayTest.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-package de.westnordost.streetcomplete.data.osm.changes
-
-import de.westnordost.osmapi.map.data.OsmNode
-import de.westnordost.osmapi.map.data.OsmWay
-import org.junit.Test
-import java.lang.IllegalArgumentException
-
-class SplitWayTest {
-
-    private val node1 = OsmNode(1, 1, 0.0, 0.0, null)
-    private val node2 = OsmNode(2, 1, 0.0, 1.0, null)
-    private val node3 = OsmNode(3, 1, 1.0, 1.0, null)
-    private val way = OsmWay(1,1, listOf(1,2,3), null)
-
-    @Test(expected = IllegalArgumentException::class)
-    fun `do not allow negative delta`() {
-        SplitWay(way, node1, node2, -0.1)
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun `do not allow delta above or equal 1`() {
-        SplitWay(way, node1, node2, 1.0)
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun `do not allow delta 0 if split is at first node of way`() {
-        SplitWay(way, node1, node2, 0.0)
-    }
-
-    @Test fun `allow delta 0 if split is not at first node of way`() {
-        SplitWay(way, node2, node3, 0.0)
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun `ensure that first node is actually in the way`() {
-        val way = OsmWay(1,1, listOf(2,3), null)
-        SplitWay(way, node1, node2, 0.5)
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun `ensure that second node is actually in the way`() {
-        val way = OsmWay(1,1, listOf(1,2), null)
-        SplitWay(way, node1, node3, 0.5)
-    }
-
-    @Test(expected = IllegalArgumentException::class)
-    fun `ensure that second node is one after first node in the way`() {
-        SplitWay(way, node1, node3, 0.5)
-    }
-}
diff --git a/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUploadTest.kt b/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUploadTest.kt
index 6efe7fe68ce..305926d4be0 100644
--- a/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUploadTest.kt
+++ b/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitSingleWayUploadTest.kt
@@ -5,7 +5,9 @@ import de.westnordost.osmapi.map.MapDataDao
 import de.westnordost.osmapi.map.data.*
 import de.westnordost.osmapi.map.data.Element.Type.*
 import de.westnordost.streetcomplete.argumentCaptor
-import de.westnordost.streetcomplete.data.osm.changes.SplitWay
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtLinePosition
+import de.westnordost.streetcomplete.data.osm.changes.SplitAtPoint
+import de.westnordost.streetcomplete.data.osm.changes.SplitPolylineAtPosition
 import de.westnordost.streetcomplete.eq
 import de.westnordost.streetcomplete.on
 import de.westnordost.streetcomplete.util.SphericalEarthMath
@@ -19,136 +21,156 @@ class SplitSingleWayUploadTest {
     private val osmDao = mock(MapDataDao::class.java)
     private val uploader = SplitSingleWayUpload(osmDao)
 
-    private val node1 = OsmNode(1, 1, 0.0, 0.0, null)
-    private val node2 = OsmNode(2, 1, 0.0, 1.0, null)
-    private val node3 = OsmNode(3, 1, 1.0, 1.0, null)
-    private val node4 = OsmNode(4, 1, 1.0, 0.0, null)
-    private var way = OsmWay(1,1, mutableListOf(1,2,3,4), null)
+    private val p = arrayOf(
+        OsmLatLon(0.0, 0.0),
+        OsmLatLon(0.0, 1.0),
+        OsmLatLon(1.0, 1.0),
+        OsmLatLon(1.0, 0.0)
+    )
+    private val n = arrayOf(
+        OsmNode(0, 1, p[0], null),
+        OsmNode(1, 1, p[1], null),
+        OsmNode(2, 1, p[2], null),
+        OsmNode(3, 1, p[3], null)
+    )
+
+    private var way = OsmWay(0,1, mutableListOf(0,1,2,3), null)
         set(value) {
             field = value
-            on(osmDao.getWay(1)).thenReturn(way)
+            on(osmDao.getWay(0)).thenReturn(way)
         }
-    private val split = SplitWay(way, node2, node3, 0.5)
+    private val split = SplitAtLinePosition(p[1], p[2], 0.5)
 
     @Before fun setUp() {
-        way = OsmWay(1,1, mutableListOf(1,2,3,4), null)
         reset(osmDao)
-        on(osmDao.getWay(1)).thenReturn(way)
-        on(osmDao.getNode(1)).thenReturn(node1)
-        on(osmDao.getNode(2)).thenReturn(node2)
-        on(osmDao.getNode(3)).thenReturn(node3)
-        on(osmDao.getNode(4)).thenReturn(node4)
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf())
+        way = OsmWay(0,1, mutableListOf(0,1,2,3), null)
+        on(osmDao.getNodes(any())).then { invocation ->
+            val nodeIds = invocation.getArgument(0) as List<Long>
+            nodeIds.map { nodeId -> n[nodeId.toInt()] }
+        }
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf())
     }
 
-    @Test(expected = IllegalArgumentException::class)
-    fun `throw if less than two split positions on closed way`() {
-        way = OsmWay(1, 1, mutableListOf(1,2,3,1), null)
-        doSplit(SplitWay(way, node1, node2, 0.5))
+    @Test(expected = ElementConflictException::class)
+    fun `raise conflict if less than two split positions on closed way`() {
+        way = OsmWay(0, 1, mutableListOf(0,1,2,0), null)
+        doSplit(SplitAtPoint(p[1]))
     }
 
     @Test(expected = ElementConflictException::class)
     fun `raise conflict if way was deleted`() {
-        on(osmDao.getWay(1)).thenReturn(null)
+        on(osmDao.getWay(0)).thenReturn(null)
         doSplit()
     }
 
     @Test(expected = ElementConflictException::class)
     fun `raise conflict if updated way was cut at the start`() {
-        on(osmDao.getWay(1)).thenReturn(wayWithNodes(2,3,4))
+        on(osmDao.getWay(0)).thenReturn(updatedWayWithNodes(1,2,3))
         doSplit()
     }
 
     @Test(expected = ElementConflictException::class)
     fun `raise conflict if updated way was cut at the end`() {
-        on(osmDao.getWay(1)).thenReturn(wayWithNodes(1,2,3))
+        on(osmDao.getWay(0)).thenReturn(updatedWayWithNodes(0,1,2))
         doSplit()
     }
 
     @Test(expected = ElementConflictException::class)
-    fun `raise conflict if updated way has split position at its very start`() {
-        on(osmDao.getWay(1)).thenReturn(wayWithNodes(2,3,4))
-        doSplit(SplitWay(way, node2, node3, 0.0))
+    fun `raise conflict if way has split position at its very start`() {
+        doSplit(SplitAtPoint(p[0]))
     }
 
     @Test(expected = ElementConflictException::class)
-    fun `raise conflict if first node is not in the updated way`() {
-        on(osmDao.getWay(1)).thenReturn(wayWithNodes(1,3,4))
-        doSplit()
+    fun `raise conflict if way has split position at its very end`() {
+        doSplit(SplitAtPoint(p[3]))
     }
 
     @Test(expected = ElementConflictException::class)
-    fun `raise conflict if second node is not in the updated way`() {
-        on(osmDao.getWay(1)).thenReturn(wayWithNodes(1,2,4))
-        doSplit()
+    fun `raise conflict if first split point of line split is not in the way`() {
+        way = OsmWay(0,1, mutableListOf(1,2), null)
+        doSplit(SplitAtLinePosition(p[0], p[1], 0.5))
     }
 
     @Test(expected = ElementConflictException::class)
-    fun `raise conflict if the second node is not directly after the first one in the updated way`() {
-        on(osmDao.getWay(1)).thenReturn(wayWithNodes(1,3,2,4))
-        doSplit()
+    fun `raise conflict if second split point of line split is not in the way`() {
+        way = OsmWay(0,1, mutableListOf(0,1), null)
+        doSplit(SplitAtLinePosition(p[1], p[2], 0.5))
     }
 
     @Test(expected = ElementConflictException::class)
-    fun `raise conflict if first node of split position was deleted`() {
-        on(osmDao.getNode(2)).thenReturn(null)
-        doSplit()
+    fun `raise conflict if split point of point split is not in the way`() {
+        way = OsmWay(0,1, mutableListOf(1,3), null)
+        doSplit(SplitAtPoint(p[2]))
     }
 
     @Test(expected = ElementConflictException::class)
-    fun `raise conflict if second node of split position was deleted`() {
-        on(osmDao.getNode(3)).thenReturn(null)
-        doSplit()
+    fun `raise conflict if the second node is not directly after the first one in the updated way`() {
+        way = OsmWay(0,1, mutableListOf(1,3,2), null)
+        doSplit(SplitAtLinePosition(p[1], p[2], 0.3))
     }
 
-    @Test(expected = ElementConflictException::class)
-    fun `raise conflict if first node of split position has been moved`() {
-        on(osmDao.getNode(2)).thenReturn(OsmNode(2, 2, 0.333, 0.333, null))
+    @Test(expected = ChangesetConflictException::class)
+    fun `raise changeset conflict on conflict of uploadChanges`() {
+        on(osmDao.uploadChanges(anyLong(), anyList(), any())).thenThrow(OsmConflictException(409, "jo", "ho"))
         doSplit()
     }
 
-    @Test(expected = ElementConflictException::class)
-    fun `raise conflict if second node of split position has been moved`() {
-        on(osmDao.getNode(3)).thenReturn(OsmNode(3, 2, 0.333, 0.333, null))
-        doSplit()
+    @Test fun `find node to split at from several alternatives`() {
+        way = OsmWay(0, 1, mutableListOf(0,1,2,0,3,0,1), null)
+        val elements = doSplit(SplitAtPoint(p[0]))
+        assertEquals(2, elements.ways.size)
+        assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
+            listOf(0,1,2,0),
+            listOf(0,3,0,1)
+        )))
     }
 
-    @Test(expected = ChangesetConflictException::class)
-    fun `raise changeset conflict on conflict of uploadChanges`() {
-        on(osmDao.uploadChanges(anyLong(), anyList(), any())).thenThrow(OsmConflictException(409, "jo", "ho"))
-        doSplit()
+    @Test fun `find line to split at from several alternatives`() {
+        way = OsmWay(0, 1, mutableListOf(0,1,2,0,3,0,1), null)
+        val elements = doSplit(SplitAtLinePosition(p[2],p[0], 0.5))
+        assertEquals(2, elements.ways.size)
+        assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
+            listOf(0,1,2,-1),
+            listOf(-1,0,3,0,1)
+        )))
+    }
+
+    @Test fun `the order in which SplitLineAtPosition is defined does not matter`() {
+        val elements = doSplit(SplitAtLinePosition(p[2],p[1], 0.5))
+        assertEquals(2, elements.ways.size)
+        assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
+            listOf(0,1,-1),
+            listOf(-1,2,3)
+        )))
     }
 
     @Test fun `merge last and first chunk for closed ways`() {
-        way = OsmWay(1,1, mutableListOf(1,2,3,4,1), null)
-        val elements = doSplit(
-            SplitWay(way, node2, node3, 0.0),
-            SplitWay(way, node3, node4, 0.0)
-        )
+        way = OsmWay(0,1, mutableListOf(0,1,2,3,0), null)
+        val elements = doSplit(SplitAtPoint(p[1]), SplitAtPoint(p[2]))
         assertEquals(2, elements.ways.size)
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
-            listOf(3,4,1,2),
-            listOf(2,3)
+            listOf(2,3,0,1),
+            listOf(1,2)
         )))
     }
 
     @Test fun `split way with one split position at vertex`() {
-        val elements = doSplit(SplitWay(way, node2, node3, 0.0))
+        val elements = doSplit(SplitAtPoint(p[1]))
         assertTrue(elements.nodes.isEmpty()) // no nodes were added
         assertEquals(2, elements.ways.size)
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
-            listOf(1,2),
-            listOf(2,3,4)
+            listOf(0,1),
+            listOf(1,2,3)
         )))
     }
 
     @Test fun `split way with one split position`() {
-        val elements = doSplit(SplitWay(way, node2, node3, 0.5))
+        val p1 = p[1]
+        val p2 = p[2]
+        val elements = doSplit(SplitAtLinePosition(p1, p2, 0.5))
         assertEquals(1, elements.nodes.size)
         assertEquals(2, elements.ways.size)
         val node = elements.nodes.single()
-        val p1 = node2.position
-        val p2 = node3.position
         assertEquals(
             SphericalEarthMath.createTranslated(
                 p1.latitude + 0.5 * (p2.latitude - p1.latitude),
@@ -157,170 +179,167 @@ class SplitSingleWayUploadTest {
         )
 
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
-            listOf(1,2,-1),
-            listOf(-1,3,4)
+            listOf(0,1,-1),
+            listOf(-1,2,3)
         )))
     }
 
     @Test fun `split way with several split position at vertices`() {
-        // 1   2   3   4
+        // 0   1   2   3
         //     |   |
-        val elements = doSplit(
-            SplitWay(way, node2, node3, 0.0),
-            SplitWay(way, node3, node4, 0.0)
-        )
+        val elements = doSplit(SplitAtPoint(p[1]), SplitAtPoint(p[2]))
 
         assertTrue(elements.nodes.isEmpty()) // no nodes were added
         assertEquals(3, elements.ways.size)
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
+            listOf(0,1),
             listOf(1,2),
-            listOf(2,3),
-            listOf(3,4)
+            listOf(2,3)
         )))
     }
 
     @Test fun `split way with multiple split positions`() {
-        // 1   2   3   4
+        // 0   1   2   3
         //       |   |
         val elements = doSplit(
-            SplitWay(way, node2, node3, 0.5),
-            SplitWay(way, node3, node4, 0.5)
+            SplitAtLinePosition(p[1], p[2], 0.5),
+            SplitAtLinePosition(p[2], p[3], 0.5)
         )
 
         assertEquals(2, elements.nodes.size)
         assertEquals(3, elements.ways.size)
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
-            listOf(1,2,-1),
-            listOf(-1,3,-2),
-            listOf(-2,4)
+            listOf(0,1,-1),
+            listOf(-1,2,-2),
+            listOf(-2,3)
         )))
     }
 
     @Test fun `split way with multiple split positions, one of which is at vertices`() {
-        // 1   2   3   4
+        // 0   1   2   3
         //   | |
         val elements = doSplit(
-            SplitWay(way, node1, node2, 0.5),
-            SplitWay(way, node2, node3, 0.0)
+            SplitAtLinePosition(p[0], p[1], 0.5),
+            SplitAtPoint(p[1])
         )
 
         assertEquals(1, elements.nodes.size)
         assertEquals(3, elements.ways.size)
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
-            listOf(1,-1),
-            listOf(-1,2),
-            listOf(2,3,4)
+            listOf(0,-1),
+            listOf(-1,1),
+            listOf(1,2,3)
         )))
     }
 
     @Test fun `split way with multiple unordered split positions between the same nodes`() {
-        // 1  2  3  4
+        // 0  1  2  3
         //    ||||
         val elements = doSplit(
-            SplitWay(way, node2, node3, 0.66),
-            SplitWay(way, node3, node4, 0.0),
-            SplitWay(way, node2, node3, 0.0),
-            SplitWay(way, node2, node3, 0.33)
+            SplitAtLinePosition(p[1], p[2], 0.66),
+            SplitAtPoint(p[2]),
+            SplitAtPoint(p[1]),
+            SplitAtLinePosition(p[1], p[2], 0.33)
         )
 
         assertEquals(2, elements.nodes.size)
         assertEquals(5, elements.ways.size)
         assertTrue(elements.waysNodeIds.containsAll(listOf<List<Long>>(
-            listOf(1,2),
-            listOf(2,-1),
+            listOf(0,1),
+            listOf(1,-1),
             listOf(-1,-2),
-            listOf(-2,3),
-            listOf(3,4)
+            listOf(-2,2),
+            listOf(2,3)
         )))
     }
 
     @Test fun `reuse object id of longest split chunk (= second chunk)`() {
-        val elements = doSplit(SplitWay(way, node2, node3, 0.0))
+        val elements = doSplit(SplitAtPoint(p[1]))
         assertEquals(way.id, elements.ways.maxBy { it.nodeIds.size }?.id)
     }
 
     @Test fun `reuse object id of longest split chunk (= first chunk)`() {
-        val elements = doSplit(SplitWay(way, node3, node4, 0.0))
+        val elements = doSplit(SplitAtPoint(p[2]))
         assertEquals(way.id, elements.ways.maxBy { it.nodeIds.size }?.id)
     }
 
     @Test fun `insert all way chunks into relation the way is a member of`() {
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(1)), null)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(0)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(1,2,-1), listOf(-1,3,4)),
-            elements.memberNodeIdsByRelationId[1]
+            elements.memberNodeIdsByRelationId[0],
+            listOf<List<Long>>(listOf(0,1,-1), listOf(-1,2,3))
         )
     }
 
     @Test fun `insert all way chunks into multiple relations the way is a member of`() {
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(1)), null),
-            OsmRelation(2,1, membersForWays(listOf(1)), null)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(0)), null),
+            OsmRelation(1,1, membersForWays(listOf(0)), null)
         ))
         val elements = doSplit()
 
         assertEquals(2, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(1,2,-1), listOf(-1,3,4)),
-            elements.memberNodeIdsByRelationId[1]
+            elements.memberNodeIdsByRelationId[0],
+            listOf<List<Long>>(listOf(0,1,-1), listOf(-1,2,3))
         )
         assertEquals(
-            listOf<List<Long>>(listOf(1,2,-1), listOf(-1,3,4)),
-            elements.memberNodeIdsByRelationId[2]
+            elements.memberNodeIdsByRelationId[1],
+            listOf<List<Long>>(listOf(0,1,-1), listOf(-1,2,3))
         )
     }
 
     @Test fun `insert all way chunks multiple times into relation the way is a member of multiple times`() {
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(1,6,1), null))
-        on(osmDao.getWay(3)).thenReturn(OsmWay(3, 1, listOf(4,5,4), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(1,2,1,3)), null)
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(0,5,0), null))
+        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(3,4,3), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(0,1,0,2)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
+            elements.memberNodeIdsByRelationId[0],
             listOf<List<Long>>(
-                listOf(-1,3,4),
-                listOf(1,2,-1),
-                listOf(1,6,1),
-                listOf(1,2,-1),
-                listOf(-1,3,4),
-                listOf(4,5,4)
-            ),
-            elements.memberNodeIdsByRelationId[1]
+                listOf(-1,2,3),
+                listOf(0,1,-1),
+                listOf(0,5,0),
+                listOf(0,1,-1),
+                listOf(-1,2,3),
+                listOf(3,4,3)
+            )
         )
     }
 
     @Test fun `all way chunks in updated relations have the same role as the original way`() {
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(1), "cool role"), null),
-            OsmRelation(2,1, membersForWays(listOf(1), "not so cool role"), null)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(0), "cool role"), null),
+            OsmRelation(1,1, membersForWays(listOf(0), "not so cool role"), null)
         ))
         val relationsById = doSplit().relationsById
 
-        assertTrue(relationsById.getValue(1).members.all { it.role == "cool role" })
-        assertTrue(relationsById.getValue(2).members.all { it.role == "not so cool role" })
+        assertTrue(relationsById.getValue(0).members.all { it.role == "cool role" })
+        assertTrue(relationsById.getValue(1).members.all { it.role == "not so cool role" })
     }
 
     @Test fun `insert way chunks at correct position in the updated relation`() {
-        // 5 6 | 1 2 3 4 | 7 8  => 5 6 | 1 2 -1 | -1 3 4 | 7 8
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,6), null))
-        on(osmDao.getWay(3)).thenReturn(OsmWay(3, 1, listOf(7,8), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(2,1,3)), null)
+        // 4 5 | 0 1 2 3 | 6 7  => 4 5 | 0 1 -1 | -1 2 3 | 6 7
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(4,5), null))
+        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(6,7), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(1,0,2)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(5,6), listOf(1,2,-1), listOf(-1,3,4), listOf(7,8)),
-            elements.memberNodeIdsByRelationId[1]
+            listOf<List<Long>>(listOf(4,5), listOf(0,1,-1), listOf(-1,2,3), listOf(6,7)),
+            elements.memberNodeIdsByRelationId[0]
         )
     }
 
@@ -328,93 +347,93 @@ class SplitSingleWayUploadTest {
         /* while determining the orientation of the way in the relation, the neighbouring ways are
            downloaded and analyzed - if they do not exist anymore, this should not lead to a
            nullpointer exception */
+        on(osmDao.getWay(1)).thenReturn(null)
         on(osmDao.getWay(2)).thenReturn(null)
-        on(osmDao.getWay(3)).thenReturn(null)
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(2,1,3)), null)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(1,0,2)), null)
         ))
         doSplit()
     }
 
     @Test fun `insert way chunks backwards in the updated relation as end of reverse chain`() {
-        // 5 4 | 1 2 3 4  =>  5 4 | -1 3 4 | 1 2 -1
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,4), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(2,1)), null)
+        // 4 3 | 0 1 2 3  =>  4 3 | -1 2 3 | 0 1 -1
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(4,3), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(1,0)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(5,4), listOf(-1,3,4), listOf(1,2,-1)),
-            elements.memberNodeIdsByRelationId[1]
+            listOf<List<Long>>(listOf(4,3), listOf(-1,2,3), listOf(0,1,-1)),
+            elements.memberNodeIdsByRelationId[0]
         )
     }
 
     @Test fun `ignore non-way relation members when determining way orientation in relation`() {
-        // 5 4 | 1 2 3 4  =>  5 4 | -1 3 4 | 1 2 -1
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,4), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, mutableListOf<RelationMember>(
-                OsmRelationMember(2, "", WAY),
-                OsmRelationMember(1, "", NODE),
-                OsmRelationMember(2, "", RELATION),
+        // 4 3 | 0 1 2 3  =>  4 3 | -1 2 3 | 0 1 -1
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(4,3), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, mutableListOf<RelationMember>(
                 OsmRelationMember(1, "", WAY),
-                OsmRelationMember(1, "", NODE),
-                OsmRelationMember(2, "", RELATION)
+                OsmRelationMember(0, "", NODE),
+                OsmRelationMember(1, "", RELATION),
+                OsmRelationMember(0, "", WAY),
+                OsmRelationMember(0, "", NODE),
+                OsmRelationMember(1, "", RELATION)
             ), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(5,4), listOf(-1,3,4), listOf(1,2,-1)),
-            elements.memberNodeIdsByRelationId[1]
+            elements.memberNodeIdsByRelationId[0],
+            listOf<List<Long>>(listOf(4,3), listOf(-1,2,3), listOf(0,1,-1))
         )
     }
 
     @Test fun `insert way chunks forwards in the updated relation as end of chain`() {
-        // 5 1 | 1 2 3 4  =>  5 1 | 1 2 -1 | -1 3 4
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,1), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(2,1)), null)
+        // 4 0 | 0 1 2 3  =>  4 0 | 0 1 -1 | -1 2 3
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(4,0), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(1,0)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(5,1), listOf(1,2,-1), listOf(-1,3,4)),
-            elements.memberNodeIdsByRelationId[1]
+            elements.memberNodeIdsByRelationId[0],
+            listOf<List<Long>>(listOf(4,0), listOf(0,1,-1), listOf(-1,2,3))
         )
     }
 
     @Test fun `insert way chunks backwards in the updated relation as start of reverse chain`() {
-        // 1 2 3 4 | 5 1  =>  -1 3 4 | 1 2 -1 | 5 1
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,1), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(1,2)), null)
+        // 0 1 2 3 | 4 0  =>  -1 2 3 | 0 1 -1 | 4 0
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(4,0), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(0,1)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(-1,3,4), listOf(1,2,-1), listOf(5,1)),
-            elements.memberNodeIdsByRelationId[1]
+            elements.memberNodeIdsByRelationId[0],
+            listOf<List<Long>>(listOf(-1,2,3), listOf(0,1,-1), listOf(4,0))
         )
     }
 
     @Test fun `insert way chunks forwards in the updated relation as start of chain`() {
-        // 1 2 3 4 | 5 4  =>  1 2 -1 | -1 3 4 | 5 4
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,4), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, membersForWays(listOf(1,2)), null)
+        // 0 1 2 3 | 4 3  =>  0 1 -1 | -1 2 3 | 4 3
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(4,3), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, membersForWays(listOf(0,1)), null)
         ))
         val elements = doSplit()
 
         assertEquals(1, elements.relations.size)
         assertEquals(
-            listOf<List<Long>>(listOf(1,2,-1), listOf(-1,3,4), listOf(5,4)),
-            elements.memberNodeIdsByRelationId[1]
+            elements.memberNodeIdsByRelationId[0],
+            listOf<List<Long>>(listOf(0,1,-1), listOf(-1,2,3), listOf(4,3))
         )
     }
 
@@ -429,12 +448,12 @@ class SplitSingleWayUploadTest {
     private fun `update a restriction-like relation with split-way and via node`(
         relationType: String, via: String, role: String) {
         val otherRole = if (role == "from") "to" else "from"
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(4,5), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, mutableListOf<RelationMember>(
-                OsmRelationMember(1, role, WAY),
-                OsmRelationMember(2, otherRole, WAY),
-                OsmRelationMember(4, via, NODE)
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(3,4), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, mutableListOf<RelationMember>(
+                OsmRelationMember(0, role, WAY),
+                OsmRelationMember(1, otherRole, WAY),
+                OsmRelationMember(3, via, NODE)
             ), mapOf("type" to relationType))
         ))
         val elements = doSplit()
@@ -444,7 +463,7 @@ class SplitSingleWayUploadTest {
 
         val relationMember = relation.members[0]!!
         val newWay = elements.waysById.getValue(relationMember.ref)
-        assertEquals(listOf<Long>(-1,3,4), newWay.nodeIds.toList())
+        assertEquals(listOf<Long>(-1,2,3), newWay.nodeIds.toList())
         assertEquals(role, relationMember.role)
         assertEquals(WAY, relationMember.type)
     }
@@ -464,13 +483,13 @@ class SplitSingleWayUploadTest {
     private fun `update a restriction-like relation with split-way and via way`(
         relationType: String, via: String, role: String) {
         val otherRole = if (role == "from") "to" else "from"
-        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(6,8), null))
-        on(osmDao.getWay(3)).thenReturn(OsmWay(2, 1, listOf(6,5,4), null))
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, mutableListOf<RelationMember>(
-                OsmRelationMember(1, role, WAY),
-                OsmRelationMember(2, otherRole, WAY),
-                OsmRelationMember(3, via, WAY)
+        on(osmDao.getWay(1)).thenReturn(OsmWay(1, 1, listOf(5,7), null))
+        on(osmDao.getWay(2)).thenReturn(OsmWay(2, 1, listOf(5,4,3), null))
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, mutableListOf<RelationMember>(
+                OsmRelationMember(0, role, WAY),
+                OsmRelationMember(1, otherRole, WAY),
+                OsmRelationMember(2, via, WAY)
             ), mapOf("type" to relationType))
         ))
         val elements = doSplit()
@@ -480,18 +499,18 @@ class SplitSingleWayUploadTest {
 
         val fromRelationMember = relation.members[0]!!
         val fromWay = elements.waysById.getValue(fromRelationMember.ref)
-        assertEquals(listOf<Long>(-1,3,4), fromWay.nodeIds.toList())
+        assertEquals(listOf<Long>(-1,2,3), fromWay.nodeIds.toList())
         assertEquals(role, fromRelationMember.role)
         assertEquals(WAY, fromRelationMember.type)
     }
 
     @Test fun `no special treatment of restriction relation if the way has another role`() {
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, mutableListOf<RelationMember>(
-                OsmRelationMember(1, "another role", WAY),
-                OsmRelationMember(2, "from", WAY),
-                OsmRelationMember(4, "via", NODE),
-                OsmRelationMember(4, "to", WAY)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, mutableListOf<RelationMember>(
+                OsmRelationMember(0, "another role", WAY),
+                OsmRelationMember(1, "from", WAY),
+                OsmRelationMember(3, "via", NODE),
+                OsmRelationMember(3, "to", WAY)
             ), mapOf("type" to "restriction"))
         ))
         val elements = doSplit()
@@ -501,10 +520,10 @@ class SplitSingleWayUploadTest {
     }
 
     @Test fun `no special treatment of restriction relation if there is no via`() {
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, mutableListOf<RelationMember>(
-                OsmRelationMember(1, "from", WAY),
-                OsmRelationMember(2, "to", WAY)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, mutableListOf<RelationMember>(
+                OsmRelationMember(0, "from", WAY),
+                OsmRelationMember(1, "to", WAY)
             ), mapOf("type" to "restriction"))
         ))
         val elements = doSplit()
@@ -514,11 +533,11 @@ class SplitSingleWayUploadTest {
     }
 
     @Test fun `no special treatment of restriction relation if from-way does not touch via`() {
-        on(osmDao.getRelationsForWay(1)).thenReturn(listOf(
-            OsmRelation(1,1, mutableListOf<RelationMember>(
-                OsmRelationMember(1, "from", WAY),
-                OsmRelationMember(5, "via", NODE),
-                OsmRelationMember(2, "to", WAY)
+        on(osmDao.getRelationsForWay(0)).thenReturn(listOf(
+            OsmRelation(0,1, mutableListOf<RelationMember>(
+                OsmRelationMember(0, "from", WAY),
+                OsmRelationMember(4, "via", NODE),
+                OsmRelationMember(3, "to", WAY)
             ), mapOf("type" to "restriction"))
         ))
         val elements = doSplit()
@@ -543,7 +562,7 @@ class SplitSingleWayUploadTest {
         `update a restriction-like relation with split-way and via node`("destination_sign", "sign", "from")
     }
 
-    private fun doSplit(vararg splits: SplitWay = arrayOf(split)) : Elements {
+    private fun doSplit(vararg splits: SplitPolylineAtPosition = arrayOf(split)) : Elements {
         uploader.upload(0, way, splits.asList())
         val arg: ArgumentCaptor<Iterable<Element>> = argumentCaptor()
         verify(osmDao).uploadChanges(eq(0), arg.capture(), any())
@@ -558,7 +577,7 @@ class SplitSingleWayUploadTest {
         )
     }
 
-    private fun wayWithNodes(vararg nodes: Long) = OsmWay(1, 2, nodes.asList(), null)
+    private fun updatedWayWithNodes(vararg nodes: Long) = OsmWay(0, 2, nodes.asList(), null)
 
     private fun membersForWays(ids: List<Long>, role: String = ""): List<RelationMember> =
         ids.map { id -> OsmRelationMember(id, role, WAY) }.toMutableList()
diff --git a/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUploadTest.kt b/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUploadTest.kt
index 0d1076f09b7..20e50da2a8e 100644
--- a/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUploadTest.kt
+++ b/app/src/test/java/de/westnordost/streetcomplete/data/osm/upload/SplitWaysUploadTest.kt
@@ -2,7 +2,7 @@ package de.westnordost.streetcomplete.data.osm.upload
 
 import de.westnordost.osmapi.map.data.Way
 import de.westnordost.streetcomplete.data.osm.OsmQuestSplitWay
-import de.westnordost.streetcomplete.data.osm.persist.SplitWayDao
+import de.westnordost.streetcomplete.data.osm.persist.OsmQuestSplitWayDao
 import de.westnordost.streetcomplete.data.upload.OnUploadedChangeListener
 import de.westnordost.streetcomplete.on
 import de.westnordost.streetcomplete.any
@@ -19,7 +19,7 @@ import org.mockito.Mockito.*
 import java.util.concurrent.atomic.AtomicBoolean
 
 class SplitWaysUploadTest {
-    private lateinit var splitWayDB: SplitWayDao
+    private lateinit var splitWayDB: OsmQuestSplitWayDao
     private lateinit var elementDB: MergedElementDao
     private lateinit var changesetManager: OpenQuestChangesetsManager
     private lateinit var elementGeometryDB: ElementGeometryDao
@@ -30,7 +30,7 @@ class SplitWaysUploadTest {
     private lateinit var uploader: SplitWaysUpload
 
     @Before fun setUp() {
-        splitWayDB = mock(SplitWayDao::class.java)
+        splitWayDB = mock(OsmQuestSplitWayDao::class.java)
         elementDB = mock(MergedElementDao::class.java)
         on(elementDB.get(any(), ArgumentMatchers.anyLong())).thenReturn(mock(Way::class.java))
         changesetManager = mock(OpenQuestChangesetsManager::class.java)
diff --git a/app/src/test/java/de/westnordost/streetcomplete/ktx/CollectionsTest.kt b/app/src/test/java/de/westnordost/streetcomplete/ktx/CollectionsTest.kt
index d71cd1b4700..2c7944935bc 100644
--- a/app/src/test/java/de/westnordost/streetcomplete/ktx/CollectionsTest.kt
+++ b/app/src/test/java/de/westnordost/streetcomplete/ktx/CollectionsTest.kt
@@ -1,7 +1,6 @@
 package de.westnordost.streetcomplete.ktx
 
-import org.junit.Assert.assertEquals
-import org.junit.Assert.assertNull
+import org.junit.Assert.*
 import org.junit.Test
 
 class CollectionsTest {
@@ -49,4 +48,30 @@ class CollectionsTest {
     fun `findPrevious throws if negative index`() {
         assertNull(listOf(1, 2, 3).findPrevious(-1) { true })
     }
+
+    @Test fun `forEachPair with empty list`() {
+        listOf<String>().forEachPair { _, _ -> fail() }
+    }
+
+    @Test fun `forEachPair with list with only one element`() {
+        listOf(1).forEachPair { _, _ -> fail() }
+    }
+
+    @Test fun `forEachPair with several elements`() {
+        var counter = 0
+        listOf(1,2,3,4).forEachPair { first, second ->
+            assertEquals(first+1, second)
+            counter++
+        }
+        assertEquals(3, counter)
+    }
+
+    @Test fun `indexOfMaxBy with no elements`() {
+        assertEquals(-1, listOf<String>().indexOfMaxBy { it.length })
+    }
+
+    @Test fun `indexOfMaxBy with some elements`() {
+        assertEquals(2, listOf(3,4,8).indexOfMaxBy { it })
+        assertEquals(0, listOf(4,0,-1).indexOfMaxBy { it })
+    }
 }
