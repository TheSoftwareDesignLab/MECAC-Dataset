diff --git a/app/src/androidTest/java/de/westnordost/osmagent/util/SlippyMapMathTest.java b/app/src/androidTest/java/de/westnordost/osmagent/util/SlippyMapMathTest.java
new file mode 100644
index 00000000000..1292df9cbe6
--- /dev/null
+++ b/app/src/androidTest/java/de/westnordost/osmagent/util/SlippyMapMathTest.java
@@ -0,0 +1,46 @@
+package de.westnordost.osmagent.util;
+
+import android.graphics.Point;
+import android.graphics.Rect;
+
+import junit.framework.TestCase;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.westnordost.osmapi.map.data.BoundingBox;
+import de.westnordost.osmapi.map.data.LatLon;
+import de.westnordost.osmapi.map.data.OsmLatLon;
+
+public class SlippyMapMathTest extends TestCase
+{
+	public void testForthAndBack()
+	{
+		LatLon p = new OsmLatLon(53.0,9.0);
+		Point tile = SlippyMapMath.enclosingTile(p, 15);
+		BoundingBox bbox = SlippyMapMath.asBoundingBox(tile, 15);
+
+		assertTrue(bbox.getMinLatitude() <= p.getLatitude());
+		assertTrue(bbox.getMaxLatitude() >= p.getLatitude());
+		assertTrue(bbox.getMinLongitude() <= p.getLongitude());
+		assertTrue(bbox.getMaxLongitude() >= p.getLongitude());
+
+		Rect r = SlippyMapMath.enclosingTiles(bbox, 15);
+		BoundingBox bbox2 = SlippyMapMath.asBoundingBox(r, 15);
+
+		assertEquals(bbox, bbox2);
+
+
+	}
+
+	public void testAsTileList()
+	{
+		List<Point> ps = new ArrayList<>();
+		ps.add(new Point(1,1));
+		ps.add(new Point(2,1));
+		ps.add(new Point(1,2));
+		ps.add(new Point(2,2));
+
+		assertEquals(ps, SlippyMapMath.asTileList(new Rect(1,1,2,2)));
+	}
+}
diff --git a/app/src/main/assets/osmagent.yaml b/app/src/main/assets/osmagent.yaml
index eb5ff9a29bd..b22fe2fb962 100644
--- a/app/src/main/assets/osmagent.yaml
+++ b/app/src/main/assets/osmagent.yaml
@@ -41,6 +41,7 @@ styles:
 
 layers:
     osmagent_quests:
+        filter: { $zoom: { min: 14 } }
         data: { source: osmagent_quests }
         draw:
             quest-icons:
diff --git a/app/src/main/java/de/westnordost/osmagent/MainActivity.java b/app/src/main/java/de/westnordost/osmagent/MainActivity.java
index c4af305d9cb..7e9d8cc92d3 100644
--- a/app/src/main/java/de/westnordost/osmagent/MainActivity.java
+++ b/app/src/main/java/de/westnordost/osmagent/MainActivity.java
@@ -503,8 +503,12 @@ public void onClick(DialogInterface dialog, int which)
 
 	@Override public void onMapReady()
 	{
-		// TODO: only for now null (=ALL quests), later only where the user is standing
-		questController.retrieve(null);
+
+	}
+
+	@Override public void onFirstInView(BoundingBox bbox)
+	{
+		questController.retrieve(bbox);
 	}
 
 	@Override public void onClickedQuest(QuestGroup questGroup, Long questId)
diff --git a/app/src/main/java/de/westnordost/osmagent/tangram/OsmagentMapFragment.java b/app/src/main/java/de/westnordost/osmagent/tangram/OsmagentMapFragment.java
index 729f3e0be9d..1dc7683fa83 100644
--- a/app/src/main/java/de/westnordost/osmagent/tangram/OsmagentMapFragment.java
+++ b/app/src/main/java/de/westnordost/osmagent/tangram/OsmagentMapFragment.java
@@ -3,6 +3,7 @@
 import android.app.Activity;
 import android.graphics.Point;
 import android.graphics.PointF;
+import android.graphics.Rect;
 import android.support.annotation.Nullable;
 
 import com.mapzen.tangram.LngLat;
@@ -11,16 +12,21 @@
 import com.mapzen.tangram.TouchInput;
 
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import de.westnordost.osmagent.data.Quest;
 import de.westnordost.osmagent.data.QuestGroup;
 import de.westnordost.osmagent.data.osm.ElementGeometry;
+import de.westnordost.osmagent.util.SlippyMapMath;
 import de.westnordost.osmapi.map.data.BoundingBox;
 import de.westnordost.osmapi.map.data.LatLon;
 
-public class OsmagentMapFragment extends MapFragment
+public class OsmagentMapFragment extends MapFragment implements TouchInput.ScaleResponder,
+		TouchInput.ShoveResponder, TouchInput.RotateResponder, MapController.FeaturePickListener,
+		TouchInput.TapResponder, TouchInput.PanResponder
 {
 	private static final String MARKER_QUEST_ID = "quest_id";
 	private static final String MARKER_QUEST_GROUP = "quest_group";
@@ -31,6 +37,12 @@ public class OsmagentMapFragment extends MapFragment
 	private MapData questsLayer;
 	private MapData geometryLayer;
 
+	private LngLat lastPos;
+	private Rect lastDisplayedRect;
+	private Set<Point> retrievedTiles;
+	private static int RETRIEVED_TILES_ZOOM = 14;
+	private static int MIN_ZOOM_TO_DISPLAY_QUESTS = 14;
+
 	private Listener listener;
 
 	public interface Listener
@@ -38,6 +50,8 @@ public interface Listener
 		void onMapReady();
 		void onClickedQuest(QuestGroup questGroup, Long questId);
 		void onClickedMapAt(@Nullable LatLon position);
+		/** Called once the given bbox comes into view first (listener should get quests there) */
+		void onFirstInView(BoundingBox bbox);
 	}
 
 	@Override public void onAttach(Activity activity)
@@ -51,38 +65,66 @@ protected void initMap()
 	{
 		super.initMap();
 
+		retrievedTiles = new HashSet<>();
+
 		geometryLayer = controller.addDataLayer(GEOMETRY_LAYER);
 		questsLayer = controller.addDataLayer(QUESTS_LAYER);
 
-		controller.setFeaturePickListener(new MapController.FeaturePickListener()
-		{
-			@Override
-			public void onFeaturePick(Map<String, String> props, float positionX, float positionY)
-			{
-				boolean clickedMarker = props != null && props.containsKey(MARKER_QUEST_ID);
+		controller.setFeaturePickListener(this);
+		controller.setTapResponder(this);
+		controller.setRotateResponder(this);
+		controller.setShoveResponder(this);
+		controller.setScaleResponder(this);
+		controller.setPanResponder(this);
 
-				if(clickedMarker)
-				{
-					listener.onClickedQuest(
-							QuestGroup.valueOf(props.get(MARKER_QUEST_GROUP)),
-							Long.valueOf(props.get(MARKER_QUEST_ID))
-					);
-				}
-			}
-		});
+		lastPos = controller.getPosition();
 
-		controller.setTapResponder(new TouchInput.TapResponder()
-		{
-			@Override public boolean onSingleTapUp(float x, float y)
-			{
-				return false;
-			}
+		listener.onMapReady();
+	}
 
-			@Override public boolean onSingleTapConfirmed(float x, float y)
-			{
-				controller.pickFeature(x,y);
+	@Override public boolean onScale(float x, float y, float scale, float velocity)
+	{
+		updateView();
+		// okay, scale
+		return false;
+	}
+
+	@Override public boolean onPan(float startX, float startY, float endX, float endY)
+	{
+		updateView();
+		// okay, pan
+		return false;
+	}
+
+	@Override public boolean onFling(float posX, float posY, float velocityX, float velocityY)
+	{
+		updateView();
+		// okay, fling
+		return false;
+	}
+
+	@Override public boolean onShove(float distance)
+	{
+		// no tilting the map! (for now)
+		return true;
+	}
+
+	@Override public boolean onRotate(float x, float y, float rotation)
+	{
+		// no rotating the map! (for now)
+		return true;
+	}
+
+	@Override public boolean onSingleTapUp(float x, float y)
+	{
+		return false;
+	}
+
+	@Override public boolean onSingleTapConfirmed(float x, float y)
+	{
+		controller.pickFeature(x,y);
 
-				// TODO use later!:
+		// TODO use later!:
 				/*LngLat lngLat = controller.screenPositionToLngLat(new PointF(x,y));
 				LatLon latLon = null;
 				if(lngLat != null)
@@ -91,29 +133,58 @@ public void onFeaturePick(Map<String, String> props, float positionX, float posi
 				}
 				listener.onClickedMapAt(latLon);*/
 
-				return true;
-			}
-		});
+		return true;
+	}
 
-		controller.setRotateResponder(new TouchInput.RotateResponder()
-		{
-			@Override public boolean onRotate(float x, float y, float rotation)
-			{
-				// no rotating the map! (for now)
-				return true;
-			}
-		});
+	@Override
+	public void onFeaturePick(Map<String, String> props, float positionX, float positionY)
+	{
+		boolean clickedMarker = props != null && props.containsKey(MARKER_QUEST_ID);
 
-		controller.setShoveResponder(new TouchInput.ShoveResponder()
+		if(clickedMarker)
 		{
-			@Override public boolean onShove(float distance)
-			{
-				// no tilting the map! (for now)
-				return true;
-			}
-		});
+			listener.onClickedQuest(
+					QuestGroup.valueOf(props.get(MARKER_QUEST_GROUP)),
+					Long.valueOf(props.get(MARKER_QUEST_ID))
+			);
+		}
+	}
 
-		listener.onMapReady();
+	private void updateView()
+	{
+		if(controller.getZoom() < MIN_ZOOM_TO_DISPLAY_QUESTS) return;
+
+		// check if anything changed (needs to be extended when I reenable tilt and rotation)
+		LngLat positionNow = controller.getPosition();
+		if(lastPos != null  && lastPos.equals(positionNow)) return;
+		lastPos = positionNow;
+
+		BoundingBox displayedArea = getDisplayedArea();
+		if(displayedArea == null) return;
+
+		Rect tilesRect = SlippyMapMath.enclosingTiles(displayedArea, RETRIEVED_TILES_ZOOM);
+		if(lastDisplayedRect != null && lastDisplayedRect.equals(tilesRect)) return;
+		lastDisplayedRect = tilesRect;
+
+		List<Point> tiles = SlippyMapMath.asTileList(tilesRect);
+		tiles.removeAll(retrievedTiles);
+
+		Rect minRect = SlippyMapMath.minRect(tiles);
+		if(minRect == null) return;
+		BoundingBox bbox = SlippyMapMath.asBoundingBox(minRect, RETRIEVED_TILES_ZOOM);
+
+		listener.onFirstInView(bbox);
+
+		// debugging
+		/*List<LatLon> corners = new ArrayList<LatLon>(4);
+		corners.add(bbox.getMin());
+		corners.add(new OsmLatLon(bbox.getMinLatitude(), bbox.getMaxLongitude()));
+		corners.add(bbox.getMax());
+		corners.add(new OsmLatLon(bbox.getMaxLatitude(), bbox.getMinLongitude()));
+		ElementGeometry e = new ElementGeometry(null, Collections.singletonList(corners));
+		addQuestGeometry(e);*/
+
+		retrievedTiles.addAll(tiles);
 	}
 
 	public void addQuestGeometry(ElementGeometry g)
@@ -191,20 +262,10 @@ public BoundingBox getDisplayedArea()
 		if(controller.getTilt() > Math.PI / 4f) return null; // 45Â°
 
 		LatLon[] positions = new LatLon[4];
-		try
-		{
-			positions[0] = getLatLonAtPos(new PointF(0,0));
-			positions[1] = getLatLonAtPos(new PointF(size.x, 0));
-			positions[2] = getLatLonAtPos(new PointF(0,size.y));
-			positions[3] = getLatLonAtPos(new PointF(size));
-		}
-		// screenPositionToLngLat returns positions out of range (crossing 180th meridian?)
-		catch(IllegalArgumentException e)
-		{
-			// in any case, this special case is not really relevant for this app, we are not
-			// downloading huge areas here
-			return null;
-		}
+		positions[0] = getLatLonAtPos(new PointF(0,0));
+		positions[1] = getLatLonAtPos(new PointF(size.x, 0));
+		positions[2] = getLatLonAtPos(new PointF(0,size.y));
+		positions[3] = getLatLonAtPos(new PointF(size));
 
 		// dealing with rotation: find each the largest latlon and the smallest latlon, that'll
 		// be our bounding box
diff --git a/app/src/main/java/de/westnordost/osmagent/util/SlippyMapMath.java b/app/src/main/java/de/westnordost/osmagent/util/SlippyMapMath.java
new file mode 100644
index 00000000000..8a8f3241a1d
--- /dev/null
+++ b/app/src/main/java/de/westnordost/osmagent/util/SlippyMapMath.java
@@ -0,0 +1,97 @@
+package de.westnordost.osmagent.util;
+
+
+import android.graphics.Point;
+import android.graphics.Rect;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import de.westnordost.osmapi.map.data.BoundingBox;
+import de.westnordost.osmapi.map.data.LatLon;
+import de.westnordost.osmapi.map.data.OsmLatLon;
+
+/** Taken from http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames#Java */
+public class SlippyMapMath
+{
+	public static Rect enclosingTiles(BoundingBox bbox, int zoom)
+	{
+		double notTheNextTile = 0.0000001;
+		Point min = enclosingTile(bbox.getMin(), zoom);
+		Point max = enclosingTile(
+				new OsmLatLon(
+						bbox.getMaxLatitude() - notTheNextTile,
+						bbox.getMaxLongitude() - notTheNextTile),
+				zoom);
+		return new Rect(min.x, max.y, max.x, min.y);
+	}
+
+	public static Point enclosingTile(LatLon pos, int zoom)
+	{
+		double radianLat = Math.toRadians(pos.getLatitude());
+
+		int tiles = 1<<zoom;
+		int xtile = (int) Math.floor( (pos.getLongitude() + 180) / 360 * tiles ) ;
+		int ytile = (int) Math.floor( (1 - Math.log(Math.tan(radianLat) + 1 / Math.cos(radianLat)) / Math.PI) / 2 * tiles ) ;
+
+		xtile = Math.max(0, Math.min(xtile , tiles - 1));
+		ytile = Math.max(0, Math.min(ytile , tiles - 1));
+
+		return new Point(xtile, ytile);
+	}
+
+	public static BoundingBox asBoundingBox(Point tile, int zoom)
+	{
+		return new BoundingBox(
+				tile2lat(tile.y + 1, zoom),
+				tile2lon(tile.x, zoom),
+				tile2lat(tile.y, zoom),
+				tile2lon(tile.x + 1, zoom)
+		);
+	}
+
+	public static BoundingBox asBoundingBox(Rect tiles, int zoom)
+	{
+		return new BoundingBox(
+				tile2lat(tiles.bottom + 1, zoom),
+				tile2lon(tiles.left, zoom),
+				tile2lat(tiles.top, zoom),
+				tile2lon(tiles.right + 1, zoom)
+		);
+	}
+
+	public static List<Point> asTileList(Rect tiles)
+	{
+		int size = (1 + tiles.height()) * (1 + tiles.width());
+		List<Point> tileList = new ArrayList<>(size);
+		for(int y = tiles.top; y <= tiles.bottom; ++y)
+			for(int x = tiles.left; x <= tiles.right; ++x)
+				tileList.add(new Point(x,y));
+
+		return tileList;
+	}
+
+	/** Minimum rect that encloses all the given tiles */
+	public static Rect minRect(List<Point> tiles)
+	{
+		if(tiles.isEmpty()) return null;
+		Integer bottom = null, top = null, left = null, right = null;
+		for(Point p : tiles)
+		{
+			if(bottom == null || bottom < p.y) bottom = p.y;
+			if(top == null || top > p.y) top = p.y;
+			if(left == null || left > p.x) left = p.x;
+			if(right == null || right < p.x) right = p.x;
+		}
+		return new Rect(left, top, right, bottom);
+	}
+
+	private static double tile2lon(int x, int z) {
+		return x / Math.pow(2.0, z) * 360.0 - 180;
+	}
+
+	private static double tile2lat(int y, int z) {
+		double n = Math.PI - (2.0 * Math.PI * y) / Math.pow(2.0, z);
+		return Math.toDegrees(Math.atan(Math.sinh(n)));
+	}
+}
\ No newline at end of file
