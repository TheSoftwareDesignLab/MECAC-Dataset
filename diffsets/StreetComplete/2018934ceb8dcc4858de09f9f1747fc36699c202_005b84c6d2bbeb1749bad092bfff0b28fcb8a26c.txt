diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/LocationAwareMapFragment.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/LocationAwareMapFragment.kt
index aeba69f85e2..4fc57040126 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/LocationAwareMapFragment.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/LocationAwareMapFragment.kt
@@ -22,7 +22,6 @@ import de.westnordost.streetcomplete.util.location.FineLocationManager
 import de.westnordost.streetcomplete.util.location.LocationAvailabilityReceiver
 import de.westnordost.streetcomplete.util.prefs.Preferences
 import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.delay
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
 import kotlinx.serialization.encodeToString
@@ -147,9 +146,11 @@ open class LocationAwareMapFragment : MapFragment() {
             viewLifecycleOwner.lifecycle.addObserver(locationMapComponent)
         }
 
-        tracksMapComponent = TracksMapComponent(ctx, style, map)
-        val positionsLists = tracks.map { track -> track.map { it.position } }
-        tracksMapComponent?.setTracks(positionsLists, isRecordingTracks)
+        tracksMapComponent = TracksMapComponent(ctx, style, map).also { tracksMapComponent ->
+            viewLifecycleOwner.lifecycle.addObserver(tracksMapComponent)
+            val positionsLists = tracks.map { track -> track.map { it.position } }
+            tracksMapComponent.setTracks(positionsLists, isRecordingTracks)
+        }
 
         tracksMapComponent?.layers?.forEach { map.style?.addLayer(it) }
         locationMapComponent?.layers?.forEach { map.style?.addLayer(it) }
@@ -265,8 +266,6 @@ open class LocationAwareMapFragment : MapFragment() {
         // in rare cases, onLocationChanged may already be called before the view has been created
         // so we need to check that first
         if (view != null) {
-            // delay update by 600 ms because the animation to the new location takes that long
-            delay(600)
             withContext(Dispatchers.Main) { tracksMapComponent?.addToCurrentTrack(trackpoint.position) }
         }
     }
diff --git a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/components/TracksMapComponent.kt b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/components/TracksMapComponent.kt
index c3b019ed1f8..3361da4f7a7 100644
--- a/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/components/TracksMapComponent.kt
+++ b/app/src/main/java/de/westnordost/streetcomplete/screens/main/map/components/TracksMapComponent.kt
@@ -1,14 +1,17 @@
 package de.westnordost.streetcomplete.screens.main.map.components
 
+import android.animation.ValueAnimator
 import android.content.Context
+import android.view.animation.AccelerateDecelerateInterpolator
 import androidx.annotation.UiThread
+import androidx.lifecycle.DefaultLifecycleObserver
+import androidx.lifecycle.LifecycleOwner
 import com.google.gson.JsonObject
 import com.mapbox.geojson.Feature
 import com.mapbox.geojson.FeatureCollection
 import com.mapbox.geojson.LineString
 import com.mapbox.geojson.Point
 import de.westnordost.streetcomplete.R
-import org.maplibre.android.geometry.LatLng
 import org.maplibre.android.maps.MapLibreMap
 import org.maplibre.android.style.expressions.Expression.*
 import org.maplibre.android.style.layers.Layer
@@ -18,131 +21,154 @@ import org.maplibre.android.style.layers.PropertyFactory.*
 import org.maplibre.android.style.sources.GeoJsonSource
 import de.westnordost.streetcomplete.data.osm.mapdata.LatLon
 import de.westnordost.streetcomplete.screens.main.map.maplibre.clear
-import de.westnordost.streetcomplete.screens.main.map.maplibre.toLatLng
 import de.westnordost.streetcomplete.util.ktx.isApril1st
+import de.westnordost.streetcomplete.util.math.normalizeLongitude
 import org.maplibre.android.maps.Style
 import kotlin.math.max
 
 /** Takes care of showing the path(s) walked on the map */
-class TracksMapComponent(context: Context, mapStyle: Style, private val map: MapLibreMap) {
+class TracksMapComponent(context: Context, mapStyle: Style, private val map: MapLibreMap)
+    : DefaultLifecycleObserver {
     /* There are two sources simply as a performance optimization: If there are thousands of
        trackpoints, we don't want to update (=copy) the thousands of points each time a new
        trackpoint is added. Instead, we only update a list of 100 trackpoints each time a new
        trackpoint is added and every 100th time, we update the other layer.
 
        So, the list of points updated ~per second doesn't grow too long.
+       The animation source is just the last line, whose progress is animated.
      */
+    private val trackAnimationSource = GeoJsonSource("animate-track-source")
+    private val animation = ValueAnimator.ofFloat(0f, 1f)
+
     private val trackSource = GeoJsonSource("track-source")
     private val oldTrackSource = GeoJsonSource("old-track-source")
 
-    private var index = 0
-    private data class Track(val trackpoints: MutableList<LatLng>, val isRecording: Boolean)
-    private var tracks: MutableList<Track> = arrayListOf(Track(ArrayList(), false))
+    private data class Track(val trackpoints: MutableList<LatLon>, val isRecording: Boolean)
+    private var track: Track = Track(ArrayList(), false)
+    private var oldTracks: MutableList<MutableList<LatLon>> = arrayListOf()
 
-    val layers: List<Layer> = if (!isApril1st()) listOf(
-        LineLayer("track", "track-source")
-            .withProperties(
-                lineWidth(14f),
-                lineColor(switchCase(
-                    get("recording"), literal("#fe1616"),
-                    literal("#536dfe")
-                )),
-                lineOpacity(0.3f),
-                lineCap(Property.LINE_CAP_ROUND)
-            ),
-        LineLayer("old-track", "old-track-source")
-            .withProperties(
-                lineWidth(14f),
-                lineColor(switchCase(
-                    get("recording"), literal("#fe1616"),
-                    literal("#536dfe")
-                )),
-                lineOpacity(0.15f),
-                lineCap(Property.LINE_CAP_ROUND),
-            )
-    ) else listOf(
+    private val commonTrackProperties get() = if (!isApril1st()) arrayOf(
+        lineWidth(6f),
+        lineColor(switchCase(
+            get("recording"), literal("#fe1616"),
+            literal("#536dfe")
+        ))
+    ) else arrayOf(
+        lineWidth(26f),
+        linePattern(switchCase(
+            get("recording"), literal("trackRecordImg"),
+            literal("trackImg")
+        ))
+    )
+
+    val layers: List<Layer> = listOf(
+        LineLayer("animate-track", "animate-track-source")
+            .withProperties(*commonTrackProperties, lineOpacity(0.6f)),
         LineLayer("track", "track-source")
-            .withProperties(
-                lineWidth(34f),
-                linePattern(switchCase(
-                    get("recording"), literal("trackRecordImg"),
-                    literal("trackImg")
-                )),
-                lineOpacity(1.0f),
-                lineCap(Property.LINE_CAP_ROUND)
-            ),
+            .withProperties(*commonTrackProperties, lineOpacity(0.6f)),
         LineLayer("old-track", "old-track-source")
-            .withProperties(
-                lineWidth(34f),
-                linePattern(switchCase(
-                    get("recording"), literal("trackRecordImg"),
-                    literal("trackImg")
-                )),
-                lineOpacity(0.25f),
-                lineCap(Property.LINE_CAP_ROUND)
-            )
+            .withProperties(*commonTrackProperties, lineOpacity(0.2f))
     )
 
     init {
+        trackAnimationSource.isVolatile = true
         trackSource.isVolatile = true
         oldTrackSource.isVolatile = true
 
+        animation.duration = 600L
+        animation.interpolator = AccelerateDecelerateInterpolator()
+        animation.addUpdateListener { updateAnimatedTrack(it.animatedValue as Float) }
+
         if (isApril1st()) {
             mapStyle.addImage("trackImg", context.getDrawable(R.drawable.track_nyan)!!)
             mapStyle.addImage("trackRecordImg", context.getDrawable(R.drawable.track_nyan_record)!!)
         }
 
+        map.style?.addSource(trackAnimationSource)
         map.style?.addSource(trackSource)
         map.style?.addSource(oldTrackSource)
     }
 
+    override fun onPause(owner: LifecycleOwner) {
+        animation.pause()
+    }
+
+    override fun onResume(owner: LifecycleOwner) {
+        animation.resume()
+    }
+
+    override fun onDestroy(owner: LifecycleOwner) {
+        animation.cancel()
+    }
+
     /** Add a point to the current track */
     @UiThread fun addToCurrentTrack(pos: LatLon) {
-        val track = tracks.last()
-        track.trackpoints.add(pos.toLatLng())
-        val trackpoints = track.trackpoints
-
-        // every 100th trackpoint, move the index to the back
-        if (trackpoints.size - index > 100) {
-            putAllTracksInOldLayer()
-        } else {
-            trackSource.setGeoJson(trackpoints.toLineFeature(track.isRecording))
+        track.trackpoints.add(pos)
+        // every 100th trackpoint, move older trackpoints to old tracks
+        if (track.trackpoints.size > 100) {
+            oldTracks.add(track.trackpoints.subList(0, 50).toMutableList())
+            val lastPoints = track.trackpoints.subList(50, track.trackpoints.size).toMutableList()
+            track.trackpoints.clear()
+            track.trackpoints.addAll(lastPoints)
+            updateOldTracks()
         }
+        updateTrack()
     }
 
     /** Start a new track. I.e. the points in that track will be drawn as an own polyline */
     @UiThread fun startNewTrack(record: Boolean) {
-        tracks.add(Track(ArrayList(), record))
-        putAllTracksInOldLayer()
+        animation.cancel()
+        oldTracks.add(track.trackpoints)
+        track = Track(ArrayList(), record)
+        updateOldTracks()
+        trackSource.clear()
+        trackAnimationSource.clear()
     }
 
-    /** Set all the tracks (when re-initializing), if recording the last track is the only recording */
+    /** Set all the tracks (when re-initializing) */
     @UiThread fun setTracks(pointsList: List<List<LatLon>>, isRecording: Boolean) {
         require(pointsList.isNotEmpty())
-        tracks = pointsList.mapIndexed { index, track ->
-            var recording = false
-            if (isRecording && index == pointsList.size - 1) {
-                recording = true
-            }
-            Track(track.map { it.toLatLng() }.toMutableList(), recording)
-        }.toMutableList()
-        putAllTracksInOldLayer()
+        oldTracks = pointsList.map { it.toMutableList() }.toMutableList()
+        track = Track(ArrayList(), isRecording)
+        updateOldTracks()
     }
 
-    private fun putAllTracksInOldLayer() {
-        index = max(0, tracks.last().trackpoints.lastIndex)
+    @UiThread fun clear() {
+        animation.cancel()
+        oldTracks.clear()
+        track = Track(ArrayList(), false)
         trackSource.clear()
-        val features = tracks.map { it.trackpoints.toLineFeature(it.isRecording) }
-        oldTrackSource.setGeoJson(FeatureCollection.fromFeatures(features))
+        oldTrackSource.clear()
+        trackAnimationSource.clear()
     }
 
-    @UiThread fun clear() {
-        tracks = ArrayList()
-        startNewTrack(false)
+    private fun updateAnimatedTrack(progress: Float) {
+        val size = track.trackpoints.size
+        val s = track.trackpoints[size - 2] // TODO
+        val e = track.trackpoints[size - 1]
+        val animated = LatLon(
+            latitude = s.latitude + (e.latitude - s.latitude) * progress,
+            longitude = normalizeLongitude(s.longitude + (e.longitude - s.longitude) * progress)
+        )
+        trackAnimationSource.setGeoJson(listOf(s, animated).toLineFeature(track.isRecording))
+    }
+
+    private fun updateTrack() {
+        val trackpoints = track.trackpoints
+        val pointsExceptLast = trackpoints.subList(0, max(0, trackpoints.size - 1))
+        trackSource.setGeoJson(pointsExceptLast.toLineFeature(track.isRecording))
+        if (trackpoints.size >= 2) {
+            animation.start()
+        }
+    }
+
+    private fun updateOldTracks() {
+        val features = oldTracks.map { it.toLineFeature(false) }
+        oldTrackSource.setGeoJson(FeatureCollection.fromFeatures(features))
     }
 }
 
-private fun List<LatLng>.toLineFeature(record: Boolean): Feature {
+private fun List<LatLon>.toLineFeature(record: Boolean): Feature {
     val line = LineString.fromLngLats(map { Point.fromLngLat(it.longitude, it.latitude) })
     val p = JsonObject()
     p.addProperty("recording", record)
