diff --git a/DataExtractionOSM/src/net/osmand/render/default.render.xml b/DataExtractionOSM/src/net/osmand/render/default.render.xml
index 8e1da12ba81..73117071423 100644
--- a/DataExtractionOSM/src/net/osmand/render/default.render.xml
+++ b/DataExtractionOSM/src/net/osmand/render/default.render.xml
@@ -306,7 +306,7 @@
 			<case tag="amenity" value="fast_food" />
 			<case tag="amenity" value="pub" />
 			<case tag="amenity" value="bar" />
-			<filter minzoom="17" textSize="12" textColor="#734a08" textHaloRadius="1" textDy="13" textWrapWidth="34" />
+			<filter minzoom="17" textSize="12" textColor="#734a08" textHaloRadius="1" textDy="13" textWrapWidth="34"  />
 		</switch>
 
 		<filter minzoom="16" textSize="12" textColor="#000033" textWrapWidth="16" tag="amenity" value="kindergarten" />
diff --git a/OsmAnd/res/values/strings.xml b/OsmAnd/res/values/strings.xml
index 0c0bc8afe65..f81e3761adf 100644
--- a/OsmAnd/res/values/strings.xml
+++ b/OsmAnd/res/values/strings.xml
@@ -1,5 +1,7 @@
 <?xml version="1.0" encoding="utf-8" standalone="no"?>
 <resources>
+	<string name="map_text_size_descr">Select text size for names on the map</string>
+	<string name="map_text_size">Text size</string>
 	<string name="trace_rendering">Rendering debug info</string>
 	<string name="trace_rendering_descr">Show rendering performance data for debugging purposes</string>
 	<string name="tip_recent_changes">Recent changes</string>
diff --git a/OsmAnd/res/xml/settings_pref.xml b/OsmAnd/res/xml/settings_pref.xml
index bd62803a4f2..6d44529d506 100644
--- a/OsmAnd/res/xml/settings_pref.xml
+++ b/OsmAnd/res/xml/settings_pref.xml
@@ -22,6 +22,7 @@
 			android:dialogMessage="@string/modify_transparency" android:title="@string/map_transparency" android:summary="@string/map_transparency_descr"/>
 		<CheckBoxPreference android:summary="@string/continuous_rendering_descr" android:title="@string/continuous_rendering"
 			android:key="use_step_by_step_rendering" />
+		<ListPreference android:key="map_text_size" android:title="@string/map_text_size" android:summary="@string/map_text_size_descr"/>
 		<CheckBoxPreference android:key="use_high_res_maps" android:title="@string/use_high_res_maps" android:summary="@string/use_high_res_maps_descr"></CheckBoxPreference>
 
 		<CheckBoxPreference android:summary="@string/trace_rendering_descr" android:title="@string/trace_rendering"
diff --git a/OsmAnd/src/net/osmand/plus/OsmandSettings.java b/OsmAnd/src/net/osmand/plus/OsmandSettings.java
index a02cdfd8155..dbfd4c1abc9 100644
--- a/OsmAnd/src/net/osmand/plus/OsmandSettings.java
+++ b/OsmAnd/src/net/osmand/plus/OsmandSettings.java
@@ -299,6 +299,29 @@ protected boolean setValue(SharedPreferences prefs, Integer val) {
 
 	}
 	
+	private class FloatPreference extends CommonPreference<Float> {
+
+
+		private FloatPreference(String id, float defaultValue, boolean global) {
+			super(id, global, defaultValue);
+		}
+		
+		private FloatPreference(String id, float defaultValue, boolean global, boolean cache) {
+			super(id, global, cache, defaultValue);
+		}
+		
+		@Override
+		protected Float getValue(SharedPreferences prefs, Float defaultValue) {
+			return prefs.getFloat(getId(), defaultValue);
+		}
+
+		@Override
+		protected boolean setValue(SharedPreferences prefs, Float val) {
+			return prefs.edit().putFloat(getId(), val).commit();
+		}
+
+	}
+	
 	private class StringPreference extends CommonPreference<String> {
 
 		private StringPreference(String id, String defaultValue, boolean global) {
@@ -373,6 +396,10 @@ protected boolean setValue(SharedPreferences prefs,E val) {
 	public final OsmandPreference<Boolean> USE_HIGH_RES_MAPS =
 		new BooleanPreference("use_high_res_maps", false, false, true);
 	
+	// this value string is synchronized with settings_pref.xml preference name
+	public final OsmandPreference<Float> MAP_TEXT_SIZE =
+		new FloatPreference("map_text_size", 1.0f, false, true);
+	
 
 	// this value string is synchronized with settings_pref.xml preference name
 	public final OsmandPreference<Boolean> SHOW_POI_OVER_MAP =
diff --git a/OsmAnd/src/net/osmand/plus/activities/SettingsActivity.java b/OsmAnd/src/net/osmand/plus/activities/SettingsActivity.java
index 84e207c2368..8b8f24b8dec 100644
--- a/OsmAnd/src/net/osmand/plus/activities/SettingsActivity.java
+++ b/OsmAnd/src/net/osmand/plus/activities/SettingsActivity.java
@@ -226,6 +226,13 @@ public void onCreate(Bundle savedInstanceState) {
 		}
 		registerListPreference(osmandSettings.MAX_LEVEL_TO_DOWNLOAD_TILE, screen, entries, intValues);
 		
+		Float[] floatValues = new Float[] {0.3f, 0.5f, 0.7f, 0.8f, 1.0f, 1.2f, 1.3f, 1.5f, 2.0f, 2.5f};
+		entries = new String[floatValues.length];
+		for (int i = 0; i < floatValues.length; i++) {
+			entries[i] = floatValues[i] +"";
+		}
+		registerListPreference(osmandSettings.MAP_TEXT_SIZE, screen, entries, floatValues);
+		
 		startZoom = 1;
 		endZoom = 18;
 		entries = new String[endZoom - startZoom + 1];
diff --git a/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java b/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java
index 96cff9953df..e808d909012 100644
--- a/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java
+++ b/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java
@@ -385,6 +385,7 @@ public synchronized void loadMap(RotatedTileBox tileRect, List<IMapDownloaderCal
 			currentRenderingContext.height = (int) (requestedBox.getTileHeight() * OsmandRenderer.TILE_SIZE);
 			currentRenderingContext.nightMode = nightMode;
 			currentRenderingContext.highResMode = prefs.USE_HIGH_RES_MAPS.get();
+			currentRenderingContext.mapTextSize = prefs.MAP_TEXT_SIZE.get();
 			if (checkWhetherInterrupted()) {
 				return;
 			}
diff --git a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
index 4875d854e19..e6014a8ba3e 100644
--- a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
@@ -107,6 +107,7 @@ private static class IconDrawInfo {
 		public boolean interrupted = false;
 		public boolean nightMode = false;
 		public boolean highResMode = false;
+		public float mapTextSize = 1;
 		
 		List<TextDrawInfo> textToDraw = new ArrayList<TextDrawInfo>();
 		List<IconDrawInfo> iconsToDraw = new ArrayList<IconDrawInfo>();
@@ -151,6 +152,7 @@ private static class IconDrawInfo {
 		RenderingPaintProperties second = new RenderingPaintProperties();
 		RenderingPaintProperties third = new RenderingPaintProperties();
 		RenderingPaintProperties[] adds = null;
+		
 
 		
 		public void clearText() {
@@ -226,6 +228,7 @@ public OsmandRenderer(Context context) {
 
 		paintText = new TextPaint();
 		paintText.setStyle(Style.FILL);
+		paintText.setStrokeWidth(1);
 		paintText.setColor(Color.BLACK);
 		paintText.setTextAlign(Align.CENTER);
 		paintText.setTypeface(Typeface.create("Droid Serif", Typeface.NORMAL)); //$NON-NLS-1$
@@ -414,9 +417,9 @@ private void notifyListeners(List<IMapDownloaderCallback> notifyList) {
 	
 	private float getDensityValue(RenderingContext rc, float val) {
 		if (rc.highResMode) {
-			return val * dm.density;
+			return val * dm.density * rc.mapTextSize;
 		} else {
-			return val;
+			return val * rc.mapTextSize;
 		}
 	}
 
@@ -431,9 +434,6 @@ public int compare(RectF object1, RectF object2) {
 			}
 			
 		};
-		paint.setStyle(Style.STROKE);
-		paint.setTextSize(10);
-		paint.setColor(Color.BLACK);
 		
 		nextText: for (int i = 0; i < size; i++) {
 			TextDrawInfo text  = rc.textToDraw.get(i);
@@ -447,76 +447,176 @@ public int compare(RectF object1, RectF object2) {
 				if(useEnglishNames){
 					text.text = Junidecode.unidecode(text.text);
 				}
-				RectF bounds = new RectF();
-				if(!rc.highResMode){
-					paintText.setTextSize(getDensityValue(rc, text.textSize));
-				} else {
-					paintText.setTextSize(text.textSize);
-				}
-				paintText.setFakeBoldText(text.bold);
-				boolean horizontalWayDisplay = (text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315);
-				float mes = paintText.measureText(text.text) + (!horizontalWayDisplay ? 0 : text.minDistance);
-				 // Paint.ascent is negative, so negate it.
-				int ascent = (int) Math.ceil(-paintText.ascent());
-				int descent = (int) Math.ceil(paintText.descent());
-				float textHeight = ascent + descent + (horizontalWayDisplay ? 0 : text.minDistance) + getDensityValue(rc, 5);
 				
 				
-				if(text.drawOnPath == null || horizontalWayDisplay){
-					bounds.set(text.centerX - mes / 2, text.centerY - textHeight / 2 ,
-							text.centerX + mes / 2 , text.centerY + textHeight / 2 );
-				} else {
-					bounds.set(text.centerX - textHeight / 2, text.centerY - mes / 2, 
-							text.centerX + textHeight / 2 , text.centerY + mes / 2);
+				// sest text size before finding intersection (it is used there)
+				float textSize = getDensityValue(rc, text.textSize);
+				paintText.setTextSize(textSize);
+				paintText.setFakeBoldText(text.bold);
+				paintText.setColor(text.textColor);
+				// align center y
+				text.centerY += (-paintText.ascent());
+				
+				// calculate if there is intersection
+				boolean intersects = findTextIntersection(rc, boundsNotPathIntersect, boundsPathIntersect, c, text);
+				if(intersects){
+					continue nextText;
 				}
-				List<RectF> boundsIntersect = text.drawOnPath == null || findAllTextIntersections? 
-						boundsNotPathIntersect : boundsPathIntersect;
-				if(boundsIntersect.isEmpty()){
-					boundsIntersect.add(bounds);
-				} else {
-					final int diff = (int) (getDensityValue(rc, 3));
-					final int diff2 = (int) (getDensityValue(rc, 15));
-					// implement binary search 
-					int index = Collections.binarySearch(boundsIntersect, bounds, c);
-					if (index < 0) {
-						index = -(index + 1);
+				
+				
+				if(text.drawOnPath != null){
+					if(text.textShadow > 0){
+						paintText.setColor(Color.WHITE);
+						paintText.setStyle(Style.STROKE);
+						paintText.setStrokeWidth(2 + text.textShadow);
+						cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
+						// reset
+						paintText.setStyle(Style.FILL);
+						paintText.setStrokeWidth(2);
+						paintText.setColor(text.textColor);
 					}
-					// find sublist that is appropriate
-					int e = index;
-					while (e < boundsIntersect.size()) {
-						if (boundsIntersect.get(e).left < bounds.right ) {
-							e++;
-						} else {
-							break;
+					cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
+				} else {
+					if (text.shieldRes != 0) {
+						if (cachedIcons.get(text.shieldRes) == null) {
+							cachedIcons.put(text.shieldRes, BitmapFactory.decodeResource(context.getResources(), text.shieldRes));
 						}
-					}
-					int st = index - 1;
-					while (st >= 0) {
-						// that's not exact algorithm that replace comparison rect with each other
-						// because of that comparison that is not obvious 
-						// (we store array sorted by left boundary, not by right) - that's euristic
-						if (boundsIntersect.get(st).right > bounds.left ) {
-							st--;
-						} else {
-							break;
+						Bitmap ico = cachedIcons.get(text.shieldRes);
+						if (ico != null) {
+							cv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f, text.centerY
+									- ico.getHeight() / 2 - getDensityValue(rc, 4.5f) 
+									, paintIcon);
 						}
 					}
-					if (st < 0) {
-						st = 0;
+					
+					drawWrappedText(cv, text, textSize);
+				}
+			}
+		}
+	}
+
+	private void drawWrappedText(Canvas cv, TextDrawInfo text, float textSize) {
+		if(text.textWrap == 0){
+			// set maximum for all text
+			text.textWrap = 40;
+		}
+		
+		if(text.text.length() > text.textWrap){
+			int start = 0;
+			int end = text.text.length();
+			int lastSpace = -1;
+			int line = 0;
+			int pos = 0;
+			int limit = 0;
+			while(pos < end){
+				lastSpace = -1;
+				limit += text.textWrap;
+				while(pos < limit && pos < end){
+					if(!Character.isLetterOrDigit(text.text.charAt(pos))){
+						lastSpace = pos;
 					}
-					// test functionality
+					pos++;
+				}
+				if(lastSpace == -1){
+					drawTextOnCanvas(cv, text.text.substring(start, pos), 
+							text.centerX, text.centerY + line * (textSize + 2), paintText, text.textShadow);
+					start = pos;
+				} else {
+					drawTextOnCanvas(cv, text.text.substring(start, lastSpace), 
+							text.centerX, text.centerY + line * (textSize + 2), paintText, text.textShadow); 
+					start = lastSpace + 1;
+					limit += (start - pos) - 1;
+				}
+				line++;
+				
+			}
+		} else {
+			drawTextOnCanvas(cv, text.text, text.centerX, text.centerY, paintText, text.textShadow);
+		}
+	}
+	
+	private void drawTextOnCanvas(Canvas cv, String text, float centerX, float centerY, Paint paint, float textShadow){
+		if(textShadow > 0){
+			int c = paintText.getColor();
+			paintText.setStyle(Style.STROKE);
+			paintText.setColor(Color.WHITE);
+			paintText.setStrokeWidth(2 + textShadow);
+			cv.drawText(text, centerX, centerY, paint);
+			cv.drawText(text, centerX, centerY, paint);
+			// reset
+			paintText.setStrokeWidth(2);
+			paintText.setStyle(Style.FILL);
+			paintText.setColor(c);
+		}
+		cv.drawText(text, centerX, centerY, paint);
+	}
+	
+
+	private boolean findTextIntersection(RenderingContext rc, List<RectF> boundsNotPathIntersect, List<RectF> boundsPathIntersect,
+			Comparator<RectF> c, TextDrawInfo text) {
+		boolean horizontalWayDisplay = (text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315);
+		float textWidth = paintText.measureText(text.text) + (!horizontalWayDisplay ? 0 : text.minDistance);
+		 // Paint.ascent is negative, so negate it.
+		int ascent = (int) Math.ceil(-paintText.ascent());
+		int descent = (int) Math.ceil(paintText.descent());
+		float textHeight = ascent + descent + (horizontalWayDisplay ? 0 : text.minDistance) + getDensityValue(rc, 5);
+		
+		RectF bounds = new RectF();
+		if(text.drawOnPath == null || horizontalWayDisplay){
+			bounds.set(text.centerX - textWidth / 2, text.centerY - textHeight / 2 ,
+					text.centerX + textWidth / 2 , text.centerY + textHeight / 2 );
+		} else {
+			bounds.set(text.centerX - textHeight / 2, text.centerY - textWidth / 2, 
+					text.centerX + textHeight / 2 , text.centerY + textWidth / 2);
+		}
+		List<RectF> boundsIntersect = text.drawOnPath == null || findAllTextIntersections? 
+				boundsNotPathIntersect : boundsPathIntersect;
+		if(boundsIntersect.isEmpty()){
+			boundsIntersect.add(bounds);
+		} else {
+			final int diff = (int) (getDensityValue(rc, 3));
+			final int diff2 = (int) (getDensityValue(rc, 15));
+			// implement binary search 
+			int index = Collections.binarySearch(boundsIntersect, bounds, c);
+			if (index < 0) {
+				index = -(index + 1);
+			}
+			// find sublist that is appropriate
+			int e = index;
+			while (e < boundsIntersect.size()) {
+				if (boundsIntersect.get(e).left < bounds.right ) {
+					e++;
+				} else {
+					break;
+				}
+			}
+			int st = index - 1;
+			while (st >= 0) {
+				// that's not exact algorithm that replace comparison rect with each other
+				// because of that comparison that is not obvious 
+				// (we store array sorted by left boundary, not by right) - that's euristic
+				if (boundsIntersect.get(st).right > bounds.left ) {
+					st--;
+				} else {
+					break;
+				}
+			}
+			if (st < 0) {
+				st = 0;
+			}
+			// test functionality
 //					 cv.drawRect(bounds, paint);
 //					 cv.drawText(text.text.substring(0, Math.min(5, text.text.length())), bounds.centerX(), bounds.centerY(), paint);
-					
-					for (int j = st; j < e; j++) {
-						RectF b = boundsIntersect.get(j);
-						float x = Math.min(bounds.right, b.right) - Math.max(b.left, bounds.left);
-						float y = Math.min(bounds.bottom, b.bottom) - Math.max(b.top, bounds.top);
-						if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
-							continue nextText;
-						}
-					}
-					// store in list sorted by left boundary
+			
+			for (int j = st; j < e; j++) {
+				RectF b = boundsIntersect.get(j);
+				float x = Math.min(bounds.right, b.right) - Math.max(b.left, bounds.left);
+				float y = Math.min(bounds.bottom, b.bottom) - Math.max(b.top, bounds.top);
+				if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
+					return true;
+				}
+			}
+			// store in list sorted by left boundary
 //					if(text.minDistance > 0){
 //						if (verticalText) {
 //							bounds.set(bounds.left + text.minDistance / 2, bounds.top, 
@@ -526,79 +626,9 @@ public int compare(RectF object1, RectF object2) {
 //									bounds.bottom - text.minDistance / 2);
 //						}
 //					}
-					boundsIntersect.add(index, bounds);
-				}
-				
-				
-				// Shadow layer
-				// paintText.setShadowLayer(text.textShadow, 0, 0, Color.WHITE);
-//				if(text.textShadow > 0){
-//					paintText.setColor(Color.WHITE);
-//					paintText.setTextSize(text.textSize + text.textShadow * 2);
-//					if(text.drawOnPath != null){
-//						cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
-//					} else {
-//						cv.drawText(text.text, text.centerX, text.centerY, paintText);
-//					}
-//					paintText.setTextSize(text.textSize);
-//				}
-				
-				
-				paintText.setColor(text.textColor);
-				if(text.drawOnPath != null){
-					cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
-				} else {
-					if(text.textWrap == 0){
-						// set maximum for all text
-						text.textWrap = 40;
-					}
-					if(text.shieldRes != 0){
-						if(cachedIcons.get(text.shieldRes) == null){
-							cachedIcons.put(text.shieldRes, BitmapFactory.decodeResource(context.getResources(), text.shieldRes));
-						}
-						Bitmap ico = cachedIcons.get(text.shieldRes);
-						if (ico  != null) {
-							cv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - getDensityValue(rc, 0.5f), 
-									text.centerY - text.textSize / 2 - getDensityValue(rc, 6.5f),
-									paintIcon);
-						}
-					}
-					if(text.text.length() > text.textWrap){
-						int start = 0;
-						int end = text.text.length();
-						int lastSpace = -1;
-						int line = 0;
-						int pos = 0;
-						int limit = 0;
-						while(pos < end){
-							lastSpace = -1;
-							limit += text.textWrap;
-							while(pos < limit && pos < end){
-								if(!Character.isLetterOrDigit(text.text.charAt(pos))){
-									lastSpace = pos;
-								}
-								pos++;
-							}
-							if(lastSpace == -1){
-								cv.drawText(text.text.substring(start, pos), 
-										text.centerX, text.centerY + line * (text.textSize + 2), paintText);
-								start = pos;
-							} else {
-								cv.drawText(text.text.substring(start, lastSpace), 
-										text.centerX, text.centerY + line * (text.textSize + 2), paintText); 
-								start = lastSpace + 1;
-								limit += (start - pos) - 1;
-							}
-							line++;
-							
-						}
-						
-					} else {
-						cv.drawText(text.text, text.centerX, text.centerY, paintText);
-					}
-				}
-			}
+				boundsIntersect.add(index, bounds);
 		}
+		return false;
 	}
 
 	
