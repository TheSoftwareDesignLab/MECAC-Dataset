diff --git a/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java b/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
index 1a77404da03..734fdade89a 100644
--- a/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
+++ b/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
@@ -609,6 +609,12 @@ public static void main(String[] args) throws IOException, SAXException, SQLExce
 //		creator.generateIndexes(new File("/home/victor/projects/OsmAnd/data/belarus-osm/belarus.osm.pbf"),
 //				new ConsoleProgressImplementation(1), null, MapZooms.getDefault(), null);
 		
+		creator.setNodesDBFile(new File("/home/victor/projects/OsmAnd/data/osm-gen/nodes3.tmp.odb"));
+		creator.generateIndexes(new File("/home/victor/projects/OsmAnd/data/osm-maps/stadion-dynamo.osm"),
+				new ConsoleProgressImplementation(1), null, MapZooms.getDefault(), null);
+		
+		
+		
 		
 		
 		// world generation
diff --git a/DataExtractionOSM/src/net/osmand/data/preparation/IndexVectorMapCreator.java b/DataExtractionOSM/src/net/osmand/data/preparation/IndexVectorMapCreator.java
index 28c42326dd8..d460268077c 100644
--- a/DataExtractionOSM/src/net/osmand/data/preparation/IndexVectorMapCreator.java
+++ b/DataExtractionOSM/src/net/osmand/data/preparation/IndexVectorMapCreator.java
@@ -146,7 +146,8 @@ private void indexMultiPolygon(Entity e, OsmDbAccessorContext ctx) throws SQLExc
 
 				for (List<Way> l : completedRings) {
 					boolean innerType = "inner".equals(entities.get(l.get(0))); //$NON-NLS-1$
-					boolean clockwise = MapSwingAlgorithms.isClockwiseWay(l);
+					boolean clockwise = MapAlgorithms.isClockwiseWay(l);
+					
 					// clockwise - outer (like coastline), anticlockwise - inner
 					boolean inverse = clockwise != !innerType;
 					for (Way way : l) {
diff --git a/DataExtractionOSM/src/net/osmand/data/preparation/MapSwingAlgorithms.java b/DataExtractionOSM/src/net/osmand/data/preparation/MapSwingAlgorithms.java
deleted file mode 100644
index 1ffe2f4d861..00000000000
--- a/DataExtractionOSM/src/net/osmand/data/preparation/MapSwingAlgorithms.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package net.osmand.data.preparation;
-
-import java.awt.geom.Line2D;
-import java.awt.geom.Point2D;
-import java.util.ArrayList;
-import java.util.List;
-
-import net.osmand.osm.Node;
-import net.osmand.osm.Way;
-
-public class MapSwingAlgorithms {
-
-	public static Point2D.Float getIntersectionPoint(Line2D.Float line1, Line2D.Float line2) {
-		if (!line1.intersectsLine(line2))
-			return null;
-		double px = line1.getX1(), py = line1.getY1(), rx = line1.getX2() - px, ry = line1.getY2() - py;
-		double qx = line2.getX1(), qy = line2.getY1(), sx = line2.getX2() - qx, sy = line2.getY2() - qy;
-
-		double det = sx * ry - sy * rx;
-		if (det == 0) {
-			return null;
-		} else {
-			double z = (sx * (qy - py) + sy * (px - qx)) / det;
-			if (z <= 0 || z >= 1)
-				return null; // intersection at end point!
-			return new Point2D.Float((float) (px + z * rx), (float) (py + z * ry));
-		}
-	} // end intersection line-line
-
-	public static boolean isClockwiseWay(List<Way> ways) {
-		if (ways.isEmpty()) {
-			return false;
-		}
-		List<Node> nodes;
-		if (ways.size() == 1) {
-			nodes = ways.get(0).getNodes();
-		} else {
-			nodes = new ArrayList<Node>();
-			boolean first = true;
-			for (Way e : ways) {
-				if (first) {
-					first = false;
-					nodes.addAll(e.getNodes());
-				} else {
-					nodes.addAll(e.getNodes().subList(1, e.getNodes().size()));
-				}
-			}
-		}
-		if (nodes.isEmpty()) {
-			return false;
-		}
-		double angle = 0;
-		double prevAng = 0;
-		double firstAng = 0;
-		double selfIntersection = 0;
-		boolean open = nodes.get(nodes.size() - 1).getId() != nodes.get(0).getId();
-
-		for (int i = 1; open ? i < nodes.size() : i <= nodes.size(); i++) {// nodes.get(i).getId()
-			double ang;
-			if (i < nodes.size()) {
-				ang = Math.atan2(nodes.get(i).getLatitude() - nodes.get(i - 1).getLatitude(), nodes.get(i).getLongitude()
-						- nodes.get(i - 1).getLongitude());
-				// find self intersection
-				Line2D.Float l = new Line2D.Float((float) nodes.get(i).getLongitude(), (float) nodes.get(i).getLatitude(), (float) nodes
-						.get(i - 1).getLongitude(), (float) nodes.get(i - 1).getLatitude());
-				for (int j = i - 2; j > i - 7; j--) {
-					if (j < 1) {
-						break;
-					}
-					Line2D.Float l2 = new Line2D.Float((float) nodes.get(j).getLongitude(), (float) nodes.get(j).getLatitude(),
-							(float) nodes.get(j - 1).getLongitude(), (float) nodes.get(j - 1).getLatitude());
-					java.awt.geom.Point2D.Float point = getIntersectionPoint(l, l2);
-					if (point != null) {
-						double dang = Math.atan2(nodes.get(j).getLatitude() - nodes.get(j - 1).getLatitude(), nodes.get(j).getLongitude()
-								- nodes.get(j - 1).getLongitude());
-						if (adjustDirection(ang - dang) < 0) {
-							selfIntersection += 2 * Math.PI;
-						} else {
-							selfIntersection -= 2 * Math.PI;
-						}
-					}
-
-				}
-			} else {
-				ang = firstAng;
-			}
-			if (i > 1) {
-				angle += adjustDirection(ang - prevAng);
-				prevAng = ang;
-			} else {
-				prevAng = ang;
-				firstAng = ang;
-			}
-
-		}
-		return (angle - selfIntersection) < 0;
-	}
-
-	private static double adjustDirection(double ang) {
-		if (ang < -Math.PI) {
-			ang += 2 * Math.PI;
-		} else if (ang > Math.PI) {
-			ang -= 2 * Math.PI;
-		}
-		return ang;
-	}
-
-}
diff --git a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
index 52cbe8287cb..48cfa93f769 100644
--- a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
@@ -417,7 +417,11 @@ public int compare(RectF object1, RectF object2) {
 			}
 			
 		};
-		next: for (int i = 0; i < size; i++) {
+		paint.setStyle(Style.STROKE);
+		paint.setTextSize(10);
+		paint.setColor(Color.BLACK);
+		
+		nextText: for (int i = 0; i < size; i++) {
 			TextDrawInfo text  = rc.textToDraw.get(i);
 			if(text.text != null){
 				int d = text.text.indexOf(MapRenderingTypes.DELIM_CHAR);
@@ -432,18 +436,20 @@ public int compare(RectF object1, RectF object2) {
 				RectF bounds = new RectF();
 				paintText.setTextSize(text.textSize * dm.density);
 				paintText.setFakeBoldText(text.bold);
-				float mes = paintText.measureText(text.text);
-				if(text.drawOnPath == null || 
-						(text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315)){
-					bounds.set(text.centerX - mes / 2, text.centerY - 3 * text.textSize / 2 ,
-							text.centerX + mes / 2 , text.centerY + 3 * text.textSize / 2 );
+				boolean horizontalWayDisplay = (text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315);
+				float mes = paintText.measureText(text.text) + (!horizontalWayDisplay ? 0 : text.minDistance);
+				 // Paint.ascent is negative, so negate it.
+				int ascent = (int) Math.ceil(-paintText.ascent());
+				int descent = (int) Math.ceil(paintText.descent());
+				float textHeight = ascent + descent + (horizontalWayDisplay ? 0 : text.minDistance);
+				
+				
+				if(text.drawOnPath == null || horizontalWayDisplay){
+					bounds.set(text.centerX - mes / 2, text.centerY - textHeight / 2 ,
+							text.centerX + mes / 2 , text.centerY + textHeight / 2 );
 				} else {
-					bounds.set(text.centerX - 3 * text.textSize , text.centerY - mes, 
-							text.centerX + 3 * text.textSize , text.centerY + mes );
-				}
-				if(text.minDistance > 0){
-					bounds.set(bounds.left - text.minDistance / 2, bounds.top - text.minDistance / 2,
-							bounds.right + text.minDistance / 2, bounds.bottom + text.minDistance / 2);
+					bounds.set(text.centerX - textHeight / 2, text.centerY - mes / 2, 
+							text.centerX + textHeight / 2 , text.centerY + mes / 2);
 				}
 				List<RectF> boundsIntersect = text.drawOnPath == null || findAllTextIntersections? 
 						boundsNotPathIntersect : boundsPathIntersect;
@@ -480,19 +486,28 @@ public int compare(RectF object1, RectF object2) {
 					if (st < 0) {
 						st = 0;
 					}
+					// test functionality
+					// cv.drawRect(bounds, paint);
+					// cv.drawText(text.text.substring(0, Math.min(5, text.text.length())), bounds.centerX(), bounds.centerY(), paint);
+					
 					for (int j = st; j < e; j++) {
 						RectF b = boundsIntersect.get(j);
 						float x = Math.min(bounds.right, b.right) - Math.max(b.left, bounds.left);
 						float y = Math.min(bounds.bottom, b.bottom) - Math.max(b.top, bounds.top);
 						if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
-							continue next;
+							continue nextText;
 						}
 					}
 					// store in list sorted by left boundary
-					if(text.minDistance > 0){
-						bounds.set(bounds.left + text.minDistance / 2, bounds.top + text.minDistance / 2,
-								bounds.right - text.minDistance / 2, bounds.bottom - text.minDistance / 2);
-					}
+//					if(text.minDistance > 0){
+//						if (verticalText) {
+//							bounds.set(bounds.left + text.minDistance / 2, bounds.top, 
+//									bounds.right - text.minDistance / 2, bounds.bottom);
+//						} else {
+//							bounds.set(bounds.left, bounds.top + text.minDistance / 2, bounds.right, 
+//									bounds.bottom - text.minDistance / 2);
+//						}
+//					}
 					boundsIntersect.add(index, bounds);
 				}
 				
@@ -899,11 +914,8 @@ private void drawPolyline(BinaryMapDataObject obj, BaseOsmandRender render, Canv
 					rc.clearText();
 					ref = render.renderObjectText(ref, pair.tag, pair.value, rc, true);
 					TextDrawInfo text = new TextDrawInfo(ref);
-					if(!rc.showTextOnPath){
-						text.fillProperties(rc, middlePoint.x, middlePoint.y);
-					} else {
-						// TODO
-					}
+					text.fillProperties(rc, middlePoint.x, middlePoint.y);
+					text.pathRotate = pathRotate;
 					rc.textToDraw.add(text);
 					
 				}
@@ -917,7 +929,7 @@ private void drawPolyline(BinaryMapDataObject obj, BaseOsmandRender render, Canv
 							text.fillProperties(rc, middlePoint.x, middlePoint.y);
 							rc.textToDraw.add(text);
 						} else {
-							if (paintText.measureText(obj.getName()) < Math.max(Math.abs(xLength), Math.abs(yLength))) {
+							if (paintText.measureText(obj.getName()) < Math.abs(xLength) + Math.abs(yLength)) {
 								if (inverse) {
 									path.rewind();
 									boolean st = true;
