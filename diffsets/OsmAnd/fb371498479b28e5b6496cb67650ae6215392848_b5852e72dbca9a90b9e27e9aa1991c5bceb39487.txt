diff --git a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
index 0c06ac67d6b..f8e2b75bdae 100644
--- a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
+++ b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
@@ -60,7 +60,7 @@ private void pendingRotateAnimation() {
 					tileView.rotateToAnimate(rotationDiff / 5 + tileView.getRotate());
 				}
 			}
-		} while (conditionToCountinue);
+		} while (conditionToCountinue && tileView.isMapRotateEnabled());
 	}
 	
 
diff --git a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
index c4e139c58ac..dfb15de49d5 100644
--- a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
+++ b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
@@ -43,6 +43,7 @@
 
 public class OsmandMapTileView extends SurfaceView implements IMapDownloaderCallback, Callback {
 
+	protected final static int LOWEST_ZOOM_TO_ROTATE = 10;
 
 	protected final int emptyTileDivisor = 16;
 	
@@ -263,11 +264,16 @@ public void setZoom(float zoom) {
 	}
 
 	
+	public boolean isMapRotateEnabled(){
+		return zoom > LOWEST_ZOOM_TO_ROTATE;
+	}
 
 	public void setRotate(float rotate) {
-		float diff = MapUtils.unifyRotationDiff(rotate, this.rotate);
-		if (Math.abs(diff) > 5) { // check smallest rotation
-			animatedDraggingThread.startRotate(rotate);
+		if (isMapRotateEnabled()) {
+			float diff = MapUtils.unifyRotationDiff(rotate, getRotate());
+			if (Math.abs(diff) > 5) { // check smallest rotation
+				animatedDraggingThread.startRotate(rotate);
+			}
 		}
 	}
 
@@ -280,7 +286,7 @@ public void setShowMapPosition(boolean showMapPosition) {
 	}
 
 	public float getRotate() {
-		return rotate;
+		return isMapRotateEnabled() ?  rotate : 0;
 	}
 
 
@@ -488,7 +494,7 @@ private void drawOverMap(Canvas canvas, RectF latlonRect, RectF tilesRect, boole
 				canvas.save();
 				// rotate if needed
 				if (!layer.drawInScreenPixels()) {
-					canvas.rotate(rotate, w, h);
+					canvas.rotate(getRotate(), w, h);
 				}
 				layer.onDraw(canvas, latlonRect, tilesRect, nightMode);
 				canvas.restore();
@@ -537,19 +543,37 @@ public void tileDownloaded(DownloadRequest request) {
 
 	// ///////////////////////////////// DRAGGING PART ///////////////////////////////////////
 	public float calcDiffTileY(float dx, float dy) {
-		return (-rotateSin * dx + rotateCos * dy) / getTileSize();
+		if(isMapRotateEnabled()){
+			return (-rotateSin * dx + rotateCos * dy) / getTileSize();
+		} else {
+			return dy / getTileSize();
+		}
+		
 	}
 
 	public float calcDiffTileX(float dx, float dy) {
-		return (rotateCos * dx + rotateSin * dy) / getTileSize();
+		if(isMapRotateEnabled()){
+			return (rotateCos * dx + rotateSin * dy) / getTileSize();
+		} else {
+			return dx / getTileSize();
+		}
 	}
 
 	public float calcDiffPixelY(float dTileX, float dTileY) {
-		return (rotateSin * dTileX + rotateCos * dTileY) * getTileSize();
+		if(isMapRotateEnabled()){
+			return (rotateSin * dTileX + rotateCos * dTileY) * getTileSize();
+		} else {
+			return dTileY * getTileSize();
+		}
+		
 	}
 
 	public float calcDiffPixelX(float dTileX, float dTileY) {
-		return (rotateCos * dTileX - rotateSin * dTileY) * getTileSize();
+		if(isMapRotateEnabled()){
+			return (rotateCos * dTileX - rotateSin * dTileY) * getTileSize();
+		} else {
+			return dTileX * getTileSize();
+		}
 	}
 
 	/**
@@ -602,11 +626,13 @@ protected void dragToAnimate(float fromX, float fromY, float toX, float toY, boo
 	}
 
 	protected void rotateToAnimate(float rotate) {
-		this.rotate = MapUtils.unifyRotationTo360(rotate);
-		float rotateRad = (float) Math.toRadians(rotate);
-		this.rotateCos = FloatMath.cos(rotateRad);
-		this.rotateSin = FloatMath.sin(rotateRad);
-		refreshMap();
+		if (isMapRotateEnabled()) {
+			this.rotate = MapUtils.unifyRotationTo360(rotate);
+			float rotateRad = (float) Math.toRadians(rotate);
+			this.rotateCos = FloatMath.cos(rotateRad);
+			this.rotateSin = FloatMath.sin(rotateRad);
+			refreshMap();
+		}
 	}
 	
 	protected void setLatLonAnimate(double latitude, double longitude, boolean notify) {
