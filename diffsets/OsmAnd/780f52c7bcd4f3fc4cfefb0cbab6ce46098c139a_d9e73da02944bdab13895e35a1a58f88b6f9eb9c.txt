diff --git a/OsmAnd/jni/osmand/rendering.cpp b/OsmAnd/jni/osmand/rendering.cpp
index 8b73c19e56b..ea5a0cee523 100644
--- a/OsmAnd/jni/osmand/rendering.cpp
+++ b/OsmAnd/jni/osmand/rendering.cpp
@@ -123,6 +123,8 @@ int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int ar
 		rPathEff = req->props()->R_PATH_EFFECT_3;
 	}
 	paint->setColorFilter(NULL);
+	paint->setShader(NULL);
+	paint->setLooper(NULL);
 	if (area) {
 		paint->setStyle(SkPaint::kStrokeAndFill_Style);
 		paint->setStrokeWidth(0);
@@ -159,26 +161,19 @@ int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int ar
 	int color = req->getIntPropertyValue(rColor);
 	paint->setColor(color);
 
+
 	if (ind == 0) {
 		std::string shader = req->getStringPropertyValue(req->props()->R_SHADER);
 		if (shader.size() > 0) {
 			SkBitmap* bmp = getCachedBitmap(rc, shader);
-			if (bmp == NULL) {
-				paint->setShader(NULL);
-			} else {
+			if (bmp != NULL) {
 				paint->setShader(new SkBitmapProcShader(*bmp, SkShader::kRepeat_TileMode, SkShader::kRepeat_TileMode))->unref();
 			}
-		} else {
-			paint->setShader(NULL);
 		}
-	} else {
-		paint->setShader(NULL);
 	}
 
 	// do not check shadow color here
-	paint->setLooper(NULL);
 	if (rc->shadowRenderingMode == 1 && ind == 0) {
-		paint->setLooper(NULL);
 		int shadowColor = req->getIntPropertyValue(req->props()->R_SHADOW_COLOR);
 		int shadowLayer = req->getIntPropertyValue(req->props()->R_SHADOW_RADIUS);
 		if (shadowColor == 0) {
diff --git a/OsmAnd/jni/osmand/textdraw.cpp b/OsmAnd/jni/osmand/textdraw.cpp
index 97e968cb7b3..363801da340 100644
--- a/OsmAnd/jni/osmand/textdraw.cpp
+++ b/OsmAnd/jni/osmand/textdraw.cpp
@@ -61,7 +61,7 @@ private :
 
     void query_node(SkRect& box, std::vector<T> & result, node* node) const {
 		if (node) {
-			if (box.intersect(node->bounds)) {
+			if (SkRect::Intersects(box, node->bounds)) {
 				node_data_iterator i = node->data.begin();
 				node_data_iterator end = node->data.end();
 				while (i != end) {
@@ -120,6 +120,8 @@ private :
 void fillTextProperties(TextDrawInfo* info, RenderingRuleSearchRequest* render, float cx, float cy) {
 	info->centerX = cx;
 	info->centerY = cy + render->getIntPropertyValue(render->props()->R_TEXT_DY, 0);
+	// used only for draw on path where centerY doesn't play role
+	info->vOffset = render->getIntPropertyValue(render->props()->R_TEXT_DY, 0);
 	info->textColor = render->getIntPropertyValue(render->props()->R_TEXT_COLOR);
 	if (info->textColor == 0) {
 		info->textColor = 0xff000000;
@@ -215,7 +217,6 @@ bool calculatePathToRotate(RenderingContext* rc, TextDrawInfo* p) {
 	p->path->getPoints(points, len);
 	if (!p->drawOnPath) {
 		// simply calculate rotation of path used for shields
-		p->vOffset -= p->textSize / 2 - 1;
 		float px = 0;
 		float py = 0;
 		for (int i = 1; i < len; i++) {
@@ -334,7 +335,7 @@ bool calculatePathToRotate(RenderingContext* rc, TextDrawInfo* p) {
 
 	p->centerX = points[startInd].fX + scale * px + ox;
 	p->centerY = points[startInd].fY + scale * py + oy;
-	p->vOffset = p->textSize / 2 - 1;
+	p->vOffset += p->textSize / 2 - 1;
 	p->hOffset = 0;
 
 	if (inverse) {
@@ -373,11 +374,11 @@ inline float sqr(float a){
 	return a*a;
 }
 
-bool intersect(SkRect tRect, float tRot, TextDrawInfo* s)
+bool intersects(SkRect tRect, float tRot, TextDrawInfo* s)
 {
 	float sRot = s->pathRotate;
 	if (abs(tRot) < M_PI / 15 && abs(sRot) < M_PI / 15) {
-		return tRect.intersect(s->bounds);
+		return SkRect::Intersects(tRect, s->bounds);
 	}
 	float dist = sqrt(sqr(tRect.centerX() - s->bounds.centerX()) + sqr(tRect.centerY() - s->bounds.centerY()));
 	if(dist < 3) {
@@ -402,15 +403,15 @@ bool intersect(SkRect tRect, float tRot, TextDrawInfo* s)
 		float left = sRect.centerX() + dist* cos(diff) - tRect.width()/2;
 		float top = sRect.centerY() - dist* sin(diff) - tRect.height()/2;
 		SkRect nRect = SkRect::MakeXYWH(left, top, tRect.width(), tRect.height());
-		return nRect.intersect(sRect);
+		return SkRect::Intersects(nRect, sRect);
 	}
 
 	// TODO other cases not covered
-	return tRect.intersect(sRect);
+	return SkRect::Intersects(tRect, sRect);
 }
 
-bool intersect(TextDrawInfo* t, TextDrawInfo* s) {
-	return intersect(t->bounds, t->pathRotate, s);
+bool intersects(TextDrawInfo* t, TextDrawInfo* s) {
+	return intersects(t->bounds, t->pathRotate, s);
 }
 std::vector<TextDrawInfo*> search;
 bool findTextIntersection(SkCanvas* cv, RenderingContext* rc, quad_tree<TextDrawInfo*>& boundIntersections, TextDrawInfo* text,
@@ -424,7 +425,7 @@ bool findTextIntersection(SkCanvas* cv, RenderingContext* rc, quad_tree<TextDraw
 		return true;
 	}
 
-	if(!text->drawOnPath) {
+	if(text->path == NULL) {
 		text->bounds.offset(text->centerX, text->centerY);
 		// shift to match alignment
 		text->bounds.offset(-text->bounds.width()/2, 0);
@@ -437,18 +438,18 @@ bool findTextIntersection(SkCanvas* cv, RenderingContext* rc, quad_tree<TextDraw
 	boundIntersections.query_in_box(text->bounds, search);
 	for (uint i = 0; i < search.size(); i++) {
 		TextDrawInfo* t = search.at(i);
-		if (intersect(text, t)) {
+		if (intersects(text, t)) {
 			return true;
 		}
 	}
 	if(text->minDistance > 0) {
 		SkRect boundsSearch = text->bounds;
-		boundsSearch.inset(-getDensityValue(rc, std::max(5.0f, text->minDistance)), -getDensityValue(rc, 12));
+		boundsSearch.inset(-getDensityValue(rc, std::max(5.0f, text->minDistance)), -getDensityValue(rc, 15));
 		boundIntersections.query_in_box(boundsSearch, search);
-//		drawTestBox(cv, &boundsSearch, text->pathRotate, paintIcon, text->text, NULL/*paintText*/);
+//		drawTestBox(cv, &boundsSearch, text->pathRotate, paintIcon, text->text, paintText);
 		for (uint i = 0; i < search.size(); i++) {
 			TextDrawInfo* t = search.at(i);
-			if (t->minDistance > 0 && t->text == text->text && intersect(boundsSearch, text->pathRotate,  t)) {
+			if (t->minDistance > 0 && t->text == text->text && intersects(boundsSearch, text->pathRotate,  t)) {
 				return true;
 			}
 		}
diff --git a/OsmAnd/libs/armeabi/libosmand.so b/OsmAnd/libs/armeabi/libosmand.so
index 464a2e7e645..802f8b752d5 100755
Binary files a/OsmAnd/libs/armeabi/libosmand.so and b/OsmAnd/libs/armeabi/libosmand.so differ
diff --git a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
index 929f251a766..1c642393a0a 100644
--- a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
@@ -393,7 +393,7 @@ private TIntObjectHashMap<TIntArrayList> sortObjectsByProperOrder(RenderingConte
 						int wholeType = o.getTypes()[j];
 						int mask = wholeType & 3;
 						int layer = 0;
-						if (mask != 1) {
+						if (mask != MapRenderingTypes.POINT_TYPE) {
 							layer = MapRenderingTypes.getNegativeWayLayer(wholeType);
 						}
 
@@ -592,6 +592,10 @@ private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, bo
 		RenderingRuleProperty rStrokeW;
 		RenderingRuleProperty rCap;
 		RenderingRuleProperty rPathEff;
+		
+		p.setShader(null);
+		p.setColorFilter(null);
+		p.clearShadowLayer();
 		if(ind == 0){
 			rColor = req.ALL.R_COLOR;
 			rStrokeW = req.ALL.R_STROKE_WIDTH;
@@ -633,21 +637,15 @@ private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, bo
 				p.setPathEffect(null);
 			}
 		}
-		p.setColorFilter(null);
-		p.setColor(req.getIntPropertyValue(rColor));
 		
+		p.setColor(req.getIntPropertyValue(rColor));
 		if(ind == 0){
 			String resId = req.getStringPropertyValue(req.ALL.R_SHADER);
 			if(resId != null){
 				p.setShader(getShader(resId));
-			} else {
-				p.setShader(null);
 			}
-			
 			// do not check shadow color here
-			if(rc.shadowRenderingMode != 1) {
-				paint.clearShadowLayer();
-			} else {
+			if(rc.shadowRenderingMode == 1) {
 				int shadowColor = req.getIntPropertyValue(req.ALL.R_SHADOW_COLOR);
 				int shadowLayer = req.getIntPropertyValue(req.ALL.R_SHADOW_RADIUS);
 				if (shadowColor == 0) {
@@ -655,10 +653,8 @@ private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, bo
 				}
 				p.setShadowLayer(shadowLayer, 0, 0, shadowColor);
 			}
-		} else {
-			p.setShader(null);
-			p.clearShadowLayer();
 		}
+		
 		return true;
 		
 	}
diff --git a/OsmAnd/src/net/osmand/plus/render/QuadTree.java b/OsmAnd/src/net/osmand/plus/render/QuadTree.java
index 3cf63627812..a13ed2cb6ef 100644
--- a/OsmAnd/src/net/osmand/plus/render/QuadTree.java
+++ b/OsmAnd/src/net/osmand/plus/render/QuadTree.java
@@ -40,7 +40,7 @@ void queryInBox(RectF box, List<T> result) {
 
 	private void queryNode(RectF box, List<T> result, Node<T> node) {
 		if (node != null) {
-			if (box.intersect(node.bounds)) {
+			if (RectF.intersects(box, node.bounds)) {
 				if (node.data != null) {
 					result.addAll(node.data);
 				}
diff --git a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
index 5dbc63bcc62..5f86fd0288b 100644
--- a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
@@ -57,6 +57,8 @@ public TextDrawInfo(String text) {
 		public void fillProperties(RenderingRuleSearchRequest render, float centerX, float centerY) {
 			this.centerX = centerX;
 			this.centerY = centerY + render.getIntPropertyValue(render.ALL.R_TEXT_DY, 0);
+			// used only for draw on path where centerY doesn't play role
+			this.vOffset = render.getIntPropertyValue(render.ALL.R_TEXT_DY, 0);
 			textColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);
 			if (textColor == 0) {
 				textColor = Color.BLACK;
@@ -95,9 +97,9 @@ private float sqr(float a) {
 		return a * a;
 	}
 
-	boolean intersect(RectF tRect, float tRot, RectF sRect, float sRot) {
+	boolean intersects(RectF tRect, float tRot, RectF sRect, float sRot) {
 		if (Math.abs(tRot) < Math.PI / 15 && Math.abs(sRot) < Math.PI / 15) {
-			return tRect.intersect(sRect);
+			return RectF.intersects(tRect, sRect);
 		}
 		float dist = FloatMath.sqrt(sqr(tRect.centerX() - sRect.centerX()) + sqr(tRect.centerY() - sRect.centerY()));
 		if (dist < 3) {
@@ -122,11 +124,11 @@ boolean intersect(RectF tRect, float tRot, RectF sRect, float sRot) {
 			float left = sRect.centerX() + dist * FloatMath.cos(diff) - tRect.width() / 2;
 			float top = sRect.centerY() - dist * FloatMath.sin(diff) - tRect.height() / 2;
 			RectF nRect = new RectF(left, top, left + tRect.width(), top + tRect.height());
-			return nRect.intersect(sRect);
+			return RectF.intersects(nRect, sRect);
 		}
 
 		// TODO other cases not covered
-		return tRect.intersect(sRect);
+		return RectF.intersects(tRect, sRect);
 	}
 
 	void drawTestBox(Canvas cv, RectF r, float rot, String text) {
@@ -151,19 +153,19 @@ private boolean findTextIntersection(Canvas cv, RenderingContext rc, QuadTree<Te
 		boundIntersections.queryInBox(text.bounds, tempSearch);
 		for (int i = 0; i < tempSearch.size(); i++) {
 			TextDrawInfo t = tempSearch.get(i);
-			if (intersect(text.bounds, text.pathRotate, t.bounds, t.pathRotate)) {
+			if (intersects(text.bounds, text.pathRotate, t.bounds, t.pathRotate)) {
 				return true;
 			}
 		}
 		if (text.minDistance > 0) {
 			RectF boundsSearch = new RectF(text.bounds);
-			boundsSearch.inset(-rc.getDensityValue(Math.max(5.0f, text.minDistance)), -rc.getDensityValue(12));
+			boundsSearch.inset(-rc.getDensityValue(Math.max(5.0f, text.minDistance)), -rc.getDensityValue(15));
 			boundIntersections.queryInBox(boundsSearch, tempSearch);
 			// drawTestBox(cv, &boundsSearch, text.pathRotate, paintIcon, text.text, NULL/*paintText*/);
 			for (int i = 0; i < tempSearch.size(); i++) {
 				TextDrawInfo t = tempSearch.get(i);
 				if (t.minDistance > 0 && t.text.equals(text.text) &&
-						intersect(boundsSearch, text.pathRotate, t.bounds, t.pathRotate)) {
+						intersects(boundsSearch, text.pathRotate, t.bounds, t.pathRotate)) {
 					return true;
 				}
 			}
@@ -358,7 +360,6 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 		if (!drawOnPath) {
 			p.drawOnPath = null;
 			// simply calculate rotation of path used for shields
-			p.vOffset -= p.textSize / 2 - 1;
 			float px = 0;
 			float py = 0;
 			for (int i = 1; i < len; i++) {
@@ -472,7 +473,7 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 
 		p.centerX = points[startInd].x + scale * px + ox;
 		p.centerY = points[startInd].y + scale * py + oy;
-		p.vOffset = p.textSize / 2 - 1;
+		p.vOffset += p.textSize / 2 - 1;
 //		p.hOffset = 0;
 
 		if (inverse) {
