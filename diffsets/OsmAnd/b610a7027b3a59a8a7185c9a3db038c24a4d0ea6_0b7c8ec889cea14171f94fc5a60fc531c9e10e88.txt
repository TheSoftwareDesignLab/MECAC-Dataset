diff --git a/OsmAnd/src/net/osmand/plus/auto/SurfaceRenderer.java b/OsmAnd/src/net/osmand/plus/auto/SurfaceRenderer.java
index 00618ad37e7..6233fd9daab 100644
--- a/OsmAnd/src/net/osmand/plus/auto/SurfaceRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/auto/SurfaceRenderer.java
@@ -461,6 +461,12 @@ public void renderFrame(RotatedTileBox tileBox, DrawSettings drawSettings) {
 		}
 	}
 
+
+	@Nullable
+	public Rect getVisibleArea() {
+		return visibleArea;
+	}
+
 	public double getVisibleAreaWidth() {
 		return visibleArea != null ? visibleArea.width() : 0f;
 	}
diff --git a/OsmAnd/src/net/osmand/plus/auto/screens/BaseAndroidAutoScreen.kt b/OsmAnd/src/net/osmand/plus/auto/screens/BaseAndroidAutoScreen.kt
index e72e4bdeab7..774face8359 100644
--- a/OsmAnd/src/net/osmand/plus/auto/screens/BaseAndroidAutoScreen.kt
+++ b/OsmAnd/src/net/osmand/plus/auto/screens/BaseAndroidAutoScreen.kt
@@ -1,5 +1,7 @@
 package net.osmand.plus.auto.screens
 
+import android.graphics.Rect
+import android.util.Log
 import androidx.car.app.CarContext
 import androidx.car.app.Screen
 import androidx.car.app.constraints.ConstraintManager
@@ -93,21 +95,31 @@ abstract class BaseAndroidAutoScreen(carContext: CarContext) : Screen(carContext
 		app.carNavigationSession?.navigationCarSurface?.let { surfaceRenderer ->
 			if (!mapRect.hasInitialState()) {
 				val mapView = app.osmandMap.mapView
-				val tileBox = mapView.rotatedTileBox
-				val rectWidth = mapRect.right - mapRect.left
-				val coef: Double = surfaceRenderer.visibleAreaWidth / tileBox.pixWidth
-				val left = mapRect.left - rectWidth * coef
-				val right = mapRect.right + rectWidth * coef
-				mapView.fitRectToMap(
-					left,
-					right,
-					mapRect.top,
-					mapRect.bottom,
-					tileBox.pixWidth,
-					tileBox.pixHeight,
-					0,
-					0,
-					true
+				// FIXME revert after start
+				//				val prevElevationAngle: Float = mapView.normalizeElevationAngle(mapView.elevationAngle)
+				mapView.setElevationAngle(90f)
+				mapView.setRotate(0f, true)
+				// DELETE
+//				val tileBox = mapView.rotatedTileBox
+//				val vArea = surfaceRenderer.visibleArea
+//				val rectWidth = mapRect.right - mapRect.left
+//				val coef: Double = surfaceRenderer.visibleAreaWidth / tileBox.pixWidth
+//				mapRect.left -= rectWidth * coef
+//				mapRect.right += rectWidth * coef
+//				Log.i("net.osmand.dev", "ZOOM " + coef + " map rect" + mapRect)
+//				var dx = 0
+//				if (vArea != null) {
+//					val ltr = vArea.left > (vArea.width() - vArea.right)
+//					if (ltr) {
+//						dx = vArea.left
+//					} else {
+//						dx = -(vArea.width() - vArea.right)
+//					}
+//				}
+				val tb = mapView.getRotatedTileBox()
+				mapView.fitRectToMap(tb,
+					mapRect.left, mapRect.right, mapRect.top, mapRect.bottom,
+					0, 0, true
 				)
 				mapView.refreshMap()
 			}
diff --git a/OsmAnd/src/net/osmand/plus/auto/screens/RoutePreviewScreen.java b/OsmAnd/src/net/osmand/plus/auto/screens/RoutePreviewScreen.java
index 037d0db7bb2..8b3a3af79ee 100644
--- a/OsmAnd/src/net/osmand/plus/auto/screens/RoutePreviewScreen.java
+++ b/OsmAnd/src/net/osmand/plus/auto/screens/RoutePreviewScreen.java
@@ -3,6 +3,7 @@
 import static net.osmand.search.core.ObjectType.GPX_TRACK;
 
 import android.text.SpannableString;
+import android.util.Log;
 
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
@@ -19,6 +20,7 @@
 import androidx.lifecycle.DefaultLifecycleObserver;
 import androidx.lifecycle.LifecycleOwner;
 
+import net.osmand.PlatformUtil;
 import net.osmand.plus.shared.SharedUtil;
 import net.osmand.StateChangedListener;
 import net.osmand.data.QuadRect;
@@ -47,6 +49,8 @@
 public final class RoutePreviewScreen extends BaseAndroidAutoScreen implements IRouteInformationListener,
 		DefaultLifecycleObserver {
 
+	private static final org.apache.commons.logging.Log LOG = PlatformUtil.getLog(RoutePreviewScreen.class);
+
 	@NonNull
 	private final Action settingsAction;
 	@NonNull
@@ -64,6 +68,7 @@ public void stateChanged(Void change) {
 			if (routeGpxFile != null) {
 				QuadRect mapRect = new QuadRect();
 				Algorithms.extendRectToContainRect(mapRect, SharedUtil.jQuadRect(routeGpxFile.getRect()));
+
 				adjustMapToRect(getApp().getMapViewTrackingUtilities().getDefaultLocation(), mapRect);
 			}
 		}
@@ -207,6 +212,7 @@ public void newRouteIsCalculated(boolean newRoute, ValueHolder<Boolean> showToas
 		RoutingHelper rh = getApp().getRoutingHelper();
 		QuadRect mapRect = RoutingHelperUtils.getRouteRect(getApp(), rh.getRoute());
 		if (mapRect != null) {
+			LOG.info("ZOOM Route " + mapRect);
 			adjustMapToRect(getApp().getMapViewTrackingUtilities().getDefaultLocation(), mapRect);
 		}
 		updateRoute(newRoute);
diff --git a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
index 3a25feca2d7..23a4e175c2e 100644
--- a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
+++ b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
@@ -1682,28 +1682,8 @@ public void fitRectToMap(double left, double right, double top, double bottom,
 
 	public void fitRectToMap(double left, double right, double top, double bottom,
 	                         int tileBoxWidthPx, int tileBoxHeightPx, int marginTopPx, int marginLeftPx) {
-		fitRectToMap(left, right, top, bottom, tileBoxWidthPx, tileBoxHeightPx, marginTopPx, marginLeftPx, true);
-	}
-
-	public boolean fullyContains(RotatedTileBox tb, double left, double top, double right, double bottom) {
-		// if at least one point is not inside the boundary, return false
-		if (!tb.containsLatLon(top, left)) {
-			return false;
-		} else if (!tb.containsLatLon(bottom, left)) {
-			return false;
-		} else if (!tb.containsLatLon(top, right)) {
-			return false;
-		} else if (!tb.containsLatLon(bottom, right)) {
-			return false;
-		}
-		return true;
-	}
-
-	public void fitRectToMap(double left, double right, double top, double bottom,
-	                         int tileBoxWidthPx, int tileBoxHeightPx, int marginTopPx, int marginLeftPx, boolean useSmallZoom) {
 		RotatedTileBox tb = currentViewport.copy();
-		float zoomStep = useSmallZoom ? 0.1f : 1f;
-		double border = 0.8;
+		double border = 0.9;
 		int dx = 0;
 		int dy = 0;
 		int tbw = (int) (tb.getPixWidth() * border);
@@ -1720,7 +1700,32 @@ public void fitRectToMap(double left, double right, double top, double bottom,
 		}
 		dy += tb.getCenterPixelY() - tb.getPixHeight() / 2;
 		tb.setPixelDimensions(tbw, tbh);
+		fitRectToMap(tb, left, right, top, bottom, dx, dy, true);
+	}
 
+	public boolean fullyContains(RotatedTileBox tb, double left, double top, double right, double bottom) {
+		// if at least one point is not inside the boundary, return false
+		if (!tb.containsLatLon(top, left)) {
+			return false;
+		} else if (!tb.containsLatLon(bottom, left)) {
+			return false;
+		} else if (!tb.containsLatLon(top, right)) {
+			return false;
+		} else if (!tb.containsLatLon(bottom, right)) {
+			return false;
+		}
+		return true;
+	}
+
+	public void fitRectToMap(RotatedTileBox tb, double left, double right, double top, double bottom,
+	                         int dx, int dy, boolean useSmallZoom) {
+		float zoomStep = useSmallZoom ? 0.1f : 1f;
+		LOG.info(String.format(Locale.ENGLISH,
+				"FIXME ZOOM 1 FROM %.6f, %.6f - %.6f, %.6f - z=%.2f - fit %.6f, %.6f - %.6f, %.6f ",
+				tb.getLeftTopLatLon().getLatitude(), tb.getLeftTopLatLon().getLongitude(),
+				tb.getRightBottomLatLon().getLatitude(), tb.getRightBottomLatLon().getLongitude(),
+				tb.getZoom() + tb.getZoomFloatPart(),
+				top, left, bottom, right));
 		double clat = bottom / 2 + top / 2;
 		double clon = left / 2 + right / 2;
 		tb.setLatLonCenter(clat, clon);
@@ -1731,13 +1736,26 @@ public void fitRectToMap(double left, double right, double top, double bottom,
 			zoom.partialChangeZoom(-zoomStep);
 			tb.setZoomAndAnimation(zoom.getBaseZoom(), 0, zoom.getZoomFloatPart());
 		}
-		zoom.partialChangeZoom(zoomStep);
 		while (zoom.isZoomInAllowed() && fullyContains(tb, left, top, right, bottom)) {
 			zoom.partialChangeZoom(zoomStep);
 			tb.setZoomAndAnimation(zoom.getBaseZoom(), 0, zoom.getZoomFloatPart());
 		}
-		zoom.partialChangeZoom(-zoomStep);
-		tb.setZoomAndAnimation(zoom.getBaseZoom(), 0, zoom.getZoomFloatPart());
+		LOG.info(String.format(Locale.ENGLISH,
+				"FIXME ZOOM LAST %.6f, %.6f - %.6f, %.6f - z=%.2f - fit %.6f, %.6f - %.6f, %.6f ",
+				tb.getLeftTopLatLon().getLatitude(), tb.getLeftTopLatLon().getLongitude(),
+				tb.getRightBottomLatLon().getLatitude(), tb.getRightBottomLatLon().getLongitude(),
+				tb.getZoom() + tb.getZoomFloatPart(),
+				top, left, bottom, right));
+		if (zoom.isZoomOutAllowed()) {
+			zoom.partialChangeZoom(-zoomStep);
+			tb.setZoomAndAnimation(zoom.getBaseZoom(), 0, zoom.getZoomFloatPart());
+		}
+		LOG.info(String.format(Locale.ENGLISH,
+				"FIXME ZOOM TO %.6f, %.6f - %.6f, %.6f - z=%.2f - fit %.6f, %.6f - %.6f, %.6f ",
+				tb.getLeftTopLatLon().getLatitude(), tb.getLeftTopLatLon().getLongitude(),
+				tb.getRightBottomLatLon().getLatitude(), tb.getRightBottomLatLon().getLongitude(),
+				tb.getZoom() + tb.getZoomFloatPart(),
+				top, left, bottom, right));
 		if (dy != 0 || dx != 0) {
 			float x = tb.getPixWidth() / 2f + dx;
 			float y = tb.getPixHeight() / 2f + dy;
