diff --git a/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/OBDDispatcher.kt b/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/OBDDispatcher.kt
index 283937217db..047590110ba 100644
--- a/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/OBDDispatcher.kt
+++ b/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/OBDDispatcher.kt
@@ -61,44 +61,46 @@ object OBDDispatcher {
 						readStatusListener?.onInitConnectionFailed()
 					}
 				})
-				while (obd2Connection?.initialized == true) {
-					try {
-						for (command in commandQueue) {
-							if (command.isStale) {
-								val cachedCommandResponse = staleCommandsCache[command]
-								if (cachedCommandResponse != null && cachedCommandResponse != OBDUtils.INVALID_RESPONSE_CODE) {
-									continue
+				if(obd2Connection?.initialized == true) {
+					while (obd2Connection?.isFinished == false) {
+						try {
+							for (command in commandQueue) {
+								if (command.isStale) {
+									val cachedCommandResponse = staleCommandsCache[command]
+									if (cachedCommandResponse != null && cachedCommandResponse != OBDUtils.INVALID_RESPONSE_CODE) {
+										continue
+									}
 								}
-							}
-							val hexGroupCode = "%02X".format(command.commandGroup)
-							val hexCode = "%02X".format(command.command)
-							val fullCommand = "$hexGroupCode$hexCode"
-							val commandResult =
-								obd2Connection!!.run(
-									fullCommand,
-									command.command,
-									command.commandType)
-							if (commandResult.isValid()) {
-								if (commandResult.result.size >= command.responseLength) {
-									sensorDataCache[command] =
-										command.parseResponse(commandResult.result)
-								} else {
-									log.error("Incorrect response length for command $command")
+								val hexGroupCode = "%02X".format(command.commandGroup)
+								val hexCode = "%02X".format(command.command)
+								val fullCommand = "$hexGroupCode$hexCode"
+								val commandResult =
+									obd2Connection!!.run(
+										fullCommand,
+										command.command,
+										command.commandType)
+								if (commandResult.isValid()) {
+									if (commandResult.result.size >= command.responseLength) {
+										sensorDataCache[command] =
+											command.parseResponse(commandResult.result)
+									} else {
+										log.error("Incorrect response length for command $command")
+									}
+								} else if(commandResult == OBDResponse.NO_DATA) {
+									sensorDataCache[command] = OBDDataField.NO_DATA
+								} else if(commandResult == OBDResponse.ERROR) {
+									readStatusListener?.onIOError()
 								}
-							} else if(commandResult == OBDResponse.NO_DATA) {
-								sensorDataCache[command] = OBDDataField.NO_DATA
-							} else if(commandResult == OBDResponse.ERROR) {
-								readStatusListener?.onIOError()
 							}
+						} catch (error: IOException) {
+							log.error("Run OBD looper error. $error")
+							if (inputStream == null || outputStream == null) {
+								break
+							}
+							readStatusListener?.onIOError()
 						}
-					} catch (error: IOException) {
-						log.error("Run OBD looper error. $error")
-						if (inputStream == null || outputStream == null) {
-							break
-						}
-						readStatusListener?.onIOError()
+						OBDDataComputer.acceptValue(sensorDataCache)
 					}
-					OBDDataComputer.acceptValue(sensorDataCache)
 				}
 			} catch (cancelError: CancellationException) {
 				log.error("OBD reading canceled")
@@ -130,6 +132,8 @@ object OBDDispatcher {
 		outputStream = writeStream
 		if (readStream != null && writeStream != null) {
 			startReadObdLooper()
+		} else {
+			obd2Connection?.isFinished = true
 		}
 	}
 
diff --git a/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/Obd2Connection.kt b/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/Obd2Connection.kt
index b6ec8b0bab4..7c74fa60b6b 100644
--- a/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/Obd2Connection.kt
+++ b/OsmAnd-shared/src/commonMain/kotlin/net/osmand/shared/obd/Obd2Connection.kt
@@ -11,6 +11,7 @@ class Obd2Connection(private val connection: UnderlyingTransport) {
 
 	private val log = LoggerFactory.getLogger("Obd2Connection")
 	var initialized = false
+	var isFinished = false
 
 	init {
 		try {
@@ -31,7 +32,7 @@ class Obd2Connection(private val connection: UnderlyingTransport) {
 		val response = StringBuilder()
 		log.debug("runImpl($command)")
 		connection.write((command + "\r").encodeToByteArray())
-		while (true) {
+		while (!isFinished) {
 			val value = connection.readByte() ?: continue
 			val c = value.toChar()
 			// this is the prompt, stop here
@@ -48,6 +49,9 @@ class Obd2Connection(private val connection: UnderlyingTransport) {
 		fullCommand: String,
 		command: Int,
 		commandType: COMMAND_TYPE = COMMAND_TYPE.LIVE): OBDResponse {
+		if(isFinished) {
+			return OBDResponse.ERROR
+		}
 		log.debug("before runImpl")
 		var response = runImpl(fullCommand)
 		log.debug("after runImpl")
@@ -73,7 +77,7 @@ class Obd2Connection(private val connection: UnderlyingTransport) {
 			"?" -> return OBDResponse.QUESTION_MARK
 			"NODATA" -> return OBDResponse.NO_DATA
 			"UNABLETOCONNECT" -> {
-				initialized = false
+				isFinished = true
 				log.error("connection failure")
 				return OBDResponse.ERROR
 			}
diff --git a/OsmAnd/src/net/osmand/plus/plugins/odb/VehicleMetricsPlugin.kt b/OsmAnd/src/net/osmand/plus/plugins/odb/VehicleMetricsPlugin.kt
index bf75d1f4771..86639cc154e 100644
--- a/OsmAnd/src/net/osmand/plus/plugins/odb/VehicleMetricsPlugin.kt
+++ b/OsmAnd/src/net/osmand/plus/plugins/odb/VehicleMetricsPlugin.kt
@@ -18,6 +18,7 @@ import com.google.gson.GsonBuilder
 import com.google.gson.reflect.TypeToken
 import net.osmand.Location
 import net.osmand.PlatformUtil
+import net.osmand.StateChangedListener
 import net.osmand.aidlapi.OsmAndCustomizationConstants
 import net.osmand.aidlapi.OsmAndCustomizationConstants.DRAWER_VEHICLE_METRICS_ID
 import net.osmand.plus.OsmandApplication
@@ -301,9 +302,16 @@ class VehicleMetricsPlugin(app: OsmandApplication) : OsmandPlugin(app),
 		for (command in OBDCommand.entries) {
 			OBDDispatcher.addCommand(command)
 		}
+		settings.SIMULATE_OBD_DATA.addListener(simulateOBDListener)
 		return true
 	}
 
+	private val simulateOBDListener = StateChangedListener<Boolean> { enabled ->
+		if (!enabled) {
+			disconnect()
+		}
+	}
+
 	fun registerBooleanPref(prefId: String, defValue: Boolean): CommonPreference<Boolean> {
 		return registerBooleanPreference(prefId, defValue).makeGlobal().makeShared()
 	}
@@ -356,9 +364,9 @@ class VehicleMetricsPlugin(app: OsmandApplication) : OsmandPlugin(app),
 	}
 
 	fun disconnect() {
+		OBDDispatcher.stopReading()
 		socket?.apply {
 			if (isConnected) {
-				OBDDispatcher.stopReading()
 				close()
 			}
 		}
@@ -482,7 +490,7 @@ class VehicleMetricsPlugin(app: OsmandApplication) : OsmandPlugin(app),
 			close()
 			disconnect()
 			handler.removeCallbacksAndMessages(null)
-			handler.postDelayed({reconnectObd()}, RECONNECT_DELAY)
+			handler.postDelayed({ reconnectObd() }, RECONNECT_DELAY)
 		}
 	}
 
@@ -523,16 +531,18 @@ class VehicleMetricsPlugin(app: OsmandApplication) : OsmandPlugin(app),
 	}
 
 	private fun saveDeviceToUsedOBDDevicesList(deviceInfo: BTDeviceInfo) {
-		val currentList = getUsedOBDDevicesList().toMutableList()
-		val savedDevice = currentList.find { it.address == deviceInfo.address }
-		if (savedDevice == null) {
-			currentList.add(deviceInfo)
-			writeUsedOBDDevicesList(currentList)
-		} else {
-			if (savedDevice.name != deviceInfo.name) {
-				currentList.remove(savedDevice)
+		if (deviceInfo.address.isNotEmpty()) {
+			val currentList = getUsedOBDDevicesList().toMutableList()
+			val savedDevice = currentList.find { it.address == deviceInfo.address }
+			if (savedDevice == null) {
 				currentList.add(deviceInfo)
 				writeUsedOBDDevicesList(currentList)
+			} else {
+				if (savedDevice.name != deviceInfo.name) {
+					currentList.remove(savedDevice)
+					currentList.add(deviceInfo)
+					writeUsedOBDDevicesList(currentList)
+				}
 			}
 		}
 	}
diff --git a/OsmAnd/src/net/osmand/plus/plugins/odb/adapters/OBDDevicesAdapter.kt b/OsmAnd/src/net/osmand/plus/plugins/odb/adapters/OBDDevicesAdapter.kt
index a96a80aec01..199db2cfe60 100644
--- a/OsmAnd/src/net/osmand/plus/plugins/odb/adapters/OBDDevicesAdapter.kt
+++ b/OsmAnd/src/net/osmand/plus/plugins/odb/adapters/OBDDevicesAdapter.kt
@@ -81,7 +81,7 @@ open class OBDDevicesAdapter(
 			if (isConnected) R.string.external_device_details_disconnect else R.string.external_device_details_connect)
 		enableDisableItem.setIcon(
 			app.uiUtilities.getIcon(
-				if (isConnected) R.drawable.ic_action_obd2_connector_disconnect else R.drawable.ic_action_obd2_connector_disable,
+				if (isConnected) R.drawable.ic_action_obd2_connector_disconnect else R.drawable.ic_action_obd2_connector,
 				menuIconColor))
 		enableDisableItem.setOnMenuItemClickListener { _: MenuItem? ->
 			if (isConnected) {
@@ -121,7 +121,7 @@ open class OBDDevicesAdapter(
 			R.string.external_device_menu_forget)
 		forgetItem.setIcon(
 			app.uiUtilities.getIcon(
-				R.drawable.ic_action_obd2_connector_disconnect,
+				R.drawable.ic_action_obd2_connector_disable,
 				menuIconColor))
 		forgetItem.setOnMenuItemClickListener { _: MenuItem? ->
 			deviceClickListener?.onForget(device)
diff --git a/OsmAnd/src/net/osmand/plus/plugins/odb/dialogs/OBDDevicesListFragment.kt b/OsmAnd/src/net/osmand/plus/plugins/odb/dialogs/OBDDevicesListFragment.kt
index ee27d86ac19..878a22d56a6 100644
--- a/OsmAnd/src/net/osmand/plus/plugins/odb/dialogs/OBDDevicesListFragment.kt
+++ b/OsmAnd/src/net/osmand/plus/plugins/odb/dialogs/OBDDevicesListFragment.kt
@@ -162,7 +162,7 @@ class OBDDevicesListFragment : OBDDevicesBaseFragment(),
 				val disconnectedDevices =
 					plugin.getUsedOBDDevicesList().filter { it.address != connectedDevice?.address }
 						.toMutableList()
-				if (disconnectedDevices.isEmpty() && settings.SIMULATE_OBD_DATA.get()) {
+				if (connectedDevices.isEmpty() && disconnectedDevices.isEmpty() && settings.SIMULATE_OBD_DATA.get()) {
 					disconnectedDevices.add(BTDeviceInfo("Simulation Device", ""))
 				}
 				if (Algorithms.isEmpty(disconnectedDevices) && Algorithms.isEmpty(connectedDevices)) {
