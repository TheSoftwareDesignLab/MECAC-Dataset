diff --git a/OsmAnd/src/net/osmand/plus/views/layers/PreviewRouteLineLayer.java b/OsmAnd/src/net/osmand/plus/views/layers/PreviewRouteLineLayer.java
index 3e938e8c4a2..6f44aadfb2e 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/PreviewRouteLineLayer.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/PreviewRouteLineLayer.java
@@ -143,14 +143,15 @@ private void drawRouteLinePreview(Canvas canvas,
 		ty.add(endY);
 		ty.add(endY);
 
+		List<Integer> indexes = new ArrayList<>();
 		List<Double> angles = new ArrayList<>();
 		List<Double> distances = new ArrayList<>();
 		List<GeometryWayStyle<?>> styles = new ArrayList<>();
 		previewLineGeometry.setRouteStyleParams(getRouteLineColor(), getRouteLineWidth(tileBox),
 				true, directionArrowsColor, routeColoringType, routeInfoAttribute);
-		fillPreviewLineArrays(tx, ty, angles, distances, styles);
+		fillPreviewLineArrays(tx, ty, indexes, angles, distances, styles);
 		canvas.rotate(+tileBox.getRotate(), tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
-		previewLineGeometry.drawRouteSegment(tileBox, canvas, null, tx, ty, tx31, ty31, angles, distances, 0, styles);
+		previewLineGeometry.drawRouteSegment(tileBox, canvas, indexes, tx, ty, tx31, ty31, angles, distances, 0, styles);
 		canvas.rotate(-tileBox.getRotate(), tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
 
 		if (previewRouteLineInfo.shouldShowTurnArrows()) {
@@ -183,7 +184,7 @@ private void drawRouteLinePreview(Canvas canvas,
 		canvas.rotate(90, centerX, centerY);
 	}
 
-	private void fillPreviewLineArrays(List<Float> tx, List<Float> ty, List<Double> angles,
+	private void fillPreviewLineArrays(List<Float> tx, List<Float> ty, List<Integer> indexes, List<Double> angles,
 	                                   List<Double> distances, List<GeometryWayStyle<?>> styles) {
 		fillDistancesAngles(tx, ty, angles, distances);
 
@@ -201,6 +202,10 @@ private void fillPreviewLineArrays(List<Float> tx, List<Float> ty, List<Double>
 				fillSolidSingeColorArrays(tx, styles);
 			}
 		}
+
+		for (int i = 0; i < tx.size(); i++) {
+			indexes.add(i);
+		}
 	}
 
 	private void fillSolidSingeColorArrays(List<Float> tx, List<GeometryWayStyle<?>> styles) {
diff --git a/OsmAnd/src/net/osmand/plus/views/layers/RouteLayer.java b/OsmAnd/src/net/osmand/plus/views/layers/RouteLayer.java
index fd7800ef877..7cd675b63b0 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/RouteLayer.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/RouteLayer.java
@@ -607,6 +607,8 @@ private List<ActionPoint> calculateActionPoints(double topLatitude, double leftL
 			double rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,
 			Iterator<RouteDirectionInfo> it, int zoom) {
 		RouteDirectionInfo nf = null;
+
+		int currentRoute = helper.getRoute().getCurrentRoute();
 		
 		double DISTANCE_ACTION = 35;
 		if(zoom >= 17) {
@@ -656,13 +658,13 @@ private List<ActionPoint> calculateActionPoints(double topLatitude, double leftL
 				if (actionDist >= DISTANCE_ACTION) {
 					double normalizedOffset = 1 - (actionDist - DISTANCE_ACTION) / dist;
 					Location projection = calculateProjection(normalizedOffset, previousAction, loc);
-					actionPoints.add(new ActionPoint(projection, routePoint - 1, normalizedOffset));
+					actionPoints.add(new ActionPoint(projection, routePoint - 1 + currentRoute, normalizedOffset));
 					actionPoints.add(null);
 					prevFinishPoint = routePoint;
 					previousAction = null;
 					actionDist = 0;
 				} else {
-					actionPoints.add(new ActionPoint(loc, routePoint, 0.0f));
+					actionPoints.add(new ActionPoint(loc, routePoint + currentRoute, 0.0f));
 					previousAction = loc;
 				}
 			} else {
@@ -671,7 +673,7 @@ private List<ActionPoint> calculateActionPoints(double topLatitude, double leftL
 					addPreviousToActionPoints(actionPoints, lastProjection, routeNodes, DISTANCE_ACTION,
 							prevFinishPoint, routePoint, loc);
 				}
-				actionPoints.add(new ActionPoint(loc, routePoint, 0.0f));
+				actionPoints.add(new ActionPoint(loc, routePoint + currentRoute, 0.0f));
 				previousAction = loc;
 				prevFinishPoint = -1;
 				actionDist = 0;
@@ -687,23 +689,26 @@ private List<ActionPoint> calculateActionPoints(double topLatitude, double leftL
 	private void addPreviousToActionPoints(List<ActionPoint> actionPoints, Location lastProjection,
 	                                       List<Location> routeNodes, double distanceAction,
 	                                       int prevFinishPoint, int routePoint, Location loc) {
+		int currentRoute = helper.getRoute().getCurrentRoute();
+
 		// put some points in front
 		int ind = actionPoints.size();
 		Location lprevious = loc;
 		double dist = 0;
 		for (int k = routePoint - 1; k >= -1; k--) {
 			Location location = k == -1 ? lastProjection : routeNodes.get(k);
+			int actionPointIndex = k == -1 ? -1 : k + currentRoute;
 			float locDist = lprevious.distanceTo(location);
 			dist += locDist;
 			if (dist >= distanceAction) {
 				if (locDist > 1) {
 					double normalizedOffset = (dist - distanceAction) / locDist;
 					Location projection = calculateProjection(1 - normalizedOffset, lprevious, location);
-					actionPoints.add(ind, new ActionPoint(projection, k, normalizedOffset));
+					actionPoints.add(ind, new ActionPoint(projection, actionPointIndex, normalizedOffset));
 				}
 				break;
 			} else {
-				actionPoints.add(ind, new ActionPoint(location, k, 0.0));
+				actionPoints.add(ind, new ActionPoint(location, actionPointIndex, 0.0));
 				lprevious = location;
 			}
 			if (prevFinishPoint == k) {
diff --git a/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java b/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java
index afe0adba0a3..37d6fca34a2 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java
@@ -4,15 +4,12 @@
 import android.graphics.Path;
 import android.graphics.PointF;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import net.osmand.gpx.GPXUtilities;
 import net.osmand.Location;
 import net.osmand.core.android.MapRendererView;
 import net.osmand.core.jni.VectorLineArrowsProvider;
 import net.osmand.core.jni.VectorLinesCollection;
 import net.osmand.data.RotatedTileBox;
+import net.osmand.gpx.GPXUtilities;
 import net.osmand.plus.views.layers.geometry.GeometryWayDrawer.DrawPathData;
 import net.osmand.plus.views.layers.geometry.GeometryWayDrawer.DrawPathData31;
 import net.osmand.util.Algorithms;
@@ -25,11 +22,13 @@
 import java.util.Map;
 import java.util.TreeMap;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import gnu.trove.list.array.TByteArrayList;
 
 public abstract class GeometryWay<T extends GeometryWayContext, D extends GeometryWayDrawer<T>> {
 
-	private static final int INITIAL_POINT_INDEX_SHIFT = 1 << 30;
+	protected static final int INITIAL_POINT_INDEX_SHIFT = 1 << 30;
 
 	private double mapDensity;
 	private final T context;
@@ -49,7 +48,7 @@ public abstract class GeometryWay<T extends GeometryWayContext, D extends Geomet
 	//OpenGL
 	private final List<Integer> tx31 = new ArrayList<>();
 	private final List<Integer> ty31 = new ArrayList<>();
-	protected final List<List<DrawPathData31>> pathsData31Cache = new ArrayList<>();
+	protected List<List<DrawPathData31>> pathsData31Cache = new ArrayList<>();
 	public int baseOrder = -1;
 	public VectorLinesCollection vectorLinesCollection;
 	public VectorLineArrowsProvider vectorLineArrowsProvider;
@@ -228,69 +227,15 @@ public void drawSegments(@NonNull RotatedTileBox tb, @Nullable Canvas canvas, do
 		}
 		Location nextVisiblePoint = getNextVisiblePoint();
 		if (nextVisiblePoint != null) {
-			previousVisible = addInitialPoint(tb, topLatitude, leftLongitude, bottomLatitude, rightLongitude,
+			boolean added = addInitialPoint(tb, topLatitude, leftLongitude, bottomLatitude, rightLongitude,
 					style, previousVisible, nextVisiblePoint, startLocationIndex);
+			if (added) {
+				previousVisible = true;
+			}
 		}
 
 		if (hasMapRenderer && !pathsData31Cache.isEmpty()) {
-			boolean drawNext = false;
-			for (List<DrawPathData31> pathsDataList : pathsData31Cache) {
-				if (drawNext) {
-					drawPathLine(tb, pathsDataList);
-					continue;
-				}
-				List<DrawPathData31> newPathsDataList = new ArrayList<>();
-				for (DrawPathData31 pathData : pathsDataList) {
-					if (drawNext) {
-						newPathsDataList.add(pathData);
-						continue;
-					}
-					if (pathData.indexes.contains(startLocationIndex)) {
-						List<Integer> ind = new ArrayList<>();
-						List<Integer> tx = new ArrayList<>();
-						List<Integer> ty = new ArrayList<>();
-						List<Integer> indexes = pathData.indexes;
-						for (int i = 0; i < indexes.size(); i++) {
-							Integer index = indexes.get(i);
-							if (previousVisible && index >= INITIAL_POINT_INDEX_SHIFT) {
-								continue;
-							}
-							if (index >= startLocationIndex) {
-								ind.add(index);
-								tx.add(pathData.tx.get(i));
-								ty.add(pathData.ty.get(i));
-							}
-						}
-						if (previousVisible) {
-							if (!this.indexes.isEmpty()) {
-								Integer index = this.indexes.get(0);
-								ind.add(0, index);
-								tx.add(0, this.tx31.get(0));
-								ty.add(0, this.ty31.get(0));
-							}
-						}
-						if (tx.size() > 1) {
-							DrawPathData31 newPathData = new DrawPathData31(ind, tx, ty, pathData.style);
-							newPathsDataList.add(newPathData);
-						}
-						drawNext = true;
-					}
-				}
-				drawPathLine(tb, newPathsDataList);
-			}
-
-			if (shouldDrawArrows()) {
-				VectorLinesCollection vectorLinesCollection = this.vectorLinesCollection;
-				VectorLineArrowsProvider vectorLineArrowsProvider = this.vectorLineArrowsProvider;
-
-				boolean updateArrowsProvider = vectorLineArrowsProvider == null
-						|| !mapRenderer.hasSymbolsProvider(vectorLineArrowsProvider);
-				if (vectorLinesCollection != null && updateArrowsProvider) {
-					VectorLineArrowsProvider newArrowsProvider = new VectorLineArrowsProvider(vectorLinesCollection);
-					this.vectorLineArrowsProvider = newArrowsProvider;
-					mapRenderer.addSymbolsProvider(newArrowsProvider);
-				}
-			}
+			cutStartOfCachedPath(mapRenderer, tb, startLocationIndex, previousVisible);
 			return;
 		}
 
@@ -395,9 +340,10 @@ protected void addLocation(RotatedTileBox tb, double latitude, double longitude,
 	                           List<Integer> tx31, List<Integer> ty31,
 	                           List<Double> angles, List<Double> distances,
 	                           List<GeometryWayStyle<?>> styles) {
+		indexes.add((initialPoint ? INITIAL_POINT_INDEX_SHIFT : 0) +  locationIdx);
+
 		if (hasMapRenderer())
 		{
-			indexes.add((initialPoint ? INITIAL_POINT_INDEX_SHIFT : 0) +  locationIdx);
 			tx31.add(MapUtils.get31TileNumberX(longitude));
 			ty31.add(MapUtils.get31TileNumberY(latitude));
 			styles.add(style);
@@ -433,16 +379,87 @@ protected boolean addInitialPoint(RotatedTileBox tb, double topLatitude, double
 				&& bottomLatitude <= lastPoint.getLatitude() && lastPoint.getLatitude() <= topLatitude)) {
 			addLocation(tb, lastPoint.getLatitude(), lastPoint.getLongitude(), startLocationIndex, 0, true,
 					style, indexes, tx, ty, tx31, ty31, angles, distances, styles);
-			previousVisible = true;
+			return true;
+		}
+		return false;
+	}
+
+	protected void cutStartOfCachedPath(@NonNull MapRendererView mapRenderer,
+	                                    @NonNull RotatedTileBox tb,
+	                                    int startLocationIndex,
+	                                    boolean previousVisible) {
+		List<List<DrawPathData31>> newPathsData31Cache = new ArrayList<>();
+		boolean drawNext = false;
+		for (List<DrawPathData31> pathsDataList : pathsData31Cache) {
+			if (drawNext) {
+				newPathsData31Cache.add(pathsDataList);
+				drawPathLine(tb, pathsDataList);
+				continue;
+			}
+			List<DrawPathData31> newPathsDataList = new ArrayList<>();
+			for (DrawPathData31 pathData : pathsDataList) {
+				if (drawNext) {
+					newPathsDataList.add(pathData);
+					continue;
+				}
+				if (pathData.indexes.contains(startLocationIndex)) {
+					List<Integer> ind = new ArrayList<>();
+					List<Integer> tx = new ArrayList<>();
+					List<Integer> ty = new ArrayList<>();
+					List<Integer> indexes = pathData.indexes;
+					for (int i = 0; i < indexes.size(); i++) {
+						Integer index = indexes.get(i);
+						if (previousVisible && index >= INITIAL_POINT_INDEX_SHIFT) {
+							continue;
+						}
+						if (index >= startLocationIndex) {
+							ind.add(index);
+							tx.add(pathData.tx.get(i));
+							ty.add(pathData.ty.get(i));
+						}
+					}
+					if (previousVisible) {
+						if (!this.indexes.isEmpty()) {
+							Integer index = this.indexes.get(0);
+							ind.add(0, index);
+							tx.add(0, this.tx31.get(0));
+							ty.add(0, this.ty31.get(0));
+						}
+					}
+					if (tx.size() > 1) {
+						DrawPathData31 newPathData = new DrawPathData31(ind, tx, ty, pathData.style);
+						newPathsDataList.add(newPathData);
+					}
+					drawNext = true;
+				}
+			}
+			newPathsData31Cache.add(newPathsDataList);
+			drawPathLine(tb, newPathsDataList);
+		}
+
+		if (drawNext) {
+			this.pathsData31Cache = newPathsData31Cache;
+		}
+
+		if (shouldDrawArrows()) {
+			VectorLinesCollection vectorLinesCollection = this.vectorLinesCollection;
+			VectorLineArrowsProvider vectorLineArrowsProvider = this.vectorLineArrowsProvider;
+
+			boolean updateArrowsProvider = vectorLineArrowsProvider == null
+					|| !mapRenderer.hasSymbolsProvider(vectorLineArrowsProvider);
+			if (vectorLinesCollection != null && updateArrowsProvider) {
+				VectorLineArrowsProvider newArrowsProvider = new VectorLineArrowsProvider(vectorLinesCollection);
+				this.vectorLineArrowsProvider = newArrowsProvider;
+				mapRenderer.addSymbolsProvider(newArrowsProvider);
+			}
 		}
-		return previousVisible;
 	}
 
 	protected boolean shouldDrawArrows() {
 		return true;
 	}
 
-	private void clearArrays() {
+	protected void clearArrays() {
 		indexes.clear();
 		tx.clear();
 		ty.clear();
diff --git a/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiColoringGeometryWay.java b/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiColoringGeometryWay.java
index 06e12b363b7..ad4e1f26106 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiColoringGeometryWay.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiColoringGeometryWay.java
@@ -41,6 +41,8 @@ public abstract class MultiColoringGeometryWay
 		<C extends MultiColoringGeometryWayContext, D extends MultiColoringGeometryWayDrawer<C>> extends
 		GeometryWay<C, D> {
 
+	protected static final int MISSING_ROUTE_DATA_COLOR = RouteColorize.LIGHT_GREY;
+
 	protected int customColor;
 	protected float customWidth;
 	protected float[] dashPattern;
@@ -141,7 +143,7 @@ private List<Integer> getRouteInfoAttributesColors(List<Location> locations, Lis
 			RouteSegmentAttribute attribute =
 					statisticComputer.classifySegment(routeInfoAttribute, -1, segment.getObject());
 			int color = attribute.getColor();
-			color = color == 0 ? RouteColorize.LIGHT_GREY : color;
+			color = color == 0 ? MISSING_ROUTE_DATA_COLOR : color;
 
 			if (i == 0) {
 				for (int j = 0; j < firstSegmentLocationIdx; j++) {
@@ -215,8 +217,12 @@ protected void addLocation(RotatedTileBox tb, int locationIdx, double dist,
 	protected boolean addInitialPoint(RotatedTileBox tb, double topLatitude, double leftLongitude,
 	                                  double bottomLatitude, double rightLongitude, GeometryWayStyle<?> style,
 	                                  boolean previousVisible, Location lastPoint, int startLocationIndex) {
-		previousVisible = super.addInitialPoint(tb, topLatitude, leftLongitude, bottomLatitude, rightLongitude,
+		boolean added = super.addInitialPoint(tb, topLatitude, leftLongitude, bottomLatitude, rightLongitude,
 				style, previousVisible, lastPoint, startLocationIndex);
+		if (!added) {
+			return false;
+		}
+
 		if (style instanceof GeometryGradientWayStyle) {
 			GeometryGradientWayStyle<?> gradientWayStyle = (GeometryGradientWayStyle<?>) style;
 			GradientGeometryWayProvider locationProvider = getGradientLocationProvider();
@@ -243,7 +249,7 @@ protected boolean addInitialPoint(RotatedTileBox tb, double topLatitude, double
 			int prevStyleIdx = startLocationIndex > 0 ? startLocationIndex - 1 : 0;
 			prevStyle.color = getStyle(prevStyleIdx, transparentWayStyle).color;
 		}
-		return previousVisible;
+		return true;
 	}
 
 	@Override
diff --git a/OsmAnd/src/net/osmand/plus/views/layers/geometry/RouteGeometryWay.java b/OsmAnd/src/net/osmand/plus/views/layers/geometry/RouteGeometryWay.java
index cefac632bea..208dd35ffdd 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/geometry/RouteGeometryWay.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/geometry/RouteGeometryWay.java
@@ -1,11 +1,9 @@
 package net.osmand.plus.views.layers.geometry;
 
 import android.content.Context;
+import android.graphics.Canvas;
 import android.graphics.Paint;
-
-import androidx.annotation.ColorInt;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
+import android.util.Pair;
 
 import net.osmand.Location;
 import net.osmand.core.android.MapRendererView;
@@ -21,12 +19,20 @@
 import net.osmand.plus.utils.ColorUtilities;
 import net.osmand.plus.utils.NativeUtilities;
 import net.osmand.plus.views.layers.RouteLayer.ActionPoint;
+import net.osmand.plus.views.layers.geometry.GeometryWayDrawer.DrawPathData31;
 import net.osmand.router.RouteColorize;
 import net.osmand.util.Algorithms;
 import net.osmand.util.MapUtils;
 
 import java.util.ArrayList;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import androidx.annotation.ColorInt;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 public class RouteGeometryWay extends
 		MultiColoringGeometryWay<RouteGeometryWayContext, MultiColoringGeometryWayDrawer<RouteGeometryWayContext>> {
@@ -35,6 +41,7 @@ public class RouteGeometryWay extends
 
 	private final RoutingHelper helper;
 	private RouteCalculationResult route;
+	private int startLocationIndex;
 
 	private Integer customDirectionArrowColor;
 
@@ -42,6 +49,9 @@ public class RouteGeometryWay extends
 	private boolean drawDirectionArrows = true;
 	private VectorLinesCollection actionLinesCollection;
 
+	private final List<Segment> cachedSegments = new ArrayList<>();
+	private Segment currentCachedSegment = null;
+
 	public RouteGeometryWay(RouteGeometryWayContext context) {
 		super(context, new MultiColoringGeometryWayDrawer<>(context));
 		this.helper = context.getApp().getRoutingHelper();
@@ -100,6 +110,80 @@ public boolean updateRoute(@NonNull RotatedTileBox tb, @NonNull RouteCalculation
 		return false;
 	}
 
+	@Override
+	public void drawSegments(@NonNull RotatedTileBox tb, @Nullable Canvas canvas,
+	                         double topLatitude, double leftLongitude, double bottomLatitude, double rightLongitude,
+	                         Location lastProjection, int startLocationIndex) {
+		this.startLocationIndex = startLocationIndex;
+		super.drawSegments(tb, canvas, topLatitude, leftLongitude, bottomLatitude, rightLongitude,
+				lastProjection, startLocationIndex);
+	}
+
+	@Override
+	protected boolean addInitialPoint(RotatedTileBox tb,
+	                                  double topLatitude, double leftLongitude, double bottomLatitude, double rightLongitude,
+	                                  GeometryWayStyle<?> style, boolean previousVisible, Location lastPoint, int startLocationIndex) {
+		boolean added = super.addInitialPoint(tb, topLatitude, leftLongitude, bottomLatitude, rightLongitude,
+				style, previousVisible, lastPoint, startLocationIndex);
+		if (added) {
+			if (currentCachedSegment == null) {
+				currentCachedSegment = new Segment();
+			}
+			currentCachedSegment.initialLocations.add(lastPoint);
+		}
+		return added;
+	}
+
+	@Override
+	protected void cutStartOfCachedPath(@NonNull MapRendererView mapRenderer, @NonNull RotatedTileBox tb, int startLocationIndex, boolean previousVisible) {
+		super.cutStartOfCachedPath(mapRenderer, tb, startLocationIndex, previousVisible);
+
+		List<Segment> segments = new ArrayList<>();
+		for (List<DrawPathData31> segmentData : pathsData31Cache) {
+
+			Segment segment = new Segment();
+			segment.indexes = new ArrayList<>();
+			segment.styles = new ArrayList<>();
+
+			for (int lineIndex = 0; lineIndex < segmentData.size(); lineIndex++) {
+				DrawPathData31 line = segmentData.get(lineIndex);
+
+				boolean lastLine = lineIndex + 1 == segmentData.size();
+				int endIndex = lastLine
+						? line.indexes.size()
+						: line.indexes.size() - 1;
+				for (int i = 0; i < endIndex; i++) {
+					int index = line.indexes.get(i);
+					if (index >= INITIAL_POINT_INDEX_SHIFT) {
+						int x31 = line.tx.get(i);
+						int y31 = line.ty.get(i);
+						double lat = MapUtils.get31LatitudeY(y31);
+						double lon = MapUtils.get31LongitudeX(x31);
+						segment.initialLocations.add(new Location("", lat, lon));
+					}
+
+					segment.indexes.add(index);
+					segment.styles.add(line.style);
+				}
+			}
+			segments.add(segment);
+		}
+
+		cachedSegments.clear();
+		cachedSegments.addAll(segments);
+	}
+
+	@Override
+	public void drawRouteSegment(@NonNull RotatedTileBox tb, @Nullable Canvas canvas, List<Integer> indexes, List<Float> tx, List<Float> ty, List<Integer> tx31, List<Integer> ty31, List<Double> angles, List<Double> distances, double distToFinish, List<GeometryWayStyle<?>> styles) {
+		super.drawRouteSegment(tb, canvas, indexes, tx, ty, tx31, ty31, angles, distances, distToFinish, styles);
+
+		Segment segment = currentCachedSegment != null ? currentCachedSegment : new Segment();
+		segment.indexes = new ArrayList<>(indexes);
+		segment.styles = new ArrayList<>(styles);
+		cachedSegments.add(segment);
+		currentCachedSegment = null;
+	}
+
 	@NonNull
 	@Override
 	public GeometryWayStyle<?> getDefaultWayStyle() {
@@ -174,6 +258,12 @@ public void resetActionLines() {
 		}
 	}
 
+	@Override
+	protected void clearArrays() {
+		super.clearArrays();
+		cachedSegments.clear();
+	}
+
 	public List<List<ActionPoint>> getActionArrows(List<ActionPoint> actionPoints) {
 		List<List<ActionPoint>> ll = new ArrayList<>();
 		ll.add(new ArrayList<>());
@@ -216,6 +306,7 @@ public void buildActionArrows(@NonNull List<ActionPoint> actionPoints, int custo
 					vectorLine.setPoints(points);
 					vectorLine.setIsHidden(false);
 					vectorLine.setLineWidth(customWidth);
+					vectorLine.setFillColor(NativeUtilities.createFColorARGB(arrowColor));
 					lineIdx++;
 				} else {
 					VectorLineBuilder vectorLineBuilder = new VectorLineBuilder();
@@ -244,53 +335,151 @@ public int getContrastArrowColor(@NonNull List<ActionPoint> line, @ColorInt int
 		int lightColor = ColorUtilities.getSecondaryIconColor(context, false);
 		int darkColor = ColorUtilities.getSecondaryIconColor(context, true);
 
-		List<Integer> colors = new ArrayList<>(line.size());
-		int originalLowDistanceCount = 0;
-		int lightLowDistanceCount = 0;
-		int darkLowDistanceCount = 0;
+		Map<Integer, Integer> lowDistanceCounts = new LinkedHashMap<>();
+		lowDistanceCounts.put(originalArrowColor, 0);
+		lowDistanceCounts.put(lightColor, 0);
+		lowDistanceCounts.put(darkColor, 0);
 
 		for (ActionPoint actionPoint : line) {
-			Integer lineColor;
+			Integer lineColor = getActionPointColor(actionPoint);
+			if (lineColor == null) {
+				return originalArrowColor;
+			}
 
-			if (styleMap.isEmpty()) {
-				lineColor = getDefaultWayStyle().getColor();
-			} else {
-				GeometryWayStyle<?> style = getStyle(actionPoint.index, null);
-				if (style == null || !style.hasPathLine()) {
-					return originalArrowColor;
-				}
+			for (Entry<Integer, Integer> entry : lowDistanceCounts.entrySet()) {
+				int color = entry.getKey();
+				int count = entry.getValue();
 
-				if (style instanceof GeometryGradientWayStyle<?>) {
-					GeometryGradientWayStyle<?> gradientStyle = ((GeometryGradientWayStyle<?>) style);
-					int startColor = gradientStyle.currColor;
-					int endColor = gradientStyle.nextColor;
-					lineColor = RouteColorize.getIntermediateColor(startColor, endColor, actionPoint.normalizedOffset);
-				} else {
-					lineColor = style.getColor();
+				if (ColorUtilities.getColorsSquareDistance(color, lineColor) < MIN_COLOR_SQUARE_DISTANCE) {
+					entry.setValue(count + 1);
 				}
 			}
+		}
 
-			if (lineColor == null) {
-				return originalArrowColor;
+		int minLowDistanceCount = Integer.MAX_VALUE;
+		for (int count : lowDistanceCounts.values()) {
+			if (count < minLowDistanceCount) {
+				minLowDistanceCount = count;
 			}
-			colors.add(lineColor);
+		}
 
-			if (ColorUtilities.getColorsSquareDistance(originalArrowColor, lineColor) < MIN_COLOR_SQUARE_DISTANCE) {
-				originalLowDistanceCount++;
+		for (Entry<Integer, Integer> entry : lowDistanceCounts.entrySet()) {
+			int color = entry.getKey();
+			int count = entry.getValue();
+			if (count == minLowDistanceCount) {
+				return color;
 			}
-			if (ColorUtilities.getColorsSquareDistance(lightColor, lineColor) < MIN_COLOR_SQUARE_DISTANCE) {
-				lightLowDistanceCount++;
+		}
+
+		return originalArrowColor;
+	}
+
+	@ColorInt
+	private Integer getActionPointColor(@NonNull ActionPoint actionPoint) {
+		if (styleMap.isEmpty()) {
+			return getDefaultWayStyle().getColor();
+		}
+
+		GeometryWayProvider locationProvider = getLocationProvider();
+		if (locationProvider == null) {
+			return null;
+		}
+
+		for (Segment segment : cachedSegments) {
+
+			if (!segment.isCompleted()) {
+				return null;
+			}
+
+			Pair<Integer, Integer> range = segment.getClosestPointOrdersRange(actionPoint.index);
+			if (range == null) {
+				return null;
 			}
-			if (ColorUtilities.getColorsSquareDistance(darkColor, lightColor) < MIN_COLOR_SQUARE_DISTANCE) {
-				darkLowDistanceCount++;
+
+			GeometryWayStyle<?> style = segment.styles.get(range.first);
+
+			if (!(style instanceof GeometryGradientWayStyle<?>)) {
+				return style.getColor();
+			}
+
+			GeometryGradientWayStyle<?> gradientStyle = (GeometryGradientWayStyle<?>) style;
+			double normalizedOffset;
+
+			if (range.first.equals(range.second)) {
+				if (range.first + 1 == segment.styles.size()) {
+					return gradientStyle.nextColor;
+				}
+
+				normalizedOffset = actionPoint.normalizedOffset;
+			} else {
+				int startIndex = segment.indexes.get(range.first);
+				int endIndex = segment.indexes.get(range.second);
+
+				double startLat;
+				double startLon;
+				double endLat;
+				double endLon;
+
+				if (startIndex >= INITIAL_POINT_INDEX_SHIFT) {
+					int index = startIndex - INITIAL_POINT_INDEX_SHIFT - startLocationIndex;
+					if (index < 0 || index > segment.initialLocations.size()) {
+						return null;
+					}
+					Location location = segment.initialLocations.get(index);
+					startLat = location.getLatitude();
+					startLon = location.getLongitude();
+				} else {
+					startLat = locationProvider.getLatitude(startIndex);
+					startLon = locationProvider.getLongitude(startIndex);
+				}
+
+				if (endIndex >= INITIAL_POINT_INDEX_SHIFT) {
+					return null;
+				} else {
+					endLat = locationProvider.getLongitude(endIndex);
+					endLon = locationProvider.getLongitude(endIndex);
+				}
+
+				normalizedOffset = MapUtils.getProjectionCoeff(
+						actionPoint.location.getLatitude(), actionPoint.location.getLongitude(),
+						startLat, startLon,
+						endLat, endLon);
 			}
+
+			int startColor = gradientStyle.currColor;
+			int endColor = gradientStyle.nextColor;
+			return RouteColorize.getIntermediateColor(startColor, endColor, normalizedOffset);
 		}
 
-		if (originalLowDistanceCount < line.size() / 2f
-				|| originalLowDistanceCount < Math.min(lightLowDistanceCount, darkLowDistanceCount)) {
-			return originalArrowColor;
+		return null;
+	}
+
+	private static class Segment {
+		public List<Location> initialLocations = new ArrayList<>();
+		public List<Integer> indexes;
+		public List<GeometryWayStyle<?>> styles;
+
+		public boolean isCompleted() {
+			return indexes != null && styles != null;
 		}
 
-		return lightLowDistanceCount <= darkLowDistanceCount ? lightColor : darkColor;
+		@Nullable
+		public Pair<Integer, Integer> getClosestPointOrdersRange(int index) {
+			for (int pointOrder = 0; pointOrder < indexes.size(); pointOrder++) {
+				int pointIndex = indexes.get(pointOrder);
+
+				if (index >= 0 && index == pointIndex || index == -1 && pointIndex >= INITIAL_POINT_INDEX_SHIFT) {
+					return Pair.create(pointOrder, pointOrder);
+				}
+
+				if (pointIndex > index && pointIndex < INITIAL_POINT_INDEX_SHIFT) {
+					return pointOrder > 0
+							? Pair.create(pointOrder - 1, pointOrder)
+							: null;
+				}
+			}
+
+			return null;
+		}
 	}
 }
\ No newline at end of file
