diff --git a/OsmAnd/res/drawable/box_expand.xml b/OsmAnd/res/drawable/box_expand.xml
new file mode 100644
index 00000000000..2272c902026
--- /dev/null
+++ b/OsmAnd/res/drawable/box_expand.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="utf-8"?>
+<selector xmlns:android="http://schemas.android.com/apk/res/android">
+    <item android:state_pressed="true" android:drawable="@drawable/box_expand_pressed" />
+    <item android:state_focused="true" android:drawable="@drawable/box_expand_pressed" />
+    <item android:drawable="@drawable/box_expand_normal" />
+</selector>
diff --git a/OsmAnd/res/layout/main.xml b/OsmAnd/res/layout/main.xml
index b11bded402e..a0aac44a8e4 100644
--- a/OsmAnd/res/layout/main.xml
+++ b/OsmAnd/res/layout/main.xml
@@ -2,7 +2,7 @@
 <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="vertical"
     android:layout_width="fill_parent"
-    android:layout_height="fill_parent" android:keepScreenOn="true">
+    android:layout_height="fill_parent" android:keepScreenOn="true" android:clipChildren="false">
 <net.osmand.plus.views.OsmandMapTileView android:id="@+id/MapView" android:layout_width="fill_parent" android:layout_height="fill_parent"/>
 
 <LinearLayout android:layout_width="wrap_content" android:id="@+id/RouteLayout" android:orientation="horizontal" android:layout_height="wrap_content" 
diff --git a/OsmAnd/src/net/osmand/plus/views/GPXLayer.java b/OsmAnd/src/net/osmand/plus/views/GPXLayer.java
index 7e87c86bb21..58d1239c095 100644
--- a/OsmAnd/src/net/osmand/plus/views/GPXLayer.java
+++ b/OsmAnd/src/net/osmand/plus/views/GPXLayer.java
@@ -18,20 +18,14 @@
 import android.graphics.Paint.Style;
 
 public class GPXLayer extends OsmandMapLayer {
-
 	
 	private OsmandMapTileView view;
 	
 	private List<List<WptPt>> points = new ArrayList<List<WptPt>>();
 	private Paint paint;
-	
 
 	private Path path;
 	
-	public GPXLayer(){
-	}
-	
-
 	private void initUI() {
 		paint = new Paint();
 		paint.setColor(Color.argb(180, 160, 10, 215));
diff --git a/OsmAnd/src/net/osmand/plus/views/MapInfoControl.java b/OsmAnd/src/net/osmand/plus/views/MapInfoControl.java
new file mode 100644
index 00000000000..c4882e66a73
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/MapInfoControl.java
@@ -0,0 +1,50 @@
+package net.osmand.plus.views;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+
+public abstract class MapInfoControl extends View {
+	int width = 0;
+	int height = 0;
+	Drawable background;
+
+	public MapInfoControl(Context ctx, int background) {
+		super(ctx);
+		this.background = ctx.getResources().getDrawable(background).mutate();
+	}
+
+	@Override
+	protected void drawableStateChanged() {
+		super.drawableStateChanged();
+		background.setState(getDrawableState());
+		invalidate();
+	}
+
+	public boolean updateInfo() { return false; }
+	
+	protected boolean updateVisibility(boolean visible) {
+		if (visible != (getVisibility() == View.VISIBLE)) {
+			if (visible) {
+				setVisibility(View.VISIBLE);
+			} else {
+				setVisibility(View.GONE);
+			}
+			requestLayout();
+			return true;
+		}
+		return false;
+	}
+	
+	@Override
+	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+		super.onLayout(changed, left, top, right, bottom);
+		background.setBounds(0, 0, right - left, bottom - top);
+	}
+
+	@Override
+	protected void onDraw(Canvas cv) {
+		background.draw(cv);
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java b/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java
index 73240fee5fb..fecb02696e9 100644
--- a/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java
+++ b/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java
@@ -1,25 +1,17 @@
 package net.osmand.plus.views;
 
 
-import java.util.ArrayList;
-import java.util.List;
-
 import net.osmand.Algoritms;
 import net.osmand.OsmAndFormatter;
 import net.osmand.osm.LatLon;
 import net.osmand.plus.R;
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.routing.RoutingHelper.RouteDirectionInfo;
-import net.osmand.plus.routing.RoutingHelper.TurnType;
 import android.content.Context;
 import android.graphics.Canvas;
 import android.graphics.Color;
-import android.graphics.Matrix;
 import android.graphics.Paint;
-import android.graphics.Paint.Cap;
-import android.graphics.Paint.Join;
 import android.graphics.Paint.Style;
-import android.graphics.Path;
 import android.graphics.Rect;
 import android.graphics.RectF;
 import android.graphics.drawable.Drawable;
@@ -27,7 +19,6 @@
 import android.text.format.DateFormat;
 import android.util.DisplayMetrics;
 import android.view.Gravity;
-import android.view.MotionEvent;
 import android.view.View;
 import android.view.View.MeasureSpec;
 import android.view.ViewGroup;
@@ -40,56 +31,31 @@
 
 public class MapInfoLayer extends OsmandMapLayer {
 
+	public static float scaleCoefficient = 1;
+	
 	private final MapActivity map;
 	private final RouteLayer routeLayer;
 	private OsmandMapTileView view;
 	
-	private boolean showMiniMap = false;
-	private boolean showArrivalTime = true;
-	
-	private Paint paintBlack;
 	private Paint paintText;
 	private Paint paintSubText;
-	private Paint paintMiniRoute;
-	private Paint fillBlack;
-	private Paint fillRed;
-	private Paint paintRouteDirection;
+	private Paint paintImg;
 	
-	private long cachedLeftTime = 0;
-	private float[] calculations = new float[1];
-	private int cachedMeters = 0;
-	private float cachedSpeed = 0;
 	private float cachedRotate = 0;
-	
-	private DisplayMetrics dm;
-	
-	private float scaleCoefficient;
-	private Paint paintImg;
+	private boolean showArrivalTime = true;
+	private boolean showMiniMap = false;
 	
 	// layout pseudo-constants
-	private int STATUS_BAR_MARGIN_X = 10;
-	private int MARGIN_Y = 10;
-	
-	// controls
-	private TextInfoControl distanceControl;
-	private TextInfoControl speedControl;
-	private TextInfoControl leftTimeControl;
-	private NextTurnInfoControl nextTurnInfo;
+	private int STATUS_BAR_MARGIN_X = 4;
 	
 	private ImageView backToLocation;
 	private ImageView compassView;
 	private View progressBar;
 	
 	// groups
-	private List<MapInfoControl> leftControls = new ArrayList<MapInfoLayer.MapInfoControl>();
-	private List<MapInfoControl> rightControls = new ArrayList<MapInfoLayer.MapInfoControl>();
+	private MapStackControl rightStack;
+	private MapStackControl leftStack;
 	private ViewGroup statusBar;
-	private Drawable statusBarBackground;
-	
-	// currently pressed view
-	private View pressedView = null;
-	
-	
 	
 	public MapInfoLayer(MapActivity map, RouteLayer layer){
 		this.map = map;
@@ -100,7 +66,7 @@ public MapInfoLayer(MapActivity map, RouteLayer layer){
 	public void initLayer(final OsmandMapTileView view) {
 		this.view = view;
 		WindowManager mgr = (WindowManager) view.getContext().getSystemService(Context.WINDOW_SERVICE);
-		dm = new DisplayMetrics();
+		DisplayMetrics dm = new DisplayMetrics();
 		mgr.getDefaultDisplay().getMetrics(dm);
 		scaleCoefficient = dm.density;
 		if (Math.min(dm.widthPixels / (dm.density * 160), dm.heightPixels / (dm.density * 160)) > 2.5f) {
@@ -108,14 +74,6 @@ public void initLayer(final OsmandMapTileView view) {
 			scaleCoefficient *= 1.5f;
 		}
 		
-		FrameLayout parent = (FrameLayout) view.getParent();
-		
-		paintBlack = new Paint();
-		paintBlack.setStyle(Style.STROKE);
-		paintBlack.setColor(Color.BLACK);
-		paintBlack.setTextSize(23 * scaleCoefficient);
-		paintBlack.setAntiAlias(true);
-		
 		paintText = new Paint();
 		paintText.setStyle(Style.FILL_AND_STROKE);
 		paintText.setColor(Color.BLACK);
@@ -134,110 +92,59 @@ public void initLayer(final OsmandMapTileView view) {
 		paintImg.setFilterBitmap(true);
 		paintImg.setAntiAlias(true);
 		
-		paintRouteDirection = new Paint();
-		paintRouteDirection.setStyle(Style.FILL_AND_STROKE);
-		paintRouteDirection.setColor(Color.rgb(100, 0, 255));
-		paintRouteDirection.setAntiAlias(true);
-		
-		fillBlack = new Paint();
-		fillBlack.setStyle(Style.FILL_AND_STROKE);
-		fillBlack.setColor(Color.BLACK);
-		fillBlack.setAntiAlias(true);
-		
-		paintMiniRoute = new Paint();
-		paintMiniRoute.setStyle(Style.STROKE);
-		paintMiniRoute.setStrokeWidth(35 * scaleCoefficient);
-		paintMiniRoute.setColor(Color.BLUE);
-		paintMiniRoute.setStrokeJoin(Join.ROUND);
-		paintMiniRoute.setStrokeCap(Cap.ROUND);
-		paintMiniRoute.setAntiAlias(true);
-		
-		fillRed = new Paint();
-		fillRed.setStyle(Style.FILL_AND_STROKE);
-		fillRed.setColor(Color.RED);
-		fillRed.setAntiAlias(true);
+		createTopBarElements();
+	}
+	
+	
+	public void createTopBarElements() {
+		// 1. Create view groups and controls
+		statusBar = createStatusBar();
 		
+		rightStack = new MapStackControl(view.getContext());
+		rightStack.addStackView(createDistanceControl());
+		rightStack.addCollapsedView(createSpeedControl());
+		rightStack.addCollapsedView(createTimeControl());
 		
+		leftStack = new MapStackControl(view.getContext());
+		leftStack.addStackView(createNextInfoControl());
+		leftStack.addStackView(createMiniMapControl());
 		
+		// 2. Preparations
 		STATUS_BAR_MARGIN_X = (int) (STATUS_BAR_MARGIN_X * scaleCoefficient);
-		statusBar = createStatusBar();
-		parent.addView(statusBar);
-		
-		MARGIN_Y = statusBar.getMeasuredHeight() ;
-		Drawable time = view.getResources().getDrawable(R.drawable.info_time);
-		speedControl = new TextInfoControl(R.drawable.box_top, null, 0, paintText, paintSubText);
-		leftTimeControl = new TextInfoControl(R.drawable.box_top, time, 0, paintText, paintSubText);
-		leftTimeControl.setOnClickListener(new View.OnClickListener() {
-			
-			@Override
-			public void onClick(View v) {
-				showArrivalTime = !showArrivalTime;
-				view.getSettings().SHOW_ARRIVAL_TIME_OTHERWISE_EXPECTED_TIME.set(showArrivalTime);
-				view.refreshMap();
-			}
-		});
-		distanceControl = new TextInfoControl(R.drawable.box_top, view.getResources().getDrawable(R.drawable.info_target), 0,
-				paintText, paintSubText);
-		distanceControl.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View v) {
-				AnimateDraggingMapThread thread = view.getAnimatedDraggingThread();
-				LatLon pointToNavigate = view.getSettings().getPointToNavigate();
-				if(pointToNavigate != null){
-					int fZoom = view.getZoom() < 15 ? 15 : view.getZoom(); 
-					thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), 
-							fZoom, true);
-				}
-			}
-		});
-		rightControls.add(distanceControl);
-		rightControls.add(speedControl);
-		rightControls.add(leftTimeControl);
+		statusBar.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
+		Rect statusBarPadding = new Rect();
+		statusBar.getBackground().getPadding(statusBarPadding);
+		Rect topRectPadding = new Rect();
+		view.getResources().getDrawable(R.drawable.box_top).getPadding(topRectPadding);
+
+		// 3. put into frame parent layout controls
+		FrameLayout parent = (FrameLayout) view.getParent();
+		// status bar hides own top part 
+		int topMargin = statusBar.getMeasuredHeight()  - statusBarPadding.top;
+		// we want that status bar lays over map stack controls
+		topMargin -= topRectPadding.bottom;
+
+		FrameLayout.LayoutParams flp = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,
+				android.view.ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.RIGHT);
+		flp.rightMargin = STATUS_BAR_MARGIN_X;
+		flp.topMargin = topMargin;
+		parent.addView(rightStack, flp);
 		
+		flp = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,
+				android.view.ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.LEFT);
+		flp.leftMargin = STATUS_BAR_MARGIN_X;
+		flp.topMargin = topMargin;
+		parent.addView(leftStack, flp);
 
-		nextTurnInfo = new NextTurnInfoControl(R.drawable.box_top, paintText, paintSubText);
-		nextTurnInfo.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View v) {
-				showMiniMap = !showMiniMap;
-				view.refreshMap();
-			}
-		});
-		leftControls.add(nextTurnInfo);
-		showArrivalTime = view.getSettings().SHOW_ARRIVAL_TIME_OTHERWISE_EXPECTED_TIME.get();
-	}
+		flp = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT,
+				android.view.ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.TOP);
+		flp.leftMargin = STATUS_BAR_MARGIN_X;
+		flp.rightMargin = STATUS_BAR_MARGIN_X;
+		flp.topMargin = -topRectPadding.top;
 
-	public void relayoutLeftControls(MapInfoControl... cs){
-		for(MapInfoControl c : cs) {
-			c.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
-		}
-		int w = 0;
-		for(MapInfoControl c : leftControls) {
-			w = Math.max(w, c.getMeasuredWidth());
-		}
-		int x = STATUS_BAR_MARGIN_X;
-		int y = MARGIN_Y;
-		for(MapInfoControl c : leftControls) {
-			c.layout(x, y, x + w, y + c.getMeasuredHeight());
-			y += c.getMeasuredHeight();
-		}
-	}
-	
-	public void relayoutRightControls(MapInfoControl... cs){
-		for(MapInfoControl c : cs) {
-			c.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
-		}
-		int w = 0;
-		for(MapInfoControl c : rightControls) {
-			w = Math.max(w, c.getMeasuredWidth());
-		}
-		int x = view.getWidth() -  STATUS_BAR_MARGIN_X - w;
-		int y = MARGIN_Y;
-		for(MapInfoControl c : rightControls) {
-			c.layout(x, y, x + w, y + c.getMeasuredHeight());
-			y += c.getMeasuredHeight();
-		}
+		parent.addView(statusBar, flp);
 	}
+
 	
 	public boolean distChanged(int oldDist, int dist){
 		if(oldDist != 0 && oldDist - dist < 100 && Math.abs(((float) dist - oldDist)/oldDist) < 0.01){
@@ -246,128 +153,17 @@ public boolean distChanged(int oldDist, int dist){
 		return true;
 	}
 	
-	private void updateDistanceToGo() {
-		if(map.getPointToNavigate() != null){
-			int d = 0;
-			if(map.getRoutingHelper().isRouterEnabled()){
-				d = map.getRoutingHelper().getLeftDistance();
-			} 
-			if (d == 0) {
-				Location.distanceBetween(view.getLatitude(), view.getLongitude(), map.getPointToNavigate().getLatitude(), map
-						.getPointToNavigate().getLongitude(), calculations);
-				d = (int) calculations[0];
-			}
-			if(distChanged(cachedMeters, d)){
-				cachedMeters = d;
-				if(cachedMeters <= 20){
-					cachedMeters = 0;
-					distanceControl.setText(null, null);
-				} else {
-					String ds = OsmAndFormatter.getFormattedDistance(cachedMeters, map);
-					int ls = ds.lastIndexOf(' ');
-					if(ls == -1) {
-						distanceControl.setText(ds, null);	
-					} else {
-						distanceControl.setText(ds.substring(0, ls), ds.substring(ls + 1));
-					}
-				}
-				relayoutRightControls(distanceControl);
-			}
-		} else if(cachedMeters != 0){
-			cachedMeters = 0;
-			distanceControl.setText(null, null);
-			relayoutRightControls(distanceControl);
-		}
-	}
-	
 	@Override
 	public void onDraw(Canvas canvas, RectF latlonBounds, RectF tilesRect, boolean nightMode) {
-		// prepare data (left distance, speed, compass)
-		updateDistanceToGo();
-		updateSpeedInfo();
-		updateTimeLeftInfo();
+		// update data on draw
+		rightStack.updateInfo();
+		leftStack.updateInfo();
 		if(view.getRotate() != cachedRotate) {
 			cachedRotate = view.getRotate();
 			compassView.invalidate();
 		}
-		if(nextTurnInfo.isVisible() != (nextTurnInfo.getMeasuredHeight() > 0)) {
-			relayoutLeftControls(nextTurnInfo);
-		}
-		
-		// draw left controls
-		for (int i = leftControls.size() - 1; i >= 0; i--) {
-			if(leftControls.get(i).getMeasuredHeight() > 0) {
-				leftControls.get(i).onDraw(canvas);
-			}
-		}
-		for (int i = rightControls.size() - 1; i >= 0; i--) {
-			if(rightControls.get(i).getMeasuredHeight() > 0) {
-				rightControls.get(i).onDraw(canvas);
-			}
-		}
-		statusBarBackground.draw(canvas);
-	}
-
-	private void updateSpeedInfo() {
-		// draw speed 	
-		if(map.getLastKnownLocation() != null){
-			if(map.getLastKnownLocation().hasSpeed()) {
-				if(Math.abs(map.getLastKnownLocation().getSpeed() - cachedSpeed) > .3f){
-					cachedSpeed = map.getLastKnownLocation().getSpeed();
-					String ds = OsmAndFormatter.getFormattedSpeed(cachedSpeed, map);
-					int ls = ds.lastIndexOf(' ');
-					if(ls == -1) {
-						speedControl.setText(ds, null);	
-					} else {
-						speedControl.setText(ds.substring(0, ls), ds.substring(ls + 1));
-					}
-					relayoutRightControls(speedControl);
-				}	
-			} else if(cachedSpeed != 0) {
-				cachedSpeed = 0;
-				speedControl.setText(null, null);
-				relayoutRightControls(speedControl);
-			}
-		}
 	}
 	
-	private void updateTimeLeftInfo() {
-		int time = 0;
-		if (routeLayer != null && routeLayer.getHelper().isRouterEnabled()) {
-			boolean followingMode = routeLayer.getHelper().isFollowingMode();
-			time = routeLayer.getHelper().getLeftTime();
-			if (time != 0) {
-				if (followingMode && showArrivalTime) {
-					long toFindTime = time * 1000 + System.currentTimeMillis();
-					if (Math.abs(toFindTime - cachedLeftTime) > 30000) {
-						cachedLeftTime = toFindTime;
-						if (DateFormat.is24HourFormat(map)) {
-							leftTimeControl.setText(DateFormat.format("kk:mm", toFindTime).toString(), null); //$NON-NLS-1$
-						} else {
-							leftTimeControl.setText(DateFormat.format("k:mm aa", toFindTime).toString(), null); //$NON-NLS-1$
-						}
-						relayoutRightControls(leftTimeControl);
-					}
-				} else {
-					if (Math.abs(time - cachedLeftTime) > 30) {
-						cachedLeftTime = time;
-						int hours = time / (60 * 60);
-						int minutes = (time / 60) % 60;
-						leftTimeControl.setText(String.format("%d:%02d", hours, minutes), null); //$NON-NLS-1$
-					}
-					relayoutRightControls(leftTimeControl);
-				}
-			}
-		}
-		if (time == 0 && cachedLeftTime != 0) {
-			cachedLeftTime = 0;
-			leftTimeControl.setText(null, null);
-			relayoutRightControls(leftTimeControl);
-		}
-	}
-	
-	
-	
 	@Override
 	public void destroyLayer() {
 	}
@@ -378,40 +174,6 @@ public boolean drawInScreenPixels() {
 	}
 	
 	
-	@Override
-	public boolean onTouchEvent(MotionEvent event) {
-		int x = (int) event.getX();
-		int y = (int) event.getY();
-		if (event.getAction() == MotionEvent.ACTION_DOWN) {
-			pressedView = null;
-			ArrayList<View> l = new ArrayList<View>(leftControls);
-			l.addAll(rightControls);
-			for (View v : l) {
-				if (v.getMeasuredHeight() > 0 && v.isClickable()) {
-					if (v.getLeft() <= x && x <= v.getRight() && v.getTop() <= y && y <= v.getBottom()) {
-						pressedView = v;
-						break;
-					}
-				}
-			}
-			if (pressedView != null) {
-				pressedView.setPressed(true);
-				view.refreshMap();
-			}
-			return pressedView != null;
-		}
-		boolean pressed = pressedView != null;
-		if (pressed && (event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL)) {
-			pressedView.setPressed(false);
-			if (pressedView.getLeft() <= x && x <= pressedView.getRight() && pressedView.getTop() <= y && y <= pressedView.getBottom()) {
-				pressedView.performClick();
-			}
-			view.refreshMap();
-		}
-		return pressed;
-	}
-
-	
 	public ImageView getBackToLocation() {
 		return backToLocation;
 	}
@@ -420,37 +182,232 @@ public View getProgressBar() {
 		return progressBar;
 	}
 
+	private TextInfoControl createSpeedControl(){
+		final TextInfoControl speedControl = new TextInfoControl(map, R.drawable.box_top, null, 0, paintText, paintSubText) {
+			private float cachedSpeed = 0;
+
+			@Override
+			public boolean updateInfo() {
+				// draw speed
+				if (map.getLastKnownLocation() != null && map.getLastKnownLocation().hasSpeed()) {
+					if (Math.abs(map.getLastKnownLocation().getSpeed() - cachedSpeed) > .3f) {
+						cachedSpeed = map.getLastKnownLocation().getSpeed();
+						String ds = OsmAndFormatter.getFormattedSpeed(cachedSpeed, map);
+						int ls = ds.lastIndexOf(' ');
+						if (ls == -1) {
+							setText(ds, null);
+						} else {
+							setText(ds.substring(0, ls), ds.substring(ls + 1));
+						}
+						return true;
+					}
+				} else if (cachedSpeed != 0) {
+					cachedSpeed = 0;
+					setText(null, null);
+					return true;
+				}
+				return false;
+			}
+		};
+		return speedControl;
+	}
 	
+	private TextInfoControl createTimeControl(){
+		Drawable time = view.getResources().getDrawable(R.drawable.info_time);
+		showArrivalTime = view.getSettings().SHOW_ARRIVAL_TIME_OTHERWISE_EXPECTED_TIME.get();
+		TextInfoControl leftTimeControl = new TextInfoControl(map, R.drawable.box_top, time, 0, paintText, paintSubText) {
+			private long cachedLeftTime = 0;
+			
+			@Override
+			public boolean updateInfo() {
+				int time = 0;
+				if (routeLayer != null && routeLayer.getHelper().isRouterEnabled()) {
+					boolean followingMode = routeLayer.getHelper().isFollowingMode();
+					time = routeLayer.getHelper().getLeftTime();
+					if (time != 0) {
+						if (followingMode && showArrivalTime) {
+							long toFindTime = time * 1000 + System.currentTimeMillis();
+							if (Math.abs(toFindTime - cachedLeftTime) > 30000) {
+								cachedLeftTime = toFindTime;
+								if (DateFormat.is24HourFormat(map)) {
+									setText(DateFormat.format("kk:mm", toFindTime).toString(), null); //$NON-NLS-1$
+								} else {
+									setText(DateFormat.format("k:mm aa", toFindTime).toString(), null); //$NON-NLS-1$
+								}
+								return true;
+							}
+						} else {
+							if (Math.abs(time - cachedLeftTime) > 30) {
+								cachedLeftTime = time;
+								int hours = time / (60 * 60);
+								int minutes = (time / 60) % 60;
+								setText(String.format("%d:%02d", hours, minutes), null); //$NON-NLS-1$
+								return true;
+							}
+						}
+					}
+				}
+				if (time == 0 && cachedLeftTime != 0) {
+					cachedLeftTime = 0;
+					setText(null, null);
+					return true;
+				}
+				return false;
+			};
+		};
+		leftTimeControl.setOnClickListener(new View.OnClickListener() {
+			
+			@Override
+			public void onClick(View v) {
+				showArrivalTime = !showArrivalTime;
+				view.getSettings().SHOW_ARRIVAL_TIME_OTHERWISE_EXPECTED_TIME.set(showArrivalTime);
+				view.refreshMap();
+			}
+			
+		});
+		return leftTimeControl;
+	}
 	
-	private ViewGroup createStatusBar() {
-		final Drawable compass = view.getResources().getDrawable(R.drawable.compass);
-		final int mw = (int) compass.getMinimumWidth() ;
-		final int mh = (int) compass.getMinimumHeight() ;
-		statusBarBackground = view.getResources().getDrawable(R.drawable.box_top).mutate();
-		LinearLayout statusBar = new LinearLayout(view.getContext()) {
+	private TextInfoControl createDistanceControl() {
+		TextInfoControl distanceControl = new TextInfoControl(map, R.drawable.box_top, view.getResources().getDrawable(R.drawable.info_target), 0, paintText,
+				paintSubText) {
+			private float[] calculations = new float[1];
+			private int cachedMeters = 0;
+
 			@Override
-			protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-				super.onLayout(changed, left, top, right, bottom);
-				Rect padding = new Rect();
-				if (statusBarBackground.getPadding(padding)) {
-					statusBarBackground.setBounds(-padding.left + left, top 
-							-padding.top, right + padding.right, bottom + padding.bottom);
+			public boolean updateInfo() {
+				if (map.getPointToNavigate() != null) {
+					int d = 0;
+					if (map.getRoutingHelper().isRouterEnabled()) {
+						d = map.getRoutingHelper().getLeftDistance();
+					}
+					if (d == 0) {
+						Location.distanceBetween(view.getLatitude(), view.getLongitude(), map.getPointToNavigate().getLatitude(), map
+								.getPointToNavigate().getLongitude(), calculations);
+						d = (int) calculations[0];
+					}
+					if (distChanged(cachedMeters, d)) {
+						cachedMeters = d;
+						if (cachedMeters <= 20) {
+							cachedMeters = 0;
+							setText(null, null);
+						} else {
+							String ds = OsmAndFormatter.getFormattedDistance(cachedMeters, map);
+							int ls = ds.lastIndexOf(' ');
+							if (ls == -1) {
+								setText(ds, null);
+							} else {
+								setText(ds.substring(0, ls), ds.substring(ls + 1));
+							}
+						}
+						return true;
+					}
+				} else if (cachedMeters != 0) {
+					cachedMeters = 0;
+					setText(null, null);
+					return true;
 				}
+				return false;
 			}
 		};
+		distanceControl.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				AnimateDraggingMapThread thread = view.getAnimatedDraggingThread();
+				LatLon pointToNavigate = view.getSettings().getPointToNavigate();
+				if (pointToNavigate != null) {
+					int fZoom = view.getZoom() < 15 ? 15 : view.getZoom();
+					thread.startMoving(pointToNavigate.getLatitude(), pointToNavigate.getLongitude(), fZoom, true);
+				}
+			}
+		});
+		return distanceControl;
+	}
+		
+	private MiniMapControl createMiniMapControl() {
+		MiniMapControl miniMapControl = new MiniMapControl(map, view, R.drawable.box_top) {
+			@Override
+			public boolean updateInfo() {
+				boolean visible = false;
+				// TODO
+				if (routeLayer != null && routeLayer.getHelper().isRouterEnabled() /* && routeLayer.getHelper().isFollowingMode() */) {
+					visible = true;
+				}
+				updateVisibility(visible);
+				return super.updateInfo();
+			}
+		};
+		miniMapControl.setVisibility(View.GONE);
+		miniMapControl.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				showMiniMap = false;
+			}
+		});
+		return miniMapControl;
+	}
+	
+	private NextTurnInfoControl createNextInfoControl() {
+		NextTurnInfoControl nextTurnInfo = new NextTurnInfoControl(map, R.drawable.box_top, paintText, paintSubText) {
+			
+			@Override
+			public boolean updateInfo() {
+				boolean visible = false;
+				if (routeLayer != null && routeLayer.getHelper().isRouterEnabled() /* && routeLayer.getHelper().isFollowingMode() */) {
+					int d = routeLayer.getHelper().getDistanceToNextRouteDirection();
+					if (d > 0 && !showMiniMap) {
+						visible = true;
+						RouteDirectionInfo next = routeLayer.getHelper().getNextRouteDirectionInfo();
+						if (next == null) {
+							if (turnType != null) {
+								turnType = null;
+								invalidate();
+							}
+						} else if (!Algoritms.objectEquals(turnType, next.turnType)) {
+							turnType = next.turnType;
+							TurnPathHelper.calcTurnPath(pathForTurn, turnType, pathTransform);
+							if (turnType.getExitOut() > 0) {
+								exitOut = turnType.getExitOut() + ""; //$NON-NLS-1$
+							} else {
+								exitOut = null;
+							}
+							invalidate();
+						}
+						if (distChanged(d, nextTurnDirection)) {
+							invalidate();
+							nextTurnDirection = d;
+						}
+					}
+				}
+				updateVisibility(visible);
+				return true;
+			}
+		};
+		nextTurnInfo.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				showMiniMap = true;
+			}
+		});
+		// initial state
+		nextTurnInfo.setVisibility(View.GONE);
+		return nextTurnInfo;
+	}	
+	
+	private ViewGroup createStatusBar() {
+		LinearLayout statusBar = new LinearLayout(view.getContext());
+		statusBar.setBackgroundDrawable(view.getResources().getDrawable(R.drawable.box_top).mutate());
 		statusBar.setOrientation(LinearLayout.HORIZONTAL);
-		FrameLayout.LayoutParams flp = new FrameLayout.LayoutParams(android.view.ViewGroup.LayoutParams.FILL_PARENT, 
-				android.view.ViewGroup.LayoutParams.WRAP_CONTENT);
-		flp.leftMargin = STATUS_BAR_MARGIN_X;
-		flp.rightMargin = STATUS_BAR_MARGIN_X;
-		flp.gravity = Gravity.TOP;
-		statusBar.setLayoutParams(flp);		
+		
+		// Compass icon
+		final Drawable compass = view.getResources().getDrawable(R.drawable.compass);
+		final int mw = (int) compass.getMinimumWidth() ;
+		final int mh = (int) compass.getMinimumHeight() ;
 		LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
 		compassView = new ImageView(view.getContext()) {
 			@Override
 			protected void onDraw(Canvas canvas) {
 				canvas.save();
-				canvas.translate(getLeft(), getTop());
 				canvas.rotate(view.getRotate(), mw / 2, mh / 2);
 				compass.draw(canvas);
 				canvas.restore();
@@ -465,12 +422,12 @@ public void onClick(View v) {
 		compassView.setImageDrawable(compass);
 		statusBar.addView(compassView, params);
 		
-		// Space
+		// Space (future text)
 		params = new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.MATCH_PARENT, 1);
 		TextView space = new TextView(view.getContext());
 		statusBar.addView(space, params);
 
-		// Map and progress
+		// Map and progress icon
 		Drawable globusDrawable = view.getResources().getDrawable(R.drawable.globus);
 		
 		params = new LinearLayout.LayoutParams(globusDrawable.getMinimumWidth(), globusDrawable.getMinimumHeight());
@@ -498,6 +455,7 @@ public void onClick(View v) {
 		});
 		fl.addView(progressBar, fparams);
 		
+		// Back to location icon 
 		params = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
 		params.leftMargin = (int) (10 * scaleCoefficient);
 		params.rightMargin = (int) (1 * scaleCoefficient);
@@ -510,245 +468,7 @@ public void onClick(View v) {
 			}
 		});
 		statusBar.addView(backToLocation, params);
-		
-		statusBar.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
 		return statusBar;
 	}
-	
-	
-	public abstract class MapInfoControl extends View {
-		int width = 0;
-		int height = 0;
-		boolean pressed = false;
-		Drawable background;
-		
-		public MapInfoControl(int background){
-			super(view.getContext());
-			this.background = view.getResources().getDrawable(background).mutate();
-		}
-		
-		@Override
-		public void setPressed(boolean pressed) {
-			super.setPressed(pressed);
-			background.setState(getDrawableState());
-			Rect padding = new Rect();
-			if (background.getPadding(padding)) {
-				background.setBounds(-padding.left + getLeft(), getTop() 
-						-padding.top, getRight() + padding.right, getBottom() + padding.bottom);
-			}
-		}
-		
-		@Override
-		protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-			super.onLayout(changed, left, top, right, bottom);
-			Rect padding = new Rect();
-			if (background.getPadding(padding)) {
-				background.setBounds(-padding.left + left, top 
-						-padding.top, right + padding.right, bottom + padding.bottom);
-			}
-		}
-		
-		@Override
-		protected void onDraw(Canvas cv) {
-			background.draw(cv);
-		}
-	}
-	
-	public class TextInfoControl extends MapInfoControl {
-		
-		String text;
-		Paint textPaint;
-		String subtext;
-		Paint subtextPaint;
-		int leftMargin = 0;
-		private Drawable imageDrawable;
-		
-		public TextInfoControl(int background, Drawable drawable, int leftMargin, Paint textPaint,
-				Paint subtextPaint) {
-			super(background);
-			this.leftMargin = leftMargin;
-			this.imageDrawable = drawable;
-			this.textPaint = textPaint;
-			this.subtextPaint = subtextPaint;
-		}
-		
-		@Override
-		protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-			super.onLayout(changed, left, top, right, bottom);
-			if(imageDrawable != null) {
-				// Unknown reason to add 3*scaleCoefficient
-				imageDrawable.setBounds(getLeft(), 
-						getTop() + (int) (3*scaleCoefficient), 
-						getLeft() + imageDrawable.getMinimumWidth(), 
-						getTop() +  imageDrawable.getMinimumHeight() + 
-						(int)(3*scaleCoefficient));
-			}
-		}
-		
-		public void setText(String text, String subtext) {
-			this.text = text;
-			this.subtext = subtext;
-			requestLayout();
-		}
-		
-		@Override
-		protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-			// ignore attributes
-			int w = 0;
-			int h = 0;
-			if (text != null) {
-				if(imageDrawable != null) {
-					w += imageDrawable.getMinimumWidth();
-				}
-				w += leftMargin;
-				w += textPaint.measureText(text);
-				if (subtext != null) {
-					w += subtextPaint.measureText(subtext) + 2 * scaleCoefficient;
-				}
-				
-				h = (int) (5 * scaleCoefficient + Math.max(textPaint.getTextSize(), subtextPaint.getTextSize()));
-				if(imageDrawable != null) {
-					h = Math.max(h, (int)(imageDrawable.getMinimumHeight()));
-				}
-			}
-			setMeasuredDimension(w, h);
-		}
-		
-		@Override
-		protected void onDraw(Canvas cv) {
-			super.onDraw(cv);
-			if (isVisible()) {
-				int margin = 0;
-				if(imageDrawable != null) {
-					imageDrawable.draw(cv);
-					margin = imageDrawable.getBounds().width();
-				}
-				margin += leftMargin;
-				cv.drawText(text, margin + getLeft(), getBottom() - 3 * scaleCoefficient, textPaint);
-				if (subtext != null) {
-					cv.drawText(subtext, getLeft() + margin + 2 * scaleCoefficient + textPaint.measureText(text), getBottom()
-							- 3 * scaleCoefficient, subtextPaint);
-				}
-			}
-		}
-		
-		public boolean isVisible() {
-			return text != null && text.length() > 0;
-		}
-	}
-	
-	public class NextTurnInfoControl extends MapInfoControl {
-		
-		private final float scaleMiniRoute = 0.15f;
-		private final float width = 96 * scaleCoefficient;
-		private final float height = 96 * scaleCoefficient;
-		
-		private final float centerMiniRouteY = 3 * height /4;
-		private final float centerMiniRouteX = width / 2;
-		
-		private Path pathForTurn = new Path();
-		private Matrix pathTransform = new Matrix();
-		
-		private TurnType cachedTurnType = null;
-		private String cachedExitOut = null;
-		private final Paint textPaint;
-		private final Paint subtextPaint;
-
-		public NextTurnInfoControl(int background, Paint textPaint, Paint subtextPaint) {
-			super(background);
-			this.textPaint = textPaint;
-			this.subtextPaint = subtextPaint;
-		}
-		
-		public boolean isVisible() {
-			// TODO
-			if (routeLayer != null && routeLayer.getHelper().isRouterEnabled() /*&& routeLayer.getHelper().isFollowingMode()*/) {
-				int d = routeLayer.getHelper().getDistanceToNextRouteDirection();
-				if (d > 0 || (showMiniMap && !routeLayer.getPath().isEmpty())) {
-					return true;
-				}
-			}
-			return false;
-		}
-		
-		@Override
-		protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-			super.onLayout(changed, left, top, right, bottom);
-			pathTransform = new Matrix();
-			pathTransform.postScale(scaleCoefficient, scaleCoefficient);
-			pathTransform.postTranslate(left, top);
-		}
-		
-		@Override
-		protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-			super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-			if(!isVisible()) {
-				setMeasuredDimension(0, 0);
-			} else if(showMiniMap){
-				setMeasuredDimension((int) width, (int) height);
-			} else {
-				int h = (int) (5 * scaleCoefficient + Math.max(textPaint.getTextSize(), subtextPaint.getTextSize()));
-				setMeasuredDimension((int) width, (int) height + h);
-			}
-		}
-		
-		
-		@Override
-		protected void onDraw(Canvas canvas) {
-			super.onDraw(canvas);
-			// TODO
-			if (routeLayer != null /*&& routeLayer.getHelper().isFollowingMode()*/) {
-				int d = routeLayer.getHelper().getDistanceToNextRouteDirection();
-				if (showMiniMap || d == 0) {
-					if (!routeLayer.getPath().isEmpty()) {
-						canvas.save();
-						canvas.translate(centerMiniRouteX - view.getCenterPointX(), centerMiniRouteY - view.getCenterPointY());
-						canvas.scale(scaleMiniRoute, scaleMiniRoute, view.getCenterPointX(), view.getCenterPointY());
-						canvas.rotate(view.getRotate(), view.getCenterPointX(), view.getCenterPointY());
-						canvas.drawCircle(view.getCenterPointX(), view.getCenterPointY(), 3 / scaleMiniRoute, fillBlack);
-						canvas.drawPath(routeLayer.getPath(), paintMiniRoute);
-						canvas.restore();
-					}
-				} else {
-					RouteDirectionInfo next = routeLayer.getHelper().getNextRouteDirectionInfo();
-					if (next != null) {
-						if (!Algoritms.objectEquals(cachedTurnType, next.turnType)) {
-							cachedTurnType = next.turnType;
-							TurnPathHelper.calcTurnPath(pathForTurn, cachedTurnType, pathTransform);
-							if (cachedTurnType.getExitOut() > 0) {
-								cachedExitOut = cachedTurnType.getExitOut() + ""; //$NON-NLS-1$
-							} else {
-								cachedExitOut = null;
-							}
-						}
-						canvas.drawPath(pathForTurn, paintRouteDirection);
-						canvas.drawPath(pathForTurn, paintBlack);
-						// TODO test
-						if (cachedExitOut != null) {
-							canvas.drawText(cachedExitOut, (getLeft() + getRight()) / 2 - 6 * scaleCoefficient, (getTop() + getBottom())
-									/ 2 - 9 * scaleCoefficient, paintBlack);
-						}
-						
-						String text = OsmAndFormatter.getFormattedDistance(cachedMeters, map);
-						String subtext = null;
-						int ls = text.lastIndexOf(' ');
-						if (ls != -1) {
-							subtext = text.substring(ls + 1);
-							text = text.substring(0, ls);
-						}
-						// TODO align center
-						int margin = (int) (10 * scaleCoefficient);
-						canvas.drawText(text, margin + getLeft(), getBottom() - 3 * scaleCoefficient, textPaint);
-						if (subtext != null) {
-							canvas.drawText(subtext, getLeft() + margin + 2 * scaleCoefficient + textPaint.measureText(text), getBottom()
-									- 3 * scaleCoefficient, subtextPaint);
-						}
-					}
-				}
-			}
-		}
-	}
-
-
 
 }
diff --git a/OsmAnd/src/net/osmand/plus/views/MapStackControl.java b/OsmAnd/src/net/osmand/plus/views/MapStackControl.java
new file mode 100644
index 00000000000..f1d3058d35f
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/MapStackControl.java
@@ -0,0 +1,154 @@
+package net.osmand.plus.views;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.osmand.plus.R;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+public class MapStackControl extends ViewGroup {
+	List<MapInfoControl> stackViews = new ArrayList<MapInfoControl>();
+	List<MapInfoControl> collapsedViews = new ArrayList<MapInfoControl>();
+	ImageView expandView;
+	private boolean isCollapsed = true;
+	private boolean isCollapsible = true;
+
+	public MapStackControl(Context context) {
+		super(context);
+		final Bitmap arrowDown = BitmapFactory.decodeResource(context.getResources(), R.drawable.arrow_down);
+		final Bitmap arrowUp = BitmapFactory.decodeResource(context.getResources(), R.drawable.arrow_up);
+		final Paint paintImg = new Paint();
+		paintImg.setAntiAlias(true);
+		setChildrenDrawingOrderEnabled(true);
+		expandView = new ImageView(context) {
+			@Override
+			protected void onDraw(Canvas canvas) {
+				super.onDraw(canvas);
+				int cx = (getLeft() + getRight()) / 2 - getLeft();
+				int t = (int) (getBottom() - getTop() - 12 * MapInfoLayer.scaleCoefficient);
+
+				if (!isCollapsed) {
+					canvas.drawBitmap(arrowUp, cx - arrowUp.getWidth() / 2, t - arrowUp.getHeight(), paintImg);
+				} else {
+					canvas.drawBitmap(arrowDown, cx - arrowDown.getWidth() / 2, t - arrowUp.getHeight(), paintImg);
+				}
+			}
+		};
+		expandView.setImageDrawable(context.getResources().getDrawable(R.drawable.box_expand).mutate());
+		expandView.setOnClickListener(new View.OnClickListener() {
+			@Override
+			public void onClick(View v) {
+				isCollapsed = !isCollapsed;
+				if (!isCollapsed) {
+					for (MapInfoControl l : collapsedViews) {
+						l.updateInfo();
+					}
+				}
+				MapStackControl.this.requestLayout();
+
+			}
+		});
+		MapStackControl.this.addView(expandView);
+	}
+
+	public void updateInfo() {
+		for (MapInfoControl v : stackViews) {
+			v.updateInfo();
+		}
+		if (!isCollapsed) {
+			for (MapInfoControl v : collapsedViews) {
+				v.updateInfo();
+			}
+		}
+	}
+
+	@Override
+	protected int getChildDrawingOrder(int childCount, int i) {
+		// start from expand view
+		if (i == 0) {
+			return 0;
+		}
+		return childCount - i;
+	}
+
+	public void addStackView(MapInfoControl v) {
+		stackViews.add(v);
+		MapStackControl.this.addView(v);
+	}
+
+	public void addCollapsedView(MapInfoControl v) {
+		collapsedViews.add(v);
+		MapStackControl.this.addView(v);
+	}
+
+	public boolean isCollapsed() {
+		return isCollapsed;
+	}
+
+	public boolean isCollapsible() {
+		return isCollapsible;
+	}
+
+	@Override
+	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+		int w = 0;
+		int h = 0;
+		if (stackViews != null) {
+			for (View c : stackViews) {
+				c.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
+				w = Math.max(w, c.getMeasuredWidth());
+				h += c.getMeasuredHeight();
+			}
+			isCollapsible = false;
+			for (View c : collapsedViews) {
+				c.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);
+				if (c.getMeasuredHeight() > 0) {
+					w = Math.max(w, c.getMeasuredWidth());
+					h += c.getMeasuredHeight();
+					isCollapsible = true;
+				}
+			}
+			if (isCollapsible) {
+				h += expandView.getDrawable().getMinimumHeight();
+			}
+		}
+		setMeasuredDimension(w, h);
+	}
+
+	@Override
+	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+		int y = 0;
+		int cw = right - left;
+		for (View c : stackViews) {
+			c.layout(0, y, cw, y + c.getMeasuredHeight());
+			y += c.getMeasuredHeight();
+		}
+
+		for (View c : collapsedViews) {
+			if (!isCollapsed) {
+				c.setVisibility(VISIBLE);
+				c.layout(0, y, cw, y + c.getMeasuredHeight());
+				y += c.getMeasuredHeight();
+			} else {
+				c.setVisibility(GONE);
+			}
+		}
+
+		if (isCollapsible) {
+			expandView.setVisibility(VISIBLE);
+			int w = expandView.getDrawable().getMinimumWidth();
+			int h = expandView.getDrawable().getMinimumHeight();
+			expandView.layout((cw - w) / 2, y, (cw + w) / 2, y + h);
+		} else {
+			expandView.setVisibility(GONE);
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/MiniMapControl.java b/OsmAnd/src/net/osmand/plus/views/MiniMapControl.java
new file mode 100644
index 00000000000..8839a4ec735
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/MiniMapControl.java
@@ -0,0 +1,68 @@
+package net.osmand.plus.views;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Cap;
+import android.graphics.Paint.Join;
+import android.graphics.Paint.Style;
+import android.graphics.Path;
+
+public class MiniMapControl extends MapInfoControl {
+	private float scaleCoefficient = MapInfoLayer.scaleCoefficient;
+	private final float scaleMiniRoute = 0.15f;
+	private final float width = 96 * scaleCoefficient;
+	private final float height = 96 * scaleCoefficient;
+	private final float centerMiniRouteY = 3 * height / 4;
+	private final float centerMiniRouteX = width / 2;
+
+	private final OsmandMapTileView view;
+	private Paint paintMiniRoute;
+	private Paint fillBlack;
+	protected Path miniMapPath = null;
+
+	public MiniMapControl(Context ctx, OsmandMapTileView view, int background) {
+		super(ctx, background);
+		this.view = view;
+
+		fillBlack = new Paint();
+		fillBlack.setStyle(Style.FILL_AND_STROKE);
+		fillBlack.setColor(Color.BLACK);
+		fillBlack.setAntiAlias(true);
+
+		paintMiniRoute = new Paint();
+		paintMiniRoute.setStyle(Style.STROKE);
+		paintMiniRoute.setStrokeWidth(35 * scaleCoefficient);
+		paintMiniRoute.setColor(Color.BLUE);
+		paintMiniRoute.setStrokeJoin(Join.ROUND);
+		paintMiniRoute.setStrokeCap(Cap.ROUND);
+		paintMiniRoute.setAntiAlias(true);
+
+	}
+
+	@Override
+	public boolean updateInfo() {
+		invalidate();
+		return true;
+	}
+
+	@Override
+	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+		setMeasuredDimension((int) width, (int) height);
+	}
+
+	@Override
+	protected void onDraw(Canvas canvas) {
+		super.onDraw(canvas);
+		if (miniMapPath != null && !miniMapPath.isEmpty()) {
+			canvas.save();
+			canvas.translate(centerMiniRouteX - view.getCenterPointX(), centerMiniRouteY - view.getCenterPointY());
+			canvas.scale(scaleMiniRoute, scaleMiniRoute, view.getCenterPointX(), view.getCenterPointY());
+			canvas.rotate(view.getRotate(), view.getCenterPointX(), view.getCenterPointY());
+			canvas.drawCircle(view.getCenterPointX(), view.getCenterPointY(), 3 / scaleMiniRoute, fillBlack);
+			canvas.drawPath(miniMapPath, paintMiniRoute);
+			canvas.restore();
+		}
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/NextTurnInfoControl.java b/OsmAnd/src/net/osmand/plus/views/NextTurnInfoControl.java
new file mode 100644
index 00000000000..2809bcb9718
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/NextTurnInfoControl.java
@@ -0,0 +1,94 @@
+package net.osmand.plus.views;
+
+import net.osmand.OsmAndFormatter;
+import net.osmand.plus.routing.RoutingHelper.TurnType;
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Matrix;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.Path;
+
+public class NextTurnInfoControl extends MapInfoControl {
+
+	private float scaleCoefficient = MapInfoLayer.scaleCoefficient;
+	private final float width = 96 * scaleCoefficient;
+	private final float height = 96 * scaleCoefficient;
+
+	protected Path pathForTurn = new Path();
+
+	protected TurnType turnType = null;
+	protected String exitOut = null;
+	protected int nextTurnDirection = 0;
+
+	private final Paint textPaint;
+	private final Paint subtextPaint;
+	private Paint paintBlack;
+	private Paint paintRouteDirection;
+
+	public NextTurnInfoControl(Context ctx, int background, Paint textPaint, Paint subtextPaint) {
+		super(ctx, background);
+		this.textPaint = textPaint;
+		this.subtextPaint = subtextPaint;
+
+		paintBlack = new Paint();
+		paintBlack.setStyle(Style.STROKE);
+		paintBlack.setColor(Color.BLACK);
+		paintBlack.setAntiAlias(true);
+
+		paintRouteDirection = new Paint();
+		paintRouteDirection.setStyle(Style.FILL_AND_STROKE);
+		paintRouteDirection.setColor(Color.rgb(100, 0, 255));
+		paintRouteDirection.setAntiAlias(true);
+	}
+
+	protected Matrix pathTransform = new Matrix();
+
+	@Override
+	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+		super.onLayout(changed, left, top, right, bottom);
+		pathTransform = new Matrix();
+		pathTransform.postScale(scaleCoefficient, scaleCoefficient);
+		pathTransform.postTranslate(left, top);
+	}
+
+	@Override
+	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+		int h = (int) (5 * scaleCoefficient + Math.max(textPaint.getTextSize(), subtextPaint.getTextSize()));
+		setMeasuredDimension((int) width, (int) height + h);
+	}
+
+	@Override
+	protected void onDraw(Canvas canvas) {
+		super.onDraw(canvas);
+		if (pathForTurn != null) {
+			canvas.drawPath(pathForTurn, paintRouteDirection);
+			canvas.drawPath(pathForTurn, paintBlack);
+			// TODO test
+			if (exitOut != null) {
+				canvas.drawText(exitOut, (getLeft() + getRight()) / 2 - 6 * scaleCoefficient, (getTop() + getBottom()) / 2 - 9
+						* scaleCoefficient, paintBlack);
+			}
+			String text = OsmAndFormatter.getFormattedDistance(nextTurnDirection, getContext());
+			String subtext = null;
+			int ls = text.lastIndexOf(' ');
+			if (ls != -1) {
+				subtext = text.substring(ls + 1);
+				text = text.substring(0, ls);
+			}
+			// TODO align center
+			int margin = (int) (10 * scaleCoefficient);
+			canvas.drawText(text, margin + getLeft(), getBottom() - 3 * scaleCoefficient, textPaint);
+			if (subtext != null) {
+				canvas.drawText(subtext, getLeft() + margin + 2 * scaleCoefficient + textPaint.measureText(text), getBottom() - 3
+						* scaleCoefficient, subtextPaint);
+			}
+		}
+	}
+
+	@Override
+	public boolean updateInfo() {
+		return false;
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/TextInfoControl.java b/OsmAnd/src/net/osmand/plus/views/TextInfoControl.java
new file mode 100644
index 00000000000..f19f8b60aee
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/TextInfoControl.java
@@ -0,0 +1,96 @@
+package net.osmand.plus.views;
+
+import android.content.Context;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+import android.view.View;
+
+public class TextInfoControl extends MapInfoControl {
+		
+		String text;
+		Paint textPaint;
+		String subtext;
+		Paint subtextPaint;
+		int leftMargin = 0;
+		private Drawable imageDrawable;
+		private float scaleCoefficient;
+		
+		public TextInfoControl(Context ctx, int background, Drawable drawable, int leftMargin, Paint textPaint,
+				Paint subtextPaint) {
+			super(ctx, background);
+			scaleCoefficient = MapInfoLayer.scaleCoefficient;
+			this.leftMargin = leftMargin;
+			this.imageDrawable = drawable;
+			this.textPaint = textPaint;
+			this.subtextPaint = subtextPaint;
+		}
+		
+		@Override
+		protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
+			super.onLayout(changed, left, top, right, bottom);
+			if (imageDrawable != null) {
+				// Unknown reason to add 3*scaleCoefficient
+				imageDrawable.setBounds(0, (int) (3 *  scaleCoefficient), imageDrawable.getMinimumWidth(), imageDrawable.getMinimumHeight()
+						+ (int) (3 * scaleCoefficient));
+			}
+		}
+		
+		public void setText(String text, String subtext) {
+			this.text = text;
+			this.subtext = subtext;
+			updateVisibility(text == null);
+			requestLayout();
+			invalidate();
+		}
+
+		@Override
+		protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+			// ignore attributes
+			int w = 0;
+			int h = 0;
+			if (text != null) {
+				if(imageDrawable != null) {
+					w += imageDrawable.getMinimumWidth();
+				}
+				w += leftMargin;
+				w += textPaint.measureText(text);
+				if (subtext != null) {
+					w += subtextPaint.measureText(subtext) + 2 * scaleCoefficient;
+				}
+				
+				h = (int) (5 * scaleCoefficient + Math.max(textPaint.getTextSize(), subtextPaint.getTextSize()));
+				if(imageDrawable != null) {
+					h = Math.max(h, (int)(imageDrawable.getMinimumHeight()));
+				}
+			}
+			setMeasuredDimension(w, h);
+		}
+		
+		@Override
+		protected void onDraw(Canvas cv) {
+			super.onDraw(cv);
+			if (isVisible()) {
+				int margin = 0;
+				if(imageDrawable != null) {
+					imageDrawable.draw(cv);
+					margin = imageDrawable.getBounds().width();
+				}
+				margin += leftMargin;
+				cv.drawText(text, margin, getBottom() - getTop() - 3 * scaleCoefficient, textPaint);
+				if (subtext != null) {
+					cv.drawText(subtext, margin + 2 * scaleCoefficient + textPaint.measureText(text), 
+							getBottom() - getTop() - 3 * scaleCoefficient, subtextPaint);
+				}
+			}
+		}
+		
+		public boolean isVisible() {
+			return text != null && text.length() > 0;
+		}
+
+		@Override
+		public boolean updateInfo() {
+			return false;
+		}
+	}
\ No newline at end of file
