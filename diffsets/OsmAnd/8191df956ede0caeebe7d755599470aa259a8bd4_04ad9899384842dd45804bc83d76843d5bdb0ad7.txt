diff --git a/OsmAnd/src/net/osmand/plus/activities/MapActivity.java b/OsmAnd/src/net/osmand/plus/activities/MapActivity.java
index 01625f11a27..e98b7075a04 100644
--- a/OsmAnd/src/net/osmand/plus/activities/MapActivity.java
+++ b/OsmAnd/src/net/osmand/plus/activities/MapActivity.java
@@ -357,7 +357,7 @@ protected GPXFile doInBackground(String... params) {
 
 						@Override
 						protected void onPostExecute(GPXFile result) {
-							final GPXRouteParams gpxRoute = result == null ? null : new GPXRouteParams(result, false);
+							final GPXRouteParams gpxRoute = result == null ? null : new GPXRouteParams(result, false, settings);
 							LatLon endPoint = pointToNavigate != null ? pointToNavigate : gpxRoute.getLastPoint();
 							Location startPoint = gpxRoute == null ? null : gpxRoute.getStartPointForRoute();
 							if (endPoint == null) {
diff --git a/OsmAnd/src/net/osmand/plus/activities/MapActivityActions.java b/OsmAnd/src/net/osmand/plus/activities/MapActivityActions.java
index d3591ff4cd9..153211d5043 100644
--- a/OsmAnd/src/net/osmand/plus/activities/MapActivityActions.java
+++ b/OsmAnd/src/net/osmand/plus/activities/MapActivityActions.java
@@ -549,7 +549,7 @@ public void onClick(DialogInterface dialog, int which) {
 						boolean reverse = props[0];
 						boolean passWholeWay = props[2];
 						boolean useDestination = props[1];
-						GPXRouteParams gpxRoute = new GPXRouteParams(result, reverse);
+						GPXRouteParams gpxRoute = new GPXRouteParams(result, reverse, settings);
 						
 						Location loc = mapActivity.getLastKnownLocation();
 						if(passWholeWay && loc != null){
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
index 6826120723e..e80b55b5f7b 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
@@ -30,6 +30,7 @@
 import net.osmand.osm.LatLon;
 import net.osmand.osm.MapUtils;
 import net.osmand.plus.OsmandApplication;
+import net.osmand.plus.OsmandSettings;
 import net.osmand.plus.R;
 import net.osmand.plus.activities.ApplicationMode;
 import net.osmand.plus.routing.RoutingHelper.RouteDirectionInfo;
@@ -75,8 +76,8 @@ public static class GPXRouteParams {
 		List<Location> points = new ArrayList<Location>();
 		List<RouteDirectionInfo> directions;
 	
-		public GPXRouteParams(GPXFile file, boolean reverse){
-			prepareEverything(file, reverse);
+		public GPXRouteParams(GPXFile file, boolean reverse, OsmandSettings settings){
+			prepareEverything(file, reverse, settings.LEFT_SIDE_NAVIGATION.get());
 		}
 		
 		public void setStartPoint(Location startPoint) {
@@ -100,9 +101,9 @@ public LatLon getLastPoint() {
 			return null;
 		}
 		
-		private void prepareEverything(GPXFile file, boolean reverse){
+		private void prepareEverything(GPXFile file, boolean reverse, boolean leftSide){
 			if(file.isCloudmadeRouteFile() || OSMAND_ROUTER.equals(file.author)){
-				directions =  parseCloudmadeRoute(points, file, OSMAND_ROUTER.equals(file.author));
+				directions =  parseCloudmadeRoute(points, file, OSMAND_ROUTER.equals(file.author), leftSide);
 				if(reverse){
 					// clear directions all turns should be recalculated
 					directions = null;
@@ -184,7 +185,7 @@ private void prepareResult(Location start, LatLon end) {
 							i.routePointOffset++;
 						}
 						RouteDirectionInfo info = new RouteDirectionInfo();
-						info.turnType = TurnType.valueOf(TurnType.C);
+						info.turnType = TurnType.valueOf(TurnType.C, false);
 						info.routePointOffset = 0;
 						info.descriptionRoute = "" ;//getString(ctx, R.string.route_head); //$NON-NLS-1$
 						directions.add(0, info);
@@ -253,7 +254,7 @@ public String getErrorMessage(){
 	}
 
 	public RouteCalculationResult calculateRouteImpl(Location start, LatLon end, ApplicationMode mode, RouteService type, Context ctx,
-			GPXRouteParams gpxRoute, boolean fast){
+			GPXRouteParams gpxRoute, boolean fast, boolean leftSide){
 		long time = System.currentTimeMillis();
 		if (start != null && end != null) {
 			if(log.isInfoEnabled()){
@@ -263,13 +264,13 @@ public RouteCalculationResult calculateRouteImpl(Location start, LatLon end, App
 				RouteCalculationResult res;
 				if(gpxRoute != null && !gpxRoute.points.isEmpty()){
 					res = calculateGpxRoute(start, end, gpxRoute);
-					addMissingTurnsToRoute(res, start, end, mode, ctx);
+					addMissingTurnsToRoute(res, start, end, mode, ctx, leftSide);
 				} else if (type == RouteService.YOURS) {
 					res = findYOURSRoute(start, end, mode, fast);
-					addMissingTurnsToRoute(res, start, end, mode, ctx);
+					addMissingTurnsToRoute(res, start, end, mode, ctx, leftSide);
 				} else if (type == RouteService.ORS) {
 					res = findORSRoute(start, end, mode, fast);
-					addMissingTurnsToRoute(res, start, end, mode, ctx);
+					addMissingTurnsToRoute(res, start, end, mode, ctx, leftSide);
 //				} else if (type == RouteService.OSMAND) {
 //					res = findVectorMapsRoute(start, end, mode, fast, (OsmandApplication)ctx.getApplicationContext());
 //					addMissingTurnsToRoute(res, start, end, mode, ctx);
@@ -277,9 +278,9 @@ public RouteCalculationResult calculateRouteImpl(Location start, LatLon end, App
 					if (type == RouteService.OSMAND) {
 						AccessibleToast.makeText(ctx, R.string.offline_navigation_not_available, Toast.LENGTH_LONG).show();
 					}
-					res = findCloudMadeRoute(start, end, mode, ctx, fast);
+					res = findCloudMadeRoute(start, end, mode, ctx, fast, leftSide);
 					// for test purpose
-					addMissingTurnsToRoute(res, start, end, mode, ctx);
+					addMissingTurnsToRoute(res, start, end, mode, ctx, leftSide);
 				}
 				if(log.isInfoEnabled() && res.locations != null){
 					log.info("Finding route contained " + res.locations.size() + " points for " + (System.currentTimeMillis() - time) + " ms"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
@@ -358,7 +359,8 @@ protected String getString(Context ctx, int resId){
 		return ctx.getString(resId);
 	}
 	
-	protected void addMissingTurnsToRoute(RouteCalculationResult res, Location start, LatLon end, ApplicationMode mode, Context ctx){
+	protected void addMissingTurnsToRoute(RouteCalculationResult res, Location start, LatLon end, ApplicationMode mode, Context ctx,
+			boolean leftSide){
 		if(!res.isCalculated()){
 			return;
 		}
@@ -383,7 +385,8 @@ protected void addMissingTurnsToRoute(RouteCalculationResult res, Location start
 		int previousLocation = 0;
 		int prevBearingLocation = 0;
 		RouteDirectionInfo previousInfo = new RouteDirectionInfo();
-		previousInfo.turnType = TurnType.valueOf(TurnType.C);
+		
+		previousInfo.turnType = TurnType.valueOf(TurnType.C, leftSide);
 		previousInfo.routePointOffset = 0;
 		previousInfo.descriptionRoute = getString(ctx, R.string.route_head);
 		directions.add(previousInfo);
@@ -436,26 +439,26 @@ protected void addMissingTurnsToRoute(RouteCalculationResult res, Location start
 			if(delta > 45 && delta < 315){
 				
 				if(delta < 60){
-					type = TurnType.valueOf(TurnType.TSLL);
+					type = TurnType.valueOf(TurnType.TSLL, leftSide);
 					description = getString(ctx, R.string.route_tsll);
 				} else if(delta < 120){
-					type = TurnType.valueOf(TurnType.TL);
+					type = TurnType.valueOf(TurnType.TL, leftSide);
 					description = getString(ctx, R.string.route_tl);
 				} else if(delta < 150){
-					type = TurnType.valueOf(TurnType.TSHL);
+					type = TurnType.valueOf(TurnType.TSHL, leftSide);
 					description = getString(ctx, R.string.route_tshl);
 				} else if(delta < 210){
-					type = TurnType.valueOf(TurnType.TU);
+					type = TurnType.valueOf(TurnType.TU, leftSide);
 					description = getString(ctx, R.string.route_tu);
 				} else if(delta < 240){
 					description = getString(ctx, R.string.route_tshr);
-					type = TurnType.valueOf(TurnType.TSHR);
+					type = TurnType.valueOf(TurnType.TSHR, leftSide);
 				} else if(delta < 300){
 					description = getString(ctx, R.string.route_tr);
-					type = TurnType.valueOf(TurnType.TR);
+					type = TurnType.valueOf(TurnType.TR, leftSide);
 				} else {
 					description = getString(ctx, R.string.route_tslr);
-					type = TurnType.valueOf(TurnType.TSLR);
+					type = TurnType.valueOf(TurnType.TSLR, leftSide);
 				}
 				
 				// calculate for previousRoute 
@@ -486,7 +489,7 @@ protected void addMissingTurnsToRoute(RouteCalculationResult res, Location start
 			info.expectedTime = 0;
 			info.distance = 0;
 			info.descriptionRoute = ""; //$NON-NLS-1$
-			info.turnType = TurnType.valueOf(TurnType.C);
+			info.turnType = TurnType.valueOf(TurnType.C, leftSide);
 			info.routePointOffset = locations.size() - 1;
 			directions.add(info);
 		}
@@ -665,7 +668,7 @@ protected RouteCalculationResult findVectorMapsRoute(Location start, LatLon end,
 	}
 	
 	
-	protected RouteCalculationResult findCloudMadeRoute(Location start, LatLon end, ApplicationMode mode, Context ctx, boolean fast)
+	protected RouteCalculationResult findCloudMadeRoute(Location start, LatLon end, ApplicationMode mode, Context ctx, boolean fast, boolean leftSide)
 			throws MalformedURLException, IOException, ParserConfigurationException, FactoryConfigurationError, SAXException {
 		List<Location> res = new ArrayList<Location>();
 		List<RouteDirectionInfo> directions = null;
@@ -693,12 +696,13 @@ protected RouteCalculationResult findCloudMadeRoute(Location start, LatLon end,
 		URL url = new URL(uri.toString());
 		URLConnection connection = url.openConnection();
 		GPXFile gpxFile = GPXUtilities.loadGPXFile(ctx, connection.getInputStream(), false);
-		directions = parseCloudmadeRoute(res, gpxFile, false);
+		directions = parseCloudmadeRoute(res, gpxFile, false, leftSide);
 
 		return new RouteCalculationResult(res, directions, start, end, null);
 	}
 
-	private static List<RouteDirectionInfo> parseCloudmadeRoute(List<Location> res, GPXFile gpxFile, boolean osmandRouter) {
+	private static List<RouteDirectionInfo> parseCloudmadeRoute(List<Location> res, GPXFile gpxFile, boolean osmandRouter,
+			boolean leftSide) {
 		List<RouteDirectionInfo> directions = null;
 		if (!osmandRouter) {
 			for (WptPt pt : gpxFile.points) {
@@ -731,9 +735,9 @@ private static List<RouteDirectionInfo> parseCloudmadeRoute(List<Location> res,
 					}
 					String stype = item.getExtensionsToRead().get("turn"); //$NON-NLS-1$
 					if (stype != null) {
-						dirInfo.turnType = TurnType.valueOf(stype.toUpperCase());
+						dirInfo.turnType = TurnType.valueOf(stype.toUpperCase(), leftSide);
 					} else {
-						dirInfo.turnType = TurnType.valueOf(TurnType.C);
+						dirInfo.turnType = TurnType.valueOf(TurnType.C, leftSide);
 					}
 					String sturn = item.getExtensionsToRead().get("turn-angle"); //$NON-NLS-1$
 					if (sturn != null) {
diff --git a/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java b/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
index 0dab5b4f304..925e5be2373 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
@@ -602,7 +602,9 @@ private void recalculateRouteInBackground(final Location start, final LatLon end
 					currentRunningJob = new Thread(new Runnable() {
 						@Override
 						public void run() {
-							RouteCalculationResult res = provider.calculateRouteImpl(start, end, mode, service, context, gpxRoute, fastRouteMode);
+							boolean leftSide = settings.LEFT_SIDE_NAVIGATION.get();
+							RouteCalculationResult res = provider.calculateRouteImpl(start, end, mode, service, context, gpxRoute, fastRouteMode, 
+									leftSide);
 							synchronized (RoutingHelper.this) {
 								if (res.isCalculated()) {
 									setNewRoute(res, start);
@@ -720,31 +722,36 @@ public static class TurnType {
 		public static String[] predefinedTypes = new String[] {C, KL, KR, TL, TSLL, TSHL, TR, TSLR, TSHR, TU, TRU}; 
 		
 		
-		public static TurnType valueOf(String s){
+		public static TurnType valueOf(String s, boolean leftSide){
 			for(String v : predefinedTypes){
 				if(v.equals(s)){
+					if(leftSide && TU.equals(v)){
+						v = TRU;
+					}
 					return new TurnType(v);
 				}
 			}
 			if (s != null && s.startsWith("EXIT")) { //$NON-NLS-1$
-				return getExitTurn(Integer.parseInt(s.substring(4)), 0);
+				return getExitTurn(Integer.parseInt(s.substring(4)), 0, leftSide);
 			}
 			return null;
 		}
 		
 		private final String value;
 		private int exitOut;
+		private boolean isLeftSide;
 		// calculated CW head rotation if previous direction to NORTH
 		private float turnAngle;
 		
-		public static TurnType getExitTurn(int out, float angle){
-			TurnType r = new TurnType("EXIT", out); //$NON-NLS-1$
+		private static TurnType getExitTurn(int out, float angle, boolean leftSide){
+			TurnType r = new TurnType("EXIT", out, leftSide); //$NON-NLS-1$
 			r.setTurnAngle(angle);
 			return r;
 		}
-		private TurnType(String value, int exitOut){
+		private TurnType(String value, int exitOut, boolean leftSide){
 			this.value = value;
 			this.exitOut = exitOut;
+			this.isLeftSide = leftSide;
 		}
 
 		// calculated CW head rotation if previous direction to NORTH
@@ -752,6 +759,10 @@ public float getTurnAngle() {
 			return turnAngle;
 		}
 		
+		public boolean isLeftSide(){
+			return isLeftSide;
+		}
+		
 
 		public void setTurnAngle(float turnAngle) {
 			this.turnAngle = turnAngle;
diff --git a/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java b/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java
index 2c2fea958e7..a9ace7cd90f 100644
--- a/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java
+++ b/OsmAnd/src/net/osmand/plus/views/MapInfoLayer.java
@@ -522,7 +522,7 @@ public boolean updateInfo() {
 					if (routingHelper.makeUturnWhenPossible() == true) {
 						if (!showMiniMap) {
 							visible = true;
-							turnType = TurnType.valueOf(TurnType.TU);
+							turnType = TurnType.valueOf(TurnType.TU, view.getSettings().LEFT_SIDE_NAVIGATION.get());
 							TurnPathHelper.calcTurnPath(pathForTurn, turnType, pathTransform);
 							invalidate();
 						}
