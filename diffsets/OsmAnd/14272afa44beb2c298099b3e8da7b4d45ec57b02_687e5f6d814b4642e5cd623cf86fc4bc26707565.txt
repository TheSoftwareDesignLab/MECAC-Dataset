diff --git a/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java b/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java
index ab98990d368..aed7a2f3157 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/geometry/GeometryWay.java
@@ -4,15 +4,10 @@
 import android.graphics.Path;
 import android.util.Pair;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
 import net.osmand.Location;
 import net.osmand.data.RotatedTileBox;
 import net.osmand.util.MapAlgorithms;
 import net.osmand.util.MapUtils;
-import net.osmand.plus.views.layers.geometry.MultiProfileGeometryWay.GeometryMultiProfileWayStyle;
-
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -20,6 +15,8 @@
 import java.util.Map;
 import java.util.TreeMap;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 import gnu.trove.list.array.TByteArrayList;
 
 public abstract class GeometryWay<T extends GeometryWayContext, D extends GeometryWayDrawer<T>> {
@@ -176,7 +173,7 @@ public void drawSegments(RotatedTileBox tb, Canvas canvas, double topLatitude, d
 			}
 			double lat = locationProvider.getLatitude(i);
 			double lon = locationProvider.getLongitude(i);
-			if (shouldAddLocation(tb, leftLongitude, rightLongitude, bottomLatitude, topLatitude,
+			if (shouldAddLocation(simplification, leftLongitude, rightLongitude, bottomLatitude, topLatitude,
 					locationProvider, i)) {
 				double dist = previous == -1 ? 0 : odistances.get(i);
 				if (!previousVisible) {
@@ -210,7 +207,7 @@ public void drawSegments(RotatedTileBox tb, Canvas canvas, double topLatitude, d
 		drawRouteSegment(tb, canvas, tx, ty, angles, distances, 0, styles);
 	}
 
-	protected boolean shouldAddLocation(RotatedTileBox tileBox, double leftLon, double rightLon, double bottomLat,
+	protected boolean shouldAddLocation(TByteArrayList simplification, double leftLon, double rightLon, double bottomLat,
 										double topLat, GeometryWayProvider provider, int currLocationIdx) {
 		double lat = provider.getLatitude(currLocationIdx);
 		double lon = provider.getLongitude(currLocationIdx);
diff --git a/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiProfileGeometryWay.java b/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiProfileGeometryWay.java
index 0fb6b87ca78..c004dc7fcd5 100644
--- a/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiProfileGeometryWay.java
+++ b/OsmAnd/src/net/osmand/plus/views/layers/geometry/MultiProfileGeometryWay.java
@@ -29,6 +29,7 @@
 import androidx.annotation.NonNull;
 import androidx.core.content.ContextCompat;
 import androidx.core.graphics.ColorUtils;
+import gnu.trove.list.array.TByteArrayList;
 
 public class MultiProfileGeometryWay extends GeometryWay<MultiProfileGeometryWayContext, MultiProfileGeometryWayDrawer> {
 
@@ -148,19 +149,23 @@ private List<LatLon> getRoutePoints(WptPt start, WptPt end) {
 	}
 
 	@Override
-	protected boolean shouldAddLocation(RotatedTileBox tileBox, double leftLon, double rightLon,
+	protected boolean shouldAddLocation(TByteArrayList simplification, double leftLon, double rightLon,
 										double bottomLat, double topLat, GeometryWayProvider provider,
 										int currLocationIdx) {
-		float currX = tileBox.getPixXFromLatLon(provider.getLatitude(currLocationIdx), provider.getLongitude(currLocationIdx));
-		float currY = tileBox.getPixYFromLatLon(provider.getLatitude(currLocationIdx), provider.getLongitude(currLocationIdx));
-		if (tileBox.containsPoint(currX, currY, getContext().circleSize)) {
-			return true;
-		} else if (currLocationIdx + 1 >= provider.getSize()) {
-			return false;
+		double currLat = provider.getLatitude(currLocationIdx);
+		double currLon = provider.getLongitude(currLocationIdx);
+
+		int nextIdx = currLocationIdx;
+		for (int i = nextIdx + 1; i < simplification.size(); i++) {
+			if (simplification.getQuick(i) == 1) {
+				nextIdx = i;
+			}
 		}
-		float nextX = tileBox.getPixXFromLatLon(provider.getLatitude(currLocationIdx + 1), provider.getLongitude(currLocationIdx + 1));
-		float nextY = tileBox.getPixXFromLatLon(provider.getLatitude(currLocationIdx + 1), provider.getLongitude(currLocationIdx + 1));
-		return tileBox.containsPoint(nextX, nextY, getContext().circleSize);
+
+		double nextLat = provider.getLatitude(nextIdx);
+		double nextLon = provider.getLongitude(nextIdx);
+		return Math.min(currLon, nextLon) < rightLon && Math.max(currLon, nextLon) > leftLon
+				&& Math.min(currLat, nextLat) < topLat && Math.max(currLat, nextLat) > bottomLat;
 	}
 
 	private boolean segmentDataChanged(Map<Pair<WptPt, WptPt>, RoadSegmentData> other) {
