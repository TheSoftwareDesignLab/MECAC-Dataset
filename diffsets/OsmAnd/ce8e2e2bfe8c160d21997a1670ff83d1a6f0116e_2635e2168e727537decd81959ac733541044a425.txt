diff --git a/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java b/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
index a2e59d37485..675e1413ae6 100644
--- a/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
+++ b/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
@@ -245,6 +245,9 @@ public void updateLocation(Location location) {
 					mapView.getAnimatedDraggingThread().startMoving(
 							location.getLatitude(), location.getLongitude(), zoom,
 							pendingRotation, rotation, false);
+					if (mapView.getElevationAngle() < 90f && app.getRoutingHelper().isFollowingMode()) {
+						mapView.adjustElevationAngle();
+					}
 				} else {
 					if (zoom != null && zoom.first != null && zoom.second != null) {
 						mapView.getAnimatedDraggingThread().startZooming(zoom.first, zoom.second, false);
diff --git a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
index 0e6d97339f4..8cf9274dcad 100644
--- a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
+++ b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
@@ -81,6 +81,7 @@ public class OsmandMapTileView implements IMapDownloaderCallback {
 	private static final int MAP_FORCE_REFRESH_MESSAGE = OsmAndConstants.UI_HANDLER_MAP_VIEW + 5;
 	private static final int BASE_REFRESH_MESSAGE = OsmAndConstants.UI_HANDLER_MAP_VIEW + 3;
 	private static final int MAP_DEFAULT_COLOR = 0xffebe7e4;
+	private static final float MIN_ELEVATION_ANGLE = 35f;
 
 	private boolean MEASURE_FPS = false;
 	private final FPSMeasurement main = new FPSMeasurement();
@@ -503,6 +504,9 @@ public void resetManualRotation() {
 	}
 
 	public void setRotate(float rotate, boolean force) {
+		if (multiTouch) {
+			return;
+		}
 		float diff = MapUtils.unifyRotationDiff(rotate, getRotate());
 		if (Math.abs(diff) > 5 || force) { // check smallest rotation
 			animatedDraggingThread.startRotate(rotate);
@@ -1100,27 +1104,23 @@ private void setRotateImpl(float rotate) {
 	private void setRotateImpl(float rotate, int centerX, int centerY) {
 		MapRendererView mapRenderer = getMapRenderer();
 		if (mapRenderer != null) {
-			RotatedTileBox tb = currentViewport.copy();
-			boolean centerShifted = tb.isCenterShifted();
-			if (centerShifted) {
-				int centerX31 = 0;
-				int centerY31 = 0;
-				PointI center31 = new PointI();
-				if (mapRenderer.getLocationFromScreenPoint(new PointI(centerX, centerY), center31)) {
-					centerX31 = center31.getX();
-					centerY31 = center31.getY();
-				}
-				PointI target31 = mapRenderer.getState().getTarget31();
-				float azimuth = mapRenderer.getState().getAzimuth();
-				int targetX = target31.getX() - centerX31;
-				int targetY = target31.getY() - centerY31;
-				double angleR = Math.toRadians(-azimuth - rotate);
-				double cosAngle = Math.cos(angleR);
-				double sinAngle = Math.sin(angleR);
-				int newTargetX = (int) (targetX * cosAngle - targetY * sinAngle + centerX31);
-				int newTargetY = (int) (targetX * sinAngle + targetY * cosAngle + centerY31);
-				mapRenderer.setTarget(new PointI(newTargetX, newTargetY));
+			int centerX31 = 0;
+			int centerY31 = 0;
+			PointI center31 = new PointI();
+			if (mapRenderer.getLocationFromScreenPoint(new PointI(centerX, centerY), center31)) {
+				centerX31 = center31.getX();
+				centerY31 = center31.getY();
 			}
+			PointI target31 = mapRenderer.getState().getTarget31();
+			float azimuth = mapRenderer.getState().getAzimuth();
+			int targetX = target31.getX() - centerX31;
+			int targetY = target31.getY() - centerY31;
+			double angleR = Math.toRadians(-azimuth - rotate);
+			double cosAngle = Math.cos(angleR);
+			double sinAngle = Math.sin(angleR);
+			int newTargetX = (int) (targetX * cosAngle - targetY * sinAngle + centerX31);
+			int newTargetY = (int) (targetX * sinAngle + targetY * cosAngle + centerY31);
+			mapRenderer.setTarget(new PointI(newTargetX, newTargetY));
 			mapRenderer.setAzimuth(-rotate);
 		}
 		currentViewport.setRotate(rotate);
@@ -1145,16 +1145,12 @@ private void setZoomAndAnimationImpl(int zoom, double zoomAnimation, double zoom
 			RotatedTileBox tb = currentViewport.copy();
 			int centerX31Before = 0;
 			int centerY31Before = 0;
-			// If map center is shifted we need to store map center in 31 coordinates before zoom and
-			// after zoom - shift map to new center (to keep map center in same px coordinate)
-			boolean centerShifted = tb.isCenterShifted();
-			if (centerShifted) {
-				// Get map center in 31
-				PointI center31 = new PointI();
-				if (mapRenderer.getLocationFromScreenPoint(new PointI(centerX, centerY), center31)) {
-					centerX31Before = center31.getX();
-					centerY31Before = center31.getY();
-				}
+
+			// Get map center in 31
+			PointI center31 = new PointI();
+			if (mapRenderer.getLocationFromScreenPoint(new PointI(centerX, centerY), center31)) {
+				centerX31Before = center31.getX();
+				centerY31Before = center31.getY();
 			}
 
 			// Zoom
@@ -1163,21 +1159,20 @@ private void setZoomAndAnimationImpl(int zoom, double zoomAnimation, double zoom
 			mapRenderer.setVisualZoomShift(zoomMagnifier - 1.0f);
 
 			// Shift map to new center
-			if (centerShifted) {
-				PointI center31 = new PointI();
-				// Get new map center in 31
-				if (mapRenderer.getLocationFromScreenPoint(new PointI(centerX, centerY), center31)) {
-					int centerX31After = center31.getX();
-					int centerY31After = center31.getY();
-					PointI target31 = mapRenderer.getState().getTarget31();
-					int targetX = target31.getX() - (centerX31After - centerX31Before);
-					int targetY = target31.getY() - (centerY31After - centerY31Before);
-					// Shift map
-					mapRenderer.setTarget(new PointI(targetX, targetY));
-				}
+			center31 = new PointI();
+			// Get new map center in 31
+			if (mapRenderer.getLocationFromScreenPoint(new PointI(centerX, centerY), center31)) {
+				int centerX31After = center31.getX();
+				int centerY31After = center31.getY();
+				PointI target31 = mapRenderer.getState().getTarget31();
+				int targetX = target31.getX() - (centerX31After - centerX31Before);
+				int targetY = target31.getY() - (centerY31After - centerY31Before);
+				// Shift map
+				mapRenderer.setTarget(new PointI(targetX, targetY));
 			}
 		}
 		currentViewport.setZoomAndAnimation(zoom, zoomAnimation, zoomFloatPart);
+		setElevationAngle(normalizeElevationAngle(this.elevationAngle, (float) (zoom + zoomAnimation + zoomFloatPart)));
 	}
 
 	private void setMapDensityImpl(double mapDensity) {
@@ -1189,6 +1184,24 @@ private void setMapDensityImpl(double mapDensity) {
 		currentViewport.setMapDensity(mapDensity);
 	}
 
+	private float normalizeElevationAngle(float elevationAngle, float zoom) {
+		if (elevationAngle > 90f) {
+			return 90f;
+		}
+		if (zoom > 15) {
+			return Math.max(35f, elevationAngle);
+		} else if (zoom > 12) {
+			return Math.max(45f, elevationAngle);
+		} else if (zoom > 9) {
+			return Math.max(50f, elevationAngle);
+		} else if (zoom > 7) {
+			return Math.max(55f, elevationAngle);
+		} else if (zoom > 5) {
+			return Math.max(65f, elevationAngle);
+		}
+		return Math.max(75f, elevationAngle);
+	}
+
 	protected void zoomToAnimate(int zoom, double zoomToAnimate, int centerX, int centerY, boolean notify) {
 		if (mainLayer != null && getMaxZoom() >= zoom && getMinZoom() <= zoom) {
 			setZoomAndAnimationImpl(zoom, zoomToAnimate, centerX, centerY);
@@ -1640,26 +1653,6 @@ private void changeZoomPosition(float dz, float angle) {
 			// Keep zoom center fixed or flexible
 			if (mapRenderer != null) {
 				zoomToAnimate(initialViewport, dz, multiTouchCenterX, multiTouchCenterY);
-/*
-				int multiTouchCenterX31After = 0;
-				int multiTouchCenterY31After = 0;
-				PointI center31 = new PointI();
-				if (mapRenderer.getLocationFromScreenPoint(new PointI(
-						multiTouchCenterX, multiTouchCenterY), center31)) {
-					multiTouchCenterX31After = center31.getX();
-					multiTouchCenterY31After = center31.getY();
-				}
-
-				PointI target31 = mapRenderer.getState().getTarget31();
-				int targetX = target31.getX() - multiTouchCenterX31After;
-				int targetY = target31.getY() - multiTouchCenterY31After;
-				double angleR = Math.toRadians(prevAngle - angle);
-				double cosAngle = Math.cos(angleR);
-				double sinAngle = Math.sin(angleR);
-				int newTargetX = (int) (targetX * cosAngle - targetY * sinAngle + multiTouchCenterX31After);
-				int newTargetY = (int) (targetX * sinAngle + targetY * cosAngle + multiTouchCenterY31After);
-				setTarget31(newTargetX, newTargetY);
- */
 				rotateToAnimate(calcRotate, multiTouchCenterX, multiTouchCenterY);
 			} else {
 				LatLon r = calc.getLatLonFromPixel(cp.x + cp.x - multiTouchCenterX, cp.y + cp.y - multiTouchCenterY);
@@ -1671,12 +1664,14 @@ private void changeZoomPosition(float dz, float angle) {
 		}
 	}
 
+	public void adjustElevationAngle() {
+		setElevationAngle(MIN_ELEVATION_ANGLE);
+	}
+
 	private void setElevationAngle(float angle) {
-		if (angle < 35f) {
-			angle = 35f;
-		} else if (angle > 90f) {
-			angle = 90f;
-		}
+		RotatedTileBox tb = currentViewport.copy();
+		float zoom = (float) (tb.getZoom() + tb.getZoomAnimation() + tb.getZoomFloatPart());
+		angle = normalizeElevationAngle(angle, zoom);
 		this.elevationAngle = angle;
 		application.getOsmandMap().setMapElevation(angle);
 	}
