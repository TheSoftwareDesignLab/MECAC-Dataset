diff --git a/OsmAnd-java/src/main/java/net/osmand/data/RotatedTileBox.java b/OsmAnd-java/src/main/java/net/osmand/data/RotatedTileBox.java
index bf4b821da3e..d9312242bad 100644
--- a/OsmAnd-java/src/main/java/net/osmand/data/RotatedTileBox.java
+++ b/OsmAnd-java/src/main/java/net/osmand/data/RotatedTileBox.java
@@ -339,6 +339,10 @@ public double getRotateSin() {
 		return rotateSin;
 	}
 
+	public double getFullZoom() {
+		return getZoom() + getZoomFloatPart() + getZoomAnimation();
+	}
+
 	public int getZoom() {
 		return zoom;
 	}
diff --git a/OsmAnd-java/src/main/java/net/osmand/gpx/GPXUtilities.java b/OsmAnd-java/src/main/java/net/osmand/gpx/GPXUtilities.java
index dbcb6cbf160..5bf65c6a1e4 100644
--- a/OsmAnd-java/src/main/java/net/osmand/gpx/GPXUtilities.java
+++ b/OsmAnd-java/src/main/java/net/osmand/gpx/GPXUtilities.java
@@ -73,6 +73,7 @@ public class GPXUtilities {
 
 	public static final String POINT_ELEVATION = "ele";
 	public static final String POINT_SPEED = "speed";
+	public static final String POINT_BEARING = "bearing";
 
 	public static final char TRAVEL_GPX_CONVERT_FIRST_LETTER = 'A';
 	public static final int TRAVEL_GPX_CONVERT_FIRST_DIST = 5000;
@@ -241,6 +242,7 @@ public static class WptPt extends GPXExtensions {
 		public double speed = 0;
 		public double hdop = Double.NaN;
 		public float heading = Float.NaN;
+		public float bearing = Float.NaN;
 		public boolean deleted = false;
 		public int speedColor = 0;
 		public int altitudeColor = 0;
@@ -1452,11 +1454,19 @@ public static GPXFile loadGPXFile(InputStream stream, GPXExtensionsReader extens
 											}
 											parse.getExtensionsToWrite().put(t, value);
 
-											if (tag.equals(POINT_SPEED) && parse instanceof WptPt) {
-												try {
-													((WptPt) parse).speed = Float.parseFloat(value);
-												} catch (NumberFormatException e) {
-													log.debug(e.getMessage(), e);
+											if (parse instanceof WptPt) {
+												WptPt wptPt = (WptPt) parse;
+												if (POINT_SPEED.equals(tag)) {
+													try {
+														wptPt.speed = Float.parseFloat(value);
+													} catch (NumberFormatException e) {
+														log.debug(e.getMessage(), e);
+													}
+												} else if (POINT_BEARING.equals(tag)) {
+													try {
+														wptPt.bearing = Float.parseFloat(value);
+													} catch (NumberFormatException ignored) {
+													}
 												}
 											}
 										}
diff --git a/OsmAnd-java/src/main/java/net/osmand/gpx/PointAttributes.java b/OsmAnd-java/src/main/java/net/osmand/gpx/PointAttributes.java
index fdebc3f8688..e29bab68269 100644
--- a/OsmAnd-java/src/main/java/net/osmand/gpx/PointAttributes.java
+++ b/OsmAnd-java/src/main/java/net/osmand/gpx/PointAttributes.java
@@ -12,7 +12,9 @@ public class PointAttributes {
 	public static final String SENSOR_TAG_TEMPERATURE = "temp";
 	public static final String SENSOR_TAG_DISTANCE = "osmand:bike_distance_sensor";
 
-	public static final String DEV_ZOOM = "zoom";
+	public static final String DEV_RAW_ZOOM = "raw_zoom";
+	public static final String DEV_ANIMATED_ZOOM = "animated_zoom";
+	public static final String DEV_INTERPOLATION_OFFSET_N = "offset";
 
 	public float distance;
 	public final float timeDiff;
@@ -26,7 +28,10 @@ public class PointAttributes {
 	public float bikeCadence;
 	public float bikePower;
 	public float temperature;
-	public float zoom;
+
+	public float rawZoom;
+	public float animatedZoom;
+	public float interpolationOffsetN;
 
 	public PointAttributes(float distance, float timeDiff, boolean firstPoint, boolean lastPoint) {
 		this.distance = distance;
@@ -51,8 +56,12 @@ public Float getAttributeValue(String tag) {
 				return bikePower;
 			case SENSOR_TAG_TEMPERATURE:
 				return temperature;
-			case DEV_ZOOM:
-				return zoom;
+			case DEV_RAW_ZOOM:
+				return rawZoom;
+			case DEV_ANIMATED_ZOOM:
+				return animatedZoom;
+			case DEV_INTERPOLATION_OFFSET_N:
+				return interpolationOffsetN;
 		}
 		return null;
 	}
@@ -80,8 +89,14 @@ public void setAttributeValue(String tag, float value) {
 			case SENSOR_TAG_TEMPERATURE:
 				temperature = value;
 				break;
-			case DEV_ZOOM:
-				zoom = value;
+			case DEV_RAW_ZOOM:
+				rawZoom = value;
+				break;
+			case DEV_ANIMATED_ZOOM:
+				animatedZoom = value;
+				break;
+			case DEV_INTERPOLATION_OFFSET_N:
+				interpolationOffsetN = value;
 				break;
 		}
 	}
diff --git a/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java b/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java
index 825577300a6..44497449c13 100644
--- a/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java
+++ b/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java
@@ -759,11 +759,15 @@ public static boolean areLatLonEqualPrecise(Location l, double lat, double lon)
 	}
 
 	public static LatLon rhumbDestinationPoint(LatLon latLon, double distance, double bearing) {
+		return rhumbDestinationPoint(latLon.getLatitude(), latLon.getLongitude(), distance, bearing);
+	}
+
+	public static LatLon rhumbDestinationPoint(double lat, double lon, double distance, double bearing) {
 		double radius = EARTH_RADIUS_A;
 
 		double d = distance / radius; // angular distance in radians
-		double phi1 = Math.toRadians(latLon.getLatitude());
-		double lambda1 = Math.toRadians(latLon.getLongitude());
+		double phi1 = Math.toRadians(lat);
+		double lambda1 = Math.toRadians(lon);
 		double theta = Math.toRadians(bearing);
 
 		double deltaPhi = d * Math.cos(theta);
diff --git a/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java b/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
index bf566a17460..b8b3e29d26a 100644
--- a/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
+++ b/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
@@ -1,16 +1,9 @@
 package net.osmand.plus.base;
 
-import static net.osmand.plus.settings.enums.CompassMode.COMPASS_DIRECTION;
-import static net.osmand.plus.views.AnimateDraggingMapThread.SKIP_ANIMATION_DP_THRESHOLD;
-
 import android.content.Context;
 import android.os.AsyncTask;
 import android.view.WindowManager;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.core.util.Pair;
-
 import net.osmand.CallbackWithObject;
 import net.osmand.Location;
 import net.osmand.StateChangedListener;
@@ -40,14 +33,20 @@
 import net.osmand.plus.settings.enums.DrivingRegion;
 import net.osmand.plus.utils.NativeUtilities;
 import net.osmand.plus.views.AnimateDraggingMapThread;
-import net.osmand.plus.views.AutoZoomBySpeedUtils;
+import net.osmand.plus.views.AutoZoomBySpeedHelper;
 import net.osmand.plus.views.OsmandMapTileView;
-import net.osmand.plus.views.Zoom;
 import net.osmand.plus.views.Zoom.ComplexZoom;
 import net.osmand.util.MapUtils;
 
 import java.text.SimpleDateFormat;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.util.Pair;
+
+import static net.osmand.plus.settings.enums.CompassMode.COMPASS_DIRECTION;
+import static net.osmand.plus.views.AnimateDraggingMapThread.SKIP_ANIMATION_DP_THRESHOLD;
+
 public class MapViewTrackingUtilities implements OsmAndLocationListener, IMapLocationListener,
 		OsmAndCompassListener, MapMarkerChangedListener {
 
@@ -62,6 +61,7 @@ public class MapViewTrackingUtilities implements OsmAndLocationListener, IMapLoc
 	private final OsmandSettings settings;
 	private final RoutingHelper routingHelper;
 	private final MapDisplayPositionManager mapDisplayPositionManager;
+	private final AutoZoomBySpeedHelper autoZoomBySpeedHelper;
 
 	private OsmandMapTileView mapView;
 	private DashboardOnMap dashboard;
@@ -87,6 +87,7 @@ public MapViewTrackingUtilities(@NonNull OsmandApplication app) {
 		settings = app.getSettings();
 		routingHelper = app.getRoutingHelper();
 		mapDisplayPositionManager = new MapDisplayPositionManager(app);
+		autoZoomBySpeedHelper = new AutoZoomBySpeedHelper(app);
 		myLocation = app.getLocationProvider().getLastKnownLocation();
 		app.getLocationProvider().addLocationListener(this);
 		app.getLocationProvider().addCompassListener(this);
@@ -229,7 +230,6 @@ public void updateLocation(Location location) {
 				boolean pendingRotation = false;
 				int currentMapRotation = settings.ROTATE_MAP.get();
 				boolean smallSpeedForCompass = isSmallSpeedForCompass(location);
-				boolean smallSpeedForAnimation = isSmallSpeedForAnimation(location);
 
 				showViewAngle = (!location.hasBearing() || smallSpeedForCompass) && (tb != null &&
 						NativeUtilities.containsLatLon(mapRenderer, tb, location.getLatitude(), location.getLongitude()));
@@ -255,54 +255,10 @@ public void updateLocation(Location location) {
 				}
 				registerUnregisterSensor(location, smallSpeedForCompass);
 
-				ComplexZoom autoZoom = null;
-				if (shouldAutoZoom(location)) {
-					autoZoom = mapRenderer != null
-							? AutoZoomBySpeedUtils.autoZoomBySpeed(app, tb, location.getSpeed())
-							: AutoZoomBySpeedUtils.calculateAutoZoomBySpeed(app, tb, location.getSpeed());
-					if (autoZoom != null) {
-						lastTimeAutoZooming = System.currentTimeMillis();
-					}
-				}
-
-				if (settings.ANIMATE_MY_LOCATION.get() && !smallSpeedForAnimation && !movingToMyLocation) {
-					mapView.getAnimatedDraggingThread().stopAnimatingSync();
-					Pair<ComplexZoom, Long> zoomParams = null;
-					if (autoZoom != null) {
-						zoomParams = mapRenderer != null
-								? smoothenAutoZoom(tb, autoZoom, movingTime)
-								: new Pair<>(autoZoom, AutoZoomBySpeedUtils.FIXED_ZOOM_DURATION_MILLIS);
-						if (mapRenderer != null && zoomParams.second < AutoZoomBySpeedUtils.MIN_ZOOM_DURATION_MILLIS) {
-							zoomParams = null;
-						}
-					}
-					mapView.getAnimatedDraggingThread().startMoving(
-							location.getLatitude(), location.getLongitude(), zoomParams,
-							pendingRotation, rotation, movingTime, false,
-							() -> movingToMyLocation = false);
+				if (mapRenderer != null) {
+					setMyLocationV2(mapView, mapRenderer, location, movingTime, rotation);
 				} else {
-					if (mapRenderer != null) {
-						movingTime = movingToMyLocation
-								? (long) Math.min(movingTime * 0.7, MOVE_ANIMATION_TIME) : MOVE_ANIMATION_TIME;
-						if (mapView.getSettings().DO_NOT_USE_ANIMATIONS.get()) {
-							movingTime = 0;
-						}
-						Pair<ComplexZoom, Long> zoomParams = autoZoom != null
-								? new Pair<>(autoZoom, AutoZoomBySpeedUtils.FIXED_ZOOM_DURATION_MILLIS)
-								: null;
-						mapView.getAnimatedDraggingThread().startMoving(
-								location.getLatitude(), location.getLongitude(), zoomParams,
-								pendingRotation, rotation, movingTime, false,
-								() -> movingToMyLocation = false);
-					} else {
-						if (autoZoom != null) {
-							mapView.getAnimatedDraggingThread().startZooming(autoZoom.base, autoZoom.floatPart, null, false);
-						}
-						if (rotation != null) {
-							mapView.setRotate(rotation, false);
-						}
-						mapView.setLatLon(location.getLatitude(), location.getLongitude());
-					}
+					setMyLocationV1(mapView, location, movingTime, rotation, pendingRotation);
 				}
 			} else if (location != null) {
 				showViewAngle = (!location.hasBearing() || isSmallSpeedForCompass(location)) && (tb != null &&
@@ -334,16 +290,72 @@ public static boolean isSmallSpeedForAnimation(Location location) {
 		return !location.hasSpeed() || Float.isNaN(location.getSpeed()) || location.getSpeed() < 1.5;
 	}
 
-	@NonNull
-	private Pair<ComplexZoom, Long> smoothenAutoZoom(@NonNull RotatedTileBox tileBox,
-	                                                 @NonNull ComplexZoom autoZoom,
-	                                                 long maxDuration) {
-		float currentZoom = (float) (tileBox.getZoom() + tileBox.getZoomAnimation() + tileBox.getZoomFloatPart());
-		float zoomDelta = autoZoom.fullZoom() - currentZoom;
-		long zoomingTime = Math.min(maxDuration, (long) (Math.abs(zoomDelta) / AutoZoomBySpeedUtils.ZOOM_PER_SECOND * 1000));
-		float boundedZoomDelta = Math.signum(zoomDelta) * AutoZoomBySpeedUtils.ZOOM_PER_SECOND * (zoomingTime / 1000f);
-		ComplexZoom boundedAutoZoom = ComplexZoom.fromPreferredBase(currentZoom + boundedZoomDelta, tileBox.getZoom());
-		return new Pair<>(boundedAutoZoom, zoomingTime);
+	private void setMyLocationV2(@NonNull OsmandMapTileView mapView, @NonNull MapRendererView mapRenderer,
+	                             @NonNull Location location, long timeDiff, @Nullable Float rotation) {
+		boolean animateMyLocation = animateMyLocation(location);
+
+		ComplexZoom autoZoom = null;
+		if (shouldAutoZoom(location, 0)) {
+			if (animateMyLocation) {
+				mapView.getAnimatedDraggingThread().stopAnimatingSync();
+			}
+			autoZoom = autoZoomBySpeedHelper.calculateZoomBySpeedToAnimate(mapRenderer, location, rotation);
+		}
+
+		long movingTime;
+		if (animateMyLocation) {
+			movingTime = timeDiff;
+		} else {
+			if (settings.DO_NOT_USE_ANIMATIONS.get()) {
+				movingTime = 0;
+			} else {
+				movingTime = movingToMyLocation
+						? (long) Math.min(timeDiff * 0.7, MOVE_ANIMATION_TIME)
+						: MOVE_ANIMATION_TIME;
+			}
+		}
+
+		Pair<ComplexZoom, Long> zoomParams = autoZoom != null
+				? autoZoomBySpeedHelper.getAutoZoomParams(mapRenderer.getZoom(), autoZoom, !animateMyLocation)
+				: null;
+
+		mapView.getAnimatedDraggingThread().startMoving(
+				location.getLatitude(), location.getLongitude(), zoomParams,
+				false, rotation, movingTime, false,
+				() -> movingToMyLocation = false);
+	}
+
+	private void setMyLocationV1(@NonNull OsmandMapTileView mapView,
+	                             @NonNull Location location, long movingTime,
+	                             @Nullable Float rotation, boolean pendingRotation) {
+		RotatedTileBox tileBox = mapView.getRotatedTileBox();
+		ComplexZoom autoZoom = null;
+		if (shouldAutoZoom(location, AUTO_ZOOM_DEFAULT_CHANGE_ZOOM)) {
+			autoZoom = autoZoomBySpeedHelper.calculateAutoZoomBySpeedV1(tileBox, location.getSpeed());
+			lastTimeAutoZooming = System.currentTimeMillis();
+		}
+
+		if (animateMyLocation(location)) {
+			Pair<ComplexZoom, Long> zoomParams = autoZoom != null
+					? new Pair<>(autoZoom, AutoZoomBySpeedHelper.FIXED_ZOOM_DURATION_MILLIS)
+					: null;
+			mapView.getAnimatedDraggingThread().startMoving(
+					location.getLatitude(), location.getLongitude(), zoomParams,
+					pendingRotation, rotation, movingTime, false,
+					() -> movingToMyLocation = false);
+		} else {
+			if (autoZoom != null) {
+				mapView.getAnimatedDraggingThread().startZooming(autoZoom.base, autoZoom.floatPart, null, false);
+			}
+			if (rotation != null) {
+				mapView.setRotate(rotation, false);
+			}
+			mapView.setLatLon(location.getLatitude(), location.getLongitude());
+		}
+	}
+
+	private boolean animateMyLocation(@NonNull Location location) {
+		return settings.ANIMATE_MY_LOCATION.get() && !isSmallSpeedForAnimation(location) && !movingToMyLocation;
 	}
 
 	public boolean isShowViewAngle() {
@@ -391,22 +403,7 @@ private void registerUnregisterSensor(net.osmand.Location location, boolean smal
 		}
 	}
 
-	private float defineZoomFromSpeed(RotatedTileBox tb, float speed) {
-		if (speed < 7f / 3.6) {
-			return 0;
-		}
-		double visibleDist = tb.getDistance(tb.getCenterPixelX(), 0, tb.getCenterPixelX(), tb.getCenterPixelY());
-		float time = 75f; // > 83 km/h show 75 seconds 
-		if (speed < 83f / 3.6) {
-			time = 60f;
-		}
-		time /= settings.AUTO_ZOOM_MAP_SCALE.get().coefficient;
-		double distToSee = speed * time;
-		// check if 17, 18 is correct?
-		return (float) (Math.log(visibleDist / distToSee) / Math.log(2.0f));
-	}
-
-	private boolean shouldAutoZoom(@NonNull Location location) {
+	private boolean shouldAutoZoom(@NonNull Location location, long autoZoomFrequency) {
 		if (!settings.AUTO_ZOOM_MAP.get() || !location.hasSpeed()) {
 			return false;
 		}
@@ -415,7 +412,7 @@ private boolean shouldAutoZoom(@NonNull Location location) {
 		boolean isUserZoomed = lastTimeManualZooming > lastTimeAutoZooming;
 		return isUserZoomed
 				? now - lastTimeManualZooming > Math.max(settings.AUTO_FOLLOW_ROUTE.get(), AUTO_ZOOM_DEFAULT_CHANGE_ZOOM)
-				: now - lastTimeAutoZooming > AUTO_ZOOM_DEFAULT_CHANGE_ZOOM;
+				: now - lastTimeAutoZooming > autoZoomFrequency;
 	}
 
 	public void backToLocationImpl() {
diff --git a/OsmAnd/src/net/osmand/plus/charts/GPXDataSetType.java b/OsmAnd/src/net/osmand/plus/charts/GPXDataSetType.java
index 27c32837aa7..6fdd298b34e 100644
--- a/OsmAnd/src/net/osmand/plus/charts/GPXDataSetType.java
+++ b/OsmAnd/src/net/osmand/plus/charts/GPXDataSetType.java
@@ -32,8 +32,8 @@ public enum GPXDataSetType {
 	SENSOR_BIKE_CADENCE(R.string.map_widget_ant_bicycle_cadence, R.drawable.ic_action_sensor_cadence_outlined, SENSOR_TAG_CADENCE, R.color.gpx_chart_indigo_label, R.color.gpx_chart_indigo),
 	SENSOR_TEMPERATURE(R.string.map_settings_weather_temp, R.drawable.ic_action_thermometer, SENSOR_TAG_TEMPERATURE, R.color.gpx_chart_green_label, R.color.gpx_chart_green),
 
-	ZOOM_ANIMATED(R.string.zoom_animated, R.drawable.widget_developer_map_zoom_day, PointAttributes.DEV_ZOOM, R.color.gpx_chart_teal_label, R.color.gpx_chart_teal),
-	ZOOM_NON_ANIMATED(R.string.zoom_non_animated, R.drawable.widget_developer_map_zoom_day, PointAttributes.DEV_ZOOM, R.color.gpx_chart_indigo_label, R.color.gpx_chart_indigo);
+	ZOOM_ANIMATED(R.string.zoom_animated, R.drawable.widget_developer_map_zoom_day, PointAttributes.DEV_ANIMATED_ZOOM, R.color.gpx_chart_teal_label, R.color.gpx_chart_teal),
+	ZOOM_NON_ANIMATED(R.string.zoom_non_animated, R.drawable.widget_developer_map_zoom_day, PointAttributes.DEV_RAW_ZOOM, R.color.gpx_chart_indigo_label, R.color.gpx_chart_indigo);
 
 	@StringRes
 	private final int titleId;
diff --git a/OsmAnd/src/net/osmand/plus/plugins/development/OsmandDevelopmentPlugin.java b/OsmAnd/src/net/osmand/plus/plugins/development/OsmandDevelopmentPlugin.java
index 58efc788315..884f96c6f46 100644
--- a/OsmAnd/src/net/osmand/plus/plugins/development/OsmandDevelopmentPlugin.java
+++ b/OsmAnd/src/net/osmand/plus/plugins/development/OsmandDevelopmentPlugin.java
@@ -33,7 +33,7 @@
 import net.osmand.plus.settings.backend.WidgetsAvailabilityHelper;
 import net.osmand.plus.settings.backend.preferences.OsmandPreference;
 import net.osmand.plus.settings.fragments.SettingsScreenType;
-import net.osmand.plus.views.AutoZoomBySpeedUtils;
+import net.osmand.plus.views.AutoZoomBySpeedHelper;
 import net.osmand.plus.views.mapwidgets.MapWidgetInfo;
 import net.osmand.plus.views.mapwidgets.WidgetInfoCreator;
 import net.osmand.plus.views.mapwidgets.WidgetType;
@@ -242,19 +242,19 @@ private SRTMPlugin getSrtmPlugin() {
 
 	@Override
 	public void getAvailableGPXDataSetTypes(@NonNull GPXTrackAnalysis analysis, @NonNull List<GPXDataSetType[]> availableTypes) {
-		AutoZoomBySpeedUtils.addAvailableGPXDataSetTypes(app, analysis, availableTypes);
+		AutoZoomBySpeedHelper.addAvailableGPXDataSetTypes(app, analysis, availableTypes);
 	}
 
 	@Nullable
 	@Override
 	public OrderedLineDataSet getOrderedLineDataSet(@NonNull LineChart chart, @NonNull GPXTrackAnalysis analysis, @NonNull GPXDataSetType graphType, @NonNull GPXDataSetAxisType chartAxisType, boolean calcWithoutGaps, boolean useRightAxis) {
-		return AutoZoomBySpeedUtils.getOrderedLineDataSet(app, chart, analysis, graphType, chartAxisType,
+		return AutoZoomBySpeedHelper.getOrderedLineDataSet(app, chart, analysis, graphType, chartAxisType,
 				calcWithoutGaps, useRightAxis);
 	}
 
 	@Nullable
 	@Override
 	protected TrackPointsAnalyser getTrackPointsAnalyser() {
-		return AutoZoomBySpeedUtils.getTrackPointsAnalyser(app);
+		return AutoZoomBySpeedHelper.getTrackPointsAnalyser(app);
 	}
 }
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/plugins/development/widget/ZoomLevelWidget.java b/OsmAnd/src/net/osmand/plus/plugins/development/widget/ZoomLevelWidget.java
index eaf16dbe134..60f4e505649 100644
--- a/OsmAnd/src/net/osmand/plus/plugins/development/widget/ZoomLevelWidget.java
+++ b/OsmAnd/src/net/osmand/plus/plugins/development/widget/ZoomLevelWidget.java
@@ -46,7 +46,7 @@ protected void updateSimpleWidgetInfo(@Nullable DrawSettings drawSettings) {
 			float visualZoom = newZoomFloatPart >= 0.0f
 					? 1.0f + newZoomFloatPart
 					: 1.0f + 0.5f * newZoomFloatPart;
-			float offsetFromLogicalZoom = getZoomDeltaFromMapScale(visualZoom * newMapDensity);
+			float offsetFromLogicalZoom = getZoomDeltaFromMapScale(visualZoom);
 			float preFormattedOffset = Math.round(Math.abs(offsetFromLogicalZoom) * 100) / 100.0f;
 			String formattedOffset = OsmAndFormatter
 					.formatValue(preFormattedOffset, "", true, 2, app)
diff --git a/OsmAnd/src/net/osmand/plus/utils/NativeUtilities.java b/OsmAnd/src/net/osmand/plus/utils/NativeUtilities.java
index df8eb5024eb..c797aa5bf5c 100644
--- a/OsmAnd/src/net/osmand/plus/utils/NativeUtilities.java
+++ b/OsmAnd/src/net/osmand/plus/utils/NativeUtilities.java
@@ -472,6 +472,11 @@ public static PointI getPoint31FromLatLon(double lat, double lon) {
 		return new PointI(x31, y31);
 	}
 
+	public static float getLocationHeightOrZero(@NonNull MapRendererView mapRenderer, @NonNull PointI location31) {
+		float height = mapRenderer.getLocationHeightInMeters(location31);
+		return height > MIN_ALTITUDE_VALUE ? height : 0.0f;
+	}
+
 	@Nullable
 	public static Pair<PointF, PointF> clipLineInVisibleRect(@NonNull MapRendererView mapRenderer,
 	                                                         @NonNull RotatedTileBox tileBox,
diff --git a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
index a4860ecd56c..440650825f9 100644
--- a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
+++ b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
@@ -273,7 +273,7 @@ public void startMoving(double finalLat, double finalLon, @Nullable Pair<Complex
 
 		float animationDuration = Math.max(movingTime, NAV_ANIMATION_TIME / 4);
 
-		boolean animateZoom = zoomParams != null && (zoom != startZoom || startZoomFP != 0);
+		boolean animateZoom = zoomParams != null && (zoom != startZoom || zoomFP != startZoomFP);
 		float rotationDiff = finalRotation != null
 				? Math.abs(MapUtils.unifyRotationDiff(rotation, startRotation)) : 0;
 		boolean animateRotation = rotationDiff > 0.1;
@@ -337,7 +337,11 @@ public void startMoving(double finalLat, double finalLon, @Nullable Pair<Complex
 
 		startThreadAnimating(() -> {
 			animatingMapMove = true;
-			setTargetValues(zoom, zoomFP, finalLat, finalLon);
+			if (mapRenderer != null) {
+				setTargetValues(0, 0, finalLat, finalLon);
+			} else {
+				setTargetValues(zoom, zoomFP, finalLat, finalLon);
+			}
 
 			if (mapRenderer != null) {
 				if (animateZoom) {
@@ -543,7 +547,6 @@ private void animatingMapAnimator() {
 
 		PointI initFlatTarget31 = mapRenderer.getState().getTarget31();
 		float initZoom = mapRenderer.getZoom();
-		int zoomThreshold = ((int) (targetFloatZoom * 2));
 		float initAzimuth = mapRenderer.getAzimuth();
 		float initElevationAngle = mapRenderer.getElevationAngle();
 
@@ -574,7 +577,7 @@ private void animatingMapAnimator() {
 					|| initFlatTarget31.getY() != flatTarget31.getY();
 			}
 			if (!animateZoom) {
-				animateZoom = initZoom != zoom && targetIntZoom > 0;
+				animateZoom = initZoom != zoom;
 			}
 			if (!animateAzimuth) {
 				animateAzimuth = initAzimuth != azimuth;
@@ -588,9 +591,9 @@ private void animatingMapAnimator() {
 					MapUtils.get31LongitudeX(target31.getX()));
 			}
 			if (!stopped && animateZoom) {
-				int baseZoom = (int) Math.round(zoom - 0.5 * zoomThreshold);
-				double zaAnimate = zoom - baseZoom;
-				tb.setZoomAndAnimation(baseZoom, zaAnimate, tb.getZoomFloatPart());
+				int zoomBase = Math.round(zoom);
+				double zoomAnimation = zoom - zoomBase - tb.getZoomFloatPart();
+				tb.setZoomAndAnimation(zoomBase, zoomAnimation, tb.getZoomFloatPart());
 			}
 			if (!stopped && animateAzimuth) {
 				tb.setRotate(-azimuth);
@@ -604,8 +607,12 @@ private void animatingMapAnimator() {
 			}
 		}
 		if (animateZoom && mapRenderer != null) {
-			mapRenderer.setZoom(targetIntZoom + (float) targetFloatZoom);
-			tb.setZoomAndAnimation(targetIntZoom, 0, targetFloatZoom);
+			if (targetIntZoom > 0) {
+				mapRenderer.setZoom(targetIntZoom + (float) targetFloatZoom);
+				tb.setZoomAndAnimation(targetIntZoom, 0, targetFloatZoom);
+			} else {
+				tb.setZoomAndAnimation(tb.getZoom(), 0, tb.getZoomFloatPart() + tb.getZoomAnimation());
+			}
 		}
 		tileView.refreshMap();
 	}
diff --git a/OsmAnd/src/net/osmand/plus/views/AutoZoomBySpeedHelper.java b/OsmAnd/src/net/osmand/plus/views/AutoZoomBySpeedHelper.java
new file mode 100644
index 00000000000..2d0c7f27c46
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/AutoZoomBySpeedHelper.java
@@ -0,0 +1,413 @@
+package net.osmand.plus.views;
+
+import com.github.mikephil.charting.charts.LineChart;
+import com.github.mikephil.charting.components.YAxis;
+import com.github.mikephil.charting.data.Entry;
+
+import net.osmand.Location;
+import net.osmand.core.android.MapRendererView;
+import net.osmand.core.jni.MapRendererState;
+import net.osmand.core.jni.PointD;
+import net.osmand.core.jni.PointI;
+import net.osmand.core.jni.ZoomLevel;
+import net.osmand.data.LatLon;
+import net.osmand.data.RotatedTileBox;
+import net.osmand.gpx.GPXTrackAnalysis;
+import net.osmand.gpx.GPXTrackAnalysis.TrackPointsAnalyser;
+import net.osmand.gpx.GPXUtilities.WptPt;
+import net.osmand.gpx.PointAttributes;
+import net.osmand.plus.OsmandApplication;
+import net.osmand.plus.charts.ChartUtils;
+import net.osmand.plus.charts.GPXDataSetAxisType;
+import net.osmand.plus.charts.GPXDataSetType;
+import net.osmand.plus.charts.OrderedLineDataSet;
+import net.osmand.plus.settings.backend.OsmandSettings;
+import net.osmand.plus.settings.enums.AutoZoomMap;
+import net.osmand.plus.utils.ColorUtilities;
+import net.osmand.plus.utils.NativeUtilities;
+import net.osmand.plus.utils.OsmAndFormatter;
+import net.osmand.plus.views.Zoom.ComplexZoom;
+import net.osmand.util.MapUtils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.core.util.Pair;
+
+import static net.osmand.gpx.PointAttributes.DEV_ANIMATED_ZOOM;
+import static net.osmand.gpx.PointAttributes.DEV_INTERPOLATION_OFFSET_N;
+import static net.osmand.gpx.PointAttributes.DEV_RAW_ZOOM;
+
+public class AutoZoomBySpeedHelper {
+
+	public static final float ZOOM_PER_SECOND = 0.1f;
+	public static final float ZOOM_PER_MILLIS = ZOOM_PER_SECOND / 1000f;
+	public static final int MIN_ZOOM_DURATION_MILLIS = 1500;
+	public static final long FIXED_ZOOM_DURATION_MILLIS = 1000;
+
+	private static final int SHOW_DRIVING_SECONDS_V2 = 37; // TODO: depending on map center?
+	private static final float MIN_AUTO_ZOOM_SPEED = 7 / 3.6f;
+
+	private static final int FOCUS_DIV_X = 2;
+	private static final int FOCUS_DIV_Y = 3;
+
+	private final OsmandApplication app;
+	private final OsmandSettings settings;
+	private final LocationsFilter locationsFilter;
+
+	public AutoZoomBySpeedHelper(@NonNull OsmandApplication app) {
+		this.app = app;
+		this.settings = app.getSettings();
+		this.locationsFilter = new LocationsFilter();
+	}
+
+	@Nullable
+	public ComplexZoom calculateAutoZoomBySpeedV1(@NonNull RotatedTileBox tb, float speed) {
+		float zoomProximityCoeff = settings.AUTO_ZOOM_MAP_SCALE.get().coefficient;
+		float zoomDelta = defineZoomFromSpeed(tb, speed, zoomProximityCoeff);
+		if (Math.abs(zoomDelta) < 0.5) {
+			return null;
+		}
+
+		if (zoomDelta >= 2) {
+			zoomDelta -= 1;
+		} else if (zoomDelta <= -2) {
+			zoomDelta += 1;
+		}
+		double targetZoom = Math.min(tb.getZoom() + tb.getZoomFloatPart() + zoomDelta, settings.AUTO_ZOOM_MAP_SCALE.get().maxZoom);
+		targetZoom = Math.round(targetZoom * 3) / 3f;
+		int newIntegerZoom = (int) Math.round(targetZoom);
+		float zPart = (float) (targetZoom - newIntegerZoom);
+		return newIntegerZoom > 0 ? new ComplexZoom(newIntegerZoom, zPart) : null;
+	}
+
+	private float defineZoomFromSpeed(@NonNull RotatedTileBox tb, float speed, float zoomProximityCoeff) {
+		if (speed < MIN_AUTO_ZOOM_SPEED) {
+			return 0;
+		}
+		double visibleDist = tb.getDistance(tb.getCenterPixelX(), 0, tb.getCenterPixelX(), tb.getCenterPixelY());
+		float time = speed < 83f / 3.6 ? 60 : 75;
+		double distToSee = speed * time / zoomProximityCoeff;
+		float currentZoom = (float) (tb.getZoom() + tb.getZoomFloatPart() + tb.getZoomAnimation());
+		return Zoom.fromDistanceRatio(visibleDist, distToSee, currentZoom);
+	}
+
+	@Nullable
+	public ComplexZoom calculateZoomBySpeedToAnimate(@NonNull MapRendererView mapRenderer, @NonNull Location myLocation, @Nullable Float rotationToAnimate) {
+		float speed = myLocation.getSpeed();
+		if (speed < MIN_AUTO_ZOOM_SPEED) {
+			return null;
+		}
+
+		float filteredSpeed = locationsFilter.getFilteredSpeed(speed);
+		if (Float.isNaN(filteredSpeed)) {
+			return null;
+		}
+
+		OsmandMapTileView mapView = app.getOsmandMap().getMapView();
+		AutoZoomMap autoZoomScale = settings.AUTO_ZOOM_MAP_SCALE.get();
+
+		LatLon myLocationLatLon = new LatLon(myLocation.getLatitude(), myLocation.getLongitude());
+		PointI myLocation31 = NativeUtilities.getPoint31FromLatLon(myLocationLatLon);
+		float myLocationHeight = NativeUtilities.getLocationHeightOrZero(mapRenderer, myLocation31);
+		PointI myLocationPixel = mapRenderer.getState().getFixedPixel();
+
+		float showDistanceToDrive = filteredSpeed * SHOW_DRIVING_SECONDS_V2 / autoZoomScale.coefficient;
+		float rotation = rotationToAnimate != null ? rotationToAnimate : mapView.getRotate();
+		LatLon anotherLatLon = MapUtils.rhumbDestinationPoint(myLocationLatLon, showDistanceToDrive, rotation);
+
+		PointI anotherLocation31 = NativeUtilities.getPoint31FromLatLon(anotherLatLon);
+		float anotherLocationHeight = NativeUtilities.getLocationHeightOrZero(mapRenderer, anotherLocation31);
+		PointI windowSize = mapRenderer.getState().getWindowSize();
+		PointI anotherPixel = new PointI(windowSize.getX() / FOCUS_DIV_X, windowSize.getY() / FOCUS_DIV_Y);
+
+		float expectedSurfaceZoom = mapRenderer.getSurfaceZoomAfterPinch(
+				myLocation31, myLocationHeight, myLocationPixel,
+				anotherLocation31, anotherLocationHeight, anotherPixel);
+		if (expectedSurfaceZoom == -1.0f) {
+			return null;
+		}
+
+		int minZoom = mapView.getMinZoom();
+		int maxZoom = Math.min(mapView.getMaxZoom(), autoZoomScale.maxZoom);
+		Zoom boundedZoom = Zoom.checkZoomBounds(expectedSurfaceZoom, minZoom, maxZoom);
+		return ComplexZoom.fromPreferredBase(boundedZoom.getBaseZoom() + boundedZoom.getZoomFloatPart(), mapView.getZoom());
+	}
+
+	@Nullable
+	public Pair<ComplexZoom, Long> getAnimatedZoomParamsForChart(@NonNull MapRendererView mapRenderer, float currentZoom,
+	                                                             double lat, double lon, float heading, float speed) {
+		if (speed < MIN_AUTO_ZOOM_SPEED) {
+			return null;
+		}
+
+		float filteredSpeed = locationsFilter.getFilteredSpeed(speed);
+		if (Float.isNaN(filteredSpeed)) {
+			return null;
+		}
+
+		ComplexZoom autoZoom = calculateRawZoomBySpeedForChart(mapRenderer, currentZoom, lat, lon, heading, filteredSpeed);
+		if (autoZoom == null) {
+			return null;
+		}
+
+		return getAutoZoomParams(currentZoom, autoZoom, false);
+	}
+
+	@Nullable
+	public ComplexZoom calculateRawZoomBySpeedForChart(@NonNull MapRendererView mapRenderer, float currentZoom, double lat, double lon, float rotation, float speed) {
+		OsmandMapTileView mapView = app.getOsmandMap().getMapView();
+		MapRendererState state = mapRenderer.getState();
+
+		AutoZoomMap autoZoomScale = settings.AUTO_ZOOM_MAP_SCALE.get();
+
+		PointI fixedLocation31 = NativeUtilities.getPoint31FromLatLon(lat, lon);
+
+		PointI firstLocation31 = fixedLocation31;
+		float firstHeightInMeters = NativeUtilities.getLocationHeightOrZero(mapRenderer, firstLocation31);
+		PointI firstPixel = state.getFixedPixel();
+
+		float showDistanceToDrive = speed * SHOW_DRIVING_SECONDS_V2 / autoZoomScale.coefficient;
+		LatLon secondLatLon = MapUtils.rhumbDestinationPoint(lat, lon, showDistanceToDrive, rotation);
+		PointI secondLocation31 = NativeUtilities.getPoint31FromLatLon(secondLatLon);
+		float secondHeightInMeters = NativeUtilities.getLocationHeightOrZero(mapRenderer, secondLocation31);
+		PointI windowSize = state.getWindowSize();
+		PointI secondPixel = new PointI(windowSize.getX() / FOCUS_DIV_X, windowSize.getY() / FOCUS_DIV_Y);
+
+		float expectedSurfaceZoom = mapRenderer.getSurfaceZoomAfterPinchWithParams(
+				fixedLocation31, currentZoom, -rotation,
+				firstLocation31, firstHeightInMeters, firstPixel,
+				secondLocation31, secondHeightInMeters, secondPixel);
+
+		if (expectedSurfaceZoom == -1.0f) {
+			return null;
+		}
+
+		int minZoom = mapView.getMinZoom();
+		int maxZoom = Math.min(mapView.getMaxZoom(), autoZoomScale.maxZoom);
+		Zoom boundedZoom = Zoom.checkZoomBounds(expectedSurfaceZoom, minZoom, maxZoom);
+		return new ComplexZoom(boundedZoom.getBaseZoom(), boundedZoom.getZoomFloatPart());
+	}
+	@Nullable
+	public Pair<ComplexZoom, Long> getAutoZoomParams(float currentZoom, @NonNull ComplexZoom autoZoom, boolean fixedDuration) {
+		if (fixedDuration) {
+			return new Pair<>(autoZoom, FIXED_ZOOM_DURATION_MILLIS);
+		}
+
+		float zoomDelta = autoZoom.fullZoom() - currentZoom;
+		float zoomDuration = Math.abs(zoomDelta) / ZOOM_PER_MILLIS;
+
+		if (zoomDuration < MIN_ZOOM_DURATION_MILLIS) {
+			return null;
+		}
+
+		return new Pair<>(autoZoom, (long) zoomDuration);
+	}
+
+	@Nullable
+	public static TrackPointsAnalyser getTrackPointsAnalyser(@NonNull OsmandApplication app) {
+		OsmandMapTileView mapView = app.getOsmandMap().getMapView();
+		MapRendererView mapRenderer = mapView.getMapRenderer();
+
+		if (mapRenderer == null) {
+			return null;
+		}
+
+		AutoZoomBySpeedHelper autoZoomBySpeedHelper = new AutoZoomBySpeedHelper(app);
+		return new TrackPointsAnalyser() {
+
+			private float currentRawZoom = mapRenderer.getZoom();
+
+			float currentAnimatedZoom = mapRenderer.getZoom();
+			private Pair<ComplexZoom, Long> prevAnimatedZoomParams;
+
+			boolean firstPoint = true;
+
+			@Override
+			public void onAnalysePoint(GPXTrackAnalysis analysis, WptPt point, PointAttributes attributes) {
+				// First point is skipped is GPS simulation
+				if (firstPoint) {
+					firstPoint = false;
+					return;
+				}
+
+				float bearing = Float.isNaN(point.bearing) ? mapView.getRotate() : -point.bearing;
+
+				ComplexZoom rawAutoZoom = autoZoomBySpeedHelper.calculateRawZoomBySpeedForChart(
+						mapRenderer, currentRawZoom, point.lat, point.lon, bearing, attributes.speed);
+				if (rawAutoZoom != null) {
+					attributes.setAttributeValue(DEV_RAW_ZOOM, rawAutoZoom.fullZoom());
+					currentRawZoom = rawAutoZoom.fullZoom();
+
+					attributes.setAttributeValue(DEV_RAW_ZOOM, rawAutoZoom.fullZoom());
+					if (!analysis.hasData(DEV_RAW_ZOOM)) {
+						analysis.setHasData(DEV_RAW_ZOOM, true);
+					}
+				} else {
+					attributes.setAttributeValue(DEV_RAW_ZOOM, 0);
+				}
+
+				if (prevAnimatedZoomParams != null) {
+					float timeDiffMillis = attributes.timeDiff * 1000;
+					float animationTime;
+					if (prevAnimatedZoomParams.second < timeDiffMillis) {
+						float offsetN = prevAnimatedZoomParams.second / timeDiffMillis;
+						attributes.setAttributeValue(DEV_INTERPOLATION_OFFSET_N, offsetN);
+						animationTime = prevAnimatedZoomParams.second;
+					} else {
+						animationTime = timeDiffMillis;
+					}
+
+					float zoomDeltaSign = Math.signum(prevAnimatedZoomParams.first.fullZoom() - currentAnimatedZoom);
+					float zoomDelta = zoomDeltaSign * animationTime * ZOOM_PER_MILLIS;
+					currentAnimatedZoom += zoomDelta;
+
+					long leftDuration = prevAnimatedZoomParams.second - (long) animationTime;
+					prevAnimatedZoomParams = new Pair<>(prevAnimatedZoomParams.first, leftDuration);
+				}
+
+				attributes.setAttributeValue(DEV_ANIMATED_ZOOM, currentAnimatedZoom);
+				if (!analysis.hasData(DEV_ANIMATED_ZOOM)) {
+					analysis.setHasData(DEV_ANIMATED_ZOOM, true);
+				}
+
+				Pair<ComplexZoom, Long> zoomParams = autoZoomBySpeedHelper.getAnimatedZoomParamsForChart(
+						mapRenderer, currentAnimatedZoom, point.lat, point.lon, bearing, attributes.speed);
+				if (zoomParams != null) {
+					prevAnimatedZoomParams = zoomParams;
+				}
+			}
+		};
+	}
+
+	public static void addAvailableGPXDataSetTypes(@NonNull OsmandApplication app,
+			@NonNull GPXTrackAnalysis analysis,
+			@NonNull List<GPXDataSetType[]> availableTypes) {
+		if (!app.getOsmandMap().getMapView().hasMapRenderer()) {
+			return;
+		}
+
+		if (analysis.hasSpeedData()) {
+			if (analysis.hasData(DEV_RAW_ZOOM)) {
+				availableTypes.add(new GPXDataSetType[] {GPXDataSetType.ZOOM_NON_ANIMATED, GPXDataSetType.SPEED});
+			}
+			if (analysis.hasData(DEV_ANIMATED_ZOOM)) {
+				availableTypes.add(new GPXDataSetType[] {GPXDataSetType.ZOOM_ANIMATED, GPXDataSetType.SPEED});
+			}
+		}
+		if (analysis.hasData(DEV_RAW_ZOOM) && analysis.hasData(DEV_ANIMATED_ZOOM)) {
+			availableTypes.add(new GPXDataSetType[] {GPXDataSetType.ZOOM_NON_ANIMATED, GPXDataSetType.ZOOM_ANIMATED});
+		}
+	}
+
+	@Nullable
+	public static OrderedLineDataSet getOrderedLineDataSet(@NonNull OsmandApplication app,
+	                                                       @NonNull LineChart chart,
+	                                                       @NonNull GPXTrackAnalysis analysis,
+	                                                       @NonNull GPXDataSetType graphType,
+	                                                       @NonNull GPXDataSetAxisType chartAxisType,
+	                                                       boolean calcWithoutGaps,
+	                                                       boolean useRightAxis) {
+		switch (graphType) {
+			case ZOOM_NON_ANIMATED:
+				if (analysis.hasData(DEV_RAW_ZOOM)) {
+					return getZoomDataSet(app, chart, analysis, analysis.pointAttributes, graphType,
+							chartAxisType, calcWithoutGaps, useRightAxis);
+				}
+			case ZOOM_ANIMATED:
+				if (analysis.hasData(DEV_ANIMATED_ZOOM)) {
+					List<PointAttributes> processedAttributes = postProcessAttributes(analysis.pointAttributes);
+					return getZoomDataSet(app, chart, analysis, processedAttributes, graphType,
+							chartAxisType, calcWithoutGaps, useRightAxis);
+				}
+		}
+		return null;
+	}
+
+	@NonNull
+	private static OrderedLineDataSet getZoomDataSet(@NonNull OsmandApplication app,
+	                                                 @NonNull LineChart chart,
+	                                                 @NonNull GPXTrackAnalysis analysis,
+	                                                 @NonNull List<PointAttributes> pointAttributes,
+	                                                 @NonNull GPXDataSetType graphType,
+	                                                 @NonNull GPXDataSetAxisType chartAxisType,
+	                                                 boolean calcWithoutGaps,
+	                                                 boolean useRightAxis) {
+		OsmandSettings settings = app.getSettings();
+		boolean nightMode = !settings.isLightContent();
+
+		float divX = ChartUtils.getDivX(app, chart, analysis, chartAxisType, calcWithoutGaps);
+
+		List<Entry> values = ChartUtils.getPointAttributeValues(graphType.getDataKey(), pointAttributes, chartAxisType, divX, 1f, Float.NaN, calcWithoutGaps);
+		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", graphType, chartAxisType, !useRightAxis);
+		dataSet.setAxisValueFormatter((app1, value) -> OsmAndFormatter.formatValue(value, "", true, 2, app1).value);
+
+		int textColor = ColorUtilities.getColor(app, graphType.getTextColorId(false));
+		YAxis yAxis = ChartUtils.getYAxis(chart, textColor, useRightAxis);
+		yAxis.resetAxisMinimum();
+		String mainUnitY = graphType.getMainUnitY(app);
+		yAxis.setValueFormatter((value, axis) ->
+				OsmAndFormatter.formatValue(value, mainUnitY, true, 2, app).value);
+
+		dataSet.setDivX(divX);
+		dataSet.setUnits(mainUnitY);
+
+		int color = ColorUtilities.getColor(app, graphType.getFillColorId(false));
+		ChartUtils.setupDataSet(app, dataSet, color, color, true, false, useRightAxis, nightMode);
+
+		return dataSet;
+	}
+
+	@NonNull
+	private static List<PointAttributes> postProcessAttributes(@NonNull List<PointAttributes> originalAttributes) {
+		List<PointAttributes> result = new ArrayList<>();
+
+		for (PointAttributes original : originalAttributes) {
+			float offsetN = original.interpolationOffsetN;
+			if (offsetN > 0) {
+				PointAttributes intermediateAttribute = new PointAttributes(
+						original.distance * offsetN,
+						original.timeDiff * offsetN,
+						original.firstPoint,
+						false);
+				intermediateAttribute.animatedZoom = original.animatedZoom;
+
+				PointAttributes modifiedAttribute = new PointAttributes(
+						original.distance * (1.0f - offsetN),
+						original.timeDiff * (1.0f - offsetN),
+						false,
+						original.lastPoint);
+				modifiedAttribute.animatedZoom = original.animatedZoom;
+
+				result.add(intermediateAttribute);
+				result.add(modifiedAttribute);
+			} else {
+				result.add(original);
+			}
+		}
+
+		return result;
+	}
+
+	private static class LocationsFilter {
+
+		private float speedToFilter = Float.NaN;
+		private float currentSpeed = Float.NaN;
+
+		public float getFilteredSpeed(float speed) {
+			float oldSpeed = speedToFilter;
+			speedToFilter = currentSpeed;
+			currentSpeed = speed;
+
+			if (Float.isNaN(oldSpeed)) {
+				return speedToFilter;
+			} else {
+				boolean monotonous = currentSpeed >= speedToFilter && speedToFilter >= oldSpeed
+						|| currentSpeed <= speedToFilter && speedToFilter <= oldSpeed;
+				return monotonous ? speedToFilter : Float.NaN;
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/AutoZoomBySpeedUtils.java b/OsmAnd/src/net/osmand/plus/views/AutoZoomBySpeedUtils.java
deleted file mode 100644
index d682ed6fb01..00000000000
--- a/OsmAnd/src/net/osmand/plus/views/AutoZoomBySpeedUtils.java
+++ /dev/null
@@ -1,253 +0,0 @@
-package net.osmand.plus.views;
-
-import com.github.mikephil.charting.charts.LineChart;
-import com.github.mikephil.charting.components.YAxis;
-import com.github.mikephil.charting.data.Entry;
-
-import net.osmand.core.android.MapRendererView;
-import net.osmand.data.RotatedTileBox;
-import net.osmand.gpx.GPXTrackAnalysis;
-import net.osmand.gpx.GPXTrackAnalysis.TrackPointsAnalyser;
-import net.osmand.gpx.PointAttributes;
-import net.osmand.plus.OsmandApplication;
-import net.osmand.plus.charts.ChartUtils;
-import net.osmand.plus.charts.GPXDataSetAxisType;
-import net.osmand.plus.charts.GPXDataSetType;
-import net.osmand.plus.charts.OrderedLineDataSet;
-import net.osmand.plus.settings.backend.OsmandSettings;
-import net.osmand.plus.settings.enums.AutoZoomMap;
-import net.osmand.plus.utils.ColorUtilities;
-import net.osmand.plus.utils.OsmAndFormatter;
-import net.osmand.plus.views.Zoom.ComplexZoom;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-public class AutoZoomBySpeedUtils {
-
-	public static final float ZOOM_PER_SECOND = 0.1f;
-	public static final int MIN_ZOOM_DURATION_MILLIS = 1500;
-	public static final long FIXED_ZOOM_DURATION_MILLIS = 1000;
-	private static final int SHOW_DRIVING_SECONDS = 60;
-
-	@Nullable
-	public static ComplexZoom calculateAutoZoomBySpeed(@NonNull OsmandApplication app, @NonNull RotatedTileBox tb, float speed) {
-		OsmandSettings settings = app.getSettings();
-
-		float zoomProximityCoeff = settings.AUTO_ZOOM_MAP_SCALE.get().coefficient;
-		float zoomDelta = defineZoomFromSpeed(tb, speed, zoomProximityCoeff);
-		if (Math.abs(zoomDelta) < 0.5) {
-			return null;
-		}
-
-		if (zoomDelta >= 2) {
-			zoomDelta -= 1;
-		} else if (zoomDelta <= -2) {
-			zoomDelta += 1;
-		}
-		double targetZoom = Math.min(tb.getZoom() + tb.getZoomFloatPart() + zoomDelta, settings.AUTO_ZOOM_MAP_SCALE.get().maxZoom);
-		targetZoom = Math.round(targetZoom * 3) / 3f;
-		int newIntegerZoom = (int) Math.round(targetZoom);
-		float zPart = (float) (targetZoom - newIntegerZoom);
-		return newIntegerZoom > 0 ? new ComplexZoom(newIntegerZoom, zPart) : null;
-	}
-
-	private static float defineZoomFromSpeed(@NonNull RotatedTileBox tb, float speed, float zoomProximityCoeff) {
-		if (speed < 7f / 3.6) {
-			return 0;
-		}
-		double visibleDist = tb.getDistance(tb.getCenterPixelX(), 0, tb.getCenterPixelX(), tb.getCenterPixelY());
-		float time = speed < 83f / 3.6 ? 60 : 75;
-		double distToSee = speed * time / zoomProximityCoeff;
-		float currentZoom = (float) (tb.getZoom() + tb.getZoomFloatPart() + tb.getZoomAnimation());
-		return Zoom.fromDistanceRatio(visibleDist, distToSee, currentZoom);
-	}
-
-	@Nullable
-	public static ComplexZoom autoZoomBySpeed(@NonNull OsmandApplication app, @NonNull RotatedTileBox tileBox, float speed) {
-		if (speed < 7 / 3.6) {
-			return null;
-		}
-
-		OsmandMapTileView mapView = app.getOsmandMap().getMapView();
-
-		AutoZoomMap autoZoomScale = app.getSettings().AUTO_ZOOM_MAP_SCALE.get();
-		double visibleDist = tileBox.getDistance(tileBox.getCenterPixelX(), 0, tileBox.getCenterPixelX(), tileBox.getCenterPixelY());
-		float distanceToDrive = speed * SHOW_DRIVING_SECONDS / autoZoomScale.coefficient;
-		float currentZoom = (float) (tileBox.getZoom() + tileBox.getZoomFloatPart() + tileBox.getZoomAnimation());
-		float expectedZoom = Zoom.fromDistanceRatio(visibleDist, distanceToDrive, currentZoom);
-
-		int minZoom = mapView.getMinZoom();
-		int maxZoom = Math.min(mapView.getMaxZoom(), autoZoomScale.maxZoom);
-		Zoom boundedZoom = Zoom.checkZoomBounds(expectedZoom, minZoom, maxZoom);
-		return new ComplexZoom(boundedZoom.getBaseZoom(), boundedZoom.getZoomFloatPart());
-	}
-
-	@Nullable
-	public static TrackPointsAnalyser getTrackPointsAnalyser(@NonNull OsmandApplication app) {
-		OsmandMapTileView mapView = app.getOsmandMap().getMapView();
-		MapRendererView mapRenderer = mapView.getMapRenderer();
-		RotatedTileBox tileBox = mapView.getRotatedTileBox();
-
-		if (mapRenderer == null) {
-			return null;
-		}
-
-		return (analysis, point, attributes) -> {
-			ComplexZoom autoZoom = AutoZoomBySpeedUtils.autoZoomBySpeed(app, tileBox, attributes.speed);
-
-			if (autoZoom != null) {
-				tileBox.setZoomAndAnimation(autoZoom.base, 0.0, autoZoom.floatPart);
-			}
-
-			float expectedZoom = (float) (tileBox.getZoom() + tileBox.getZoomFloatPart() + tileBox.getZoomAnimation());
-			attributes.setAttributeValue(PointAttributes.DEV_ZOOM, expectedZoom);
-			if (!analysis.hasData(PointAttributes.DEV_ZOOM)) {
-				analysis.setHasData(PointAttributes.DEV_ZOOM, true);
-			}
-		};
-	}
-
-	public static void addAvailableGPXDataSetTypes(@NonNull OsmandApplication app,
-			@NonNull GPXTrackAnalysis analysis,
-			@NonNull List<GPXDataSetType[]> availableTypes) {
-		boolean cameraElevationAvailable = app.getOsmandMap().getMapView().hasMapRenderer()
-				&& analysis.hasData(PointAttributes.DEV_ZOOM);
-		if (cameraElevationAvailable) {
-			if (analysis.hasSpeedData()) {
-				availableTypes.add(new GPXDataSetType[] {GPXDataSetType.ZOOM_NON_ANIMATED, GPXDataSetType.SPEED});
-				availableTypes.add(new GPXDataSetType[] {GPXDataSetType.ZOOM_ANIMATED, GPXDataSetType.SPEED});
-			}
-			availableTypes.add(new GPXDataSetType[] {GPXDataSetType.ZOOM_NON_ANIMATED, GPXDataSetType.ZOOM_ANIMATED});
-		}
-	}
-
-	@Nullable
-	public static OrderedLineDataSet getOrderedLineDataSet(@NonNull OsmandApplication app,
-	                                                       @NonNull LineChart chart,
-	                                                       @NonNull GPXTrackAnalysis analysis,
-	                                                       @NonNull GPXDataSetType graphType,
-	                                                       @NonNull GPXDataSetAxisType chartAxisType,
-	                                                       boolean calcWithoutGaps,
-	                                                       boolean useRightAxis) {
-		switch (graphType) {
-			case ZOOM_NON_ANIMATED:
-				if (analysis.hasData(PointAttributes.DEV_ZOOM)) {
-					return getZoomDataSet(app, chart, analysis, analysis.pointAttributes, graphType,
-							chartAxisType, calcWithoutGaps, useRightAxis);
-				}
-			case ZOOM_ANIMATED:
-				if (analysis.hasData(PointAttributes.DEV_ZOOM)) {
-					List<PointAttributes> animatedAttributes = simulateZoomAttributesAnimation(analysis.pointAttributes);
-					return getZoomDataSet(app, chart, analysis, animatedAttributes, graphType,
-							chartAxisType, calcWithoutGaps, useRightAxis);
-				}
-		}
-		return null;
-	}
-
-	@NonNull
-	private static OrderedLineDataSet getZoomDataSet(@NonNull OsmandApplication app,
-	                                                 @NonNull LineChart chart,
-	                                                 @NonNull GPXTrackAnalysis analysis,
-	                                                 @NonNull List<PointAttributes> pointAttributes,
-	                                                 @NonNull GPXDataSetType graphType,
-	                                                 @NonNull GPXDataSetAxisType chartAxisType,
-	                                                 boolean calcWithoutGaps,
-	                                                 boolean useRightAxis) {
-		OsmandSettings settings = app.getSettings();
-		boolean nightMode = !settings.isLightContent();
-
-		float divX = ChartUtils.getDivX(app, chart, analysis, chartAxisType, calcWithoutGaps);
-
-		List<Entry> values = ChartUtils.getPointAttributeValues(graphType.getDataKey(), pointAttributes, chartAxisType, divX, 1f, Float.NaN, calcWithoutGaps);
-		OrderedLineDataSet dataSet = new OrderedLineDataSet(values, "", graphType, chartAxisType, !useRightAxis);
-		dataSet.setAxisValueFormatter((app1, value) -> OsmAndFormatter.formatValue(value, "", true, 2, app1).value);
-
-		int textColor = ColorUtilities.getColor(app, graphType.getTextColorId(false));
-		YAxis yAxis = ChartUtils.getYAxis(chart, textColor, useRightAxis);
-		yAxis.resetAxisMinimum();
-		String mainUnitY = graphType.getMainUnitY(app);
-		yAxis.setValueFormatter((value, axis) ->
-				OsmAndFormatter.formatValue(value, mainUnitY, true, 2, app).value);
-
-		dataSet.setDivX(divX);
-		dataSet.setUnits(mainUnitY);
-
-		int color = ColorUtilities.getColor(app, graphType.getFillColorId(false));
-		ChartUtils.setupDataSet(app, dataSet, color, color, true, false, useRightAxis, nightMode);
-
-		return dataSet;
-	}
-
-	@NonNull
-	private static List<PointAttributes> simulateZoomAttributesAnimation(@NonNull List<PointAttributes> original) {
-		List<PointAttributes> result = new ArrayList<>();
-
-		float currentZoom = original.get(0).zoom;
-		PointAttributes overridenCurrentAttribute = null;
-
-		for (int i = 1; i < original.size(); i++) {
-			PointAttributes currentAttributes = overridenCurrentAttribute != null
-					? overridenCurrentAttribute
-					: original.get(i);
-			overridenCurrentAttribute = null;
-
-			float zoomToAnimate = currentAttributes.zoom;
-
-			PointAttributes currentAnimatedAttributes = new PointAttributes(
-					currentAttributes.distance,
-					currentAttributes.timeDiff,
-					currentAttributes.firstPoint,
-					currentAttributes.lastPoint
-			);
-			currentAnimatedAttributes.zoom = currentZoom;
-			result.add(currentAnimatedAttributes);
-
-			if (i + 1 == original.size()) {
-				break;
-			}
-
-			PointAttributes nextAttributes = original.get(i + 1);
-
-			float zoomDelta = zoomToAnimate - currentZoom;
-			float secondsToZoom = Math.abs(zoomDelta) / ZOOM_PER_SECOND;
-
-			if (secondsToZoom * 1000f < MIN_ZOOM_DURATION_MILLIS) {
-				continue;
-			}
-
-			float allowedZoomDelta = ZOOM_PER_SECOND * nextAttributes.timeDiff;
-
-			if (Math.abs(zoomDelta) < allowedZoomDelta) {
-				float offsetN = secondsToZoom / nextAttributes.timeDiff;
-
-				PointAttributes intermediateAttribute = new PointAttributes(
-						nextAttributes.distance * offsetN,
-						secondsToZoom,
-						nextAttributes.firstPoint,
-						false
-				);
-				intermediateAttribute.zoom = zoomToAnimate;
-				result.add(intermediateAttribute);
-
-				overridenCurrentAttribute = new PointAttributes(
-						nextAttributes.distance * (1.0f - offsetN),
-						nextAttributes.timeDiff - secondsToZoom,
-						false,
-						nextAttributes.lastPoint
-				);
-				overridenCurrentAttribute.zoom = nextAttributes.zoom;
-
-				currentZoom = zoomToAnimate;
-			} else {
-				currentZoom += Math.signum(zoomDelta) * Math.min(Math.abs(zoomDelta), allowedZoomDelta);
-			}
-		}
-
-		return result;
-	}
-}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/WidgetsVisibilityHelper.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/WidgetsVisibilityHelper.java
index b968a6d909b..e228e2b1887 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/WidgetsVisibilityHelper.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/WidgetsVisibilityHelper.java
@@ -48,7 +48,7 @@ public WidgetsVisibilityHelper(@NonNull MapActivity mapActivity) {
 	public boolean shouldShowQuickActionButton() {
 		return isQuickActionLayerOn()
 				&& !isInConfigureMapOptionMode()
-				&& shouldShowFabButton();
+				&& true;
 	}
 
 	public boolean shouldShowMap3DButton() {
