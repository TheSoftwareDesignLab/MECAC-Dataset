diff --git a/OsmAnd/res/values/styles.xml b/OsmAnd/res/values/styles.xml
index 330191c0e6f..009a9d90b5c 100644
--- a/OsmAnd/res/values/styles.xml
+++ b/OsmAnd/res/values/styles.xml
@@ -7,4 +7,4 @@
     <item name="android:windowContentOverlay">@null</item>
     <item name="android:backgroundDimEnabled">false</item>
 </style> 
-</resources>
+</resources>
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
index 8f5091c12e3..debed015395 100644
--- a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
+++ b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
@@ -5,7 +5,11 @@
 
 import org.apache.commons.logging.Log;
 
+import android.os.SystemClock;
 import android.util.FloatMath;
+import android.view.animation.AccelerateDecelerateInterpolator;
+import android.view.animation.DecelerateInterpolator;
+import android.view.animation.LinearInterpolator;
 
 /**
  * Thread for animated dragging.
@@ -70,7 +74,9 @@ public interface AnimateDraggingCallback {
 	@Override
 	public void run() {
 		currentThread = Thread.currentThread();
+		AccelerateDecelerateInterpolator interpolator = new AccelerateDecelerateInterpolator();
 		try {
+			
 			boolean conditionToCountinue = true;
 			while (!stopped && conditionToCountinue) {
 				// calculate sleep
@@ -159,11 +165,11 @@ public void run() {
 			conditionToCountinue = true;
 			while (conditionToCountinue && callback != null) {
 				conditionToCountinue = false;
-				float rotationDiff = targetRotate-callback.getRotate();
-				if (Math.abs((rotationDiff+360)%360) < Math.abs((rotationDiff-360)%360)) {
-					rotationDiff = (rotationDiff+360)%360;
+				float rotationDiff = targetRotate - callback.getRotate();
+				if (Math.abs((rotationDiff + 360) % 360) < Math.abs((rotationDiff - 360) % 360)) {
+					rotationDiff = (rotationDiff + 360) % 360;
 				} else {
-					rotationDiff = (rotationDiff-360)%360;
+					rotationDiff = (rotationDiff - 360) % 360;
 				}
 				float absDiff = Math.abs(rotationDiff);
 				if (absDiff > 0) {
@@ -172,7 +178,7 @@ public void run() {
 						callback.rotateTo(targetRotate);
 					} else {
 						conditionToCountinue = true;
-						callback.rotateTo(((absDiff/10)*Math.signum(rotationDiff) + callback.getRotate())%360);
+						callback.rotateTo(((absDiff / 10) * Math.signum(rotationDiff) + callback.getRotate()) % 360);
 					}
 				}
 			}
@@ -285,32 +291,63 @@ public void startMoving(double curLat, double curLon, double finalLat, double fi
 		thread.start();
 	}
 	
-	public void startDragging(float velocityX, float velocityY, float  startX, float  startY, float  endX, float  endY){
+	public void startDragging(final float velocityX, final float velocityY, float startX, float startY, 
+			final float  endX, final float  endY){
 		stopAnimatingSync();
-		targetZoom = 0;
 		this.notifyListener = true;
-		vx = velocityX;
-		vy = velocityY;
-		dirX = (byte) (endX > startX ? 1 : -1);
-		dirY = (byte) (endY > startY ? 1 : -1);
-		animateDrag = true;
-		ax = vx * a;
-		ay = vy * a;
-		time = System.currentTimeMillis();
 		stopped = false;
-		Thread thread = new Thread(this,"Animatable dragging"); //$NON-NLS-1$
+		final float animationTime = 1900f;
+		System.out.println("Velocity x " +  velocityX + " velocity Y " + velocityY);
+		
+		Thread thread = new Thread(new Runnable(){
+			@Override
+			public void run() {
+				float curX = endX;
+				float curY = endY;
+				
+				DecelerateInterpolator interpolator = new DecelerateInterpolator(1);
+				
+				long timeMillis = SystemClock.uptimeMillis();
+				float normalizedTime = 0f;
+				float prevNormalizedTime = 0f;
+				while(!stopped){
+					normalizedTime = (SystemClock.uptimeMillis() - timeMillis) / animationTime; 
+					if(normalizedTime >= 1f){
+						break;
+					}
+					float interpolation = interpolator.getInterpolation(normalizedTime);
+					
+					float newX = velocityX * (1 - interpolation) * (normalizedTime - prevNormalizedTime) + curX;
+					float newY = velocityY * (1 - interpolation) * (normalizedTime - prevNormalizedTime) + curY;
+					
+					callback.dragTo(curX, curY, newX, newY, notifyListener);
+					curX = newX;
+					curY = newY;
+					prevNormalizedTime = normalizedTime;
+					try {
+						Thread.sleep(50);
+					} catch (InterruptedException e) {
+						stopped = true;
+					}
+				}
+				
+				if(!stopped){
+					
+				}
+				
+			}
+		},"Animatable dragging"); //$NON-NLS-1$
 		thread.start();
 	}
 	
-	public void startRotate(float rotate)
-	{
+	public void startRotate(float rotate) {
 		this.targetRotate = rotate;
 		if (!isAnimating()) {
-			//stopped = false;
-			//do we need to kill and recreate the thread? wait would be enough as now it
-			//also handles the rotation?
-			Thread thread = new Thread(this,"Animatable dragging"); //$NON-NLS-1$
-			thread.start();			
+			// stopped = false;
+			// do we need to kill and recreate the thread? wait would be enough as now it
+			// also handles the rotation?
+			Thread thread = new Thread(this, "Animatable dragging"); //$NON-NLS-1$
+			thread.start();
 		}
 	}
 	
diff --git a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
index b287484141c..58b3a21acf5 100644
--- a/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
+++ b/OsmAnd/src/net/osmand/plus/views/OsmandMapTileView.java
@@ -421,7 +421,7 @@ public OsmandSettings getSettings(){
 	private void refreshMapInternal() {
 		handler.removeMessages(1);
 		
-		long time = System.currentTimeMillis();
+		// long time = System.currentTimeMillis();
 
 		boolean useInternet = getSettings().USE_INTERNET_TO_DOWNLOAD_TILES.get();
 		if (useInternet) {
@@ -439,7 +439,6 @@ private void refreshMapInternal() {
 			Canvas canvas = holder.lockCanvas();
 			if (canvas != null) {
 				boolean nightMode = false;
-				log.info("Canvas " + (System.currentTimeMillis() - time));
 				if (application != null) {
 					Boolean dayNightRenderer = application.getDaynightHelper().getDayNightRenderer();
 					if (dayNightRenderer != null) {
@@ -455,7 +454,6 @@ private void refreshMapInternal() {
 					latlonRect.left = (float) MapUtils.getLongitudeFromTile(nzoom, tilesRect.left);
 					latlonRect.bottom = (float) MapUtils.getLatitudeFromTile(nzoom, tilesRect.bottom);
 					latlonRect.right = (float) MapUtils.getLongitudeFromTile(nzoom, tilesRect.right);
-					log.info("Calc" + (System.currentTimeMillis() - time));
 					if(nightMode){
 						canvas.drawARGB(255, 220, 220, 220);
 					} else {
@@ -472,11 +470,9 @@ private void refreshMapInternal() {
 //							drawEmptyTile(canvas, x1, y1, ftileSize, nightMode);
 //						}
 //					}
-					log.info("Draw before layers" + (System.currentTimeMillis() - time));
-					
 					drawOverMap(canvas, latlonRect, tilesRect, nightMode);
 					
-					log.info("Draw with layers " + (System.currentTimeMillis() - time));
+//					log.info("Draw with layers " + (System.currentTimeMillis() - time));
 				} finally {
 					holder.unlockCanvasAndPost(canvas);
 				}
@@ -752,8 +748,8 @@ public boolean onDown(MotionEvent e) {
 		@Override
 		public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
 			if (Math.abs(e1.getX() - e2.getX()) + Math.abs(e1.getX() - e2.getX()) > 50 * dm.density) {
-				animatedDraggingThread.startDragging(Math.abs(velocityX / 1000), Math.abs(velocityY / 1000), e1.getX(), e1.getY(), e2
-						.getX(), e2.getY());
+				animatedDraggingThread.startDragging(velocityX, velocityY, 
+						e1.getX(), e1.getY(), e2.getX(), e2.getY());
 			} else {
 				onScroll(e1, e2, e1.getX() - e2.getX(), e1.getY() - e2.getY());
 			}
