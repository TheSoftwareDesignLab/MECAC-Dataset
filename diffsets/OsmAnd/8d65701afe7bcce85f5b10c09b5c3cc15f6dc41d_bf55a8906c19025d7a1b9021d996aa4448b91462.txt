diff --git a/OsmAnd-java/src/main/java/net/osmand/map/OsmandRegions.java b/OsmAnd-java/src/main/java/net/osmand/map/OsmandRegions.java
index f014a4fc8b3..5dfa0f6d7fe 100644
--- a/OsmAnd-java/src/main/java/net/osmand/map/OsmandRegions.java
+++ b/OsmAnd-java/src/main/java/net/osmand/map/OsmandRegions.java
@@ -190,8 +190,39 @@ public String getLocaleNameByFullName(String fullName, boolean includingParent)
 			}
 			if (parentParent.getRegionId().equals(WorldRegion.JAPAN_REGION_ID)) {
 				return parentParent.getLocaleName() + " " + rd.getLocaleName();
+			} else {
+				return parent.getLocaleName() + " " + rd.getLocaleName();
+			}
+		} else {
+			return rd.getLocaleName();
+		}
+	}
+
+	public String getSuggestedDownloadMapName(String downloadName) {
+		final String lc = downloadName.toLowerCase();
+		if (downloadNamesToFullNames.containsKey(lc)) {
+			String fullName = downloadNamesToFullNames.get(lc);
+			return getSuggestedMapsName(fullName);
+		}
+		return downloadName.replace('_', ' ');
+	}
+
+	public String getSuggestedMapsName(String fullName) {
+		WorldRegion rd = fullNamesToRegionData.get(fullName);
+		if (rd == null) {
+			return fullName.replace('_', ' ');
+		}
+		if (rd.getSuperregion() != null && rd.getSuperregion().getSuperregion() != null) {
+			WorldRegion parentParent = rd.getSuperregion().getSuperregion();
+			WorldRegion parent = rd.getSuperregion();
+			if (parentParent.getRegionId().equals(WorldRegion.RUSSIA_REGION_ID)) {
+				return rd.getLocaleName() + ", " + parentParent.getLocaleName();
+			}
+			if (parentParent.getRegionId().equals(WorldRegion.JAPAN_REGION_ID)) {
+				return rd.getLocaleName() + ", " + parentParent.getLocaleName();
+			} else {
+				return rd.getLocaleName() + ", " + parent.getLocaleName();
 			}
-			return parent.getLocaleName() + " " + rd.getLocaleName();
 		} else {
 			return rd.getLocaleName();
 		}
diff --git a/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java b/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java
index 3709a257ff6..86811a5db33 100644
--- a/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java
+++ b/OsmAnd-java/src/main/java/net/osmand/util/MapUtils.java
@@ -1,9 +1,5 @@
 package net.osmand.util;
 
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-
 import net.osmand.Location;
 import net.osmand.data.LatLon;
 import net.osmand.data.MapObject;
@@ -11,8 +7,17 @@
 import net.osmand.data.QuadRect;
 import net.osmand.util.GeoPointParserUtil.GeoParsedPoint;
 
-import static com.jwetherell.openmap.common.MoreMath.QUAD_PI;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
 import static com.jwetherell.openmap.common.MoreMath.QUAD_PI_D;
+import static java.lang.Math.PI;
+import static java.lang.Math.asin;
+import static java.lang.Math.atan2;
+import static java.lang.Math.cos;
+import static java.lang.Math.sin;
+import static java.lang.Math.toDegrees;
 
 
 /**
@@ -751,4 +756,17 @@ public static double getSqrtDistance(int startX, int startY, int endX, int endY)
 	public static double getSqrtDistance(float startX, float startY, float endX, float endY) {
 		return Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY));
 	}
+
+	//Looks like a method rhumbDestinationPoint. The result is also looks the same, for example: 19983.254 and 19983.266. Please, choose better method.
+	public static LatLon findPointAtDistanceFrom(double latitude, double longitude, double distanceInMetres, double bearing) {
+		double bearingRad = toRadians(bearing);
+		double latRad = toRadians(latitude);
+		double lonRad = toRadians(longitude);
+		double distFraction = distanceInMetres / EARTH_RADIUS_A;
+
+		double latitudeResult = asin(sin(latRad) * cos(distFraction) + cos(latRad) * sin(distFraction) * cos(bearingRad));
+		double a = atan2(sin(bearingRad) * sin(distFraction) * cos(latRad), cos(distFraction) - sin(latRad) * sin(latitudeResult));
+		double longitudeResult = (lonRad + a + 3 * PI) % (2 * PI) - PI;
+		return new LatLon(toDegrees(latitudeResult), toDegrees(longitudeResult));
+	}
 }
\ No newline at end of file
diff --git a/OsmAnd/res/values/strings.xml b/OsmAnd/res/values/strings.xml
index b39b295e02d..f1a5c2fc409 100644
--- a/OsmAnd/res/values/strings.xml
+++ b/OsmAnd/res/values/strings.xml
@@ -12,6 +12,10 @@
 
 -->
 
+    <string name="online_maps__required_descr">The calculation of the route takes more than usual. Perhaps some cards are not loaded. You can run online checking the necessary cards.</string>
+    <string name="offline_maps_required_descr">Additional offline maps are required to calculate the route.</string>
+    <string name="online_direct_line_maps_link">Check the necessary maps</string>
+    <string name="direct_line_maps_required_descr">Perhaps some cards are not loaded.</string>
     <string name="verification_code_missing_description">Waiting time for code can be 10 minutes, also you can check your spam folder. If it doesn\'t help, use button below.</string>
     <string name="verification_code_missing">I didn\'t receive verification code</string>
     <string name="resend_verification_code">Resend code</string>
diff --git a/OsmAnd/src/net/osmand/plus/activities/MapActivity.java b/OsmAnd/src/net/osmand/plus/activities/MapActivity.java
index ec1b66b585f..4527cd683c5 100644
--- a/OsmAnd/src/net/osmand/plus/activities/MapActivity.java
+++ b/OsmAnd/src/net/osmand/plus/activities/MapActivity.java
@@ -126,6 +126,7 @@
 import net.osmand.plus.routepreparationmenu.MapRouteInfoMenu;
 import net.osmand.plus.routepreparationmenu.MapRouteInfoMenuFragment;
 import net.osmand.plus.routing.IRouteInformationListener;
+import net.osmand.plus.routing.RouteCalculationParams;
 import net.osmand.plus.routing.RouteCalculationProgressCallback;
 import net.osmand.plus.routing.RoutingHelper;
 import net.osmand.plus.routing.TransportRoutingHelper.TransportRouteCalculationProgressCallback;
@@ -586,6 +587,11 @@ public void onClick(DialogInterface dialog, int which) {
 				}
 			}
 
+			@Override
+			public void updateMissingMaps(RouteCalculationParams params) {
+				mapRouteInfoMenu.updateMissingMapsOnDirectLine(params);
+			}
+
 			@Override
 			public void finish() {
 				mapRouteInfoMenu.routeCalculationFinished();
diff --git a/OsmAnd/src/net/osmand/plus/download/DownloadActivityType.java b/OsmAnd/src/net/osmand/plus/download/DownloadActivityType.java
index c5c4dab186f..c0a4cb162b6 100644
--- a/OsmAnd/src/net/osmand/plus/download/DownloadActivityType.java
+++ b/OsmAnd/src/net/osmand/plus/download/DownloadActivityType.java
@@ -10,7 +10,6 @@
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.Version;
-import net.osmand.plus.activities.LocalIndexInfo;
 import net.osmand.plus.helpers.FileNameTranslationHelper;
 import net.osmand.util.Algorithms;
 
@@ -28,7 +27,6 @@
 import java.util.Map;
 
 import static net.osmand.IndexConstants.BINARY_MAP_INDEX_EXT;
-import static net.osmand.plus.activities.LocalIndexHelper.LocalIndexType.SRTM_DATA;
 
 public class DownloadActivityType {
 	private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat("dd.MM.yyyy", Locale.US);
@@ -390,6 +388,16 @@ public String getVisibleName(DownloadItem downloadItem, Context ctx, OsmandRegio
 		return osmandRegions.getLocaleName(basename, includingParent);
 	}
 
+	public String getSuggestedMapsName (DownloadItem downloadItem, Context ctx, OsmandRegions osmandRegions) {
+		final String basename = getBasename(downloadItem);
+		final String lc = basename.toLowerCase();
+		String std = FileNameTranslationHelper.getStandardMapName(ctx, lc);
+		if (std != null) {
+			return std;
+		}
+		return osmandRegions.getSuggestedDownloadMapName(basename);
+	}
+
 	public String getTargetFileName(IndexItem item) {
 		String fileName = item.fileName;
 		// if(fileName.endsWith(IndexConstants.VOICE_INDEX_EXT_ZIP) ||
diff --git a/OsmAnd/src/net/osmand/plus/download/DownloadItem.java b/OsmAnd/src/net/osmand/plus/download/DownloadItem.java
index 6b758f8af8d..2c9f322e5b1 100644
--- a/OsmAnd/src/net/osmand/plus/download/DownloadItem.java
+++ b/OsmAnd/src/net/osmand/plus/download/DownloadItem.java
@@ -52,6 +52,10 @@ public String getVisibleDescription(OsmandApplication ctx) {
 		return type.getVisibleDescription(this, ctx);
 	}
 
+	public String getVisibleMapsName(Context ctx, OsmandRegions osmandRegions) {
+		return type.getSuggestedMapsName(this, ctx, osmandRegions);
+	}
+
 	@NonNull
 	public String getBasename() {
 		return type.getBasename(this);
@@ -63,7 +67,7 @@ public String getBasename() {
 	@Nullable
 	public abstract String getAdditionalDescription(Context ctx);
 
-	protected abstract double getSizeToDownloadInMb();
+	public abstract double getSizeToDownloadInMb();
 
 	public abstract double getArchiveSizeMB();
 
diff --git a/OsmAnd/src/net/osmand/plus/download/IndexItem.java b/OsmAnd/src/net/osmand/plus/download/IndexItem.java
index 4f12d032dc0..03f162ff581 100644
--- a/OsmAnd/src/net/osmand/plus/download/IndexItem.java
+++ b/OsmAnd/src/net/osmand/plus/download/IndexItem.java
@@ -94,7 +94,7 @@ public double getArchiveSizeMB() {
 	}
 
 	@Override
-	protected double getSizeToDownloadInMb() {
+	public double getSizeToDownloadInMb() {
 		return Algorithms.parseDoubleSilently(size, 0.0);
 	}
 
diff --git a/OsmAnd/src/net/osmand/plus/download/SrtmDownloadItem.java b/OsmAnd/src/net/osmand/plus/download/SrtmDownloadItem.java
index 217b9eb0eea..cd16a795306 100644
--- a/OsmAnd/src/net/osmand/plus/download/SrtmDownloadItem.java
+++ b/OsmAnd/src/net/osmand/plus/download/SrtmDownloadItem.java
@@ -67,7 +67,7 @@ public IndexItem getDefaultIndexItem() {
 	}
 
 	@Override
-	protected double getSizeToDownloadInMb() {
+	public double getSizeToDownloadInMb() {
 		return getIndexItem().getSizeToDownloadInMb();
 	}
 
diff --git a/OsmAnd/src/net/osmand/plus/mapmarkers/MarkersPlanRouteContext.java b/OsmAnd/src/net/osmand/plus/mapmarkers/MarkersPlanRouteContext.java
index 2060140d3df..d5a470305c1 100644
--- a/OsmAnd/src/net/osmand/plus/mapmarkers/MarkersPlanRouteContext.java
+++ b/OsmAnd/src/net/osmand/plus/mapmarkers/MarkersPlanRouteContext.java
@@ -240,6 +240,11 @@ public void requestPrivateAccessRouting() {
 
 			}
 
+			@Override
+			public void updateMissingMaps(RouteCalculationParams params) {
+
+			}
+
 			@Override
 			public void finish() {
 				calculatedPairs = 0;
diff --git a/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java b/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java
index 7d5b7fbec2b..b0ce4695863 100644
--- a/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java
+++ b/OsmAnd/src/net/osmand/plus/measurementtool/MeasurementEditingContext.java
@@ -986,6 +986,11 @@ public void updateProgress(int progress) {
 			public void requestPrivateAccessRouting() {
 			}
 
+			@Override
+			public void updateMissingMaps(RouteCalculationParams params) {
+
+			}
+
 			@Override
 			public void finish() {
 				calculatedPairs = 0;
diff --git a/OsmAnd/src/net/osmand/plus/routepreparationmenu/MapRouteInfoMenu.java b/OsmAnd/src/net/osmand/plus/routepreparationmenu/MapRouteInfoMenu.java
index e57dec6080c..89b8f7b957f 100644
--- a/OsmAnd/src/net/osmand/plus/routepreparationmenu/MapRouteInfoMenu.java
+++ b/OsmAnd/src/net/osmand/plus/routepreparationmenu/MapRouteInfoMenu.java
@@ -48,6 +48,7 @@
 import net.osmand.data.PointDescription;
 import net.osmand.data.QuadRect;
 import net.osmand.data.RotatedTileBox;
+import net.osmand.map.WorldRegion;
 import net.osmand.plus.FavouritesDbHelper;
 import net.osmand.plus.FavouritesDbHelper.FavoritesListener;
 import net.osmand.plus.GeocodingLookupService;
@@ -97,12 +98,15 @@
 import net.osmand.plus.routepreparationmenu.cards.PublicTransportNotFoundSettingsWarningCard;
 import net.osmand.plus.routepreparationmenu.cards.PublicTransportNotFoundWarningCard;
 import net.osmand.plus.routepreparationmenu.cards.SimpleRouteCard;
+import net.osmand.plus.routepreparationmenu.cards.SuggestionsMapsDownloadWarningCard;
 import net.osmand.plus.routepreparationmenu.cards.TracksCard;
 import net.osmand.plus.routing.GPXRouteParams.GPXRouteParamsBuilder;
 import net.osmand.plus.routing.IRouteInformationListener;
+import net.osmand.plus.routing.RouteCalculationParams;
 import net.osmand.plus.routing.RouteCalculationResult;
 import net.osmand.plus.routing.RoutingHelper;
 import net.osmand.plus.routing.RoutingHelperUtils;
+import net.osmand.plus.routing.SuggestionsMapsProvider;
 import net.osmand.plus.routing.TransportRoutingHelper;
 import net.osmand.plus.search.QuickSearchHelper;
 import net.osmand.plus.settings.backend.ApplicationMode;
@@ -130,6 +134,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -193,6 +198,13 @@ public class MapRouteInfoMenu implements IRouteInformationListener, CardListener
 	private boolean editButtonCollapsed;
 	private boolean addButtonCollapsing;
 	private boolean addButtonCollapsed;
+	private boolean isMapsNeededRouteCalculationStopped;
+
+	public List<WorldRegion> getMissingMapsOnDirectLine() {
+		return missingMapsOnDirectLine;
+	}
+
+	private List<WorldRegion> missingMapsOnDirectLine;
 
 	private interface OnButtonCollapsedListener {
 		void onButtonCollapsed(boolean success);
@@ -506,6 +518,17 @@ public void openMenuFullScreen() {
 		}
 	}
 
+	public void updateMissingMapsOnDirectLine(RouteCalculationParams params) {
+		try {
+			SuggestionsMapsProvider suggestionsMapsProvider = new SuggestionsMapsProvider(params);
+			LinkedList<Location> points = suggestionsMapsProvider.getStartFinishIntermediatesPoints("");
+			List<Location> pointsStraightLine = suggestionsMapsProvider.getLocationBasedOnDistanceInterval(points);
+			missingMapsOnDirectLine = suggestionsMapsProvider.getSuggestedMaps(pointsStraightLine);
+		} catch (IOException e) {
+			LOG.error(e.getMessage(), e);
+		}
+	}
+
 	public void openMenuHeaderOnly() {
 		WeakReference<MapRouteInfoMenuFragment> fragmentRef = findMenuFragment();
 		if (fragmentRef != null && fragmentRef.get().isVisible()) {
@@ -571,9 +594,9 @@ public void updateInfo(@NonNull View main) {
 
 		updateApplicationModes();
 		updateApplicationModesOptions();
-		updateOptionsButtons();
-
 		updateCards();
+		
+		updateOptionsButtons();
 	}
 
 	private void applyCardsState(@NonNull List<BaseCard> newCards, @NonNull List<BaseCard> prevCards) {
@@ -599,6 +622,9 @@ private void updateCards() {
 		TargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();
 		RoutingHelper routingHelper = app.getRoutingHelper();
 
+		isMapsNeededRouteCalculationStopped = !Algorithms.isEmpty(routingHelper.getRoute().getDownloadMaps());
+		boolean isMapsNeededRouteCalculationStarted = !Algorithms.isEmpty(missingMapsOnDirectLine);
+
 		List<BaseCard> menuCards = new ArrayList<>();
 
 		boolean bottomShadowVisible = true;
@@ -677,63 +703,69 @@ private void updateCards() {
 				menuCards.add(new PublicTransportBetaWarningCard(mapActivity));
 			} else if (app.getRoutingHelper().isBoatMode()) {
 				menuCards.add(new NauticalBridgeHeightWarningCard(mapActivity));
+			} else if (isMapsNeededRouteCalculationStarted && !isMapsNeededRouteCalculationStopped) {
+				menuCards.add(new SuggestionsMapsDownloadWarningCard(mapActivity));
 			} else if (app.getTargetPointsHelper().hasTooLongDistanceToNavigate()) {
 				menuCards.add(new LongDistanceWarningCard(mapActivity));
 			}
 		} else {
-			// Home/work card
-			HomeWorkCard homeWorkCard = new HomeWorkCard(mapActivity);
-			menuCards.add(homeWorkCard);
-
-			// Previous route card
-			TargetPoint startBackup = targetPointsHelper.getPointToStartBackup();
-			if (startBackup == null) {
-				startBackup = targetPointsHelper.getMyLocationToStart();
-			}
-			TargetPoint destinationBackup = targetPointsHelper.getPointToNavigateBackup();
-			if (startBackup != null && destinationBackup != null) {
-				PreviousRouteCard previousRouteCard = new PreviousRouteCard(mapActivity);
-				previousRouteCard.setListener(this);
-				menuCards.add(previousRouteCard);
-			}
-
-			// Gpx card
-			List<SelectedGpxFile> selectedGPXFiles =
-					app.getSelectedGpxHelper().getSelectedGPXFiles();
-			final List<GPXFile> gpxFiles = new ArrayList<>();
-			for (SelectedGpxFile gs : selectedGPXFiles) {
-				if (!gs.isShowCurrentTrack()) {
-					if (gs.getGpxFile().hasRtePt() || gs.getGpxFile().hasTrkPt()) {
-						gpxFiles.add(gs.getGpxFile());
+			if (isMapsNeededRouteCalculationStopped) {
+				menuCards.add(new SuggestionsMapsDownloadWarningCard(mapActivity));
+			} else {
+				// Home/work card
+				HomeWorkCard homeWorkCard = new HomeWorkCard(mapActivity);
+				menuCards.add(homeWorkCard);
+
+				// Previous route card
+				TargetPoint startBackup = targetPointsHelper.getPointToStartBackup();
+				if (startBackup == null) {
+					startBackup = targetPointsHelper.getMyLocationToStart();
+				}
+				TargetPoint destinationBackup = targetPointsHelper.getPointToNavigateBackup();
+				if (startBackup != null && destinationBackup != null) {
+					PreviousRouteCard previousRouteCard = new PreviousRouteCard(mapActivity);
+					previousRouteCard.setListener(this);
+					menuCards.add(previousRouteCard);
+				}
+
+				// Gpx card
+				List<SelectedGpxFile> selectedGPXFiles =
+						app.getSelectedGpxHelper().getSelectedGPXFiles();
+				final List<GPXFile> gpxFiles = new ArrayList<>();
+				for (SelectedGpxFile gs : selectedGPXFiles) {
+					if (!gs.isShowCurrentTrack()) {
+						if (gs.getGpxFile().hasRtePt() || gs.getGpxFile().hasTrkPt()) {
+							gpxFiles.add(gs.getGpxFile());
+						}
 					}
 				}
-			}
-			if (gpxFiles.size() > 0) {
-				TracksCard tracksCard = new TracksCard(mapActivity, gpxFiles);
-				tracksCard.setListener(this);
-				menuCards.add(tracksCard);
-			}
+				if (gpxFiles.size() > 0) {
+					TracksCard tracksCard = new TracksCard(mapActivity, gpxFiles);
+					tracksCard.setListener(this);
+					menuCards.add(tracksCard);
+				}
 
-			// Map markers card
-			List<MapMarker> mapMarkers = app.getMapMarkersHelper().getMapMarkers();
-			if (mapMarkers.size() > 0) {
-				MapMarkersCard mapMarkersCard = new MapMarkersCard(mapActivity, mapMarkers);
-				menuCards.add(mapMarkersCard);
-			}
+				// Map markers card
+				List<MapMarker> mapMarkers = app.getMapMarkersHelper().getMapMarkers();
+				if (mapMarkers.size() > 0) {
+					MapMarkersCard mapMarkersCard = new MapMarkersCard(mapActivity, mapMarkers);
+					menuCards.add(mapMarkersCard);
+				}
 
-			// History card
-			SearchResultCollection res = null;
-			try {
-				res = app.getSearchUICore().getCore().shallowSearch(QuickSearchHelper.SearchHistoryAPI.class, "", null);
-			} catch (IOException e) {
-				// ignore
-			}
-			if (res != null) {
-				List<SearchResult> results = res.getCurrentSearchResults();
-				if (results.size() > 0) {
-					HistoryCard historyCard = new HistoryCard(mapActivity, results);
-					historyCard.setListener(this);
-					menuCards.add(historyCard);
+				// History card
+				SearchResultCollection res = null;
+				try {
+					res = app.getSearchUICore().getCore().shallowSearch(QuickSearchHelper.SearchHistoryAPI.class, "", null);
+				} catch (IOException e) {
+					// ignore
+				}
+				if (res != null) {
+					List<SearchResult> results = res.getCurrentSearchResults();
+					if (results.size() > 0) {
+						HistoryCard historyCard = new HistoryCard(mapActivity, results);
+						historyCard.setListener(this);
+						menuCards.add(historyCard);
+					}
 				}
 			}
 		}
@@ -1076,15 +1108,14 @@ private void updateControlButtons(MapActivity mapActivity, View mainView) {
 			if (routeCalculated && hasTransportRoutes()) {
 				color1 = nightMode ? R.color.active_color_primary_dark : R.color.active_color_primary_light;
 				AndroidUtils.setBackground(app, startButton, nightMode, R.color.card_and_list_background_light, R.color.card_and_list_background_dark);
-				color2 = color1;
 			} else {
 				color1 = R.color.description_font_and_bottom_sheet_icons;
 				AndroidUtils.setBackground(app, startButton, nightMode, R.color.activity_background_light, R.color.activity_background_dark);
-				color2 = color1;
 			}
+			color2 = color1;
 		} else {
 			color1 = nightMode ? R.color.active_buttons_and_links_text_dark : R.color.active_buttons_and_links_text_light;
-			if (routeCalculated || currentLocationNotFound && !helper.isRouteBeingCalculated()) {
+			if (routeCalculated || currentLocationNotFound && !helper.isRouteBeingCalculated() && !isMapsNeededRouteCalculationStopped) {
 				AndroidUtils.setBackground(app, startButton, nightMode, R.color.active_color_primary_light, R.color.active_color_primary_dark);
 				color2 = color1;
 			} else {
@@ -1102,6 +1133,15 @@ private void updateControlButtons(MapActivity mapActivity, View mainView) {
 		} else {
 			startButtonText.setText(R.string.shared_string_control_start);
 		}
+
+		if (isMapsNeededRouteCalculationStopped) {
+			startButton.setClickable(false);
+			startButton.setEnabled(false);
+		} else {
+			startButton.setEnabled(true);
+			startButton.setClickable(true);
+		}
+
 		startButton.setOnClickListener(new OnClickListener() {
 			@Override
 			public void onClick(View v) {
@@ -1476,20 +1516,15 @@ private LinearLayout createToolbarOptionView(boolean active, String title, @Draw
 		}
 		if (title == null) {
 			textView.setVisibility(View.GONE);
-			if (activeItemDrawable != null && itemDrawable != null) {
-				imageView.setImageDrawable(active ? activeItemDrawable : itemDrawable);
-			} else {
-				imageView.setVisibility(View.GONE);
-			}
 		} else {
 			textView.setVisibility(View.VISIBLE);
 			textView.setTextColor(active ? colorActive : colorDisabled);
 			textView.setText(title);
-			if (activeItemDrawable != null && itemDrawable != null) {
-				imageView.setImageDrawable(active ? activeItemDrawable : itemDrawable);
-			} else {
-				imageView.setVisibility(View.GONE);
-			}
+		}
+		if (activeItemDrawable != null && itemDrawable != null) {
+			imageView.setImageDrawable(active ? activeItemDrawable : itemDrawable);
+		} else {
+			imageView.setVisibility(View.GONE);
 		}
 		item.setOnClickListener(listener);
 
diff --git a/OsmAnd/src/net/osmand/plus/routepreparationmenu/cards/SuggestionsMapsDownloadWarningCard.java b/OsmAnd/src/net/osmand/plus/routepreparationmenu/cards/SuggestionsMapsDownloadWarningCard.java
new file mode 100644
index 00000000000..cf9afc2cce5
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/routepreparationmenu/cards/SuggestionsMapsDownloadWarningCard.java
@@ -0,0 +1,166 @@
+package net.osmand.plus.routepreparationmenu.cards;
+
+import androidx.annotation.NonNull;
+
+import net.osmand.map.WorldRegion;
+import net.osmand.plus.R;
+import net.osmand.plus.activities.MapActivity;
+import net.osmand.plus.base.MultipleSelectionBottomSheet;
+import net.osmand.plus.base.SelectionBottomSheet;
+import net.osmand.plus.download.DownloadIndexesThread;
+import net.osmand.plus.download.DownloadItem;
+import net.osmand.plus.download.DownloadValidationManager;
+import net.osmand.plus.download.IndexItem;
+import net.osmand.util.Algorithms;
+
+import java.text.DateFormat;
+import java.util.ArrayList;
+import java.util.List;
+
+import static net.osmand.plus.download.MultipleDownloadItem.getIndexItem;
+
+public class SuggestionsMapsDownloadWarningCard extends WarningCard {
+	boolean isRouteCalculationStopped;
+	boolean isRouteCalculationInProgress;
+	private SelectionBottomSheet dialog;
+
+	public SuggestionsMapsDownloadWarningCard(@NonNull MapActivity mapActivity) {
+		super(mapActivity);
+		isRouteCalculationInProgress = !Algorithms.isEmpty(mapActivity.getMapRouteInfoMenu().getMissingMapsOnDirectLine());
+		isRouteCalculationStopped = !Algorithms.isEmpty(mapActivity.getRoutingHelper().getRoute().getDownloadMaps());
+		if (isRouteCalculationStopped) {
+			imageId = R.drawable.ic_map;
+			title = mapActivity.getString(R.string.offline_maps_required_descr);
+			linkText = mapActivity.getString(R.string.welmode_download_maps);
+		} else if (isRouteCalculationInProgress) {
+			imageId = R.drawable.ic_action_time_span;
+			title = mapActivity.getString(R.string.direct_line_maps_required_descr);
+			linkText = mapActivity.getString(R.string.online_direct_line_maps_link);
+		}
+	}
+
+	private void showMultipleSelectionDialog() {
+		List<DownloadItem> downloadMapsList = getMapsList();
+		List<SelectionBottomSheet.SelectableItem> allItems = new ArrayList<>();
+		List<SelectionBottomSheet.SelectableItem> selectedItems = new ArrayList<>();
+
+		for (DownloadItem di : downloadMapsList) {
+			boolean isSuggestedDownloadsMaps = di.getType().getTag().equals("map");
+			SelectionBottomSheet.SelectableItem si = createSelectableItem(di);
+			if (isSuggestedDownloadsMaps) {
+				allItems.add(si);
+				selectedItems.add(si);
+			}
+		}
+
+		MultipleSelectionBottomSheet msDialog =
+				MultipleSelectionBottomSheet.showInstance(mapActivity, allItems, selectedItems, true);
+		this.dialog = msDialog;
+
+		msDialog.setDialogStateListener(new SelectionBottomSheet.DialogStateListener() {
+			@Override
+			public void onDialogCreated() {
+				dialog.setTitle(app.getString(R.string.welmode_download_maps));
+			}
+
+			@Override
+			public void onCloseDialog() {
+
+			}
+		});
+
+		msDialog.setSelectionUpdateListener(this::updateSize);
+
+		msDialog.setOnApplySelectionListener(selectedItems1 -> {
+			List<IndexItem> indexes = new ArrayList<>();
+			for (SelectionBottomSheet.SelectableItem item : selectedItems1) {
+				IndexItem index = getIndexItem((DownloadItem) item.getObject());
+				if (index != null) {
+					indexes.add(index);
+				}
+			}
+			IndexItem[] indexesArray = new IndexItem[indexes.size()];
+			new DownloadValidationManager(app).startDownload(mapActivity, indexes.toArray(indexesArray));
+		});
+	}
+
+	private void updateSize() {
+		double sizeToDownload = getDownloadSizeInMb(dialog.getSelectedItems());
+		String size = DownloadItem.getFormattedMb(app, sizeToDownload);
+		String total = app.getString(R.string.shared_string_total);
+		String description = app.getString(R.string.ltr_or_rtl_combine_via_colon, total, size);
+		dialog.setTitleDescription(description);
+		String btnTitle = app.getString(R.string.shared_string_download);
+		if (sizeToDownload > 0) {
+			btnTitle = app.getString(R.string.ltr_or_rtl_combine_via_dash, btnTitle, size);
+		}
+		dialog.setApplyButtonTitle(btnTitle);
+	}
+
+	private double getDownloadSizeInMb(@NonNull List<SelectionBottomSheet.SelectableItem> selectableItems) {
+		double totalSizeMb = 0.0d;
+		for (SelectionBottomSheet.SelectableItem i : selectableItems) {
+			Object obj = i.getObject();
+			totalSizeMb += ((DownloadItem) obj).getSizeToDownloadInMb();
+		}
+		return totalSizeMb;
+	}
+
+
+	public List<DownloadItem> getMapsList() {
+		DownloadIndexesThread downloadThread = app.getDownloadThread();
+		if (!downloadThread.getIndexes().isDownloadedFromInternet) {
+			if (mapActivity.getMyApplication().getSettings().isInternetConnectionAvailable()) {
+				downloadThread.runReloadIndexFiles();
+			}
+		}
+
+		boolean downloadIndexes = app.getSettings().isInternetConnectionAvailable()
+				&& !downloadThread.getIndexes().isDownloadedFromInternet
+				&& !downloadThread.getIndexes().downloadFromInternetFailed;
+
+		List<WorldRegion> suggestedMaps;
+		if (isRouteCalculationStopped) {
+			suggestedMaps = mapActivity.getRoutingHelper().getRoute().getDownloadMaps();
+		} else {
+			suggestedMaps = mapActivity.getMapRouteInfoMenu().getMissingMapsOnDirectLine();
+		}
+		List<DownloadItem> suggestedDownloadsMaps = new ArrayList<>();
+		if (!downloadIndexes) {
+			for (WorldRegion suggestedDownloadMap : suggestedMaps) {
+				suggestedDownloadsMaps.addAll(app.getDownloadThread().getIndexes().getDownloadItems(suggestedDownloadMap));
+			}
+		}
+		return suggestedDownloadsMaps;
+	}
+
+	private SelectionBottomSheet.SelectableItem createSelectableItem(DownloadItem item) {
+		SelectionBottomSheet.SelectableItem selectableItem = new SelectionBottomSheet.SelectableItem();
+		updateSelectableItem(selectableItem, item);
+		selectableItem.setObject(item);
+		return selectableItem;
+	}
+
+	private void updateSelectableItem(SelectionBottomSheet.SelectableItem selectableItem,
+									  DownloadItem downloadItem) {
+		selectableItem.setTitle(downloadItem.getVisibleMapsName(app, app.getRegions()));
+		DateFormat dateFormat = android.text.format.DateFormat.getMediumDateFormat(app);
+		String size = downloadItem.getSizeDescription(app);
+		String additionalDescription = downloadItem.getAdditionalDescription(app);
+		if (additionalDescription != null) {
+			size += " " + additionalDescription;
+		}
+		String date = downloadItem.getDate(dateFormat, true);
+		String description = app.getString(R.string.ltr_or_rtl_combine_via_bold_point, size, date);
+		selectableItem.setDescription(description);
+
+		selectableItem.setIconId(downloadItem.getType().getIconResource());
+	}
+
+	@Override
+	protected void onLinkClicked() {
+		showMultipleSelectionDialog();
+	}
+
+}
+
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationParams.java b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationParams.java
index 0c4f2a4cb62..e50b7922e4b 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationParams.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationParams.java
@@ -2,8 +2,9 @@
 
 import net.osmand.Location;
 import net.osmand.data.LatLon;
-import net.osmand.plus.settings.backend.ApplicationMode;
+import net.osmand.map.WorldRegion;
 import net.osmand.plus.OsmandApplication;
+import net.osmand.plus.settings.backend.ApplicationMode;
 import net.osmand.router.RouteCalculationProgress;
 
 import java.util.List;
@@ -26,6 +27,7 @@ public class RouteCalculationParams {
 	public boolean inPublicTransportMode;
 	public boolean startTransportStop;
 	public boolean targetTransportStop;
+	public List<WorldRegion> missingMaps;
 	public RouteCalculationProgress calculationProgress;
 	public RouteCalculationProgressCallback calculationProgressCallback;
 	public RouteCalculationResultListener resultListener;
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationProgressCallback.java b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationProgressCallback.java
index a0649ba109a..78fa3f9ce83 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationProgressCallback.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationProgressCallback.java
@@ -8,5 +8,7 @@ public interface RouteCalculationProgressCallback {
 
 	void requestPrivateAccessRouting();
 
+	void updateMissingMaps(RouteCalculationParams params);
+
 	void finish();
 }
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
index b98213e3e98..e54a93274bc 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
@@ -12,6 +12,7 @@
 import net.osmand.data.LatLon;
 import net.osmand.data.LocationPoint;
 import net.osmand.data.QuadRect;
+import net.osmand.map.WorldRegion;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.routing.AlarmInfo.AlarmInfoType;
@@ -60,6 +61,8 @@ public class RouteCalculationResult {
 	protected List<RouteDirectionInfo> cacheAgreggatedDirections;
 	protected List<LocationPoint> locationPoints = new ArrayList<LocationPoint>();
 
+	protected final List<WorldRegion> downloadMaps;
+
 	// params
 	protected final ApplicationMode appMode;
 	protected final RouteService routeService;
@@ -79,6 +82,26 @@ public class RouteCalculationResult {
 
 	public RouteCalculationResult(String errorMessage) {
 		this.errorMessage = errorMessage;
+		this.downloadMaps = null;
+		this.routingTime = 0;
+		this.loadedTiles = 0;
+		this.visitedSegments = 0;
+		this.calculateTime = 0;
+		this.intermediatePoints = new int[0];
+		this.locations = new ArrayList<Location>();
+		this.segments = new ArrayList<RouteSegmentResult>();
+		this.listDistance = new int[0];
+		this.directions = new ArrayList<RouteDirectionInfo>();
+		this.alarmInfo = new ArrayList<AlarmInfo>();
+		this.routeService = null;
+		this.appMode = null;
+		this.routeRecalcDistance = 0;
+		this.routeVisibleAngle = 0;
+	}
+
+	public RouteCalculationResult(List<WorldRegion> suggestedOfflineMaps) {
+		this.downloadMaps = suggestedOfflineMaps;
+		this.errorMessage = null;
 		this.routingTime = 0;
 		this.loadedTiles = 0;
 		this.visitedSegments = 0;
@@ -101,6 +124,7 @@ public RouteCalculationResult(List<Location> list, List<RouteDirectionInfo> dire
 		this.calculateTime = 0;
 		this.visitedSegments = 0;
 		this.errorMessage = null;
+		this.downloadMaps = null;
 		this.intermediatePoints = new int[params.intermediates == null ? 0 : params.intermediates.size()];
 		List<Location> locations = list == null ? new ArrayList<Location>() : new ArrayList<Location>(list);
 		List<RouteDirectionInfo> localDirections = directions == null? new ArrayList<RouteDirectionInfo>() : new ArrayList<RouteDirectionInfo>(directions);
@@ -159,6 +183,7 @@ public RouteCalculationResult(List<RouteSegmentResult> list, Location start, Lat
 		}
 		List<RouteDirectionInfo> computeDirections = new ArrayList<RouteDirectionInfo>();
 		this.errorMessage = null;
+		this.downloadMaps = null;
 		this.intermediatePoints = new int[intermediates == null ? 0 : intermediates.size()];
 		List<Location> locations = new ArrayList<Location>();
 		ArrayList<AlarmInfo> alarms = new ArrayList<AlarmInfo>();
@@ -1286,6 +1311,10 @@ public void updateNextVisiblePoint(int nextPoint, Location mp) {
 		currentStraightAngleRoute = nextPoint;
 	}
 
+	public List<WorldRegion> getDownloadMaps() {
+		return downloadMaps;
+	}
+
 	public static class NextDirectionInfo {
 		public RouteDirectionInfo directionInfo;
 		public int distanceTo;
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
index e5974fc32d8..04bda6a2743 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
@@ -15,6 +15,7 @@
 import net.osmand.ResultMatcher;
 import net.osmand.binary.BinaryMapIndexReader;
 import net.osmand.data.LatLon;
+import net.osmand.map.WorldRegion;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.TargetPointsHelper;
@@ -105,7 +106,21 @@ public RouteCalculationResult calculateRouteImpl(RouteCalculationParams params)
 				if (calcGPXRoute && !params.gpxRoute.calculateOsmAndRoute) {
 					res = calculateGpxRoute(params);
 				} else if (params.mode.getRouteService() == RouteService.OSMAND) {
-					res = findVectorMapsRoute(params, calcGPXRoute);
+					SuggestionsMapsProvider suggestionsMapsProvider = new SuggestionsMapsProvider(params);
+
+					LinkedList<Location> points = suggestionsMapsProvider.getStartFinishIntermediatesPoints("");
+					List<WorldRegion> suggestionsMapsStartFinishIntermediates = suggestionsMapsProvider.getSuggestedMaps(points);
+
+					List<Location> pointsStraightLine = suggestionsMapsProvider.getLocationBasedOnDistanceInterval(points);
+					List<WorldRegion> suggestedMapsOnStraightLine = suggestionsMapsProvider.getSuggestedMaps(pointsStraightLine);
+					if (!Algorithms.isEmpty(suggestionsMapsStartFinishIntermediates)) {
+						res = new RouteCalculationResult(suggestedMapsOnStraightLine);
+					} else {
+						if (!suggestionsMapsProvider.isPointOnWater()) {
+							params.missingMaps = suggestedMapsOnStraightLine;
+						}
+						res = findVectorMapsRoute(params, calcGPXRoute);
+					}
 				} else if (params.mode.getRouteService() == RouteService.BROUTER) {
 					res = findBROUTERRoute(params);
 				} else if (params.mode.getRouteService() == RouteService.ONLINE) {
@@ -130,7 +145,7 @@ public RouteCalculationResult calculateRouteImpl(RouteCalculationParams params)
 				log.error("Failed to find route ", e); //$NON-NLS-1$
 			}
 		}
-		return new RouteCalculationResult(null);
+		return new RouteCalculationResult((String) null);
 	}
 
 	public RouteCalculationResult recalculatePartOfflineRoute(RouteCalculationResult res, RouteCalculationParams params) {
@@ -1174,7 +1189,8 @@ protected RouteCalculationResult findBROUTERRoute(RouteCalculationParams params)
 	}
 
 	private RouteCalculationResult findStraightRoute(RouteCalculationParams params) {
-		LinkedList<Location> points = new LinkedList<>();
+		SuggestionsMapsProvider suggestionsMapsProvider = new SuggestionsMapsProvider(params);
+		LinkedList<Location> points = suggestionsMapsProvider.getStartFinishIntermediatesPoints("pnt");
 		List<Location> segments = new ArrayList<>();
 		points.add(new Location("pnt", params.start.getLatitude(), params.start.getLongitude()));
 		if(params.intermediates != null) {
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteRecalculationHelper.java b/OsmAnd/src/net/osmand/plus/routing/RouteRecalculationHelper.java
index 8fb8201dea6..d68562223d8 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteRecalculationHelper.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteRecalculationHelper.java
@@ -10,6 +10,7 @@
 import net.osmand.plus.settings.backend.ApplicationMode;
 import net.osmand.plus.settings.backend.OsmandSettings;
 import net.osmand.router.RouteCalculationProgress;
+import net.osmand.util.Algorithms;
 
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -259,12 +260,18 @@ public void run() {
 							if (calculationProgress.requestPrivateAccessRouting) {
 								progressRoute.requestPrivateAccessRouting();
 							}
+							if (!Algorithms.isEmpty(params.missingMaps)) {
+								progressRoute.updateMissingMaps(params);
+							}
 							updateProgress(params);
 						}
 					} else {
 						if (calculationProgress.requestPrivateAccessRouting) {
 							progressRoute.requestPrivateAccessRouting();
 						}
+						if (!Algorithms.isEmpty(params.missingMaps)) {
+							progressRoute.updateMissingMaps(params);
+						}
 						progressRoute.finish();
 					}
 				}
@@ -345,6 +352,7 @@ public void run() {
 			}
 			RouteCalculationResult prev = routingHelper.getRoute();
 			synchronized (routingHelper) {
+				routingHelper.setRoute(res);
 				if (res.isCalculated()) {
 					if (!params.inSnapToRoadMode && !params.inPublicTransportMode) {
 						routingHelper.setRoute(res);
@@ -376,7 +384,9 @@ public void run() {
 					routeCalcError = app.getString(R.string.empty_route_calculated);
 					routeCalcErrorShort = app.getString(R.string.empty_route_calculated);
 				}
-				showMessage(routeCalcError);
+				if (res.getDownloadMaps().isEmpty()) {
+					showMessage(routeCalcError);
+				}
 			}
 			app.getNotificationHelper().refreshNotification(NAVIGATION);
 		}
diff --git a/OsmAnd/src/net/osmand/plus/routing/SuggestionsMapsProvider.java b/OsmAnd/src/net/osmand/plus/routing/SuggestionsMapsProvider.java
new file mode 100644
index 00000000000..af72cc8dddb
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/routing/SuggestionsMapsProvider.java
@@ -0,0 +1,102 @@
+package net.osmand.plus.routing;
+
+import net.osmand.IndexConstants;
+import net.osmand.Location;
+import net.osmand.data.LatLon;
+import net.osmand.map.WorldRegion;
+import net.osmand.util.Algorithms;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+
+import static net.osmand.util.MapUtils.findPointAtDistanceFrom;
+
+public class SuggestionsMapsProvider {
+
+	private static final int DISTANCE = 20000;
+	RouteCalculationParams params;
+	private boolean isPointOnWater;
+
+	public SuggestionsMapsProvider(RouteCalculationParams params) {
+		this.params = params;
+	}
+
+	public boolean isPointOnWater() {
+		return isPointOnWater;
+	}
+
+	public boolean checkIfObjectDownloaded(String downloadName) {
+		final String regionName = Algorithms.capitalizeFirstLetterAndLowercase(downloadName)
+				+ IndexConstants.BINARY_MAP_INDEX_EXT;
+		final String roadsRegionName = Algorithms.capitalizeFirstLetterAndLowercase(downloadName) + ".road"
+				+ IndexConstants.BINARY_MAP_INDEX_EXT;
+		return params.ctx.getResourceManager().getIndexFileNames().containsKey(regionName) || params.ctx.getResourceManager().getIndexFileNames().containsKey(roadsRegionName);
+	}
+
+	public List<Location> getLocationBasedOnDistanceInterval(List<Location> points) {
+		List<Location> mapsBasedOnPoints = new ArrayList<>();
+		for (int i = 0; i < points.size(); i++) {
+			int nextIndex = i + 1 < points.size() ? i + 1 : i;
+			mapsBasedOnPoints.add(0, points.get(i));
+			mapsBasedOnPoints.add(mapsBasedOnPoints.size(), points.get(nextIndex));
+			while (mapsBasedOnPoints.get(0).distanceTo(mapsBasedOnPoints.get(mapsBasedOnPoints.size() - 1)) > DISTANCE) {
+				float bearing = mapsBasedOnPoints.get(0).bearingTo(mapsBasedOnPoints.get(mapsBasedOnPoints.size() - 1));
+				LatLon latLon = findPointAtDistanceFrom(mapsBasedOnPoints.get(0).getLatitude(), mapsBasedOnPoints.get(0).getLongitude(), DISTANCE, bearing);
+				Location location = new Location("", latLon.getLatitude(), latLon.getLongitude());
+				mapsBasedOnPoints.add(0, location);
+			}
+		}
+		return mapsBasedOnPoints;
+	}
+
+	public LinkedList<Location> getStartFinishIntermediatesPoints(String locationProvider) {
+		LinkedList<Location> points = new LinkedList<>();
+		points.add(new Location(locationProvider, params.start.getLatitude(), params.start.getLongitude()));
+		if (params.intermediates != null) {
+			for (LatLon l : params.intermediates) {
+				points.add(new Location(locationProvider, l.getLatitude(), l.getLongitude()));
+			}
+		}
+		points.add(new Location(locationProvider, params.end.getLatitude(), params.end.getLongitude()));
+		return points;
+	}
+
+	public List<WorldRegion> getSuggestedMaps(List<Location> points) throws IOException {
+		LinkedHashSet<WorldRegion> suggestedMaps = new LinkedHashSet<>();
+		for (int i = 0; i < points.size(); i++) {
+			final Location o = points.get(i);
+			LatLon latLonPoint = new LatLon(o.getLatitude(), o.getLongitude());
+			List<WorldRegion> downloadRegions = params.ctx.getRegions().getWorldRegionsAt(latLonPoint);
+
+			if (downloadRegions.isEmpty()) {
+				isPointOnWater = true;
+			}
+
+			List<Boolean> mapsDownloadedList = new ArrayList<>();
+			List<WorldRegion> maps = new ArrayList<>();
+			for (WorldRegion downloadRegion : downloadRegions) {
+				String mapName = downloadRegion.getRegionDownloadName();
+				String countryMapName = downloadRegion.getSuperregion().getRegionDownloadName();
+				List<WorldRegion> subregions = downloadRegion.getSubregions();
+				boolean isSuggestedMapsNeeded = !checkIfObjectDownloaded(mapName);
+				boolean isCountry = Algorithms.isEmpty(countryMapName) && !subregions.isEmpty();
+				if (isSuggestedMapsNeeded) {
+					if (!isCountry) {
+						maps.add(downloadRegion);
+					}
+					mapsDownloadedList.add(true);
+				} else {
+					mapsDownloadedList.add(false);
+				}
+			}
+			if (!mapsDownloadedList.contains(false)) {
+				suggestedMaps.addAll(maps);
+			}
+		}
+
+		return new ArrayList<>(suggestedMaps);
+	}
+}
diff --git a/OsmAnd/src/net/osmand/plus/routing/TransportRoutingHelper.java b/OsmAnd/src/net/osmand/plus/routing/TransportRoutingHelper.java
index 9f56f6d6333..22fd7911e6e 100644
--- a/OsmAnd/src/net/osmand/plus/routing/TransportRoutingHelper.java
+++ b/OsmAnd/src/net/osmand/plus/routing/TransportRoutingHelper.java
@@ -567,6 +567,10 @@ public void updateProgress(int progress) {
 				public void requestPrivateAccessRouting() {
 				}
 
+				@Override
+				public void updateMissingMaps(RouteCalculationParams params) {
+				}
+
 				@Override
 				public void finish() {
 					if (walkingSegmentsToCalculate.isEmpty()) {
