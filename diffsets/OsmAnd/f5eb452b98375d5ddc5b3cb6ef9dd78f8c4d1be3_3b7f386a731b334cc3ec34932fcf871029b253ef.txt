diff --git a/OsmAnd/res/layout/list_item_expandable_category.xml b/OsmAnd/res/layout/list_item_expandable_category.xml
index 77f057aa9d7..51f735e97e6 100644
--- a/OsmAnd/res/layout/list_item_expandable_category.xml
+++ b/OsmAnd/res/layout/list_item_expandable_category.xml
@@ -29,6 +29,7 @@
 			android:orientation="horizontal">
 
 			<LinearLayout
+				android:id="@+id/text_container"
 				android:layout_width="0dp"
 				android:layout_height="wrap_content"
 				android:layout_gravity="center_vertical"
@@ -75,13 +76,20 @@
 		android:id="@+id/divider"
 		android:layout_width="wrap_content"
 		android:layout_height="1dp"
-		android:background="?attr/dashboard_divider"/>
+		android:background="?attr/divider_color_basic"/>
 
-	<LinearLayout
-		android:id="@+id/items_container"
+	<FrameLayout
 		android:layout_width="match_parent"
 		android:layout_height="wrap_content"
-		android:background="?attr/bg_color"
-		android:orientation="vertical" />
+		android:background="?attr/bg_color">
+
+		<LinearLayout
+			android:id="@+id/items_container"
+			android:layout_width="match_parent"
+			android:layout_height="wrap_content"
+			android:fillViewport="true"
+			android:orientation="vertical" />
+
+	</FrameLayout>
 
 </LinearLayout>
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/configmap/CategoryAnimator.java b/OsmAnd/src/net/osmand/plus/configmap/CategoryAnimator.java
new file mode 100644
index 00000000000..2ae89e2f911
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/configmap/CategoryAnimator.java
@@ -0,0 +1,200 @@
+package net.osmand.plus.configmap;
+
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewGroup.LayoutParams;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import androidx.annotation.NonNull;
+
+import net.osmand.plus.R;
+import net.osmand.plus.helpers.AndroidUiHelper;
+import net.osmand.plus.utils.AndroidUtils;
+import net.osmand.plus.utils.ColorUtilities;
+import net.osmand.plus.widgets.ctxmenu.data.ContextMenuItem;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public class CategoryAnimator {
+
+	private static Map<ContextMenuItem, ValueAnimator> runningAnimations = new HashMap<>();
+
+	private static final float MAX_ROTATION = 180;
+
+	private final Context ctx;
+	private final boolean isExpanding;
+	private final ContextMenuItem category;
+
+	private final View header;
+	private final ImageView ivIndicator;
+	private final TextView tvDescription;
+	private final View itemsContainer;
+	private final View divider;
+
+	// common parameters
+	private float descHeight;
+	private float minHeaderHeight;
+	private float maxHeaderHeight;
+	private int maxListHeight;
+	private int maxDuration;
+
+
+	private CategoryAnimator(@NonNull ContextMenuItem category, @NonNull View view, boolean isExpanding) {
+		this.category = category;
+		this.ctx = view.getContext();
+		this.isExpanding = isExpanding;
+
+		header = view.findViewById(R.id.button_container);
+		ivIndicator = view.findViewById(R.id.explicit_indicator);
+		tvDescription = view.findViewById(R.id.description);
+		itemsContainer = view.findViewById(R.id.items_container);
+		divider = view.findViewById(R.id.divider);
+
+		calculateCommonParameters();
+	}
+
+	private ValueAnimator startAnimation() {
+		onBeforeAnimation();
+		// Determine passed distance in current direction
+		float currentHeaderHeight = header.getHeight();
+		float wholeDistance = maxHeaderHeight - minHeaderHeight;
+		float leftDistance = isExpanding ?
+				(currentHeaderHeight - minHeaderHeight) :
+				(maxHeaderHeight - currentHeaderHeight);
+		float passedDistance = wholeDistance - leftDistance;
+
+		// Determine restrictions
+		int minValue = 0;
+		int maxValue = 100;
+		int startValue = (int) ((passedDistance / wholeDistance) * maxValue);
+
+		// Determine correct animation duration
+		int duration = (int) ((float) maxDuration / maxValue * (maxValue - startValue));
+
+		// Create animation
+		ValueAnimator animation = ValueAnimator.ofInt(startValue, maxValue);
+		animation.setDuration(duration);
+		animation.addUpdateListener(animator -> {
+			int val = (Integer) animator.getAnimatedValue();
+			onMainAnimationUpdate(val, minValue, maxValue);
+			if (val == maxValue) {
+				onMainAnimationFinished();
+				if (isExpanding) {
+					runningAnimations.remove(category);
+				} else {
+					onShowDescriptionAnimation(minValue, maxValue, (int) (duration * 0.7f));
+				}
+			}
+		});
+
+		animation.start();
+		return animation;
+	}
+
+	private void calculateCommonParameters() {
+		descHeight = getDimen(R.dimen.default_desc_line_height);
+		int titleHeight = getDimen(R.dimen.default_title_line_height);
+		int verticalMargin = getDimen(R.dimen.content_padding_small)*2;
+		minHeaderHeight = titleHeight + verticalMargin - AndroidUtils.dpToPx(ctx, 3);
+		maxHeaderHeight = minHeaderHeight + descHeight;
+
+		itemsContainer.measure(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
+		maxListHeight = itemsContainer.getMeasuredHeight();
+
+		maxDuration = getInteger(android.R.integer.config_mediumAnimTime);
+	}
+
+	private void onBeforeAnimation() {
+		// Make all views visible before animate them
+		tvDescription.setVisibility(View.VISIBLE);
+		itemsContainer.setVisibility(View.VISIBLE);
+		divider.setVisibility(View.VISIBLE);
+		tvDescription.setVisibility(View.INVISIBLE);
+	}
+
+	private void onMainAnimationUpdate(int val, float minValue, float maxValue) {
+		// Set indicator rotation
+		float rotation = MAX_ROTATION / maxValue * val;
+		ivIndicator.setRotation(isExpanding ? -rotation : rotation);
+
+		// Set header height
+		float headerIncrement = descHeight / maxValue * val;
+		float headerHeight = isExpanding ? maxHeaderHeight - headerIncrement : minHeaderHeight + headerIncrement;
+		ViewGroup.LayoutParams layoutParams = header.getLayoutParams();
+		layoutParams.height = (int) headerHeight;
+		header.setLayoutParams(layoutParams);
+
+		// Set list alpha
+		float listAlpha = ColorUtilities.getProportionalAlpha(minValue, maxValue, val);
+		float inverseListAlpha = 1.0f - listAlpha;
+		itemsContainer.setAlpha(isExpanding ? inverseListAlpha : listAlpha);
+
+		// Set list height
+		float increment = (float) maxListHeight / maxValue * val;
+		float height = isExpanding ? increment : maxListHeight - increment;
+		ViewGroup.LayoutParams layoutParams1 = itemsContainer.getLayoutParams();
+		layoutParams1.height = (int) height;
+		itemsContainer.setLayoutParams(layoutParams1);
+	}
+
+	private void onMainAnimationFinished() {
+		int indicatorRes = isExpanding ? R.drawable.ic_action_arrow_up : R.drawable.ic_action_arrow_down;
+		ivIndicator.setRotation(0);
+		ivIndicator.setImageResource(indicatorRes);
+
+		AndroidUiHelper.updateVisibility(divider, isExpanding);
+		AndroidUiHelper.updateVisibility(tvDescription, !isExpanding);
+		AndroidUiHelper.updateVisibility(itemsContainer, isExpanding);
+
+		LayoutParams params = itemsContainer.getLayoutParams();
+		params.height = LayoutParams.WRAP_CONTENT;
+		itemsContainer.setLayoutParams(params);
+	}
+
+	private void onShowDescriptionAnimation(int minValue, int maxValue, int duration) {
+		ValueAnimator animator = ValueAnimator.ofInt(minValue, maxValue);
+		animator.setDuration(duration);
+		animator.addUpdateListener(animation -> {
+			int val = (Integer) animator.getAnimatedValue();
+			float alpha = ColorUtilities.getProportionalAlpha(minValue, maxValue, val);
+			tvDescription.setAlpha(1.0f - alpha);
+			if (maxValue == val) {
+				runningAnimations.remove(category);
+			}
+		});
+		animator.start();
+	}
+
+	private int getDimen(int id) {
+		return ctx.getResources().getDimensionPixelSize(id);
+	}
+
+	private int getInteger(int id) {
+		return ctx.getResources().getInteger(id);
+	}
+
+
+	public static void startCollapsing(@NonNull ContextMenuItem category, @NonNull View view) {
+		tryStartAnimation(category, view, false);
+	}
+
+	public static void startExpanding(@NonNull ContextMenuItem category, @NonNull View view) {
+		tryStartAnimation(category, view, true);
+	}
+
+	private static void tryStartAnimation(@NonNull ContextMenuItem category, @NonNull View view, boolean isExpanding) {
+		CategoryAnimator animator = new CategoryAnimator(category, view, isExpanding);
+		// Stop previous animation for the category
+		ValueAnimator runningAnimation = runningAnimations.remove(category);
+		if (runningAnimation != null && runningAnimation.isRunning()) {
+			runningAnimation.end();
+		}
+		// Create and run a new animation
+		runningAnimations.put(category, animator.startAnimation());
+	}
+
+}
diff --git a/OsmAnd/src/net/osmand/plus/configmap/ConfigureMapFragment.java b/OsmAnd/src/net/osmand/plus/configmap/ConfigureMapFragment.java
index 163141edfb2..0aaf690c839 100644
--- a/OsmAnd/src/net/osmand/plus/configmap/ConfigureMapFragment.java
+++ b/OsmAnd/src/net/osmand/plus/configmap/ConfigureMapFragment.java
@@ -36,6 +36,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 
 public class ConfigureMapFragment extends BaseOsmAndFragment implements OnDataChangeUiAdapter {
 
@@ -46,8 +47,9 @@ public class ConfigureMapFragment extends BaseOsmAndFragment implements OnDataCh
 	private OsmandSettings settings;
 	private ApplicationMode appMode;
 	private ViewCreator viewCreator;
-	Map<ContextMenuItem, List<ContextMenuItem>> items;
+	private Map<ContextMenuItem, List<ContextMenuItem>> items;
 	private boolean nightMode;
+	private boolean useAnimation;
 
 	private final Map<Integer, View> views = new HashMap<>();
 	private LinearLayout llList;
@@ -70,6 +72,7 @@ public View onCreateView(@NonNull LayoutInflater inflater,
 	                         @Nullable Bundle savedInstanceState) {
 		appMode = settings.getApplicationMode();
 		nightMode = app.getDaynightHelper().isNightModeForMapControls();
+		useAnimation = !settings.DO_NOT_USE_ANIMATIONS.getModeValue(appMode);
 		inflater = UiUtilities.getInflater(getContext(), nightMode);
 		View view = inflater.inflate(R.layout.fragment_configure_map, container, false);
 
@@ -133,9 +136,9 @@ private void bindCategoryView(@NonNull ContextMenuItem category,
 		btnView.setOnClickListener(v -> {
 			boolean isCollapsed = collapsedIds.containsValue(appMode, id);
 			if (isCollapsed) {
-				expand(category);
+				expandCategory(category);
 			} else {
-				collapse(category);
+				collapseCategory(category);
 			}
 		});
 
@@ -160,28 +163,38 @@ private void bindItemView(@NonNull ContextMenuItem item, @NonNull ViewGroup cont
 	}
 
 	private void updateCategoryView(@NonNull ContextMenuItem category) {
-		String id = category.getId();
-		int standardId = category.getTitleId();
-		View view = views.get(standardId);
-		if (view == null) {
-			return;
+		View view = views.get(category.getTitleId());
+		if (view != null) {
+			String id = category.getId();
+			boolean isCollapsed = collapsedIds.containsValue(appMode, id);
+
+			ImageView ivIndicator = view.findViewById(R.id.explicit_indicator);
+			ivIndicator.setImageResource(isCollapsed ? R.drawable.ic_action_arrow_down : R.drawable.ic_action_arrow_up);
+
+			AndroidUiHelper.updateVisibility(view.findViewById(R.id.description), isCollapsed);
+			AndroidUiHelper.updateVisibility(view.findViewById(R.id.items_container), !isCollapsed);
+			AndroidUiHelper.updateVisibility(view.findViewById(R.id.divider), !isCollapsed);
 		}
-		boolean isCollapsed = collapsedIds.containsValue(appMode, id);
-		ImageView ivIndicator = view.findViewById(R.id.explicit_indicator);
-		ivIndicator.setImageResource(isCollapsed ? R.drawable.ic_action_arrow_down : R.drawable.ic_action_arrow_up);
-		AndroidUiHelper.updateVisibility(view.findViewById(R.id.description), isCollapsed);
-		AndroidUiHelper.updateVisibility(view.findViewById(R.id.items_container), !isCollapsed);
-		AndroidUiHelper.updateVisibility(view.findViewById(R.id.divider), !isCollapsed);
 	}
 
-	private void expand(@NonNull ContextMenuItem category) {
+	private void expandCategory(@NonNull ContextMenuItem category) {
 		collapsedIds.removeValueForProfile(appMode, category.getId());
-		updateCategoryView(category);
+		if (useAnimation) {
+			View view = views.get(category.getTitleId());
+			CategoryAnimator.startExpanding(category, Objects.requireNonNull(view));
+		} else {
+			updateCategoryView(category);
+		}
 	}
 
-	private void collapse(@NonNull ContextMenuItem category) {
+	private void collapseCategory(@NonNull ContextMenuItem category) {
 		collapsedIds.addModeValue(appMode, category.getId());
-		updateCategoryView(category);
+		if (useAnimation) {
+			View view = views.get(category.getTitleId());
+			CategoryAnimator.startCollapsing(category, Objects.requireNonNull(view));
+		} else {
+			updateCategoryView(category);
+		}
 	}
 
 	public View.OnClickListener getItemsClickListener() {
diff --git a/OsmAnd/src/net/osmand/plus/utils/ColorUtilities.java b/OsmAnd/src/net/osmand/plus/utils/ColorUtilities.java
index 8960d799d72..bc6b94986b0 100644
--- a/OsmAnd/src/net/osmand/plus/utils/ColorUtilities.java
+++ b/OsmAnd/src/net/osmand/plus/utils/ColorUtilities.java
@@ -19,8 +19,7 @@ public static int getContrastColor(Context context, @ColorInt int color, boolean
 		return luminance < 0.5 ? transparent ? ContextCompat.getColor(context, R.color.color_black_transparent) : Color.BLACK : Color.WHITE;
 	}
 
-	public static float getProportionalAlpha(float startValue, float endValue,
-	                                         float currentValue) {
+	public static float getProportionalAlpha(float startValue, float endValue, float currentValue) {
 		currentValue = Math.min(currentValue, endValue);
 		float proportion = (endValue - startValue) / 100;
 		if (currentValue > startValue) {
@@ -32,8 +31,7 @@ public static float getProportionalAlpha(float startValue, float endValue,
 
 	@ColorInt
 	public static int getProportionalColorMix(@ColorInt int startColor, @ColorInt int endColor,
-	                                          float startValue, float endValue,
-	                                          float currentValue) {
+	                                          float startValue, float endValue, float currentValue) {
 		currentValue = Math.min(currentValue, endValue);
 		float proportion = (endValue - startValue) / 100;
 		if (currentValue > startValue) {
