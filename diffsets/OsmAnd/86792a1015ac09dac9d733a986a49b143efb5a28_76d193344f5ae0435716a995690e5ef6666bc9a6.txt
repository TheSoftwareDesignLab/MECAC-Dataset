diff --git a/OsmAnd-java/src/main/java/net/osmand/GPXUtilities.java b/OsmAnd-java/src/main/java/net/osmand/GPXUtilities.java
index d48ec295b95..3d362c10c11 100644
--- a/OsmAnd-java/src/main/java/net/osmand/GPXUtilities.java
+++ b/OsmAnd-java/src/main/java/net/osmand/GPXUtilities.java
@@ -676,24 +676,17 @@ public GPXTrackAnalysis prepareInformation(long filestamp, SplitSegment... split
 			double totalSpeedSum = 0;
 			points = 0;
 
-			double channelThresMin = 10;           // Minimum oscillation amplitude considered as relevant or as above noise for accumulated Ascent/Descent analysis
-			double channelThres = channelThresMin; // Actual oscillation amplitude considered as above noise (dynamic channel adjustment, accomodates depedency on current VDOP/getAccuracy if desired)
-			double channelBase;
-			double channelTop;
-			double channelBottom;
-			boolean climb = false;
-
 			elevationData = new ArrayList<>();
 			speedData = new ArrayList<>();
 
-			for (SplitSegment s : splitSegments) {
+			for (final SplitSegment s : splitSegments) {
 				final int numberOfPoints = s.getNumberOfPoints();
-
-				channelBase = 99999;
-				channelTop = channelBase;
-				channelBottom = channelBase;
-				//channelThres = channelThresMin; //only for dynamic channel adjustment
-
+				ElevationDiffsCalculator elevationDiffsCalc = new ElevationDiffsCalculator(numberOfPoints) {
+					@Override
+					public WptPt getPoint(int index) {
+						return s.get(index);
+					}
+				};
 				float segmentDistance = 0f;
 				metricEnd += s.metricEnd;
 				secondaryMetricEnd += s.secondaryMetricEnd;
@@ -756,80 +749,7 @@ public GPXTrackAnalysis prepareInformation(long filestamp, SplitSegment... split
 						hasSpeedInTrack = true;
 					}
 
-					// Trend channel analysis for elevation gain/loss, Hardy 2015-09-22, LPF filtering added 2017-10-26:
-					// - Detect the consecutive elevation trend channels: Only use the net elevation changes of each trend channel (i.e. between the turnarounds) to accumulate the Ascent/Descent values.
-					// - Perform the channel evaluation on Low Pass Filter (LPF) smoothed ele data instead of on the raw ele data
-					// Parameters:
-					// - channelThresMin (in meters): defines the channel turnaround detection, i.e. oscillations smaller than this are ignored as irrelevant or noise.
-					// - smoothWindow (number of points): is the LPF window
-					// NOW REMOVED, as no relevant examples found: Dynamic channel adjustment: To suppress unreliable measurement points, could relax the turnaround detection from the constant channelThresMin to channelThres which is e.g. based on the maximum VDOP of any point which contributed to the current trend. (Good assumption is VDOP=2*HDOP, which accounts for invisibility of lower hemisphere satellites.)
-
-					// LPF smooting of ele data, usually smooth over odd number of values like 5
-					final int smoothWindow = 5;
-					double eleSmoothed = Double.NaN;
-					int j2 = 0;
-					for (int j1 = - smoothWindow + 1; j1 <= 0; j1++) {
-						if ((j + j1 >= 0) && !Double.isNaN(s.get(j + j1).ele)) {
-							j2++;
-							if (!Double.isNaN(eleSmoothed)) {
-								eleSmoothed = eleSmoothed + s.get(j + j1).ele;
-							} else {
-								eleSmoothed = s.get(j + j1).ele;
-							}
-						}
-					}
-					if (!Double.isNaN(eleSmoothed)) {
-						eleSmoothed = eleSmoothed / j2;
-					}
-
-					if (!Double.isNaN(eleSmoothed)) {
-						// Init channel
-						if (channelBase == 99999) {
-							channelBase = eleSmoothed;
-							channelTop = channelBase;
-							channelBottom = channelBase;
-							//channelThres = channelThresMin; //only for dynamic channel adjustment
-						}
-						// Channel maintenance
-						if (eleSmoothed > channelTop) {
-							channelTop = eleSmoothed;
-							//if (!Double.isNaN(point.hdop)) {
-							//	channelThres = Math.max(channelThres, 2.0 * point.hdop); //only for dynamic channel adjustment
-							//}
-						} else if (eleSmoothed < channelBottom) {
-							channelBottom = eleSmoothed;
-							//if (!Double.isNaN(point.hdop)) {
-							//	channelThres = Math.max(channelThres, 2.0 * point.hdop); //only for dynamic channel adjustment
-							//}
-						}
-						// Turnaround (breakout) detection
-						if ((eleSmoothed <= (channelTop - channelThres)) && (climb == true)) {
-							if ((channelTop - channelBase) >= channelThres) {
-								diffElevationUp += channelTop - channelBase;
-							}
-							channelBase = channelTop;
-							channelBottom = eleSmoothed;
-							climb = false;
-							//channelThres = channelThresMin; //only for dynamic channel adjustment
-						} else if ((eleSmoothed >= (channelBottom + channelThres)) && (climb == false)) {
-							if ((channelBase - channelBottom) >= channelThres) {
-								diffElevationDown += channelBase - channelBottom;
-							}
-							channelBase = channelBottom;
-							channelTop = eleSmoothed;
-							climb = true;
-							//channelThres = channelThresMin; //only for dynamic channel adjustment
-						}
-						// End detection without breakout
-						if (j == (numberOfPoints - 1)) {
-							if ((channelTop - channelBase) >= channelThres) {
-								diffElevationUp += channelTop - channelBase;
-							}
-							if ((channelBase - channelBottom) >= channelThres) {
-								diffElevationDown += channelBase - channelBottom;
-							}
-						}
-					}
+					elevationDiffsCalc.calculateElevationDiff(j);
 
 					if (j > 0) {
 						WptPt prev = s.get(j - 1);
@@ -925,6 +845,8 @@ public GPXTrackAnalysis prepareInformation(long filestamp, SplitSegment... split
 						}
 					}
 				}
+				diffElevationUp += elevationDiffsCalc.diffElevationUp;
+				diffElevationDown += elevationDiffsCalc.diffElevationDown;
 			}
 			if (totalDistance < 0) {
 				hasElevationData = false;
@@ -963,6 +885,115 @@ public GPXTrackAnalysis prepareInformation(long filestamp, SplitSegment... split
 			return this;
 		}
 
+		public abstract static class ElevationDiffsCalculator {
+
+			private final int numberOfPoints;
+
+			private final double channelThresMin = 10;           // Minimum oscillation amplitude considered as relevant or as above noise for accumulated Ascent/Descent analysis
+			private double channelThres = channelThresMin; // Actual oscillation amplitude considered as above noise (dynamic channel adjustment, accomodates depedency on current VDOP/getAccuracy if desired)
+			private double channelBase;
+			private double channelTop;
+			private double channelBottom;
+			private boolean climb = false;
+
+			private double diffElevationUp = 0;
+			private double diffElevationDown = 0;
+
+			public ElevationDiffsCalculator(int numberOfPoints) {
+				this.numberOfPoints = numberOfPoints;
+				channelBase = 99999;
+				channelTop = channelBase;
+				channelBottom = channelBase;
+				//channelThres = channelThresMin; //only for dynamic channel adjustment
+			}
+
+			public abstract WptPt getPoint(int index);
+
+			public double getDiffElevationUp() {
+				return diffElevationUp;
+			}
+
+			public double getDiffElevationDown() {
+				return diffElevationDown;
+			}
+
+			public void calculateElevationDiff(int index) {
+				// Trend channel analysis for elevation gain/loss, Hardy 2015-09-22, LPF filtering added 2017-10-26:
+				// - Detect the consecutive elevation trend channels: Only use the net elevation changes of each trend channel (i.e. between the turnarounds) to accumulate the Ascent/Descent values.
+				// - Perform the channel evaluation on Low Pass Filter (LPF) smoothed ele data instead of on the raw ele data
+				// Parameters:
+				// - channelThresMin (in meters): defines the channel turnaround detection, i.e. oscillations smaller than this are ignored as irrelevant or noise.
+				// - smoothWindow (number of points): is the LPF window
+				// NOW REMOVED, as no relevant examples found: Dynamic channel adjustment: To suppress unreliable measurement points, could relax the turnaround detection from the constant channelThresMin to channelThres which is e.g. based on the maximum VDOP of any point which contributed to the current trend. (Good assumption is VDOP=2*HDOP, which accounts for invisibility of lower hemisphere satellites.)
+
+				// LPF smooting of ele data, usually smooth over odd number of values like 5
+				final int smoothWindow = 5;
+				double eleSmoothed = Double.NaN;
+				int j2 = 0;
+				for (int j1 = -smoothWindow + 1; j1 <= 0; j1++) {
+					if ((index + j1 >= 0) && !Double.isNaN(getPoint(index + j1).ele)) {
+						j2++;
+						if (!Double.isNaN(eleSmoothed)) {
+							eleSmoothed = eleSmoothed + getPoint(index + j1).ele;
+						} else {
+							eleSmoothed = getPoint(index + j1).ele;
+						}
+					}
+				}
+				if (!Double.isNaN(eleSmoothed)) {
+					eleSmoothed = eleSmoothed / j2;
+				}
+
+				if (!Double.isNaN(eleSmoothed)) {
+					// Init channel
+					if (channelBase == 99999) {
+						channelBase = eleSmoothed;
+						channelTop = channelBase;
+						channelBottom = channelBase;
+						//channelThres = channelThresMin; //only for dynamic channel adjustment
+					}
+					// Channel maintenance
+					if (eleSmoothed > channelTop) {
+						channelTop = eleSmoothed;
+						//if (!Double.isNaN(point.hdop)) {
+						//	channelThres = Math.max(channelThres, 2.0 * point.hdop); //only for dynamic channel adjustment
+						//}
+					} else if (eleSmoothed < channelBottom) {
+						channelBottom = eleSmoothed;
+						//if (!Double.isNaN(point.hdop)) {
+						//	channelThres = Math.max(channelThres, 2.0 * point.hdop); //only for dynamic channel adjustment
+						//}
+					}
+					// Turnaround (breakout) detection
+					if ((eleSmoothed <= (channelTop - channelThres)) && (climb == true)) {
+						if ((channelTop - channelBase) >= channelThres) {
+							diffElevationUp += channelTop - channelBase;
+						}
+						channelBase = channelTop;
+						channelBottom = eleSmoothed;
+						climb = false;
+						//channelThres = channelThresMin; //only for dynamic channel adjustment
+					} else if ((eleSmoothed >= (channelBottom + channelThres)) && (climb == false)) {
+						if ((channelBase - channelBottom) >= channelThres) {
+							diffElevationDown += channelBase - channelBottom;
+						}
+						channelBase = channelBottom;
+						channelTop = eleSmoothed;
+						climb = true;
+						//channelThres = channelThresMin; //only for dynamic channel adjustment
+					}
+					// End detection without breakout
+					if (index == (numberOfPoints - 1)) {
+						if ((channelTop - channelBase) >= channelThres) {
+							diffElevationUp += channelTop - channelBase;
+						}
+						if ((channelBase - channelBottom) >= channelThres) {
+							diffElevationDown += channelBase - channelBottom;
+						}
+					}
+				}
+			}
+		}
 	}
 
 	private static class SplitSegment {
@@ -1368,7 +1399,7 @@ private SplitSegment createSplitSegment(TrkSegment segment,
 
 		public int getPointIndexByDistance(List<WptPt> points, double distance) {
 			int index = 0;
-			double minDistanceChange = 99999;
+			double minDistanceChange = Double.MAX_VALUE;
 			for (int i = 0; i < points.size(); i++) {
 				WptPt point = points.get(i);
 				double currentDistanceChange = Math.abs(point.distance - distance);
diff --git a/OsmAnd/src/net/osmand/plus/helpers/CustomBarChartRenderer.java b/OsmAnd/src/net/osmand/plus/helpers/CustomBarChartRenderer.java
index 3321399dbfa..f391fb3b7e8 100644
--- a/OsmAnd/src/net/osmand/plus/helpers/CustomBarChartRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/helpers/CustomBarChartRenderer.java
@@ -14,7 +14,7 @@ public class CustomBarChartRenderer extends HorizontalBarChartRenderer {
 	private float highlightHalfWidth;
 
 	public CustomBarChartRenderer(@NonNull BarChart chart) {
-		this(chart, AndroidUtils.dpToPx(chart.getContext(), 1f) / 2f);
+		this(chart, AndroidUtils.dpToPx(chart.getContext(), 2f) / 2f);
 	}
 
 	public CustomBarChartRenderer(@NonNull BarChart chart, float highlightHalfWidth) {
diff --git a/OsmAnd/src/net/osmand/plus/helpers/GpxUiHelper.java b/OsmAnd/src/net/osmand/plus/helpers/GpxUiHelper.java
index e59e0739165..293f7254758 100644
--- a/OsmAnd/src/net/osmand/plus/helpers/GpxUiHelper.java
+++ b/OsmAnd/src/net/osmand/plus/helpers/GpxUiHelper.java
@@ -1510,12 +1510,7 @@ public String getFormattedValue(float value) {
 
 		//dataSet.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);
 
-		dataSet.setFillFormatter(new IFillFormatter() {
-			@Override
-			public float getFillLinePosition(ILineDataSet dataSet, LineDataProvider dataProvider) {
-				return dataProvider.getYChartMin();
-			}
-		});
+		dataSet.setFillFormatter((ds, dataProvider) -> dataProvider.getYChartMin());
 		if (useRightAxis) {
 			dataSet.setAxisDependency(YAxis.AxisDependency.RIGHT);
 		}
@@ -1995,12 +1990,32 @@ public String getUnits() {
 		}
 	}
 
+	public static class GPXHighlight extends Highlight {
+
+		private final boolean showIcon;
+
+		public GPXHighlight(float x, int dataSetIndex, boolean showIcon) {
+			super(x, Float.NaN, dataSetIndex);
+			this.showIcon = showIcon;
+		}
+
+		public GPXHighlight(float x, float y, int dataSetIndex, boolean showIcon) {
+			super(x, y, dataSetIndex);
+			this.showIcon = showIcon;
+		}
+
+		public boolean shouldShowIcon() {
+			return showIcon;
+		}
+	}
+
 	@SuppressLint("ViewConstructor")
 	private static class GPXMarkerView extends MarkerView {
 
 		private final View textAltView;
 		private final View textSpdView;
 		private final View textSlpView;
+		private final boolean hasIcon;
 
 		public GPXMarkerView(@NonNull Context context,
 		                     @Nullable Drawable icon) {
@@ -2013,13 +2028,19 @@ public GPXMarkerView(@NonNull Context context,
 				findViewById(R.id.icon_container).setVisibility(VISIBLE);
 				((ImageView) findViewById(R.id.icon)).setImageDrawable(icon);
 			}
+			hasIcon = icon != null;
 		}
 
 		// callbacks everytime the MarkerView is redrawn, can be used to update the
 		// content (user-interface)
 		@Override
 		public void refreshContent(Entry e, Highlight highlight) {
-			ChartData chartData = getChartView().getData();
+			ChartData<?> chartData = getChartView().getData();
+			if (hasIcon && highlight instanceof GPXHighlight) {
+				boolean showIcon = ((GPXHighlight) highlight).shouldShowIcon();
+				AndroidUiHelper.setVisibility(showIcon ? VISIBLE : GONE, findViewById(R.id.icon_divider));
+				AndroidUiHelper.setVisibility(showIcon ? VISIBLE : GONE, findViewById(R.id.icon_container));
+			}
 			if (chartData.getDataSetCount() == 1) {
 				OrderedLineDataSet dataSet = (OrderedLineDataSet) chartData.getDataSetByIndex(0);
 				String value = (int) e.getY() + " ";
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
index 61cb8ef91d9..956ab374d7c 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
@@ -1202,9 +1202,8 @@ public Location getNextRouteLocation() {
 		return null;
 	}
 
-
 	public Location getNextRouteLocation(int after) {
-		if (currentRoute + after < locations.size()) {
+		if (currentRoute + after >= 0 && currentRoute + after < locations.size()) {
 			return locations.get(currentRoute + after);
 		}
 		return null;
@@ -1236,6 +1235,13 @@ public int getDistanceFromPoint(int locationIndex) {
 		return 0;
 	}
 
+	public int getDistanceFromStart() {
+		if (listDistance != null && currentRoute < listDistance.length) {
+			return listDistance[0] - listDistance[currentRoute];
+		}
+		return 0;
+	}
+
 	public boolean isPointPassed(int locationIndex) {
 		return locationIndex <= currentRoute;
 	}
diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/ElevationProfileWidget.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/ElevationProfileWidget.java
index 7fbd45576fe..69223876e48 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/ElevationProfileWidget.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/ElevationProfileWidget.java
@@ -3,28 +3,32 @@
 import android.graphics.Matrix;
 import android.graphics.Typeface;
 import android.graphics.drawable.Drawable;
-import android.util.Pair;
+import android.util.Log;
+import android.view.MotionEvent;
 import android.view.View;
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
 import com.github.mikephil.charting.charts.LineChart;
 import com.github.mikephil.charting.components.YAxis.AxisDependency;
+import com.github.mikephil.charting.data.DataSet;
+import com.github.mikephil.charting.data.Entry;
 import com.github.mikephil.charting.data.LineData;
+import com.github.mikephil.charting.highlight.Highlight;
 import com.github.mikephil.charting.interfaces.datasets.ILineDataSet;
+import com.github.mikephil.charting.listener.ChartTouchListener.ChartGesture;
+import com.github.mikephil.charting.listener.OnChartGestureListener;
 import com.github.mikephil.charting.utils.Transformer;
 import com.github.mikephil.charting.utils.ViewPortHandler;
 
 import net.osmand.GPXUtilities.GPXFile;
 import net.osmand.GPXUtilities.GPXTrackAnalysis;
+import net.osmand.GPXUtilities.GPXTrackAnalysis.ElevationDiffsCalculator;
 import net.osmand.GPXUtilities.TrkSegment;
 import net.osmand.GPXUtilities.WptPt;
 import net.osmand.Location;
-import net.osmand.data.LatLon;
-import net.osmand.data.RotatedTileBox;
 import net.osmand.plus.GpxSelectionHelper.GpxDisplayItem;
 import net.osmand.plus.OsmAndFormatter;
 import net.osmand.plus.OsmandApplication;
@@ -33,22 +37,19 @@
 import net.osmand.plus.helpers.AndroidUiHelper;
 import net.osmand.plus.helpers.GpxUiHelper;
 import net.osmand.plus.helpers.GpxUiHelper.GPXDataSetAxisType;
+import net.osmand.plus.helpers.GpxUiHelper.GPXHighlight;
 import net.osmand.plus.helpers.GpxUiHelper.OrderedLineDataSet;
 import net.osmand.plus.mapcontextmenu.other.TrackDetailsMenu;
 import net.osmand.plus.mapcontextmenu.other.TrackDetailsMenu.ChartPointLayer;
 import net.osmand.plus.measurementtool.graph.BaseCommonChartAdapter;
 import net.osmand.plus.routing.RouteCalculationResult;
 import net.osmand.plus.settings.backend.OsmandSettings;
-import net.osmand.plus.views.layers.GPXLayer;
-import net.osmand.plus.views.layers.MapQuickActionLayer;
 import net.osmand.util.Algorithms;
 import net.osmand.util.MapUtils;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static net.osmand.plus.mapcontextmenu.other.TrackDetailsMenu.MAX_DISTANCE_LOCATION_PROJECTION;
-
 public class ElevationProfileWidget {
 
 	private static final int MAX_DISTANCE_TO_SHOW_IM_METERS = 10_000;
@@ -70,9 +71,13 @@ public class ElevationProfileWidget {
 	private GPXFile gpx;
 	private float toMetersMultiplier;
 	private Location myLocation;
+	private List<WptPt> allPoints;
 
 	private boolean showSlopes = false;
 	private RouteCalculationResult route;
+	private int firstVisiblePointIndex = -1;
+	private int lastVisiblePointIndex = -1;
+	private OrderedLineDataSet slopeDataSet;
 
 	public ElevationProfileWidget(MapActivity map) {
 		this.map = map;
@@ -124,11 +129,14 @@ public void updateInfo() {
 	}
 
 	private void updateInfoImpl() {
-		if (updateSettings()) {
+		boolean settingsUpdated = updateSettings();
+		if (settingsUpdated) {
 			setupChart();
 		}
-		updateChart();
-		updateWidgets();
+		boolean chartUpdated = updateChart(settingsUpdated);
+		if (chartUpdated) {
+			updateWidgets();
+		}
 	}
 
 	private boolean updateSettings() {
@@ -144,7 +152,11 @@ private boolean updateSettings() {
 	private void setupChart() {
 		gpx = GpxUiHelper.makeGpxFromRoute(app.getRoutingHelper().getRoute(), app);
 		analysis = gpx.getAnalysis(0);
+		allPoints = gpx.getAllSegmentsPoints();
 		gpxItem = GpxUiHelper.makeGpxDisplayItem(app, gpx, ChartPointLayer.ROUTE);
+		firstVisiblePointIndex = -1;
+		lastVisiblePointIndex = -1;
+		slopeDataSet = null;
 
 		chart = view.findViewById(R.id.line_chart);
 		Drawable markerIcon = app.getUIUtilities().getIcon(R.drawable.ic_action_location_color);
@@ -159,13 +171,12 @@ private void setupChart() {
 					GPXDataSetAxisType.DISTANCE, false, true, false);
 			dataSets.add(elevationDataSet);
 
-			if (showSlopes) {
-				OrderedLineDataSet slopeDataSet = GpxUiHelper.createGPXSlopeDataSet(app, chart, analysis,
-						GPXDataSetAxisType.DISTANCE, elevationDataSet.getValues(), true, true, false);
-				if (slopeDataSet != null) {
-					dataSets.add(slopeDataSet);
-				}
+			OrderedLineDataSet slopeDataSet = GpxUiHelper.createGPXSlopeDataSet(app, chart, analysis,
+					GPXDataSetAxisType.DISTANCE, elevationDataSet.getValues(), true, true, false);
+			if (showSlopes && slopeDataSet != null) {
+				dataSets.add(slopeDataSet);
 			}
+			this.slopeDataSet = slopeDataSet;
 
 			chartAdapter.updateContent(new LineData(dataSets), gpxItem);
 			toMetersMultiplier = ((OrderedLineDataSet) dataSets.get(0)).getDivX();
@@ -175,80 +186,210 @@ private void setupChart() {
 		} else {
 			chart.setVisibility(View.GONE);
 		}
+		segment = TrackDetailsMenu.getTrackSegment(chart, gpxItem);
+		chart.setOnChartGestureListener(new OnChartGestureListener() {
+			boolean hasTranslated = false;
+			float highlightDrawX = -1;
+
+			@Override
+			public void onChartGestureStart(MotionEvent me, ChartGesture lastPerformedGesture) {
+				hasTranslated = false;
+				Highlight[] highlighted = chart.getHighlighted();
+				boolean setupDrawX = false;
+				if (highlighted != null && highlighted.length > 0) {
+					for (Highlight highlight : highlighted) {
+						if (highlight != locationHighlight) {
+							highlightDrawX = highlight.getDrawX();
+							setupDrawX = true;
+							break;
+						}
+					}
+				}
+				if (!setupDrawX) {
+					highlightDrawX = -1;
+				}
+			}
+
+			@Override
+			public void onChartGestureEnd(MotionEvent me, ChartGesture lastPerformedGesture) {
+				gpxItem.chartMatrix = new Matrix(chart.getViewPortHandler().getMatrixTouch());
+			}
+
+			@Override
+			public void onChartLongPressed(MotionEvent me) {
+			}
+
+			@Override
+			public void onChartDoubleTapped(MotionEvent me) {
+			}
+
+			@Override
+			public void onChartSingleTapped(MotionEvent me) {
+				Highlight h = chart.getHighlightByTouchPoint(me.getX(), me.getY());
+				Highlight locationHighlight = ElevationProfileWidget.this.locationHighlight;
+				h = createHighlight(h.getX(), false);
+				if (locationHighlight != null) {
+					chart.highlightValues(new Highlight[]{locationHighlight, h});
+				} else {
+					chart.highlightValue(h, true);
+				}
+			}
+
+			@Override
+			public void onChartFling(MotionEvent me1, MotionEvent me2, float velocityX, float velocityY) {
+			}
+
+			@Override
+			public void onChartScale(MotionEvent me, float scaleX, float scaleY) {
+			}
+
+			@Override
+			public void onChartTranslate(MotionEvent me, float dX, float dY) {
+				hasTranslated = true;
+				if (highlightDrawX != -1) {
+					Highlight h = chart.getHighlightByTouchPoint(highlightDrawX, 0f);
+					if (h != null) {
+						h = createHighlight(h.getX(), false);
+						if (locationHighlight != null) {
+							chart.highlightValues(new Highlight[]{locationHighlight, h});
+						} else {
+							chart.highlightValue(h, true);
+						}
+					}
+				}
+				app.runInUIThread(() -> updateWidgets());
+			}
+		});
 	}
 
-	private void updateChart() {
+	private Highlight locationHighlight;
+
+	private boolean updateChart(boolean forceUpdate) {
 		Location location = app.getLocationProvider().getLastKnownLocation();
-		if (myLocation != null && MapUtils.areLatLonEqual(myLocation, location)) return;
+		if (!forceUpdate && myLocation != null && MapUtils.areLatLonEqual(myLocation, location)) {
+			return false;
+		}
 		myLocation = location;
-
-		TrkSegment segment = getTrackSegment(chart);
+		if (location == null) {
+			gpxItem.chartHighlightPos = -1f;
+			refreshHighlights(null);
+			return true;
+		}
 		LineData lineData = chart.getLineData();
 		List<ILineDataSet> ds = lineData != null ? lineData.getDataSets() : null;
-		if (Algorithms.isEmpty(ds) || gpxItem == null || segment == null) return;
-
-		RotatedTileBox tb = map.getMapView().getCurrentRotatedTileBox();
-		int mx = (int) tb.getPixXFromLatLon(location.getLatitude(), location.getLongitude());
-		int my = (int) tb.getPixYFromLatLon(location.getLatitude(), location.getLongitude());
-		int r = (int) (MAX_DISTANCE_LOCATION_PROJECTION * tb.getPixDensity());
-		Pair<WptPt, WptPt> points = GPXLayer.findPointsNearSegment(tb, segment.points, r, mx, my);
-		if (points != null) {
-			LatLon latLon = tb.getLatLonFromPixel(mx, my);
-			gpxItem.locationOnMap = GPXLayer.createProjectionPoint(points.first, points.second, latLon);
-
-			double totalDistance = 0;
-			int index = segment.points.indexOf(points.first);
-			if (index != -1) {
-				WptPt previousPoint = null;
-				for (int i = 0; i < index; i++) {
-					WptPt currentPoint = segment.points.get(i);
-					if (previousPoint != null) {
-						totalDistance += MapUtils.getDistance(previousPoint.lat, previousPoint.lon, currentPoint.lat, currentPoint.lon);
-					}
-					previousPoint = currentPoint;
-				}
+		RouteCalculationResult route = this.route;
+		TrkSegment segment = this.segment;
+		if (Algorithms.isEmpty(ds) || gpxItem == null || route == null || segment == null) {
+			return false;
+		}
+		float distanceFromStart = route.getDistanceFromStart();
+		if (distanceFromStart == 0) {
+			gpxItem.chartHighlightPos = -1f;
+			refreshHighlights(null);
+			return true;
+		}
+		float minVisibleX = chart.getLowestVisibleX();
+		float maxVisibleX = chart.getHighestVisibleX();
+		float twentyPercent = ((maxVisibleX - minVisibleX) / 5);
+		float startMoveChartPosition = minVisibleX + twentyPercent;
+		float pos = distanceFromStart / ((OrderedLineDataSet) ds.get(0)).getDivX();
+
+		if (pos >= minVisibleX && pos <= maxVisibleX) {
+			if (pos >= startMoveChartPosition) {
+				float nextVisibleX = pos - twentyPercent;
+				moveViewToX(chart, nextVisibleX);
 			}
+			gpxItem.chartHighlightPos = pos;
+			Highlight newLocationHighlight = createHighlight(pos, true);
+			refreshHighlights(newLocationHighlight);
+		}
+		return true;
+	}
 
-			float minVisibleX = chart.getLowestVisibleX();
-			float maxVisibleX = chart.getHighestVisibleX();
-			float twentyPercent = ((maxVisibleX - minVisibleX) / 5);
-			float startMoveChartPosition = minVisibleX + twentyPercent;
-			float pos = (float) (totalDistance / ((OrderedLineDataSet) ds.get(0)).getDivX());
-
-			if (pos >= minVisibleX && pos <= maxVisibleX) {
-				if (pos >= startMoveChartPosition) {
-					float nextVisibleX = pos - twentyPercent;
-					moveViewToX(chart, nextVisibleX);
+	private void refreshHighlights(@Nullable Highlight newLocationHighlight) {
+		Highlight[] highlighted = chart.getHighlighted();
+		int replaceIndex = -1;
+		if (highlighted != null) {
+			for (int i = 0; i < highlighted.length; i++) {
+				Highlight highlight = highlighted[i];
+				if (highlight == locationHighlight) {
+					replaceIndex = i;
+					break;
 				}
-				gpxItem.chartHighlightPos = pos;
-				chart.highlightValue(gpxItem.chartHighlightPos, 0);
-
-				chart.notifyDataSetChanged();
-				chart.invalidate();
 			}
 		}
+		locationHighlight = newLocationHighlight;
+		if (replaceIndex != -1) {
+			if (newLocationHighlight != null) {
+				highlighted[replaceIndex] = newLocationHighlight;
+			} else {
+				Highlight[] newHighlighted = new Highlight[highlighted.length - 1];
+				int k = 0;
+				for (int i = 0; i < highlighted.length; i++) {
+					if (i != replaceIndex) {
+						newHighlighted[k++] = highlighted[i];
+					}
+				}
+				highlighted = newHighlighted;
+			}
+		} else if (newLocationHighlight != null) {
+			if (highlighted == null) {
+				highlighted = new Highlight[]{newLocationHighlight};
+			} else {
+				Highlight[] newHighlighted = new Highlight[highlighted.length + 1];
+				newHighlighted[0] = newLocationHighlight;
+				System.arraycopy(highlighted, 0, newHighlighted, 1, highlighted.length);
+				highlighted = newHighlighted;
+			}
+		}
+		chart.highlightValues(highlighted);
+	}
+
+	private Highlight createHighlight(float x, boolean location) {
+		return new GPXHighlight(x, 0, location);
 	}
 
-	private void updateWidgets() {
+	private boolean updateWidgets() {
 		double minVisibleX = chart.getLowestVisibleX();
 		double maxVisibleX = chart.getHighestVisibleX();
 		float highlightPosition = gpxItem != null ? gpxItem.chartHighlightPos : -1f;
-
-		if (highlightPosition != -1) {
+		if (highlightPosition > minVisibleX && highlightPosition < maxVisibleX) {
 			minVisibleX = highlightPosition;
 		}
-
 		double fromDistance = minVisibleX * toMetersMultiplier;
 		double toDistance = maxVisibleX * toMetersMultiplier;
-
-		GPXTrackAnalysis analysis = gpx.getAnalysis(0, fromDistance, toDistance);
-		String uphill = OsmAndFormatter.getFormattedAlt(analysis.diffElevationUp, app);
-		String downhill = OsmAndFormatter.getFormattedAlt(analysis.diffElevationDown, app);
-		String grade = calculateGrade() + " %";
-
-		updateTextWidget(uphillView, uphill);
-		updateTextWidget(downhillView, downhill);
-		updateTextWidget(gradeView, grade);
+		final List<WptPt> points = this.allPoints;
+		int firstPointIndex = gpx.getPointIndexByDistance(points, fromDistance);
+		int lastPointIndex = gpx.getPointIndexByDistance(points, toDistance);
+		if (firstVisiblePointIndex == firstPointIndex && lastVisiblePointIndex == lastPointIndex) {
+			return false;
+		}
+		firstVisiblePointIndex = firstPointIndex;
+		lastVisiblePointIndex = lastPointIndex;
+		if (firstPointIndex >= 0 && lastPointIndex > firstPointIndex) {
+			ElevationDiffsCalculator elevationDiffsCalc = new ElevationDiffsCalculator(lastPointIndex - firstPointIndex + 1) {
+				@Override
+				public WptPt getPoint(int index) {
+					return points.get(index);
+				}
+			};
+			for (int i = firstPointIndex; i <= lastPointIndex; i++) {
+				elevationDiffsCalc.calculateElevationDiff(i);
+			}
+			String uphill = OsmAndFormatter.getFormattedAlt(elevationDiffsCalc.getDiffElevationUp(), app);
+			updateTextWidget(uphillView, uphill);
+			String downhill = OsmAndFormatter.getFormattedAlt(elevationDiffsCalc.getDiffElevationDown(), app);
+			updateTextWidget(downhillView, downhill);
+		}
+		int maxGrade = calculateMaxGrade();
+		String maxGradeStr;
+		if (maxGrade == Integer.MAX_VALUE) {
+			maxGradeStr = "--";
+		} else {
+			maxGradeStr = maxGrade + " %";
+		}
+		updateTextWidget(gradeView, maxGradeStr);
+		return true;
 	}
 
 	private void updateTextWidget(View container, String text) {
@@ -256,11 +397,37 @@ private void updateTextWidget(View container, String text) {
 		if (split.length == 2) {
 			((TextView) container.findViewById(R.id.widget_text)).setText(split[0]);
 			((TextView) container.findViewById(R.id.widget_text_small)).setText(split[1]);
+		} else {
+			((TextView) container.findViewById(R.id.widget_text)).setText(text);
+			((TextView) container.findViewById(R.id.widget_text_small)).setText("");
 		}
 	}
 
-	private int calculateGrade() {
-		return 0;
+	private int calculateMaxGrade() {
+		OrderedLineDataSet slopeDataSet = this.slopeDataSet;
+		if (slopeDataSet == null) {
+			return Integer.MAX_VALUE;
+		}
+		float minVisibleX = chart.getLowestVisibleX();
+		float maxVisibleX = chart.getHighestVisibleX();
+		float highlightPosition = gpxItem != null ? gpxItem.chartHighlightPos : -1f;
+		if (highlightPosition > minVisibleX && highlightPosition < maxVisibleX) {
+			minVisibleX = highlightPosition;
+		}
+		int firstEntryIndex = slopeDataSet.getEntryIndex(minVisibleX, Float.NaN, DataSet.Rounding.CLOSEST);
+		int lastEntryIndex = slopeDataSet.getEntryIndex(maxVisibleX, Float.NaN, DataSet.Rounding.CLOSEST);
+		if (firstEntryIndex == -1 || lastEntryIndex == -1) {
+			return Integer.MAX_VALUE;
+		}
+		float maxValue = 0;
+		for (int i = firstEntryIndex; i <= lastEntryIndex; i++) {
+			Entry e = slopeDataSet.getEntryForIndex(i);
+			float v = e.getY();
+			if (Math.abs(v) > Math.abs(maxValue)) {
+				maxValue = v;
+			}
+		}
+		return (int) maxValue;
 	}
 
 	private void setupZoom(LineChart chart) {
@@ -273,14 +440,6 @@ private void setupZoom(LineChart chart) {
 		}
 	}
 
-	@Nullable
-	private TrkSegment getTrackSegment(@NonNull LineChart chart) {
-		if (segment == null) {
-			segment = TrackDetailsMenu.getTrackSegment(chart, gpxItem);
-		}
-		return segment;
-	}
-
 	private boolean isNightMode() {
 		return app.getDaynightHelper().isNightModeForMapControls();
 	}
