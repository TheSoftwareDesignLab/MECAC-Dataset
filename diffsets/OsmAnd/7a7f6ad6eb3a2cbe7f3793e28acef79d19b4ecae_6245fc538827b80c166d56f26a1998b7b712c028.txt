diff --git a/DataExtractionOSM/src/com/osmand/ToDoConstants.java b/DataExtractionOSM/src/com/osmand/ToDoConstants.java
index 83b82117bf3..8ac9cc360f2 100644
--- a/DataExtractionOSM/src/com/osmand/ToDoConstants.java
+++ b/DataExtractionOSM/src/com/osmand/ToDoConstants.java
@@ -22,11 +22,18 @@ public class ToDoConstants {
 	//   Improvement : Show stops in the transport route on the map
 	//   Improvement : redesign poi selecting (show on map )
 	///  Better : improve zooming (better zoom out)
+	//   Add menu mute for voice
 	//   BUG with search area for poi/transport bounds region
+	//   BUG with foot navigation (unavailable for cloudmade)
+	//   BUG animated move more precise check final location
+	//   BUG turn concatenation
+	///  BUG Settings for osm bug creator name (save)
+	//   BUG 9
+	
 	//   69. Add phone information to POI
 	
 	// Not clear if it is really needed 
-    //   43. Enable poi filter by name (find lake by name or shop) - case sensitive search DB!
+    //   43. Enable poi filter by name (find lake by name or shop) - case sensitive search DB - make only search filter (on UI)!
 	//   45. Get clear <Use internet> settings. Move that setting on top settings screen. 
 	//       That setting should rule all activities that use internet. It should ask whenever internet is used 
 	//		(would you like to use internet for that operation - if using internet is not checked). 
@@ -41,7 +48,6 @@ public class ToDoConstants {
 
 
 	// BUGS Android
- 
 	
 	// TODO swing
 	// 9. Fix issues with big files (such as netherlands) - save memory (!) - very slow due to transport index !
diff --git a/OsmAnd/AndroidManifest.xml b/OsmAnd/AndroidManifest.xml
index 0c2dc7c39a9..57417ecdbe5 100644
--- a/OsmAnd/AndroidManifest.xml
+++ b/OsmAnd/AndroidManifest.xml
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
-	package="com.osmand" android:versionName="0.2.2" android:versionCode="5">
+	package="com.osmand" android:versionName="0.2.3" android:versionCode="6">
 	<application android:icon="@drawable/icon" android:label="@string/app_name"
-		android:debuggable="true" android:name=".activities.OsmandApplication" android:description="@string/app_description">
+		android:debuggable="false" android:name=".activities.OsmandApplication" android:description="@string/app_description">
 		<activity android:name=".activities.MainMenuActivity"
 			android:label="@string/app_name">
 			<intent-filter>
diff --git a/OsmAnd/src/com/osmand/activities/MapActivity.java b/OsmAnd/src/com/osmand/activities/MapActivity.java
index 85a96d92601..295257cd7ce 100644
--- a/OsmAnd/src/com/osmand/activities/MapActivity.java
+++ b/OsmAnd/src/com/osmand/activities/MapActivity.java
@@ -828,7 +828,9 @@ public void onClick(DialogInterface dialog, int which) {
     		builder.setNeutralButton(R.string.route_about, new DialogInterface.OnClickListener(){
 				@Override
 				public void onClick(DialogInterface dialog, int which) {
-					startActivity(new Intent(MapActivity.this, ShowRouteInfoActivity.class));
+					Intent intent = new Intent(MapActivity.this, ShowRouteInfoActivity.class);
+					intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+					startActivity(intent);
 				}
     		});
     	}
@@ -836,7 +838,6 @@ public void onClick(DialogInterface dialog, int which) {
 
 			@Override
 			public void onClick(DialogInterface dialog, int which) {
-				
 				Location map = new Location("map"); //$NON-NLS-1$
 				map.setLatitude(lat);
 				map.setLongitude(lon);
diff --git a/OsmAnd/src/com/osmand/activities/RouteProvider.java b/OsmAnd/src/com/osmand/activities/RouteProvider.java
index 0990bcaad97..bdc4aed5520 100644
--- a/OsmAnd/src/com/osmand/activities/RouteProvider.java
+++ b/OsmAnd/src/com/osmand/activities/RouteProvider.java
@@ -504,16 +504,14 @@ protected RouteCalculationResult findCloudMadeRoute(Location start, LatLon end,
 						} else {
 							caz = res.get(dirInfo.routePointOffset - 1).bearingTo(res.get(dirInfo.routePointOffset));
 						}
-						float angle = caz  - paz + 15; 
+						float angle = caz  - paz; 
 						if(angle < 0){
 							angle += 360;
 						} else if(angle > 360){
 							angle -= 360;
 						}
 						// that magic number helps to fix some errors for turn
-						if(angle < 100){
-							angle += 45;
-						}
+						angle += 75;
 
 						if(previous.turnType.getTurnAngle() < 0.5f){
 							previous.turnType.setTurnAngle(angle);
diff --git a/OsmAnd/src/com/osmand/activities/RoutingHelper.java b/OsmAnd/src/com/osmand/activities/RoutingHelper.java
index c6a0cc991ff..cbe4d4bea85 100644
--- a/OsmAnd/src/com/osmand/activities/RoutingHelper.java
+++ b/OsmAnd/src/com/osmand/activities/RoutingHelper.java
@@ -34,8 +34,8 @@ public class RoutingHelper {
 
 	// Note always currentRoute > get(currentDirectionInfo).routeOffset, 
 	//         but currentRoute <= get(currentDirectionInfo+1).routeOffset 
-	private int currentDirectionInfo = 0;
-	private int currentRoute = 0;
+	protected int currentDirectionInfo = 0;
+	protected int currentRoute = 0;
 	
 	
 	private LatLon finalLocation;
@@ -47,6 +47,7 @@ public class RoutingHelper {
 	private ApplicationMode mode;
 	
 	private RouteProvider provider = new RouteProvider();
+	private VoiceRouter voiceRouter;
 	
 	
 	// TEST CODE
@@ -66,11 +67,13 @@ public class RoutingHelper {
 	
 	
 	private RoutingHelper(){
+		voiceRouter = new VoiceRouter(this);
 	}
 	
 	private static RoutingHelper INSTANCE = new RoutingHelper(); 
 	public static RoutingHelper getInstance(Activity ctx){
 		INSTANCE.activity = ctx;
+		INSTANCE.voiceRouter.init(ctx);
 		return INSTANCE;
 	}
 	
@@ -100,6 +103,7 @@ public void setFinalLocation(LatLon finalLocation){
 	
 	public void setAppMode(ApplicationMode mode){
 		this.mode = mode;
+		voiceRouter.updateAppMode();
 	}
 	
 	public ApplicationMode getAppMode() {
@@ -115,12 +119,17 @@ public boolean isRouterEnabled(){
 		return finalLocation != null && lastFixedLocation != null;
 	}
 	
+	public VoiceRouter getVoiceRouter() {
+		return voiceRouter;
+	}
+	
 	
 	public boolean finishAtLocation(Location currentLocation) {
 		Location lastPoint = routeNodes.get(routeNodes.size() - 1);
 		if(currentRoute > routeNodes.size() - 3 && currentLocation.distanceTo(lastPoint) < 60){
 			if(lastFixedLocation != null && lastFixedLocation.distanceTo(lastPoint) < 60){
 				showMessage(activity.getString(R.string.arrived_at_destination));
+				voiceRouter.arrivedDestinationPoint();
 				updateCurrentRoute(routeNodes.size() - 1);
 				// clear final location to prevent all time showing message
 				finalLocation = null;
@@ -286,6 +295,7 @@ public void setCurrentLocation(Location currentLocation) {
 //				}
 			}
 		}
+		voiceRouter.updateStatus();
 
 		lastFixedLocation = currentLocation;
 		if(calculateRoute){
@@ -299,6 +309,9 @@ private void setNewRoute(RouteCalculationResult res){
 		listDistance = res.getListDistance();
 		currentDirectionInfo = 0;
 		currentRoute = 0;
+		if(isFollowingMode){
+			voiceRouter.newRouteIsCalculated();
+		}
 	}
 	
 	public synchronized int getLeftDistance(){
@@ -327,6 +340,12 @@ public RouteDirectionInfo getNextRouteDirectionInfo(){
 		}
 		return null;
 	}
+	public RouteDirectionInfo getNextNextRouteDirectionInfo(){
+		if(directionInfo != null && currentDirectionInfo < directionInfo.size() - 2){
+			return directionInfo.get(currentDirectionInfo + 2);
+		}
+		return null;
+	}
 	
 	public List<RouteDirectionInfo> getRouteDirections(){
 		if(directionInfo != null && currentDirectionInfo < directionInfo.size()){
@@ -509,11 +528,13 @@ private TurnType(String value, int exitOut){
 			this.value = value;
 			this.exitOut = exitOut;
 		}
-		
+
+		// calculated CW head rotation if previous direction to NORTH
 		public float getTurnAngle() {
 			return turnAngle;
 		}
 		
+
 		public void setTurnAngle(float turnAngle) {
 			this.turnAngle = turnAngle;
 		}
diff --git a/OsmAnd/src/com/osmand/activities/ShowRouteInfoActivity.java b/OsmAnd/src/com/osmand/activities/ShowRouteInfoActivity.java
index 3f86559a3a2..7a4df65b7ea 100644
--- a/OsmAnd/src/com/osmand/activities/ShowRouteInfoActivity.java
+++ b/OsmAnd/src/com/osmand/activities/ShowRouteInfoActivity.java
@@ -34,8 +34,6 @@
 import com.osmand.activities.RoutingHelper.TurnType;
 import com.osmand.osm.MapUtils;
 import com.osmand.views.MapInfoLayer;
-import com.osmand.voice.CommandPlayer;
-import com.osmand.voice.CommandPlayer.CommandBuilder;
 
 /**
  * 
@@ -65,30 +63,6 @@ public void onCreate(Bundle icicle) {
 	public void onListItemClick(ListView parent, View v, int position, long id) {
 		RouteDirectionInfo item = ((RouteInfoAdapter)getListAdapter()).getItem(position - 1);
 		Location loc = helper.getLocationFromRouteDirection(item);
-		CommandPlayer player = CommandPlayer.getInstance(this);
-		if(player != null){
-			CommandBuilder builder = player.newCommandBuilder();
-			if(item.turnType.getValue() == TurnType.C){
-				builder.goAhead(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TU){
-				builder.makeUT(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TL){
-				builder.turnLeft(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TSLL) { 
-				builder.turnSLLeft(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TSHL) { 
-				builder.turnSHLeft(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TR){
-				builder.turnRight(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TSLR) { 
-				builder.turnSLRight(item.distance);
-			} else if(item.turnType.getValue() == TurnType.TSHR) { 
-				builder.turnSHRight(item.distance);
-			} else if(item.turnType.isRoundAbout()) { 
-				builder.roundAbout(item.distance, item.turnType.getExitOut());
-			}
-			builder.play();
-		}
 		if(loc != null){
 			OsmandSettings.setMapLocationToShow(this, loc.getLatitude(),loc.getLongitude());
 			startActivity(new Intent(this, MapActivity.class));
diff --git a/OsmAnd/src/com/osmand/activities/VoiceRouter.java b/OsmAnd/src/com/osmand/activities/VoiceRouter.java
new file mode 100644
index 00000000000..08138784210
--- /dev/null
+++ b/OsmAnd/src/com/osmand/activities/VoiceRouter.java
@@ -0,0 +1,230 @@
+package com.osmand.activities;
+
+import android.content.Context;
+
+import com.osmand.OsmandSettings.ApplicationMode;
+import com.osmand.activities.RoutingHelper.RouteDirectionInfo;
+import com.osmand.activities.RoutingHelper.TurnType;
+import com.osmand.voice.CommandPlayer;
+import com.osmand.voice.CommandPlayer.CommandBuilder;
+
+public class VoiceRouter {
+	
+	private final RoutingHelper router;
+	private boolean mute = false;
+	private CommandPlayer player;
+	
+	private int currentDirection = 0;
+	// 0 - unknown, 1 - notify prepare, 2 - notify to turn after , 3 - notify to turn 
+	private int currentStatus = 0;
+
+	public VoiceRouter(RoutingHelper router){
+		this.router = router;
+		updateAppMode();
+	}
+	
+	protected void init(Context ctx){
+		player = CommandPlayer.getInstance(ctx);
+	}
+	
+	public void setMute(boolean mute) {
+		this.mute = mute;
+	}
+	
+	public boolean isMute() {
+		return mute;
+	}
+	
+	
+	protected CommandBuilder getNewCommandPlayerToPlay(){
+		if(player == null || mute){
+			return null;
+		}
+		return player.newCommandBuilder();
+	}
+	
+	protected int PREPARE_DISTANCE = 0;
+	protected int TURN_IN_DISTANCE = 0;
+	protected int TURN_DISTANCE = 0;
+	
+	public void updateAppMode(){
+		if(router.getAppMode() == ApplicationMode.PEDESTRIAN){
+			PREPARE_DISTANCE = 400;
+			TURN_IN_DISTANCE = 150;
+			TURN_DISTANCE = 20;
+		} else if(router.getAppMode() == ApplicationMode.BICYCLE){
+			PREPARE_DISTANCE = 550;
+			TURN_IN_DISTANCE = 200;
+			TURN_DISTANCE = 40;
+		} else {
+			PREPARE_DISTANCE = 800;
+			TURN_IN_DISTANCE = 300;
+			TURN_DISTANCE = 70;
+		}
+	}
+	
+	
+	
+	protected void updateStatus(){
+		// directly after turn (go - ahead dist)
+		// < 800m prepare
+		// < 200m turn in
+		// < 50m turn
+		if(currentDirection != router.currentDirectionInfo){
+			currentDirection = router.currentDirectionInfo;
+			currentStatus = 0;
+		}
+		RouteDirectionInfo next = router.getNextRouteDirectionInfo();
+		int dist = router.getDistanceToNextRouteDirection();
+		if(next == null && currentDirection > 0) {
+			if(currentStatus == 0){
+				CommandBuilder play = getNewCommandPlayerToPlay();
+				if(play != null){
+					play.goAhead(router.getLeftDistance()).andArriveAtDestination().play();
+				}
+				currentStatus = 1;
+			}
+			return;
+		}
+		if(dist == 0){
+			// nothing said possibly that's wrong case we should say before that
+			// however it should be checked manually !?
+			return;
+		}
+		
+		RouteDirectionInfo nextNext = router.getNextNextRouteDirectionInfo();
+		
+		if(currentStatus == 0){
+			if(dist > PREPARE_DISTANCE){
+				CommandBuilder play = getNewCommandPlayerToPlay();
+				if(play != null){
+					play.goAhead(dist).play();
+				}
+			} else if (dist < TURN_IN_DISTANCE){
+				// should already told it
+				currentStatus = 3;
+			}
+			currentStatus = 1;
+		}
+		
+		
+		if(currentStatus <= 3 && dist <= TURN_DISTANCE){
+			CommandBuilder play = getNewCommandPlayerToPlay();
+			if(play != null){
+				String tParam = getTurnType(next.turnType);
+				boolean isplay = true;
+				if(tParam != null){
+					play.turn(tParam);
+				} else if(next.turnType.isRoundAbout()){
+					play.roundAbout(next.turnType.getExitOut());
+				} else if(next.turnType.getValue().equals(TurnType.TU)){
+					play.makeUT();
+				} else if(next.turnType.getValue().equals(TurnType.C)){
+					play.goAhead();
+				} else {
+					isplay = false;
+				}
+				
+				if (nextNext != null && next.distance <= TURN_IN_DISTANCE) {
+					isplay = true;
+					String t2Param = getTurnType(nextNext.turnType);
+					if (t2Param != null) {
+						play.then().turn(t2Param, next.distance);
+					} else if (nextNext.turnType.isRoundAbout()) {
+						play.then().roundAbout(next.distance, next.turnType.getExitOut());
+					} else if (nextNext.turnType.getValue().equals(TurnType.TU)) {
+						play.then().makeUT(next.distance);
+					}
+				}
+				if(isplay){
+					play.play();
+				}
+			}
+			currentStatus = 4;
+		} else if(currentStatus <= 2 && dist <= TURN_IN_DISTANCE){
+			CommandBuilder play = getNewCommandPlayerToPlay();
+			if (play != null) {
+				String tParam = getTurnType(next.turnType);
+				boolean isPlay = true;
+				if (tParam != null) {
+					play.turn(tParam, dist);
+				} else if (next.turnType.isRoundAbout()) {
+					play.roundAbout(dist, next.turnType.getExitOut());
+				} else if (next.turnType.getValue().equals(TurnType.TU)) {
+					play.makeUT(dist);
+				} else {
+					isPlay = false;
+				}
+
+				if (nextNext != null && next.distance <= TURN_DISTANCE) {
+					TurnType t = nextNext.turnType;
+					isPlay = true;
+					if (next.turnType.getValue().equals(TurnType.C)) {
+						play.goAhead(dist);
+					}
+					if (TurnType.TL.equals(t.getValue()) || TurnType.TSHL.equals(t.getValue()) || TurnType.TSLL.equals(t.getValue())
+							|| TurnType.TU.equals(t.getValue())) {
+						play.then().bearLeft();
+					} else if (TurnType.TR.equals(t.getValue()) || TurnType.TSHR.equals(t.getValue()) || TurnType.TSLR.equals(t.getValue())) {
+						play.then().bearRight();
+					}
+				}
+				if(isPlay){
+					play.play();
+				}
+			}
+			currentStatus = 3;
+		} else if(currentStatus <= 1 && dist <= PREPARE_DISTANCE){
+			CommandBuilder play = getNewCommandPlayerToPlay();
+			if(play != null){
+				String tParam = getTurnType(next.turnType);
+				if(tParam != null){
+					play.prepareTurn(tParam, dist).play();
+				} else if(next.turnType.isRoundAbout()){
+					play.prepareRoundAbout(dist).play();
+				} else if(next.turnType.getValue().equals(TurnType.TU)){
+					play.prepareMakeUT(dist).play();
+				} 
+			}
+			currentStatus = 2;
+		}
+		
+		
+		
+		
+		
+	}
+	
+	private String getTurnType(TurnType t){
+		if(TurnType.TL.equals(t.getValue())){
+			return CommandPlayer.A_LEFT;
+		} else if(TurnType.TSHL.equals(t.getValue())){
+			return CommandPlayer.A_LEFT_SH;
+		} else if(TurnType.TSLL.equals(t.getValue())){
+			return CommandPlayer.A_LEFT_SL;
+		} else if(TurnType.TR.equals(t.getValue())){
+			return CommandPlayer.A_RIGHT;
+		} else if(TurnType.TSHR.equals(t.getValue())){
+			return CommandPlayer.A_RIGHT_SH;
+		} else if(TurnType.TSLR.equals(t.getValue())){
+			return CommandPlayer.A_RIGHT_SL;
+		}
+		return null;
+	}
+
+	public void newRouteIsCalculated() {
+		CommandBuilder play = getNewCommandPlayerToPlay();
+		if(play != null){
+			play.newRouteCalculated(router.getLeftDistance()).play();
+		}
+		currentDirection = router.currentDirectionInfo;
+	}
+
+	public void arrivedDestinationPoint() {
+		CommandBuilder play = getNewCommandPlayerToPlay();
+		if(play != null){
+			play.arrivedAtDestination().play();
+		}
+	}
+
+}
diff --git a/OsmAnd/src/com/osmand/views/OsmBugsLayer.java b/OsmAnd/src/com/osmand/views/OsmBugsLayer.java
index eff5848070f..97e6384f97a 100644
--- a/OsmAnd/src/com/osmand/views/OsmBugsLayer.java
+++ b/OsmAnd/src/com/osmand/views/OsmBugsLayer.java
@@ -384,7 +384,7 @@ public void commentBug(final Context ctx, LayoutInflater layoutInflater, final O
 			public void onClick(DialogInterface dialog, int which) {
 				String text = ((EditText)view.findViewById(R.id.BugMessage)).getText().toString();
 				String author = ((EditText)view.findViewById(R.id.AuthorName)).getText().toString();
-				OsmandSettings.setUserName(ctx, author);
+//				OsmandSettings.setUserName(ctx, author);
 				boolean added = addingComment(bug.getId(), text, author);
 		    	if (added) {
 		    		Toast.makeText(ctx, ctx.getResources().getString(R.string.osb_comment_dialog_success), Toast.LENGTH_LONG).show();
diff --git a/OsmAnd/src/com/osmand/voice/CommandPlayer.java b/OsmAnd/src/com/osmand/voice/CommandPlayer.java
index 6222b41d1f2..b8c8a46a834 100644
--- a/OsmAnd/src/com/osmand/voice/CommandPlayer.java
+++ b/OsmAnd/src/com/osmand/voice/CommandPlayer.java
@@ -4,6 +4,7 @@
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -39,13 +40,17 @@ public class CommandPlayer {
 	private static CommandPlayer instance = null;
 
 	protected Context ctx;
+	// or zip file
 	private File voiceDir;
+//	private ZipFile voiceZipFile;
 	
 	// resolving commands to play
 	private Prolog prologSystem;
 	
 	// playing media
 	private MediaPlayer mediaPlayer;
+	// indicates that player is ready to play first file
+	private boolean playNext = true;
 	private List<String> filesToPlay = new ArrayList<String>();
 
 	/**
@@ -107,20 +112,29 @@ protected String init(){
 				return ctx.getString(R.string.voice_data_unavailable);
 			}
 		}
+		
+		// see comments while it is impossible to read from zip
+//		voiceZipFile = null;
 		if(voiceDir != null) {
 			long time = System.currentTimeMillis();
-			File config = new File(voiceDir, "_config.p"); //$NON-NLS-1$
-			boolean wrong = !config.exists();
-				
-			if (!wrong) {
-
-				try {
-					prologSystem.setTheory(new Theory(new FileInputStream(config)));
-				} catch (InvalidTheoryException e) {
-					log.error("Loading voice config exception " + voiceProvider, e); //$NON-NLS-1$
-				} catch (IOException e) {
-					log.error("Loading voice config exception " + voiceProvider, e); //$NON-NLS-1$
+			boolean wrong = false;
+			try {
+				InputStream config;
+//				if (voiceDir.getName().endsWith(".zip")) { //$NON-NLS-1$
+//					voiceZipFile = new ZipFile(voiceDir);
+//					config = voiceZipFile.getInputStream(voiceZipFile.getEntry("_config.p")); //$NON-NLS-1$
+//				} else {
+					config = new FileInputStream(new File(voiceDir, "_config.p")); //$NON-NLS-1$
+//				}
+				if (!wrong) {
+					prologSystem.setTheory(new Theory(config));
 				}
+			} catch (InvalidTheoryException e) {
+				log.error("Loading voice config exception " + voiceProvider, e); //$NON-NLS-1$
+				wrong = true;
+			} catch (IOException e) {
+				log.error("Loading voice config exception " + voiceProvider, e); //$NON-NLS-1$
+				wrong = true;
 			}
 			if(wrong){
 				return ctx.getString(R.string.voice_data_corrupted);
@@ -186,14 +200,25 @@ public void playCommands(CommandBuilder builder){
 		playQueue();
 	}
 	
-	private void playQueue() {
-		boolean playNext = true;
+	private synchronized void playQueue() {
 		while (!filesToPlay.isEmpty() && playNext) {
 			String f = filesToPlay.remove(0);
 			if (f != null && voiceDir != null) {
-				File file = new File(voiceDir, f);
-				if (file.exists()) {
+				boolean exists = false;
+//				if(voiceZipFile != null){
+//					ZipEntry entry = voiceZipFile.getEntry(f);
+//					exists = entry != null;
+//					voiceZipFile.getInputStream(entry);
+//					
+//				} else {
+					File file = new File(voiceDir, f);
+					exists = file.exists();
+//				}
+				if (exists) {
+					log.debug("Playing file : " + f); //$NON-NLS-1$
+					playNext = false;
 					try {
+						// Can't play sound file from zip it seams to be impossible only unpack and play!!!
 						mediaPlayer.setDataSource(file.getAbsolutePath());
 						mediaPlayer.prepare();
 						mediaPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {
@@ -215,18 +240,21 @@ public void onCompletion(MediaPlayer mp) {
 									Thread.sleep(sleep);
 								} catch (InterruptedException e) {
 								}
+								playNext = true;
 								playQueue();
 							}
 						});
-						playNext = false;
+						
 						mediaPlayer.start();
 					} catch (Exception e) {
 						log.error("Error while playing voice command", e); //$NON-NLS-1$
 						playNext = true;
 						
 					}
+				} else {
+					log.info("Play file not found : " + f); //$NON-NLS-1$
 				}
-			}
+			} 
 		}
 	}
 	
@@ -235,12 +263,12 @@ public void onCompletion(MediaPlayer mp) {
 	protected static final String P_VERSION = "version";  //$NON-NLS-1$
 	protected static final String P_RESOLVE = "resolve";  //$NON-NLS-1$
 	
-	protected static final String A_LEFT = "left"; //$NON-NLS-1$
-	protected static final String A_LEFT_SH = "left_sh"; //$NON-NLS-1$
-	protected static final String A_LEFT_SL = "left_sl"; //$NON-NLS-1$
-	protected static final String A_RIGHT = "right"; //$NON-NLS-1$
-	protected static final String A_RIGHT_SH = "right_sh"; //$NON-NLS-1$
-	protected static final String A_RIGHT_SL = "right_sl"; //$NON-NLS-1$
+	public static final String A_LEFT = "left"; //$NON-NLS-1$
+	public static final String A_LEFT_SH = "left_sh"; //$NON-NLS-1$
+	public static final String A_LEFT_SL = "left_sl"; //$NON-NLS-1$
+	public static final String A_RIGHT = "right"; //$NON-NLS-1$
+	public static final String A_RIGHT_SH = "right_sh"; //$NON-NLS-1$
+	public static final String A_RIGHT_SL = "right_sl"; //$NON-NLS-1$
 	
 	protected static final String С_PREPARE_TURN = "prepare_turn";  //$NON-NLS-1$
 	protected static final String С_PREPARE_ROUNDABOUT = "prepare_roundabout";  //$NON-NLS-1$
@@ -250,6 +278,13 @@ public void onCompletion(MediaPlayer mp) {
 	protected static final String С_TURN = "turn";  //$NON-NLS-1$
 	protected static final String С_MAKE_UT = "make_ut";  //$NON-NLS-1$
 	protected static final String С_PREAMBLE = "preamble";  //$NON-NLS-1$
+	protected static final String С_AND_ARRIVE_DESTINATION = "and_arrive_destination";  //$NON-NLS-1$
+	protected static final String С_THEN = "then";  //$NON-NLS-1$
+	protected static final String С_REACHED_DESTINATION = "reached_destination";  //$NON-NLS-1$
+	protected static final String С_BEAR_LEFT = "bear_left";  //$NON-NLS-1$
+	protected static final String С_BEAR_RIGHT = "bear_right";  //$NON-NLS-1$
+	protected static final String С_ROUTE_RECALC = "route_recalc";  //$NON-NLS-1$
+	
 	
 	protected static final String DELAY_CONST = "delay_"; //$NON-NLS-1$
 	
@@ -298,6 +333,7 @@ private CommandBuilder addCommand(String name, Object... args){
 				}
 			}
 			Struct struct = new Struct(name, list);
+			log.debug("Adding command : " + name); //$NON-NLS-1$
 			listStruct.add(struct);
 			return this;
 		}
@@ -324,88 +360,58 @@ public CommandBuilder prepareMakeUT(double dist){
 		}
 		
 		
-		public CommandBuilder turnLeft(){
-			return addCommand(С_TURN, A_LEFT);
+		public CommandBuilder turn(String param){
+			return addCommand(С_TURN, param);
 		}
 		
-		public CommandBuilder turnSLLeft(){
-			return addCommand(С_TURN, A_LEFT_SL);
+		public CommandBuilder turn(String param, double dist){
+			return addCommand(С_TURN, param, dist);
 		}
 		
-		public CommandBuilder turnSHLeft(){
-			return addCommand(С_TURN, A_LEFT_SH);
+		/**
+		 * 
+		 * @param param A_LEFT, A_RIGHT, ...
+		 * @param dist
+		 * @return
+		 */
+		public CommandBuilder prepareTurn(String param, double dist){
+			return addCommand(С_PREPARE_TURN, param, dist);
 		}
 		
-		public CommandBuilder turnRight(){
-			return addCommand(С_TURN, A_RIGHT);
-		}
-		
-		public CommandBuilder turnSLRight(){
-			return addCommand(С_TURN, A_RIGHT_SL);
-		}
-		
-		public CommandBuilder turnSHRight(){
-			return addCommand(С_TURN, A_RIGHT_SL);
-		}
-		
-		
-		public CommandBuilder turnLeft(double dist){
-			return addCommand(С_TURN, A_LEFT, dist);
-		}
-		
-		public CommandBuilder turnSLLeft(double dist){
-			return addCommand(С_TURN, A_LEFT_SL, dist);
-		}
-		
-		public CommandBuilder turnSHLeft(double dist){
-			return addCommand(С_TURN, A_LEFT_SH, dist);
-		}
-		
-		public CommandBuilder turnRight(double dist){
-			return addCommand(С_TURN, A_RIGHT, dist);
-		}
-
-		public CommandBuilder turnSLRight(double dist){
-			return addCommand(С_TURN, A_RIGHT_SL, dist);
-		}
-		
-		public CommandBuilder turnSHRight(double dist){
-			return addCommand(С_TURN, A_RIGHT_SL, dist);
+		public CommandBuilder prepareRoundAbout(double dist){
+			return addCommand(С_PREPARE_ROUNDABOUT, dist);
 		}
 		
-		public CommandBuilder prepareTurnLeft(double dist){
-			return addCommand(С_PREPARE_TURN, A_LEFT, dist);
+		public CommandBuilder roundAbout(double dist, int exit){
+			return addCommand(С_ROUNDABOUT, dist, exit);
 		}
 		
-		public CommandBuilder prepareTurnSLLeft(double dist){
-			return addCommand(С_PREPARE_TURN, A_LEFT_SL, dist);
-		}
-		public CommandBuilder prepareTurnSHLeft(double dist){
-			return addCommand(С_PREPARE_TURN, A_LEFT_SH, dist);
+		public CommandBuilder roundAbout(int exit){
+			return addCommand(С_ROUNDABOUT, exit);
 		}
 		
-		public CommandBuilder prepareTurnRight(double dist){
-			return addCommand(С_PREPARE_TURN, A_RIGHT, dist);
+		public CommandBuilder andArriveAtDestination(){
+			return addCommand(С_AND_ARRIVE_DESTINATION);
 		}
 		
-		public CommandBuilder prepareTurnSLRight(double dist){
-			return addCommand(С_PREPARE_TURN, A_RIGHT_SL, dist);
+		public CommandBuilder arrivedAtDestination(){
+			return addCommand(С_REACHED_DESTINATION);
 		}
 		
-		public CommandBuilder prepareTurnSHRight(double dist){
-			return addCommand(С_PREPARE_TURN, A_RIGHT_SH, dist);
+		public CommandBuilder bearLeft(){
+			return addCommand(С_BEAR_LEFT);
 		}
 		
-		public CommandBuilder prepareRoundAbout(double dist){
-			return addCommand(С_PREPARE_ROUNDABOUT, dist);
+		public CommandBuilder bearRight(){
+			return addCommand(С_BEAR_RIGHT);
 		}
 		
-		public CommandBuilder roundAbout(double dist, int exit){
-			return addCommand(С_ROUNDABOUT, dist, exit);
+		public CommandBuilder then(){
+			return addCommand(С_THEN);
 		}
 		
-		public CommandBuilder roundAbout(int exit){
-			return addCommand(С_ROUNDABOUT, exit);
+		public CommandBuilder newRouteCalculated(double dist){
+			return addCommand(С_ROUTE_RECALC, dist);
 		}
 	
 		
diff --git a/OsmAnd/voice/_config.p b/OsmAnd/voice/_config.p
index 72a63fe8b43..809ebf7ecfb 100644
--- a/OsmAnd/voice/_config.p
+++ b/OsmAnd/voice/_config.p
@@ -7,11 +7,11 @@ preamble - [].
 
 
 %% TURNS 
-turn('left', ['turn.ogg', 'left.ogg']).
-turn('left_sh', ['turn_sharply.ogg', 'left.ogg']).
+turn('left', ['turn.ogg', delay_350, 'left.ogg']).
+turn('left_sh', ['turn_sharply.ogg', delay_350, 'left.ogg']).
 turn('left_sl', ['turn_slightly_left.ogg']).
-turn('right', ['turn.ogg', 'right.ogg']).
-turn('right_sh', ['turn_sharply.ogg', 'right.ogg']).
+turn('right', ['turn.ogg', delay_350, 'right.ogg']).
+turn('right_sh', ['turn_sharply.ogg', delay_350,'right.ogg']).
 turn('right_sl', ['turn_slightly_right.ogg']).
 
 prepare_turn(Turn, Dist) == ['Prepare_to.ogg', 'in.ogg', delay_450, D, delay_450, M] :- 
@@ -21,22 +21,22 @@ turn(Turn, Dist) == ['in.ogg', delay_450, D, delay_450, M] :-
 turn(Turn) == M :- turn(Turn, M).
 
 
-prepare_make_ut(Dist) == ['Prepare_to.ogg', 'in.ogg', delay_450, D, delay_450, 'Turn_back.ogg'] :- 
+prepare_make_ut(Dist) == ['Prepare_to.ogg', 'in.ogg', delay_300, D, delay_300,'Turn_back.ogg'] :- 
 		distance(Dist) == D.
 
-prepare_roundabout(Dist) == ['Prepare_to.ogg', 'in.ogg', delay_450, D, delay_450, 'roundabout.ogg'] :- 
+prepare_roundabout(Dist) == ['Prepare_to.ogg', 'in.ogg', delay_300, D, delay_300, 'roundabout.ogg'] :- 
 		distance(Dist) == D.
 
-make_ut(Dist) == ['in.ogg', delay_450, D, delay_450, 'Turn_back.ogg'] :- 
+make_ut(Dist) == ['in.ogg', delay_300, D, delay_300, 'Turn_back.ogg'] :- 
 			distance(Dist) == D.
 make_ut == ['Turn_back.ogg'].
 
-roundabout(Dist, Exit) == ['in.ogg', delay_450, D, delay_450, 'roundabout.ogg', delay_450, 'DO.ogg', delay_250, E, 'the_exit.ogg'] :- 
+roundabout(Dist, Exit) == ['in.ogg', delay_300, D, delay_300, 'roundabout.ogg', delay_250, 'DO.ogg', delay_250, E, 'the_exit.ogg'] :- 
 			distance(Dist) == D, nth(Exit, E).
 roundabout(Exit) == ['DO.ogg', delay_250,  E, 'the_exit.ogg'] :- nth(Exit, E).
 
 and_arrive_destination == ['arrive_at_destination.ogg'].
-then == ['then', delay_350].
+then == ['then.ogg', delay_350].
 reached_destination == ['you_reached.ogg',delay_250, 'TO_DESTINATION.ogg'].
 bear_right == ['bear_right.ogg'].
 bear_left == ['bear_left.ogg'].
