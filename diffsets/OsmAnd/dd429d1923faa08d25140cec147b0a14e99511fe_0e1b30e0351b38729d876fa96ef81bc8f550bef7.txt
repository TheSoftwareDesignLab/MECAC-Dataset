diff --git a/OsmAnd-java/src/net/osmand/router/GeneralRouter.java b/OsmAnd-java/src/net/osmand/router/GeneralRouter.java
index 6f5cc4ce94d..36155c9f0a7 100644
--- a/OsmAnd-java/src/net/osmand/router/GeneralRouter.java
+++ b/OsmAnd-java/src/net/osmand/router/GeneralRouter.java
@@ -317,23 +317,23 @@ public double getRoundaboutTurn() {
 	}
 	@Override
 	public double calculateTurnTime(RouteSegment segment, int segmentEnd, RouteSegment prev, int prevSegmentEnd) {
-		int[] pt = prev.getRoad().getPointTypes(prevSegmentEnd);
-		if(pt != null) {
-			RouteRegion reg = prev.getRoad().region;
-			for (int i = 0; i < pt.length; i++) {
-				RouteTypeRule r = reg.quickGetEncodingRule(pt[i]);
-				if ("highway".equals(r.getTag()) && "traffic_signals".equals(r.getValue())) {
-					// traffic signals don't add turn info
-//					return 0;
-				}
-			}
-		}
-		
 		float ts = getPenaltyTransition(segment.getRoad());
 		float prevTs = getPenaltyTransition(prev.getRoad());
 		if(prevTs != ts) {
 			if(ts > prevTs) return (ts - prevTs);
 		}
+//		int[] pt = prev.getRoad().getPointTypes(prevSegmentEnd);
+//		if(pt != null) {
+//			RouteRegion reg = prev.getRoad().region;
+//			for (int i = 0; i < pt.length; i++) {
+//				RouteTypeRule r = reg.quickGetEncodingRule(pt[i]);
+//				if ("highway".equals(r.getTag()) && "traffic_signals".equals(r.getValue())) {
+//					// traffic signals don't add turn info
+//					return 0;
+//				}
+//			}
+//		}
+		
 		
 		if(segment.getRoad().roundabout() && !prev.getRoad().roundabout()) {
 			double rt = getRoundaboutTurn();
diff --git a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
index 81da9503097..b1d6d096117 100644
--- a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
@@ -241,13 +241,15 @@ public int compare(TextDrawInfo object1, TextDrawInfo object2) {
 							paintText.setColor(text.textShadowColor);
 							paintText.setStyle(Style.STROKE);
 							paintText.setStrokeWidth(2 + text.textShadow);
-							cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
+							cv.drawTextOnPath(text.text, text.drawOnPath, 0, 
+									text.vOffset - ( paintText.ascent()/2 + paintText.descent()), paintText);
 							// reset
 							paintText.setStyle(Style.FILL);
 							paintText.setStrokeWidth(2);
 							paintText.setColor(text.textColor);
 						}
-						cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
+						cv.drawTextOnPath(text.text, text.drawOnPath, 0, 
+								text.vOffset - ( paintText.ascent()/2 + paintText.descent()), paintText);
 					} else {
 						if (text.shieldRes != null) {
 							float coef = rc.getDensityValue(rc.screenDensityRatio * rc.textScale);
@@ -513,7 +515,6 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 
 		p.centerX = points[startInd].x + scale * px + ox;
 		p.centerY = points[startInd].y + scale * py + oy;
-		p.vOffset += p.textSize / 2 - 1;
 //		p.hOffset = 0;
 
 		if (inverse) {
