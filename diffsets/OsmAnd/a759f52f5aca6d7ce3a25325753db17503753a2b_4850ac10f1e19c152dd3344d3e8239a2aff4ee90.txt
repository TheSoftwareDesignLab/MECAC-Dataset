diff --git a/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java b/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
index 914eae1af1a..b19c5721718 100644
--- a/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
+++ b/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
@@ -153,7 +153,10 @@ public class IndexCreator {
 
 	
 	private RTree[] mapTree = null;
-	private final int[] MAP_ZOOMS = MapRenderingTypes.MAP_ZOOMS;
+	// maximum 5 limitation => 4 levels allowed
+	public static final int[] MAP_ZOOMS = new int[]{5, 8, 11, 14, 22};
+//	public static final int[] MAP_ZOOMS = new int[]{5, 9, 14, 22};
+	
 	
 	// MEMORY map :  save it in memory while that is allowed
 	private Map<Long, Set<Integer>>[] multiPolygonsWays = new Map[MAP_ZOOMS.length - 1];
@@ -221,6 +224,19 @@ public void setNormalizeStreets(boolean normalizeStreets) {
 	}
 
 	
+	protected static int defineLevel(int minZoom) {
+		int level = 0;
+		if (minZoom < 15) {
+			for (int i = 1; i < MAP_ZOOMS.length; i++) {
+				if (minZoom <= MAP_ZOOMS[i]) {
+					level = MAP_ZOOMS.length - 1 - i;
+					break;
+				}
+			}
+		}
+		return level;
+	}
+	
 	protected class NewDataExtractionOsmFilter implements IOsmStorageFilter {
 
 		int currentCountNode = 0;
@@ -1126,25 +1142,21 @@ private void iterateEntity(Entity e, int step) throws SQLException {
 						boolean clockwise = isClockwiseWay(l);
 						// clockwise - outer (like coastline), anticlockwise - inner
 						boolean inverse = clockwise != !innerType;
-						for(Way es : l){
+						for (Way es : l) {
 							boolean inner = "inner".equals(entities.get(es));
-							if(innerType != inner){
+							if (innerType != inner) {
 								throw new IllegalStateException();
 							}
-							if(!inner && name != null){
+							if (!inner && name != null) {
 								multiPolygonsNames.put(es.getId(), name);
 							}
 							putMultipolygonType(multiPolygonsWays[0], es.getId(), mtType, inverse);
-							// TODO that's not a solution !!! All wholes will not be visible at lower levels
-							// That doesn't solve initial problem (try minsk small area)
-//							if (!inner) {
-								for (int i = 1; i < multiPolygonsWays.length; i++) {
-									int type = findMultiPolygonType(e, i);
-									if (type != 0) {
-										putMultipolygonType(multiPolygonsWays[i], es.getId(), type, inverse);
-									}
+							for (int i = 1; i < multiPolygonsWays.length; i++) {
+								int type = findMultiPolygonType(e, i);
+								if (type != 0) {
+									putMultipolygonType(multiPolygonsWays[i], es.getId(), type, inverse);
 								}
-//							}
+							}
 						}
 					}
 
@@ -1215,7 +1227,7 @@ private void putMultipolygonType(Map<Long, Set<Integer>> multiPolygonsWays, long
 	}
 	
 	private int findMultiPolygonType(Entity e, int level){
-		int t = MapRenderingTypes.encodeEntityWithType(e, level, true, typeUse);
+		int t = MapRenderingTypes.encodeEntityWithType(e, MAP_ZOOMS[MAP_ZOOMS.length - level - 1], true, typeUse);
 		int mtType = 0;
 		if (t != 0) {
 			if ((t & 3) == MapRenderingTypes.MULTY_POLYGON_TYPE) {
@@ -1347,7 +1359,7 @@ private void registerCityIfNeeded(Entity e) {
 	
 
 	private void writeBinaryEntityToMapDatabase(Entity e, long baseId, boolean inverse, int level) throws SQLException {
-		int type = MapRenderingTypes.encodeEntityWithType(e, level, false, typeUse);
+		int type = MapRenderingTypes.encodeEntityWithType(e, MAP_ZOOMS[MAP_ZOOMS.length - level - 1], false, typeUse);
 		Map<Long, Set<Integer>> multiPolygonsWays = this.multiPolygonsWays[level];
 		boolean hasMulti = e instanceof Way && multiPolygonsWays.containsKey(e.getId());
 		if (hasMulti) {
@@ -1415,7 +1427,7 @@ private void writeBinaryEntityToMapDatabase(Entity e, long baseId, boolean inver
 				int minY = Integer.MAX_VALUE;
 				int maxY = Integer.MIN_VALUE;
 				for (int i = 0; i < nodes.size(); i++) {
-					int r = 1; //i == nodes.size() - 1 ? 1 : 2;
+					int r = i == nodes.size() - 1 ? 1 : 3;
 					// do not simplify last node it could be important node for multipolygon
 					if (nodes.get(i) != null) {
 						int x = (int) (MapUtils.getTileNumberX(zoom, nodes.get(i).getLongitude()) * 256d);
@@ -2008,6 +2020,7 @@ public static void main(String[] args) throws IOException, SAXException, SQLExce
 		 creator.setNodesDBFile(new File("e:/Information/OSM maps/osmand/belarus_nodes.tmp.odb"));
 		 creator.generateIndexes(new File("e:/Information/OSM maps/belarus osm/belarus.osm.bz2"), new ConsoleProgressImplementation(3), null);
 		 
+		 
 //		 creator.generateIndexes(new File("e:/Information/OSM maps/belarus osm/forest.osm"), new ConsoleProgressImplementation(3), null);
 		 
 //		 double dist = MapUtils.getDistance(50, MapUtils.getLongitudeFromTile(25, 0), 50, MapUtils.getLongitudeFromTile(25, 1));
diff --git a/DataExtractionOSM/src/net/osmand/osm/MapRenderingTypes.java b/DataExtractionOSM/src/net/osmand/osm/MapRenderingTypes.java
index 1e2af824818..9733bf70e05 100644
--- a/DataExtractionOSM/src/net/osmand/osm/MapRenderingTypes.java
+++ b/DataExtractionOSM/src/net/osmand/osm/MapRenderingTypes.java
@@ -1,6 +1,7 @@
 package net.osmand.osm;
 
 import gnu.trove.map.TIntByteMap;
+import gnu.trove.map.hash.TIntByteHashMap;
 
 import java.util.Collection;
 import java.util.LinkedHashMap;
@@ -19,9 +20,8 @@
  * 1. Last 2 bits define type of element : polygon, polyline, point 
  */
 public class MapRenderingTypes {
-	// maximum 5 limitation => 4 levels allowed
-//	public static final int[] MAP_ZOOMS = new int[]{5, 8, 11, 14, 22};
-	public static final int[] MAP_ZOOMS = new int[]{5, 9, 14, 22};
+	
+	public static final int[] MAP_ZOOMS = null;
 	
 	// TODO Internet access bits for point, polygon
 	/** standard schema :	 
@@ -173,8 +173,8 @@ public String getTag() {
 			return tag;
 		}
 		
-		public void registerType(int level, String val, int pointRule, int polylineRule, int polygonRule, int type, int subtype){
-			int r = encodeRule(level, pointRule, polylineRule, polygonRule, type, subtype);
+		public void registerType(int minZoom, String val, int pointRule, int polylineRule, int polygonRule, int type, int subtype){
+			int r = encodeRule(minZoom, pointRule, polylineRule, polygonRule, type, subtype);
 			if(val != null){
 				rules.put(val, r);
 			} else {
@@ -190,8 +190,8 @@ public boolean registeredAsNull(){
 			return nullRule != null && nullRule > 0;
 		}
 		
-		private int encodeRule(int level, int pointRule, int polylineRule, int polygonRule, int type, int subtype){
-			int rule = (((((level << 4) | polygonRule) << 4) | polylineRule) << 4) | pointRule; // 14 bit
+		private int encodeRule(int minZoom, int pointRule, int polylineRule, int polygonRule, int type, int subtype){
+			int rule = (((((minZoom << 4) | polygonRule) << 4) | polylineRule) << 4) | pointRule; // 17 bit
 			rule = (((rule << 8) | subtype) << 5) | type; // + 13 bits
 			return rule;
 		}
@@ -220,12 +220,12 @@ public int getPolygonRule(String val){
 			return (i >> 21) & MASK_4;
 		}
 		
-		public int getLevel(String val){
+		public int getMinZoom(String val){
 			Integer i = val == null ? nullRule : rules.get(val);
 			if(i == null){
 				return 0;
 			}
-			return (i >> 25) & MASK_4;
+			return (i >> 25);
 		}
 		
 		
@@ -239,7 +239,7 @@ public int getType(String val, int mask){
 	}
 	
 	// if type equals 0 no need to save that point
-	public static int encodeEntityWithType(Entity e, int level, boolean multipolygon, List<Integer> additionalTypes) {
+	public static int encodeEntityWithType(Entity e, int zoom, boolean multipolygon, List<Integer> additionalTypes) {
 		if (types == null) {
 			types = new LinkedHashMap<String, MapRulType>();
 			init(INIT_RULE_TYPES);
@@ -283,7 +283,7 @@ public static int encodeEntityWithType(Entity e, int level, boolean multipolygon
 				if (types.containsKey(tag)) {
 					MapRulType rType = types.get(tag);
 					String val = i == 1 ? null : e.getTag(tag);
-					if(rType.getLevel(val) < level){
+					if(rType.getMinZoom(val) > zoom){
 						continue;
 					}
 					int pr = point ? rType.getPointRule(val) : (polygon ? rType.getPolygonRule(val) : rType.getPolylineRule(val));
@@ -510,14 +510,14 @@ public static String getEntityName(Entity e, int mainType) {
 		return name;
 	}
 	
-	private static void registerRules(int level, 
+	private static void registerRules(int minZoom, 
 			String tag, String val, int type, int subtype, int pointRule, int polylineRule, int polygonRule){
 		MapRulType rtype = types.get(tag);
 		if(rtype == null){
 			rtype = new MapRulType(tag);
 			types.put(tag, rtype);
 		}
-		rtype.registerType(level, val, pointRule, polylineRule, polygonRule, type, subtype);
+		rtype.registerType(minZoom, val, pointRule, polylineRule, polygonRule, type, subtype);
 	}
 	
 	private static void initAmenityMap(){
@@ -536,6 +536,7 @@ private static void initAmenityMap(){
 	 */
 	public static TIntByteMap getObjectTypeMinZoom(){
 		if(objectsToMinZoom == null){
+			objectsToMinZoom = new TIntByteHashMap();
 			init(INIT_TYPE_ZOOM);
 		}
 		return objectsToMinZoom;
@@ -646,7 +647,6 @@ private static void register(int st, String tag, String val, int type, int subty
 	}
 	private static void register(int st, int minZoom, String tag, String val, int type, int subtype, int renderType){
 		if(st == INIT_RULE_TYPES){
-			int level = defineLevel(minZoom);
 			int polygonRule = 0;
 			int polylineRule = 0;
 			int pointRule = 0;
@@ -658,30 +658,18 @@ private static void register(int st, int minZoom, String tag, String val, int ty
 			} else {
 				polygonRule = renderType;
 			}
-			registerRules(level, tag, val, type, subtype, pointRule, polylineRule, polygonRule);
+			registerRules(minZoom, tag, val, type, subtype, pointRule, polylineRule, polygonRule);
 		} else if(st == INIT_AMENITY_MAP) {
 			if(renderType == POINT_TYPE || renderType == POLYGON_TYPE){
 				registerAmenity(tag, val, type, subtype);
 			}
 		} else if(st == INIT_TYPE_ZOOM){
 			if(minZoom < 15){
-				objectsToMinZoom.put((((subtype) << 5) << type) << 2, (byte) minZoom);
+				objectsToMinZoom.put(((subtype << 5) | type) << 2, (byte) minZoom);
 			}
 		}
 	}
 
-	private static int defineLevel(int minZoom) {
-		int level = 0;
-		if (minZoom < 15) {
-			for (int i = 1; i < MAP_ZOOMS.length; i++) {
-				if (minZoom <= MAP_ZOOMS[i]) {
-					level = MAP_ZOOMS.length - 1 - i;
-					break;
-				}
-			}
-		}
-		return level;
-	}
 	
 	private static void register(int st, String tag, String val, int type, int subtype, int renderType, int renderType2){
 		register(st, 15, tag, val, type, subtype, renderType, renderType2);
@@ -711,14 +699,14 @@ private static void register(int st, int minZoom, String tag, String val, int ty
 			}
 		}
 		if(st == INIT_RULE_TYPES){
-			registerRules(defineLevel(minZoom), tag, val, type, subtype, pointRule, polylineRule, polygonRule);
+			registerRules(minZoom, tag, val, type, subtype, pointRule, polylineRule, polygonRule);
 		} else if(st == INIT_AMENITY_MAP){
 			if(pointRule == POINT_TYPE){
 				registerAmenity(tag, val, type, subtype);
 			}
 		} else if(st == INIT_TYPE_ZOOM){
 			if(minZoom < 15){
-				objectsToMinZoom.put((((subtype) << 5) << type) << 2, (byte) minZoom);
+				objectsToMinZoom.put((((subtype) << 5) | type) << 2, (byte) minZoom);
 			}
 		}
 	}
@@ -732,7 +720,7 @@ private static void registerAsBuilding(int st, String tag, String val, int type,
 				rtype = new MapRulType(tag);
 				types.put(tag, rtype);
 			}
-			rtype.registerType(0, val, POINT_TYPE, 0, DEFAULT_POLYGON_BUILDING, type, subtype);
+			rtype.registerType(15, val, POINT_TYPE, 0, DEFAULT_POLYGON_BUILDING, type, subtype);
 		} else if (st == INIT_AMENITY_MAP) {
 			registerAmenity(tag, val, type, subtype);
 		} else if(st == INIT_TYPE_ZOOM){
diff --git a/OsmAnd/res/values-sk/strings.xml b/OsmAnd/res/values-sk/strings.xml
index 6a5887c984a..9866f3c24e8 100644
--- a/OsmAnd/res/values-sk/strings.xml
+++ b/OsmAnd/res/values-sk/strings.xml
@@ -2,8 +2,8 @@
 <resources>
 	<string name="use_high_res_maps">Mapa s veľkým rozlíšením</string>
 <string name="use_high_res_maps_descr">Použiť mapu s veľkým rozlíšením pre zariadenia s vysokou hustotou bodov</string>
-<string name="unknown_location">Aktuálna pozícia nie je známa</string>
-<string name="download_files_question">Stiahnuť {0} súborov?</string>
+<string name="unknown_location">Pozícia nie je zatiaľ známa</string>
+<string name="download_files_question">Stiahnuť {0} súbor/y?</string>
 <string name="download_files">Stiahnuť</string>
 <string name="context_menu_item_search_transport">Hľadať prepravu</string>
 <string name="transport_searching_transport">Hľadá sa preprava (bez cieľa)</string>
@@ -138,7 +138,7 @@
 <string name="update_poi_no_offline_poi_index">Nie sú dostupné žiadne indexy offlinových POI pre túto oblasť</string>
 <string name="update_poi_is_not_available_for_zoom">Aktualizácia POI nie je dostupná pre nízke úrovne priblíženia</string>
 <string name="context_menu_item_update_poi">Aktualizovať POI</string>
-<string name="context_menu_item_update_map_confirm">Ste si istý, že chcete aktualizovat lokálne údaje z internetu?</string>
+<string name="context_menu_item_update_map_confirm">Naozaj chcete aktualizovať lokálne údaje z internetu?</string>
 <string name="search_history_city">Mesto: {0}</string>
 <string name="search_history_street">Ulica: {0}, {1}</string>
 <string name="search_history_int_streets">Pretínajúce ulice: {0} x {1} v {2}</string>
@@ -148,11 +148,11 @@
 <string name="clear_all">Zmazať všetko</string>
 <string name="history">História</string>
 <string name="uploading_data">Nahrávajú sa údaje...</string>
-<string name="uploading">Nahrávania</string>
+<string name="uploading">Nahrávanie</string>
 <string name="search_nothing_found">Nič sa nenašlo</string>
 <string name="searching">Vyhľadáva sa</string>
 <string name="searching_address">Hľadá sa adresa...</string>
-<string name="search_osm_nominatim">Hľadať adresu použiťím OSM Nominatim</string>
+<string name="search_osm_nominatim">Nájdite adresu použiťím OSM Nominatim</string>
 <string name="hint_search_online">Číslo domu, ulica, mesto</string>
 <string name="search_offline_address">Offline</string>
 <string name="search_online_address">Internet</string>
@@ -239,7 +239,7 @@
 <string name="save_track_interval">Interval ukladania stopy</string>
 <string name="monitor_preferences">Monitorovanie</string>
 <string name="save_track_to_gpx_descrp">Stopy budú uložené do adresára stôp, zoskupené podľa dní</string>
-<string name="save_track_to_gpx">Uložiť stopu do GPX</string>
+<string name="save_track_to_gpx">Ukladať stopu do GPX</string>
 <string name="navigate_to">Navigovať sem</string>
 <string name="update_tile">Aktualizovať mapu</string>
 <string name="reload_tile">Znovu načítať dlaždicu</string>
@@ -263,7 +263,7 @@
 <string name="map_specify_point">Určiť bod</string>
 <string name="show_view_angle_descr">Uhol pohľadu zobrazenia podľa kompasu</string>
 <string name="show_view_angle">Zobraziť uhol pohľadu</string>
-<string name="stop_navigation">Zmazať bod</string>
+<string name="stop_navigation">Zmazať cieľ</string>
 <string name="navigate_to_point">Označiť bod</string>
 <string name="map_view_3d_descr">Zapnúť 3D zobrazenie mapy</string>
 <string name="map_view_3d">3D zobrazenie mapy</string>
@@ -274,7 +274,7 @@
 <string name="map_tile_source">Zdroj dlaždíc mapy</string>
 <string name="map_source">Zdroj mapy</string>
 <string name="use_internet">Použiť internet</string>
-<string name="show_location">Zobraziť umiestnenie</string>
+<string name="show_location">Zobraziť pozíciu</string>
 <string name="map_preferences">Mapa</string>
 <string name="settings_activity">Nastavenia</string>
 <string name="show_gps_coordinates_text">Zobraziť GPS súradnice na mape</string>
@@ -320,7 +320,7 @@
 <string name="navigate_point_format_DMS">DDD:MM:SS.SSSSS</string>
 <string name="search_shown_on_map">Zobraziť na mape</string>
 <string name="navigate_point_cancel">Zrušiť</string>
-<string name="search_address_top_text">Vybrať adresu</string>
+<string name="search_address_top_text">Zvoľte adresu</string>
 <string name="search_address_region">Oblasť</string>
 <string name="search_address_city">Mesto</string>
 <string name="search_address_street">Ulica</string>
@@ -328,7 +328,7 @@
 <string name="search_address_building_option">Budova</string>
 <string name="search_address_street_option">Pretínajúca ulica</string>
 
-<string name="search_tabs_location">Umiestnenie</string>
+<string name="search_tabs_location">Pozícia</string>
 
 <string name="context_menu_item_navigate_point">Navigovať do bodu</string>
 <string name="context_menu_item_add_favorite">Pridať do Obľúbených</string>
diff --git a/OsmAnd/src/net/osmand/render/MapRenderRepositories.java b/OsmAnd/src/net/osmand/render/MapRenderRepositories.java
index d54b58f41fd..5e41c5ef270 100644
--- a/OsmAnd/src/net/osmand/render/MapRenderRepositories.java
+++ b/OsmAnd/src/net/osmand/render/MapRenderRepositories.java
@@ -1,5 +1,7 @@
 package net.osmand.render;
 
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.map.TIntByteMap;
 import gnu.trove.set.TLongSet;
 import gnu.trove.set.hash.TLongHashSet;
 
@@ -168,7 +170,7 @@ private boolean checkWhetherInterrupted(){
 		return false;
 	}
 	
-	private boolean loadVectorData(RectF dataBox, int zoom){
+	private boolean loadVectorData(RectF dataBox, final int zoom){
 		double cBottomLatitude = dataBox.bottom;
 		double cTopLatitude = dataBox.top;
 		double cLeftLongitude = dataBox.left;
@@ -195,6 +197,32 @@ private boolean loadVectorData(RectF dataBox, int zoom){
 			int bottomY = MapUtils.get31TileNumberY(cBottomLatitude);
 			int topY = MapUtils.get31TileNumberY(cTopLatitude);
 			searchRequest = BinaryMapIndexReader.buildSearchRequest(leftX, rightX, topY, bottomY, zoom);
+			if (zoom < 15) {
+				searchRequest.setSearchFilter(new BinaryMapIndexReader.SearchFilter() {
+					TIntByteMap map = MapRenderingTypes.getObjectTypeMinZoom();
+
+					@Override
+					public boolean accept(TIntArrayList types) {
+						for (int j = 0; j < types.size(); j++) {
+							int type = types.get(j);
+							if ((type & 3) == MapRenderingTypes.POINT_TYPE) {
+								// keep 13 bit after last 2 bits and
+								// 0111 1111 1111 1100
+								type &= 0x7ffc;
+							} else {
+								// 0000 1111 1111 1100
+								type &= 0xffc;
+							}
+							byte b = map.get(type);
+							if (b != 0 && b <= zoom) {
+								return true;
+							}
+						}
+						return false;
+					}
+
+				});
+			}
 			
 			for (BinaryMapIndexReader c : files.values()) {
 				List<BinaryMapDataObject> res = c.searchMapIndex(searchRequest);
@@ -223,7 +251,7 @@ private boolean loadVectorData(RectF dataBox, int zoom){
 				}
 			}
 			
-			List<MultyPolygon> pMulti = proccessMultiPolygons(multiPolygons, leftX, rightX, bottomY, topY);
+			List<MultyPolygon> pMulti = proccessMultiPolygons(multiPolygons, leftX, rightX, bottomY, topY, zoom);
 			tempList.addAll(pMulti);
 			log.info(String.format("Search has been done in %s ms. %s results were found.", System.currentTimeMillis() - now, count)); //$NON-NLS-1$
 			
@@ -322,7 +350,7 @@ private void registerMultipolygon(Map<Integer, List<BinaryMapDataObject>> multyP
 		}
 	}
 	
-	public List<MultyPolygon> proccessMultiPolygons(Map<Integer, List<BinaryMapDataObject>> multyPolygons, int leftX, int rightX, int bottomY, int topY){
+	public List<MultyPolygon> proccessMultiPolygons(Map<Integer, List<BinaryMapDataObject>> multyPolygons, int leftX, int rightX, int bottomY, int topY, int zoom){
 		List<MultyPolygon> listPolygons = new ArrayList<MultyPolygon>(multyPolygons.size());
 		List<List<Long>> completedRings = new ArrayList<List<Long>>();
 		List<List<Long>> incompletedRings = new ArrayList<List<Long>>();
@@ -354,7 +382,7 @@ public List<MultyPolygon> proccessMultiPolygons(Map<Integer, List<BinaryMapDataO
 			incompletedRingNames.clear();
 			
 			MultyPolygon pl = processMultiPolygon(leftX, rightX, bottomY, topY, listPolygons, completedRings, incompletedRings, 
-					completedRingNames, incompletedRingNames, type,	directList, inverselist);
+					completedRingNames, incompletedRingNames, type,	directList, inverselist, zoom);
 			if(pl != null){
 				listPolygons.add(pl);
 			}
@@ -364,7 +392,7 @@ public List<MultyPolygon> proccessMultiPolygons(Map<Integer, List<BinaryMapDataO
 
 	private MultyPolygon processMultiPolygon(int leftX, int rightX, int bottomY, int topY, List<MultyPolygon> listPolygons,
 			List<List<Long>> completedRings, List<List<Long>> incompletedRings, List<String> completedRingNames, List<String> incompletedRingNames, 
-			Integer type, List<BinaryMapDataObject> directList, List<BinaryMapDataObject> inverselist) {
+			Integer type, List<BinaryMapDataObject> directList, List<BinaryMapDataObject> inverselist, int zoom) {
 		MultyPolygon pl = new MultyPolygon();
 		// delete direction last bit (to not show point)
 		pl.setType(type & 0x7fff);
@@ -377,7 +405,7 @@ private MultyPolygon processMultiPolygon(int leftX, int rightX, int bottomY, int
 					continue;
 				}
 				dbId = o.getId() >> 3;
-				List<Long> coordinates = new ArrayList<Long>();
+				List<Long> coordinates = new ArrayList<Long>(o.getPointsLength() / 2);
 				int px = o.getPoint31XTile(km == 0 ? 0 : len - 1); 
 				int py = o.getPoint31YTile(km == 0 ? 0 : len - 1);
 				int x = px;
@@ -409,24 +437,30 @@ private MultyPolygon processMultiPolygon(int leftX, int rightX, int bottomY, int
 			return null;
 		}
 		if (incompletedRings.size() > 0) {
-			unifyIncompletedRings(incompletedRings, completedRings, completedRingNames, incompletedRingNames, leftX, rightX, bottomY, topY, dbId);
+			unifyIncompletedRings(incompletedRings, completedRings, completedRingNames, incompletedRingNames, leftX, rightX, bottomY, topY, dbId, zoom);
 		} else {
-			// check for isolated island (android do not fill area outside path)
-			boolean clockwiseFound = false;
-			for(List<Long> c : completedRings){
-				if(isClockwiseWay(c)){
-					clockwiseFound = true;
-					break;
+			// due to self intersection small objects (for low zooms check only coastline)
+			if (zoom >= 13
+					|| (MapRenderingTypes.getMainObjectType(pl.getTypes()[0]) == MapRenderingTypes.NATURAL && MapRenderingTypes
+							.getObjectSubType(pl.getTypes()[0]) == 5)) {
+				boolean clockwiseFound = false;
+				for (List<Long> c : completedRings) {
+					if (isClockwiseWay(c)) {
+						clockwiseFound = true;
+						break;
+					}
 				}
-			}
-			if(!clockwiseFound){
-				// add whole bound
-				List<Long> whole = new ArrayList<Long>(4);
-				whole.add((((long) leftX) << 32) | ((long) topY));
-				whole.add((((long) rightX) << 32) | ((long) topY));
-				whole.add((((long) rightX) << 32) | ((long) bottomY));
-				whole.add((((long) leftX) << 32) | ((long) bottomY));
-				completedRings.add(whole);
+				if (!clockwiseFound) {
+					// add whole bound
+					List<Long> whole = new ArrayList<Long>(4);
+					whole.add((((long) leftX) << 32) | ((long) topY));
+					whole.add((((long) rightX) << 32) | ((long) topY));
+					whole.add((((long) rightX) << 32) | ((long) bottomY));
+					whole.add((((long) leftX) << 32) | ((long) bottomY));
+					completedRings.add(whole);
+					log.info("!!! Isolated island !!!"); //$NON-NLS-1$
+				}
+
 			}
 		}
 		
@@ -522,7 +556,7 @@ private void processMultipolygonLine(List<List<Long>> completedRings, List<List<
 
 	private void unifyIncompletedRings(List<List<Long>> incompletedRings, List<List<Long>> completedRings, 
 			List<String> completedRingNames, List<String> incompletedRingNames, 
-			int leftX, int rightX,	int bottomY, int topY, long dbId) {
+			int leftX, int rightX,	int bottomY, int topY, long dbId, int zoom) {
 		int mask = 0xffffffff;
 		Set<Integer> nonvisitedRings = new LinkedHashSet<Integer>();
 		for(int j = 0; j< incompletedRings.size(); j++){
@@ -568,7 +602,9 @@ private void unifyIncompletedRings(List<List<Long>> incompletedRings, List<List<
 			
 			int x = (int) (i.get(i.size() - 1) >> 32);
 			int y = (int) (i.get(i.size() - 1) & mask);
-			
+			// 31 - (zoom + 8)
+			int EVAL_DELTA = 6 << (23 - zoom); 
+			int UNDEFINED_MIN_DIFF = -1 - EVAL_DELTA;			
 			while (true) {
 				int st = 0; // st already checked to be one of the four
 				if (y == topY) {
@@ -585,39 +621,39 @@ private void unifyIncompletedRings(List<List<Long>> incompletedRings, List<List<
 				for (int h = st; h < st + 4; h++) {
 
 					// BEGIN find closest nonvisited start (including current)
-					int mindiff = -1;
+					int mindiff = UNDEFINED_MIN_DIFF;
 					for (Integer ni : nonvisitedRings) {
 						List<Long> cni = incompletedRings.get(ni);
 						int csx = (int) (cni.get(0) >> 32);
 						int csy = (int) (cni.get(0) & mask);
 						if (h % 4 == 0) {
 							// top
-							if (csy == topY && csx >= x) {
-								if (mindiff == -1 || (csx - x) <= mindiff) {
+							if (csy == topY && csx >= x - EVAL_DELTA) {
+								if (mindiff == UNDEFINED_MIN_DIFF || (csx - x) <= mindiff) {
 									mindiff = (csx - x);
 									nextRingIndex = ni;
 								}
 							}
 						} else if (h % 4 == 1) {
 							// right
-							if (csx == rightX && csy >= y) {
-								if (mindiff == -1 || (csy - y) <= mindiff) {
+							if (csx == rightX && csy >= y - EVAL_DELTA) {
+								if (mindiff == UNDEFINED_MIN_DIFF || (csy - y) <= mindiff) {
 									mindiff = (csy - y);
 									nextRingIndex = ni;
 								}
 							}
 						} else if (h % 4 == 2) {
 							// bottom
-							if (csy == bottomY && csx <= x) {
-								if (mindiff == -1 || (x - csx) <= mindiff) {
+							if (csy == bottomY && csx <= x + EVAL_DELTA) {
+								if (mindiff == UNDEFINED_MIN_DIFF || (x - csx) <= mindiff) {
 									mindiff = (x - csx);
 									nextRingIndex = ni;
 								}
 							}
 						} else if (h % 4 == 3) {
 							// left
-							if (csx == leftX && csy <= y) {
-								if (mindiff == -1 || (y - csy) <= mindiff) {
+							if (csx == leftX && csy <= y + EVAL_DELTA) {
+								if (mindiff == UNDEFINED_MIN_DIFF || (y - csy) <= mindiff) {
 									mindiff = (y - csy);
 									nextRingIndex = ni;
 								}
@@ -626,7 +662,7 @@ private void unifyIncompletedRings(List<List<Long>> incompletedRings, List<List<
 					} // END find closest start (including current)
 
 					// we found start point
-					if (mindiff != -1) {
+					if (mindiff != UNDEFINED_MIN_DIFF) {
 						break;
 					} else {
 						if (h % 4 == 0) {
diff --git a/OsmAnd/src/net/osmand/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/render/OsmandRenderer.java
index df5fb168e70..cf92a81ace3 100644
--- a/OsmAnd/src/net/osmand/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/render/OsmandRenderer.java
@@ -586,6 +586,9 @@ private void drawMultiPolygon(BinaryMapDataObject obj, Canvas canvas, RenderingC
 		rc.main.updatePaint(paint);
 		canvas.drawPath(path, paint);
 		if (rc.second.strokeWidth != 0) {
+		    //rc.second.strokeWidth = 1.5f;
+		    //rc.second.color = Color.BLACK; 
+		    
 			rc.second.updatePaint(paint);
 			canvas.drawPath(path, paint);
 		}
