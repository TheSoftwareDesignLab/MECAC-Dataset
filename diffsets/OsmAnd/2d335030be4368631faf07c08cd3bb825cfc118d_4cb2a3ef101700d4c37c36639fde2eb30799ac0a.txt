diff --git a/OsmAnd/res/layout-land/dashboard_over_map.xml b/OsmAnd/res/layout-land/dashboard_over_map.xml
index 70210ec79f1..e708d739366 100644
--- a/OsmAnd/res/layout-land/dashboard_over_map.xml
+++ b/OsmAnd/res/layout-land/dashboard_over_map.xml
@@ -52,13 +52,13 @@
                 android:layout_gravity="start"
                 android:visibility="gone" >
 
-                <com.github.ksoichiro.android.observablescrollview.ObservableListView
+                <net.osmand.plus.views.controls.DynamicListView
                     android:id="@+id/dash_list_view"
                     android:layout_width="match_parent"
                     android:layout_height="match_parent"
                     android:background="?attr/bg_color"
                     android:fadeScrollbars="true" >
-                </com.github.ksoichiro.android.observablescrollview.ObservableListView>
+                </net.osmand.plus.views.controls.DynamicListView>
             </FrameLayout>
         </LinearLayout>
 
diff --git a/OsmAnd/res/layout-land/plan_route_info.xml b/OsmAnd/res/layout-land/plan_route_info.xml
index 83c6f731de6..71784746315 100644
--- a/OsmAnd/res/layout-land/plan_route_info.xml
+++ b/OsmAnd/res/layout-land/plan_route_info.xml
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
-<FrameLayout android:id="@+id/plan_route_info"
-             xmlns:android="http://schemas.android.com/apk/res/android"
-             android:layout_width="match_parent"
-             android:layout_height="match_parent"
-             android:clickable="true"
-             android:background="@color/color_transparent">
+<FrameLayout
+    android:id="@+id/plan_route_info"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/color_transparent"
+    android:clickable="true">
 
     <LinearLayout
         android:id="@+id/main_view"
@@ -18,53 +19,47 @@
         <LinearLayout
             android:id="@+id/ModesLayout"
             android:layout_width="fill_parent"
-            android:layout_height="@dimen/list_item_height"
+            android:layout_height="wrap_content"
             android:orientation="vertical">
 
-            <FrameLayout
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-                <View
-                    android:id="@+id/dividerModesLayout"
-                    android:layout_width="match_parent"
-                    android:layout_height="1dp"
-                    android:layout_gravity="bottom"
-                    android:background="@color/dashboard_divider_dark"
-                    android:focusable="false"/>
+            <LinearLayout
+                android:layout_width="fill_parent"
+                android:layout_height="@dimen/list_item_height"
+                android:orientation="horizontal">
 
                 <LinearLayout
-                    android:layout_width="fill_parent"
+                    android:id="@+id/app_modes"
+                    android:layout_width="0dp"
                     android:layout_height="wrap_content"
-                    android:orientation="horizontal">
+                    android:layout_gravity="center_vertical"
+                    android:layout_weight="1"
+                    android:gravity="left"
+                    android:orientation="horizontal"/>
 
-                    <LinearLayout
-                        android:id="@+id/app_modes"
-                        android:layout_width="0dp"
-                        android:layout_height="wrap_content"
-                        android:layout_gravity="center_vertical"
-                        android:layout_weight="1"
-                        android:gravity="left"
-                        android:orientation="horizontal"/>
-
-                    <LinearLayout
-                        android:layout_width="wrap_content"
-                        android:layout_height="wrap_content"
-                        android:layout_gravity="center_horizontal"
-                        android:layout_marginLeft="@dimen/list_content_padding"
-                        android:orientation="horizontal"
-                        android:visibility="gone">
+                <LinearLayout
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center_horizontal"
+                    android:layout_marginLeft="@dimen/list_content_padding"
+                    android:orientation="horizontal"
+                    android:visibility="gone">
 
-                        <ImageView
-                            android:id="@+id/waypoints"
-                            android:layout_width="@dimen/list_item_height"
-                            android:layout_height="@dimen/list_item_height"
-                            android:background="?attr/dashboard_button"
-                            android:scaleType="center"
-                            android:src="@drawable/map_action_waypoints"/>
-                    </LinearLayout>
+                    <ImageView
+                        android:id="@+id/waypoints"
+                        android:layout_width="@dimen/list_item_height"
+                        android:layout_height="@dimen/list_item_height"
+                        android:background="?attr/dashboard_button"
+                        android:scaleType="center"
+                        android:src="@drawable/map_action_waypoints"/>
                 </LinearLayout>
-            </FrameLayout>
+            </LinearLayout>
+
+            <View
+                android:id="@+id/dividerModesLayout"
+                android:layout_width="match_parent"
+                android:layout_height="1dp"
+                android:background="@color/dashboard_divider_dark"
+                android:focusable="false"/>
         </LinearLayout>
 
         <ScrollView
@@ -252,8 +247,8 @@
                         android:id="@+id/Info"
                         android:layout_width="fill_parent"
                         android:layout_height="wrap_content"
-                        android:minHeight="@dimen/list_item_height"
                         android:background="?attr/dashboard_button"
+                        android:minHeight="@dimen/list_item_height"
                         android:orientation="horizontal">
 
                         <ImageView
@@ -269,9 +264,9 @@
                             android:id="@+id/InfoIcon"
                             android:layout_width="@dimen/standard_icon_size"
                             android:layout_height="match_parent"
+                            android:layout_gravity="center_vertical"
                             android:layout_marginLeft="@dimen/list_content_padding"
                             android:layout_marginRight="@dimen/list_content_padding"
-                            android:layout_gravity="center_vertical"
                             android:contentDescription="@string/info_button"
                             android:scaleType="center"
                             android:src="@drawable/ic_action_info_dark"/>
@@ -309,9 +304,9 @@
                             android:id="@+id/DurationIcon"
                             android:layout_width="@dimen/standard_icon_size"
                             android:layout_height="match_parent"
+                            android:layout_gravity="center_vertical"
                             android:layout_marginLeft="@dimen/list_content_padding"
                             android:layout_marginRight="@dimen/list_content_padding"
-                            android:layout_gravity="center_vertical"
                             android:contentDescription="@string/info_button"
                             android:scaleType="center"
                             android:src="@drawable/ic_action_time"/>
@@ -350,8 +345,8 @@
                             android:layout_width="0dp"
                             android:layout_height="wrap_content"
                             android:layout_gravity="center_vertical|left"
-                            android:layout_weight="1"
                             android:layout_margin="8dp"
+                            android:layout_weight="1"
                             android:textSize="@dimen/default_desc_text_size"/>
 
                         <ImageView
diff --git a/OsmAnd/res/layout/dashboard_over_map.xml b/OsmAnd/res/layout/dashboard_over_map.xml
index 95a5751072c..b25766238e0 100644
--- a/OsmAnd/res/layout/dashboard_over_map.xml
+++ b/OsmAnd/res/layout/dashboard_over_map.xml
@@ -61,12 +61,12 @@
                 android:layout_height="wrap_content"
                 android:background="?attr/bg_color" />
 
-            <com.github.ksoichiro.android.observablescrollview.ObservableListView
+            <net.osmand.plus.views.controls.DynamicListView
                 android:id="@+id/dash_list_view"
                 android:layout_width="match_parent"
                 android:layout_height="match_parent"
                 android:fadeScrollbars="true" >
-            </com.github.ksoichiro.android.observablescrollview.ObservableListView>
+            </net.osmand.plus.views.controls.DynamicListView>
         </FrameLayout>
 
         <include layout="@layout/dashboard_toolbar"/>
diff --git a/OsmAnd/res/layout/drawer_list_radius.xml b/OsmAnd/res/layout/drawer_list_radius.xml
index fa6ab1029a0..6865055b2a4 100644
--- a/OsmAnd/res/layout/drawer_list_radius.xml
+++ b/OsmAnd/res/layout/drawer_list_radius.xml
@@ -5,7 +5,7 @@
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:layout_marginTop="5dp"
-    android:minHeight="40dp"
+    android:minHeight="48dp"
     android:layout_marginBottom="5dp">
 
     <ImageView
@@ -24,15 +24,16 @@
         android:layout_height="wrap_content"
         android:layout_weight="1"
         android:layout_gravity="center_vertical"
-        android:textSize="@dimen/default_list_text_size" />
+        android:textSize="@dimen/default_desc_text_size" />
 
     <TextView
         android:id="@+id/description"
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
-        android:textSize="@dimen/default_list_text_size"
-        android:textColor="@color/sherpafy_selection"
+        android:textStyle="bold"
+        android:textSize="@dimen/default_desc_text_size"
+        android:textColor="@color/color_myloc_distance"
         android:layout_gravity="center_vertical"
-        android:layout_marginRight="8dp" />
+        android:layout_marginRight="16dp" />
 
 </LinearLayout>
\ No newline at end of file
diff --git a/OsmAnd/res/layout/drawer_list_radius_ex.xml b/OsmAnd/res/layout/drawer_list_radius_ex.xml
new file mode 100644
index 00000000000..30c7db3cf49
--- /dev/null
+++ b/OsmAnd/res/layout/drawer_list_radius_ex.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:orientation="horizontal"
+              android:layout_width="match_parent"
+              android:layout_height="wrap_content"
+              android:paddingLeft="16dp"
+              android:paddingRight="16dp"
+              android:minHeight="50dp"
+              android:layout_marginBottom="5dp">
+
+    <LinearLayout
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:layout_gravity="center_vertical"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/title"
+            android:text="@string/search_radius_proximity"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:textSize="@dimen/default_desc_text_size" />
+
+        <TextView
+            android:id="@+id/description"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textStyle="bold"
+            android:textSize="@dimen/default_desc_text_size"
+            android:textColor="@color/color_myloc_distance"
+            android:layout_gravity="center_vertical"
+            android:layout_marginTop="2dp"
+            android:text="500 m"
+            android:layout_marginRight="16dp" />
+
+    </LinearLayout>
+
+    <LinearLayout
+        android:layout_width="0dp"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:layout_gravity="center_vertical"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/titleEx"
+            android:text="@string/shared_string_type"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_gravity="center_vertical"
+            android:textSize="@dimen/default_desc_text_size" />
+
+        <TextView
+            android:id="@+id/descriptionEx"
+            android:layout_width="wrap_content"
+            android:layout_height="wrap_content"
+            android:textStyle="bold"
+            android:textSize="@dimen/default_desc_text_size"
+            android:textColor="@color/color_myloc_distance"
+            android:layout_gravity="center_vertical"
+            android:layout_marginTop="2dp"
+            android:text="Cinema"
+            android:layout_marginRight="16dp" />
+
+    </LinearLayout>
+
+</LinearLayout>
\ No newline at end of file
diff --git a/OsmAnd/res/layout/plan_route_info.xml b/OsmAnd/res/layout/plan_route_info.xml
index e37ff457056..25cb993d913 100644
--- a/OsmAnd/res/layout/plan_route_info.xml
+++ b/OsmAnd/res/layout/plan_route_info.xml
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
-<FrameLayout android:id="@+id/plan_route_info"
-             xmlns:android="http://schemas.android.com/apk/res/android"
-             android:layout_width="match_parent"
-             android:layout_height="match_parent"
-             android:clickable="true"
-             android:background="@color/color_transparent">
+<FrameLayout
+    android:id="@+id/plan_route_info"
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="match_parent"
+    android:background="@color/color_transparent"
+    android:clickable="true">
 
     <LinearLayout
         android:id="@+id/main_view"
@@ -18,53 +19,46 @@
         <LinearLayout
             android:id="@+id/ModesLayout"
             android:layout_width="fill_parent"
-            android:layout_height="@dimen/list_item_height"
+            android:layout_height="wrap_content"
             android:orientation="vertical">
 
-            <FrameLayout
-                android:layout_width="match_parent"
-                android:layout_height="wrap_content">
-
-                <View
-                    android:id="@+id/dividerModesLayout"
-                    android:layout_width="match_parent"
-                    android:layout_height="1dp"
-                    android:layout_gravity="bottom"
-                    android:background="@color/dashboard_divider_dark"
-                    android:focusable="false"/>
+            <LinearLayout
+                android:layout_width="fill_parent"
+                android:layout_height="@dimen/list_item_height"
+                android:orientation="horizontal">
 
                 <LinearLayout
-                    android:layout_width="fill_parent"
+                    android:id="@+id/app_modes"
+                    android:layout_width="0dp"
                     android:layout_height="wrap_content"
-                    android:orientation="horizontal">
+                    android:layout_gravity="center_vertical"
+                    android:layout_weight="1"
+                    android:gravity="left"
+                    android:orientation="horizontal"/>
 
-                    <LinearLayout
-                        android:id="@+id/app_modes"
-                        android:layout_width="0dp"
-                        android:layout_height="wrap_content"
-                        android:layout_gravity="center_vertical"
-                        android:layout_weight="1"
-                        android:gravity="left"
-                        android:orientation="horizontal"/>
-
-                    <LinearLayout
-                        android:layout_width="wrap_content"
-                        android:layout_height="wrap_content"
-                        android:layout_gravity="center_horizontal"
-                        android:layout_marginLeft="@dimen/list_content_padding"
-                        android:orientation="horizontal"
-                        android:visibility="gone">
+                <LinearLayout
+                    android:layout_width="wrap_content"
+                    android:layout_height="wrap_content"
+                    android:layout_gravity="center_horizontal"
+                    android:layout_marginLeft="@dimen/list_content_padding"
+                    android:orientation="horizontal"
+                    android:visibility="gone">
 
-                        <ImageView
-                            android:id="@+id/waypoints"
-                            android:layout_width="@dimen/list_item_height"
-                            android:layout_height="@dimen/list_item_height"
-                            android:background="?attr/dashboard_button"
-                            android:scaleType="center"
-                            android:src="@drawable/map_action_waypoints"/>
-                    </LinearLayout>
+                    <ImageView
+                        android:id="@+id/waypoints"
+                        android:layout_width="@dimen/list_item_height"
+                        android:layout_height="@dimen/list_item_height"
+                        android:background="?attr/dashboard_button"
+                        android:scaleType="center"
+                        android:src="@drawable/map_action_waypoints"/>
                 </LinearLayout>
-            </FrameLayout>
+            </LinearLayout>
+            <View
+                android:id="@+id/dividerModesLayout"
+                android:layout_width="match_parent"
+                android:layout_height="1dp"
+                android:background="@color/dashboard_divider_dark"
+                android:focusable="false"/>
         </LinearLayout>
 
         <ScrollView
@@ -252,8 +246,8 @@
                         android:id="@+id/Info"
                         android:layout_width="fill_parent"
                         android:layout_height="wrap_content"
-                        android:minHeight="@dimen/list_item_height"
                         android:background="?attr/dashboard_button"
+                        android:minHeight="@dimen/list_item_height"
                         android:orientation="horizontal">
 
                         <ImageView
@@ -269,9 +263,9 @@
                             android:id="@+id/InfoIcon"
                             android:layout_width="@dimen/standard_icon_size"
                             android:layout_height="match_parent"
+                            android:layout_gravity="center_vertical"
                             android:layout_marginLeft="@dimen/list_content_padding"
                             android:layout_marginRight="@dimen/list_content_padding"
-                            android:layout_gravity="center_vertical"
                             android:contentDescription="@string/info_button"
                             android:scaleType="center"
                             android:src="@drawable/ic_action_info_dark"/>
@@ -309,9 +303,9 @@
                             android:id="@+id/DurationIcon"
                             android:layout_width="@dimen/standard_icon_size"
                             android:layout_height="match_parent"
+                            android:layout_gravity="center_vertical"
                             android:layout_marginLeft="@dimen/list_content_padding"
                             android:layout_marginRight="@dimen/list_content_padding"
-                            android:layout_gravity="center_vertical"
                             android:contentDescription="@string/info_button"
                             android:scaleType="center"
                             android:src="@drawable/ic_action_time"/>
diff --git a/OsmAnd/res/layout/waypoint_header.xml b/OsmAnd/res/layout/waypoint_header.xml
index e2aba557792..40ff101a1a5 100644
--- a/OsmAnd/res/layout/waypoint_header.xml
+++ b/OsmAnd/res/layout/waypoint_header.xml
@@ -1,13 +1,14 @@
 <?xml version="1.0" encoding="utf-8"?>
 <LinearLayout
     xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:osmand="http://schemas.android.com/apk/res-auto"
     android:layout_width="fill_parent"
     android:layout_height="match_parent"
     android:layout_marginBottom="5dp"
-    android:layout_marginRight="3dp"
+    android:paddingRight="16dp"
     android:layout_marginTop="5dp"
     android:gravity="center_vertical"
-    android:minHeight="40dp"
+    android:minHeight="48dp"
     android:orientation="horizontal">
 
     <ProgressBar
@@ -17,16 +18,17 @@
         android:layout_gravity="center_vertical"
         android:layout_marginLeft="4dp"/>
 
-    <TextView
+    <net.osmand.plus.widgets.TextViewEx
         android:id="@+id/header_text"
         android:layout_width="0dp"
         android:layout_height="wrap_content"
         android:layout_gravity="center_vertical"
-        android:layout_marginLeft="8dp"
+        android:layout_marginLeft="16dp"
         android:layout_weight="1"
         android:ellipsize="end"
         android:singleLine="true"
-        android:textSize="@dimen/default_list_text_size_large"/>
+        style="@style/DashboardSubHeader"
+        osmand:typeface="@string/font_roboto_medium"/>
 
     <include layout="@layout/check_item_rel"/>
 
diff --git a/OsmAnd/res/layout/waypoint_reached.xml b/OsmAnd/res/layout/waypoint_reached.xml
index f506deb976e..50a4772d9ea 100644
--- a/OsmAnd/res/layout/waypoint_reached.xml
+++ b/OsmAnd/res/layout/waypoint_reached.xml
@@ -3,63 +3,103 @@
 <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:orientation="horizontal"
     android:layout_width="fill_parent"
-    android:layout_height="match_parent"
+    android:layout_height="wrap_content"
     android:background="@drawable/view_transparent_selection"
     android:id="@+id/package_delivered_layout"
-    android:minHeight="48dp"
+    android:minHeight="50dp"
     android:descendantFocusability="blocksDescendants">
 
     <ImageView
         android:id="@+id/waypoint_icon"
-        android:layout_marginLeft="8dp"
         android:src="@drawable/ic_action_fav_dark"
         android:layout_height="25dp"
-        android:layout_width="25dp"
+        android:layout_width="56dp"
         android:layout_gravity="center_vertical" />
 
-    <TextView
-        android:id="@+id/waypoint_dist"
-        android:layout_width="60dp"
-        android:layout_height="wrap_content"
-        android:layout_marginLeft="4dp"
-        android:layout_gravity="center_vertical"
-        android:textColor="@color/wpt_distance_color"
-        android:maxLines="2"
-        android:textStyle="bold"
-        android:textSize="@dimen/default_desc_text_size"/>
-
-    <TextView
-        android:id="@+id/waypoint_text"
+    <LinearLayout
         android:layout_width="0dp"
         android:layout_height="wrap_content"
-        android:layout_marginLeft="4dp"
-        android:maxLines="2"
-        android:ellipsize="end"
-        android:layout_gravity="center_vertical"
         android:layout_weight="1"
-        android:textSize="@dimen/default_list_text_size" />
+        android:gravity="center"
+        android:layout_gravity="center_vertical"
+        android:orientation="vertical">
+
+        <TextView
+            android:id="@+id/waypoint_text"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:maxLines="2"
+            android:ellipsize="end"
+            android:layout_gravity="center_vertical"
+            android:textSize="@dimen/default_list_text_size" />
+
+        <LinearLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginTop="2dp"
+            android:orientation="horizontal">
+
+            <TextView
+                android:id="@+id/waypoint_dist"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_gravity="bottom"
+                android:textColor="@color/color_myloc_distance"
+                android:maxLines="1"
+                android:textSize="@dimen/default_sub_text_size"/>
+
+            <TextView
+                android:id="@+id/waypoint_desc_text"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:maxLines="1"
+                android:ellipsize="end"
+                android:layout_gravity="bottom"
+                android:layout_weight="1"
+                android:textColor="@color/secondary_text_dark"
+                android:textSize="@dimen/default_sub_text_size" />
+
+        </LinearLayout>
+
+
+    </LinearLayout>
 
     <ImageButton
         android:id="@+id/all_points"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
         android:contentDescription="@string/shared_string_more"
         android:layout_gravity="center_vertical"
+        android:layout_marginRight="2dp"
         android:visibility="gone"
         android:focusable="false"
+        android:scaleType="center"
         style="@style/Widget.AppCompat.ActionButton"
-        android:src="@drawable/ic_action_core_overflow_dark" />
+        android:src="@drawable/map_overflow_menu_white" />
 
     <ImageButton
         android:id="@+id/info_close"
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
         android:contentDescription="@string/shared_string_close"
         android:layout_gravity="center_vertical"
-        android:layout_marginRight="4dp"
+        android:layout_marginRight="2dp"
         style="@style/Widget.AppCompat.ActionButton"
         android:focusable="false"
-        android:src="@drawable/ic_action_gremove_dark" />
+        android:scaleType="center"
+        android:src="@drawable/ic_action_remove_dark" />
 
+    <ImageView
+        android:id="@+id/info_move"
+        android:layout_width="48dp"
+        android:layout_height="48dp"
+        android:layout_gravity="center_vertical"
+        android:layout_marginRight="2dp"
+        android:focusable="false"
+        android:clickable="false"
+        android:scaleType="center"
+        android:src="@drawable/ic_flat_list_dark"
+        android:tag="DragIcon"
+        android:visibility="gone"/>
 
 </LinearLayout>
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/CurrentPositionHelper.java b/OsmAnd/src/net/osmand/plus/CurrentPositionHelper.java
index 616ad7341d4..1da82e05b3b 100644
--- a/OsmAnd/src/net/osmand/plus/CurrentPositionHelper.java
+++ b/OsmAnd/src/net/osmand/plus/CurrentPositionHelper.java
@@ -83,8 +83,13 @@ public void run() {
 					}
 				}
 			};
-			if (!app.getRoutingHelper().startTaskInRouteThreadIfPossible(run) && result != null) {
-				result.publish(null);
+			if (!app.getRoutingHelper().startTaskInRouteThreadIfPossible(run)) {
+				if (result != null) {
+					result.publish(null);
+				}
+				if (geoCoding != null) {
+					geoCoding.publish(null);
+				}
 			}
 		}
 	}
diff --git a/OsmAnd/src/net/osmand/plus/TargetPointsHelper.java b/OsmAnd/src/net/osmand/plus/TargetPointsHelper.java
index 287f72ed324..89346575912 100644
--- a/OsmAnd/src/net/osmand/plus/TargetPointsHelper.java
+++ b/OsmAnd/src/net/osmand/plus/TargetPointsHelper.java
@@ -29,7 +29,8 @@ public static class TargetPoint implements LocationPoint {
 		private PointDescription pointDescription;
 		public int index;
 		public boolean intermediate;
-		
+		public boolean start;
+
 		public TargetPoint(LatLon point, PointDescription name) {
 			this.point = point;
 			this.pointDescription = name;
@@ -66,7 +67,15 @@ public static TargetPoint create(LatLon point, PointDescription name) {
 			}
 			return null;
 		}
-		
+
+		public static TargetPoint createStartPoint(LatLon point, PointDescription name) {
+			if (point != null) {
+				TargetPoint target = new TargetPoint(point, name);
+				target.start = true;
+				return target;
+			}
+			return null;
+		}
 
 		public double getLatitude() {
 			return point.getLatitude();
@@ -97,7 +106,7 @@ public TargetPointsHelper(OsmandApplication ctx){
 
 	private void readFromSettings(OsmandSettings settings) {
 		pointToNavigate = TargetPoint.create(settings.getPointToNavigate(), settings.getPointNavigateDescription());
-		pointToStart = TargetPoint.create(settings.getPointToStart(), settings.getStartPointDescription());
+		pointToStart = TargetPoint.createStartPoint(settings.getPointToStart(), settings.getStartPointDescription());
 		intermediatePoints.clear();
 		List<LatLon> ips = settings.getIntermediatePoints();
 		List<String> desc = settings.getIntermediatePointDescriptions(ips.size());
@@ -285,7 +294,7 @@ public void clearStartPoint(boolean updateRoute) {
 	}
 
 
-	public void reorderAllTargetPoints(List<TargetPoint> point, boolean updateRoute){
+	public void reorderAllTargetPoints(List<TargetPoint> point, boolean updateRoute) {
 		settings.clearPointToNavigate();
 		if (point.size() > 0) {
 			List<TargetPoint> subList = point.subList(0, point.size() - 1);
diff --git a/OsmAnd/src/net/osmand/plus/dashboard/DashWaypointsFragment.java b/OsmAnd/src/net/osmand/plus/dashboard/DashWaypointsFragment.java
index 0d9ad80bf0e..0d5a723f895 100644
--- a/OsmAnd/src/net/osmand/plus/dashboard/DashWaypointsFragment.java
+++ b/OsmAnd/src/net/osmand/plus/dashboard/DashWaypointsFragment.java
@@ -96,7 +96,7 @@ public void onClick(View v) {
 			View dv = getActivity().getLayoutInflater().inflate(R.layout.divider, null);
 			favorites.addView(dv);
 			View v = WaypointDialogHelper.updateWaypointItemView(false, null, getMyApplication(),
-					getActivity(), null, ps, null, !getMyApplication().getSettings().isLightContent());
+					getActivity(), null, ps, null, !getMyApplication().getSettings().isLightContent(), true);
 			favorites.addView(v);
 
 		}
@@ -142,7 +142,21 @@ public void onClick(View view) {
 			view.findViewById(R.id.group_image).setVisibility(View.GONE);
 
 			boolean target = helper.getPointToNavigate() == point;
-			int id = target ? R.drawable.list_destination : R.drawable.list_intermediate;
+			int id;
+			if (!target) {
+				if (getMyApplication().getSettings().isLightContent()) {
+					id = R.drawable.widget_intermediate_day;
+				} else {
+					id = R.drawable.widget_intermediate_night;
+				}
+			} else {
+				if (getMyApplication().getSettings().isLightContent()) {
+					id = R.drawable.widget_target_day;
+				} else {
+					id = R.drawable.widget_target_night;
+				}
+			}
+
 			((ImageView) view.findViewById(R.id.favourite_icon)).setImageDrawable(getMyApplication().getIconsCache()
 					.getIcon(id, 0));
 			DashLocationView dv = new DashLocationView(direction, label, new LatLon(point.getLatitude(),
diff --git a/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java b/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java
index 52751363519..deccbaafbd8 100644
--- a/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java
+++ b/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java
@@ -35,6 +35,7 @@
 import com.github.ksoichiro.android.observablescrollview.ScrollState;
 
 import net.osmand.PlatformUtil;
+import net.osmand.ValueHolder;
 import net.osmand.data.LatLon;
 import net.osmand.plus.ContextMenuAdapter;
 import net.osmand.plus.ContextMenuAdapter.OnContextMenuClick;
@@ -44,7 +45,7 @@
 import net.osmand.plus.OsmandPlugin;
 import net.osmand.plus.OsmandSettings;
 import net.osmand.plus.R;
-import net.osmand.plus.activities.IntermediatePointsDialog;
+import net.osmand.plus.TargetPointsHelper.TargetPoint;
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.dashboard.tools.DashFragmentData;
 import net.osmand.plus.dashboard.tools.DashboardSettingsDialogFragment;
@@ -57,8 +58,12 @@
 import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu;
 import net.osmand.plus.mapcontextmenu.other.RoutePreferencesMenu.LocalRoutingParameter;
 import net.osmand.plus.routing.RoutingHelper;
+import net.osmand.plus.routing.RoutingHelper.IRouteInformationListener;
 import net.osmand.plus.views.DownloadedRegionsLayer;
 import net.osmand.plus.views.OsmandMapTileView;
+import net.osmand.plus.views.controls.DynamicListView;
+import net.osmand.plus.views.controls.DynamicListViewCallbacks;
+import net.osmand.plus.views.controls.StableArrayAdapter;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
@@ -72,7 +77,7 @@
 
 /**
  */
-public class DashboardOnMap implements ObservableScrollViewCallbacks {
+public class DashboardOnMap implements ObservableScrollViewCallbacks, DynamicListViewCallbacks, IRouteInformationListener {
 	private static final org.apache.commons.logging.Log LOG =
 			PlatformUtil.getLog(DashboardOnMap.class);
 	private static final String TAG = "DashboardOnMap";
@@ -182,6 +187,8 @@ public void onClick(View v) {
 		toolbar = ((Toolbar) dashboardView.findViewById(R.id.toolbar));
 		ObservableScrollView scrollView = ((ObservableScrollView) dashboardView.findViewById(R.id.main_scroll));
 		listView = (ListView) dashboardView.findViewById(R.id.dash_list_view);
+		listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
+		((DynamicListView) listView).setDynamicListViewCallbacks(this);
 		gradientToolbar = mapActivity.getResources().getDrawable(R.drawable.gradient_toolbar).mutate();
 		if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
 			this.portrait = true;
@@ -211,7 +218,7 @@ public void onClick(View v) {
 					FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
 			shadow.setScaleType(ScaleType.FIT_XY);
 			shadowContainer.addView(shadow);
-			((FrameLayout)paddingView).addView(shadowContainer);
+			((FrameLayout) paddingView).addView(shadowContainer);
 			listView.addHeaderView(paddingView);
 			listBackgroundView = mapActivity.findViewById(R.id.dash_list_background);
 		}
@@ -248,8 +255,7 @@ private void updateToolbarActions() {
 		TextView tv = (TextView) dashboardView.findViewById(R.id.toolbar_text);
 		tv.setText("");
 		boolean waypointsVisible = visibleType == DashboardType.WAYPOINTS || visibleType == DashboardType.WAYPOINTS_FLAT;
-		boolean waypointsEdit = visibleType == DashboardType.WAYPOINTS_EDIT;
-		if (waypointsVisible || waypointsEdit) {
+		if (waypointsVisible) {
 			tv.setText(R.string.waypoints);
 		} else if (visibleType == DashboardType.CONFIGURE_MAP) {
 			tv.setText(R.string.configure_map);
@@ -283,25 +289,6 @@ public void onClick(View v) {
 		});
 
 		if (waypointsVisible && getMyApplication().getWaypointHelper().getAllPoints().size() > 0) {
-			if (mapActivity.getMyApplication().getTargetPointsHelper().getIntermediatePoints().size() > 0) {
-				sort.setVisibility(View.VISIBLE);
-				sort.setOnClickListener(new View.OnClickListener() {
-
-					@Override
-					public void onClick(View v) {
-						hideDashboard();
-						IntermediatePointsDialog.openIntermediatePointsDialog(mapActivity, getMyApplication(), true);
-					}
-				});
-			}
-			edit.setVisibility(View.VISIBLE);
-			edit.setOnClickListener(new View.OnClickListener() {
-
-				@Override
-				public void onClick(View v) {
-					setDashboardVisibility(true, DashboardType.WAYPOINTS_EDIT);
-				}
-			});
 			if (getMyApplication().getWaypointHelper().isRouteCalculated()) {
 				flat.setVisibility(View.VISIBLE);
 				final boolean flatNow = visibleType == DashboardType.WAYPOINTS_FLAT;
@@ -317,17 +304,17 @@ public void onClick(View v) {
 				});
 			}
 		}
-		if (waypointsEdit) {
-			ok.setVisibility(View.VISIBLE);
-			ok.setOnClickListener(new View.OnClickListener() {
-
-				@Override
-				public void onClick(View v) {
-					mapActivity.getMyApplication().getWaypointHelper().removeVisibleLocationPoint(deletedPoints);
-					hideDashboard();
-				}
-			});
-		}
+//		if (waypointsEdit) {
+//			ok.setVisibility(View.VISIBLE);
+//			ok.setOnClickListener(new View.OnClickListener() {
+//
+//				@Override
+//				public void onClick(View v) {
+		mapActivity.getMyApplication().getWaypointHelper().removeVisibleLocationPoint(deletedPoints);
+//					hideDashboard();
+//				}
+//			});
+//		}
 		if (visibleType == DashboardType.DASHBOARD || visibleType == DashboardType.LIST_MENU) {
 			settingsButton.setVisibility(View.VISIBLE);
 			settingsButton.setOnClickListener(new View.OnClickListener() {
@@ -552,7 +539,9 @@ public void setDashboardVisibility(boolean visible, DashboardType type, Dashboar
 			open(dashboardView.findViewById(R.id.animateContent), animation);
 			updateLocation(true, true, false);
 //			addOrUpdateDashboardFragments();
+			mapActivity.getRoutingHelper().addListener(this);
 		} else {
+			mapActivity.getRoutingHelper().removeListener(this);
 			mapActivity.getMapViewTrackingUtilities().setDashboard(null);
 			hide(dashboardView.findViewById(R.id.animateContent), animation);
 			mapActivity.findViewById(R.id.MapHudButtonsOverlay).setVisibility(View.VISIBLE);
@@ -607,10 +596,15 @@ private int dpToPx(float dp) {
 	private void updateListAdapter() {
 		ContextMenuAdapter cm = null;
 		if (DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType) {
-			ArrayAdapter<Object> listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(false, deletedPoints, mapActivity, running,
+			StableArrayAdapter listAdapter = waypointDialogHelper.getWaypointsDrawerAdapter(true, deletedPoints, mapActivity, running,
 					DashboardType.WAYPOINTS_FLAT == visibleType, nightMode);
 			OnItemClickListener listener = waypointDialogHelper.getDrawerItemClickListener(mapActivity, running,
 					listAdapter);
+
+			DynamicListView dynamicListView = (DynamicListView) listView;
+			dynamicListView.setItemsList(listAdapter.getObjects());
+			dynamicListView.setActiveItemsList(listAdapter.getActiveObjects());
+
 			updateListAdapter(listAdapter, listener);
 		} else if (DashboardType.WAYPOINTS_EDIT == visibleType) {
 			deletedPoints.clear();
@@ -643,7 +637,7 @@ public void updateListAdapter(ContextMenuAdapter cm) {
 		boolean nightMode = mapActivity.getMyApplication().getDaynightHelper().isNightModeForMapControls();
 		if (this.nightMode != nightMode) {
 			this.nightMode = nightMode;
- 			applyDayNightMode();
+			applyDayNightMode();
 		}
 		final ArrayAdapter<?> listAdapter = cm.createListAdapter(mapActivity, !nightMode);
 		OnItemClickListener listener = getOptionsMenuOnClickListener(cm, listAdapter);
@@ -1087,4 +1081,54 @@ public boolean shouldShow(OsmandSettings settings, MapActivity activity, String
 			return settings.registerBooleanPreference(SHOULD_SHOW + tag, true).makeGlobal().get();
 		}
 	}
+
+	@Override
+	public void onItemsSwapped(final List<Object> items) {
+		getMyApplication().runInUIThread(new Runnable() {
+			@Override
+			public void run() {
+				if (visibleType == DashboardType.WAYPOINTS) {
+					List<TargetPoint> allTargets = new ArrayList<>();
+					if (items != null) {
+						for (Object obj : items) {
+							if (obj instanceof LocationPointWrapper) {
+								LocationPointWrapper p = (LocationPointWrapper) obj;
+								if (p.getPoint() instanceof TargetPoint) {
+									TargetPoint t = (TargetPoint) p.getPoint();
+									if (!t.start) {
+										t.intermediate = true;
+										allTargets.add(t);
+									}
+								}
+							}
+						}
+						if (allTargets.size() > 0) {
+							allTargets.get(allTargets.size() - 1).intermediate = false;
+						}
+					}
+					getMyApplication().getTargetPointsHelper().reorderAllTargetPoints(allTargets, false);
+					newRouteIsCalculated(false, null);
+					getMyApplication().getTargetPointsHelper().updateRouteAndReferesh(true);
+				}
+			}
+		}, 50);
+	}
+
+	@Override
+	public void newRouteIsCalculated(boolean newRoute, ValueHolder<Boolean> showToast) {
+		if ((DashboardType.WAYPOINTS == visibleType || DashboardType.WAYPOINTS_FLAT == visibleType)
+				&& listAdapter != null && listAdapter instanceof StableArrayAdapter) {
+			StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
+			waypointDialogHelper.reloadListAdapter(stableAdapter);
+			if (listView instanceof DynamicListView) {
+				DynamicListView dynamicListView = (DynamicListView) listView;
+				dynamicListView.setItemsList(stableAdapter.getObjects());
+				dynamicListView.setActiveItemsList(stableAdapter.getActiveObjects());
+			}
+		}
+	}
+
+	@Override
+	public void routeWasCancelled() {
+	}
 }
diff --git a/OsmAnd/src/net/osmand/plus/helpers/AvoidSpecificRoads.java b/OsmAnd/src/net/osmand/plus/helpers/AvoidSpecificRoads.java
index 98592988bf2..70fb81fa05d 100644
--- a/OsmAnd/src/net/osmand/plus/helpers/AvoidSpecificRoads.java
+++ b/OsmAnd/src/net/osmand/plus/helpers/AvoidSpecificRoads.java
@@ -74,7 +74,7 @@ public View getView(final int position, View convertView, ViewGroup parent) {
 				ImageButton remove = (ImageButton) v.findViewById(R.id.info_close);
 				remove.setVisibility(View.VISIBLE);
 				remove.setImageDrawable(app.getIconsCache().getContentIcon(
-						R.drawable.ic_action_gremove_dark));
+						R.drawable.ic_action_remove_dark));
 				remove.setOnClickListener(new View.OnClickListener() {
 
 					@Override
diff --git a/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java b/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java
index 3d209ecd47d..40101711228 100644
--- a/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java
+++ b/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java
@@ -4,8 +4,6 @@
 import android.content.DialogInterface;
 import android.content.DialogInterface.OnClickListener;
 import android.content.DialogInterface.OnDismissListener;
-import android.graphics.drawable.ColorDrawable;
-import android.graphics.drawable.Drawable;
 import android.os.AsyncTask;
 import android.support.v4.app.FragmentActivity;
 import android.support.v7.app.AlertDialog;
@@ -19,18 +17,20 @@
 import android.widget.TextView;
 
 import net.osmand.AndroidUtils;
+import net.osmand.Location;
+import net.osmand.data.FavouritePoint;
 import net.osmand.data.LatLon;
 import net.osmand.data.LocationPoint;
 import net.osmand.data.PointDescription;
-import net.osmand.data.RotatedTileBox;
-import net.osmand.plus.IconsCache;
 import net.osmand.plus.OsmAndFormatter;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
+import net.osmand.plus.TargetPointsHelper.TargetPoint;
+import net.osmand.plus.activities.IntermediatePointsDialog;
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.helpers.WaypointHelper.LocationPointWrapper;
 import net.osmand.plus.poi.PoiUIFilter;
-import net.osmand.plus.views.AnimateDraggingMapThread;
+import net.osmand.plus.views.controls.StableArrayAdapter;
 import net.osmand.util.Algorithms;
 import net.osmand.util.MapUtils;
 
@@ -62,39 +62,74 @@ public WaypointDialogHelper(MapActivity mapActivity) {
 
 	public static void updatePointInfoView(final OsmandApplication app, final Activity activity,
 										   View localView, final LocationPointWrapper ps,
-										   final boolean mapCenter, final boolean nightMode) {
+										   final boolean mapCenter, final boolean nightMode,
+										   final boolean edit) {
 		WaypointHelper wh = app.getWaypointHelper();
 		final LocationPoint point = ps.getPoint();
 		TextView text = (TextView) localView.findViewById(R.id.waypoint_text);
 		AndroidUtils.setTextPrimaryColor(activity, text, nightMode);
 		TextView textShadow = (TextView) localView.findViewById(R.id.waypoint_text_shadow);
-		localView.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View view) {
-				showOnMap(app, activity, point, mapCenter);
-			}
-		});
+		if (!edit) {
+			localView.setOnClickListener(new View.OnClickListener() {
+				@Override
+				public void onClick(View view) {
+					showOnMap(app, activity, point, mapCenter);
+				}
+			});
+		}
 		TextView textDist = (TextView) localView.findViewById(R.id.waypoint_dist);
-		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(ps.getDrawable(activity, app));
+		((ImageView) localView.findViewById(R.id.waypoint_icon)).setImageDrawable(ps.getDrawable(activity, app, nightMode));
 		int dist = -1;
-		if (!wh.isRouteCalculated()) {
-			if (activity instanceof MapActivity) {
-				dist = (int) MapUtils.getDistance(((MapActivity) activity).getMapView().getLatitude(), ((MapActivity) activity)
-						.getMapView().getLongitude(), point.getLatitude(), point.getLongitude());
+		boolean startPoint = ps.type == WaypointHelper.TARGETS && ((TargetPoint) ps.point).start;
+		if (!startPoint) {
+			if (!wh.isRouteCalculated()) {
+				if (activity instanceof MapActivity) {
+					dist = (int) MapUtils.getDistance(((MapActivity) activity).getMapView().getLatitude(), ((MapActivity) activity)
+							.getMapView().getLongitude(), point.getLatitude(), point.getLongitude());
+				}
+			} else {
+				dist = wh.getRouteDistance(ps);
 			}
-		} else {
-			dist = wh.getRouteDistance(ps);
 		}
+
+		String pointDescription = "";
+		TextView descText = (TextView) localView.findViewById(R.id.waypoint_desc_text);
+		if (descText != null) {
+			AndroidUtils.setTextSecondaryColor(activity, descText, nightMode);
+			switch (ps.type) {
+				case WaypointHelper.TARGETS:
+					TargetPoint targetPoint = (TargetPoint) ps.point;
+					if (targetPoint.start) {
+						pointDescription = activity.getResources().getString(R.string.starting_point);
+					} else {
+						pointDescription = targetPoint.getPointDescription(activity).getTypeName();
+					}
+					break;
+
+				case WaypointHelper.FAVORITES:
+					FavouritePoint favPoint = (FavouritePoint) ps.point;
+					pointDescription = favPoint.getCategory();
+					break;
+			}
+		}
+
 		if (dist > 0) {
 			String dd = OsmAndFormatter.getFormattedDistance(dist, app);
 			if (ps.deviationDistance > 0) {
-				dd += "\n+" + OsmAndFormatter.getFormattedDistance(ps.deviationDistance, app);
+				dd += "  +" + OsmAndFormatter.getFormattedDistance(ps.deviationDistance, app);
 			}
 			textDist.setText(dd);
+			if (!Algorithms.isEmpty(pointDescription)) {
+				pointDescription = "  â€¢  " + pointDescription;
+			}
 		} else {
 			textDist.setText("");
 		}
 
+		if (descText != null) {
+			descText.setText(pointDescription);
+		}
+
 		String descr;
 		PointDescription pd = point.getPointDescription(app);
 		if (Algorithms.isEmpty(pd.getName())) {
@@ -113,18 +148,33 @@ public void onClick(View view) {
 //					0);
 	}
 
+	private List<Object> getActivePoints(List<Object> points) {
+		List<Object> activePoints = new ArrayList<>();
+		for (Object p : points) {
+			if (p instanceof LocationPointWrapper) {
+				LocationPointWrapper w = (LocationPointWrapper) p;
+				if (w.type == WaypointHelper.TARGETS && !((TargetPoint) w.point).start) {
+					activePoints.add(p);
+				}
+			}
+		}
+		return activePoints;
+	}
 
-	public ArrayAdapter<Object> getWaypointsDrawerAdapter(
+	public StableArrayAdapter getWaypointsDrawerAdapter(
 			final boolean edit, final List<LocationPointWrapper> deletedPoints,
 			final MapActivity ctx, final int[] running, final boolean flat, final boolean nightMode) {
+
 		final List<Object> points;
 		if (flat) {
 			points = new ArrayList<Object>(waypointHelper.getAllPoints());
 		} else {
 			points = getPoints();
 		}
-		return new ArrayAdapter<Object>(ctx,
-				R.layout.waypoint_reached, R.id.title, points) {
+		List<Object> activePoints = getActivePoints(points);
+
+		return new StableArrayAdapter(ctx,
+				R.layout.waypoint_reached, R.id.title, points, activePoints) {
 
 			@Override
 			public View getView(final int position, View convertView, ViewGroup parent) {
@@ -139,56 +189,76 @@ public View getView(final int position, View convertView, ViewGroup parent) {
 					final int type = ((RadiusItem) obj).type;
 					v = createItemForRadiusProximity(ctx, type, running, position, thisAdapter, nightMode);
 					//Drawable d = new ColorDrawable(mapActivity.getResources().getColor(R.color.dashboard_divider_light));
-					if (nightMode) {
-						v.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_dark));
-					} else {
-						v.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_light));
-					}
+					AndroidUtils.setListItemBackground(mapActivity, v, nightMode);
 				} else if (labelView) {
 					v = createItemForCategory(ctx, (Integer) obj, running, position, thisAdapter, nightMode);
-					if (nightMode) {
-						v.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_dark));
-					} else {
-						v.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_light));
-					}
+					AndroidUtils.setListItemBackground(mapActivity, v, nightMode);
 				} else if (topDividerView) {
 					v = ctx.getLayoutInflater().inflate(R.layout.card_top_divider, null);
 				} else if (bottomDividerView) {
 					v = ctx.getLayoutInflater().inflate(R.layout.card_bottom_divider, null);
 				} else if (obj instanceof LocationPointWrapper) {
 					LocationPointWrapper point = (LocationPointWrapper) obj;
-					v = updateWaypointItemView(edit, deletedPoints, app, ctx, v, point, this, nightMode);
-					if (nightMode) {
-						v.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_dark));
-					} else {
-						v.setBackgroundColor(mapActivity.getResources().getColor(R.color.bg_color_light));
-					}
+					v = updateWaypointItemView(edit, deletedPoints, app, ctx, v, point, this,
+							nightMode, flat);
+					AndroidUtils.setListItemBackground(mapActivity, v, nightMode);
 				}
 				return v;
 			}
-
-
 		};
 	}
 
 
 	public static View updateWaypointItemView(final boolean edit, final List<LocationPointWrapper> deletedPoints,
-											  final OsmandApplication app, final Activity ctx, View v, final LocationPointWrapper point,
-											  final ArrayAdapter adapter, final boolean nightMode) {
+											  final OsmandApplication app, final Activity ctx, View v,
+											  final LocationPointWrapper point,
+											  final ArrayAdapter adapter, final boolean nightMode,
+											  final boolean flat) {
 		if (v == null || v.findViewById(R.id.info_close) == null) {
 			v = ctx.getLayoutInflater().inflate(R.layout.waypoint_reached, null);
 		}
-		updatePointInfoView(app, ctx, v, point, true, nightMode);
+		updatePointInfoView(app, ctx, v, point, true, nightMode, edit);
+		View more = v.findViewById(R.id.all_points);
+		View move = v.findViewById(R.id.info_move);
 		View remove = v.findViewById(R.id.info_close);
 		if (!edit) {
 			remove.setVisibility(View.GONE);
+			move.setVisibility(View.GONE);
+			more.setVisibility(View.GONE);
+		} else if (point.type == WaypointHelper.TARGETS && !flat) {
+			if (((TargetPoint) point.point).start) {
+				remove.setVisibility(View.GONE);
+				move.setVisibility(View.GONE);
+				more.setVisibility(View.VISIBLE);
+				((ImageButton) more).setImageDrawable(app.getIconsCache().getContentIcon(
+						R.drawable.map_overflow_menu_white, !nightMode));
+				more.setOnClickListener(new View.OnClickListener() {
+					@Override
+					public void onClick(View view) {
+						//hideDashboard();
+						IntermediatePointsDialog.openIntermediatePointsDialog(ctx, app, true);
+					}
+				});
+			} else {
+				remove.setVisibility(View.GONE);
+				move.setVisibility(View.VISIBLE);
+				more.setVisibility(View.GONE);
+				((ImageView) move).setImageDrawable(app.getIconsCache().getContentIcon(
+						R.drawable.ic_flat_list_dark, !nightMode));
+			}
 		} else {
 			remove.setVisibility(View.VISIBLE);
+			move.setVisibility(View.GONE);
+			more.setVisibility(View.GONE);
 			((ImageButton) remove).setImageDrawable(app.getIconsCache().getContentIcon(
-					R.drawable.ic_action_gremove_dark, !nightMode));
+					R.drawable.ic_action_remove_dark, !nightMode));
 			remove.setOnClickListener(new View.OnClickListener() {
 				@Override
 				public void onClick(View view) {
+					ArrayList<LocationPointWrapper> arr = new ArrayList<>();
+					arr.add(point);
+					app.getWaypointHelper().removeVisibleLocationPoint(arr);
+
 					deletedPoints.add(point);
 					if (adapter != null) {
 						adapter.remove(point);
@@ -204,11 +274,38 @@ public void onClick(View view) {
 	protected View createItemForRadiusProximity(final FragmentActivity ctx, final int type, final int[] running,
 												final int position, final ArrayAdapter<Object> thisAdapter, boolean nightMode) {
 		View v;
-		IconsCache iconsCache = app.getIconsCache();
-		v = ctx.getLayoutInflater().inflate(R.layout.drawer_list_radius, null);
+		if (type == WaypointHelper.POI) {
+			v = ctx.getLayoutInflater().inflate(R.layout.drawer_list_radius_ex, null);
+			AndroidUtils.setTextPrimaryColor(mapActivity, (TextView) v.findViewById(R.id.titleEx), nightMode);
+			String descEx = waypointHelper.getPoiFilter() == null ? ctx.getString(R.string.poi) : waypointHelper
+					.getPoiFilter().getName();
+			((TextView) v.findViewById(R.id.title)).setText(ctx.getString(R.string.search_radius_proximity) + ":");
+			((TextView) v.findViewById(R.id.titleEx)).setText(ctx.getString(R.string.shared_string_type) + ":");
+			final TextView radiusEx = (TextView) v.findViewById(R.id.descriptionEx);
+			radiusEx.setText(descEx);
+			radiusEx.setOnClickListener(new View.OnClickListener() {
+				@Override
+				public void onClick(View view) {
+					running[0] = position;
+					thisAdapter.notifyDataSetInvalidated();
+					MapActivity map = (MapActivity) ctx;
+					final PoiUIFilter[] selected = new PoiUIFilter[1];
+					AlertDialog dlg = map.getMapLayers().selectPOIFilterLayer(map.getMapView(), selected);
+					dlg.setOnDismissListener(new OnDismissListener() {
+						@Override
+						public void onDismiss(DialogInterface dialog) {
+							enableType(running, thisAdapter, type, true);
+						}
+					});
+				}
+
+			});
+		} else {
+			v = ctx.getLayoutInflater().inflate(R.layout.drawer_list_radius, null);
+			((TextView) v.findViewById(R.id.title)).setText(ctx.getString(R.string.search_radius_proximity));
+		}
 		AndroidUtils.setTextPrimaryColor(mapActivity, (TextView) v.findViewById(R.id.title), nightMode);
 		final TextView radius = (TextView) v.findViewById(R.id.description);
-		((ImageView) v.findViewById(R.id.waypoint_icon)).setImageDrawable(iconsCache.getContentIcon(R.drawable.ic_poi_radius_dark, !nightMode));
 		radius.setText(OsmAndFormatter.getFormattedDistance(waypointHelper.getSearchDeviationRadius(type), app));
 		radius.setOnClickListener(new View.OnClickListener() {
 			@Override
@@ -249,26 +346,6 @@ public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
 		TextView tv = (TextView) v.findViewById(R.id.header_text);
 		AndroidUtils.setTextPrimaryColor(mapActivity, tv, nightMode);
 		tv.setText(getHeader(type, checked, ctx));
-		v.setOnClickListener(new View.OnClickListener() {
-			@Override
-			public void onClick(View view) {
-				if (type == WaypointHelper.POI && btn.isChecked()) {
-					running[0] = position;
-					thisAdapter.notifyDataSetInvalidated();
-					MapActivity map = (MapActivity) ctx;
-					final PoiUIFilter[] selected = new PoiUIFilter[1];
-					AlertDialog dlg = map.getMapLayers().selectPOIFilterLayer(map.getMapView(), selected);
-					dlg.setOnDismissListener(new OnDismissListener() {
-						@Override
-						public void onDismiss(DialogInterface dialog) {
-							if (selected != null) {
-								enableType(running, thisAdapter, type, true);
-							}
-						}
-					});
-				}
-			}
-		});
 		return v;
 	}
 
@@ -305,11 +382,7 @@ protected Void doInBackground(Void... params) {
 
 			protected void onPostExecute(Void result) {
 				running[0] = -1;
-				listAdapter.clear();
-				for (Object point : getPoints()) {
-					listAdapter.add(point);
-				}
-				listAdapter.notifyDataSetChanged();
+				reloadListAdapter(listAdapter);
 			}
 		}.execute((Void) null);
 	}
@@ -372,15 +445,23 @@ protected Void doInBackground(Void... params) {
 
 			protected void onPostExecute(Void result) {
 				running[0] = -1;
-				listAdapter.clear();
-				for (Object point : getPoints()) {
-					listAdapter.add(point);
-				}
-				listAdapter.notifyDataSetChanged();
+				reloadListAdapter(listAdapter);
 			}
 		}.execute((Void) null);
 	}
 
+	public void reloadListAdapter(ArrayAdapter<Object> listAdapter) {
+		listAdapter.clear();
+		List<Object> points = getPoints();
+		for (Object point : points) {
+			listAdapter.add(point);
+		}
+		if (listAdapter instanceof StableArrayAdapter) {
+			((StableArrayAdapter) listAdapter).updateObjects(points, getActivePoints(points));
+		}
+		listAdapter.notifyDataSetChanged();
+	}
+
 	protected String getHeader(int type, boolean checked, Activity ctx) {
 		String str = ctx.getString(R.string.waypoints);
 		switch (type) {
@@ -397,8 +478,7 @@ protected String getHeader(int type, boolean checked, Activity ctx) {
 				str = ctx.getString(R.string.waypoints);
 				break;
 			case WaypointHelper.POI:
-				str = waypointHelper.getPoiFilter() == null || !checked ? ctx.getString(R.string.poi) : waypointHelper
-						.getPoiFilter().getName();
+				str = ctx.getString(R.string.poi);
 				break;
 		}
 		return str;
@@ -416,7 +496,33 @@ protected List<Object> getPoints() {
 					points.add(true);
 				}
 				points.add(i);
-				if ((i == WaypointHelper.POI || i == WaypointHelper.FAVORITES || i == WaypointHelper.WAYPOINTS)
+				if (i == WaypointHelper.TARGETS && rc) {
+					TargetPoint start = app.getTargetPointsHelper().getPointToStart();
+					if (start == null) {
+						LatLon latLon;
+						Location loc = app.getLocationProvider().getLastKnownLocation();
+						if (loc != null) {
+							latLon = new LatLon(loc.getLatitude(), loc.getLongitude());
+						} else {
+							latLon = new LatLon(mapActivity.getMapView().getLatitude(),
+									mapActivity.getMapView().getLongitude());
+						}
+						start = TargetPoint.createStartPoint(latLon,
+								new PointDescription(PointDescription.POINT_TYPE_MY_LOCATION,
+										mapActivity.getString(R.string.shared_string_my_location)));
+
+					} else {
+						String oname = start.getOnlyName().length() > 0 ? start.getOnlyName()
+								: (mapActivity.getString(R.string.route_descr_map_location)
+								+ " " + mapActivity.getString(R.string.route_descr_lat_lon, start.getLatitude(), start.getLongitude()));
+
+						start = TargetPoint.createStartPoint(new LatLon(start.getLatitude(), start.getLongitude()),
+								new PointDescription(PointDescription.POINT_TYPE_LOCATION,
+										oname));
+					}
+					points.add(new LocationPointWrapper(null, WaypointHelper.TARGETS, start, 0f, 0));
+
+				} else if ((i == WaypointHelper.POI || i == WaypointHelper.FAVORITES || i == WaypointHelper.WAYPOINTS)
 						&& rc) {
 					if (waypointHelper.isTypeEnabled(i)) {
 						points.add(new RadiusItem(i));
@@ -435,6 +541,11 @@ public static void showOnMap(OsmandApplication app, Activity a, LocationPoint lo
 		if (!(a instanceof MapActivity)) {
 			return;
 		}
+		app.getSettings().setMapLocationToShow(locationPoint.getLatitude(), locationPoint.getLongitude(),
+				15, locationPoint.getPointDescription(a), false, locationPoint);
+		MapActivity.launchMapActivityMoveToTop(a);
+
+		/*
 		MapActivity ctx = (MapActivity) a;
 		AnimateDraggingMapThread thread = ctx.getMapView().getAnimatedDraggingThread();
 		int fZoom = ctx.getMapView().getZoom() < 15 ? 15 : ctx.getMapView().getZoom();
@@ -467,15 +578,9 @@ public static void showOnMap(OsmandApplication app, Activity a, LocationPoint lo
 						new LatLon(locationPoint.getLatitude(), locationPoint.getLongitude()),
 						locationPoint.getPointDescription(ctx),
 						locationPoint);
-/*
-				ctx.getMapLayers().getContextMenuLayer().setSelectedObject(locationPoint);
-				ctx.getMapLayers()
-						.getContextMenuLayer()
-						.setLocation(new LatLon(locationPoint.getLatitude(), locationPoint.getLongitude()),
-								PointDescription.getSimpleName(locationPoint, ctx));
-*/
 			}
 		}
+		*/
 	}
 
 }
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/helpers/WaypointHelper.java b/OsmAnd/src/net/osmand/plus/helpers/WaypointHelper.java
index 9ec641345df..ffe100a99c1 100644
--- a/OsmAnd/src/net/osmand/plus/helpers/WaypointHelper.java
+++ b/OsmAnd/src/net/osmand/plus/helpers/WaypointHelper.java
@@ -19,6 +19,8 @@
 import net.osmand.data.LocationPoint;
 import net.osmand.data.PointDescription;
 import net.osmand.osm.PoiType;
+import net.osmand.plus.ApplicationMode;
+import net.osmand.plus.IconsCache;
 import net.osmand.plus.OsmAndFormatter;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.OsmandSettings.MetricsConstants;
@@ -33,6 +35,7 @@
 import net.osmand.plus.routing.RouteCalculationResult;
 import net.osmand.plus.routing.VoiceRouter;
 import net.osmand.util.MapUtils;
+
 import android.content.Context;
 import android.graphics.drawable.Drawable;
 
@@ -48,7 +51,7 @@ public class WaypointHelper {
 	private static final int LONG_ANNOUNCE_RADIUS = 700;
 	private static final int SHORT_ANNOUNCE_RADIUS = 150;
 	private static final int ALARMS_ANNOUNCE_RADIUS = 150;
-	
+
 	// don't annoy users by lots of announcements
 	private static final int APPROACH_POI_LIMIT = 3;
 	private static final int ANNOUNCE_POI_LIMIT = 3;
@@ -62,26 +65,25 @@ public class WaypointHelper {
 	public static final int ALARMS = 4;
 	public static final int MAX = 5;
 	public static final int[] SEARCH_RADIUS_VALUES = {50, 100, 150, 250, 500, 1000, 1500};
-	
+
 	private List<List<LocationPointWrapper>> locationPoints = new ArrayList<List<LocationPointWrapper>>();
 	private ConcurrentHashMap<LocationPoint, Integer> locationPointsStates = new ConcurrentHashMap<LocationPoint, Integer>();
 	private TIntArrayList pointsProgress = new TIntArrayList();
 	private RouteCalculationResult route;
-	
+
 	private long announcedAlarmTime;
-	
-	
+
 
 	public WaypointHelper(OsmandApplication application) {
 		app = application;
 	}
-	
+
 
 	public List<LocationPointWrapper> getWaypoints(int type) {
-		if(type == TARGETS) {
+		if (type == TARGETS) {
 			return getTargets(new ArrayList<WaypointHelper.LocationPointWrapper>());
 		}
-		if(type >= locationPoints.size()) {
+		if (type >= locationPoints.size()) {
 			return Collections.emptyList();
 		}
 		return locationPoints.get(type);
@@ -98,21 +100,21 @@ public int getRouteDistance(LocationPointWrapper point) {
 	}
 
 	public void removeVisibleLocationPoint(LocationPointWrapper lp) {
-		if(lp.type < locationPoints.size()) {
+		if (lp.type < locationPoints.size()) {
 			locationPoints.get(lp.type).remove(lp);
 		}
 	}
-	
+
 	public void removeVisibleLocationPoint(List<LocationPointWrapper> points) {
 		List<TargetPoint> ps = app.getTargetPointsHelper().getIntermediatePointsWithTarget();
 		boolean[] checkedIntermediates = null;
 		for (LocationPointWrapper lp : points) {
 			if (lp.type == TARGETS) {
-				if(checkedIntermediates == null) {
+				if (checkedIntermediates == null) {
 					checkedIntermediates = new boolean[ps.size()];
 					Arrays.fill(checkedIntermediates, true);
 				}
-				if(((TargetPoint) lp.point).intermediate) {
+				if (((TargetPoint) lp.point).intermediate) {
 					checkedIntermediates[((TargetPoint) lp.point).index] = false;
 				} else {
 					checkedIntermediates[ps.size() - 1] = false;
@@ -121,33 +123,33 @@ public void removeVisibleLocationPoint(List<LocationPointWrapper> points) {
 				locationPoints.get(lp.type).remove(lp);
 			}
 		}
-		if(checkedIntermediates != null) {
+		if (checkedIntermediates != null) {
 			IntermediatePointsDialog.commitPointsRemoval(app, checkedIntermediates);
 		}
-		
+
 	}
-	
-	public LocationPointWrapper getMostImportantLocationPoint(List<LocationPointWrapper> list ) {
+
+	public LocationPointWrapper getMostImportantLocationPoint(List<LocationPointWrapper> list) {
 		//Location lastProjection = app.getRoutingHelper().getLastProjection();
-		if(list != null) {
+		if (list != null) {
 			list.clear();
 		}
 		LocationPointWrapper found = null;
 		for (int type = 0; type < locationPoints.size(); type++) {
-			if(type == ALARMS || type == TARGETS) {
+			if (type == ALARMS || type == TARGETS) {
 				continue;
 			}
 			int kIterator = pointsProgress.get(type);
 			List<LocationPointWrapper> lp = locationPoints.get(type);
-			while(kIterator < lp.size()) {
+			while (kIterator < lp.size()) {
 				LocationPointWrapper lwp = lp.get(kIterator);
-				if(lp.get(kIterator).routeIndex < route.getCurrentRoute()) {
+				if (lp.get(kIterator).routeIndex < route.getCurrentRoute()) {
 					// skip
 				} else {
-					if(route.getDistanceToPoint(lwp.routeIndex) <= LONG_ANNOUNCE_RADIUS ) {
-						if(found == null || found.routeIndex < lwp.routeIndex) {
+					if (route.getDistanceToPoint(lwp.routeIndex) <= LONG_ANNOUNCE_RADIUS) {
+						if (found == null || found.routeIndex < lwp.routeIndex) {
 							found = lwp;
-							if(list != null) {
+							if (list != null) {
 								list.add(lwp);
 							}
 						}
@@ -159,7 +161,7 @@ public LocationPointWrapper getMostImportantLocationPoint(List<LocationPointWrap
 		}
 		return found;
 	}
-	
+
 	public AlarmInfo getMostImportantAlarm(MetricsConstants mc, boolean showCameras) {
 		Location lastProjection = app.getRoutingHelper().getLastProjection();
 		float mxspeed = route.getCurrentMaxSpeed();
@@ -196,30 +198,30 @@ public AlarmInfo getMostImportantAlarm(MetricsConstants mc, boolean showCameras)
 		}
 		return mostImportant;
 	}
-	
+
 	public void enableWaypointType(int type, boolean enable) {
 		//An item will be displayed in the Waypoint list if either "Show..." or "Announce..." is selected for it in the Navigation settings
 		//Keep both "Show..." and "Announce..." Nav settings in sync when user changes what to display in the Waypoint list, as follows:
-		if(type == ALARMS) {
+		if (type == ALARMS) {
 			app.getSettings().SHOW_TRAFFIC_WARNINGS.set(enable);
 			app.getSettings().SPEAK_TRAFFIC_WARNINGS.set(enable);
 			app.getSettings().SHOW_PEDESTRIAN.set(enable);
 			app.getSettings().SPEAK_PEDESTRIAN.set(enable);
 			//But do not implicitly change speed_cam settings here because of legal restrictions in some countries, so Nav settings must prevail
-		} else if(type == POI) {
+		} else if (type == POI) {
 			app.getSettings().SHOW_NEARBY_POI.set(enable);
 			app.getSettings().ANNOUNCE_NEARBY_POI.set(enable);
-		} else if(type == FAVORITES) {
+		} else if (type == FAVORITES) {
 			app.getSettings().SHOW_NEARBY_FAVORITES.set(enable);
 			app.getSettings().ANNOUNCE_NEARBY_FAVORITES.set(enable);
-		} else if(type == WAYPOINTS) {
+		} else if (type == WAYPOINTS) {
 			app.getSettings().SHOW_WPT.set(enable);
 			app.getSettings().ANNOUNCE_WPT.set(enable);
 		}
 		recalculatePoints(route, type, locationPoints);
 	}
-	
-	public void recalculatePoints(int type){
+
+	public void recalculatePoints(int type) {
 		recalculatePoints(route, type, locationPoints);
 	}
 
@@ -227,17 +229,17 @@ public void recalculatePoints(int type){
 	public boolean isTypeConfigurable(int waypointType) {
 		return waypointType != TARGETS;
 	}
-	
+
 	public boolean isTypeVisible(int waypointType) {
 		boolean vis = app.getAppCustomization().isWaypointGroupVisible(waypointType, route);
-		if(!vis) {
+		if (!vis) {
 			return false;
 		}
 		return vis;
 	}
 
 	public boolean isTypeEnabled(int type) {
-		if(type == ALARMS) {
+		if (type == ALARMS) {
 			return showAlarms() || announceAlarms();
 		} else if (type == POI) {
 			//no SHOW item in nav settings, hence only query ANNOUNCE here (makes inital Waypoint dialogue consistent with nav settings)
@@ -254,12 +256,12 @@ public boolean isTypeEnabled(int type) {
 		}
 		return true;
 	}
-	
-	public AlarmInfo calculateMostImportantAlarm(RouteDataObject ro, Location loc, 
-			MetricsConstants mc, boolean showCameras) {
+
+	public AlarmInfo calculateMostImportantAlarm(RouteDataObject ro, Location loc,
+												 MetricsConstants mc, boolean showCameras) {
 		boolean direction = true;
-		if(loc.hasBearing()) {
-			double diff = MapUtils.alignAngleDifference(ro.directionRoute(0, true) -  
+		if (loc.hasBearing()) {
+			double diff = MapUtils.alignAngleDifference(ro.directionRoute(0, true) -
 					loc.getBearing() / (2 * Math.PI));
 			direction = Math.abs(diff) < Math.PI;
 		}
@@ -279,8 +281,8 @@ public AlarmInfo calculateMostImportantAlarm(RouteDataObject ro, Location loc,
 					AlarmInfo info = AlarmInfo.createAlarmInfo(typeRule, 0, loc);
 					if (info != null) {
 						if (info.getType() != AlarmInfoType.SPEED_CAMERA || showCameras) {
-							long ms = System.currentTimeMillis() ;
-							if(ms - announcedAlarmTime > 50 * 1000) {
+							long ms = System.currentTimeMillis();
+							if (ms - announcedAlarmTime > 50 * 1000) {
 								announcedAlarmTime = ms;
 								getVoiceRouter().announceAlarm(info.getType());
 							}
@@ -319,15 +321,15 @@ public void announceVisibleLocations() {
 				List<LocationPointWrapper> approachPoints = new ArrayList<LocationPointWrapper>();
 				List<LocationPointWrapper> announcePoints = new ArrayList<LocationPointWrapper>();
 				List<LocationPointWrapper> lp = locationPoints.get(type);
-				if(lp != null) {
+				if (lp != null) {
 					int kIterator = pointsProgress.get(type);
-					while(kIterator < lp.size() && lp.get(kIterator).routeIndex < currentRoute) {
+					while (kIterator < lp.size() && lp.get(kIterator).routeIndex < currentRoute) {
 						kIterator++;
 					}
 					pointsProgress.set(type, kIterator);
-					while(kIterator < lp.size()) {
+					while (kIterator < lp.size()) {
 						LocationPointWrapper lwp = lp.get(kIterator);
-						if(route.getDistanceToPoint(lwp.routeIndex) > LONG_ANNOUNCE_RADIUS * 2){
+						if (route.getDistanceToPoint(lwp.routeIndex) > LONG_ANNOUNCE_RADIUS * 2) {
 							break;
 						}
 						LocationPoint point = lwp.point;
@@ -350,7 +352,7 @@ && getVoiceRouter().isDistanceLess(lastKnownLocation.getSpeed(), d1, ALARMS_ANNO
 						kIterator++;
 					}
 					if (!announcePoints.isEmpty()) {
-						if(announcePoints.size() > ANNOUNCE_POI_LIMIT) {
+						if (announcePoints.size() > ANNOUNCE_POI_LIMIT) {
 							announcePoints = announcePoints.subList(0, ANNOUNCE_POI_LIMIT);
 						}
 						if (type == WAYPOINTS) {
@@ -364,7 +366,7 @@ && getVoiceRouter().isDistanceLess(lastKnownLocation.getSpeed(), d1, ALARMS_ANNO
 						}
 					}
 					if (!approachPoints.isEmpty()) {
-						if(approachPoints.size() > APPROACH_POI_LIMIT) {
+						if (approachPoints.size() > APPROACH_POI_LIMIT) {
 							approachPoints = approachPoints.subList(0, APPROACH_POI_LIMIT);
 						}
 						if (type == WAYPOINTS) {
@@ -373,10 +375,10 @@ && getVoiceRouter().isDistanceLess(lastKnownLocation.getSpeed(), d1, ALARMS_ANNO
 							getVoiceRouter().approachPoi(lastKnownLocation, approachPoints);
 						} else if (type == ALARMS) {
 							EnumSet<AlarmInfoType> ait = EnumSet.noneOf(AlarmInfoType.class);
-							for(LocationPointWrapper pw : approachPoints) {
+							for (LocationPointWrapper pw : approachPoints) {
 								ait.add(((AlarmInfo) pw.point).getType());
 							}
-							for(AlarmInfoType t : ait) {
+							for (AlarmInfoType t : ait) {
 								app.getRoutingHelper().getVoiceRouter().announceAlarm(t);
 							}
 						} else if (type == FAVORITES) {
@@ -392,11 +394,11 @@ && getVoiceRouter().isDistanceLess(lastKnownLocation.getSpeed(), d1, ALARMS_ANNO
 	protected VoiceRouter getVoiceRouter() {
 		return app.getRoutingHelper().getVoiceRouter();
 	}
-	
+
 	public boolean isRouteCalculated() {
 		return route != null && !route.isEmpty();
 	}
-	
+
 	public List<LocationPointWrapper> getAllPoints() {
 		List<LocationPointWrapper> points = new ArrayList<WaypointHelper.LocationPointWrapper>();
 		List<List<LocationPointWrapper>> local = locationPoints;
@@ -418,8 +420,8 @@ protected List<LocationPointWrapper> getTargets(List<LocationPointWrapper> point
 		for (int k = 0; k < wts.size(); k++) {
 			final int index = wts.size() - k - 1;
 			TargetPoint tp = wts.get(index);
-			int routeIndex ;
-			if(route == null) {
+			int routeIndex;
+			if (route == null) {
 				routeIndex = k == 0 ? Integer.MAX_VALUE : index;
 			} else {
 				routeIndex = k == 0 ? route.getImmutableAllLocations().size() - 1 : route.getIndexOfIntermediate(k - 1);
@@ -435,7 +437,7 @@ public void clearAllVisiblePoints() {
 		this.locationPoints = new ArrayList<List<LocationPointWrapper>>();
 	}
 
-	
+
 	public void setNewRoute(RouteCalculationResult route) {
 		List<List<LocationPointWrapper>> locationPoints = new ArrayList<List<LocationPointWrapper>>();
 		recalculatePoints(route, -1, locationPoints);
@@ -459,7 +461,7 @@ protected void recalculatePoints(RouteCalculationResult route, int type, List<Li
 					sortList(array);
 				}
 			}
-			if((type == ALARMS || all)) {
+			if ((type == ALARMS || all)) {
 				final List<LocationPointWrapper> array = clearAndGetArray(locationPoints, ALARMS);
 				calculateAlarms(route, array);
 				sortList(array);
@@ -473,26 +475,26 @@ protected void recalculatePoints(RouteCalculationResult route, int type, List<Li
 					sortList(array);
 				}
 			}
-			if((type == POI || all)) {
+			if ((type == POI || all)) {
 				final List<LocationPointWrapper> array = clearAndGetArray(locationPoints, POI);
-				if(showPOI()) {
+				if (showPOI()) {
 					calculatePoi(route, array);
 					sortList(array);
 				}
 			}
 		}
 	}
-	
+
 	private float dist(LocationPoint l, List<Location> locations, int[] ind) {
 		float dist = Float.POSITIVE_INFINITY;
 		// Special iterations because points stored by pairs!
-		for (int i = 1; i < locations.size(); i ++) {
+		for (int i = 1; i < locations.size(); i++) {
 			final double ld = MapUtils.getOrthogonalDistance(
-					l.getLatitude(), l.getLongitude(), 
-					locations.get(i - 1).getLatitude(), locations.get(i - 1).getLongitude(), 
+					l.getLatitude(), l.getLongitude(),
+					locations.get(i - 1).getLatitude(), locations.get(i - 1).getLongitude(),
 					locations.get(i).getLatitude(), locations.get(i).getLongitude());
-			if(ld < dist){
-				if(ind != null) {
+			if (ld < dist) {
+				if (ind != null) {
 					ind[0] = i;
 				}
 				dist = (float) ld;
@@ -517,7 +519,7 @@ protected void sortList(List<LocationPointWrapper> list) {
 			public int compare(LocationPointWrapper olhs, LocationPointWrapper orhs) {
 				int lhs = olhs.routeIndex;
 				int rhs = orhs.routeIndex;
-				if(lhs == rhs) {
+				if (lhs == rhs) {
 					return Float.compare(olhs.deviationDistance, orhs.deviationDistance);
 				}
 				return lhs < rhs ? -1 : 1;
@@ -545,31 +547,30 @@ protected void calculatePoi(RouteCalculationResult route, List<LocationPointWrap
 	}
 
 
-
 	private void calculateAlarms(RouteCalculationResult route, List<LocationPointWrapper> array) {
-		for(AlarmInfo i : route.getAlarmInfo()) {
-			if(i.getType() == AlarmInfoType.SPEED_CAMERA) {
-				if(app.getSettings().SHOW_CAMERAS.get() || app.getSettings().SPEAK_SPEED_CAMERA.get()){
-					LocationPointWrapper lw = new LocationPointWrapper(route, ALARMS, i, 0, i.getLocationIndex());	
+		for (AlarmInfo i : route.getAlarmInfo()) {
+			if (i.getType() == AlarmInfoType.SPEED_CAMERA) {
+				if (app.getSettings().SHOW_CAMERAS.get() || app.getSettings().SPEAK_SPEED_CAMERA.get()) {
+					LocationPointWrapper lw = new LocationPointWrapper(route, ALARMS, i, 0, i.getLocationIndex());
 					lw.setAnnounce(app.getSettings().SPEAK_SPEED_CAMERA.get());
 					array.add(lw);
 				}
 			} else {
-				if(app.getSettings().SHOW_TRAFFIC_WARNINGS.get() || app.getSettings().SPEAK_TRAFFIC_WARNINGS.get()){
-					LocationPointWrapper lw = new LocationPointWrapper(route, ALARMS, i, 0, i.getLocationIndex());	
+				if (app.getSettings().SHOW_TRAFFIC_WARNINGS.get() || app.getSettings().SPEAK_TRAFFIC_WARNINGS.get()) {
+					LocationPointWrapper lw = new LocationPointWrapper(route, ALARMS, i, 0, i.getLocationIndex());
 					lw.setAnnounce(app.getSettings().SPEAK_TRAFFIC_WARNINGS.get());
 					array.add(lw);
 				}
 			}
-			
+
 		}
-		
+
 	}
 
 
 	private List<LocationPointWrapper> clearAndGetArray(List<List<LocationPointWrapper>> array,
-			int ind) {
-		while(array.size() <= ind) {
+														int ind) {
+		while (array.size() <= ind) {
 			array.add(new ArrayList<WaypointHelper.LocationPointWrapper>());
 		}
 		array.get(ind).clear();
@@ -578,13 +579,13 @@ private List<LocationPointWrapper> clearAndGetArray(List<List<LocationPointWrapp
 
 
 	private void findLocationPoints(RouteCalculationResult rt, int type, List<LocationPointWrapper> locationPoints,
-			List<? extends LocationPoint> points, boolean announce) {
+									List<? extends LocationPoint> points, boolean announce) {
 		List<Location> immutableAllLocations = rt.getImmutableAllLocations();
 		int[] ind = new int[1];
-		for(LocationPoint p : points) {
+		for (LocationPoint p : points) {
 			float dist = dist(p, immutableAllLocations, ind);
 			int rad = getSearchDeviationRadius(type);
-			if(dist <= rad) {
+			if (dist <= rad) {
 				LocationPointWrapper lpw = new LocationPointWrapper(rt, type, p, dist, ind[0]);
 				lpw.setAnnounce(announce);
 				locationPoints.add(lpw);
@@ -597,10 +598,11 @@ private void findLocationPoints(RouteCalculationResult rt, int type, List<Locati
 	public PoiUIFilter getPoiFilter() {
 		return app.getPoiFilters().getFilterById(app.getSettings().SELECTED_POI_FILTER_FOR_MAP.get());
 	}
+
 	public boolean showPOI() {
 		return app.getSettings().SHOW_NEARBY_POI.get();
 	}
-	
+
 	public boolean announcePOI() {
 		return app.getSettings().ANNOUNCE_NEARBY_POI.get();
 	}
@@ -608,15 +610,15 @@ public boolean announcePOI() {
 	public boolean showGPXWaypoints() {
 		return app.getSettings().SHOW_WPT.get();
 	}
-	
+
 	public boolean announceGPXWaypoints() {
 		return app.getSettings().ANNOUNCE_WPT.get();
 	}
-	
+
 	public boolean showFavorites() {
 		return app.getSettings().SHOW_NEARBY_FAVORITES.get();
 	}
-	
+
 	public boolean announceFavorites() {
 		return app.getSettings().ANNOUNCE_NEARBY_FAVORITES.get();
 	}
@@ -637,10 +639,10 @@ public static class LocationPointWrapper {
 		boolean announce = true;
 		RouteCalculationResult route;
 		int type;
-		
+
 		public LocationPointWrapper() {
 		}
-		
+
 		public LocationPointWrapper(RouteCalculationResult rt, int type, LocationPoint point, float deviationDistance, int routeIndex) {
 			this.route = rt;
 			this.type = type;
@@ -648,11 +650,11 @@ public LocationPointWrapper(RouteCalculationResult rt, int type, LocationPoint p
 			this.deviationDistance = deviationDistance;
 			this.routeIndex = routeIndex;
 		}
-		
+
 		public void setAnnounce(boolean announce) {
 			this.announce = announce;
 		}
-		
+
 		public float getDeviationDistance() {
 			return deviationDistance;
 		}
@@ -662,10 +664,8 @@ public LocationPoint getPoint() {
 		}
 
 
-		
-
-		public Drawable getDrawable(Context uiCtx, OsmandApplication app) {
-			if(type == POI) {
+		public Drawable getDrawable(Context uiCtx, OsmandApplication app, boolean nightMode) {
+			if (type == POI) {
 				Amenity amenity = ((AmenityLocationPoint) point).a;
 				PoiType st = amenity.getType().getPoiTypeByKeyName(amenity.getSubType());
 				if (st != null) {
@@ -678,36 +678,53 @@ public Drawable getDrawable(Context uiCtx, OsmandApplication app) {
 					}
 				}
 				return null;
-			} else if(type == TARGETS) {
-				int i = !((TargetPoint)point).intermediate? R.drawable.list_destination :
-					R.drawable.list_intermediate;
-				return uiCtx.getResources().getDrawable(i);
-			} else if(type == FAVORITES || type == WAYPOINTS) {
+
+			} else if (type == TARGETS) {
+				IconsCache iconsCache = app.getIconsCache();
+				if (((TargetPoint) point).start) {
+					ApplicationMode appMode = app.getSettings().getApplicationMode();
+					return uiCtx.getResources().getDrawable(appMode.getResourceLocationDay());
+				} else if (((TargetPoint) point).intermediate) {
+					if (!nightMode) {
+						return iconsCache.getIcon(R.drawable.widget_intermediate_day, 0, 0f);
+					} else {
+						return iconsCache.getIcon(R.drawable.widget_intermediate_night, 0, 0f);
+					}
+				} else {
+					if (!nightMode) {
+						return iconsCache.getIcon(R.drawable.widget_target_day, 0, 0f);
+					} else {
+						return iconsCache.getIcon(R.drawable.widget_target_night, 0, 0f);
+					}
+				}
+
+			} else if (type == FAVORITES || type == WAYPOINTS) {
 				return FavoriteImageDrawable.getOrCreate(uiCtx, point.getColor(), false);
-			} else if(type == ALARMS) {
+
+			} else if (type == ALARMS) {
 				//assign alarm list icons manually for now
-				if(((AlarmInfo) point).getType().toString() == "SPEED_CAMERA") {
+				if (((AlarmInfo) point).getType().toString().equals("SPEED_CAMERA")) {
 					return uiCtx.getResources().getDrawable(R.drawable.mx_highway_speed_camera);
-				} else if(((AlarmInfo) point).getType().toString() == "BORDER_CONTROL") {
+				} else if (((AlarmInfo) point).getType().toString().equals("BORDER_CONTROL")) {
 					return uiCtx.getResources().getDrawable(R.drawable.mx_barrier_border_control);
-				} else	if(((AlarmInfo) point).getType().toString() == "RAILWAY") {
-					if(app.getSettings().DRIVING_REGION.get().americanSigns){
+				} else if (((AlarmInfo) point).getType().toString().equals("RAILWAY")) {
+					if (app.getSettings().DRIVING_REGION.get().americanSigns) {
 						return uiCtx.getResources().getDrawable(R.drawable.list_warnings_railways_us);
 					} else {
 						return uiCtx.getResources().getDrawable(R.drawable.list_warnings_railways);
 					}
-				} else if(((AlarmInfo) point).getType().toString() == "TRAFFIC_CALMING") {
-					if(app.getSettings().DRIVING_REGION.get().americanSigns){
+				} else if (((AlarmInfo) point).getType().toString().equals("TRAFFIC_CALMING")) {
+					if (app.getSettings().DRIVING_REGION.get().americanSigns) {
 						return uiCtx.getResources().getDrawable(R.drawable.list_warnings_traffic_calming_us);
 					} else {
 						return uiCtx.getResources().getDrawable(R.drawable.list_warnings_traffic_calming);
 					}
-				} else if(((AlarmInfo) point).getType().toString() == "TOLL_BOOTH") {
+				} else if (((AlarmInfo) point).getType().toString().equals("TOLL_BOOTH")) {
 					return uiCtx.getResources().getDrawable(R.drawable.mx_toll_booth);
-				} else if(((AlarmInfo) point).getType().toString() == "STOP") {
+				} else if (((AlarmInfo) point).getType().toString().equals("STOP")) {
 					return uiCtx.getResources().getDrawable(R.drawable.list_stop);
-				} else if(((AlarmInfo) point).getType().toString() == "PEDESTRIAN") {
-					if(app.getSettings().DRIVING_REGION.get().americanSigns){
+				} else if (((AlarmInfo) point).getType().toString().equals("PEDESTRIAN")) {
+					if (app.getSettings().DRIVING_REGION.get().americanSigns) {
 						return uiCtx.getResources().getDrawable(R.drawable.list_warnings_pedestrian_us);
 					} else {
 						return uiCtx.getResources().getDrawable(R.drawable.list_warnings_pedestrian);
@@ -715,15 +732,17 @@ public Drawable getDrawable(Context uiCtx, OsmandApplication app) {
 				} else {
 					return null;
 				}
+
 			} else {
 				return null;
 			}
 		}
-		
+
 		@Override
 		public int hashCode() {
 			return ((point == null) ? 0 : point.hashCode());
 		}
+
 		@Override
 		public boolean equals(Object obj) {
 			if (this == obj)
@@ -740,15 +759,15 @@ public boolean equals(Object obj) {
 				return false;
 			return true;
 		}
-		
+
 	}
 
-	public int getSearchDeviationRadius(int type){
+	public int getSearchDeviationRadius(int type) {
 		return type == POI ? poiSearchDeviationRadius : searchDeviationRadius;
 	}
 
-	public void setSearchDeviationRadius(int type, int radius){
-		if(type == POI) {
+	public void setSearchDeviationRadius(int type, int radius) {
+		if (type == POI) {
 			this.poiSearchDeviationRadius = radius;
 		} else {
 			this.searchDeviationRadius = radius;
@@ -758,7 +777,7 @@ public void setSearchDeviationRadius(int type, int radius){
 	private class AmenityLocationPoint implements LocationPoint {
 
 		Amenity a;
-		
+
 		public AmenityLocationPoint(Amenity a) {
 			this.a = a;
 		}
@@ -773,10 +792,10 @@ public double getLongitude() {
 			return a.getLocation().getLongitude();
 		}
 
-		
+
 		@Override
 		public PointDescription getPointDescription(Context ctx) {
-			return new PointDescription(PointDescription.POINT_TYPE_POI, 
+			return new PointDescription(PointDescription.POINT_TYPE_POI,
 					OsmAndFormatter.getPoiStringWithoutType(a, app.getSettings().MAP_PREFERRED_LOCALE.get()));
 		}
 
diff --git a/OsmAnd/src/net/osmand/plus/mapcontextmenu/MenuTitleController.java b/OsmAnd/src/net/osmand/plus/mapcontextmenu/MenuTitleController.java
index b6bef830dc4..6c9ad911492 100644
--- a/OsmAnd/src/net/osmand/plus/mapcontextmenu/MenuTitleController.java
+++ b/OsmAnd/src/net/osmand/plus/mapcontextmenu/MenuTitleController.java
@@ -144,7 +144,7 @@ protected void acquireStreetName() {
 				public void run() {
 					acquireStreetName();
 				}
-			}, 50);
+			}, 100);
 			return;
 		}
 
diff --git a/OsmAnd/src/net/osmand/plus/mapcontextmenu/other/MapRouteInfoMenu.java b/OsmAnd/src/net/osmand/plus/mapcontextmenu/other/MapRouteInfoMenu.java
index 249104eee49..5f60c3ac6b4 100644
--- a/OsmAnd/src/net/osmand/plus/mapcontextmenu/other/MapRouteInfoMenu.java
+++ b/OsmAnd/src/net/osmand/plus/mapcontextmenu/other/MapRouteInfoMenu.java
@@ -65,6 +65,7 @@ public class MapRouteInfoMenu implements IRouteInformationListener {
 	private boolean selectFromMapForTarget;
 
 	private boolean showMenu = false;
+	private boolean visible;
 	private MapActivity mapActivity;
 	private MapControlsLayer mapControlsLayer;
 	public static final String TARGET_SELECT = "TARGET_SELECT";
@@ -371,7 +372,7 @@ public static int getDirectionInfo() {
 	}
 
 	public boolean isVisible() {
-		return findMenuFragment() != null;
+		return visible;
 	}
 
 	public WeakReference<MapRouteInfoMenuFragment> findMenuFragment() {
@@ -598,29 +599,34 @@ public void routeWasCancelled() {
 	}
 
 	public void onDismiss() {
+		visible = false;
 		mapActivity.getMapView().setMapPositionX(0);
 		mapActivity.getMapView().refreshMap();
 		AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin), false);
 		AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_right_widgets_panel), true);
-		AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_left_widgets_panel), true);
 		if (switched) {
 			mapControlsLayer.switchToRouteFollowingLayout();
 		}
 	}
 
 	public void show() {
+		visible = true;
 		switched = mapControlsLayer.switchToRoutePlanningLayout();
+		boolean refreshMap = !switched;
 		boolean portrait = AndroidUiHelper.isOrientationPortrait(mapActivity);
 		if (!portrait) {
 			mapActivity.getMapView().setMapPositionX(1);
-			mapActivity.getMapView().refreshMap();
+			refreshMap = true;
+		}
+
+		if (refreshMap) {
+			mapActivity.refreshMap();
 		}
 
 		MapRouteInfoMenuFragment.showInstance(mapActivity);
 
 		if (!AndroidUiHelper.isXLargeDevice(mapActivity)) {
 			AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_right_widgets_panel), false);
-			AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_left_widgets_panel), false);
 		}
 		if (!portrait) {
 			AndroidUiHelper.updateVisibility(mapActivity.findViewById(R.id.map_route_land_left_margin), true);
@@ -631,6 +637,8 @@ public void hide() {
 		WeakReference<MapRouteInfoMenuFragment> fragmentRef = findMenuFragment();
 		if (fragmentRef != null) {
 			fragmentRef.get().dismiss();
+		} else {
+			visible = false;
 		}
 	}
 
@@ -673,7 +681,8 @@ public View getDropDownView(int position, View convertView, ViewGroup parent) {
 			label.setText(row.text);
 			Drawable icon = mapActivity.getMyApplication().getIconsCache().getContentIcon(row.iconId);
 			label.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
-			label.setCompoundDrawablePadding(dpToPx(12f));
+			label.setCompoundDrawablePadding(dpToPx(16f));
+			label.setPadding(dpToPx((16f)), 0, 0, 0);
 
 			return label;
 		}
diff --git a/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java b/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
index 6e3e9d83703..7f79fb4765c 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
@@ -609,20 +609,21 @@ private void setNewRoute(RouteCalculationResult prevRoute, final RouteCalculatio
 				voiceRouter.newRouteIsCalculated(newRoute);
 			}
 		}
-		
+		app.getWaypointHelper().setNewRoute(res);
+
 		app.runInUIThread(new Runnable() {
 			@Override
 			public void run() {
 				ValueHolder<Boolean> showToast = new ValueHolder<Boolean>();
 				showToast.value = true;
 				Iterator<WeakReference<IRouteInformationListener>> it = listeners.iterator();
-				while(it.hasNext()) {
+				while (it.hasNext()) {
 					WeakReference<IRouteInformationListener> ref = it.next();
 					IRouteInformationListener l = ref.get();
-					if(l == null) {
+					if (l == null) {
 						it.remove();
 					} else {
-						l.newRouteIsCalculated(newRoute, showToast);	
+						l.newRouteIsCalculated(newRoute, showToast);
 					}
 				}
 				if (showToast.value) {
@@ -635,9 +636,6 @@ public void run() {
 				}
 			}
 		});
-
-		
-		app.getWaypointHelper().setNewRoute(res);
 	}
 	
 	public int getLeftDistance(){
diff --git a/OsmAnd/src/net/osmand/plus/views/MapControlsLayer.java b/OsmAnd/src/net/osmand/plus/views/MapControlsLayer.java
index e57ec18f570..bf817066273 100644
--- a/OsmAnd/src/net/osmand/plus/views/MapControlsLayer.java
+++ b/OsmAnd/src/net/osmand/plus/views/MapControlsLayer.java
@@ -492,7 +492,7 @@ private void updateControls(@NonNull RotatedTileBox tileBox, DrawSettings nightM
 				((System.currentTimeMillis() - touchEvent < TIMEOUT_TO_SHOW_BUTTONS) && routeFollowingMode);
 		updateMyLocation(rh, dialogOpened);
 		boolean showButtons = (showRouteCalculationControls || !routeFollowingMode);
-		routePlanningBtn.setIconResId(routeFollowingMode ? R.drawable.ic_action_gabout_dark : R.drawable.map_directions);
+		//routePlanningBtn.setIconResId(routeFollowingMode ? R.drawable.ic_action_gabout_dark : R.drawable.map_directions);
 		if (routePlanningMode || routeFollowingMode) {
 			routePlanningBtn.setIconResId(R.drawable.map_start_navigation);
 			routePlanningBtn.setIconColorId(R.color.color_myloc_distance);
@@ -534,7 +534,7 @@ private void updateControls(@NonNull RotatedTileBox tileBox, DrawSettings nightM
 		updateCompass(isNight);
 
 		for (MapHudButton mc : controls) {
-			mc.update(mapActivity.getMyApplication(), nightMode != null && nightMode.isNightMode());
+			mc.update(mapActivity.getMyApplication(), isNight);
 		}
 	}
 
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java
new file mode 100644
index 00000000000..068beac3e2e
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java
@@ -0,0 +1,689 @@
+package net.osmand.plus.views.controls;
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ObjectAnimator;
+import android.animation.TypeEvaluator;
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Rect;
+import android.graphics.drawable.BitmapDrawable;
+import android.support.annotation.NonNull;
+import android.util.AttributeSet;
+import android.util.DisplayMetrics;
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewTreeObserver;
+import android.widget.AbsListView;
+import android.widget.HeaderViewListAdapter;
+import android.widget.ListAdapter;
+
+import com.github.ksoichiro.android.observablescrollview.ObservableListView;
+
+import java.util.List;
+
+public class DynamicListView extends ObservableListView {
+
+	public final String TAG_DRAG_ICON = "DragIcon";
+	protected final int SMOOTH_SCROLL_AMOUNT_AT_EDGE = 15;
+	protected final int MOVE_DURATION = 150;
+
+	protected List<Object> mItemsList;
+	protected List<Object> mActiveItemsList;
+
+	private DynamicListViewCallbacks dCallbacks;
+
+	private int mLastEventY = -1;
+
+	protected int mDownY = -1;
+	protected int mDownX = -1;
+
+	private int mTotalOffset = 0;
+
+	private boolean mCellIsMobile = false;
+	private boolean mIsMobileScrolling = false;
+	private int mSmoothScrollAmountAtEdge = 0;
+	private boolean itemsSwapped = false;
+
+	protected final int INVALID_ID = -1;
+	private long mAboveItemId = INVALID_ID;
+	private long mMobileItemId = INVALID_ID;
+	private long mBelowItemId = INVALID_ID;
+
+	private BitmapDrawable mHoverCell;
+	private Rect mHoverCellCurrentBounds;
+	private Rect mHoverCellOriginalBounds;
+
+	protected final int INVALID_POINTER_ID = -1;
+	private int mActivePointerId = INVALID_POINTER_ID;
+
+	private boolean mIsWaitingForScrollFinish = false;
+	private int mScrollState = OnScrollListener.SCROLL_STATE_IDLE;
+
+	public DynamicListView(Context context) {
+		super(context);
+		init(context);
+	}
+
+	public DynamicListView(Context context, AttributeSet attrs, int defStyle) {
+		super(context, attrs, defStyle);
+		init(context);
+	}
+
+	public DynamicListView(Context context, AttributeSet attrs) {
+		super(context, attrs);
+		init(context);
+	}
+
+	public void init(Context context) {
+		setOnScrollListener(mScrollListener);
+		DisplayMetrics metrics = context.getResources().getDisplayMetrics();
+		mSmoothScrollAmountAtEdge = (int) (SMOOTH_SCROLL_AMOUNT_AT_EDGE / metrics.density);
+	}
+
+	public void setDynamicListViewCallbacks(DynamicListViewCallbacks callbacks) {
+		dCallbacks = callbacks;
+	}
+
+	/**
+	 * Creates the hover cell with the appropriate bitmap and of appropriate
+	 * size. The hover cell's BitmapDrawable is drawn on top of the bitmap every
+	 * single time an invalidate call is made.
+	 */
+	private BitmapDrawable getAndAddHoverView(View v) {
+
+		int w = v.getWidth();
+		int h = v.getHeight();
+		int top = v.getTop();
+		int left = v.getLeft();
+
+		Bitmap b = getBitmapFromView(v);
+
+		BitmapDrawable drawable = new BitmapDrawable(getResources(), b);
+
+		mHoverCellOriginalBounds = new Rect(left, top, left + w, top + h);
+		mHoverCellCurrentBounds = new Rect(mHoverCellOriginalBounds);
+
+		drawable.setBounds(mHoverCellCurrentBounds);
+
+		return drawable;
+	}
+
+	/**
+	 * Returns a bitmap showing a screenshot of the view passed in.
+	 */
+	private Bitmap getBitmapFromView(View v) {
+		Bitmap bitmap = Bitmap.createBitmap(v.getWidth(), v.getHeight(), Bitmap.Config.ARGB_8888);
+		Canvas canvas = new Canvas(bitmap);
+		v.draw(canvas);
+
+		Bitmap bitmapOut = Bitmap.createBitmap(v.getWidth(), v.getHeight(), Bitmap.Config.ARGB_8888);
+		Canvas canvasOut = new Canvas(bitmapOut);
+		canvasOut.drawColor(Color.TRANSPARENT);
+		Paint p = new Paint();
+		p.setAlpha(200);
+		canvasOut.drawBitmap(bitmap, 0, 0, p);
+
+		return bitmapOut;
+	}
+
+	public StableArrayAdapter getStableAdapter() {
+		ListAdapter listAdapter = getAdapter();
+		if (listAdapter instanceof HeaderViewListAdapter) {
+			listAdapter = ((HeaderViewListAdapter) listAdapter).getWrappedAdapter();
+		}
+		if (listAdapter instanceof StableArrayAdapter) {
+			return (StableArrayAdapter) listAdapter;
+		}
+		return null;
+	}
+
+	/**
+	 * Stores a reference to the views above and below the item currently
+	 * corresponding to the hover cell. It is important to note that if this
+	 * item is either at the top or bottom of the list, mAboveItemId or mBelowItemId
+	 * may be invalid.
+	 */
+	private void updateNeighborViewsForID(long itemID) {
+		ListAdapter adapter = getAdapter();
+		int position = getPositionForID(itemID);
+		int pos = position;
+		mAboveItemId = INVALID_ID;
+		while (mAboveItemId == INVALID_ID && pos > 0) {
+			pos--;
+			mAboveItemId = adapter.getItemId(pos);
+			if (mAboveItemId != INVALID_ID) {
+				Object obj = adapter.getItem(pos);
+				if (mActiveItemsList == null || !mActiveItemsList.contains(obj)) {
+					mAboveItemId = INVALID_ID;
+				}
+			}
+		}
+		pos = position;
+		mBelowItemId = INVALID_ID;
+		while (mBelowItemId == INVALID_ID && pos < mItemsList.size()) {
+			pos++;
+			mBelowItemId = adapter.getItemId(pos);
+			if (mBelowItemId != INVALID_ID) {
+				Object obj = adapter.getItem(pos);
+				if (mActiveItemsList == null || !mActiveItemsList.contains(obj)) {
+					mBelowItemId = INVALID_ID;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Retrieves the view in the list corresponding to itemID
+	 */
+	public View getViewForID(long itemID) {
+		if (itemID != INVALID_ID) {
+			int firstVisiblePosition = getFirstVisiblePosition();
+			ListAdapter adapter = getAdapter();
+			for (int i = 0; i < getChildCount(); i++) {
+				View v = getChildAt(i);
+				int position = firstVisiblePosition + i;
+				long id = adapter.getItemId(position);
+				if (id == itemID) {
+					return v;
+				}
+			}
+		}
+		return null;
+	}
+
+	public void setAllVisible() {
+		for (int i = 0; i < getChildCount(); i++) {
+			View v = getChildAt(i);
+			if (v != null && v.getVisibility() != VISIBLE) {
+				v.setVisibility(VISIBLE);
+			}
+		}
+	}
+
+	/**
+	 * Retrieves the position in the list corresponding to itemID
+	 */
+	public int getPositionForID(long itemID) {
+		View v = getViewForID(itemID);
+		if (v == null) {
+			return -1;
+		} else {
+			return getPositionForView(v);
+		}
+	}
+
+	/**
+	 * dispatchDraw gets invoked when all the child views are about to be drawn.
+	 * By overriding this method, the hover cell (BitmapDrawable) can be drawn
+	 * over the listview's items whenever the listview is redrawn.
+	 */
+	@Override
+	protected void dispatchDraw(@NonNull Canvas canvas) {
+		super.dispatchDraw(canvas);
+		if (mHoverCell != null) {
+			mHoverCell.draw(canvas);
+		}
+	}
+
+	@Override
+	public boolean onTouchEvent(@NonNull MotionEvent event) {
+
+		switch (event.getAction() & MotionEvent.ACTION_MASK) {
+			case MotionEvent.ACTION_DOWN:
+				if (!mCellIsMobile && mHoverCell == null) {
+					mDownX = (int) event.getX();
+					mDownY = (int) event.getY();
+					mActivePointerId = event.getPointerId(0);
+
+					// Find the view that the user pressed their finger down on.
+					View v = findViewAtPositionWithTag(getRootView(), (int) event.getRawX(), (int) event.getRawY(), TAG_DRAG_ICON);
+
+					// If the view contains a tag set to "DragIcon", it means that the user wants to
+					// reorder the list item.
+					if ((v != null) && (v.getTag() != null) && (v.getTag().equals(TAG_DRAG_ICON))) {
+						mTotalOffset = 0;
+
+						int position = pointToPosition(mDownX, mDownY);
+						if (position != INVALID_POSITION) {
+							Object item = getAdapter().getItem(position);
+							if (mActiveItemsList == null || mActiveItemsList.contains(item)) {
+
+								int itemNum = position - getFirstVisiblePosition();
+								itemsSwapped = false;
+
+								View selectedView = getChildAt(itemNum);
+								mMobileItemId = getAdapter().getItemId(position);
+								mHoverCell = getAndAddHoverView(selectedView);
+								selectedView.setVisibility(INVISIBLE);
+
+								mCellIsMobile = true;
+
+								updateNeighborViewsForID(mMobileItemId);
+							}
+						}
+					}
+				}
+				break;
+
+			case MotionEvent.ACTION_MOVE:
+				if (mActivePointerId == INVALID_POINTER_ID) {
+					break;
+				}
+
+				int pointerIndex = event.findPointerIndex(mActivePointerId);
+
+				mLastEventY = (int) event.getY(pointerIndex);
+				int deltaY = mLastEventY - mDownY;
+
+				if (mCellIsMobile && mHoverCell != null) {
+					mHoverCellCurrentBounds.offsetTo(mHoverCellOriginalBounds.left,
+							mHoverCellOriginalBounds.top + deltaY + mTotalOffset);
+					mHoverCell.setBounds(mHoverCellCurrentBounds);
+					invalidate();
+
+					handleCellSwitch();
+
+					mIsMobileScrolling = false;
+					handleMobileCellScroll();
+
+					return false;
+				}
+				break;
+
+			case MotionEvent.ACTION_UP:
+				touchEventsEnded();
+				break;
+
+			case MotionEvent.ACTION_CANCEL:
+				touchEventsCancelled();
+				break;
+
+			case MotionEvent.ACTION_POINTER_UP:
+				/* If a multitouch event took place and the original touch dictating
+				 * the movement of the hover cell has ended, then the dragging event
+                 * ends and the hover cell is animated to its corresponding position
+                 * in the listview. */
+				pointerIndex = (event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >>
+						MotionEvent.ACTION_POINTER_INDEX_SHIFT;
+				final int pointerId = event.getPointerId(pointerIndex);
+				if (pointerId == mActivePointerId) {
+					touchEventsEnded();
+				}
+				break;
+
+			default:
+				break;
+		}
+
+		return super.onTouchEvent(event);
+	}
+
+	/**
+	 * This method determines whether the hover cell has been shifted far enough
+	 * to invoke a cell swap. If so, then the respective cell swap candidate is
+	 * determined and the data set is changed. Upon posting a notification of the
+	 * data set change, a layout is invoked to place the cells in the right place.
+	 * Using a ViewTreeObserver and a corresponding OnPreDrawListener, we can
+	 * offset the cell being swapped to where it previously was and then animate it to
+	 * its new position.
+	 */
+	private void handleCellSwitch() {
+		final int deltaY = mLastEventY - mDownY;
+		final int deltaYTotal = mHoverCellOriginalBounds.top + mTotalOffset + deltaY;
+
+		View belowView = getViewForID(mBelowItemId);
+		View mobileView = getViewForID(mMobileItemId);
+		View aboveView = getViewForID(mAboveItemId);
+
+		boolean isBelow = (belowView != null) && (deltaYTotal > belowView.getTop());
+		boolean isAbove = (aboveView != null) && (deltaYTotal < aboveView.getTop());
+
+		if (isBelow || isAbove) {
+
+			final long switchItemID = isBelow ? mBelowItemId : mAboveItemId;
+			View switchView = isBelow ? belowView : aboveView;
+			final int originalItem = getPositionForView(mobileView) - getHeaderViewsCount();
+			final int switchItem = getPositionForView(switchView) - getHeaderViewsCount();
+			swapElements(originalItem, switchItem);
+
+			getStableAdapter().notifyDataSetChanged();
+
+			mDownY = mLastEventY;
+
+			final int switchViewStartTop = switchView.getTop();
+
+			if (android.os.Build.VERSION.SDK_INT <= android.os.Build.VERSION_CODES.KITKAT) {
+				mobileView.setVisibility(View.VISIBLE);
+				switchView.setVisibility(View.INVISIBLE);
+			}
+			updateNeighborViewsForID(mMobileItemId);
+
+			final ViewTreeObserver observer = getViewTreeObserver();
+			observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
+				public boolean onPreDraw() {
+					observer.removeOnPreDrawListener(this);
+
+					View switchView = getViewForID(switchItemID);
+
+					mTotalOffset += deltaY;
+
+					int switchViewNewTop = switchView.getTop();
+					int delta = switchViewStartTop - switchViewNewTop;
+
+					switchView.setTranslationY(delta);
+
+					ObjectAnimator animator = ObjectAnimator.ofFloat(switchView,
+							View.TRANSLATION_Y, 0);
+					animator.setDuration(MOVE_DURATION);
+					animator.start();
+
+					return true;
+				}
+			});
+		}
+	}
+
+	private void swapElements(int indexOne, int indexTwo) {
+		Object obj1 = mItemsList.get(indexOne);
+		Object obj2 = mItemsList.get(indexTwo);
+		mItemsList.set(indexOne, obj2);
+		mItemsList.set(indexTwo, obj1);
+
+		int index1 = mActiveItemsList.indexOf(obj1);
+		int index2 = mActiveItemsList.indexOf(obj2);
+		if (index1 != -1 && index2 != -1) {
+			mActiveItemsList.set(index1, obj2);
+			mActiveItemsList.set(index2, obj1);
+			itemsSwapped = true;
+		}
+	}
+
+
+	/**
+	 * Resets all the appropriate fields to a default state while also animating
+	 * the hover cell back to its correct location.
+	 */
+	private void touchEventsEnded() {
+		final View mobileView = getViewForID(mMobileItemId);
+		if (mCellIsMobile || mIsWaitingForScrollFinish) {
+			mCellIsMobile = false;
+			mIsWaitingForScrollFinish = false;
+			mIsMobileScrolling = false;
+			mActivePointerId = INVALID_POINTER_ID;
+
+			// If the autoscroller has not completed scrolling, we need to wait for it to
+			// finish in order to determine the final location of where the hover cell
+			// should be animated to.
+			if (mScrollState != OnScrollListener.SCROLL_STATE_IDLE) {
+				mIsWaitingForScrollFinish = true;
+				return;
+			}
+
+			mHoverCellCurrentBounds.offsetTo(mHoverCellOriginalBounds.left, mobileView.getTop());
+
+			ObjectAnimator hoverViewAnimator = ObjectAnimator.ofObject(mHoverCell, "bounds",
+					sBoundEvaluator, mHoverCellCurrentBounds);
+			hoverViewAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+				@Override
+				public void onAnimationUpdate(ValueAnimator valueAnimator) {
+					invalidate();
+				}
+			});
+			hoverViewAnimator.addListener(new AnimatorListenerAdapter() {
+				@Override
+				public void onAnimationStart(Animator animation) {
+					setEnabled(false);
+				}
+
+				@Override
+				public void onAnimationEnd(Animator animation) {
+					mAboveItemId = INVALID_ID;
+					mMobileItemId = INVALID_ID;
+					mBelowItemId = INVALID_ID;
+					setAllVisible();
+					mHoverCell = null;
+					setEnabled(true);
+					invalidate();
+					processSwapped();
+				}
+			});
+			hoverViewAnimator.start();
+		} else {
+			touchEventsCancelled();
+		}
+	}
+
+	/**
+	 * Resets all the appropriate fields to a default state.
+	 */
+	private void touchEventsCancelled() {
+		if (mCellIsMobile) {
+			mAboveItemId = INVALID_ID;
+			mMobileItemId = INVALID_ID;
+			mBelowItemId = INVALID_ID;
+			setAllVisible();
+			mHoverCell = null;
+			invalidate();
+			processSwapped();
+		}
+
+		mCellIsMobile = false;
+		mIsMobileScrolling = false;
+		mActivePointerId = INVALID_POINTER_ID;
+	}
+
+	private void processSwapped() {
+		if (itemsSwapped) {
+			itemsSwapped = false;
+			if (dCallbacks != null) {
+				dCallbacks.onItemsSwapped(mActiveItemsList);
+			}
+		}
+	}
+
+	/**
+	 * This TypeEvaluator is used to animate the BitmapDrawable back to its
+	 * final location when the user lifts his finger by modifying the
+	 * BitmapDrawable's bounds.
+	 */
+	private final static TypeEvaluator<Rect> sBoundEvaluator = new TypeEvaluator<Rect>() {
+		public Rect evaluate(float fraction, Rect startValue, Rect endValue) {
+			return new Rect(interpolate(startValue.left, endValue.left, fraction),
+					interpolate(startValue.top, endValue.top, fraction),
+					interpolate(startValue.right, endValue.right, fraction),
+					interpolate(startValue.bottom, endValue.bottom, fraction));
+		}
+
+		public int interpolate(int start, int end, float fraction) {
+			return (int) (start + fraction * (end - start));
+		}
+	};
+
+	/**
+	 * Determines whether this listview is in a scrolling state invoked
+	 * by the fact that the hover cell is out of the bounds of the listview;
+	 */
+	private void handleMobileCellScroll() {
+		mIsMobileScrolling = handleMobileCellScroll(mHoverCellCurrentBounds);
+	}
+
+	/**
+	 * This method is in charge of determining if the hover cell is above
+	 * or below the bounds of the listview. If so, the listview does an appropriate
+	 * upward or downward smooth scroll so as to reveal new items.
+	 */
+	public boolean handleMobileCellScroll(Rect r) {
+		int offset = computeVerticalScrollOffset();
+		int height = getHeight();
+		int extent = computeVerticalScrollExtent();
+		int range = computeVerticalScrollRange();
+		int hoverViewTop = r.top;
+		int hoverHeight = r.height();
+
+		if (hoverViewTop <= 0 && offset > 0) {
+			smoothScrollBy(-mSmoothScrollAmountAtEdge, 0);
+			return true;
+		}
+
+		if (hoverViewTop + hoverHeight >= height && (offset + extent) < range) {
+			smoothScrollBy(mSmoothScrollAmountAtEdge, 0);
+			return true;
+		}
+
+		return false;
+	}
+
+	public void setItemsList(List<Object> itemsList) {
+		mItemsList = itemsList;
+	}
+
+	/*
+	 * Define items which can be moved
+	 * mActiveItemsList == null means all items are movable
+	 */
+	public void setActiveItemsList(List<Object> mActiveItemsList) {
+		this.mActiveItemsList = mActiveItemsList;
+	}
+
+	/**
+	 * This scroll listener is added to the listview in order to handle cell swapping
+	 * when the cell is either at the top or bottom edge of the listview. If the hover
+	 * cell is at either edge of the listview, the listview will begin scrolling. As
+	 * scrolling takes place, the listview continuously checks if new cells became visible
+	 * and determines whether they are potential candidates for a cell swap.
+	 */
+	private AbsListView.OnScrollListener mScrollListener = new AbsListView.OnScrollListener() {
+
+		private int mPreviousFirstVisibleItem = -1;
+		private int mPreviousVisibleItemCount = -1;
+		private int mCurrentFirstVisibleItem;
+		private int mCurrentVisibleItemCount;
+		private int mCurrentScrollState;
+
+		public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount,
+							 int totalItemCount) {
+			mCurrentFirstVisibleItem = firstVisibleItem;
+			mCurrentVisibleItemCount = visibleItemCount;
+
+			mPreviousFirstVisibleItem = (mPreviousFirstVisibleItem == -1) ? mCurrentFirstVisibleItem
+					: mPreviousFirstVisibleItem;
+			mPreviousVisibleItemCount = (mPreviousVisibleItemCount == -1) ? mCurrentVisibleItemCount
+					: mPreviousVisibleItemCount;
+
+			checkAndHandleFirstVisibleCellChange();
+			checkAndHandleLastVisibleCellChange();
+
+			mPreviousFirstVisibleItem = mCurrentFirstVisibleItem;
+			mPreviousVisibleItemCount = mCurrentVisibleItemCount;
+		}
+
+		@Override
+		public void onScrollStateChanged(AbsListView view, int scrollState) {
+			mCurrentScrollState = scrollState;
+			mScrollState = scrollState;
+			isScrollCompleted();
+		}
+
+		/**
+		 * This method is in charge of invoking 1 of 2 actions. Firstly, if the listview
+		 * is in a state of scrolling invoked by the hover cell being outside the bounds
+		 * of the listview, then this scrolling event is continued. Secondly, if the hover
+		 * cell has already been released, this invokes the animation for the hover cell
+		 * to return to its correct position after the listview has entered an idle scroll
+		 * state.
+		 */
+		private void isScrollCompleted() {
+			if (mCurrentVisibleItemCount > 0 && mCurrentScrollState == SCROLL_STATE_IDLE) {
+				if (mCellIsMobile && mIsMobileScrolling) {
+					handleMobileCellScroll();
+				} else if (mIsWaitingForScrollFinish) {
+					touchEventsEnded();
+				}
+			}
+		}
+
+		/**
+		 * Determines if the listview scrolled up enough to reveal a new cell at the
+		 * top of the list. If so, then the appropriate parameters are updated.
+		 */
+		public void checkAndHandleFirstVisibleCellChange() {
+			if (mCurrentFirstVisibleItem != mPreviousFirstVisibleItem) {
+				if (mCellIsMobile && mMobileItemId != INVALID_ID) {
+					updateNeighborViewsForID(mMobileItemId);
+					handleCellSwitch();
+				}
+			}
+		}
+
+		/**
+		 * Determines if the listview scrolled down enough to reveal a new cell at the
+		 * bottom of the list. If so, then the appropriate parameters are updated.
+		 */
+		public void checkAndHandleLastVisibleCellChange() {
+			int currentLastVisibleItem = mCurrentFirstVisibleItem + mCurrentVisibleItemCount;
+			int previousLastVisibleItem = mPreviousFirstVisibleItem + mPreviousVisibleItemCount;
+			if (currentLastVisibleItem != previousLastVisibleItem) {
+				if (mCellIsMobile && mMobileItemId != INVALID_ID) {
+					updateNeighborViewsForID(mMobileItemId);
+					handleCellSwitch();
+				}
+			}
+		}
+	};
+
+	/**
+	 * Returns the most inner view that contains the xy coordinate.
+	 *
+	 * @param v This method gets called recursively. The initial call should be the root view.
+	 * @param x The X location to be tested.
+	 * @param y The Y location to be tested.
+	 * @return Returns the most inner view that contains the XY coordinate or null if no view could be found.
+	 */
+	private View findViewAtPositionWithTag(View v, int x, int y, String tag) {
+		View vXY = null;
+
+		if (v instanceof ViewGroup) {
+			ViewGroup viewGroup = (ViewGroup) v;
+
+			for (int i = 0; i < viewGroup.getChildCount(); i++) {
+				View c = viewGroup.getChildAt(i);
+
+				int loc[] = new int[2];
+				c.getLocationOnScreen(loc);
+
+				if ((x >= loc[0] && (x <= (loc[0] + c.getWidth()))) && (y >= loc[1] && (y <= (loc[1] + c.getHeight())))) {
+					vXY = c;
+					View viewAtPosition = findViewAtPositionWithTag(c, x, y, tag);
+
+					if ((viewAtPosition != null) && (viewAtPosition.getTag() != null) && viewAtPosition.getTag().equals(tag)) {
+						vXY = viewAtPosition;
+						break;
+					}
+				}
+			}
+		}
+
+		return vXY;
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java
new file mode 100644
index 00000000000..982d0d447fa
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java
@@ -0,0 +1,9 @@
+package net.osmand.plus.views.controls;
+
+import java.util.List;
+
+public interface DynamicListViewCallbacks {
+
+	void onItemsSwapped(final List<Object> items);
+
+}
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java b/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java
new file mode 100644
index 00000000000..dc62e525671
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java
@@ -0,0 +1,66 @@
+package net.osmand.plus.views.controls;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.widget.ArrayAdapter;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+
+public class StableArrayAdapter extends ArrayAdapter<Object> {
+
+	final int INVALID_ID = -1;
+
+	List<Object> objects;
+	List<Object> activeObjects;
+	HashMap<Object, Integer> mIdMap = new HashMap<>();
+
+	public StableArrayAdapter(Context context, int textViewResourceId, int titleId,
+							  List<Object> objects, List<Object> activeObjects) {
+		super(context, textViewResourceId, titleId, objects);
+		updateObjects(objects, activeObjects);
+	}
+
+	public List<Object> getObjects() {
+		return objects;
+	}
+
+	public List<Object> getActiveObjects() {
+		return activeObjects;
+	}
+
+	public void updateObjects(List<Object> objects, List<Object> activeObjects) {
+		this.objects = objects;
+		this.activeObjects = activeObjects;
+
+		HashMap<Object, Integer> idMap = new HashMap<>();
+		for (int i = 0; i < objects.size(); ++i) {
+			idMap.put(objects.get(i), i);
+		}
+		mIdMap = idMap;
+	}
+
+	@Override
+	public Object getItem(int position) {
+		return objects.get(position);
+	}
+
+	@Override
+	public long getItemId(int position) {
+		if (position < 0 || position >= mIdMap.size()) {
+			return INVALID_ID;
+		}
+		Object item = getItem(position);
+		if (mIdMap.containsKey(item)) {
+			return mIdMap.get(item);
+		} else {
+			return INVALID_ID;
+		}
+	}
+
+	@Override
+	public boolean hasStableIds() {
+		return true;
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/MapInfoWidgetsFactory.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/MapInfoWidgetsFactory.java
index 4683e6ae65e..7cc18692d47 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/MapInfoWidgetsFactory.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/MapInfoWidgetsFactory.java
@@ -321,7 +321,7 @@ public boolean updateWaypoint() {
 				boolean updated = updateVisibility(waypointInfoBar, true);
 				// pass top bar to make it clickable
 				WaypointDialogHelper.updatePointInfoView(map.getMyApplication(), map, topBar,
-						pnt, true, !map.getMyApplication().getSettings().isLightContent());
+						pnt, true, !map.getMyApplication().getSettings().isLightContent(), false);
 				if (updated || changed) {
 					ImageView all = (ImageView) waypointInfoBar.findViewById(R.id.waypoint_more);
 					ImageView remove = (ImageView) waypointInfoBar.findViewById(R.id.waypoint_close);
