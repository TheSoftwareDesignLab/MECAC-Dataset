diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
index 94a56369d35..b133d185aab 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteCalculationResult.java
@@ -1037,10 +1037,7 @@ public Location getLocationFromRouteDirection(RouteDirectionInfo i){
 					nextInd++;
 				}
 			}
-			int dist = getListDistance(currentRoute);
-			if (fromLoc != null) {
-				dist += fromLoc.distanceTo(locations.get(currentRoute));
-			}
+			int dist = getDistanceToFinish(fromLoc);
 			if (nextInd < directions.size()) {
 				info.directionInfo = directions.get(nextInd);
 				if (directions.get(nextInd).routePointOffset <= currentRoute
@@ -1162,10 +1159,15 @@ public boolean isPointPassed(int locationIndex) {
 	}
 	
 	public int getDistanceToFinish(Location fromLoc) {
-		if(listDistance != null && currentRoute < listDistance.length){
-			int dist = listDistance[currentRoute];
-			Location l = locations.get(currentRoute);
-			if(fromLoc != null){
+		Location ap = this.currentStraightAnglePoint;
+		int rp = currentStraightAngleRoute > currentRoute ? currentStraightAngleRoute : currentRoute;
+		if(listDistance != null && rp < listDistance.length){
+			int dist = listDistance[rp];
+			Location l = locations.get(rp);
+			if(ap != null){
+				dist += fromLoc.distanceTo(ap);
+				dist += ap.distanceTo(l);
+			} else {
 				dist += fromLoc.distanceTo(l);
 			}
 			return dist;
@@ -1174,12 +1176,8 @@ public int getDistanceToFinish(Location fromLoc) {
 	}
 	
 	public int getDistanceToNextIntermediate(Location fromLoc) {
+		int dist = getDistanceToFinish(fromLoc);
 		if(listDistance != null && currentRoute < listDistance.length){
-			int dist = listDistance[currentRoute];
-			Location l = locations.get(currentRoute);
-			if(fromLoc != null){
-				dist += fromLoc.distanceTo(l);
-			}
 			if(nextIntermediate >= intermediatePoints.length ){
 				return 0;
 			} else {
@@ -1245,8 +1243,8 @@ public Location getCurrentStraightAnglePoint() {
 	}
 
 	public void updateNextVisiblePoint(int nextPoint, Location mp) {
-		currentStraightAngleRoute = nextPoint;
 		currentStraightAnglePoint = mp;
+		currentStraightAngleRoute = nextPoint;
 	}
 
 	public static class NextDirectionInfo {
diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
index 43cd6907f63..45b15fdab13 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
@@ -78,7 +78,7 @@ public class RouteProvider {
 	private static final org.apache.commons.logging.Log log = PlatformUtil.getLog(RouteProvider.class);
 	private static final String OSMAND_ROUTER = "OsmAndRouter";
 	private static final int MIN_DISTANCE_FOR_INSERTING_ROUTE_SEGMENT = 60;
-	private static final int MIN_STRAIGHT_DIST = 150;
+	private static final int MIN_STRAIGHT_DIST = 50000;
 
 	public enum RouteService {
 		OSMAND("OsmAnd (offline)"),
@@ -1249,13 +1249,12 @@ private RouteCalculationResult findStraightRoute(RouteCalculationParams params)
 			}
 		}
 		points.add(new Location("", params.end.getLatitude(), params.end.getLongitude()));
-		Location lastAdded = points.poll();
-		segments.add(lastAdded);
+		Location lastAdded = null;
 		float speed = params.mode.getDefaultSpeed();
 		List<RouteDirectionInfo> computeDirections = new ArrayList<RouteDirectionInfo>();
 		while(!points.isEmpty()) {
 			Location pl = points.peek();
-			if (lastAdded.distanceTo(pl) < MIN_STRAIGHT_DIST) {
+			if (lastAdded == null || lastAdded.distanceTo(pl) < MIN_STRAIGHT_DIST) {
 				lastAdded = points.poll();
 				if(lastAdded.getProvider().equals("pnt")) {
 					RouteDirectionInfo previousInfo = new RouteDirectionInfo(speed, TurnType.straight());
