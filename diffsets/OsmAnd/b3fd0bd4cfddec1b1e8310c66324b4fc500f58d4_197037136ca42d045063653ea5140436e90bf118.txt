diff --git a/OsmAnd/res/anim/popup_hide.xml b/OsmAnd/res/anim/popup_hide.xml
new file mode 100644
index 00000000000..4a9eafdb884
--- /dev/null
+++ b/OsmAnd/res/anim/popup_hide.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<set xmlns:android="http://schemas.android.com/apk/res/android">
+    <alpha android:fromAlpha="1.0"
+           android:toAlpha="0.0"
+           android:duration="500"
+           android:repeatCount="0"/>
+</set>
\ No newline at end of file
diff --git a/OsmAnd/res/anim/popup_show.xml b/OsmAnd/res/anim/popup_show.xml
new file mode 100644
index 00000000000..ddca59f8b3b
--- /dev/null
+++ b/OsmAnd/res/anim/popup_show.xml
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="utf-8"?>
+<set xmlns:android="http://schemas.android.com/apk/res/android">
+    <alpha android:fromAlpha="0.0"
+           android:toAlpha="1.0"
+           android:duration="500"
+           android:repeatCount="0"/>
+</set>
\ No newline at end of file
diff --git a/OsmAnd/res/drawable/popup_bg.xml b/OsmAnd/res/drawable/popup_bg.xml
new file mode 100644
index 00000000000..40dc344b9f2
--- /dev/null
+++ b/OsmAnd/res/drawable/popup_bg.xml
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<shape xmlns:android="http://schemas.android.com/apk/res/android">
+    <solid android:color="@color/popup_bg_color"/>
+    <corners android:radius="5dp"/>
+</shape>
\ No newline at end of file
diff --git a/OsmAnd/res/layout/undo_popup.xml b/OsmAnd/res/layout/undo_popup.xml
new file mode 100644
index 00000000000..6596c22d9f8
--- /dev/null
+++ b/OsmAnd/res/layout/undo_popup.xml
@@ -0,0 +1,40 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
+              android:layout_width="fill_parent"
+              android:layout_height="fill_parent"
+              android:background="@drawable/popup_bg"
+              android:gravity="center"
+              android:orientation="horizontal">
+
+    <TextView
+        android:id="@+id/text"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_weight="1"
+        android:ellipsize="end"
+        android:paddingTop="8dp"
+        android:paddingBottom="8dp"
+        android:paddingRight="16dp"
+        android:paddingLeft="16dp"
+        android:singleLine="true"
+        android:textColor="@color/popup_text_color"
+        android:text="Item deleted"
+        android:textSize="@dimen/default_list_text_size"/>
+
+    <View
+        android:layout_width="1dp"
+        android:layout_height="fill_parent"
+        android:layout_marginBottom="15dp"
+        android:layout_marginTop="15dp"
+        android:layout_weight="0"
+        android:background="@color/popup_separator_color"/>
+
+    <Button
+        android:id="@+id/undo"
+        android:layout_width="wrap_content"
+        android:layout_height="wrap_content"
+        android:layout_weight="0"
+        android:background="?attr/selectableItemBackground"
+        android:text="UNDO"
+        android:textColor="@color/popup_text_color"/>
+</LinearLayout>
\ No newline at end of file
diff --git a/OsmAnd/res/values/colors.xml b/OsmAnd/res/values/colors.xml
index dfa5fa6f1cb..fbff124c198 100644
--- a/OsmAnd/res/values/colors.xml
+++ b/OsmAnd/res/values/colors.xml
@@ -1,6 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
 
+	<color name="popup_bg_color">#EE666666</color>
+	<color name="popup_separator_color">#BBBBBB</color>
+	<color name="popup_text_color">#FFFFFF</color>
+
 	<color name="primary_text_light">#de000000</color>
 	<color name="secondary_text_light">#8a000000</color>
 	<color name="primary_text_dark">#ffffffff</color>
diff --git a/OsmAnd/res/values/sizes.xml b/OsmAnd/res/values/sizes.xml
index f1dc5e7b834..7d1b2cf9bc3 100644
--- a/OsmAnd/res/values/sizes.xml
+++ b/OsmAnd/res/values/sizes.xml
@@ -1,5 +1,8 @@
 <?xml version="1.0" encoding="utf-8"?>
 <resources>
+	<dimen name="undo_bottom_offset">15dp</dimen>
+	<dimen name="touch_slop">32dp</dimen>
+
     <dimen name="list_item_height">50dp</dimen>
 	<dimen name="list_header_height">40dp</dimen>
 	<dimen name="dashboard_map_top_padding">240dp</dimen>
diff --git a/OsmAnd/res/values/strings.xml b/OsmAnd/res/values/strings.xml
index d34b9ae2be2..91f80b908cc 100644
--- a/OsmAnd/res/values/strings.xml
+++ b/OsmAnd/res/values/strings.xml
@@ -9,6 +9,9 @@
          3. All your modified/created strings are in the top of the file (to make easier find what\'s translated).
     PLEASE: Have a look at http://code.google.com/p/osmand/wiki/UIConsistency, it may really improve your and our work  :-)  Thx - Hardy
     -->
+    <string name="item_deleted">Item deleted</string>
+    <string name="n_items_deleted">items deleted</string>
+    <string name="shared_string_undo_all">UNDO ALL</string>
     <string name="shared_string_type">Type</string>
     <string name="starting_point">Starting point</string>
     <string name="shared_string_not_selected">Not selected</string>
diff --git a/OsmAnd/res/values/styles.xml b/OsmAnd/res/values/styles.xml
index 3c23f11c4dd..64568c0e435 100644
--- a/OsmAnd/res/values/styles.xml
+++ b/OsmAnd/res/values/styles.xml
@@ -299,6 +299,11 @@
     <!-- PopUpMenu -->
     <style name="Animations.PopUpMenu"/>
 
+    <style name="Animations.PopUpMenu.Fade">
+        <item name="@android:windowEnterAnimation">@anim/popup_show</item>
+        <item name="@android:windowExitAnimation">@anim/popup_hide</item>
+    </style>
+
     <style name="Animations.PopUpMenu.Left">
         <item name="@android:windowEnterAnimation">@anim/grow_from_bottomleft_to_topright</item>
         <item name="@android:windowExitAnimation">@anim/shrink_from_topright_to_bottomleft</item>
diff --git a/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java b/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java
index deccbaafbd8..39c1909d89d 100644
--- a/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java
+++ b/OsmAnd/src/net/osmand/plus/dashboard/DashboardOnMap.java
@@ -64,6 +64,8 @@
 import net.osmand.plus.views.controls.DynamicListView;
 import net.osmand.plus.views.controls.DynamicListViewCallbacks;
 import net.osmand.plus.views.controls.StableArrayAdapter;
+import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener;
+import net.osmand.plus.views.controls.SwipeDismissListViewTouchListener.Undoable;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
@@ -111,7 +113,7 @@ public class DashboardOnMap implements ObservableScrollViewCallbacks, DynamicLis
 
 	private ArrayAdapter<?> listAdapter;
 	private OnItemClickListener listAdapterOnClickListener;
-
+	private SwipeDismissListViewTouchListener swipeDismissListener;
 
 	private boolean visible = false;
 	private DashboardType visibleType;
@@ -178,7 +180,7 @@ public void createDashboardView() {
 		waypointDialogHelper = new WaypointDialogHelper(mapActivity);
 		landscape = !AndroidUiHelper.isOrientationPortrait(mapActivity);
 		dashboardView = (FrameLayout) mapActivity.findViewById(R.id.dashboard);
-		View.OnClickListener listener = new View.OnClickListener() {
+		final View.OnClickListener listener = new View.OnClickListener() {
 			@Override
 			public void onClick(View v) {
 				hideDashboard();
@@ -189,6 +191,72 @@ public void onClick(View v) {
 		listView = (ListView) dashboardView.findViewById(R.id.dash_list_view);
 		listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
 		((DynamicListView) listView).setDynamicListViewCallbacks(this);
+
+		// Create a ListView-specific touch listener. ListViews are given special treatment because
+		// by default they handle touches for their list items... i.e. they're in charge of drawing
+		// the pressed state (the list selector), handling list item clicks, etc.
+		swipeDismissListener = new SwipeDismissListViewTouchListener(
+						listView,
+						new SwipeDismissListViewTouchListener.DismissCallbacks() {
+							@Override
+							public boolean canDismiss(int position) {
+								boolean res = false;
+								if (listAdapter instanceof StableArrayAdapter) {
+									List<Object> activeObjects = ((StableArrayAdapter) listAdapter).getActiveObjects();
+									Object obj = listAdapter.getItem(position);
+									res = activeObjects.contains(obj);
+								}
+								return res;
+							}
+
+							@Override
+							public Undoable onDismiss(final int position) {
+								final Object item;
+								final StableArrayAdapter stableAdapter;
+								final int activeObjPos;
+								if (listAdapter instanceof StableArrayAdapter) {
+									stableAdapter = (StableArrayAdapter) listAdapter;
+									item = stableAdapter.getItem(position);
+
+									stableAdapter.setNotifyOnChange(false);
+									stableAdapter.remove(item);
+									stableAdapter.getObjects().remove(item);
+									activeObjPos = stableAdapter.getActiveObjects().indexOf(item);
+									stableAdapter.getActiveObjects().remove(item);
+									stableAdapter.notifyDataSetChanged();
+
+								} else {
+									item = null;
+									stableAdapter = null;
+									activeObjPos = 0;
+								}
+
+								return new Undoable() {
+									@Override
+									public void undo() {
+										if (item != null) {
+											stableAdapter.setNotifyOnChange(false);
+											stableAdapter.insert(item, position);
+											stableAdapter.getObjects().add(position, item);
+											stableAdapter.getActiveObjects().add(activeObjPos, item);
+											stableAdapter.updateIdMap();
+
+											onItemsSwapped(stableAdapter.getActiveObjects());
+										}
+									}
+								};
+							}
+
+							@Override
+							public void onHidePopup() {
+								if (listAdapter instanceof StableArrayAdapter) {
+									StableArrayAdapter stableAdapter = (StableArrayAdapter) listAdapter;
+									stableAdapter.updateIdMap();
+									onItemsSwapped(stableAdapter.getActiveObjects());
+								}
+							}
+						});
+
 		gradientToolbar = mapActivity.getResources().getDrawable(R.drawable.gradient_toolbar).mutate();
 		if (AndroidUiHelper.isOrientationPortrait(mapActivity)) {
 			this.portrait = true;
@@ -541,6 +609,9 @@ public void setDashboardVisibility(boolean visible, DashboardType type, Dashboar
 //			addOrUpdateDashboardFragments();
 			mapActivity.getRoutingHelper().addListener(this);
 		} else {
+			if (swipeDismissListener != null) {
+				swipeDismissListener.discardUndo();
+			}
 			mapActivity.getRoutingHelper().removeListener(this);
 			mapActivity.getMapViewTrackingUtilities().setDashboard(null);
 			hide(dashboardView.findViewById(R.id.animateContent), animation);
@@ -1082,6 +1153,13 @@ public boolean shouldShow(OsmandSettings settings, MapActivity activity, String
 		}
 	}
 
+	@Override
+	public void onItemSwapping(int position) {
+		if (swipeDismissListener != null) {
+			swipeDismissListener.setEnabled(false);
+		}
+	}
+
 	@Override
 	public void onItemsSwapped(final List<Object> items) {
 		getMyApplication().runInUIThread(new Runnable() {
@@ -1109,6 +1187,10 @@ public void run() {
 					getMyApplication().getTargetPointsHelper().reorderAllTargetPoints(allTargets, false);
 					newRouteIsCalculated(false, null);
 					getMyApplication().getTargetPointsHelper().updateRouteAndReferesh(true);
+
+					if (swipeDismissListener != null) {
+						swipeDismissListener.setEnabled(true);
+					}
 				}
 			}
 		}, 50);
@@ -1131,4 +1213,11 @@ public void newRouteIsCalculated(boolean newRoute, ValueHolder<Boolean> showToas
 	@Override
 	public void routeWasCancelled() {
 	}
+
+	@Override
+	public void onWindowVisibilityChanged(int visibility) {
+		if (visibility != View.VISIBLE && swipeDismissListener != null) {
+			swipeDismissListener.discardUndo();
+		}
+	}
 }
diff --git a/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java b/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java
index 40101711228..0271ea46aa5 100644
--- a/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java
+++ b/OsmAnd/src/net/osmand/plus/helpers/WaypointDialogHelper.java
@@ -261,6 +261,7 @@ public void onClick(View view) {
 
 					deletedPoints.add(point);
 					if (adapter != null) {
+						adapter.setNotifyOnChange(false);
 						adapter.remove(point);
 						adapter.notifyDataSetChanged();
 					}
@@ -451,6 +452,7 @@ protected void onPostExecute(Void result) {
 	}
 
 	public void reloadListAdapter(ArrayAdapter<Object> listAdapter) {
+		listAdapter.setNotifyOnChange(false);
 		listAdapter.clear();
 		List<Object> points = getPoints();
 		for (Object point : points) {
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java
index 068beac3e2e..be0198c19d5 100644
--- a/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java
+++ b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListView.java
@@ -28,6 +28,7 @@
 import android.graphics.Rect;
 import android.graphics.drawable.BitmapDrawable;
 import android.support.annotation.NonNull;
+import android.support.v4.view.ViewCompat;
 import android.util.AttributeSet;
 import android.util.DisplayMetrics;
 import android.view.MotionEvent;
@@ -278,8 +279,11 @@ public boolean onTouchEvent(@NonNull MotionEvent event) {
 								selectedView.setVisibility(INVISIBLE);
 
 								mCellIsMobile = true;
-
 								updateNeighborViewsForID(mMobileItemId);
+
+								if (dCallbacks != null) {
+									dCallbacks.onItemSwapping(position);
+								}
 							}
 						}
 					}
@@ -393,10 +397,16 @@ public boolean onPreDraw() {
 
 					switchView.setTranslationY(delta);
 
-					ObjectAnimator animator = ObjectAnimator.ofFloat(switchView,
-							View.TRANSLATION_Y, 0);
-					animator.setDuration(MOVE_DURATION);
-					animator.start();
+					if (android.os.Build.VERSION.SDK_INT < 12) {
+						ViewCompat.animate(switchView)
+								.translationY(0)
+								.setDuration(MOVE_DURATION);
+					} else {
+						ObjectAnimator animator = ObjectAnimator.ofFloat(switchView,
+								View.TRANSLATION_Y, 0);
+						animator.setDuration(MOVE_DURATION);
+						animator.start();
+					}
 
 					return true;
 				}
@@ -442,33 +452,30 @@ private void touchEventsEnded() {
 
 			mHoverCellCurrentBounds.offsetTo(mHoverCellOriginalBounds.left, mobileView.getTop());
 
-			ObjectAnimator hoverViewAnimator = ObjectAnimator.ofObject(mHoverCell, "bounds",
-					sBoundEvaluator, mHoverCellCurrentBounds);
-			hoverViewAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
-				@Override
-				public void onAnimationUpdate(ValueAnimator valueAnimator) {
-					invalidate();
-				}
-			});
-			hoverViewAnimator.addListener(new AnimatorListenerAdapter() {
-				@Override
-				public void onAnimationStart(Animator animation) {
-					setEnabled(false);
-				}
+			if (android.os.Build.VERSION.SDK_INT < 12) {
+				finishTouch();
+			} else {
+				ObjectAnimator hoverViewAnimator = ObjectAnimator.ofObject(mHoverCell, "bounds",
+						sBoundEvaluator, mHoverCellCurrentBounds);
+				hoverViewAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+					@Override
+					public void onAnimationUpdate(ValueAnimator valueAnimator) {
+						invalidate();
+					}
+				});
+				hoverViewAnimator.addListener(new AnimatorListenerAdapter() {
+					@Override
+					public void onAnimationStart(Animator animation) {
+						setEnabled(false);
+					}
 
-				@Override
-				public void onAnimationEnd(Animator animation) {
-					mAboveItemId = INVALID_ID;
-					mMobileItemId = INVALID_ID;
-					mBelowItemId = INVALID_ID;
-					setAllVisible();
-					mHoverCell = null;
-					setEnabled(true);
-					invalidate();
-					processSwapped();
-				}
-			});
-			hoverViewAnimator.start();
+					@Override
+					public void onAnimationEnd(Animator animation) {
+						finishTouch();
+					}
+				});
+				hoverViewAnimator.start();
+			}
 		} else {
 			touchEventsCancelled();
 		}
@@ -479,13 +486,7 @@ public void onAnimationEnd(Animator animation) {
 	 */
 	private void touchEventsCancelled() {
 		if (mCellIsMobile) {
-			mAboveItemId = INVALID_ID;
-			mMobileItemId = INVALID_ID;
-			mBelowItemId = INVALID_ID;
-			setAllVisible();
-			mHoverCell = null;
-			invalidate();
-			processSwapped();
+			finishTouch();
 		}
 
 		mCellIsMobile = false;
@@ -493,6 +494,17 @@ private void touchEventsCancelled() {
 		mActivePointerId = INVALID_POINTER_ID;
 	}
 
+	private void finishTouch() {
+		mAboveItemId = INVALID_ID;
+		mMobileItemId = INVALID_ID;
+		mBelowItemId = INVALID_ID;
+		setAllVisible();
+		mHoverCell = null;
+		setEnabled(true);
+		invalidate();
+		processSwapped();
+	}
+
 	private void processSwapped() {
 		if (itemsSwapped) {
 			itemsSwapped = false;
@@ -686,4 +698,12 @@ private View findViewAtPositionWithTag(View v, int x, int y, String tag) {
 
 		return vXY;
 	}
+
+	@Override
+	protected void onWindowVisibilityChanged(int visibility) {
+		super.onWindowVisibilityChanged(visibility);
+		if (dCallbacks != null) {
+			dCallbacks.onWindowVisibilityChanged(visibility);
+		}
+	}
 }
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java
index 982d0d447fa..2e168f76cc3 100644
--- a/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java
+++ b/OsmAnd/src/net/osmand/plus/views/controls/DynamicListViewCallbacks.java
@@ -5,5 +5,8 @@
 public interface DynamicListViewCallbacks {
 
 	void onItemsSwapped(final List<Object> items);
+	void onItemSwapping(final int position);
+
+	void onWindowVisibilityChanged(int visibility);
 
 }
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java b/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java
index dc62e525671..c3c9f2d6495 100644
--- a/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java
+++ b/OsmAnd/src/net/osmand/plus/views/controls/StableArrayAdapter.java
@@ -4,7 +4,9 @@
 import android.support.annotation.NonNull;
 import android.widget.ArrayAdapter;
 
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 
@@ -33,7 +35,10 @@ public List<Object> getActiveObjects() {
 	public void updateObjects(List<Object> objects, List<Object> activeObjects) {
 		this.objects = objects;
 		this.activeObjects = activeObjects;
+		updateIdMap();
+	}
 
+	public void updateIdMap() {
 		HashMap<Object, Integer> idMap = new HashMap<>();
 		for (int i = 0; i < objects.size(); ++i) {
 			idMap.put(objects.get(i), i);
diff --git a/OsmAnd/src/net/osmand/plus/views/controls/SwipeDismissListViewTouchListener.java b/OsmAnd/src/net/osmand/plus/views/controls/SwipeDismissListViewTouchListener.java
new file mode 100644
index 00000000000..5da7ffa495e
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/views/controls/SwipeDismissListViewTouchListener.java
@@ -0,0 +1,885 @@
+package net.osmand.plus.views.controls;
+
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ValueAnimator;
+import android.content.Context;
+import android.graphics.Rect;
+import android.os.Build;
+import android.os.Handler;
+import android.os.Message;
+import android.support.annotation.NonNull;
+import android.support.v4.animation.AnimatorCompatHelper;
+import android.support.v4.view.ViewCompat;
+import android.support.v4.view.ViewPropertyAnimatorListener;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.ViewParent;
+import android.view.ViewPropertyAnimator;
+import android.widget.AbsListView;
+import android.widget.Button;
+import android.widget.ListView;
+import android.widget.PopupWindow;
+import android.widget.TextView;
+
+import net.osmand.plus.R;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+/**
+ * A {@link View.OnTouchListener} that makes the list items in a {@link ListView}
+ * dismissable. {@link ListView} is given special treatment because by default it handles touches
+ * for its list items... i.e. it's in charge of drawing the pressed state (the list selector),
+ * handling list item clicks, etc.
+ * <p/>
+ * <p>After creating the listener, the caller should also call
+ * {@link ListView#setOnScrollListener(AbsListView.OnScrollListener)}, passing
+ * in the scroll listener returned by {@link #makeScrollListener()}. If a scroll listener is
+ * already assigned, the caller should still pass scroll changes through to this listener. This will
+ * ensure that this {@link SwipeDismissListViewTouchListener} is paused during list view
+ * scrolling.</p>
+ * <p/>
+ * <p>Example usage:</p>
+ * <p/>
+ * <pre>
+ * SwipeDismissListViewTouchListener touchListener =
+ *         new SwipeDismissListViewTouchListener(
+ *                 listView,
+ *                 new SwipeDismissListViewTouchListener.OnDismissCallback() {
+ *                     public void onDismiss(ListView listView, int[] reverseSortedPositions) {
+ *                         for (int position : reverseSortedPositions) {
+ *                             adapter.remove(adapter.getItem(position));
+ *                         }
+ *                         adapter.notifyDataSetChanged();
+ *                     }
+ *                 });
+ * listView.setOnTouchListener(touchListener);
+ * listView.setOnScrollListener(touchListener.makeScrollListener());
+ * </pre>
+ * <p/>
+ * <p>This class Requires API level 12 or later due to use of {@link
+ * ViewPropertyAnimator}.</p>
+ * <p/>
+ */
+public class SwipeDismissListViewTouchListener implements View.OnTouchListener {
+	// Cached ViewConfiguration and system-wide constant values
+	private int mSlop;
+	private int mMinFlingVelocity;
+	private int mMaxFlingVelocity;
+	private long mAnimationTime;
+
+	// Fixed properties
+	private ListView mListView;
+	private DismissCallbacks mCallbacks;
+	private int mViewWidth = 1; // 1 and not 0 to prevent dividing by zero
+
+	// Transient properties
+	//private List<PendingDismissData> mPendingDismisses = new ArrayList<PendingDismissData>();
+	private int mDismissAnimationRefCount = 0;
+	private float mDownX;
+	private boolean mSwiping;
+	private VelocityTracker mVelocityTracker;
+	private int mDownPosition;
+	private View mSwipeDownView;
+	private boolean mSwipePaused;
+
+	private PopupWindow mUndoPopup;
+	private int mValidDelayedMsgId;
+	private Handler mHideUndoHandler = new HideUndoPopupHandler();
+	private Button mUndoButton;
+
+	private UndoStyle mUndoStyle = UndoStyle.SINGLE_POPUP;
+	private boolean mTouchBeforeAutoHide = false;
+	private SwipeDirection mSwipeDirection = SwipeDirection.BOTH;
+	private int mUndoHideDelay = 5000;
+	private int mSwipingLayout;
+
+	private final Object[] mAnimationLock = new Object[0];
+	private List<Undoable> mUndoActions = new ArrayList<>();
+	private SortedSet<PendingDismissData> mPendingDismisses = new TreeSet<>();
+	private List<View> mAnimatedViews = new LinkedList<>();
+
+	private View mSwipeDownChild;
+	private TextView mUndoPopupTextView;
+	private float mScreenDensity;
+
+	/**
+	 * Defines the direction in which list items can be swiped out to delete them.
+	 * Use {@code #setSwipeDirection(SwipeDirection)}
+	 * to change the default behavior.
+	 */
+	public enum SwipeDirection {
+
+		/**
+		 * The user can swipe each item into both directions (left and right) to delete it.
+		 */
+		BOTH,
+
+		/**
+		 * The user can only swipe the items to the beginning of the item to
+		 * delete it. The start of an item is in Left-To-Right languages the left
+		 * side and in Right-To-Left languages the right side. Before API level
+		 * 17 this is always the left side.
+		 */
+		START,
+
+		/**
+		 * The user can only swipe the items to the end of the item to delete it.
+		 * This is in Left-To-Right languages the right side in Right-To-Left
+		 * languages the left side. Before API level 17 this will always be the
+		 * right side.
+		 */
+		END
+
+	}
+
+	/**
+	 * Extend this abstract class and return it from
+	 * {@code OnDismissCallback#onDismiss(EnhancedListView, int)}
+	 * to let the user undo the deletion you've done with your {@code OnDismissCallback}.
+	 * You have at least to implement the {@link #undo()} method, and can override {@link #discard()}
+	 * and {@link #getTitle()} to offer more functionality. See the README file for example implementations.
+	 */
+	public abstract static class Undoable {
+
+		/**
+		 * This method must undo the deletion you've done in
+		 * OnDismissCallback.onDismiss(ListView, int) and reinsert
+		 * the element into the adapter.
+		 * <p/>
+		 * In the most implementations, you will only remove the list item from your adapter
+		 * in the {@code onDismiss} method and delete it from the database (or your permanent
+		 * storage) in {@link #discard()}. In that case you only need to reinsert the item
+		 * to the adapter.
+		 */
+		public abstract void undo();
+
+		/**
+		 * Returns the individual undo message for this undo. This will be displayed in the undo
+		 * window, beside the undo button. The default implementation returns {@code null},
+		 * what will lead in a default message to be displayed in the undo window.
+		 * Don't call the super method, when overriding this method.
+		 *
+		 * @return The title for a special string.
+		 */
+		public String getTitle() {
+			return null;
+		}
+
+		/**
+		 * Discard the undo, meaning the user has no longer the possibility to undo the deletion.
+		 * Implement this, to finally delete your stuff from permanent storages like databases
+		 * (whereas in onKeyDown(int, android.view.KeyEvent) you should only remove it from the
+		 * list adapter).
+		 */
+		public void discard() {
+		}
+
+	}
+
+	/**
+	 * Defines the style in which <i>undos</i> should be displayed and handled in the list.
+	 */
+	public enum UndoStyle {
+
+		/**
+		 * Shows a popup window, that allows the user to undo the last
+		 * dismiss. If another element is deleted, the undo popup will undo that deletion.
+		 * The user is only able to undo the last deletion.
+		 */
+		SINGLE_POPUP,
+
+		/**
+		 * Shows a popup window, that allows the user to undo the last dismiss.
+		 * If another item is deleted, this will be added to the chain of undos. So pressing
+		 * undo will undo the last deletion, pressing it again will undo the deletion before that,
+		 * and so on. As soon as the popup vanished (e.g. because {@link #setUndoHideDelay(int) autoHideDelay}
+		 * is over) all saved undos will be discarded.
+		 */
+		MULTILEVEL_POPUP,
+
+		/**
+		 * Shows a popup window, that allows the user to undo the last dismisses.
+		 * If another item is deleted, while there is still an undo popup visible, the label
+		 * of the button changes to <i>Undo all</i> and a press on the button, will discard
+		 * all stored undos. As soon as the popup vanished (e.g. because {@link #setUndoHideDelay(int) autoHideDelay}
+		 * is over) all saved undos will be discarded.
+		 */
+		COLLAPSED_POPUP
+
+	}
+
+	private class PendingDismissData implements Comparable<PendingDismissData> {
+
+		public int position;
+		/**
+		 * The view that should get swiped out.
+		 */
+		public View view;
+		/**
+		 * The whole list item view.
+		 */
+		public View childView;
+
+		PendingDismissData(int position, View view, View childView) {
+			this.position = position;
+			this.view = view;
+			this.childView = childView;
+		}
+
+		@Override
+		public int compareTo(@NonNull PendingDismissData other) {
+			// Sort by descending position
+			return other.position - position;
+		}
+
+	}
+
+	private class UndoClickListener implements View.OnClickListener {
+
+		/**
+		 * Called when a view has been clicked.
+		 *
+		 * @param v The view that was clicked.
+		 */
+		@Override
+		public void onClick(View v) {
+			if (!mUndoActions.isEmpty()) {
+				switch (mUndoStyle) {
+					case SINGLE_POPUP:
+						mUndoActions.get(0).undo();
+						mUndoActions.clear();
+						break;
+					case COLLAPSED_POPUP:
+						Collections.reverse(mUndoActions);
+						for (Undoable undo : mUndoActions) {
+							undo.undo();
+						}
+						mUndoActions.clear();
+						break;
+					case MULTILEVEL_POPUP:
+						mUndoActions.get(mUndoActions.size() - 1).undo();
+						mUndoActions.remove(mUndoActions.size() - 1);
+						break;
+				}
+			}
+
+			// Dismiss dialog or change text
+			if (mUndoActions.isEmpty()) {
+				if (mUndoPopup.isShowing()) {
+					mUndoPopup.dismiss();
+				}
+			} else {
+				changePopupText();
+				changeButtonLabel();
+			}
+
+			mValidDelayedMsgId++;
+		}
+	}
+
+	private class HideUndoPopupHandler extends Handler {
+
+		/**
+		 * Subclasses must implement this to receive messages.
+		 */
+		@Override
+		public void handleMessage(Message msg) {
+			if (msg.what == mValidDelayedMsgId) {
+				discardUndo();
+			}
+		}
+	}
+
+	/**
+	 * The callback interface used by {@link SwipeDismissListViewTouchListener} to inform its client
+	 * about a successful dismissal of one or more list item positions.
+	 */
+	public interface DismissCallbacks {
+		/**
+		 * Called to determine whether the given position can be dismissed.
+		 */
+		boolean canDismiss(int position);
+
+		/**
+		 * Called when the user has indicated they she would like to dismiss one or more list item
+		 * positions.
+		 *
+		 * @param position               Position to dismiss
+		 */
+		Undoable onDismiss(int position);
+
+		/**
+		 * Called when popup is going to be hidden after time expired (not when UNDO clicked)
+		 */
+		void onHidePopup();
+	}
+
+	/**
+	 * Constructs a new swipe-to-dismiss touch listener for the given list view.
+	 *
+	 * @param listView  The list view whose items should be dismissable.
+	 * @param callbacks The callback to trigger when the user has indicated that she would like to
+	 *                  dismiss one or more list items.
+	 */
+	public SwipeDismissListViewTouchListener(ListView listView, DismissCallbacks callbacks) {
+		ViewConfiguration vc = ViewConfiguration.get(listView.getContext());
+		mSlop = vc.getScaledTouchSlop();
+		mMinFlingVelocity = vc.getScaledMinimumFlingVelocity() * 16;
+		mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
+		mAnimationTime = listView.getContext().getResources().getInteger(
+				android.R.integer.config_shortAnimTime);
+		mListView = listView;
+		mCallbacks = callbacks;
+
+		// Initialize undo popup
+		LayoutInflater inflater = (LayoutInflater) listView.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+		View undoView = inflater.inflate(R.layout.undo_popup, null);
+		mUndoButton = (Button) undoView.findViewById(R.id.undo);
+		mUndoButton.setOnClickListener(new UndoClickListener());
+		mUndoButton.setOnTouchListener(new View.OnTouchListener() {
+			@Override
+			public boolean onTouch(View v, MotionEvent event) {
+				// If the user touches the screen invalidate the current running delay by incrementing
+				// the valid message id. So this delay won't hide the undo popup anymore
+				mValidDelayedMsgId++;
+				return false;
+			}
+		});
+		mUndoPopupTextView = (TextView) undoView.findViewById(R.id.text);
+
+		mUndoPopup = new PopupWindow(undoView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, false);
+		mUndoPopup.setAnimationStyle(R.style.Animations_PopUpMenu_Fade);
+
+		mScreenDensity = listView.getResources().getDisplayMetrics().density;
+		// END initialize undo popup
+
+		mListView.setOnTouchListener(this);
+		// Setting this scroll listener is required to ensure that during ListView scrolling,
+		// we don't look for swipes.
+		mListView.setOnScrollListener(makeScrollListener());
+	}
+
+	/**
+	 * Enables or disables (pauses or resumes) watching for swipe-to-dismiss gestures.
+	 *
+	 * @param enabled Whether or not to watch for gestures.
+	 */
+	public void setEnabled(boolean enabled) {
+		mSwipePaused = !enabled;
+	}
+
+	/**
+	 * Sets the undo style of this list.
+	 *
+	 * @param undoStyle The style of this listview.
+	 */
+	public void setUndoStyle(UndoStyle undoStyle) {
+		mUndoStyle = undoStyle;
+	}
+
+	/**
+	 * Sets the time in milliseconds after which the undo popup automatically disappears.
+	 * The countdown will start when the user touches the screen. If you want to start the countdown
+	 * immediately when the popups appears, call {@link #setRequireTouchBeforeDismiss(boolean)} with
+	 * {@code false}.
+	 *
+	 * @param hideDelay The delay in milliseconds.
+	 */
+	public void setUndoHideDelay(int hideDelay) {
+		mUndoHideDelay = hideDelay;
+	}
+
+	/**
+	 * Sets whether another touch on the view is required before the popup counts down to dismiss
+	 * the undo popup. By default this is set to {@code true}.
+	 *
+	 * @param touchBeforeDismiss Whether the screen needs to be touched before the countdown starts.
+	 * @see #setUndoHideDelay(int)
+	 */
+	public void setRequireTouchBeforeDismiss(boolean touchBeforeDismiss) {
+		mTouchBeforeAutoHide = touchBeforeDismiss;
+	}
+
+	/**
+	 * Sets the directions in which a list item can be swiped to delete.
+	 * By default this is set to {@link SwipeDirection#BOTH} so that an item
+	 * can be swiped into both directions.
+	 */
+	public void setSwipeDirection(SwipeDirection direction) {
+		mSwipeDirection = direction;
+	}
+
+	/**
+	 * Sets the id of the view, that should be moved, when the user swipes an item.
+	 * Only the view with the specified id will move, while all other views in the list item, will
+	 * stay where they are. This might be usefull to have a background behind the view that is swiped
+	 * out, to stay where it is (and maybe explain that the item is going to be deleted).
+	 * If you never call this method (or call it with 0), the whole view will be swiped. Also if there
+	 * is no view in a list item, with the given id, the whole view will be swiped.
+	 */
+	public void setSwipingLayout(int swipingLayoutId) {
+		mSwipingLayout = swipingLayoutId;
+	}
+
+	/**
+	 * Discard all stored undos and hide the undo popup dialog.
+	 * This method must be called in {@link android.app.Activity#onStop()}. Otherwise
+	 * might not be called for several items, what might
+	 * break your data consistency.
+	 */
+	public void discardUndo() {
+		for (Undoable undoable : mUndoActions) {
+			undoable.discard();
+		}
+		mUndoActions.clear();
+		if (mCallbacks != null) {
+			mCallbacks.onHidePopup();
+		}
+		if (mUndoPopup.isShowing()) {
+			mUndoPopup.dismiss();
+		}
+	}
+
+	/**
+	 * Delete the list item at the specified position. This will animate the item sliding out of the
+	 * list and then collapsing until it vanished (same as if the user slides out an item).
+	 * <p/>
+	 * NOTE: If you are using list headers, be aware, that the position argument must take care of
+	 * them. Meaning 0 references the first list header. So if you want to delete the first list
+	 * item, you have to pass the number of list headers as {@code position}. Most of the times
+	 * that shouldn't be a problem, since you most probably will evaluate the position which should
+	 * be deleted in a way, that respects the list headers.
+	 */
+	public void delete(int position) {
+		if (mCallbacks == null) {
+			throw new IllegalStateException("You must set an OnDismissCallback, before deleting items.");
+		}
+		if (position < 0 || position >= mListView.getCount()) {
+			throw new IndexOutOfBoundsException(String.format("Tried to delete item %d. #items in list: %d", position, mListView.getCount()));
+		}
+		View childView = mListView.getChildAt(position - mListView.getFirstVisiblePosition());
+		View view = null;
+		if (mSwipingLayout > 0) {
+			view = childView.findViewById(mSwipingLayout);
+		}
+		if (view == null) {
+			view = childView;
+		}
+		slideOutView(view, childView, position, true);
+	}
+
+	/**
+	 * Slide out a view to the right or left of the list. After the animation has finished, the
+	 * view will be dismissed by calling {@link #performDismiss(android.view.View, android.view.View, int)}.
+	 *
+	 * @param view        The view, that should be slided out.
+	 * @param childView   The whole view of the list item.
+	 * @param position    The item position of the item.
+	 * @param toRightSide Whether it should slide out to the right side.
+	 */
+	private void slideOutView(final View view, final View childView, final int position, boolean toRightSide) {
+
+		// Only start new animation, if this view isn't already animated (too fast swiping bug)
+		synchronized (mAnimationLock) {
+			if (mAnimatedViews.contains(view)) {
+				return;
+			}
+			++mDismissAnimationRefCount;
+			mAnimatedViews.add(view);
+		}
+
+		ViewCompat.animate(view)
+				.translationX(toRightSide ? mViewWidth : -mViewWidth)
+				.alpha(0)
+				.setDuration(mAnimationTime)
+				.setListener(new ViewPropertyAnimatorListener() {
+					@Override
+					public void onAnimationStart(View view) {
+					}
+
+					@Override
+					public void onAnimationEnd(View view) {
+						performDismiss(view, childView, position);
+					}
+
+					@Override
+					public void onAnimationCancel(View view) {
+
+					}
+				});
+	}
+
+	/**
+	 * Returns an {@link AbsListView.OnScrollListener} to be added to the {@link
+	 * ListView} using {@link ListView#setOnScrollListener(AbsListView.OnScrollListener)}.
+	 * If a scroll listener is already assigned, the caller should still pass scroll changes through
+	 * to this listener. This will ensure that this {@link SwipeDismissListViewTouchListener} is
+	 * paused during list view scrolling.</p>
+	 *
+	 * @see SwipeDismissListViewTouchListener
+	 */
+	public AbsListView.OnScrollListener makeScrollListener() {
+		return new AbsListView.OnScrollListener() {
+			@Override
+			public void onScrollStateChanged(AbsListView absListView, int scrollState) {
+				setEnabled(scrollState != AbsListView.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
+			}
+
+			@Override
+			public void onScroll(AbsListView absListView, int i, int i1, int i2) {
+			}
+		};
+	}
+
+	@Override
+	public boolean onTouch(View view, MotionEvent ev) {
+		if (mViewWidth < 2) {
+			mViewWidth = mListView.getWidth();
+		}
+
+		switch (ev.getActionMasked()) {
+			case MotionEvent.ACTION_DOWN: {
+				if (mSwipePaused) {
+					return false;
+				}
+
+				// TODO: ensure this is a finger, and set a flag
+
+				// Find the child view that was touched (perform a hit test)
+				Rect rect = new Rect();
+				int childCount = mListView.getChildCount();
+				int[] listViewCoords = new int[2];
+				mListView.getLocationOnScreen(listViewCoords);
+				int x = (int) ev.getRawX() - listViewCoords[0];
+				int y = (int) ev.getRawY() - listViewCoords[1];
+				View child;
+				for (int i = mListView.getHeaderViewsCount(); i < childCount; i++) {
+					child = mListView.getChildAt(i);
+					if (child != null) {
+						child.getHitRect(rect);
+						if (rect.contains(x, y)) {
+							// if a specific swiping layout has been giving, use this to swipe.
+							if (mSwipingLayout > 0) {
+								View swipingView = child.findViewById(mSwipingLayout);
+								if (swipingView != null) {
+									mSwipeDownView = swipingView;
+									mSwipeDownChild = child;
+									break;
+								}
+							}
+							// If no swiping layout has been found, swipe the whole child
+							mSwipeDownView = mSwipeDownChild = child;
+							break;
+						}
+					}
+				}
+
+				if (mSwipeDownView != null) {
+					// test if the item should be swiped
+					int position = mListView.getPositionForView(mSwipeDownView) - mListView.getHeaderViewsCount();
+					if (mCallbacks == null || mCallbacks.canDismiss(position)) {
+						mDownX = ev.getRawX();
+						mDownPosition = position;
+
+						mVelocityTracker = VelocityTracker.obtain();
+						mVelocityTracker.addMovement(ev);
+					} else {
+						// set back to null to revert swiping
+						mSwipeDownView = mSwipeDownChild = null;
+					}
+				}
+				return false;
+			}
+
+			case MotionEvent.ACTION_CANCEL: {
+				if (mVelocityTracker == null) {
+					break;
+				}
+
+				if (mSwipeDownView != null && mSwiping) {
+					// cancel
+					ViewCompat.animate(mSwipeDownView)
+							.translationX(0)
+							.alpha(1)
+							.setDuration(mAnimationTime)
+							.setListener(null);
+				}
+				mVelocityTracker.recycle();
+				mVelocityTracker = null;
+				mDownX = 0;
+				mSwipeDownView = mSwipeDownChild = null;
+				mDownPosition = ListView.INVALID_POSITION;
+				mSwiping = false;
+				break;
+			}
+
+			case MotionEvent.ACTION_UP: {
+				if (mVelocityTracker == null) {
+					break;
+				}
+
+				float deltaX = ev.getRawX() - mDownX;
+				mVelocityTracker.addMovement(ev);
+				mVelocityTracker.computeCurrentVelocity(1000);
+				float velocityX = Math.abs(mVelocityTracker.getXVelocity());
+				float velocityY = Math.abs(mVelocityTracker.getYVelocity());
+				boolean dismiss = false;
+				boolean dismissRight = false;
+				if (Math.abs(deltaX) > mViewWidth / 2 && mSwiping) {
+					dismiss = true;
+					dismissRight = deltaX > 0;
+				} else if (mMinFlingVelocity <= velocityX && velocityX <= mMaxFlingVelocity
+						&& velocityY < velocityX && mSwiping && isSwipeDirectionValid(mVelocityTracker.getXVelocity())
+						&& deltaX >= mViewWidth * 0.2f) {
+					dismiss = true;
+					dismissRight = mVelocityTracker.getXVelocity() > 0;
+				}
+				if (dismiss) {
+					// dismiss
+					slideOutView(mSwipeDownView, mSwipeDownChild, mDownPosition, dismissRight);
+				} else if (mSwiping) {
+					// Swipe back to regular position
+					ViewCompat.animate(mSwipeDownView)
+							.translationX(0)
+							.alpha(1)
+							.setDuration(mAnimationTime)
+							.setListener(null);
+				}
+				mVelocityTracker = null;
+				mDownX = 0;
+				mSwipeDownView = null;
+				mSwipeDownChild = null;
+				mDownPosition = AbsListView.INVALID_POSITION;
+				mSwiping = false;
+				break;
+			}
+
+			case MotionEvent.ACTION_MOVE: {
+				if (mVelocityTracker == null || mSwipePaused) {
+					break;
+				}
+
+				mVelocityTracker.addMovement(ev);
+				float deltaX = ev.getRawX() - mDownX;
+				// Only start swipe in correct direction
+				if (isSwipeDirectionValid(deltaX)) {
+					ViewParent parent = mListView.getParent();
+					if (parent != null) {
+						// If we swipe don't allow parent to intercept touch (e.g. like NavigationDrawer does)
+						// otherwise swipe would not be working.
+						parent.requestDisallowInterceptTouchEvent(true);
+					}
+					if (Math.abs(deltaX) > mSlop) {
+						mSwiping = true;
+						mListView.requestDisallowInterceptTouchEvent(true);
+
+						// Cancel ListView's touch (un-highlighting the item)
+						MotionEvent cancelEvent = MotionEvent.obtain(ev);
+						cancelEvent.setAction(MotionEvent.ACTION_CANCEL
+								| (ev.getActionIndex()
+								<< MotionEvent.ACTION_POINTER_INDEX_SHIFT));
+						mListView.onTouchEvent(cancelEvent);
+					}
+				} else {
+					// If we swiped into wrong direction, act like this was the new
+					// touch down point
+					mDownX = ev.getRawX();
+					deltaX = 0;
+				}
+
+				if (mSwiping) {
+					mSwipeDownView.setTranslationX(deltaX);
+					mSwipeDownView.setAlpha(Math.max(0f, Math.min(1f,
+							1f - 2f * Math.abs(deltaX) / mViewWidth)));
+					return true;
+				}
+				break;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Animate the dismissed list item to zero-height and fire the dismiss callback when
+	 * all dismissed list item animations have completed.
+	 *
+	 * @param dismissView     The view that has been slided out.
+	 * @param listItemView    The list item view. This is the whole view of the list item, and not just
+	 *                        the part, that the user swiped.
+	 * @param dismissPosition The position of the view inside the list.
+	 */
+	private void performDismiss(final View dismissView, final View listItemView, final int dismissPosition) {
+
+		final ViewGroup.LayoutParams lp = listItemView.getLayoutParams();
+		final int originalLayoutHeight = lp.height;
+
+		if (android.os.Build.VERSION.SDK_INT < 12) {
+			mPendingDismisses.add(new PendingDismissData(dismissPosition, dismissView, listItemView));
+			finishDismiss(dismissView, originalLayoutHeight);
+		} else {
+			int originalHeight = listItemView.getHeight();
+			ValueAnimator animator = ValueAnimator.ofInt(originalHeight, 1).setDuration(mAnimationTime);
+
+			animator.addListener(new AnimatorListenerAdapter() {
+				@Override
+				public void onAnimationEnd(Animator animation) {
+					finishDismiss(dismissView, originalLayoutHeight);
+				}
+			});
+
+			animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
+				@Override
+				public void onAnimationUpdate(ValueAnimator valueAnimator) {
+					lp.height = (Integer) valueAnimator.getAnimatedValue();
+					listItemView.setLayoutParams(lp);
+				}
+			});
+
+			mPendingDismisses.add(new PendingDismissData(dismissPosition, dismissView, listItemView));
+			animator.start();
+		}
+	}
+
+	private void finishDismiss(View dismissView, int originalLayoutHeight) {
+		// Make sure no other animation is running. Remove animation from running list, that just finished
+		boolean noAnimationLeft;
+		synchronized (mAnimationLock) {
+			--mDismissAnimationRefCount;
+			mAnimatedViews.remove(dismissView);
+			noAnimationLeft = mDismissAnimationRefCount == 0;
+		}
+
+		if (noAnimationLeft) {
+			// No active animations, process all pending dismisses.
+
+			for (PendingDismissData dismiss : mPendingDismisses) {
+				if (mUndoStyle == UndoStyle.SINGLE_POPUP) {
+					for (Undoable undoable : mUndoActions) {
+						undoable.discard();
+					}
+					mUndoActions.clear();
+				}
+				Undoable undoable = mCallbacks.onDismiss(dismiss.position);
+				if (undoable != null) {
+					mUndoActions.add(undoable);
+				}
+				mValidDelayedMsgId++;
+			}
+
+			if (!mUndoActions.isEmpty()) {
+				changePopupText();
+				changeButtonLabel();
+
+				// Show undo popup
+				float yLocationOffset = mListView.getResources().getDimension(R.dimen.undo_bottom_offset);
+				mUndoPopup.setWidth((int) Math.min(mScreenDensity * 400, mListView.getWidth() * 0.9f));
+				mUndoPopup.showAtLocation(mListView,
+						Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM,
+						0, (int) yLocationOffset);
+
+				// Queue the dismiss only if required
+				if (!mTouchBeforeAutoHide) {
+					// Send a delayed message to hide popup
+					mHideUndoHandler.sendMessageDelayed(mHideUndoHandler.obtainMessage(mValidDelayedMsgId),
+							mUndoHideDelay);
+				}
+			}
+
+			ViewGroup.LayoutParams lp;
+			for (PendingDismissData pendingDismiss : mPendingDismisses) {
+				pendingDismiss.view.setAlpha(1f);
+				pendingDismiss.view.setTranslationX(0);
+				lp = pendingDismiss.childView.getLayoutParams();
+				lp.height = originalLayoutHeight;
+				pendingDismiss.childView.setLayoutParams(lp);
+			}
+
+			mPendingDismisses.clear();
+		}
+	}
+
+	/**
+	 * Changes the text of the undo popup. If more then one item can be undone, the number of deleted
+	 * items will be shown. If only one deletion can be undone, the title of this deletion (or a default
+	 * string in case the title is {@code null}) will be shown.
+	 */
+	private void changePopupText() {
+		String msg = null;
+		if (mUndoActions.size() > 1) {
+			msg = mUndoActions.size() + " " + mListView.getResources().getString(R.string.n_items_deleted);
+		} else if (mUndoActions.size() >= 1) {
+			// Set title from single undoable or when no multiple deletion string
+			// is given
+			msg = mUndoActions.get(mUndoActions.size() - 1).getTitle();
+
+			if (msg == null) {
+				msg = mListView.getResources().getString(R.string.item_deleted);
+			}
+		}
+		mUndoPopupTextView.setText(msg);
+	}
+
+	/**
+	 * Changes the label of the undo button.
+	 */
+	private void changeButtonLabel() {
+		String msg;
+		if (mUndoActions.size() > 1 && mUndoStyle == UndoStyle.COLLAPSED_POPUP) {
+			msg = mListView.getResources().getString(R.string.shared_string_undo_all);
+		} else {
+			msg = mListView.getResources().getString(R.string.shared_string_undo);
+		}
+		mUndoButton.setText(msg);
+	}
+
+	private boolean isSwipeDirectionValid(float deltaX) {
+
+		int rtlSign = 1;
+		// On API level 17 and above, check if we are in a Right-To-Left layout
+		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
+			if (mListView.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
+				rtlSign = -1;
+			}
+		}
+
+		// Check if swipe has been done in the correct direction
+		switch (mSwipeDirection) {
+			default:
+			case BOTH:
+				return true;
+			case START:
+				return rtlSign * deltaX < 0;
+			case END:
+				return rtlSign * deltaX > 0;
+		}
+	}
+}
+
