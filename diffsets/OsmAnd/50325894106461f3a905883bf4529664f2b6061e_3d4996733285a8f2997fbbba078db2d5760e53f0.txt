diff --git a/OsmAnd-telegram/src/net/osmand/telegram/TelegramSettings.kt b/OsmAnd-telegram/src/net/osmand/telegram/TelegramSettings.kt
index 6a75cbc8423..8abe5a87b38 100644
--- a/OsmAnd-telegram/src/net/osmand/telegram/TelegramSettings.kt
+++ b/OsmAnd-telegram/src/net/osmand/telegram/TelegramSettings.kt
@@ -204,13 +204,27 @@ class TelegramSettings(private val app: TelegramApplication) {
 
 	fun prepareForSharingNewMessages() {
 		shareChatsInfo.forEach { (_, shareInfo) ->
-			shareInfo.pendingTdLibText = 0
-			shareInfo.pendingTdLibMap = 0
-			shareInfo.pendingTextMessage = false
-			shareInfo.pendingMapMessage = false
+			prepareForSharingNewMessages(shareInfo)
 		}
 	}
 
+	fun prepareForSharingNewMessages(chatsIds: List<Long>) {
+		chatsIds.forEach {
+			shareChatsInfo[it]?.also { shareInfo ->
+				prepareForSharingNewMessages(shareInfo)
+			}
+		}
+	}
+
+	fun prepareForSharingNewMessages(shareInfo: ShareChatInfo) {
+		shareInfo.pendingTdLibText = 0
+		shareInfo.pendingTdLibMap = 0
+		shareInfo.currentTextMessageId = -1L
+		shareInfo.currentMapMessageId = -1L
+		shareInfo.pendingTextMessage = false
+		shareInfo.pendingMapMessage = false
+	}
+
 	fun getChatLivePeriod(chatId: Long) = shareChatsInfo[chatId]?.livePeriod
 
 	fun getChatsShareInfo() = shareChatsInfo
@@ -228,7 +242,11 @@ class TelegramSettings(private val app: TelegramApplication) {
 
 	fun getCurrentSharingDevice() = shareDevices.singleOrNull { it.externalId == currentSharingMode }
 
-	fun getLastSuccessfulSendTime() = shareChatsInfo.values.maxBy { it.lastSuccessfulSendTime }?.lastSuccessfulSendTime ?: -1
+	fun getLastSuccessfulSendTime(): Long {
+		val lastSuccessTextSend = shareChatsInfo.values.maxBy { it.lastTextSuccessfulSendTime }?.lastTextSuccessfulSendTime ?: -1
+		val lastSuccessMapSend = shareChatsInfo.values.maxBy { it.lastMapSuccessfulSendTime }?.lastMapSuccessfulSendTime ?: -1
+		return Math.max(lastSuccessTextSend, lastSuccessMapSend)
+	}
 
 	fun stopSharingLocationToChats() {
 		shareChatsInfo.clear()
@@ -285,7 +303,7 @@ class TelegramSettings(private val app: TelegramApplication) {
 					} else {
 						shareInfo.currentMapMessageId = message.id
 						shareInfo.pendingMapMessage = false
-						shareInfo.lastSuccessfulSendTime = Math.max(message.editDate, message.date).toLong()
+						shareInfo.lastMapSuccessfulSendTime = System.currentTimeMillis() / 1000
 						if (!isOsmAndBot) {
 							shareInfo.pendingTdLibMap--
 							if (shareTypeValue == SHARE_TYPE_MAP) {
@@ -316,7 +334,7 @@ class TelegramSettings(private val app: TelegramApplication) {
 						shareInfo.currentTextMessageId = message.id
 						shareInfo.updateTextMessageId++
 						shareInfo.pendingTextMessage = false
-						shareInfo.lastSuccessfulSendTime = Math.max(message.editDate, message.date).toLong()
+						shareInfo.lastTextSuccessfulSendTime = System.currentTimeMillis() / 1000
 						if (!isOsmAndBot) {
 							shareInfo.pendingTdLibText--
 							shareInfo.sentMessages++
@@ -341,7 +359,7 @@ class TelegramSettings(private val app: TelegramApplication) {
 				lastSharingStatus.apply {
 					statusChangeTime = newSharingStatus.statusChangeTime
 					locationTime = newSharingStatus.locationTime
-					chatsTitles = newSharingStatus.chatsTitles
+					chatsIds = newSharingStatus.chatsIds
 					title = newSharingStatus.title
 
 					if (statusType == SharingStatusType.INITIALIZING
@@ -406,18 +424,16 @@ class TelegramSettings(private val app: TelegramApplication) {
 			var sendChatsErrors = false
 
 			shareChatsInfo.forEach { (_, shareInfo) ->
-				if (shareInfo.lastSuccessfulSendTime == -1L && ((statusChangeTime / 1000 - shareInfo.start) < SHARING_INITIALIZATION_TIME)) {
+				if (shareInfo.lastTextSuccessfulSendTime == -1L && shareInfo.lastMapSuccessfulSendTime == -1L
+					&& ((statusChangeTime / 1000 - shareInfo.start) < SHARING_INITIALIZATION_TIME)) {
 					initializing = true
 				} else if (shareInfo.hasSharingError
-					|| (shareInfo.lastSuccessfulSendTime - shareInfo.lastSendTextMessageTime > WAITING_TDLIB_TIME)
-					|| (shareInfo.lastSuccessfulSendTime - shareInfo.lastSendMapMessageTime > WAITING_TDLIB_TIME)
+					|| (shareInfo.lastSendTextMessageTime - shareInfo.lastTextSuccessfulSendTime > WAITING_TDLIB_TIME)
+					|| (shareInfo.lastSendMapMessageTime - shareInfo.lastMapSuccessfulSendTime > WAITING_TDLIB_TIME)
 				) {
 					sendChatsErrors = true
-					locationTime = shareInfo.lastSuccessfulSendTime
-					val title = app.telegramHelper.getChat(shareInfo.chatId)?.title
-					if (title != null) {
-						chatsTitles.add(title)
-					}
+					locationTime = Math.max(shareInfo.lastTextSuccessfulSendTime, shareInfo.lastMapSuccessfulSendTime)
+					chatsIds.add(shareInfo.chatId)
 				}
 			}
 
@@ -567,7 +583,8 @@ class TelegramSettings(private val app: TelegramApplication) {
 		val shareTypeDef = SHARE_TYPE_VALUES[SHARE_TYPE_DEFAULT_INDEX]
 		shareTypeValue = prefs.getString(SHARE_TYPE_KEY, shareTypeDef)
 
-		currentSharingMode = prefs.getString(SHARING_MODE_KEY, "")
+		val currentUserId = app.telegramHelper.getCurrentUserId()
+		currentSharingMode = prefs.getString(SHARING_MODE_KEY, if (currentUserId != -1) currentUserId.toString() else "")
 
 		val defPackage = if (AppConnect.getInstalledApps(app).size == 1) AppConnect.getInstalledApps(app).first().appPackage else ""
 		appToConnectPackage = prefs.getString(APP_TO_CONNECT_PACKAGE_KEY, defPackage)
@@ -619,7 +636,8 @@ class TelegramSettings(private val app: TelegramApplication) {
 				obj.put(ShareChatInfo.CURRENT_TEXT_MESSAGE_ID_KEY, chatInfo.currentTextMessageId)
 				obj.put(ShareChatInfo.USER_SET_LIVE_PERIOD_KEY, chatInfo.userSetLivePeriod)
 				obj.put(ShareChatInfo.USER_SET_LIVE_PERIOD_START_KEY, chatInfo.userSetLivePeriodStart)
-				obj.put(ShareChatInfo.LAST_SUCCESSFUL_SEND_TIME_KEY, chatInfo.lastSuccessfulSendTime)
+				obj.put(ShareChatInfo.LAST_TEXT_SUCCESSFUL_SEND_TIME_KEY, chatInfo.lastTextSuccessfulSendTime)
+				obj.put(ShareChatInfo.LAST_MAP_SUCCESSFUL_SEND_TIME_KEY, chatInfo.lastMapSuccessfulSendTime)
 				obj.put(ShareChatInfo.LAST_SEND_MAP_TIME_KEY, chatInfo.lastSendMapMessageTime)
 				obj.put(ShareChatInfo.LAST_SEND_TEXT_TIME_KEY, chatInfo.lastSendTextMessageTime)
 				obj.put(ShareChatInfo.PENDING_TEXT_MESSAGE_KEY, chatInfo.pendingTextMessage)
@@ -648,7 +666,8 @@ class TelegramSettings(private val app: TelegramApplication) {
 				currentTextMessageId = obj.optLong(ShareChatInfo.CURRENT_TEXT_MESSAGE_ID_KEY)
 				userSetLivePeriod = obj.optLong(ShareChatInfo.USER_SET_LIVE_PERIOD_KEY)
 				userSetLivePeriodStart = obj.optLong(ShareChatInfo.USER_SET_LIVE_PERIOD_START_KEY)
-				lastSuccessfulSendTime = obj.optLong(ShareChatInfo.LAST_SUCCESSFUL_SEND_TIME_KEY)
+				lastTextSuccessfulSendTime = obj.optLong(ShareChatInfo.LAST_TEXT_SUCCESSFUL_SEND_TIME_KEY)
+				lastMapSuccessfulSendTime = obj.optLong(ShareChatInfo.LAST_MAP_SUCCESSFUL_SEND_TIME_KEY)
 				lastSendMapMessageTime = obj.optInt(ShareChatInfo.LAST_SEND_MAP_TIME_KEY)
 				lastSendTextMessageTime = obj.optInt(ShareChatInfo.LAST_SEND_TEXT_TIME_KEY)
 				pendingTextMessage = obj.optBoolean(ShareChatInfo.PENDING_TEXT_MESSAGE_KEY)
@@ -913,22 +932,25 @@ class TelegramSettings(private val app: TelegramApplication) {
 		var description: String = ""
 		var locationTime: Long = -1
 		var statusChangeTime: Long = -1
-		var chatsTitles: MutableList<String> = mutableListOf()
+		var chatsIds: MutableList<Long> = mutableListOf()
 
 		lateinit var statusType: SharingStatusType
 
 		fun getTitle(app: TelegramApplication): CharSequence {
-			return if (statusType != SharingStatusType.NOT_POSSIBLE_TO_SENT_TO_CHATS || chatsTitles.isEmpty()) {
+			return if (statusType != SharingStatusType.NOT_POSSIBLE_TO_SENT_TO_CHATS || chatsIds.isEmpty()) {
 				title
 			} else {
 				val spannableString = SpannableStringBuilder(title)
-				val iterator = chatsTitles.iterator()
+				val iterator = chatsIds.iterator()
 				while (iterator.hasNext()) {
-					val chatTitle = iterator.next()
-					val start = spannableString.length
-					val newSpannable = if (iterator.hasNext()) " @$chatTitle," else " @$chatTitle."
-					spannableString.append(newSpannable)
-					spannableString.setSpan(ForegroundColorSpan(app.uiUtils.getActiveColor()), start, spannableString.length - 1, 0)
+					val chatId = iterator.next()
+					val chatTitle = app.telegramHelper.getChat(chatId)?.title
+					if (chatTitle != null) {
+						val start = spannableString.length
+						val newSpannable = if (iterator.hasNext()) " @$chatTitle," else " @$chatTitle."
+						spannableString.append(newSpannable)
+						spannableString.setSpan(ForegroundColorSpan(app.uiUtils.getActiveColor()), start, spannableString.length - 1, 0)
+					}
 				}
 				spannableString
 			}
@@ -949,7 +971,8 @@ class TelegramSettings(private val app: TelegramApplication) {
 		var oldTextMessageId = -1L
 		var userSetLivePeriod = -1L
 		var userSetLivePeriodStart = -1L
-		var lastSuccessfulSendTime = -1L
+		var lastTextSuccessfulSendTime = -1L
+		var lastMapSuccessfulSendTime = -1L
 		var lastSendTextMessageTime = -1
 		var lastSendMapMessageTime = -1
 		var sentMessages = 0
@@ -960,8 +983,6 @@ class TelegramSettings(private val app: TelegramApplication) {
 		var shouldSendViaBotTextMessage = false
 		var shouldSendViaBotMapMessage = false
 		var hasSharingError = false
-		var shouldDeletePreviousMapMessage = false
-		var shouldDeletePreviousTextMessage = false
 		var additionalActiveTime = ADDITIONAL_ACTIVE_TIME_VALUES_SEC[0]
 
 		fun getPendingTdLib() = pendingTdLibText + pendingTdLibMap
@@ -991,7 +1012,8 @@ class TelegramSettings(private val app: TelegramApplication) {
 			internal const val CURRENT_TEXT_MESSAGE_ID_KEY = "currentTextMessageId"
 			internal const val USER_SET_LIVE_PERIOD_KEY = "userSetLivePeriod"
 			internal const val USER_SET_LIVE_PERIOD_START_KEY = "userSetLivePeriodStart"
-			internal const val LAST_SUCCESSFUL_SEND_TIME_KEY = "lastSuccessfulSendTime"
+			internal const val LAST_MAP_SUCCESSFUL_SEND_TIME_KEY = "lastMapSuccessfulSendTime"
+			internal const val LAST_TEXT_SUCCESSFUL_SEND_TIME_KEY = "lastTextSuccessfulSendTime"
 			internal const val LAST_SEND_MAP_TIME_KEY = "lastSendMapMessageTime"
 			internal const val LAST_SEND_TEXT_TIME_KEY = "lastSendTextMessageTime"
 			internal const val PENDING_TEXT_MESSAGE_KEY = "pendingTextMessage"
diff --git a/OsmAnd-telegram/src/net/osmand/telegram/helpers/ShareLocationHelper.kt b/OsmAnd-telegram/src/net/osmand/telegram/helpers/ShareLocationHelper.kt
index 65643cb3694..125d71ee689 100644
--- a/OsmAnd-telegram/src/net/osmand/telegram/helpers/ShareLocationHelper.kt
+++ b/OsmAnd-telegram/src/net/osmand/telegram/helpers/ShareLocationHelper.kt
@@ -76,16 +76,12 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 									livePeriod
 								}
 							livePeriod = newLivePeriod
-							shouldDeletePreviousMapMessage = true
-							shouldDeletePreviousTextMessage = true
 							currentMessageLimit = currentTime + Math.min(newLivePeriod, TelegramHelper.MAX_LOCATION_MESSAGE_LIVE_PERIOD_SEC.toLong())
 						}
 					}
 					shareInfo.userSetLivePeriod != shareInfo.livePeriod
 							&& (shareInfo.userSetLivePeriodStart + USER_SET_LIVE_PERIOD_DELAY_MS) > currentTime -> {
 						shareInfo.apply {
-							shouldDeletePreviousMapMessage = true
-							shouldDeletePreviousTextMessage = true
 							livePeriod = shareInfo.userSetLivePeriod
 							currentMessageLimit = currentTime + Math.min(livePeriod, TelegramHelper.MAX_LOCATION_MESSAGE_LIVE_PERIOD_SEC.toLong())
 						}
@@ -102,7 +98,7 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 		var bufferedMessagesFull = false
 		app.settings.getChatsShareInfo().forEach { (chatId, shareInfo) ->
 			checkAndSendBufferMessagesToChat(chatId)
-			if (shareInfo.getPendingTdLib() > 10) {
+			if (shareInfo.getPendingTdLib() > MAX_MESSAGES_IN_TDLIB_PER_CHAT) {
 				bufferedMessagesFull = true
 			}
 		}
@@ -113,30 +109,31 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 
 	fun checkAndSendBufferMessagesToChat(chatId: Long) {
 		val shareInfo = app.settings.getChatsShareInfo()[chatId]
-		if (shareInfo != null && shareInfo.getPendingTdLib() < 10) {
-			app.locationMessages.getBufferedMessagesForChat(chatId).forEach {
+		if (shareInfo != null) {
+			app.locationMessages.getBufferedMessagesForChat(chatId).take(MAX_MESSAGES_IN_TDLIB_PER_CHAT).forEach {
 				if (it.type == LocationMessages.TYPE_TEXT) {
-					if (it.deviceName.isEmpty()) {
-						if (!shareInfo.pendingTextMessage && shareInfo.currentTextMessageId != -1L) {
-							app.telegramHelper.editTextLocation(shareInfo, it)
-							app.locationMessages.removeBufferedMessage(it)
+					if (shareInfo.pendingTdLibText < MAX_MESSAGES_IN_TDLIB_PER_CHAT) {
+						if (it.deviceName.isEmpty()) {
+							if (!shareInfo.pendingTextMessage && shareInfo.currentTextMessageId != -1L) {
+								app.telegramHelper.editTextLocation(shareInfo, it)
+								app.locationMessages.removeBufferedMessage(it)
+							}
+						} else {
+							sendLocationToBot(it, shareInfo, SHARE_TYPE_TEXT)
 						}
-					} else {
-						sendLocationToBot(it, shareInfo, SHARE_TYPE_TEXT)
 					}
 				} else if (it.type == LocationMessages.TYPE_MAP) {
-					if (it.deviceName.isEmpty()) {
-						if (!shareInfo.pendingMapMessage && shareInfo.currentMapMessageId != -1L) {
-							app.telegramHelper.editMapLocation(shareInfo, it)
-							app.locationMessages.removeBufferedMessage(it)
+					if (shareInfo.pendingTdLibMap < MAX_MESSAGES_IN_TDLIB_PER_CHAT) {
+						if (it.deviceName.isEmpty()) {
+							if (!shareInfo.pendingMapMessage && shareInfo.currentMapMessageId != -1L) {
+								app.telegramHelper.editMapLocation(shareInfo, it)
+								app.locationMessages.removeBufferedMessage(it)
+							}
+						} else {
+							sendLocationToBot(it, shareInfo, SHARE_TYPE_MAP)
 						}
-					} else {
-						sendLocationToBot(it, shareInfo, SHARE_TYPE_MAP)
 					}
 				}
-				if (shareInfo.getPendingTdLib() >= 10) {
-					return
-				}
 			}
 		}
 	}
@@ -194,7 +191,7 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 		var bufferedMessagesFull = false
 
 		chatsShareInfo.values.forEach { shareInfo ->
-			if (shareInfo.getPendingTdLib() >= 10 || app.locationMessages.getBufferedMessagesCountForChat(shareInfo.chatId) >= 10) {
+			if (shareInfo.getPendingTdLib() >= MAX_MESSAGES_IN_TDLIB_PER_CHAT || app.locationMessages.getBufferedMessagesCountForChat(shareInfo.chatId) >= 10) {
 				bufferedMessagesFull = true
 			}
 			when (app.settings.shareTypeValue) {
@@ -240,7 +237,7 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 					app.locationMessages.addBufferedMessage(message)
 				}
 			} else {
-				if (shareInfo.getPendingTdLib() < 10) {
+				if (shareInfo.pendingTdLibText < MAX_MESSAGES_IN_TDLIB_PER_CHAT) {
 					app.telegramHelper.editTextLocation(shareInfo, message)
 				} else {
 					app.locationMessages.addBufferedMessage(message)
@@ -273,7 +270,7 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 					app.locationMessages.addBufferedMessage(message)
 				}
 			} else {
-				if (shareInfo.getPendingTdLib() < 10) {
+				if (shareInfo.pendingTdLibMap < MAX_MESSAGES_IN_TDLIB_PER_CHAT) {
 					app.telegramHelper.editMapLocation(shareInfo, message)
 				} else {
 					app.locationMessages.addBufferedMessage(message)
@@ -297,18 +294,24 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 		if (app.isInternetConnectionAvailable) {
 			log.debug("sendLocationToBot ${locationMessage.deviceName}")
 			val url = getDeviceSharingUrl(locationMessage, locationMessage.deviceName)
-			shareInfo.lastSendTextMessageTime = (System.currentTimeMillis() / 1000).toInt()
-			shareInfo.lastSendTextMessageTime = (System.currentTimeMillis() / 1000).toInt()
+			if (shareType == SHARE_TYPE_TEXT) {
+				shareInfo.lastSendTextMessageTime = (System.currentTimeMillis() / 1000).toInt()
+			} else if (shareType == SHARE_TYPE_MAP) {
+				shareInfo.lastSendMapMessageTime = (System.currentTimeMillis() / 1000).toInt()
+			}
 			AndroidNetworkUtils.sendRequestAsync(app, url, null, "Send Location", false, false,
 				object : AndroidNetworkUtils.OnRequestResultListener {
 					override fun onResult(result: String?) {
-						val chatsShareInfo = app.settings.getChatsShareInfo()
-						val success = checkResultAndUpdateShareInfoSuccessfulSendTime(result, chatsShareInfo)
+						val success = checkResult(result)
 						val osmandBotId = app.telegramHelper.getOsmandBot()?.id ?: -1
 						val device = app.settings.getCurrentSharingDevice()
 						if (success) {
 							shareInfo.sentMessages++
-							shareInfo.lastSuccessfulSendTime = System.currentTimeMillis() / 1000
+							if (shareType == SHARE_TYPE_TEXT) {
+								shareInfo.lastTextSuccessfulSendTime = System.currentTimeMillis() / 1000
+							} else if (shareType == SHARE_TYPE_MAP) {
+								shareInfo.lastMapSuccessfulSendTime = System.currentTimeMillis() / 1000
+							}
 							app.locationMessages.removeBufferedMessage(locationMessage)
 							if ((shareInfo.shouldSendViaBotTextMessage || shareInfo.shouldSendViaBotMapMessage) && osmandBotId != -1 && device != null) {
 								app.telegramHelper.sendViaBotLocationMessage(osmandBotId, shareInfo, TdApi.Location(locationMessage.lat, locationMessage.lon), device, shareType)
@@ -339,18 +342,12 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 		return builder.toString()
 	}
 
-	private fun checkResultAndUpdateShareInfoSuccessfulSendTime(result: String?, chatsShareInfo: Map<Long, TelegramSettings.ShareChatInfo>):Boolean {
+	private fun checkResult(result: String?): Boolean {
 		if (result != null) {
 			try {
 				val jsonResult = JSONObject(result)
 				val status = jsonResult.getString("status")
-				val currentTime = System.currentTimeMillis() / 1000
-				if (status == "OK") {
-					chatsShareInfo.forEach { (_, shareInfo) ->
-						shareInfo.lastSuccessfulSendTime = currentTime
-					}
-					return true
-				}
+				return status == "OK"
 			} catch (e: JSONException) {
 			}
 		}
@@ -365,6 +362,8 @@ class ShareLocationHelper(private val app: TelegramApplication) {
 
 	companion object {
 
+		const val MAX_MESSAGES_IN_TDLIB_PER_CHAT = 10
+
 		// min and max values for the UI
 		const val MIN_LOCATION_MESSAGE_LIVE_PERIOD_SEC = TelegramHelper.MIN_LOCATION_MESSAGE_LIVE_PERIOD_SEC - 1
 		const val MAX_LOCATION_MESSAGE_LIVE_PERIOD_SEC = TelegramHelper.MAX_LOCATION_MESSAGE_LIVE_PERIOD_SEC + 1
diff --git a/OsmAnd-telegram/src/net/osmand/telegram/helpers/TelegramHelper.kt b/OsmAnd-telegram/src/net/osmand/telegram/helpers/TelegramHelper.kt
index 5c2e368d1a3..04750f11ef9 100644
--- a/OsmAnd-telegram/src/net/osmand/telegram/helpers/TelegramHelper.kt
+++ b/OsmAnd-telegram/src/net/osmand/telegram/helpers/TelegramHelper.kt
@@ -137,7 +137,7 @@ class TelegramHelper private constructor() {
 
 	fun getChat(id: Long) = chats[id]
 
-	fun getUser(id: Int) = users[id]
+	fun getUser(id: Int) = if (id == getCurrentUserId()) currentUser else users[id]
 
 	fun getOsmandBot() = osmandBot
 
@@ -689,8 +689,6 @@ class TelegramHelper private constructor() {
 					outgoingMessagesListeners.forEach {
 						it.onUpdateMessages(listOf(message))
 					}
-				} else {
-					return
 				}
 			} else {
 				incomingMessagesListeners.forEach {
@@ -882,9 +880,7 @@ class TelegramHelper private constructor() {
 				log.debug("handleMapLocationMessageUpdate - ERROR $obj")
 				val error = obj as TdApi.Error
 				needRefreshActiveLiveLocationMessages = true
-				if (error.code == MESSAGE_CANNOT_BE_EDITED_ERROR_CODE) {
-					shareInfo.shouldDeletePreviousMapMessage = true
-				} else if (error.code != IGNORED_ERROR_CODE) {
+				if (error.code != IGNORED_ERROR_CODE) {
 					shareInfo.hasSharingError = true
 					outgoingMessagesListeners.forEach {
 						it.onSendLiveLocationError(error.code, error.message)
@@ -929,9 +925,7 @@ class TelegramHelper private constructor() {
 			TdApi.Error.CONSTRUCTOR -> {
 				log.debug("handleTextLocationMessageUpdate - ERROR")
 				val error = obj as TdApi.Error
-				if (error.code == MESSAGE_CANNOT_BE_EDITED_ERROR_CODE) {
-					shareInfo.shouldDeletePreviousTextMessage = true
-				} else if (error.code != IGNORED_ERROR_CODE) {
+				if (error.code != IGNORED_ERROR_CODE) {
 					shareInfo.hasSharingError = true
 					outgoingMessagesListeners.forEach {
 						it.onSendLiveLocationError(error.code, error.message)
diff --git a/OsmAnd-telegram/src/net/osmand/telegram/ui/SharingStatusBottomSheet.kt b/OsmAnd-telegram/src/net/osmand/telegram/ui/SharingStatusBottomSheet.kt
index 51ef8b14ebc..0dfdb2abbbf 100644
--- a/OsmAnd-telegram/src/net/osmand/telegram/ui/SharingStatusBottomSheet.kt
+++ b/OsmAnd-telegram/src/net/osmand/telegram/ui/SharingStatusBottomSheet.kt
@@ -75,7 +75,7 @@ class SharingStatusBottomSheet : DialogFragment() {
 						if (i == 0) {
 							setOnClickListener {
 								app.shareLocationHelper.checkNetworkType()
-								app.settings.prepareForSharingNewMessages()
+								app.settings.prepareForSharingNewMessages(sharingStatus.chatsIds)
 								app.shareLocationHelper.checkAndSendBufferMessages()
 								app.forceUpdateMyLocation()
 								dismiss()
