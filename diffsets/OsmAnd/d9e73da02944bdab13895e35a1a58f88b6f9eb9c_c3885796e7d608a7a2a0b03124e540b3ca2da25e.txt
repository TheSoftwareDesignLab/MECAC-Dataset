diff --git a/DataExtractionOSM/src/net/osmand/render/new_default.render.xml b/DataExtractionOSM/src/net/osmand/render/new_default.render.xml
index 6b47d4f4205..69a9857391d 100644
--- a/DataExtractionOSM/src/net/osmand/render/new_default.render.xml
+++ b/DataExtractionOSM/src/net/osmand/render/new_default.render.xml
@@ -54,7 +54,9 @@
 	<renderingProperty attr="hmRendered" name="Show more map detail" description="Default renderer: Increase amount of map detail shown"
 		type="boolean" possibleValues=""/>
 	<renderingProperty attr="appMode" name="Rendering mode" description="Default renderer: Adjust rendering for specific purpose"
-		type="string" possibleValues="default,car,bicycle,pedestrian"/>	
+		type="string" possibleValues="default,car,bicycle,pedestrian"/>
+	<renderingProperty attr="shadowRenderingMode" name="Shadow rendering" description="Default renderer: change way of displaying road edges."
+		type="string" possibleValues="no shadow,one step,blur shadow,solid shadow"/>		
 
 
 	<!-- input exact layer, orderType check tag, value -->
diff --git a/OsmAnd/jni/osmand/rendering.cpp b/OsmAnd/jni/osmand/rendering.cpp
index b60b14477cc..8b73c19e56b 100644
--- a/OsmAnd/jni/osmand/rendering.cpp
+++ b/OsmAnd/jni/osmand/rendering.cpp
@@ -11,6 +11,7 @@
 #include <time.h>
 #include "SkTypes.h"
 #include "SkBitmap.h"
+#include "SkColorFilter.h"
 #include "SkShader.h"
 #include "SkBitmapProcShader.h"
 #include "SkPathEffect.h"
@@ -121,6 +122,7 @@ int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int ar
 		rCap = req->props()->R_CAP_3;
 		rPathEff = req->props()->R_PATH_EFFECT_3;
 	}
+	paint->setColorFilter(NULL);
 	if (area) {
 		paint->setStyle(SkPaint::kStrokeAndFill_Style);
 		paint->setStrokeWidth(0);
@@ -174,9 +176,9 @@ int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int ar
 	}
 
 	// do not check shadow color here
-	if (rc->shadowRenderingMode != 1 || ind != 0) {
+	paint->setLooper(NULL);
+	if (rc->shadowRenderingMode == 1 && ind == 0) {
 		paint->setLooper(NULL);
-	} else {
 		int shadowColor = req->getIntPropertyValue(req->props()->R_SHADOW_COLOR);
 		int shadowLayer = req->getIntPropertyValue(req->props()->R_SHADOW_RADIUS);
 		if (shadowColor == 0) {
@@ -185,7 +187,6 @@ int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int ar
 		if (shadowLayer > 0) {
 			paint->setLooper(new SkBlurDrawLooper(shadowLayer, 0, 0, shadowColor))->unref();
 		}
-		paint->setLooper(NULL);
 	}
 	return 1;
 }
@@ -257,7 +258,8 @@ void drawPolylineShadow(SkCanvas* cv, SkPaint* paint, RenderingContext* rc, SkPa
 	if (rc->shadowRenderingMode == 3 && shadowRadius > 0) {
 		paint->setLooper(NULL);
 		paint->setStrokeWidth(paint->getStrokeWidth() + shadowRadius * 2);
-		paint->setColor(0xffbababa);
+//		paint->setColor(0xffbababa);
+		paint->setColorFilter(SkColorFilter::CreateModeFilter(shadowColor, SkXfermode::kSrcIn_Mode))->unref();
 //		paint->setColor(shadowColor);
 		NAT_COUNT(rc, cv->drawPath(*path, *paint));
 	}
diff --git a/OsmAnd/jni/osmand/textdraw.cpp b/OsmAnd/jni/osmand/textdraw.cpp
index 98d817bc013..97e968cb7b3 100644
--- a/OsmAnd/jni/osmand/textdraw.cpp
+++ b/OsmAnd/jni/osmand/textdraw.cpp
@@ -369,7 +369,7 @@ void drawTestBox(SkCanvas* cv, SkRect* r, float rot, SkPaint* paintIcon, std::st
 	cv->restore();
 }
 
-float sqr(float a){
+inline float sqr(float a){
 	return a*a;
 }
 
@@ -444,10 +444,11 @@ bool findTextIntersection(SkCanvas* cv, RenderingContext* rc, quad_tree<TextDraw
 	if(text->minDistance > 0) {
 		SkRect boundsSearch = text->bounds;
 		boundsSearch.inset(-getDensityValue(rc, std::max(5.0f, text->minDistance)), -getDensityValue(rc, 12));
+		boundIntersections.query_in_box(boundsSearch, search);
 //		drawTestBox(cv, &boundsSearch, text->pathRotate, paintIcon, text->text, NULL/*paintText*/);
 		for (uint i = 0; i < search.size(); i++) {
 			TextDrawInfo* t = search.at(i);
-			if (t->minDistance > 0 && intersect(boundsSearch, text->pathRotate,  t)) {
+			if (t->minDistance > 0 && t->text == text->text && intersect(boundsSearch, text->pathRotate,  t)) {
 				return true;
 			}
 		}
diff --git a/OsmAnd/libs/armeabi/libosmand.so b/OsmAnd/libs/armeabi/libosmand.so
index c1505c619b5..464a2e7e645 100755
Binary files a/OsmAnd/libs/armeabi/libosmand.so and b/OsmAnd/libs/armeabi/libosmand.so differ
diff --git a/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java b/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java
index 044c5b232a8..108ab2ff166 100644
--- a/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java
+++ b/OsmAnd/src/net/osmand/plus/render/MapRenderRepositories.java
@@ -39,6 +39,7 @@
 import net.osmand.plus.activities.OsmandApplication;
 import net.osmand.plus.render.NativeOsmandLibrary.NativeSearchResult;
 import net.osmand.plus.render.OsmandRenderer.RenderingContext;
+import net.osmand.plus.render.OsmandRenderer.ShadowRenderingMode;
 import net.osmand.render.RenderingRuleProperty;
 import net.osmand.render.RenderingRuleSearchRequest;
 import net.osmand.render.RenderingRulesStorage;
@@ -484,6 +485,17 @@ public synchronized void loadMap(RotatedTileBox tileRect, List<IMapDownloaderCal
 			final long searchTime = System.currentTimeMillis() - now;
 
 			currentRenderingContext = new OsmandRenderer.RenderingContext(context);
+			RenderingRuleProperty rr = storage.PROPS.get("shadowRenderingMode");
+			if(rr != null){
+				CommonPreference<String> settings = app.getSettings().getCustomRenderProperty(rr.getAttrName());
+				if(settings.get().length() > 0 ) {
+					try {
+						ShadowRenderingMode m = ShadowRenderingMode.valueOf(settings.get().replace(' ', '_').toUpperCase());
+						currentRenderingContext.shadowRenderingMode = m.value;
+					} catch(IllegalArgumentException e){
+					}
+				}
+			}
 			currentRenderingContext.leftX = (float) requestedBox.getLeftTileX();
 			currentRenderingContext.topY = (float) requestedBox.getTopTileY();
 			currentRenderingContext.zoom = requestedBox.getZoom();
diff --git a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
index 6f5ad731b58..929f251a766 100644
--- a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
@@ -5,8 +5,6 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -19,10 +17,10 @@
 import net.osmand.osm.MapRenderingTypes;
 import net.osmand.osm.MultyPolygon;
 import net.osmand.plus.render.NativeOsmandLibrary.NativeSearchResult;
+import net.osmand.plus.render.TextRenderer.TextDrawInfo;
 import net.osmand.render.RenderingRuleProperty;
 import net.osmand.render.RenderingRuleSearchRequest;
 import net.osmand.render.RenderingRulesStorage;
-import net.sf.junidecode.Junidecode;
 
 import org.apache.commons.logging.Log;
 
@@ -31,21 +29,20 @@
 import android.graphics.BitmapShader;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.ColorFilter;
 import android.graphics.DashPathEffect;
 import android.graphics.Paint;
 import android.graphics.Path;
 import android.graphics.PathEffect;
 import android.graphics.PointF;
-import android.graphics.RectF;
+import android.graphics.PorterDuff.Mode;
+import android.graphics.PorterDuffColorFilter;
 import android.graphics.Shader;
-import android.graphics.Typeface;
-import android.graphics.Paint.Align;
 import android.graphics.Paint.Cap;
 import android.graphics.Paint.Style;
 import android.graphics.Shader.TileMode;
 import android.os.Handler;
 import android.os.Looper;
-import android.text.TextPaint;
 import android.util.DisplayMetrics;
 import android.util.FloatMath;
 import android.view.WindowManager;
@@ -56,7 +53,6 @@ public class OsmandRenderer {
 	private final int clFillScreen = Color.rgb(241, 238, 232);
 
 	
-	private TextPaint paintText;
 	private Paint paint;
 
 	private Paint paintFillEmpty;
@@ -71,51 +67,29 @@ public class OsmandRenderer {
 
 	private DisplayMetrics dm;
 
-	private static class TextDrawInfo {
+	private TextRenderer textRenderer;
 
-		public TextDrawInfo(String text){
-			this.text = text;
-		}
-
-		String text = null;
-		Path drawOnPath = null;
-		float vOffset = 0;
-		float centerX = 0;
-		float pathRotate = 0;
-		float centerY = 0;
-		float textSize = 0;
-		float minDistance = 0;
-		int textColor = Color.BLACK;
-		int textShadow = 0;
-		int textWrap = 0;
-		boolean bold = false;
-		String shieldRes = null;
-		int textOrder = 100;
-		
-		public void fillProperties(RenderingRuleSearchRequest render, float centerX, float centerY){
-			this.centerX = centerX;
-			this.centerY = centerY + render.getIntPropertyValue(render.ALL.R_TEXT_DY, 0);
-			textColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);
-			if(textColor == 0){
-				textColor = Color.BLACK;
-			}
-			textSize = render.getIntPropertyValue(render.ALL.R_TEXT_SIZE);
-			textShadow = render.getIntPropertyValue(render.ALL.R_TEXT_HALO_RADIUS, 0);
-			textWrap = render.getIntPropertyValue(render.ALL.R_TEXT_WRAP_WIDTH, 0);
-			bold = render.getIntPropertyValue(render.ALL.R_TEXT_BOLD, 0) > 0;
-			minDistance = render.getIntPropertyValue(render.ALL.R_TEXT_MIN_DISTANCE,0);
-			if(render.isSpecified(render.ALL.R_TEXT_SHIELD)) {
-				shieldRes = render.getStringPropertyValue(render.ALL.R_TEXT_SHIELD);
-			}
-			textOrder = render.getIntPropertyValue(render.ALL.R_TEXT_ORDER, 100);
-		}
-	}
 
 	private static class IconDrawInfo {
 		float x = 0;
 		float y = 0;
 		String resId;
 	}
+	
+	static enum ShadowRenderingMode {
+		// int shadowRenderingMode = 0; // no shadow (minumum CPU)
+		// int shadowRenderingMode = 1; // classic shadow (the implementaton in master)
+		// int shadowRenderingMode = 2; // blur shadow (most CPU, but still reasonable)
+		// int shadowRenderingMode = 3; solid border (CPU use like classic version or even smaller)
+		NO_SHADOW(0),
+		ONE_STEP(1),
+		BLUR_SHADOW(2),
+		SOLID_SHADOW(3);
+		public final int value;
+		ShadowRenderingMode(int v) {
+			this.value = v;
+		}
+	}
 
 	/*package*/ static class RenderingContext {
 		// FIELDS OF THAT CLASS ARE USED IN C++
@@ -155,11 +129,8 @@ public RenderingContext(Context ctx) {
 		float cosRotateTileSize;
 		float sinRotateTileSize;
 		
-		// int shadowRenderingMode = 0; // no shadow (minumum CPU)
-		// int shadowRenderingMode = 1; // classic shadow (the implementaton in master)
-		// int shadowRenderingMode = 2; // blur shadow (most CPU, but still reasonable)
-		// int shadowRenderingMode = 3; solid border (CPU use like classic version or even smaller)
-		int shadowRenderingMode = 3;
+		// be aware field is using in C++
+		int shadowRenderingMode = ShadowRenderingMode.BLUR_SHADOW.value;
 		
 		// not expect any shadow
 		int shadowLevelMin = 256;
@@ -168,6 +139,14 @@ public RenderingContext(Context ctx) {
 		String renderingDebugInfo;
 		
 		boolean ended = false;
+		
+		float getDensityValue(float val) {
+			if (highResMode && density > 1) {
+				return val * density * mapTextSize;
+			} else {
+				return val * mapTextSize;
+			}
+		}
 	}
 
 	public OsmandRenderer(Context context) {
@@ -176,14 +155,8 @@ public OsmandRenderer(Context context) {
 		paintIcon = new Paint();
 		paintIcon.setStyle(Style.STROKE);
 
-		paintText = new TextPaint();
-		paintText.setStyle(Style.FILL);
-		paintText.setStrokeWidth(1);
-		paintText.setColor(Color.BLACK);
-		paintText.setTextAlign(Align.CENTER);
-		paintText.setTypeface(Typeface.create("Droid Serif", Typeface.NORMAL)); //$NON-NLS-1$
-		paintText.setAntiAlias(true);
 
+		textRenderer = new TextRenderer(context);
 		paint = new Paint();
 		paint.setAntiAlias(true);
 
@@ -334,7 +307,7 @@ public void generateNewBitmap(RenderingContext rc, List<BinaryMapDataObject> obj
 			drawIconsOverCanvas(rc, cv);
 
 			notifyListeners(notifyList);
-			drawTextOverCanvas(rc, cv, useEnglishNames);
+			textRenderer.drawTextOverCanvas(rc, cv, useEnglishNames);
 
 			long time = System.currentTimeMillis() - now;
 			rc.renderingDebugInfo = String.format("Rendering: %s ms  (%s text)\n"
@@ -360,7 +333,7 @@ public void run() {
 	}
 
 	private void drawIconsOverCanvas(RenderingContext rc, Canvas cv) {
-		int skewConstant = (int) getDensityValue(rc, 16);
+		int skewConstant = (int) rc.getDensityValue(16);
 		int iconsW = rc.width / skewConstant;
 		int iconsH = rc.height / skewConstant;
 		int[] alreadyDrawnIcons = new int[iconsW * iconsH / 32];
@@ -450,8 +423,6 @@ private TIntObjectHashMap<TIntArrayList> sortObjectsByProperOrder(RenderingConte
 		}
 		return orderMap;
 	}
-	
-
 	private void notifyListeners(List<IMapDownloaderCallback> notifyList) {
 		if (notifyList != null) {
 			for (IMapDownloaderCallback c : notifyList) {
@@ -459,230 +430,7 @@ private void notifyListeners(List<IMapDownloaderCallback> notifyList) {
 			}
 		}
 	}
-	private final static boolean findAllTextIntersections = true;
 
-	private float getDensityValue(RenderingContext rc, float val) {
-		if (rc.highResMode && rc.density > 1) {
-			return val * rc.density * rc.mapTextSize;
-		} else {
-			return val * rc.mapTextSize;
-		}
-	}
-
-	public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {
-		List<RectF> boundsNotPathIntersect = new ArrayList<RectF>();
-		List<RectF> boundsPathIntersect = new ArrayList<RectF>();
-		int size = rc.textToDraw.size();
-		Comparator<RectF> c = new Comparator<RectF>(){
-			@Override
-			public int compare(RectF object1, RectF object2) {
-				return Float.compare(object1.left, object2.left);
-			}
-
-		};
-		
-		// 1. Sort text using text order 
-		Collections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {
-			@Override
-			public int compare(TextDrawInfo object1, TextDrawInfo object2) {
-				return object1.textOrder - object2.textOrder;
-			}
-		});
-		
-		nextText: for (int i = 0; i < size; i++) {
-			TextDrawInfo text  = rc.textToDraw.get(i);
-			if(text.text != null){
-				int d = text.text.indexOf(MapRenderingTypes.DELIM_CHAR);
-				// not used now functionality 
-				// possibly it will be used specifying english names after that character
-				if(d > 0){
-					text.text = text.text.substring(0, d);
-				}
-				if(useEnglishNames){
-					text.text = Junidecode.unidecode(text.text);
-				}
-
-
-				// sest text size before finding intersection (it is used there)
-				float textSize = getDensityValue(rc, text.textSize);
-				paintText.setTextSize(textSize);
-				paintText.setFakeBoldText(text.bold);
-				paintText.setColor(text.textColor);
-				// align center y
-				text.centerY += (-paintText.ascent());
-
-				// calculate if there is intersection
-				boolean intersects = findTextIntersection(rc, boundsNotPathIntersect, boundsPathIntersect, c, text);
-				if(intersects){
-					continue nextText;
-				}
-
-
-				if(text.drawOnPath != null){
-					if(text.textShadow > 0){
-						paintText.setColor(Color.WHITE);
-						paintText.setStyle(Style.STROKE);
-						paintText.setStrokeWidth(2 + text.textShadow);
-						cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
-						// reset
-						paintText.setStyle(Style.FILL);
-						paintText.setStrokeWidth(2);
-						paintText.setColor(text.textColor);
-					}
-					cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
-				} else {
-					if (text.shieldRes != null) {
-						Bitmap ico = RenderingIcons.getIcon(context, text.shieldRes);
-						if (ico != null) {
-							cv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f, text.centerY
-									- ico.getHeight() / 2 - getDensityValue(rc, 4.5f) 
-									, paintIcon);
-						}
-					}
-
-					drawWrappedText(cv, text, textSize);
-				}
-			}
-		}
-	}
-
-	private void drawWrappedText(Canvas cv, TextDrawInfo text, float textSize) {
-		if(text.textWrap == 0){
-			// set maximum for all text
-			text.textWrap = 40;
-		}
-
-		if(text.text.length() > text.textWrap){
-			int start = 0;
-			int end = text.text.length();
-			int lastSpace = -1;
-			int line = 0;
-			int pos = 0;
-			int limit = 0;
-			while(pos < end){
-				lastSpace = -1;
-				limit += text.textWrap;
-				while(pos < limit && pos < end){
-					if(!Character.isLetterOrDigit(text.text.charAt(pos))){
-						lastSpace = pos;
-					}
-					pos++;
-				}
-				if(lastSpace == -1){
-					drawTextOnCanvas(cv, text.text.substring(start, pos), 
-							text.centerX, text.centerY + line * (textSize + 2), paintText, text.textShadow);
-					start = pos;
-				} else {
-					drawTextOnCanvas(cv, text.text.substring(start, lastSpace), 
-							text.centerX, text.centerY + line * (textSize + 2), paintText, text.textShadow); 
-					start = lastSpace + 1;
-					limit += (start - pos) - 1;
-				}
-				line++;
-
-			}
-		} else {
-			drawTextOnCanvas(cv, text.text, text.centerX, text.centerY, paintText, text.textShadow);
-		}
-	}
-
-	private void drawTextOnCanvas(Canvas cv, String text, float centerX, float centerY, Paint paint, float textShadow){
-		if(textShadow > 0){
-			int c = paintText.getColor();
-			paintText.setStyle(Style.STROKE);
-			paintText.setColor(Color.WHITE);
-			paintText.setStrokeWidth(2 + textShadow);
-			cv.drawText(text, centerX, centerY, paint);
-			// reset
-			paintText.setStrokeWidth(2);
-			paintText.setStyle(Style.FILL);
-			paintText.setColor(c);
-		}
-		cv.drawText(text, centerX, centerY, paint);
-	}
-
-
-	private boolean findTextIntersection(RenderingContext rc, List<RectF> boundsNotPathIntersect, List<RectF> boundsPathIntersect,
-			Comparator<RectF> c, TextDrawInfo text) {
-		boolean horizontalWayDisplay = (text.pathRotate > 45 && text.pathRotate < 135) || (text.pathRotate > 225 && text.pathRotate < 315);
-//		text.minDistance = 0;
-		float textWidth = paintText.measureText(text.text) + (!horizontalWayDisplay ? 0 : text.minDistance);
-		// Paint.ascent is negative, so negate it.
-		int ascent = (int) Math.ceil(-paintText.ascent());
-		int descent = (int) Math.ceil(paintText.descent());
-		float textHeight = ascent + descent + (horizontalWayDisplay ? 0 : text.minDistance) + getDensityValue(rc, 5);
-
-		RectF bounds = new RectF();
-		if(text.drawOnPath == null || horizontalWayDisplay){
-			bounds.set(text.centerX - textWidth / 2, text.centerY - textHeight / 2 ,
-					text.centerX + textWidth / 2 , text.centerY + textHeight / 2 );
-		} else {
-			bounds.set(text.centerX - textHeight / 2, text.centerY - textWidth / 2, 
-					text.centerX + textHeight / 2 , text.centerY + textWidth / 2);
-		}
-		List<RectF> boundsIntersect = text.drawOnPath == null || findAllTextIntersections? 
-				boundsNotPathIntersect : boundsPathIntersect;
-		if(boundsIntersect.isEmpty()){
-			boundsIntersect.add(bounds);
-		} else {
-			final int diff = (int) (getDensityValue(rc, 3));
-			final int diff2 = (int) (getDensityValue(rc, 15));
-			// implement binary search 
-			int index = Collections.binarySearch(boundsIntersect, bounds, c);
-			if (index < 0) {
-				index = -(index + 1);
-			}
-			// find sublist that is appropriate
-			int e = index;
-			while (e < boundsIntersect.size()) {
-				if (boundsIntersect.get(e).left < bounds.right ) {
-					e++;
-				} else {
-					break;
-				}
-			}
-			int st = index - 1;
-			while (st >= 0) {
-				// that's not exact algorithm that replace comparison rect with each other
-				// because of that comparison that is not obvious 
-				// (we store array sorted by left boundary, not by right) - that's euristic
-				if (boundsIntersect.get(st).right > bounds.left ) {
-					st--;
-				} else {
-					break;
-				}
-			}
-			if (st < 0) {
-				st = 0;
-			}
-			// test functionality
-			//					 cv.drawRect(bounds, paint);
-			//					 cv.drawText(text.text.substring(0, Math.min(5, text.text.length())), bounds.centerX(), bounds.centerY(), paint);
-
-			for (int j = st; j < e; j++) {
-				RectF b = boundsIntersect.get(j);
-				float x = Math.min(bounds.right, b.right) - Math.max(b.left, bounds.left);
-				float y = Math.min(bounds.bottom, b.bottom) - Math.max(b.top, bounds.top);
-				if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
-					return true;
-				}
-			}
-			// store in list sorted by left boundary
-			//					if(text.minDistance > 0){
-			//						if (verticalText) {
-			//							bounds.set(bounds.left + text.minDistance / 2, bounds.top, 
-			//									bounds.right - text.minDistance / 2, bounds.bottom);
-			//						} else {
-			//							bounds.set(bounds.left, bounds.top + text.minDistance / 2, bounds.right, 
-			//									bounds.bottom - text.minDistance / 2);
-			//						}
-			//					}
-			boundsIntersect.add(index, bounds);
-		}
-		return false;
-	}
-
-	
 	protected void drawObj(BinaryMapDataObject obj, RenderingRuleSearchRequest render, Canvas canvas, RenderingContext rc, int l,
 			boolean renderText, boolean drawOnlyShadow) {
 		rc.allObjects++;
@@ -780,7 +528,7 @@ private void drawMultiPolygon(BinaryMapDataObject obj, RenderingRuleSearchReques
 			if (cnt > 0) {
 				String name = ((MultyPolygon) obj).getName(i);
 				if (name != null) {
-					drawPointText(render, rc, new TagValuePair(tag, value), xText / cnt, yText / cnt, name);
+					textRenderer.renderText(name, render, rc, new TagValuePair(tag, value), xText / cnt, yText / cnt, null, null);
 				}
 			}
 		}
@@ -834,7 +582,7 @@ private void drawPolygon(BinaryMapDataObject obj, RenderingRuleSearchRequest ren
 			}
 			String name = obj.getName();
 			if(name != null){
-				drawPointText(render, rc, pair, xText / len, yText / len, name);
+				textRenderer.renderText(name, render, rc, pair, xText / len, yText / len, null, null);
 			}
 		}
 	}
@@ -885,12 +633,12 @@ private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, bo
 				p.setPathEffect(null);
 			}
 		}
+		p.setColorFilter(null);
 		p.setColor(req.getIntPropertyValue(rColor));
 		
 		if(ind == 0){
 			String resId = req.getStringPropertyValue(req.ALL.R_SHADER);
 			if(resId != null){
-				p.setColor(Color.BLACK);
 				p.setShader(getShader(resId));
 			} else {
 				p.setShader(null);
@@ -916,47 +664,6 @@ private boolean updatePaint(RenderingRuleSearchRequest req, Paint p, int ind, bo
 	}
 	
 
-	private void drawPointText(RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair, float xText, float yText, String name) {
-		String ref = null;
-		if (name.charAt(0) == MapRenderingTypes.REF_CHAR) {
-			ref = name.substring(1);
-			name = ""; //$NON-NLS-1$
-			for (int k = 0; k < ref.length(); k++) {
-				if (ref.charAt(k) == MapRenderingTypes.REF_CHAR) {
-					if (k < ref.length() - 1) {
-						name = ref.substring(k + 1);
-					}
-					ref = ref.substring(0, k);
-					break;
-				}
-			}
-		}
-
-		if (ref != null && ref.trim().length() > 0) {
-			render.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);
-			render.setIntFilter(render.ALL.R_TEXT_LENGTH, ref.length());
-			render.setBooleanFilter(render.ALL.R_REF, true);
-			if(render.search(RenderingRulesStorage.TEXT_RULES)){
-				if(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0){
-					TextDrawInfo text = new TextDrawInfo(ref);
-					text.fillProperties(render, xText, yText);
-					rc.textToDraw.add(text);
-				}
-			}
-		}
-		
-		render.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);
-		render.setIntFilter(render.ALL.R_TEXT_LENGTH, name.length());
-		render.setBooleanFilter(render.ALL.R_REF, false);
-		if(render.search(RenderingRulesStorage.TEXT_RULES) ){
-			if(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0){
-				TextDrawInfo info = new TextDrawInfo(name);
-				info.fillProperties(render, xText, yText);
-				rc.textToDraw.add(info);
-			}
-		}
-	}
-	
 	private void drawPoint(BinaryMapDataObject obj, RenderingRuleSearchRequest render, Canvas canvas, RenderingContext rc, TagValuePair pair, boolean renderText) {
 		if(render == null || pair == null){
 			return;
@@ -992,8 +699,8 @@ private void drawPoint(BinaryMapDataObject obj, RenderingRuleSearchRequest rende
 			ico.resId = resId;
 			rc.iconsToDraw.add(ico);
 		}
-		if (name != null) {
-			drawPointText(render, rc, pair, ps.x, ps.y, name);
+		if (name != null && name.trim().length() > 0) {
+			textRenderer.renderText(name, render, rc, pair, ps.x, ps.y, null, null);
 		}
 
 	}
@@ -1012,7 +719,9 @@ private void drawPolylineShadow(Canvas canvas, RenderingContext rc, Path path, i
 		if (rc.shadowRenderingMode == 3 && shadowRadius > 0) {
 			paint.clearShadowLayer();
 			paint.setStrokeWidth(paint.getStrokeWidth() + shadowRadius * 2);
-			 paint.setColor(0xffbababa);
+			ColorFilter cf = new PorterDuffColorFilter(shadowColor, Mode.SRC_IN);
+			paint.setColorFilter(cf);
+//			 paint.setColor(0xffbababa);
 //			paint.setColor(shadowColor);
 			canvas.drawPath(path, paint);
 		}
@@ -1042,43 +751,29 @@ private void drawPolyline(BinaryMapDataObject obj, RenderingRuleSearchRequest re
 		rc.visible++;
 
 		Path path = null;
-		float pathRotate = 0;
-		float roadLength = 0;
-		boolean inverse = false;
-		float xPrev = 0;
-		float yPrev = 0;
 		float xMid = 0;
 		float yMid = 0;
-		PointF middlePoint = new PointF();
 		int middle = obj.getPointsLength() / 2;
+		PointF[] textPoints = null;
+		if (!drawOnlyShadow && obj.getName() != null && obj.getName().length() > 0) {
+			textPoints = new PointF[length];
+		}
 
 		for (int i = 0; i < length ; i++) {
 			PointF p = calcPoint(obj, i, rc);
-			if(i == 0 || i == length -1){
-				xMid += p.x;
-				yMid += p.y;
+			if(textPoints != null) {
+				textPoints[i] = new PointF(p.x, p.y);
 			}
 			if (path == null) {
 				path = new Path();
 				path.moveTo(p.x, p.y);
 			} else {
-				roadLength += Math.sqrt((p.x - xPrev) * (p.x - xPrev) + (p.y - yPrev) * (p.y - yPrev)); 
 				if(i == middle){
-					middlePoint.set(p.x, p.y);
-					double rot = - Math.atan2(p.x - xPrev, p.y - yPrev) * 180 / Math.PI;
-					if (rot < 0) {
-						rot += 360;
-					}
-					if (rot < 180) {
-						rot += 180;
-						inverse = true;
-					}
-					pathRotate = (float) rot;
+					xMid = p.x;
+					yMid = p.y;
 				}
 				path.lineTo(p.x, p.y);
 			}
-			xPrev = p.x;
-			yPrev = p.y;
 		}
 		if (path != null) {
 			if(drawOnlyShadow) {
@@ -1101,81 +796,13 @@ private void drawPolyline(BinaryMapDataObject obj, RenderingRuleSearchRequest re
 					canvas.drawPath(path, paints[i]);
 				}
 			}
-			if (!drawOnlyShadow && obj.getName() != null && obj.getName().length() > 0) {
-				calculatePolylineText(obj, render, rc, pair, path, pathRotate, roadLength, inverse, xMid, yMid, middlePoint);
+			if (textPoints != null) {
+				textRenderer.renderText(obj.getName(), render, rc, pair, xMid, yMid, path, textPoints);
 			}
 		}
 	}
 
-	private void calculatePolylineText(BinaryMapDataObject obj, RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair,
-			Path path, float pathRotate, float roadLength, boolean inverse, float xMid, float yMid, PointF middlePoint) {
-		String name = obj.getName();
-		String ref = null;
-		if(name.charAt(0) == MapRenderingTypes.REF_CHAR){
-			ref = name.substring(1);
-			name = ""; //$NON-NLS-1$
-			for(int k = 0; k < ref.length(); k++){
-				if(ref.charAt(k) == MapRenderingTypes.REF_CHAR){
-					if(k < ref.length() - 1){
-						name = ref.substring(k + 1);
-					}
-					ref = ref.substring(0, k);
-					break;
-				}
-			}
-		}
-		if(ref != null && ref.trim().length() > 0){
-			render.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);
-			render.setIntFilter(render.ALL.R_TEXT_LENGTH, ref.length());
-			render.setBooleanFilter(render.ALL.R_REF, true);
-			if(render.search(RenderingRulesStorage.TEXT_RULES)){
-				if(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0){
-					TextDrawInfo text = new TextDrawInfo(ref);
-					text.fillProperties(render, middlePoint.x, middlePoint.y);
-					text.pathRotate = pathRotate;
-					rc.textToDraw.add(text);
-				}
-			}
-		}
-
-		if(name != null && name.trim().length() > 0){
-			render.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);
-			render.setIntFilter(render.ALL.R_TEXT_LENGTH, name.length());
-			render.setBooleanFilter(render.ALL.R_REF, false);
-			if (render.search(RenderingRulesStorage.TEXT_RULES) && render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0) {
-				TextDrawInfo text = new TextDrawInfo(name);
-				if (render.getIntPropertyValue(render.ALL.R_TEXT_ON_PATH, 0) == 0) {
-					text.fillProperties(render, middlePoint.x, middlePoint.y);
-					rc.textToDraw.add(text);
-				} else {
-					paintText.setTextSize(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE));
-					if (paintText.measureText(obj.getName()) < roadLength ) {
-						if (inverse) {
-							path.rewind();
-							boolean st = true;
-							for (int i = obj.getPointsLength() - 1; i >= 0; i--) {
-								PointF p = calcPoint(obj, i, rc);
-								if (st) {
-									st = false;
-									path.moveTo(p.x, p.y);
-								} else {
-									path.lineTo(p.x, p.y);
-								}
-							}
-						}
-						text.fillProperties(render, xMid / 2, yMid / 2);
-						text.pathRotate = pathRotate;
-						text.drawOnPath = path;
-						int strokeWidth = render.getIntPropertyValue(render.ALL.R_TEXT_SIZE);
-						text.vOffset = strokeWidth / 2 - 1;
-						rc.textToDraw.add(text);
-					}
-				}
-			}
-
-		}
-	}
-	
+		
 	private static Paint[] oneWay = null;
 	private static Paint oneWayPaint(){
 		Paint oneWay = new Paint();
@@ -1211,6 +838,4 @@ public static Paint[] getOneWayPaints(){
 		}
 		return oneWay;
 	}
-
-
 }
diff --git a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
new file mode 100644
index 00000000000..5dbc63bcc62
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
@@ -0,0 +1,493 @@
+package net.osmand.plus.render;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+
+import net.osmand.binary.BinaryMapIndexReader.TagValuePair;
+import net.osmand.osm.MapRenderingTypes;
+import net.osmand.plus.render.OsmandRenderer.RenderingContext;
+import net.osmand.render.RenderingRuleSearchRequest;
+import net.osmand.render.RenderingRulesStorage;
+import net.sf.junidecode.Junidecode;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.PointF;
+import android.graphics.Rect;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Style;
+import android.graphics.Path;
+import android.graphics.RectF;
+import android.graphics.Typeface;
+import android.text.TextPaint;
+import android.util.FloatMath;
+
+public class TextRenderer {
+
+	private TextPaint paintText;
+	private final Context context;
+	private Paint paintIcon;
+
+	static class TextDrawInfo {
+
+		public TextDrawInfo(String text) {
+			this.text = text;
+		}
+
+		String text = null;
+		Path drawOnPath = null;
+		RectF bounds = null;
+		float vOffset = 0;
+		float centerX = 0;
+		float pathRotate = 0;
+		float centerY = 0;
+		float textSize = 0;
+		float minDistance = 0;
+		int textColor = Color.BLACK;
+		int textShadow = 0;
+		int textWrap = 0;
+		boolean bold = false;
+		String shieldRes = null;
+		int textOrder = 100;
+
+		public void fillProperties(RenderingRuleSearchRequest render, float centerX, float centerY) {
+			this.centerX = centerX;
+			this.centerY = centerY + render.getIntPropertyValue(render.ALL.R_TEXT_DY, 0);
+			textColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);
+			if (textColor == 0) {
+				textColor = Color.BLACK;
+			}
+			textSize = render.getIntPropertyValue(render.ALL.R_TEXT_SIZE);
+			textShadow = render.getIntPropertyValue(render.ALL.R_TEXT_HALO_RADIUS, 0);
+			textWrap = render.getIntPropertyValue(render.ALL.R_TEXT_WRAP_WIDTH, 0);
+			bold = render.getIntPropertyValue(render.ALL.R_TEXT_BOLD, 0) > 0;
+			minDistance = render.getIntPropertyValue(render.ALL.R_TEXT_MIN_DISTANCE, 0);
+			if (render.isSpecified(render.ALL.R_TEXT_SHIELD)) {
+				shieldRes = render.getStringPropertyValue(render.ALL.R_TEXT_SHIELD);
+			}
+			textOrder = render.getIntPropertyValue(render.ALL.R_TEXT_ORDER, 100);
+		}
+	}
+
+	public TextRenderer(Context context) {
+		this.context = context;
+		paintText = new TextPaint();
+		paintText.setStyle(Style.FILL);
+		paintText.setStrokeWidth(1);
+		paintText.setColor(Color.BLACK);
+		paintText.setTextAlign(Align.CENTER);
+		paintText.setTypeface(Typeface.create("Droid Serif", Typeface.NORMAL)); //$NON-NLS-1$
+		paintText.setAntiAlias(true);
+
+		paintIcon = new Paint();
+		paintIcon.setStyle(Style.STROKE);
+	}
+
+	public TextPaint getPaintText() {
+		return paintText;
+	}
+
+	private float sqr(float a) {
+		return a * a;
+	}
+
+	boolean intersect(RectF tRect, float tRot, RectF sRect, float sRot) {
+		if (Math.abs(tRot) < Math.PI / 15 && Math.abs(sRot) < Math.PI / 15) {
+			return tRect.intersect(sRect);
+		}
+		float dist = FloatMath.sqrt(sqr(tRect.centerX() - sRect.centerX()) + sqr(tRect.centerY() - sRect.centerY()));
+		if (dist < 3) {
+			return true;
+		}
+
+		// difference close to 90/270 degrees
+		if (Math.abs(Math.cos(tRot - sRot)) < 0.3) {
+			// rotate one rectangle to 90 degrees
+			tRot += Math.PI / 2;
+			float l = tRect.centerX() - tRect.height() / 2;
+			float t = tRect.centerY() - tRect.width() / 2;
+			tRect = new RectF(l, t, l + tRect.height(), t + tRect.width());
+		}
+
+		// determine difference close to 180/0 degrees
+		if (Math.abs(FloatMath.sin(tRot - sRot)) < 0.3) {
+			// rotate t box
+			// (calculate offset for t center suppose we rotate around s center)
+			float diff = (float) (-Math.atan2(tRect.centerX() - sRect.centerX(), tRect.centerY() - sRect.centerY()) + Math.PI / 2);
+			diff -= sRot;
+			float left = sRect.centerX() + dist * FloatMath.cos(diff) - tRect.width() / 2;
+			float top = sRect.centerY() - dist * FloatMath.sin(diff) - tRect.height() / 2;
+			RectF nRect = new RectF(left, top, left + tRect.width(), top + tRect.height());
+			return nRect.intersect(sRect);
+		}
+
+		// TODO other cases not covered
+		return tRect.intersect(sRect);
+	}
+
+	void drawTestBox(Canvas cv, RectF r, float rot, String text) {
+		cv.save();
+		cv.translate(r.centerX(), r.centerY());
+		cv.rotate((float) (rot * 180 / Math.PI));
+		RectF rs = new RectF(-r.width() / 2, -r.height() / 2, r.width() / 2, r.height() / 2);
+		cv.drawRect(rs, paintIcon);
+		if (text != null) {
+			paintText.setTextSize(paintText.getTextSize() - 4);
+			cv.drawText(text, rs.centerX(), rs.centerY(), paintText);
+			paintText.setTextSize(paintText.getTextSize() + 4);
+		}
+		cv.restore();
+	}
+
+	List<TextDrawInfo> tempSearch = new ArrayList<TextDrawInfo>();
+
+	private boolean findTextIntersection(Canvas cv, RenderingContext rc, QuadTree<TextDrawInfo> boundIntersections, TextDrawInfo text) {
+		// for test purposes
+//		drawTestBox(cv, text.bounds, text.pathRotate, text.text);
+		boundIntersections.queryInBox(text.bounds, tempSearch);
+		for (int i = 0; i < tempSearch.size(); i++) {
+			TextDrawInfo t = tempSearch.get(i);
+			if (intersect(text.bounds, text.pathRotate, t.bounds, t.pathRotate)) {
+				return true;
+			}
+		}
+		if (text.minDistance > 0) {
+			RectF boundsSearch = new RectF(text.bounds);
+			boundsSearch.inset(-rc.getDensityValue(Math.max(5.0f, text.minDistance)), -rc.getDensityValue(12));
+			boundIntersections.queryInBox(boundsSearch, tempSearch);
+			// drawTestBox(cv, &boundsSearch, text.pathRotate, paintIcon, text.text, NULL/*paintText*/);
+			for (int i = 0; i < tempSearch.size(); i++) {
+				TextDrawInfo t = tempSearch.get(i);
+				if (t.minDistance > 0 && t.text.equals(text.text) &&
+						intersect(boundsSearch, text.pathRotate, t.bounds, t.pathRotate)) {
+					return true;
+				}
+			}
+		}
+		boundIntersections.insert(text, text.bounds);
+		return false;
+	}
+
+	private void drawTextOnCanvas(Canvas cv, String text, float centerX, float centerY, Paint paint, float textShadow) {
+		if (textShadow > 0) {
+			int c = paintText.getColor();
+			paintText.setStyle(Style.STROKE);
+			paintText.setColor(Color.WHITE);
+			paintText.setStrokeWidth(2 + textShadow);
+			cv.drawText(text, centerX, centerY, paint);
+			// reset
+			paintText.setStrokeWidth(2);
+			paintText.setStyle(Style.FILL);
+			paintText.setColor(c);
+		}
+		cv.drawText(text, centerX, centerY, paint);
+	}
+
+	public void drawTextOverCanvas(RenderingContext rc, Canvas cv, boolean useEnglishNames) {
+		int size = rc.textToDraw.size();
+
+		// 1. Sort text using text order
+		Collections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {
+			@Override
+			public int compare(TextDrawInfo object1, TextDrawInfo object2) {
+				return object1.textOrder - object2.textOrder;
+			}
+		});
+		RectF r = new RectF(0, 0, rc.width, rc.height);
+		r.inset(-100, -100);
+		QuadTree<TextDrawInfo> nonIntersectedBounds = new QuadTree<TextDrawInfo>(r, 4, 0.6f);
+
+		for (int i = 0; i < size; i++) {
+			TextDrawInfo text = rc.textToDraw.get(i);
+			if (text.text != null && text.text.length() > 0) {
+				int d = text.text.indexOf(MapRenderingTypes.DELIM_CHAR);
+				// not used now functionality
+				// possibly it will be used specifying english names after that character
+				if (d > 0) {
+					text.text = text.text.substring(0, d);
+				}
+				if (useEnglishNames) {
+					text.text = Junidecode.unidecode(text.text);
+				}
+
+				// sest text size before finding intersection (it is used there)
+				float textSize = rc.getDensityValue(text.textSize);
+				paintText.setTextSize(textSize);
+				paintText.setFakeBoldText(text.bold);
+				paintText.setColor(text.textColor);
+				// align center y
+				text.centerY += (-paintText.ascent());
+
+				// calculate if there is intersection
+				boolean intersects = findTextIntersection(cv, rc, nonIntersectedBounds, text);
+				if (!intersects) {
+					if (text.drawOnPath != null) {
+						if (text.textShadow > 0) {
+							paintText.setColor(Color.WHITE);
+							paintText.setStyle(Style.STROKE);
+							paintText.setStrokeWidth(2 + text.textShadow);
+							cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
+							// reset
+							paintText.setStyle(Style.FILL);
+							paintText.setStrokeWidth(2);
+							paintText.setColor(text.textColor);
+						}
+						cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
+					} else {
+						if (text.shieldRes != null) {
+							Bitmap ico = RenderingIcons.getIcon(context, text.shieldRes);
+							if (ico != null) {
+								cv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f,
+										text.centerY - ico.getHeight() / 2 - rc.getDensityValue(4.5f), paintIcon);
+							}
+						}
+
+						drawWrappedText(cv, text, textSize);
+					}
+				}
+			}
+		}
+	}
+
+	private void drawWrappedText(Canvas cv, TextDrawInfo text, float textSize) {
+		if (text.textWrap == 0) {
+			// set maximum for all text
+			text.textWrap = 40;
+		}
+
+		if (text.text.length() > text.textWrap) {
+			int start = 0;
+			int end = text.text.length();
+			int lastSpace = -1;
+			int line = 0;
+			int pos = 0;
+			int limit = 0;
+			while (pos < end) {
+				lastSpace = -1;
+				limit += text.textWrap;
+				while (pos < limit && pos < end) {
+					if (!Character.isLetterOrDigit(text.text.charAt(pos))) {
+						lastSpace = pos;
+					}
+					pos++;
+				}
+				if (lastSpace == -1) {
+					drawTextOnCanvas(cv, text.text.substring(start, pos), text.centerX, text.centerY + line * (textSize + 2), paintText,
+							text.textShadow);
+					start = pos;
+				} else {
+					drawTextOnCanvas(cv, text.text.substring(start, lastSpace), text.centerX, text.centerY + line * (textSize + 2),
+							paintText, text.textShadow);
+					start = lastSpace + 1;
+					limit += (start - pos) - 1;
+				}
+				line++;
+
+			}
+		} else {
+			drawTextOnCanvas(cv, text.text, text.centerX, text.centerY, paintText, text.textShadow);
+		}
+	}
+	
+	private void createTextDrawInfo(RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair, float xMid, float yMid,
+			Path path, PointF[] points, String name, boolean ref) {
+		render.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom);
+		render.setIntFilter(render.ALL.R_TEXT_LENGTH, name.length());
+		render.setBooleanFilter(render.ALL.R_REF, ref);
+		if(render.search(RenderingRulesStorage.TEXT_RULES)){
+			if(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE) > 0){
+				TextDrawInfo text = new TextDrawInfo(name);
+				text.fillProperties(render, xMid, yMid);
+				paintText.setTextSize(text.textSize);
+				Rect bs = new Rect();
+				paintText.getTextBounds(name, 0, name.length(), bs);
+				text.bounds = new RectF(bs);
+				text.bounds.inset(-rc.getDensityValue(3), -rc.getDensityValue(10));
+				boolean display = true;
+				if(path != null) {
+					text.drawOnPath = path;
+					display = calculatePathToRotate(rc, text, points, 
+							render.getIntPropertyValue(render.ALL.R_TEXT_ON_PATH, 0) != 0);
+				}
+				if(text.drawOnPath == null) {
+					text.bounds.offset(text.centerX, text.centerY);
+					// shift to match alignment
+					text.bounds.offset(-text.bounds.width()/2, 0);
+				} else {
+					text.bounds.offset(text.centerX - text.bounds.width()/2, text.centerY - text.bounds.height()/2);
+				}
+				if(display) {
+					rc.textToDraw.add(text);
+				}
+			}
+		}
+	}
+	
+	public void renderText(String name, RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair,
+			float xMid, float yMid, Path path, PointF[] points) {
+		String ref = null;
+		if(name.charAt(0) == MapRenderingTypes.REF_CHAR){
+			ref = name.substring(1);
+			name = ""; //$NON-NLS-1$
+			for(int k = 0; k < ref.length(); k++){
+				if(ref.charAt(k) == MapRenderingTypes.REF_CHAR){
+					if(k < ref.length() - 1){
+						name = ref.substring(k + 1);
+					}
+					ref = ref.substring(0, k);
+					break;
+				}
+			}
+		}
+		if(ref != null && ref.trim().length() > 0){
+			createTextDrawInfo(render, rc, pair, xMid, yMid, path, points, ref, true);
+		}
+
+		if(name != null && name.trim().length() > 0){
+			createTextDrawInfo(render, rc, pair, xMid, yMid, path, points, name, false);
+		}
+	}
+
+	
+	boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] points, boolean drawOnPath) {
+		int len = points.length;
+		if (!drawOnPath) {
+			p.drawOnPath = null;
+			// simply calculate rotation of path used for shields
+			p.vOffset -= p.textSize / 2 - 1;
+			float px = 0;
+			float py = 0;
+			for (int i = 1; i < len; i++) {
+				px += points[i].x - points[i - 1].x;
+				py += points[i].y - points[i - 1].y;
+			}
+			if (px != 0 || py != 0) {
+				p.pathRotate = (float) (-Math.atan2(px, py) + Math.PI / 2);
+			}
+			return true;
+		}
+
+		boolean inverse = false;
+		float roadLength = 0;
+		boolean prevInside = false;
+		float visibleRoadLength = 0;
+		float textw = p.bounds.width();
+		int last = 0;
+		int startVisible = 0;
+		float[] distances = new float[points.length - 1];
+
+		float normalTextLen = 1.5f * textw;
+		for (int i = 0; i < len; i++, last++) {
+			boolean inside = points[i].x >= 0 && points[i].x <= rc.width &&
+					points[i].x >= 0 && points[i].y <= rc.height;
+			if (i > 0) {
+				float d = FloatMath.sqrt(sqr(points[i].x - points[i - 1].x) + 
+						sqr(points[i].y - points[i - 1].y));
+				distances[i-1]= d;
+				roadLength += d;
+				if(inside) {
+					visibleRoadLength += d;
+					if(!prevInside) {
+						startVisible = i - 1;
+					}
+				} else if(prevInside) {
+					if(visibleRoadLength >= normalTextLen) {
+						break;
+					}
+					visibleRoadLength = 0;
+				}
+
+			}
+			prevInside = inside;
+		}
+		if (textw >= roadLength) {
+			return false;
+		}
+		int startInd = 0;
+		int endInd = len;
+
+		if(textw < visibleRoadLength &&  last - startVisible > 1) {
+			startInd = startVisible;
+			endInd = last;
+			// display long road name in center
+			if (visibleRoadLength > 3 * textw) {
+				boolean ch ;
+				do {
+					ch = false;
+					if(endInd - startInd > 2 && visibleRoadLength - distances[startInd] > normalTextLen){
+						visibleRoadLength -= distances[startInd];
+						startInd++;
+						ch = true;
+					}
+					if(endInd - startInd > 2 && visibleRoadLength - distances[endInd - 2] > normalTextLen){
+						visibleRoadLength -= distances[endInd - 2];
+						endInd--;
+						ch = true;
+					}
+				} while(ch);
+			}
+		}
+		// shrink path to display more text
+		if (startInd > 0 || endInd < len) {
+			// find subpath
+			Path path = new Path(); 
+			for (int i = startInd; i < endInd; i++) {
+				if (i == startInd) {
+					path.moveTo(points[i].x, points[i].y);
+				} else {
+					path.lineTo(points[i].x, points[i].y);
+				}
+			}
+			p.drawOnPath = path;
+		}
+		// calculate vector of the road (px, py) to proper rotate it
+		float px = 0;
+		float py = 0;
+		for (int i = startInd + 1; i < endInd; i++) {
+			px += points[i].x - points[i - 1].x;
+			py += points[i].y - points[i - 1].y;
+		}
+		float scale = 0.5f;
+		float plen = (float) Math.sqrt(px * px + py * py);
+		// vector ox,oy orthogonal to px,py to measure height
+		float ox = -py;
+		float oy = px;
+		if(plen > 0) {
+			float rot = (float) (-Math.atan2(px, py) + Math.PI / 2);
+			if (rot < 0) rot += Math.PI * 2;
+			if (rot > Math.PI / 2f && rot < 3 * Math.PI / 2f) {
+				rot += Math.PI;
+				inverse = true;
+				ox = -ox;
+				oy = -oy;
+			}
+			p.pathRotate = rot;
+			ox *= (p.bounds.height() / plen) / 2;
+			oy *= (p.bounds.height() / plen) / 2;
+		}
+
+		p.centerX = points[startInd].x + scale * px + ox;
+		p.centerY = points[startInd].y + scale * py + oy;
+		p.vOffset = p.textSize / 2 - 1;
+//		p.hOffset = 0;
+
+		if (inverse) {
+			Path path = new Path();
+			for (int i = endInd - 1; i >= startInd; i--) {
+				if (i == endInd - 1) {
+					path.moveTo(points[i].x, points[i].y);
+				} else {
+					path.lineTo(points[i].x, points[i].y);
+				}
+			}
+			p.drawOnPath = path;
+		}
+		return true;
+	}
+
+
+}
