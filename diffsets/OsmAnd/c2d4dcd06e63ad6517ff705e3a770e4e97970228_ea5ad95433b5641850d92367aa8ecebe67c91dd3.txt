diff --git a/OsmAnd/.cproject b/OsmAnd/.cproject
index 4193a07b939..417af8facc6 100644
--- a/OsmAnd/.cproject
+++ b/OsmAnd/.cproject
@@ -46,7 +46,7 @@
 							</tool>
 							<tool id="cdt.managedbuild.tool.gnu.c.linker.base.1072970274" name="GCC C Linker" superClass="cdt.managedbuild.tool.gnu.c.linker.base"/>
 							<tool id="cdt.managedbuild.tool.gnu.cpp.linker.base.1246211237" name="GCC C++ Linker" superClass="cdt.managedbuild.tool.gnu.cpp.linker.base">
-								<option id="gnu.cpp.link.option.paths.266312846" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths" valueType="libPaths"/>
+								<option id="gnu.cpp.link.option.paths.266312846" name="Library search path (-L)" superClass="gnu.cpp.link.option.paths"/>
 								<option id="gnu.cpp.link.option.libs.743028931" name="Libraries (-l)" superClass="gnu.cpp.link.option.libs"/>
 								<inputType id="cdt.managedbuild.tool.gnu.cpp.linker.input.2067702743" superClass="cdt.managedbuild.tool.gnu.cpp.linker.input">
 									<additionalInput kind="additionalinputdependency" paths="$(USER_OBJS)"/>
diff --git a/OsmAnd/.settings/org.eclipse.cdt.codan.core.prefs b/OsmAnd/.settings/org.eclipse.cdt.codan.core.prefs
index 581c8e8a229..5e5fc923df4 100644
--- a/OsmAnd/.settings/org.eclipse.cdt.codan.core.prefs
+++ b/OsmAnd/.settings/org.eclipse.cdt.codan.core.prefs
@@ -1,4 +1,4 @@
-#Mon Oct 24 01:30:06 CEST 2011
+#Tue Oct 25 13:50:37 CEST 2011
 eclipse.preferences.version=1
 org.eclipse.cdt.codan.checkers.errnoreturn=Warning
 org.eclipse.cdt.codan.checkers.errnoreturn.params={implicit\=>false}
@@ -6,9 +6,9 @@ org.eclipse.cdt.codan.checkers.errreturnvalue=Error
 org.eclipse.cdt.codan.checkers.errreturnvalue.params={}
 org.eclipse.cdt.codan.checkers.noreturn=Error
 org.eclipse.cdt.codan.checkers.noreturn.params={implicit\=>false}
-org.eclipse.cdt.codan.internal.checkers.AbstractClassCreation=Error
+org.eclipse.cdt.codan.internal.checkers.AbstractClassCreation=-Error
 org.eclipse.cdt.codan.internal.checkers.AbstractClassCreation.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.AmbiguousProblem=Error
+org.eclipse.cdt.codan.internal.checkers.AmbiguousProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.AmbiguousProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
 org.eclipse.cdt.codan.internal.checkers.AssignmentInConditionProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.AssignmentInConditionProblem.params={}
@@ -18,31 +18,31 @@ org.eclipse.cdt.codan.internal.checkers.CaseBreakProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.CaseBreakProblem.params={no_break_comment\=>"no break",last_case_param\=>true,empty_case_param\=>false}
 org.eclipse.cdt.codan.internal.checkers.CatchByReference=Warning
 org.eclipse.cdt.codan.internal.checkers.CatchByReference.params={unknown\=>false,exceptions\=>()}
-org.eclipse.cdt.codan.internal.checkers.CircularReferenceProblem=Error
+org.eclipse.cdt.codan.internal.checkers.CircularReferenceProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.CircularReferenceProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.FieldResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.FieldResolutionProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.FieldResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.FunctionResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.FunctionResolutionProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.FunctionResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.InvalidArguments=Error
+org.eclipse.cdt.codan.internal.checkers.InvalidArguments=-Warning
 org.eclipse.cdt.codan.internal.checkers.InvalidArguments.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.InvalidTemplateArgumentsProblem=Error
+org.eclipse.cdt.codan.internal.checkers.InvalidTemplateArgumentsProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.InvalidTemplateArgumentsProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.LabelStatementNotFoundProblem=Error
+org.eclipse.cdt.codan.internal.checkers.LabelStatementNotFoundProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.LabelStatementNotFoundProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.MemberDeclarationNotFoundProblem=Error
+org.eclipse.cdt.codan.internal.checkers.MemberDeclarationNotFoundProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.MemberDeclarationNotFoundProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.MethodResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.MethodResolutionProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.MethodResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
 org.eclipse.cdt.codan.internal.checkers.NamingConventionFunctionChecker=-Info
 org.eclipse.cdt.codan.internal.checkers.NamingConventionFunctionChecker.params={pattern\=>"^[a-z]",macro\=>true,exceptions\=>()}
 org.eclipse.cdt.codan.internal.checkers.NonVirtualDestructorProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.NonVirtualDestructorProblem.params={}
-org.eclipse.cdt.codan.internal.checkers.OverloadProblem=Error
+org.eclipse.cdt.codan.internal.checkers.OverloadProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.OverloadProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.RedeclarationProblem=Error
+org.eclipse.cdt.codan.internal.checkers.RedeclarationProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.RedeclarationProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
-org.eclipse.cdt.codan.internal.checkers.RedefinitionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.RedefinitionProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.RedefinitionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
 org.eclipse.cdt.codan.internal.checkers.ReturnStyleProblem=-Warning
 org.eclipse.cdt.codan.internal.checkers.ReturnStyleProblem.params={}
@@ -54,7 +54,7 @@ org.eclipse.cdt.codan.internal.checkers.SuggestedParenthesisProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.SuggestedParenthesisProblem.params={paramNot\=>false}
 org.eclipse.cdt.codan.internal.checkers.SuspiciousSemicolonProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.SuspiciousSemicolonProblem.params={else\=>false,afterelse\=>false}
-org.eclipse.cdt.codan.internal.checkers.TypeResolutionProblem=Error
+org.eclipse.cdt.codan.internal.checkers.TypeResolutionProblem=-Error
 org.eclipse.cdt.codan.internal.checkers.TypeResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
 org.eclipse.cdt.codan.internal.checkers.UnusedFunctionDeclarationProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.UnusedFunctionDeclarationProblem.params={macro\=>true}
@@ -62,6 +62,6 @@ org.eclipse.cdt.codan.internal.checkers.UnusedStaticFunctionProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.UnusedStaticFunctionProblem.params={macro\=>true}
 org.eclipse.cdt.codan.internal.checkers.UnusedVariableDeclarationProblem=Warning
 org.eclipse.cdt.codan.internal.checkers.UnusedVariableDeclarationProblem.params={macro\=>true,exceptions\=>("@(\#)","$Id")}
-org.eclipse.cdt.codan.internal.checkers.VariableResolutionProblem=Warning
+org.eclipse.cdt.codan.internal.checkers.VariableResolutionProblem=-Warning
 org.eclipse.cdt.codan.internal.checkers.VariableResolutionProblem.params={launchModes\=>{RUN_ON_FULL_BUILD\=>false,RUN_ON_INC_BUILD\=>false,RUN_AS_YOU_TYPE\=>true,RUN_ON_DEMAND\=>true}}
 useParentScope=false
diff --git a/OsmAnd/jni/Android.mk b/OsmAnd/jni/Android.mk
index a1be2a6585d..ce1c8868bbe 100644
--- a/OsmAnd/jni/Android.mk
+++ b/OsmAnd/jni/Android.mk
@@ -34,7 +34,7 @@ LOCAL_C_INCLUDES := $(LOCAL_PATH)/jni \
     $(ANDROID_FOLDER)/frameworks/base/include
 
 
-LOCAL_SRC_FILES := osmand/rendering.cpp
+LOCAL_SRC_FILES := osmand/rendering.cpp 
 	
 	
 LOCAL_CFLAGS := -Wall -g
diff --git a/OsmAnd/jni/osmand/common.cpp b/OsmAnd/jni/osmand/common.cpp
index 5a192cc7f1e..5e9ecac205d 100644
--- a/OsmAnd/jni/osmand/common.cpp
+++ b/OsmAnd/jni/osmand/common.cpp
@@ -3,8 +3,122 @@
 
 #include <jni.h>
 #include <string>
-std::string EMPTY_STRING;
+#include <vector>
+#include <hash_map>
+#include <SkPath.h>
+#include <SkBitmap.h>
+
+
 JNIEnv* env;
+const std::string EMPTY_STRING;
+const int WHITE_COLOR = -1;
+const int BLACK_COLOR = 0xff000000;
+
+jclass RenderingContextClass;
+jfieldID RenderingContext_interrupted;
+
+jclass RenderingIconsClass;
+jmethodID RenderingIcons_getIcon;
+
+jclass globalRef(jobject o)
+{
+	return  (jclass) env->NewGlobalRef( o);
+}
+
+class TextDrawInfo {
+public :
+	std::string text;
+
+	TextDrawInfo(std::string itext)  {
+		text = itext;
+		drawOnPath = NULL;
+	}
+	SkPath* drawOnPath;
+	float vOffset ;
+	float centerX;
+	float centerY;
+	float pathRotate;
+
+	float textSize ;
+	float minDistance ;
+	int textColor;
+	int textShadow ;
+	uint textWrap ;
+	bool bold ;
+	std::string shieldRes;
+	int textOrder;
+
+	~TextDrawInfo() {
+		if (drawOnPath != NULL) {
+			delete drawOnPath;
+		}
+	}
+};
+
+struct IconDrawInfo {
+	SkBitmap* bmp;
+	float x;
+	float y;
+};
+
+jfieldID getFid(jclass cls,const char* fieldName, const char* sig )
+{
+	return env->GetFieldID( cls, fieldName, sig);
+}
+
+
+struct RenderingContext {
+	jobject originalRC;
+	jobject androidContext;
+
+	std::vector<TextDrawInfo*> textToDraw;
+	std::vector<IconDrawInfo> iconsToDraw;
+	bool highResMode;
+	float mapTextSize;
+	float density;
+
+
+	float leftX;
+	float topY;
+	int width;
+	int height;
+
+	int zoom;
+	float rotate;
+	float tileDivisor;
+
+	// debug purpose
+	int pointCount;
+	int pointInsideCount;
+	int visible;
+	int allObjects;
+	int textRendering;
+
+	// use to calculate points
+	float calcX;
+	float calcY;
+
+	float cosRotateTileSize;
+	float sinRotateTileSize;
+
+	int shadowRenderingMode;
+
+	// not expect any shadow
+	int shadowLevelMin;
+	int shadowLevelMax;
+
+	bool interrupted() {
+		return env->GetBooleanField(originalRC, RenderingContext_interrupted);
+	}
+	~RenderingContext() {
+		for (uint i = 0; i < textToDraw.size(); i++) {
+			delete textToDraw.at(i);
+		}
+	}
+};
+
+
+
 
 std::string getStringField(jobject o, jfieldID fid)
 {
@@ -46,5 +160,58 @@ std::string getStringMethod(jobject o, jmethodID fid, int i)
 	return res;
 }
 
+float getDensityValue(RenderingContext* rc, float val) {
+	if (rc -> highResMode && rc -> density > 1) {
+		return val * rc -> density * rc -> mapTextSize;
+	} else {
+		return val * rc -> mapTextSize;
+	}
+}
+
+SkBitmap* getNativeBitmap(jobject bmpObj){
+	if(bmpObj == NULL){
+		return NULL;
+	}
+	jclass bmpClass = env->GetObjectClass(bmpObj);
+	SkBitmap* bmp = (SkBitmap*)env->CallIntMethod(bmpObj, env->GetMethodID(bmpClass, "ni", "()I"));
+	env->DeleteLocalRef(bmpClass);
+	return bmp;
+}
+
+std::hash_map<std::string, SkBitmap*> cachedBitmaps;
+SkBitmap* getCachedBitmap(RenderingContext* rc, std::string js)
+{
+	if (cachedBitmaps.find(js) != cachedBitmaps.end()) {
+		return cachedBitmaps[js];
+	}
+	jstring jstr = env->NewStringUTF(js.c_str());
+	jobject bmp = env->CallStaticObjectMethod(RenderingIconsClass, RenderingIcons_getIcon, rc->androidContext, jstr);
+	SkBitmap* res = getNativeBitmap(bmp);
+	env->DeleteLocalRef(bmp);
+	env->DeleteLocalRef(jstr);
+	if(res != NULL){
+		res = new SkBitmap(*res);
+	}
+	cachedBitmaps[js] = res;
+	return res;
+}
+
+void loadJniCommon(jobject rc) {
+
+	RenderingContextClass = globalRef(env->GetObjectClass(rc));
+	RenderingContext_interrupted = getFid(RenderingContextClass, "interrupted", "Z");
+
+	RenderingIconsClass = globalRef(env->FindClass("net/osmand/plus/render/RenderingIcons"));
+	RenderingIcons_getIcon = env->GetStaticMethodID(RenderingIconsClass, "getIcon",
+			"(Landroid/content/Context;Ljava/lang/String;)Landroid/graphics/Bitmap;");
+
+}
+
+void unloadJniCommon() {
+	env->DeleteGlobalRef(RenderingContextClass);
+	env->DeleteGlobalRef(RenderingIconsClass);
+}
+
+
 
 #endif
diff --git a/OsmAnd/jni/osmand/mapObjects.cpp b/OsmAnd/jni/osmand/mapObjects.cpp
index 0ccbb8a1a3f..27d8e7f393f 100644
--- a/OsmAnd/jni/osmand/mapObjects.cpp
+++ b/OsmAnd/jni/osmand/mapObjects.cpp
@@ -19,6 +19,7 @@ jclass BinaryMapDataObjectClass;
 jmethodID BinaryMapDataObject_getPointsLength;
 jmethodID BinaryMapDataObject_getPoint31YTile;
 jmethodID BinaryMapDataObject_getPoint31XTile;
+jmethodID BinaryMapDataObject_getHighwayAttributes;
 jmethodID BinaryMapDataObject_getTypes;
 jmethodID BinaryMapDataObject_getName;
 jmethodID BinaryMapDataObject_getTagValue;
@@ -58,6 +59,7 @@ class MapDataObject : BaseMapDataObject
 	std::vector< int>  types;
 	std::vector< std::pair<int, int> >  points;
 	std::vector< std::pair<std::string, std::string> >  tagValues;
+	int highwayAttributes;
 };
 
 
@@ -120,6 +122,7 @@ std::vector <BaseMapDataObject* > marshalObjects(jobjectArray binaryMapDataObjec
 					o->points.push_back(std::pair<int, int>(tx, ty));
 				}
 				o->name = getStringMethod(binaryMapDataObject, BinaryMapDataObject_getName);
+				o->highwayAttributes = env->CallIntMethod(binaryMapDataObject, BinaryMapDataObject_getHighwayAttributes);
 				env->ReleaseIntArrayElements(types, els, JNI_ABORT);
 				env->DeleteLocalRef(types);
 				v.push_back((BaseMapDataObject* )o);
@@ -156,6 +159,7 @@ void loadJniMapObjects()
 	BinaryMapDataObject_getPointsLength = env->GetMethodID(BinaryMapDataObjectClass, "getPointsLength", "()I");
 	BinaryMapDataObject_getPoint31YTile = env->GetMethodID(BinaryMapDataObjectClass, "getPoint31YTile", "(I)I");
 	BinaryMapDataObject_getPoint31XTile = env->GetMethodID(BinaryMapDataObjectClass, "getPoint31XTile", "(I)I");
+	BinaryMapDataObject_getHighwayAttributes = env->GetMethodID(BinaryMapDataObjectClass, "getHighwayAttributes", "()I");
 	BinaryMapDataObject_getTypes = env->GetMethodID(BinaryMapDataObjectClass, "getTypes", "()[I");
 	BinaryMapDataObject_getName = env->GetMethodID(BinaryMapDataObjectClass, "getName", "()Ljava/lang/String;");
 	BinaryMapDataObject_getTagValue = env->GetMethodID(BinaryMapDataObjectClass, "getTagValue",
diff --git a/OsmAnd/jni/osmand/renderRules.cpp b/OsmAnd/jni/osmand/renderRules.cpp
index cc60b2bc89d..359faa7577c 100644
--- a/OsmAnd/jni/osmand/renderRules.cpp
+++ b/OsmAnd/jni/osmand/renderRules.cpp
@@ -1,3 +1,6 @@
+#ifndef _OSMAND_RENDER_RULES
+#define _OSMAND_RENDER_RULES
+
 #include <jni.h>
 #include <android/log.h>
 #include <iterator>
@@ -41,32 +44,33 @@ jfieldID RenderingRuleSearchRequest_savedFvalues;
 
 class RenderingRuleProperty
 {
-public :
+public:
 	int type;
 	bool input;
 	std::string attrName;
 	// order in
-	int id ;
+	int id;
 	RenderingRuleProperty(int type, bool input, std::string& name, int id) :
-		type(type), input(input), attrName(name), id(id)
-	{}
+			type(type), input(input), attrName(name), id(id) {
+	}
 
-	bool isFloat()
-	{
+	bool isFloat() {
 		return type == FLOAT_TYPE;
 	}
 
-	const static int TRUE_VALUE = 1;
-	const static int FALSE_VALUE = 0;
-private :
-   const static int INT_TYPE = 1;
-   const static int FLOAT_TYPE = 2;
-   const static int STRING_TYPE = 3;
-   const static int COLOR_TYPE = 4;
-   const static int BOOLEAN_TYPE = 5;
+
+private:
+	const static int INT_TYPE = 1;
+	const static int FLOAT_TYPE = 2;
+	const static int STRING_TYPE = 3;
+	const static int COLOR_TYPE = 4;
+	const static int BOOLEAN_TYPE = 5;
 
 };
 
+const static int TRUE_VALUE = 1;
+const static int FALSE_VALUE = 0;
+
 
 class RenderingRule
 {
@@ -471,21 +475,26 @@ private :
 		clearState();
 	}
 
-public :
-
+public:
 
-	int getIntPropertyValue(RenderingRuleProperty* prop)
-	{
+	int getIntPropertyValue(RenderingRuleProperty* prop) {
 		if (prop == NULL) {
 			return 0;
 		}
 		return values[prop->id];
 	}
 
+	int getIntPropertyValue(RenderingRuleProperty* prop, int def) {
+		if (prop == NULL) {
+			return def;
+		}
+		return values[prop->id];
+	}
+
 	std::string getStringPropertyValue(RenderingRuleProperty* prop)
 	{
 		if (prop == NULL) {
-			return "";
+			return EMPTY_STRING;
 		}
 		int s = values[prop->id];
 		return storage -> getDictionaryValue(s);
@@ -522,7 +531,7 @@ public :
 	void setBooleanFilter(RenderingRuleProperty* p, bool filter) {
 		if (p != NULL) {
 			// assert p->input;
-			values[p->id] = filter ? RenderingRuleProperty::TRUE_VALUE : RenderingRuleProperty::FALSE_VALUE;
+			values[p->id] = filter ? TRUE_VALUE : FALSE_VALUE;
 		}
 	}
 
@@ -646,11 +655,6 @@ public :
 };
 
 
-jclass globalRef(jobject o)
-{
-	return  (jclass) env->NewGlobalRef( o);
-}
-
 RenderingRuleSearchRequest* initSearchRequest(jobject renderingRuleSearchRequest)
 {
 	return new RenderingRuleSearchRequest(renderingRuleSearchRequest);
@@ -708,3 +712,4 @@ void unloadJniRenderRules() {
 
 
 
+#endif
diff --git a/OsmAnd/jni/osmand/rendering.cpp b/OsmAnd/jni/osmand/rendering.cpp
index 3bcda9b1df6..ea5accd9797 100644
--- a/OsmAnd/jni/osmand/rendering.cpp
+++ b/OsmAnd/jni/osmand/rendering.cpp
@@ -1,5 +1,5 @@
-
 #include <jni.h>
+#include <math.h>
 #include <android/log.h>
 #include <stdio.h>
 #include <vector>
@@ -19,75 +19,12 @@
 
 #include "common.cpp"
 #include "renderRules.cpp"
+#include "textdraw.cpp"
 #include "mapObjects.cpp"
 
 
-jclass RenderingContextClass;
-jfieldID RenderingContext_interrupted;
-
-jclass RenderingIconsClass;
-jmethodID RenderingIcons_getIcon;
-
-
-struct IconDrawInfo {
-	SkBitmap* bmp;
-	float x;
-	float y;
-};
-
 char debugMessage[1024];
 
-typedef struct RenderingContext {
-		jobject originalRC;
-		jobject androidContext;
-		
-		// TODO text
-		// List<TextDrawInfo> textToDraw = new ArrayList<TextDrawInfo>();
-		bool highResMode;
-		float mapTextSize ;
-		float density ;
-		std::vector<IconDrawInfo> iconsToDraw;
-
-		float leftX;
-		float topY;
-		int width;
-		int height;
-
-		int zoom;
-		float rotate;
-		float tileDivisor;
-
-		// debug purpose
-		int pointCount ;
-		int pointInsideCount;
-		int visible;
-		int allObjects;
-
-		// use to calculate points
-		float calcX;
-		float calcY;
-		
-		float cosRotateTileSize;
-		float sinRotateTileSize;
-		
-		int shadowRenderingMode;
-		
-		// not expect any shadow
-		int shadowLevelMin;
-		int shadowLevelMax;
-
-		bool interrupted() {
-			return env->GetBooleanField(originalRC, RenderingContext_interrupted);
-		}
-} RenderingContext;
-
-
-
-jfieldID getFid(jclass cls,const char* fieldName, const char* sig )
-{
-	return env->GetFieldID( cls, fieldName, sig);
-}
-
 
  void calcPoint(MapDataObject* mObj, jint ind, RenderingContext* rc) {
 	rc->pointCount++;
@@ -156,33 +93,7 @@ SkPathEffect* getDashEffect(std::string input){
 	return r;
 }
 
-SkBitmap* getNativeBitmap(jobject bmpObj){
-	if(bmpObj == NULL){
-		return NULL;
-	}
-	jclass bmpClass = env->GetObjectClass(bmpObj);
-	SkBitmap* bmp = (SkBitmap*)env->CallIntMethod(bmpObj, env->GetMethodID(bmpClass, "ni", "()I"));
-	env->DeleteLocalRef(bmpClass);
-	return bmp;
-}
 
-std::hash_map<std::string, SkBitmap*> cachedBitmaps;
-SkBitmap* getCachedBitmap(RenderingContext* rc, std::string js)
-{
-	if (cachedBitmaps.find(js) != cachedBitmaps.end()) {
-		return cachedBitmaps[js];
-	}
-	jstring jstr = env->NewStringUTF(js.c_str());
-	jobject bmp = env->CallStaticObjectMethod(RenderingIconsClass, RenderingIcons_getIcon, rc->androidContext, jstr);
-	SkBitmap* res = getNativeBitmap(bmp);
-	env->DeleteLocalRef(bmp);
-	env->DeleteLocalRef(jstr);
-	if(res != NULL){
-		res = new SkBitmap(*res);
-	}
-	cachedBitmaps[js] = res;
-	return res;
-}
 
 
 int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int area, RenderingContext* rc) {
@@ -275,13 +186,73 @@ int updatePaint(RenderingRuleSearchRequest* req, SkPaint* paint, int ind, int ar
 	return 1;
 }
 
+void drawPointText(RenderingRuleSearchRequest* req, RenderingContext* rc, std::string tag, std::string value,
+		float xText, float yText, std::string name,
+		// line text properties
+		SkPath* path, float pathRotate, float roadLength, float xCenter, float yCenter,
+		SkPaint* paintText)
+{
+	if (name.at(0) == REF_CHAR) {
+		std::string ref = name.substr(1);
+		name = ""; //$NON-NLS-1$
+		for (uint k = 0; k < ref.length(); k++) {
+			if (ref.at(k) == REF_CHAR) {
+				if (k < ref.length() - 1) {
+					name = ref.substr(k + 1);
+				}
+				ref = ref.substr(0, k);
+				break;
+			}
+		}
+		if (ref.length() > 0) {
+			req->setInitialTagValueZoom(tag, value, rc->zoom);
+			req->setIntFilter(req->props()->R_TEXT_LENGTH, ref.length());
+			req->setBooleanFilter(req->props()->R_REF, true);
+			if (req->searchRule(RenderingRulesStorage::TEXT_RULES)) {
+				if (req->getIntPropertyValue(req->props()->R_TEXT_SIZE) > 0) {
+					TextDrawInfo* text = new TextDrawInfo(ref);
+					fillTextProperties(text, req, xText, yText);
+					rc->textToDraw.push_back(text);
+				}
+			}
+		}
+	}
+
+	req->setInitialTagValueZoom(tag, value, rc->zoom);
+	req->setIntFilter(req->props()->R_TEXT_LENGTH, name.length());
+	req->setBooleanFilter(req->props()->R_REF, false);
+	if (req->searchRule(RenderingRulesStorage::TEXT_RULES) &&
+			req->getIntPropertyValue(req->props()->R_TEXT_SIZE) > 0) {
+		if (path == NULL || req->getIntPropertyValue(req->props()->R_TEXT_ON_PATH, 0) == 0) {
+			TextDrawInfo* info = new TextDrawInfo(name);
+			fillTextProperties(info, req, xText, yText);
+			rc->textToDraw.push_back(info);
+		} else {
+			paintText->setTextSize(req->getIntPropertyValue(req->props()->R_TEXT_SIZE) > 0);
+			if (paintText->measureText(name.c_str(), name.size()) < roadLength) {
+				TextDrawInfo* text = new TextDrawInfo(name);
+				fillTextProperties(text, req, xCenter / 2, yCenter / 2);
+				text->pathRotate = pathRotate;
+				text->drawOnPath = new SkPath(*path);
+				int strokeWidth = req->getIntPropertyValue(req->props()->R_TEXT_SIZE);
+				text->vOffset = strokeWidth / 2 - 1;
+				rc->textToDraw.push_back(text);
+			}
+		}
+    }
+}
+
+void drawPointText(RenderingRuleSearchRequest* req, RenderingContext* rc, std::string tag, std::string value,
+		float xText, float yText, std::string name){
+	drawPointText(req, rc, tag, value, xText, yText, name, NULL, 0, 0, 0, 0, NULL);
+}
+
 void drawPolylineShadow(SkCanvas* cv, SkPaint* paint, RenderingContext* rc, SkPath* path, int shadowColor,
 		int shadowRadius) {
 	// blurred shadows
 	if (rc->shadowRenderingMode == 2 && shadowRadius > 0) {
 		// simply draw shadow? difference from option 3 ?
-		// paint.setColor(shadowRadius);
-		// paint.setColor(0xffffffff);
+		// paint->setColor(0xffffffff);
 		paint->setLooper(new SkBlurDrawLooper(shadowRadius, 0, 0, shadowColor))->unref();
 		cv->drawPath(*path, *paint);
 	}
@@ -291,14 +262,62 @@ void drawPolylineShadow(SkCanvas* cv, SkPaint* paint, RenderingContext* rc, SkPa
 		paint->setLooper(NULL);
 		paint->setStrokeWidth(paint->getStrokeWidth() + shadowRadius * 2);
 		paint->setColor(0xffbababa);
-//			paint.setColor(shadowColor);
+//		paint->setColor(shadowColor);
 		cv->drawPath(*path, *paint);
 	}
 }
 
- void drawPolyline(MapDataObject* mObj,	RenderingRuleSearchRequest* req, SkCanvas* cv, SkPaint* paint,
- 		RenderingContext* rc, std::pair<std::string, std::string> pair, int layer, int drawOnlyShadow)
- {
+std::vector<SkPaint> oneWayPaints;
+SkPaint* oneWayPaint(){
+	SkPaint* oneWay = new SkPaint;
+	oneWay->setStyle(SkPaint::kStroke_Style);
+	oneWay->setColor(0xff6c70d5);
+	oneWay->setAntiAlias(true);
+	return oneWay;
+}
+void drawOneWayPaints(SkCanvas* cv, SkPath* p) {
+	if (oneWayPaints.size() == 0) {
+		SkPathEffect* arrowDashEffect1 = new SkDashPathEffect((float []){ 0, 12, 10, 152 }, 4, 0);
+		SkPathEffect* arrowDashEffect2 = new SkDashPathEffect((float[]){ 0, 12, 9, 153 }, 4, 1);
+		SkPathEffect* arrowDashEffect3 = new SkDashPathEffect((float[]){ 0, 18, 2, 154 }, 4, 1);
+		SkPathEffect* arrowDashEffect4 = new SkDashPathEffect((float[]){ 0, 18, 1, 155 }, 4, 1);
+
+		SkPaint* p = oneWayPaint();
+		p->setStrokeWidth(1);
+		p->setPathEffect(arrowDashEffect1)->unref();
+		oneWayPaints.push_back(*p);
+
+		p = oneWayPaint();
+		p->setStrokeWidth(2);
+		p->setPathEffect(arrowDashEffect2)->unref();
+		oneWayPaints.push_back(*p);
+
+		p = oneWayPaint();
+		p->setStrokeWidth(3);
+		p->setPathEffect(arrowDashEffect3)->unref();
+		oneWayPaints.push_back(*p);
+
+		p = oneWayPaint();
+		p->setStrokeWidth(4);
+		p->setPathEffect(arrowDashEffect4)->unref();
+		oneWayPaints.push_back(*p);
+	}
+
+	for (size_t i = 0; i < oneWayPaints.size(); i++) {
+		cv->drawPath(*p, oneWayPaints.at(i));
+	}
+}
+
+bool isOneWayWay(int highwayAttributes) {
+	return (highwayAttributes & 1) > 0;
+}
+
+bool isRoundabout(int highwayAttributes) {
+	return ((highwayAttributes >> 2) & 1) > 0;
+}
+
+void drawPolyline(MapDataObject* mObj, RenderingRuleSearchRequest* req, SkCanvas* cv, SkPaint* paint,
+		RenderingContext* rc, std::pair<std::string, std::string> pair, int layer, int drawOnlyShadow) {
 	jint length = mObj->points.size();
 	if (length < 2) {
 		return;
@@ -308,28 +327,54 @@ void drawPolylineShadow(SkCanvas* cv, SkPaint* paint, RenderingContext* rc, SkPa
 
 	req->setInitialTagValueZoom(tag, value, rc->zoom);
 	req->setIntFilter(req->props()->R_LAYER, layer);
-	// TODO oneway
-	// int oneway = 0;
-	//if(rc -> zoom >= 16 && "highway".equals(pair.tag) && MapRenderingTypes.isOneWayWay(obj.getHighwayAttributes())){
-	//strcmp("highway") oneway = 1;
-	//}
+	bool oneway = false;
+	if (rc->zoom >= 16 && "highway" == pair.first && isOneWayWay(mObj->highwayAttributes)) {
+		oneway = true;
+	}
 
 	bool rendered = req->searchRule(2);
-	if (!rendered || !updatePaint(req,paint, 0, 0, rc)) {
+	if (!rendered || !updatePaint(req, paint, 0, 0, rc)) {
 		return;
 	}
 
 	rc->visible++;
-	SkPath path ;
+	SkPath path;
 	int i = 0;
-	// TODO calculate text
+	float pathRotate = 0;
+	float roadLength = 0;
+	bool inverse = false;
+	float xPrev = 0;
+	float yPrev = 0;
+	float xMid = 0;
+	float yMid = 0;
+	SkPoint middlePoint;
+	int middle = length / 2;
 	for (; i < length; i++) {
 		calcPoint(mObj, i, rc);
+		if(i == 0 || i == length -1){
+			xMid += rc->calcX;
+			yMid += rc->calcY;
+		}
 		if (i == 0) {
 			path.moveTo(rc->calcX, rc->calcY);
 		} else {
+			roadLength += std::sqrt((rc->calcX - xPrev) * (rc->calcX - xPrev) + (rc->calcY - yPrev) * (rc->calcY - yPrev));
+			if(i == middle){
+				middlePoint.set(rc->calcX, rc->calcY);
+				float rot = - std::atan2(rc->calcX - xPrev, rc->calcY - yPrev) * 180 / M_PI;
+				if (rot < 0) {
+					rot += 360;
+				}
+				if (rot < 180) {
+					rot += 180;
+					inverse = true;
+				}
+				pathRotate = (float) rot;
+			}
 			path.lineTo(rc->calcX, rc->calcY);
 		}
+		xPrev = rc->calcX;
+		yPrev = rc->calcY;
 	}
 	if (i > 0) {
 		if (drawOnlyShadow) {
@@ -344,17 +389,26 @@ void drawPolylineShadow(SkCanvas* cv, SkPaint* paint, RenderingContext* rc, SkPa
 					cv->drawPath(path, *paint);
 				}
 			}
-			// TODO oneway text
-//			if (oneway && !drawOnlyShadow) {
-//				Paint[] paints = getOneWayPaints();
-//				for (int i = 0; i < paints.length; i++) {
-//					canvas.drawPath(path, paints[i]);
-//				}
-//			}
-//			if (!drawOnlyShadow && obj.getName() != null && obj.getName().length() > 0) {
-//				calculatePolylineText(obj, render, rc, pair, path, pathRotate, roadLength, inverse, xMid, yMid,
-//						middlePoint);
-//			}
+			if (oneway && !drawOnlyShadow) {
+				drawOneWayPaints(cv, &path);
+			}
+			if (!drawOnlyShadow && mObj->name.length() > 0) {
+				if (inverse) {
+					path.rewind();
+					bool st = true;
+					for (i = length - 1; i >= 0; i--) {
+						calcPoint(mObj, i, rc);
+						if (st) {
+							st = false;
+							path.moveTo(rc->calcX, rc->calcY);
+						} else {
+							path.lineTo(rc->calcX, rc->calcY);
+						}
+					}
+				}
+				drawPointText(req, rc,pair.first, pair.second, middlePoint.fX, middlePoint.fY, mObj->name,
+						&path, pathRotate, roadLength, xMid, yMid, paint);
+			}
 		}
 	}
 }
@@ -391,11 +445,10 @@ void drawMultiPolygon(MultiPolygonObject* mapObject,RenderingRuleSearchRequest*
 			}
 		}
 		if (cnt > 0) {
-			// TODO text
-			// String name = ((MultyPolygon) obj).getName(i);
-			// if (name != null) {
-			// drawPointText(render, rc, new TagValuePair(tag, value), xText / cnt, yText / cnt, name);
-			// }
+			std::string name = mapObject->names.at(i);
+			if (name.length() > 0) {
+				drawPointText(req, rc, mapObject->tag, mapObject->value, xText / cnt, yText / cnt, name);
+			}
 		}
 	}
 
@@ -408,6 +461,7 @@ void drawMultiPolygon(MultiPolygonObject* mapObject,RenderingRuleSearchRequest*
 	}
 }
 
+
 void drawPolygon(MapDataObject* mObj, RenderingRuleSearchRequest* req, SkCanvas* cv, SkPaint* paint,
 		  		RenderingContext* rc, std::pair<std::string, std::string> pair) {
 	jint length = mObj->points.size();
@@ -429,8 +483,6 @@ void drawPolygon(MapDataObject* mObj, RenderingRuleSearchRequest* req, SkCanvas*
 	rc->visible++;
 	SkPath path;
 	int i = 0;
-	float px = 0;
-	float py = 0;
 	for (; i < length; i++) {
 		calcPoint(mObj, i, rc);
 		if (i == 0) {
@@ -438,20 +490,18 @@ void drawPolygon(MapDataObject* mObj, RenderingRuleSearchRequest* req, SkCanvas*
 		} else {
 			path.lineTo(rc->calcX, rc->calcY);
 		}
-		xText += px;
-		yText += py;
+		xText += rc->calcX;
+		yText += rc->calcY;
 	}
 
 	cv->drawPath(path, *paint);
 	if (updatePaint(req, paint, 1, 0, rc)) {
 		cv->drawPath(path, *paint);
 	}
-	// TODO polygon text
-//			String name = obj.getName();
-//			if(name != null){
-//				drawPointText(render, rc, pair, xText / len, yText / len, name);
-//			}
-//		}
+	std::string name = mObj->name;
+	if (name.length() > 0) {
+		drawPointText(req, rc, tag, value, xText / length, yText / length, name);
+	}
 }
 
 void drawPoint(MapDataObject* mObj,	RenderingRuleSearchRequest* req, SkCanvas* cv, SkPaint* paint,
@@ -464,12 +514,11 @@ void drawPoint(MapDataObject* mObj,	RenderingRuleSearchRequest* req, SkCanvas* c
 	req->searchRule(1);
 	std::string resId = req->getStringPropertyValue(req-> props()-> R_ICON);
 	SkBitmap* bmp = getCachedBitmap(rc, resId);
-	jstring name = NULL;
+	std::string name = EMPTY_STRING;
 	if (renderText) {
-		// TODO text
-//		name = obj.getName();
+		name = mObj->name;
 	}
-	if (!bmp && !name) {
+	if (!bmp && name.length() == 0) {
 		return;
 	}
 
@@ -496,9 +545,8 @@ void drawPoint(MapDataObject* mObj,	RenderingRuleSearchRequest* req, SkCanvas* c
 		ico.bmp = bmp;
 		rc->iconsToDraw.push_back(ico);
 	}
-	if (name != NULL) {
-		// TODO text
-//		drawPointText(render, rc, pair, px, py, name);
+	if (name.length() > 0) {
+		drawPointText(req, rc, tag, value, px, py, name);
 	}
 
 }
@@ -586,39 +634,21 @@ void mergeRenderingContext(jobject orc, RenderingContext* rc)
 	env->SetIntField( orc, getFid(RenderingContextClass, "pointInsideCount", "I" ) , rc->pointInsideCount);
 	env->SetIntField( orc, getFid(RenderingContextClass, "visible", "I" ) , rc->visible);
 	env->SetIntField( orc, getFid(RenderingContextClass, "allObjects", "I" ) , rc->allObjects);
+	env->SetIntField( orc, getFid(RenderingContextClass, "textRenderingTime", "I" ) , rc->textRendering);
 	env->DeleteLocalRef(rc->androidContext);
 
 }
 
-void loadLibrary(jobject rc)
-{
-
-   RenderingContextClass = globalRef(env->GetObjectClass( rc));
-   RenderingContext_interrupted = getFid( RenderingContextClass, "interrupted", "Z" );
-
-   RenderingIconsClass = globalRef(env->FindClass( "net/osmand/plus/render/RenderingIcons"));
-   RenderingIcons_getIcon = env->GetStaticMethodID(RenderingIconsClass, "getIcon","(Landroid/content/Context;Ljava/lang/String;)Landroid/graphics/Bitmap;");
-
-   loadJNIRenderingRules();
-   loadJniMapObjects();
-
-}
-
-void unloadLibrary()
-{
-   env->DeleteGlobalRef( RenderingContextClass );
-   env->DeleteGlobalRef( RenderingIconsClass );
-
-   unloadJniRenderRules();
-   unloadJniMapObjects();
+void loadLibrary(jobject rc) {
+	loadJniCommon(rc);
+	loadJNIRenderingRules();
+	loadJniMapObjects();
 }
 
-float getDensityValue(RenderingContext* rc, float val) {
-	if (rc -> highResMode && rc -> density > 1) {
-		return val * rc -> density * rc -> mapTextSize;
-	} else {
-		return val * rc -> mapTextSize;
-	}
+void unloadLibrary() {
+	unloadJniMapObjects();
+	unloadJniRenderRules();
+	unloadJniCommon();
 }
 
 
@@ -780,12 +810,14 @@ void doRendering(std::vector <BaseMapDataObject* > mapDataObjects, SkCanvas* can
 	objectDrawn(true);
 	drawIconsOverCanvas(rc, canvas);
 
-
+	struct timeval startInit;
+	struct timeval endInit;
+	gettimeofday(&startInit, NULL);
 	objectDrawn(true);
-	// TODO text
-//	drawTextOverCanvas(rc, cv, useEnglishNames);
-
+	drawTextOverCanvas(rc, canvas);
+	gettimeofday(&endInit, NULL);
 
+	rc->textRendering = (endInit.tv_sec * 1000 + endInit.tv_usec/1000) - (startInit.tv_sec * 1000 + startInit.tv_usec / 1000);
 }
 
 
diff --git a/OsmAnd/jni/osmand/textdraw.cpp b/OsmAnd/jni/osmand/textdraw.cpp
new file mode 100644
index 00000000000..f2d171b7536
--- /dev/null
+++ b/OsmAnd/jni/osmand/textdraw.cpp
@@ -0,0 +1,268 @@
+#include <vector>
+#include <set>
+#include <algorithm>
+#include <hash_map>
+#include <time.h>
+#include <jni.h>
+#include "SkTypes.h"
+#include "SkTypeface.h"
+#include "SkCanvas.h"
+#include "SkPaint.h"
+#include "SkPath.h"
+
+#include "common.cpp"
+#include "renderRules.cpp"
+
+const char REF_CHAR = ((char)0x0019);
+const char DELIM_CHAR = ((char)0x0018);
+
+
+
+void fillTextProperties(TextDrawInfo* info, RenderingRuleSearchRequest* render, float cx, float cy) {
+	info->centerX = cx;
+	info->centerY = cy + render->getIntPropertyValue(render->props()->R_TEXT_DY, 0);
+	info->textColor = render->getIntPropertyValue(render->props()->R_TEXT_COLOR);
+	if (info->textColor == 0) {
+		info->textColor = 0xff000000;
+	}
+	info->textSize = render->getIntPropertyValue(render->props()->R_TEXT_SIZE);
+	info->textShadow = render->getIntPropertyValue(render->props()->R_TEXT_HALO_RADIUS, 0);
+	info->textWrap = render->getIntPropertyValue(render->props()->R_TEXT_WRAP_WIDTH, 0);
+	info->bold = render->getIntPropertyValue(render->props()->R_TEXT_BOLD, 0) > 0;
+	info->minDistance = render->getIntPropertyValue(render->props()->R_TEXT_MIN_DISTANCE, 0);
+	info->shieldRes = render->getStringPropertyValue(render->props()->R_TEXT_SHIELD);
+	info->textOrder = render->getIntPropertyValue(render->props()->R_TEXT_ORDER, 20);
+}
+
+bool isLetterOrDigit(char c)
+{
+	return c != ' ';
+}
+
+void drawTextOnCanvas(SkCanvas* cv, std::string text, float centerX, float centerY, SkPaint& paintText,
+		float textShadow) {
+	if (textShadow > 0) {
+		int c = paintText.getColor();
+		paintText.setStyle(SkPaint::kStroke_Style);
+		paintText.setColor(-1); // white
+		paintText.setStrokeWidth(2 + textShadow);
+		cv->drawText(text.c_str(), text.length(), centerX, centerY, paintText);
+// reset
+		paintText.setStrokeWidth(2);
+		paintText.setStyle(SkPaint::kFill_Style);
+		paintText.setColor(c);
+	}
+	cv->drawText(text.data(), text.length(), centerX, centerY, paintText);
+}
+
+
+void drawWrappedText(SkCanvas* cv, TextDrawInfo* text, float textSize, SkPaint& paintText) {
+	if(text->textWrap == 0) {
+		// set maximum for all text
+		text->textWrap = 40;
+	}
+
+	if(text->text.length() > text->textWrap) {
+		int start = 0;
+		int end = text->text.length();
+		int lastSpace = -1;
+		int line = 0;
+		int pos = 0;
+		int limit = 0;
+		while(pos < end) {
+			lastSpace = -1;
+			limit += text->textWrap;
+			while(pos < limit && pos < end) {
+				if(!isLetterOrDigit(text->text.at(pos))) {
+					lastSpace = pos;
+				}
+				pos++;
+			}
+			if(lastSpace == -1) {
+				drawTextOnCanvas(cv, text->text.substr(start, pos),
+						text->centerX, text->centerY + line * (textSize + 2), paintText, text->textShadow);
+				start = pos;
+			} else {
+				drawTextOnCanvas(cv, text->text.substr(start, lastSpace),
+						text->centerX, text->centerY + line * (textSize + 2), paintText, text->textShadow);
+				start = lastSpace + 1;
+				limit += (start - pos) - 1;
+			}
+			line++;
+
+		}
+	} else {
+		drawTextOnCanvas(cv, text->text, text->centerX, text->centerY, paintText, text->textShadow);
+	}
+}
+
+const static bool findAllTextIntersections = true;
+bool findTextIntersection(RenderingContext* rc, std::vector<SkRect>& boundsNotPathIntersect,
+		std::vector<SkRect>&  boundsPathIntersect, /*Comparator<RectF> c, */TextDrawInfo* text,
+		SkPaint* paintText) {
+	bool horizontalWayDisplay = (text->pathRotate > 45 && text->pathRotate < 135)
+			|| (text->pathRotate > 225 && text->pathRotate < 315);
+	//text->minDistance = 0;
+
+	float textWidth = paintText->measureText(text->text.c_str(), text->text.length()) +
+			(!horizontalWayDisplay ? 0 : text->minDistance);
+	// Paint.ascent is negative, so negate it.
+	SkPaint::FontMetrics fm;
+	paintText->getFontMetrics(&fm);
+	int ascent = (int) std::ceil(-fm.fAscent);
+	int descent = (int) std::ceil(fm.fDescent);
+	float textHeight = ascent + descent + (horizontalWayDisplay ? 0 : text->minDistance) + getDensityValue(rc, 5);
+
+	SkRect bounds;
+	if (text->drawOnPath == NULL || horizontalWayDisplay) {
+		bounds.set(text->centerX - textWidth / 2, text->centerY - textHeight / 2, text->centerX + textWidth / 2,
+				text->centerY + textHeight / 2);
+	} else {
+		bounds.set(text->centerX - textHeight / 2, text->centerY - textWidth / 2, text->centerX + textHeight / 2,
+				text->centerY + textWidth / 2);
+	}
+	std::vector< SkRect >* boundsIntersect =
+			text->drawOnPath == NULL || findAllTextIntersections ? &boundsNotPathIntersect : &boundsPathIntersect;
+	if (boundsIntersect->size()==0) {
+		boundsIntersect->push_back(bounds);
+	} else {
+		int diff = (int) (getDensityValue(rc, 3));
+		int diff2 = (int) (getDensityValue(rc, 15));
+		// implement binary search
+		// TODO binary search
+//		int index = Collections.binarySearch(boundsIntersect, bounds, c);
+//		if (index < 0) {
+//			index = -(index + 1);
+//		}
+		int index = 0;
+		// find sublist that is appropriate
+		uint e = index;
+		while (e < boundsIntersect->size()) {
+			if (boundsIntersect->at(e).fLeft < bounds.fRight) {
+				e++;
+			} else {
+				break;
+			}
+		}
+		int st = index - 1;
+		while (st >= 0) {
+			// that's not exact algorithm that replace comparison rect with each other
+			// because of that comparison that is not obvious
+			// (we store array sorted by left boundary, not by right) - that's euristic
+			if (boundsIntersect->at(st).fRight > bounds.fLeft) {
+				st--;
+			} else {
+				break;
+			}
+		}
+		if (st < 0) {
+			st = 0;
+		}
+		// test functionality
+		//cv.drawRect(bounds, paint);
+		//cv.drawText(text->text->substring(0, Math.min(5, text->text->length())), bounds.centerX(), bounds.centerY(), paint);
+
+		for (uint j = st; j < e; j++) {
+			SkRect b = boundsIntersect->at(j);
+			float x = std::min(bounds.fRight, b.fRight) - std::max(b.fLeft, bounds.fLeft);
+			float y = std::min(bounds.fBottom, b.fBottom) - std::max(b.fTop, bounds.fTop);
+			if ((x > diff && y > diff2) || (x > diff2 && y > diff)) {
+				return true;
+			}
+		}
+		// TODO insert
+		// boundsIntersect->(index, bounds);
+	}
+	return false;
+}
+
+SkTypeface* serif = SkTypeface::CreateFromName("Droid Serif", SkTypeface::kNormal);
+void drawTextOverCanvas(RenderingContext* rc, SkCanvas* cv) {
+		std::vector<SkRect> boundsNotPathIntersect;
+		std::vector<SkRect> boundsPathIntersect;
+		uint size = rc->textToDraw.size();
+
+		// TODO comparator !!!
+//	Comparator < SkRect > c = new Comparator<SkRect>()
+//	{
+//		int compare(SkRect object1, SkRect object2) {
+//			return Float.compare(object1.left, object2.left);
+//		}
+//
+//	};
+
+	// 1. Sort text using text order
+		// TODO sort !!!
+//	Collections.sort(rc.textToDraw, new Comparator<TextDrawInfo>() {
+//				@Override
+//			public int compare(TextDrawInfo object1, TextDrawInfo object2) {
+//					return object1.textOrder - object2.textOrder;
+//				}
+//			});
+	SkPaint paintIcon;
+	paintIcon.setStyle(SkPaint::kStroke_Style);
+	SkPaint paintText;
+	paintText.setStyle(SkPaint::kFill_Style);
+	paintText.setStrokeWidth(1);
+	paintText.setColor(0xff000000);
+	paintText.setTextAlign(SkPaint::kCenter_Align);
+	paintText.setTypeface(serif);
+	paintText.setAntiAlias(true);
+	SkPaint::FontMetrics fm;
+
+	for (uint i = 0; i < size; i++) {
+		TextDrawInfo* text = rc->textToDraw.at(i);
+		if (text->text.length() > 0) {
+			size_t d = text->text.find(DELIM_CHAR);
+			// not used now functionality
+			// possibly it will be used specifying english names after that character
+			if (d > 0) {
+				text->text = text->text.substr(0, d);
+			}
+
+			// sest text size before finding intersection (it is used there)
+			float textSize = getDensityValue(rc, text->textSize);
+			paintText.setTextSize(textSize);
+			paintText.setFakeBoldText(text->bold);
+			paintText.setColor(text->textColor);
+			// align center y
+			paintText.getFontMetrics(&fm);
+			text->centerY += (-fm.fAscent);
+
+			// calculate if there is intersection
+			// bool intersects = findTextIntersection(rc, boundsNotPathIntersect, boundsPathIntersect, c, text);
+			// TODO
+			bool intersects = false;
+			if (!intersects) {
+
+				if (text->drawOnPath != NULL) {
+					if (text->textShadow > 0) {
+						paintText.setColor(WHITE_COLOR);
+						paintText.setStyle(SkPaint::kStroke_Style);
+						paintText.setStrokeWidth(2 + text->textShadow);
+						cv->drawTextOnPathHV(text->text.c_str(), text->text.length(), *text->drawOnPath, 0,
+								text->vOffset, paintText);
+						// reset
+						paintText.setStyle(SkPaint::kFill_Style);
+						paintText.setStrokeWidth(2);
+						paintText.setColor(text->textColor);
+					}
+					cv->drawTextOnPathHV(text->text.c_str(), text->text.length(), *text->drawOnPath, 0, text->vOffset,
+							paintText);
+				} else {
+					if (text->shieldRes.length() > 0) {
+						SkBitmap* ico = getCachedBitmap(rc, text->shieldRes);
+						if (ico != NULL) {
+							cv->drawBitmap(*ico, text->centerX - ico->width() / 2 - 0.5f,
+									text->centerY - ico->height() / 2 - getDensityValue(rc, 4.5f), &paintIcon);
+						}
+					}
+
+					drawWrappedText(cv, text, textSize, paintText);
+				}
+			}
+		}
+	}
+}
+
+
diff --git a/OsmAnd/libs/armeabi/libosmand.so b/OsmAnd/libs/armeabi/libosmand.so
index a5d758aa2f7..0280a794893 100755
Binary files a/OsmAnd/libs/armeabi/libosmand.so and b/OsmAnd/libs/armeabi/libosmand.so differ
diff --git a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
index 9cd159b2fb4..a213a9b3555 100644
--- a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
@@ -144,6 +144,7 @@ public RenderingContext(Context ctx) {
 		int pointInsideCount = 0;
 		int visible = 0;
 		int allObjects = 0;
+		int textRenderingTime = 0;
 
 		// use to calculate points
 		PointF tempPoint = new PointF();
@@ -154,7 +155,7 @@ public RenderingContext(Context ctx) {
 		// int shadowRenderingMode = 1; // classic shadow (the implementaton in master)
 		// int shadowRenderingMode = 2; // blur shadow (most CPU, but still reasonable)
 		// int shadowRenderingMode = 3; solid border (CPU use like classic version or even smaller)
-		int shadowRenderingMode = 2;
+		int shadowRenderingMode = 3;
 		
 		// not expect any shadow
 		int shadowLevelMin = 256;
@@ -312,7 +313,7 @@ public Bitmap generateNewBitmap(RenderingContext rc, List<BinaryMapDataObject> o
 					long time = System.currentTimeMillis() - now;
 					rc.renderingDebugInfo = String.format("Rendering done in %s (%s text) ms\n"
 							+ "(%s points, %s points inside, %s objects visile from %s)\n" + res,//$NON-NLS-1$
-							time, 0, rc.pointCount, rc.pointInsideCount, rc.visible, rc.allObjects);
+							time, rc.textRenderingTime, rc.pointCount, rc.pointInsideCount, rc.visible, rc.allObjects);
 				} catch (Exception e) {
 					e.printStackTrace();
 				}
@@ -1107,7 +1108,7 @@ private void calculatePolylineText(BinaryMapDataObject obj, RenderingRuleSearchR
 					text.fillProperties(render, middlePoint.x, middlePoint.y);
 					rc.textToDraw.add(text);
 				} else {
-					paintText.setTextSize(text.textSize);
+					paintText.setTextSize(render.getIntPropertyValue(render.ALL.R_TEXT_SIZE));
 					if (paintText.measureText(obj.getName()) < roadLength ) {
 						if (inverse) {
 							path.rewind();
@@ -1125,7 +1126,7 @@ private void calculatePolylineText(BinaryMapDataObject obj, RenderingRuleSearchR
 						text.fillProperties(render, xMid / 2, yMid / 2);
 						text.pathRotate = pathRotate;
 						text.drawOnPath = path;
-						float strokeWidth = render.getFloatPropertyValue(render.ALL.R_STROKE_WIDTH);
+						int strokeWidth = render.getIntPropertyValue(render.ALL.R_TEXT_SIZE);
 						text.vOffset = strokeWidth / 2 - 1;
 						rc.textToDraw.add(text);
 					}
