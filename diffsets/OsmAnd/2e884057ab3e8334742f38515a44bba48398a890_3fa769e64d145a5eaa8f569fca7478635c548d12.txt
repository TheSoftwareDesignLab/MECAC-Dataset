diff --git a/OsmAnd/src/net/osmand/plus/mapcontextmenu/MapContextMenuFragment.java b/OsmAnd/src/net/osmand/plus/mapcontextmenu/MapContextMenuFragment.java
index 0a61a7abf09..ab78e3f90a6 100644
--- a/OsmAnd/src/net/osmand/plus/mapcontextmenu/MapContextMenuFragment.java
+++ b/OsmAnd/src/net/osmand/plus/mapcontextmenu/MapContextMenuFragment.java
@@ -1734,6 +1734,7 @@ private LatLon calculateCenterLatLon(LatLon latLon, int zoom, boolean updateOrig
 
 	private void showOnMap(LatLon latLon, boolean updateCoords, boolean alreadyAdjusted, int zoom) {
 		AnimateDraggingMapThread thread = map.getAnimatedDraggingThread();
+		zoom = Math.min(zoom, thread.calculateMoveZoom(null, latLon.getLatitude(), latLon.getLongitude(), null));
 		LatLon calcLatLon = calculateCenterLatLon(latLon, zoom, updateCoords);
 		if (updateCoords) {
 			mapCenter = calcLatLon;
diff --git a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
index f753837253e..bcdef370ee3 100644
--- a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
+++ b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
@@ -188,19 +188,9 @@ public void startMoving(final double finalLat, final double finalLon, final int
 		double startLon = rb.getLongitude();
 		final int startZoom = rb.getZoom();
 		final double startZoomFP = rb.getZoomFloatPart();
-
-		boolean skipAnimation = false;
-		float mStX = rb.getPixXFromLatLon(startLat, startLon) - rb.getPixXFromLatLon(finalLat, finalLon);
-		float mStY = rb.getPixYFromLatLon(startLat, startLon) - rb.getPixYFromLatLon(finalLat, finalLon);
-		while (Math.abs(mStX) + Math.abs(mStY) > 1200) {
-			rb.setZoom(rb.getZoom() - 1);
-			if (rb.getZoom() <= 4) {
-				skipAnimation = true;
-			}
-			mStX = rb.getPixXFromLatLon(startLat, startLon) - rb.getPixXFromLatLon(finalLat, finalLon);
-			mStY = rb.getPixYFromLatLon(startLat, startLon) - rb.getPixYFromLatLon(finalLat, finalLon);
-		}
-		final int moveZoom = rb.getZoom();
+		float[] mSt = new float[2];
+		final int moveZoom = calculateMoveZoom(rb, finalLat, finalLon, mSt);
+		boolean skipAnimation = moveZoom == 0;
 		// check if animation needed
 		skipAnimation = skipAnimation || (Math.abs(moveZoom - startZoom) >= 3 || Math.abs(endZoom - moveZoom) > 3);
 		if (skipAnimation || wasAnimating) {
@@ -220,7 +210,7 @@ public void run() {
 		final float mMoveY = rb.getPixYFromLatLon(startLat, startLon) - rb.getPixYFromLatLon(finalLat, finalLon);
 
 		final boolean doNotUseAnimations = tileView.getSettings().DO_NOT_USE_ANIMATIONS.get();
-		final float animationTime = doNotUseAnimations ? 1 : Math.max(450, (Math.abs(mStX) + Math.abs(mStY)) / 1200f * MOVE_MOVE_ANIMATION_TIME);
+		final float animationTime = doNotUseAnimations ? 1 : Math.max(450, (Math.abs(mSt[0]) + Math.abs(mSt[1])) / 1200f * MOVE_MOVE_ANIMATION_TIME);
 
 		startThreadAnimating(new Runnable() {
 
@@ -249,6 +239,30 @@ public void run() {
 		});
 	}
 
+	public int calculateMoveZoom(RotatedTileBox rb, final double finalLat, final double finalLon, float[] mSt) {
+		if (rb == null) {
+			rb = tileView.getCurrentRotatedTileBox().copy();
+		}
+		double startLat = rb.getLatitude();
+		double startLon = rb.getLongitude();
+
+		boolean skipAnimation = false;
+		if (mSt == null) {
+			mSt = new float[2];
+		}
+		mSt[0] = rb.getPixXFromLatLon(startLat, startLon) - rb.getPixXFromLatLon(finalLat, finalLon);
+		mSt[1] = rb.getPixYFromLatLon(startLat, startLon) - rb.getPixYFromLatLon(finalLat, finalLon);
+		while (Math.abs(mSt[0]) + Math.abs(mSt[1]) > 1200) {
+			rb.setZoom(rb.getZoom() - 1);
+			if (rb.getZoom() <= 4) {
+				skipAnimation = true;
+			}
+			mSt[0] = rb.getPixXFromLatLon(startLat, startLon) - rb.getPixXFromLatLon(finalLat, finalLon);
+			mSt[1] = rb.getPixYFromLatLon(startLat, startLon) - rb.getPixYFromLatLon(finalLat, finalLon);
+		}
+		return skipAnimation ? 0 : rb.getZoom();
+	}
+
 	private void animatingRotateInThread(float rotate, float animationTime, boolean notify) {
 		AccelerateDecelerateInterpolator interpolator = new AccelerateDecelerateInterpolator();
 		float startRotate = tileView.getRotate();
