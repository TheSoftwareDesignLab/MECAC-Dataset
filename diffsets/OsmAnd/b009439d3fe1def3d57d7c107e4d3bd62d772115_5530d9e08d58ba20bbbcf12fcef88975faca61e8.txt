diff --git a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
index 8e39b478bd0..99f82883276 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RouteProvider.java
@@ -831,6 +831,7 @@ private static List<RouteDirectionInfo> parseOsmAndGPXRoute(List<Location> res,
 		if (route != null && route.points.size() > 0) {
 			directions = new ArrayList<RouteDirectionInfo>();
 			Iterator<WptPt> iterator = route.points.iterator();
+			float lasttime = 0;
 			while(iterator.hasNext()){
 				WptPt item = iterator.next();
 				try {
@@ -846,12 +847,15 @@ private static List<RouteDirectionInfo> parseOsmAndGPXRoute(List<Location> res,
 						if (distanceToEnd.length > last.routePointOffset && distanceToEnd.length > offset) {
 							float lastDistanceToEnd = distanceToEnd[last.routePointOffset];
 							float currentDistanceToEnd = distanceToEnd[offset];
-							last.setAverageSpeed((lastDistanceToEnd - currentDistanceToEnd) / last.getAverageSpeed());
+							if (lasttime != 0) {
+								last.setAverageSpeed((lastDistanceToEnd - currentDistanceToEnd) / lasttime);
+							} 
 							last.distance = (int) Math.round(lastDistanceToEnd - currentDistanceToEnd);
 						}
 					} 
 					// save time as a speed because we don't know distance of the route segment
-					float avgSpeed = time;
+					lasttime = time;
+					float avgSpeed = defSpeed;
 					if (!iterator.hasNext() && time > 0) {
 						if (distanceToEnd.length > offset) {
 							avgSpeed = distanceToEnd[offset] / time;
@@ -1135,6 +1139,8 @@ protected RouteCalculationResult findBROUTERRoute(RouteCalculationParams params)
 		double[] lons = new double[numpoints];
 		int index = 0;
 		String mode;
+		float defSpeed;
+		boolean addMissingTurns = true;
 		lats[index] = params.start.getLatitude();
 		lons[index] = params.start.getLongitude();
 		index++;
@@ -1149,10 +1155,13 @@ protected RouteCalculationResult findBROUTERRoute(RouteCalculationParams params)
 		lons[index] = params.end.getLongitude();
 		if (ApplicationMode.PEDESTRIAN == params.mode) {
 			mode = "foot"; //$NON-NLS-1$
+			defSpeed = (float) (5/3.6);
 		} else if (ApplicationMode.BICYCLE == params.mode) {
 			mode = "bicycle"; //$NON-NLS-1$
+			defSpeed = (float) (20/3.6);
 		} else {
 			mode = "motorcar"; //$NON-NLS-1$
+			defSpeed = (float) (60/3.6);
 		}
 		Bundle bpars = new Bundle();
 		bpars.putDoubleArray("lats", lats);
@@ -1160,9 +1169,11 @@ protected RouteCalculationResult findBROUTERRoute(RouteCalculationParams params)
 		bpars.putString("fast", params.fast ? "1" : "0");
 		bpars.putString("v", mode);
 		bpars.putString("trackFormat", "gpx");
+		bpars.putString("turnInstructionFormat", "osmand");
 
 		OsmandApplication ctx = (OsmandApplication) params.ctx;
 		List<Location> res = new ArrayList<Location>();
+		List<RouteDirectionInfo > dir = new ArrayList<>();
 
 		IBRouterService brouterService = ctx.getBRouterService();
 		if (brouterService == null) {
@@ -1178,23 +1189,16 @@ protected RouteCalculationResult findBROUTERRoute(RouteCalculationParams params)
 
 			GPXFile gpxFile = GPXUtilities.loadGPXFile(new ByteArrayInputStream(gpxMessage.getBytes("UTF-8")));
 
-			for (Track track : gpxFile.tracks) {
-				for (TrkSegment ts : track.segments) {
-					for (WptPt p : ts.points) {
-						Location l = new Location("router"); //$NON-NLS-1$
-						l.setLatitude(p.lat);
-						l.setLongitude(p.lon);
-						if (p.ele != Double.NaN) {
-							l.setAltitude(p.ele);
-						}
-						res.add(l);
-					}
-				}
+			dir = parseOsmAndGPXRoute(res, gpxFile, true, params.leftSide, defSpeed);
+
+			if (dir != null) {
+				addMissingTurns = false;
 			}
+
 		} catch (Exception e) {
 			return new RouteCalculationResult("Exception calling BRouter: " + e); //$NON-NLS-1$
 		}
-		return new RouteCalculationResult(res, null, params, null, true);
+		return new RouteCalculationResult(res, dir, params, null, addMissingTurns);
 	}
 
 	private RouteCalculationResult findStraightRoute(RouteCalculationParams params) {
