diff --git a/OsmAnd/res/values/strings.xml b/OsmAnd/res/values/strings.xml
index 9f7e9c76c2a..731b2fcb61f 100644
--- a/OsmAnd/res/values/strings.xml
+++ b/OsmAnd/res/values/strings.xml
@@ -9,6 +9,8 @@
          3. All your modified/created strings are in the top of the file (to make easier find what\'s translated).
     PLEASE: Have a look at http://code.google.com/p/osmand/wiki/UIConsistency, it may really improve your and our work  :-)  Thx - Hardy
     -->
+    <string name="animate_my_location">Animate my location</string>
+    <string name="animate_my_location_desc">Enable animation of my location on the map</string>
     <string name="shared_string_overview">Overview</string>
     <string name="select_street">Select street</string>
     <string name="shared_string_in_name">in %1$s</string>
diff --git a/OsmAnd/src/net/osmand/plus/OsmandSettings.java b/OsmAnd/src/net/osmand/plus/OsmandSettings.java
index 4651784fe8a..060a7028bfe 100644
--- a/OsmAnd/src/net/osmand/plus/OsmandSettings.java
+++ b/OsmAnd/src/net/osmand/plus/OsmandSettings.java
@@ -1287,6 +1287,8 @@ protected Integer getDefaultValue() {
 		MAP_MARKERS_MODE.setModeDefaultValue(ApplicationMode.PEDESTRIAN, MapMarkersMode.TOOLBAR);
 	}
 
+	public final OsmandPreference<Boolean> ANIMATE_MY_LOCATION = new BooleanPreference("animate_my_location", true).makeGlobal().cache();
+
 	public final OsmandPreference<Boolean> ROUTE_MAP_MARKERS_START_MY_LOC = new BooleanPreference("route_map_markers_start_my_loc", false).makeGlobal().cache();
 
 	public ITileSource getMapTileSource(boolean warnWhenSelected) {
diff --git a/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java b/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
index 32c81719633..111e1981a19 100644
--- a/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
+++ b/OsmAnd/src/net/osmand/plus/base/MapViewTrackingUtilities.java
@@ -1,6 +1,7 @@
 package net.osmand.plus.base;
 
 import android.content.Context;
+import android.support.v4.util.Pair;
 import android.view.WindowManager;
 
 import net.osmand.Location;
@@ -171,7 +172,7 @@ public void updateLocation(Location location) {
 		if (mapView != null) {
 			RotatedTileBox tb = mapView.getCurrentRotatedTileBox();
 			if (isMapLinkedToLocation() && location != null) {
-				Integer zoom = null;
+				Pair<Integer, Double> zoom = null;
 				Float rotation = null;
 				if (settings.AUTO_ZOOM_MAP.get()) {
 					zoom = autozoom(location);
@@ -186,16 +187,24 @@ public void updateLocation(Location location) {
 						// special case when bearing equals to zero (we don't change anything)
 						if (location.getBearing() != 0f) {
 							rotation = -location.getBearing();
-							//mapView.setRotate(-location.getBearing());
 						}
 					}
 				} else if(currentMapRotation == OsmandSettings.ROTATE_MAP_COMPASS) {
 					showViewAngle = routePlanningMode; // disable compass rotation in that mode
 				}
 				registerUnregisterSensor(location);
-				mapView.getAnimatedDraggingThread().startMoving(
-						location.getLatitude(), location.getLongitude(), zoom, rotation, false);
-				//mapView.setLatLon(location.getLatitude(), location.getLongitude());
+				if (settings.ANIMATE_MY_LOCATION.get()) {
+					mapView.getAnimatedDraggingThread().startMoving(
+							location.getLatitude(), location.getLongitude(), zoom, rotation, false);
+				} else {
+					if (zoom != null) {
+						mapView.getAnimatedDraggingThread().startZooming(zoom.first, zoom.second, false);
+					}
+					if (rotation != null) {
+						mapView.setRotate(rotation);
+					}
+					mapView.setLatLon(location.getLatitude(), location.getLongitude());
+				}
 			} else if(location != null) {
 				showViewAngle = (!location.hasBearing() || isSmallSpeedForCompass(location)) && (tb != null && 
 						tb.containsLatLon(location.getLatitude(), location.getLongitude()));
@@ -278,7 +287,7 @@ private float defineZoomFromSpeed(RotatedTileBox tb, float speed) {
 		return zoomDelta;
 	}
 	
-	public Integer autozoom(Location location) {
+	public Pair<Integer, Double> autozoom(Location location) {
 		if (location.hasSpeed()) {
 			long now = System.currentTimeMillis();
 			final RotatedTileBox tb = mapView.getCurrentRotatedTileBox();
@@ -303,13 +312,12 @@ public Integer autozoom(Location location) {
 					// round to 0.33
 					targetZoom = Math.round(targetZoom * 3) / 3f;
 					int newIntegerZoom = (int)Math.round(targetZoom);
-					//double zPart = targetZoom - newIntegerZoom;
-					//mapView.getAnimatedDraggingThread().startZooming(newIntegerZoom, zPart, false);
-					return newIntegerZoom;
+					double zPart = targetZoom - newIntegerZoom;
+					return new Pair<>(newIntegerZoom, zPart);
 				}
 			}
 		}
-		return mapView.getZoom();
+		return null;
 	}
 	
 	public void backToLocationImpl() {
diff --git a/OsmAnd/src/net/osmand/plus/development/SettingsDevelopmentActivity.java b/OsmAnd/src/net/osmand/plus/development/SettingsDevelopmentActivity.java
index 6a374af766d..8dedbad5bcf 100644
--- a/OsmAnd/src/net/osmand/plus/development/SettingsDevelopmentActivity.java
+++ b/OsmAnd/src/net/osmand/plus/development/SettingsDevelopmentActivity.java
@@ -63,6 +63,10 @@ public void onCreate(Bundle savedInstanceState) {
 				R.string.use_osm_live_routing,
 				R.string.use_osm_live_routing_description));
 
+		cat.addPreference(createCheckBoxPreference(settings.ANIMATE_MY_LOCATION,
+				R.string.animate_my_location,
+				R.string.animate_my_location_desc));
+
 		final Preference firstRunPreference = new Preference(this);
 		firstRunPreference.setTitle(R.string.simulate_initial_startup);
 		firstRunPreference.setSummary(R.string.simulate_initial_startup_descr);
diff --git a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
index 08e30b47be0..47e2a8766fe 100644
--- a/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
+++ b/OsmAnd/src/net/osmand/plus/views/AnimateDraggingMapThread.java
@@ -1,6 +1,7 @@
 package net.osmand.plus.views;
 
 import android.os.SystemClock;
+import android.support.v4.util.Pair;
 import android.view.animation.AccelerateDecelerateInterpolator;
 import android.view.animation.DecelerateInterpolator;
 import android.view.animation.LinearInterpolator;
@@ -24,6 +25,7 @@ public class AnimateDraggingMapThread {
 	private final static float ZOOM_ANIMATION_TIME = 250f;
 	private final static float ZOOM_MOVE_ANIMATION_TIME = 350f;
 	private final static float MOVE_MOVE_ANIMATION_TIME = 900f;
+	private final static float NAV_ANIMATION_TIME = 1000f;
 	private final static int DEFAULT_SLEEP_TO_REDRAW = 15;
 	
 	private volatile boolean stopped;
@@ -116,7 +118,7 @@ public void run() {
 		
 	}
 
-	public void startMoving(final double finalLat, final double finalLon, final Integer finalZoom,
+	public void startMoving(final double finalLat, final double finalLon, final Pair<Integer, Double> finalZoom,
 							final Float finalRotation, final boolean notifyListener) {
 		stopAnimatingSync();
 		final RotatedTileBox rb = tileView.getCurrentRotatedTileBox().copy();
@@ -127,11 +129,14 @@ public void startMoving(final double finalLat, final double finalLon, final Inte
 		final float startRotaton = rb.getRotate();
 
 		final int zoom;
+		final double zoomFP;
 		final float rotation;
 		if (finalZoom != null) {
-			zoom = finalZoom;
+			zoom = finalZoom.first;
+			zoomFP = finalZoom.second;
 		} else {
 			zoom = startZoom;
+			zoomFP = startZoomFP;
 		}
 		if (finalRotation != null) {
 			rotation = finalRotation;
@@ -149,31 +154,33 @@ public void startMoving(final double finalLat, final double finalLon, final Inte
 			return;
 		}
 
-		final float animationTime = 1000;//Math.max(450, (Math.abs(mMoveX) + Math.abs(mMoveY)) / 1200f * MOVE_MOVE_ANIMATION_TIME);
-
 		startThreadAnimating(new Runnable() {
 
 			@Override
 			public void run() {
 				setTargetValues(zoom, finalLat, finalLon);
-				if (zoom != startZoom || startZoomFP != 0) {
-					animatingZoomInThread(startZoom, startZoomFP, zoom, 0, ZOOM_MOVE_ANIMATION_TIME, notifyListener);
+				boolean animateZoom = finalZoom != null && (zoom != startZoom || startZoomFP != 0);
+				if (animateZoom) {
+					animatingZoomInThread(startZoom, startZoomFP, zoom, zoomFP, NAV_ANIMATION_TIME, notifyListener);
 				}
 
-				if (!stopped){
-					animatingMoveInThread(mMoveX, mMoveY, animationTime, notifyListener);
+				if (rotation != startRotaton) {
+					AnimateDraggingMapThread.this.targetRotate = rotation;
+					//animatingRotateInThread(rotation, NAV_ANIMATION_TIME, notifyListener);
 				}
+				pendingRotateAnimation();
 
 				if (!stopped){
-					tileView.setLatLonAnimate(finalLat, finalLon, notifyListener);
+					animatingMoveInThread(mMoveX, mMoveY, NAV_ANIMATION_TIME, notifyListener);
 				}
 
-				tileView.setFractionalZoom(zoom, 0, notifyListener);
+				if (!stopped){
+					//tileView.setLatLonAnimate(finalLat, finalLon, notifyListener);
+				}
 
-				if (rotation != startRotaton) {
-					AnimateDraggingMapThread.this.targetRotate = rotation;
+				if (animateZoom) {
+					//tileView.setFractionalZoom(zoom, zoomFP, notifyListener);
 				}
-				pendingRotateAnimation();
 			}
 		});
 	}
@@ -236,7 +243,31 @@ public void run() {
 			}
 		});
 	}
-	
+
+	private void animatingRotateInThread(float rotate, float animationTime, boolean notify){
+		AccelerateDecelerateInterpolator interpolator = new AccelerateDecelerateInterpolator();
+		float startRotate = tileView.getRotate();
+		float rotationDiff = MapUtils.unifyRotationDiff(startRotate, rotate);
+		if (tileView.isMapRotateEnabled() && Math.abs(rotationDiff) > 1) {
+			long timeMillis = SystemClock.uptimeMillis();
+			float normalizedTime;
+			while (!stopped) {
+				normalizedTime = (SystemClock.uptimeMillis() - timeMillis) / animationTime;
+				if (normalizedTime > 1f) {
+					break;
+				}
+				float interpolation = interpolator.getInterpolation(normalizedTime);
+				tileView.rotateToAnimate(rotationDiff * interpolation + startRotate);
+				try {
+					Thread.sleep(DEFAULT_SLEEP_TO_REDRAW);
+				} catch (InterruptedException e) {
+					stopped = true;
+				}
+			}
+		}
+		tileView.rotateToAnimate(rotate);
+	}
+
 	private void animatingMoveInThread(float moveX, float moveY, float animationTime,
 			boolean notify){
 		AccelerateDecelerateInterpolator interpolator = new AccelerateDecelerateInterpolator();
@@ -245,9 +276,9 @@ private void animatingMoveInThread(float moveX, float moveY, float animationTime
 		float cY = 0;
 		long timeMillis = SystemClock.uptimeMillis();
 		float normalizedTime = 0f;
-		while(!stopped){
+		while (!stopped){
 			normalizedTime = (SystemClock.uptimeMillis() - timeMillis) / animationTime; 
-			if(normalizedTime > 1f){
+			if (normalizedTime > 1f) {
 				break;
 			}
 			float interpolation = interpolator.getInterpolation(normalizedTime);
@@ -262,7 +293,6 @@ private void animatingMoveInThread(float moveX, float moveY, float animationTime
 				stopped = true;
 			}
 		}
-		
 	}
 	
 	private void animatingZoomInThread(int zoomStart, double zoomFloatStart, 
