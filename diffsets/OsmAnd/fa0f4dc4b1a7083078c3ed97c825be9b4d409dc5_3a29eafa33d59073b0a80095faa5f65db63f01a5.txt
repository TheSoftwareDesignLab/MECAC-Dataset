diff --git a/OsmAnd-java/src/net/osmand/router/RouteResultPreparation.java b/OsmAnd-java/src/net/osmand/router/RouteResultPreparation.java
index 365fbe0e626..3e1d852af1b 100644
--- a/OsmAnd-java/src/net/osmand/router/RouteResultPreparation.java
+++ b/OsmAnd-java/src/net/osmand/router/RouteResultPreparation.java
@@ -850,6 +850,36 @@ public static int[] parseTurnLanes(RouteDataObject ro, double dirToNorthEastPi)
 		return calculateRawTurnLanes(splitLaneOptions, 0);
 	}
 	
+	public static int[] parseLanes(RouteDataObject ro, double dirToNorthEastPi) {
+		int lns = 0;
+		try {
+			if (ro.getOneway() == 0) {
+				// we should get direction to detect forward or backward
+				double cmp = ro.directionRoute(0, true);
+				
+				if(Math.abs(MapUtils.alignAngleDifference(dirToNorthEastPi -cmp)) < Math.PI / 2) {
+					if(ro.getValue("lanes:forward") != null) {
+						lns = Integer.parseInt(ro.getValue("lanes:forward"));
+					}
+				} else {
+					if(ro.getValue("lanes:backward") != null) {
+					lns = Integer.parseInt(ro.getValue("lanes:backward"));
+					}
+				}
+				if (lns == 0 && ro.getValue("lanes") != null) {
+					lns = Integer.parseInt(ro.getValue("lanes")) / 2;
+				}
+			} else {
+				lns = Integer.parseInt(ro.getValue("lanes"));
+			}
+			if(lns > 0 ) {
+				return new int[lns];
+			}
+		} catch (NumberFormatException e) {
+		}
+		return null;
+	}
+	
 	private static int[] calculateRawTurnLanes(String[] splitLaneOptions, int calcTurnType) {
 		int[] lanes = new int[splitLaneOptions.length];
 		for (int i = 0; i < splitLaneOptions.length; i++) {
diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/RouteInfoWidgetsFactory.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/RouteInfoWidgetsFactory.java
index 55a6b2ffa69..0f34a9a0dcf 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/RouteInfoWidgetsFactory.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/RouteInfoWidgetsFactory.java
@@ -614,6 +614,9 @@ public boolean updateInfo(DrawSettings drawSettings) {
 					if(ro != null) {
 						float degree = lp == null || !lp.hasBearing() ? 0 : lp.getBearing();
 						loclanes = RouteResultPreparation.parseTurnLanes(ro, degree / 180 * Math.PI);
+						if(loclanes == null) {
+							loclanes = RouteResultPreparation.parseLanes(ro, degree / 180 * Math.PI);
+						}
 					}
 				} else if (rh != null && rh.isRouteCalculated() ) {
 					if (rh.isFollowingMode() && view.getSettings().SHOW_LANES.get()) {
