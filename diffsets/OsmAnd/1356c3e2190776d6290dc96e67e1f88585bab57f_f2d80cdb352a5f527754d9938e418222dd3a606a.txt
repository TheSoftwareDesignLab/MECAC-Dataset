diff --git a/OsmAnd-java/src/main/java/net/osmand/binary/Abbreviations.java b/OsmAnd-java/src/main/java/net/osmand/binary/Abbreviations.java
index 09b081cc4a9..67f88c11edf 100644
--- a/OsmAnd-java/src/main/java/net/osmand/binary/Abbreviations.java
+++ b/OsmAnd-java/src/main/java/net/osmand/binary/Abbreviations.java
@@ -23,6 +23,11 @@ private Abbreviations() {
         abbreviations.put("nw", "Northwest");
         abbreviations.put("ne", "Northeast");
         abbreviations.put("ln", "Lane");
+        abbreviations.put("dr", "Drive");
+        abbreviations.put("rd", "Road");
+        abbreviations.put("ave", "Avenue");
+        abbreviations.put("st", "Street");
+        abbreviations.put("blvd", "Boulevard");
     }
 
     public static String replace(String word) {
diff --git a/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapAddressReaderAdapter.java b/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapAddressReaderAdapter.java
index b602cb6a276..1272aad3931 100644
--- a/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapAddressReaderAdapter.java
+++ b/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapAddressReaderAdapter.java
@@ -696,7 +696,8 @@ public boolean matches(City city) {
 				// here offsets are sorted by distance
 				TIntArrayList charsList = new TIntArrayList();
 				charsList.add(0);
-				map.readIndexedStringTable(stringMatcher.getCollator(), Collections.singletonList(req.nameQuery), "", Collections.singletonList(loffsets), charsList);
+				map.readIndexedStringTable(reg, stringMatcher.getCollator(), Collections.singletonList(req.nameQuery),
+						"", Collections.singletonList(loffsets), charsList);
 				codedIS.popLimit(oldLimit);
 				break;
 			case OsmAndAddressNameIndexData.ATOM_FIELD_NUMBER:
diff --git a/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapIndexReader.java b/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapIndexReader.java
index ad960e776d9..c2adbaf3c0d 100644
--- a/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapIndexReader.java
+++ b/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapIndexReader.java
@@ -99,6 +99,7 @@ public class BinaryMapIndexReader {
 	public static final int LABEL_ZOOM_ENCODE = 31 - SHIFT_COORDINATES;
 	private final static Log log = PlatformUtil.getLog(BinaryMapIndexReader.class);
 	public static boolean READ_STATS = false;
+	private static boolean TRACE_SEARCH = false; 
 	public static final SearchPoiTypeFilter ACCEPT_ALL_POI_TYPE_FILTER = new SearchPoiTypeFilter() {
 		@Override
 		public boolean isEmpty() {
@@ -669,7 +670,7 @@ public List<TransportStop> searchTransportIndex(SearchRequest<TransportStop> req
 		for (TransportIndex index : transportIndexes) {
 			searchTransportIndex(index, req);
 		}
-		if (req.numberOfVisitedObjects > 0 && req.log) {
+		if (TRACE_SEARCH && req.numberOfVisitedObjects > 0 && req.log) {
 			log.debug("Search is done. Visit " + req.numberOfVisitedObjects + " objects. Read " + req.numberOfAcceptedObjects + " objects."); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 			log.debug("Read " + req.numberOfReadSubtrees + " subtrees. Go through " + req.numberOfAcceptedSubtrees + " subtrees.");   //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
 		}
@@ -1031,7 +1032,7 @@ public int compare(MapTree o1, MapTree o2) {
 				}
 			}
 		}
-		if (req.numberOfVisitedObjects > 0 && req.log) {
+		if (TRACE_SEARCH && req.numberOfVisitedObjects > 0 && req.log) {
 			log.info("Search is done. Visit " + req.numberOfVisitedObjects + " objects. Read " + req.numberOfAcceptedObjects + " objects."); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
 			log.info("Read " + req.numberOfReadSubtrees + " subtrees. Go through " + req.numberOfAcceptedSubtrees + " subtrees.");   //$NON-NLS-1$//$NON-NLS-2$//$NON-NLS-3$
 		}
@@ -1859,7 +1860,7 @@ public void setBBoxRadius(double lat, double lon, int radiusMeters) {
 			top = (int) (y - cf31);
 			bottom = (int) (y + cf31);
 		}
-
+		
 		public void setBBox(int x31, int y31, int left, int top, int right, int bottom) {
 			x = x31;
 			y = y31;
@@ -2595,9 +2596,10 @@ private static void updateFrequence(Map<String, Integer> street, String key) {
 
 	}
 
-	void readIndexedStringTable(Collator instance, List<String> queries, String prefix, List<TIntArrayList> listOffsets, TIntArrayList matchedCharacters) throws IOException {
-		String key = null;
+	void readIndexedStringTable(BinaryIndexPart part, Collator instance, List<String> queries, String prefix, List<TIntArrayList> listOffsets,
+			TIntArrayList matchedCharacters) throws IOException {
 		boolean[] matched = new boolean[matchedCharacters.size()];
+		String key = null;
 		boolean shouldWeReadSubtable = false;
 		while (true) {
 			int t = codedIS.readTag();
@@ -2610,39 +2612,11 @@ void readIndexedStringTable(Collator instance, List<String> queries, String pref
 				if (prefix.length() > 0) {
 					key = prefix + key;
 				}
-				shouldWeReadSubtable = false;
-				for (int i = 0; i < queries.size(); i++) {
-					int charMatches = matchedCharacters.get(i);
-					String query = queries.get(i);
-					matched[i] = false;
-					if (query == null) {
-						continue;
-					}
-					
-					// check query is part of key (the best matching)
-					if (CollatorStringMatcher.cmatches(instance, key, query, StringMatcherMode.CHECK_ONLY_STARTS_WITH)) {
-						if (query.length() >= charMatches) {
-							if (query.length() > charMatches) {
-								matchedCharacters.set(i, query.length());
-								listOffsets.get(i).clear();
-							}
-							matched[i] = true;
-						}
-						// check key is part of query
-					} else if (CollatorStringMatcher.cmatches(instance, query, key, StringMatcherMode.CHECK_ONLY_STARTS_WITH)) {
-						if (key.length() >= charMatches) {
-							if (key.length() > charMatches) {
-								matchedCharacters.set(i, key.length());
-								listOffsets.get(i).clear();
-							}
-							matched[i] = true;
-						}
-					}
-					shouldWeReadSubtable |= matched[i];
-				}
+				shouldWeReadSubtable = matchIndexByNameKey(instance, queries, listOffsets, matchedCharacters, key,
+						matched);
 				break;
 			case OsmandOdb.IndexedStringTable.VAL_FIELD_NUMBER :
-				int val = (int) readInt(); // FIXME
+				int val = (int) readInt(); // FIXME for 64 bit support
 				for (int i = 0; i < queries.size(); i++) {
 					if (matched[i]) {
 						listOffsets.get(i).add(val);
@@ -2660,7 +2634,7 @@ void readIndexedStringTable(Collator instance, List<String> queries, String pref
 							subqueries.set(i, null);
 						}
 					}
-					readIndexedStringTable(instance, subqueries, key, listOffsets, matchedCharacters);
+					readIndexedStringTable(part, instance, subqueries, key, listOffsets, matchedCharacters);
 				} else {
 					codedIS.skipRawBytes(codedIS.getBytesUntilLimit());
 				}
@@ -2673,6 +2647,41 @@ void readIndexedStringTable(Collator instance, List<String> queries, String pref
 		}
 	}
 
+	private boolean matchIndexByNameKey(Collator instance, List<String> queries, List<TIntArrayList> listOffsets,
+			TIntArrayList matchedCharacters, String key, boolean[] matched) {
+		boolean shouldWeReadSubtable = false;
+		for (int i = 0; i < queries.size(); i++) {
+			int charMatches = matchedCharacters.get(i);
+			String query = queries.get(i);
+			matched[i] = false;
+			if (query == null) {
+				continue;
+			}
+			
+			// check query is part of key (the best matching)
+			if (CollatorStringMatcher.cmatches(instance, key, query, StringMatcherMode.CHECK_ONLY_STARTS_WITH)) {
+				if (query.length() >= charMatches) {
+					if (query.length() > charMatches) {
+						matchedCharacters.set(i, query.length());
+						listOffsets.get(i).clear();
+					}
+					matched[i] = true;
+				}
+				// check key is part of query
+			} else if (CollatorStringMatcher.cmatches(instance, query, key, StringMatcherMode.CHECK_ONLY_STARTS_WITH)) {
+				if (key.length() >= charMatches) {
+					if (key.length() > charMatches) {
+						matchedCharacters.set(i, key.length());
+						listOffsets.get(i).clear();
+					}
+					matched[i] = true;
+				}
+			}
+			shouldWeReadSubtable |= matched[i];
+		}
+		return shouldWeReadSubtable;
+	}
+
 	private static void testAddressSearchByName(BinaryMapIndexReader reader, SearchStat stat) throws IOException {
 		SearchRequest<MapObject> req = buildAddressByNameRequest(new ResultMatcher<MapObject>() {
 			@Override
diff --git a/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapPoiReaderAdapter.java b/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapPoiReaderAdapter.java
index 15b8d1b8185..32f62da7a02 100644
--- a/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapPoiReaderAdapter.java
+++ b/OsmAnd-java/src/main/java/net/osmand/binary/BinaryMapPoiReaderAdapter.java
@@ -428,7 +428,7 @@ private TIntLongHashMap readPoiNameIndex(Collator instance, String query, Search
 					charsList.add(0);
 					listOffsets.add(new TIntArrayList());
 				}
-				map.readIndexedStringTable(instance, queries, "", listOffsets, charsList);
+				map.readIndexedStringTable(region, instance, queries, "", listOffsets, charsList);
 				codedIS.popLimit(oldLimit);
 				break;
 			}
diff --git a/OsmAnd-java/src/main/java/net/osmand/binary/CommonWords.java b/OsmAnd-java/src/main/java/net/osmand/binary/CommonWords.java
index d01666a1890..c83e7c01241 100644
--- a/OsmAnd-java/src/main/java/net/osmand/binary/CommonWords.java
+++ b/OsmAnd-java/src/main/java/net/osmand/binary/CommonWords.java
@@ -843,8 +843,6 @@ private static void parseRegionNames(WorldRegion region, Set<String> result) {
 		addFrequentlyUsed("augusta");
 		addFrequentlyUsed("neuburger");
 
-
-
 		addCommon("la");
 		addCommon("via");
 		addCommon("rua");
@@ -971,7 +969,6 @@ private static void parseRegionNames(WorldRegion region, Set<String> result) {
 		addCommon("viale");
 		addCommon("loop");
 		
-
 		addCommon("bridge");
 		addCommon("embankment");
 		addCommon("township");
diff --git a/OsmAnd-java/src/main/java/net/osmand/data/City.java b/OsmAnd-java/src/main/java/net/osmand/data/City.java
index 7c40eeaad00..fb5da45e461 100644
--- a/OsmAnd-java/src/main/java/net/osmand/data/City.java
+++ b/OsmAnd-java/src/main/java/net/osmand/data/City.java
@@ -80,9 +80,6 @@ public static CityType valueFromString(String place) {
 			if ("township".equals(place)) {
 				return CityType.TOWN;
 			}
-			if ("township".equals(place)) {
-				return CityType.TOWN;
-			}
 			for (CityType t : CityType.values()) {
 				if (t.name().equalsIgnoreCase(place) 
 						&& t != BOUNDARY && t != POSTCODE) {
diff --git a/OsmAnd-java/src/main/java/net/osmand/search/SearchUICore.java b/OsmAnd-java/src/main/java/net/osmand/search/SearchUICore.java
index a87761e4587..c0c16704ae4 100644
--- a/OsmAnd-java/src/main/java/net/osmand/search/SearchUICore.java
+++ b/OsmAnd-java/src/main/java/net/osmand/search/SearchUICore.java
@@ -665,11 +665,8 @@ public SearchResultCollection immediateSearch(final String text, final LatLon lo
 		return resultCollection;
 	}
 
-	public void search(final String text, final boolean delayedExecution, final ResultMatcher<SearchResult> matcher) {
-		search(text, delayedExecution, matcher, searchSettings);
-	}
 
-	public void search(final String text, final boolean delayedExecution, final ResultMatcher<SearchResult> matcher, final SearchSettings searchSettings) {
+	public void search(final String text, final boolean delayedExecution, final ResultMatcher<SearchResult> matcher) {
 		final int request = requestNumber.incrementAndGet();
 		final SearchPhrase phrase = this.phrase.generateNewPhrase(text, searchSettings);
 		phrase.setAcceptPrivate(this.phrase.isAcceptPrivate());
@@ -1192,10 +1189,10 @@ public int compare(SearchResult o1, SearchResult o2, SearchResultComparator c) {
 				double o1PhraseWeight = o1.getUnknownPhraseMatchWeight();
 				double o2PhraseWeight = o2.getUnknownPhraseMatchWeight();
 				if (o1PhraseWeight == o2PhraseWeight && o1PhraseWeight / SearchResult.MAX_PHRASE_WEIGHT_TOTAL > 1) {
-					if (!ph.getUnknownWordToSearchBuildingNameMatcher().matches(stripBraces(o1.localeName))) {
+					if (!ph.getUnknownWordToSearchBuildingNameMatcher().matches(SearchPhrase.stripBraces(o1.localeName))) {
 						o1PhraseWeight--;
 					}
-					if (!ph.getUnknownWordToSearchBuildingNameMatcher().matches(stripBraces(o2.localeName))) {
+					if (!ph.getUnknownWordToSearchBuildingNameMatcher().matches(SearchPhrase.stripBraces(o2.localeName))) {
 						o2PhraseWeight--;
 					}
 				}
@@ -1268,20 +1265,9 @@ public int compare(SearchResult o1, SearchResult o2, SearchResultComparator c) {
 			}
 			return 0;
 		}
+
 	}
 	
-	private static String stripBraces(String localeName) {
-		int i = localeName.indexOf('(');
-		String retName = localeName;
-		if (i > -1) {
-			retName = localeName.substring(0, i);
-			int j = localeName.indexOf(')', i);
-			if (j > -1) {
-				retName = (retName.trim() + ' ' + localeName.substring(j + 1)).trim();
-			}
-		}
-		return retName;
-	}
 
 	public boolean isOnlineSearch() {
 		return searchSettings.hasCustomSearchType(ONLINE_SEARCH);
diff --git a/OsmAnd-java/src/main/java/net/osmand/search/core/ObjectType.java b/OsmAnd-java/src/main/java/net/osmand/search/core/ObjectType.java
index 06a97400f5e..b7c56e39ab2 100644
--- a/OsmAnd-java/src/main/java/net/osmand/search/core/ObjectType.java
+++ b/OsmAnd-java/src/main/java/net/osmand/search/core/ObjectType.java
@@ -2,7 +2,7 @@
 
 public enum ObjectType {
 	// ADDRESS
-	CITY(true), VILLAGE(true), POSTCODE(true), STREET(true), HOUSE(true), STREET_INTERSECTION(true),
+	CITY(true), VILLAGE(true), BOUNDARY(true), POSTCODE(true), STREET(true), HOUSE(true), STREET_INTERSECTION(true),
 	// POI
 	POI_TYPE(false), POI(true),
 	// LOCATION
@@ -34,13 +34,13 @@ public boolean hasLocation() {
 	}
 
 	public static boolean isAddress(ObjectType t) {
-		return t == CITY || t == VILLAGE || t == POSTCODE || t == STREET || t == HOUSE || t == STREET_INTERSECTION;
+		return t == CITY || t == VILLAGE || t == BOUNDARY || t == POSTCODE || t == STREET || t == HOUSE || t == STREET_INTERSECTION;
 	}
 
 	public static boolean isTopVisible(ObjectType t) {
 		return t == POI_TYPE || t == FAVORITE || t == FAVORITE_GROUP || t == WPT || t == GPX_TRACK || t == LOCATION || t == PARTIAL_LOCATION || t == INDEX_ITEM;
 	}
-
+	
 	public static ObjectType getExclusiveSearchType(ObjectType t) {
 		if (t == FAVORITE_GROUP) {
 			return FAVORITE;
@@ -54,14 +54,15 @@ public static int getTypeWeight(ObjectType t) {
 		}
 		switch (t) {
 			case HOUSE:
-			case STREET_INTERSECTION:
 				return 4;
 			case STREET:
 				return 3;
+			case STREET_INTERSECTION:
 			case CITY:
 			case VILLAGE:
 			case POSTCODE:
 				return 2;
+			case BOUNDARY:
 			case POI:
 				return 1;
 			default:
diff --git a/OsmAnd-java/src/main/java/net/osmand/search/core/SearchCoreFactory.java b/OsmAnd-java/src/main/java/net/osmand/search/core/SearchCoreFactory.java
index 1d5da3e5c92..1b813ecfa06 100644
--- a/OsmAnd-java/src/main/java/net/osmand/search/core/SearchCoreFactory.java
+++ b/OsmAnd-java/src/main/java/net/osmand/search/core/SearchCoreFactory.java
@@ -157,65 +157,21 @@ public int getNextSearchRadius(SearchPhrase phrase) {
 
 		protected SearchPhrase subSearchApiOrPublish(SearchPhrase phrase, SearchResultMatcher resultMatcher, SearchResult res, SearchBaseAPI api)
 				throws IOException {
-			return subSearchApiOrPublish(phrase, resultMatcher, res, api, true);
+			return subSearchApiOrPublish(phrase, resultMatcher, res, api, null, true);
 		}
 
 		protected SearchPhrase subSearchApiOrPublish(SearchPhrase phrase, SearchResultMatcher resultMatcher, SearchResult res, SearchBaseAPI api,
-											 boolean publish)
-				throws IOException {
+									SearchResult setParentSearchResult, boolean publish) throws IOException {
 			phrase.countUnknownWordsMatchMainResult(res);
-			boolean firstUnknownWordMatches = res.firstUnknownWordMatches;
-			List<String> leftUnknownSearchWords = new ArrayList<String>(phrase.getUnknownSearchWords());
-			if (res.otherWordsMatch != null) {
-//				leftUnknownSearchWords.removeAll(res.otherWordsMatch); // incorrect 
-				for (String otherWord : res.otherWordsMatch) {
-					leftUnknownSearchWords.remove(otherWord); // remove 1 by 1
-				}
-			}
-			SearchResult newParentSearchResult = null;
-			if (res.parentSearchResult == null && resultMatcher.getParentSearchResult() == null &&
-					res.objectType == ObjectType.STREET && res.object instanceof Street && ((Street) res.object).getCity() != null) {
-				City ct = ((Street) res.object).getCity();
-				SearchResult cityResult = new SearchResult(phrase);
-				cityResult.object = ct;
-				cityResult.objectType = ObjectType.CITY;
-				cityResult.localeName = ct.getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
-				cityResult.otherNames = ct.getOtherNames(true);
-				cityResult.location = ct.getLocation();
-				cityResult.localeRelatedObjectName = res.file.getRegionName();
-				cityResult.file = res.file;
-				phrase.countUnknownWordsMatchMainResult(cityResult);
-				boolean match = false;
-				if (firstUnknownWordMatches) {
-					cityResult.firstUnknownWordMatches = false; // don't count same name twice
-				} else if (cityResult.firstUnknownWordMatches) {
-					firstUnknownWordMatches = true;
-					match = true;
-				}
-				if (cityResult.otherWordsMatch != null) {
-					Iterator<String> iterator = cityResult.otherWordsMatch.iterator();
-					while (iterator.hasNext()) {
-						String n = iterator.next();
-						boolean wasPresent = leftUnknownSearchWords.remove(n);
-						if (!wasPresent) {
-							iterator.remove(); // don't count same name twice
-						} else {
-							match = true;
-						}
-					}
-				}
-				// include parent search result even if it is empty
-				if (match) {
-					newParentSearchResult = cityResult;
-				}
-			}
-			if (!firstUnknownWordMatches) {
-				leftUnknownSearchWords.add(0, phrase.getFirstUnknownSearchWord());
+			List<String> leftUnknownSearchWords = res.filterUnknownSearchWord(null);
+			if (setParentSearchResult != null) {
+				phrase.countUnknownWordsMatchMainResult(setParentSearchResult);
+				leftUnknownSearchWords = setParentSearchResult.filterUnknownSearchWord(leftUnknownSearchWords);
 			}
 			// publish result to set parentSearchResult before search
 			if (publish) {
-				if (newParentSearchResult != null) {
-					SearchResult prev = resultMatcher.setParentSearchResult(newParentSearchResult);
+				if (setParentSearchResult != null) {
+					SearchResult prev = resultMatcher.setParentSearchResult(setParentSearchResult);
 					resultMatcher.publish(res);
 					resultMatcher.setParentSearchResult(prev);
 				} else {
@@ -235,6 +191,95 @@ protected SearchPhrase subSearchApiOrPublish(SearchPhrase phrase, SearchResultMa
 			}
 			return null;
 		}
+		
+		boolean matchAddressName(SearchPhrase phrase, SearchResult parent, SearchResult res, boolean fullMatch) {
+			boolean match = false;
+			if (parent != null) {
+				phrase.countUnknownWordsMatchMainResult(parent);
+			}
+			if (!phrase.isUnknownSearchWordPresent()) {
+				return false;
+			}
+			// res only used as container to count matches 
+//			phrase.countUnknownWordsMatchMainResult(res);
+			
+			NameStringMatcher nm = phrase.getMainUnknownNameStringMatcher();
+			String localeName = res.localeName;
+			Collection<String> otherNames = res.otherNames;
+			// quick check
+			if (!fullMatch && (nm.matches(localeName) || nm.matches(otherNames))) {
+				return true;
+			}
+			List<String> localeNames = SearchPhrase.splitWords(localeName, new ArrayList<String>(), SearchPhrase.ALLDELIMITERS);
+			if (parent == null || !parent.firstUnknownWordMatches) {
+				Iterator<String> it = localeNames.iterator();
+				while (it.hasNext()) {
+					String lName = it.next();
+					if (phrase.getFirstUnknownNameStringMatcher().matches(lName)) {
+						it.remove();
+					}
+				}
+				for (String otherName : otherNames) {
+					if (phrase.getFirstUnknownNameStringMatcher().matches(otherName)) {
+						if (!fullMatch || phrase.getCollator().equals(phrase.getFirstUnknownSearchWord(), otherName)) {
+							return true;
+						}
+					}
+				}
+			}
+			List<String> leftUnknownSearchWords = parent == null ? phrase.getUnknownSearchWords() : parent.filterUnknownSearchWord(null);
+			List<String> unknownSearchWords = phrase.getUnknownSearchWords();
+			for (int i = 0; i < unknownSearchWords.size() && !match; i++) {
+				String leftUnknownSearchWord = unknownSearchWords.get(i);
+				if (!leftUnknownSearchWords.contains(leftUnknownSearchWord)) {
+					continue;
+				}
+				Iterator<String> it = localeNames.iterator();
+				while (it.hasNext()) {
+					String lName = it.next();
+					if (phrase.getUnknownNameStringMatcher(i).matches(lName)) {
+						it.remove();
+					}
+				}
+				for (String otherName : otherNames) {
+					if (phrase.getUnknownNameStringMatcher(i).matches(otherName)) {
+						if (!fullMatch || phrase.getCollator().equals(phrase.getUnknownSearchWords().get(i), otherName)) {
+							return true;
+						}
+					}
+				}
+			}
+			if (localeNames.size() == 0) {
+				return true;
+			}
+			return false;
+		}
+		
+		Set<String> splitAddressSearchNames(String name) {
+			int prev = -1;
+			Set<String> namesToAdd = new HashSet<>();
+
+			for (int i = 0; i <= name.length(); i++) {
+				boolean isHyphenNearNumber = i != name.length() && name.charAt(i) == '-'
+						&& ((i + 1 < name.length() && Character.isDigit(name.charAt(i + 1)))
+								|| (i - 1 >= 0 && Character.isDigit(name.charAt(i - 1))));
+				if (i == name.length() || (!Character.isLetter(name.charAt(i)) && !Character.isDigit(name.charAt(i))
+						&& name.charAt(i) != '\'' && !isHyphenNearNumber)) {
+					if (prev != -1) {
+						String substr = name.substring(prev, i);
+						namesToAdd.add(substr.toLowerCase());
+						prev = -1;
+					}
+				} else {
+					if (prev == -1) {
+						prev = i;
+					}
+				}
+			}
+			return namesToAdd;
+		}
+
+
 
 		@Override
 		public String toString() {
@@ -289,16 +334,18 @@ public static class SearchAddressByNameAPI extends SearchBaseAPI {
 		private static final int DEFAULT_ADDRESS_BBOX_RADIUS = 100 * 1000;
 		private static final int LIMIT = 10000;
 
-		private Map<BinaryMapIndexReader, List<City>> townCities = new LinkedHashMap<>();
+		private Set<String> townCitiesInit = new LinkedHashSet<>();
 		private QuadTree<City> townCitiesQR = new QuadTree<City>(new QuadRect(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE),
-				8, 0.55f);
+				12, 0.55f);
+		private QuadTree<City> boundariesQR = new QuadTree<City>(new QuadRect(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE),
+				12, 0.55f);
 		private List<City> resArray = new ArrayList<>();
 		private SearchStreetByCityAPI cityApi;
 		private SearchBuildingAndIntersectionsByStreetAPI streetsApi;
 
 		public SearchAddressByNameAPI(SearchBuildingAndIntersectionsByStreetAPI streetsApi,
 									  SearchStreetByCityAPI cityApi) {
-			super(ObjectType.CITY, ObjectType.VILLAGE, ObjectType.POSTCODE,
+			super(ObjectType.CITY, ObjectType.VILLAGE, ObjectType.BOUNDARY, ObjectType.POSTCODE,
 					ObjectType.STREET, ObjectType.HOUSE, ObjectType.STREET_INTERSECTION);
 			this.streetsApi = streetsApi;
 			this.cityApi = cityApi;
@@ -340,7 +387,9 @@ public boolean search(final SearchPhrase phrase, final SearchResultMatcher resul
 				return false;
 			}
 			// phrase.isLastWord(ObjectType.CITY, ObjectType.VILLAGE, ObjectType.POSTCODE) || phrase.isLastWord(ObjectType.REGION)
-			if (phrase.isNoSelectedType() || phrase.getRadiusLevel() >= 2) {
+			if (phrase.isNoSelectedType() || phrase.isLastWord(ObjectType.BOUNDARY, ObjectType.REGION)
+					|| phrase.isLastWord(ObjectType.CITY, ObjectType.VILLAGE, ObjectType.POSTCODE)
+					|| phrase.getRadiusLevel() >= 2) {
 				initAndSearchCities(phrase, resultMatcher);
 				// not publish results (let it sort)
 				// resultMatcher.apiSearchFinished(this, phrase);
@@ -354,17 +403,35 @@ private void initAndSearchCities(final SearchPhrase phrase, final SearchResultMa
 			Iterator<BinaryMapIndexReader> offlineIndexes = phrase.getOfflineIndexes(bbox, SearchPhraseDataType.ADDRESS);
 			while (offlineIndexes.hasNext()) {
 				BinaryMapIndexReader r = offlineIndexes.next();
-				if (!townCities.containsKey(r)) {
+				if (!townCitiesInit.contains(r.getRegionName())) {
 					List<City> l = r.getCities(null, CityBlocks.CITY_TOWN_TYPE, null, phrase.getSettings().getStat());
-					townCities.put(r, l);
+					townCitiesInit.add(r.getRegionName());
 					for (City c  : l) {
 						c.setReferenceFile(r);
 						LatLon cl = c.getLocation();
+						
 						int y = MapUtils.get31TileNumberY(cl.getLatitude());
 						int x = MapUtils.get31TileNumberX(cl.getLongitude());
 						QuadRect qr = new QuadRect(x, y, x, y);
+						int[] bbox31 = c.getBbox31();
+						if (bbox31 != null) {
+							qr = new QuadRect(bbox31[0], bbox31[1], bbox31[2], bbox31[3]);
+						}
 						townCitiesQR.insert(c, qr);
 					}
+					l = r.getCities(null, CityBlocks.BOUNDARY_TYPE, null, phrase.getSettings().getStat());
+					for (City c  : l) {
+						c.setReferenceFile(r);
+						LatLon cl = c.getLocation();
+						int y = MapUtils.get31TileNumberY(cl.getLatitude());
+						int x = MapUtils.get31TileNumberX(cl.getLongitude());
+						QuadRect qr = new QuadRect(x, y, x, y);
+						int[] bbox31 = c.getBbox31();
+						if (bbox31 != null) {
+							qr = new QuadRect(bbox31[0], bbox31[1], bbox31[2], bbox31[3]);
+						}
+						boundariesQR.insert(c, qr);
+					}
 				}
 			}
 			if (phrase.isNoSelectedType() && bbox != null
@@ -392,8 +459,14 @@ private void initAndSearchCities(final SearchPhrase phrase, final SearchResultMa
 					if (phrase.isEmptyQueryAllowed() && phrase.isEmpty()) {
 						resultMatcher.publish(res);
 					} else if (nm.matches(res.localeName) || nm.matches(res.otherNames)) {
-						SearchPhrase nphrase = subSearchApiOrPublish(phrase, resultMatcher, res, cityApi);
-						searchPoiInCity(nphrase, res, resultMatcher);
+						subSearchApiOrPublish(phrase, resultMatcher, res, cityApi);
+						// No failed cases found yet - city / town should have exact boundary that street belongs to
+						
+						// // Require exact name matching to search street by name (not attached to city)
+						// It will be very inefficient too
+//						if (matchAddressName(phrase, null, res, true)) {
+//							subSearchApiOrPublish(phrase, resultMatcher, res, this);
+//						}
 					}
 					if (limit++ > LIMIT * phrase.getRadiusLevel()) {
 						break;
@@ -402,14 +475,6 @@ private void initAndSearchCities(final SearchPhrase phrase, final SearchResultMa
 			}
 		}
 		
-		private void searchPoiInCity(SearchPhrase nphrase, SearchResult res, SearchResultMatcher resultMatcher) throws IOException {
-			if (nphrase != null && res.objectType == ObjectType.CITY) {
-				SearchAmenityByNameAPI poiApi = new SearchCoreFactory.SearchAmenityByNameAPI();
-				SearchPhrase newPhrase = nphrase.generateNewPhrase(nphrase, res.file);
-				newPhrase.getSettings().setOriginalLocation(res.location);
-				poiApi.search(newPhrase, resultMatcher);
-			}
-		}
 
 		private void searchByName(final SearchPhrase phrase, final SearchResultMatcher resultMatcher)
 				throws IOException {
@@ -421,7 +486,7 @@ private void searchByName(final SearchPhrase phrase, final SearchResultMatcher r
 //				final QuadRect streetBbox = phrase.getRadiusBBoxToSearch(DEFAULT_ADDRESS_BBOX_RADIUS);
 				final QuadRect postcodeBbox = phrase.getRadiusBBoxToSearch(DEFAULT_ADDRESS_BBOX_RADIUS * 5);
 				final QuadRect villagesBbox = phrase.getRadiusBBoxToSearch(DEFAULT_ADDRESS_BBOX_RADIUS * 3);
-				final QuadRect cityBbox = phrase.getRadiusBBoxToSearch(DEFAULT_ADDRESS_BBOX_RADIUS * 5); // covered by separate search before
+				final QuadRect cityBbox = phrase.getRadiusBBoxToSearch(DEFAULT_ADDRESS_BBOX_RADIUS * 5); // covered by separate sbefore
 				final int priority = phrase.isNoSelectedType() ?
 						SEARCH_ADDRESS_BY_NAME_PRIORITY : SEARCH_ADDRESS_BY_NAME_PRIORITY_RADIUS2;
 				final BinaryMapIndexReader[] currentFile = new BinaryMapIndexReader[1];
@@ -458,7 +523,7 @@ public boolean publish(MapObject object) {
 							sr.objectType = ObjectType.STREET;
 							sr.localeRelatedObjectName = ((Street)object).getCity().getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
 							sr.relatedObject = ((Street)object).getCity();
-						} else if (object instanceof City) {
+						} else if (object instanceof City && !isLastWordCityGroup(phrase)) {
 							CityType type = ((City)object).getType();
 							if (type == CityType.CITY || type == CityType.TOWN) {
 								if (phrase.isNoSelectedType()) {
@@ -478,8 +543,16 @@ public boolean publish(MapObject object) {
 								}
 								sr.objectType = ObjectType.POSTCODE;
 								sr.priorityDistance = 0;
+							} else if (type == CityType.BOUNDARY) {
+								if ((locSpecified && !villagesBbox.contains(x, y, x, y))
+										|| !phrase.isSearchTypeAllowed(ObjectType.BOUNDARY)) {
+									return false;
+								}
+								sr.objectType = ObjectType.BOUNDARY;
+								sr.priorityDistance = 0;
+								phrase.countUnknownWordsMatchMainResult(sr);
 							} else if (type == CityType.HAMLET || type == CityType.SUBURB || 
-									type == CityType.VILLAGE || type == CityType.BOUNDARY) {
+									type == CityType.VILLAGE) {
 								if ((locSpecified && !villagesBbox.contains(x, y, x, y))
 										|| !phrase.isSearchTypeAllowed(ObjectType.VILLAGE)) {
 									return false;
@@ -540,6 +613,11 @@ public boolean isCancelled() {
 				Iterator<BinaryMapIndexReader> offlineIterator = phrase.getRadiusOfflineIndexes(DEFAULT_ADDRESS_BBOX_RADIUS * 5,
 						SearchPhraseDataType.ADDRESS);
 				String wordToSearch = phrase.getUnknownWordToSearch();
+				Set<String> wordToSearchSplit = splitAddressSearchNames(wordToSearch);
+				if (wordToSearchSplit.size() > 1) {
+					wordToSearch = phrase.selectMainUnknownWordToSearch(new ArrayList<>(wordToSearchSplit));
+				}
+				
 				while (offlineIterator.hasNext() && wordToSearch.length() > 0) {
 					BinaryMapIndexReader r = offlineIterator.next();
 					currentFile[0] = r;
@@ -561,7 +639,8 @@ public boolean isCancelled() {
 								continue;
 							}
 							if (bb != null) {
-								req.setBBox(x31, y31, bb[0], bb[1], bb[2], bb[3]);
+								int w = (bb[2] - bb[0]) / 3, h = (bb[3] - bb[1]) / 3; // enlarge for 1234 Golden Pond Road Woodhull	
+								req.setBBox(x31, y31, bb[0] - w, bb[1] - h, bb[2] + w, bb[3] + h);
 							} else {
 								req.setBBoxRadius(c.getLocation().getLatitude(), c.getLocation().getLongitude(),
 										(int) c.getType().getRadius() * 3);
@@ -571,22 +650,80 @@ public boolean isCancelled() {
 								phrase.getRadiusSearch(DEFAULT_ADDRESS_BBOX_RADIUS * 5));
 						}
 					}
+
 					r.searchAddressDataByName(req);
 					for (SearchResult res : immediateResults) {
 						if (res.objectType == ObjectType.STREET) {
-							subSearchApiOrPublish(phrase, resultMatcher, res, streetsApi);
+							SearchResult newParentSearchResult = null;
+							if (res.parentSearchResult == null && resultMatcher.getParentSearchResult() == null &&
+									res.object instanceof Street && ((Street) res.object).getCity() != null) {
+								City ct = ((Street) res.object).getCity();
+								SearchResult cityResult = new SearchResult(phrase);
+								cityResult.object = ct;
+								cityResult.objectType = ObjectType.CITY;
+								cityResult.localeName = ct.getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
+								cityResult.otherNames = ct.getOtherNames(true);
+								cityResult.location = ct.getLocation();
+								cityResult.localeRelatedObjectName = res.file.getRegionName();
+								cityResult.file = res.file;
+								// include parent search result even if it is empty
+								// for street-city don't require exact matching 
+								boolean match = matchAddressName(phrase, res, cityResult,  true);
+								if (match) {
+									newParentSearchResult = cityResult;
+								} else {
+									resArray.clear();
+									QuadRect bbox = SearchPhrase.caculateBbox(1000, res.location);
+									resArray = boundariesQR.queryInBox(bbox, resArray);
+									for (City boundary : resArray) {
+										int[] bb = boundary.getBbox31();
+										if (bb == null) {
+											continue;
+										}
+										QuadRect boundBox = new QuadRect(bb[0], bb[1], bb[2], bb[3]);
+										if (!QuadRect.intersects(boundBox, bbox)) {
+											continue;
+										}
+										// cityResult.object = boundary; // keep city the same
+										cityResult.localeName = boundary.getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
+										cityResult.otherNames = boundary.getOtherNames(true);
+										// for another city require exact matching
+										if (matchAddressName(phrase, res, cityResult,  true)) {
+											cityResult.object = boundary; 
+											cityResult.location = boundary.getLocation();
+											newParentSearchResult = cityResult;
+											break;
+										}
+									}
+								}
+								
+							}
+							subSearchApiOrPublish(phrase, resultMatcher, res, streetsApi, newParentSearchResult, true);
+						} else if (res.objectType == ObjectType.BOUNDARY ) {
+							// require exact matching to speed up
+							if (matchAddressName(phrase, null, res, true)) {
+								subSearchApiOrPublish(phrase, resultMatcher, res, this);
+							}
 						} else {
-							SearchPhrase nphrase = subSearchApiOrPublish(phrase, resultMatcher, res, cityApi);
-							searchPoiInCity(nphrase, res, resultMatcher);
+							 
+							subSearchApiOrPublish(phrase, resultMatcher, res, cityApi);
+							// if subsearch by cityApi we could avoid calling subsearch by boundary 
+							// but it's tricky to check how good matching reuslts (case Hohlmaier 1 Breuningsweiler)
+							
+							// require exact matching to search street by name (not attached to city) 
+							if (matchAddressName(phrase, null, res, true)) {
+								subSearchApiOrPublish(phrase, resultMatcher, res, this);
+							}
 						}
 					}
 					resultMatcher.apiSearchRegionFinished(this, r, phrase);
 				}
 			}
 		}
+		
 	}
 
-	public static class SearchAmenityByNameAPI extends SearchBaseAPI {
+		public static class SearchAmenityByNameAPI extends SearchBaseAPI {
 		private static final int LIMIT = 10000;
 		private static final int BBOX_RADIUS = 500 * 1000;
 		private static final int BBOX_RADIUS_INSIDE = 5600 * 1000; // 5600 is the minimum to pass test [14: hisar]
@@ -1464,7 +1601,7 @@ public int getSearchPriority(SearchPhrase p) {
 	public static class SearchStreetByCityAPI extends SearchBaseAPI {
 		private static final int DEFAULT_ADDRESS_BBOX_RADIUS = 100 * 1000;
 
-		private SearchBaseAPI streetsAPI;
+		private SearchBuildingAndIntersectionsByStreetAPI streetsAPI;
 		public SearchStreetByCityAPI(SearchBuildingAndIntersectionsByStreetAPI streetsAPI) {
 			super(ObjectType.HOUSE, ObjectType.STREET, ObjectType.STREET_INTERSECTION);
 			this.streetsAPI = streetsAPI;
@@ -1496,29 +1633,26 @@ public boolean search(SearchPhrase phrase, SearchResultMatcher resultMatcher) th
 					sw.getResult().file.preloadStreets(c, null, phrase.getSettings().getStat());
 				}
 				int limit = 0;
-				NameStringMatcher nm = phrase.getMainUnknownNameStringMatcher();
 				for (Street object : c.getStreets()) {
 					SearchResult res = new SearchResult(phrase);
-
 					res.localeName = object.getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
 					res.otherNames = object.getOtherNames(true);
+					res.object = object;
 					boolean pub = true;
 					if (object.getName().startsWith("<")) {
 						// streets related to city
 						pub = false;
-					} else if (phrase.isUnknownSearchWordPresent()
-							&& !(nm.matches(res.localeName) || nm.matches(res.otherNames))) {
+					} else if (phrase.isUnknownSearchWordPresent() && !matchAddressName(phrase, null, res, false)) {
 						continue;
 					}
 					res.localeRelatedObjectName = c.getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
-					res.object = object;
 					res.preferredZoom = PREFERRED_STREET_ZOOM;
 					res.file = sw.getResult().file;
 					res.location = object.getLocation();
 					res.priority = SEARCH_STREET_BY_CITY_PRIORITY;
 					//res.priorityDistance = 1;
 					res.objectType = ObjectType.STREET;
-					subSearchApiOrPublish(phrase, resultMatcher, res, streetsAPI, pub);
+					subSearchApiOrPublish(phrase, resultMatcher, res, streetsAPI, null, pub);
 					if (limit++ > LIMIT) {
 						break;
 					}
@@ -1642,19 +1776,18 @@ public int compare(Building o1, Building o2) {
 					resultMatcher.publish(res);
 				}
 				String streetIntersection = phrase.getUnknownWordToSearch();
-				NameStringMatcher streetMatch = phrase.getMainUnknownNameStringMatcher();
 				if (Algorithms.isEmpty(streetIntersection) ||
 						(!Character.isDigit(streetIntersection.charAt(0)) &&
-								CommonWords.getCommonSearch(streetIntersection) == -1) ) {
+						  CommonWords.getCommonSearch(streetIntersection) == -1) &&
+						 phrase.isSearchTypeAllowed(ObjectType.STREET_INTERSECTION)) {
 					for (Street street : s.getIntersectedStreets()) {
 						SearchResult res = new SearchResult(phrase);
-						if ((!streetMatch.matches(street.getName()) && !streetMatch.matches(street.getOtherNames(true)))
-								|| !phrase.isSearchTypeAllowed(ObjectType.STREET_INTERSECTION)) {
-							continue;
-						}
 						res.otherNames = street.getOtherNames(true);
 						res.localeName = street.getName(phrase.getSettings().getLang(), phrase.getSettings().isTransliterate());
 						res.object = street;
+						if (!matchAddressName(phrase, null, res, false)) {
+							continue;
+						}
 						res.file = file;
 						res.relatedObject = s;
 						res.priority = priority + 1;
@@ -1982,7 +2115,7 @@ private String formatLatLon(double latLon) {
 
 	public static boolean isLastWordCityGroup(SearchPhrase p ) {
 		return p.isLastWord(ObjectType.CITY) || p.isLastWord(ObjectType.POSTCODE) ||
-				p.isLastWord(ObjectType.VILLAGE);
+				p.isLastWord(ObjectType.VILLAGE) || p.isLastWord(ObjectType.BOUNDARY);
 	}
 
 	public static SearchResult createSearchResult(Amenity amenity, SearchPhrase phrase, MapPoiTypes poiTypes) {
diff --git a/OsmAnd-java/src/main/java/net/osmand/search/core/SearchPhrase.java b/OsmAnd-java/src/main/java/net/osmand/search/core/SearchPhrase.java
index 1868333cedf..5f97b70f16a 100644
--- a/OsmAnd-java/src/main/java/net/osmand/search/core/SearchPhrase.java
+++ b/OsmAnd-java/src/main/java/net/osmand/search/core/SearchPhrase.java
@@ -79,49 +79,8 @@ public class SearchPhrase {
 		conjunctions.add("y");
 		conjunctions.add("и");
 		
-		// short - issues for perfect matching "Drive A"
+		// Don't add short names !  issues for perfect matching "Drive A", ...
 //		conjunctions.add("f");
-//		conjunctions.add("u");
-//		conjunctions.add("jl.");
-//		conjunctions.add("j");
-//		conjunctions.add("sk");
-//		conjunctions.add("w");
-//		conjunctions.add("a.");
-//		conjunctions.add("of");
-//		conjunctions.add("k");
-//		conjunctions.add("r");
-//		conjunctions.add("h");
-//		conjunctions.add("mc");
-//		conjunctions.add("sw");
-//		conjunctions.add("g");
-//		conjunctions.add("v");
-//		conjunctions.add("m");
-//		conjunctions.add("c.");
-//		conjunctions.add("r.");
-//		conjunctions.add("ct");
-//		conjunctions.add("e.");
-//		conjunctions.add("dr.");
-//		conjunctions.add("j.");		
-//		conjunctions.add("in");
-//		conjunctions.add("al");
-//		conjunctions.add("út");
-//		conjunctions.add("per");
-//		conjunctions.add("ne");
-//		conjunctions.add("p");
-//		conjunctions.add("et");
-//		conjunctions.add("s.");
-//		conjunctions.add("f.");
-//		conjunctions.add("t");
-//		conjunctions.add("fe");
-//		conjunctions.add("à");
-//		conjunctions.add("i");
-//		conjunctions.add("c");
-//		conjunctions.add("le");
-//		conjunctions.add("s");
-//		conjunctions.add("av.");
-//		conjunctions.add("den");
-//		conjunctions.add("dr");
-//		conjunctions.add("y");
 
 		commonWordsComparator = new Comparator<String>() {
 
@@ -162,11 +121,6 @@ public BinaryMapIndexReader getFileRequest() {
 		return fileRequest;
 	}
 	
-	public SearchPhrase generateNewPhrase(SearchPhrase phrase, BinaryMapIndexReader file) {
-		SearchPhrase nphrase = generateNewPhrase(phrase.getUnknownSearchPhrase(), phrase.getSettings());
-		nphrase.fileRequest = file;
-		return nphrase;
-	}
 	
 	
 	public SearchPhrase generateNewPhrase(String text, SearchSettings settings) {
@@ -304,6 +258,16 @@ public SearchPhrase selectWord(SearchResult res, List<String> unknownWords, bool
 		return sp;
 	}
 	
+	public String selectMainUnknownWordToSearch(List<String> searchWords) {
+		Collections.sort(searchWords, commonWordsComparator);
+		for (String s : searchWords) {
+			s = s.trim();
+			if (s.length() > 0) {
+				return s;
+			}
+		}
+		return "";
+	}
 	
 	private void calcMainUnknownWordToSearch() {
 		if (mainUnknownWordToSearch != null) {
@@ -426,7 +390,12 @@ public QuadRect get1km31Rect() {
 		if (l == null) {
 			return null;
 		}
-		float coeff = (float) (1000 / MapUtils.getTileDistanceWidth(SearchRequest.ZOOM_TO_SEARCH_POI));
+		cache1kmRect= caculateBbox(1000, l);
+		return cache1kmRect;
+	}
+
+	public static QuadRect caculateBbox(int radiusMeters, LatLon l) {
+		float coeff = (float) (radiusMeters / MapUtils.getTileDistanceWidth(SearchRequest.ZOOM_TO_SEARCH_POI));
 		double tx = MapUtils.getTileNumberX(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLongitude());
 		double ty = MapUtils.getTileNumberY(SearchRequest.ZOOM_TO_SEARCH_POI, l.getLatitude());
 		double topLeftX = Math.max(0, tx - coeff);
@@ -435,8 +404,7 @@ public QuadRect get1km31Rect() {
 		double bottomRightX = Math.min(max, tx + coeff);
 		double bottomRightY = Math.min(max, ty + coeff);
 		double pw = MapUtils.getPowZoom(31 - SearchRequest.ZOOM_TO_SEARCH_POI);
-		cache1kmRect = new QuadRect(topLeftX * pw, topLeftY * pw, bottomRightX * pw, bottomRightY * pw);
-		return cache1kmRect;
+		return new QuadRect(topLeftX * pw, topLeftY * pw, bottomRightX * pw, bottomRightY * pw);
 	}
 	
 	
@@ -675,16 +643,16 @@ public boolean isEmpty() {
 	}
 
 	public SearchWord getLastSelectedWord() {
-		if(words.isEmpty()) {
+		if (words.isEmpty()) {
 			return null;
 		}
 		return words.get(words.size() - 1);
 	}
 	
 	public LatLon getWordLocation() {
-		for(int i = words.size() - 1; i >= 0; i--) {
+		for (int i = words.size() - 1; i >= 0; i--) {
 			SearchWord sw = words.get(i);
-			if(sw.getLocation() != null) {
+			if (sw.getLocation() != null) {
 				return sw.getLocation();
 			}
 		}
@@ -692,13 +660,13 @@ public LatLon getWordLocation() {
 	}
 	
 	public LatLon getLastTokenLocation() {
-		for(int i = words.size() - 1; i >= 0; i--) {
+		for (int i = words.size() - 1; i >= 0; i--) {
 			SearchWord sw = words.get(i);
-			if(sw.getLocation() != null) {
+			if (sw.getLocation() != null) {
 				return sw.getLocation();
 			}
 		}
-		// last token or myLocationOrVisibleMap if not selected 
+		// last token or myLocationOrVisibleMap if not selected
 		if (settings != null) {
 			return settings.getOriginalLocation();
 		}
@@ -845,7 +813,7 @@ private int countUnknownWordsMatchInternal(SearchResult sr, String extraName, in
 				}
 				if (match) {
 					if (sr.otherWordsMatch == null) {
-						sr.otherWordsMatch = new TreeSet<>();
+						sr.otherWordsMatch = new TreeSet<>(getCollator());
 					}
 					sr.otherWordsMatch.add(otherUnknownWords.get(i));
 					r++;
@@ -957,5 +925,17 @@ private boolean isTextComplete(String fullText) {
 		return lastUnknownSearchWordComplete;
 	}
 
+	public static String stripBraces(String localeName) {
+		int i = localeName.indexOf('(');
+		String retName = localeName;
+		if (i > -1) {
+			retName = localeName.substring(0, i);
+			int j = localeName.indexOf(')', i);
+			if (j > -1) {
+				retName = (retName.trim() + ' ' + localeName.substring(j + 1)).trim();
+			}
+		}
+		return retName;
+	}
 	
 }
diff --git a/OsmAnd-java/src/main/java/net/osmand/search/core/SearchResult.java b/OsmAnd-java/src/main/java/net/osmand/search/core/SearchResult.java
index 2a30885a927..467c2fc583b 100644
--- a/OsmAnd-java/src/main/java/net/osmand/search/core/SearchResult.java
+++ b/OsmAnd-java/src/main/java/net/osmand/search/core/SearchResult.java
@@ -22,7 +22,7 @@ public class SearchResult {
 
 	public static final String DELIMITER = " ";
 	private static final String HYPHEN = "-";
-	private static final int NEAREST_METERS_LIMIT = 30000;
+	static final int NEAREST_METERS_LIMIT = 30000;
 	
 	// MAX_TYPES_BASE_10 should be > ObjectType.getTypeWeight(objectType) = 5
 	public static final double MAX_TYPES_BASE_10 = 10;
@@ -81,12 +81,11 @@ public double getUnknownPhraseMatchWeight() {
 		if (unknownPhraseMatchWeight != 0) {
 			return unknownPhraseMatchWeight;
 		}
-		// normalize number to get as power, so we get numbers > 1
-		unknownPhraseMatchWeight = getSumPhraseMatchWeight() / Math.pow(MAX_PHRASE_WEIGHT_TOTAL, getDepth() - 1);
+		unknownPhraseMatchWeight = getSumPhraseMatchWeight(null);
 		return unknownPhraseMatchWeight;
 	}
 
-	private double getSumPhraseMatchWeight() {
+	private double getSumPhraseMatchWeight(SearchResult exactResult) {
 		double res = ObjectType.getTypeWeight(objectType);
 		if (requiredSearchPhrase.getUnselectedPoiType() != null) {
 			// search phrase matches poi type, then we lower all POI matches and don't check allWordsMatched
@@ -94,27 +93,54 @@ private double getSumPhraseMatchWeight() {
 			// don't overload with poi types
 		} else {
 			CheckWordsMatchCount completeMatchRes = new CheckWordsMatchCount();
-			boolean matched = false;
-			matched = allWordsMatched(localeName, completeMatchRes);
+			boolean matched = allWordsMatched(localeName, exactResult, completeMatchRes);
+			// incorrect fix
+//			if (!matched && object instanceof Street s) { // parentSearchResult == null &&
+//				matched = allWordsMatched(localeName + " " + s.getCity().getName(requiredSearchPhrase.getSettings().getLang()), exactResult, completeMatchRes);
+//			}
 			if (!matched && alternateName != null && !Algorithms.objectEquals(cityName, alternateName)) {
-				matched = allWordsMatched(alternateName, completeMatchRes);
+				matched = allWordsMatched(alternateName, exactResult, completeMatchRes);
 			}
 			if (!matched && otherNames != null) {
 				for (String otherName : otherNames) {
-					if (allWordsMatched(otherName, completeMatchRes)) {
+					if (allWordsMatched(otherName, exactResult, completeMatchRes)) {
 						matched = true;
 						break;
 					}
 				}
 			}
+			City selectedCity = null;
+			if (exactResult != null && exactResult.object instanceof Street s) {
+				selectedCity = s.getCity();
+			} else if (exactResult != null && 
+					exactResult.parentSearchResult != null && exactResult.parentSearchResult.object instanceof Street s) {
+				selectedCity = s.getCity();
+			}
+			if (matched && selectedCity != null && object instanceof City c) {
+				// city don't match because of boundary search -> lower priority
+				if (!Algorithms.objectEquals(selectedCity.getName(), c.getName())) {
+					matched = false;
+					// for unmatched cities calculate how close street is to boundary
+					// 1 - very close, 0 - very far
+					int[] bbox31 = selectedCity.getBbox31();
+					LatLon latlon = selectedCity.getLocation();
+					if (bbox31 != null) {
+						// even center is shifted probably best to do combination of bbox & center
+						double lon = MapUtils.get31LongitudeX(bbox31[0] / 2 + bbox31[2] / 2);
+						double lat = MapUtils.get31LatitudeY(bbox31[1] / 2 + bbox31[3] / 2);
+						latlon = new LatLon(lat, lon);
+					}
+					res += 100 / Math.max(100, MapUtils.getDistance(location, latlon));
+				}
+			}
 			// if all words from search phrase match (<) the search result words - we prioritize it higher
-			if (completeMatchRes.allWordsInPhraseAreInResult) {
+			if (matched) {
 				res = getPhraseWeightForCompleteMatch(completeMatchRes);
 			}
 		}
 		if (parentSearchResult != null) {
 			// parent search result should not change weight of current result, so we divide by MAX_TYPES_BASE_10^2
-			res = res + parentSearchResult.getSumPhraseMatchWeight() / (MAX_PHRASE_WEIGHT_TOTAL);
+			res = res + parentSearchResult.getSumPhraseMatchWeight(exactResult == null ? this : exactResult) / (MAX_PHRASE_WEIGHT_TOTAL);
 		}
 		return res;
 	}
@@ -122,10 +148,10 @@ private double getSumPhraseMatchWeight() {
 	private double getPhraseWeightForCompleteMatch(CheckWordsMatchCount completeMatchRes) {
 		double res = ObjectType.getTypeWeight(objectType) * MAX_TYPES_BASE_10;
 		// if all words from search phrase == the search result words - we prioritize it even higher
-		if (completeMatchRes.allWordsEqual && requiredSearchPhrase.getLastTokenLocation() != null && this.location != null) {
-			boolean closeDistance = MapUtils.getDistance(requiredSearchPhrase.getLastTokenLocation(),
-					this.location) <= NEAREST_METERS_LIMIT;
-			if (objectType == ObjectType.CITY || objectType == ObjectType.VILLAGE || closeDistance) {
+		if (completeMatchRes.allWordsEqual) {
+			boolean closeDistance = requiredSearchPhrase.getLastTokenLocation() != null && this.location != null 
+					&& MapUtils.getDistance(requiredSearchPhrase.getLastTokenLocation(), this.location) <= NEAREST_METERS_LIMIT;
+			if (objectType != ObjectType.POI || closeDistance) {
 				res = ObjectType.getTypeWeight(objectType) * MAX_TYPES_BASE_10 + MAX_PHRASE_WEIGHT_TOTAL / 2;
 			}
 		}
@@ -148,10 +174,23 @@ public int getFoundWordCount() {
 		}
 		return inc;
 	}
+	
+	public boolean hasObjectTypePresent(ObjectType type) {
+		if (objectType == type) {
+			return true;
+		}
+		if (parentSearchResult != null) {
+			return parentSearchResult.hasObjectTypePresent(type);
+		}
+		return false;
+	}
 
-	private boolean allWordsMatched(String name, CheckWordsMatchCount cnt) {
+	private boolean allWordsMatched(String name, SearchResult exactResult, CheckWordsMatchCount cnt) {
 		List<String> searchPhraseNames = getSearchPhraseNames();
 		List<String> localResultNames;
+		if (name.indexOf('(') != -1) {
+			name = SearchPhrase.stripBraces(name);
+		}
 		if (!requiredSearchPhrase.getFullSearchPhrase().contains(HYPHEN)) {
 			// we split '-' words in result, so user can input same without '-'
 			localResultNames = SearchPhrase.splitWords(name, new ArrayList<String>(), SearchPhrase.ALLDELIMITERS_WITH_HYPHEN);
@@ -163,6 +202,17 @@ private boolean allWordsMatched(String name, CheckWordsMatchCount cnt) {
 		if (searchPhraseNames.isEmpty()) {
 			return false;
 		}
+		while (exactResult != null && exactResult != this) {
+			List<String> lst = exactResult.getSearchPhraseNames();
+			for (String l : lst) {
+				int i = searchPhraseNames.indexOf(l);
+				if (i != -1) {
+					searchPhraseNames.remove(i);
+				}
+			}
+			exactResult = exactResult.parentSearchResult;
+		}
+		
 		int idxMatchedWord = -1;
 		for (String searchPhraseName : searchPhraseNames) {
 			wordMatched = false;
@@ -201,6 +251,17 @@ private List<String> getSearchPhraseNames() {
 		if (ow != null) {
 			searchPhraseNames.addAll(ow);
 		}
+		// when parent result was recreated with same phrase (it doesn't have preselected word)
+		// SearchCoreFactory.subSearchApiOrPublish
+		if (parentSearchResult != null && requiredSearchPhrase == parentSearchResult.requiredSearchPhrase
+				&& parentSearchResult.getOtherWordsMatch() != null) {
+			for (String s : parentSearchResult.getOtherWordsMatch()) {
+				int i = searchPhraseNames.indexOf(s);
+				if (i != -1) {
+					searchPhraseNames.remove(i);
+				}
+			}
+		}
 
 		return searchPhraseNames;
 	}
@@ -321,4 +382,26 @@ public void setUnknownPhraseMatchWeight(double weight) {
 	public boolean isFullPhraseEqualLocaleName() {
 		return requiredSearchPhrase.getFullSearchPhrase().equalsIgnoreCase(localeName);
 	}
+
+	public List<String> filterUnknownSearchWord(List<String> leftUnknownSearchWords) {
+		if (leftUnknownSearchWords == null) {
+			leftUnknownSearchWords = new ArrayList<String>(requiredSearchPhrase.getUnknownSearchWords());
+			leftUnknownSearchWords.add(0, requiredSearchPhrase.getFirstUnknownSearchWord());
+		}
+		if (firstUnknownWordMatches) {
+			leftUnknownSearchWords.remove(requiredSearchPhrase.getFirstUnknownSearchWord());
+		}
+		if (otherWordsMatch != null) {
+//			removeAll(res.otherWordsMatch); // incorrect 
+			for (String otherWord : otherWordsMatch) {
+				int ind = firstUnknownWordMatches ? leftUnknownSearchWords.indexOf(otherWord)
+						: leftUnknownSearchWords.lastIndexOf(otherWord);
+				if (ind != -1) {
+					leftUnknownSearchWords.remove(ind); // remove 1 by 1
+				}
+			}
+		}
+		
+		return leftUnknownSearchWords;
+	}
 }
