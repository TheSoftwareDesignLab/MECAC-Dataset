diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoCalculator.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoCalculator.java
index d7a3048b02a..25d80793cce 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoCalculator.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoCalculator.java
@@ -3,6 +3,7 @@
 import static net.osmand.plus.views.mapwidgets.widgets.DistanceToPointWidget.DESTINATION_REACHED_THRESHOLD;
 
 import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
 
 import net.osmand.Location;
 import net.osmand.data.LatLon;
@@ -14,6 +15,8 @@
 import net.osmand.plus.views.OsmandMapTileView;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 
 public class RouteInfoCalculator {
@@ -33,45 +36,95 @@ public RouteInfoCalculator(@NonNull MapActivity mapActivity) {
 		this.targetPointsHelper = app.getTargetPointsHelper();
 	}
 
+	/**
+	 * Calculates route information with a priority setting.
+	 *
+	 * @param priority The display priority (intermediate first or final destination first).
+	 * @return A list of DestinationInfo objects representing route points.
+	 */
+	@NonNull
+	public List<DestinationInfo> calculateRouteInformation(@NonNull DisplayPriority priority) {
+		DestinationInfo currentIntermediate = getCurrentIntermediateInfo();
+		DestinationInfo finalDestination = getFinalDestinationInfo();
+		if (currentIntermediate != null && finalDestination != null) {
+			return priority == DisplayPriority.INTERMEDIATE_FIRST
+					? Arrays.asList(currentIntermediate, finalDestination)
+					: Arrays.asList(finalDestination, currentIntermediate);
+		} else if (finalDestination != null) {
+			return Collections.singletonList(finalDestination);
+		}
+		return Collections.emptyList();
+	}
+
+	/**
+	 * Calculates route information, considering intermediate and final destination points.
+	 *
+	 * @return A list of DestinationInfo objects representing the upcoming route points.
+	 */
 	@NonNull
 	public List<DestinationInfo> calculateRouteInformation() {
-		List<DestinationInfo> intermediateInfos = collectNotPassedIntermediatePoints();
-		List<DestinationInfo> destinationInfos = new ArrayList<>(intermediateInfos);
+		List<DestinationInfo> intermediates = collectNotPassedIntermediatePoints(POINTS_LIMIT);
+		List<DestinationInfo> result = new ArrayList<>(intermediates);
 
-		if (destinationInfos.size() < POINTS_LIMIT) {
-			TargetPoint finalDestination = mapActivity.getPointToNavigate();
+		if (result.size() < POINTS_LIMIT) {
+			DestinationInfo finalDestination = getFinalDestinationInfo();
 			if (finalDestination != null) {
-				int distance = getDistanceToDestination(finalDestination.getLatLon());
-				int leftTime = getEstimatedTimeToDestination();
-				if (isPointNotPassed(distance, leftTime)) {
-					destinationInfos.add(createDestinationInfo(distance, leftTime));
-				}
+				result.add(finalDestination);
 			}
 		}
-		return destinationInfos;
+		return result;
 	}
 
+	@Nullable
+	private DestinationInfo getCurrentIntermediateInfo() {
+		List<DestinationInfo> intermediateInfos = collectNotPassedIntermediatePoints(1);
+		return !intermediateInfos.isEmpty() ? intermediateInfos.get(0) : null;
+	}
+
+	/**
+	 * Collects unpassed intermediate route points, limited by the specified count.
+	 *
+	 * @param pointsLimit The maximum number of intermediate points to return.
+	 * @return A list of DestinationInfo objects for upcoming intermediate points.
+	 */
 	@NonNull
-	private List<DestinationInfo> collectNotPassedIntermediatePoints() {
+	private List<DestinationInfo> collectNotPassedIntermediatePoints(int pointsLimit) {
 		List<DestinationInfo> result = new ArrayList<>();
-
 		TargetPoint intermediate;
-		int intermediatePointIndex = 0;
-		while ((intermediate = targetPointsHelper.getIntermediatePoint(intermediatePointIndex)) != null) {
-			int distance = getDistanceToIntermediate(intermediate.getLatLon(), intermediatePointIndex);
-			int estimatedTime = getEstimatedTimeToIntermediate(intermediatePointIndex);
+		int index = 0;
+		while ((intermediate = targetPointsHelper.getIntermediatePoint(index)) != null) {
+			int distance = getDistanceToIntermediate(intermediate.getLatLon(), index);
+			int estimatedTime = getEstimatedTimeToIntermediate(index);
 
 			if (isPointNotPassed(distance, estimatedTime)) {
 				result.add(createDestinationInfo(distance, estimatedTime));
-				if (result.size() == POINTS_LIMIT) {
+				if (result.size() >= pointsLimit) {
 					break;
 				}
 			}
-			intermediatePointIndex++;
+			index++;
 		}
 		return result;
 	}
 
+	/**
+	 * Retrieves the final destination information if available.
+	 *
+	 * @return The final DestinationInfo or null if the destination has been reached.
+	 */
+	@Nullable
+	private DestinationInfo getFinalDestinationInfo() {
+		TargetPoint destination = mapActivity.getPointToNavigate();
+		if (destination != null) {
+			int distance = getDistanceToDestination(destination.getLatLon());
+			int leftTime = getEstimatedTimeToDestination();
+			if (isPointNotPassed(distance, leftTime)) {
+				return createDestinationInfo(distance, leftTime);
+			}
+		}
+		return null;
+	}
+
 	private int getDistanceToIntermediate(@NonNull LatLon location, int intermediateIndexOffset) {
 		if (routingHelper.isRouteCalculated()) {
 			return routingHelper.getLeftDistanceToIntermediate(intermediateIndexOffset);
diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoWidget.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoWidget.java
index 72c6b81991a..502ba8b20e0 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoWidget.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/routeinfo/RouteInfoWidget.java
@@ -56,6 +56,7 @@ public class RouteInfoWidget extends MapWidget implements ISupportVerticalPanel,
 	private final RouteInfoCalculator calculator;
 	private List<DestinationInfo> cachedRouteInfo;
 	private RouteInfoDisplayMode cachedDisplayMode;
+	private DisplayPriority cachedDisplayPriority;
 	private int cachedContentLayoutId;
 	private Integer cachedMetricSystem;
 	private boolean forceUpdate = false;
@@ -73,7 +74,7 @@ public class RouteInfoWidget extends MapWidget implements ISupportVerticalPanel,
 	private View blocksDivider;
 
 	public RouteInfoWidget(@NonNull MapActivity mapActivity, @Nullable String customId,
-			@Nullable WidgetsPanel panel) {
+	                       @Nullable WidgetsPanel panel) {
 		super(mapActivity, ROUTE_INFO, customId, panel);
 		widgetState = new RouteInfoWidgetState(app, customId);
 		calculator = new RouteInfoCalculator(mapActivity);
@@ -196,7 +197,10 @@ protected boolean shouldHide() {
 	}
 
 	private void updateRouteInformation() {
-		List<DestinationInfo> calculatedRouteInfo = calculator.calculateRouteInformation();
+		ApplicationMode appMode = settings.getApplicationMode();
+		DisplayPriority priority = getDisplayPriority(appMode);
+
+		List<DestinationInfo> calculatedRouteInfo = calculator.calculateRouteInformation(priority);
 		if (Algorithms.isEmpty(calculatedRouteInfo)) {
 			updateVisibility(false);
 			return;
@@ -208,7 +212,7 @@ private void updateRouteInformation() {
 		}
 		cachedRouteInfo = calculatedRouteInfo;
 
-		RouteInfoDisplayMode primaryDisplayMode = getDisplayMode(settings.getApplicationMode());
+		RouteInfoDisplayMode primaryDisplayMode = getDisplayMode(appMode);
 		RouteInfoDisplayMode[] orderedDisplayModes = RouteInfoDisplayMode.values(primaryDisplayMode);
 
 		updatePrimaryBlock(cachedRouteInfo.get(0), orderedDisplayModes);
@@ -225,7 +229,7 @@ private void updateRouteInformation() {
 	}
 
 	private void updatePrimaryBlock(@NonNull DestinationInfo destinationInfo,
-			@NonNull RouteInfoDisplayMode[] modes) {
+	                                @NonNull RouteInfoDisplayMode[] modes) {
 		Map<RouteInfoDisplayMode, String> displayData = prepareDisplayData(destinationInfo);
 
 		tvPrimaryValue1.setText(displayData.get(modes[0]));
@@ -234,7 +238,7 @@ private void updatePrimaryBlock(@NonNull DestinationInfo destinationInfo,
 	}
 
 	private void updateSecondaryBlock(@NonNull DestinationInfo destinationInfo,
-			@NonNull RouteInfoDisplayMode[] modes) {
+	                                  @NonNull RouteInfoDisplayMode[] modes) {
 		Map<RouteInfoDisplayMode, String> displayData = prepareDisplayData(destinationInfo);
 
 		tvPrimaryValue2.setText(displayData.get(modes[0]));
@@ -263,6 +267,11 @@ private boolean isUpdateNeeded(@NonNull List<DestinationInfo> routeInfo) {
 			cachedDisplayMode = displayMode;
 			return true;
 		}
+		DisplayPriority displayPriority = widgetState.getDisplayPriority();
+		if (cachedDisplayPriority != displayPriority) {
+			cachedDisplayPriority = displayPriority;
+			return true;
+		}
 		if (Algorithms.isEmpty(cachedRouteInfo) || isDataChanged(cachedRouteInfo.get(0), routeInfo.get(0))) {
 			return true;
 		}
