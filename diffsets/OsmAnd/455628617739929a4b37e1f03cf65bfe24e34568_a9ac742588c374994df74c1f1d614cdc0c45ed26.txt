diff --git a/DataExtractionOSM/src/net/osmand/Algoritms.java b/DataExtractionOSM/src/net/osmand/Algoritms.java
index 08057c1f4ea..013e86472d2 100644
--- a/DataExtractionOSM/src/net/osmand/Algoritms.java
+++ b/DataExtractionOSM/src/net/osmand/Algoritms.java
@@ -129,10 +129,10 @@ public static void putLongToBytes(byte[] bytes, int offset, long l){
 	
 	
 	public static int parseIntFromBytes(byte[] bytes, int offset) {
-		int o = 0xff & bytes[offset + 3];
-		o = o << 8 | (0xff & bytes[offset + 2]);
-		o = o << 8 | (0xff & bytes[offset + 1]);
-		o = o << 8 | (0xff & bytes[offset + 0]);
+		int o = (0xff & bytes[offset + 3]) << 24;
+		o |= (0xff & bytes[offset + 2]) << 16;
+		o |= (0xff & bytes[offset + 1]) << 8;
+		o |= (0xff & bytes[offset + 0]);
 		return o;
 	}
 	
diff --git a/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java b/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
index 9e579a14c8f..0db583349ee 100644
--- a/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
+++ b/DataExtractionOSM/src/net/osmand/data/preparation/IndexCreator.java
@@ -953,7 +953,6 @@ private void iterateEntity(Entity e, int step) throws SQLException {
 					// manipulate what kind of way to load
 					loadEntityData(e, true);
 					boolean inverse = "-1".equals(e.getTag(OSMTagKey.ONEWAY));
-
 					writeEntityToMapDatabase(e, e.getId(), inverse, 0);
 					indexLowLevelMap(e, 1);
 					indexLowLevelMap(e, 2);
@@ -1020,28 +1019,31 @@ private void iterateEntity(Entity e, int step) throws SQLException {
 				}
 			}
 		} else if (step == STEP_ADDRESS_RELATIONS_AND_MULTYPOLYGONS) {
-			if (e instanceof Relation && "address".equals(e.getTag(OSMTagKey.TYPE))) {
-				indexAddressRelation((Relation) e);
-			}
-			if(e instanceof Relation && "multipolygon".equals(e.getTag(OSMTagKey.TYPE))){
-				loadEntityData(e, true);
-				Map<Entity, String> entities = ((Relation) e).getMemberEntities();
-				for(Entity es : entities.keySet()){
-					if(es instanceof Way){
-						boolean inner = "inner".equals(entities.get(es));
-						// TODO determine clockwise
-						boolean clockwise = true;
-						// TODO add tags from relation to outer ways!
-						
-						boolean inverse = !clockwise == inner;
-						writeEntityToMapDatabase(es, es.getId(), inverse, 0);
-						indexLowLevelMap(es, 1);
-						indexLowLevelMap(es, 2);
-						
-						multiPolygonsWays.add(es.getId());
-					}
+			if (indexAddress) {
+				if (e instanceof Relation && "address".equals(e.getTag(OSMTagKey.TYPE))) {
+					indexAddressRelation((Relation) e);
 				}
 			}
+//			if(indexMap && e instanceof Relation && "multipolygon".equals(e.getTag(OSMTagKey.TYPE))){
+//				loadEntityData(e, true);
+//				Map<Entity, String> entities = ((Relation) e).getMemberEntities();
+//				for(Entity es : entities.keySet()){
+//					if(es instanceof Way){
+//						
+//						boolean inner = "inner".equals(entities.get(es));
+//						// TODO determine clockwise
+//						boolean clockwise = true;
+//						// TODO add tags from relation to outer ways!
+//						
+//						boolean inverse = !clockwise == inner;
+//						writeEntityToMapDatabase(es, es.getId(), inverse, 0);
+//						indexLowLevelMap(es, 1);
+//						indexLowLevelMap(es, 2);
+//						
+//						multiPolygonsWays.add(es.getId());
+//					}
+//				}
+//			}
 		} else if (step == STEP_CITY_NODES) {
 			registerCityIfNeeded(e);
 		}
@@ -1206,6 +1208,9 @@ private void writeEntityToMapDatabase(Entity e, long baseId, boolean inverse, in
 			if (level > 0) {
 				List<Node> nodes = ((Way) e).getNodes();
 				Way way = new Way(id);
+				for(String t : e.getTagKeySet()){
+					way.putTag(t, e.getTag(t));
+				}
 				int prevX = 0;
 				int prevY = 0;
 				for (int i = 0; i < nodes.size(); i++) {
@@ -1468,15 +1473,17 @@ public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter
 			progress.startTask("Preindexing address...", -1);
 			allRelations = iterateOverEntities(progress, EntityType.RELATION, allRelations, STEP_ADDRESS_RELATIONS_AND_MULTYPOLYGONS);
 			// commit to put all cities
-			if(pStatements.get(addressBuildingStat) > 0){
-				addressBuildingStat.executeBatch();
-				pStatements.put(addressBuildingStat, 0);
-			}
-			if(pStatements.get(addressStreetNodeStat) > 0){
-				addressStreetNodeStat.executeBatch();
-				pStatements.put(addressStreetNodeStat, 0);
+			if (indexAddress) {
+				if (pStatements.get(addressBuildingStat) > 0) {
+					addressBuildingStat.executeBatch();
+					pStatements.put(addressBuildingStat, 0);
+				}
+				if (pStatements.get(addressStreetNodeStat) > 0) {
+					addressStreetNodeStat.executeBatch();
+					pStatements.put(addressStreetNodeStat, 0);
+				}
+				addressConnection.commit();
 			}
-			addressConnection.commit();
 		}
 		
 
@@ -1611,8 +1618,8 @@ public static void main(String[] args) throws IOException, SAXException, SQLExce
 //		 creator.setNodesDBFile(new File("e:/Information/OSM maps/osmand/ams.tmp.odb"));
 //		 creator.generateIndexes(new File("e:/Information/OSM maps/osm_map/ams_part_map.osm"), new ConsoleProgressImplementation(3), null);
 		 
-//		 creator.setNodesDBFile(new File("e:/Information/OSM maps/osmand/netherlands.tmp.odb"));
-//		 creator.generateIndexes(new File("e:/Information/OSM maps/osm_map/netherlands.osm.bz2"), new ConsoleProgressImplementation(1), null);
+		 creator.setNodesDBFile(new File("e:/Information/OSM maps/osmand/netherlands.tmp.odb"));
+		 creator.generateIndexes(new File("e:/Information/OSM maps/osm_map/netherlands.osm.bz2"), new ConsoleProgressImplementation(1), null);
 		 
 		/*try {
 //			RTree rtree = new RTree("e:/Information/OSM maps/osmand/Belarus_2010_09_03.map.odb_ind");
diff --git a/DataExtractionOSM/src/net/osmand/osm/MapRenderObject.java b/DataExtractionOSM/src/net/osmand/osm/MapRenderObject.java
index d51c92599bc..61d580710f7 100644
--- a/DataExtractionOSM/src/net/osmand/osm/MapRenderObject.java
+++ b/DataExtractionOSM/src/net/osmand/osm/MapRenderObject.java
@@ -48,7 +48,7 @@ public int getPoint31YTile(int ind){
 		return Algoritms.parseIntFromBytes(data, ind * 8);
 	}
 	
-	public float getPoint31XTile(int ind) {
+	public int getPoint31XTile(int ind) {
 		return Algoritms.parseIntFromBytes(data, ind * 8 + 4);
 	}
 	
diff --git a/DataExtractionOSM/src/net/osmand/osm/MultyPolygon.java b/DataExtractionOSM/src/net/osmand/osm/MultyPolygon.java
new file mode 100644
index 00000000000..454beaa6f9f
--- /dev/null
+++ b/DataExtractionOSM/src/net/osmand/osm/MultyPolygon.java
@@ -0,0 +1,8 @@
+package net.osmand.osm;
+
+public class MultyPolygon {
+	
+	public MultyPolygon(){
+	}
+
+}
diff --git a/OsmAnd/src/net/osmand/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/render/OsmandRenderer.java
index 358e5322621..9d6769e2de4 100644
--- a/OsmAnd/src/net/osmand/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/render/OsmandRenderer.java
@@ -59,6 +59,22 @@ public class OsmandRenderer implements Comparator<MapRenderObject> {
 
 	
 	private static class TextDrawInfo {
+		
+		public TextDrawInfo(String text){
+			this.text = text;
+		}
+		
+		public void fillProperties(RenderingContext rc, float centerX, float centerY){
+			this.centerX = centerX + rc.textDx;
+			this.centerY = centerY + rc.textDy;
+			textColor = rc.textColor;
+			textSize = rc.textSize;
+			textShadow = (int) rc.textHaloRadius;
+			textWrap = rc.textWrapWidth;
+			bold = rc.textBold;
+			minDistance = rc.textMinDistance;
+			shieldRes = rc.textShield;
+		}
 		String text = null;
 		Path drawOnPath = null;
 		float vOffset = 0;
@@ -66,6 +82,7 @@ private static class TextDrawInfo {
 		float pathRotate = 0;
 		float centerY = 0;
 		float textSize = 0;
+		float minDistance = 0;
 		int textColor = Color.BLACK;
 		int textShadow = 0;
 		int textWrap = 0;
@@ -304,12 +321,16 @@ public int compare(RectF object1, RectF object2) {
 					bounds.set(text.centerX - 3 * text.textSize / 2, text.centerY - mes/2, 
 										text.centerX + 3 * text.textSize / 2, text.centerY + mes/2);
 				}
+				if(text.minDistance > 0){
+					bounds.set(bounds.left - text.minDistance / 2, bounds.top - text.minDistance / 2
+							, bounds.right + text.minDistance / 2, bounds.bottom + text.minDistance / 2);
+				}
 				List<RectF> boundsIntersect = text.drawOnPath == null ? boundsNotPathIntersect : boundsPathIntersect;
 				if(boundsIntersect.isEmpty()){
 					boundsIntersect.add(bounds);
 				} else {
-					final int diff = 3;
-					final int diff2 = 15;
+					final int diff = (int) 3 ;
+					final int diff2 =  (int) 15;
 					// implement binary search 
 					int index = Collections.binarySearch(boundsIntersect, bounds, c);
 					if (index < 0) {
@@ -318,7 +339,7 @@ public int compare(RectF object1, RectF object2) {
 					// find sublist that is appropriate
 					int e = index;
 					while (e < boundsIntersect.size()) {
-						if (boundsIntersect.get(e).left < bounds.right) {
+						if (boundsIntersect.get(e).left < bounds.right ) {
 							e++;
 						} else {
 							break;
@@ -329,7 +350,7 @@ public int compare(RectF object1, RectF object2) {
 						// that's not exact algorithm that replace comparison rect with each other
 						// because of that comparison that is not obvious 
 						// (we store array sorted by left boundary, not by right) - that's euristic
-						if (boundsIntersect.get(st).right > bounds.left) {
+						if (boundsIntersect.get(st).right > bounds.left ) {
 							st--;
 						} else {
 							break;
@@ -347,6 +368,10 @@ public int compare(RectF object1, RectF object2) {
 						}
 					}
 					// store in list sorted by left boundary
+					if(text.minDistance > 0){
+						bounds.set(bounds.left + text.minDistance / 2, bounds.top + text.minDistance / 2,
+								bounds.right - text.minDistance / 2, bounds.bottom - text.minDistance / 2);
+					}
 					boundsIntersect.add(index, bounds);
 				}
 				
@@ -363,8 +388,9 @@ public int compare(RectF object1, RectF object2) {
 //					}
 //					paintText.setTextSize(text.textSize);
 //				}
-				paintText.setColor(text.textColor);
 				
+				
+				paintText.setColor(text.textColor);
 				if(text.drawOnPath != null){
 					cv.drawTextOnPath(text.text, text.drawOnPath, 0, text.vOffset, paintText);
 				} else {
@@ -378,7 +404,7 @@ public int compare(RectF object1, RectF object2) {
 						}
 						Bitmap ico = cachedIcons.get(text.shieldRes);
 						if (ico  != null) {
-							cv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 1, text.centerY - text.textSize - 2, paintIcon);
+							cv.drawBitmap(ico, text.centerX - ico.getWidth() / 2 - 0.5f, text.centerY - text.textSize - 2, paintIcon);
 						}
 					}
 					if(text.text.length() > text.textWrap){
@@ -442,15 +468,8 @@ protected void draw(MapRenderObject obj, Canvas canvas, RenderingContext rc) {
 					}
 					
 					if (rc.textSize > 0 && name != null) {
-						TextDrawInfo info = new TextDrawInfo();
-						info.centerX = center.x + rc.textDx;
-						info.centerY = center.y + rc.textDy;
-						info.textColor = rc.textColor;
-						info.textSize = rc.textSize;
-						info.text = name;
-						info.textShadow = (int) rc.textHaloRadius;
-						info.textWrap = rc.textWrapWidth;
-						info.bold = rc.textBold;
+						TextDrawInfo info = new TextDrawInfo(name);
+						
 						rc.textToDraw.add(info);
 					}
 				}
@@ -570,15 +589,8 @@ private void drawPoint(MapRenderObject obj, Canvas canvas, RenderingContext rc)
 			rc.clearText();
 			n = renderObjectText(n, subType, type, zoom, true, rc);
 			if (rc.textSize > 0 && n != null) {
-				TextDrawInfo info = new TextDrawInfo();
-				info.centerX = p.x + rc.textDx;
-				info.centerY = p.y + rc.textDy;
-				info.textColor = rc.textColor;
-				info.textSize = rc.textSize;
-				info.text = n;
-				info.textShadow = (int) rc.textHaloRadius;
-				info.textWrap = rc.textWrapWidth;
-				info.bold = rc.textBold;
+				TextDrawInfo info = new TextDrawInfo(n);
+				info.fillProperties(rc, p.x, p.y);
 				rc.textToDraw.add(info);
 			}
 		}
@@ -614,13 +626,14 @@ private void drawPolyline(MapRenderObject obj, Canvas canvas, RenderingContext r
 		float yPrev = 0;
 		float xMid = 0;
 		float yMid = 0;
+		PointF middlePoint = new PointF();
 		int middle = obj.getPointsLength() / 2;
 		
 		for (int i = 0; i < length ; i++) {
 			PointF p = calcPoint(obj, i, rc);
 			if(i == 0 || i == length -1){
-				xMid+= p.x;
-				yMid+= p.y;
+				xMid += p.x;
+				yMid += p.y;
 			}
 			if (path == null) {
 				path = new Path();
@@ -629,6 +642,7 @@ private void drawPolyline(MapRenderObject obj, Canvas canvas, RenderingContext r
 				xLength += p.x - xPrev; // not abs
 				yLength += p.y - yPrev; // not abs
 				if(i == middle){
+					middlePoint.set(p.x, p.y);
 					double rot = - Math.atan2(p.x - xPrev, p.y - yPrev) * 180 / Math.PI;
 					if (rot < 0) {
 						rot += 360;
@@ -667,18 +681,10 @@ private void drawPolyline(MapRenderObject obj, Canvas canvas, RenderingContext r
 				name = renderObjectText(name, subtype, type, rc.zoom, false, rc);
 				if (name != null && rc.textSize > 0) {
 					if (!rc.showTextOnPath) {
-						TextDrawInfo text = new TextDrawInfo();
-						text.text = name;
-						text.bold = rc.textBold;
-						text.centerX = xMid / 2;
-						text.centerY = yMid / 2;
-						text.shieldRes = rc.textShield;
-						text.textColor = rc.textColor;
-						text.textSize = rc.textSize;
-						text.vOffset = rc.textDy;
-						text.textShadow = (int) rc.textHaloRadius;
+						TextDrawInfo text = new TextDrawInfo(name);
+						text.fillProperties(rc, middlePoint.x, middlePoint.y);
 						rc.textToDraw.add(text);
-					} else /*if (paintText.measureText(obj.getName()) < Math.max(Math.abs(xLength), Math.abs(yLength)))*/ {
+					} else if (paintText.measureText(obj.getName()) < Math.max(Math.abs(xLength), Math.abs(yLength))) {
 						if (inverse) {
 							path.rewind();
 							boolean st = true;
@@ -693,17 +699,10 @@ private void drawPolyline(MapRenderObject obj, Canvas canvas, RenderingContext r
 							}
 						}
 
-						TextDrawInfo text = new TextDrawInfo();
-						text.text = name;
-						text.shieldRes = rc.textShield;
-						text.centerX = xMid / 2;
-						text.centerY = yMid / 2;
+						TextDrawInfo text = new TextDrawInfo(name);
+						text.fillProperties(rc, xMid / 2, yMid / 2);
 						text.pathRotate = pathRotate;
-						text.bold = rc.textBold;
 						text.drawOnPath = path;
-						text.textColor = rc.textColor;
-						text.textShadow = (int) rc.textHaloRadius;
-						text.textSize = rc.textSize;
 						text.vOffset = rc.main.strokeWidth / 2 - 1;
 						rc.textToDraw.add(text);
 
@@ -753,7 +752,7 @@ public static String renderObjectText(String name, int subType, int type, int zo
 					textSize = 10;
 					textColor = Color.WHITE;
 					bold = true;
-					textMinDistance = 50;
+					textMinDistance = 70;
 					// spacing = 750
 					if (subType == MapRenderingTypes.PL_HW_TRUNK) {
 						textShield = trunkShields[len - 1];
@@ -787,7 +786,7 @@ public static String renderObjectText(String name, int subType, int type, int zo
 							showTextOnPath = true;
 							textColor = Color.BLACK;
 							textSize = 10;
-							textMinDistance = 20;
+							textMinDistance = 40;
 							shadowRadius = 1;
 							// spacing = 750;
 						}
@@ -850,7 +849,7 @@ public static String renderObjectText(String name, int subType, int type, int zo
 					showTextOnPath = true;
 					shadowRadius = 1;
 					textColor = 0xff6699cc;
-					textMinDistance = 200;
+					textMinDistance = 70;
 				}
 			} else if (subType == 5 || subType == 6) {
 				if (zoom >= 15 /* && !tunnel */) {
@@ -887,7 +886,7 @@ public static String renderObjectText(String name, int subType, int type, int zo
 					showTextOnPath = true;
 					textSize = 10;
 					textColor = 0xff333333;
-					textMinDistance = 20;
+					textMinDistance = 50;
 					shadowRadius = 1;
 					// spacing = 750;
 				}
