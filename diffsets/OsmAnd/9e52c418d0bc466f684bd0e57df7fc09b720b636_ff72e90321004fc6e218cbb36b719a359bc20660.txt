diff --git a/OsmAnd/res/values/strings.xml b/OsmAnd/res/values/strings.xml
index 50c8662bf1b..8d3ebccabf2 100644
--- a/OsmAnd/res/values/strings.xml
+++ b/OsmAnd/res/values/strings.xml
@@ -11,6 +11,14 @@
 	Thx - Hardy
 -->
 
+    <string name="auto_25_chars_route_tl_kl">Turn left and keep left</string>
+    <string name="auto_25_chars_route_tl_kr">Turn left and keep right</string>
+    <string name="auto_25_chars_route_tr_kl">Turn right and keep left</string>
+    <string name="auto_25_chars_route_tr_kr">Turn right and keep right</string>
+    <string name="auto_25_chars_route_tu_kl">Make U-turn and keep left</string>
+    <string name="auto_25_chars_route_tu_kr">Make U-turn and keep right</string>
+    <string name="auto_25_chars_route_roundabout_kl">Take %1$d exit and keep left</string>
+    <string name="auto_25_chars_route_roundabout_kr">Take %1$d exit and keep right</string>
     <string name="auto_backup_preference_desc">By default Android saves backups of favourites, map tokens and osmand settings to restore them on new devices or after reinstallation, this backup is limited to 25 MB.\nIf you are using OsmAnd Cloud, this can lead to misunderstandings after reinstallation.</string>
     <string name="auto_backup_title">Auto-backup</string>
     <string name="duplacate_widget_added_snackbar">A duplicate widget is added next in the list.</string>
diff --git a/OsmAnd/src/net/osmand/plus/NavigationService.java b/OsmAnd/src/net/osmand/plus/NavigationService.java
index b4c2ccb01c4..c83f044bcc1 100644
--- a/OsmAnd/src/net/osmand/plus/NavigationService.java
+++ b/OsmAnd/src/net/osmand/plus/NavigationService.java
@@ -283,7 +283,7 @@ public void stopCarNavigation() {
 		}
 	}
 
-	public void updateCarNavigation() {
+	public void updateCarNavigation(Location currentLocation) {
 		OsmandApplication app = getApp();
 		RoutingHelper routingHelper = app.getRoutingHelper();
 		TripHelper tripHelper = this.tripHelper;
@@ -297,7 +297,7 @@ public void updateCarNavigation() {
 					if (density == 0) {
 						density = 1;
 					}
-					Trip trip = tripHelper.buildTrip(density);
+					Trip trip = tripHelper.buildTrip(currentLocation, density);
 					navigationManager.updateTrip(trip);
 
 					List<Destination> destinations = null;
diff --git a/OsmAnd/src/net/osmand/plus/auto/TripHelper.java b/OsmAnd/src/net/osmand/plus/auto/TripHelper.java
index ab808e2d7ce..899604f9965 100644
--- a/OsmAnd/src/net/osmand/plus/auto/TripHelper.java
+++ b/OsmAnd/src/net/osmand/plus/auto/TripHelper.java
@@ -1,19 +1,44 @@
 package net.osmand.plus.auto;
 
+import static net.osmand.plus.routing.data.AnnounceTimeDistances.STATE_TURN_IN;
+import static net.osmand.plus.routing.data.AnnounceTimeDistances.STATE_TURN_NOW;
+import static net.osmand.plus.utils.OsmAndFormatter.FEET_IN_ONE_METER;
+import static net.osmand.plus.utils.OsmAndFormatter.METERS_IN_KILOMETER;
+import static net.osmand.plus.utils.OsmAndFormatter.METERS_IN_ONE_MILE;
+import static net.osmand.plus.utils.OsmAndFormatter.METERS_IN_ONE_NAUTICALMILE;
+import static net.osmand.plus.utils.OsmAndFormatter.YARDS_IN_ONE_METER;
+
+import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
 import android.graphics.PorterDuff;
 import android.graphics.drawable.Drawable;
+import android.util.Log;
 import android.util.Pair;
 
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.car.app.model.CarIcon;
+import androidx.car.app.model.DateTimeWithZone;
+import androidx.car.app.model.Distance;
+import androidx.car.app.navigation.model.Destination;
+import androidx.car.app.navigation.model.Lane;
+import androidx.car.app.navigation.model.LaneDirection;
+import androidx.car.app.navigation.model.Maneuver;
+import androidx.car.app.navigation.model.Step;
+import androidx.car.app.navigation.model.TravelEstimate;
+import androidx.car.app.navigation.model.Trip;
+import androidx.core.graphics.drawable.IconCompat;
+
+import net.osmand.Location;
 import net.osmand.plus.OsmandApplication;
 import net.osmand.plus.R;
 import net.osmand.plus.helpers.TargetPointsHelper;
 import net.osmand.plus.helpers.TargetPointsHelper.TargetPoint;
 import net.osmand.plus.routing.CurrentStreetName;
-import net.osmand.plus.routing.RouteCalculationResult;
 import net.osmand.plus.routing.RouteCalculationResult.NextDirectionInfo;
 import net.osmand.plus.routing.RoutingHelper;
+import net.osmand.plus.routing.data.AnnounceTimeDistances;
 import net.osmand.plus.settings.backend.OsmandSettings;
 import net.osmand.plus.settings.enums.MetricsConstants;
 import net.osmand.plus.views.mapwidgets.LanesDrawable;
@@ -23,26 +48,6 @@
 
 import java.util.TimeZone;
 
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.car.app.model.CarIcon;
-import androidx.car.app.model.DateTimeWithZone;
-import androidx.car.app.model.Distance;
-import androidx.car.app.navigation.model.Destination;
-import androidx.car.app.navigation.model.Lane;
-import androidx.car.app.navigation.model.LaneDirection;
-import androidx.car.app.navigation.model.Maneuver;
-import androidx.car.app.navigation.model.Step;
-import androidx.car.app.navigation.model.TravelEstimate;
-import androidx.car.app.navigation.model.Trip;
-import androidx.core.graphics.drawable.IconCompat;
-
-import static net.osmand.plus.utils.OsmAndFormatter.FEET_IN_ONE_METER;
-import static net.osmand.plus.utils.OsmAndFormatter.METERS_IN_KILOMETER;
-import static net.osmand.plus.utils.OsmAndFormatter.METERS_IN_ONE_MILE;
-import static net.osmand.plus.utils.OsmAndFormatter.METERS_IN_ONE_NAUTICALMILE;
-import static net.osmand.plus.utils.OsmAndFormatter.YARDS_IN_ONE_METER;
-
 public class TripHelper {
 
 	public static final float TURN_IMAGE_SIZE_DP = 128f;
@@ -83,7 +88,7 @@ public CharSequence getLastCurrentRoad() {
 	}
 
 	@NonNull
-	public Trip buildTrip(float density) {
+	public Trip buildTrip(Location currentLocation, float density) {
 		RoutingHelper routingHelper = app.getRoutingHelper();
 		OsmandSettings settings = app.getSettings();
 
@@ -105,12 +110,13 @@ public Trip buildTrip(float density) {
 			Step.Builder stepBuilder = new Step.Builder();
 			Maneuver.Builder turnBuilder;
 			TurnType turnType = null;
+			TurnType nextTurnType = null;
 			boolean leftSide = settings.DRIVING_REGION.get().leftHandDriving;
 			boolean deviatedFromRoute = routingHelper.isDeviatedFromRoute();
 			int turnImminent = 0;
 			int nextTurnDistance = 0;
-			RouteCalculationResult.NextDirectionInfo nextDirInfo;
-			RouteCalculationResult.NextDirectionInfo calc = new RouteCalculationResult.NextDirectionInfo();
+			NextDirectionInfo nextDirInfo = null;
+			NextDirectionInfo calc = new NextDirectionInfo();
 			if (deviatedFromRoute) {
 				turnType = TurnType.valueOf(TurnType.OFFR, leftSide);
 				nextTurnDistance = (int) routingHelper.getRouteDeviation();
@@ -121,6 +127,7 @@ public Trip buildTrip(float density) {
 					nextTurnDistance = nextDirInfo.distanceTo;
 					turnImminent = nextDirInfo.imminent;
 				}
+
 			}
 			if (turnType != null) {
 				TurnDrawable drawable = new TurnDrawable(app, false);
@@ -139,7 +146,20 @@ public Trip buildTrip(float density) {
 				turnBuilder = new Maneuver.Builder(Maneuver.TYPE_UNKNOWN);
 			}
 			Maneuver maneuver = turnBuilder.build();
-			String cue = turnType != null ? RouteCalculationResult.toString(turnType, app, true) : "";
+			AnnounceTimeDistances atd = app.getRoutingHelper().getVoiceRouter().getAnnounceTimeDistances();
+			if (nextDirInfo != null && atd != null) {
+				float speed = atd.getSpeed(currentLocation);
+				int dist = nextDirInfo.distanceTo;
+				if (atd.isTurnStateActive(speed, dist, STATE_TURN_IN)) {
+					NextDirectionInfo nextNextDirInfo = routingHelper.getNextRouteDirectionInfoAfter(nextDirInfo, new NextDirectionInfo(), true);
+					if (nextNextDirInfo != null && nextNextDirInfo.directionInfo != null &&
+							(atd.isTurnStateActive(speed, nextNextDirInfo.distanceTo, STATE_TURN_NOW)
+							|| !atd.isTurnStateNotPassed(speed, nextNextDirInfo.distanceTo, STATE_TURN_IN))) {
+						nextTurnType = nextNextDirInfo.directionInfo.getTurnType();
+					}
+				}
+			}
+			String cue = turnType != null ? nextTurnsToString(app, turnType, nextTurnType) : "";
 			stepBuilder.setManeuver(maneuver);
 			stepBuilder.setCue(cue);
 
@@ -210,6 +230,67 @@ public Trip buildTrip(float density) {
 		return tripBuilder.build();
 	}
 
+	private boolean shouldKeepLeft(@Nullable TurnType t) {
+		return t != null && (t.getValue() == TurnType.TL || t.getValue() == TurnType.TSHL
+				|| t.getValue() == TurnType.TSLL || t.getValue() == TurnType.TU || t.getValue() == TurnType.KL);
+	}
+
+	private boolean shouldKeepRight(@Nullable TurnType t) {
+		return t != null && (t.getValue() == TurnType.TR || t.getValue() == TurnType.TSHR
+				|| t.getValue() == TurnType.TSLR || t.getValue() == TurnType.TRU || t.getValue() == TurnType.KR);
+	}
+
+	private String nextTurnsToString(@NonNull Context ctx, @NonNull TurnType type, @Nullable TurnType nextTurnType) {
+		if (type.isRoundAbout()) {
+			if (shouldKeepLeft(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_roundabout_kl, type.getExitOut());
+			} else if (shouldKeepRight(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_roundabout_kr, type.getExitOut());
+			} else {
+				return ctx.getString(R.string.route_roundabout_short, type.getExitOut());
+			}
+		} else if (type.getValue() == TurnType.TU || type.getValue() == TurnType.TRU) {
+			if (shouldKeepLeft(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_tu_kl);
+			} else if (shouldKeepRight(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_tu_kr);
+			} else {
+				return ctx.getString(R.string.route_tu);
+			}
+		} else if (type.getValue() == TurnType.C) {
+			return ctx.getString(R.string.route_head);
+		} else if (type.getValue() == TurnType.TSLL) {
+			return ctx.getString(R.string.route_tsll);
+		} else if (type.getValue() == TurnType.TL) {
+			if (shouldKeepLeft(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_tl_kl);
+			} else if (shouldKeepRight(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_tl_kr);
+			} else {
+				return ctx.getString(R.string.route_tl);
+			}
+		} else if (type.getValue() == TurnType.TSHL) {
+			return ctx.getString(R.string.route_tshl);
+		} else if (type.getValue() == TurnType.TSLR) {
+			return ctx.getString(R.string.route_tslr);
+		} else if (type.getValue() == TurnType.TR) {
+			if (shouldKeepLeft(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_tr_kl);
+			} else if (shouldKeepRight(nextTurnType)) {
+				return ctx.getString(R.string.auto_25_chars_route_tr_kr);
+			} else {
+				return ctx.getString(R.string.route_tr);
+			}
+		} else if (type.getValue() == TurnType.TSHR) {
+			return ctx.getString(R.string.route_tshr);
+		} else if (type.getValue() == TurnType.KL) {
+			return ctx.getString(R.string.route_kl);
+		} else if (type.getValue() == TurnType.KR) {
+			return ctx.getString(R.string.route_kr);
+		}
+		return "";
+	}
+
 	@NonNull
 	public Pair<Destination, TravelEstimate> getDestination(@NonNull TargetPoint pointToNavigate) {
 		RoutingHelper routingHelper = app.getRoutingHelper();
diff --git a/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java b/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
index adb0abb7580..8c185b5e4c5 100644
--- a/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
+++ b/OsmAnd/src/net/osmand/plus/routing/RoutingHelper.java
@@ -666,7 +666,7 @@ public void run() {
 		NavigationService navigationService = app.getNavigationService();
 		if (carNavigationSession != null && navigationService != null && System.currentTimeMillis() - lastCarNavUpdateTime > 1000) {
 			lastCarNavUpdateTime = System.currentTimeMillis();
-			app.runInUIThread(navigationService::updateCarNavigation);
+			app.runInUIThread(() -> navigationService.updateCarNavigation(currentLocation));
 		}
 		return false;
 	}
