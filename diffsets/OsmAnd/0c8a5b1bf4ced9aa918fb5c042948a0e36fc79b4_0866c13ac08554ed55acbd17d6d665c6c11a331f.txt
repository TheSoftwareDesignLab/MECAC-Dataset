diff --git a/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleProperty.java b/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleProperty.java
index 322a734980b..6b10c0d11f4 100644
--- a/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleProperty.java
+++ b/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleProperty.java
@@ -10,13 +10,13 @@
 
 public class RenderingRuleProperty {
 	private final static Log log = PlatformUtil.getLog(RenderingRuleProperty.class);
-	
-	private final static int INT_TYPE = 1;
-	private final static int FLOAT_TYPE = 2;
-	private final static int STRING_TYPE = 3;
-	private final static int COLOR_TYPE = 4;
-	private final static int BOOLEAN_TYPE = 5;
-	
+
+	public final static int INT_TYPE = 1;
+	public final static int FLOAT_TYPE = 2;
+	public final static int STRING_TYPE = 3;
+	public final static int COLOR_TYPE = 4;
+	public final static int BOOLEAN_TYPE = 5;
+
 	public static final int TRUE_VALUE = 1;
 	public static final int FALSE_VALUE = 0;
 	
diff --git a/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleSearchRequest.java b/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleSearchRequest.java
index 783a4c1ba5c..4effc0dec02 100644
--- a/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleSearchRequest.java
+++ b/OsmAnd-java/src/main/java/net/osmand/render/RenderingRuleSearchRequest.java
@@ -1,24 +1,30 @@
 package net.osmand.render;
 
+import static net.osmand.render.RenderingRuleProperty.BOOLEAN_TYPE;
+import static net.osmand.render.RenderingRuleProperty.COLOR_TYPE;
+import static net.osmand.render.RenderingRuleProperty.FLOAT_TYPE;
+import static net.osmand.render.RenderingRuleProperty.INT_TYPE;
+import static net.osmand.render.RenderingRuleProperty.STRING_TYPE;
+
 import net.osmand.binary.BinaryMapDataObject;
 import net.osmand.util.Algorithms;
 
 
 public class RenderingRuleSearchRequest {
 
+	public final RenderingRuleStorageProperties ALL;
+
+	private BinaryMapDataObject object;
+	private final RenderingRuleProperty[] props;
 	private final RenderingRulesStorage storage;
-	RenderingRuleProperty[] props;
-	int[] values;
-	BinaryMapDataObject object;
-	float[] fvalues;
 
-	int[] savedValues;
-	float[] savedFvalues;
-	
-	boolean searchResult = false;
-	
-	
-	public final RenderingRuleStorageProperties ALL;
+	private final int[] values;
+	private final float[] fvalues;
+
+	private int[] savedValues;
+	private float[] savedFvalues;
+
+	private boolean searchResult = false;
 
 	public RenderingRuleSearchRequest(RenderingRulesStorage storage) {
 		this.storage = storage;
@@ -35,19 +41,27 @@ public RenderingRuleSearchRequest(RenderingRulesStorage storage) {
 		saveState();
 	}
 
-	public RenderingRuleSearchRequest(RenderingRuleSearchRequest renderingRuleSearchRequest) {
-		this.storage = renderingRuleSearchRequest.storage;
-		this.props = renderingRuleSearchRequest.props;
-		this.values = new int[renderingRuleSearchRequest.values.length];
-		this.fvalues = new float[renderingRuleSearchRequest.fvalues.length];
-		this.object = renderingRuleSearchRequest.object;
-		this.searchResult = renderingRuleSearchRequest.searchResult;
-		this.ALL = renderingRuleSearchRequest.ALL;
-		System.arraycopy(renderingRuleSearchRequest.values, 0, values, 0, renderingRuleSearchRequest.values.length);
-		System.arraycopy(renderingRuleSearchRequest.fvalues, 0, fvalues, 0, renderingRuleSearchRequest.fvalues.length);
+	public RenderingRuleSearchRequest(RenderingRuleSearchRequest searchRequest) {
+		this.storage = searchRequest.storage;
+		this.props = searchRequest.props;
+		this.values = new int[searchRequest.values.length];
+		this.fvalues = new float[searchRequest.fvalues.length];
+		this.object = searchRequest.object;
+		this.searchResult = searchRequest.searchResult;
+		this.ALL = searchRequest.ALL;
+		System.arraycopy(searchRequest.values, 0, values, 0, searchRequest.values.length);
+		System.arraycopy(searchRequest.fvalues, 0, fvalues, 0, searchRequest.fvalues.length);
 		saveState();
 	}
 
+	RenderingRulesStorage getStorage() {
+		return storage;
+	}
+
+	public BinaryMapDataObject getObject() {
+		return object;
+	}
+
 	public void setStringFilter(RenderingRuleProperty p, String filter) {
 		assert p.isInputProperty();
 		values[p.getId()] = storage.getDictionaryValue(filter);
@@ -82,19 +96,13 @@ public void clearState() {
 	}
 	
 	public void clearValue(RenderingRuleProperty p) {
-		if(p.isIntParse()){
-			values[p.getId()] = savedValues[p.getId()];
-		} else {
+		if (!p.isIntParse()) {
 			fvalues[p.getId()] = savedFvalues[p.getId()];
-			values[p.getId()] = savedValues[p.getId()];
 		}
+		values[p.getId()] = savedValues[p.getId()];
 	}
-	
-	public BinaryMapDataObject getObject() {
-		return object;
-	}
-	
-	public void setInitialTagValueZoom(String tag, String val, int zoom, BinaryMapDataObject obj){
+
+	public void setInitialTagValueZoom(String tag, String val, int zoom, BinaryMapDataObject obj) {
 		clearState();
 		object = obj;
 		setIntFilter(ALL.R_MINZOOM, zoom);
@@ -102,8 +110,8 @@ public void setInitialTagValueZoom(String tag, String val, int zoom, BinaryMapDa
 		setStringFilter(ALL.R_TAG, tag);
 		setStringFilter(ALL.R_VALUE, val);
 	}
-	
-	public void setTagValueZoomLayer(String tag, String val, int zoom, int layer, BinaryMapDataObject obj){
+
+	public void setTagValueZoomLayer(String tag, String val, int zoom, int layer, BinaryMapDataObject obj) {
 		object = obj;
 		setIntFilter(ALL.R_MINZOOM, zoom);
 		setIntFilter(ALL.R_MAXZOOM, zoom);
@@ -119,14 +127,13 @@ public boolean isFound() {
 	public boolean searchRenderingAttribute(String attribute) {
 		searchResult = false;
 		RenderingRule rule = storage.getRenderingAttributeRule(attribute);
-		if(rule == null){
+		if (rule == null) {
 			return false;
 		}
 		searchResult = visitRule(rule, true);
 		return searchResult;
 	}
-	
-	
+
 	public boolean search(int state) {
 		return search(state, true);
 	}
@@ -150,11 +157,9 @@ public boolean search(int state, boolean loadOutput) {
 			searchResult = true;
 			return true;
 		}
-		
 		return false;
 	}
 
-
 	private boolean searchInternal(int state, int tagKey, int valueKey, boolean loadOutput) {
 		values[storage.PROPS.R_TAG.getId()] = tagKey;
 		values[storage.PROPS.R_VALUE.getId()] = valueKey;
@@ -164,7 +169,7 @@ private boolean searchInternal(int state, int tagKey, int valueKey, boolean load
 			return false;
 		}
 		boolean match = visitRule(accept, loadOutput);
-		if(match && values[storage.PROPS.R_DISABLE.getId()] != 0) {
+		if (match && values[storage.PROPS.R_DISABLE.getId()] != 0) {
 			return false;
 		}
 		return match;
@@ -172,17 +177,17 @@ private boolean searchInternal(int state, int tagKey, int valueKey, boolean load
 
 	private boolean visitRule(RenderingRule rule, boolean loadOutput) {
 		boolean input = checkInputProperties(rule);
-		if(!input) {
+		if (!input) {
 			return false;
 		}
 		if (!loadOutput && !rule.isGroup()) {
 			return true;
 		}
 		// accept it
-		if(!rule.isGroup()) {
+		if (!rule.isGroup()) {
 			loadOutputProperties(rule, true);
 		}
-		boolean match  = false;
+		boolean match = false;
 		for (RenderingRule rr : rule.getIfElseChildren()) {
 			match = visitRule(rr, loadOutput);
 			if (match) {
@@ -200,7 +205,6 @@ private boolean visitRule(RenderingRule rule, boolean loadOutput) {
 			}
 		}
 		return fit;
-		
 	}
 
 	protected void loadOutputProperties(RenderingRule rule, boolean override) {
@@ -210,14 +214,14 @@ protected void loadOutputProperties(RenderingRule rule, boolean override) {
 			if (rp.isOutputProperty()) {
 				if (!isSpecified(rp) || override) {
 					RenderingRule rr = rule.getAttrProp(i);
-					if(rr != null) {
+					if (rr != null) {
 						visitRule(rr, true);
-						if(isSpecified(storage.PROPS.R_ATTR_COLOR_VALUE)){
+						if (isSpecified(storage.PROPS.R_ATTR_COLOR_VALUE)) {
 							values[rp.getId()] = getIntPropertyValue(storage.PROPS.R_ATTR_COLOR_VALUE);
-						} else if(isSpecified(storage.PROPS.R_ATTR_INT_VALUE)){
+						} else if (isSpecified(storage.PROPS.R_ATTR_INT_VALUE)) {
 							values[rp.getId()] = getIntPropertyValue(storage.PROPS.R_ATTR_INT_VALUE);
 							fvalues[rp.getId()] = getFloatPropertyValue(storage.PROPS.R_ATTR_INT_VALUE);
-						} else if(isSpecified(storage.PROPS.R_ATTR_BOOL_VALUE)){
+						} else if (isSpecified(storage.PROPS.R_ATTR_BOOL_VALUE)) {
 							values[rp.getId()] = getIntPropertyValue(storage.PROPS.R_ATTR_BOOL_VALUE);
 						}
 					} else if (rp.isFloat()) {
@@ -245,20 +249,20 @@ protected boolean checkInputProperties(RenderingRule rule) {
 				if (!match) {
 					return false;
 				}
-			} else if(rp == storage.PROPS.R_DISABLE){
+			} else if (rp == storage.PROPS.R_DISABLE) {
 				// quick disable return even without load output
 				values[rp.getId()] = rule.getIntProp(i);
 			}
 		}
 		return true;
 	}
-	
-	public boolean isSpecified(RenderingRuleProperty property){
-		if(property.isFloat()){
+
+	public boolean isSpecified(RenderingRuleProperty property) {
+		if (property.isFloat()) {
 			return fvalues[property.getId()] != 0 || values[property.getId()] != -1;
 		} else {
 			int val = values[property.getId()];
-			if(property.isColor()){
+			if (property.isColor()) {
 				return val != 0;
 			} else {
 				return val != -1;
@@ -272,7 +276,7 @@ public RenderingRuleProperty[] getProperties() {
 	
 	public String getStringPropertyValue(RenderingRuleProperty property) {
 		int val = values[property.getId()];
-		if(val < 0){
+		if (val < 0) {
 			return null;
 		}
 		return storage.getStringValue(val);
@@ -284,7 +288,7 @@ public float getFloatPropertyValue(RenderingRuleProperty property) {
 	
 	public float getFloatPropertyValue(RenderingRuleProperty property, float defVal) {
 		float f = fvalues[property.getId()];
-		if(f == 0) {
+		if (f == 0) {
 			return defVal;
 		}
 		return f;
@@ -307,8 +311,31 @@ public int getIntPropertyValue(RenderingRuleProperty property, int defValue) {
 		int val = values[property.getId()];
 		return val == -1 ? defValue : val;
 	}
-	
-	RenderingRulesStorage getStorage() {
-		return storage;
+
+	@Override
+	public String toString() {
+		StringBuilder builder = new StringBuilder();
+		builder.append("object ").append(object).append("\n");
+
+		for (int i = 0; i < props.length; i++) {
+			RenderingRuleProperty property = props[i];
+			if (isSpecified(property)) {
+				builder.append(i).append(" ").append(property.getAttrName()).append(" ");
+
+				if (property.type == INT_TYPE) {
+					builder.append(getIntPropertyValue(property));
+				} else if (property.type == FLOAT_TYPE) {
+					builder.append(getFloatPropertyValue(property));
+				} else if (property.type == STRING_TYPE) {
+					builder.append(getStringPropertyValue(property));
+				} else if (property.type == COLOR_TYPE) {
+					builder.append(getColorStringPropertyValue(property));
+				} else if (property.type == BOOLEAN_TYPE) {
+					builder.append(getBoolPropertyValue(property));
+				}
+				builder.append("\n");
+			}
+		}
+		return builder.toString();
 	}
 }
\ No newline at end of file
diff --git a/OsmAnd/res/layout/menu_obj_list_item.xml b/OsmAnd/res/layout/menu_obj_list_item.xml
index 0379fa55bdd..fb4a27f941f 100644
--- a/OsmAnd/res/layout/menu_obj_list_item.xml
+++ b/OsmAnd/res/layout/menu_obj_list_item.xml
@@ -54,9 +54,12 @@
 
             <androidx.appcompat.widget.AppCompatImageView
                 android:id="@+id/context_menu_icon_view"
-                android:layout_width="@dimen/standard_icon_size"
-                android:layout_height="@dimen/standard_icon_size"
-                osmand:srcCompat="@drawable/ic_action_building_number"/>
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:minWidth="@dimen/standard_icon_size"
+                android:minHeight="@dimen/standard_icon_size"
+                osmand:srcCompat="@drawable/ic_action_building_number"
+                tools:tint="?attr/default_icon_color" />
 
         </LinearLayout>
 
diff --git a/OsmAnd/res/layout/track_menu.xml b/OsmAnd/res/layout/track_menu.xml
index 2158d25f2c9..ce6fb035a6d 100644
--- a/OsmAnd/res/layout/track_menu.xml
+++ b/OsmAnd/res/layout/track_menu.xml
@@ -79,9 +79,11 @@
 
 					<androidx.appcompat.widget.AppCompatImageView
 						android:id="@+id/icon_view"
-						android:layout_width="@dimen/map_widget_icon"
-						android:layout_height="@dimen/map_widget_icon"
+						android:layout_width="wrap_content"
+						android:layout_height="wrap_content"
 						android:layout_gravity="end|center_vertical"
+						android:minWidth="@dimen/standard_icon_size"
+						android:minHeight="@dimen/standard_icon_size"
 						osmand:srcCompat="@drawable/ic_action_polygom_dark"
 						tools:tint="?attr/default_icon_color" />
 
diff --git a/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteDrawable.java b/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteDrawable.java
new file mode 100644
index 00000000000..e7421595864
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteDrawable.java
@@ -0,0 +1,208 @@
+package net.osmand.plus.mapcontextmenu.controllers;
+
+import static net.osmand.plus.render.TextRenderer.DROID_SERIF;
+
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Paint.Align;
+import android.graphics.Paint.Style;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.Typeface;
+import android.graphics.drawable.Drawable;
+
+import androidx.annotation.NonNull;
+
+import net.osmand.plus.OsmandApplication;
+import net.osmand.plus.R;
+import net.osmand.plus.render.MapRenderRepositories;
+import net.osmand.plus.utils.AndroidUtils;
+import net.osmand.plus.utils.UiUtilities;
+import net.osmand.plus.views.mapwidgets.widgets.StreetNameWidget;
+import net.osmand.render.RenderingRuleSearchRequest;
+import net.osmand.render.RenderingRulesStorage;
+import net.osmand.router.network.NetworkRouteContext.NetworkRouteSegment;
+import net.osmand.util.Algorithms;
+
+import org.jetbrains.annotations.Nullable;
+
+public class NetworkRouteDrawable extends Drawable {
+
+	private final OsmandApplication app;
+	private final NetworkRouteSegment segment;
+
+	private final Paint paint = new Paint();
+
+	@Nullable
+	private final String osmcText;
+	@Nullable
+	private final Drawable backgroundDrawable;
+
+	private final int defaultIconSize;
+
+	public NetworkRouteDrawable(@NonNull OsmandApplication app, @NonNull NetworkRouteSegment segment, boolean nightMode) {
+		this.app = app;
+		this.segment = segment;
+		backgroundDrawable = createBackgroundIcon();
+		osmcText = segment.routeKey.getValue("osmc_text");
+		defaultIconSize = app.getResources().getDimensionPixelSize(R.dimen.standard_icon_size);
+		setupTextPaint(nightMode);
+	}
+
+	private Drawable createBackgroundIcon() {
+		Drawable foregroundIcon = getIcon("osmc_foreground", "mm_osmc_", "");
+		Drawable backgroundIcon = getIcon("osmc_background", "h_osmc_", "_bg");
+
+		if (foregroundIcon != null && backgroundIcon != null) {
+			return UiUtilities.getLayeredIcon(backgroundIcon, foregroundIcon);
+		} else {
+			return foregroundIcon != null ? foregroundIcon : backgroundIcon;
+		}
+	}
+
+	private void setupTextPaint(boolean nightMode) {
+		paint.setStrokeWidth(1);
+		paint.setAntiAlias(true);
+		paint.setStyle(Style.FILL);
+		paint.setColor(Color.BLACK);
+		paint.setTextAlign(Align.CENTER);
+		paint.setTextSize(AndroidUtils.spToPx(app, 13));
+		paint.setTypeface(Typeface.create(DROID_SERIF, Typeface.NORMAL));
+		updatePaint(nightMode);
+	}
+
+	private void updatePaint(boolean nightMode) {
+		if (!Algorithms.isEmpty(osmcText)) {
+			MapRenderRepositories renderer = app.getResourceManager().getRenderer();
+			RenderingRulesStorage storage = app.getRendererRegistry().getCurrentSelectedRenderer();
+			RenderingRuleSearchRequest request = renderer.getSearchRequestWithAppliedCustomRules(storage, nightMode);
+			request.saveState();
+
+			String tag = "route_" + segment.routeKey.type.getTag();
+			String color = segment.routeKey.getValue("osmc_textcolor");
+
+			request.setInitialTagValueZoom(tag, null, 14, null);
+			request.setIntFilter(request.ALL.R_TEXT_LENGTH, osmcText.length());
+			request.setStringFilter(request.ALL.R_NAME_TAG, tag + "_1_osmc_text");
+			request.setStringFilter(request.ALL.R_ADDITIONAL, tag + "_1_osmc_textcolor=" + color);
+			request.search(RenderingRulesStorage.TEXT_RULES);
+
+			StreetNameWidget.setupTextPaint(app, paint, request);
+		}
+	}
+
+	private Drawable getIcon(@NonNull String key, @NonNull String prefix, @NonNull String suffix) {
+		String name = segment.routeKey.getValue(key);
+		String iconName = prefix + name + suffix;
+		int iconRes = AndroidUtils.getDrawableId(app, iconName);
+		if (iconRes != 0) {
+			return app.getUIUtilities().getIcon(iconRes);
+		}
+		return null;
+	}
+
+	@Override
+	public void draw(@NonNull Canvas canvas) {
+		if (backgroundDrawable != null) {
+			backgroundDrawable.draw(canvas);
+		}
+
+		if (!Algorithms.isEmpty(osmcText)) {
+			Rect rect = getBounds();
+			float x = rect.width() / 2f;
+			float y = rect.height() / 2f - ((paint.descent() + paint.ascent()) / 2);
+			canvas.drawText(osmcText, x, y, paint);
+		}
+	}
+
+	@Override
+	public int getMinimumHeight() {
+		int height = getMaxTextHeight();
+		if (backgroundDrawable != null) {
+			height = Math.max(height, backgroundDrawable.getMinimumHeight());
+		}
+		return height;
+	}
+
+	@Override
+	public int getMinimumWidth() {
+		int width = getMaxTextWidth();
+		if (backgroundDrawable != null) {
+			width = Math.max(width, backgroundDrawable.getMinimumWidth());
+		}
+		return width;
+	}
+
+	@Override
+	public int getIntrinsicHeight() {
+		int height = getMaxTextHeight();
+		if (backgroundDrawable != null) {
+			height = Math.max(height, backgroundDrawable.getIntrinsicHeight());
+		}
+		return height;
+	}
+
+	@Override
+	public int getIntrinsicWidth() {
+		int width = getMaxTextWidth();
+		if (backgroundDrawable != null) {
+			width = Math.max(width, backgroundDrawable.getIntrinsicWidth());
+		}
+		return width;
+	}
+
+	private int getMaxTextHeight() {
+		int height = defaultIconSize;
+		if (!Algorithms.isEmpty(osmcText)) {
+			height = Math.max(height, AndroidUtils.getTextHeight(paint));
+		}
+		return height;
+	}
+
+	private int getMaxTextWidth() {
+		int width = defaultIconSize;
+		if (!Algorithms.isEmpty(osmcText)) {
+			width = Math.max(width, AndroidUtils.getTextWidth(paint.getTextSize(), osmcText));
+		}
+		return width;
+	}
+
+	@Override
+	public void setChangingConfigurations(int configs) {
+		super.setChangingConfigurations(configs);
+		if (backgroundDrawable != null) {
+			backgroundDrawable.setChangingConfigurations(configs);
+		}
+	}
+
+	@Override
+	public void setBounds(int left, int top, int right, int bottom) {
+		super.setBounds(left, top, right, bottom);
+		if (backgroundDrawable != null) {
+			backgroundDrawable.setBounds(left, top, right, bottom);
+		}
+	}
+
+	@Override
+	public void setAlpha(int alpha) {
+		paint.setAlpha(alpha);
+		if (backgroundDrawable != null) {
+			backgroundDrawable.setAlpha(alpha);
+		}
+	}
+
+	@Override
+	public void setColorFilter(@Nullable ColorFilter filter) {
+		paint.setColorFilter(filter);
+		if (backgroundDrawable != null) {
+			backgroundDrawable.setColorFilter(filter);
+		}
+	}
+
+	@Override
+	public int getOpacity() {
+		return backgroundDrawable != null ? backgroundDrawable.getOpacity() : PixelFormat.UNKNOWN;
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteMenuController.java b/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteMenuController.java
index cf2c7d172dd..ed4f2c620d7 100644
--- a/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteMenuController.java
+++ b/OsmAnd/src/net/osmand/plus/mapcontextmenu/controllers/NetworkRouteMenuController.java
@@ -1,6 +1,6 @@
 package net.osmand.plus.mapcontextmenu.controllers;
 
-import static net.osmand.router.network.NetworkRouteContext.*;
+import static net.osmand.router.network.NetworkRouteContext.NetworkRouteSegment;
 
 import android.graphics.drawable.Drawable;
 import android.util.Pair;
@@ -14,8 +14,6 @@
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.mapcontextmenu.MenuBuilder;
 import net.osmand.plus.mapcontextmenu.MenuController;
-import net.osmand.plus.utils.UiUtilities;
-import net.osmand.router.network.NetworkRouteSelector.RouteKey;
 
 public class NetworkRouteMenuController extends MenuController {
 
@@ -49,7 +47,7 @@ protected void setObject(Object object) {
 
 	@Override
 	public Drawable getRightIcon() {
-		return getIconForRouteObject(app, pair.first);
+		return new NetworkRouteDrawable(app, pair.first, !isLight());
 	}
 
 	@NonNull
@@ -62,40 +60,4 @@ public String getCommonTypeStr() {
 			return "";
 		}
 	}
-
-	public static Drawable getIconForRouteObject(@NonNull OsmandApplication app, @NonNull NetworkRouteSegment routeSegment) {
-
-		RouteKey routeKey = routeSegment.routeKey;
-
-		Pair<String, Integer> foreground = getForegroundIconIdWithName(app, routeKey);
-		Pair<String, Integer> background = getBackgroundIconIdWithName(app, routeKey);
-
-		UiUtilities uiUtilities = app.getUIUtilities();
-		Drawable foregroundIcon = foreground != null ? uiUtilities.getIcon(foreground.second) : null;
-		Drawable backgroundIcon = background != null ? uiUtilities.getIcon(background.second) : null;
-
-		if (foregroundIcon != null && backgroundIcon != null) {
-			return UiUtilities.getLayeredIcon(backgroundIcon, foregroundIcon);
-		}
-		return foregroundIcon != null ? foregroundIcon : backgroundIcon;
-	}
-
-	public static Pair<String, Integer> getForegroundIconIdWithName(@NonNull OsmandApplication app, @NonNull RouteKey routeKey) {
-		return getIconIdWithName(app, routeKey, "osmc_foreground", "mm_osmc_", "");
-	}
-
-	public static Pair<String, Integer> getBackgroundIconIdWithName(@NonNull OsmandApplication app, @NonNull RouteKey routeKey) {
-		return getIconIdWithName(app, routeKey, "osmc_background", "h_osmc_", "_bg");
-	}
-
-	private static Pair<String, Integer> getIconIdWithName(@NonNull OsmandApplication app, @NonNull RouteKey routeKey,
-	                                                       @NonNull String key, @NonNull String prefix, @NonNull String suffix) {
-		String name = routeKey.getValue(key);
-		String iconName = prefix + name + suffix;
-		int iconRes = app.getResources().getIdentifier(iconName, "drawable", app.getPackageName());
-		if (iconRes != 0) {
-			return new Pair<>(name, iconRes);
-		}
-		return null;
-	}
 }
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
index e960ea44bac..8cf6575092b 100644
--- a/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/OsmandRenderer.java
@@ -1,33 +1,5 @@
 package net.osmand.plus.render;
 
-import gnu.trove.list.array.TIntArrayList;
-import gnu.trove.map.hash.TIntObjectHashMap;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
-import net.osmand.NativeLibrary;
-import net.osmand.NativeLibrary.NativeSearchResult;
-import net.osmand.RenderingContext.ShadowRenderingMode;
-import net.osmand.PlatformUtil;
-import net.osmand.binary.BinaryMapDataObject;
-import net.osmand.binary.BinaryMapIndexReader.TagValuePair;
-import net.osmand.data.QuadRect;
-import net.osmand.data.QuadTree;
-import net.osmand.map.MapTileDownloader;
-import net.osmand.plus.render.TextRenderer.TextDrawInfo;
-import net.osmand.render.RenderingRuleProperty;
-import net.osmand.render.RenderingRuleSearchRequest;
-import net.osmand.render.RenderingRulesStorage;
-import net.osmand.util.Algorithms;
-import net.osmand.util.MapUtils;
-
-import org.apache.commons.logging.Log;
-
 import android.content.Context;
 import android.graphics.Bitmap;
 import android.graphics.BitmapShader;
@@ -53,6 +25,33 @@
 import android.util.DisplayMetrics;
 import android.view.WindowManager;
 
+import net.osmand.NativeLibrary;
+import net.osmand.NativeLibrary.NativeSearchResult;
+import net.osmand.PlatformUtil;
+import net.osmand.RenderingContext.ShadowRenderingMode;
+import net.osmand.binary.BinaryMapDataObject;
+import net.osmand.binary.BinaryMapIndexReader.TagValuePair;
+import net.osmand.data.QuadRect;
+import net.osmand.data.QuadTree;
+import net.osmand.map.MapTileDownloader;
+import net.osmand.render.RenderingRuleProperty;
+import net.osmand.render.RenderingRuleSearchRequest;
+import net.osmand.render.RenderingRulesStorage;
+import net.osmand.util.Algorithms;
+import net.osmand.util.MapUtils;
+
+import org.apache.commons.logging.Log;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import gnu.trove.list.array.TIntArrayList;
+import gnu.trove.map.hash.TIntObjectHashMap;
+
 public class OsmandRenderer {
 	private static final Log log = PlatformUtil.getLog(OsmandRenderer.class);
 
diff --git a/OsmAnd/src/net/osmand/plus/render/TextDrawInfo.java b/OsmAnd/src/net/osmand/plus/render/TextDrawInfo.java
new file mode 100644
index 00000000000..1902bd9a532
--- /dev/null
+++ b/OsmAnd/src/net/osmand/plus/render/TextDrawInfo.java
@@ -0,0 +1,88 @@
+package net.osmand.plus.render;
+
+import android.graphics.Color;
+import android.graphics.Path;
+
+import androidx.annotation.NonNull;
+
+import net.osmand.data.QuadRect;
+import net.osmand.plus.render.OsmandRenderer.RenderingContext;
+import net.osmand.render.RenderingRuleSearchRequest;
+
+public class TextDrawInfo {
+
+	String text;
+	Path drawOnPath = null;
+	QuadRect bounds = null;
+	float vOffset = 0;
+	float centerX = 0;
+	float pathRotate = 0;
+	float centerY = 0;
+	float textSize = 0;
+	float minDistance = 0;
+	int textColor = Color.BLACK;
+	int textShadow = 0;
+	int textWrap = 0;
+	boolean bold = false;
+	boolean italic = false;
+	String shieldRes = null;
+	String shieldResIcon = null;
+	int textOrder = 100;
+	int textShadowColor = Color.WHITE;
+
+	public TextDrawInfo(@NonNull String text) {
+		this.text = text;
+	}
+
+	public void fillProperties(RenderingContext rc, RenderingRuleSearchRequest render, float centerX, float centerY) {
+		this.centerX = centerX;
+		// used only for draw on path where centerY doesn't play role
+		this.vOffset = (int) rc.getComplexValue(render, render.ALL.R_TEXT_DY);
+		this.centerY = centerY + this.vOffset;
+		textColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);
+		if (textColor == 0) {
+			textColor = Color.BLACK;
+		}
+		textSize = rc.getComplexValue(render, render.ALL.R_TEXT_SIZE);
+		textShadow = (int) rc.getComplexValue(render, render.ALL.R_TEXT_HALO_RADIUS);
+		textShadowColor = render.getIntPropertyValue(render.ALL.R_TEXT_HALO_COLOR);
+		if (textShadowColor == 0) {
+			textShadowColor = Color.WHITE;
+		}
+		textWrap = (int) rc.getComplexValue(render, render.ALL.R_TEXT_WRAP_WIDTH);
+		bold = render.getIntPropertyValue(render.ALL.R_TEXT_BOLD, 0) > 0;
+		italic = render.getIntPropertyValue(render.ALL.R_TEXT_ITALIC, 0) > 0;
+		minDistance = rc.getComplexValue(render, render.ALL.R_TEXT_MIN_DISTANCE);
+		if (render.isSpecified(render.ALL.R_TEXT_SHIELD)) {
+			shieldRes = render.getStringPropertyValue(render.ALL.R_TEXT_SHIELD);
+		}
+		if (render.isSpecified(render.ALL.R_ICON)) {
+			shieldResIcon = render.getStringPropertyValue(render.ALL.R_ICON);
+		}
+		textOrder = render.getIntPropertyValue(render.ALL.R_TEXT_ORDER, 100);
+	}
+
+	public float getCenterX() {
+		return centerX;
+	}
+
+	public void setCenterX(float centerX) {
+		this.centerX = centerX;
+	}
+
+	public float getCenterY() {
+		return centerY;
+	}
+
+	public void setCenterY(float centerY) {
+		this.centerY = centerY;
+	}
+
+	public String getShieldResIcon() {
+		return shieldResIcon;
+	}
+
+	public void setShieldResIcon(String shieldResIcon) {
+		this.shieldResIcon = shieldResIcon;
+	}
+}
\ No newline at end of file
diff --git a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
index fe57beb1267..16af786f4bc 100644
--- a/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
+++ b/OsmAnd/src/net/osmand/plus/render/TextRenderer.java
@@ -1,23 +1,6 @@
 package net.osmand.plus.render;
 
 
-import gnu.trove.map.hash.TIntObjectHashMap;
-import gnu.trove.procedure.TIntObjectProcedure;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.List;
-
-import net.osmand.binary.BinaryMapDataObject;
-import net.osmand.binary.BinaryMapIndexReader.TagValuePair;
-import net.osmand.data.QuadRect;
-import net.osmand.data.QuadTree;
-import net.osmand.plus.render.OsmandRenderer.RenderingContext;
-import net.osmand.render.RenderingRuleSearchRequest;
-import net.osmand.render.RenderingRulesStorage;
-import net.osmand.util.Algorithms;
-import net.osmand.util.TransliterationHelper;
 import android.content.Context;
 import android.graphics.Canvas;
 import android.graphics.Color;
@@ -31,113 +14,55 @@
 import android.graphics.Typeface;
 import android.graphics.drawable.Drawable;
 
-public class TextRenderer {
-
-	public static final String DROID_SERIF = "Droid Serif";
+import androidx.annotation.NonNull;
 
-	private Paint paintText;
-	private final Context context;
-	private Paint paintIcon;
-	private Typeface defaultTypeface;
-	private Typeface boldItalicTypeface;
-	private Typeface italicTypeface;
-	private Typeface boldTypeface;
+import net.osmand.binary.BinaryMapDataObject;
+import net.osmand.binary.BinaryMapIndexReader.TagValuePair;
+import net.osmand.data.QuadRect;
+import net.osmand.data.QuadTree;
+import net.osmand.plus.render.OsmandRenderer.RenderingContext;
+import net.osmand.render.RenderingRuleSearchRequest;
+import net.osmand.render.RenderingRulesStorage;
+import net.osmand.util.Algorithms;
+import net.osmand.util.TransliterationHelper;
 
-	public static class TextDrawInfo {
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
 
-		public TextDrawInfo(String text) {
-			this.text = text;
-		}
+import gnu.trove.map.hash.TIntObjectHashMap;
+import gnu.trove.procedure.TIntObjectProcedure;
 
-		String text = null;
-		Path drawOnPath = null;
-		QuadRect bounds = null;
-		float vOffset = 0;
-		float centerX = 0;
-		float pathRotate = 0;
-		float centerY = 0;
-		float textSize = 0;
-		float minDistance = 0;
-		int textColor = Color.BLACK;
-		int textShadow = 0;
-		int textWrap = 0;
-		boolean bold = false;
-		boolean italic = false;
-		String shieldRes = null;
-		String shieldResIcon = null;
-		int textOrder = 100;
-		int textShadowColor = Color.WHITE;
-
-		public void fillProperties(RenderingContext rc, RenderingRuleSearchRequest render, float centerX, float centerY) {
-			this.centerX = centerX;
-			// used only for draw on path where centerY doesn't play role
-			this.vOffset = (int) rc.getComplexValue(render, render.ALL.R_TEXT_DY);
-			this.centerY = centerY + this.vOffset;
-			textColor = render.getIntPropertyValue(render.ALL.R_TEXT_COLOR);
-			if (textColor == 0) {
-				textColor = Color.BLACK;
-			}
-			textSize = rc.getComplexValue(render, render.ALL.R_TEXT_SIZE) ;
-			textShadow = (int) rc.getComplexValue(render, render.ALL.R_TEXT_HALO_RADIUS);
-			textShadowColor = render.getIntPropertyValue(render.ALL.R_TEXT_HALO_COLOR);
-			if(textShadowColor == 0) {
-				textShadowColor = Color.WHITE;
-			}
-			textWrap = (int) rc.getComplexValue(render, render.ALL.R_TEXT_WRAP_WIDTH);
-			bold = render.getIntPropertyValue(render.ALL.R_TEXT_BOLD, 0) > 0;
-			italic = render.getIntPropertyValue(render.ALL.R_TEXT_ITALIC, 0) > 0;
-			minDistance = rc.getComplexValue(render, render.ALL.R_TEXT_MIN_DISTANCE);
-			if (render.isSpecified(render.ALL.R_TEXT_SHIELD)) {
-				shieldRes = render.getStringPropertyValue(render.ALL.R_TEXT_SHIELD);
-			}
-			if (render.isSpecified(render.ALL.R_ICON)) {
-				shieldResIcon = render.getStringPropertyValue(render.ALL.R_ICON);
-			}
-			textOrder = render.getIntPropertyValue(render.ALL.R_TEXT_ORDER, 100);
-		}
+public class TextRenderer {
 
-		public float getCenterX() {
-			return centerX;
-		}
+	public static final String DROID_SERIF = "Droid Serif";
 
-		public void setCenterX(float centerX) {
-			this.centerX = centerX;
-		}
+	private final Context context;
 
-		public float getCenterY() {
-			return centerY;
-		}
+	private final Paint paintText = new Paint();
+	private final Paint paintIcon = new Paint();
 
-		public void setCenterY(float centerY) {
-			this.centerY = centerY;
-		}
+	private final Typeface defaultTypeface;
+	private final Typeface boldItalicTypeface;
+	private final Typeface italicTypeface;
+	private final Typeface boldTypeface;
 
-		public String getShieldResIcon() {
-			return shieldResIcon;
-		}
+	public TextRenderer(@NonNull Context context) {
+		this.context = context;
 
-		public void setShieldResIcon(String shieldResIcon) {
-			this.shieldResIcon = shieldResIcon;
-		}
-	}
+		defaultTypeface = Typeface.create(DROID_SERIF, Typeface.NORMAL);
+		boldItalicTypeface = Typeface.create(DROID_SERIF, Typeface.BOLD_ITALIC);
+		italicTypeface = Typeface.create(DROID_SERIF, Typeface.ITALIC);
+		boldTypeface = Typeface.create(DROID_SERIF, Typeface.BOLD);
 
-	public TextRenderer(Context context) {
-		this.context = context;
-		paintText = new Paint();
 		paintText.setStyle(Style.FILL);
 		paintText.setStrokeWidth(1);
 		paintText.setColor(Color.BLACK);
 		paintText.setTextAlign(Align.CENTER);
-		defaultTypeface = Typeface.create(DROID_SERIF, Typeface.NORMAL);
-		boldItalicTypeface = Typeface.create(DROID_SERIF, Typeface.BOLD_ITALIC);
-		italicTypeface = Typeface.create(DROID_SERIF, Typeface.ITALIC);
-		boldTypeface = Typeface.create(DROID_SERIF, Typeface.BOLD);
 		paintText.setTypeface(defaultTypeface);
 		paintText.setAntiAlias(true);
-
-		paintIcon = new Paint();
 		paintIcon.setStyle(Style.STROKE);
-		
 	}
 
 	public Paint getPaintText() {
@@ -147,7 +72,7 @@ public Paint getPaintText() {
 	private double sqr(double a) {
 		return a * a;
 	}
-	
+
 	private float fsqr(float a) {
 		return a * a;
 	}
@@ -229,8 +154,8 @@ private boolean findTextIntersection(Canvas cv, RenderingContext rc, QuadTree<Te
 		return false;
 	}
 
-	private void drawTextOnCanvas(Canvas cv, String text, float centerX, float centerY, Paint paint, int shadowColor,
-			float textShadow) {
+	private void drawTextOnCanvas(Canvas cv, String text, float centerX, float centerY, Paint paint,
+	                              int shadowColor, float textShadow) {
 		if (textShadow > 0) {
 			int c = paintText.getColor();
 			paintText.setStyle(Style.STROKE);
@@ -265,22 +190,7 @@ public int compare(TextDrawInfo object1, TextDrawInfo object2) {
 				if (preferredLocale.length() > 0) {
 					text.text = TransliterationHelper.transliterate(text.text);
 				}
-
-				// sest text size before finding intersection (it is used there)
-				float textSize = text.textSize * rc.textScale ;
-				paintText.setTextSize(textSize);
-				if(text.bold && text.italic) {
-					paintText.setTypeface(boldItalicTypeface);
-				} else if(text.bold) {
-					paintText.setTypeface(boldTypeface);
-				} else if(text.italic) {
-					paintText.setTypeface(italicTypeface);
-				} else {
-					paintText.setTypeface(defaultTypeface);
-				}
-				paintText.setFakeBoldText(text.bold);
-				
-				paintText.setColor(text.textColor);
+				updateTextPaint(text, rc);
 				// align center y
 				text.centerY += (-paintText.ascent());
 
@@ -292,42 +202,57 @@ public int compare(TextDrawInfo object1, TextDrawInfo object2) {
 							paintText.setColor(text.textShadowColor);
 							paintText.setStyle(Style.STROKE);
 							paintText.setStrokeWidth(2 + text.textShadow);
-							cv.drawTextOnPath(text.text, text.drawOnPath, 0, 
-									text.vOffset - ( paintText.ascent()/2 + paintText.descent()), paintText);
+							cv.drawTextOnPath(text.text, text.drawOnPath, 0,
+									text.vOffset - (paintText.ascent() / 2 + paintText.descent()), paintText);
 							// reset
 							paintText.setStyle(Style.FILL);
 							paintText.setStrokeWidth(2);
 							paintText.setColor(text.textColor);
 						}
-						cv.drawTextOnPath(text.text, text.drawOnPath, 0, 
-								text.vOffset - ( paintText.ascent()/2 + paintText.descent()), paintText);
+						cv.drawTextOnPath(text.text, text.drawOnPath, 0,
+								text.vOffset - (paintText.ascent() / 2 + paintText.descent()), paintText);
 					} else {
 						drawShieldIcon(rc, cv, text, text.shieldRes);
 						drawShieldIcon(rc, cv, text, text.shieldResIcon);
-
-						drawWrappedText(cv, text, textSize);
+						drawWrappedText(cv, text, paintText.getTextSize());
 					}
 				}
 			}
 		}
 	}
 
+	public void updateTextPaint(TextDrawInfo text, RenderingContext rc) {
+		// set text size before finding intersection (it is used there)
+		float textSize = text.textSize * rc.textScale;
+		paintText.setTextSize(textSize);
+		if (text.bold && text.italic) {
+			paintText.setTypeface(boldItalicTypeface);
+		} else if (text.bold) {
+			paintText.setTypeface(boldTypeface);
+		} else if (text.italic) {
+			paintText.setTypeface(italicTypeface);
+		} else {
+			paintText.setTypeface(defaultTypeface);
+		}
+		paintText.setFakeBoldText(text.bold);
+		paintText.setColor(text.textColor);
+	}
+
 	public void drawShieldIcon(RenderingContext rc, Canvas cv, TextDrawInfo text, String sr) {
 		if (sr != null) {
 			float coef = rc.getDensityValue(rc.screenDensityRatio * rc.textScale);
 			Drawable ico = RenderingIcons.getDrawableIcon(context, sr, true);
 			if (ico != null) {
 				float left = text.centerX - ico.getIntrinsicWidth() / 2f * coef - 0.5f;
-				float top = text.centerY - ico.getIntrinsicHeight() / 2f * coef -  paintText.descent() * 1.5f;
+				float top = text.centerY - ico.getIntrinsicHeight() / 2f * coef - paintText.descent() * 1.5f;
 				cv.save();
 				cv.translate(left, top);
 				if (rc.screenDensityRatio != 1f) {
 					ico.setBounds(0, 0, (int) (ico.getIntrinsicWidth() * coef), (int) (ico.getIntrinsicHeight() * coef));
-					ico.draw(cv);
 				} else {
 					ico.setBounds(0, 0, ico.getIntrinsicWidth(), ico.getIntrinsicHeight());
-					ico.draw(cv);
 				}
+				ico.draw(cv);
 				cv.restore();
 			}
 		}
@@ -355,12 +280,13 @@ public void drawWrappedText(Canvas cv, TextDrawInfo text, float textSize) {
 					}
 					pos++;
 				}
+				float centerY = text.centerY + line * (textSize + 2);
 				if (lastSpace == -1 || pos == end) {
-					drawTextOnCanvas(cv, text.text.substring(start, pos), text.centerX, text.centerY + line * (textSize + 2), 
+					drawTextOnCanvas(cv, text.text.substring(start, pos), text.centerX, centerY,
 							paintText, text.textShadowColor, text.textShadow);
 					start = pos;
 				} else {
-					drawTextOnCanvas(cv, text.text.substring(start, lastSpace), text.centerX, text.centerY + line * (textSize + 2),
+					drawTextOnCanvas(cv, text.text.substring(start, lastSpace), text.centerX, centerY,
 							paintText, text.textShadowColor, text.textShadow);
 					start = lastSpace + 1;
 					limit += (start - pos) - 1;
@@ -372,14 +298,15 @@ public void drawWrappedText(Canvas cv, TextDrawInfo text, float textSize) {
 			drawTextOnCanvas(cv, text.text, text.centerX, text.centerY, paintText, text.textShadowColor, text.textShadow);
 		}
 	}
-	
-	private void createTextDrawInfo(final BinaryMapDataObject o, RenderingRuleSearchRequest render, RenderingContext rc, TagValuePair pair, final float xMid, float yMid,
-			Path path, final PointF[] points, String name, String tagName) {
+
+	private void createTextDrawInfo(final BinaryMapDataObject o, RenderingRuleSearchRequest render,
+	                                RenderingContext rc, TagValuePair pair, final float xMid, float yMid,
+	                                Path path, final PointF[] points, String name, String tagName) {
 		render.setInitialTagValueZoom(pair.tag, pair.value, rc.zoom, o);
 		render.setIntFilter(render.ALL.R_TEXT_LENGTH, name.length());
 		render.setStringFilter(render.ALL.R_NAME_TAG, tagName);
-		if(render.search(RenderingRulesStorage.TEXT_RULES)){
-			if(render.getFloatPropertyValue(render.ALL.R_TEXT_SIZE) > 0){
+		if (render.search(RenderingRulesStorage.TEXT_RULES)) {
+			if (render.getFloatPropertyValue(render.ALL.R_TEXT_SIZE) > 0) {
 				final TextDrawInfo text = new TextDrawInfo(name);
 				text.fillProperties(rc, render, xMid, yMid);
 				final String tagName2 = render.getStringPropertyValue(render.ALL.R_NAME_TAG2);
@@ -390,14 +317,13 @@ public boolean execute(int tagid, String nname) {
 							String tagNameN2 = o.getMapIndex().decodeType(tagid).tag;
 							if (tagName2.equals(tagNameN2)) {
 								if (nname != null && nname.trim().length() > 0) {
-									text.text += " (" + nname +")";
+									text.text += " (" + nname + ")";
 								}
 								return false;
 							}
 							return true;
 						}
 					});
-
 				}
 				paintText.setTextSize(text.textSize);
 				Rect bs = new Rect();
@@ -405,27 +331,28 @@ public boolean execute(int tagid, String nname) {
 				text.bounds = new QuadRect(bs.left, bs.top, bs.right, bs.bottom);
 				text.bounds.inset(-rc.getDensityValue(3), -rc.getDensityValue(10));
 				boolean display = true;
-				if(path != null) {
+				if (path != null) {
 					text.drawOnPath = path;
-					display = calculatePathToRotate(rc, text, points, 
+					display = calculatePathToRotate(rc, text, points,
 							render.getIntPropertyValue(render.ALL.R_TEXT_ON_PATH, 0) != 0);
 				}
-				if(text.drawOnPath == null) {
+				if (text.drawOnPath == null) {
 					text.bounds.offset(text.centerX, text.centerY);
 					// shift to match alignment
-					text.bounds.offset(-text.bounds.width()/2, 0);
+					text.bounds.offset(-text.bounds.width() / 2, 0);
 				} else {
-					text.bounds.offset(text.centerX - text.bounds.width()/2, text.centerY - text.bounds.height()/2);
+					text.bounds.offset(text.centerX - text.bounds.width() / 2, text.centerY - text.bounds.height() / 2);
 				}
-				if(display) {
+				if (display) {
 					rc.textToDraw.add(text);
 				}
 			}
 		}
 	}
-	
-	public void renderText(final BinaryMapDataObject obj, final RenderingRuleSearchRequest render, final RenderingContext rc, 
-			final TagValuePair pair, final float xMid, final float yMid, final Path path, final PointF[] points) {
+
+	public void renderText(final BinaryMapDataObject obj, final RenderingRuleSearchRequest render,
+	                       final RenderingContext rc, final TagValuePair pair, final float xMid,
+	                       final float yMid, final Path path, final PointF[] points) {
 		final TIntObjectHashMap<String> map = obj.getObjectNames();
 		if (map != null) {
 			map.forEachEntry(new TIntObjectProcedure<String>() {
@@ -439,11 +366,11 @@ public boolean execute(int tag, String name) {
 						if (isName && !rc.preferredLocale.isEmpty() &&
 								map.containsKey(obj.getMapIndex().nameEnEncodingType)) {
 							skip = true;
-						} 
+						}
 //						if (tag == obj.getMapIndex().nameEnEncodingType && !rc.useEnglishNames) {
 //							skip = true;
 //						}
-						if(!skip) {
+						if (!skip) {
 							createTextDrawInfo(obj, render, rc, pair, xMid, yMid, path, points, name, nameTag);
 						}
 					}
@@ -453,7 +380,6 @@ public boolean execute(int tag, String name) {
 		}
 	}
 
-	
 	boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] points, boolean drawOnPath) {
 		int len = points.length;
 		if (!drawOnPath) {
@@ -483,19 +409,19 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 		float normalTextLen = 1.5f * textw;
 		for (int i = 0; i < len; i++, last++) {
 			boolean inside = points[i].x >= 0 && points[i].x <= rc.width &&
-					points[i].x >= 0 && points[i].y <= rc.height;
+					points[i].y >= 0 && points[i].y <= rc.height;
 			if (i > 0) {
-				float d = (float) Math.sqrt(fsqr(points[i].x - points[i - 1].x) + 
+				float d = (float) Math.sqrt(fsqr(points[i].x - points[i - 1].x) +
 						fsqr(points[i].y - points[i - 1].y));
-				distances[i-1]= d;
+				distances[i - 1] = d;
 				roadLength += d;
-				if(inside) {
+				if (inside) {
 					visibleRoadLength += d;
-					if(!prevInside) {
+					if (!prevInside) {
 						startVisible = i - 1;
 					}
-				} else if(prevInside) {
-					if(visibleRoadLength >= normalTextLen) {
+				} else if (prevInside) {
+					if (visibleRoadLength >= normalTextLen) {
 						break;
 					}
 					visibleRoadLength = 0;
@@ -510,31 +436,31 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 		int startInd = 0;
 		int endInd = len;
 
-		if(textw < visibleRoadLength &&  last - startVisible > 1) {
+		if (textw < visibleRoadLength && last - startVisible > 1) {
 			startInd = startVisible;
 			endInd = last;
 			// display long road name in center
 			if (visibleRoadLength > 3 * textw) {
-				boolean ch ;
+				boolean ch;
 				do {
 					ch = false;
-					if(endInd - startInd > 2 && visibleRoadLength - distances[startInd] > normalTextLen){
+					if (endInd - startInd > 2 && visibleRoadLength - distances[startInd] > normalTextLen) {
 						visibleRoadLength -= distances[startInd];
 						startInd++;
 						ch = true;
 					}
-					if(endInd - startInd > 2 && visibleRoadLength - distances[endInd - 2] > normalTextLen){
+					if (endInd - startInd > 2 && visibleRoadLength - distances[endInd - 2] > normalTextLen) {
 						visibleRoadLength -= distances[endInd - 2];
 						endInd--;
 						ch = true;
 					}
-				} while(ch);
+				} while (ch);
 			}
 		}
 		// shrink path to display more text
 		if (startInd > 0 || endInd < len) {
 			// find subpath
-			Path path = new Path(); 
+			Path path = new Path();
 			for (int i = startInd; i < endInd; i++) {
 				if (i == startInd) {
 					path.moveTo(points[i].x, points[i].y);
@@ -556,7 +482,7 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 		// vector ox,oy orthogonal to px,py to measure height
 		float ox = -py;
 		float oy = px;
-		if(plen > 0) {
+		if (plen > 0) {
 			float rot = (float) (-Math.atan2(px, py) + Math.PI / 2);
 			if (rot < 0) rot += Math.PI * 2;
 			if (rot > Math.PI / 2f && rot < 3 * Math.PI / 2f) {
@@ -587,6 +513,4 @@ boolean calculatePathToRotate(RenderingContext rc, TextDrawInfo p, PointF[] poin
 		}
 		return true;
 	}
-
-
 }
diff --git a/OsmAnd/src/net/osmand/plus/track/cards/RouteInfoCard.java b/OsmAnd/src/net/osmand/plus/track/cards/RouteInfoCard.java
index 83410edd468..fb6c8993d7b 100644
--- a/OsmAnd/src/net/osmand/plus/track/cards/RouteInfoCard.java
+++ b/OsmAnd/src/net/osmand/plus/track/cards/RouteInfoCard.java
@@ -1,13 +1,12 @@
 package net.osmand.plus.track.cards;
 
-import static net.osmand.plus.mapcontextmenu.controllers.NetworkRouteMenuController.getBackgroundIconIdWithName;
-import static net.osmand.plus.mapcontextmenu.controllers.NetworkRouteMenuController.getForegroundIconIdWithName;
+import static net.osmand.aidlapi.OsmAndCustomizationConstants.CONTEXT_MENU_LINKS_ID;
 import static net.osmand.plus.utils.AndroidUtils.getActivityTypeStringPropertyName;
 import static net.osmand.plus.utils.AndroidUtils.getStringByProperty;
-import static net.osmand.router.network.NetworkRouteContext.*;
+import static net.osmand.router.network.NetworkRouteContext.NetworkRouteSegment;
 import static net.osmand.util.Algorithms.capitalizeFirstLetterAndLowercase;
 
-import android.util.Pair;
+import android.text.util.Linkify;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
@@ -20,7 +19,11 @@
 import net.osmand.plus.activities.MapActivity;
 import net.osmand.plus.helpers.AndroidUiHelper;
 import net.osmand.plus.routepreparationmenu.cards.MapBaseCard;
+import net.osmand.plus.settings.backend.OsmAndAppCustomization;
+import net.osmand.plus.utils.AndroidUtils;
+import net.osmand.plus.utils.ColorUtilities;
 import net.osmand.plus.utils.UiUtilities;
+import net.osmand.plus.widgets.tools.ClickableSpanTouchListener;
 import net.osmand.router.network.NetworkRouteSelector.RouteKey;
 import net.osmand.util.Algorithms;
 
@@ -58,44 +61,42 @@ public void updateContent() {
 		if (!Algorithms.isEmpty(operatorTag)) {
 			addInfoRow(container, operatorTag, app.getString(R.string.poi_operator));
 		}
-//			addSymbolRow(container, routeKey);
-	}
-
-	private void addSymbolRow(@NonNull LinearLayout container, @NonNull RouteKey routeKey) {
-		String foregroundName = null;
-		String backgroundName = null;
-
-		Pair<String, Integer> foreground = getForegroundIconIdWithName(app, routeKey);
-		Pair<String, Integer> background = getBackgroundIconIdWithName(app, routeKey);
-		if (foreground != null) {
-			foregroundName = foreground.first.replace('_', ' ');
+		String symbolTag = routeKey.getValue("symbol");
+		if (!Algorithms.isEmpty(symbolTag)) {
+			addInfoRow(container, symbolTag, app.getString(R.string.shared_string_symbol));
 		}
-		if (background != null) {
-			backgroundName = background.first.replace('_', ' ');
-		}
-
-		String symbolName;
-		if (backgroundName != null && foregroundName != null) {
-			symbolName = app.getString(R.string.on_with_params, foregroundName, backgroundName);
-		} else {
-			symbolName = foregroundName != null ? foregroundName : backgroundName;
+		String websiteTag = routeKey.getValue("website");
+		if (!Algorithms.isEmpty(websiteTag)) {
+			addInfoRow(container, websiteTag, app.getString(R.string.website), true);
 		}
-		if (!Algorithms.isEmpty(symbolName)) {
-			addInfoRow(container, capitalizeFirstLetterAndLowercase(symbolName), app.getString(R.string.shared_string_symbol));
+		String wikipediaTag = routeKey.getValue("wikipedia");
+		if (!Algorithms.isEmpty(wikipediaTag)) {
+			addInfoRow(container, wikipediaTag, app.getString(R.string.shared_string_wikipedia));
 		}
 	}
 
 	private void addInfoRow(@NonNull ViewGroup container, @NonNull String text, @NonNull String description) {
+		addInfoRow(container, text, description, false);
+	}
+
+	private void addInfoRow(@NonNull ViewGroup container, @NonNull String text, @NonNull String description, boolean needLinks) {
 		LayoutInflater inflater = UiUtilities.getInflater(container.getContext(), nightMode);
 		View view = inflater.inflate(R.layout.list_item_with_descr, container, false);
 
 		TextView titleTv = view.findViewById(R.id.title);
 		TextView descriptionTv = view.findViewById(R.id.description);
+
 		titleTv.setText(text);
 		descriptionTv.setText(description);
 
+		OsmAndAppCustomization customization = app.getAppCustomization();
+		if (needLinks && customization.isFeatureEnabled(CONTEXT_MENU_LINKS_ID) && Linkify.addLinks(titleTv, Linkify.ALL)) {
+			titleTv.setMovementMethod(null);
+			titleTv.setLinkTextColor(ColorUtilities.getActiveColor(app, nightMode));
+			titleTv.setOnTouchListener(new ClickableSpanTouchListener());
+			AndroidUtils.removeLinkUnderline(titleTv);
+		}
 		AndroidUiHelper.updateVisibility(view.findViewById(R.id.divider), container.getChildCount() > 0);
-
 		container.addView(view);
 	}
 }
diff --git a/OsmAnd/src/net/osmand/plus/track/fragments/TrackMenuFragment.java b/OsmAnd/src/net/osmand/plus/track/fragments/TrackMenuFragment.java
index 588552c60ac..a49969e53c9 100644
--- a/OsmAnd/src/net/osmand/plus/track/fragments/TrackMenuFragment.java
+++ b/OsmAnd/src/net/osmand/plus/track/fragments/TrackMenuFragment.java
@@ -3,7 +3,6 @@
 import static net.osmand.GPXUtilities.GPXTrackAnalysis;
 import static net.osmand.plus.activities.MapActivityActions.KEY_LATITUDE;
 import static net.osmand.plus.activities.MapActivityActions.KEY_LONGITUDE;
-import static net.osmand.plus.mapcontextmenu.controllers.NetworkRouteMenuController.getIconForRouteObject;
 import static net.osmand.plus.measurementtool.MeasurementToolFragment.ATTACH_ROADS_MODE;
 import static net.osmand.plus.measurementtool.MeasurementToolFragment.CALCULATE_SRTM_MODE;
 import static net.osmand.plus.measurementtool.MeasurementToolFragment.PLAN_ROUTE_MODE;
@@ -85,6 +84,7 @@
 import net.osmand.plus.helpers.FontCache;
 import net.osmand.plus.helpers.GpxUiHelper;
 import net.osmand.plus.mapcontextmenu.MapContextMenu;
+import net.osmand.plus.mapcontextmenu.controllers.NetworkRouteDrawable;
 import net.osmand.plus.mapcontextmenu.controllers.SelectedGpxMenuController.OpenGpxDetailsTask;
 import net.osmand.plus.mapcontextmenu.controllers.SelectedGpxMenuController.SelectedGpxPoint;
 import net.osmand.plus.mapcontextmenu.other.TrackChartPoints;
@@ -161,6 +161,7 @@ public class TrackMenuFragment extends ContextMenuScrollFragment implements Card
 	public static final String TRACK_DELETED_KEY = "track_deleted_key";
 
 	private OsmandApplication app;
+	private UiUtilities uiUtilities;
 	private TrackDisplayHelper displayHelper;
 	private SelectedGpxFile selectedGpxFile;
 	private GPXTrackAnalysis analyses;
@@ -282,7 +283,8 @@ public void onCreate(Bundle savedInstanceState) {
 		super.onCreate(savedInstanceState);
 		app = requireMyApplication();
 		displayHelper = new TrackDisplayHelper(app);
-		updateLocationViewCache = app.getUIUtilities().getUpdateLocationViewCache();
+		uiUtilities = app.getUIUtilities();
+		updateLocationViewCache = uiUtilities.getUpdateLocationViewCache();
 
 		toolbarHeightPx = getResources().getDimensionPixelSize(R.dimen.dashboard_map_toolbar);
 		if (selectedGpxFile == null && savedInstanceState != null) {
@@ -467,11 +469,9 @@ private void updateHeader() {
 		AndroidUiHelper.updateVisibility(displayGroupsButton, hasPointsGroups());
 		AndroidUiHelper.updateVisibility(headerIcon, menuType != TrackMenuType.OPTIONS);
 
-		Drawable icon = null;
-		if (routeSegment != null) {
-			icon = getIconForRouteObject(app, routeSegment);
-		}
-		headerIcon.setImageDrawable(icon != null ? icon : app.getUIUtilities().getThemedIcon(R.drawable.ic_action_polygom_dark));
+		Drawable icon = routeSegment != null ? new NetworkRouteDrawable(app, routeSegment, isNightMode())
+				: uiUtilities.getThemedIcon(R.drawable.ic_action_polygom_dark);
+		headerIcon.setImageDrawable(icon);
 	}
 
 	@NonNull
@@ -902,7 +902,7 @@ private void updateDistanceDirection() {
 			View view = overviewCard.getView();
 			TextView distanceText = view.findViewById(R.id.distance);
 			ImageView direction = view.findViewById(R.id.direction);
-			app.getUIUtilities().updateLocationView(updateLocationViewCache, direction, distanceText, latLon);
+			uiUtilities.updateLocationView(updateLocationViewCache, direction, distanceText, latLon);
 		}
 	}
 
@@ -1438,12 +1438,12 @@ public void showOptionsPopupMenu(View view, final TrkSegment segment, final bool
 			IconPopupMenu optionsPopupMenu = new IconPopupMenu(activity, view.findViewById(R.id.overflow_menu));
 			Menu menu = optionsPopupMenu.getMenu();
 			optionsPopupMenu.getMenuInflater().inflate(R.menu.track_segment_menu, menu);
-			menu.findItem(R.id.action_edit).setIcon(app.getUIUtilities().getThemedIcon(R.drawable.ic_action_edit_dark));
-			menu.findItem(R.id.action_delete).setIcon(app.getUIUtilities().getThemedIcon(R.drawable.ic_action_remove_dark));
+			menu.findItem(R.id.action_edit).setIcon(uiUtilities.getThemedIcon(R.drawable.ic_action_edit_dark));
+			menu.findItem(R.id.action_delete).setIcon(uiUtilities.getThemedIcon(R.drawable.ic_action_remove_dark));
 			if (getGpx().showCurrentTrack) {
 				menu.findItem(R.id.split_interval).setVisible(false);
 			} else {
-				menu.findItem(R.id.split_interval).setIcon(app.getUIUtilities().getThemedIcon(R.drawable.ic_action_split_interval));
+				menu.findItem(R.id.split_interval).setIcon(uiUtilities.getThemedIcon(R.drawable.ic_action_split_interval));
 			}
 			optionsPopupMenu.setOnMenuItemClickListener(new IconPopupMenu.OnMenuItemClickListener() {
 				@Override
diff --git a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/StreetNameWidget.java b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/StreetNameWidget.java
index faaa4bdc1ae..483b9ddaad2 100644
--- a/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/StreetNameWidget.java
+++ b/OsmAnd/src/net/osmand/plus/views/mapwidgets/widgets/StreetNameWidget.java
@@ -1,7 +1,6 @@
 package net.osmand.plus.views.mapwidgets.widgets;
 
 import static net.osmand.plus.render.OsmandRenderer.RenderingContext;
-import static net.osmand.plus.render.TextRenderer.TextDrawInfo;
 
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -34,6 +33,7 @@
 import net.osmand.plus.helpers.WaypointDialogHelper;
 import net.osmand.plus.helpers.WaypointHelper;
 import net.osmand.plus.helpers.WaypointHelper.LocationPointWrapper;
+import net.osmand.plus.render.TextDrawInfo;
 import net.osmand.plus.render.TextRenderer;
 import net.osmand.plus.routepreparationmenu.MapRouteInfoMenu;
 import net.osmand.plus.routepreparationmenu.ShowAlongTheRouteBottomSheet;
@@ -287,7 +287,7 @@ private boolean setRoadShield(@NonNull RouteDataObject object, @NonNull String n
 
 		Bitmap bitmap = Bitmap.createBitmap((int) xSize, (int) ySize, Bitmap.Config.ARGB_8888);
 		Canvas canvas = new Canvas(bitmap);
-		Paint paint = setupTextPaint(textRenderer.getPaintText(), rreq);
+		Paint paint = setupTextPaint(app, textRenderer.getPaintText(), rreq);
 
 		float centerX = xSize / 2f;
 		float centerY = ySize / 2f - paint.getFontMetrics().ascent / 2f;
@@ -300,7 +300,8 @@ private boolean setRoadShield(@NonNull RouteDataObject object, @NonNull String n
 	}
 
 	@NonNull
-	private Paint setupTextPaint(@NonNull Paint paint, @NonNull RenderingRuleSearchRequest request) {
+	public static Paint setupTextPaint(@NonNull OsmandApplication app, @NonNull Paint paint,
+	                                   @NonNull RenderingRuleSearchRequest request) {
 		paint.setTypeface(Typeface.create(TextRenderer.DROID_SERIF, Typeface.BOLD));
 
 		if (request.isSpecified(request.ALL.R_TEXT_COLOR)) {
