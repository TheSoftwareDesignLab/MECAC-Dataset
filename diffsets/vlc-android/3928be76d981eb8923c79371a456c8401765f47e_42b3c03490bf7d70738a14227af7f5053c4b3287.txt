diff --git a/vlc-android/res/layout/media_browser_tv_item.xml b/vlc-android/res/layout/media_browser_tv_item.xml
index df31906703..f86a112921 100644
--- a/vlc-android/res/layout/media_browser_tv_item.xml
+++ b/vlc-android/res/layout/media_browser_tv_item.xml
@@ -49,7 +49,7 @@
 
         <variable
             name="holder"
-            type="org.videolan.vlc.gui.tv.TvItemAdapter.MediaItemTVViewHolder" />
+            type="org.videolan.vlc.gui.tv.MediaTvItemAdapter.AbstractMediaItemViewHolder" />
     </data>
 
     <org.videolan.vlc.gui.tv.FocusableConstraintLayout
diff --git a/vlc-android/res/layout/song_browser.xml b/vlc-android/res/layout/song_browser.xml
index a8cf2b02d8..e8c81eadde 100644
--- a/vlc-android/res/layout/song_browser.xml
+++ b/vlc-android/res/layout/song_browser.xml
@@ -58,7 +58,6 @@
         android:background="@color/transparent"
         android:elevation="6dp"
         android:src="@drawable/ic_menu_header_tv"
-        android:visibility="gone"
         app:layout_constraintEnd_toEndOf="parent"
         app:layout_constraintTop_toTopOf="parent" />
 
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/FileTvItemAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/tv/FileTvItemAdapter.kt
new file mode 100644
index 0000000000..a2294f3c03
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/FileTvItemAdapter.kt
@@ -0,0 +1,197 @@
+package org.videolan.vlc.gui.tv
+
+import android.annotation.TargetApi
+import android.content.Context
+import android.graphics.drawable.BitmapDrawable
+import android.os.Build
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.databinding.ViewDataBinding
+import androidx.fragment.app.Fragment
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.util.AndroidUtil
+import org.videolan.medialibrary.Tools
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.databinding.MediaBrowserTvItemBinding
+import org.videolan.vlc.gui.DiffUtilAdapter
+import org.videolan.vlc.gui.helpers.getAudioIconDrawable
+import org.videolan.vlc.gui.view.FastScroller
+import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.util.generateResolutionClass
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+class FileTvItemAdapter(type: Int, private val eventsHandler: IEventsHandler, var itemSize: Int) : DiffUtilAdapter<MediaLibraryItem, MediaTvItemAdapter.AbstractMediaItemViewHolder<ViewDataBinding>>(), FastScroller.SeparatedAdapter, TvItemAdapter {
+    override fun submitList(pagedList: Any?) {
+
+        if (pagedList is List<*>) {
+            update(pagedList as List<MediaLibraryItem>)
+        }
+
+
+    }
+
+    override var focusNext = -1
+    private val mDefaultCover: BitmapDrawable?
+    private var focusListener: FocusableRecyclerView.FocusListener? = null
+
+
+    init {
+        var ctx: Context? = null
+        if (eventsHandler is Context)
+            ctx = eventsHandler
+        else if (eventsHandler is Fragment) ctx = (eventsHandler as Fragment).context
+        mDefaultCover = if (ctx != null) getAudioIconDrawable(ctx, type) else null
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MediaTvItemAdapter.AbstractMediaItemViewHolder<ViewDataBinding> {
+        val inflater = parent.context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
+        val binding = MediaBrowserTvItemBinding.inflate(inflater, parent, false)
+        return MediaItemTVViewHolder(binding, eventsHandler) as MediaTvItemAdapter.AbstractMediaItemViewHolder<ViewDataBinding>
+    }
+
+    override fun onBindViewHolder(holder: MediaTvItemAdapter.AbstractMediaItemViewHolder<ViewDataBinding>, position: Int) {
+        if (position >= itemCount) return
+        val item = getItem(position)
+        holder.setItem(item)
+        holder.binding.executePendingBindings()
+        if (position == focusNext) {
+            holder.binding.root.requestFocus()
+            focusNext = -1
+        }
+    }
+
+
+    override fun hasSections(): Boolean {
+        return true
+    }
+
+
+    override fun setOnFocusChangeListener(focusListener: FocusableRecyclerView.FocusListener?) {
+        this.focusListener = focusListener
+    }
+
+    override fun createCB(): DiffCallback<MediaLibraryItem> {
+        return object : DiffCallback<MediaLibraryItem>() {
+            override fun areItemsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
+                return try {
+                    dataset[oldItemPosition] === dataset[newItemPosition]
+                } catch (e: IndexOutOfBoundsException) {
+                    false
+                }
+            }
+
+            override fun areContentsTheSame(oldItemPosition: Int, newItemPosition: Int): Boolean {
+                return dataset[oldItemPosition].description == dataset[newItemPosition].description
+                        && dataset[oldItemPosition].title == dataset[newItemPosition].title
+            }
+
+            override fun getChangePayload(oldItemPosition: Int, newItemPosition: Int): Any? {
+                return arrayListOf(UPDATE_PAYLOAD)
+            }
+        }
+    }
+
+
+    companion object {
+
+        private val TAG = "VLC/AudioBrowserAdapter"
+        private const val UPDATE_PAYLOAD = 1
+
+    }
+
+
+    inner class MediaItemTVViewHolder @TargetApi(Build.VERSION_CODES.M)
+    internal constructor(binding: MediaBrowserTvItemBinding, override val eventsHandler: IEventsHandler) : MediaTvItemAdapter.AbstractMediaItemViewHolder<MediaBrowserTvItemBinding>(binding), View.OnFocusChangeListener {
+        override fun getItem(layoutPosition: Int): MediaLibraryItem? {
+            return this@FileTvItemAdapter.getItem(layoutPosition)
+        }
+
+        init {
+            binding.holder = this
+            if (mDefaultCover != null) binding.cover = mDefaultCover
+            if (AndroidUtil.isMarshMallowOrLater)
+                itemView.setOnContextClickListener { v ->
+                    onMoreClick(v)
+                    true
+                }
+            binding.container.layoutParams.width = itemSize
+            binding.container.onFocusChangeListener = View.OnFocusChangeListener { _, hasFocus ->
+                if (hasFocus) {
+                    var newWidth = (itemSize * 1.1).toInt()
+                    if (newWidth % 2 == 1) {
+                        newWidth--
+                    }
+                    val scale = newWidth.toFloat() / itemSize
+                    binding.container.animate().scaleX(scale).scaleY(scale).translationZ(scale)
+
+                    eventsHandler.onItemFocused(binding.root, getItem(layoutPosition)!!)
+                    if (focusListener != null) {
+                        focusListener!!.onFocusChanged(layoutPosition)
+                    }
+
+                } else {
+                    binding.container.animate().scaleX(1f).scaleY(1f).translationZ(1f)
+                }
+            }
+            binding.container.clipToOutline = true
+
+        }
+
+        override fun recycle() {
+            if (mDefaultCover != null) binding.cover = mDefaultCover
+            binding.title.text = ""
+            binding.subtitle.text = ""
+        }
+
+        override fun setItem(item: MediaLibraryItem?) {
+            binding.item = item
+            var isSquare = true
+            var progress = 0
+            var seen = 0L
+            var description = item?.description
+            var resolution = ""
+            if (item is MediaWrapper) {
+                if (item.type == MediaWrapper.TYPE_VIDEO) {
+                    resolution = generateResolutionClass(item.width, item.height) ?: ""
+                    isSquare = false
+                    description = if (item.time == 0L) Tools.millisToString(item.length) else Tools.getProgressText(item)
+                    binding.badge = resolution
+                    seen = item.seen
+                    var max = 0
+
+
+                    if (item.length > 0) {
+                        val lastTime = item.displayTime
+                        if (lastTime > 0) {
+                            max = (item.length / 1000).toInt()
+                            progress = (lastTime / 1000).toInt()
+                        }
+                    }
+                    binding.max = max
+                }
+
+
+            }
+
+            binding.progress = progress
+            binding.isSquare = isSquare
+            binding.seen = seen
+            binding.description = description
+            if (seen == 0L) binding.mlItemSeen.visibility = View.GONE
+            if (progress <= 0L) binding.progressBar.visibility = View.GONE
+            binding.badgeTV.visibility = if (resolution.isBlank()) View.GONE else View.VISIBLE
+        }
+
+        @ObsoleteCoroutinesApi
+        override fun setCoverlay(selected: Boolean) {
+        }
+
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/MainTvFragment.kt b/vlc-android/src/org/videolan/vlc/gui/tv/MainTvFragment.kt
index c7166fe6b9..fd1c63547a 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/MainTvFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/MainTvFragment.kt
@@ -195,7 +195,7 @@ class MainTvFragment : BrowseSupportFragment(), OnItemViewSelectedListener, OnIt
                 }
                 val intent = Intent(activity, VerticalGridActivity::class.java)
                 intent.putExtra(MainTvActivity.BROWSER_TYPE, HEADER_CATEGORIES)
-                intent.putExtra(AUDIO_CATEGORY, item.id)
+                intent.putExtra(CATEGORY, item.id)
                 activity.startActivity(intent)
             }
             HEADER_MISC -> {
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/MediaBrowserAnimatorDelegate.kt b/vlc-android/src/org/videolan/vlc/gui/tv/MediaBrowserAnimatorDelegate.kt
index a9d7429355..a7b42238f2 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/MediaBrowserAnimatorDelegate.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/MediaBrowserAnimatorDelegate.kt
@@ -35,17 +35,20 @@ import kotlinx.android.synthetic.main.song_browser.*
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.ObsoleteCoroutinesApi
 import org.videolan.vlc.R
-import org.videolan.vlc.gui.tv.browser.MediaBrowserTvFragment
+import org.videolan.vlc.gui.tv.browser.BaseBrowserTvFragment
 
 
 @ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
-internal class MediaBrowserAnimatorDelegate(val browser: MediaBrowserTvFragment, private val cl: ConstraintLayout) : RecyclerView.OnScrollListener(), View.OnFocusChangeListener {
+internal class MediaBrowserAnimatorDelegate(val browser: BaseBrowserTvFragment, private val cl: ConstraintLayout) : RecyclerView.OnScrollListener(), View.OnFocusChangeListener {
 
     private val scrolledUpConstraintSet = ConstraintSet()
     private val scrolledDownFABCollapsedConstraintSet = ConstraintSet()
     private val scrolledDownFABExpandedConstraintSet = ConstraintSet()
     private val headerVisibleConstraintSet = ConstraintSet()
+
+    private val constraintSets = arrayOf(scrolledUpConstraintSet, scrolledDownFABCollapsedConstraintSet, scrolledDownFABExpandedConstraintSet, headerVisibleConstraintSet)
+
     private val transition = ChangeBounds().apply {
         interpolator = AccelerateDecelerateInterpolator()
         duration = 300
@@ -143,6 +146,19 @@ internal class MediaBrowserAnimatorDelegate(val browser: MediaBrowserTvFragment,
 
     }
 
+    //FIXME it doesn't work. WHY???
+    fun setVisibility(view: View, visibility: Int) {
+
+
+        constraintSets.forEach {
+            it.setVisibility(view.id, visibility)
+        }
+
+        view.visibility = visibility
+
+
+    }
+
     init {
 
         // Scrolled up is the state already described in the XML. We clone it to be able to reuse it.
@@ -250,7 +266,7 @@ internal class MediaBrowserAnimatorDelegate(val browser: MediaBrowserTvFragment,
 
 @ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
-fun MediaBrowserTvFragment.setAnimator(cl: ConstraintLayout) {
+fun BaseBrowserTvFragment.setAnimator(cl: ConstraintLayout) {
     animationDelegate = MediaBrowserAnimatorDelegate(this, cl)
     headerButton.onFocusChangeListener = animationDelegate
     sortButton.onFocusChangeListener = animationDelegate
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/MediaTvItemAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/tv/MediaTvItemAdapter.kt
new file mode 100644
index 0000000000..e005d1684a
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/MediaTvItemAdapter.kt
@@ -0,0 +1,259 @@
+package org.videolan.vlc.gui.tv
+
+import android.annotation.TargetApi
+import android.content.Context
+import android.graphics.drawable.BitmapDrawable
+import android.os.Build
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.databinding.ViewDataBinding
+import androidx.fragment.app.Fragment
+import androidx.paging.PagedList
+import androidx.paging.PagedListAdapter
+import androidx.recyclerview.widget.DiffUtil
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.util.AndroidUtil
+import org.videolan.medialibrary.Tools
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.databinding.MediaBrowserTvItemBinding
+import org.videolan.vlc.gui.helpers.SelectorViewHolder
+import org.videolan.vlc.gui.helpers.getAudioIconDrawable
+import org.videolan.vlc.gui.view.FastScroller
+import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.util.UPDATE_SELECTION
+import org.videolan.vlc.util.Util
+import org.videolan.vlc.util.generateResolutionClass
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+class MediaTvItemAdapter(type: Int, private val eventsHandler: IEventsHandler, var itemSize: Int) : PagedListAdapter<MediaLibraryItem, MediaTvItemAdapter.AbstractMediaItemViewHolder<ViewDataBinding>>(DIFF_CALLBACK), FastScroller.SeparatedAdapter, TvItemAdapter {
+    override var focusNext = -1
+    private val mDefaultCover: BitmapDrawable?
+    private var focusListener: FocusableRecyclerView.FocusListener? = null
+
+
+    init {
+        var ctx: Context? = null
+        if (eventsHandler is Context)
+            ctx = eventsHandler
+        else if (eventsHandler is Fragment) ctx = (eventsHandler as Fragment).context
+        mDefaultCover = if (ctx != null) getAudioIconDrawable(ctx, type) else null
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AbstractMediaItemViewHolder<ViewDataBinding> {
+        val inflater = parent.context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
+        val binding = MediaBrowserTvItemBinding.inflate(inflater, parent, false)
+        return MediaItemTVViewHolder(binding, eventsHandler) as AbstractMediaItemViewHolder<ViewDataBinding>
+    }
+
+    override fun onBindViewHolder(holder: AbstractMediaItemViewHolder<ViewDataBinding>, position: Int) {
+        if (position >= itemCount) return
+        val item = getItem(position)
+        holder.setItem(item)
+        holder.binding.executePendingBindings()
+        if (position == focusNext) {
+            holder.binding.root.requestFocus()
+            focusNext = -1
+        }
+    }
+
+    override fun onBindViewHolder(holder: AbstractMediaItemViewHolder<ViewDataBinding>, position: Int, payloads: List<Any>) {
+        if (Util.isListEmpty(payloads))
+            onBindViewHolder(holder, position)
+        else {
+            val payload = payloads[0]
+            if (payload is MediaLibraryItem) {
+                val isSelected = payload.hasStateFlags(MediaLibraryItem.FLAG_SELECTED)
+                holder.setCoverlay(isSelected)
+                holder.selectView(isSelected)
+            } else if (payload is Int) {
+                if (payload == UPDATE_SELECTION) {
+                }
+            }
+        }
+    }
+
+    override fun hasSections(): Boolean {
+        return true
+    }
+
+
+    override fun submitList(pagedList: Any?) {
+        if (pagedList == null) {
+            this.submitList(null)
+        }
+        if (pagedList is PagedList<*>) {
+            this.submitList(pagedList as PagedList<MediaLibraryItem>)
+        }
+    }
+
+
+    override fun setOnFocusChangeListener(focusListener: FocusableRecyclerView.FocusListener?) {
+        this.focusListener = focusListener
+    }
+
+
+    companion object {
+
+        private val TAG = "VLC/AudioBrowserAdapter"
+        private const val UPDATE_PAYLOAD = 1
+        /**
+         * Awful hack to workaround the [PagedListAdapter] not keeping track of notifyItemMoved operations
+         */
+        private var preventNextAnim: Boolean = false
+
+        private val DIFF_CALLBACK = object : DiffUtil.ItemCallback<MediaLibraryItem>() {
+            override fun areItemsTheSame(
+                    oldMedia: MediaLibraryItem, newMedia: MediaLibraryItem): Boolean {
+                return if (preventNextAnim) {
+                    true
+                } else oldMedia === newMedia || oldMedia.itemType == newMedia.itemType && oldMedia.equals(newMedia)
+            }
+
+            override fun areContentsTheSame(
+                    oldMedia: MediaLibraryItem, newMedia: MediaLibraryItem): Boolean {
+                return false
+            }
+
+            override fun getChangePayload(oldItem: MediaLibraryItem, newItem: MediaLibraryItem): Any? {
+                preventNextAnim = false
+                return UPDATE_PAYLOAD
+            }
+        }
+    }
+
+
+    abstract class AbstractMediaItemViewHolder<T : ViewDataBinding> @TargetApi(Build.VERSION_CODES.M)
+    internal constructor(binding: T) : SelectorViewHolder<T>(binding), View.OnFocusChangeListener {
+
+
+        fun onClick(v: View) {
+            val item = getItem(layoutPosition)
+            if (item != null) eventsHandler.onClick(v, layoutPosition, item)
+        }
+
+        fun onMoreClick(v: View) {
+            val item = getItem(layoutPosition)
+            if (item != null) eventsHandler.onCtxClick(v, layoutPosition, item)
+        }
+
+        fun onLongClick(view: View): Boolean {
+            val item = getItem(layoutPosition)
+            return item != null && eventsHandler.onLongClick(view, layoutPosition, item)
+        }
+
+        fun onImageClick(v: View) {
+            val item = getItem(layoutPosition)
+            if (item != null) eventsHandler.onImageClick(v, layoutPosition, item)
+        }
+
+        fun onMainActionClick(v: View) {
+            val item = getItem(layoutPosition)
+            if (item != null) eventsHandler.onMainActionClick(v, layoutPosition, item)
+        }
+
+        abstract fun getItem(layoutPosition: Int): MediaLibraryItem?
+
+        abstract val eventsHandler: IEventsHandler
+
+        abstract fun setItem(item: MediaLibraryItem?)
+
+        abstract fun recycle()
+
+        abstract fun setCoverlay(selected: Boolean)
+    }
+
+    inner class MediaItemTVViewHolder @TargetApi(Build.VERSION_CODES.M)
+    internal constructor(binding: MediaBrowserTvItemBinding, override val eventsHandler: IEventsHandler) : AbstractMediaItemViewHolder<MediaBrowserTvItemBinding>(binding), View.OnFocusChangeListener {
+        override fun getItem(layoutPosition: Int): MediaLibraryItem? {
+            return this@MediaTvItemAdapter.getItem(layoutPosition)
+        }
+
+        init {
+            binding.holder = this
+            if (mDefaultCover != null) binding.cover = mDefaultCover
+            if (AndroidUtil.isMarshMallowOrLater)
+                itemView.setOnContextClickListener { v ->
+                    onMoreClick(v)
+                    true
+                }
+            binding.container.layoutParams.width = itemSize
+            binding.container.onFocusChangeListener = View.OnFocusChangeListener { _, hasFocus ->
+                if (hasFocus) {
+                    var newWidth = (itemSize * 1.1).toInt()
+                    if (newWidth % 2 == 1) {
+                        newWidth--
+                    }
+                    val scale = newWidth.toFloat() / itemSize
+                    binding.container.animate().scaleX(scale).scaleY(scale).translationZ(scale)
+
+                    eventsHandler.onItemFocused(binding.root, getItem(layoutPosition)!!)
+                    if (focusListener != null) {
+                        focusListener!!.onFocusChanged(layoutPosition)
+                    }
+
+                } else {
+                    binding.container.animate().scaleX(1f).scaleY(1f).translationZ(1f)
+                }
+            }
+            binding.container.clipToOutline = true
+
+        }
+
+        override fun recycle() {
+            if (mDefaultCover != null) binding.cover = mDefaultCover
+            binding.title.text = ""
+            binding.subtitle.text = ""
+        }
+
+        override fun setItem(item: MediaLibraryItem?) {
+            binding.item = item
+            var isSquare = true
+            var progress = 0
+            var seen = 0L
+            var description = item?.description
+            var resolution = ""
+            if (item is MediaWrapper) {
+                if (item.type == MediaWrapper.TYPE_VIDEO) {
+                    resolution = generateResolutionClass(item.width, item.height) ?: ""
+                    isSquare = false
+                    description = if (item.time == 0L) Tools.millisToString(item.length) else Tools.getProgressText(item)
+                    binding.badge = resolution
+                    seen = item.seen
+                    var max = 0
+
+
+                    if (item.length > 0) {
+                        val lastTime = item.displayTime
+                        if (lastTime > 0) {
+                            max = (item.length / 1000).toInt()
+                            progress = (lastTime / 1000).toInt()
+                        }
+                    }
+                    binding.max = max
+                }
+
+
+            }
+
+            binding.progress = progress
+            binding.isSquare = isSquare
+            binding.seen = seen
+            binding.description = description
+            if (seen == 0L) binding.mlItemSeen.visibility = View.GONE
+            if (progress <= 0L) binding.progressBar.visibility = View.GONE
+            binding.badgeTV.visibility = if (resolution.isBlank()) View.GONE else View.VISIBLE
+        }
+
+        @ObsoleteCoroutinesApi
+        override fun setCoverlay(selected: Boolean) {
+        }
+
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/TvItemAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/tv/TvItemAdapter.kt
index 4f98540005..1dcc7e1012 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/TvItemAdapter.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/TvItemAdapter.kt
@@ -1,246 +1,9 @@
 package org.videolan.vlc.gui.tv
 
-import android.annotation.TargetApi
-import android.content.Context
-import android.graphics.drawable.BitmapDrawable
-import android.os.Build
-import android.view.LayoutInflater
-import android.view.View
-import android.view.ViewGroup
-import androidx.databinding.ViewDataBinding
-import androidx.fragment.app.Fragment
-import androidx.paging.PagedListAdapter
-import androidx.recyclerview.widget.DiffUtil
-import kotlinx.coroutines.ExperimentalCoroutinesApi
-import kotlinx.coroutines.ObsoleteCoroutinesApi
-import org.videolan.libvlc.util.AndroidUtil
-import org.videolan.medialibrary.Tools
-import org.videolan.medialibrary.media.MediaLibraryItem
-import org.videolan.medialibrary.media.MediaWrapper
-import org.videolan.vlc.databinding.MediaBrowserTvItemBinding
-import org.videolan.vlc.gui.helpers.SelectorViewHolder
-import org.videolan.vlc.gui.helpers.getAudioIconDrawable
-import org.videolan.vlc.gui.view.FastScroller
-import org.videolan.vlc.interfaces.IEventsHandler
-import org.videolan.vlc.util.UPDATE_SELECTION
-import org.videolan.vlc.util.Util
-import org.videolan.vlc.util.generateResolutionClass
-
-@ExperimentalCoroutinesApi
-@ObsoleteCoroutinesApi
-class TvItemAdapter(type: Int, private val eventsHandler: IEventsHandler, var itemSize: Int) : PagedListAdapter<MediaLibraryItem, TvItemAdapter.AbstractMediaItemViewHolder<ViewDataBinding>>(TvItemAdapter.DIFF_CALLBACK), FastScroller.SeparatedAdapter {
-    var focusNext = -1
-    private val mDefaultCover: BitmapDrawable?
-    private var focusListener: FocusableRecyclerView.FocusListener? = null
-
-
-    init {
-        var ctx: Context? = null
-        if (eventsHandler is Context)
-            ctx = eventsHandler
-        else if (eventsHandler is Fragment) ctx = (eventsHandler as Fragment).context
-        mDefaultCover = if (ctx != null) getAudioIconDrawable(ctx, type) else null
-    }
-
-    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AbstractMediaItemViewHolder<ViewDataBinding> {
-        val inflater = parent.context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
-        val binding = MediaBrowserTvItemBinding.inflate(inflater, parent, false)
-        return MediaItemTVViewHolder(binding) as AbstractMediaItemViewHolder<ViewDataBinding>
-    }
-
-    override fun onBindViewHolder(holder: AbstractMediaItemViewHolder<ViewDataBinding>, position: Int) {
-        if (position >= itemCount) return
-        val item = getItem(position)
-        holder.setItem(item)
-        holder.binding.executePendingBindings()
-        if (position == focusNext) {
-            holder.binding.root.requestFocus()
-            focusNext = -1
-        }
-    }
-
-    override fun onBindViewHolder(holder: AbstractMediaItemViewHolder<ViewDataBinding>, position: Int, payloads: List<Any>) {
-        if (Util.isListEmpty(payloads))
-            onBindViewHolder(holder, position)
-        else {
-            val payload = payloads[0]
-            if (payload is MediaLibraryItem) {
-                val isSelected = payload.hasStateFlags(MediaLibraryItem.FLAG_SELECTED)
-                holder.setCoverlay(isSelected)
-                holder.selectView(isSelected)
-            } else if (payload is Int) {
-                if (payload == UPDATE_SELECTION) {
-                }
-            }
-        }
-    }
-
-    override fun hasSections(): Boolean {
-        return true
-    }
-
-    override fun getItem(position: Int): MediaLibraryItem? {
-        return super.getItem(position)
-    }
-
-
-    fun setOnFocusChangeListener(focusListener: FocusableRecyclerView.FocusListener?) {
-        this.focusListener = focusListener
-    }
-
-
-    companion object {
-
-        private val TAG = "VLC/AudioBrowserAdapter"
-        private const val UPDATE_PAYLOAD = 1
-        /**
-         * Awful hack to workaround the [PagedListAdapter] not keeping track of notifyItemMoved operations
-         */
-        private var preventNextAnim: Boolean = false
-
-        private val DIFF_CALLBACK = object : DiffUtil.ItemCallback<MediaLibraryItem>() {
-            override fun areItemsTheSame(
-                    oldMedia: MediaLibraryItem, newMedia: MediaLibraryItem): Boolean {
-                return if (preventNextAnim) {
-                    true
-                } else oldMedia === newMedia || oldMedia.itemType == newMedia.itemType && oldMedia.equals(newMedia)
-            }
-
-            override fun areContentsTheSame(
-                    oldMedia: MediaLibraryItem, newMedia: MediaLibraryItem): Boolean {
-                return false
-            }
-
-            override fun getChangePayload(oldItem: MediaLibraryItem, newItem: MediaLibraryItem): Any? {
-                preventNextAnim = false
-                return UPDATE_PAYLOAD
-            }
-        }
-    }
-
-
-    abstract inner class AbstractMediaItemViewHolder<T : ViewDataBinding> @TargetApi(Build.VERSION_CODES.M)
-    internal constructor(binding: T) : SelectorViewHolder<T>(binding), View.OnFocusChangeListener {
-
-
-        fun onClick(v: View) {
-            val item = getItem(layoutPosition)
-            if (item != null) eventsHandler.onClick(v, layoutPosition, item)
-        }
-
-        fun onMoreClick(v: View) {
-            val item = getItem(layoutPosition)
-            if (item != null) eventsHandler.onCtxClick(v, layoutPosition, item)
-        }
-
-        fun onLongClick(view: View): Boolean {
-            val item = getItem(layoutPosition)
-            return item != null && eventsHandler.onLongClick(view, layoutPosition, item)
-        }
-
-        fun onImageClick(v: View) {
-            val item = getItem(layoutPosition)
-            if (item != null) eventsHandler.onImageClick(v, layoutPosition, item)
-        }
-
-        fun onMainActionClick(v: View) {
-            val item = getItem(layoutPosition)
-            if (item != null) eventsHandler.onMainActionClick(v, layoutPosition, item)
-        }
-
-
-        abstract fun setItem(item: MediaLibraryItem?)
-
-        abstract fun recycle()
-
-        abstract fun setCoverlay(selected: Boolean)
-    }
-
-    inner class MediaItemTVViewHolder @TargetApi(Build.VERSION_CODES.M)
-    internal constructor(binding: MediaBrowserTvItemBinding) : AbstractMediaItemViewHolder<MediaBrowserTvItemBinding>(binding), View.OnFocusChangeListener {
-
-        init {
-            binding.holder = this
-            if (mDefaultCover != null) binding.cover = mDefaultCover
-            if (AndroidUtil.isMarshMallowOrLater)
-                itemView.setOnContextClickListener { v ->
-                    onMoreClick(v)
-                    true
-                }
-            binding.container.layoutParams.width = itemSize
-            binding.container.onFocusChangeListener = View.OnFocusChangeListener { _, hasFocus ->
-                if (hasFocus) {
-                    var newWidth = (itemSize * 1.1).toInt()
-                    if (newWidth % 2 == 1) {
-                        newWidth--
-                    }
-                    val scale = newWidth.toFloat() / itemSize
-                    binding.container.animate().scaleX(scale).scaleY(scale).translationZ(scale)
-
-                    eventsHandler.onItemFocused(binding.root, getItem(layoutPosition)!!)
-                    if (focusListener != null) {
-                        focusListener!!.onFocusChanged(layoutPosition)
-                    }
-
-                } else {
-                    binding.container.animate().scaleX(1f).scaleY(1f).translationZ(1f)
-                }
-            }
-            binding.container.clipToOutline = true
-
-        }
-
-        override fun recycle() {
-            if (mDefaultCover != null) binding.cover = mDefaultCover
-            binding.title.text = ""
-            binding.subtitle.text = ""
-        }
-
-        override fun setItem(item: MediaLibraryItem?) {
-            binding.item = item
-            var isSquare = true
-            var progress = 0
-            var seen = 0L
-            var description = item?.description
-            var resolution = ""
-            if (item is MediaWrapper) {
-                if (item.type == MediaWrapper.TYPE_VIDEO) {
-                    resolution = generateResolutionClass(item.width, item.height) ?: ""
-                    isSquare = false
-                    description = if (item.time == 0L) Tools.millisToString(item.length) else Tools.getProgressText(item)
-                    binding.badge = resolution
-                    seen = item.seen
-                    var max = 0
-
-
-                    if (item.length > 0) {
-                        val lastTime = item.displayTime
-                        if (lastTime > 0) {
-                            max = (item.length / 1000).toInt()
-                            progress = (lastTime / 1000).toInt()
-                        }
-                    }
-                    binding.max = max
-                }
-
-
-            }
-
-            binding.progress = progress
-            binding.isSquare = isSquare
-            binding.seen = seen
-            binding.description = description
-            if (seen == 0L) binding.mlItemSeen.visibility = View.GONE
-            if (progress <= 0L) binding.progressBar.visibility = View.GONE
-            binding.badgeTV.visibility = if (resolution.isBlank()) View.GONE else View.VISIBLE
-        }
-
-        @ObsoleteCoroutinesApi
-        override fun setCoverlay(selected: Boolean) {
-        }
-
-
-    }
+interface TvItemAdapter {
+    fun submitList(pagedList: Any?)
+    fun setOnFocusChangeListener(focusListener: FocusableRecyclerView.FocusListener?)
 
 
+    var focusNext: Int
 }
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/TvUtil.kt b/vlc-android/src/org/videolan/vlc/gui/tv/TvUtil.kt
index 6d0e4a4457..60c3152f4e 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/TvUtil.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/TvUtil.kt
@@ -249,8 +249,8 @@ object TvUtil {
             }
             else -> {
                 val intent = Intent(context, VerticalGridActivity::class.java)
-                intent.putExtra(AUDIO_ITEM, mediaLibraryItem)
-                intent.putExtra(AUDIO_CATEGORY, CATEGORY_ALBUMS)
+                intent.putExtra(ITEM, mediaLibraryItem)
+                intent.putExtra(CATEGORY, CATEGORY_ALBUMS)
                 intent.putExtra(MainTvActivity.BROWSER_TYPE, HEADER_CATEGORIES)
                 context.startActivity(intent)
             }
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/browser/BaseBrowserTvFragment.kt b/vlc-android/src/org/videolan/vlc/gui/tv/browser/BaseBrowserTvFragment.kt
new file mode 100644
index 0000000000..470567cca5
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/browser/BaseBrowserTvFragment.kt
@@ -0,0 +1,374 @@
+/*
+ * ************************************************************************
+ *  MediaBrowserTvFragment.kt
+ * *************************************************************************
+ *  Copyright Â© 2016-2019 VLC authors and VideoLAN
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *
+ *  *************************************************************************
+ */
+
+package org.videolan.vlc.gui.tv.browser
+
+import android.annotation.TargetApi
+import android.content.Intent
+import android.content.res.Configuration
+import android.graphics.Rect
+import android.os.Build
+import android.os.Bundle
+import android.util.Log
+import android.view.KeyEvent.*
+import android.view.LayoutInflater
+import android.view.MenuItem
+import android.view.View
+import android.view.ViewGroup
+import android.widget.PopupMenu
+import androidx.annotation.MainThread
+import androidx.constraintlayout.widget.ConstraintLayout
+import androidx.constraintlayout.widget.ConstraintSet
+import androidx.databinding.BindingAdapter
+import androidx.fragment.app.Fragment
+import androidx.leanback.app.BackgroundManager
+import androidx.recyclerview.widget.GridLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import kotlinx.android.synthetic.main.song_browser.*
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.MainScope
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.BuildConfig
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.tv.*
+import org.videolan.vlc.gui.tv.browser.interfaces.BrowserFragmentInterface
+import org.videolan.vlc.gui.view.RecyclerSectionItemGridDecoration
+import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.util.RefreshModel
+import org.videolan.vlc.util.getScreenWidth
+import org.videolan.vlc.viewmodels.tv.TvBrowserModel
+
+private const val TAG = "MediaBrowserTvFragment"
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+abstract class BaseBrowserTvFragment : Fragment(), BrowserFragmentInterface, IEventsHandler,
+        PopupMenu.OnMenuItemClickListener, MediaHeaderAdapter.OnHeaderSelected,
+        VerticalGridActivity.OnKeyPressedListener, CoroutineScope by MainScope() {
+
+    abstract fun getTitle(): String
+    abstract fun getColumnNumber(): Int
+    abstract fun provideAdapter(eventsHandler: IEventsHandler, itemSize: Int): TvItemAdapter
+
+
+    lateinit var viewModel: TvBrowserModel
+    private var spacing: Int = 0
+    abstract var adapter: TvItemAdapter
+    lateinit var headerAdapter: MediaHeaderAdapter
+    private lateinit var gridLayoutManager: GridLayoutManager
+    private var currentArt: String? = null
+    private lateinit var backgroundManager: BackgroundManager
+    internal lateinit var animationDelegate: MediaBrowserAnimatorDelegate
+
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        return inflater.inflate(R.layout.song_browser, container, false)
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+
+        backgroundManager = BackgroundManager.getInstance(requireActivity())
+
+
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+
+        //overscan
+        val hp = TvUtil.getOverscanHorizontal(requireContext())
+        val vp = TvUtil.getOverscanVertical(requireContext())
+        headerList.setPadding(list.paddingLeft + hp, list.paddingTop + vp, list.paddingRight + hp, list.paddingBottom + vp)
+
+
+        val lp = (imageButtonSettings.layoutParams as ConstraintLayout.LayoutParams)
+        lp.leftMargin += hp
+        lp.rightMargin += hp
+        lp.topMargin += vp
+        lp.bottomMargin += vp
+
+
+
+        calculateNbColumns()
+
+        title.text = if (viewModel.currentItem != null) {
+            viewModel.currentItem!!.title
+        } else getTitle()
+
+
+        val searchHeaderClick: (View) -> Unit = { animationDelegate.hideFAB() }
+
+        val sortClick: (View) -> Unit = { v ->
+            animationDelegate.setVisibility(headerButton, View.GONE)
+            sort(v)
+        }
+
+        headerButton.setOnClickListener(searchHeaderClick)
+        imageButtonHeader.setOnClickListener(searchHeaderClick)
+
+        sortButton.setOnClickListener(sortClick)
+        imageButtonSort.setOnClickListener(sortClick)
+
+
+        gridLayoutManager = object : GridLayoutManager(requireActivity(), viewModel.nbColumns) {
+            override fun requestChildRectangleOnScreen(parent: RecyclerView, child: View, rect: Rect, immediate: Boolean) = false
+
+            override fun requestChildRectangleOnScreen(parent: RecyclerView, child: View, rect: Rect, immediate: Boolean, focusedChildVisible: Boolean) = false
+        }
+
+        spacing = resources.getDimensionPixelSize(R.dimen.kl_small)
+
+        //size of an item
+        val itemSize = (requireActivity().getScreenWidth() - list.paddingLeft - list.paddingRight) / viewModel.nbColumns - spacing * 2
+
+        gridLayoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
+            override fun getSpanSize(position: Int): Int {
+
+                if (position == (adapter as RecyclerView.Adapter<*>).itemCount - 1) {
+                    return 1
+                }
+                if (viewModel.provider.isFirstInSection(position + 1)) {
+
+                    //calculate how many cell it must take
+                    val firstSection = viewModel.provider.getPositionForSection(position)
+                    val nbItems = position - firstSection
+                    if (BuildConfig.DEBUG)
+                        Log.d("SongsBrowserFragment", "Position: " + position + " nb items: " + nbItems + " span: " + (viewModel.nbColumns - nbItems % viewModel.nbColumns))
+
+                    return viewModel.nbColumns - nbItems % viewModel.nbColumns
+                }
+                return 1
+            }
+        }
+
+        list.layoutManager = gridLayoutManager
+
+        adapter = provideAdapter(this, itemSize)
+
+        list.addItemDecoration(RecyclerSectionItemGridDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_tv_height), spacing, true, viewModel.nbColumns, viewModel.provider))
+
+        //header list
+        headerListContainer.visibility = View.GONE
+        headerAdapter = MediaHeaderAdapter(this)
+        headerList.adapter = headerAdapter
+        headerList.addItemDecoration(object : RecyclerView.ItemDecoration() {
+            override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) {
+                super.getItemOffsets(outRect, view, parent, state)
+                outRect.bottom = 2
+                outRect.top = 2
+                outRect.left = 2
+                outRect.right = 2
+            }
+        })
+        setAnimator(view as ConstraintLayout)
+        super.onViewCreated(view, savedInstanceState)
+    }
+
+    private fun calculateNbColumns() {
+        viewModel.nbColumns = getColumnNumber()
+    }
+
+
+    override fun onConfigurationChanged(newConfig: Configuration?) {
+        super.onConfigurationChanged(newConfig)
+
+        calculateNbColumns()
+        gridLayoutManager.spanCount = viewModel.nbColumns
+        if (BuildConfig.DEBUG) Log.d(TAG, "${viewModel.nbColumns}");
+        list.layoutManager = gridLayoutManager
+    }
+
+    override fun onActivityCreated(savedInstanceState: Bundle?) {
+        list.adapter = adapter as RecyclerView.Adapter<*>
+        if (!backgroundManager.isAttached) {
+            backgroundManager.attachToView(view)
+        }
+        super.onActivityCreated(savedInstanceState)
+    }
+
+
+    override fun refresh() = (viewModel as RefreshModel).refresh()
+
+
+    override fun onLongClick(v: View, position: Int, item: MediaLibraryItem): Boolean {
+
+        if (item is MediaWrapper) {
+
+            val intent = Intent(requireActivity(), DetailsActivity::class.java)
+            // pass the item information
+            intent.putExtra("media", item)
+            intent.putExtra("item", MediaItemDetails(item.title, item.artist, item.album, item.location, item.artworkURL))
+            startActivity(intent)
+        }
+
+
+        return true
+    }
+
+    override fun onCtxClick(v: View, position: Int, item: MediaLibraryItem) {}
+
+    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {}
+
+    override fun onImageClick(v: View, position: Int, item: MediaLibraryItem) {}
+
+
+    override fun onItemFocused(v: View, item: MediaLibraryItem) {
+        (item as? MediaLibraryItem)?.run {
+            if (currentArt == artworkMrl) return@run
+            currentArt = artworkMrl
+            TvUtil.updateBackground(backgroundManager, this)
+        }
+    }
+
+    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
+
+    fun sort(v: View) {
+        val menu = PopupMenu(v.context, v)
+        menu.inflate(R.menu.sort_options)
+        menu.menu.findItem(R.id.ml_menu_sortby_filename).isVisible = viewModel.canSortByFileNameName()
+        menu.menu.findItem(R.id.ml_menu_sortby_length).isVisible = viewModel.canSortByDuration()
+        menu.menu.findItem(R.id.ml_menu_sortby_date).isVisible = viewModel.canSortByInsertionDate() || viewModel.canSortByReleaseDate() || viewModel.canSortByLastModified()
+        menu.menu.findItem(R.id.ml_menu_sortby_date).isVisible = viewModel.canSortByReleaseDate()
+        menu.menu.findItem(R.id.ml_menu_sortby_last_modified).isVisible = viewModel.canSortByLastModified()
+        menu.menu.findItem(R.id.ml_menu_sortby_number).isVisible = false
+        menu.setOnMenuItemClickListener(this)
+        menu.show()
+    }
+
+    override fun onMenuItemClick(item: MenuItem): Boolean {
+        animationDelegate.collapseExtendedFAB()
+        when (item.itemId) {
+            R.id.ml_menu_sortby_name -> {
+                sortBy(Medialibrary.SORT_ALPHA)
+                return true
+            }
+            R.id.ml_menu_sortby_filename -> {
+                sortBy(Medialibrary.SORT_FILENAME)
+                return true
+            }
+            R.id.ml_menu_sortby_length -> {
+                sortBy(Medialibrary.SORT_DURATION)
+                return true
+            }
+            R.id.ml_menu_sortby_date -> {
+                sortBy(Medialibrary.SORT_RELEASEDATE)
+                return true
+            }
+            R.id.ml_menu_sortby_last_modified -> {
+                sortBy(Medialibrary.SORT_LASTMODIFICATIONDATE)
+                return true
+            }
+            R.id.ml_menu_sortby_artist_name -> {
+                sortBy(Medialibrary.SORT_ARTIST)
+                return true
+            }
+            R.id.ml_menu_sortby_album_name -> {
+                sortBy(Medialibrary.SORT_ALBUM)
+                return true
+            }
+            R.id.ml_menu_sortby_number -> {
+                sortBy(Medialibrary.SORT_FILESIZE)
+                return super.onOptionsItemSelected(item)
+            }
+            else -> return super.onOptionsItemSelected(item)
+        }
+    }
+
+    private fun sortBy(sort: Int) = viewModel.sort(sort)
+
+    override fun onHeaderSelected(header: String) {
+        hideHeaderSelectionScreen()
+
+        val positionForSectionByName = viewModel.provider.getPositionForSectionByName(header)
+        if (list.getChildAt(positionForSectionByName) == null) {
+            adapter.focusNext = positionForSectionByName
+        } else {
+            list.getChildAt(positionForSectionByName).requestFocus()
+        }
+        list.scrollToPosition(positionForSectionByName)
+    }
+
+    private fun hideHeaderSelectionScreen() {
+        headerListContainer.visibility = View.GONE
+        list.visibility = View.VISIBLE
+        animationDelegate.showFAB()
+    }
+
+    private var lastDpadEventTime = 0L
+    override fun onKeyPressed(keyCode: Int) = when (keyCode) {
+        KEYCODE_MENU -> {
+            imageButtonSettings.requestFocusFromTouch()
+            animationDelegate.expandExtendedFAB()
+            true
+        }
+        KEYCODE_BACK -> {
+            if (headerListContainer != null && headerListContainer.visibility == View.VISIBLE) {
+                hideHeaderSelectionScreen()
+                true
+            } else false
+        }
+        /**
+         * mitigate the perf issue when scrolling fast with d-pad
+         */
+        KEYCODE_DPAD_DOWN, KEYCODE_DPAD_UP -> {
+            val now = System.currentTimeMillis()
+            if (now - lastDpadEventTime > 200) {
+                lastDpadEventTime = now
+                if (BuildConfig.DEBUG) Log.d("keydown", "Keydown propagated");
+                false
+            } else true
+        }
+        else -> false
+    }
+
+    fun submitList(pagedList: Any) {
+        adapter.submitList(pagedList)
+
+        animationDelegate.setVisibility(imageButtonHeader, if (viewModel.provider.headers.isEmpty) View.GONE else View.VISIBLE)
+        animationDelegate.setVisibility(headerButton, if (viewModel.provider.headers.isEmpty) View.GONE else View.VISIBLE)
+        animationDelegate.setVisibility(headerDescription, if (viewModel.provider.headers.isEmpty) View.GONE else View.VISIBLE)
+
+
+    }
+}
+
+
+@MainThread
+@BindingAdapter("constraintRatio")
+fun constraintRatio(v: View, isSquare: Boolean) {
+    val constraintLayout = v.parent as? ConstraintLayout
+    constraintLayout?.let {
+        val constraintSet = ConstraintSet()
+        constraintSet.clone(constraintLayout)
+        constraintSet.setDimensionRatio(v.id, if (isSquare) "1" else "16:10")
+        constraintLayout.setConstraintSet(constraintSet)
+
+    }
+
+
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/browser/FileBrowserTvFragment.kt b/vlc-android/src/org/videolan/vlc/gui/tv/browser/FileBrowserTvFragment.kt
new file mode 100644
index 0000000000..df235e58af
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/browser/FileBrowserTvFragment.kt
@@ -0,0 +1,143 @@
+package org.videolan.vlc.gui.tv.browser
+
+import android.os.Bundle
+import android.os.Parcelable
+import android.util.Log
+import android.view.View
+import androidx.lifecycle.Observer
+import androidx.recyclerview.widget.GridLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import kotlinx.android.synthetic.main.song_browser.*
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.BuildConfig
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.tv.FileTvItemAdapter
+import org.videolan.vlc.gui.tv.TvItemAdapter
+import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.providers.BrowserProvider
+import org.videolan.vlc.util.CATEGORY
+import org.videolan.vlc.util.ITEM
+import org.videolan.vlc.viewmodels.browser.BrowserModel
+import org.videolan.vlc.viewmodels.browser.TYPE_FILE
+import org.videolan.vlc.viewmodels.browser.TYPE_NETWORK
+import org.videolan.vlc.viewmodels.browser.getBrowserModel
+import java.util.*
+
+@UseExperimental(ObsoleteCoroutinesApi::class)
+@ExperimentalCoroutinesApi
+class FileBrowserTvFragment : BaseBrowserTvFragment() {
+    private var item: MediaLibraryItem? = null
+    override lateinit var adapter: TvItemAdapter
+
+    override fun getTitle(): String =
+            when (getCategory()) {
+                TYPE_FILE -> getString(R.string.directories)
+                TYPE_NETWORK -> getString(R.string.network_browsing)
+                else -> getString(R.string.video)
+            }
+
+    override fun getColumnNumber(): Int =
+            resources.getInteger(R.integer.tv_songs_col_count)
+
+    companion object {
+        fun newInstance(type: Int, item: MediaLibraryItem?) =
+                FileBrowserTvFragment().apply {
+                    arguments = Bundle().apply {
+                        this.putInt(CATEGORY, type)
+                        this.putParcelable(ITEM, item)
+                    }
+                }
+    }
+
+    override fun provideAdapter(eventsHandler: IEventsHandler, itemSize: Int): TvItemAdapter {
+        return FileTvItemAdapter(MediaLibraryItem.TYPE_MEDIA, this, itemSize)
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        item = if (savedInstanceState != null) savedInstanceState.getParcelable<Parcelable>(ITEM) as? MediaLibraryItem
+        else arguments?.getParcelable(ITEM) as? MediaLibraryItem
+        viewModel = getBrowserModel(getCategory(), (item as? MediaWrapper)?.location, true, false)
+
+        viewModel.currentItem = item
+
+
+        (viewModel.provider as BrowserProvider).dataset.observe(this, Observer { items ->
+            submitList(items)
+            if (BuildConfig.DEBUG) Log.d("FileBrowserTvFragment", "Submit lis of ${items.size} items")
+
+            //headers
+            val nbColumns = if ((viewModel as BrowserModel).sort == Medialibrary.SORT_ALPHA) 9 else 1
+
+            headerList.layoutManager = GridLayoutManager(requireActivity(), nbColumns)
+            headerAdapter.sortType = (viewModel as BrowserModel).sort
+            val headerItems = ArrayList<String>()
+            viewModel.provider.liveHeaders.value?.run {
+                for (i in 0 until size()) {
+                    headerItems.add(valueAt(i))
+                }
+            }
+            headerAdapter.items = headerItems
+            headerAdapter.notifyDataSetChanged()
+        })
+
+        (viewModel as BrowserModel).getDescriptionUpdate().observe(this, Observer { pair ->
+            if (BuildConfig.DEBUG) Log.d("FileBrowserTvFragment", "Description update: ${pair.first} ${pair.second}")
+            if (pair != null) (adapter as RecyclerView.Adapter<*>).notifyItemChanged(pair.first, pair.second)
+        })
+
+
+    }
+
+    override fun onResume() {
+        super.onResume()
+
+        if (item == null)
+            (viewModel.provider as BrowserProvider).browseRoot()
+        else
+            refresh()
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        outState.putParcelable(ITEM, item)
+        outState.putInt(CATEGORY, getCategory())
+        super.onSaveInstanceState(outState)
+    }
+
+
+    override fun onStop() {
+        super.onStop()
+        (viewModel as BrowserModel).stop()
+    }
+
+
+    private fun getCategory() = arguments?.getInt(CATEGORY, TYPE_FILE) ?: TYPE_FILE
+
+    override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
+        val mediaWrapper = item as MediaWrapper
+
+        mediaWrapper.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+        if (mediaWrapper.type == MediaWrapper.TYPE_DIR) browse(mediaWrapper, true)
+        else MediaUtils.openMedia(v.context, mediaWrapper)
+
+        //todo
+//         launch { TvUtil.openMediaFromPaged(requireActivity(), item, viewModel.provider as MedialibraryProvider<out MediaLibraryItem>) }
+    }
+
+    fun browse(media: MediaWrapper, save: Boolean) {
+        val ctx = activity
+        if (ctx == null || !isResumed || isRemoving) return
+        val ft = ctx.supportFragmentManager.beginTransaction()
+        val next = newInstance(getCategory(), media)
+        (viewModel as BrowserModel).saveList(media)
+        if (save) ft.addToBackStack(media.title)
+        ft.replace(R.id.tv_fragment_placeholder, next, media.title)
+        ft.commit()
+    }
+
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/browser/MediaBrowserTvFragment.kt b/vlc-android/src/org/videolan/vlc/gui/tv/browser/MediaBrowserTvFragment.kt
index e16a57d3ef..d661b8ed6f 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/browser/MediaBrowserTvFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/browser/MediaBrowserTvFragment.kt
@@ -1,401 +1,96 @@
-/*
- * ************************************************************************
- *  MediaBrowserTvFragment.kt
- * *************************************************************************
- *  Copyright Â© 2016-2019 VLC authors and VideoLAN
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *
- *  *************************************************************************
- */
-
 package org.videolan.vlc.gui.tv.browser
 
-import android.annotation.TargetApi
-import android.content.Intent
-import android.content.res.Configuration
-import android.graphics.Rect
-import android.os.Build
 import android.os.Bundle
 import android.os.Parcelable
-import android.util.Log
-import android.view.KeyEvent.*
-import android.view.LayoutInflater
-import android.view.MenuItem
 import android.view.View
-import android.view.ViewGroup
-import android.widget.PopupMenu
-import androidx.annotation.MainThread
-import androidx.constraintlayout.widget.ConstraintLayout
-import androidx.constraintlayout.widget.ConstraintSet
-import androidx.databinding.BindingAdapter
-import androidx.fragment.app.Fragment
-import androidx.leanback.app.BackgroundManager
 import androidx.lifecycle.Observer
-import androidx.paging.PagedList
 import androidx.recyclerview.widget.GridLayoutManager
-import androidx.recyclerview.widget.RecyclerView
 import kotlinx.android.synthetic.main.song_browser.*
-import kotlinx.coroutines.*
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import kotlinx.coroutines.launch
 import org.videolan.medialibrary.Medialibrary
 import org.videolan.medialibrary.media.MediaLibraryItem
-import org.videolan.medialibrary.media.MediaWrapper
-import org.videolan.vlc.BuildConfig
 import org.videolan.vlc.R
-import org.videolan.vlc.gui.tv.*
-import org.videolan.vlc.gui.tv.browser.interfaces.BrowserFragmentInterface
-import org.videolan.vlc.gui.view.RecyclerSectionItemGridDecoration
+import org.videolan.vlc.gui.tv.MediaTvItemAdapter
+import org.videolan.vlc.gui.tv.TvItemAdapter
+import org.videolan.vlc.gui.tv.TvUtil
 import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.providers.medialibrary.MedialibraryProvider
 import org.videolan.vlc.util.*
 import org.videolan.vlc.viewmodels.tv.MediaBrowserViewModel
 import org.videolan.vlc.viewmodels.tv.getMediaBrowserModel
 import java.util.*
 
-private const val TAG = "MediaBrowserTvFragment"
-
+@UseExperimental(ObsoleteCoroutinesApi::class)
 @ExperimentalCoroutinesApi
-@ObsoleteCoroutinesApi
-@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-class MediaBrowserTvFragment : Fragment(), BrowserFragmentInterface, IEventsHandler,
-        PopupMenu.OnMenuItemClickListener, MediaHeaderAdapter.OnHeaderSelected,
-        VerticalGridActivity.OnKeyPressedListener, CoroutineScope by MainScope() {
+class MediaBrowserTvFragment : BaseBrowserTvFragment() {
+    override fun provideAdapter(eventsHandler: IEventsHandler, itemSize: Int): TvItemAdapter {
+        return MediaTvItemAdapter(MediaLibraryItem.TYPE_MEDIA, this, itemSize)
+    }
+
+    override lateinit var adapter: TvItemAdapter
+
+
+    override fun getTitle(): String =
+            when (arguments?.getLong(CATEGORY, CATEGORY_SONGS)) {
+                CATEGORY_SONGS -> getString(R.string.tracks)
+                CATEGORY_ALBUMS -> getString(R.string.albums)
+                CATEGORY_ARTISTS -> getString(R.string.artists)
+                CATEGORY_GENRES -> getString(R.string.genres)
+                else -> getString(R.string.video)
+            }
+
+    override fun getColumnNumber(): Int =
+            when (arguments?.getLong(CATEGORY, CATEGORY_SONGS)) {
 
-    private var spacing: Int = 0
-    private lateinit var viewModel: MediaBrowserViewModel
-    private lateinit var adapter: TvItemAdapter
-    //    private lateinit var headerList: RecyclerView
-    private lateinit var headerAdapter: MediaHeaderAdapter
-    private lateinit var gridLayoutManager: GridLayoutManager
-    private var currentArt: String? = null
-    private lateinit var backgroundManager: BackgroundManager
-    internal lateinit var animationDelegate: MediaBrowserAnimatorDelegate
+                CATEGORY_VIDEOS -> resources.getInteger(R.integer.tv_videos_col_count)
+                else -> resources.getInteger(R.integer.tv_songs_col_count)
+            }
 
     companion object {
         fun newInstance(type: Long, item: MediaLibraryItem?) =
                 MediaBrowserTvFragment().apply {
                     arguments = Bundle().apply {
-                        this.putLong(AUDIO_CATEGORY, type)
-                        this.putParcelable(AUDIO_ITEM, item)
+                        this.putLong(CATEGORY, type)
+                        this.putParcelable(ITEM, item)
                     }
                 }
     }
 
-
-    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
-        return inflater.inflate(R.layout.song_browser, container, false)
-    }
-
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
 
-        backgroundManager = BackgroundManager.getInstance(requireActivity())
 
-        val category = arguments?.getLong(AUDIO_CATEGORY, CATEGORY_SONGS) ?: CATEGORY_SONGS
+        viewModel = getMediaBrowserModel(arguments?.getLong(CATEGORY, CATEGORY_SONGS)
+                ?: CATEGORY_SONGS)
 
-        viewModel = getMediaBrowserModel(category)
+        viewModel.currentItem = if (savedInstanceState != null) savedInstanceState.getParcelable<Parcelable>(ITEM) as? MediaLibraryItem
+        else requireActivity().intent.getParcelableExtra<Parcelable>(ITEM) as? MediaLibraryItem
 
-        viewModel.currentItem = if (savedInstanceState != null) savedInstanceState.getParcelable<Parcelable>(AUDIO_ITEM) as? MediaLibraryItem
-        else requireActivity().intent.getParcelableExtra<Parcelable>(AUDIO_ITEM) as? MediaLibraryItem
-
-        viewModel.provider.pagedList.observe(this, Observer { items ->
-            @Suppress("UNCHECKED_CAST")
-            adapter.submitList(items as PagedList<MediaLibraryItem>?)
+        (viewModel.provider as MedialibraryProvider<*>).pagedList.observe(this, Observer { items ->
+            submitList(items)
 
             //headers
-            val nbColumns = if (viewModel.sort == Medialibrary.SORT_ALPHA ) 9 else 1
+            val nbColumns = if ((viewModel as MediaBrowserViewModel).sort == Medialibrary.SORT_ALPHA) 9 else 1
 
             headerList.layoutManager = GridLayoutManager(requireActivity(), nbColumns)
-            headerAdapter.sortType = viewModel.sort
+            headerAdapter.sortType = (viewModel as MediaBrowserViewModel).sort
             val headerItems = ArrayList<String>()
             viewModel.provider.liveHeaders.value?.run {
-                for (i in 0 until size()) { headerItems.add(valueAt(i)) }
+                for (i in 0 until size()) {
+                    headerItems.add(valueAt(i))
+                }
             }
             headerAdapter.items = headerItems
             headerAdapter.notifyDataSetChanged()
         })
 
-    }
-
-    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
-
-        //overscan
-        val hp = TvUtil.getOverscanHorizontal(requireContext())
-        val vp = TvUtil.getOverscanVertical(requireContext())
-        headerList.setPadding(list.paddingLeft + hp, list.paddingTop + vp, list.paddingRight + hp, list.paddingBottom + vp)
-
-
-        val lp = (imageButtonSettings.layoutParams as ConstraintLayout.LayoutParams)
-        lp.leftMargin += hp
-        lp.rightMargin += hp
-        lp.topMargin += vp
-        lp.bottomMargin += vp
-
-
-
-        calculateNbColumns()
-
-        if (viewModel.currentItem != null) {
-            title.text = viewModel.currentItem!!.title
-        } else when (arguments?.getLong(AUDIO_CATEGORY, CATEGORY_SONGS)) {
-            CATEGORY_SONGS -> title.setText(R.string.tracks)
-            CATEGORY_ALBUMS -> title.setText(R.string.albums)
-            CATEGORY_ARTISTS -> title.setText(R.string.artists)
-            CATEGORY_GENRES -> title.setText(R.string.genres)
-            CATEGORY_VIDEOS -> title.setText(R.string.video)
-        }
-
-        val searchHeaderClick: (View) -> Unit = { animationDelegate.hideFAB() }
-
-        val sortClick: (View) -> Unit = { v -> sort(v) }
-
-        headerButton.setOnClickListener(searchHeaderClick)
-        imageButtonHeader.setOnClickListener(searchHeaderClick)
-
-        sortButton.setOnClickListener(sortClick)
-        imageButtonSort.setOnClickListener(sortClick)
-
-
-        gridLayoutManager = object : GridLayoutManager(requireActivity(), viewModel.nbColumns) {
-            override fun requestChildRectangleOnScreen(parent: RecyclerView, child: View, rect: Rect, immediate: Boolean) = false
-
-            override fun requestChildRectangleOnScreen(parent: RecyclerView, child: View, rect: Rect, immediate: Boolean, focusedChildVisible: Boolean) = false
-        }
-
-        spacing = resources.getDimensionPixelSize(R.dimen.kl_small)
-
-        //size of an item
-        val itemSize = (requireActivity().getScreenWidth() - list.paddingLeft - list.paddingRight) / viewModel.nbColumns - spacing * 2
-
-        gridLayoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
-            override fun getSpanSize(position: Int): Int {
-
-                if (position == adapter.itemCount - 1) {
-                    return 1
-                }
-                if (viewModel.provider.isFirstInSection(position + 1)) {
-
-                    //calculate how many cell it must take
-                    val firstSection = viewModel.provider.getPositionForSection(position)
-                    val nbItems = position - firstSection
-                    if (BuildConfig.DEBUG)
-                        Log.d("SongsBrowserFragment", "Position: " + position + " nb items: " + nbItems + " span: " + (viewModel.nbColumns - nbItems % viewModel.nbColumns))
-
-                    return viewModel.nbColumns - nbItems % viewModel.nbColumns
-                }
-                return 1
-            }
-        }
-
-        list.layoutManager = gridLayoutManager
-
-        adapter = TvItemAdapter(MediaLibraryItem.TYPE_MEDIA, this, itemSize)
-
-        list.addItemDecoration(RecyclerSectionItemGridDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_tv_height), spacing, true, viewModel.nbColumns, viewModel.provider))
-
-        //header list
-        headerListContainer.visibility = View.GONE
-        headerAdapter = MediaHeaderAdapter(this)
-        headerList.adapter = headerAdapter
-        headerList.addItemDecoration(object : RecyclerView.ItemDecoration() {
-            override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State) {
-                super.getItemOffsets(outRect, view, parent, state)
-                outRect.bottom = 2
-                outRect.top = 2
-                outRect.left = 2
-                outRect.right = 2
-            }
-        })
-        setAnimator(view as ConstraintLayout)
-        super.onViewCreated(view, savedInstanceState)
-    }
-
-    private fun calculateNbColumns() {
-        viewModel.nbColumns = when (arguments?.getLong(AUDIO_CATEGORY, CATEGORY_SONGS)) {
 
-            CATEGORY_VIDEOS -> resources.getInteger(R.integer.tv_videos_col_count)
-            else -> resources.getInteger(R.integer.tv_songs_col_count)
-        }
     }
 
-
-    override fun onConfigurationChanged(newConfig: Configuration?) {
-        super.onConfigurationChanged(newConfig)
-
-        calculateNbColumns()
-        gridLayoutManager.spanCount = viewModel.nbColumns
-        if (BuildConfig.DEBUG) Log.d(TAG, "${viewModel.nbColumns}");
-        list.layoutManager = gridLayoutManager
-    }
-
-    override fun onActivityCreated(savedInstanceState: Bundle?) {
-        list.adapter = adapter
-        backgroundManager.attachToView(view)
-        super.onActivityCreated(savedInstanceState)
-    }
-
-
-    override fun refresh() = viewModel.refresh()
-
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
-        launch { TvUtil.openMediaFromPaged(requireActivity(), item, viewModel.provider) }
-    }
-
-    override fun onLongClick(v: View, position: Int, item: MediaLibraryItem): Boolean {
-
-        if (item is MediaWrapper) {
-
-            val intent = Intent(requireActivity(), DetailsActivity::class.java)
-            // pass the item information
-            intent.putExtra("media", item)
-            intent.putExtra("item", MediaItemDetails(item.title, item.artist, item.album, item.location, item.artworkURL))
-            startActivity(intent)
-        }
-
-
-        return true
-    }
-
-    override fun onCtxClick(v: View, position: Int, item: MediaLibraryItem) {}
-
-    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {}
-
-    override fun onImageClick(v: View, position: Int, item: MediaLibraryItem) {}
-
-
-    override fun onItemFocused(v: View, item: MediaLibraryItem) {
-        (item as? MediaLibraryItem)?.run {
-            if (currentArt == artworkMrl) return@run
-            currentArt = artworkMrl
-            TvUtil.updateBackground(backgroundManager, this)
-        }
-    }
-
-    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
-
-    fun sort(v: View) {
-        val menu = PopupMenu(v.context, v)
-        menu.inflate(R.menu.sort_options)
-        menu.menu.findItem(R.id.ml_menu_sortby_filename).isVisible = viewModel.canSortByFileNameName()
-        menu.menu.findItem(R.id.ml_menu_sortby_length).isVisible = viewModel.canSortByDuration()
-        menu.menu.findItem(R.id.ml_menu_sortby_date).isVisible = viewModel.canSortByInsertionDate() || viewModel.canSortByReleaseDate() || viewModel.canSortByLastModified()
-        menu.menu.findItem(R.id.ml_menu_sortby_date).isVisible = viewModel.canSortByReleaseDate()
-        menu.menu.findItem(R.id.ml_menu_sortby_last_modified).isVisible = viewModel.canSortByLastModified()
-        menu.menu.findItem(R.id.ml_menu_sortby_number).isVisible = false
-        menu.setOnMenuItemClickListener(this)
-        menu.show()
+        launch { TvUtil.openMediaFromPaged(requireActivity(), item, viewModel.provider as MedialibraryProvider<out MediaLibraryItem>) }
     }
 
-    override fun onMenuItemClick(item: MenuItem): Boolean {
-        animationDelegate.collapseExtendedFAB()
-        when (item.itemId) {
-            R.id.ml_menu_sortby_name -> {
-                sortBy(Medialibrary.SORT_ALPHA)
-                return true
-            }
-            R.id.ml_menu_sortby_filename -> {
-                sortBy(Medialibrary.SORT_FILENAME)
-                return true
-            }
-            R.id.ml_menu_sortby_length -> {
-                sortBy(Medialibrary.SORT_DURATION)
-                return true
-            }
-            R.id.ml_menu_sortby_date -> {
-                sortBy(Medialibrary.SORT_RELEASEDATE)
-                return true
-            }
-            R.id.ml_menu_sortby_last_modified -> {
-                sortBy(Medialibrary.SORT_LASTMODIFICATIONDATE)
-                return true
-            }
-            R.id.ml_menu_sortby_artist_name -> {
-                sortBy(Medialibrary.SORT_ARTIST)
-                return true
-            }
-            R.id.ml_menu_sortby_album_name -> {
-                sortBy(Medialibrary.SORT_ALBUM)
-                return true
-            }
-            R.id.ml_menu_sortby_number -> {
-                sortBy(Medialibrary.SORT_FILESIZE)
-                return super.onOptionsItemSelected(item)
-            }
-            else -> return super.onOptionsItemSelected(item)
-        }
-    }
-
-    private fun sortBy(sort: Int) = viewModel.sort(sort)
-
-    override fun onHeaderSelected(header: String) {
-        hideHeaderSelectionScreen()
-
-        val positionForSectionByName = viewModel.provider.getPositionForSectionByName(header)
-        if (list.getChildAt(positionForSectionByName) == null) {
-            adapter.focusNext = positionForSectionByName
-        } else {
-            list.getChildAt(positionForSectionByName).requestFocus()
-        }
-        list.scrollToPosition(positionForSectionByName)
-    }
-
-    private fun hideHeaderSelectionScreen() {
-        headerListContainer.visibility = View.GONE
-        list.visibility = View.VISIBLE
-        animationDelegate.showFAB()
-    }
-
-    private var lastDpadEventTime = 0L
-    override fun onKeyPressed(keyCode: Int) = when (keyCode) {
-        KEYCODE_MENU -> {
-            imageButtonSettings.requestFocusFromTouch()
-            animationDelegate.expandExtendedFAB()
-            true
-        }
-        KEYCODE_BACK -> {
-            if (headerListContainer.visibility == View.VISIBLE) {
-                hideHeaderSelectionScreen()
-                true
-            } else false
-        }
-        /**
-         * mitigate the perf issue when scrolling fast with d-pad
-         */
-        KEYCODE_DPAD_DOWN, KEYCODE_DPAD_UP -> {
-            val now = System.currentTimeMillis()
-            if (now - lastDpadEventTime > 200) {
-                lastDpadEventTime = now
-                if (BuildConfig.DEBUG) Log.d("keydown", "Keydown propagated");
-                false
-            } else true
-        }
-        else -> false
-    }
-}
-
-
-@MainThread
-@BindingAdapter("constraintRatio")
-fun constraintRatio(v: View, isSquare: Boolean) {
-    val constraintLayout = v.parent as? ConstraintLayout
-    constraintLayout?.let {
-        val constraintSet = ConstraintSet()
-        constraintSet.clone(constraintLayout)
-        constraintSet.setDimensionRatio(v.id, if (isSquare) "1" else "16:10")
-        constraintLayout.setConstraintSet(constraintSet)
-
-    }
-
-
 }
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/browser/VerticalGridActivity.kt b/vlc-android/src/org/videolan/vlc/gui/tv/browser/VerticalGridActivity.kt
index 2d23d3797a..adecdfad3d 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/browser/VerticalGridActivity.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/browser/VerticalGridActivity.kt
@@ -37,6 +37,7 @@ import org.videolan.vlc.gui.tv.browser.interfaces.BrowserFragmentInterface
 import org.videolan.vlc.gui.tv.browser.interfaces.DetailsFragment
 import org.videolan.vlc.interfaces.Sortable
 import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.browser.TYPE_FILE
 
 @ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
@@ -53,8 +54,8 @@ class VerticalGridActivity : BaseTvActivity(), BrowserActivityInterface {
             if (type == HEADER_VIDEO) {
                 fragment = MediaBrowserTvFragment.newInstance(CATEGORY_VIDEOS, null)
             } else if (type == HEADER_CATEGORIES) {
-                val audioCategory = intent.getLongExtra(AUDIO_CATEGORY, CATEGORY_SONGS)
-                val item = intent.getParcelableExtra<MediaLibraryItem>(AUDIO_ITEM)
+                val audioCategory = intent.getLongExtra(CATEGORY, CATEGORY_SONGS)
+                val item = intent.getParcelableExtra<MediaLibraryItem>(ITEM)
                 when (audioCategory) {
                     CATEGORY_SONGS -> fragment = MediaBrowserTvFragment.newInstance(CATEGORY_SONGS, item)
                     CATEGORY_ALBUMS -> fragment = MediaBrowserTvFragment.newInstance(CATEGORY_ALBUMS, item)
@@ -69,7 +70,7 @@ class VerticalGridActivity : BaseTvActivity(), BrowserActivityInterface {
                 else
                     fragment = NetworkBrowserFragment()
             } else if (type == HEADER_DIRECTORIES) {
-                fragment = DirectoryBrowserFragment()
+                fragment = FileBrowserTvFragment.newInstance(TYPE_FILE, null)
             } else {
                 finish()
                 return
diff --git a/vlc-android/src/org/videolan/vlc/gui/view/FastScroller.kt b/vlc-android/src/org/videolan/vlc/gui/view/FastScroller.kt
index eb7d8d9e3f..bc2d5b8c1d 100644
--- a/vlc-android/src/org/videolan/vlc/gui/view/FastScroller.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/view/FastScroller.kt
@@ -51,7 +51,7 @@ import kotlinx.coroutines.channels.actor
 import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.vlc.BuildConfig
 import org.videolan.vlc.R
-import org.videolan.vlc.providers.medialibrary.HeadersIndex
+import org.videolan.vlc.providers.HeadersIndex
 import org.videolan.vlc.providers.medialibrary.MedialibraryProvider
 import org.videolan.vlc.util.WeakHandler
 import java.util.concurrent.atomic.AtomicBoolean
diff --git a/vlc-android/src/org/videolan/vlc/gui/view/RecyclerSectionItemGridDecoration.kt b/vlc-android/src/org/videolan/vlc/gui/view/RecyclerSectionItemGridDecoration.kt
index fc26627352..44d30f5cbf 100644
--- a/vlc-android/src/org/videolan/vlc/gui/view/RecyclerSectionItemGridDecoration.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/view/RecyclerSectionItemGridDecoration.kt
@@ -10,12 +10,12 @@ import android.widget.TextView
 import androidx.recyclerview.widget.RecyclerView
 import org.videolan.vlc.BuildConfig
 import org.videolan.vlc.R
-import org.videolan.vlc.providers.medialibrary.MedialibraryProvider
+import org.videolan.vlc.providers.HeaderProvider
 import org.videolan.vlc.util.Settings
 
 private const val TAG = "RecyclerSectionItemDecoration"
 
-class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private val space: Int, private val sticky: Boolean, private val nbColumns: Int, private val provider: MedialibraryProvider<*>) : RecyclerView.ItemDecoration() {
+class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private val space: Int, private val sticky: Boolean, private val nbColumns: Int, private val provider: HeaderProvider) : RecyclerView.ItemDecoration() {
 
     private lateinit var headerView: View
     private lateinit var header: TextView
@@ -28,19 +28,19 @@ class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private v
         outRect.top = space
         outRect.bottom = space
 
-
         val pos = parent.getChildAdapterPosition(view)
         for (i in 0 until nbColumns) {
             if ((pos - i) >= 0 && provider.isFirstInSection(pos - i)) {
                 outRect.top = headerOffset + space
             }
         }
-
-
     }
 
     override fun onDrawOver(c: Canvas, parent: RecyclerView, state: RecyclerView.State) {
         super.onDrawOver(c, parent, state)
+        if (provider.headers.isEmpty) {
+            return
+        }
 
         if (!::headerView.isInitialized) {
             headerView = inflateHeaderView(parent)
@@ -48,7 +48,6 @@ class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private v
             fixLayoutSize(headerView, parent)
         }
 
-
         //draw current header
         //look if previous header has been drawn
         var previousSectionPosition = 0
@@ -82,8 +81,6 @@ class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private v
                 drawnPositions.add(i)
             }
         }
-
-
     }
 
     private fun drawHeader(c: Canvas, child: View, headerView: View) {
@@ -105,7 +102,6 @@ class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private v
             return LayoutInflater.from(parent.context).inflate(R.layout.recycler_section_header_tv, parent, false)
         }
         return LayoutInflater.from(parent.context).inflate(R.layout.recycler_section_header, parent, false)
-
     }
 
     /**
@@ -123,5 +119,4 @@ class RecyclerSectionItemGridDecoration(private val headerOffset: Int, private v
 
         view.layout(0, 0, view.measuredWidth, view.measuredHeight)
     }
-
-}
\ No newline at end of file
+}
diff --git a/vlc-android/src/org/videolan/vlc/providers/BrowserProvider.kt b/vlc-android/src/org/videolan/vlc/providers/BrowserProvider.kt
index d42f3902f0..f4e2812ebd 100644
--- a/vlc-android/src/org/videolan/vlc/providers/BrowserProvider.kt
+++ b/vlc-android/src/org/videolan/vlc/providers/BrowserProvider.kt
@@ -47,7 +47,7 @@ const val TAG = "VLC/BrowserProvider"
 
 @ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
-abstract class BrowserProvider(val context: Context, val dataset: LiveDataset<MediaLibraryItem>, val url: String?, private val showHiddenFiles: Boolean) : EventListener, CoroutineScope {
+abstract class BrowserProvider(val context: Context, val dataset: LiveDataset<MediaLibraryItem>, val url: String?, private val showHiddenFiles: Boolean) : EventListener, CoroutineScope, HeaderProvider() {
 
     override val coroutineContext = Dispatchers.Main.immediate + SupervisorJob()
     val loading = MutableLiveData<Boolean>().apply { value = false }
@@ -122,6 +122,22 @@ abstract class BrowserProvider(val context: Context, val dataset: LiveDataset<Me
         browserActor.post(Refresh)
     }
 
+    fun computeHeaders(value: MutableList<MediaLibraryItem>) {
+        headers.clear()
+        for ((position, item) in value.withIndex()) {
+            val previous = when {
+                position > 0 -> value[position - 1]
+                else -> null
+            }
+            ModelsHelper.getHeader(context, Medialibrary.SORT_ALPHA, item, previous)?.let {
+                launch {
+                    headers.put(position, it)
+                    (liveHeaders as MutableLiveData<HeadersIndex>).value = headers
+                }
+            }
+        }
+    }
+
     internal open fun parseSubDirectories() {
         browserActor.post(ParseSubDirectories)
     }
@@ -129,14 +145,16 @@ abstract class BrowserProvider(val context: Context, val dataset: LiveDataset<Me
     open suspend fun refreshImpl() {
         browserChannel = Channel(Channel.UNLIMITED)
         requestBrowsing(url)
-        dataset.value = browserChannel.mapNotNullTo(mutableListOf()) { findMedia(it) }
+        val value: MutableList<MediaLibraryItem> = browserChannel.mapNotNullTo(mutableListOf()) { findMedia(it) }
+        computeHeaders(value)
+        dataset.value = value
         parseSubDirectories()
         loading.value = false
     }
 
     private suspend fun parseSubDirectoriesImpl() {
         if (dataset.value.isEmpty()) return
-        val currentMediaList = withContext(Dispatchers.Main) { dataset.value.toList() }
+        val currentMediaList = withContext(Dispatchers.Main) { dataset.value.toList().also { if (url != null) computeHeaders(dataset.value) } }
         val directories: MutableList<MediaWrapper> = ArrayList()
         val files: MutableList<MediaWrapper> = ArrayList()
         foldersContentMap.clear()
diff --git a/vlc-android/src/org/videolan/vlc/providers/FileBrowserProvider.kt b/vlc-android/src/org/videolan/vlc/providers/FileBrowserProvider.kt
index 0524c8f7ca..2840397deb 100644
--- a/vlc-android/src/org/videolan/vlc/providers/FileBrowserProvider.kt
+++ b/vlc-android/src/org/videolan/vlc/providers/FileBrowserProvider.kt
@@ -49,7 +49,7 @@ open class FileBrowserProvider(
         context: Context,
         dataset: LiveDataset<MediaLibraryItem>,
         url: String?, private val filePicker: Boolean = false,
-        showHiddenFiles: Boolean) : BrowserProvider(context, dataset,
+        showHiddenFiles: Boolean, private val showDummyCategory: Boolean = true) : BrowserProvider(context, dataset,
         url, showHiddenFiles
 ), Observer<MutableList<UsbDevice>> {
 
@@ -100,7 +100,7 @@ open class FileBrowserProvider(
         val browserStorage = context.getString(R.string.browser_storages)
         val storages = DirectoryRepository.getInstance(context).getMediaDirectories()
         val devices = mutableListOf<MediaLibraryItem>()
-        if (!filePicker) devices.add(DummyItem(browserStorage))
+        if (!filePicker && showDummyCategory) devices.add(DummyItem(browserStorage))
         for (mediaDirLocation in storages) {
             val file = File(mediaDirLocation)
             if (!file.exists() || !file.canRead()) continue
@@ -135,6 +135,8 @@ open class FileBrowserProvider(
         ExternalMonitor.devices.observeForever(this@FileBrowserProvider)
         if (showFavorites) favorites?.observeForever(favoritesObserver)
         loading.postValue(false)
+        //no headers in root
+        headers.clear()
     }
 
 
diff --git a/vlc-android/src/org/videolan/vlc/providers/FilePickerProvider.kt b/vlc-android/src/org/videolan/vlc/providers/FilePickerProvider.kt
index f1019451f5..e3d6bd0df3 100644
--- a/vlc-android/src/org/videolan/vlc/providers/FilePickerProvider.kt
+++ b/vlc-android/src/org/videolan/vlc/providers/FilePickerProvider.kt
@@ -26,7 +26,7 @@ import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.medialibrary.media.MediaWrapper
 import org.videolan.vlc.util.LiveDataset
 
-class FilePickerProvider(context: Context, dataset: LiveDataset<MediaLibraryItem>, url: String?) : FileBrowserProvider(context, dataset, url, true, false) {
+class FilePickerProvider(context: Context, dataset: LiveDataset<MediaLibraryItem>, url: String?, showDummyCategory: Boolean = false) : FileBrowserProvider(context, dataset, url, true, false, showDummyCategory) {
 
     override fun getFlags(): Int {
         return MediaBrowser.Flag.Interact or MediaBrowser.Flag.NoSlavesAutodetect
diff --git a/vlc-android/src/org/videolan/vlc/providers/HeaderProvider.kt b/vlc-android/src/org/videolan/vlc/providers/HeaderProvider.kt
new file mode 100644
index 0000000000..3534016eea
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/providers/HeaderProvider.kt
@@ -0,0 +1,41 @@
+package org.videolan.vlc.providers
+
+import androidx.annotation.MainThread
+import androidx.collection.SparseArrayCompat
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+
+typealias HeadersIndex = SparseArrayCompat<String>
+
+open class HeaderProvider {
+    val headers = HeadersIndex()
+    val liveHeaders: LiveData<HeadersIndex> = MutableLiveData<HeadersIndex>()
+
+
+    @MainThread
+    fun getSectionforPosition(position: Int): String {
+        for (pos in headers.size() - 1 downTo 0) if (position >= headers.keyAt(pos)) return headers.valueAt(pos)
+        return ""
+    }
+
+
+    @MainThread
+    fun isFirstInSection(position: Int): Boolean {
+        return headers.containsKey(position)
+    }
+
+    @MainThread
+    fun getPositionForSection(position: Int): Int {
+        for (pos in headers.size() - 1 downTo 0) if (position >= headers.keyAt(pos)) return headers.keyAt(pos)
+        return 0
+    }
+
+    @MainThread
+    fun getPositionForSectionByName(header: String): Int {
+        for (pos in headers.size() - 1 downTo 0) if (headers.valueAt(pos) == header) return headers.keyAt(pos)
+        return 0
+    }
+
+    @MainThread
+    fun getHeaderForPostion(position: Int) = headers.get(position)
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/providers/medialibrary/MedialibraryProvider.kt b/vlc-android/src/org/videolan/vlc/providers/medialibrary/MedialibraryProvider.kt
index b7d01eebfd..4fa6a0af58 100644
--- a/vlc-android/src/org/videolan/vlc/providers/medialibrary/MedialibraryProvider.kt
+++ b/vlc-android/src/org/videolan/vlc/providers/medialibrary/MedialibraryProvider.kt
@@ -21,9 +21,6 @@
 package org.videolan.vlc.providers.medialibrary
 
 import android.content.Context
-import androidx.annotation.MainThread
-import androidx.collection.SparseArrayCompat
-import androidx.lifecycle.LiveData
 import androidx.lifecycle.MutableLiveData
 import androidx.paging.Config
 import androidx.paging.DataSource
@@ -34,15 +31,15 @@ import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.launch
 import org.videolan.medialibrary.Medialibrary
 import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.vlc.providers.HeaderProvider
+import org.videolan.vlc.providers.HeadersIndex
 import org.videolan.vlc.util.*
 import org.videolan.vlc.viewmodels.SortableModel
 
-typealias HeadersIndex = SparseArrayCompat<String>
-abstract class MedialibraryProvider<T : MediaLibraryItem>(val context: Context, val scope: SortableModel) {
+abstract class MedialibraryProvider<T : MediaLibraryItem>(val context: Context, val scope: SortableModel) : HeaderProvider() {
     protected val medialibrary = Medialibrary.getInstance()
     val loading = MutableLiveData<Boolean>().apply { value = false }
-    private val headers = HeadersIndex()
-    val liveHeaders : LiveData<HeadersIndex> = MutableLiveData<HeadersIndex>()
+
 
     protected open val sortKey : String = this.javaClass.simpleName
     var sort = Medialibrary.SORT_DEFAULT
@@ -116,32 +113,7 @@ abstract class MedialibraryProvider<T : MediaLibraryItem>(val context: Context,
         }
     }
 
-    @MainThread
-    fun getSectionforPosition(position: Int): String {
-        for (pos in headers.size()-1 downTo 0) if (position >= headers.keyAt(pos)) return headers.valueAt(pos)
-        return ""
-    }
-
-
-    @MainThread
-    fun isFirstInSection(position: Int): Boolean {
-        return headers.containsKey(position)
-    }
-
-    @MainThread
-    fun getPositionForSection(position: Int): Int {
-        for (pos in headers.size()-1 downTo 0) if (position >= headers.keyAt(pos)) return headers.keyAt(pos)
-        return 0
-    }
-
-    @MainThread
-    fun getPositionForSectionByName(header: String): Int {
-        for (pos in headers.size() - 1 downTo 0) if (headers.valueAt(pos) == header) return headers.keyAt(pos)
-        return 0
-    }
 
-    @MainThread
-    fun getHeaderForPostion(position: Int) = headers.get(position)
 
     inner class MLDataSource : PositionalDataSource<T>() {
 
diff --git a/vlc-android/src/org/videolan/vlc/util/Constants.kt b/vlc-android/src/org/videolan/vlc/util/Constants.kt
index 403890fe3a..dca186197b 100644
--- a/vlc-android/src/org/videolan/vlc/util/Constants.kt
+++ b/vlc-android/src/org/videolan/vlc/util/Constants.kt
@@ -118,8 +118,8 @@ const val CATEGORY_GENRES = 23L
 const val CATEGORY_SONGS = 24L
 const val CATEGORY_VIDEOS = 25L
 
-const val AUDIO_CATEGORY = "category"
-const val AUDIO_ITEM = "item"
+const val CATEGORY = "category"
+const val ITEM = "item"
 const val KEY_GROUP = "key_group"
 const val KEY_FOLDER = "key_folder"
 
diff --git a/vlc-android/src/org/videolan/vlc/viewmodels/browser/BrowserModel.kt b/vlc-android/src/org/videolan/vlc/viewmodels/browser/BrowserModel.kt
index 9378c9ed71..f12eab185f 100644
--- a/vlc-android/src/org/videolan/vlc/viewmodels/browser/BrowserModel.kt
+++ b/vlc-android/src/org/videolan/vlc/viewmodels/browser/BrowserModel.kt
@@ -22,14 +22,17 @@ package org.videolan.vlc.viewmodels.browser
 
 import android.content.Context
 import androidx.annotation.MainThread
+import androidx.fragment.app.Fragment
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.ViewModelProvider
+import androidx.lifecycle.ViewModelProviders
 import kotlinx.coroutines.*
 import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.medialibrary.media.MediaWrapper
 import org.videolan.vlc.providers.*
 import org.videolan.vlc.repository.DirectoryRepository
 import org.videolan.vlc.viewmodels.BaseModel
+import org.videolan.vlc.viewmodels.tv.TvBrowserModel
 
 const val TYPE_FILE = 0
 const val TYPE_NETWORK = 1
@@ -38,13 +41,15 @@ const val TYPE_STORAGE = 3
 
 @ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
-open class BrowserModel(context: Context, val url: String?, type: Int, showHiddenFiles: Boolean) : BaseModel<MediaLibraryItem>(context) {
+open class BrowserModel(context: Context, val url: String?, type: Int, showHiddenFiles: Boolean, private val showDummyCategory: Boolean) : BaseModel<MediaLibraryItem>(context), TvBrowserModel {
+    override var currentItem: MediaLibraryItem? = null
+    override var nbColumns: Int = 0
 
-    protected val provider: BrowserProvider = when (type) {
+    override val provider: BrowserProvider = when (type) {
         TYPE_PICKER -> FilePickerProvider(context, dataset, url)
         TYPE_NETWORK -> NetworkProvider(context, dataset, url, showHiddenFiles)
         TYPE_STORAGE -> StorageProvider(context, dataset, url, showHiddenFiles)
-        else -> FileBrowserProvider(context, dataset, url, showHiddenFiles = showHiddenFiles)
+        else -> FileBrowserProvider(context, dataset, url, showHiddenFiles = showHiddenFiles, showDummyCategory = showDummyCategory)
     }
 
     override val loading = provider.loading
@@ -58,7 +63,7 @@ open class BrowserModel(context: Context, val url: String?, type: Int, showHidde
         launch {
             this@BrowserModel.sort = sort
             desc = !desc
-            dataset.value = withContext(Dispatchers.Default) { dataset.value.apply { sortWith(if (desc) descComp else ascComp) } }
+            dataset.value = withContext(Dispatchers.Default) { dataset.value.apply { sortWith(if (desc) descComp else ascComp) }.also { provider.computeHeaders(dataset.value) } }
         }
     }
 
@@ -81,10 +86,10 @@ open class BrowserModel(context: Context, val url: String?, type: Int, showHidde
 
     suspend fun customDirectoryExists(path: String) = DirectoryRepository.getInstance(context).customDirectoryExists(path)
 
-    class Factory(val context: Context, val url: String?, private val type: Int,  private val showHiddenFiles: Boolean): ViewModelProvider.NewInstanceFactory() {
+    class Factory(val context: Context, val url: String?, private val type: Int, private val showHiddenFiles: Boolean, private val showDummyCategory: Boolean = true) : ViewModelProvider.NewInstanceFactory() {
         override fun <T : ViewModel> create(modelClass: Class<T>): T {
             @Suppress("UNCHECKED_CAST")
-            return BrowserModel(context.applicationContext, url, type, showHiddenFiles) as T
+            return BrowserModel(context.applicationContext, url, type, showHiddenFiles, showDummyCategory = showDummyCategory) as T
         }
     }
 }
@@ -110,4 +115,7 @@ private val descComp by lazy {
         }
         item2?.title?.toLowerCase()?.compareTo(item1?.title?.toLowerCase() ?: "") ?: -1
     }
-}
\ No newline at end of file
+}
+
+@ExperimentalCoroutinesApi
+fun Fragment.getBrowserModel(category: Int, url: String?, showHiddenFiles: Boolean, showDummyCategory: Boolean) = ViewModelProviders.of(this, BrowserModel.Factory(requireContext(), url, category, showHiddenFiles, showDummyCategory = showDummyCategory)).get(BrowserModel::class.java)
diff --git a/vlc-android/src/org/videolan/vlc/viewmodels/browser/NetworkModel.kt b/vlc-android/src/org/videolan/vlc/viewmodels/browser/NetworkModel.kt
index 75a1446760..6871f1b524 100644
--- a/vlc-android/src/org/videolan/vlc/viewmodels/browser/NetworkModel.kt
+++ b/vlc-android/src/org/videolan/vlc/viewmodels/browser/NetworkModel.kt
@@ -24,7 +24,7 @@ import android.content.Context
 import androidx.lifecycle.ViewModel
 import androidx.lifecycle.ViewModelProvider
 
-class NetworkModel(context: Context, url: String? = null, showHiddenFiles: Boolean): BrowserModel(context, url, TYPE_NETWORK, showHiddenFiles) {
+class NetworkModel(context: Context, url: String? = null, showHiddenFiles: Boolean) : BrowserModel(context, url, TYPE_NETWORK, showHiddenFiles, true) {
 
     class Factory(val context: Context, val url: String?, private val showHiddenFiles: Boolean): ViewModelProvider.NewInstanceFactory() {
         override fun <T : ViewModel> create(modelClass: Class<T>): T {
diff --git a/vlc-android/src/org/videolan/vlc/viewmodels/tv/MediaBrowserViewModel.kt b/vlc-android/src/org/videolan/vlc/viewmodels/tv/MediaBrowserViewModel.kt
index c36ca93efc..644d304537 100644
--- a/vlc-android/src/org/videolan/vlc/viewmodels/tv/MediaBrowserViewModel.kt
+++ b/vlc-android/src/org/videolan/vlc/viewmodels/tv/MediaBrowserViewModel.kt
@@ -7,7 +7,6 @@ import androidx.lifecycle.ViewModelProvider
 import androidx.lifecycle.ViewModelProviders
 import kotlinx.coroutines.ExperimentalCoroutinesApi
 import org.videolan.medialibrary.media.MediaLibraryItem
-import org.videolan.vlc.R
 import org.videolan.vlc.providers.medialibrary.*
 import org.videolan.vlc.util.CATEGORY_ALBUMS
 import org.videolan.vlc.util.CATEGORY_ARTISTS
@@ -17,21 +16,14 @@ import org.videolan.vlc.viewmodels.MedialibraryViewModel
 
 
 @ExperimentalCoroutinesApi
-class MediaBrowserViewModel(context: Context, private val category: Long) : MedialibraryViewModel(context) {
+class MediaBrowserViewModel(context: Context, category: Long) : MedialibraryViewModel(context), TvBrowserModel {
 
 
-    var nbColumns = 0
-    var currentItem: MediaLibraryItem? = null
-
-    fun updateColumns() {
-        nbColumns = when (category) {
-            CATEGORY_VIDEOS -> context.resources.getInteger(R.integer.tv_videos_col_count)
-            else -> context.resources.getInteger(R.integer.tv_songs_col_count)
-        }
-    }
+    override var nbColumns = 0
+    override var currentItem: MediaLibraryItem? = null
 
 
-    val provider = when (category) {
+    override val provider = when (category) {
         CATEGORY_ALBUMS -> AlbumsProvider(null, context, this)
         CATEGORY_ARTISTS -> ArtistsProvider(context, this, true)
         CATEGORY_GENRES -> GenresProvider(context, this)
diff --git a/vlc-android/src/org/videolan/vlc/viewmodels/tv/TvBrowserModel.kt b/vlc-android/src/org/videolan/vlc/viewmodels/tv/TvBrowserModel.kt
new file mode 100644
index 0000000000..aebd428cfe
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/viewmodels/tv/TvBrowserModel.kt
@@ -0,0 +1,19 @@
+package org.videolan.vlc.viewmodels.tv
+
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.vlc.providers.HeaderProvider
+
+interface TvBrowserModel {
+    fun canSortByFileNameName(): Boolean
+    fun canSortByDuration(): Boolean
+    fun canSortByInsertionDate(): Boolean
+    fun canSortByReleaseDate(): Boolean
+    fun canSortByLastModified(): Boolean
+    fun sort(sort: Int)
+
+    var currentItem: MediaLibraryItem?
+    var nbColumns: Int
+    val provider: HeaderProvider
+
+
+}
\ No newline at end of file
