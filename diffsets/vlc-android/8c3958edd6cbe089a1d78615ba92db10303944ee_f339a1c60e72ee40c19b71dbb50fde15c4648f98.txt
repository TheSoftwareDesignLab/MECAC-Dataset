diff --git a/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java b/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java
index c01da80baf..4041fe0e16 100644
--- a/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java
@@ -76,8 +76,8 @@ public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
         mEmptyView = view.findViewById(R.id.empty);
         mRecyclerView = view.findViewById(android.R.id.list);
-        viewModel = ViewModelProviders.of(requireActivity(), new HistoryModel.Factory(requireContext())).get(HistoryModel.class);
-        viewModel.getDataset().observe(this, new Observer<List<MediaWrapper>>() {
+        setViewModel(ViewModelProviders.of(requireActivity(), new HistoryModel.Factory(requireContext())).get(HistoryModel.class));
+        getViewModel().getDataset().observe(this, new Observer<List<MediaWrapper>>() {
             @Override
             public void onChanged(@Nullable List<MediaWrapper> mediaWrappers) {
                 if (mediaWrappers != null) mHistoryAdapter.update(mediaWrappers);
@@ -87,7 +87,7 @@ public void onChanged(@Nullable List<MediaWrapper> mediaWrappers) {
 
     @Override
     protected void onRestart() {
-        viewModel.refresh();
+        getViewModel().refresh();
     }
 
     @Override
@@ -101,7 +101,7 @@ public void onActivityCreated(@Nullable Bundle savedInstanceState) {
         mRecyclerView.setNextFocusForwardId(android.R.id.list);
         mRecyclerView.requestFocus();
         registerForContextMenu(mRecyclerView);
-        mSwipeRefreshLayout.setOnRefreshListener(this);
+        getSwipeRefreshLayout().setOnRefreshListener(this);
     }
 
     @Override
@@ -129,12 +129,12 @@ public boolean onOptionsItemSelected(MenuItem item) {
 
     @Override
     public void setFabPlayVisibility(boolean enable) {
-        if (mFabPlay != null) mFabPlay.setVisibility(View.GONE);
+        if (getFabPlay() != null) getFabPlay().setVisibility(View.GONE);
     }
 
     @Override
     public void refresh() {
-        viewModel.refresh();
+        getViewModel().refresh();
     }
 
     @Override
@@ -152,11 +152,11 @@ public void clear(){}
 
     private void updateEmptyView() {
         if (mHistoryAdapter.isEmpty()){
-            mSwipeRefreshLayout.setVisibility(View.GONE);
+            getSwipeRefreshLayout().setVisibility(View.GONE);
             mEmptyView.setVisibility(View.VISIBLE);
         } else {
             mEmptyView.setVisibility(View.GONE);
-            mSwipeRefreshLayout.setVisibility(View.VISIBLE);
+            getSwipeRefreshLayout().setVisibility(View.VISIBLE);
         }
     }
 
@@ -167,8 +167,8 @@ public boolean isEmpty() {
 
     @Override
     public void clearHistory() {
-        mMediaLibrary.clearHistory();
-        viewModel.clear();
+        getMediaLibrary().clearHistory();
+        getViewModel().clear();
         updateEmptyView();
     }
 
@@ -215,9 +215,9 @@ public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 
     @Override
     public void onDestroyActionMode(ActionMode mode) {
-        mActionMode = null;
+        setActionMode(null);
         int index = -1;
-        for (MediaWrapper media : viewModel.getDataset().getValue()) {
+        for (MediaWrapper media : getViewModel().getDataset().getValue()) {
             ++index;
             if (media.hasStateFlags(MediaLibraryItem.FLAG_SELECTED)) {
                 media.removeStateFlags(MediaLibraryItem.FLAG_SELECTED);
@@ -228,19 +228,19 @@ public void onDestroyActionMode(ActionMode mode) {
 
     @Override
     public void onClick(View v, int position, MediaLibraryItem item) {
-        if (mActionMode != null) {
+        if (getActionMode() != null) {
             item.toggleStateFlag(MediaLibraryItem.FLAG_SELECTED);
             mHistoryAdapter.notifyItemChanged(position, item);
             invalidateActionMode();
             return;
         }
-        if (position != 0) viewModel.moveUp((MediaWrapper) item);
+        if (position != 0) getViewModel().moveUp((MediaWrapper) item);
         MediaUtils.INSTANCE.openMedia(v.getContext(), (MediaWrapper) item);
     }
 
     @Override
     public boolean onLongClick(View v, int position, MediaLibraryItem item) {
-        if (mActionMode != null) return false;
+        if (getActionMode() != null) return false;
         item.toggleStateFlag(MediaLibraryItem.FLAG_SELECTED);
         mHistoryAdapter.notifyItemChanged(position, item);
         startActionMode();
@@ -249,7 +249,7 @@ public boolean onLongClick(View v, int position, MediaLibraryItem item) {
 
     @Override
     public void onImageClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        if (mActionMode != null) {
+        if (getActionMode() != null) {
             onClick(v, position, item);
             return;
         }
@@ -267,7 +267,7 @@ public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibra
     @Override
     public void onUpdateFinished(RecyclerView.Adapter adapter) {
         UiTools.updateSortTitles(this);
-        mSwipeRefreshLayout.setRefreshing(false);
+        getSwipeRefreshLayout().setRefreshing(false);
     }
 
     @Override
diff --git a/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt b/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
index 551085b7c8..090ae2951b 100644
--- a/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
@@ -66,10 +66,8 @@ class PlaylistFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshListene
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
-        if (viewModel == null) {
             viewModel = ViewModelProviders.of(requireActivity(), PagedPlaylistsModel.Factory(requireContext())).get(PagedPlaylistsModel::class.java)
 
-        }
     }
     override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
         binding = PlaylistsFragmentBinding.inflate(inflater, container, false)
@@ -139,7 +137,7 @@ class PlaylistFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshListene
     }
 
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode == null) {
+        if (actionMode == null) {
             val i = Intent(activity, PlaylistActivity::class.java)
             i.putExtra(AudioBrowserFragment.TAG_ITEM, item)
             startActivity(i)
@@ -151,7 +149,8 @@ class PlaylistFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshListene
         activity?.reloadLibrary()
     }
 
-    override fun getTitle() = getString(R.string.playlists)
+    override fun getTitle(): String = getString(R.string.playlists)
+
 
     override fun getCurrentRV(): RecyclerView = playlists
 
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt b/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt
index e57dfdba55..19eec3cf73 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt
@@ -35,6 +35,7 @@ import androidx.lifecycle.ViewModelProviders
 import androidx.paging.PagedList
 import androidx.recyclerview.widget.LinearLayoutManager
 import androidx.recyclerview.widget.RecyclerView
+import androidx.viewpager.widget.ViewPager
 import com.google.android.material.appbar.AppBarLayout
 import com.google.android.material.floatingactionbutton.FloatingActionButton
 import com.google.android.material.tabs.TabLayout
@@ -48,7 +49,6 @@ import org.videolan.vlc.gui.ContentActivity
 import org.videolan.vlc.gui.PlaylistActivity
 import org.videolan.vlc.gui.view.FastScroller
 import org.videolan.vlc.gui.view.RecyclerSectionItemDecoration
-import org.videolan.vlc.gui.view.SwipeRefreshLayout
 import org.videolan.vlc.media.MediaUtils
 import org.videolan.vlc.util.Util
 import org.videolan.vlc.viewmodels.paged.MLPagedModel
@@ -64,7 +64,6 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
     private lateinit var albumModel: PagedAlbumsModel
     private lateinit var tracksModel: PagedTracksModel
 
-    private lateinit var swipeRefreshLayout: SwipeRefreshLayout
     private lateinit var lists: Array<RecyclerView>
     private lateinit var audioModels: Array<MLPagedModel<MediaLibraryItem>>
     private lateinit var songsAdapter: AudioBrowserAdapter
@@ -77,7 +76,7 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
      * Disable Swipe Refresh while scrolling horizontally
      */
     private val mSwipeFilter = View.OnTouchListener { v, event ->
-        swipeRefreshLayout.isEnabled = event.action == MotionEvent.ACTION_UP
+        swipeRefreshLayout?.isEnabled = event.action == MotionEvent.ACTION_UP
         false
     }
 
@@ -97,13 +96,9 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
         audioModels = arrayOf(albumModel as MLPagedModel<MediaLibraryItem>, tracksModel as MLPagedModel<MediaLibraryItem>)
     }
 
-    override fun getTitle(): String {
-        return mItem.title
-    }
+    override fun getTitle(): String = mItem.title
+
 
-    override fun getViewModel(): MLPagedModel<MediaLibraryItem> {
-        return audioModels[viewPager!!.currentItem]
-    }
 
     override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
         return inflater.inflate(R.layout.audio_albums_songs, container, false)
@@ -133,9 +128,22 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
         fastScroller.attachToCoordinator(view.rootView.findViewById<View>(R.id.appbar) as AppBarLayout, view.rootView.findViewById<View>(R.id.coordinator) as CoordinatorLayout, view.rootView.findViewById<View>(R.id.fab) as FloatingActionButton)
 
         viewPager!!.setOnTouchListener(mSwipeFilter)
+        viewModel = audioModels[viewPager!!.currentItem]
+        viewPager!!.addOnPageChangeListener(object : ViewPager.OnPageChangeListener {
+            override fun onPageScrollStateChanged(state: Int) {}
+
+            override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {}
+
+            override fun onPageSelected(position: Int) {
+                viewModel = audioModels[viewPager!!.currentItem]
+            }
+
+        })
+
+
 
-        swipeRefreshLayout = view.findViewById<SwipeRefreshLayout>(R.id.swipeLayout)
-        swipeRefreshLayout.setOnRefreshListener(this)
+        swipeRefreshLayout = view.findViewById(R.id.swipeLayout)
+        swipeRefreshLayout!!.setOnRefreshListener(this)
         for (rv in lists) {
             rv.layoutManager = LinearLayoutManager(view.context)
             val llm = LinearLayoutManager(activity)
@@ -144,7 +152,7 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
             rv.addOnScrollListener(scrollListener)
 
         }
-        mFabPlay.setImageResource(R.drawable.ic_fab_play)
+        fabPlay?.setImageResource(R.drawable.ic_fab_play)
         albumModel.pagedList.observe(this, Observer { albums -> if (albums != null) albumsAdapter.submitList(albums as PagedList<MediaLibraryItem>) })
         tracksModel.pagedList.observe(this, Observer { tracks ->
             if (tracks != null) {
@@ -171,11 +179,11 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
     override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
         super.onUpdateFinished(adapter)
         handler.post {
-            swipeRefreshLayout.isRefreshing = false
+            swipeRefreshLayout?.isRefreshing = false
             val albums = albumModel.pagedList.value
-            if (Util.isListEmpty(albums) && !getViewModel().isFiltering())
+            if (Util.isListEmpty(albums) && !viewModel.isFiltering())
                 viewPager!!.currentItem = 1
-            fastScroller.setRecyclerView(getCurrentRV(), getViewModel())
+            fastScroller.setRecyclerView(getCurrentRV(), viewModel)
         }
     }
 
@@ -185,7 +193,7 @@ class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout
     }
 
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode != null) {
+        if (actionMode != null) {
             super.onClick(v, position, item)
             return
         }
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt
index f3093a96b2..25129f46e7 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt
@@ -33,6 +33,7 @@ import androidx.lifecycle.ViewModelProviders
 import androidx.recyclerview.widget.LinearLayoutManager
 import androidx.recyclerview.widget.RecyclerView
 import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
+import androidx.viewpager.widget.ViewPager
 import com.google.android.material.appbar.AppBarLayout
 import com.google.android.material.floatingactionbutton.FloatingActionButton
 import com.google.android.material.tabs.TabLayout
@@ -87,7 +88,7 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
      * Disable Swipe Refresh while scrolling horizontally
      */
     private val mSwipeFilter = View.OnTouchListener { _, event ->
-        mSwipeRefreshLayout.isEnabled = event.action == MotionEvent.ACTION_UP
+        swipeRefreshLayout?.isEnabled = event.action == MotionEvent.ACTION_UP
         false
     }
 
@@ -142,7 +143,18 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
             list.addItemDecoration(RecyclerSectionItemDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_height), true, models[i]))
         }
         viewPager!!.setOnTouchListener(mSwipeFilter)
-        mSwipeRefreshLayout.setOnRefreshListener(this)
+        swipeRefreshLayout?.setOnRefreshListener(this)
+        viewPager!!.addOnPageChangeListener(object : ViewPager.OnPageChangeListener {
+            override fun onPageScrollStateChanged(state: Int) {}
+
+            override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {}
+
+            override fun onPageSelected(position: Int) {
+                viewModel = models[viewPager!!.currentItem]
+            }
+
+        })
+        viewModel = models[viewPager!!.currentItem]
     }
 
     override fun onSaveInstanceState(outState: Bundle) {
@@ -194,7 +206,7 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
     override fun onStart() {
         super.onStart()
         setFabPlayShuffleAllVisibility()
-        mFabPlay.setImageResource(R.drawable.ic_fab_shuffle)
+        fabPlay.setImageResource(R.drawable.ic_fab_shuffle)
     }
 
     override fun onPrepareOptionsMenu(menu: Menu?) {
@@ -215,9 +227,7 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
         requireContext().reloadLibrary()
     }
 
-    override fun getTitle(): String {
-        return getString(R.string.audio)
-    }
+    override fun getTitle(): String = getString(R.string.audio)
 
     override fun enableSearchOption(): Boolean {
         return true
@@ -238,7 +248,7 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
         super.onTabSelected(tab)
         fastScroller.setRecyclerView(lists[tab.position]!!, models[tab.position])
         settings.edit().putInt(KEY_AUDIO_CURRENT_TAB, tab.position).apply()
-        val loading = getViewModel().loading.value
+        val loading = viewModel.loading.value
         if (loading == null || !loading)
             mHandler.sendEmptyMessage(UNSET_REFRESHING)
         else
@@ -256,7 +266,7 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
     }
 
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode != null) {
+        if (actionMode != null) {
             super.onClick(v, position, item)
             return
         }
@@ -283,16 +293,13 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
     override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
         super.onUpdateFinished(adapter)
         if (currentAdapter != null && adapter === currentAdapter) {
-            mSwipeRefreshLayout.isEnabled = (getCurrentRV().layoutManager as LinearLayoutManager).findFirstVisibleItemPosition() <= 0
+            swipeRefreshLayout?.isEnabled = (getCurrentRV().layoutManager as LinearLayoutManager).findFirstVisibleItemPosition() <= 0
             updateEmptyView()
-            fastScroller.setRecyclerView(getCurrentRV(), getViewModel())
+            fastScroller.setRecyclerView(getCurrentRV(), viewModel)
         } else
             setFabPlayShuffleAllVisibility()
     }
 
-    override fun getViewModel(): MLPagedModel<MediaLibraryItem> {
-        return models[viewPager!!.currentItem]
-    }
 
 
     override fun getCurrentRV(): RecyclerView {
@@ -304,10 +311,10 @@ class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshLis
         override fun handleMessage(msg: Message) {
             val fragment = owner ?: return
             when (msg.what) {
-                SET_REFRESHING -> fragment.mSwipeRefreshLayout.isRefreshing = true
+                SET_REFRESHING -> fragment.swipeRefreshLayout?.isRefreshing = true
                 UNSET_REFRESHING -> {
                     removeMessages(SET_REFRESHING)
-                    fragment.mSwipeRefreshLayout.isRefreshing = false
+                    fragment.swipeRefreshLayout?.isRefreshing = false
                 }
                 UPDATE_EMPTY_VIEW -> fragment.updateEmptyView()
             }
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt
index d5c51b854f..cb68b0d2fe 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt
@@ -70,11 +70,11 @@ abstract class BaseAudioBrowser : MediaBrowserFragment<MLPagedModel<*>>(), IEven
     internal val scrollListener: RecyclerView.OnScrollListener = object : RecyclerView.OnScrollListener() {
         override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
             if (newState != RecyclerView.SCROLL_STATE_IDLE) {
-                mSwipeRefreshLayout.isEnabled = false
+                swipeRefreshLayout?.isEnabled = false
                 return
             }
             val llm = getCurrentRV().layoutManager as LinearLayoutManager? ?: return
-            mSwipeRefreshLayout.isEnabled = llm.findFirstVisibleItemPosition() <= 0
+            swipeRefreshLayout?.isEnabled = llm.findFirstVisibleItemPosition() <= 0
         }
 
         override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {}
@@ -191,33 +191,33 @@ abstract class BaseAudioBrowser : MediaBrowserFragment<MLPagedModel<*>>(), IEven
 
     internal fun onDestroyActionMode(adapter: AudioBrowserAdapter?) {
         setFabPlayVisibility(true)
-        mActionMode = null
+        actionMode = null
         adapter?.multiSelectHelper?.clearSelection()
     }
 
     override fun sortBy(sort: Int) {
-        getViewModel().canSortBy(sort)
+        viewModel.canSortBy(sort)
         super.sortBy(sort)
     }
 
     override fun onRefresh() {}
 
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode != null) {
+        if (actionMode != null) {
             currentAdapter?.multiSelectHelper?.toggleSelection(position)
             invalidateActionMode()
         }
     }
 
     override fun onLongClick(v: View, position: Int, item: MediaLibraryItem): Boolean {
-        if (mActionMode != null) return false
+        if (actionMode != null) return false
         currentAdapter?.multiSelectHelper?.toggleSelection(position)
         startActionMode()
         return true
     }
 
     override fun onImageClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode != null) {
+        if (actionMode != null) {
             onClick(v, position, item)
             return
         }
@@ -230,7 +230,7 @@ abstract class BaseAudioBrowser : MediaBrowserFragment<MLPagedModel<*>>(), IEven
             MediaLibraryItem.TYPE_PLAYLIST -> CTX_PLAYLIST_FLAGS
             else -> CTX_AUDIO_FLAGS
         }
-        if (mActionMode == null) showContext(requireActivity(), this, position, item.title, flags)
+        if (actionMode == null) showContext(requireActivity(), this, position, item.title, flags)
     }
 
 
@@ -252,7 +252,7 @@ abstract class BaseAudioBrowser : MediaBrowserFragment<MLPagedModel<*>>(), IEven
         val media = adapter?.getItem(position) ?: return
         when (option) {
             CTX_PLAY -> MediaUtils.playTracks(requireActivity(), media, 0)
-            CTX_PLAY_ALL -> MediaUtils.playAll(requireContext(), getViewModel() as MLPagedModel<MediaWrapper>, position, false)
+            CTX_PLAY_ALL -> MediaUtils.playAll(requireContext(), viewModel as MLPagedModel<MediaWrapper>, position, false)
             CTX_INFORMATION -> showInfoDialog(media)
             CTX_DELETE -> removeItem(media)
             CTX_APPEND -> MediaUtils.appendMedia(requireActivity(), media.tracks)
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserAdapter.java b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserAdapter.java
deleted file mode 100644
index a51f414efe..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserAdapter.java
+++ /dev/null
@@ -1,333 +0,0 @@
-/**
- * **************************************************************************
- * BaseBrowserAdapter.java
- * ****************************************************************************
- * Copyright © 2015-2017 VLC authors and VideoLAN
- * Author: Geoffrey Métais
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- * ***************************************************************************
- */
-package org.videolan.vlc.gui.browser;
-
-import android.annotation.TargetApi;
-import android.content.res.Resources;
-import android.graphics.BitmapFactory;
-import android.graphics.drawable.BitmapDrawable;
-import android.net.Uri;
-import android.os.Build;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-
-import org.videolan.libvlc.util.AndroidUtil;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.medialibrary.media.Storage;
-import org.videolan.tools.MultiSelectAdapter;
-import org.videolan.tools.MultiSelectHelper;
-import org.videolan.vlc.R;
-import org.videolan.vlc.databinding.BrowserItemBinding;
-import org.videolan.vlc.databinding.BrowserItemSeparatorBinding;
-import org.videolan.vlc.gui.DiffUtilAdapter;
-import org.videolan.vlc.gui.helpers.SelectorViewHolder;
-import org.videolan.vlc.util.AndroidDevices;
-import org.videolan.vlc.util.Constants;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import androidx.databinding.ViewDataBinding;
-
-import static org.videolan.medialibrary.media.MediaLibraryItem.TYPE_MEDIA;
-import static org.videolan.medialibrary.media.MediaLibraryItem.TYPE_STORAGE;
-
-public class BaseBrowserAdapter extends DiffUtilAdapter<MediaLibraryItem, BaseBrowserAdapter.ViewHolder> implements MultiSelectAdapter<MediaLibraryItem> {
-    protected static final String TAG = "VLC/BaseBrowserAdapter";
-
-    private MultiSelectHelper<MediaLibraryItem> multiSelectHelper;
-
-    private final BitmapDrawable IMAGE_FOLDER;
-    private final BitmapDrawable IMAGE_AUDIO;
-    private final BitmapDrawable IMAGE_VIDEO;
-    private final BitmapDrawable IMAGE_SUBTITLE;
-    private final BitmapDrawable IMAGE_UNKNOWN;
-    private final BitmapDrawable IMAGE_QA_MOVIES;
-    private final BitmapDrawable IMAGE_QA_MUSIC;
-    private final BitmapDrawable IMAGE_QA_PODCASTS;
-    private final BitmapDrawable IMAGE_QA_DOWNLOAD;
-
-    protected final BaseBrowserFragment fragment;
-    private int mMediaCount = 0;
-    private final boolean mNetworkRoot, mSpecialIcons;
-
-    BaseBrowserAdapter(BaseBrowserFragment fragment) {
-        this.fragment = fragment;
-        multiSelectHelper = new MultiSelectHelper<>(this, Constants.UPDATE_SELECTION);
-        final boolean root = fragment.isRootDirectory();
-        final boolean fileBrowser = fragment instanceof FileBrowserFragment;
-        final boolean filesRoot = root && fileBrowser;
-        mNetworkRoot = root && fragment instanceof NetworkBrowserFragment;
-        final String mrl = fragment.getMrl();
-        mSpecialIcons = filesRoot || fileBrowser && mrl != null && mrl.endsWith(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY);
-        // Setup resources
-        final Resources res = fragment.requireContext().getResources();
-        IMAGE_FOLDER = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_menu_folder));
-        IMAGE_AUDIO = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_audio_normal));
-        IMAGE_VIDEO = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_video_normal));
-        IMAGE_SUBTITLE = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_subtitle_normal));
-        IMAGE_UNKNOWN = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_unknown_normal));
-        IMAGE_QA_MOVIES = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_movies_normal));
-        IMAGE_QA_MUSIC = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_music_normal));
-        IMAGE_QA_PODCASTS = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_podcasts_normal));
-        IMAGE_QA_DOWNLOAD = new BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_download_normal));
-    }
-
-    @Override
-    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        LayoutInflater inflater = LayoutInflater.from(parent.getContext());
-        if (viewType == MediaLibraryItem.TYPE_MEDIA || viewType == MediaLibraryItem.TYPE_STORAGE)
-            return new MediaViewHolder(BrowserItemBinding.inflate(inflater, parent, false));
-        else
-            return new SeparatorViewHolder(BrowserItemSeparatorBinding.inflate(inflater, parent, false));
-    }
-
-    @Override
-    public void onBindViewHolder(final ViewHolder holder, int position) {
-        int viewType = getItemViewType(position);
-        if (viewType == TYPE_MEDIA) {
-            onBindMediaViewHolder((MediaViewHolder) holder, position);
-        } else {
-            SeparatorViewHolder vh = (SeparatorViewHolder) holder;
-            vh.binding.setTitle(getDataset().get(position).getTitle());
-        }
-    }
-
-    @Override
-    public void onBindViewHolder(ViewHolder holder, int position, List<Object> payloads) {
-        if (payloads.isEmpty()) onBindViewHolder(holder, position);
-        else if (payloads.get(0) instanceof CharSequence){
-            ((MediaViewHolder) holder).binding.text.setVisibility(View.VISIBLE);
-            ((MediaViewHolder) holder).binding.text.setText((CharSequence) payloads.get(0));
-        } else if (payloads.get(0) instanceof Integer) {
-            final int value = (Integer) payloads.get(0);
-            if (value == Constants.UPDATE_SELECTION) holder.selectView(multiSelectHelper.isSelected(position));
-        }
-    }
-
-    private void onBindMediaViewHolder(final MediaViewHolder vh, int position) {
-        final MediaWrapper media = (MediaWrapper) getItem(position);
-        final boolean isFavorite = media.hasStateFlags(MediaLibraryItem.FLAG_FAVORITE);
-        vh.binding.setItem(media);
-        final String scheme = media.getUri().getScheme();
-        vh.binding.setHasContextMenu((!mNetworkRoot || isFavorite)
-                && !"content".equals(scheme)
-                && !"otg".equals(scheme));
-        vh.binding.setFilename(media.getType() != MediaWrapper.TYPE_DIR && "file".equals(scheme) ? media.getFileName() : null);
-        if (mNetworkRoot) vh.binding.setProtocol(getProtocol(media));
-        vh.binding.setCover(getIcon(media, mSpecialIcons));
-        vh.selectView(multiSelectHelper.isSelected(position));
-    }
-
-    @Override
-    public int getItemCount() {
-        return getDataset().size();
-    }
-
-    public MultiSelectHelper<MediaLibraryItem> getMultiSelectHelper() {
-        return multiSelectHelper;
-    }
-
-    public abstract class ViewHolder<T extends ViewDataBinding> extends SelectorViewHolder<T> {
-
-        public ViewHolder(T binding) {
-            super(binding);
-        }
-
-        public void onClick(View v){}
-
-        public void onImageClick(View v) {
-        }
-
-        public boolean onLongClick(View v){ return false; }
-
-        public void onCheckBoxClick(View v){}
-
-        public void onMoreClick(View v){}
-
-        public abstract int getType();
-
-    }
-
-    class MediaViewHolder extends ViewHolder<BrowserItemBinding> implements View.OnFocusChangeListener {
-
-        @TargetApi(Build.VERSION_CODES.M)
-        MediaViewHolder(final BrowserItemBinding binding) {
-            super(binding);
-            binding.setHolder(this);
-            if (AndroidUtil.isMarshMallowOrLater) itemView.setOnContextClickListener(new View.OnContextClickListener() {
-                @Override
-                public boolean onContextClick(View v) {
-                    onMoreClick(v);
-                    return true;
-                }
-            });
-        }
-
-        protected void openStorage() {
-            MediaWrapper mw = new MediaWrapper(((Storage) getItem(getLayoutPosition())).getUri());
-            mw.setType(MediaWrapper.TYPE_DIR);
-            fragment.browse(mw, binding.browserCheckbox.isChecked());
-        }
-
-        @Override
-        public void onCheckBoxClick(View v) {
-            if (getItem(getLayoutPosition()).getItemType() == TYPE_STORAGE)
-                checkBoxAction(v, ((Storage) getItem(getLayoutPosition())).getUri().toString());
-        }
-
-        @Override
-        public int getType() {
-            return TYPE_MEDIA;
-        }
-
-        @Override
-        public void onClick(View v){
-            int position = getLayoutPosition();
-            if (position < getDataset().size() && position >= 0)
-                fragment.onClick(v, position, getDataset().get(position));
-        }
-
-        @Override
-        public void onImageClick(View v) {
-            int position = getLayoutPosition();
-            if (position < getDataset().size() && position >= 0)
-                fragment.onImageClick(v, position, getDataset().get(position));
-        }
-
-        @Override
-        public void onMoreClick(View v) {
-            int position = getLayoutPosition();
-            if (position < getDataset().size() && position >= 0)
-                fragment.onCtxClick(v, position, getDataset().get(position));
-        }
-
-        @Override
-        public boolean onLongClick(View v) {
-            int position = getLayoutPosition();
-            if (getItem(position).getItemType() == TYPE_STORAGE && AndroidDevices.showTvUi(itemView.getContext())) {
-                binding.browserCheckbox.toggle();
-                onCheckBoxClick(binding.browserCheckbox);
-                return true;
-            }
-            return position < getDataset().size() && position >= 0
-                    && fragment.onLongClick(v, position, getDataset().get(position));
-        }
-
-        @Override
-        protected boolean isSelected() {
-            return multiSelectHelper.isSelected(getLayoutPosition());
-        }
-    }
-
-    private class SeparatorViewHolder extends ViewHolder<BrowserItemSeparatorBinding> {
-
-        public SeparatorViewHolder(BrowserItemSeparatorBinding binding) {
-            super(binding);
-        }
-
-        @Override
-        public int getType() {
-            return MediaLibraryItem.TYPE_DUMMY;
-        }
-    }
-
-    public void clear() {
-        if (!isEmpty()) update(new ArrayList<MediaLibraryItem>(0));
-    }
-
-    public List<MediaLibraryItem> getAll(){
-        return getDataset();
-    }
-
-    @Override
-    public MediaLibraryItem getItem(int position){
-        if (position < 0 || position >= getDataset().size())
-            return null;
-        return getDataset().get(position);
-    }
-
-    @Override
-    public int getItemViewType(int position){
-        return getItem(position).getItemType();
-    }
-
-    int getMediaCount() {
-        return mMediaCount;
-    }
-
-    BitmapDrawable getIcon(MediaWrapper media, boolean specialFolders) {
-        switch (media.getType()){
-            case MediaWrapper.TYPE_AUDIO:
-                return IMAGE_AUDIO;
-            case MediaWrapper.TYPE_DIR:
-                if (specialFolders) {
-                    final Uri uri = media.getUri();
-                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_MOVIES_DIRECTORY_URI.equals(uri)
-                            || AndroidDevices.MediaFolders.WHATSAPP_VIDEOS_FILE_URI.equals(uri))
-                        return IMAGE_QA_MOVIES;
-                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_MUSIC_DIRECTORY_URI.equals(uri))
-                        return IMAGE_QA_MUSIC;
-                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_PODCAST_DIRECTORY_URI.equals(uri))
-                        return IMAGE_QA_PODCASTS;
-                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_DOWNLOAD_DIRECTORY_URI.equals(uri))
-                        return IMAGE_QA_DOWNLOAD;
-                }
-                return IMAGE_FOLDER;
-            case MediaWrapper.TYPE_VIDEO:
-                return IMAGE_VIDEO;
-            case MediaWrapper.TYPE_SUBTITLE:
-                return IMAGE_SUBTITLE;
-            default:
-                return IMAGE_UNKNOWN;
-        }
-    }
-
-    private String getProtocol(MediaWrapper media) {
-        if (media.getType() != MediaWrapper.TYPE_DIR)
-            return null;
-        return media.getUri().getScheme();
-    }
-
-    protected void checkBoxAction(View v, String mrl){}
-
-    @SuppressWarnings("unchecked")
-    @Override
-    protected List<MediaLibraryItem> prepareList(List<? extends MediaLibraryItem> list) {
-        final List<MediaLibraryItem> internalList = new ArrayList<>(list);
-        mMediaCount = 0;
-        for (MediaLibraryItem item : internalList) {
-            if (item.getItemType() == MediaLibraryItem.TYPE_MEDIA
-                    && (((MediaWrapper)item).getType() == MediaWrapper.TYPE_AUDIO || ((MediaWrapper)item).getType() == MediaWrapper.TYPE_VIDEO))
-                ++mMediaCount;
-        }
-        return internalList;
-    }
-
-    @Override
-    protected void onUpdateFinished() {
-        fragment.onUpdateFinished(this);
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserAdapter.kt
new file mode 100644
index 0000000000..8e37740ee4
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserAdapter.kt
@@ -0,0 +1,288 @@
+/**
+ * **************************************************************************
+ * BaseBrowserAdapter.kt
+ * ****************************************************************************
+ * Copyright © 2015-2017 VLC authors and VideoLAN
+ * Author: Geoffrey Métais
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ * ***************************************************************************
+ */
+package org.videolan.vlc.gui.browser
+
+import android.annotation.TargetApi
+import android.graphics.BitmapFactory
+import android.graphics.drawable.BitmapDrawable
+import android.os.Build
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.databinding.ViewDataBinding
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.util.AndroidUtil
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaLibraryItem.TYPE_MEDIA
+import org.videolan.medialibrary.media.MediaLibraryItem.TYPE_STORAGE
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.medialibrary.media.Storage
+import org.videolan.tools.MultiSelectAdapter
+import org.videolan.tools.MultiSelectHelper
+import org.videolan.vlc.R
+import org.videolan.vlc.databinding.BrowserItemBinding
+import org.videolan.vlc.databinding.BrowserItemSeparatorBinding
+import org.videolan.vlc.gui.DiffUtilAdapter
+import org.videolan.vlc.gui.helpers.SelectorViewHolder
+import org.videolan.vlc.util.AndroidDevices
+import org.videolan.vlc.util.UPDATE_SELECTION
+import java.util.*
+
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+open class BaseBrowserAdapter() : DiffUtilAdapter<MediaLibraryItem, BaseBrowserAdapter.ViewHolder<ViewDataBinding>>(), MultiSelectAdapter<MediaLibraryItem> {
+
+
+    protected val TAG = "VLC/BaseBrowserAdapter"
+
+    lateinit var multiSelectHelper: MultiSelectHelper<MediaLibraryItem>
+
+    private lateinit var folderDrawable: BitmapDrawable
+    private lateinit var audioDrawable: BitmapDrawable
+    private lateinit var videoDrawable: BitmapDrawable
+    private lateinit var subtitleDrawable: BitmapDrawable
+    private lateinit var unknownDrawable: BitmapDrawable
+    private lateinit var qaMoviesDrawable: BitmapDrawable
+    private lateinit var qaMusicDrawable: BitmapDrawable
+    private lateinit var qaPodcastsDrawable: BitmapDrawable
+    private lateinit var qaDownloadDrawable: BitmapDrawable
+
+    protected lateinit var fragment: BaseBrowserFragment
+    var mediaCount = 0
+    private var networkRoot = false
+    private var specialIcons = false
+
+    constructor(fragment: BaseBrowserFragment) : this() {
+        this.fragment = fragment
+        multiSelectHelper = MultiSelectHelper(this, UPDATE_SELECTION)
+        val root = fragment.isRootDirectory
+        val fileBrowser = fragment is FileBrowserFragment
+        val filesRoot = root && fileBrowser
+        networkRoot = root && fragment is NetworkBrowserFragment
+        val mrl = fragment.mrl
+        specialIcons = filesRoot || fileBrowser && mrl != null && mrl.endsWith(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY)
+        // Setup resources
+        val res = fragment.requireContext().resources
+        folderDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_menu_folder))
+        audioDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_audio_normal))
+        videoDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_video_normal))
+        subtitleDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_subtitle_normal))
+        unknownDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_unknown_normal))
+        qaMoviesDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_movies_normal))
+        qaMusicDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_music_normal))
+        qaPodcastsDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_podcasts_normal))
+        qaDownloadDrawable = BitmapDrawable(res, BitmapFactory.decodeResource(res, R.drawable.ic_browser_download_normal))
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder<ViewDataBinding> {
+        val inflater = LayoutInflater.from(parent.context)
+        return if (viewType == TYPE_MEDIA || viewType == TYPE_STORAGE)
+            MediaViewHolder(BrowserItemBinding.inflate(inflater, parent, false)) as ViewHolder<ViewDataBinding>
+        else
+            SeparatorViewHolder(BrowserItemSeparatorBinding.inflate(inflater, parent, false)) as ViewHolder<ViewDataBinding>
+    }
+
+    override fun onBindViewHolder(holder: ViewHolder<ViewDataBinding>, position: Int) {
+        val viewType = getItemViewType(position)
+        if (viewType == TYPE_MEDIA) {
+            onBindMediaViewHolder(holder as MediaViewHolder, position)
+        } else {
+            val vh = holder as SeparatorViewHolder
+            vh.binding.title = dataset[position].title
+        }
+    }
+
+    override fun onBindViewHolder(holder: ViewHolder<ViewDataBinding>, position: Int, payloads: MutableList<Any>) {
+        if (payloads.isEmpty())
+            onBindViewHolder(holder, position)
+        else if (payloads[0] is CharSequence) {
+            (holder as MediaViewHolder).binding.text.visibility = View.VISIBLE
+            (holder as MediaViewHolder).binding.text.text = payloads[0] as CharSequence
+        } else if (payloads[0] is Int) {
+            val value = payloads[0] as Int
+            if (value == UPDATE_SELECTION) holder.selectView(multiSelectHelper.isSelected(position))
+        }
+    }
+
+    private fun onBindMediaViewHolder(vh: MediaViewHolder, position: Int) {
+        val media = getItem(position) as MediaWrapper
+        val isFavorite = media.hasStateFlags(MediaLibraryItem.FLAG_FAVORITE)
+        vh.binding.item = media
+        val scheme = media.uri.scheme
+        vh.binding.hasContextMenu = ((!networkRoot || isFavorite)
+                && "content" != scheme
+                && "otg" != scheme)
+        vh.binding.filename = if (media.type != MediaWrapper.TYPE_DIR && "file" == scheme) media.fileName else null
+        if (networkRoot) vh.binding.protocol = getProtocol(media)
+        vh.binding.cover = getIcon(media, specialIcons)
+        vh.selectView(multiSelectHelper.isSelected(position))
+    }
+
+    override fun getItemCount(): Int {
+        return dataset.size
+    }
+
+
+    abstract inner class ViewHolder<T : ViewDataBinding>(binding: T) : SelectorViewHolder<T>(binding) {
+
+        abstract fun getType(): Int
+
+        open fun onClick(v: View) {}
+
+        open fun onImageClick(v: View) {}
+
+        open fun onLongClick(v: View): Boolean {
+            return false
+        }
+
+        open fun onCheckBoxClick(v: View) {}
+
+        open fun onMoreClick(v: View) {}
+
+    }
+
+    @TargetApi(Build.VERSION_CODES.M)
+    internal inner class MediaViewHolder(binding: BrowserItemBinding) : ViewHolder<BrowserItemBinding>(binding), View.OnFocusChangeListener {
+
+        init {
+            binding.holder = this
+            if (AndroidUtil.isMarshMallowOrLater)
+                itemView.setOnContextClickListener { v ->
+                    onMoreClick(v)
+                    true
+                }
+        }
+
+
+        override fun onCheckBoxClick(v: View) {
+            if (getItem(layoutPosition).itemType == TYPE_STORAGE)
+                checkBoxAction(v, (getItem(layoutPosition) as Storage).uri.toString())
+        }
+
+        override fun getType(): Int {
+            return TYPE_MEDIA
+        }
+
+        override fun onClick(v: View) {
+            val position = layoutPosition
+            if (position < dataset.size && position >= 0)
+                fragment.onClick(v, position, dataset[position])
+        }
+
+        override fun onImageClick(v: View) {
+            val position = layoutPosition
+            if (position < dataset.size && position >= 0)
+                fragment.onImageClick(v, position, dataset[position])
+        }
+
+        override fun onMoreClick(v: View) {
+            val position = layoutPosition
+            if (position < dataset.size && position >= 0)
+                fragment.onCtxClick(v, position, dataset[position])
+        }
+
+        override fun onLongClick(v: View): Boolean {
+            val position = layoutPosition
+            if (getItem(position).itemType == TYPE_STORAGE && AndroidDevices.showTvUi(itemView.context)) {
+                binding.browserCheckbox.toggle()
+                onCheckBoxClick(binding.browserCheckbox)
+                return true
+            }
+            return (position < dataset.size && position >= 0
+                    && fragment.onLongClick(v, position, dataset[position]))
+        }
+
+        override fun isSelected(): Boolean {
+            return multiSelectHelper.isSelected(layoutPosition)
+        }
+    }
+
+    private inner class SeparatorViewHolder(binding: BrowserItemSeparatorBinding) : ViewHolder<BrowserItemSeparatorBinding>(binding) {
+
+        override fun getType(): Int {
+            return MediaLibraryItem.TYPE_DUMMY
+        }
+    }
+
+    fun clear() {
+        if (!isEmpty()) update(ArrayList(0))
+    }
+
+    fun getAll(): List<MediaLibraryItem> {
+        return dataset
+    }
+
+    override fun getItem(position: Int): MediaLibraryItem {
+        return dataset[position]
+    }
+
+    override fun getItemViewType(position: Int): Int {
+        return getItem(position).itemType
+    }
+
+
+    fun getIcon(media: MediaWrapper, specialFolders: Boolean): BitmapDrawable {
+        when (media.type) {
+            MediaWrapper.TYPE_AUDIO -> return audioDrawable
+            MediaWrapper.TYPE_DIR -> {
+                if (specialFolders) {
+                    val uri = media.uri
+                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_MOVIES_DIRECTORY_URI == uri || AndroidDevices.MediaFolders.WHATSAPP_VIDEOS_FILE_URI == uri)
+                        return qaMoviesDrawable
+                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_MUSIC_DIRECTORY_URI == uri)
+                        return qaMusicDrawable
+                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_PODCAST_DIRECTORY_URI == uri)
+                        return qaPodcastsDrawable
+                    if (AndroidDevices.MediaFolders.EXTERNAL_PUBLIC_DOWNLOAD_DIRECTORY_URI == uri)
+                        return qaDownloadDrawable
+                }
+                return folderDrawable
+            }
+            MediaWrapper.TYPE_VIDEO -> return videoDrawable
+            MediaWrapper.TYPE_SUBTITLE -> return subtitleDrawable
+            else -> return unknownDrawable
+        }
+    }
+
+    private fun getProtocol(media: MediaWrapper): String? {
+        return if (media.type != MediaWrapper.TYPE_DIR) null else media.uri.scheme
+    }
+
+    open fun checkBoxAction(v: View, mrl: String) {}
+
+    override fun prepareList(list: List<MediaLibraryItem>): List<MediaLibraryItem> {
+        val internalList = ArrayList(list)
+        mediaCount = 0
+        for (item in internalList) {
+            if (item.itemType == TYPE_MEDIA && ((item as MediaWrapper).type == MediaWrapper.TYPE_AUDIO || item.type == MediaWrapper.TYPE_VIDEO))
+                ++mediaCount
+        }
+        return internalList
+    }
+
+    override fun onUpdateFinished() {
+        fragment.onUpdateFinished(this)
+    }
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt
index 10cc6d88ef..72a6c6a812 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt
@@ -67,6 +67,7 @@ private const val MSG_SHOW_LOADING = 0
 internal const val MSG_HIDE_LOADING = 1
 private const val MSG_REFRESH = 3
 
+@ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
 abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefreshable, SwipeRefreshLayout.OnRefreshListener, View.OnClickListener, IEventsHandler, CtxActionReceiver {
 
@@ -106,11 +107,11 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
         browserFavRepository = BrowserFavRepository.getInstance(requireContext())
     }
 
-    override fun onPrepareOptionsMenu(menu: Menu) {
+    override fun onPrepareOptionsMenu(menu: Menu?) {
         super.onPrepareOptionsMenu(menu)
-        val item = menu.findItem(R.id.ml_menu_filter)
+        val item = menu?.findItem(R.id.ml_menu_filter)
         if (item != null) item.isVisible = enableSearchOption()
-        val sortItem = menu.findItem(R.id.ml_menu_sortby)
+        val sortItem = menu?.findItem(R.id.ml_menu_sortby)
         if (sortItem != null) sortItem.isVisible = !isRootDirectory
     }
 
@@ -132,7 +133,7 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
         viewModel.getDescriptionUpdate().observe(this, Observer { pair -> if (pair != null) adapter.notifyItemChanged(pair.first, pair.second) })
     }
 
-    open fun registerSwiperRefreshlayout() = mSwipeRefreshLayout.setOnRefreshListener(this)
+    open fun registerSwiperRefreshlayout() = swipeRefreshLayout?.setOnRefreshListener(this)
 
     override fun setBreadcrumb() {
         val ariane = requireActivity().findViewById<RecyclerView>(R.id.ariane) ?: return
@@ -157,7 +158,7 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
 
     override fun onStart() {
         super.onStart()
-        mFabPlay?.run {
+        fabPlay.run {
             setImageResource(R.drawable.ic_fab_play)
             updateFab()
         }
@@ -181,25 +182,26 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
         super.onSaveInstanceState(outState)
     }
 
-    override fun getTitle(): String? {
-        return when {
-            isRootDirectory -> categoryTitle
-            currentMedia != null -> currentMedia!!.title
-            else -> mrl
-        }
-    }
 
-    public override fun getSubTitle(): String? {
-        if (isRootDirectory) return null
-        var mrl = mrl?.removeFileProtocole() ?: ""
-        if (!TextUtils.isEmpty(mrl)) {
-            if (this is FileBrowserFragment && mrl.startsWith(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY))
-                mrl = getString(R.string.internal_memory) + mrl.substring(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY.length)
-            mrl = Uri.decode(mrl).replace("://".toRegex(), " ").replace("/".toRegex(), " > ")
-        }
-        return if (currentMedia != null) mrl else null
+    override fun getTitle(): String = when {
+        isRootDirectory -> categoryTitle
+        currentMedia != null -> currentMedia!!.title
+        else -> mrl ?: ""
     }
 
+
+    override val subTitle: String? =
+            if (isRootDirectory) null else {
+                var mrl = mrl?.removeFileProtocole() ?: ""
+                if (!TextUtils.isEmpty(mrl)) {
+                    if (this is FileBrowserFragment && mrl.startsWith(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY))
+                        mrl = getString(R.string.internal_memory) + mrl.substring(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY.length)
+                    mrl = Uri.decode(mrl).replace("://".toRegex(), " ").replace("/".toRegex(), " > ")
+                }
+                if (currentMedia != null) mrl else null
+            }
+
+
     fun goBack(): Boolean {
         val activity = activity ?: return false
         if (!isRootDirectory) activity.supportFragmentManager.popBackStack()
@@ -215,7 +217,8 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
         viewModel.saveList(media)
         args.putParcelable(KEY_MEDIA, media)
         next.arguments = args
-        if (save) ft.addToBackStack(if (isRootDirectory) "root" else currentMedia?.title ?: FileUtils.getFileNameFromPath(mrl))
+        if (save) ft.addToBackStack(if (isRootDirectory) "root" else currentMedia?.title
+                ?: FileUtils.getFileNameFromPath(mrl))
         ft.replace(R.id.fragment_placeholder, next, media.title)
         ft.commit()
     }
@@ -229,16 +232,18 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
      * Update views visibility and emptiness info
      */
     protected open fun updateEmptyView() {
-        if (mSwipeRefreshLayout == null) return
-        if (Util.isListEmpty(getViewModel().dataset.value)) {
-            if (mSwipeRefreshLayout.isRefreshing) {
-                binding.empty.setText(R.string.loading)
-                binding.empty.visibility = View.VISIBLE
-                binding.networkList.visibility = View.GONE
-            } else {
-                binding.empty.setText(R.string.directory_empty)
-                binding.empty.visibility = View.VISIBLE
-                binding.networkList.visibility = View.GONE
+        if (swipeRefreshLayout == null) return
+        if (Util.isListEmpty(viewModel.dataset.value)) {
+            if (swipeRefreshLayout != null) {
+                if (swipeRefreshLayout!!.isRefreshing) {
+                    binding.empty.setText(R.string.loading)
+                    binding.empty.visibility = View.VISIBLE
+                    binding.networkList.visibility = View.GONE
+                } else {
+                    binding.empty.setText(R.string.directory_empty)
+                    binding.empty.visibility = View.VISIBLE
+                    binding.networkList.visibility = View.GONE
+                }
             }
         } else if (binding.empty.visibility == View.VISIBLE) {
             binding.empty.visibility = View.GONE
@@ -261,10 +266,10 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
         override fun handleMessage(msg: Message) {
             val fragment = owner ?: return
             when (msg.what) {
-                MSG_SHOW_LOADING -> fragment.mSwipeRefreshLayout.isRefreshing = true
+                MSG_SHOW_LOADING -> fragment.swipeRefreshLayout?.isRefreshing = true
                 MSG_HIDE_LOADING -> {
                     removeMessages(MSG_SHOW_LOADING)
-                    fragment.mSwipeRefreshLayout?.isRefreshing = false
+                    fragment.swipeRefreshLayout?.isRefreshing = false
                 }
                 MSG_REFRESH -> {
                     removeMessages(MSG_REFRESH)
@@ -276,7 +281,9 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
 
     override fun clear() = adapter.clear()
 
-    override fun removeItem(item: MediaLibraryItem?): Boolean {
+
+    override fun removeItem(item: MediaLibraryItem): Boolean {
+
         val view = view ?: return false
         val mw = item as? MediaWrapper ?: return false
         val cancel = Runnable { viewModel.refresh() }
@@ -349,18 +356,18 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
     }
 
     override fun onDestroyActionMode(mode: ActionMode?) {
-        mActionMode = null
+        actionMode = null
         adapter.multiSelectHelper.clearSelection()
     }
 
-    override fun onOptionsItemSelected(item: MenuItem): Boolean {
-        when (item!!.itemId) {
+    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
+        return when (item!!.itemId) {
             R.id.ml_menu_save -> {
                 toggleFavorite()
                 onPrepareOptionsMenu(menu)
-                return true
+                true
             }
-            else -> return super.onOptionsItemSelected(item)
+            else -> super.onOptionsItemSelected(item)
         }
     }
 
@@ -378,7 +385,7 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
 
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
         val mediaWrapper = item as MediaWrapper
-        if (mActionMode != null) {
+        if (actionMode != null) {
             if (mediaWrapper.type == MediaWrapper.TYPE_AUDIO ||
                     mediaWrapper.type == MediaWrapper.TYPE_VIDEO ||
                     mediaWrapper.type == MediaWrapper.TYPE_DIR) {
@@ -393,12 +400,12 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
     }
 
     override fun onLongClick(v: View, position: Int, item: MediaLibraryItem): Boolean {
-        if (mActionMode != null || item.itemType != MediaLibraryItem.TYPE_MEDIA) return false
+        if (actionMode != null || item.itemType != MediaLibraryItem.TYPE_MEDIA) return false
         val mediaWrapper = item as MediaWrapper
         if (mediaWrapper.type == MediaWrapper.TYPE_AUDIO ||
                 mediaWrapper.type == MediaWrapper.TYPE_VIDEO ||
                 mediaWrapper.type == MediaWrapper.TYPE_DIR) {
-            if (mActionMode != null) return false
+            if (actionMode != null) return false
             adapter.multiSelectHelper.toggleSelection(position)
             startActionMode()
         } else onCtxClick(v, position, item)
@@ -406,7 +413,7 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
     }
 
     override fun onCtxClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode == null && item.itemType == MediaLibraryItem.TYPE_MEDIA) coroutineScope.launch {
+        if (actionMode == null && item.itemType == MediaLibraryItem.TYPE_MEDIA) coroutineScope.launch {
             val mw = item as MediaWrapper
             if (mw.uri.scheme == "content" || mw.uri.scheme == OTG_SCHEME) return@launch
             var flags = if (!isRootDirectory && this@BaseBrowserFragment is FileBrowserFragment) CTX_DELETE else 0
@@ -459,7 +466,7 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
     }
 
     override fun onImageClick(v: View, position: Int, item: MediaLibraryItem) {
-        if (mActionMode != null) {
+        if (actionMode != null) {
             onClick(v, position, item)
             return
         }
@@ -469,10 +476,10 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
     override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
 
     override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
-        if (mSwipeRefreshLayout != null) mSwipeRefreshLayout.isRefreshing = false
+        if (swipeRefreshLayout != null) swipeRefreshLayout!!.isRefreshing = false
         handler.sendEmptyMessage(MSG_HIDE_LOADING)
         updateEmptyView()
-        if (!Util.isListEmpty(getViewModel().dataset.value)) {
+        if (!Util.isListEmpty(viewModel.dataset.value)) {
             if (savedPosition > 0) {
                 layoutManager.scrollToPositionWithOffset(savedPosition, 0)
                 savedPosition = 0
@@ -489,12 +496,12 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
     }
 
     private fun updateFab() {
-        mFabPlay?.let {
+        fabPlay?.let {
             if (adapter.mediaCount > 0) {
-                it.visibility = View.VISIBLE
+                it.show()
                 it.setOnClickListener(this)
             } else {
-                it.visibility = View.GONE
+                it.hide()
                 it.setOnClickListener(null)
             }
         }
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionAdapter.java b/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionAdapter.java
deleted file mode 100644
index 7090157a60..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionAdapter.java
+++ /dev/null
@@ -1,135 +0,0 @@
-package org.videolan.vlc.gui.browser;
-
-import androidx.databinding.DataBindingUtil;
-import android.net.Uri;
-import androidx.recyclerview.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.R;
-import org.videolan.vlc.databinding.ExtensionItemViewBinding;
-import org.videolan.vlc.extensions.api.VLCExtensionItem;
-import org.videolan.vlc.media.MediaUtils;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class ExtensionAdapter extends RecyclerView.Adapter<ExtensionAdapter.ViewHolder> {
-    private static final String TAG = "VLC/ExtensionAdapter";
-
-    ExtensionBrowser mFragment;
-    List<VLCExtensionItem> mItemsList = new ArrayList<>();
-
-    public class ViewHolder extends RecyclerView.ViewHolder implements View.OnLongClickListener {
-
-        public ExtensionItemViewBinding binding;
-
-        public ViewHolder(ExtensionItemViewBinding binding) {
-            super(binding.getRoot());
-            this.binding = binding;
-            binding.setHolder(this);
-        }
-
-        public void onClick(View v){
-            final VLCExtensionItem item = getItem(getLayoutPosition());
-            if (item.type == VLCExtensionItem.TYPE_DIRECTORY) {
-                mFragment.browseItem(item);
-            } else if (item.type == VLCExtensionItem.TYPE_AUDIO || item.type == VLCExtensionItem.TYPE_VIDEO){
-                MediaWrapper mw = new MediaWrapper(Uri.parse(item.link));
-                mw.setDisplayTitle(item.getTitle());
-                mw.setDescription(item.getSubTitle());
-                mw.setType(getTypeAccordingToItem(item.type));
-                MediaUtils.INSTANCE.openMedia(v.getContext(), mw);
-            }
-        }
-
-        public void onMoreClick(View v){
-            openContextMenu();
-        }
-
-        @Override
-        public boolean onLongClick(View v) {
-            return openContextMenu();
-        }
-
-        private boolean openContextMenu() {
-            if (mFragment == null)
-                return false;
-            mFragment.openContextMenu(getLayoutPosition());
-            return true;
-        }
-    }
-
-    public ExtensionAdapter(ExtensionBrowser fragment) {
-        mFragment = fragment;
-    }
-
-    @Override
-    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        return new ViewHolder((ExtensionItemViewBinding) DataBindingUtil.inflate(LayoutInflater.from(parent.getContext()),R.layout.extension_item_view, parent, false));
-    }
-
-    @Override
-    public void onBindViewHolder(ViewHolder holder, int position) {
-        final VLCExtensionItem item = getItem(position);
-        holder.binding.setItem(item);
-        holder.binding.executePendingBindings();
-    }
-
-    private int getIconResId(VLCExtensionItem item) {
-        switch (item.type){
-            case VLCExtensionItem.TYPE_AUDIO:
-                return R.drawable.ic_browser_audio_normal;
-            case VLCExtensionItem.TYPE_DIRECTORY:
-                return R.drawable.ic_menu_folder;
-            case VLCExtensionItem.TYPE_VIDEO:
-                return R.drawable.ic_browser_video_normal;
-            case VLCExtensionItem.TYPE_SUBTITLE:
-                return R.drawable.ic_browser_subtitle_normal;
-            default:
-                return R.drawable.ic_browser_unknown_normal;
-        }
-    }
-
-    public VLCExtensionItem getItem(int position) {
-        return mItemsList.get(position);
-    }
-
-    public List<VLCExtensionItem> getAll() {
-        return mItemsList;
-    }
-
-    @Override
-    public int getItemCount() {
-        return mItemsList.size();
-    }
-
-    public void addAll(List<VLCExtensionItem> list) {
-        mItemsList.clear();
-        mItemsList.addAll(list);
-        notifyDataSetChanged();
-    }
-
-    public void clear() {
-        mItemsList.clear();
-    }
-
-    private int getTypeAccordingToItem(int type) {
-        switch (type) {
-            case VLCExtensionItem.TYPE_DIRECTORY:
-                return MediaWrapper.TYPE_DIR;
-            case VLCExtensionItem.TYPE_VIDEO:
-                return MediaWrapper.TYPE_VIDEO;
-            case VLCExtensionItem.TYPE_AUDIO:
-                return MediaWrapper.TYPE_AUDIO;
-            case VLCExtensionItem.TYPE_PLAYLIST:
-                return MediaWrapper.TYPE_PLAYLIST;
-            case VLCExtensionItem.TYPE_SUBTITLE:
-                return MediaWrapper.TYPE_SUBTITLE;
-            default:
-                return MediaWrapper.TYPE_ALL;
-        }
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionAdapter.kt
new file mode 100644
index 0000000000..025a787fae
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionAdapter.kt
@@ -0,0 +1,114 @@
+package org.videolan.vlc.gui.browser
+
+import android.net.Uri
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import androidx.databinding.DataBindingUtil
+import androidx.databinding.ViewDataBinding
+import androidx.recyclerview.widget.RecyclerView
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.R
+import org.videolan.vlc.databinding.ExtensionItemViewBinding
+import org.videolan.vlc.extensions.api.VLCExtensionItem
+import org.videolan.vlc.media.MediaUtils
+import java.util.*
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class ExtensionAdapter(internal var fragment: ExtensionBrowser?) : RecyclerView.Adapter<ExtensionAdapter.ViewHolder>() {
+    private var itemsList: MutableList<VLCExtensionItem> = ArrayList()
+
+    val all: List<VLCExtensionItem>
+        get() = itemsList
+
+    inner class ViewHolder(var binding: ExtensionItemViewBinding) : RecyclerView.ViewHolder(binding.root), View.OnLongClickListener {
+
+        init {
+            binding.holder = this
+        }
+
+        fun onClick(v: View) {
+            val item = getItem(layoutPosition)
+            if (item.type == VLCExtensionItem.TYPE_DIRECTORY) {
+                fragment!!.browseItem(item)
+            } else if (item.type == VLCExtensionItem.TYPE_AUDIO || item.type == VLCExtensionItem.TYPE_VIDEO) {
+                val mw = MediaWrapper(Uri.parse(item.link))
+                mw.setDisplayTitle(item.getTitle())
+                mw.description = item.getSubTitle()
+                mw.type = getTypeAccordingToItem(item.type)
+                MediaUtils.openMedia(v.context, mw)
+            }
+        }
+
+        fun onMoreClick(v: View) {
+            openContextMenu()
+        }
+
+        override fun onLongClick(v: View): Boolean {
+            return openContextMenu()
+        }
+
+        private fun openContextMenu(): Boolean {
+            if (fragment == null)
+                return false
+            fragment!!.openContextMenu(layoutPosition)
+            return true
+        }
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
+        return ViewHolder(DataBindingUtil.inflate<ViewDataBinding>(LayoutInflater.from(parent.context), R.layout.extension_item_view, parent, false) as ExtensionItemViewBinding)
+    }
+
+    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
+        val item = getItem(position)
+        holder.binding.item = item
+        holder.binding.executePendingBindings()
+    }
+
+    private fun getIconResId(item: VLCExtensionItem): Int {
+        return when (item.type) {
+            VLCExtensionItem.TYPE_AUDIO -> R.drawable.ic_browser_audio_normal
+            VLCExtensionItem.TYPE_DIRECTORY -> R.drawable.ic_menu_folder
+            VLCExtensionItem.TYPE_VIDEO -> R.drawable.ic_browser_video_normal
+            VLCExtensionItem.TYPE_SUBTITLE -> R.drawable.ic_browser_subtitle_normal
+            else -> R.drawable.ic_browser_unknown_normal
+        }
+    }
+
+    fun getItem(position: Int): VLCExtensionItem {
+        return itemsList[position]
+    }
+
+    override fun getItemCount(): Int {
+        return itemsList.size
+    }
+
+    fun addAll(list: List<VLCExtensionItem>) {
+        itemsList.clear()
+        itemsList.addAll(list)
+        notifyDataSetChanged()
+    }
+
+    fun clear() {
+        itemsList.clear()
+    }
+
+    private fun getTypeAccordingToItem(type: Int): Int {
+        return when (type) {
+            VLCExtensionItem.TYPE_DIRECTORY -> MediaWrapper.TYPE_DIR
+            VLCExtensionItem.TYPE_VIDEO -> MediaWrapper.TYPE_VIDEO
+            VLCExtensionItem.TYPE_AUDIO -> MediaWrapper.TYPE_AUDIO
+            VLCExtensionItem.TYPE_PLAYLIST -> MediaWrapper.TYPE_PLAYLIST
+            VLCExtensionItem.TYPE_SUBTITLE -> MediaWrapper.TYPE_SUBTITLE
+            else -> MediaWrapper.TYPE_ALL
+        }
+    }
+
+    companion object {
+        private val TAG = "VLC/ExtensionAdapter"
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionBrowser.java b/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionBrowser.java
deleted file mode 100644
index b02410381c..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionBrowser.java
+++ /dev/null
@@ -1,223 +0,0 @@
-package org.videolan.vlc.gui.browser;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import com.google.android.material.floatingactionbutton.FloatingActionButton;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentActivity;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.R;
-import org.videolan.vlc.extensions.ExtensionListing;
-import org.videolan.vlc.extensions.ExtensionManagerService;
-import org.videolan.vlc.extensions.Utils;
-import org.videolan.vlc.extensions.api.VLCExtensionItem;
-import org.videolan.vlc.gui.dialogs.ContextSheetKt;
-import org.videolan.vlc.gui.dialogs.CtxActionReceiver;
-import org.videolan.vlc.gui.view.SwipeRefreshLayout;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.WeakHandler;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class ExtensionBrowser extends Fragment implements View.OnClickListener, androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener, CtxActionReceiver {
-
-    public static final String TAG = "VLC/ExtensionBrowser";
-
-    public static final String KEY_ITEMS_LIST = "key_items_list";
-    public static final String KEY_SHOW_FAB = "key_fab";
-    public static final String KEY_TITLE = "key_title";
-
-
-    private static final int ACTION_HIDE_REFRESH = 42;
-    private static final int ACTION_SHOW_REFRESH = 43;
-
-    private static final int REFRESH_TIMEOUT = 5000;
-
-    private String mTitle;
-    private FloatingActionButton mAddDirectoryFAB;
-    private ExtensionAdapter mAdapter;
-    protected RecyclerView mRecyclerView;
-    protected TextView mEmptyView;
-    protected SwipeRefreshLayout mSwipeRefreshLayout;
-
-    private ExtensionManagerService mExtensionManagerService;
-    private boolean showSettings = false;
-    private boolean mustBeTerminated = false;
-
-    public void setExtensionService(ExtensionManagerService service) {
-        mExtensionManagerService = service;
-    }
-
-    public ExtensionBrowser() {
-        mAdapter = new ExtensionAdapter(this);
-    }
-
-    @Override
-    public void onCreate(Bundle bundle) {
-        super.onCreate(bundle);
-        if (bundle == null) bundle = getArguments();
-        if (bundle != null) {
-            mTitle = bundle.getString(KEY_TITLE);
-            showSettings = bundle.getBoolean(KEY_SHOW_FAB);
-            final List<VLCExtensionItem> list = bundle.getParcelableArrayList(KEY_ITEMS_LIST);
-            if (list != null) mAdapter.addAll(list);
-        }
-        setHasOptionsMenu(true);
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState){
-        final View v = inflater.inflate(R.layout.directory_browser, container, false);
-        mRecyclerView = v.findViewById(R.id.network_list);
-        mEmptyView = v.findViewById(android.R.id.empty);
-        mEmptyView.setText(R.string.extension_empty);
-        mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));
-        mRecyclerView.setAdapter(mAdapter);
-        registerForContextMenu(mRecyclerView);
-        mSwipeRefreshLayout = v.findViewById(R.id.swipeLayout);
-        mSwipeRefreshLayout.setOnRefreshListener(this);
-        return v;
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        if (mustBeTerminated)
-            getActivity().getSupportFragmentManager().beginTransaction().remove(this).commit();
-        mustBeTerminated = true;
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        setTitle(mTitle);
-        updateDisplay();
-        if (showSettings) {
-            if (mAddDirectoryFAB == null) mAddDirectoryFAB = getActivity().findViewById(R.id.fab);
-            mAddDirectoryFAB.setImageResource(R.drawable.ic_fab_add);
-            mAddDirectoryFAB.setVisibility(View.VISIBLE);
-            mAddDirectoryFAB.setOnClickListener(this);
-        }
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        if (showSettings) {
-            mAddDirectoryFAB.setVisibility(View.GONE);
-            mAddDirectoryFAB.setOnClickListener(null);
-        }
-    }
-
-    private void setTitle(String title) {
-        final AppCompatActivity activity = (AppCompatActivity)getActivity();
-        if (activity != null && activity.getSupportActionBar() != null) {
-            activity.getSupportActionBar().setTitle(title);
-            getActivity().invalidateOptionsMenu();
-        }
-    }
-
-    public void goBack() {
-        final FragmentActivity activity = getActivity();
-        if (activity != null && activity.getSupportFragmentManager().popBackStackImmediate()) getActivity().finish();
-    }
-
-    public void doRefresh(String title, List<VLCExtensionItem> items) {
-        setTitle(title);
-        mAdapter.addAll(items);
-    }
-
-    private void updateDisplay() {
-        if (mAdapter.getItemCount() > 0) {
-            mEmptyView.setVisibility(View.GONE);
-            mRecyclerView.setVisibility(View.VISIBLE);
-        } else {
-            mEmptyView.setVisibility(View.VISIBLE);
-            mRecyclerView.setVisibility(View.GONE);
-        }
-    }
-
-    public void browseItem(VLCExtensionItem item) {
-        mExtensionManagerService.browse(item.stringId);
-    }
-
-    @Override
-    public void onClick(View v) {
-        if (v.getId() == mAddDirectoryFAB.getId()){
-            final ExtensionListing extension = mExtensionManagerService.getCurrentExtension();
-            if (extension == null) return;
-            final Intent intent = new Intent(Intent.ACTION_VIEW);
-            intent.setComponent(extension.settingsActivity());
-            startActivity(intent);
-        }
-    }
-
-    @Override
-    public void onRefresh() {
-        mExtensionManagerService.refresh();
-        mHandler.sendEmptyMessageDelayed(ACTION_HIDE_REFRESH, REFRESH_TIMEOUT);
-    }
-
-    public void openContextMenu(final int position) {
-        ContextSheetKt.showContext(requireActivity(), this, position, mAdapter.getItem(position).title, Constants.CTX_PLAY_ALL|Constants.CTX_APPEND|Constants.CTX_PLAY_AS_AUDIO|Constants.CTX_ITEM_DL);
-    }
-
-    @Override
-    public void onCtxAction(int position, int option) {
-        switch (option) {
-            case Constants.CTX_PLAY_ALL:
-                final List<VLCExtensionItem> items = mAdapter.getAll();
-                final List<MediaWrapper> medias = new ArrayList<>(items.size());
-                for (VLCExtensionItem vlcItem : items) medias.add(Utils.mediawrapperFromExtension(vlcItem));
-                MediaUtils.INSTANCE.openList(getActivity(), medias, position);
-                break;
-            case Constants.CTX_APPEND:
-                MediaUtils.INSTANCE.appendMedia(getActivity(), Utils.mediawrapperFromExtension(mAdapter.getItem(position)));
-                break;
-            case Constants.CTX_PLAY_AS_AUDIO:
-                final MediaWrapper mw = Utils.mediawrapperFromExtension(mAdapter.getItem(position));
-                mw.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-                MediaUtils.INSTANCE.openMedia(getActivity(), mw);
-                break;
-            case Constants.CTX_ITEM_DL:
-                //TODO
-                break;
-        }
-    }
-
-    private Handler mHandler = new ExtensionBrowserHandler(this);
-
-    private class ExtensionBrowserHandler extends WeakHandler<ExtensionBrowser> {
-
-        ExtensionBrowserHandler(ExtensionBrowser owner) {
-            super(owner);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case ACTION_HIDE_REFRESH:
-                    removeMessages(ACTION_SHOW_REFRESH);
-                    getOwner().mSwipeRefreshLayout.setRefreshing(false);
-                    break;
-                case ACTION_SHOW_REFRESH:
-                    removeMessages(ACTION_HIDE_REFRESH);
-                    getOwner().mSwipeRefreshLayout.setRefreshing(true);
-                    sendEmptyMessageDelayed(ACTION_HIDE_REFRESH, REFRESH_TIMEOUT);
-                    break;
-            }
-        }
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionBrowser.kt b/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionBrowser.kt
new file mode 100644
index 0000000000..595ea1ecb3
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/ExtensionBrowser.kt
@@ -0,0 +1,203 @@
+package org.videolan.vlc.gui.browser
+
+import android.content.Intent
+import android.os.Bundle
+import android.os.Message
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import androidx.appcompat.app.AppCompatActivity
+import androidx.fragment.app.Fragment
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import com.google.android.material.floatingactionbutton.FloatingActionButton
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.R
+import org.videolan.vlc.extensions.ExtensionManagerService
+import org.videolan.vlc.extensions.Utils
+import org.videolan.vlc.extensions.api.VLCExtensionItem
+import org.videolan.vlc.gui.dialogs.CtxActionReceiver
+import org.videolan.vlc.gui.dialogs.showContext
+import org.videolan.vlc.gui.view.SwipeRefreshLayout
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.util.*
+import java.util.*
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+class ExtensionBrowser : Fragment(), View.OnClickListener, androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener, CtxActionReceiver {
+
+    private var mTitle: String? = null
+    private var mAddDirectoryFAB: FloatingActionButton? = null
+    private val mAdapter: ExtensionAdapter = ExtensionAdapter(this)
+    private lateinit var mRecyclerView: RecyclerView
+    private lateinit var mEmptyView: TextView
+    private lateinit var mSwipeRefreshLayout: SwipeRefreshLayout
+
+    private var mExtensionManagerService: ExtensionManagerService? = null
+    private var showSettings = false
+    private var mustBeTerminated = false
+
+    private val mHandler = ExtensionBrowserHandler(this)
+
+    fun setExtensionService(service: ExtensionManagerService) {
+        mExtensionManagerService = service
+    }
+
+    override fun onCreate(bundle: Bundle?) {
+        var bundle = bundle
+        super.onCreate(bundle)
+        if (bundle == null) bundle = arguments
+        if (bundle != null) {
+            mTitle = bundle.getString(KEY_TITLE)
+            showSettings = bundle.getBoolean(KEY_SHOW_FAB)
+            val list = bundle.getParcelableArrayList<VLCExtensionItem>(KEY_ITEMS_LIST)
+            if (list != null) mAdapter.addAll(list)
+        }
+        setHasOptionsMenu(true)
+    }
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        val v = inflater.inflate(R.layout.directory_browser, container, false)
+        mRecyclerView = v.findViewById(R.id.network_list)
+        mEmptyView = v.findViewById(android.R.id.empty)
+        mEmptyView.setText(R.string.extension_empty)
+        mRecyclerView.layoutManager = LinearLayoutManager(activity)
+        mRecyclerView.adapter = mAdapter
+        registerForContextMenu(mRecyclerView)
+        mSwipeRefreshLayout = v.findViewById(R.id.swipeLayout)
+        mSwipeRefreshLayout.setOnRefreshListener(this)
+        return v
+    }
+
+    override fun onResume() {
+        super.onResume()
+        if (mustBeTerminated)
+            activity!!.supportFragmentManager.beginTransaction().remove(this).commit()
+        mustBeTerminated = true
+    }
+
+    override fun onStart() {
+        super.onStart()
+        setTitle(mTitle)
+        updateDisplay()
+        if (showSettings) {
+            if (mAddDirectoryFAB == null) mAddDirectoryFAB = activity!!.findViewById(R.id.fab)
+            mAddDirectoryFAB!!.setImageResource(R.drawable.ic_fab_add)
+            mAddDirectoryFAB!!.show()
+            mAddDirectoryFAB!!.setOnClickListener(this)
+        }
+    }
+
+    override fun onStop() {
+        super.onStop()
+        if (showSettings) {
+            mAddDirectoryFAB!!.hide()
+            mAddDirectoryFAB!!.setOnClickListener(null)
+        }
+    }
+
+    private fun setTitle(title: String?) {
+        val activity = activity as AppCompatActivity?
+        if (activity != null && activity.supportActionBar != null) {
+            activity.supportActionBar!!.title = title
+            getActivity()!!.invalidateOptionsMenu()
+        }
+    }
+
+    fun goBack() {
+        val activity = activity
+        if (activity != null && activity.supportFragmentManager.popBackStackImmediate()) getActivity()!!.finish()
+    }
+
+    fun doRefresh(title: String, items: List<VLCExtensionItem>) {
+        setTitle(title)
+        mAdapter.addAll(items)
+    }
+
+    private fun updateDisplay() {
+        if (mAdapter.itemCount > 0) {
+            mEmptyView.visibility = View.GONE
+            mRecyclerView.visibility = View.VISIBLE
+        } else {
+            mEmptyView.visibility = View.VISIBLE
+            mRecyclerView.visibility = View.GONE
+        }
+    }
+
+    fun browseItem(item: VLCExtensionItem) {
+        mExtensionManagerService!!.browse(item.stringId)
+    }
+
+    override fun onClick(v: View) {
+        if (v.id == mAddDirectoryFAB!!.id) {
+            val extension = mExtensionManagerService!!.currentExtension ?: return
+            val intent = Intent(Intent.ACTION_VIEW)
+            intent.component = extension.settingsActivity()
+            startActivity(intent)
+        }
+    }
+
+    override fun onRefresh() {
+        mExtensionManagerService!!.refresh()
+        mHandler.sendEmptyMessageDelayed(ACTION_HIDE_REFRESH, REFRESH_TIMEOUT.toLong())
+    }
+
+    fun openContextMenu(position: Int) {
+        showContext(requireActivity(), this, position, mAdapter.getItem(position).title, CTX_PLAY_ALL or CTX_APPEND or CTX_PLAY_AS_AUDIO or CTX_ITEM_DL)
+    }
+
+    override fun onCtxAction(position: Int, option: Int) {
+        when (option) {
+            CTX_PLAY_ALL -> {
+                val items = mAdapter.all
+                val medias = ArrayList<MediaWrapper>(items.size)
+                for (vlcItem in items) medias.add(Utils.mediawrapperFromExtension(vlcItem))
+                MediaUtils.openList(activity, medias, position)
+            }
+            CTX_APPEND -> MediaUtils.appendMedia(activity, Utils.mediawrapperFromExtension(mAdapter.getItem(position)))
+            CTX_PLAY_AS_AUDIO -> {
+                val mw = Utils.mediawrapperFromExtension(mAdapter.getItem(position))
+                mw.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+                MediaUtils.openMedia(activity, mw)
+            }
+            CTX_ITEM_DL -> {
+            }
+        }//TODO
+    }
+
+    private inner class ExtensionBrowserHandler internal constructor(owner: ExtensionBrowser) : WeakHandler<ExtensionBrowser>(owner) {
+
+        override fun handleMessage(msg: Message) {
+            when (msg.what) {
+                ACTION_HIDE_REFRESH -> {
+                    removeMessages(ACTION_SHOW_REFRESH)
+                    owner.mSwipeRefreshLayout.isRefreshing = false
+                }
+                ACTION_SHOW_REFRESH -> {
+                    removeMessages(ACTION_HIDE_REFRESH)
+                    owner.mSwipeRefreshLayout.isRefreshing = true
+                    sendEmptyMessageDelayed(ACTION_HIDE_REFRESH, REFRESH_TIMEOUT.toLong())
+                }
+            }
+        }
+    }
+
+    companion object {
+
+        const val TAG = "VLC/ExtensionBrowser"
+
+        const val KEY_ITEMS_LIST = "key_items_list"
+        const val KEY_SHOW_FAB = "key_fab"
+        const val KEY_TITLE = "key_title"
+
+
+        private const val ACTION_HIDE_REFRESH = 42
+        private const val ACTION_SHOW_REFRESH = 43
+
+        private const val REFRESH_TIMEOUT = 5000
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java b/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java
deleted file mode 100644
index 1a5676244f..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * *************************************************************************
- *  FileBrowserFragment.java
- * **************************************************************************
- *  Copyright © 2015 VLC authors and VideoLAN
- *  Author: Geoffrey Métais
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *  ***************************************************************************
- */
-
-package org.videolan.vlc.gui.browser;
-
-import android.net.Uri;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-
-import org.jetbrains.annotations.NotNull;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.ExternalMonitor;
-import org.videolan.vlc.R;
-import org.videolan.vlc.gui.helpers.hf.OtgAccess;
-import org.videolan.vlc.util.AndroidDevices;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.FileUtils;
-import org.videolan.vlc.util.Strings;
-import org.videolan.vlc.util.WorkersKt;
-import org.videolan.vlc.viewmodels.browser.BrowserModel;
-import org.videolan.vlc.viewmodels.browser.BrowserModelKt;
-
-import androidx.annotation.Nullable;
-import androidx.fragment.app.Fragment;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.Observer;
-import androidx.lifecycle.ViewModelProviders;
-
-public class FileBrowserFragment extends BaseBrowserFragment {
-
-    @Override
-    protected Fragment createFragment() {
-        return new FileBrowserFragment();
-    }
-
-    @Override
-    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        setupBrowser();
-    }
-
-    private boolean needsRefresh;
-    @Override
-    public void onStart() {
-        super.onStart();
-        if (needsRefresh) viewModel.browserRoot();
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        if (isRootDirectory() && adapter.isEmpty()) needsRefresh = true;
-    }
-
-    @Override
-    public void registerSwiperRefreshlayout() {
-        if (!isRootDirectory()) super.registerSwiperRefreshlayout();
-        else mSwipeRefreshLayout.setEnabled(false);
-    }
-
-    protected void setupBrowser() {
-        if (isRootDirectory()) viewModel = ViewModelProviders.of(requireActivity(), new BrowserModel.Factory(requireContext(), null, BrowserModelKt.TYPE_FILE, getShowHiddenFiles())).get(BrowserModel.class);
-        else viewModel = ViewModelProviders.of(this, new BrowserModel.Factory(requireContext(), getMrl(), BrowserModelKt.TYPE_FILE, getShowHiddenFiles())).get(BrowserModel.class);
-    }
-
-    @Override
-    public String getTitle() {
-        if (isRootDirectory()) return getCategoryTitle();
-        else {
-            String title;
-            if (getCurrentMedia() != null) {
-                if (TextUtils.equals(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY, Strings.removeFileProtocole(getMrl())))
-                    title = getString(R.string.internal_memory);
-                else
-                    title = this instanceof FilePickerFragment ? getCurrentMedia().getUri().toString() : getCurrentMedia().getTitle();
-            } else
-                title = this instanceof FilePickerFragment ? getMrl() : FileUtils.getFileNameFromPath(getMrl());
-            return title;
-        }
-    }
-
-    @Override
-    protected String getCategoryTitle() {
-        return getString(R.string.directories);
-    }
-
-    @Override
-    protected void browseRoot() {
-        viewModel.browserRoot();
-    }
-
-    @Override
-    public void onClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        if (item.getItemType() == MediaLibraryItem.TYPE_MEDIA) {
-            final MediaWrapper mw = (MediaWrapper) item;
-            if ("otg://".equals(mw.getLocation())) {
-                final String title = getString(R.string.otg_device_title);
-                final LiveData<Uri> otgRoot = OtgAccess.Companion.getOtgRoot();
-                final Uri rootUri = otgRoot.getValue();
-                if (rootUri != null && ExternalMonitor.INSTANCE.getDevices().getValue().size() == 1) {
-                    browseOtgDevice(rootUri, title);
-                } else {
-                    otgRoot.observeForever(new Observer<Uri>() {
-                        @Override
-                        public void onChanged(@Nullable Uri uri) {
-                            OtgAccess.Companion.getOtgRoot().removeObserver(this);
-                            if (uri != null) browseOtgDevice(uri, title);
-                        }
-                    });
-                    OtgAccess.Companion.requestOtgRoot(requireActivity());
-                }
-                return;
-            }
-        }
-        super.onClick(v, position, item);
-    }
-
-    @Override
-    public void onCtxAction(int position, int option) {
-        final MediaWrapper mw = (MediaWrapper) getAdapter().getItem(position);
-        switch (option) {
-            case Constants.CTX_FAV_ADD:
-                getBrowserFavRepository().addLocalFavItem(mw.getUri(), mw.getTitle(), mw.getArtworkURL());
-                break;
-            default:
-                super.onCtxAction(position, option);
-        }
-    }
-
-    @Override
-    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-    }
-
-    @Override
-    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-        if (!(this instanceof FilePickerFragment || this instanceof StorageBrowserFragment))
-            inflater.inflate(R.menu.fragment_option_network, menu);
-        super.onCreateOptionsMenu(menu, inflater);
-    }
-
-    @Override
-    public void onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        final MenuItem item = menu.findItem(R.id.ml_menu_save);
-        if (item == null) return;
-        item.setVisible(!isRootDirectory() && getMrl().startsWith("file"));
-        WorkersKt.runIO(new Runnable() {
-            @Override
-            public void run() {
-                final boolean isFavorite = getMrl() != null && getBrowserFavRepository().browserFavExists(Uri.parse(getMrl()));
-                WorkersKt.runOnMainThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        item.setIcon(isFavorite ?
-                                R.drawable.ic_menu_bookmark_w :
-                                R.drawable.ic_menu_bookmark_outline_w);
-                        item.setTitle(isFavorite ? R.string.favorites_remove : R.string.favorites_add);
-                    }
-                });
-            }
-        });
-    }
-
-    private void browseOtgDevice(@NotNull Uri uri, @NotNull String title) {
-        final MediaWrapper mw = new MediaWrapper(uri);
-        mw.setType(MediaWrapper.TYPE_DIR);
-        mw.setTitle(title);
-        getHandler().post(new Runnable() {
-            @Override
-            public void run() {
-                browse(mw, true);
-            }
-        });
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.kt
new file mode 100644
index 0000000000..4ebe9f51cf
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.kt
@@ -0,0 +1,170 @@
+/*
+ * *************************************************************************
+ *  FileBrowserFragment.java
+ * **************************************************************************
+ *  Copyright © 2015 VLC authors and VideoLAN
+ *  Author: Geoffrey Métais
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *  ***************************************************************************
+ */
+
+package org.videolan.vlc.gui.browser
+
+import android.net.Uri
+import android.os.Bundle
+import android.text.TextUtils
+import android.view.Menu
+import android.view.MenuInflater
+import android.view.View
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.Observer
+import androidx.lifecycle.ViewModelProviders
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.ExternalMonitor
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.helpers.hf.OtgAccess
+import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.browser.BrowserModel
+import org.videolan.vlc.viewmodels.browser.TYPE_FILE
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+open class FileBrowserFragment : BaseBrowserFragment() {
+
+    private var needsRefresh: Boolean = false
+
+    override val categoryTitle: String
+        get() = getString(R.string.directories)
+
+    override fun createFragment(): Fragment {
+        return FileBrowserFragment()
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+        setupBrowser()
+    }
+
+    override fun onStart() {
+        super.onStart()
+        if (needsRefresh) viewModel.browserRoot()
+    }
+
+    override fun onStop() {
+        super.onStop()
+        if (isRootDirectory && adapter.isEmpty()) needsRefresh = true
+    }
+
+    override fun registerSwiperRefreshlayout() {
+        if (!isRootDirectory)
+            super.registerSwiperRefreshlayout()
+        else
+            swipeRefreshLayout?.isEnabled = false
+    }
+
+    protected open fun setupBrowser() {
+        viewModel = if (isRootDirectory)
+            ViewModelProviders.of(requireActivity(), BrowserModel.Factory(requireContext(), null, TYPE_FILE, showHiddenFiles)).get(BrowserModel::class.java)
+        else
+            ViewModelProviders.of(this, BrowserModel.Factory(requireContext(), mrl, TYPE_FILE, showHiddenFiles)).get(BrowserModel::class.java)
+    }
+
+    override fun getTitle(): String = if (isRootDirectory)
+        categoryTitle
+    else {
+        when {
+            currentMedia != null -> when {
+                TextUtils.equals(AndroidDevices.EXTERNAL_PUBLIC_DIRECTORY, mrl?.removeFileProtocole()) -> getString(R.string.internal_memory)
+                this is FilePickerFragment -> currentMedia!!.uri.toString()
+                else -> currentMedia!!.title
+            }
+            this is FilePickerFragment -> mrl ?: ""
+            else -> FileUtils.getFileNameFromPath(mrl)
+        }
+    }
+
+
+    public override fun browseRoot() {
+        viewModel.browserRoot()
+    }
+
+    override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
+        if (item.itemType == MediaLibraryItem.TYPE_MEDIA) {
+            val mw = item as MediaWrapper
+            if ("otg://" == mw.location) {
+                val title = getString(R.string.otg_device_title)
+                val otgRoot = OtgAccess.otgRoot
+                val rootUri = otgRoot.value
+                if (rootUri != null && ExternalMonitor.devices.value.size == 1) {
+                    browseOtgDevice(rootUri, title)
+                } else {
+                    otgRoot.observeForever(object : Observer<Uri> {
+                        override fun onChanged(uri: Uri?) {
+                            OtgAccess.otgRoot.removeObserver(this)
+                            if (uri != null) browseOtgDevice(uri, title)
+                        }
+                    })
+                    OtgAccess.requestOtgRoot(requireActivity())
+                }
+                return
+            }
+        }
+        super.onClick(v, position, item)
+    }
+
+    override fun onCtxAction(position: Int, option: Int) {
+        val mw = adapter.getItem(position) as MediaWrapper?
+        when (option) {
+            CTX_FAV_ADD -> browserFavRepository.addLocalFavItem(mw!!.uri, mw.title, mw.artworkURL)
+            else -> super.onCtxAction(position, option)
+        }
+    }
+
+    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
+
+    override fun onCreateOptionsMenu(menu: Menu?, inflater: MenuInflater?) {
+        if (!(this is FilePickerFragment || this is StorageBrowserFragment))
+            inflater!!.inflate(R.menu.fragment_option_network, menu)
+        super.onCreateOptionsMenu(menu, inflater)
+    }
+
+    override fun onPrepareOptionsMenu(menu: Menu?) {
+        super.onPrepareOptionsMenu(menu)
+        val item = menu?.findItem(R.id.ml_menu_save) ?: return
+        item.isVisible = !isRootDirectory && mrl!!.startsWith("file")
+        runIO(Runnable {
+            val isFavorite = mrl != null && browserFavRepository.browserFavExists(Uri.parse(mrl))
+            runOnMainThread(Runnable {
+                item.setIcon(if (isFavorite)
+                    R.drawable.ic_menu_bookmark_w
+                else
+                    R.drawable.ic_menu_bookmark_outline_w)
+                item.setTitle(if (isFavorite) R.string.favorites_remove else R.string.favorites_add)
+            })
+        })
+    }
+
+
+    private fun browseOtgDevice(uri: Uri, title: String) {
+        val mw = MediaWrapper(uri)
+        mw.type = MediaWrapper.TYPE_DIR
+        mw.title = title
+        handler.post { browse(mw, true) }
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerActivity.java b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerActivity.java
deleted file mode 100644
index 72be7bb1dc..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerActivity.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * *************************************************************************
- *  FilePickerActivity.java
- * **************************************************************************
- *  Copyright © 2015 VLC authors and VideoLAN
- *  Author: Geoffrey Métais
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *  ***************************************************************************
- */
-
-package org.videolan.vlc.gui.browser;
-
-import android.os.Bundle;
-import androidx.fragment.app.FragmentTransaction;
-import androidx.appcompat.app.AppCompatActivity;
-import android.view.View;
-
-import org.videolan.vlc.R;
-
-public class FilePickerActivity extends AppCompatActivity {
-    protected static final String TAG = "VLC/BaseBrowserFragment";
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.file_picker_activity);
-        final FragmentTransaction ft = getSupportFragmentManager().beginTransaction();
-        ft.replace(R.id.fragment_placeholder, new FilePickerFragment(), "picker");
-        ft.commit();
-    }
-
-    @Override
-    public void onBackPressed() {
-        final FilePickerFragment fpf = ((FilePickerFragment) getSupportFragmentManager().findFragmentById(R.id.fragment_placeholder));
-        if (fpf.isRootDirectory())
-            finish();
-        else if (getSupportFragmentManager().getBackStackEntryCount() > 0)
-            super.onBackPressed();
-        else
-            fpf.browseUp();
-    }
-
-    public void onHomeClick(View v) {
-        ((FilePickerFragment) getSupportFragmentManager().findFragmentById(R.id.fragment_placeholder)).browseRoot();
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerActivity.kt b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerActivity.kt
new file mode 100644
index 0000000000..f72402125d
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerActivity.kt
@@ -0,0 +1,57 @@
+/*
+ * *************************************************************************
+ *  FilePickerActivity.java
+ * **************************************************************************
+ *  Copyright © 2015 VLC authors and VideoLAN
+ *  Author: Geoffrey Métais
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *  ***************************************************************************
+ */
+
+package org.videolan.vlc.gui.browser
+
+import android.os.Bundle
+import android.view.View
+import androidx.appcompat.app.AppCompatActivity
+import org.videolan.vlc.R
+
+class FilePickerActivity : AppCompatActivity() {
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.file_picker_activity)
+        val ft = supportFragmentManager.beginTransaction()
+        ft.replace(R.id.fragment_placeholder, FilePickerFragment(), "picker")
+        ft.commit()
+    }
+
+    override fun onBackPressed() {
+        val fpf = supportFragmentManager.findFragmentById(R.id.fragment_placeholder) as FilePickerFragment
+        when {
+            fpf.isRootDirectory -> finish()
+            supportFragmentManager.backStackEntryCount > 0 -> super.onBackPressed()
+            else -> fpf.browseUp()
+        }
+    }
+
+    fun onHomeClick(v: View) {
+        (supportFragmentManager.findFragmentById(R.id.fragment_placeholder) as FilePickerFragment).browseRoot()
+    }
+
+    companion object {
+        private val TAG = "VLC/BaseBrowserFragment"
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerAdapter.java b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerAdapter.kt
similarity index 59%
rename from vlc-android/src/org/videolan/vlc/gui/browser/FilePickerAdapter.java
rename to vlc-android/src/org/videolan/vlc/gui/browser/FilePickerAdapter.kt
index ced5e7d9dc..1f617b92d2 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerAdapter.java
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerAdapter.kt
@@ -21,25 +21,23 @@
  *  ***************************************************************************
  */
 
-package org.videolan.vlc.gui.browser;
+package org.videolan.vlc.gui.browser
 
-import org.videolan.medialibrary.media.MediaWrapper;
+import androidx.databinding.ViewDataBinding
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaWrapper
 
-public class FilePickerAdapter extends BaseBrowserAdapter {
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class FilePickerAdapter internal constructor(fragment: BaseBrowserFragment) : BaseBrowserAdapter(fragment) {
 
-    FilePickerAdapter(BaseBrowserFragment fragment) {
-        super(fragment);
-    }
-
-    @Override
-    public void onBindViewHolder(final ViewHolder holder, int position) {
-        if (holder instanceof MediaViewHolder) {
-            final MediaViewHolder vh = (MediaViewHolder) holder;
-            final MediaWrapper media = (MediaWrapper) getItem(position);
-            vh.binding.setItem(media);
-            vh.binding.setHasContextMenu(false);
-            vh.binding.setProtocol(null);
-            vh.binding.setCover(getIcon(media, false));
-        }
+    override fun onBindViewHolder(holder: ViewHolder<ViewDataBinding>, position: Int) {
+        val h = holder as MediaViewHolder
+        val media = getItem(position) as MediaWrapper
+        h.binding.item = media
+        h.binding.hasContextMenu = false
+        h.binding.protocol = null
+        h.binding.cover = getIcon(media, false)
     }
 }
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerFragment.kt
index 30f5062b29..d69507d365 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/FilePickerFragment.kt
@@ -74,8 +74,8 @@ class FilePickerFragment : FileBrowserFragment() {
 
     override fun onStart() {
         super.onStart()
-        activity?.title = title
-        mSwipeRefreshLayout.isEnabled = false
+        activity?.title = getTitle()
+        swipeRefreshLayout?.isEnabled = false
     }
 
     override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/MediaBrowserFragment.java b/vlc-android/src/org/videolan/vlc/gui/browser/MediaBrowserFragment.java
deleted file mode 100644
index 1501e02840..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/MediaBrowserFragment.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * *************************************************************************
- *  MediaBrowserFragment.java
- * **************************************************************************
- *  Copyright © 2015-2016 VLC authors and VideoLAN
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *  ***************************************************************************
- */
-
-package org.videolan.vlc.gui.browser;
-
-import android.annotation.TargetApi;
-import android.content.Intent;
-import android.os.Build;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-
-import com.google.android.material.floatingactionbutton.FloatingActionButton;
-
-import org.videolan.medialibrary.Medialibrary;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.medialibrary.media.Playlist;
-import org.videolan.vlc.R;
-import org.videolan.vlc.VLCApplication;
-import org.videolan.vlc.gui.AudioPlayerContainerActivity;
-import org.videolan.vlc.gui.ContentActivity;
-import org.videolan.vlc.gui.InfoActivity;
-import org.videolan.vlc.gui.helpers.UiTools;
-import org.videolan.vlc.gui.view.SwipeRefreshLayout;
-import org.videolan.vlc.interfaces.Filterable;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.util.AndroidDevices;
-import org.videolan.vlc.util.FileUtils;
-import org.videolan.vlc.util.Util;
-import org.videolan.vlc.util.WorkersKt;
-import org.videolan.vlc.viewmodels.SortableModel;
-
-import java.util.LinkedList;
-
-import androidx.annotation.Nullable;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.appcompat.view.ActionMode;
-import androidx.constraintlayout.widget.ConstraintLayout;
-import androidx.constraintlayout.widget.ConstraintSet;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentActivity;
-import androidx.recyclerview.widget.RecyclerView;
-import androidx.transition.TransitionManager;
-
-public abstract class MediaBrowserFragment<T extends SortableModel> extends Fragment implements ActionMode.Callback, Filterable {
-
-    public final static String TAG = "VLC/MediaBrowserFragment";
-
-    protected View mSearchButtonView;
-    protected SwipeRefreshLayout mSwipeRefreshLayout;
-    protected Medialibrary mMediaLibrary;
-    protected ActionMode mActionMode;
-    public FloatingActionButton mFabPlay;
-    protected T viewModel;
-    private boolean restart = false;
-
-    public T getViewModel() {
-        return viewModel;
-    }
-
-    protected boolean hasTabs() {
-        return false;
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mMediaLibrary = VLCApplication.getMLInstance();
-        setHasOptionsMenu(!AndroidDevices.isAndroidTv);
-        restart = false;
-    }
-
-    @Override
-    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        mSearchButtonView = view.findViewById(R.id.searchButton);
-        mSwipeRefreshLayout = view.findViewById(R.id.swipeLayout);
-        mSwipeRefreshLayout.setColorSchemeResources(R.color.orange700);
-        if (hasFAB()) mFabPlay = requireActivity().findViewById(R.id.fab);
-    }
-
-    protected boolean hasFAB() {
-        return mSwipeRefreshLayout != null;
-    }
-
-    protected void setBreadcrumb() {
-        final RecyclerView ariane = requireActivity().findViewById(R.id.ariane);
-        if (ariane != null) ariane.setVisibility(View.GONE);
-    }
-
-    protected void releaseBreadCrumb() {
-        final RecyclerView ariane = requireActivity().findViewById(R.id.ariane);
-        if (ariane != null) ariane.setAdapter(null);
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        setBreadcrumb();
-        updateActionBar();
-        if (mFabPlay != null) {
-            setFabPlayVisibility(true);
-            mFabPlay.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    onFabPlayClick(v);
-                }
-            });
-        }
-        if (restart) onRestart();
-    }
-
-    protected void onRestart() {}
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        releaseBreadCrumb();
-        setFabPlayVisibility(false);
-        restart = true;
-    }
-
-    public void updateActionBar() {
-        final AppCompatActivity activity = (AppCompatActivity)getActivity();
-        if (activity == null) return;
-        if (activity.getSupportActionBar() != null) {
-            activity.getSupportActionBar().setTitle(getTitle());
-            activity.getSupportActionBar().setSubtitle(getSubTitle());
-            activity.supportInvalidateOptionsMenu();
-        }
-        if (activity instanceof ContentActivity) ((ContentActivity)activity).setTabLayoutVisibility(hasTabs());
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        stopActionMode();
-    }
-
-    public void setFabPlayVisibility(boolean enable) {
-        if (mFabPlay != null) {
-            if (enable) mFabPlay.show();
-            else mFabPlay.hide();
-        }
-    }
-
-    public void onFabPlayClick(View view) {}
-
-    public abstract String getTitle();
-    public abstract void onRefresh();
-
-    protected String getSubTitle() { return null; }
-    public void clear() {}
-
-    protected boolean removeItem(final MediaLibraryItem item) {
-        final View view = getView();
-        if (view == null) return false;
-        if (item.getItemType() == MediaLibraryItem.TYPE_PLAYLIST) {
-            UiTools.snackerConfirm(getView(), getString(R.string.confirm_delete_playlist, item.getTitle()), new Runnable() {
-                @Override
-                public void run() {
-                    MediaUtils.INSTANCE.deletePlaylist((Playlist) item);
-                }
-            });
-        } else if (item.getItemType() == MediaLibraryItem.TYPE_MEDIA) {
-            final Runnable deleteAction = new Runnable() {
-                @Override
-                public void run() {
-                    deleteMedia(item, false, null);
-                }
-            };
-            final int resid = ((MediaWrapper)item).getType() == MediaWrapper.TYPE_DIR ? R.string.confirm_delete_folder : R.string.confirm_delete;
-            UiTools.snackerConfirm(getView(), getString(resid, item.getTitle()), new Runnable() {
-                @Override
-                public void run() {
-                    if (Util.checkWritePermission(requireActivity(), (MediaWrapper) item, deleteAction)) deleteAction.run();
-                }
-            });
-        } else return false;
-        return true;
-    }
-
-    protected void deleteMedia(final MediaLibraryItem mw, final boolean refresh, final Runnable failCB) {
-        WorkersKt.runIO(new Runnable() {
-            @Override
-            public void run() {
-                final LinkedList<String> foldersToReload = new LinkedList<>();
-                final LinkedList<String> mediaPaths = new LinkedList<>();
-                for (MediaWrapper media : mw.getTracks()) {
-                    final String path = media.getUri().getPath();
-                    final String parentPath = FileUtils.getParent(path);
-                    if (FileUtils.deleteFile(media.getUri())) {
-                        if (media.getId() > 0L && !foldersToReload.contains(parentPath)) {
-                            foldersToReload.add(parentPath);
-                        }
-                        mediaPaths.add(media.getLocation());
-                    } else onDeleteFailed(media);
-                }
-                for (String folder : foldersToReload) mMediaLibrary.reload(folder);
-                if (getActivity() != null) {
-                    WorkersKt.runOnMainThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            if (mediaPaths.isEmpty()) {
-                                if (failCB != null) failCB.run();
-                                return;
-                            }
-                            if (refresh) onRefresh();
-                        }
-                    });
-                }
-            }
-        });
-    }
-
-    private void onDeleteFailed(MediaWrapper media) {
-        final View v = getView();
-        if (v != null && isAdded()) UiTools.snacker(v, getString(R.string.msg_delete_failed, media.getTitle()));
-    }
-
-    protected void showInfoDialog(MediaLibraryItem item) {
-        final Intent i = new Intent(getActivity(), InfoActivity.class);
-        i.putExtra(InfoActivity.TAG_ITEM, item);
-        startActivity(i);
-    }
-
-    @Override
-    public void onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        menu.findItem(R.id.ml_menu_sortby).setVisible(getViewModel().canSortByName());
-        menu.findItem(R.id.ml_menu_sortby_filename).setVisible(getViewModel().canSortByFileNameName());
-        menu.findItem(R.id.ml_menu_sortby_artist_name).setVisible(getViewModel().canSortByArtist());
-        menu.findItem(R.id.ml_menu_sortby_album_name).setVisible(getViewModel().canSortByAlbum());
-        menu.findItem(R.id.ml_menu_sortby_length).setVisible(getViewModel().canSortByDuration());
-        menu.findItem(R.id.ml_menu_sortby_date).setVisible(getViewModel().canSortByReleaseDate());
-        menu.findItem(R.id.ml_menu_sortby_last_modified).setVisible(getViewModel().canSortByLastModified());
-        menu.findItem(R.id.ml_menu_sortby_number).setVisible(false);
-        UiTools.updateSortTitles(this);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.ml_menu_sortby_name:
-                sortBy(Medialibrary.SORT_ALPHA);
-                return true;
-            case R.id.ml_menu_sortby_filename:
-                sortBy(Medialibrary.SORT_FILENAME);
-                return true;
-            case R.id.ml_menu_sortby_length:
-                sortBy(Medialibrary.SORT_DURATION);
-                return true;
-            case R.id.ml_menu_sortby_date:
-                sortBy(Medialibrary.SORT_RELEASEDATE);
-                return true;
-            case R.id.ml_menu_sortby_last_modified:
-                sortBy(Medialibrary.SORT_LASTMODIFICATIONDATE);
-                return true;
-            case R.id.ml_menu_sortby_artist_name:
-                sortBy(Medialibrary.SORT_ARTIST);
-                return true;
-            case R.id.ml_menu_sortby_album_name:
-                sortBy(Medialibrary.SORT_ALBUM);
-                return true;
-            case R.id.ml_menu_sortby_number:
-                sortBy(Medialibrary.SORT_FILESIZE); //TODO
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-    }
-
-    protected void sortBy(int sort) {
-        getViewModel().sort(sort);
-    }
-
-    public Menu getMenu() {
-        final FragmentActivity activity = getActivity();
-        if (!(activity instanceof AudioPlayerContainerActivity)) return null;
-        return ((AudioPlayerContainerActivity)activity).getMenu();
-
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    public void startActionMode() {
-        final AppCompatActivity activity = (AppCompatActivity) getActivity();
-        if (activity == null) return;
-        mActionMode = activity.startSupportActionMode(this);
-        setFabPlayVisibility(false);
-    }
-
-    protected void stopActionMode() {
-        if (mActionMode != null) {
-            mActionMode.finish();
-            onDestroyActionMode(mActionMode);
-            setFabPlayVisibility(true);
-        }
-    }
-
-    public void invalidateActionMode() {
-        if (mActionMode != null) mActionMode.invalidate();
-    }
-
-    @Override
-    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-        return false;
-    }
-
-    @Override
-    public void filter(String query) {
-        getViewModel().filter(query);
-    }
-
-    @Override
-    public void restoreList() {
-        getViewModel().restore();
-    }
-
-    @Override
-    public boolean enableSearchOption() {
-        return true;
-    }
-
-    @Override
-    public String getFilterQuery() {
-        return getViewModel().getFilterQuery();
-    }
-
-    @Override
-    public void setSearchVisibility(boolean visible) {
-        if ((mSearchButtonView.getVisibility() == View.VISIBLE) == visible) return;
-        if (mSearchButtonView.getParent() instanceof ConstraintLayout) {
-            final ConstraintLayout cl = (ConstraintLayout) mSearchButtonView.getParent();
-            final ConstraintSet cs = new ConstraintSet();
-            cs.clone(cl);
-            cs.setVisibility(R.id.searchButton, visible ? ConstraintSet.VISIBLE : ConstraintSet.GONE);
-            TransitionManager.beginDelayedTransition(cl);
-            cs.applyTo(cl);
-        } else UiTools.setViewVisibility(mSearchButtonView, visible ? View.VISIBLE : View.GONE);
-    }
-
-    @Override
-    public boolean allowedToExpand() {
-        return true;
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/MediaBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/MediaBrowserFragment.kt
new file mode 100644
index 0000000000..ffd82e7019
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/MediaBrowserFragment.kt
@@ -0,0 +1,332 @@
+/*
+ * *************************************************************************
+ *  MediaBrowserFragment.java
+ * **************************************************************************
+ *  Copyright © 2015-2016 VLC authors and VideoLAN
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *  ***************************************************************************
+ */
+
+package org.videolan.vlc.gui.browser
+
+import android.annotation.TargetApi
+import android.content.Intent
+import android.os.Build
+import android.os.Bundle
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import androidx.appcompat.app.AppCompatActivity
+import androidx.appcompat.view.ActionMode
+import androidx.constraintlayout.widget.ConstraintLayout
+import androidx.constraintlayout.widget.ConstraintSet
+import androidx.fragment.app.Fragment
+import androidx.recyclerview.widget.RecyclerView
+import androidx.transition.TransitionManager
+import com.google.android.material.floatingactionbutton.FloatingActionButton
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.medialibrary.media.Playlist
+import org.videolan.vlc.R
+import org.videolan.vlc.VLCApplication
+import org.videolan.vlc.gui.AudioPlayerContainerActivity
+import org.videolan.vlc.gui.ContentActivity
+import org.videolan.vlc.gui.InfoActivity
+import org.videolan.vlc.gui.helpers.UiTools
+import org.videolan.vlc.gui.view.SwipeRefreshLayout
+import org.videolan.vlc.interfaces.Filterable
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.SortableModel
+import java.util.*
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+abstract class MediaBrowserFragment<T : SortableModel> : Fragment(), ActionMode.Callback, Filterable {
+
+    private lateinit var searchButtonView: View
+    var swipeRefreshLayout: SwipeRefreshLayout? = null
+    lateinit var mediaLibrary: Medialibrary
+    var actionMode: ActionMode? = null
+    lateinit var fabPlay: FloatingActionButton
+    open lateinit var viewModel: T
+        protected set
+    private var restart = false
+
+
+    abstract fun getTitle(): String
+
+    open val subTitle: String?
+        get() = null
+
+    val menu: Menu?
+        get() {
+            val activity = activity
+            return if (activity !is AudioPlayerContainerActivity) null else activity.menu
+
+        }
+
+    protected open fun hasTabs(): Boolean {
+        return false
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        mediaLibrary = VLCApplication.getMLInstance()
+        setHasOptionsMenu(!AndroidDevices.isAndroidTv)
+        restart = false
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+        searchButtonView = view.findViewById(R.id.searchButton)
+        swipeRefreshLayout = view.findViewById(R.id.swipeLayout)
+        swipeRefreshLayout?.setColorSchemeResources(R.color.orange700)
+        if (hasFAB()) fabPlay = requireActivity().findViewById(R.id.fab)
+    }
+
+    protected open fun hasFAB(): Boolean {
+        return true
+    }
+
+    protected open fun setBreadcrumb() {
+        val ariane = requireActivity().findViewById<RecyclerView>(R.id.ariane)
+        if (ariane != null) ariane.visibility = View.GONE
+    }
+
+    private fun releaseBreadCrumb() {
+        val ariane = requireActivity().findViewById<RecyclerView>(R.id.ariane)
+        if (ariane != null) ariane.adapter = null
+    }
+
+    override fun onStart() {
+        super.onStart()
+        setBreadcrumb()
+        updateActionBar()
+        setFabPlayVisibility(true)
+        fabPlay.setOnClickListener { v -> onFabPlayClick(v) }
+        if (restart) onRestart()
+    }
+
+    protected open fun onRestart() {}
+
+    override fun onStop() {
+        super.onStop()
+        releaseBreadCrumb()
+        setFabPlayVisibility(false)
+        restart = true
+    }
+
+    private fun updateActionBar() {
+        val activity = activity as AppCompatActivity? ?: return
+        if (activity.supportActionBar != null) {
+            activity.supportActionBar!!.title = getTitle()
+            activity.supportActionBar!!.subtitle = subTitle
+            activity.supportInvalidateOptionsMenu()
+        }
+        if (activity is ContentActivity) activity.setTabLayoutVisibility(hasTabs())
+    }
+
+    override fun onPause() {
+        super.onPause()
+        stopActionMode()
+    }
+
+    open fun setFabPlayVisibility(enable: Boolean) {
+        if (fabPlay != null) {
+            if (enable)
+                fabPlay!!.show()
+            else
+                fabPlay!!.hide()
+        }
+    }
+
+    open fun onFabPlayClick(view: View) {}
+    abstract fun onRefresh()
+    open fun clear() {}
+
+    protected open fun removeItem(item: MediaLibraryItem): Boolean {
+        view ?: return false
+        when {
+            item.itemType == MediaLibraryItem.TYPE_PLAYLIST -> UiTools.snackerConfirm(view!!, getString(R.string.confirm_delete_playlist, item.title)) { MediaUtils.deletePlaylist(item as Playlist) }
+            item.itemType == MediaLibraryItem.TYPE_MEDIA -> {
+                val deleteAction = Runnable { deleteMedia(item, false, null) }
+                val resid = if ((item as MediaWrapper).type == MediaWrapper.TYPE_DIR) R.string.confirm_delete_folder else R.string.confirm_delete
+                UiTools.snackerConfirm(view!!, getString(resid, item.getTitle())) { if (Util.checkWritePermission(requireActivity(), item, deleteAction)) deleteAction.run() }
+            }
+            else -> return false
+        }
+        return true
+    }
+
+    protected fun deleteMedia(mw: MediaLibraryItem, refresh: Boolean, failCB: Runnable?) {
+        runIO(Runnable {
+            val foldersToReload = LinkedList<String>()
+            val mediaPaths = LinkedList<String>()
+            for (media in mw.tracks) {
+                val path = media.uri.path
+                val parentPath = FileUtils.getParent(path)
+                if (FileUtils.deleteFile(media.uri)) {
+                    if (media.id > 0L && !foldersToReload.contains(parentPath)) {
+                        foldersToReload.add(parentPath)
+                    }
+                    mediaPaths.add(media.location)
+                } else
+                    onDeleteFailed(media)
+            }
+            for (folder in foldersToReload) mediaLibrary.reload(folder)
+            if (activity != null) {
+                runOnMainThread(Runnable {
+                    if (mediaPaths.isEmpty()) {
+                        failCB?.run()
+                        return@Runnable
+                    }
+                    if (refresh) onRefresh()
+                })
+            }
+        })
+    }
+
+    private fun onDeleteFailed(media: MediaWrapper) {
+        val v = view
+        if (v != null && isAdded) UiTools.snacker(v, getString(R.string.msg_delete_failed, media.title))
+    }
+
+    protected fun showInfoDialog(item: MediaLibraryItem) {
+        val i = Intent(activity, InfoActivity::class.java)
+        i.putExtra(InfoActivity.TAG_ITEM, item)
+        startActivity(i)
+    }
+
+    override fun onPrepareOptionsMenu(menu: Menu?) {
+        super.onPrepareOptionsMenu(menu)
+        menu!!.findItem(R.id.ml_menu_sortby).isVisible = viewModel.canSortByName()
+        menu.findItem(R.id.ml_menu_sortby_filename).isVisible = viewModel.canSortByFileNameName()
+        menu.findItem(R.id.ml_menu_sortby_artist_name).isVisible = viewModel.canSortByArtist()
+        menu.findItem(R.id.ml_menu_sortby_album_name).isVisible = viewModel.canSortByAlbum()
+        menu.findItem(R.id.ml_menu_sortby_length).isVisible = viewModel.canSortByDuration()
+        menu.findItem(R.id.ml_menu_sortby_date).isVisible = viewModel.canSortByReleaseDate()
+        menu.findItem(R.id.ml_menu_sortby_last_modified).isVisible = viewModel.canSortByLastModified()
+        menu.findItem(R.id.ml_menu_sortby_number).isVisible = false
+        UiTools.updateSortTitles(this)
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
+        when (item!!.itemId) {
+            R.id.ml_menu_sortby_name -> {
+                sortBy(Medialibrary.SORT_ALPHA)
+                return true
+            }
+            R.id.ml_menu_sortby_filename -> {
+                sortBy(Medialibrary.SORT_FILENAME)
+                return true
+            }
+            R.id.ml_menu_sortby_length -> {
+                sortBy(Medialibrary.SORT_DURATION)
+                return true
+            }
+            R.id.ml_menu_sortby_date -> {
+                sortBy(Medialibrary.SORT_RELEASEDATE)
+                return true
+            }
+            R.id.ml_menu_sortby_last_modified -> {
+                sortBy(Medialibrary.SORT_LASTMODIFICATIONDATE)
+                return true
+            }
+            R.id.ml_menu_sortby_artist_name -> {
+                sortBy(Medialibrary.SORT_ARTIST)
+                return true
+            }
+            R.id.ml_menu_sortby_album_name -> {
+                sortBy(Medialibrary.SORT_ALBUM)
+                return true
+            }
+            R.id.ml_menu_sortby_number -> {
+                sortBy(Medialibrary.SORT_FILESIZE) //TODO
+                return super.onOptionsItemSelected(item)
+            }
+            else -> return super.onOptionsItemSelected(item)
+        }
+    }
+
+    protected open fun sortBy(sort: Int) {
+        viewModel.sort(sort)
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    fun startActionMode() {
+        val activity = activity as AppCompatActivity? ?: return
+        actionMode = activity.startSupportActionMode(this)
+        setFabPlayVisibility(false)
+    }
+
+    protected fun stopActionMode() {
+        if (actionMode != null) {
+            actionMode!!.finish()
+            onDestroyActionMode(actionMode)
+            setFabPlayVisibility(true)
+        }
+    }
+
+    fun invalidateActionMode() {
+        if (actionMode != null) actionMode!!.invalidate()
+    }
+
+    override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
+        return false
+    }
+
+    override fun filter(query: String) {
+        viewModel.filter(query)
+    }
+
+    override fun restoreList() {
+        viewModel.restore()
+    }
+
+    override fun enableSearchOption(): Boolean {
+        return true
+    }
+
+    override fun getFilterQuery(): String? {
+        return viewModel.filterQuery
+    }
+
+    override fun setSearchVisibility(visible: Boolean) {
+        if (searchButtonView.visibility == View.VISIBLE == visible) return
+        if (searchButtonView.parent is ConstraintLayout) {
+            val cl = searchButtonView.parent as ConstraintLayout
+            val cs = ConstraintSet()
+            cs.clone(cl)
+            cs.setVisibility(R.id.searchButton, if (visible) ConstraintSet.VISIBLE else ConstraintSet.GONE)
+            TransitionManager.beginDelayedTransition(cl)
+            cs.applyTo(cl)
+        } else
+            UiTools.setViewVisibility(searchButtonView, if (visible) View.VISIBLE else View.GONE)
+    }
+
+    override fun allowedToExpand(): Boolean {
+        return true
+    }
+
+    companion object {
+
+        val TAG = "VLC/MediaBrowserFragment"
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/NetworkBrowserFragment.java b/vlc-android/src/org/videolan/vlc/gui/browser/NetworkBrowserFragment.java
deleted file mode 100644
index 5d4254fe9d..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/browser/NetworkBrowserFragment.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * *************************************************************************
- *  NetworkBrowserFragment.java
- * **************************************************************************
- *  Copyright © 2015-2017 VLC authors and VideoLAN
- *  Author: Geoffrey Métais
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *  ***************************************************************************
- */
-
-package org.videolan.vlc.gui.browser;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.net.Uri;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-
-import org.jetbrains.annotations.NotNull;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.ExternalMonitor;
-import org.videolan.vlc.R;
-import org.videolan.vlc.VLCApplication;
-import org.videolan.vlc.gui.dialogs.NetworkServerDialog;
-import org.videolan.vlc.gui.dialogs.VlcLoginDialog;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.Util;
-import org.videolan.vlc.util.WorkersKt;
-import org.videolan.vlc.viewmodels.browser.NetworkModel;
-
-import androidx.annotation.Nullable;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-import androidx.lifecycle.Observer;
-import androidx.lifecycle.ViewModelProviders;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import androidx.recyclerview.widget.RecyclerView;
-
-public class NetworkBrowserFragment extends BaseBrowserFragment {
-
-    @Override
-    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        viewModel = ViewModelProviders.of(this, new NetworkModel.Factory(requireContext(), getMrl(), getShowHiddenFiles())).get(NetworkModel.class);
-    }
-
-    @Override
-    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        ExternalMonitor.INSTANCE.getConnected().observe(this, new Observer<Boolean>() {
-            @Override
-            public void onChanged(@Nullable Boolean connected) {
-                refresh(connected);
-            }
-        });
-    }
-
-    @Override
-    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-        inflater.inflate(R.menu.fragment_option_network, menu);
-        super.onCreateOptionsMenu(menu, inflater);
-    }
-
-    @Override
-    public void onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        final MenuItem item = menu.findItem(R.id.ml_menu_save);
-        item.setVisible(!isRootDirectory());
-        WorkersKt.runIO(new Runnable() {
-            @Override
-            public void run() {
-                final boolean isFavorite = getMrl() != null && getBrowserFavRepository().browserFavExists(Uri.parse(getMrl()));
-                WorkersKt.runOnMainThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        item.setIcon(isFavorite ?
-                                R.drawable.ic_menu_bookmark_w :
-                                R.drawable.ic_menu_bookmark_outline_w);
-                        item.setTitle(isFavorite ? R.string.favorites_remove : R.string.favorites_add);
-                    }
-                });
-            }
-        });
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        if (!isRootDirectory()) LocalBroadcastManager.getInstance(VLCApplication.getAppContext()).registerReceiver(mLocalReceiver, new IntentFilter(VlcLoginDialog.ACTION_DIALOG_CANCELED));
-        mFabPlay.setImageResource(isRootDirectory() ? R.drawable.ic_fab_add : R.drawable.ic_fab_play);
-        mFabPlay.setOnClickListener(this);
-        setFabPlayVisibility(true);
-    }
-
-    @Override
-    public void refresh() {
-        refresh(ExternalMonitor.INSTANCE.isConnected());
-    }
-
-    public void refresh(boolean connected) {
-        if (connected) super.refresh();
-        else {
-            updateEmptyView();
-            getAdapter().clear();
-        }
-    }
-
-    @Override
-    protected Fragment createFragment() {
-        return new NetworkBrowserFragment();
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        if (!isRootDirectory()) LocalBroadcastManager.getInstance(VLCApplication.getAppContext()).unregisterReceiver(mLocalReceiver);
-        setGoBack(false);
-    }
-
-    @Override
-    public void onCtxAction(int position, int option) {
-        final MediaWrapper mw = (MediaWrapper) getAdapter().getItem(position);
-        switch (option) {
-            case Constants.CTX_FAV_ADD:
-                getBrowserFavRepository().addNetworkFavItem(mw.getUri(), mw.getTitle(), mw.getArtworkURL());
-                break;
-            case Constants.CTX_FAV_EDIT:
-                showAddServerDialog(mw);
-                break;
-            default:
-                super.onCtxAction(position, option);
-        }
-    }
-
-    @Override
-    protected void browseRoot() {}
-
-    private boolean allowLAN() {
-        return ExternalMonitor.INSTANCE.isLan() || ExternalMonitor.INSTANCE.isVPN();
-    }
-
-    @Override
-    protected String getCategoryTitle() {
-        return getString(R.string.network_browsing);
-    }
-
-    /**
-     * Update views visibility and emptiness info
-     */
-    @Override
-    protected void updateEmptyView() {
-        if (getBinding() == null) return;
-        if (ExternalMonitor.INSTANCE.isConnected()) {
-            if (Util.isListEmpty(getViewModel().getDataset().getValue())) {
-                if (mSwipeRefreshLayout == null || mSwipeRefreshLayout.isRefreshing()) {
-                    getBinding().empty.setText(R.string.loading);
-                    getBinding().empty.setVisibility(View.VISIBLE);
-                    getBinding().networkList.setVisibility(View.GONE);
-                } else {
-                    if (isRootDirectory()) getBinding().empty.setText(allowLAN() ? R.string.network_shares_discovery : R.string.network_connection_needed);
-                    else getBinding().empty.setText(R.string.network_empty);
-                    getBinding().empty.setVisibility(View.VISIBLE);
-                    getBinding().networkList.setVisibility(View.GONE);
-                    getHandler().sendEmptyMessage(BaseBrowserFragmentKt.MSG_HIDE_LOADING);
-                }
-            } else if (getBinding().empty.getVisibility() == View.VISIBLE) {
-                    getBinding().empty.setVisibility(View.GONE);
-                    getBinding().networkList.setVisibility(View.VISIBLE);
-            }
-        } else {
-            getBinding().empty.setText(R.string.network_connection_needed);
-            getBinding().empty.setVisibility(View.VISIBLE);
-            getBinding().networkList.setVisibility(View.GONE);
-            getBinding().setShowFavorites(false);
-        }
-    }
-
-    @Override
-    public void onClick(View v) {
-        if (!isRootDirectory()) super.onClick(v);
-        else if (v.getId() == R.id.fab) showAddServerDialog(null);
-    }
-
-    public void showAddServerDialog(MediaWrapper mw) {
-        final FragmentManager fm = getFragmentManager();
-        final NetworkServerDialog dialog = new NetworkServerDialog();
-        if (mw != null) dialog.setServer(mw);
-        dialog.show(fm, "fragment_add_server");
-    }
-
-    private BroadcastReceiver mLocalReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (isResumed()) goBack();
-            else setGoBack(true);
-        }
-    };
-
-    @Override
-    public void onUpdateFinished(@NotNull RecyclerView.Adapter<?> adapter) {
-        super.onUpdateFinished(adapter);
-        if (isRootDirectory()) mFabPlay.show();
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/NetworkBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/NetworkBrowserFragment.kt
new file mode 100644
index 0000000000..aef42e08c7
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/NetworkBrowserFragment.kt
@@ -0,0 +1,192 @@
+/*
+ * *************************************************************************
+ *  NetworkBrowserFragment.java
+ * **************************************************************************
+ *  Copyright © 2015-2017 VLC authors and VideoLAN
+ *  Author: Geoffrey Métais
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *  ***************************************************************************
+ */
+
+package org.videolan.vlc.gui.browser
+
+import android.content.BroadcastReceiver
+import android.content.Context
+import android.content.Intent
+import android.content.IntentFilter
+import android.net.Uri
+import android.os.Bundle
+import android.view.Menu
+import android.view.MenuInflater
+import android.view.View
+import androidx.fragment.app.Fragment
+import androidx.lifecycle.Observer
+import androidx.lifecycle.ViewModelProviders
+import androidx.localbroadcastmanager.content.LocalBroadcastManager
+import androidx.recyclerview.widget.RecyclerView
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.ExternalMonitor
+import org.videolan.vlc.R
+import org.videolan.vlc.VLCApplication
+import org.videolan.vlc.gui.dialogs.NetworkServerDialog
+import org.videolan.vlc.gui.dialogs.VlcLoginDialog
+import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.browser.NetworkModel
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+class NetworkBrowserFragment : BaseBrowserFragment() {
+
+    override val categoryTitle: String
+        get() = getString(R.string.network_browsing)
+
+    private val mLocalReceiver = object : BroadcastReceiver() {
+        override fun onReceive(context: Context, intent: Intent) {
+            if (isResumed)
+                goBack()
+            else
+                goBack = true
+        }
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+        viewModel = ViewModelProviders.of(this, NetworkModel.Factory(requireContext(), mrl, showHiddenFiles)).get(NetworkModel::class.java)
+    }
+
+    override fun onActivityCreated(savedInstanceState: Bundle?) {
+        super.onActivityCreated(savedInstanceState)
+        ExternalMonitor.connected.observe(this, Observer { connected -> refresh(connected!!) })
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu?, inflater: MenuInflater?) {
+        inflater!!.inflate(R.menu.fragment_option_network, menu)
+        super.onCreateOptionsMenu(menu, inflater)
+    }
+
+    override fun onPrepareOptionsMenu(menu: Menu?) {
+        super.onPrepareOptionsMenu(menu)
+        val item = menu!!.findItem(R.id.ml_menu_save)
+        item.isVisible = !isRootDirectory
+        runIO(Runnable {
+            val isFavorite = mrl != null && browserFavRepository.browserFavExists(Uri.parse(mrl))
+            runOnMainThread(Runnable {
+                item.setIcon(if (isFavorite)
+                    R.drawable.ic_menu_bookmark_w
+                else
+                    R.drawable.ic_menu_bookmark_outline_w)
+                item.setTitle(if (isFavorite) R.string.favorites_remove else R.string.favorites_add)
+            })
+        })
+    }
+
+    override fun onStart() {
+        super.onStart()
+        if (!isRootDirectory) LocalBroadcastManager.getInstance(VLCApplication.getAppContext()).registerReceiver(mLocalReceiver, IntentFilter(VlcLoginDialog.ACTION_DIALOG_CANCELED))
+        fabPlay.setImageResource(if (isRootDirectory) R.drawable.ic_fab_add else R.drawable.ic_fab_play)
+        fabPlay.setOnClickListener(this)
+        setFabPlayVisibility(true)
+    }
+
+    override fun refresh() {
+        refresh(ExternalMonitor.isConnected)
+    }
+
+    fun refresh(connected: Boolean) {
+        if (connected)
+            super.refresh()
+        else {
+            updateEmptyView()
+            adapter.clear()
+        }
+    }
+
+    override fun createFragment(): Fragment {
+        return NetworkBrowserFragment()
+    }
+
+    override fun onStop() {
+        super.onStop()
+        if (!isRootDirectory) LocalBroadcastManager.getInstance(VLCApplication.getAppContext()).unregisterReceiver(mLocalReceiver)
+        goBack = false
+    }
+
+    override fun onCtxAction(position: Int, option: Int) {
+        val mw = adapter.getItem(position) as MediaWrapper
+        when (option) {
+            CTX_FAV_ADD -> browserFavRepository.addNetworkFavItem(mw.uri, mw.title, mw.artworkURL)
+            CTX_FAV_EDIT -> showAddServerDialog(mw)
+            else -> super.onCtxAction(position, option)
+        }
+    }
+
+    override fun browseRoot() {}
+
+    private fun allowLAN(): Boolean {
+        return ExternalMonitor.isLan || ExternalMonitor.isVPN
+    }
+
+    /**
+     * Update views visibility and emptiness info
+     */
+    override fun updateEmptyView() {
+        if (ExternalMonitor.isConnected) {
+            if (Util.isListEmpty(viewModel.dataset.value)) {
+                if (swipeRefreshLayout == null || swipeRefreshLayout!!.isRefreshing) {
+                    binding.empty.setText(R.string.loading)
+                    binding.empty.visibility = View.VISIBLE
+                    binding.networkList.visibility = View.GONE
+                } else {
+                    if (isRootDirectory)
+                        binding.empty.setText(if (allowLAN()) R.string.network_shares_discovery else R.string.network_connection_needed)
+                    else
+                        binding.empty.setText(R.string.network_empty)
+                    binding.empty.visibility = View.VISIBLE
+                    binding.networkList.visibility = View.GONE
+                    handler.sendEmptyMessage(MSG_HIDE_LOADING)
+                }
+            } else if (binding.empty.visibility == View.VISIBLE) {
+                binding.empty.visibility = View.GONE
+                binding.networkList.visibility = View.VISIBLE
+            }
+        } else {
+            binding.empty.setText(R.string.network_connection_needed)
+            binding.empty.visibility = View.VISIBLE
+            binding.networkList.visibility = View.GONE
+            binding.showFavorites = false
+        }
+    }
+
+    override fun onClick(v: View) {
+        if (!isRootDirectory)
+            super.onClick(v)
+        else if (v.id == R.id.fab) showAddServerDialog(null)
+    }
+
+    private fun showAddServerDialog(mw: MediaWrapper?) {
+        val fm = fragmentManager
+        val dialog = NetworkServerDialog()
+        if (mw != null) dialog.setServer(mw)
+        dialog.show(fm!!, "fragment_add_server")
+    }
+
+    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
+        super.onUpdateFinished(adapter)
+        if (isRootDirectory) fabPlay.show()
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserAdapter.kt
index fed34e5c3f..1978b75c68 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserAdapter.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserAdapter.kt
@@ -26,7 +26,10 @@ package org.videolan.vlc.gui.browser
 import android.content.Context
 import android.net.Uri
 import android.view.View
+import androidx.databinding.ViewDataBinding
+import kotlinx.coroutines.ExperimentalCoroutinesApi
 import kotlinx.coroutines.Job
+import kotlinx.coroutines.ObsoleteCoroutinesApi
 import kotlinx.coroutines.launch
 import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.medialibrary.media.MediaWrapper
@@ -37,6 +40,8 @@ import org.videolan.vlc.gui.helpers.ThreeStatesCheckbox
 import org.videolan.vlc.repository.DirectoryRepository
 import org.videolan.vlc.util.containsPath
 
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
 internal class StorageBrowserAdapter(fragment: StorageBrowserFragment) : BaseBrowserAdapter(fragment) {
 
     private var mediaDirsLocation: MutableList<String> = mutableListOf()
@@ -47,13 +52,13 @@ internal class StorageBrowserAdapter(fragment: StorageBrowserFragment) : BaseBro
         updateMediaDirs(fragment.requireContext())
     }
 
-    override fun onBindViewHolder(holder: BaseBrowserAdapter.ViewHolder<*>, position: Int) {
+    override fun onBindViewHolder(holder: ViewHolder<ViewDataBinding>, position: Int) {
         launch {
             val vh = holder as BaseBrowserAdapter.MediaViewHolder
             var storage = getItem(position)
 
-            if (storage?.itemType == MediaLibraryItem.TYPE_MEDIA) storage = Storage((storage as MediaWrapper).uri)
-            var storagePath = (storage as Storage).uri.path
+            if (storage.itemType == MediaLibraryItem.TYPE_MEDIA) storage = Storage((storage as MediaWrapper).uri)
+            var storagePath = (storage as Storage).uri.path ?: ""
             if (!storagePath.endsWith("/")) storagePath += "/"
             vh.binding.item = storage
             job?.join()
@@ -65,7 +70,7 @@ internal class StorageBrowserAdapter(fragment: StorageBrowserFragment) : BaseBro
                 hasDiscoveredChildren(storagePath) -> vh.binding.browserCheckbox.state = ThreeStatesCheckbox.STATE_PARTIAL
                 else -> vh.binding.browserCheckbox.state = ThreeStatesCheckbox.STATE_UNCHECKED
             }
-            vh.binding.checkEnabled = !fragment.mScannedDirectory
+            vh.binding.checkEnabled = !(fragment as StorageBrowserFragment).mScannedDirectory
         }
     }
 
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt
index 9df3519a65..2939ac4880 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt
@@ -62,6 +62,7 @@ import java.io.File
 
 const val KEY_IN_MEDIALIB = "key_in_medialib"
 
+@ObsoleteCoroutinesApi
 @ExperimentalCoroutinesApi
 class StorageBrowserFragment : FileBrowserFragment(), EntryPointsEventsCb, CoroutineScope by MainScope() {
 
@@ -120,14 +121,14 @@ class StorageBrowserFragment : FileBrowserFragment(), EntryPointsEventsCb, Corou
         outState.putBoolean(KEY_IN_MEDIALIB, mScannedDirectory)
     }
 
-    override fun onPrepareOptionsMenu(menu: Menu) {
+    override fun onPrepareOptionsMenu(menu: Menu?) {
         super.onPrepareOptionsMenu(menu)
-        menu.findItem(R.id.ml_menu_custom_dir)?.isVisible = true
-        menu.findItem(R.id.ml_menu_refresh)?.isVisible = false
+        menu?.findItem(R.id.ml_menu_custom_dir)?.isVisible = true
+        menu?.findItem(R.id.ml_menu_refresh)?.isVisible = false
     }
 
-    override fun onOptionsItemSelected(item: MenuItem): Boolean {
-        if (item.itemId == R.id.ml_menu_custom_dir) {
+    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
+        if (item?.itemId == R.id.ml_menu_custom_dir) {
             showAddDirectoryDialog()
             return true
         }
diff --git a/vlc-android/src/org/videolan/vlc/gui/folders/FoldersFragment.kt b/vlc-android/src/org/videolan/vlc/gui/folders/FoldersFragment.kt
index bafc73d082..dc45cf0a5b 100644
--- a/vlc-android/src/org/videolan/vlc/gui/folders/FoldersFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/folders/FoldersFragment.kt
@@ -38,7 +38,7 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
     private val actor = actor<FolderAction> {
         for (action in channel) when(action) {
             is FolderClick -> {
-                if (mActionMode != null) {
+                if (actionMode != null) {
                     adapter.multiSelectHelper.toggleSelection(action.position)
                     invalidateActionMode()
                 } else {
@@ -49,7 +49,7 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
                 }
             }
             is FolderLongClick -> {
-                if (mActionMode == null) {
+                if (actionMode == null) {
                     adapter.multiSelectHelper.toggleSelection(action.position)
                     startActionMode()
                 }
@@ -66,7 +66,7 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
             adapter = FoldersAdapter(actor)
             viewModel = ViewModelProviders.of(requireActivity(), PagedFoldersModel.Factory(requireContext(), Folder.TYPE_FOLDER_VIDEO)).get(PagedFoldersModel::class.java)
             viewModel.pagedList.observe(requireActivity(), Observer {
-                mSwipeRefreshLayout?.isRefreshing = false
+                swipeRefreshLayout?.isRefreshing = false
                 adapter.submitList(it)
             })
         }
@@ -80,27 +80,28 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
         super.onViewCreated(view, savedInstanceState)
         folders_list.layoutManager = LinearLayoutManager(view.context, RecyclerView.VERTICAL, false)
         folders_list.adapter = adapter
-        mSwipeRefreshLayout.setOnRefreshListener { activity?.reloadLibrary() }
+        swipeRefreshLayout?.setOnRefreshListener { activity?.reloadLibrary() }
     }
 
     override fun onStart() {
         super.onStart()
         setFabPlayVisibility(true);
-        mFabPlay.setImageResource(R.drawable.ic_fab_play);
+        fabPlay.setImageResource(R.drawable.ic_fab_play);
     }
 
-    override fun getTitle() = getString(R.string.video)
+
+    override fun getTitle(): String = getString(R.string.video)
 
     override fun onRefresh() {
         viewModel.refresh()
     }
 
-    override fun onPrepareOptionsMenu(menu: Menu) {
+    override fun onPrepareOptionsMenu(menu: Menu?) {
         super.onPrepareOptionsMenu(menu)
-        menu.findItem(R.id.ml_menu_last_playlist).isVisible = true
+        menu?.findItem(R.id.ml_menu_last_playlist)?.isVisible = true
     }
 
-    override fun onOptionsItemSelected(item: MenuItem)= when (item.itemId) {
+    override fun onOptionsItemSelected(item: MenuItem?) = when (item?.itemId) {
         R.id.ml_menu_last_playlist -> {
             MediaUtils.loadlastPlaylist(activity, PLAYLIST_TYPE_VIDEO)
             true
@@ -116,7 +117,7 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
         }
     }
 
-    override fun onFabPlayClick(view: View?) {
+    override fun onFabPlayClick(view: View) {
         MediaUtils.playAllTracks(context, viewModel, 0, false)
     }
 
@@ -125,13 +126,13 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
         return true
     }
 
-    override fun onPrepareActionMode(mode: ActionMode?, menu: Menu?): Boolean {
+    override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
         val count = adapter.multiSelectHelper.getSelectionCount()
         if (count == 0) {
             stopActionMode()
             return false
         }
-        menu?.findItem(R.id.action_video_append)?.isVisible = PlaylistManager.hasMedia()
+        menu.findItem(R.id.action_video_append)?.isVisible = PlaylistManager.hasMedia()
         return true
     }
 
@@ -148,7 +149,7 @@ class FoldersFragment : MediaBrowserFragment<PagedFoldersModel>(), CoroutineScop
     }
 
     override fun onDestroyActionMode(mode: ActionMode?) {
-        mActionMode = null
+        actionMode = null
         adapter.multiSelectHelper.clearSelection()
     }
 }
diff --git a/vlc-android/src/org/videolan/vlc/gui/helpers/Navigator.kt b/vlc-android/src/org/videolan/vlc/gui/helpers/Navigator.kt
index 43701b6800..af33afc392 100644
--- a/vlc-android/src/org/videolan/vlc/gui/helpers/Navigator.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/helpers/Navigator.kt
@@ -225,7 +225,9 @@ class Navigator(private val activity: MainActivity,
                 putBoolean(ExtensionBrowser.KEY_SHOW_FAB, showParams)
                 putString(ExtensionBrowser.KEY_TITLE, title)
             }
-            fragment.setExtensionService(extensionsService)
+            if (extensionsService != null) {
+                fragment.setExtensionService(extensionsService)
+            }
             when {
                 currentFragment !is ExtensionBrowser -> //case: non-extension to extension root
                     showFragment(fragment, extensionId, title)
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
index 16b81e9309..02de443089 100644
--- a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
@@ -95,8 +95,8 @@ public void onCreate(Bundle savedInstanceState) {
             final boolean seenMarkVisible = preferences.getBoolean("media_seen", true);
             mAdapter = new VideoListAdapter(this, seenMarkVisible);
             multiSelectHelper = mAdapter.getMultiSelectHelper();
-            viewModel = PagedVideosModel.Companion.get(requireContext(), this, mFolder);
-            viewModel.getPagedList().observe(this, this);
+            setViewModel(PagedVideosModel.Companion.get(requireContext(), this, mFolder));
+            getViewModel().getPagedList().observe(this, this);
         }
         if (savedInstanceState != null) setGroup(savedInstanceState.getString(Constants.KEY_GROUP));
     }
@@ -128,7 +128,7 @@ public View onCreateView(@NotNull LayoutInflater inflater, ViewGroup container,
     @Override
     public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
-        final boolean empty = viewModel.isEmpty();
+        final boolean empty = getViewModel().isEmpty();
         mBinding.loadingFlipper.setVisibility(empty ? View.VISIBLE : View.GONE);
         mBinding.loadingTitle.setVisibility(empty ? View.VISIBLE : View.GONE);
         mBinding.setEmpty(empty);
@@ -147,7 +147,7 @@ public void onClick(View v) {
     @Override
     public void onActivityCreated(@Nullable Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
-        mSwipeRefreshLayout.setOnRefreshListener(this);
+        getSwipeRefreshLayout().setOnRefreshListener(this);
         mBinding.videoGrid.setAdapter(mAdapter);
     }
 
@@ -157,12 +157,12 @@ public void onStart() {
         registerForContextMenu(mBinding.videoGrid);
         updateViewMode();
         setFabPlayVisibility(true);
-        mFabPlay.setImageResource(R.drawable.ic_fab_play);
+        getFabPlay().setImageResource(R.drawable.ic_fab_play);
     }
 
     @Override
     protected void onRestart() {
-        if (getFilterQuery() == null) viewModel.refresh();
+        if (getFilterQuery() == null) getViewModel().refresh();
     }
 
     @Override
@@ -186,7 +186,7 @@ public void onDestroy() {
 
     @Override
     public void onChanged(@Nullable PagedList<MediaWrapper> list) {
-        mAdapter.showFilename(viewModel.getSort() == Medialibrary.SORT_FILENAME);
+        mAdapter.showFilename(getViewModel().getSort() == Medialibrary.SORT_FILENAME);
         if (list != null) mAdapter.submitList(list);
     }
 
@@ -235,18 +235,18 @@ private void playAudio(MediaWrapper media) {
 
     @Override
     public void onFabPlayClick(View view) {
-        MediaUtils.INSTANCE.playAll(requireContext(), viewModel, 0, false);
+        MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), 0, false);
     }
 
     @MainThread
     public void updateList() {
-        viewModel.refresh();
+        getViewModel().refresh();
         mHandler.sendEmptyMessageDelayed(SET_REFRESHING, 300);
     }
 
     private void updateEmptyView() {
-        final boolean empty = viewModel.isEmpty();
-        final boolean working = mMediaLibrary.isWorking();
+        final boolean empty = getViewModel().isEmpty();
+        final boolean working = getMediaLibrary().isWorking();
         mBinding.loadingFlipper.setVisibility(empty && working ? View.VISIBLE : View.GONE);
         mBinding.loadingTitle.setVisibility(empty && working ? View.VISIBLE : View.GONE);
         mBinding.setEmpty(empty && !working);
@@ -273,7 +273,7 @@ public void clear() {
 
     @Override
     public void setFabPlayVisibility(boolean enable) {
-        super.setFabPlayVisibility(!viewModel.isEmpty() && enable);
+        super.setFabPlayVisibility(!getViewModel().isEmpty() && enable);
     }
 
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
@@ -338,7 +338,7 @@ public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
 
     @Override
     public void onDestroyActionMode(ActionMode mode) {
-        mActionMode = null;
+        setActionMode(null);
         setFabPlayVisibility(true);
         multiSelectHelper.clearSelection();
     }
@@ -355,11 +355,11 @@ public void handleMessage(Message msg) {
                     updateList();
                     break;
                 case SET_REFRESHING:
-                    mSwipeRefreshLayout.setRefreshing(true);
+                    getSwipeRefreshLayout().setRefreshing(true);
                     break;
                 case UNSET_REFRESHING:
                     removeMessages(SET_REFRESHING);
-                    mSwipeRefreshLayout.setRefreshing(false);
+                    getSwipeRefreshLayout().setRefreshing(false);
                     break;
                 default:
                     super.handleMessage(msg);
@@ -370,7 +370,7 @@ public void handleMessage(Message msg) {
     @Override
     public void onClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
         final MediaWrapper media = (MediaWrapper) item;
-        if (mActionMode != null) {
+        if (getActionMode() != null) {
             multiSelectHelper.toggleSelection(position);
             invalidateActionMode();
             return;
@@ -384,7 +384,7 @@ public void onClick(@NotNull View v, int position, @NotNull MediaLibraryItem ite
             media.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
             final SharedPreferences settings = Settings.INSTANCE.getInstance(v.getContext());
             if (settings.getBoolean("force_play_all", false)) {
-                MediaUtils.INSTANCE.playAll(requireContext(), viewModel, position, false);
+                MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), position, false);
             } else {
                 playVideo(media, false);
             }
@@ -393,7 +393,7 @@ public void onClick(@NotNull View v, int position, @NotNull MediaLibraryItem ite
 
     @Override
     public boolean onLongClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        if (mActionMode != null) return false;
+        if (getActionMode() != null) return false;
         multiSelectHelper.toggleSelection(position);
         startActionMode();
         return true;
@@ -408,7 +408,7 @@ public void onCtxClick(@NotNull View v, int position, @NotNull MediaLibraryItem
         final boolean group = mw.getType() == MediaWrapper.TYPE_GROUP;
         int flags = group ? Constants.CTX_VIDEO_GOUP_FLAGS : Constants.CTX_VIDEO_FLAGS;
         if (mw.getTime() != 0L && !group) flags |= Constants.CTX_PLAY_FROM_START;
-        if (mActionMode == null)
+        if (getActionMode() == null)
             ContextSheetKt.showContext(requireActivity(), this, position, item.getTitle(), flags);
     }
 
@@ -423,7 +423,7 @@ public void onUpdateFinished(@NotNull RecyclerView.Adapter adapter) {
             @Override
             public void run() {
                 if (!isResumed()) return;
-                if (!mMediaLibrary.isWorking()) mHandler.sendEmptyMessage(UNSET_REFRESHING);
+                if (!getMediaLibrary().isWorking()) mHandler.sendEmptyMessage(UNSET_REFRESHING);
                 updateEmptyView();
                 setFabPlayVisibility(true);
                 UiTools.updateSortTitles(VideoGridFragment.this);
@@ -455,7 +455,7 @@ public void onCtxAction(int position, int option) {
                 playAudio(media);
                 break;
             case Constants.CTX_PLAY_ALL:
-                MediaUtils.INSTANCE.playAll(requireContext(), viewModel, position, false);
+                MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), position, false);
                 break;
             case Constants.CTX_INFORMATION:
                 showInfoDialog(media);
