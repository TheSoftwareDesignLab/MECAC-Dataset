diff --git a/vlc-android/src/org/videolan/vlc/gui/AboutFragment.kt b/vlc-android/src/org/videolan/vlc/gui/AboutFragment.kt
index de30d5f459..b04dc63c53 100644
--- a/vlc-android/src/org/videolan/vlc/gui/AboutFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/AboutFragment.kt
@@ -68,7 +68,7 @@ class AboutFragment : Fragment() {
         val titles = arrayOf(getString(R.string.about), getString(R.string.licence))
         val viewPager = view.findViewById<ViewPager>(R.id.pager).apply {
             offscreenPageLimit = MODE_TOTAL - 1
-            adapter = AudioPagerAdapter(lists, titles)
+            adapter = AudioPagerAdapter(lists as Array<View>, titles)
         }
         requireActivity().findViewById<TabLayout>(R.id.sliding_tabs).apply {
             visibility = View.VISIBLE
diff --git a/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt b/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
index 8140b181e9..551085b7c8 100644
--- a/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
@@ -38,6 +38,8 @@ import androidx.recyclerview.widget.RecyclerView
 import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
 import com.google.android.material.appbar.AppBarLayout
 import com.google.android.material.floatingactionbutton.FloatingActionButton
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
 import kotlinx.coroutines.launch
 import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.vlc.BuildConfig
@@ -53,7 +55,9 @@ import org.videolan.vlc.util.AppScope
 import org.videolan.vlc.util.getScreenWidth
 import org.videolan.vlc.viewmodels.paged.PagedPlaylistsModel
 
-class PlaylistFragment : BaseAudioBrowser(), Observer<PagedList<MediaLibraryItem>>, SwipeRefreshLayout.OnRefreshListener {
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class PlaylistFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshListener {
 
     private lateinit var binding: PlaylistsFragmentBinding
     private lateinit var playlists: RecyclerView
@@ -104,7 +108,7 @@ class PlaylistFragment : BaseAudioBrowser(), Observer<PagedList<MediaLibraryItem
         val itemSize = requireActivity().getScreenWidth() / nbColumns - spacing * 2
 
         playlistAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_PLAYLIST, this, itemSize)
-        mAdapter = playlistAdapter
+        currentAdapter = playlistAdapter
 
         playlists.layoutManager = gridLayoutManager
         playlists.adapter = playlistAdapter
@@ -115,19 +119,18 @@ class PlaylistFragment : BaseAudioBrowser(), Observer<PagedList<MediaLibraryItem
 
     override fun onActivityCreated(savedInstanceState: Bundle?) {
         super.onActivityCreated(savedInstanceState)
-        viewModel.pagedList.observe(requireActivity(), this)
+        viewModel.pagedList.observe(requireActivity(), Observer {
+            playlistAdapter.submitList(it as PagedList<MediaLibraryItem>)
+            binding.empty.visibility = if (it.isNullOrEmpty()) View.VISIBLE else View.GONE
+        })
         viewModel.loading.observe(this, Observer<Boolean> { loading ->
             AppScope.launch { binding.swipeLayout.isRefreshing = loading == true }
         })
 
-        fastScroller.setRecyclerView(currentRV, viewModel)
+        fastScroller.setRecyclerView(getCurrentRV(), viewModel)
 
     }
 
-    override fun onChanged(list: PagedList<MediaLibraryItem>?) {
-        playlistAdapter.submitList(list)
-        binding.empty.visibility = if (list.isNullOrEmpty()) View.VISIBLE else View.GONE
-    }
 
     override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
         mode.menuInflater.inflate(R.menu.action_mode_audio_browser, menu)
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.java b/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.java
deleted file mode 100644
index 5199d9ddab..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*****************************************************************************
- * AudioAlbumsSongsFragment.java
- *****************************************************************************
- * Copyright © 2011-2016 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.audio;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-
-import com.google.android.material.appbar.AppBarLayout;
-import com.google.android.material.floatingactionbutton.FloatingActionButton;
-import com.google.android.material.tabs.TabLayout;
-
-import org.videolan.medialibrary.media.Album;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.R;
-import org.videolan.vlc.gui.PlaylistActivity;
-import org.videolan.vlc.gui.view.FastScroller;
-import org.videolan.vlc.gui.view.RecyclerSectionItemDecoration;
-import org.videolan.vlc.gui.view.SwipeRefreshLayout;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.util.Util;
-import org.videolan.vlc.viewmodels.paged.MLPagedModel;
-import org.videolan.vlc.viewmodels.paged.PagedAlbumsModel;
-import org.videolan.vlc.viewmodels.paged.PagedTracksModel;
-
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.coordinatorlayout.widget.CoordinatorLayout;
-import androidx.lifecycle.Observer;
-import androidx.lifecycle.ViewModelProviders;
-import androidx.paging.PagedList;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-
-public class AudioAlbumsSongsFragment extends BaseAudioBrowser implements SwipeRefreshLayout.OnRefreshListener {
-
-    private final static String TAG = "VLC/AudioAlbumsSongsFragment";
-
-    protected Handler mHandler = new Handler(Looper.getMainLooper());
-    private PagedAlbumsModel albumModel;
-    private PagedTracksModel tracksModel;
-
-    private SwipeRefreshLayout mSwipeRefreshLayout;
-    private RecyclerView[] mLists;
-    private MLPagedModel<MediaLibraryItem>[] audioModels;
-    private AudioBrowserAdapter mSongsAdapter;
-    private AudioBrowserAdapter mAlbumsAdapter;
-    private FastScroller mFastScroller;
-
-    private final static int MODE_ALBUM = 0;
-    private final static int MODE_SONG = 1;
-    private final static int MODE_TOTAL = 2; // Number of audio mProvider modes
-
-    private MediaLibraryItem mItem;
-
-    @Override
-    protected boolean hasTabs() {
-        return true;
-    }
-
-    /* All subclasses of Fragment must include a public empty constructor. */
-    public AudioAlbumsSongsFragment() {
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        mItem = (MediaLibraryItem) (savedInstanceState != null ?
-                savedInstanceState.getParcelable(AudioBrowserFragment.TAG_ITEM) :
-                getArguments().getParcelable(AudioBrowserFragment.TAG_ITEM));
-        albumModel = ViewModelProviders.of(this, new PagedAlbumsModel.Factory(requireContext(), mItem)).get(PagedAlbumsModel.class);
-        tracksModel = ViewModelProviders.of(this, new PagedTracksModel.Factory(requireContext(), mItem)).get(PagedTracksModel.class);
-        audioModels = new MLPagedModel[]{albumModel, tracksModel};
-    }
-
-    @Override
-    public String getTitle() {
-        return mItem.getTitle();
-    }
-
-    @Override
-    public MLPagedModel<MediaLibraryItem> getViewModel() {
-        return audioModels[mViewPager.getCurrentItem()];
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        return inflater.inflate(R.layout.audio_albums_songs, container, false);
-    }
-
-    @SuppressWarnings("unchecked")
-    @Override
-    public void onViewCreated(View view, Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-
-        final RecyclerView albumsList = (RecyclerView) mViewPager.getChildAt(MODE_ALBUM);
-        final RecyclerView songsList = (RecyclerView) mViewPager.getChildAt(MODE_SONG);
-
-        mLists = new RecyclerView[]{albumsList, songsList};
-        final String[] titles = new String[]{getString(R.string.albums), getString(R.string.songs)};
-        mAlbumsAdapter = new AudioBrowserAdapter(MediaLibraryItem.TYPE_ALBUM, this);
-        mSongsAdapter = new AudioBrowserAdapter(MediaLibraryItem.TYPE_MEDIA, this);
-        mAdapters = new AudioBrowserAdapter[]{mAlbumsAdapter, mSongsAdapter};
-
-        albumsList.addItemDecoration(new RecyclerSectionItemDecoration(getResources().getDimensionPixelSize(R.dimen.recycler_section_header_height), true, albumModel));
-        songsList.addItemDecoration(new RecyclerSectionItemDecoration(getResources().getDimensionPixelSize(R.dimen.recycler_section_header_height), true, tracksModel));
-
-        songsList.setAdapter(mSongsAdapter);
-        albumsList.setAdapter(mAlbumsAdapter);
-        mViewPager.setOffscreenPageLimit(MODE_TOTAL - 1);
-        mViewPager.setAdapter(new AudioPagerAdapter(mLists, titles));
-
-        mFastScroller = (FastScroller) view.getRootView().findViewById(R.id.songs_fast_scroller);
-        mFastScroller.attachToCoordinator((AppBarLayout) view.getRootView().findViewById(R.id.appbar), (CoordinatorLayout) view.getRootView().findViewById(R.id.coordinator), (FloatingActionButton) view.getRootView().findViewById(R.id.fab));
-
-        mViewPager.setOnTouchListener(mSwipeFilter);
-
-        mSwipeRefreshLayout = view.findViewById(R.id.swipeLayout);
-        mSwipeRefreshLayout.setOnRefreshListener(this);
-        for (RecyclerView rv : mLists) {
-            rv.setLayoutManager(new LinearLayoutManager(view.getContext()));
-            final LinearLayoutManager llm = new LinearLayoutManager(getActivity());
-            llm.setRecycleChildrenOnDetach(true);
-            rv.setLayoutManager(llm);
-            rv.addOnScrollListener(mScrollListener);
-
-        }
-        mFabPlay.setImageResource(R.drawable.ic_fab_play);
-        ((MLPagedModel) albumModel).getPagedList().observe(this, new Observer<PagedList<MediaLibraryItem>>() {
-            @Override
-            public void onChanged(@Nullable PagedList<MediaLibraryItem> albums) {
-                if (albums != null) mAlbumsAdapter.submitList(albums);
-            }
-        });
-        ((MLPagedModel) tracksModel).getPagedList().observe(this, new Observer<PagedList<MediaLibraryItem>>() {
-            @Override
-            public void onChanged(@Nullable PagedList<MediaLibraryItem> tracks) {
-                if (tracks != null) {
-                    if (tracks.isEmpty() && !tracksModel.isFiltering()) {
-                        final Activity activity = getActivity();
-                        if (activity != null) activity.finish();
-                    } else mSongsAdapter.submitList(tracks);
-                }
-            }
-        });
-    }
-
-    @Override
-    public void onRefresh() {
-        mActivity.closeSearchView();
-        albumModel.refresh();
-        tracksModel.refresh();
-    }
-
-    @Override
-    public void onSaveInstanceState(@NonNull Bundle outState) {
-        outState.putParcelable(AudioBrowserFragment.TAG_ITEM, mItem);
-        super.onSaveInstanceState(outState);
-    }
-
-    @Override
-    public void onUpdateFinished(RecyclerView.Adapter adapter) {
-        super.onUpdateFinished(adapter);
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                mSwipeRefreshLayout.setRefreshing(false);
-                final List<Album> albums = albumModel.getPagedList().getValue();
-                if (Util.isListEmpty(albums) && !getViewModel().isFiltering())
-                    mViewPager.setCurrentItem(1);
-                mFastScroller.setRecyclerView(getCurrentRV(), getViewModel());
-            }
-        });
-    }
-
-    /*
-     * Disable Swipe Refresh while scrolling horizontally
-     */
-    private View.OnTouchListener mSwipeFilter = new View.OnTouchListener() {
-        @Override
-        public boolean onTouch(View v, MotionEvent event) {
-            mSwipeRefreshLayout.setEnabled(event.getAction() == MotionEvent.ACTION_UP);
-            return false;
-        }
-    };
-
-    @Override
-    public void clear() {
-        mAlbumsAdapter.clear();
-        mSongsAdapter.clear();
-    }
-
-    @Override
-    public void onClick(View v, int position, MediaLibraryItem item) {
-        if (mActionMode != null) {
-            super.onClick(v, position, item);
-            return;
-        }
-        if (item instanceof Album) {
-            final Intent i = new Intent(getActivity(), PlaylistActivity.class);
-            i.putExtra(AudioBrowserFragment.TAG_ITEM, item);
-            startActivity(i);
-        } else
-            MediaUtils.INSTANCE.openMedia(v.getContext(), (MediaWrapper) item);
-    }
-
-    @Override
-    public void onTabUnselected(TabLayout.Tab tab) {
-        super.onTabUnselected(tab);
-        audioModels[tab.getPosition()].restore();
-    }
-
-    @Override
-    public void onTabReselected(TabLayout.Tab tab) {
-        mLists[tab.getPosition()].smoothScrollToPosition(0);
-        mFastScroller.setRecyclerView(mLists[tab.getPosition()], audioModels[tab.getPosition()]);
-    }
-
-    @Override
-    public void onTabSelected(TabLayout.Tab tab) {
-        super.onTabSelected(tab);
-        mFastScroller.setRecyclerView(mLists[tab.getPosition()], audioModels[tab.getPosition()]);
-    }
-
-    @Override
-    public AudioBrowserAdapter getCurrentAdapter() {
-        return (AudioBrowserAdapter) getCurrentRV().getAdapter();
-    }
-
-    @Override
-    protected RecyclerView getCurrentRV() {
-        return mLists[mViewPager.getCurrentItem()];
-    }
-
-    @Override
-    public void setFabPlayVisibility(boolean enable) {
-        super.setFabPlayVisibility(enable);
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public void onFabPlayClick(View view) {
-        if (mViewPager.getCurrentItem() == 0)
-            MediaUtils.INSTANCE.playAlbums(getActivity(), albumModel, 0, false);
-        else MediaUtils.INSTANCE.playAll(view.getContext(), tracksModel, 0, false);
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt b/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt
new file mode 100644
index 0000000000..e57dfdba55
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioAlbumsSongsFragment.kt
@@ -0,0 +1,238 @@
+/*****************************************************************************
+ * AudioAlbumsSongsFragment.java
+ *
+ * Copyright © 2011-2016 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.audio
+
+import android.content.Intent
+import android.os.Bundle
+import android.os.Handler
+import android.os.Looper
+import android.os.Parcelable
+import android.view.LayoutInflater
+import android.view.MotionEvent
+import android.view.View
+import android.view.ViewGroup
+import androidx.coordinatorlayout.widget.CoordinatorLayout
+import androidx.lifecycle.Observer
+import androidx.lifecycle.ViewModelProviders
+import androidx.paging.PagedList
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import com.google.android.material.appbar.AppBarLayout
+import com.google.android.material.floatingactionbutton.FloatingActionButton
+import com.google.android.material.tabs.TabLayout
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.Album
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.ContentActivity
+import org.videolan.vlc.gui.PlaylistActivity
+import org.videolan.vlc.gui.view.FastScroller
+import org.videolan.vlc.gui.view.RecyclerSectionItemDecoration
+import org.videolan.vlc.gui.view.SwipeRefreshLayout
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.util.Util
+import org.videolan.vlc.viewmodels.paged.MLPagedModel
+import org.videolan.vlc.viewmodels.paged.PagedAlbumsModel
+import org.videolan.vlc.viewmodels.paged.PagedTracksModel
+
+/* All subclasses of Fragment must include a public empty constructor. */
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class AudioAlbumsSongsFragment : BaseAudioBrowser(), androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener {
+
+    private var handler = Handler(Looper.getMainLooper())
+    private lateinit var albumModel: PagedAlbumsModel
+    private lateinit var tracksModel: PagedTracksModel
+
+    private lateinit var swipeRefreshLayout: SwipeRefreshLayout
+    private lateinit var lists: Array<RecyclerView>
+    private lateinit var audioModels: Array<MLPagedModel<MediaLibraryItem>>
+    private lateinit var songsAdapter: AudioBrowserAdapter
+    private lateinit var albumsAdapter: AudioBrowserAdapter
+    private lateinit var fastScroller: FastScroller
+
+    private lateinit var mItem: MediaLibraryItem
+
+    /*
+     * Disable Swipe Refresh while scrolling horizontally
+     */
+    private val mSwipeFilter = View.OnTouchListener { v, event ->
+        swipeRefreshLayout.isEnabled = event.action == MotionEvent.ACTION_UP
+        false
+    }
+
+    override fun hasTabs(): Boolean {
+        return true
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+
+        mItem = if (savedInstanceState != null)
+            savedInstanceState.getParcelable<Parcelable>(AudioBrowserFragment.TAG_ITEM) as MediaLibraryItem
+        else
+            arguments!!.getParcelable<Parcelable>(AudioBrowserFragment.TAG_ITEM) as MediaLibraryItem
+        albumModel = ViewModelProviders.of(this, PagedAlbumsModel.Factory(requireContext(), mItem)).get(PagedAlbumsModel::class.java)
+        tracksModel = ViewModelProviders.of(this, PagedTracksModel.Factory(requireContext(), mItem)).get(PagedTracksModel::class.java)
+        audioModels = arrayOf(albumModel as MLPagedModel<MediaLibraryItem>, tracksModel as MLPagedModel<MediaLibraryItem>)
+    }
+
+    override fun getTitle(): String {
+        return mItem.title
+    }
+
+    override fun getViewModel(): MLPagedModel<MediaLibraryItem> {
+        return audioModels[viewPager!!.currentItem]
+    }
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        return inflater.inflate(R.layout.audio_albums_songs, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+
+        val albumsList = viewPager!!.getChildAt(MODE_ALBUM) as RecyclerView
+        val songsList = viewPager!!.getChildAt(MODE_SONG) as RecyclerView
+
+        lists = arrayOf(albumsList, songsList)
+        val titles = arrayOf(getString(R.string.albums), getString(R.string.songs))
+        albumsAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_ALBUM, this)
+        songsAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_MEDIA, this)
+        adapters = arrayOf<AudioBrowserAdapter>(albumsAdapter, songsAdapter)
+
+        albumsList.addItemDecoration(RecyclerSectionItemDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_height), true, albumModel))
+        songsList.addItemDecoration(RecyclerSectionItemDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_height), true, tracksModel))
+
+        songsList.adapter = songsAdapter
+        albumsList.adapter = albumsAdapter
+        viewPager!!.offscreenPageLimit = MODE_TOTAL - 1
+        viewPager!!.adapter = AudioPagerAdapter(lists as Array<View>, titles)
+
+        fastScroller = view.rootView.findViewById<View>(R.id.songs_fast_scroller) as FastScroller
+        fastScroller.attachToCoordinator(view.rootView.findViewById<View>(R.id.appbar) as AppBarLayout, view.rootView.findViewById<View>(R.id.coordinator) as CoordinatorLayout, view.rootView.findViewById<View>(R.id.fab) as FloatingActionButton)
+
+        viewPager!!.setOnTouchListener(mSwipeFilter)
+
+        swipeRefreshLayout = view.findViewById<SwipeRefreshLayout>(R.id.swipeLayout)
+        swipeRefreshLayout.setOnRefreshListener(this)
+        for (rv in lists) {
+            rv.layoutManager = LinearLayoutManager(view.context)
+            val llm = LinearLayoutManager(activity)
+            llm.recycleChildrenOnDetach = true
+            rv.layoutManager = llm
+            rv.addOnScrollListener(scrollListener)
+
+        }
+        mFabPlay.setImageResource(R.drawable.ic_fab_play)
+        albumModel.pagedList.observe(this, Observer { albums -> if (albums != null) albumsAdapter.submitList(albums as PagedList<MediaLibraryItem>) })
+        tracksModel.pagedList.observe(this, Observer { tracks ->
+            if (tracks != null) {
+                if (tracks.isEmpty() && !tracksModel.isFiltering()) {
+                    val activity = activity
+                    activity?.finish()
+                } else
+                    songsAdapter.submitList(tracks as PagedList<MediaLibraryItem>)
+            }
+        })
+    }
+
+    override fun onRefresh() {
+        (requireActivity() as ContentActivity).closeSearchView()
+        albumModel.refresh()
+        tracksModel.refresh()
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        outState.putParcelable(AudioBrowserFragment.TAG_ITEM, mItem)
+        super.onSaveInstanceState(outState)
+    }
+
+    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
+        super.onUpdateFinished(adapter)
+        handler.post {
+            swipeRefreshLayout.isRefreshing = false
+            val albums = albumModel.pagedList.value
+            if (Util.isListEmpty(albums) && !getViewModel().isFiltering())
+                viewPager!!.currentItem = 1
+            fastScroller.setRecyclerView(getCurrentRV(), getViewModel())
+        }
+    }
+
+    override fun clear() {
+        albumsAdapter.clear()
+        songsAdapter.clear()
+    }
+
+    override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
+        if (mActionMode != null) {
+            super.onClick(v, position, item)
+            return
+        }
+        if (item is Album) {
+            val i = Intent(activity, PlaylistActivity::class.java)
+            i.putExtra(AudioBrowserFragment.TAG_ITEM, item)
+            startActivity(i)
+        } else
+            MediaUtils.openMedia(v.context, item as MediaWrapper)
+    }
+
+    override fun onTabUnselected(tab: TabLayout.Tab) {
+        super.onTabUnselected(tab)
+        audioModels[tab.position].restore()
+    }
+
+    override fun onTabReselected(tab: TabLayout.Tab) {
+        lists[tab.position].smoothScrollToPosition(0)
+        fastScroller.setRecyclerView(lists[tab.position], audioModels[tab.position])
+    }
+
+    override fun onTabSelected(tab: TabLayout.Tab) {
+        super.onTabSelected(tab)
+        fastScroller.setRecyclerView(lists[tab.position], audioModels[tab.position])
+    }
+
+    override fun getCurrentRV(): RecyclerView {
+        return lists[viewPager!!.currentItem]
+    }
+
+    override fun setFabPlayVisibility(enable: Boolean) {
+        super.setFabPlayVisibility(enable)
+    }
+
+    override fun onFabPlayClick(view: View) {
+        if (viewPager!!.currentItem == 0)
+            MediaUtils.playAlbums(activity, albumModel, 0, false)
+        else
+            MediaUtils.playAll(view.context, tracksModel, 0, false)
+    }
+
+    companion object {
+
+        private val TAG = "VLC/AudioAlbumsSongsFragment"
+
+        private val MODE_ALBUM = 0
+        private val MODE_SONG = 1
+        private val MODE_TOTAL = 2 // Number of audio mProvider modes
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.java b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.java
deleted file mode 100644
index 0ddcc08f77..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.java
+++ /dev/null
@@ -1,401 +0,0 @@
-/*****************************************************************************
- * AudioBrowserFragment.java
- *****************************************************************************
- * Copyright © 2011-2017 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.audio;
-
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Button;
-import android.widget.TextView;
-
-import com.google.android.material.appbar.AppBarLayout;
-import com.google.android.material.floatingactionbutton.FloatingActionButton;
-import com.google.android.material.tabs.TabLayout;
-
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.MediaParsingServiceKt;
-import org.videolan.vlc.R;
-import org.videolan.vlc.gui.AudioPlayerContainerActivity;
-import org.videolan.vlc.gui.PlaylistActivity;
-import org.videolan.vlc.gui.SecondaryActivity;
-import org.videolan.vlc.gui.preferences.PreferencesActivity;
-import org.videolan.vlc.gui.view.FastScroller;
-import org.videolan.vlc.gui.view.RecyclerSectionItemDecoration;
-import org.videolan.vlc.gui.view.SwipeRefreshLayout;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.Settings;
-import org.videolan.vlc.util.WeakHandler;
-import org.videolan.vlc.viewmodels.paged.MLPagedModel;
-import org.videolan.vlc.viewmodels.paged.PagedAlbumsModel;
-import org.videolan.vlc.viewmodels.paged.PagedArtistsModel;
-import org.videolan.vlc.viewmodels.paged.PagedGenresModel;
-import org.videolan.vlc.viewmodels.paged.PagedTracksModel;
-
-import java.util.ArrayList;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.coordinatorlayout.widget.CoordinatorLayout;
-import androidx.fragment.app.FragmentActivity;
-import androidx.lifecycle.Observer;
-import androidx.lifecycle.ViewModelProviders;
-import androidx.paging.PagedList;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-
-public class AudioBrowserFragment extends BaseAudioBrowser implements SwipeRefreshLayout.OnRefreshListener {
-    public final static String TAG = "VLC/AudioBrowserFragment";
-
-    private AudioBrowserAdapter mSongsAdapter;
-    private AudioBrowserAdapter mArtistsAdapter;
-    private AudioBrowserAdapter mAlbumsAdapter;
-    private AudioBrowserAdapter mGenresAdapter;
-
-    private PagedArtistsModel artistModel;
-    private PagedAlbumsModel albumModel;
-    private PagedTracksModel tracksModel;
-    private PagedGenresModel genresModel;
-
-    private TextView mEmptyView;
-    private Button mMedialibrarySettingsBtn;
-    private final RecyclerView[] mLists = new RecyclerView[MODE_TOTAL];
-    private MLPagedModel<MediaLibraryItem>[] models;
-    private SharedPreferences mSettings;
-    private FastScroller mFastScroller;
-
-
-
-    private static final String KEY_LISTS_POSITIONS = "key_lists_position";
-    private static final int SET_REFRESHING = 103;
-    private static final int UNSET_REFRESHING = 104;
-    private static final int UPDATE_EMPTY_VIEW = 105;
-    private final static int MODE_ARTIST = 0;
-    private final static int MODE_ALBUM = 1;
-    private final static int MODE_SONG = 2;
-    private final static int MODE_GENRE = 3;
-    private final static int MODE_TOTAL = 4; // Number of audio mProvider modes
-
-    public final static String TAG_ITEM = "ML_ITEM";
-
-    @Override
-    protected boolean hasTabs() {
-        return true;
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (mSettings == null) mSettings = Settings.INSTANCE.getInstance(requireContext());
-        if (models == null) setupModels();
-        if (mSettings.getBoolean("audio_resume_card", true)) ((AudioPlayerContainerActivity)requireActivity()).proposeCard();
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        return inflater.inflate(R.layout.audio_browser, container, false);
-    }
-
-    @Override
-    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        mEmptyView = view.findViewById(R.id.no_media);
-        mMedialibrarySettingsBtn = view.findViewById(R.id.button_nomedia);
-        mFastScroller = view.getRootView().findViewById(R.id.songs_fast_scroller);
-        mFastScroller.attachToCoordinator((AppBarLayout) view.getRootView().findViewById(R.id.appbar), (CoordinatorLayout) view.getRootView().findViewById(R.id.coordinator), (FloatingActionButton) view.getRootView().findViewById(R.id.fab));
-        mMedialibrarySettingsBtn.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                final FragmentActivity activity = requireActivity();
-                final Intent intent = new Intent(activity.getApplicationContext(), SecondaryActivity.class);
-                intent.putExtra("fragment", SecondaryActivity.STORAGE_BROWSER);
-                startActivity(intent);
-                activity.setResult(PreferencesActivity.RESULT_RESTART);
-            }
-        });
-    }
-
-    @Override
-    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        for (int i = 0; i < MODE_TOTAL; i++) mLists[i] = (RecyclerView) mViewPager.getChildAt(i);
-
-        final String[] titles = new String[] {
-                getString(R.string.artists),
-                getString(R.string.albums),
-                getString(R.string.tracks),
-                getString(R.string.genres),
-        };
-        mViewPager.setOffscreenPageLimit(MODE_TOTAL - 1);
-        mViewPager.setAdapter(new AudioPagerAdapter(mLists, titles));
-        final int tabPosition = mSettings.getInt(Constants.KEY_AUDIO_CURRENT_TAB, 0);
-        mViewPager.setCurrentItem(tabPosition);
-        final ArrayList<Integer> positions = savedInstanceState != null ? savedInstanceState.getIntegerArrayList(KEY_LISTS_POSITIONS) : null;
-        for (int i = 0; i< MODE_TOTAL; ++i) {
-            final LinearLayoutManager llm = new LinearLayoutManager(getActivity());
-            llm.setRecycleChildrenOnDetach(true);
-            mLists[i].setLayoutManager(llm);
-            mLists[i].setAdapter(mAdapters[i]);
-            if (positions != null) mLists[i].scrollToPosition(positions.get(i));
-            mLists[i].addOnScrollListener(mScrollListener);
-            mLists[i].addItemDecoration(new RecyclerSectionItemDecoration(getResources().getDimensionPixelSize(R.dimen.recycler_section_header_height), true, models[i]));
-        }
-        mViewPager.setOnTouchListener(mSwipeFilter);
-        mSwipeRefreshLayout.setOnRefreshListener(this);
-    }
-
-    @Override
-    public void onSaveInstanceState(@NonNull Bundle outState) {
-        final ArrayList<Integer> positions = new ArrayList<>(MODE_TOTAL);
-        for (int i = 0; i< MODE_TOTAL; ++i) {
-            positions.add(((LinearLayoutManager)mLists[i].getLayoutManager()).findFirstCompletelyVisibleItemPosition());
-        }
-        outState.putIntegerArrayList(KEY_LISTS_POSITIONS, positions);
-        super.onSaveInstanceState(outState);
-    }
-
-    private void setupModels() {
-        final int current = mSettings.getInt(Constants.KEY_AUDIO_CURRENT_TAB, 0);
-        for (int pass = 0 ; pass < 2; ++pass) {
-            if ((pass != 0 ^ current == MODE_ARTIST) && mArtistsAdapter == null) {
-                artistModel = ViewModelProviders.of(requireActivity(), new PagedArtistsModel.Factory(requireContext(), mSettings.getBoolean(Constants.KEY_ARTISTS_SHOW_ALL, false))).get(PagedArtistsModel.class);
-                mArtistsAdapter = new AudioBrowserAdapter(MediaLibraryItem.TYPE_ARTIST, this);
-            }
-            if ((pass != 0 ^ current == MODE_ALBUM) && mAlbumsAdapter == null) {
-                albumModel = ViewModelProviders.of(requireActivity(), new PagedAlbumsModel.Factory(requireContext(), null)).get(PagedAlbumsModel.class);
-                mAlbumsAdapter = new AudioBrowserAdapter(MediaLibraryItem.TYPE_ALBUM, this);
-            }
-            if ((pass != 0 ^ current == MODE_SONG) && mSongsAdapter == null) {
-                tracksModel = ViewModelProviders.of(requireActivity(), new PagedTracksModel.Factory(requireContext(), null)).get(PagedTracksModel.class);
-                mSongsAdapter = new AudioBrowserAdapter(MediaLibraryItem.TYPE_MEDIA, this);
-            }
-            if ((pass != 0 ^ current == MODE_GENRE) && mGenresAdapter == null) {
-                genresModel = ViewModelProviders.of(requireActivity(), new PagedGenresModel.Factory(requireContext())).get(PagedGenresModel.class);
-                mGenresAdapter = new AudioBrowserAdapter(MediaLibraryItem.TYPE_GENRE, this);
-            }
-        }
-        mAdapters = new AudioBrowserAdapter[] {mArtistsAdapter, mAlbumsAdapter, mSongsAdapter, mGenresAdapter};
-        models = new MLPagedModel[] {artistModel, albumModel, tracksModel, genresModel};
-        for (int pass = 0 ; pass < 2; ++pass) {
-            for (int i = 0; i < models.length; ++i) {
-                if (pass == 0 ^ current == i) continue;
-                final int index = i;
-                models[i].getPagedList().observe(this, new Observer<PagedList<MediaLibraryItem>>() {
-                    @Override
-                    public void onChanged(@Nullable PagedList<MediaLibraryItem> items) {
-                        if (items != null) mAdapters[index].submitList(items);
-                    }
-                });
-                models[i].getLoading().observe(this, new Observer<Boolean>() {
-                    @Override
-                    public void onChanged(@Nullable Boolean loading) {
-                        if (loading == null || mViewPager.getCurrentItem() != index) return;
-                        if (loading) mHandler.sendEmptyMessageDelayed(SET_REFRESHING, 300);
-                        else mHandler.sendEmptyMessage(UNSET_REFRESHING);
-                    }
-                });
-            }
-        }
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        setFabPlayShuffleAllVisibility();
-        mFabPlay.setImageResource(R.drawable.ic_fab_shuffle);
-    }
-
-    @Override
-    public void onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        menu.findItem(R.id.ml_menu_last_playlist).setVisible(true);
-    }
-
-    @Override
-    public void onFabPlayClick(View view) {
-        MediaUtils.INSTANCE.playAll(view.getContext(), tracksModel, 0, true);
-    }
-
-    private void setFabPlayShuffleAllVisibility() {
-        setFabPlayVisibility(mSongsAdapter.getItemCount() > 2);
-    }
-
-    /**
-     * Handle changes on the list
-     */
-    private final Handler mHandler = new AudioBrowserHandler(this);
-
-    @Override
-    public void onRefresh() {
-        mActivity.closeSearchView();
-        MediaParsingServiceKt.reloadLibrary(requireContext());
-    }
-
-    @Override
-    public String getTitle() {
-        return getString(R.string.audio);
-    }
-
-    @Override
-    public boolean enableSearchOption() {
-        return true;
-    }
-
-    private void updateEmptyView() {
-        mEmptyView.setVisibility(getCurrentAdapter().isEmpty() ? View.VISIBLE : View.GONE);
-        mMedialibrarySettingsBtn.setVisibility(getCurrentAdapter().isEmpty() ? View.VISIBLE : View.GONE);
-        setFabPlayShuffleAllVisibility();
-    }
-
-    @Override
-    public void onPageSelected(int position) {
-        updateEmptyView();
-        setFabPlayShuffleAllVisibility();
-    }
-
-    @Override
-    public void onTabSelected(TabLayout.Tab tab) {
-        super.onTabSelected(tab);
-        mFastScroller.setRecyclerView(mLists[tab.getPosition()],models[tab.getPosition()]);
-        mSettings.edit().putInt(Constants.KEY_AUDIO_CURRENT_TAB, tab.getPosition()).apply();
-        final Boolean loading = getViewModel().getLoading().getValue();
-        if (loading == null || !loading) mHandler.sendEmptyMessage(UNSET_REFRESHING);
-        else mHandler.sendEmptyMessage(SET_REFRESHING);
-    }
-
-    @Override
-    public void onTabUnselected(TabLayout.Tab tab) {
-        super.onTabUnselected(tab);
-        onDestroyActionMode((AudioBrowserAdapter) mLists[tab.getPosition()].getAdapter());
-        models[tab.getPosition()].restore();
-    }
-
-    @Override
-    public void onTabReselected(TabLayout.Tab tab) {
-        mLists[tab.getPosition()].smoothScrollToPosition(0);
-    }
-
-    @Override
-    public void onClick(View v, int position, MediaLibraryItem item) {
-        if (item == null) return;
-        if (mActionMode != null) {
-            super.onClick(v, position, item);
-            return;
-        }
-        if (item.getItemType() == MediaLibraryItem.TYPE_MEDIA) {
-            MediaUtils.INSTANCE.openMedia(getActivity(), (MediaWrapper) item);
-            return;
-        }
-        final Intent i;
-        switch (item.getItemType()) {
-            case MediaLibraryItem.TYPE_ARTIST:
-            case MediaLibraryItem.TYPE_GENRE:
-                i = new Intent(getActivity(), SecondaryActivity.class);
-                i.putExtra(SecondaryActivity.KEY_FRAGMENT, SecondaryActivity.ALBUMS_SONGS);
-                i.putExtra(TAG_ITEM, item);
-                break;
-            case MediaLibraryItem.TYPE_ALBUM:
-                i = new Intent(getActivity(), PlaylistActivity.class);
-                i.putExtra(TAG_ITEM, item);
-                break;
-            default:
-                return;
-        }
-        startActivity(i);
-    }
-
-    @Override
-    public void onUpdateFinished(RecyclerView.Adapter adapter) {
-        super.onUpdateFinished(adapter);
-        if (adapter == getCurrentAdapter()) {
-            mSwipeRefreshLayout.setEnabled(((LinearLayoutManager)getCurrentRV().getLayoutManager()).findFirstVisibleItemPosition() <= 0);
-            updateEmptyView();
-            mFastScroller.setRecyclerView(getCurrentRV(), getViewModel());
-        } else setFabPlayShuffleAllVisibility();
-    }
-
-    @Override
-    public MLPagedModel<MediaLibraryItem> getViewModel() {
-        return models[mViewPager.getCurrentItem()];
-    }
-
-    @Override
-    public AudioBrowserAdapter getCurrentAdapter() {
-        return (AudioBrowserAdapter) (getCurrentRV()).getAdapter();
-    }
-
-    @Override
-    protected RecyclerView getCurrentRV() {
-        return mLists[mViewPager.getCurrentItem()];
-    }
-
-    private static class AudioBrowserHandler extends WeakHandler<AudioBrowserFragment> {
-        AudioBrowserHandler(AudioBrowserFragment owner) {
-            super(owner);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            final AudioBrowserFragment fragment = getOwner();
-            if (fragment == null) return;
-            switch (msg.what) {
-                case SET_REFRESHING:
-                    fragment.mSwipeRefreshLayout.setRefreshing(true);
-                    break;
-                case UNSET_REFRESHING:
-                    removeMessages(SET_REFRESHING);
-                    fragment.mSwipeRefreshLayout.setRefreshing(false);
-                    break;
-                case UPDATE_EMPTY_VIEW:
-                    fragment.updateEmptyView();
-            }
-        }
-    }
-
-    public void updateArtists() {
-        artistModel.showAll(mSettings.getBoolean(Constants.KEY_ARTISTS_SHOW_ALL, false));
-        artistModel.refresh();
-    }
-
-    /*
-     * Disable Swipe Refresh while scrolling horizontally
-     */
-    private View.OnTouchListener mSwipeFilter = new View.OnTouchListener() {
-        @Override
-        public boolean onTouch(View v, MotionEvent event) {
-            mSwipeRefreshLayout.setEnabled(event.getAction() == MotionEvent.ACTION_UP);
-            return false;
-        }
-    };
-
-    @Override
-    public boolean allowedToExpand() {
-        return getCurrentRV().getScrollState() == RecyclerView.SCROLL_STATE_IDLE;
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt
new file mode 100644
index 0000000000..f3093a96b2
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserFragment.kt
@@ -0,0 +1,342 @@
+/*****************************************************************************
+ * AudioBrowserFragment.java
+ *
+ * Copyright © 2011-2017 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.audio
+
+import android.content.Intent
+import android.content.SharedPreferences
+import android.os.Bundle
+import android.os.Message
+import android.view.*
+import android.widget.Button
+import android.widget.TextView
+import androidx.coordinatorlayout.widget.CoordinatorLayout
+import androidx.lifecycle.Observer
+import androidx.lifecycle.ViewModelProviders
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
+import com.google.android.material.appbar.AppBarLayout
+import com.google.android.material.floatingactionbutton.FloatingActionButton
+import com.google.android.material.tabs.TabLayout
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.AudioPlayerContainerActivity
+import org.videolan.vlc.gui.ContentActivity
+import org.videolan.vlc.gui.PlaylistActivity
+import org.videolan.vlc.gui.SecondaryActivity
+import org.videolan.vlc.gui.preferences.PreferencesActivity
+import org.videolan.vlc.gui.view.FastScroller
+import org.videolan.vlc.gui.view.RecyclerSectionItemDecoration
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.reloadLibrary
+import org.videolan.vlc.util.KEY_ARTISTS_SHOW_ALL
+import org.videolan.vlc.util.KEY_AUDIO_CURRENT_TAB
+import org.videolan.vlc.util.Settings
+import org.videolan.vlc.util.WeakHandler
+import org.videolan.vlc.viewmodels.paged.*
+import java.util.*
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class AudioBrowserFragment : BaseAudioBrowser(), SwipeRefreshLayout.OnRefreshListener {
+
+    private lateinit var songsAdapter: AudioBrowserAdapter
+    private lateinit var artistsAdapter: AudioBrowserAdapter
+    private lateinit var albumsAdapter: AudioBrowserAdapter
+    private lateinit var genresAdapter: AudioBrowserAdapter
+
+    private lateinit var artistModel: PagedArtistsModel
+    private lateinit var albumModel: PagedAlbumsModel
+    private lateinit var tracksModel: PagedTracksModel
+    private lateinit var genresModel: PagedGenresModel
+
+    private lateinit var emptyView: TextView
+    private lateinit var medialibrarySettingsBtn: Button
+    private val lists = arrayOfNulls<RecyclerView>(MODE_TOTAL)
+    private lateinit var models: Array<MLPagedModel<MediaLibraryItem>>
+    private lateinit var settings: SharedPreferences
+    private lateinit var fastScroller: FastScroller
+
+    /**
+     * Handle changes on the list
+     */
+    private val mHandler = AudioBrowserHandler(this)
+
+    /*
+     * Disable Swipe Refresh while scrolling horizontally
+     */
+    private val mSwipeFilter = View.OnTouchListener { _, event ->
+        mSwipeRefreshLayout.isEnabled = event.action == MotionEvent.ACTION_UP
+        false
+    }
+
+    override fun hasTabs(): Boolean {
+        return true
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        if (!::settings.isInitialized) settings = Settings.getInstance(requireContext())
+        if (!::models.isInitialized) setupModels()
+        if (settings.getBoolean("audio_resume_card", true)) (requireActivity() as AudioPlayerContainerActivity).proposeCard()
+    }
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        return inflater.inflate(R.layout.audio_browser, container, false)
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+        emptyView = view.findViewById(R.id.no_media)
+        medialibrarySettingsBtn = view.findViewById(R.id.button_nomedia)
+        fastScroller = view.rootView.findViewById(R.id.songs_fast_scroller)
+        fastScroller.attachToCoordinator(view.rootView.findViewById<View>(R.id.appbar) as AppBarLayout, view.rootView.findViewById<View>(R.id.coordinator) as CoordinatorLayout, view.rootView.findViewById<View>(R.id.fab) as FloatingActionButton)
+        medialibrarySettingsBtn.setOnClickListener {
+            val activity = requireActivity()
+            val intent = Intent(activity.applicationContext, SecondaryActivity::class.java)
+            intent.putExtra("fragment", SecondaryActivity.STORAGE_BROWSER)
+            startActivity(intent)
+            activity.setResult(PreferencesActivity.RESULT_RESTART)
+        }
+    }
+
+    override fun onActivityCreated(savedInstanceState: Bundle?) {
+        super.onActivityCreated(savedInstanceState)
+        for (i in 0 until MODE_TOTAL) lists[i] = viewPager!!.getChildAt(i) as RecyclerView
+
+        val titles = arrayOf(getString(R.string.artists), getString(R.string.albums), getString(R.string.tracks), getString(R.string.genres))
+        viewPager!!.offscreenPageLimit = MODE_TOTAL - 1
+        viewPager!!.adapter = AudioPagerAdapter(lists as Array<View>, titles)
+        val tabPosition = settings.getInt(KEY_AUDIO_CURRENT_TAB, 0)
+        viewPager!!.currentItem = tabPosition
+        val positions = savedInstanceState?.getIntegerArrayList(KEY_LISTS_POSITIONS)
+        for (i in 0 until MODE_TOTAL) {
+            val llm = LinearLayoutManager(activity)
+            llm.recycleChildrenOnDetach = true
+            val list = lists[i] as RecyclerView
+            list.layoutManager = llm
+            list.adapter = adapters[i]
+            if (positions != null) list.scrollToPosition(positions[i])
+            list.addOnScrollListener(scrollListener)
+            list.addItemDecoration(RecyclerSectionItemDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_height), true, models[i]))
+        }
+        viewPager!!.setOnTouchListener(mSwipeFilter)
+        mSwipeRefreshLayout.setOnRefreshListener(this)
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        val positions = ArrayList<Int>(MODE_TOTAL)
+        for (i in 0 until MODE_TOTAL) {
+            positions.add((lists[i]!!.layoutManager as LinearLayoutManager).findFirstCompletelyVisibleItemPosition())
+        }
+        outState.putIntegerArrayList(KEY_LISTS_POSITIONS, positions)
+        super.onSaveInstanceState(outState)
+    }
+
+    private fun setupModels() {
+        val current = settings.getInt(KEY_AUDIO_CURRENT_TAB, 0)
+        for (pass in 0..1) {
+            if ((pass != 0) xor (current == MODE_ARTIST) && !::artistsAdapter.isInitialized) {
+                artistModel = ViewModelProviders.of(requireActivity(), PagedArtistsModel.Factory(requireContext(), settings.getBoolean(KEY_ARTISTS_SHOW_ALL, false))).get(PagedArtistsModel::class.java)
+                artistsAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_ARTIST, this)
+            }
+            if ((pass != 0) xor (current == MODE_ALBUM) && !::albumsAdapter.isInitialized) {
+                albumModel = ViewModelProviders.of(requireActivity(), PagedAlbumsModel.Factory(requireContext(), null)).get(PagedAlbumsModel::class.java)
+                albumsAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_ALBUM, this)
+            }
+            if ((pass != 0) xor (current == MODE_SONG) && !::songsAdapter.isInitialized) {
+                tracksModel = ViewModelProviders.of(requireActivity(), PagedTracksModel.Factory(requireContext(), null)).get(PagedTracksModel::class.java)
+                songsAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_MEDIA, this)
+            }
+            if ((pass != 0) xor (current == MODE_GENRE) && !::genresAdapter.isInitialized) {
+                genresModel = ViewModelProviders.of(requireActivity(), PagedGenresModel.Factory(requireContext())).get(PagedGenresModel::class.java)
+                genresAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_GENRE, this)
+            }
+        }
+        adapters = arrayOf(artistsAdapter, albumsAdapter, songsAdapter, genresAdapter)
+        models = arrayOf(artistModel as MLPagedModel<MediaLibraryItem>, albumModel as MLPagedModel<MediaLibraryItem>, tracksModel as MLPagedModel<MediaLibraryItem>, genresModel as MLPagedModel<MediaLibraryItem>)
+        for (pass in 0..1) {
+            for (i in models.indices) {
+                if ((pass == 0) xor (current == i)) continue
+                models[i].pagedList.observe(this, Observer { items -> if (items != null) adapters[i].submitList(items) })
+                models[i].loading.observe(this, Observer { loading ->
+                    if (loading == null || viewPager!!.currentItem != i) return@Observer
+                    if (loading)
+                        mHandler.sendEmptyMessageDelayed(SET_REFRESHING, 300)
+                    else
+                        mHandler.sendEmptyMessage(UNSET_REFRESHING)
+                })
+            }
+        }
+    }
+
+    override fun onStart() {
+        super.onStart()
+        setFabPlayShuffleAllVisibility()
+        mFabPlay.setImageResource(R.drawable.ic_fab_shuffle)
+    }
+
+    override fun onPrepareOptionsMenu(menu: Menu?) {
+        super.onPrepareOptionsMenu(menu)
+        menu?.findItem(R.id.ml_menu_last_playlist)?.isVisible = true
+    }
+
+    override fun onFabPlayClick(view: View) {
+        MediaUtils.playAll(view.context, tracksModel, 0, true)
+    }
+
+    private fun setFabPlayShuffleAllVisibility() {
+        setFabPlayVisibility(songsAdapter.itemCount > 2)
+    }
+
+    override fun onRefresh() {
+        (requireActivity() as ContentActivity).closeSearchView()
+        requireContext().reloadLibrary()
+    }
+
+    override fun getTitle(): String {
+        return getString(R.string.audio)
+    }
+
+    override fun enableSearchOption(): Boolean {
+        return true
+    }
+
+    private fun updateEmptyView() {
+        emptyView.visibility = if (currentAdapter != null && currentAdapter!!.isEmpty) View.VISIBLE else View.GONE
+        medialibrarySettingsBtn.visibility = if (currentAdapter != null && currentAdapter!!.isEmpty) View.VISIBLE else View.GONE
+        setFabPlayShuffleAllVisibility()
+    }
+
+    override fun onPageSelected(position: Int) {
+        updateEmptyView()
+        setFabPlayShuffleAllVisibility()
+    }
+
+    override fun onTabSelected(tab: TabLayout.Tab) {
+        super.onTabSelected(tab)
+        fastScroller.setRecyclerView(lists[tab.position]!!, models[tab.position])
+        settings.edit().putInt(KEY_AUDIO_CURRENT_TAB, tab.position).apply()
+        val loading = getViewModel().loading.value
+        if (loading == null || !loading)
+            mHandler.sendEmptyMessage(UNSET_REFRESHING)
+        else
+            mHandler.sendEmptyMessage(SET_REFRESHING)
+    }
+
+    override fun onTabUnselected(tab: TabLayout.Tab) {
+        super.onTabUnselected(tab)
+        onDestroyActionMode(lists[tab.position]!!.adapter as AudioBrowserAdapter?)
+        models[tab.position].restore()
+    }
+
+    override fun onTabReselected(tab: TabLayout.Tab) {
+        lists[tab.position]?.smoothScrollToPosition(0)
+    }
+
+    override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
+        if (mActionMode != null) {
+            super.onClick(v, position, item)
+            return
+        }
+        if (item.itemType == MediaLibraryItem.TYPE_MEDIA) {
+            MediaUtils.openMedia(activity, item as MediaWrapper)
+            return
+        }
+        val i: Intent
+        when (item.itemType) {
+            MediaLibraryItem.TYPE_ARTIST, MediaLibraryItem.TYPE_GENRE -> {
+                i = Intent(activity, SecondaryActivity::class.java)
+                i.putExtra(SecondaryActivity.KEY_FRAGMENT, SecondaryActivity.ALBUMS_SONGS)
+                i.putExtra(TAG_ITEM, item)
+            }
+            MediaLibraryItem.TYPE_ALBUM -> {
+                i = Intent(activity, PlaylistActivity::class.java)
+                i.putExtra(TAG_ITEM, item)
+            }
+            else -> return
+        }
+        startActivity(i)
+    }
+
+    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
+        super.onUpdateFinished(adapter)
+        if (currentAdapter != null && adapter === currentAdapter) {
+            mSwipeRefreshLayout.isEnabled = (getCurrentRV().layoutManager as LinearLayoutManager).findFirstVisibleItemPosition() <= 0
+            updateEmptyView()
+            fastScroller.setRecyclerView(getCurrentRV(), getViewModel())
+        } else
+            setFabPlayShuffleAllVisibility()
+    }
+
+    override fun getViewModel(): MLPagedModel<MediaLibraryItem> {
+        return models[viewPager!!.currentItem]
+    }
+
+
+    override fun getCurrentRV(): RecyclerView {
+        return lists[viewPager!!.currentItem]!!
+    }
+
+    private class AudioBrowserHandler internal constructor(owner: AudioBrowserFragment) : WeakHandler<AudioBrowserFragment>(owner) {
+
+        override fun handleMessage(msg: Message) {
+            val fragment = owner ?: return
+            when (msg.what) {
+                SET_REFRESHING -> fragment.mSwipeRefreshLayout.isRefreshing = true
+                UNSET_REFRESHING -> {
+                    removeMessages(SET_REFRESHING)
+                    fragment.mSwipeRefreshLayout.isRefreshing = false
+                }
+                UPDATE_EMPTY_VIEW -> fragment.updateEmptyView()
+            }
+        }
+    }
+
+    fun updateArtists() {
+        artistModel.showAll(settings.getBoolean(KEY_ARTISTS_SHOW_ALL, false))
+        artistModel.refresh()
+    }
+
+    override fun allowedToExpand(): Boolean {
+        return getCurrentRV().scrollState == RecyclerView.SCROLL_STATE_IDLE
+    }
+
+    companion object {
+        val TAG = "VLC/AudioBrowserFragment"
+
+
+        private const val KEY_LISTS_POSITIONS = "key_lists_position"
+        private const val SET_REFRESHING = 103
+        private const val UNSET_REFRESHING = 104
+        private const val UPDATE_EMPTY_VIEW = 105
+        private const val MODE_ARTIST = 0
+        private const val MODE_ALBUM = 1
+        private const val MODE_SONG = 2
+        private const val MODE_GENRE = 3
+        private const val MODE_TOTAL = 4 // Number of audio mProvider modes
+
+        const val TAG_ITEM = "ML_ITEM"
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioPagerAdapter.java b/vlc-android/src/org/videolan/vlc/gui/audio/AudioPagerAdapter.kt
similarity index 50%
rename from vlc-android/src/org/videolan/vlc/gui/audio/AudioPagerAdapter.java
rename to vlc-android/src/org/videolan/vlc/gui/audio/AudioPagerAdapter.kt
index b467822e7d..1cd28cb4b3 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioPagerAdapter.java
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioPagerAdapter.kt
@@ -20,49 +20,31 @@
  *  ***************************************************************************
  */
 
-package org.videolan.vlc.gui.audio;
+package org.videolan.vlc.gui.audio
 
-import android.database.DataSetObserver;
-import androidx.viewpager.widget.PagerAdapter;
-import android.view.View;
-import android.view.ViewGroup;
+import android.view.View
+import android.view.ViewGroup
+import androidx.viewpager.widget.PagerAdapter
 
-public class AudioPagerAdapter extends PagerAdapter {
+class AudioPagerAdapter(private val mLists: Array<View>?, private val mTitles: Array<String>) : PagerAdapter() {
 
-    private View[] mLists;
-    private String[] mTitles;
-
-    public AudioPagerAdapter(View[] lists, String[] titles){
-        mLists = lists;
-        mTitles = titles;
-    }
-
-    @Override
-    public int getCount() {
-        return mLists == null ? 0 : mLists.length;
+    override fun getCount(): Int {
+        return mLists?.size ?: 0
     }
 
-    @Override
-    public boolean isViewFromObject(View view, Object object) {
-        return view == object;
+    override fun isViewFromObject(view: View, `object`: Any): Boolean {
+        return view === `object`
     }
 
-    @Override
-    public Object instantiateItem(ViewGroup container, int position) {
-        return mLists[position];
+    override fun instantiateItem(container: ViewGroup, position: Int): Any {
+        return mLists!![position]
     }
 
-    @Override
-    public CharSequence getPageTitle(int position) {
-        if (position < 0 || position >= mTitles.length)
-            return "";
+    override fun getPageTitle(position: Int): CharSequence? {
+        return if (position < 0 || position >= mTitles.size)
+            ""
         else
-            return mTitles[position];
+            mTitles[position]
     }
 
-    @Override
-    public void unregisterDataSetObserver(DataSetObserver observer) {
-        if (observer != null)
-            super.unregisterDataSetObserver(observer);
-    }
 }
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioPlayer.kt b/vlc-android/src/org/videolan/vlc/gui/audio/AudioPlayer.kt
index 723b5f5f6f..9b87179542 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioPlayer.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioPlayer.kt
@@ -176,11 +176,11 @@ class AudioPlayer : Fragment(), PlaylistAdapter.IPlayer, TextWatcher {
         }
     }
 
-    override fun onPopupMenu(anchor: View, position: Int, media: MediaWrapper) {
+    override fun onPopupMenu(view: View, position: Int, item: MediaWrapper?) {
         val activity = activity
         if (activity === null || position >= playlistAdapter.itemCount) return
         val flags = CTX_REMOVE_FROM_PLAYLIST or CTX_SET_RINGTONE or CTX_ADD_TO_PLAYLIST or CTX_STOP_AFTER_THIS
-        showContext(activity, ctxReceiver, position, media.title, flags)
+        showContext(activity, ctxReceiver, position, item?.title ?: "", flags)
     }
 
     private fun doUpdate() {
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java
deleted file mode 100644
index a9d0b15af9..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * *************************************************************************
- *  BaseAudioBrowser.java
- * **************************************************************************
- *  Copyright © 2016-2017 VLC authors and VideoLAN
- *  Author: Geoffrey Métais
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *  ***************************************************************************
- */
-
-package org.videolan.vlc.gui.audio;
-
-import android.content.Context;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-
-import com.google.android.material.tabs.TabLayout;
-
-import org.jetbrains.annotations.NotNull;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.R;
-import org.videolan.vlc.gui.ContentActivity;
-import org.videolan.vlc.gui.browser.MediaBrowserFragment;
-import org.videolan.vlc.gui.dialogs.ContextSheetKt;
-import org.videolan.vlc.gui.dialogs.CtxActionReceiver;
-import org.videolan.vlc.gui.dialogs.SavePlaylistDialog;
-import org.videolan.vlc.gui.helpers.AudioUtil;
-import org.videolan.vlc.gui.helpers.UiTools;
-import org.videolan.vlc.interfaces.IEventsHandler;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.media.PlaylistManager;
-import org.videolan.vlc.util.AndroidDevices;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.ModelsHelperKt;
-import org.videolan.vlc.util.WorkersKt;
-import org.videolan.vlc.viewmodels.paged.MLPagedModel;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.appcompat.view.ActionMode;
-import androidx.fragment.app.FragmentActivity;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-import androidx.viewpager.widget.ViewPager;
-
-public abstract class BaseAudioBrowser extends MediaBrowserFragment<MLPagedModel> implements IEventsHandler, CtxActionReceiver, ViewPager.OnPageChangeListener, TabLayout.OnTabSelectedListener {
-
-    ContentActivity mActivity;
-    AudioBrowserAdapter[] mAdapters;
-    protected AudioBrowserAdapter mAdapter;
-    protected TabLayout mTabLayout;
-    protected ViewPager mViewPager;
-
-    private final TabLayout.TabLayoutOnPageChangeListener tcl = new TabLayout.TabLayoutOnPageChangeListener(mTabLayout);
-
-    public AudioBrowserAdapter getCurrentAdapter() {
-        return mAdapter;
-    }
-
-    abstract protected RecyclerView getCurrentRV();
-
-    @Override
-    public void onAttach(Context context) {
-        super.onAttach(context);
-        mActivity = (ContentActivity) context;
-    }
-
-    @Override
-    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        mViewPager = view.findViewById(R.id.pager);
-        mTabLayout = requireActivity().findViewById(R.id.sliding_tabs);
-    }
-
-    private TabLayout.TabLayoutOnPageChangeListener mLayoutOnPageChangeListener;
-    private void setupTabLayout() {
-        if (mTabLayout == null || mViewPager == null) return;
-        mTabLayout.setupWithViewPager(mViewPager);
-        if (mLayoutOnPageChangeListener == null) mLayoutOnPageChangeListener = new TabLayout.TabLayoutOnPageChangeListener(mTabLayout);
-        mViewPager.addOnPageChangeListener(mLayoutOnPageChangeListener);
-        mTabLayout.addOnTabSelectedListener(this);
-        mViewPager.addOnPageChangeListener(this);
-    }
-
-    private void unSetTabLayout() {
-        if (mTabLayout == null || mViewPager == null) return;
-        mViewPager.removeOnPageChangeListener(mLayoutOnPageChangeListener);
-        mTabLayout.removeOnTabSelectedListener(this);
-        mViewPager.removeOnPageChangeListener(this);
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        setupTabLayout();
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        unSetTabLayout();
-    }
-
-    @Override
-    public void onTabSelected(TabLayout.Tab tab) {
-        final FragmentActivity activity = getActivity();
-        if (activity == null) return;
-        activity.invalidateOptionsMenu();
-    }
-
-    @Override
-    public void onTabUnselected(TabLayout.Tab tab) {
-        stopActionMode();
-        mActivity.closeSearchView();
-    }
-
-    @Override
-    public void onTabReselected(TabLayout.Tab tab) {}
-
-    @Override
-    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-        tcl.onPageScrolled(position, positionOffset, positionOffsetPixels);
-    }
-
-    @Override
-    public void onPageScrollStateChanged(int state) {
-        tcl.onPageScrollStateChanged(state);
-    }
-
-    @Override
-    public void onPageSelected(int position) {}
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.ml_menu_last_playlist:
-                MediaUtils.INSTANCE.loadlastPlaylist(getActivity(), Constants.PLAYLIST_TYPE_AUDIO);
-                return true;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-    }
-
-    @Override
-    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
-        mode.getMenuInflater().inflate(R.menu.action_mode_audio_browser, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-        final List<MediaLibraryItem> selection = getCurrentAdapter().getMultiSelectHelper().getSelection();
-        final int count = selection.size();
-        if (count == 0) {
-            stopActionMode();
-            return false;
-        }
-        boolean isSong = count == 1 && selection.get(0).getItemType() == MediaLibraryItem.TYPE_MEDIA;
-        menu.findItem(R.id.action_mode_audio_set_song).setVisible(isSong && AndroidDevices.isPhone);
-        menu.findItem(R.id.action_mode_audio_info).setVisible(count == 1);
-        menu.findItem(R.id.action_mode_audio_append).setVisible(PlaylistManager.Companion.hasMedia());
-        return true;
-    }
-
-    @Override
-    public boolean onActionItemClicked(ActionMode mode, final MenuItem item) {
-        final List<MediaLibraryItem> list = getCurrentAdapter().getMultiSelectHelper().getSelection();
-        stopActionMode();
-        if (!list.isEmpty()) WorkersKt.runIO(new Runnable() {
-            @Override
-            public void run() {
-                final List<MediaWrapper> tracks = new ArrayList<>();
-                for (MediaLibraryItem mediaItem : list)
-                    tracks.addAll(Arrays.asList(mediaItem.getTracks()));
-                WorkersKt.runOnMainThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        switch (item.getItemId()) {
-                            case R.id.action_mode_audio_play:
-                                MediaUtils.INSTANCE.openList(getActivity(), tracks, 0);
-                                break;
-                            case R.id.action_mode_audio_append:
-                                MediaUtils.INSTANCE.appendMedia(getActivity(), tracks);
-                                break;
-                            case R.id.action_mode_audio_add_playlist:
-                                UiTools.addToPlaylist(getActivity(), tracks);
-                                break;
-                            case R.id.action_mode_audio_info:
-                                showInfoDialog(list.get(0));
-                                break;
-                            case R.id.action_mode_audio_set_song:
-                                AudioUtil.setRingtone((MediaWrapper) list.get(0), getActivity());
-                                break;
-                        }
-                    }
-                });
-            }
-        });
-        return true;
-    }
-
-    @Override
-    public void onDestroyActionMode(ActionMode actionMode) {
-        onDestroyActionMode(getCurrentAdapter());
-    }
-
-    void onDestroyActionMode(AudioBrowserAdapter adapter) {
-        setFabPlayVisibility(true);
-        mActionMode = null;
-        adapter.getMultiSelectHelper().clearSelection();
-    }
-
-    @Override
-    protected void sortBy(int sort) {
-        ModelsHelperKt.canSortBy(getViewModel(), sort);
-        super.sortBy(sort);
-    }
-
-    @Override
-    public void onRefresh() {}
-
-    @Override
-    public void onClick(@NonNull View v, int position, @NonNull MediaLibraryItem item) {
-        if (mActionMode != null) {
-            getCurrentAdapter().getMultiSelectHelper().toggleSelection(position);
-            invalidateActionMode();
-        }
-    }
-
-    @Override
-    public boolean onLongClick(View v, int position, @NonNull MediaLibraryItem item) {
-        if (mActionMode != null) return false;
-        getCurrentAdapter().getMultiSelectHelper().toggleSelection(position);
-        startActionMode();
-        return true;
-    }
-
-    @Override
-    public void onImageClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        if (mActionMode != null) {
-            onClick(v, position, item);
-            return;
-        }
-        onLongClick(v, position, item);
-    }
-
-    @Override
-    public void onCtxClick(@NonNull View anchor, final int position, @NonNull MediaLibraryItem item) {
-        final int flags;
-        switch (item.getItemType()) {
-            case MediaLibraryItem.TYPE_MEDIA:
-                flags = Constants.CTX_TRACK_FLAGS;
-                break;
-            case MediaLibraryItem.TYPE_PLAYLIST:
-                flags = Constants.CTX_PLAYLIST_FLAGS;
-                break;
-            default:
-                flags = Constants.CTX_AUDIO_FLAGS;
-        }
-        if (mActionMode == null) ContextSheetKt.showContext(requireActivity(), this, position, item.getTitle(), flags);
-    }
-
-
-    @Override
-    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        MediaUtils.INSTANCE.openList(getActivity(), Arrays.asList(item.getTracks()), 0);
-    }
-
-    @Override
-    public void onUpdateFinished(RecyclerView.Adapter adapter) {
-        UiTools.updateSortTitles(this);
-    }
-
-    @Override
-    public void onItemFocused(@NotNull View v, @NotNull MediaLibraryItem item) {
-
-    }
-
-    @Override
-    public void onCtxAction(int position, int option) {
-        final AudioBrowserAdapter adapter = getCurrentAdapter();
-        if (position >= adapter.getItemCount()) return;
-        final MediaLibraryItem media = adapter.getItem(position);
-        if (media == null) return;
-        switch (option){
-            case Constants.CTX_PLAY:
-                MediaUtils.INSTANCE.playTracks(requireActivity(), media, 0);
-                break;
-            case Constants.CTX_PLAY_ALL:
-                MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), position, false);
-                break;
-            case Constants.CTX_INFORMATION:
-                showInfoDialog(media);
-                break;
-            case Constants.CTX_DELETE:
-                removeItem(media);
-                break;
-            case Constants.CTX_APPEND:
-                MediaUtils.INSTANCE.appendMedia(requireActivity(), media.getTracks());
-                break;
-            case Constants.CTX_PLAY_NEXT:
-                MediaUtils.INSTANCE.insertNext(requireActivity(), media.getTracks());
-                break;
-            case Constants.CTX_ADD_TO_PLAYLIST:
-                UiTools.addToPlaylist(requireActivity(), media.getTracks(), SavePlaylistDialog.KEY_NEW_TRACKS);
-                break;
-            case Constants.CTX_SET_RINGTONE:
-                AudioUtil.setRingtone((MediaWrapper) media, requireActivity());
-                break;
-        }
-    }
-
-    final RecyclerView.OnScrollListener mScrollListener = new RecyclerView.OnScrollListener() {
-        @Override
-        public void onScrollStateChanged(@NonNull RecyclerView recyclerView, int newState) {
-            if (newState != RecyclerView.SCROLL_STATE_IDLE) {
-                mSwipeRefreshLayout.setEnabled(false);
-                return;
-            }
-            final LinearLayoutManager llm = (LinearLayoutManager)getCurrentRV().getLayoutManager();
-            if (llm == null) return;
-            mSwipeRefreshLayout.setEnabled(llm.findFirstVisibleItemPosition() <= 0);
-        }
-
-        @Override
-        public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {}
-    };
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt
new file mode 100644
index 0000000000..d5c51b854f
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.kt
@@ -0,0 +1,265 @@
+/*
+ * *************************************************************************
+ *  BaseAudioBrowser.java
+ * **************************************************************************
+ *  Copyright © 2016-2017 VLC authors and VideoLAN
+ *  Author: Geoffrey Métais
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *  ***************************************************************************
+ */
+
+package org.videolan.vlc.gui.audio
+
+import android.os.Bundle
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import androidx.appcompat.view.ActionMode
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import androidx.viewpager.widget.ViewPager
+import com.google.android.material.tabs.TabLayout
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.ContentActivity
+import org.videolan.vlc.gui.browser.MediaBrowserFragment
+import org.videolan.vlc.gui.dialogs.CtxActionReceiver
+import org.videolan.vlc.gui.dialogs.SavePlaylistDialog
+import org.videolan.vlc.gui.dialogs.showContext
+import org.videolan.vlc.gui.helpers.AudioUtil
+import org.videolan.vlc.gui.helpers.UiTools
+import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.media.PlaylistManager
+import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.paged.MLPagedModel
+import java.util.*
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+abstract class BaseAudioBrowser : MediaBrowserFragment<MLPagedModel<*>>(), IEventsHandler, CtxActionReceiver, ViewPager.OnPageChangeListener, TabLayout.OnTabSelectedListener {
+
+    internal lateinit var adapters: Array<AudioBrowserAdapter>
+
+    private var tabLayout: TabLayout? = null
+    var viewPager: ViewPager? = null
+
+    private val tcl = TabLayout.TabLayoutOnPageChangeListener(tabLayout)
+
+    protected abstract fun getCurrentRV(): RecyclerView
+    protected var currentAdapter: AudioBrowserAdapter? = null
+
+    private lateinit var layoutOnPageChangeListener: TabLayout.TabLayoutOnPageChangeListener
+
+    internal val scrollListener: RecyclerView.OnScrollListener = object : RecyclerView.OnScrollListener() {
+        override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {
+            if (newState != RecyclerView.SCROLL_STATE_IDLE) {
+                mSwipeRefreshLayout.isEnabled = false
+                return
+            }
+            val llm = getCurrentRV().layoutManager as LinearLayoutManager? ?: return
+            mSwipeRefreshLayout.isEnabled = llm.findFirstVisibleItemPosition() <= 0
+        }
+
+        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {}
+    }
+
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+        viewPager = view.findViewById(R.id.pager)
+        tabLayout = requireActivity().findViewById(R.id.sliding_tabs)
+    }
+
+    private fun setupTabLayout() {
+        if (tabLayout == null || viewPager == null) return
+        tabLayout?.setupWithViewPager(viewPager)
+        if (!::layoutOnPageChangeListener.isInitialized) layoutOnPageChangeListener = TabLayout.TabLayoutOnPageChangeListener(tabLayout)
+        viewPager?.addOnPageChangeListener(layoutOnPageChangeListener)
+        tabLayout?.addOnTabSelectedListener(this)
+        viewPager?.addOnPageChangeListener(this)
+    }
+
+    private fun unSetTabLayout() {
+        if (tabLayout != null || viewPager == null) return
+        viewPager?.removeOnPageChangeListener(layoutOnPageChangeListener)
+        tabLayout?.removeOnTabSelectedListener(this)
+        viewPager?.removeOnPageChangeListener(this)
+    }
+
+    override fun onStart() {
+        super.onStart()
+        setupTabLayout()
+    }
+
+    override fun onStop() {
+        super.onStop()
+        unSetTabLayout()
+    }
+
+    override fun onTabSelected(tab: TabLayout.Tab) {
+        val activity = activity ?: return
+        activity.invalidateOptionsMenu()
+    }
+
+    override fun onTabUnselected(tab: TabLayout.Tab) {
+        stopActionMode()
+        (requireActivity() as ContentActivity).closeSearchView()
+    }
+
+    override fun onTabReselected(tab: TabLayout.Tab) {}
+
+    override fun onPageScrolled(position: Int, positionOffset: Float, positionOffsetPixels: Int) {
+        tcl.onPageScrolled(position, positionOffset, positionOffsetPixels)
+    }
+
+    override fun onPageScrollStateChanged(state: Int) {
+        tcl.onPageScrollStateChanged(state)
+    }
+
+    override fun onPageSelected(position: Int) {}
+
+    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
+        return when (item?.itemId) {
+            R.id.ml_menu_last_playlist -> {
+                MediaUtils.loadlastPlaylist(activity, PLAYLIST_TYPE_AUDIO)
+                true
+            }
+            else -> super.onOptionsItemSelected(item)
+        }
+    }
+
+    override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
+        mode.menuInflater.inflate(R.menu.action_mode_audio_browser, menu)
+        return true
+    }
+
+    override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
+        val selection = currentAdapter?.multiSelectHelper?.getSelection()
+        val count = selection?.size
+        if (count == 0) {
+            stopActionMode()
+            return false
+        }
+        val isSong = count == 1 && selection[0].itemType == MediaLibraryItem.TYPE_MEDIA
+        menu.findItem(R.id.action_mode_audio_set_song).isVisible = isSong && AndroidDevices.isPhone
+        menu.findItem(R.id.action_mode_audio_info).isVisible = count == 1
+        menu.findItem(R.id.action_mode_audio_append).isVisible = PlaylistManager.hasMedia()
+        return true
+    }
+
+    override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
+        val list = currentAdapter?.multiSelectHelper?.getSelection()
+        stopActionMode()
+        if (list != null && list.isNotEmpty())
+            runIO(Runnable {
+                val tracks = ArrayList<MediaWrapper>()
+                for (mediaItem in list)
+                    tracks.addAll(Arrays.asList(*mediaItem.tracks))
+                runOnMainThread(Runnable {
+                    when (item.itemId) {
+                        R.id.action_mode_audio_play -> MediaUtils.openList(activity, tracks, 0)
+                        R.id.action_mode_audio_append -> MediaUtils.appendMedia(activity, tracks)
+                        R.id.action_mode_audio_add_playlist -> UiTools.addToPlaylist(activity, tracks)
+                        R.id.action_mode_audio_info -> showInfoDialog(list[0])
+                        R.id.action_mode_audio_set_song -> AudioUtil.setRingtone(list[0] as MediaWrapper, activity)
+                    }
+                })
+            })
+        return true
+    }
+
+    override fun onDestroyActionMode(actionMode: ActionMode) {
+        onDestroyActionMode(currentAdapter)
+    }
+
+    internal fun onDestroyActionMode(adapter: AudioBrowserAdapter?) {
+        setFabPlayVisibility(true)
+        mActionMode = null
+        adapter?.multiSelectHelper?.clearSelection()
+    }
+
+    override fun sortBy(sort: Int) {
+        getViewModel().canSortBy(sort)
+        super.sortBy(sort)
+    }
+
+    override fun onRefresh() {}
+
+    override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
+        if (mActionMode != null) {
+            currentAdapter?.multiSelectHelper?.toggleSelection(position)
+            invalidateActionMode()
+        }
+    }
+
+    override fun onLongClick(v: View, position: Int, item: MediaLibraryItem): Boolean {
+        if (mActionMode != null) return false
+        currentAdapter?.multiSelectHelper?.toggleSelection(position)
+        startActionMode()
+        return true
+    }
+
+    override fun onImageClick(v: View, position: Int, item: MediaLibraryItem) {
+        if (mActionMode != null) {
+            onClick(v, position, item)
+            return
+        }
+        onLongClick(v, position, item)
+    }
+
+    override fun onCtxClick(v: View, position: Int, item: MediaLibraryItem) {
+        val flags: Int = when (item.itemType) {
+            MediaLibraryItem.TYPE_MEDIA -> CTX_TRACK_FLAGS
+            MediaLibraryItem.TYPE_PLAYLIST -> CTX_PLAYLIST_FLAGS
+            else -> CTX_AUDIO_FLAGS
+        }
+        if (mActionMode == null) showContext(requireActivity(), this, position, item.title, flags)
+    }
+
+
+    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {
+        MediaUtils.openList(activity, Arrays.asList(*item.tracks), 0)
+    }
+
+    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
+        UiTools.updateSortTitles(this)
+    }
+
+    override fun onItemFocused(v: View, item: MediaLibraryItem) {
+
+    }
+
+    override fun onCtxAction(position: Int, option: Int) {
+        val adapter = currentAdapter
+        if (position >= adapter?.itemCount ?: 0) return
+        val media = adapter?.getItem(position) ?: return
+        when (option) {
+            CTX_PLAY -> MediaUtils.playTracks(requireActivity(), media, 0)
+            CTX_PLAY_ALL -> MediaUtils.playAll(requireContext(), getViewModel() as MLPagedModel<MediaWrapper>, position, false)
+            CTX_INFORMATION -> showInfoDialog(media)
+            CTX_DELETE -> removeItem(media)
+            CTX_APPEND -> MediaUtils.appendMedia(requireActivity(), media.tracks)
+            CTX_PLAY_NEXT -> MediaUtils.insertNext(requireActivity(), media.tracks)
+            CTX_ADD_TO_PLAYLIST -> UiTools.addToPlaylist(requireActivity(), media.tracks, SavePlaylistDialog.KEY_NEW_TRACKS)
+            CTX_SET_RINGTONE -> AudioUtil.setRingtone(media as MediaWrapper, requireActivity())
+        }
+    }
+
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/EqualizerFragment.java b/vlc-android/src/org/videolan/vlc/gui/audio/EqualizerFragment.java
deleted file mode 100644
index ed27767add..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/audio/EqualizerFragment.java
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- *****************************************************************************
- * EqualizerFragment.java
- *****************************************************************************
- * Copyright © 2013-2019 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-package org.videolan.vlc.gui.audio;
-
-import android.content.Context;
-import android.content.DialogInterface;
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewGroup.LayoutParams;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemSelectedListener;
-import android.widget.ArrayAdapter;
-import android.widget.Button;
-import android.widget.CompoundButton;
-import android.widget.CompoundButton.OnCheckedChangeListener;
-import android.widget.EditText;
-import android.widget.LinearLayout;
-import android.widget.SeekBar;
-import android.widget.SeekBar.OnSeekBarChangeListener;
-import android.widget.Toast;
-
-import org.videolan.libvlc.MediaPlayer;
-import org.videolan.vlc.PlaybackService;
-import org.videolan.vlc.R;
-import org.videolan.vlc.VLCApplication;
-import org.videolan.vlc.databinding.EqualizerBinding;
-import org.videolan.vlc.gui.helpers.UiTools;
-import org.videolan.vlc.gui.view.EqualizerBar;
-import org.videolan.vlc.interfaces.OnEqualizerBarChangeListener;
-import org.videolan.vlc.util.Settings;
-import org.videolan.vlc.util.VLCOptions;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.appcompat.app.AlertDialog;
-import androidx.appcompat.app.AppCompatDialogFragment;
-import androidx.databinding.DataBindingUtil;
-import androidx.databinding.ObservableInt;
-
-public class EqualizerFragment extends AppCompatDialogFragment {
-
-    public final static String TAG = "VLC/EqualizerFragment";
-
-    private MediaPlayer.Equalizer mEqualizer = null;
-    private static final int BAND_COUNT = MediaPlayer.Equalizer.getBandCount();
-    private int customCount = 0;
-    private int presetCount = 0;
-    private List<String> allSets = new ArrayList<>();
-    private ArrayAdapter<String> adapter;
-    private Context context;
-    private int revertPos = 0;
-    private int savePos = 0;
-    private boolean updateAlreadyHandled = false;
-    private EqualizerBinding binding;
-    final private EqualizerState mState = new EqualizerState();
-    private final String newPresetName = VLCApplication.getAppResources().getString(R.string.equalizer_new_preset_name);
-
-    private final static int TYPE_PRESET = 0;
-    private final static int TYPE_CUSTOM = 1;
-    private final static int TYPE_NEW = 2;
-
-    @Override
-    public void onCreate(@Nullable Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-    }
-
-    @Override
-    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        super.onCreateView(inflater, container, savedInstanceState);
-        binding = DataBindingUtil.inflate(inflater, R.layout.equalizer, container, false);
-        binding.setState(mState);
-        return binding.getRoot();
-    }
-
-    private void fillViews() {
-        context = getActivity();
-        final String[] presets = getEqualizerPresets();
-
-        if (context == null || presets == null) return;
-
-        allSets.clear();
-        allSets = new ArrayList<>();
-        allSets.addAll(Arrays.asList(presets));
-        presetCount = allSets.size();
-        for (Map.Entry<String, ?> entry : Settings.INSTANCE.getInstance(context).getAll().entrySet()) {
-            if (entry.getKey().startsWith("custom_equalizer_")) {
-                allSets.add(entry.getKey().replace("custom_equalizer_", "").replace("_", " "));
-                customCount++;
-            }
-        }
-        allSets.add(newPresetName);
-
-        mEqualizer = VLCOptions.getEqualizerSetFromSettings(context, true);
-
-        // on/off
-        binding.equalizerButton.setChecked(VLCOptions.getEqualizerEnabledState(context));
-        binding.equalizerButton.setOnCheckedChangeListener(new OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-                PlaybackService.Companion.getEqualizer().setValue(isChecked ? mEqualizer : null);
-            }
-        });
-        binding.equalizerSave.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                createSaveCustomSetDialog(binding.equalizerPresets.getSelectedItemPosition(), true, false);
-            }
-        });
-        binding.equalizerDelete.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                createDeleteCustomSetSnacker();
-            }
-        });
-        binding.equalizerRevert.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                revertCustomSetChanges();
-            }
-        });
-
-        // presets
-        adapter = new ArrayAdapter<>(context, android.R.layout.simple_spinner_dropdown_item, allSets);
-        binding.equalizerPresets.setAdapter(adapter);
-
-        // Set the default selection asynchronously to prevent a layout initialization bug.
-        binding.equalizerPresets.post(new Runnable() {
-            @Override
-            public void run() {
-                binding.equalizerPresets.setOnItemSelectedListener(mSetListener);
-                final int pos = allSets.indexOf(VLCOptions.getEqualizerNameFromSettings(context));
-                mState.update(pos, VLCOptions.getEqualizerSavedState(context));
-                updateAlreadyHandled = true;
-                if (binding.equalizerButton.isChecked() || !mState.saved) {
-                    savePos = pos;
-                    revertPos = getEqualizerType(pos) == TYPE_CUSTOM ? pos : 0;
-                    binding.equalizerPresets.setSelection(pos);
-                } else {
-                    updateEqualizer(0);
-                }
-
-            }
-        });
-
-        // preamp
-        binding.equalizerPreamp.setMax(40);
-        binding.equalizerPreamp.setProgress((int) mEqualizer.getPreAmp() + 20);
-        binding.equalizerPreamp.setOnSeekBarChangeListener(mPreampListener);
-
-        // bands
-        for (int i = 0; i < BAND_COUNT; i++) {
-            float band = MediaPlayer.Equalizer.getBandFrequency(i);
-
-            EqualizerBar bar = new EqualizerBar(context, band);
-            bar.setValue(mEqualizer.getAmp(i));
-            bar.setListener(new BandListener(i));
-
-            binding.equalizerBands.addView(bar);
-            LinearLayout.LayoutParams params =
-                    new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT,
-                                                  LayoutParams.MATCH_PARENT, 1);
-            bar.setLayoutParams(params);
-        }
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        fillViews();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        binding.equalizerButton.setOnCheckedChangeListener(null);
-        binding.equalizerPresets.setOnItemSelectedListener(null);
-        binding.equalizerPreamp.setOnSeekBarChangeListener(null);
-        binding.equalizerBands.removeAllViews();
-        if (binding.equalizerButton.isChecked()) {
-            int pos = binding.equalizerPresets.getSelectedItemPosition();
-            VLCOptions.saveEqualizerInSettings(context, mEqualizer, allSets.get(pos), true, mState.saved);
-        } else {
-            VLCOptions.saveEqualizerInSettings(context, MediaPlayer.Equalizer.createFromPreset(0), allSets.get(0), false, true);
-        }
-        if (!mState.saved)
-            createSaveCustomSetDialog(binding.equalizerPresets.getSelectedItemPosition(), false, true);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        PlaybackService.Companion.getEqualizer().clear();
-    }
-
-    private final OnItemSelectedListener mSetListener = new OnItemSelectedListener() {
-        @Override
-        public void onItemSelected(AdapterView<?> parent, View view, int pos, long id) {
-            if (!binding.equalizerButton.isChecked() && !updateAlreadyHandled)
-                binding.equalizerButton.setChecked(true);
-
-            //save set if changes made (needs old currentPosition)
-            if (savePos >= 0 && !mState.saved && !updateAlreadyHandled)
-                createSaveCustomSetDialog(savePos, false, false);
-            updateEqualizer(pos);
-        }
-
-        @Override
-        public void onNothingSelected(AdapterView<?> parent) {}
-    };
-
-    private final OnSeekBarChangeListener mPreampListener = new OnSeekBarChangeListener() {
-        @Override
-        public void onStopTrackingTouch(SeekBar seekBar) {}
-
-        @Override
-        public void onStartTrackingTouch(SeekBar seekBar) {}
-
-        @Override
-        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-            if (!fromUser) return;
-            mEqualizer.setPreAmp(progress - 20);
-            if (!binding.equalizerButton.isChecked()) binding.equalizerButton.setChecked(true);
-
-            int pos = binding.equalizerPresets.getSelectedItemPosition();
-            if (getEqualizerType(pos) == TYPE_PRESET) {
-                revertPos = pos;
-                savePos = presetCount + customCount;
-                mState.update(presetCount + customCount, false);
-                updateAlreadyHandled = true;
-                binding.equalizerPresets.setSelection(presetCount + customCount);
-            } else if (getEqualizerType(pos) == TYPE_CUSTOM) {
-                revertPos = pos;
-                savePos = pos;
-                mState.update(pos, false);
-            }
-            if (binding.equalizerButton.isChecked()) PlaybackService.Companion.getEqualizer().setValue(mEqualizer);
-        }
-    };
-
-    private class BandListener implements OnEqualizerBarChangeListener {
-        private int index;
-
-        BandListener(int index) {
-            this.index = index;
-        }
-
-        @Override
-        public void onProgressChanged(float value, boolean fromUser) {
-            if (!fromUser)
-                return;
-            mEqualizer.setAmp(index, value);
-            if (!binding.equalizerButton.isChecked())
-                binding.equalizerButton.setChecked(true);
-
-            int pos = binding.equalizerPresets.getSelectedItemPosition();
-            if (getEqualizerType(pos) == TYPE_PRESET) {
-                revertPos = pos;
-                savePos = presetCount + customCount;
-                mState.update(presetCount + customCount, false);
-                updateAlreadyHandled = true;
-                binding.equalizerPresets.setSelection(presetCount + customCount);
-            } else if (getEqualizerType(pos) == TYPE_CUSTOM) {
-                revertPos = pos;
-                savePos = pos;
-                mState.update(pos, false);
-            }
-
-            if (binding.equalizerButton.isChecked()) PlaybackService.Companion.getEqualizer().setValue(mEqualizer);
-        }
-    }
-
-    private static String[] getEqualizerPresets() {
-        final int count = MediaPlayer.Equalizer.getPresetCount();
-        if (count <= 0) return null;
-        final String [] presets = new String[count];
-        for (int i = 0; i < count; ++i) {
-            presets[i] = MediaPlayer.Equalizer.getPresetName(i);
-        }
-        return presets;
-    }
-
-    private void createSaveCustomSetDialog(final int positionToSave, final boolean displayedByUser, final boolean onPause) {
-        final String oldName = allSets.get(positionToSave);
-
-        final MediaPlayer.Equalizer temporarySet = MediaPlayer.Equalizer.create();
-        temporarySet.setPreAmp(mEqualizer.getPreAmp());
-        for (int i=0; i< MediaPlayer.Equalizer.getBandCount(); i++)
-            temporarySet.setAmp(i, mEqualizer.getAmp(i));
-
-        final EditText input = new EditText(context);
-        input.setText(oldName);
-        input.setSelectAllOnFocus(true);
-
-        final AlertDialog saveEqualizer = new AlertDialog.Builder(context)
-                .setTitle(getResources().getString(displayedByUser
-                        ? R.string.custom_set_save_title
-                        : R.string.custom_set_save_warning))
-                .setMessage(getResources().getString((getEqualizerType(positionToSave) == TYPE_CUSTOM)
-                        ? R.string.existing_custom_set_save_message
-                        : R.string.new_custom_set_save_message))
-                .setView(input)
-                .setPositiveButton(R.string.save, null)
-                .setNegativeButton(R.string.do_not_save, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialogInterface, int i) {
-                        if (onPause)
-                            VLCOptions.saveEqualizerInSettings(context, mEqualizer, allSets.get(positionToSave), binding.equalizerButton.isChecked(), false);
-                    }
-                })
-                .setOnCancelListener(new DialogInterface.OnCancelListener() {
-                    @Override
-                    public void onCancel(DialogInterface dialogInterface) {
-                        if (onPause)
-                            VLCOptions.saveEqualizerInSettings(context, mEqualizer, allSets.get(positionToSave), binding.equalizerButton.isChecked(), false);
-                    }
-                })
-                .create();
-        final Window window = saveEqualizer.getWindow();
-        if (window != null) window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
-
-        //HACK to prevent closure
-        saveEqualizer.setOnShowListener(new DialogInterface.OnShowListener() {
-            @Override
-            public void onShow(DialogInterface dialog) {
-                final Button positiveButton = ((AlertDialog) dialog).getButton(AlertDialog.BUTTON_POSITIVE);
-                positiveButton.setOnClickListener(new View.OnClickListener() {
-                    @Override
-                    public void onClick(View view) {
-                        final String newName = input.getText().toString();
-                        if (newName.contains("_") || TextUtils.equals(newName, newPresetName)) {
-                            Toast.makeText(context, VLCApplication.getAppContext().getResources().getString(R.string.custom_set_wrong_input), Toast.LENGTH_SHORT).show();
-                        } else if (allSets.contains(newName) && !TextUtils.equals(newName,oldName)) {
-                            Toast.makeText(context, VLCApplication.getAppContext().getResources().getString(R.string.custom_set_already_exist), Toast.LENGTH_SHORT).show();
-                        } else {
-                            VLCOptions.saveCustomSet(context, temporarySet, newName);
-                            if (onPause) {
-                                if (binding.equalizerButton.isChecked())
-                                    VLCOptions.saveEqualizerInSettings(context, temporarySet, newName, true, true);
-                            } else {
-                                if (TextUtils.equals(newName,oldName)) {
-                                    if (displayedByUser) {
-                                        mState.update(allSets.indexOf(newName), true);
-                                    }
-                                } else {
-                                    //insert new item before the one being saved in order to keep position
-                                    allSets.add(positionToSave, newName);
-                                    customCount++;
-                                    if (displayedByUser) {
-                                        adapter.notifyDataSetChanged();
-                                        mState.update(allSets.indexOf(newName), true);
-                                        updateAlreadyHandled = true;
-                                    }
-                                }
-                            }
-                            saveEqualizer.dismiss();
-                        }
-                    }
-                });
-            }
-        });
-        saveEqualizer.show();
-    }
-
-    private void createDeleteCustomSetSnacker() {
-        final int oldPos = binding.equalizerPresets.getSelectedItemPosition();
-        final String oldName = allSets.get(oldPos);
-        if (getEqualizerType(oldPos) == TYPE_CUSTOM) {
-
-            final MediaPlayer.Equalizer savedEqualizerSet = VLCOptions.getCustomSet(context, oldName);
-            if (savedEqualizerSet == null) return;
-            Runnable cancelAction = new Runnable() {
-                @Override
-                public void run() {
-                    VLCOptions.saveCustomSet(context, savedEqualizerSet, oldName);
-                    mEqualizer = savedEqualizerSet;
-                    allSets.add(oldPos, oldName);
-                    customCount++;
-                    binding.equalizerPresets.setSelection(oldPos);
-                }
-            };
-
-            VLCOptions.deleteCustomSet(context, oldName);
-            allSets.remove(oldName);
-            customCount--;
-            mState.update(0, true);
-            binding.equalizerPresets.setSelection(0);
-            String message = context.getString(R.string.custom_set_deleted_message, oldName);
-            UiTools.snackerWithCancel(binding.getRoot(), message, null, cancelAction);
-        }
-    }
-
-    private void revertCustomSetChanges() {
-        final int pos = binding.equalizerPresets.getSelectedItemPosition();
-
-        final MediaPlayer.Equalizer temporarySet = MediaPlayer.Equalizer.create();
-        temporarySet.setPreAmp(mEqualizer.getPreAmp());
-        for (int i=0; i< MediaPlayer.Equalizer.getBandCount(); i++)
-            temporarySet.setAmp(i, mEqualizer.getAmp(i));
-
-        final Runnable cancelAction = new Runnable() {
-            @Override
-            public void run() {
-                mState.update(pos, false);
-                mEqualizer = temporarySet;
-                updateAlreadyHandled = true;
-                if (pos == revertPos)
-                    updateEqualizer(pos);
-                else
-                    binding.equalizerPresets.setSelection(pos);
-            }
-        };
-        mState.update(revertPos, true);
-        if (pos == revertPos)
-            updateEqualizer(revertPos);
-        else
-            binding.equalizerPresets.setSelection(revertPos);
-
-        String message = getEqualizerType(pos) == TYPE_CUSTOM
-                ? context.getString(R.string.custom_set_restored)
-                : context.getString(R.string.unsaved_set_deleted_message);
-        UiTools.snackerWithCancel(binding.getRoot(), message, null, cancelAction);
-    }
-
-    private void updateEqualizer(int pos) {
-        if (updateAlreadyHandled) {
-            updateAlreadyHandled = false;
-        } else {
-            if (getEqualizerType(pos) == TYPE_PRESET) {
-                mEqualizer = MediaPlayer.Equalizer.createFromPreset(pos);
-                mState.update(pos, true);
-            } else if (getEqualizerType(pos) == TYPE_CUSTOM) {
-                mEqualizer = VLCOptions.getCustomSet(context, allSets.get(pos));
-                mState.update(pos, true);
-            } else if (getEqualizerType(pos) == TYPE_NEW) {
-                mEqualizer = MediaPlayer.Equalizer.create();
-                mState.update(pos, false);
-            }
-        }
-
-        binding.equalizerPreamp.setProgress((int) mEqualizer.getPreAmp() + 20);
-        for (int i = 0; i < BAND_COUNT; ++i) {
-            EqualizerBar bar = (EqualizerBar) binding.equalizerBands.getChildAt(i);
-            if (bar != null)
-                bar.setValue(mEqualizer.getAmp(i));
-        }
-        if (binding.equalizerButton.isChecked()) PlaybackService.Companion.getEqualizer().setValue(mEqualizer);
-    }
-
-    private int getEqualizerType(int position) {
-        if (position < 0) return -1;
-        if (position < presetCount) return TYPE_PRESET;
-        if (position < presetCount + customCount) return TYPE_CUSTOM;
-        return TYPE_NEW;
-    }
-
-    public class EqualizerState {
-
-        boolean saved = true;
-        public ObservableInt saveButtonVisibility = new ObservableInt(View.INVISIBLE);
-        public ObservableInt revertButtonVisibility = new ObservableInt(View.INVISIBLE);
-        public ObservableInt deleteButtonVisibility = new ObservableInt(View.INVISIBLE);
-
-        public void update(int newPos, boolean newSaved) {
-            saved = newSaved;
-            saveButtonVisibility.set(newSaved ? View.INVISIBLE : View.VISIBLE);
-            revertButtonVisibility.set(newSaved ? View.INVISIBLE : View.VISIBLE);
-            deleteButtonVisibility.set(newSaved && getEqualizerType(newPos) == TYPE_CUSTOM ? View.VISIBLE : View.INVISIBLE);
-        }
-    }
-}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/EqualizerFragment.kt b/vlc-android/src/org/videolan/vlc/gui/audio/EqualizerFragment.kt
new file mode 100644
index 0000000000..3e64bd880c
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/EqualizerFragment.kt
@@ -0,0 +1,427 @@
+/*
+ *****************************************************************************
+ * EqualizerFragment.java
+ *****************************************************************************
+ * Copyright © 2013-2019 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+package org.videolan.vlc.gui.audio
+
+import android.os.Bundle
+import android.text.TextUtils
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.view.ViewGroup.LayoutParams
+import android.view.WindowManager
+import android.widget.*
+import android.widget.AdapterView.OnItemSelectedListener
+import android.widget.SeekBar.OnSeekBarChangeListener
+import androidx.appcompat.app.AlertDialog
+import androidx.appcompat.app.AppCompatDialogFragment
+import androidx.databinding.DataBindingUtil
+import androidx.databinding.ObservableInt
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.MediaPlayer
+import org.videolan.vlc.PlaybackService
+import org.videolan.vlc.R
+import org.videolan.vlc.VLCApplication
+import org.videolan.vlc.databinding.EqualizerBinding
+import org.videolan.vlc.gui.helpers.UiTools
+import org.videolan.vlc.gui.view.EqualizerBar
+import org.videolan.vlc.interfaces.OnEqualizerBarChangeListener
+import org.videolan.vlc.util.Settings
+import org.videolan.vlc.util.VLCOptions
+import java.util.*
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class EqualizerFragment : AppCompatDialogFragment() {
+
+    private lateinit var mEqualizer: MediaPlayer.Equalizer
+    private var customCount = 0
+    private var presetCount = 0
+    private var allSets: MutableList<String> = ArrayList()
+    private lateinit var adapter: ArrayAdapter<String>
+    private var revertPos = 0
+    private var savePos = 0
+    private var updateAlreadyHandled = false
+    private lateinit var binding: EqualizerBinding
+    private val state = EqualizerState()
+    private val newPresetName = VLCApplication.getAppResources().getString(R.string.equalizer_new_preset_name)
+
+    private val mSetListener = object : OnItemSelectedListener {
+        override fun onItemSelected(parent: AdapterView<*>, view: View, pos: Int, id: Long) {
+            if (!binding.equalizerButton.isChecked && !updateAlreadyHandled)
+                binding.equalizerButton.isChecked = true
+
+            //save set if changes made (needs old currentPosition)
+            if (savePos >= 0 && !state.saved && !updateAlreadyHandled)
+                createSaveCustomSetDialog(savePos, displayedByUser = false, onPause = false)
+            updateEqualizer(pos)
+        }
+
+        override fun onNothingSelected(parent: AdapterView<*>) {}
+    }
+
+    private val mPreampListener = object : OnSeekBarChangeListener {
+        override fun onStopTrackingTouch(seekBar: SeekBar) {}
+
+        override fun onStartTrackingTouch(seekBar: SeekBar) {}
+
+        override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) {
+            if (!fromUser) return
+            mEqualizer.preAmp = (progress - 20).toFloat()
+            if (!binding.equalizerButton.isChecked) binding.equalizerButton.isChecked = true
+
+            val pos = binding.equalizerPresets.selectedItemPosition
+            if (getEqualizerType(pos) == TYPE_PRESET) {
+                revertPos = pos
+                savePos = presetCount + customCount
+                state.update(presetCount + customCount, false)
+                updateAlreadyHandled = true
+                binding.equalizerPresets.setSelection(presetCount + customCount)
+            } else if (getEqualizerType(pos) == TYPE_CUSTOM) {
+                revertPos = pos
+                savePos = pos
+                state.update(pos, false)
+            }
+            if (binding.equalizerButton.isChecked) PlaybackService.equalizer.value = mEqualizer
+        }
+    }
+
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        super.onCreateView(inflater, container, savedInstanceState)
+        binding = DataBindingUtil.inflate(inflater, R.layout.equalizer, container, false)
+        binding.state = state
+        return binding.root
+    }
+
+    private fun fillViews() {
+        val presets = equalizerPresets
+
+        if (context == null || presets == null) return
+
+        allSets.clear()
+        allSets = ArrayList()
+        allSets.addAll(Arrays.asList(*presets))
+        presetCount = allSets.size
+        for ((key) in Settings.getInstance(requireActivity()).all) {
+            if (key.startsWith("custom_equalizer_")) {
+                allSets.add(key.replace("custom_equalizer_", "").replace("_", " "))
+                customCount++
+            }
+        }
+        allSets.add(newPresetName)
+
+        mEqualizer = VLCOptions.getEqualizerSetFromSettings(context, true)
+
+        // on/off
+        binding.equalizerButton.isChecked = VLCOptions.getEqualizerEnabledState(context)
+        binding.equalizerButton.setOnCheckedChangeListener { _, isChecked -> PlaybackService.equalizer.setValue(if (isChecked) mEqualizer else null) }
+        binding.equalizerSave.setOnClickListener { createSaveCustomSetDialog(binding.equalizerPresets.selectedItemPosition, displayedByUser = true, onPause = false) }
+        binding.equalizerDelete.setOnClickListener { createDeleteCustomSetSnacker() }
+        binding.equalizerRevert.setOnClickListener { revertCustomSetChanges() }
+
+        // presets
+        adapter = ArrayAdapter(requireContext(), android.R.layout.simple_spinner_dropdown_item, allSets)
+        binding.equalizerPresets.adapter = adapter
+
+        // Set the default selection asynchronously to prevent a layout initialization bug.
+        binding.equalizerPresets.post {
+            binding.equalizerPresets.onItemSelectedListener = mSetListener
+            val pos = allSets.indexOf(VLCOptions.getEqualizerNameFromSettings(context))
+            state.update(pos, VLCOptions.getEqualizerSavedState(context))
+            updateAlreadyHandled = true
+            if (binding.equalizerButton.isChecked || !state.saved) {
+                savePos = pos
+                revertPos = if (getEqualizerType(pos) == TYPE_CUSTOM) pos else 0
+                binding.equalizerPresets.setSelection(pos)
+            } else {
+                updateEqualizer(0)
+            }
+        }
+
+        // preamp
+        binding.equalizerPreamp.max = 40
+        binding.equalizerPreamp.progress = mEqualizer.preAmp.toInt() + 20
+        binding.equalizerPreamp.setOnSeekBarChangeListener(mPreampListener)
+
+        // bands
+        for (i in 0 until BAND_COUNT) {
+            val band = MediaPlayer.Equalizer.getBandFrequency(i)
+
+            val bar = EqualizerBar(context, band)
+            bar.setValue(mEqualizer.getAmp(i))
+            bar.setListener(BandListener(i))
+
+            binding.equalizerBands.addView(bar)
+            val params = LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT,
+                    LayoutParams.MATCH_PARENT, 1f)
+            bar.layoutParams = params
+        }
+    }
+
+    override fun onResume() {
+        super.onResume()
+        fillViews()
+    }
+
+    override fun onPause() {
+        super.onPause()
+        binding.equalizerButton.setOnCheckedChangeListener(null)
+        binding.equalizerPresets.onItemSelectedListener = null
+        binding.equalizerPreamp.setOnSeekBarChangeListener(null)
+        binding.equalizerBands.removeAllViews()
+        if (binding.equalizerButton.isChecked) {
+            val pos = binding.equalizerPresets.selectedItemPosition
+            VLCOptions.saveEqualizerInSettings(context, mEqualizer, allSets[pos], true, state.saved)
+        } else {
+            VLCOptions.saveEqualizerInSettings(context, MediaPlayer.Equalizer.createFromPreset(0), allSets[0], false, true)
+        }
+        if (!state.saved)
+            createSaveCustomSetDialog(binding.equalizerPresets.selectedItemPosition, displayedByUser = false, onPause = true)
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        PlaybackService.equalizer.clear()
+    }
+
+    private inner class BandListener internal constructor(private val index: Int) : OnEqualizerBarChangeListener {
+
+        override fun onProgressChanged(value: Float, fromUser: Boolean) {
+            if (!fromUser)
+                return
+            mEqualizer.setAmp(index, value)
+            if (!binding.equalizerButton.isChecked)
+                binding.equalizerButton.isChecked = true
+
+            val pos = binding.equalizerPresets.selectedItemPosition
+            if (getEqualizerType(pos) == TYPE_PRESET) {
+                revertPos = pos
+                savePos = presetCount + customCount
+                state.update(presetCount + customCount, false)
+                updateAlreadyHandled = true
+                binding.equalizerPresets.setSelection(presetCount + customCount)
+            } else if (getEqualizerType(pos) == TYPE_CUSTOM) {
+                revertPos = pos
+                savePos = pos
+                state.update(pos, false)
+            }
+
+            if (binding.equalizerButton.isChecked) PlaybackService.equalizer.value = mEqualizer
+        }
+    }
+
+    private fun createSaveCustomSetDialog(positionToSave: Int, displayedByUser: Boolean, onPause: Boolean) {
+        val oldName = allSets[positionToSave]
+
+        val temporarySet = MediaPlayer.Equalizer.create()
+        temporarySet.preAmp = mEqualizer.preAmp
+        for (i in 0 until MediaPlayer.Equalizer.getBandCount())
+            temporarySet.setAmp(i, mEqualizer.getAmp(i))
+
+        val input = EditText(context)
+        input.setText(oldName)
+        input.setSelectAllOnFocus(true)
+
+        val saveEqualizer = AlertDialog.Builder(requireActivity())
+                .setTitle(resources.getString(if (displayedByUser)
+                    R.string.custom_set_save_title
+                else
+                    R.string.custom_set_save_warning))
+                .setMessage(resources.getString(if (getEqualizerType(positionToSave) == TYPE_CUSTOM)
+                    R.string.existing_custom_set_save_message
+                else
+                    R.string.new_custom_set_save_message))
+                .setView(input)
+                .setPositiveButton(R.string.save, null)
+                .setNegativeButton(R.string.do_not_save) { _, _ ->
+                    if (onPause)
+                        VLCOptions.saveEqualizerInSettings(context, mEqualizer, allSets[positionToSave], binding.equalizerButton.isChecked, false)
+                }
+                .setOnCancelListener {
+                    if (onPause)
+                        VLCOptions.saveEqualizerInSettings(context, mEqualizer, allSets[positionToSave], binding.equalizerButton.isChecked, false)
+                }
+                .create()
+        val window = saveEqualizer.window
+        window?.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE)
+
+        //HACK to prevent closure
+        saveEqualizer.setOnShowListener { dialog ->
+            val positiveButton = (dialog as AlertDialog).getButton(AlertDialog.BUTTON_POSITIVE)
+            positiveButton.setOnClickListener {
+                val newName = input.text.toString()
+                if (newName.contains("_") || TextUtils.equals(newName, newPresetName)) {
+                    Toast.makeText(context, VLCApplication.getAppContext().resources.getString(R.string.custom_set_wrong_input), Toast.LENGTH_SHORT).show()
+                } else if (allSets.contains(newName) && !TextUtils.equals(newName, oldName)) {
+                    Toast.makeText(context, VLCApplication.getAppContext().resources.getString(R.string.custom_set_already_exist), Toast.LENGTH_SHORT).show()
+                } else {
+                    VLCOptions.saveCustomSet(context, temporarySet, newName)
+                    if (onPause) {
+                        if (binding.equalizerButton.isChecked)
+                            VLCOptions.saveEqualizerInSettings(context, temporarySet, newName, true, true)
+                    } else {
+                        if (TextUtils.equals(newName, oldName)) {
+                            if (displayedByUser) {
+                                state.update(allSets.indexOf(newName), true)
+                            }
+                        } else {
+                            //insert new item before the one being saved in order to keep position
+                            allSets.add(positionToSave, newName)
+                            customCount++
+                            if (displayedByUser) {
+                                adapter.notifyDataSetChanged()
+                                state.update(allSets.indexOf(newName), true)
+                                updateAlreadyHandled = true
+                            }
+                        }
+                    }
+                    saveEqualizer.dismiss()
+                }
+            }
+        }
+        saveEqualizer.show()
+    }
+
+    private fun createDeleteCustomSetSnacker() {
+        val oldPos = binding.equalizerPresets.selectedItemPosition
+        val oldName = allSets[oldPos]
+        if (getEqualizerType(oldPos) == TYPE_CUSTOM) {
+
+            val savedEqualizerSet = VLCOptions.getCustomSet(context, oldName) ?: return
+            val cancelAction = Runnable {
+                VLCOptions.saveCustomSet(context, savedEqualizerSet, oldName)
+                mEqualizer = savedEqualizerSet
+                allSets.add(oldPos, oldName)
+                customCount++
+                binding.equalizerPresets.setSelection(oldPos)
+            }
+
+            VLCOptions.deleteCustomSet(context, oldName)
+            allSets.remove(oldName)
+            customCount--
+            state.update(0, true)
+            binding.equalizerPresets.setSelection(0)
+            val message = getString(R.string.custom_set_deleted_message, oldName)
+            UiTools.snackerWithCancel(binding.root, message, null, cancelAction)
+        }
+    }
+
+    private fun revertCustomSetChanges() {
+        val pos = binding.equalizerPresets.selectedItemPosition
+
+        val temporarySet = MediaPlayer.Equalizer.create()
+        temporarySet.preAmp = mEqualizer.preAmp
+        for (i in 0 until MediaPlayer.Equalizer.getBandCount())
+            temporarySet.setAmp(i, mEqualizer.getAmp(i))
+
+        val cancelAction = Runnable {
+            state.update(pos, false)
+            mEqualizer = temporarySet
+            updateAlreadyHandled = true
+            if (pos == revertPos)
+                updateEqualizer(pos)
+            else
+                binding.equalizerPresets.setSelection(pos)
+        }
+        state.update(revertPos, true)
+        if (pos == revertPos)
+            updateEqualizer(revertPos)
+        else
+            binding.equalizerPresets.setSelection(revertPos)
+
+        val message = if (getEqualizerType(pos) == TYPE_CUSTOM)
+            getString(R.string.custom_set_restored)
+        else
+            getString(R.string.unsaved_set_deleted_message)
+        UiTools.snackerWithCancel(binding.root, message, null, cancelAction)
+    }
+
+    private fun updateEqualizer(pos: Int) {
+        if (updateAlreadyHandled) {
+            updateAlreadyHandled = false
+        } else {
+            when {
+                getEqualizerType(pos) == TYPE_PRESET -> {
+                    mEqualizer = MediaPlayer.Equalizer.createFromPreset(pos)
+                    state.update(pos, true)
+                }
+                getEqualizerType(pos) == TYPE_CUSTOM -> {
+                    mEqualizer = VLCOptions.getCustomSet(context, allSets[pos])
+                    state.update(pos, true)
+                }
+                getEqualizerType(pos) == TYPE_NEW -> {
+                    mEqualizer = MediaPlayer.Equalizer.create()
+                    state.update(pos, false)
+                }
+            }
+        }
+
+        binding.equalizerPreamp.progress = mEqualizer.preAmp.toInt() + 20
+        for (i in 0 until BAND_COUNT) {
+            val bar = binding.equalizerBands.getChildAt(i) as EqualizerBar
+            bar.setValue(mEqualizer.getAmp(i))
+        }
+        if (binding.equalizerButton.isChecked) PlaybackService.equalizer.value = mEqualizer
+    }
+
+    private fun getEqualizerType(position: Int): Int {
+        if (position < 0) return -1
+        if (position < presetCount) return TYPE_PRESET
+        return if (position < presetCount + customCount) TYPE_CUSTOM else TYPE_NEW
+    }
+
+    inner class EqualizerState {
+
+        internal var saved = true
+        var saveButtonVisibility = ObservableInt(View.INVISIBLE)
+        var revertButtonVisibility = ObservableInt(View.INVISIBLE)
+        var deleteButtonVisibility = ObservableInt(View.INVISIBLE)
+
+        fun update(newPos: Int, newSaved: Boolean) {
+            saved = newSaved
+            saveButtonVisibility.set(if (newSaved) View.INVISIBLE else View.VISIBLE)
+            revertButtonVisibility.set(if (newSaved) View.INVISIBLE else View.VISIBLE)
+            deleteButtonVisibility.set(if (newSaved && getEqualizerType(newPos) == TYPE_CUSTOM) View.VISIBLE else View.INVISIBLE)
+        }
+    }
+
+    companion object {
+
+        const val TAG = "VLC/EqualizerFragment"
+        private val BAND_COUNT = MediaPlayer.Equalizer.getBandCount()
+
+        private const val TYPE_PRESET = 0
+        private const val TYPE_CUSTOM = 1
+        private const val TYPE_NEW = 2
+
+        private val equalizerPresets: Array<String>?
+            get() {
+                val count = MediaPlayer.Equalizer.getPresetCount()
+                if (count <= 0) return null
+                val presets = ArrayList<String>(count)
+                for (i in 0 until count) {
+                    presets[i] = MediaPlayer.Equalizer.getPresetName(i)
+                }
+                return presets.toTypedArray()
+            }
+    }
+}
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/PlaylistAdapter.java b/vlc-android/src/org/videolan/vlc/gui/audio/PlaylistAdapter.java
deleted file mode 100644
index 74aea9a7a2..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/audio/PlaylistAdapter.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * *************************************************************************
- *  PlaylistAdapter.java
- * **************************************************************************
- *  Copyright © 2015-2017 VLC authors and VideoLAN
- *  Author: Geoffrey Métais
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *  ***************************************************************************
- */
-
-package org.videolan.vlc.gui.audio;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build;
-import android.os.Message;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.Toast;
-
-import org.jetbrains.annotations.NotNull;
-import org.videolan.libvlc.util.AndroidUtil;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.R;
-import org.videolan.vlc.VLCApplication;
-import org.videolan.vlc.databinding.PlaylistItemBinding;
-import org.videolan.vlc.gui.DiffUtilAdapter;
-import org.videolan.vlc.gui.helpers.UiTools;
-import org.videolan.vlc.interfaces.SwipeDragHelperAdapter;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.util.MediaItemDiffCallback;
-import org.videolan.vlc.util.WeakHandler;
-import org.videolan.vlc.viewmodels.PlaylistModel;
-
-import java.util.Collections;
-
-import androidx.annotation.MainThread;
-import androidx.databinding.DataBindingUtil;
-import androidx.fragment.app.Fragment;
-import androidx.recyclerview.widget.RecyclerView;
-
-public class PlaylistAdapter extends DiffUtilAdapter<MediaWrapper, PlaylistAdapter.ViewHolder> implements SwipeDragHelperAdapter {
-
-    private static final String TAG = "VLC/PlaylistAdapter";
-
-    private PlaylistModel mModel = null;
-    private IPlayer mPlayer;
-
-    private int mCurrentSelection = 0;
-
-    public interface IPlayer {
-        void onPopupMenu(View view, int position, MediaWrapper item);
-        void onSelectionSet(int position);
-        void playItem(int position, MediaWrapper item);
-    }
-
-    public PlaylistAdapter(IPlayer audioPlayer) {
-        mPlayer = audioPlayer;
-    }
-
-    @Override
-    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        final View v = LayoutInflater.from(parent.getContext())
-                .inflate(R.layout.playlist_item, parent, false);
-        return new ViewHolder(v);
-    }
-
-    @Override
-    public void onBindViewHolder(ViewHolder holder, int position) {
-        final Context ctx = holder.itemView.getContext();
-        final MediaWrapper media = getItem(position);
-        holder.binding.setMedia(media);
-        holder.binding.setSubTitle(MediaUtils.INSTANCE.getMediaSubtitle(media));
-        holder.binding.setTitleColor(mCurrentSelection == position
-                ? UiTools.getColorFromAttribute(ctx, R.attr.list_title_last)
-                : UiTools.getColorFromAttribute(ctx, R.attr.list_title));
-        holder.binding.executePendingBindings();
-    }
-
-    @Override
-    public int getItemCount() {
-        return getDataset().size();
-    }
-
-    @Override
-    @MainThread
-    public MediaWrapper getItem(int position) {
-        if (position >= 0 && position < getItemCount())
-            return getDataset().get(position);
-        else
-            return null;
-    }
-
-    public String getLocation(int position) {
-        MediaWrapper item = getItem(position);
-        return item == null ? "" : item.getLocation();
-    }
-
-    @Override
-    protected void onUpdateFinished() {
-        if (mModel != null) setCurrentIndex(mModel.getSelection());
-    }
-
-    @MainThread
-    public void remove(int position) {
-        if (mModel == null) return;
-        mModel.remove(position);
-    }
-
-    public int getCurrentIndex() {
-        return mCurrentSelection;
-    }
-
-    public void setCurrentIndex(int position) {
-        if (position == mCurrentSelection || position >= getItemCount()) return;
-        int former = mCurrentSelection;
-        mCurrentSelection = position;
-        if (former >= 0) notifyItemChanged(former);
-        if (position >= 0) {
-            notifyItemChanged(position);
-            mPlayer.onSelectionSet(position);
-        }
-    }
-
-    @Override
-    public void onItemMove(int fromPosition, int toPosition) {
-        Collections.swap(getDataset(), fromPosition, toPosition);
-        notifyItemMoved(fromPosition, toPosition);
-        mHandler.obtainMessage(PlaylistHandler.ACTION_MOVE, fromPosition, toPosition).sendToTarget();
-    }
-
-    @Override
-    public void onItemMoved(int dragFrom, int dragTo) {
-
-    }
-
-    @Override
-    public void onItemDismiss(final int position) {
-        final MediaWrapper media = getItem(position);
-        String message = String.format(VLCApplication.getAppResources().getString(R.string.remove_playlist_item), media.getTitle());
-        if (mPlayer instanceof Fragment){
-            final View v = ((Fragment) mPlayer).getView();
-            final Runnable cancelAction = new Runnable() {
-                @Override
-                public void run() {
-                    mModel.insertMedia(position, media);
-                }
-            };
-            UiTools.snackerWithCancel(v, message, null, cancelAction);
-        } else if (mPlayer instanceof Context){
-            Toast.makeText(VLCApplication.getAppContext(), message, Toast.LENGTH_SHORT).show();
-        }
-        remove(position);
-    }
-
-    public void setModel(PlaylistModel model) {
-        mModel = model;
-    }
-
-    public class ViewHolder extends RecyclerView.ViewHolder {
-        PlaylistItemBinding binding;
-
-        @TargetApi(Build.VERSION_CODES.M)
-        public ViewHolder(View v) {
-            super(v);
-            binding = DataBindingUtil.bind(v);
-            binding.setHolder(this);
-            if (AndroidUtil.isMarshMallowOrLater) itemView.setOnContextClickListener(new View.OnContextClickListener() {
-                @Override
-                public boolean onContextClick(View v) {
-                    onMoreClick(v);
-                    return true;
-                }
-            });
-        }
-        public void onClick(View v, MediaWrapper media){
-            int position = getLayoutPosition(); //getMediaPosition(media);
-            mPlayer.playItem(position, media);
-        }
-
-        public void onMoreClick(View v) {
-            final int position = getLayoutPosition();
-            mPlayer.onPopupMenu(v, position, getItem(position));
-        }
-    }
-
-    private PlaylistHandler mHandler = new PlaylistHandler(this);
-
-    private static class PlaylistHandler extends WeakHandler<PlaylistAdapter>{
-
-        static final int ACTION_MOVE = 0;
-        static final int ACTION_MOVED = 1;
-
-        int from = -1, to = -1;
-
-        PlaylistHandler(PlaylistAdapter owner) {
-            super(owner);
-        }
-
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what){
-                case ACTION_MOVE:
-                    removeMessages(ACTION_MOVED);
-                    if (from == -1) from = msg.arg1;
-                    to = msg.arg2;
-                    sendEmptyMessageDelayed(ACTION_MOVED, 1000);
-                    break;
-                case ACTION_MOVED:
-                    final PlaylistModel model = getOwner().mModel;
-                    if (from != -1 && to != -1 && model == null) return;
-                    if (to > from) ++to;
-                    model.move(from, to);
-                    from = to = -1;
-                    break;
-            }
-        }
-    }
-
-    @NotNull
-    @Override
-    protected DiffCallback<MediaWrapper> createCB() {
-        return new MediaItemDiffCallback();
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/PlaylistAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/audio/PlaylistAdapter.kt
new file mode 100644
index 0000000000..bd9f6bdf76
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/PlaylistAdapter.kt
@@ -0,0 +1,212 @@
+/*
+ * *************************************************************************
+ *  PlaylistAdapter.java
+ * **************************************************************************
+ *  Copyright © 2015-2017 VLC authors and VideoLAN
+ *  Author: Geoffrey Métais
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *  ***************************************************************************
+ */
+
+package org.videolan.vlc.gui.audio
+
+import android.annotation.TargetApi
+import android.content.Context
+import android.os.Build
+import android.os.Message
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.Toast
+import androidx.annotation.MainThread
+import androidx.databinding.DataBindingUtil
+import androidx.fragment.app.Fragment
+import androidx.recyclerview.widget.RecyclerView
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.util.AndroidUtil
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.R
+import org.videolan.vlc.VLCApplication
+import org.videolan.vlc.databinding.PlaylistItemBinding
+import org.videolan.vlc.gui.DiffUtilAdapter
+import org.videolan.vlc.gui.helpers.UiTools
+import org.videolan.vlc.interfaces.SwipeDragHelperAdapter
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.util.MediaItemDiffCallback
+import org.videolan.vlc.util.WeakHandler
+import org.videolan.vlc.viewmodels.PlaylistModel
+import java.util.*
+
+@ExperimentalCoroutinesApi
+@UseExperimental(ObsoleteCoroutinesApi::class)
+class PlaylistAdapter(private val player: IPlayer) : DiffUtilAdapter<MediaWrapper, PlaylistAdapter.ViewHolder>(), SwipeDragHelperAdapter {
+
+    private var mModel: PlaylistModel? = null
+
+    var currentIndex = 0
+        set(position) {
+            if (position == currentIndex || position >= itemCount) return
+            val former = currentIndex
+            field = position
+            if (former >= 0) notifyItemChanged(former)
+            if (position >= 0) {
+                notifyItemChanged(position)
+                player.onSelectionSet(position)
+            }
+        }
+
+    private val mHandler = PlaylistHandler(this)
+
+    interface IPlayer {
+        fun onPopupMenu(view: View, position: Int, item: MediaWrapper?)
+        fun onSelectionSet(position: Int)
+        fun playItem(position: Int, item: MediaWrapper)
+    }
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
+        val v = LayoutInflater.from(parent.context)
+                .inflate(R.layout.playlist_item, parent, false)
+        return ViewHolder(v)
+    }
+
+    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
+        val ctx = holder.itemView.context
+        val media = getItem(position)
+        holder.binding!!.media = media
+        holder.binding!!.subTitle = MediaUtils.getMediaSubtitle(media!!)
+        holder.binding!!.titleColor = if (currentIndex == position)
+            UiTools.getColorFromAttribute(ctx, R.attr.list_title_last)
+        else
+            UiTools.getColorFromAttribute(ctx, R.attr.list_title)
+        holder.binding!!.executePendingBindings()
+    }
+
+    override fun getItemCount(): Int {
+        return dataset.size
+    }
+
+    @MainThread
+    override fun getItem(position: Int): MediaWrapper {
+        return dataset[position]
+    }
+
+    fun getLocation(position: Int): String {
+        return getItem(position).location
+    }
+
+    override fun onUpdateFinished() {
+        if (mModel != null) currentIndex = mModel!!.selection
+    }
+
+    @MainThread
+    fun remove(position: Int) {
+        if (mModel == null) return
+        mModel!!.remove(position)
+    }
+
+    override fun onItemMove(fromPosition: Int, toPosition: Int) {
+        Collections.swap(dataset, fromPosition, toPosition)
+        notifyItemMoved(fromPosition, toPosition)
+        mHandler.obtainMessage(PlaylistHandler.ACTION_MOVE, fromPosition, toPosition).sendToTarget()
+    }
+
+    override fun onItemMoved(dragFrom: Int, dragTo: Int) {
+
+    }
+
+    override fun onItemDismiss(position: Int) {
+        val media = getItem(position)
+        val message = String.format(VLCApplication.getAppResources().getString(R.string.remove_playlist_item), media!!.title)
+        if (player is Fragment) {
+            val v = (player as Fragment).view
+            val cancelAction = Runnable { mModel!!.insertMedia(position, media) }
+            UiTools.snackerWithCancel(v!!, message, null, cancelAction)
+        } else if (player is Context) {
+            Toast.makeText(VLCApplication.getAppContext(), message, Toast.LENGTH_SHORT).show()
+        }
+        remove(position)
+    }
+
+    fun setModel(model: PlaylistModel) {
+        mModel = model
+    }
+
+    inner class ViewHolder @TargetApi(Build.VERSION_CODES.M)
+    constructor(v: View) : RecyclerView.ViewHolder(v) {
+        internal var binding: PlaylistItemBinding? = null
+
+        init {
+            binding = DataBindingUtil.bind(v)
+            binding!!.holder = this
+            if (AndroidUtil.isMarshMallowOrLater)
+                itemView.setOnContextClickListener { v ->
+                    onMoreClick(v)
+                    true
+                }
+        }
+
+        fun onClick(v: View, media: MediaWrapper) {
+            val position = layoutPosition //getMediaPosition(media);
+            player.playItem(position, media)
+        }
+
+        fun onMoreClick(v: View) {
+            val position = layoutPosition
+            player.onPopupMenu(v, position, getItem(position))
+        }
+    }
+
+    private class PlaylistHandler internal constructor(owner: PlaylistAdapter) : WeakHandler<PlaylistAdapter>(owner) {
+
+        internal var from = -1
+        internal var to = -1
+
+        override fun handleMessage(msg: Message) {
+            when (msg.what) {
+                ACTION_MOVE -> {
+                    removeMessages(ACTION_MOVED)
+                    if (from == -1) from = msg.arg1
+                    to = msg.arg2
+                    sendEmptyMessageDelayed(ACTION_MOVED, 1000)
+                }
+                ACTION_MOVED -> {
+                    val model = owner.mModel
+                    if (from != -1 && to != -1 && model == null) return
+                    if (to > from) ++to
+                    model!!.move(from, to)
+                    to = -1
+                    from = to
+                }
+            }
+        }
+
+        companion object {
+
+            internal val ACTION_MOVE = 0
+            internal val ACTION_MOVED = 1
+        }
+    }
+
+    override fun createCB(): DiffUtilAdapter.DiffCallback<MediaWrapper> {
+        return MediaItemDiffCallback()
+    }
+
+    companion object {
+
+        private val TAG = "VLC/PlaylistAdapter"
+    }
+}
