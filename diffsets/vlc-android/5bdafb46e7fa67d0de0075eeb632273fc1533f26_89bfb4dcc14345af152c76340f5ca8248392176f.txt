diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java b/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java
index 7831c1a454..7fce539ca7 100644
--- a/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java
@@ -53,14 +53,10 @@
 import android.os.PowerManager;
 import android.preference.PreferenceManager;
 import android.provider.Settings;
-import android.provider.Settings.SettingNotFoundException;
 import android.support.annotation.NonNull;
 import android.support.design.widget.Snackbar;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.content.LocalBroadcastManager;
-import android.support.v4.view.GestureDetectorCompat;
-import android.support.v4.view.ScaleGestureDetectorCompat;
-import android.support.v4.view.ViewCompat;
 import android.support.v7.app.ActionBar;
 import android.support.v7.app.AlertDialog;
 import android.support.v7.app.AppCompatActivity;
@@ -75,13 +71,11 @@
 import android.util.Log;
 import android.util.Rational;
 import android.view.Display;
-import android.view.GestureDetector;
 import android.view.InputDevice;
 import android.view.KeyEvent;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
-import android.view.ScaleGestureDetector;
 import android.view.Surface;
 import android.view.SurfaceView;
 import android.view.View;
@@ -171,9 +165,7 @@ public class VideoPlayerActivity extends AppCompatActivity implements IVLCVout.C
     private final static int RESULT_CONNECTION_FAILED = RESULT_FIRST_USER + 1;
     private final static int RESULT_PLAYBACK_ERROR = RESULT_FIRST_USER + 2;
     private final static int RESULT_VIDEO_TRACK_LOST = RESULT_FIRST_USER + 3;
-    private static final float DEFAULT_FOV = 80f;
-    private static final float MIN_FOV = 20f;
-    private static final float MAX_FOV = 150f;
+    static final float DEFAULT_FOV = 80f;
 
     private final PlaybackServiceActivity.Helper mHelper = new PlaybackServiceActivity.Helper(this, this);
     protected PlaybackService mService;
@@ -186,29 +178,23 @@ public class VideoPlayerActivity extends AppCompatActivity implements IVLCVout.C
     private Uri mUri;
     private boolean mAskResume = true;
     private boolean mIsRtl;
-    private ScaleGestureDetector mScaleGestureDetector;
-    private GestureDetectorCompat mDetector = null;
 
     private ImageView mPlaylistToggle;
     private RecyclerView mPlaylist;
     private PlaylistAdapter mPlaylistAdapter;
 
     private static final int SURFACE_BEST_FIT = 0;
-    private static final int SURFACE_FIT_SCREEN = 1;
+    static final int SURFACE_FIT_SCREEN = 1;
     private static final int SURFACE_FILL = 2;
     private static final int SURFACE_16_9 = 3;
     private static final int SURFACE_4_3 = 4;
     private static final int SURFACE_ORIGINAL = 5;
     private static final int SURFACE_SIZE_COUNT = 6;
+
     private int mCurrentSize;
 
     private SharedPreferences mSettings;
 
-    private static final int TOUCH_FLAG_AUDIO_VOLUME = 1;
-    private static final int TOUCH_FLAG_BRIGHTNESS = 1 << 1;
-    private static final int TOUCH_FLAG_SEEK = 1 << 2;
-    private int mTouchControls = 0;
-
     /** Overlay */
     private ActionBar mActionBar;
     private ViewGroup mActionBarView;
@@ -223,8 +209,8 @@ public class VideoPlayerActivity extends AppCompatActivity implements IVLCVout.C
     private static final int RESET_BACK_LOCK = 6;
     private static final int CHECK_VIDEO_TRACKS = 7;
     private static final int LOADING_ANIMATION = 8;
-    private static final int SHOW_INFO = 9;
-    private static final int HIDE_INFO = 10;
+    static final int SHOW_INFO = 9;
+    static final int HIDE_INFO = 10;
 
     private static final int LOADING_ANIMATION_DELAY = 1000;
 
@@ -269,6 +255,8 @@ public class VideoPlayerActivity extends AppCompatActivity implements IVLCVout.C
     private long mSavedTime = -1;
     private float mSavedRate = 1.f;
 
+    private float mSavedBrightness = -1f;
+
     /**
      * For uninterrupted switching between audio and video mode
      */
@@ -294,25 +282,8 @@ public class VideoPlayerActivity extends AppCompatActivity implements IVLCVout.C
     private float mOriginalVol;
     private Toast warningToast;
 
-    //Touch Events
-    private static final int TOUCH_NONE = 0;
-    private static final int TOUCH_VOLUME = 1;
-    private static final int TOUCH_BRIGHTNESS = 2;
-    private static final int TOUCH_MOVE = 3;
-    private static final int TOUCH_SEEK = 4;
-    private static final int TOUCH_IGNORE = 5;
-    private int mTouchAction = TOUCH_NONE;
-    private int mSurfaceYDisplayRange, mSurfaceXDisplayRange;
     private float mFov;
-    private float mInitTouchY, mTouchY =-1f, mTouchX=-1f;
-
-    //stick event
-    private static final int JOYSTICK_INPUT_DELAY = 300;
-    private long mLastMove;
-
-    // Brightness
-    private boolean mIsFirstBrightnessGesture = true;
-    private float mRestoreAutoBrightness = -1f;
+    private VideoTouchDelegate mTouchDelegate;
 
     // Tracks & Subtitles
     private MediaPlayer.TrackDescription[] mAudioTracksList;
@@ -362,12 +333,6 @@ protected void onCreate(Bundle savedInstanceState) {
 
         mSettings = PreferenceManager.getDefaultSharedPreferences(this);
 
-        if (!VLCApplication.showTvUi()) {
-            mTouchControls = (mSettings.getBoolean("enable_volume_gesture", true) ? TOUCH_FLAG_AUDIO_VOLUME : 0)
-                    + (mSettings.getBoolean("enable_brightness_gesture", true) ? TOUCH_FLAG_BRIGHTNESS : 0)
-                    + (mSettings.getBoolean("enable_double_tap_seek", true) ? TOUCH_FLAG_SEEK : 0);
-        }
-
         /* Services and miscellaneous */
         mAudioManager = (AudioManager) getApplicationContext().getSystemService(AUDIO_SERVICE);
         mAudioMax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
@@ -396,24 +361,24 @@ protected void onCreate(Bundle savedInstanceState) {
             if (v instanceof TextView) mBattery = (TextView) v;
         }
 
-        mPlaylistToggle = (ImageView) findViewById(R.id.playlist_toggle);
-        mPlaylist = (RecyclerView) findViewById(R.id.video_playlist);
+        mPlaylistToggle = findViewById(R.id.playlist_toggle);
+        mPlaylist = findViewById(R.id.video_playlist);
 
 
 
         mScreenOrientation = Integer.valueOf(
                 mSettings.getString("screen_orientation", "99" /*SCREEN ORIENTATION SENSOR*/));
 
-        mSurfaceView = (SurfaceView) findViewById(R.id.player_surface);
-        mSubtitlesSurfaceView = (SurfaceView) findViewById(R.id.subtitles_surface);
+        mSurfaceView = findViewById(R.id.player_surface);
+        mSubtitlesSurfaceView = findViewById(R.id.subtitles_surface);
 
         mSubtitlesSurfaceView.setZOrderMediaOverlay(true);
         mSubtitlesSurfaceView.getHolder().setFormat(PixelFormat.TRANSLUCENT);
 
-        mSurfaceFrame = (FrameLayout) findViewById(R.id.player_surface_frame);
+        mSurfaceFrame = findViewById(R.id.player_surface_frame);
 
         /* Loading view */
-        mLoading = (ImageView) findViewById(R.id.player_overlay_loading);
+        mLoading = findViewById(R.id.player_overlay_loading);
         dimStatusBar(true);
         mHandler.sendEmptyMessageDelayed(LOADING_ANIMATION, LOADING_ANIMATION_DELAY);
 
@@ -434,8 +399,7 @@ protected void onCreate(Bundle savedInstanceState) {
         editor.apply();
 
         final IntentFilter filter = new IntentFilter();
-        if (mBattery != null)
-            filter.addAction(Intent.ACTION_BATTERY_CHANGED);
+        if (mBattery != null) filter.addAction(Intent.ACTION_BATTERY_CHANGED);
         filter.addAction(VLCApplication.SLEEP_INTENT);
         registerReceiver(mReceiver, filter);
 
@@ -457,7 +421,7 @@ protected void onCreate(Bundle savedInstanceState) {
                 int hm = getResources().getDimensionPixelSize(R.dimen.tv_overscan_horizontal);
                 int vm = getResources().getDimensionPixelSize(R.dimen.tv_overscan_vertical);
 
-                final RelativeLayout uiContainer = (RelativeLayout) findViewById(R.id.player_ui_container);
+                final RelativeLayout uiContainer = findViewById(R.id.player_ui_container);
                 final RelativeLayout.LayoutParams lp = (RelativeLayout.LayoutParams) uiContainer.getLayoutParams();
                 lp.setMargins(hm, 0, hm, vm);
                 uiContainer.setLayoutParams(lp);
@@ -468,10 +432,7 @@ protected void onCreate(Bundle savedInstanceState) {
             }
         }
 
-        getWindowManager().getDefaultDisplay().getMetrics(mScreen);
-        mSurfaceYDisplayRange = Math.min(mScreen.widthPixels, mScreen.heightPixels);
-        mSurfaceXDisplayRange = Math.max(mScreen.widthPixels, mScreen.heightPixels);
-        mCurrentScreenOrientation = getResources().getConfiguration().orientation;
+
         if (mIsBenchmark) {
             mCurrentSize = SURFACE_FIT_SCREEN;
         } else {
@@ -479,6 +440,21 @@ protected void onCreate(Bundle savedInstanceState) {
         }
         mMedialibrary = VLCApplication.getMLInstance();
         mIsRtl = AndroidUtil.isJellyBeanMR1OrLater && TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()) == View.LAYOUT_DIRECTION_RTL;
+        final int touch;
+        if (!VLCApplication.showTvUi()) {
+            touch = (mSettings.getBoolean("enable_volume_gesture", true) ? VideoTouchDelegateKt.TOUCH_FLAG_AUDIO_VOLUME : 0)
+                    + (mSettings.getBoolean("enable_brightness_gesture", true) ? VideoTouchDelegateKt.TOUCH_FLAG_BRIGHTNESS : 0)
+                    + (mSettings.getBoolean("enable_double_tap_seek", true) ? VideoTouchDelegateKt.TOUCH_FLAG_SEEK : 0);
+        } else touch = 0;
+        mCurrentScreenOrientation = getResources().getConfiguration().orientation;
+        if (touch != 0) {
+            final DisplayMetrics dm = new DisplayMetrics();
+            getWindowManager().getDefaultDisplay().getMetrics(dm);
+            int yRange = Math.min(dm.widthPixels, dm.heightPixels);
+            int xRange = Math.max(dm.widthPixels, dm.heightPixels);
+            final ScreenConfig sc = new ScreenConfig(dm, xRange, yRange, mCurrentScreenOrientation);
+            mTouchDelegate = new VideoTouchDelegate(this, touch, sc, mIsRtl);
+        }
     }
 
     @Override
@@ -518,7 +494,7 @@ protected void onNewIntent(Intent intent) {
             }
             mUri = uri;
             mTitle.setText(mService.getCurrentMediaWrapper().getTitle());
-            if (mPlaylist.getVisibility() == View.VISIBLE) {
+            if (isPlaylistVisible()) {
                 mPlaylistAdapter.setCurrentIndex(mService.getCurrentMediaPosition());
                 mPlaylist.setVisibility(View.GONE);
             }
@@ -606,10 +582,16 @@ public void onVisibleBehindCanceled() {
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        getWindowManager().getDefaultDisplay().getMetrics(mScreen);
         mCurrentScreenOrientation = newConfig.orientation;
-        mSurfaceYDisplayRange = Math.min(mScreen.widthPixels, mScreen.heightPixels);
-        mSurfaceXDisplayRange = Math.max(mScreen.widthPixels, mScreen.heightPixels);
+        if (mTouchDelegate != null) {
+            final DisplayMetrics dm = new DisplayMetrics();
+            getWindowManager().getDefaultDisplay().getMetrics(dm);
+            final ScreenConfig sc = new ScreenConfig(dm,
+                    Math.max(dm.widthPixels, dm.heightPixels),
+                    Math.min(dm.widthPixels, dm.heightPixels),
+                    mCurrentScreenOrientation);
+            mTouchDelegate.setScreenConfig(sc);
+        }
         resetHudLayout();
     }
 
@@ -700,14 +682,15 @@ protected void onStop() {
     }
 
     private void restoreBrightness() {
-        if (mRestoreAutoBrightness != -1f) {
-            int brightness = (int) (mRestoreAutoBrightness*255f);
+        if (mSavedBrightness != -1f) {
+            int brightness = (int) (mSavedBrightness *255f);
             Settings.System.putInt(getContentResolver(),
                     Settings.System.SCREEN_BRIGHTNESS,
                     brightness);
             Settings.System.putInt(getContentResolver(),
                     Settings.System.SCREEN_BRIGHTNESS_MODE,
                     Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
+            mSavedBrightness = -1f;
         }
         // Save brightness if user wants to
         if (mSettings.getBoolean("save_brightness", false)) {
@@ -895,11 +878,6 @@ private void cleanUI() {
 
         if (mRootView != null) mRootView.setKeepScreenOn(false);
 
-        if (mDetector != null) {
-            mDetector.setOnDoubleTapListener(null);
-            mDetector = null;
-        }
-
         /* Stop listening for changes to media routes. */
         mDisplayManager.mediaRouterAddCallback(false);
 
@@ -1011,59 +989,13 @@ private void exitOK() {
 
     @Override
     public boolean onTrackballEvent(MotionEvent event) {
-        if (mIsLoading)
-            return false;
+        if (mIsLoading) return false;
         showOverlay();
         return true;
     }
 
-    @TargetApi(12) //only active for Android 3.1+
-    public boolean dispatchGenericMotionEvent(MotionEvent event){
-        if (mIsLoading)
-            return  false;
-        //Check for a joystick event
-        if ((event.getSource() & InputDevice.SOURCE_JOYSTICK) !=
-                InputDevice.SOURCE_JOYSTICK ||
-                event.getAction() != MotionEvent.ACTION_MOVE)
-            return false;
-
-        InputDevice mInputDevice = event.getDevice();
-
-        float dpadx = event.getAxisValue(MotionEvent.AXIS_HAT_X);
-        float dpady = event.getAxisValue(MotionEvent.AXIS_HAT_Y);
-        if (mInputDevice == null || Math.abs(dpadx) == 1.0f || Math.abs(dpady) == 1.0f)
-            return false;
-
-        float x = AndroidDevices.getCenteredAxis(event, mInputDevice,
-                MotionEvent.AXIS_X);
-        float y = AndroidDevices.getCenteredAxis(event, mInputDevice,
-                MotionEvent.AXIS_Y);
-        float rz = AndroidDevices.getCenteredAxis(event, mInputDevice,
-                MotionEvent.AXIS_RZ);
-
-        if (System.currentTimeMillis() - mLastMove > JOYSTICK_INPUT_DELAY){
-            if (Math.abs(x) > 0.3){
-                if (VLCApplication.showTvUi()) {
-                    navigateDvdMenu(x > 0.0f ? KeyEvent.KEYCODE_DPAD_RIGHT : KeyEvent.KEYCODE_DPAD_LEFT);
-                } else
-                    seekDelta(x > 0.0f ? 10000 : -10000);
-            } else if (Math.abs(y) > 0.3){
-                if (VLCApplication.showTvUi())
-                    navigateDvdMenu(x > 0.0f ? KeyEvent.KEYCODE_DPAD_UP : KeyEvent.KEYCODE_DPAD_DOWN);
-                else {
-                    if (mIsFirstBrightnessGesture)
-                        initBrightnessTouch();
-                    changeBrightness(-y / 10f);
-                }
-            } else if (Math.abs(rz) > 0.3){
-                mVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
-                int delta = -(int) ((rz / 7) * mAudioMax);
-                int vol = (int) Math.min(Math.max(mVol + delta, 0), mAudioMax);
-                setAudioVolume(vol);
-            }
-            mLastMove = System.currentTimeMillis();
-        }
-        return true;
+    public boolean dispatchGenericMotionEvent(MotionEvent event) {
+        return !mIsLoading && mTouchDelegate.dispatchGenericMotionEvent(event);
     }
 
     @Override
@@ -1072,9 +1004,9 @@ public void onBackPressed() {
             mLockBackButton = false;
             mHandler.sendEmptyMessageDelayed(RESET_BACK_LOCK, 2000);
             Toast.makeText(getApplicationContext(), getString(R.string.back_quit_lock), Toast.LENGTH_SHORT).show();
-        } else if(mPlaylist.getVisibility() == View.VISIBLE) {
+        } else if(isPlaylistVisible()) {
             togglePlaylist();
-        } else if (mPlaybackSetting != DelayState.OFF){
+        } else if (isPlaybackSettingActive()){
             endPlaybackSetting();
         } else if (VLCApplication.showTvUi() && mShowing && !mIsLocked) {
             hideOverlay(true);
@@ -1088,7 +1020,7 @@ public void onBackPressed() {
     public boolean onKeyDown(int keyCode, KeyEvent event) {
         if (mService == null || keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_BUTTON_B)
             return super.onKeyDown(keyCode, event);
-        if (mPlaybackSetting != DelayState.OFF)
+        if (isPlaybackSettingActive())
             return false;
         if (mIsLoading) {
             switch (keyCode) {
@@ -1268,6 +1200,38 @@ else if (!mShowing) {
         return super.onKeyDown(keyCode, event);
     }
 
+    void setSavedBrightness(float brightness) {
+        mSavedBrightness = brightness;
+    }
+
+    int getAudioMax() {
+        return mAudioMax;
+    }
+
+    AudioManager getAudiomanager() {
+        return mAudioManager;
+    }
+
+    float getVolume() {
+        return mVol;
+    }
+
+    void setVolume(float vol) {
+        mVol = vol;
+    }
+
+    float getOriginalVol() {
+        return mOriginalVol;
+    }
+
+    void setOriginalVol(float vol) {
+        mOriginalVol = vol;
+    }
+
+    boolean isAudioBoostEnabled() {
+        return audioBoostEnabled;
+    }
+
     private void volumeUp() {
         if (mMute) {
             updateMute();
@@ -1293,7 +1257,7 @@ private void volumeDown() {
         setAudioVolume(vol);
     }
 
-    private boolean navigateDvdMenu(int keyCode) {
+    boolean navigateDvdMenu(int keyCode) {
         switch (keyCode) {
             case KeyEvent.KEYCODE_DPAD_UP:
                 mService.navigate(MediaPlayer.Navigate.Up);
@@ -1331,13 +1295,13 @@ public void showSubsDelaySetting() {
     }
 
     public void showDelayControls(){
-        mTouchAction = TOUCH_NONE;
+        mTouchDelegate.clearTouchAction();
         if (!mDisplayManager.isPrimary()) showOverlayTimeout(OVERLAY_INFINITE);
-        ViewStubCompat vsc = (ViewStubCompat) findViewById(R.id.player_overlay_settings_stub);
+        ViewStubCompat vsc = findViewById(R.id.player_overlay_settings_stub);
         if (vsc != null) {
             vsc.inflate();
-            mPlaybackSettingPlus = (ImageView) findViewById(R.id.player_delay_plus);
-            mPlaybackSettingMinus = (ImageView) findViewById(R.id.player_delay_minus);
+            mPlaybackSettingPlus = findViewById(R.id.player_delay_plus);
+            mPlaybackSettingMinus = findViewById(R.id.player_delay_minus);
 
         }
         mPlaybackSettingMinus.setOnClickListener(this);
@@ -1350,6 +1314,7 @@ public void showDelayControls(){
         initPlaybackSettingInfo();
     }
 
+
     private void initPlaybackSettingInfo() {
         initInfoOverlay();
         UiTools.setViewVisibility(mVerticalBar, View.GONE);
@@ -1370,7 +1335,6 @@ private void initPlaybackSettingInfo() {
 
     @Override
     public void endPlaybackSetting() {
-        mTouchAction = TOUCH_NONE;
         mService.saveMediaMeta();
         if (mPlaybackSetting == DelayState.AUDIO
                 && (mAudioManager.isBluetoothA2dpOn() || mAudioManager.isBluetoothScoOn())) {
@@ -1402,19 +1366,23 @@ public void delayAudio(long delta) {
         mService.setAudioDelay(delay);
         mInfo.setText(getString(R.string.audio_delay)+"\n"+(delay/1000L)+" ms");
         mAudioDelay = delay;
-        if (mPlaybackSetting == DelayState.OFF) {
+        if (!isPlaybackSettingActive()) {
             mPlaybackSetting = DelayState.AUDIO;
             initPlaybackSettingInfo();
         }
     }
 
+    boolean isPlaybackSettingActive() {
+        return mPlaybackSetting != DelayState.OFF;
+    }
+
     public void delaySubs(long delta) {
         initInfoOverlay();
         long delay = mService.getSpuDelay()+delta;
         mService.setSpuDelay(delay);
         mInfo.setText(getString(R.string.spu_delay) + "\n" + (delay / 1000L) + " ms");
         mSpuDelay = delay;
-        if (mPlaybackSetting == DelayState.OFF) {
+        if (!isPlaybackSettingActive()) {
             mPlaybackSetting = DelayState.SUBS;
             initPlaybackSettingInfo();
         }
@@ -1502,7 +1470,7 @@ private void showInfoWithVerticalBar(String text, int duration, int barNewValue,
      * @param text
      * @param duration
      */
-    private void showInfo(String text, int duration) {
+    void showInfo(String text, int duration) {
         initInfoOverlay();
         UiTools.setViewVisibility(mVerticalBar, View.GONE);
         UiTools.setViewVisibility(mOverlayInfo, View.VISIBLE);
@@ -1512,11 +1480,11 @@ private void showInfo(String text, int duration) {
     }
 
     private void initInfoOverlay() {
-        ViewStubCompat vsc = (ViewStubCompat) findViewById(R.id.player_info_stub);
+        ViewStubCompat vsc = findViewById(R.id.player_info_stub);
         if (vsc != null) {
             vsc.inflate();
             // the info textView is not on the overlay
-            mInfo = (TextView) findViewById(R.id.player_overlay_textinfo);
+            mInfo = findViewById(R.id.player_overlay_textinfo);
             mOverlayInfo = findViewById(R.id.player_overlay_info);
             mVerticalBar = findViewById(R.id.verticalbar);
             mVerticalBarProgress = findViewById(R.id.verticalbar_progress);
@@ -1524,7 +1492,7 @@ private void initInfoOverlay() {
         }
     }
 
-    private void showInfo(int textid, int duration) {
+    void showInfo(int textid, int duration) {
         initInfoOverlay();
         UiTools.setViewVisibility(mVerticalBar, View.GONE);
         UiTools.setViewVisibility(mOverlayInfo, View.VISIBLE);
@@ -1659,22 +1627,23 @@ public void onMediaPlayerEvent(MediaPlayer.Event event) {
                 if (event.getBuffering() == 100f)
                     stopLoading();
                 else if (!mHandler.hasMessages(LOADING_ANIMATION) && !mIsLoading
-                        && mTouchAction != TOUCH_SEEK && !mDragging)
+                        && !mTouchDelegate.isSeeking() && !mDragging)
                     mHandler.sendEmptyMessageDelayed(LOADING_ANIMATION, LOADING_ANIMATION_DELAY);
                 break;
         }
     }
 
+    public Handler getHandler() {
+        return mHandler;
+    }
+
     /**
      * Handle resize of the surface and the overlay
      */
-    private final Handler mHandler = new Handler(Looper.getMainLooper(), new Handler.Callback() {
+    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
         @Override
-        public boolean handleMessage(Message msg) {
-            if (mService == null)
-                return true;
-
-            switch (msg.what) {
+        public void handleMessage(Message msg) {
+            if (mService != null) switch (msg.what) {
                 case FADE_OUT:
                     hideOverlay(false);
                     break;
@@ -1712,9 +1681,8 @@ public boolean handleMessage(Message msg) {
                     showOverlay();
                     break;
             }
-            return true;
         }
-    });
+    };
 
     private boolean canShowProgress() {
         return !mDragging && mShowing && mService != null &&  mService.isPlaying();
@@ -2021,9 +1989,8 @@ private void changeSurfaceLayout() {
         subtitlesSurface.invalidate();
     }
 
-    private void sendMouseEvent(int action, int x, int y) {
-        if (mService == null)
-            return;
+    void sendMouseEvent(int action, int x, int y) {
+        if (mService == null) return;
         final IVLCVout vlcVout = mService.getVout();
         vlcVout.sendMouseEvent(action, 0, x, y);
     }
@@ -2034,205 +2001,36 @@ private void sendMouseEvent(int action, int x, int y) {
 
     @Override
     public boolean onTouchEvent(MotionEvent event) {
-        if (mService == null) return false;
-        if (mDetector == null) {
-            mDetector = new GestureDetectorCompat(this, mGestureListener);
-            mDetector.setOnDoubleTapListener(mGestureListener);
-        }
-        if (mScaleGestureDetector == null) {
-            mScaleGestureDetector = new ScaleGestureDetector(this, mScaleListener);
-            ScaleGestureDetectorCompat.setQuickScaleEnabled(mScaleGestureDetector, false);
-        }
-        if (mPlaybackSetting != DelayState.OFF) {
-            if (event.getAction() == MotionEvent.ACTION_UP) endPlaybackSetting();
-            return true;
-        } else if (mPlaylist.getVisibility() == View.VISIBLE) {
-            mTouchAction = TOUCH_IGNORE;
-            togglePlaylist();
-            return true;
-        }
-        if (mTouchControls == 0 || mIsLocked) {
-            // locked or swipe disabled, only handle show/hide & ignore all actions
-            if (event.getAction() == MotionEvent.ACTION_UP) {
-                if (!mShowing) {
-                    showOverlay();
-                } else {
-                    hideOverlay(true);
-                }
-            }
-            return false;
-        }
-        mScaleGestureDetector.onTouchEvent(event);
-        if ((mScaleGestureDetector != null && mScaleGestureDetector.isInProgress()) ||
-                (mDetector != null && mDetector.onTouchEvent(event))) {
-            mTouchAction = TOUCH_IGNORE;
-            return true;
-        }
-
-        final float x_changed = mTouchX != -1f && mTouchY != -1f ? event.getRawX() - mTouchX : 0f;
-        final float y_changed = x_changed != 0f ? event.getRawY() - mTouchY : 0f;
-
-        // coef is the gradient's move to determine a neutral zone
-        final float coef = Math.abs (y_changed / x_changed);
-        final float xgesturesize = ((x_changed / mScreen.xdpi) * 2.54f);
-        final float delta_y = Math.max(1f, (Math.abs(mInitTouchY - event.getRawY()) / mScreen.xdpi + 0.5f) * 2f);
-
-        final int xTouch = Math.round(event.getRawX());
-        final int yTouch = Math.round(event.getRawY());
-
-        switch (event.getAction()) {
-            case MotionEvent.ACTION_DOWN:
-                // Audio
-                mTouchY = mInitTouchY = event.getRawY();
-                if (mService.getVolume() <= 100) {
-                    mVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
-                    mOriginalVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
-                }
-                else {
-                    mVol = ((float)mService.getVolume()) * mAudioMax / 100;
-                }
-                mTouchAction = TOUCH_NONE;
-                // Seek
-                mTouchX = event.getRawX();
-                // Mouse events for the core
-                sendMouseEvent(MotionEvent.ACTION_DOWN, xTouch, yTouch);
-                break;
-            case MotionEvent.ACTION_MOVE:
-                if (mTouchAction == TOUCH_IGNORE) break;
-
-                // Mouse events for the core
-                sendMouseEvent(MotionEvent.ACTION_MOVE, xTouch, yTouch);
-
-                if (mFov == 0f) {
-                    // No volume/brightness action if coef < 2 or a secondary display is connected
-                    //TODO : Volume action when a secondary display is connected
-                    if (mTouchAction != TOUCH_SEEK && coef > 2 && mDisplayManager.isPrimary()) {
-                        if (Math.abs(y_changed/mSurfaceYDisplayRange) < 0.05)
-                            return false;
-                        mTouchY = event.getRawY();
-                        mTouchX = event.getRawX();
-                        doVerticalTouchAction(y_changed);
-                    } else {
-                        // Seek (Right or Left move)
-                        doSeekTouch(Math.round(delta_y), mIsRtl ? -xgesturesize : xgesturesize , false);
-                    }
-                } else {
-                    mTouchY = event.getRawY();
-                    mTouchX = event.getRawX();
-                    mTouchAction = TOUCH_MOVE;
-                    final float yaw = mFov * -x_changed/(float)mSurfaceXDisplayRange;
-                    final float pitch = mFov * -y_changed/(float)mSurfaceXDisplayRange;
-                    mService.updateViewpoint(yaw, pitch, 0, 0, false);
-                }
-                break;
-            case MotionEvent.ACTION_UP:
-                if (mTouchAction == TOUCH_IGNORE) mTouchAction = TOUCH_NONE;
-                // Mouse events for the core
-                sendMouseEvent(MotionEvent.ACTION_UP, xTouch, yTouch);
-                // Seek
-                if (mTouchAction == TOUCH_SEEK)
-                    doSeekTouch(Math.round(delta_y), mIsRtl ? -xgesturesize : xgesturesize , true);
-                mTouchX = -1f;
-                mTouchY = -1f;
-                break;
-        }
-        return mTouchAction != TOUCH_NONE;
+        return mService != null && mTouchDelegate.onTouchEvent(event);
     }
 
-    private void doVerticalTouchAction(float y_changed) {
-        final boolean rightAction = (int) mTouchX > (4 * mScreen.widthPixels / 7f);
-        final boolean leftAction = !rightAction && (int) mTouchX < (3 * mScreen.widthPixels / 7f);
-        if (!leftAction && !rightAction)
-            return;
-        final boolean audio = (mTouchControls & TOUCH_FLAG_AUDIO_VOLUME) != 0;
-        final boolean brightness = (mTouchControls & TOUCH_FLAG_BRIGHTNESS) != 0;
-        if (!audio && !brightness)
-            return;
-        if (rightAction ^ mIsRtl) {
-            if (audio)
-                doVolumeTouch(y_changed);
-            else
-                doBrightnessTouch(y_changed);
-        } else {
-            if (brightness)
-                doBrightnessTouch(y_changed);
-            else
-                doVolumeTouch(y_changed);
-        }
-        hideOverlay(true);
+    boolean updateViewpoint(float yaw, float pitch) {
+        return mService.updateViewpoint(yaw, pitch, 0, 0, false);
     }
 
-    private void doSeekTouch(int coef, float gesturesize, boolean seek) {
-        if (coef == 0)
-            coef = 1;
-        // No seek action if coef > 0.5 and gesturesize < 1cm
-        if (Math.abs(gesturesize) < 1 || !mService.isSeekable())
-            return;
-
-        if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_SEEK)
-            return;
-        mTouchAction = TOUCH_SEEK;
-
-        long length = mService.getLength();
-        long time = getTime();
-
-        // Size of the jump, 10 minutes max (600000), with a bi-cubic progression, for a 8cm gesture
-        int jump = (int) ((Math.signum(gesturesize) * ((600000 * Math.pow((gesturesize / 8), 4)) + 3000)) / coef);
-
-        // Adjust the jump
-        if ((jump > 0) && ((time + jump) > length))
-            jump = (int) (length - time);
-        if ((jump < 0) && ((time + jump) < 0))
-            jump = (int) -time;
-
-        //Jump !
-        if (seek && length > 0)
-            seek(time + jump, length);
-
-        if (length > 0)
-            //Show the jump's size
-            showInfo(String.format("%s%s (%s)%s",
-                    jump >= 0 ? "+" : "",
-                    Tools.millisToString(jump),
-                    Tools.millisToString(time + jump),
-                    coef > 1 ? String.format(" x%.1g", 1.0/coef) : ""), 50);
-        else
-            showInfo(R.string.unseekable_stream, 1000);
+    void initAudioVolume() {
+        if (mService.getVolume() <= 100) {
+            mVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
+            mOriginalVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
+        }
+        else {
+            mVol = ((float)mService.getVolume()) * mAudioMax / 100;
+        }
     }
 
-    private void doVolumeTouch(float y_changed) {
-        if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_VOLUME)
-            return;
-        float delta = - ((y_changed / (float) mScreen.heightPixels) * mAudioMax);
-        mVol += delta;
-        int vol = (int) Math.min(Math.max(mVol, 0), mAudioMax * (audioBoostEnabled ? 2 : 1));
-        if (delta < 0)
-            mOriginalVol = vol;
-        if (delta != 0f) {
-            if (vol > mAudioMax) {
-                if (audioBoostEnabled) {
-                    if (mOriginalVol < mAudioMax) {
-                        displayWarningToast();
-                        setAudioVolume(mAudioMax);
-                    } else {
-                        setAudioVolume(vol);
-                    }
-                }
-            } else {
-                setAudioVolume(vol);
-            }
-        }
+    public void toggleOverlay() {
+        if (!mShowing) showOverlay();
+        else hideOverlay(true);
     }
 
     //Toast that appears only once
     public void displayWarningToast() {
-        if(warningToast != null)
-            warningToast.cancel();
+        if(warningToast != null) warningToast.cancel();
         warningToast = Toast.makeText(getApplication(), R.string.audio_boost_warning, Toast.LENGTH_SHORT);
         warningToast.show();
     }
 
-    private void setAudioVolume(int vol) {
+    void setAudioVolume(int vol) {
         if (AndroidUtil.isNougatOrLater && (vol <= 0 ^ mMute)) {
             mute(!mMute);
             return; //Android N+ throws "SecurityException: Not allowed to change Do Not Disturb state"
@@ -2255,7 +2053,6 @@ private void setAudioVolume(int vol) {
             vol = Math.round(vol * 100 / mAudioMax);
             mService.setVolume(Math.round(vol));
         }
-        mTouchAction = TOUCH_VOLUME;
         showInfoWithVerticalBar(getString(R.string.volume) + "\n" + Integer.toString(vol) + '%', 1000, vol, audioBoostEnabled ? 200 : 100);
     }
 
@@ -2271,46 +2068,7 @@ private void updateMute () {
         showInfo(mMute ? R.string.sound_off : R.string.sound_on, 1000);
     }
 
-    private void initBrightnessTouch() {
-        WindowManager.LayoutParams lp = getWindow().getAttributes();
-        float brightnesstemp = lp.screenBrightness != -1f ? lp.screenBrightness : 0.6f;
-        // Initialize the layoutParams screen brightness
-        try {
-            if (Settings.System.getInt(getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
-                if (!Permissions.canWriteSettings(this)) {
-                    Permissions.checkWriteSettingsPermission(this, Permissions.PERMISSION_SYSTEM_BRIGHTNESS);
-                    return;
-                }
-                Settings.System.putInt(getContentResolver(),
-                        Settings.System.SCREEN_BRIGHTNESS_MODE,
-                        Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
-                mRestoreAutoBrightness = android.provider.Settings.System.getInt(getContentResolver(),
-                        android.provider.Settings.System.SCREEN_BRIGHTNESS) / 255.0f;
-            } else if (brightnesstemp == 0.6f) {
-                brightnesstemp = android.provider.Settings.System.getInt(getContentResolver(),
-                        android.provider.Settings.System.SCREEN_BRIGHTNESS) / 255.0f;
-            }
-        } catch (SettingNotFoundException e) {
-            e.printStackTrace();
-        }
-        lp.screenBrightness = brightnesstemp;
-        getWindow().setAttributes(lp);
-        mIsFirstBrightnessGesture = false;
-    }
-
-    private void doBrightnessTouch(float y_changed) {
-        if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_BRIGHTNESS)
-            return;
-        if (mIsFirstBrightnessGesture) initBrightnessTouch();
-        mTouchAction = TOUCH_BRIGHTNESS;
-
-        // Set delta : 2f is arbitrary for now, it possibly will change in the future
-        float delta = - y_changed / mSurfaceYDisplayRange;
-
-        changeBrightness(delta);
-    }
-
-    private void changeBrightness(float delta) {
+    void changeBrightness(float delta) {
         // Estimate and adjust Brightness
         WindowManager.LayoutParams lp = getWindow().getAttributes();
         float brightness =  Math.min(Math.max(lp.screenBrightness + delta, 0.01f), 1f);
@@ -2319,7 +2077,7 @@ private void changeBrightness(float delta) {
         showInfoWithVerticalBar(getString(R.string.brightness) + "\n" + (int) brightness + '%', 1000, (int) brightness, 100);
     }
 
-    private void setWindowBrightness(float brightness) {
+    void setWindowBrightness(float brightness) {
         WindowManager.LayoutParams lp = getWindow().getAttributes();
         lp.screenBrightness =  brightness;
         // Set Brightness
@@ -2482,10 +2240,36 @@ public void toggleTimeDisplay() {
     }
 
     public void toggleLock() {
-        if (mIsLocked)
-            unlockScreen();
-        else
-            lockScreen();
+        if (mIsLocked) unlockScreen();
+        else lockScreen();
+    }
+
+    boolean isLoading() {
+        return mIsLoading;
+    }
+
+    boolean isShowing() {
+        return mShowing;
+    }
+
+    boolean isLocked() {
+        return mIsLocked;
+    }
+
+    float getFov() {
+        return mFov;
+    }
+
+    void setFov(float fov) {
+        mFov = fov;
+    }
+
+    boolean isOnPrimaryDisplay() {
+        return mDisplayManager.isPrimary();
+    }
+
+    public int getCurrentSize() {
+        return mCurrentSize;
     }
 
     public boolean toggleLoop(View v) {
@@ -2662,14 +2446,14 @@ protected void seek(long position) {
         seek(position, mService.getLength());
     }
 
-    private void seek(long position, long length) {
+    void seek(long position, long length) {
         mForcedTime = position;
         mLastTime = mService.getTime();
         mService.seek(position, length);
         mProgress.set((int) position);
     }
 
-    private void seekDelta(int delta) {
+    void seekDelta(int delta) {
         // unseekable stream
         if (mService.getLength() <= 0 || !mService.isSeekable()) return;
 
@@ -2697,7 +2481,7 @@ public void resizeVideo() {
         setVideoSurfacesize((mCurrentSize+1)%SURFACE_SIZE_COUNT);
     }
 
-    private void setVideoSurfacesize(int size) {
+    void setVideoSurfacesize(int size) {
         mCurrentSize = size;
         changeSurfaceLayout();
         switch (mCurrentSize) {
@@ -2723,7 +2507,6 @@ private void setVideoSurfacesize(int size) {
         mSettings.edit()
                 .putInt(PreferencesActivity.VIDEO_RATIO, mCurrentSize)
                 .apply();
-        showOverlay();
     }
 
     /**
@@ -2747,13 +2530,10 @@ private void showOverlay() {
      * show overlay
      */
     private void showOverlayTimeout(int timeout) {
-        if (mService == null)
-            return;
+        if (mService == null) return;
         initOverlay();
-        if (timeout != 0)
-            mOverlayTimeout = timeout;
-        else
-            mOverlayTimeout = mService.isPlaying() ? OVERLAY_TIMEOUT : OVERLAY_INFINITE;
+        if (timeout != 0) mOverlayTimeout = timeout;
+        else mOverlayTimeout = mService.isPlaying() ? OVERLAY_TIMEOUT : OVERLAY_INFINITE;
         if (mIsNavMenu){
             mShowing = true;
             return;
@@ -2850,7 +2630,7 @@ public void onChanged(@Nullable List<RendererItem> rendererItems) {
     /**
      * hider overlay
      */
-    private void hideOverlay(boolean fromUser) {
+    void hideOverlay(boolean fromUser) {
         if (mShowing) {
             mHandler.removeMessages(FADE_OUT);
             mHandler.removeMessages(SHOW_PROGRESS);
@@ -3369,8 +3149,8 @@ public void onDismiss(DialogInterface dialog) {
         hideOverlay(false);
     }
 
-    private void togglePlaylist() {
-        if (mPlaylist.getVisibility() == View.VISIBLE) {
+    void togglePlaylist() {
+        if (isPlaylistVisible()) {
             mPlaylist.setVisibility(View.GONE);
             mPlaylist.setOnClickListener(null);
             return;
@@ -3381,6 +3161,10 @@ private void togglePlaylist() {
         update();
     }
 
+    public boolean isPlaylistVisible() {
+        return mPlaylist.getVisibility() == View.VISIBLE;
+    }
+
     private final BroadcastReceiver mBtReceiver = new BroadcastReceiver() {
         @TargetApi(Build.VERSION_CODES.HONEYCOMB)
         @Override
@@ -3481,71 +3265,6 @@ else if (mMenuIdx != -1)
         supportInvalidateOptionsMenu();
     }
 
-    private ScaleGestureDetector.SimpleOnScaleGestureListener mScaleListener = new ScaleGestureDetector.SimpleOnScaleGestureListener() {
-
-        private int savedSize = -1;
-        @Override
-        public boolean onScaleBegin(ScaleGestureDetector detector) {
-            return mSurfaceXDisplayRange != 0 || mFov == 0f;
-        }
-
-        @Override
-        public boolean onScale(ScaleGestureDetector detector) {
-            if (mFov != 0f) {
-                float diff = DEFAULT_FOV * (1 - detector.getScaleFactor());
-                if (mService.updateViewpoint(0, 0, 0, diff, false)) {
-                    mFov = Math.min(Math.max(MIN_FOV, mFov + diff), MAX_FOV);
-                    return true;
-                }
-            }
-            return false;
-        }
-
-        @Override
-        public void onScaleEnd(ScaleGestureDetector detector) {
-            final boolean grow = detector.getScaleFactor() > 1.0f;
-            if (grow && mCurrentSize != SURFACE_FIT_SCREEN) {
-                savedSize = mCurrentSize;
-                setVideoSurfacesize(SURFACE_FIT_SCREEN);
-            } else if (!grow && savedSize != -1) {
-                setVideoSurfacesize(savedSize);
-                savedSize = -1;
-            }
-        }
-    };
-
-    private GestureDetector.SimpleOnGestureListener mGestureListener = new GestureDetector.SimpleOnGestureListener() {
-
-        @Override
-        public boolean onSingleTapUp(MotionEvent e) {
-            mHandler.sendEmptyMessageDelayed(mShowing ? HIDE_INFO : SHOW_INFO, 200);
-            return true;
-        }
-
-        @Override
-        public boolean onDoubleTap(MotionEvent e) {
-            mHandler.removeMessages(HIDE_INFO);
-            mHandler.removeMessages(SHOW_INFO);
-            float range = mCurrentScreenOrientation == Configuration.ORIENTATION_LANDSCAPE ? mSurfaceXDisplayRange : mSurfaceYDisplayRange;
-            if (mService == null) return false;
-            if (!mIsLocked) {
-                if ((mTouchControls & TOUCH_FLAG_SEEK) == 0) {
-                    doPlayPause();
-                    return true;
-                }
-                float x = e.getX();
-                if (x < range/4f)
-                    seekDelta(-10000);
-                else if (x > range*0.75)
-                    seekDelta(10000);
-                else
-                    doPlayPause();
-                return true;
-            }
-            return false;
-        }
-    };
-
     public PlaybackServiceActivity.Helper getHelper() {
         return mHelper;
     }
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt b/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt
new file mode 100644
index 0000000000..75caf26a2a
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt
@@ -0,0 +1,357 @@
+package org.videolan.vlc.gui.video
+
+import android.content.res.Configuration
+import android.media.AudioManager
+import android.provider.Settings
+import android.support.v4.view.GestureDetectorCompat
+import android.support.v4.view.ScaleGestureDetectorCompat
+import android.util.DisplayMetrics
+import android.view.*
+import org.videolan.medialibrary.Tools
+import org.videolan.vlc.R
+import org.videolan.vlc.VLCApplication
+import org.videolan.vlc.util.AndroidDevices
+import org.videolan.vlc.util.Permissions
+
+const val TOUCH_FLAG_AUDIO_VOLUME = 1
+const val TOUCH_FLAG_BRIGHTNESS = 1 shl 1
+const val TOUCH_FLAG_SEEK = 1 shl 2
+//Touch Events
+private const val TOUCH_NONE = 0
+private const val TOUCH_VOLUME = 1
+private const val TOUCH_BRIGHTNESS = 2
+private const val TOUCH_MOVE = 3
+private const val TOUCH_SEEK = 4
+private const val TOUCH_IGNORE = 5
+private const val MIN_FOV = 20f
+private const val MAX_FOV = 150f
+//stick event
+private const val JOYSTICK_INPUT_DELAY = 300
+
+class VideoTouchDelegate(private val player: VideoPlayerActivity,
+                         private val mTouchControls : Int,
+                         var screenConfig : ScreenConfig,
+                         private val rtl: Boolean) {
+
+    private var mTouchAction = TOUCH_NONE
+    private var mInitTouchY = 0f
+    private var mTouchY = -1f
+    private var mTouchX = -1f
+
+    private var mLastMove: Long = 0
+
+    private val mScaleGestureDetector by lazy(LazyThreadSafetyMode.NONE) {
+        ScaleGestureDetector(player, mScaleListener).apply { ScaleGestureDetectorCompat.setQuickScaleEnabled(this, false) }
+    }
+    private val mDetector by lazy(LazyThreadSafetyMode.NONE) {
+        GestureDetectorCompat(player, mGestureListener).apply { setOnDoubleTapListener(mGestureListener) }
+    }
+
+    // Brightness
+    private var mIsFirstBrightnessGesture = true
+
+    fun onTouchEvent(event: MotionEvent): Boolean {
+        if (player.isPlaybackSettingActive) {
+            if (event.action == MotionEvent.ACTION_UP) {
+                player.endPlaybackSetting()
+                mTouchAction = TOUCH_NONE
+            }
+            return true
+        } else if (player.isPlaylistVisible) {
+            mTouchAction = TOUCH_IGNORE
+            player.togglePlaylist()
+            return true
+        }
+        mScaleGestureDetector.onTouchEvent(event)
+        if (mScaleGestureDetector.isInProgress || mDetector.onTouchEvent(event)) {
+            mTouchAction = TOUCH_IGNORE
+            return true
+        }
+        if (mTouchControls == 0 || player.isLocked) {
+            // locked or swipe disabled, only handle show/hide & ignore all actions
+            if (event.action == MotionEvent.ACTION_UP && mTouchAction != TOUCH_IGNORE) player.toggleOverlay()
+            return false
+        }
+
+        val xChanged = if (mTouchX != -1f && mTouchY != -1f) event.rawX - mTouchX else 0f
+        val yChanged = if (xChanged != 0f) event.rawY - mTouchY else 0f
+
+        // coef is the gradient's move to determine a neutral zone
+        val coef = Math.abs(yChanged / xChanged)
+        val xgesturesize = xChanged / screenConfig.metrics.xdpi * 2.54f
+        val deltaY = Math.max(1f, (Math.abs(mInitTouchY - event.rawY) / screenConfig.metrics.xdpi + 0.5f) * 2f)
+
+        val xTouch = Math.round(event.rawX)
+        val yTouch = Math.round(event.rawY)
+
+        when (event.action) {
+            MotionEvent.ACTION_DOWN -> {
+                // Audio
+                mInitTouchY = event.rawY
+                mTouchY = mInitTouchY
+                player.initAudioVolume()
+                mTouchAction = TOUCH_NONE
+                // Seek
+                mTouchX = event.rawX
+                // Mouse events for the core
+                player.sendMouseEvent(MotionEvent.ACTION_DOWN, xTouch, yTouch)
+            }
+            MotionEvent.ACTION_MOVE -> {
+                if (mTouchAction != TOUCH_IGNORE) {// Mouse events for the core
+                    player.sendMouseEvent(MotionEvent.ACTION_MOVE, xTouch, yTouch)
+
+                    if (player.fov == 0f) {
+                        // No volume/brightness action if coef < 2 or a secondary display is connected
+                        //TODO : Volume action when a secondary display is connected
+                        if (mTouchAction != TOUCH_SEEK && coef > 2 && player.isOnPrimaryDisplay) {
+                            if (Math.abs(yChanged / screenConfig.yRange) < 0.05)
+                                return false
+                            mTouchY = event.rawY
+                            mTouchX = event.rawX
+                            doVerticalTouchAction(yChanged)
+                        } else {
+                            // Seek (Right or Left move)
+                            doSeekTouch(Math.round(deltaY), if (rtl) -xgesturesize else xgesturesize, false)
+                        }
+                    } else {
+                        mTouchY = event.rawY
+                        mTouchX = event.rawX
+                        mTouchAction = TOUCH_MOVE
+                        val yaw = player.fov * -xChanged / screenConfig.xRange.toFloat()
+                        val pitch = player.fov * -yChanged / screenConfig.xRange.toFloat()
+                        player.updateViewpoint(yaw, pitch)
+                    }
+                }
+            }
+            MotionEvent.ACTION_UP -> {
+                if (mTouchAction == TOUCH_IGNORE) mTouchAction = TOUCH_NONE
+                // Mouse events for the core
+                player.sendMouseEvent(MotionEvent.ACTION_UP, xTouch, yTouch)
+                // Seek
+                if (mTouchAction == TOUCH_SEEK) doSeekTouch(Math.round(deltaY), if (rtl) -xgesturesize else xgesturesize, true)
+                mTouchX = -1f
+                mTouchY = -1f
+            }
+        }
+        return mTouchAction != TOUCH_NONE
+    }
+
+    fun dispatchGenericMotionEvent(event: MotionEvent): Boolean {
+        if (player.isLoading) return false
+        //Check for a joystick event
+        if (event.source and InputDevice.SOURCE_JOYSTICK != InputDevice.SOURCE_JOYSTICK || event.action != MotionEvent.ACTION_MOVE)
+            return false
+
+        val mInputDevice = event.device
+
+        val dpadx = event.getAxisValue(MotionEvent.AXIS_HAT_X)
+        val dpady = event.getAxisValue(MotionEvent.AXIS_HAT_Y)
+        if (mInputDevice == null || Math.abs(dpadx) == 1.0f || Math.abs(dpady) == 1.0f) return false
+
+        val x = AndroidDevices.getCenteredAxis(event, mInputDevice, MotionEvent.AXIS_X)
+        val y = AndroidDevices.getCenteredAxis(event, mInputDevice, MotionEvent.AXIS_Y)
+        val rz = AndroidDevices.getCenteredAxis(event, mInputDevice, MotionEvent.AXIS_RZ)
+
+        if (System.currentTimeMillis() - mLastMove > JOYSTICK_INPUT_DELAY) {
+            if (Math.abs(x) > 0.3) {
+                if (VLCApplication.showTvUi()) {
+                    player.navigateDvdMenu(if (x > 0.0f) KeyEvent.KEYCODE_DPAD_RIGHT else KeyEvent.KEYCODE_DPAD_LEFT)
+                } else
+                    player.seekDelta(if (x > 0.0f) 10000 else -10000)
+            } else if (Math.abs(y) > 0.3) {
+                if (VLCApplication.showTvUi())
+                    player.navigateDvdMenu(if (x > 0.0f) KeyEvent.KEYCODE_DPAD_UP else KeyEvent.KEYCODE_DPAD_DOWN)
+                else {
+                    if (mIsFirstBrightnessGesture)
+                        initBrightnessTouch()
+                    player.changeBrightness(-y / 10f)
+                }
+            } else if (Math.abs(rz) > 0.3) {
+                player.volume = player.audiomanager.getStreamVolume(AudioManager.STREAM_MUSIC).toFloat()
+                val delta = -(rz / 7 * player.audioMax).toInt()
+                val vol = Math.min(Math.max(player.volume + delta, 0f), player.audioMax.toFloat()).toInt()
+                player.setAudioVolume(vol)
+            }
+            mLastMove = System.currentTimeMillis()
+        }
+        return true
+    }
+
+    fun isSeeking() = mTouchAction == TOUCH_SEEK
+
+    fun clearTouchAction() {
+        mTouchAction = TOUCH_NONE
+    }
+
+    private fun doVerticalTouchAction(y_changed: Float) {
+        val rightAction = mTouchX.toInt() > 4 * screenConfig.metrics.widthPixels / 7f
+        val leftAction = !rightAction && mTouchX.toInt() < 3 * screenConfig.metrics.widthPixels / 7f
+        if (!leftAction && !rightAction) return
+        val audio = mTouchControls and TOUCH_FLAG_AUDIO_VOLUME != 0
+        val brightness = mTouchControls and TOUCH_FLAG_BRIGHTNESS != 0
+        if (!audio && !brightness)
+            return
+        if (rightAction xor rtl) {
+            if (audio) doVolumeTouch(y_changed)
+            else doBrightnessTouch(y_changed)
+        } else {
+            if (brightness) doBrightnessTouch(y_changed)
+            else doVolumeTouch(y_changed)
+        }
+        player.hideOverlay(true)
+    }
+
+    private fun doSeekTouch(coef: Int, gesturesize: Float, seek: Boolean) {
+        var coef = coef
+        if (coef == 0) coef = 1
+        // No seek action if coef > 0.5 and gesturesize < 1cm
+        if (Math.abs(gesturesize) < 1 || !player.mService.isSeekable) return
+
+        if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_SEEK) return
+        mTouchAction = TOUCH_SEEK
+
+        val length = player.mService.length
+        val time = player.mService.time
+
+        // Size of the jump, 10 minutes max (600000), with a bi-cubic progression, for a 8cm gesture
+        var jump = (Math.signum(gesturesize) * (600000 * Math.pow((gesturesize / 8).toDouble(), 4.0) + 3000) / coef).toInt()
+
+        // Adjust the jump
+        if (jump > 0 && time + jump > length) jump = (length - time).toInt()
+        if (jump < 0 && time + jump < 0) jump = (-time).toInt()
+
+        //Jump !
+        if (seek && length > 0) player.seek(time + jump, length)
+
+        //Show the jump's size
+        if (length > 0) player.showInfo(String.format("%s%s (%s)%s",
+                    if (jump >= 0) "+" else "",
+                    Tools.millisToString(jump.toLong()),
+                    Tools.millisToString(time + jump),
+                    if (coef > 1) String.format(" x%.1g", 1.0 / coef) else ""), 50)
+        else player.showInfo(R.string.unseekable_stream, 1000)
+    }
+
+    private fun doVolumeTouch(y_changed: Float) {
+        if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_VOLUME) return
+        val audioMax = player.audioMax
+        val delta = -(y_changed / screenConfig.metrics.heightPixels.toFloat() * audioMax)
+        player.volume += delta
+        val vol = Math.min(Math.max(player.volume, 0f), (audioMax * if (player.isAudioBoostEnabled) 2 else 1).toFloat()).toInt()
+        if (delta < 0) player.originalVol = vol.toFloat()
+        if (delta != 0f) {
+            if (vol > audioMax) {
+                if (player.isAudioBoostEnabled) {
+                    if (player.originalVol < audioMax) {
+                        player.displayWarningToast()
+                        player.setAudioVolume(audioMax)
+                    } else {
+                        player.setAudioVolume(vol)
+                    }
+                    mTouchAction = TOUCH_VOLUME
+                }
+            } else {
+                player.setAudioVolume(vol)
+                mTouchAction = TOUCH_VOLUME
+            }
+        }
+    }
+
+    private fun initBrightnessTouch() {
+        val lp = player.window.attributes
+        var brightnesstemp = if (lp.screenBrightness != -1f) lp.screenBrightness else 0.6f
+        // Initialize the layoutParams screen brightness
+        try {
+            val cr = player.contentResolver
+            if (Settings.System.getInt(cr, Settings.System.SCREEN_BRIGHTNESS_MODE) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
+                if (!Permissions.canWriteSettings(player)) {
+                    Permissions.checkWriteSettingsPermission(player, Permissions.PERMISSION_SYSTEM_BRIGHTNESS)
+                    return
+                }
+                Settings.System.putInt(cr,
+                        Settings.System.SCREEN_BRIGHTNESS_MODE,
+                        Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL)
+                player.setSavedBrightness(android.provider.Settings.System.getInt(cr,
+                        android.provider.Settings.System.SCREEN_BRIGHTNESS) / 255.0f)
+            } else if (brightnesstemp == 0.6f) {
+                brightnesstemp = android.provider.Settings.System.getInt(cr,
+                        android.provider.Settings.System.SCREEN_BRIGHTNESS) / 255.0f
+            }
+        } catch (e: Settings.SettingNotFoundException) {}
+
+        lp.screenBrightness = brightnesstemp
+        player.window.attributes = lp
+        mIsFirstBrightnessGesture = false
+    }
+
+    private fun doBrightnessTouch(y_changed: Float) {
+        if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_BRIGHTNESS) return
+        if (mIsFirstBrightnessGesture) initBrightnessTouch()
+        mTouchAction = TOUCH_BRIGHTNESS
+
+        // Set delta : 2f is arbitrary for now, it possibly will change in the future
+        val delta = -y_changed / screenConfig.yRange
+
+        player.changeBrightness(delta)
+    }
+
+    private val mScaleListener = object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
+
+        private var savedSize = -1
+        override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
+            return screenConfig.xRange != 0 || player.fov == 0f
+        }
+
+        override fun onScale(detector: ScaleGestureDetector): Boolean {
+            if (player.fov != 0f) {
+                val diff = VideoPlayerActivity.DEFAULT_FOV * (1 - detector.scaleFactor)
+                if (player.updateViewpoint(0f, 0f)) {
+                    player.fov = Math.min(Math.max(MIN_FOV, player.fov + diff), MAX_FOV)
+                    return true
+                }
+            }
+            return false
+        }
+
+        override fun onScaleEnd(detector: ScaleGestureDetector) {
+            val grow = detector.scaleFactor > 1.0f
+            if (grow && player.currentSize != VideoPlayerActivity.SURFACE_FIT_SCREEN) {
+                savedSize = player.currentSize
+                player.setVideoSurfacesize(VideoPlayerActivity.SURFACE_FIT_SCREEN)
+            } else if (!grow && savedSize != -1) {
+                player.setVideoSurfacesize(savedSize)
+                savedSize = -1
+            }
+        }
+    }
+
+    private val mGestureListener = object : GestureDetector.SimpleOnGestureListener() {
+
+        override fun onSingleTapUp(e: MotionEvent): Boolean {
+            player.handler.sendEmptyMessageDelayed(if (player.isShowing) VideoPlayerActivity.HIDE_INFO else VideoPlayerActivity.SHOW_INFO, 200)
+            return true
+        }
+
+        override fun onDoubleTap(e: MotionEvent): Boolean {
+            player.handler.removeMessages(VideoPlayerActivity.HIDE_INFO)
+            player.handler.removeMessages(VideoPlayerActivity.SHOW_INFO)
+            val range = (if (screenConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) screenConfig.xRange else screenConfig.yRange).toFloat()
+            if (!player.isLocked) {
+                if (mTouchControls and TOUCH_FLAG_SEEK == 0) {
+                    player.doPlayPause()
+                    return true
+                }
+                val x = e.x
+                when {
+                    x < range / 4f -> player.seekDelta(-10000)
+                    x > range * 0.75 -> player.seekDelta(10000)
+                    else -> player.doPlayPause()
+                }
+                return true
+            }
+            return false
+        }
+    }
+}
+
+data class ScreenConfig(val metrics: DisplayMetrics, val xRange: Int, val yRange: Int, val orientation: Int)
\ No newline at end of file
