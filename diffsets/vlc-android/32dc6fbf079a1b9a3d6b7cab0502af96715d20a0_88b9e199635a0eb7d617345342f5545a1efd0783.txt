diff --git a/vlc-android/AndroidManifest.xml b/vlc-android/AndroidManifest.xml
index 48d592bf74..0f1fa7204f 100644
--- a/vlc-android/AndroidManifest.xml
+++ b/vlc-android/AndroidManifest.xml
@@ -161,6 +161,11 @@
                 android:name="android.appwidget.provider"
                 android:resource="@xml/vlcwidget" />
         </receiver>
+        <receiver android:name="RemoteControlClientReceiver">
+            <intent-filter>
+                <action android:name="android.intent.action.MEDIA_BUTTON" />
+            </intent-filter>
+        </receiver>
     </application>
 
 </manifest>
diff --git a/vlc-android/src/org/videolan/vlc/AudioService.java b/vlc-android/src/org/videolan/vlc/AudioService.java
index 32742f2cda..bfd157633f 100644
--- a/vlc-android/src/org/videolan/vlc/AudioService.java
+++ b/vlc-android/src/org/videolan/vlc/AudioService.java
@@ -40,6 +40,7 @@
 import android.app.PendingIntent;
 import android.app.Service;
 import android.content.BroadcastReceiver;
+import android.content.ComponentName;
 import android.content.ContentResolver;
 import android.content.Context;
 import android.content.Intent;
@@ -49,6 +50,9 @@
 import android.graphics.BitmapFactory;
 import android.media.AudioManager;
 import android.media.AudioManager.OnAudioFocusChangeListener;
+import android.media.MediaMetadataRetriever;
+import android.media.RemoteControlClient;
+import android.media.RemoteControlClient.MetadataEditor;
 import android.net.Uri;
 import android.os.Handler;
 import android.os.IBinder;
@@ -88,6 +92,20 @@ public class AudioService extends Service {
     private long mHeadsetDownTime = 0;
     private long mHeadsetUpTime = 0;
 
+    /**
+     * The RemoteControlClient class doesn't exist at all <ICS, so we need
+     * to cache some constants.
+     */
+    private static class RemoteControlClientConstants {
+        public static final int PLAYSTATE_STOPPED = 1;
+        public static final int PLAYSTATE_PAUSED = 2;
+        public static final int PLAYSTATE_PLAYING = 3;
+    }
+    /**
+     * RemoteControlClient is for lock screen playback control.
+     */
+    private RemoteControlClient mRemoteControlClient = null;
+
     /**
      * Distinguish between the "fake" (Java-backed) playlist versus the "real"
      * (LibVLC/LibVLCcore) backed playlist.
@@ -125,6 +143,48 @@ public void onCreate() {
         filter.addAction(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
         filter.addAction(Intent.ACTION_MEDIA_BUTTON);
         registerReceiver(serviceReceiver, filter);
+
+        if(Util.isICSOrLater())
+            setUpRemoteControlClient();
+    }
+
+    @TargetApi(14)
+    private void setUpRemoteControlClient() {
+        if(!Util.isICSOrLater()) // sanity check
+            return;
+
+        AudioManager audioManager = (AudioManager)getSystemService(AUDIO_SERVICE);
+        ComponentName eventReceiverComponent = new ComponentName(getPackageName(), RemoteControlClientReceiver.class.getName());
+
+        audioManager.registerMediaButtonEventReceiver(eventReceiverComponent);
+
+        Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+        mediaButtonIntent.setComponent(eventReceiverComponent);
+        PendingIntent mediaPendingIntent = PendingIntent.getBroadcast(getApplicationContext(), 0, mediaButtonIntent, 0);
+
+        // create and register the remote control client
+        mRemoteControlClient = new RemoteControlClient(mediaPendingIntent);
+        mRemoteControlClient.setTransportControlFlags(
+                RemoteControlClient.FLAG_KEY_MEDIA_PLAY |
+                RemoteControlClient.FLAG_KEY_MEDIA_PAUSE |
+                RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS |
+                RemoteControlClient.FLAG_KEY_MEDIA_NEXT |
+                RemoteControlClient.FLAG_KEY_MEDIA_STOP);
+        audioManager.registerRemoteControlClient(mRemoteControlClient);
+    }
+
+    /**
+     * A function to control the Remote Control Client. It is needed for
+     * compatibility with devices below Ice Cream Sandwich (4.0).
+     *
+     * @param p Playback state
+     */
+    @TargetApi(14)
+    private void setRemoteControlClientPlaybackState(int p) {
+        if(!Util.isICSOrLater())
+            return;
+
+        mRemoteControlClient.setPlaybackState(p);
     }
 
     @Override
@@ -320,16 +380,19 @@ public void handleMessage(Message msg) {
                 case EventManager.MediaPlayerPlaying:
                     Log.i(TAG, "MediaPlayerPlaying");
                     service.changeAudioFocus(true);
+                    service.setRemoteControlClientPlaybackState(RemoteControlClientConstants.PLAYSTATE_PLAYING);
                     break;
                 case EventManager.MediaPlayerPaused:
                     Log.i(TAG, "MediaPlayerPaused");
                     service.executeUpdate();
                     // also hide notification if phone ringing
                     service.hideNotification();
+                    service.setRemoteControlClientPlaybackState(RemoteControlClientConstants.PLAYSTATE_PAUSED);
                     break;
                 case EventManager.MediaPlayerStopped:
                     Log.i(TAG, "MediaPlayerStopped");
                     service.executeUpdate();
+                    service.setRemoteControlClientPlaybackState(RemoteControlClientConstants.PLAYSTATE_STOPPED);
                     break;
                 case EventManager.MediaPlayerEndReached:
                     Log.i(TAG, "MediaPlayerEndReached");
@@ -440,6 +503,7 @@ private void play() {
     private void stop() {
         mEventManager.removeHandler(mEventHandler);
         mLibVLC.stop();
+        setRemoteControlClientPlaybackState(RemoteControlClientConstants.PLAYSTATE_STOPPED);
         mCurrentMedia = null;
         mMediaList.clear();
         mPrevious.clear();
@@ -481,6 +545,22 @@ else if(mRepeating == RepeatType.Once)
         mHandler.sendEmptyMessage(SHOW_PROGRESS);
         showNotification();
         updateWidget(this);
+        updateRemoteControlClientMetadata();
+    }
+
+    @TargetApi(14)
+    private void updateRemoteControlClientMetadata() {
+        if(!Util.isICSOrLater()) // NOP check
+            return;
+
+        MetadataEditor editor = mRemoteControlClient.editMetadata(true);
+        editor.putString(MediaMetadataRetriever.METADATA_KEY_ALBUM, mCurrentMedia.getAlbum());
+        editor.putString(MediaMetadataRetriever.METADATA_KEY_ARTIST, mCurrentMedia.getArtist());
+        editor.putString(MediaMetadataRetriever.METADATA_KEY_GENRE, mCurrentMedia.getGenre());
+        editor.putString(MediaMetadataRetriever.METADATA_KEY_TITLE, mCurrentMedia.getTitle());
+        editor.putLong(MediaMetadataRetriever.METADATA_KEY_DURATION, mCurrentMedia.getLength());
+        editor.putBitmap(MetadataEditor.BITMAP_KEY_ARTWORK, getCover());
+        editor.apply();
     }
 
     private void previous() {
@@ -504,6 +584,7 @@ else if(mRepeating == RepeatType.Once)
         mHandler.sendEmptyMessage(SHOW_PROGRESS);
         showNotification();
         updateWidget(this);
+        updateRemoteControlClientMetadata();
     }
 
     private void shuffle() {
@@ -735,6 +816,7 @@ public void load(List<String> mediaPathList, int position, boolean libvlcBacked)
                 }
                 showNotification();
                 updateWidget(AudioService.this);
+                updateRemoteControlClientMetadata();
             }
         }
 
diff --git a/vlc-android/src/org/videolan/vlc/RemoteControlClientReceiver.java b/vlc-android/src/org/videolan/vlc/RemoteControlClientReceiver.java
new file mode 100644
index 0000000000..9a07b1efda
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/RemoteControlClientReceiver.java
@@ -0,0 +1,75 @@
+/*****************************************************************************
+ * RemoteControlClientReceiver.java
+ *****************************************************************************
+ * Copyright Â© 2012 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+package org.videolan.vlc;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.view.KeyEvent;
+
+/**
+ * Small class to receive events passed out by the lockscreen control.
+ */
+public class RemoteControlClientReceiver extends BroadcastReceiver {
+    @SuppressWarnings("unused")
+    private static final String TAG = "VLC/RemoteControlClientReceiver";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        LibVLC mLibVLC;
+        try {
+            mLibVLC = LibVLC.getInstance();
+        } catch (LibVlcException e) {
+            return;
+        }
+        if(mLibVLC == null)
+            return;
+
+        if(action.equalsIgnoreCase(Intent.ACTION_MEDIA_BUTTON)) {
+            if (intent.getAction().equals(Intent.ACTION_MEDIA_BUTTON)) {
+                KeyEvent keyEvent = (KeyEvent) intent.getExtras().get(Intent.EXTRA_KEY_EVENT);
+                if (keyEvent.getAction() != KeyEvent.ACTION_DOWN)
+                    return;
+
+                Intent i = null;
+                switch (keyEvent.getKeyCode()) {
+                    case KeyEvent.KEYCODE_HEADSETHOOK:
+                    case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
+                    case KeyEvent.KEYCODE_MEDIA_PLAY:
+                    case KeyEvent.KEYCODE_MEDIA_PAUSE:
+                        i = new Intent(AudioService.ACTION_WIDGET_PLAY);
+                        break;
+                    case KeyEvent.KEYCODE_MEDIA_STOP:
+                        i = new Intent(AudioService.ACTION_WIDGET_STOP);
+                        break;
+                    case KeyEvent.KEYCODE_MEDIA_NEXT:
+                        i = new Intent(AudioService.ACTION_WIDGET_FORWARD);
+                        break;
+                    case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
+                        i = new Intent(AudioService.ACTION_WIDGET_BACKWARD);
+                        break;
+                }
+                if(i != null)
+                    context.sendBroadcast(i);
+            }
+        }
+    }
+}
