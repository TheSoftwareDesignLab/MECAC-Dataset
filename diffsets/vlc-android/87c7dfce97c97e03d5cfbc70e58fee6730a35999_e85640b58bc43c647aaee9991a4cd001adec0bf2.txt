diff --git a/java-libs/SlidingMenu/.classpath b/java-libs/SlidingMenu/.classpath
deleted file mode 100644
index c8e53d5f6c..0000000000
--- a/java-libs/SlidingMenu/.classpath
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.LIBRARIES"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="gen"/>
-	<classpathentry kind="con" path="com.android.ide.eclipse.adt.ANDROID_FRAMEWORK"/>
-	<classpathentry exported="true" kind="con" path="com.android.ide.eclipse.adt.DEPENDENCIES"/>
-	<classpathentry kind="output" path="bin/classes"/>
-</classpath>
diff --git a/java-libs/SlidingMenu/.project b/java-libs/SlidingMenu/.project
deleted file mode 100644
index 347838b998..0000000000
--- a/java-libs/SlidingMenu/.project
+++ /dev/null
@@ -1,33 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SlidingMenu</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ResourceManagerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.PreCompilerBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-		<buildCommand>
-			<name>com.android.ide.eclipse.adt.ApkBuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>com.android.ide.eclipse.adt.AndroidNature</nature>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/java-libs/SlidingMenu/AndroidManifest.xml b/java-libs/SlidingMenu/AndroidManifest.xml
deleted file mode 100644
index a551abf42a..0000000000
--- a/java-libs/SlidingMenu/AndroidManifest.xml
+++ /dev/null
@@ -1,11 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.slidingmenu.lib"
-    android:versionCode="1"
-    android:versionName="1.0" >
-
-    <uses-sdk
-        android:minSdkVersion="5"
-        android:targetSdkVersion="17" />
-
-</manifest>
\ No newline at end of file
diff --git a/java-libs/SlidingMenu/LICENSE.txt b/java-libs/SlidingMenu/LICENSE.txt
deleted file mode 100644
index 7a4a3ea242..0000000000
--- a/java-libs/SlidingMenu/LICENSE.txt
+++ /dev/null
@@ -1,202 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
\ No newline at end of file
diff --git a/java-libs/SlidingMenu/build.xml b/java-libs/SlidingMenu/build.xml
deleted file mode 100644
index f60a254fc8..0000000000
--- a/java-libs/SlidingMenu/build.xml
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project name="SlidingMenu" default="help">
-
-    <!-- The local.properties file is created and updated by the 'android' tool.
-         It contains the path to the SDK. It should *NOT* be checked into
-         Version Control Systems. -->
-    <property file="local.properties" />
-
-    <!-- The ant.properties file can be created by you. It is only edited by the
-         'android' tool to add properties to it.
-         This is the place to change some Ant specific build properties.
-         Here are some properties you may want to change/update:
-
-         source.dir
-             The name of the source directory. Default is 'src'.
-         out.dir
-             The name of the output directory. Default is 'bin'.
-
-         For other overridable properties, look at the beginning of the rules
-         files in the SDK, at tools/ant/build.xml
-
-         Properties related to the SDK location or the project target should
-         be updated using the 'android' tool with the 'update' action.
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems.
-
-         -->
-    <property file="ant.properties" />
-
-    <!-- if sdk.dir was not set from one of the property file, then
-         get it from the ANDROID_HOME env var.
-         This must be done before we load project.properties since
-         the proguard config can use sdk.dir -->
-    <property environment="env" />
-    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
-        <isset property="env.ANDROID_HOME" />
-    </condition>
-
-    <!-- The project.properties file is created and updated by the 'android'
-         tool, as well as ADT.
-
-         This contains project specific properties such as project target, and library
-         dependencies. Lower level build properties are stored in ant.properties
-         (or in .classpath for Eclipse projects).
-
-         This file is an integral part of the build system for your
-         application and should be checked into Version Control Systems. -->
-    <loadproperties srcFile="project.properties" />
-
-    <!-- quick check on sdk.dir -->
-    <fail
-            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
-            unless="sdk.dir"
-    />
-
-    <!--
-        Import per project custom build rules if present at the root of the project.
-        This is the place to put custom intermediary targets such as:
-            -pre-build
-            -pre-compile
-            -post-compile (This is typically used for code obfuscation.
-                           Compiled code location: ${out.classes.absolute.dir}
-                           If this is not done in place, override ${out.dex.input.absolute.dir})
-            -post-package
-            -post-build
-            -pre-clean
-    -->
-    <import file="custom_rules.xml" optional="true" />
-
-    <!-- Import the actual build file.
-
-         To customize existing targets, there are two options:
-         - Customize only one target:
-             - copy/paste the target into this file, *before* the
-               <import> task.
-             - customize it to your needs.
-         - Customize the whole content of build.xml
-             - copy/paste the content of the rules files (minus the top node)
-               into this file, replacing the <import> task.
-             - customize to your needs.
-
-         ***********************
-         ****** IMPORTANT ******
-         ***********************
-         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
-         in order to avoid having your file be overridden by tools such as "android update project"
-    -->
-    <!-- version-tag: 1 -->
-    <import file="${sdk.dir}/tools/ant/build.xml" />
-
-</project>
diff --git a/java-libs/SlidingMenu/libs/android-support-v4.jar b/java-libs/SlidingMenu/libs/android-support-v4.jar
deleted file mode 100644
index c31cede47e..0000000000
Binary files a/java-libs/SlidingMenu/libs/android-support-v4.jar and /dev/null differ
diff --git a/java-libs/SlidingMenu/pom.xml b/java-libs/SlidingMenu/pom.xml
deleted file mode 100644
index 55779c3953..0000000000
--- a/java-libs/SlidingMenu/pom.xml
+++ /dev/null
@@ -1,51 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-	<modelVersion>4.0.0</modelVersion>
-
-	<artifactId>slidingmenu</artifactId>
-	<name>SlidingMenu</name>
-	<packaging>apklib</packaging>
-
-	<parent>
-		<groupId>com.slidingmenu</groupId>
-		<artifactId>parent</artifactId>
-		<version>1.2</version>
-		<relativePath>../pom.xml</relativePath>
-	</parent>
-
-	<dependencies>
-		<dependency>
-			<groupId>com.google.android</groupId>
-			<artifactId>android</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>com.google.android.maps</groupId>
-			<artifactId>maps</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>com.google.android</groupId>
-			<artifactId>support-v4</artifactId>
-		</dependency>
-		<dependency>
-			<groupId>com.actionbarsherlock</groupId>
-			<artifactId>actionbarsherlock</artifactId>
-			<type>apklib</type>
-		</dependency>
-	</dependencies>
-
-	<build>
-		<sourceDirectory>src</sourceDirectory>
-
-		<plugins>
-			<plugin>
-				<groupId>com.jayway.maven.plugins.android.generation2</groupId>
-				<artifactId>android-maven-plugin</artifactId>
-				<extensions>true</extensions>
-				<configuration>
-					<nativeLibrariesDirectory>ignored</nativeLibrariesDirectory>
-				</configuration>
-			</plugin>
-		</plugins>
-	</build>
-</project>
diff --git a/java-libs/SlidingMenu/project.properties b/java-libs/SlidingMenu/project.properties
deleted file mode 100644
index c57400d008..0000000000
--- a/java-libs/SlidingMenu/project.properties
+++ /dev/null
@@ -1,12 +0,0 @@
-# This file is automatically generated by Android Tools.
-# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
-#
-# This file must be checked in Version Control Systems.
-#
-# To customize properties used by the Ant build system use,
-# "ant.properties", and override values to adapt the script to your
-# project structure.
-
-android.library=true
-# Project target.
-target=android-19
diff --git a/java-libs/SlidingMenu/res/layout/slidingmenumain.xml b/java-libs/SlidingMenu/res/layout/slidingmenumain.xml
deleted file mode 100644
index babd82b8e7..0000000000
--- a/java-libs/SlidingMenu/res/layout/slidingmenumain.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<com.slidingmenu.lib.SlidingMenu xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@+id/slidingmenumain"
-    android:layout_width="fill_parent"
-    android:layout_height="fill_parent" />
\ No newline at end of file
diff --git a/java-libs/SlidingMenu/res/values/attrs.xml b/java-libs/SlidingMenu/res/values/attrs.xml
deleted file mode 100644
index d5ee00f327..0000000000
--- a/java-libs/SlidingMenu/res/values/attrs.xml
+++ /dev/null
@@ -1,45 +0,0 @@
-<!--
-  Copyright 2011 The Android Open Source Project
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-
-<resources>
-
-    <declare-styleable name="SlidingMenu">
-        <attr name="mode">
-            <enum name="left" value="0" />
-            <enum name="right" value="1" />
-        </attr>
-        <attr name="viewAbove" format="reference" />
-        <attr name="viewBehind" format="reference" />
-        <attr name="behindOffset" format="dimension" />
-        <attr name="behindWidth" format="dimension" />
-        <attr name="behindScrollScale" format="float" />
-        <attr name="touchModeAbove">
-            <enum name="margin" value="0" />
-            <enum name="fullscreen" value="1" />
-        </attr>
-        <attr name="touchModeBehind">
-            <enum name="margin" value="0" />
-            <enum name="fullscreen" value="1" />
-        </attr>
-        <attr name="shadowDrawable" format="reference" />
-        <attr name="shadowWidth" format="dimension" />
-        <attr name="fadeEnabled" format="boolean" />
-        <attr name="fadeDegree" format="float" />
-        <attr name="selectorEnabled" format="boolean" />
-        <attr name="selectorDrawable" format="reference" />
-    </declare-styleable>
-
-</resources>
\ No newline at end of file
diff --git a/java-libs/SlidingMenu/res/values/ids.xml b/java-libs/SlidingMenu/res/values/ids.xml
deleted file mode 100644
index eac70c9a9c..0000000000
--- a/java-libs/SlidingMenu/res/values/ids.xml
+++ /dev/null
@@ -1,5 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-    <item name="selected_view" type="id"/>
-    
-</resources>
\ No newline at end of file
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/CanvasTransformerBuilder.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/CanvasTransformerBuilder.java
deleted file mode 100644
index 22dbc2a331..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/CanvasTransformerBuilder.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package com.slidingmenu.lib;
-
-import android.graphics.Canvas;
-import android.view.animation.Interpolator;
-
-import com.slidingmenu.lib.SlidingMenu.CanvasTransformer;
-
-public class CanvasTransformerBuilder {
-
-	private CanvasTransformer mTrans;
-
-	private static Interpolator lin = new Interpolator() {
-		public float getInterpolation(float t) {
-			return t;
-		}
-	};
-
-	private void initTransformer() {
-		if (mTrans == null)
-			mTrans = new CanvasTransformer() {
-			public void transformCanvas(Canvas canvas, float percentOpen) {	}
-		};
-	}
-
-	public CanvasTransformer zoom(final int openedX, final int closedX, 
-			final int openedY, final int closedY, 
-			final int px, final int py) {
-		return zoom(openedX, closedX, openedY, closedY, px, py, lin);
-	}
-
-	public CanvasTransformer zoom(final int openedX, final int closedX, 
-			final int openedY, final int closedY,
-			final int px, final int py, final Interpolator interp) {
-		initTransformer();
-		mTrans = new CanvasTransformer() {
-			public void transformCanvas(Canvas canvas, float percentOpen) {
-				mTrans.transformCanvas(canvas, percentOpen);
-				float f = interp.getInterpolation(percentOpen);
-				canvas.scale((openedX - closedX) * f + closedX,
-						(openedY - closedY) * f + closedY, px, py);
-			}			
-		};
-		return mTrans;
-	}
-
-	public CanvasTransformer rotate(final int openedDeg, final int closedDeg, 
-			final int px, final int py) {
-		return rotate(openedDeg, closedDeg, px, py, lin);
-	}
-
-	public CanvasTransformer rotate(final int openedDeg, final int closedDeg, 
-			final int px, final int py, final Interpolator interp) {
-		initTransformer();
-		mTrans = new CanvasTransformer() {
-			public void transformCanvas(Canvas canvas, float percentOpen) {
-				mTrans.transformCanvas(canvas, percentOpen);
-				float f = interp.getInterpolation(percentOpen);
-				canvas.rotate((openedDeg - closedDeg) * f + closedDeg, 
-						px, py);
-			}			
-		};
-		return mTrans;
-	}
-
-	public CanvasTransformer translate(final int openedX, final int closedX, 
-			final int openedY, final int closedY) {
-		return translate(openedX, closedX, openedY, closedY, lin);
-	}
-
-	public CanvasTransformer translate(final int openedX, final int closedX, 
-			final int openedY, final int closedY, final Interpolator interp) {
-		initTransformer();
-		mTrans = new CanvasTransformer() {
-			public void transformCanvas(Canvas canvas, float percentOpen) {
-				mTrans.transformCanvas(canvas, percentOpen);
-				float f = interp.getInterpolation(percentOpen);
-				canvas.translate((openedX - closedX) * f + closedX,
-						(openedY - closedY) * f + closedY);
-			}			
-		};
-		return mTrans;
-	}
-
-	public CanvasTransformer concatTransformer(final CanvasTransformer t) {
-		initTransformer();
-		mTrans = new CanvasTransformer() {
-			public void transformCanvas(Canvas canvas, float percentOpen) {
-				mTrans.transformCanvas(canvas, percentOpen);
-				t.transformCanvas(canvas, percentOpen);
-			}			
-		};
-		return mTrans;
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/CustomViewAbove.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/CustomViewAbove.java
deleted file mode 100644
index 1412f1b477..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/CustomViewAbove.java
+++ /dev/null
@@ -1,1011 +0,0 @@
-package com.slidingmenu.lib;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Rect;
-import android.os.Build;
-import android.support.v4.view.KeyEventCompat;
-import android.support.v4.view.MotionEventCompat;
-import android.support.v4.view.VelocityTrackerCompat;
-import android.support.v4.view.ViewCompat;
-import android.support.v4.view.ViewConfigurationCompat;
-import android.util.AttributeSet;
-import android.util.FloatMath;
-import android.util.Log;
-import android.view.FocusFinder;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.SoundEffectConstants;
-import android.view.VelocityTracker;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.ViewGroup;
-import android.view.animation.Interpolator;
-import android.widget.Scroller;
-
-import com.slidingmenu.lib.SlidingMenu.OnClosedListener;
-import com.slidingmenu.lib.SlidingMenu.OnOpenedListener;
-//import com.slidingmenu.lib.SlidingMenu.OnCloseListener;
-//import com.slidingmenu.lib.SlidingMenu.OnOpenListener;
-
-public class CustomViewAbove extends ViewGroup {
-
-	private static final String TAG = "CustomViewAbove";
-	private static final boolean DEBUG = false;
-
-	private static final boolean USE_CACHE = false;
-
-	private static final int MAX_SETTLE_DURATION = 600; // ms
-	private static final int MIN_DISTANCE_FOR_FLING = 25; // dips
-
-	private static final Interpolator sInterpolator = new Interpolator() {
-		public float getInterpolation(float t) {
-			t -= 1.0f;
-			return t * t * t * t * t + 1.0f;
-		}
-	};
-
-	private View mContent;
-
-	private int mCurItem;
-	private Scroller mScroller;
-
-	private boolean mScrollingCacheEnabled;
-
-	private boolean mScrolling;
-
-	private boolean mIsBeingDragged;
-	private boolean mIsUnableToDrag;
-	private int mTouchSlop;
-	private float mInitialMotionX;
-	/**
-	 * Position of the last motion event.
-	 */
-	private float mLastMotionX;
-	private float mLastMotionY;
-	/**
-	 * ID of the active pointer. This is used to retain consistency during
-	 * drags/flings if multiple pointers are used.
-	 */
-	protected int mActivePointerId = INVALID_POINTER;
-	/**
-	 * Sentinel value for no current active pointer.
-	 * Used by {@link #mActivePointerId}.
-	 */
-	private static final int INVALID_POINTER = -1;
-
-	/**
-	 * Determines speed during touch scrolling
-	 */
-	protected VelocityTracker mVelocityTracker;
-	private int mMinimumVelocity;
-	protected int mMaximumVelocity;
-	private int mFlingDistance;
-
-	private CustomViewBehind mViewBehind;
-	//	private int mMode;
-	private boolean mEnabled = true;
-
-	private OnPageChangeListener mOnPageChangeListener;
-	private OnPageChangeListener mInternalPageChangeListener;
-
-	//	private OnCloseListener mCloseListener;
-	//	private OnOpenListener mOpenListener;
-	private OnClosedListener mClosedListener;
-	private OnOpenedListener mOpenedListener;
-
-	private List<View> mIgnoredViews = new ArrayList<View>();
-
-	//	private int mScrollState = SCROLL_STATE_IDLE;
-
-	/**
-	 * Callback interface for responding to changing state of the selected page.
-	 */
-	public interface OnPageChangeListener {
-
-		/**
-		 * This method will be invoked when the current page is scrolled, either as part
-		 * of a programmatically initiated smooth scroll or a user initiated touch scroll.
-		 *
-		 * @param position Position index of the first page currently being displayed.
-		 *                 Page position+1 will be visible if positionOffset is nonzero.
-		 * @param positionOffset Value from [0, 1) indicating the offset from the page at position.
-		 * @param positionOffsetPixels Value in pixels indicating the offset from position.
-		 */
-		public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);
-
-		/**
-		 * This method will be invoked when a new page becomes selected. Animation is not
-		 * necessarily complete.
-		 *
-		 * @param position Position index of the new selected page.
-		 */
-		public void onPageSelected(int position);
-
-	}
-
-	/**
-	 * Simple implementation of the {@link OnPageChangeListener} interface with stub
-	 * implementations of each method. Extend this if you do not intend to override
-	 * every method of {@link OnPageChangeListener}.
-	 */
-	public static class SimpleOnPageChangeListener implements OnPageChangeListener {
-
-		public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-			// This space for rent
-		}
-
-		public void onPageSelected(int position) {
-			// This space for rent
-		}
-
-		public void onPageScrollStateChanged(int state) {
-			// This space for rent
-		}
-
-	}
-
-	public CustomViewAbove(Context context) {
-		this(context, null);
-	}
-
-	public CustomViewAbove(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		initCustomViewAbove();
-	}
-
-	void initCustomViewAbove() {
-		setWillNotDraw(false);
-		setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
-		setFocusable(true);
-		final Context context = getContext();
-		mScroller = new Scroller(context, sInterpolator);
-		final ViewConfiguration configuration = ViewConfiguration.get(context);
-		mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
-		mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
-		mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
-		setInternalPageChangeListener(new SimpleOnPageChangeListener() {
-			public void onPageSelected(int position) {
-				if (mViewBehind != null) {
-					switch (position) {
-					case 0:
-					case 2:
-						mViewBehind.setChildrenEnabled(true);
-						break;
-					case 1:
-						mViewBehind.setChildrenEnabled(false);
-						break;
-					}
-				}
-			}
-		});
-
-		final float density = context.getResources().getDisplayMetrics().density;
-		mFlingDistance = (int) (MIN_DISTANCE_FOR_FLING * density);
-	}
-
-	/**
-	 * Set the currently selected page. If the CustomViewPager has already been through its first
-	 * layout there will be a smooth animated transition between the current item and the
-	 * specified item.
-	 *
-	 * @param item Item index to select
-	 */
-	public void setCurrentItem(int item) {
-		setCurrentItemInternal(item, true, false);
-	}
-
-	/**
-	 * Set the currently selected page.
-	 *
-	 * @param item Item index to select
-	 * @param smoothScroll True to smoothly scroll to the new item, false to transition immediately
-	 */
-	public void setCurrentItem(int item, boolean smoothScroll) {
-		setCurrentItemInternal(item, smoothScroll, false);
-	}
-
-	public int getCurrentItem() {
-		return mCurItem;
-	}
-
-	void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {
-		setCurrentItemInternal(item, smoothScroll, always, 0);
-	}
-
-	void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) {
-		if (!always && mCurItem == item) {
-			setScrollingCacheEnabled(false);
-			return;
-		}
-
-		item = mViewBehind.getMenuPage(item);
-
-		final boolean dispatchSelected = mCurItem != item;
-		mCurItem = item;
-		final int destX = getDestScrollX(mCurItem);
-		if (dispatchSelected && mOnPageChangeListener != null) {
-			mOnPageChangeListener.onPageSelected(item);
-		}
-		if (dispatchSelected && mInternalPageChangeListener != null) {
-			mInternalPageChangeListener.onPageSelected(item);
-		}
-		if (smoothScroll) {
-			smoothScrollTo(destX, 0, velocity);
-		} else {
-			completeScroll();
-			scrollTo(destX, 0);
-		}
-	}
-
-	/**
-	 * Set a listener that will be invoked whenever the page changes or is incrementally
-	 * scrolled. See {@link OnPageChangeListener}.
-	 *
-	 * @param listener Listener to set
-	 */
-	public void setOnPageChangeListener(OnPageChangeListener listener) {
-		mOnPageChangeListener = listener;
-	}
-	/*
-	public void setOnOpenListener(OnOpenListener l) {
-		mOpenListener = l;
-	}
-
-	public void setOnCloseListener(OnCloseListener l) {
-		mCloseListener = l;
-	}
-	 */
-	public void setOnOpenedListener(OnOpenedListener l) {
-		mOpenedListener = l;
-	}
-
-	public void setOnClosedListener(OnClosedListener l) {
-		mClosedListener = l;
-	}
-
-	/**
-	 * Set a separate OnPageChangeListener for internal use by the support library.
-	 *
-	 * @param listener Listener to set
-	 * @return The old listener that was set, if any.
-	 */
-	OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener) {
-		OnPageChangeListener oldListener = mInternalPageChangeListener;
-		mInternalPageChangeListener = listener;
-		return oldListener;
-	}
-
-	public void addIgnoredView(View v) {
-		if (!mIgnoredViews.contains(v)) {
-			mIgnoredViews.add(v);
-		}
-	}
-
-	public void removeIgnoredView(View v) {
-		mIgnoredViews.remove(v);
-	}
-
-	public void clearIgnoredViews() {
-		mIgnoredViews.clear();
-	}
-
-	// We want the duration of the page snap animation to be influenced by the distance that
-	// the screen has to travel, however, we don't want this duration to be effected in a
-	// purely linear fashion. Instead, we use this method to moderate the effect that the distance
-	// of travel has on the overall snap duration.
-	float distanceInfluenceForSnapDuration(float f) {
-		f -= 0.5f; // center the values about 0.
-		f *= 0.3f * Math.PI / 2.0f;
-		return (float) FloatMath.sin(f);
-	}
-
-	public int getDestScrollX(int page) {
-		switch (page) {
-		case 0:
-		case 2:
-			return mViewBehind.getMenuLeft(mContent, page);
-		case 1:
-			return mContent.getLeft();
-		}
-		return 0;
-	}
-
-	private int getLeftBound() {
-		return mViewBehind.getAbsLeftBound(mContent);
-	}
-
-	private int getRightBound() {
-		return mViewBehind.getAbsRightBound(mContent);
-	}
-
-	public int getContentLeft() {
-		return mContent.getLeft() + mContent.getPaddingLeft();
-	}
-
-	public boolean isMenuOpen() {
-		return mCurItem == 0 || mCurItem == 2;
-	}
-
-	private boolean isInIgnoredView(MotionEvent ev) {
-		Rect rect = new Rect();
-		for (View v : mIgnoredViews) {
-			v.getHitRect(rect);
-			if (rect.contains((int)ev.getX(), (int)ev.getY())) return true;
-		}
-		return false;
-	}
-
-	public int getBehindWidth() {
-		if (mViewBehind == null) {
-			return 0;
-		} else {
-			return mViewBehind.getBehindWidth();
-		}
-	}
-
-	public int getChildWidth(int i) {
-		switch (i) {
-		case 0:
-			return getBehindWidth();
-		case 1:
-			return mContent.getWidth();
-		default:
-			return 0;
-		}
-	}
-
-	public boolean isSlidingEnabled() {
-		return mEnabled;
-	}
-
-	public void setSlidingEnabled(boolean b) {
-		mEnabled = b;
-	}
-
-	/**
-	 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
-	 *
-	 * @param x the number of pixels to scroll by on the X axis
-	 * @param y the number of pixels to scroll by on the Y axis
-	 */
-	void smoothScrollTo(int x, int y) {
-		smoothScrollTo(x, y, 0);
-	}
-
-	/**
-	 * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
-	 *
-	 * @param x the number of pixels to scroll by on the X axis
-	 * @param y the number of pixels to scroll by on the Y axis
-	 * @param velocity the velocity associated with a fling, if applicable. (0 otherwise)
-	 */
-	void smoothScrollTo(int x, int y, int velocity) {
-		if (getChildCount() == 0) {
-			// Nothing to do.
-			setScrollingCacheEnabled(false);
-			return;
-		}
-		int sx = getScrollX();
-		int sy = getScrollY();
-		int dx = x - sx;
-		int dy = y - sy;
-		if (dx == 0 && dy == 0) {
-			completeScroll();
-			if (isMenuOpen()) {
-				if (mOpenedListener != null)
-					mOpenedListener.onOpened();
-			} else {
-				if (mClosedListener != null)
-					mClosedListener.onClosed();
-			}
-			return;
-		}
-
-		setScrollingCacheEnabled(true);
-		mScrolling = true;
-
-		final int width = getBehindWidth();
-		final int halfWidth = width / 2;
-		final float distanceRatio = Math.min(1f, 1.0f * Math.abs(dx) / width);
-		final float distance = halfWidth + halfWidth *
-				distanceInfluenceForSnapDuration(distanceRatio);
-
-		int duration = 0;
-		velocity = Math.abs(velocity);
-		if (velocity > 0) {
-			duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
-		} else {
-			final float pageDelta = (float) Math.abs(dx) / width;
-			duration = (int) ((pageDelta + 1) * 100);
-			duration = MAX_SETTLE_DURATION;
-		}
-		duration = Math.min(duration, MAX_SETTLE_DURATION);
-
-		mScroller.startScroll(sx, sy, dx, dy, duration);
-		invalidate();
-	}
-
-	public void setContent(View v) {
-		if (mContent != null) 
-			this.removeView(mContent);
-		mContent = v;
-		addView(mContent);
-	}
-
-	public View getContent() {
-		return mContent;
-	}
-
-	public void setCustomViewBehind(CustomViewBehind cvb) {
-		mViewBehind = cvb;
-	}
-
-	@Override
-	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-
-		int width = getDefaultSize(0, widthMeasureSpec);
-		int height = getDefaultSize(0, heightMeasureSpec);
-		setMeasuredDimension(width, height);
-
-		final int contentWidth = getChildMeasureSpec(widthMeasureSpec, 0, width);
-		final int contentHeight = getChildMeasureSpec(heightMeasureSpec, 0, height);
-		mContent.measure(contentWidth, contentHeight);
-	}
-
-	@Override
-	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
-		super.onSizeChanged(w, h, oldw, oldh);
-		// Make sure scroll position is set correctly.
-		if (w != oldw) {
-			// [ChrisJ] - This fixes the onConfiguration change for orientation issue..
-			// maybe worth having a look why the recomputeScroll pos is screwing
-			// up?
-			completeScroll();
-			scrollTo(getDestScrollX(mCurItem), getScrollY());
-		}
-	}
-
-	@Override
-	protected void onLayout(boolean changed, int l, int t, int r, int b) {
-		final int width = r - l;
-		final int height = b - t;
-		mContent.layout(0, 0, width, height);
-	}
-
-	public void setAboveOffset(int i) {
-		//		RelativeLayout.LayoutParams params = ((RelativeLayout.LayoutParams)mContent.getLayoutParams());
-		//		params.setMargins(i, params.topMargin, params.rightMargin, params.bottomMargin);
-		mContent.setPadding(i, mContent.getPaddingTop(), 
-				mContent.getPaddingRight(), mContent.getPaddingBottom());
-	}
-
-
-	@Override
-	public void computeScroll() {
-		if (!mScroller.isFinished()) {
-			if (mScroller.computeScrollOffset()) {
-				int oldX = getScrollX();
-				int oldY = getScrollY();
-				int x = mScroller.getCurrX();
-				int y = mScroller.getCurrY();
-
-				if (oldX != x || oldY != y) {
-					scrollTo(x, y);
-					pageScrolled(x);
-				}
-
-				// Keep on drawing until the animation has finished.
-				invalidate();
-				return;
-			}
-		}
-
-		// Done with scroll, clean up state.
-		completeScroll();
-	}
-
-	private void pageScrolled(int xpos) {
-		final int widthWithMargin = getWidth();
-		final int position = xpos / widthWithMargin;
-		final int offsetPixels = xpos % widthWithMargin;
-		final float offset = (float) offsetPixels / widthWithMargin;
-
-		onPageScrolled(position, offset, offsetPixels);
-	}
-
-	/**
-	 * This method will be invoked when the current page is scrolled, either as part
-	 * of a programmatically initiated smooth scroll or a user initiated touch scroll.
-	 * If you override this method you must call through to the superclass implementation
-	 * (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled
-	 * returns.
-	 *
-	 * @param position Position index of the first page currently being displayed.
-	 *                 Page position+1 will be visible if positionOffset is nonzero.
-	 * @param offset Value from [0, 1) indicating the offset from the page at position.
-	 * @param offsetPixels Value in pixels indicating the offset from position.
-	 */
-	protected void onPageScrolled(int position, float offset, int offsetPixels) {
-		if (mOnPageChangeListener != null) {
-			mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);
-		}
-		if (mInternalPageChangeListener != null) {
-			mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
-		}
-	}
-
-	private void completeScroll() {
-		boolean needPopulate = mScrolling;
-		if (needPopulate) {
-			// Done with scroll, no longer want to cache view drawing.
-			setScrollingCacheEnabled(false);
-			mScroller.abortAnimation();
-			int oldX = getScrollX();
-			int oldY = getScrollY();
-			int x = mScroller.getCurrX();
-			int y = mScroller.getCurrY();
-			if (oldX != x || oldY != y) {
-				scrollTo(x, y);
-			}
-			if (isMenuOpen()) {
-				if (mOpenedListener != null)
-					mOpenedListener.onOpened();
-			} else {
-				if (mClosedListener != null)
-					mClosedListener.onClosed();
-			}
-		}
-		mScrolling = false;
-	}
-
-	protected int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
-
-	public void setTouchMode(int i) {
-		mTouchMode = i;
-	}
-
-	public int getTouchMode() {
-		return mTouchMode;
-	}
-
-	private boolean thisTouchAllowed(MotionEvent ev) {
-		int x = (int) (ev.getX() + mScrollX);
-		if (isMenuOpen()) {
-			return mViewBehind.menuOpenTouchAllowed(mContent, mCurItem, x);
-		} else {
-			switch (mTouchMode) {
-			case SlidingMenu.TOUCHMODE_FULLSCREEN:
-				return !isInIgnoredView(ev);
-			case SlidingMenu.TOUCHMODE_NONE:
-				return false;
-			case SlidingMenu.TOUCHMODE_MARGIN:
-				return mViewBehind.marginTouchAllowed(mContent, x);
-			}
-		}
-		return false;
-	}
-
-	private boolean thisSlideAllowed(float dx) {
-		boolean allowed = false;
-		if (isMenuOpen()) {
-			allowed = mViewBehind.menuOpenSlideAllowed(dx);
-		} else {
-			allowed = mViewBehind.menuClosedSlideAllowed(dx);
-		}
-		if (DEBUG)
-			Log.v(TAG, "this slide allowed " + allowed + " dx: " + dx);
-		return allowed;
-	}
-
-	private int getPointerIndex(MotionEvent ev, int id) {
-		int activePointerIndex = MotionEventCompat.findPointerIndex(ev, id);
-		if (activePointerIndex == -1)
-			mActivePointerId = INVALID_POINTER;
-		return activePointerIndex;
-	}
-
-	private boolean mQuickReturn = false;
-
-	@Override
-	public boolean onInterceptTouchEvent(MotionEvent ev) {
-
-		if (!mEnabled)
-			return false;
-
-		final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
-
-		if (DEBUG)
-			if (action == MotionEvent.ACTION_DOWN)
-				Log.v(TAG, "Received ACTION_DOWN");
-
-		if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP
-				|| (action != MotionEvent.ACTION_DOWN && mIsUnableToDrag)) {
-			endDrag();
-			return false;
-		}
-
-		switch (action) {
-		case MotionEvent.ACTION_MOVE:
-			determineDrag(ev);
-			break;
-		case MotionEvent.ACTION_DOWN:
-			int index = MotionEventCompat.getActionIndex(ev);
-			mActivePointerId = MotionEventCompat.getPointerId(ev, index);
-			if (mActivePointerId == INVALID_POINTER)
-				break;
-			mLastMotionX = mInitialMotionX = MotionEventCompat.getX(ev, index);
-			mLastMotionY = MotionEventCompat.getY(ev, index);
-			if (thisTouchAllowed(ev)) {
-				mIsBeingDragged = false;
-				mIsUnableToDrag = false;
-				if (isMenuOpen() && mViewBehind.menuTouchInQuickReturn(mContent, mCurItem, ev.getX() + mScrollX)) {
-					mQuickReturn = true;
-				}
-			} else {
-				mIsUnableToDrag = true;
-			}
-			break;
-		case MotionEventCompat.ACTION_POINTER_UP:
-			onSecondaryPointerUp(ev);
-			break;
-		}
-
-		if (!mIsBeingDragged) {
-			if (mVelocityTracker == null) {
-				mVelocityTracker = VelocityTracker.obtain();
-			}
-			mVelocityTracker.addMovement(ev);
-		}
-		return mIsBeingDragged || mQuickReturn;
-	}
-
-
-	@Override
-	public boolean onTouchEvent(MotionEvent ev) {
-
-		if (!mEnabled)
-			return false;
-
-		if (!mIsBeingDragged && !thisTouchAllowed(ev))
-			return false;
-
-		//		if (!mIsBeingDragged && !mQuickReturn)
-		//			return false;
-
-		final int action = ev.getAction();
-
-		if (mVelocityTracker == null) {
-			mVelocityTracker = VelocityTracker.obtain();
-		}
-		mVelocityTracker.addMovement(ev);
-
-		switch (action & MotionEventCompat.ACTION_MASK) {
-		case MotionEvent.ACTION_DOWN:
-			/*
-			 * If being flinged and user touches, stop the fling. isFinished
-			 * will be false if being flinged.
-			 */
-			completeScroll();
-
-			// Remember where the motion event started
-			int index = MotionEventCompat.getActionIndex(ev);
-			mActivePointerId = MotionEventCompat.getPointerId(ev, index);
-			mLastMotionX = mInitialMotionX = ev.getX();
-			break;
-		case MotionEvent.ACTION_MOVE:
-			if (!mIsBeingDragged) {	
-				determineDrag(ev);
-				if (mIsUnableToDrag)
-					return false;
-			}
-			if (mIsBeingDragged) {
-				// Scroll to follow the motion event
-				final int activePointerIndex = getPointerIndex(ev, mActivePointerId);
-				if (mActivePointerId == INVALID_POINTER)
-					break;
-				final float x = MotionEventCompat.getX(ev, activePointerIndex);
-				final float deltaX = mLastMotionX - x;
-				mLastMotionX = x;
-				float oldScrollX = getScrollX();
-				float scrollX = oldScrollX + deltaX;
-				final float leftBound = getLeftBound();
-				final float rightBound = getRightBound();
-				if (scrollX < leftBound) {
-					scrollX = leftBound;
-				} else if (scrollX > rightBound) {
-					scrollX = rightBound;
-				}
-				// Don't lose the rounded component
-				mLastMotionX += scrollX - (int) scrollX;
-				scrollTo((int) scrollX, getScrollY());
-				pageScrolled((int) scrollX);
-			}
-			break;
-		case MotionEvent.ACTION_UP:
-			if (mIsBeingDragged) {
-				final VelocityTracker velocityTracker = mVelocityTracker;
-				velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
-				int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(
-						velocityTracker, mActivePointerId);
-				final int scrollX = getScrollX();
-				//				final int widthWithMargin = getWidth();
-				//				final float pageOffset = (float) (scrollX % widthWithMargin) / widthWithMargin;
-				// TODO test this. should get better flinging behavior
-				final float pageOffset = (float) (scrollX - getDestScrollX(mCurItem)) / getBehindWidth();
-				final int activePointerIndex = getPointerIndex(ev, mActivePointerId);
-				if (mActivePointerId != INVALID_POINTER) {
-					final float x = MotionEventCompat.getX(ev, activePointerIndex);
-					final int totalDelta = (int) (x - mInitialMotionX);
-					int nextPage = determineTargetPage(pageOffset, initialVelocity, totalDelta);
-					setCurrentItemInternal(nextPage, true, true, initialVelocity);
-				} else {	
-					setCurrentItemInternal(mCurItem, true, true, initialVelocity);
-				}
-				mActivePointerId = INVALID_POINTER;
-				endDrag();
-			} else if (mQuickReturn && mViewBehind.menuTouchInQuickReturn(mContent, mCurItem, ev.getX() + mScrollX)) {
-				// close the menu
-				setCurrentItem(1);
-				endDrag();
-			}
-			break;
-		case MotionEvent.ACTION_CANCEL:
-			if (mIsBeingDragged) {
-				setCurrentItemInternal(mCurItem, true, true);
-				mActivePointerId = INVALID_POINTER;
-				endDrag();
-			}
-			break;
-		case MotionEventCompat.ACTION_POINTER_DOWN: {
-			final int indexx = MotionEventCompat.getActionIndex(ev);
-			mLastMotionX = MotionEventCompat.getX(ev, indexx);
-			mActivePointerId = MotionEventCompat.getPointerId(ev, indexx);
-			break;
-		}
-		case MotionEventCompat.ACTION_POINTER_UP:
-			onSecondaryPointerUp(ev);
-			int pointerIndex = getPointerIndex(ev, mActivePointerId);
-			if (mActivePointerId == INVALID_POINTER)
-				break;
-			mLastMotionX = MotionEventCompat.getX(ev, pointerIndex);
-			break;
-		}
-		return true;
-	}
-	
-	private void determineDrag(MotionEvent ev) {
-		final int activePointerId = mActivePointerId;
-		final int pointerIndex = getPointerIndex(ev, activePointerId);
-		if (activePointerId == INVALID_POINTER)
-			return;
-		final float x = MotionEventCompat.getX(ev, pointerIndex);
-		final float dx = x - mLastMotionX;
-		final float xDiff = Math.abs(dx);
-		final float y = MotionEventCompat.getY(ev, pointerIndex);
-		final float dy = y - mLastMotionY;
-		final float yDiff = Math.abs(dy);
-		if (xDiff > (isMenuOpen()?mTouchSlop/2:mTouchSlop) && xDiff > yDiff && thisSlideAllowed(dx)) {		
-			startDrag();
-			mLastMotionX = x;
-			mLastMotionY = y;
-			setScrollingCacheEnabled(true);
-			// TODO add back in touch slop check
-		} else if (xDiff > mTouchSlop) {
-			mIsUnableToDrag = true;
-		}
-	}
-
-	@Override
-	public void scrollTo(int x, int y) {
-		super.scrollTo(x, y);
-		mScrollX = x;
-		if (mEnabled)
-			mViewBehind.scrollBehindTo(mContent, x, y);	
-		((SlidingMenu)getParent()).manageLayers(getPercentOpen());
-	}
-
-	private int determineTargetPage(float pageOffset, int velocity, int deltaX) {
-		int targetPage = mCurItem;
-		if (Math.abs(deltaX) > mFlingDistance && Math.abs(velocity) > mMinimumVelocity) {
-			if (velocity > 0 && deltaX > 0) {
-				targetPage -= 1;
-			} else if (velocity < 0 && deltaX < 0){
-				targetPage += 1;
-			}
-		} else {
-			targetPage = (int) Math.round(mCurItem + pageOffset);
-		}
-		return targetPage;
-	}
-
-	protected float getPercentOpen() {
-		return Math.abs(mScrollX-mContent.getLeft()) / getBehindWidth();
-	}
-
-	@Override
-	protected void dispatchDraw(Canvas canvas) {
-		super.dispatchDraw(canvas);
-		// Draw the margin drawable if needed.
-		mViewBehind.drawShadow(mContent, canvas);
-		mViewBehind.drawFade(mContent, canvas, getPercentOpen());
-		mViewBehind.drawSelector(mContent, canvas, getPercentOpen());
-	}
-
-	// variables for drawing
-	private float mScrollX = 0.0f;
-
-	private void onSecondaryPointerUp(MotionEvent ev) {
-		if (DEBUG) Log.v(TAG, "onSecondaryPointerUp called");
-		final int pointerIndex = MotionEventCompat.getActionIndex(ev);
-		final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
-		if (pointerId == mActivePointerId) {
-			// This was our active pointer going up. Choose a new
-			// active pointer and adjust accordingly.
-			final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
-			mLastMotionX = MotionEventCompat.getX(ev, newPointerIndex);
-			mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
-			if (mVelocityTracker != null) {
-				mVelocityTracker.clear();
-			}
-		}
-	}
-
-	private void startDrag() {
-		mIsBeingDragged = true;
-		mQuickReturn = false;
-	}
-
-	private void endDrag() {
-		mQuickReturn = false;
-		mIsBeingDragged = false;
-		mIsUnableToDrag = false;
-		mActivePointerId = INVALID_POINTER;
-
-		if (mVelocityTracker != null) {
-			mVelocityTracker.recycle();
-			mVelocityTracker = null;
-		}
-	}
-
-	private void setScrollingCacheEnabled(boolean enabled) {
-		if (mScrollingCacheEnabled != enabled) {
-			mScrollingCacheEnabled = enabled;
-			if (USE_CACHE) {
-				final int size = getChildCount();
-				for (int i = 0; i < size; ++i) {
-					final View child = getChildAt(i);
-					if (child.getVisibility() != GONE) {
-						child.setDrawingCacheEnabled(enabled);
-					}
-				}
-			}
-		}
-	}
-
-	/**
-	 * Tests scrollability within child views of v given a delta of dx.
-	 *
-	 * @param v View to test for horizontal scrollability
-	 * @param checkV Whether the view v passed should itself be checked for scrollability (true),
-	 *               or just its children (false).
-	 * @param dx Delta scrolled in pixels
-	 * @param x X coordinate of the active touch point
-	 * @param y Y coordinate of the active touch point
-	 * @return true if child views of v can be scrolled by delta of dx.
-	 */
-	protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
-		if (v instanceof ViewGroup) {
-			final ViewGroup group = (ViewGroup) v;
-			final int scrollX = v.getScrollX();
-			final int scrollY = v.getScrollY();
-			final int count = group.getChildCount();
-			// Count backwards - let topmost views consume scroll distance first.
-			for (int i = count - 1; i >= 0; i--) {
-				final View child = group.getChildAt(i);
-				if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() &&
-						y + scrollY >= child.getTop() && y + scrollY < child.getBottom() &&
-						canScroll(child, true, dx, x + scrollX - child.getLeft(),
-								y + scrollY - child.getTop())) {
-					return true;
-				}
-			}
-		}
-
-		return checkV && ViewCompat.canScrollHorizontally(v, -dx);
-	}
-
-
-	@Override
-	public boolean dispatchKeyEvent(KeyEvent event) {
-		// Let the focused view and/or our descendants get the key first
-		return super.dispatchKeyEvent(event) || executeKeyEvent(event);
-	}
-
-	/**
-	 * You can call this function yourself to have the scroll view perform
-	 * scrolling from a key event, just as if the event had been dispatched to
-	 * it by the view hierarchy.
-	 *
-	 * @param event The key event to execute.
-	 * @return Return true if the event was handled, else false.
-	 */
-	public boolean executeKeyEvent(KeyEvent event) {
-		boolean handled = false;
-		if (event.getAction() == KeyEvent.ACTION_DOWN) {
-			switch (event.getKeyCode()) {
-			case KeyEvent.KEYCODE_DPAD_LEFT:
-				handled = arrowScroll(FOCUS_LEFT);
-				break;
-			case KeyEvent.KEYCODE_DPAD_RIGHT:
-				handled = arrowScroll(FOCUS_RIGHT);
-				break;
-			case KeyEvent.KEYCODE_TAB:
-				if (Build.VERSION.SDK_INT >= 11) {
-					// The focus finder had a bug handling FOCUS_FORWARD and FOCUS_BACKWARD
-					// before Android 3.0. Ignore the tab key on those devices.
-					if (KeyEventCompat.hasNoModifiers(event)) {
-						handled = arrowScroll(FOCUS_FORWARD);
-					} else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {
-						handled = arrowScroll(FOCUS_BACKWARD);
-					}
-				}
-				break;
-			}
-		}
-		return handled;
-	}
-
-	public boolean arrowScroll(int direction) {
-		View currentFocused = findFocus();
-		if (currentFocused == this) currentFocused = null;
-
-		boolean handled = false;
-
-		View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused,
-				direction);
-		if (nextFocused != null && nextFocused != currentFocused) {
-			if (direction == View.FOCUS_LEFT) {
-				handled = nextFocused.requestFocus();
-			} else if (direction == View.FOCUS_RIGHT) {
-				// If there is nothing to the right, or this is causing us to
-				// jump to the left, then what we really want to do is page right.
-				if (currentFocused != null && nextFocused.getLeft() <= currentFocused.getLeft()) {
-					handled = pageRight();
-				} else {
-					handled = nextFocused.requestFocus();
-				}
-			}
-		} else if (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD) {
-			// Trying to move left and nothing there; try to page.
-			handled = pageLeft();
-		} else if (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) {
-			// Trying to move right and nothing there; try to page.
-			handled = pageRight();
-		}
-		if (handled) {
-			playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
-		}
-		return handled;
-	}
-
-	boolean pageLeft() {
-		if (mCurItem > 0) {
-			setCurrentItem(mCurItem-1, true);
-			return true;
-		}
-		return false;
-	}
-
-	boolean pageRight() {
-		if (mCurItem < 1) {
-			setCurrentItem(mCurItem+1, true);
-			return true;
-		}
-		return false;
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/CustomViewBehind.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/CustomViewBehind.java
deleted file mode 100644
index 1432d4ae14..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/CustomViewBehind.java
+++ /dev/null
@@ -1,431 +0,0 @@
-package com.slidingmenu.lib;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.drawable.Drawable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-
-import com.slidingmenu.lib.SlidingMenu.CanvasTransformer;
-
-public class CustomViewBehind extends ViewGroup {
-
-	private static final String TAG = "CustomViewBehind";
-
-	private static final int MARGIN_THRESHOLD = 48; // dips
-	private int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
-
-	private CustomViewAbove mViewAbove;
-
-	private View mContent;
-	private View mSecondaryContent;
-	private int mMarginThreshold;
-	private int mWidthOffset;
-	private CanvasTransformer mTransformer;
-	private boolean mChildrenEnabled;
-
-	public CustomViewBehind(Context context) {
-		this(context, null);
-	}
-
-	public CustomViewBehind(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		mMarginThreshold = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 
-				MARGIN_THRESHOLD, getResources().getDisplayMetrics());
-	}
-
-	public void setCustomViewAbove(CustomViewAbove customViewAbove) {
-		mViewAbove = customViewAbove;
-	}
-
-	public void setCanvasTransformer(CanvasTransformer t) {
-		mTransformer = t;
-	}
-
-	public void setWidthOffset(int i) {
-		mWidthOffset = i;
-		requestLayout();
-	}
-
-	public int getBehindWidth() {
-		return mContent.getWidth();
-	}
-
-	public void setContent(View v) {
-		if (mContent != null)
-			removeView(mContent);
-		mContent = v;
-		addView(mContent);
-	}
-
-	public View getContent() {
-		return mContent;
-	}
-
-	/**
-	 * Sets the secondary (right) menu for use when setMode is called with SlidingMenu.LEFT_RIGHT.
-	 * @param v the right menu
-	 */
-	public void setSecondaryContent(View v) {
-		if (mSecondaryContent != null)
-			removeView(mSecondaryContent);
-		mSecondaryContent = v;
-		addView(mSecondaryContent);
-	}
-
-	public View getSecondaryContent() {
-		return mSecondaryContent;
-	}
-
-	public void setChildrenEnabled(boolean enabled) {
-		mChildrenEnabled = enabled;
-	}
-
-	@Override
-	public void scrollTo(int x, int y) {
-		super.scrollTo(x, y);
-		if (mTransformer != null)
-			invalidate();
-	}
-
-	@Override
-	public boolean onInterceptTouchEvent(MotionEvent e) {
-		return !mChildrenEnabled;
-	}
-
-	@Override
-	public boolean onTouchEvent(MotionEvent e) {
-		return !mChildrenEnabled;
-	}
-
-	@Override
-	protected void dispatchDraw(Canvas canvas) {
-		if (mTransformer != null) {
-			canvas.save();
-			mTransformer.transformCanvas(canvas, mViewAbove.getPercentOpen());
-			super.dispatchDraw(canvas);
-			canvas.restore();
-		} else
-			super.dispatchDraw(canvas);
-	}
-
-	@Override
-	protected void onLayout(boolean changed, int l, int t, int r, int b) {
-		final int width = r - l;
-		final int height = b - t;
-		mContent.layout(0, 0, width-mWidthOffset, height);
-		if (mSecondaryContent != null)
-			mSecondaryContent.layout(0, 0, width-mWidthOffset, height);
-	}
-
-	@Override
-	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-		int width = getDefaultSize(0, widthMeasureSpec);
-		int height = getDefaultSize(0, heightMeasureSpec);
-		setMeasuredDimension(width, height);
-		final int contentWidth = getChildMeasureSpec(widthMeasureSpec, 0, width-mWidthOffset);
-		final int contentHeight = getChildMeasureSpec(heightMeasureSpec, 0, height);
-		mContent.measure(contentWidth, contentHeight);
-		if (mSecondaryContent != null)
-			mSecondaryContent.measure(contentWidth, contentHeight);
-	}
-
-	private int mMode;
-	private boolean mFadeEnabled;
-	private final Paint mFadePaint = new Paint();
-	private float mScrollScale;
-	private Drawable mShadowDrawable;
-	private Drawable mSecondaryShadowDrawable;
-	private int mShadowWidth;
-	private float mFadeDegree;
-
-	public void setMode(int mode) {
-		if (mode == SlidingMenu.LEFT || mode == SlidingMenu.RIGHT) {
-			if (mContent != null)
-				mContent.setVisibility(View.VISIBLE);
-			if (mSecondaryContent != null)
-				mSecondaryContent.setVisibility(View.INVISIBLE);
-		}
-		mMode = mode;
-	}
-
-	public int getMode() {
-		return mMode;
-	}
-
-	public void setScrollScale(float scrollScale) {
-		mScrollScale = scrollScale;
-	}
-
-	public float getScrollScale() {
-		return mScrollScale;
-	}
-
-	public void setShadowDrawable(Drawable shadow) {
-		mShadowDrawable = shadow;
-		invalidate();
-	}
-
-	public void setSecondaryShadowDrawable(Drawable shadow) {
-		mSecondaryShadowDrawable = shadow;
-		invalidate();
-	}
-
-	public void setShadowWidth(int width) {
-		mShadowWidth = width;
-		invalidate();
-	}
-
-	public void setFadeEnabled(boolean b) {
-		mFadeEnabled = b;
-	}
-
-	public void setFadeDegree(float degree) {
-		if (degree > 1.0f || degree < 0.0f)
-			throw new IllegalStateException("The BehindFadeDegree must be between 0.0f and 1.0f");
-		mFadeDegree = degree;
-	}
-
-	public int getMenuPage(int page) {
-		page = (page > 1) ? 2 : ((page < 1) ? 0 : page);
-		if (mMode == SlidingMenu.LEFT && page > 1) {
-			return 0;
-		} else if (mMode == SlidingMenu.RIGHT && page < 1) {
-			return 2;
-		} else {
-			return page;
-		}
-	}
-
-	public void scrollBehindTo(View content, int x, int y) {
-		int vis = View.VISIBLE;		
-		if (mMode == SlidingMenu.LEFT) {
-			if (x >= content.getLeft()) vis = View.INVISIBLE;
-			scrollTo((int)((x + getBehindWidth())*mScrollScale), y);
-		} else if (mMode == SlidingMenu.RIGHT) {
-			if (x <= content.getLeft()) vis = View.INVISIBLE;
-			scrollTo((int)(getBehindWidth() - getWidth() + 
-					(x-getBehindWidth())*mScrollScale), y);
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			mContent.setVisibility(x >= content.getLeft() ? View.INVISIBLE : View.VISIBLE);
-			mSecondaryContent.setVisibility(x <= content.getLeft() ? View.INVISIBLE : View.VISIBLE);
-			vis = x == 0 ? View.INVISIBLE : View.VISIBLE;
-			if (x <= content.getLeft()) {
-				scrollTo((int)((x + getBehindWidth())*mScrollScale), y);				
-			} else {
-				scrollTo((int)(getBehindWidth() - getWidth() + 
-						(x-getBehindWidth())*mScrollScale), y);				
-			}
-		}
-		if (vis == View.INVISIBLE)
-			Log.v(TAG, "behind INVISIBLE");
-		setVisibility(vis);
-	}
-
-	public int getMenuLeft(View content, int page) {
-		if (mMode == SlidingMenu.LEFT) {
-			switch (page) {
-			case 0:
-				return content.getLeft() - getBehindWidth();
-			case 2:
-				return content.getLeft();
-			}
-		} else if (mMode == SlidingMenu.RIGHT) {
-			switch (page) {
-			case 0:
-				return content.getLeft();
-			case 2:
-				return content.getLeft() + getBehindWidth();	
-			}
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			switch (page) {
-			case 0:
-				return content.getLeft() - getBehindWidth();
-			case 2:
-				return content.getLeft() + getBehindWidth();
-			}
-		}
-		return content.getLeft();
-	}
-
-	public int getAbsLeftBound(View content) {
-		if (mMode == SlidingMenu.LEFT || mMode == SlidingMenu.LEFT_RIGHT) {
-			return content.getLeft() - getBehindWidth();
-		} else if (mMode == SlidingMenu.RIGHT) {
-			return content.getLeft();
-		}
-		return 0;
-	}
-
-	public int getAbsRightBound(View content) {
-		if (mMode == SlidingMenu.LEFT) {
-			return content.getLeft();
-		} else if (mMode == SlidingMenu.RIGHT || mMode == SlidingMenu.LEFT_RIGHT) {
-			return content.getLeft() + getBehindWidth();
-		}
-		return 0;
-	}
-
-	public boolean marginTouchAllowed(View content, int x) {
-		int left = content.getLeft();
-		int right = content.getRight();
-		if (mMode == SlidingMenu.LEFT) {
-			return (x >= left && x <= mMarginThreshold + left);
-		} else if (mMode == SlidingMenu.RIGHT) {
-			return (x <= right && x >= right - mMarginThreshold);
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			return (x >= left && x <= mMarginThreshold + left) || 
-					(x <= right && x >= right - mMarginThreshold);
-		}
-		return false;
-	}
-
-	public void setTouchMode(int i) {
-		mTouchMode = i;
-	}
-
-	public boolean menuOpenTouchAllowed(View content, int currPage, float x) {
-		switch (mTouchMode) {
-		case SlidingMenu.TOUCHMODE_FULLSCREEN:
-			return true;
-		case SlidingMenu.TOUCHMODE_MARGIN:
-			return menuTouchInQuickReturn(content, currPage, x);
-		}
-		return false;
-	}
-
-	public boolean menuTouchInQuickReturn(View content, int currPage, float x) {
-		if (mMode == SlidingMenu.LEFT || (mMode == SlidingMenu.LEFT_RIGHT && currPage == 0)) {
-			return x >= content.getLeft();
-		} else if (mMode == SlidingMenu.RIGHT || (mMode == SlidingMenu.LEFT_RIGHT && currPage == 2)) {
-			return x <= content.getRight();
-		}
-		return false;
-	}
-
-	public boolean menuClosedSlideAllowed(float dx) {
-		if (mMode == SlidingMenu.LEFT) {
-			return dx > 0;
-		} else if (mMode == SlidingMenu.RIGHT) {
-			return dx < 0;
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			return true;
-		}
-		return false;
-	}
-
-	public boolean menuOpenSlideAllowed(float dx) {
-		if (mMode == SlidingMenu.LEFT) {
-			return dx < 0;
-		} else if (mMode == SlidingMenu.RIGHT) {
-			return dx > 0;
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			return true;
-		}
-		return false;
-	}
-
-	public void drawShadow(View content, Canvas canvas) {
-		if (mShadowDrawable == null || mShadowWidth <= 0) return;
-		int left = 0;
-		if (mMode == SlidingMenu.LEFT) {
-			left = content.getLeft() - mShadowWidth;
-		} else if (mMode == SlidingMenu.RIGHT) {
-			left = content.getRight();
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			if (mSecondaryShadowDrawable != null) {
-				left = content.getRight();
-				mSecondaryShadowDrawable.setBounds(left, 0, left + mShadowWidth, getHeight());
-				mSecondaryShadowDrawable.draw(canvas);
-			}
-			left = content.getLeft() - mShadowWidth;
-		}
-		mShadowDrawable.setBounds(left, 0, left + mShadowWidth, getHeight());
-		mShadowDrawable.draw(canvas);
-	}
-
-	public void drawFade(View content, Canvas canvas, float openPercent) {
-		if (!mFadeEnabled) return;
-		final int alpha = (int) (mFadeDegree * 255 * Math.abs(1-openPercent));
-		mFadePaint.setColor(Color.argb(alpha, 0, 0, 0));
-		int left = 0;
-		int right = 0;
-		if (mMode == SlidingMenu.LEFT) {
-			left = content.getLeft() - getBehindWidth();
-			right = content.getLeft();
-		} else if (mMode == SlidingMenu.RIGHT) {
-			left = content.getRight();
-			right = content.getRight() + getBehindWidth();			
-		} else if (mMode == SlidingMenu.LEFT_RIGHT) {
-			left = content.getLeft() - getBehindWidth();
-			right = content.getLeft();
-			canvas.drawRect(left, 0, right, getHeight(), mFadePaint);
-			left = content.getRight();
-			right = content.getRight() + getBehindWidth();			
-		}
-		canvas.drawRect(left, 0, right, getHeight(), mFadePaint);
-	}
-	
-	private boolean mSelectorEnabled = true;
-	private Bitmap mSelectorDrawable;
-	private View mSelectedView;
-	
-	public void drawSelector(View content, Canvas canvas, float openPercent) {
-		if (!mSelectorEnabled) return;
-		if (mSelectorDrawable != null && mSelectedView != null) {
-			String tag = (String) mSelectedView.getTag(R.id.selected_view);
-			if (tag.equals(TAG+"SelectedView")) {
-				canvas.save();
-				int left, right, offset;
-				offset = (int) (mSelectorDrawable.getWidth() * openPercent);
-				if (mMode == SlidingMenu.LEFT) {
-					right = content.getLeft();
-					left = right - offset;
-					canvas.clipRect(left, 0, right, getHeight());
-					canvas.drawBitmap(mSelectorDrawable, left, getSelectorTop(), null);		
-				} else if (mMode == SlidingMenu.RIGHT) {
-					left = content.getRight();
-					right = left + offset;
-					canvas.clipRect(left, 0, right, getHeight());
-					canvas.drawBitmap(mSelectorDrawable, right - mSelectorDrawable.getWidth(), getSelectorTop(), null);
-				}
-				canvas.restore();
-			}
-		}
-	}
-	
-	public void setSelectorEnabled(boolean b) {
-		mSelectorEnabled = b;
-	}
-
-	public void setSelectedView(View v) {
-		if (mSelectedView != null) {
-			mSelectedView.setTag(R.id.selected_view, null);
-			mSelectedView = null;
-		}
-		if (v != null && v.getParent() != null) {
-			mSelectedView = v;
-			mSelectedView.setTag(R.id.selected_view, TAG+"SelectedView");
-			invalidate();
-		}
-	}
-
-	private int getSelectorTop() {
-		int y = mSelectedView.getTop();
-		y += (mSelectedView.getHeight() - mSelectorDrawable.getHeight()) / 2;
-		return y;
-	}
-
-	public void setSelectorBitmap(Bitmap b) {
-		mSelectorDrawable = b;
-		refreshDrawableState();
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/MenuInterface.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/MenuInterface.java
deleted file mode 100644
index 8a7985317c..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/MenuInterface.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package com.slidingmenu.lib;
-
-import android.graphics.Canvas;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-
-public interface MenuInterface {
-
-	public abstract void scrollBehindTo(int x, int y, 
-			CustomViewBehind cvb, float scrollScale);
-	
-	public abstract int getMenuLeft(CustomViewBehind cvb, View content);
-	
-	public abstract int getAbsLeftBound(CustomViewBehind cvb, View content);
-
-	public abstract int getAbsRightBound(CustomViewBehind cvb, View content);
-
-	public abstract boolean marginTouchAllowed(View content, int x, int threshold);
-	
-	public abstract boolean menuOpenTouchAllowed(View content, int currPage, int x);
-	
-	public abstract boolean menuTouchInQuickReturn(View content, int currPage, int x);
-	
-	public abstract boolean menuClosedSlideAllowed(int x);
-	
-	public abstract boolean menuOpenSlideAllowed(int x);
-	
-	public abstract void drawShadow(Canvas canvas, Drawable shadow, int width);
-	
-	public abstract void drawFade(Canvas canvas, int alpha, 
-			CustomViewBehind cvb, View content);
-	
-	public abstract void drawSelector(View content, Canvas canvas, float percentOpen);
-	
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/SlidingMenu.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/SlidingMenu.java
deleted file mode 100644
index 9060ee7e36..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/SlidingMenu.java
+++ /dev/null
@@ -1,992 +0,0 @@
-package com.slidingmenu.lib;
-
-import java.lang.reflect.Method;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Canvas;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-import android.os.Handler;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.Display;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-import android.widget.FrameLayout;
-import android.widget.RelativeLayout;
-
-import com.slidingmenu.lib.CustomViewAbove.OnPageChangeListener;
-
-public class SlidingMenu extends RelativeLayout {
-
-	private static final String TAG = "SlidingMenu";
-
-	public static final int SLIDING_WINDOW = 0;
-	public static final int SLIDING_CONTENT = 1;
-	private boolean mActionbarOverlay = false;
-
-	/** Constant value for use with setTouchModeAbove(). Allows the SlidingMenu to be opened with a swipe
-	 * gesture on the screen's margin
-	 */
-	public static final int TOUCHMODE_MARGIN = 0;
-
-	/** Constant value for use with setTouchModeAbove(). Allows the SlidingMenu to be opened with a swipe
-	 * gesture anywhere on the screen
-	 */
-	public static final int TOUCHMODE_FULLSCREEN = 1;
-
-	/** Constant value for use with setTouchModeAbove(). Denies the SlidingMenu to be opened with a swipe
-	 * gesture
-	 */
-	public static final int TOUCHMODE_NONE = 2;
-
-	/** Constant value for use with setMode(). Puts the menu to the left of the content.
-	 */
-	public static final int LEFT = 0;
-
-	/** Constant value for use with setMode(). Puts the menu to the right of the content.
-	 */
-	public static final int RIGHT = 1;
-
-	/** Constant value for use with setMode(). Puts menus to the left and right of the content.
-	 */
-	public static final int LEFT_RIGHT = 2;
-
-	private CustomViewAbove mViewAbove;
-
-	private CustomViewBehind mViewBehind;
-
-	private OnOpenListener mOpenListener;
-
-	private OnCloseListener mCloseListener;
-
-	/**
-	 * The listener interface for receiving onOpen events.
-	 * The class that is interested in processing a onOpen
-	 * event implements this interface, and the object created
-	 * with that class is registered with a component using the
-	 * component's <code>addOnOpenListener<code> method. When
-	 * the onOpen event occurs, that object's appropriate
-	 * method is invoked
-	 */
-	public interface OnOpenListener {
-
-		/**
-		 * On open.
-		 */
-		public void onOpen();
-	}
-
-	/**
-	 * The listener interface for receiving onOpened events.
-	 * The class that is interested in processing a onOpened
-	 * event implements this interface, and the object created
-	 * with that class is registered with a component using the
-	 * component's <code>addOnOpenedListener<code> method. When
-	 * the onOpened event occurs, that object's appropriate
-	 * method is invoked.
-	 *
-	 * @see OnOpenedEvent
-	 */
-	public interface OnOpenedListener {
-
-		/**
-		 * On opened.
-		 */
-		public void onOpened();
-	}
-
-	/**
-	 * The listener interface for receiving onClose events.
-	 * The class that is interested in processing a onClose
-	 * event implements this interface, and the object created
-	 * with that class is registered with a component using the
-	 * component's <code>addOnCloseListener<code> method. When
-	 * the onClose event occurs, that object's appropriate
-	 * method is invoked.
-	 *
-	 * @see OnCloseEvent
-	 */
-	public interface OnCloseListener {
-
-		/**
-		 * On close.
-		 */
-		public void onClose();
-	}
-
-	/**
-	 * The listener interface for receiving onClosed events.
-	 * The class that is interested in processing a onClosed
-	 * event implements this interface, and the object created
-	 * with that class is registered with a component using the
-	 * component's <code>addOnClosedListener<code> method. When
-	 * the onClosed event occurs, that object's appropriate
-	 * method is invoked.
-	 *
-	 * @see OnClosedEvent
-	 */
-	public interface OnClosedListener {
-
-		/**
-		 * On closed.
-		 */
-		public void onClosed();
-	}
-
-	/**
-	 * The Interface CanvasTransformer.
-	 */
-	public interface CanvasTransformer {
-
-		/**
-		 * Transform canvas.
-		 *
-		 * @param canvas the canvas
-		 * @param percentOpen the percent open
-		 */
-		public void transformCanvas(Canvas canvas, float percentOpen);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu.
-	 *
-	 * @param context the associated Context
-	 */
-	public SlidingMenu(Context context) {
-		this(context, null);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu and attach to Activity.
-	 *
-	 * @param activity the activity to attach slidingmenu
-	 * @param slideStyle the slidingmenu style
-	 */
-	public SlidingMenu(Activity activity, int slideStyle) {
-		this(activity, null);
-		this.attachToActivity(activity, slideStyle);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu.
-	 *
-	 * @param context the associated Context
-	 * @param attrs the attrs
-	 */
-	public SlidingMenu(Context context, AttributeSet attrs) {
-		this(context, attrs, 0);
-	}
-
-	/**
-	 * Instantiates a new SlidingMenu.
-	 *
-	 * @param context the associated Context
-	 * @param attrs the attrs
-	 * @param defStyle the def style
-	 */
-	public SlidingMenu(Context context, AttributeSet attrs, int defStyle) {
-		super(context, attrs, defStyle);
-		
-		LayoutParams behindParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-		mViewBehind = new CustomViewBehind(context);
-		addView(mViewBehind, behindParams);
-		LayoutParams aboveParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-		mViewAbove = new CustomViewAbove(context);
-		addView(mViewAbove, aboveParams);
-		// register the CustomViewBehind with the CustomViewAbove
-		mViewAbove.setCustomViewBehind(mViewBehind);
-		mViewBehind.setCustomViewAbove(mViewAbove);
-		mViewAbove.setOnPageChangeListener(new OnPageChangeListener() {
-			public static final int POSITION_OPEN = 0;
-			public static final int POSITION_CLOSE = 1;
-
-			public void onPageScrolled(int position, float positionOffset,
-					int positionOffsetPixels) { }
-
-			public void onPageSelected(int position) {
-				if (position == POSITION_OPEN && mOpenListener != null) {
-					mOpenListener.onOpen();
-				} else if (position == POSITION_CLOSE && mCloseListener != null) {
-					mCloseListener.onClose();
-				}
-			}
-		});
-
-		// now style everything!
-		TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu);
-		// set the above and behind views if defined in xml
-		int mode = ta.getInt(R.styleable.SlidingMenu_mode, LEFT);
-		setMode(mode);
-		int viewAbove = ta.getResourceId(R.styleable.SlidingMenu_viewAbove, -1);
-		if (viewAbove != -1) {
-			setContent(viewAbove);
-		} else {
-			setContent(new FrameLayout(context));
-		}
-		int viewBehind = ta.getResourceId(R.styleable.SlidingMenu_viewBehind, -1);
-		if (viewBehind != -1) {
-			setMenu(viewBehind); 
-		} else {
-			setMenu(new FrameLayout(context));
-		}
-		int touchModeAbove = ta.getInt(R.styleable.SlidingMenu_touchModeAbove, TOUCHMODE_MARGIN);
-		setTouchModeAbove(touchModeAbove);
-		int touchModeBehind = ta.getInt(R.styleable.SlidingMenu_touchModeBehind, TOUCHMODE_MARGIN);
-		setTouchModeBehind(touchModeBehind);
-
-		int offsetBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindOffset, -1);
-		int widthBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindWidth, -1);
-		if (offsetBehind != -1 && widthBehind != -1)
-			throw new IllegalStateException("Cannot set both behindOffset and behindWidth for a SlidingMenu");
-		else if (offsetBehind != -1)
-			setBehindOffset(offsetBehind);
-		else if (widthBehind != -1)
-			setBehindWidth(widthBehind);
-		else
-			setBehindOffset(0);
-		float scrollOffsetBehind = ta.getFloat(R.styleable.SlidingMenu_behindScrollScale, 0.33f);
-		setBehindScrollScale(scrollOffsetBehind);
-		int shadowRes = ta.getResourceId(R.styleable.SlidingMenu_shadowDrawable, -1);
-		if (shadowRes != -1) {
-			setShadowDrawable(shadowRes);
-		}
-		int shadowWidth = (int) ta.getDimension(R.styleable.SlidingMenu_shadowWidth, 0);
-		setShadowWidth(shadowWidth);
-		boolean fadeEnabled = ta.getBoolean(R.styleable.SlidingMenu_fadeEnabled, true);
-		setFadeEnabled(fadeEnabled);
-		float fadeDeg = ta.getFloat(R.styleable.SlidingMenu_fadeDegree, 0.33f);
-		setFadeDegree(fadeDeg);
-		boolean selectorEnabled = ta.getBoolean(R.styleable.SlidingMenu_selectorEnabled, false);
-		setSelectorEnabled(selectorEnabled);
-		int selectorRes = ta.getResourceId(R.styleable.SlidingMenu_selectorDrawable, -1);
-		if (selectorRes != -1)
-			setSelectorDrawable(selectorRes);
-		ta.recycle();
-	}
-
-	/**
-	 * Attaches the SlidingMenu to an entire Activity
-	 * 
-	 * @param activity the Activity
-	 * @param slideStyle either SLIDING_CONTENT or SLIDING_WINDOW
-	 */
-	public void attachToActivity(Activity activity, int slideStyle) {
-		attachToActivity(activity, slideStyle, false);
-	}
-
-	/**
-	 * Attaches the SlidingMenu to an entire Activity
-	 * 
-	 * @param activity the Activity
-	 * @param slideStyle either SLIDING_CONTENT or SLIDING_WINDOW
-	 * @param actionbarOverlay whether or not the ActionBar is overlaid
-	 */
-	public void attachToActivity(Activity activity, int slideStyle, boolean actionbarOverlay) {
-		if (slideStyle != SLIDING_WINDOW && slideStyle != SLIDING_CONTENT)
-			throw new IllegalArgumentException("slideStyle must be either SLIDING_WINDOW or SLIDING_CONTENT");
-
-		if (getParent() != null)
-			throw new IllegalStateException("This SlidingMenu appears to already be attached");
-
-		// get the window background
-		TypedArray a = activity.getTheme().obtainStyledAttributes(new int[] {android.R.attr.windowBackground});
-		int background = a.getResourceId(0, 0);
-		a.recycle();
-
-		switch (slideStyle) {
-		case SLIDING_WINDOW:
-			mActionbarOverlay = false;
-			ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
-			ViewGroup decorChild = (ViewGroup) decor.getChildAt(0);
-			// save ActionBar themes that have transparent assets
-			decorChild.setBackgroundResource(background);
-			decor.removeView(decorChild);
-			decor.addView(this);
-			setContent(decorChild);
-			break;
-		case SLIDING_CONTENT:
-			mActionbarOverlay = actionbarOverlay;
-			// take the above view out of
-			ViewGroup contentParent = (ViewGroup)activity.findViewById(android.R.id.content);
-			View content = contentParent.getChildAt(0);
-			contentParent.removeView(content);
-			contentParent.addView(this);
-			setContent(content);
-			// save people from having transparent backgrounds
-			if (content.getBackground() == null)
-				content.setBackgroundResource(background);
-			break;
-		}
-	}
-
-	/**
-	 * Set the above view content from a layout resource. The resource will be inflated, adding all top-level views
-	 * to the above view.
-	 *
-	 * @param res the new content
-	 */
-	public void setContent(int res) {
-		setContent(LayoutInflater.from(getContext()).inflate(res, null));
-	}
-
-	/**
-	 * Set the above view content to the given View.
-	 *
-	 * @param view The desired content to display.
-	 */
-	public void setContent(View view) {
-		mViewAbove.setContent(view);
-		showContent();
-	}
-
-	/**
-	 * Retrieves the current content.
-	 * @return the current content
-	 */
-	public View getContent() {
-		return mViewAbove.getContent();
-	}
-
-	/**
-	 * Set the behind view (menu) content from a layout resource. The resource will be inflated, adding all top-level views
-	 * to the behind view.
-	 *
-	 * @param res the new content
-	 */
-	public void setMenu(int res) {
-		setMenu(LayoutInflater.from(getContext()).inflate(res, null));
-	}
-
-	/**
-	 * Set the behind view (menu) content to the given View.
-	 *
-	 * @param view The desired content to display.
-	 */
-	public void setMenu(View v) {
-		mViewBehind.setContent(v);
-	}
-
-	/**
-	 * Retrieves the main menu.
-	 * @return the main menu
-	 */
-	public View getMenu() {
-		return mViewBehind.getContent();
-	}
-
-	/**
-	 * Set the secondary behind view (right menu) content from a layout resource. The resource will be inflated, adding all top-level views
-	 * to the behind view.
-	 *
-	 * @param res the new content
-	 */
-	public void setSecondaryMenu(int res) {
-		setSecondaryMenu(LayoutInflater.from(getContext()).inflate(res, null));
-	}
-
-	/**
-	 * Set the secondary behind view (right menu) content to the given View.
-	 *
-	 * @param view The desired content to display.
-	 */
-	public void setSecondaryMenu(View v) {
-		mViewBehind.setSecondaryContent(v);
-		//		mViewBehind.invalidate();
-	}
-
-	/**
-	 * Retrieves the current secondary menu (right).
-	 * @return the current menu
-	 */
-	public View getSecondaryMenu() {
-		return mViewBehind.getSecondaryContent();
-	}
-
-
-	/**
-	 * Sets the sliding enabled.
-	 *
-	 * @param b true to enable sliding, false to disable it.
-	 */
-	public void setSlidingEnabled(boolean b) {
-		mViewAbove.setSlidingEnabled(b);
-	}
-
-	/**
-	 * Checks if is sliding enabled.
-	 *
-	 * @return true, if is sliding enabled
-	 */
-	public boolean isSlidingEnabled() {
-		return mViewAbove.isSlidingEnabled();
-	}
-
-	/**
-	 * Sets which side the SlidingMenu should appear on.
-	 * @param mode must be either SlidingMenu.LEFT or SlidingMenu.RIGHT
-	 */
-	public void setMode(int mode) {
-		if (mode != LEFT && mode != RIGHT && mode != LEFT_RIGHT) {
-			throw new IllegalStateException("SlidingMenu mode must be LEFT, RIGHT, or LEFT_RIGHT");
-		}
-		mViewBehind.setMode(mode);
-	}
-
-	/**
-	 * Returns the current side that the SlidingMenu is on.
-	 * @return the current mode, either SlidingMenu.LEFT or SlidingMenu.RIGHT
-	 */
-	public int getMode() {
-		return mViewBehind.getMode();
-	}
-
-	/**
-	 * Sets whether or not the SlidingMenu is in static mode (i.e. nothing is moving and everything is showing)
-	 *
-	 * @param b true to set static mode, false to disable static mode.
-	 */
-	public void setStatic(boolean b) {
-		if (b) {
-			setSlidingEnabled(false);
-			mViewAbove.setCustomViewBehind(null);
-			mViewAbove.setCurrentItem(1);
-			//			mViewBehind.setCurrentItem(0);	
-		} else {
-			mViewAbove.setCurrentItem(1);
-			//			mViewBehind.setCurrentItem(1);
-			mViewAbove.setCustomViewBehind(mViewBehind);
-			setSlidingEnabled(true);
-		}
-	}
-
-	/**
-	 * Opens the menu and shows the menu view.
-	 */
-	public void showMenu() {
-		showMenu(true);
-	}
-
-	/**
-	 * Opens the menu and shows the menu view.
-	 *
-	 * @param animate true to animate the transition, false to ignore animation
-	 */
-	public void showMenu(boolean animate) {
-		mViewAbove.setCurrentItem(0, animate);
-	}
-
-	/**
-	 * Opens the menu and shows the secondary menu view. Will default to the regular menu
-	 * if there is only one.
-	 */
-	public void showSecondaryMenu() {
-		showSecondaryMenu(true);
-	}
-
-	/**
-	 * Opens the menu and shows the secondary (right) menu view. Will default to the regular menu
-	 * if there is only one.
-	 *
-	 * @param animate true to animate the transition, false to ignore animation
-	 */
-	public void showSecondaryMenu(boolean animate) {
-		mViewAbove.setCurrentItem(2, animate);
-	}
-
-	/**
-	 * Closes the menu and shows the above view.
-	 */
-	public void showContent() {
-		showContent(true);
-	}
-
-	/**
-	 * Closes the menu and shows the above view.
-	 *
-	 * @param animate true to animate the transition, false to ignore animation
-	 */
-	public void showContent(boolean animate) {
-		mViewAbove.setCurrentItem(1, animate);
-	}
-
-	/**
-	 * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-	 */
-	public void toggle() {
-		toggle(true);
-	}
-
-	/**
-	 * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-	 *
-	 * @param animate true to animate the transition, false to ignore animation
-	 */
-	public void toggle(boolean animate) {
-		if (isMenuShowing()) {
-			showContent(animate);
-		} else {
-			showMenu(animate);
-		}
-	}
-
-	/**
-	 * Checks if is the behind view showing.
-	 *
-	 * @return Whether or not the behind view is showing
-	 */
-	public boolean isMenuShowing() {
-		return mViewAbove.getCurrentItem() == 0 || mViewAbove.getCurrentItem() == 2;
-	}
-	
-	/**
-	 * Checks if is the behind view showing.
-	 *
-	 * @return Whether or not the behind view is showing
-	 */
-	public boolean isSecondaryMenuShowing() {
-		return mViewAbove.getCurrentItem() == 2;
-	}
-
-	/**
-	 * Gets the behind offset.
-	 *
-	 * @return The margin on the right of the screen that the behind view scrolls to
-	 */
-	public int getBehindOffset() {
-		return ((RelativeLayout.LayoutParams)mViewBehind.getLayoutParams()).rightMargin;
-	}
-
-	/**
-	 * Sets the behind offset.
-	 *
-	 * @param i The margin, in pixels, on the right of the screen that the behind view scrolls to.
-	 */
-	public void setBehindOffset(int i) {
-		//		RelativeLayout.LayoutParams params = ((RelativeLayout.LayoutParams)mViewBehind.getLayoutParams());
-		//		int bottom = params.bottomMargin;
-		//		int top = params.topMargin;
-		//		int left = params.leftMargin;
-		//		params.setMargins(left, top, i, bottom);
-		mViewBehind.setWidthOffset(i);
-	}
-
-	/**
-	 * Sets the behind offset.
-	 *
-	 * @param resID The dimension resource id to be set as the behind offset.
-	 * The menu, when open, will leave this width margin on the right of the screen.
-	 */
-	public void setBehindOffsetRes(int resID) {
-		int i = (int) getContext().getResources().getDimension(resID);
-		setBehindOffset(i);
-	}
-
-	/**
-	 * Sets the above offset.
-	 *
-	 * @param i the new above offset, in pixels
-	 */
-	public void setAboveOffset(int i) {
-		mViewAbove.setAboveOffset(i);
-	}
-
-	/**
-	 * Sets the above offset.
-	 *
-	 * @param resID The dimension resource id to be set as the above offset.
-	 */
-	public void setAboveOffsetRes(int resID) {
-		int i = (int) getContext().getResources().getDimension(resID);
-		setAboveOffset(i);
-	}
-
-	/**
-	 * Sets the behind width.
-	 *
-	 * @param i The width the Sliding Menu will open to, in pixels
-	 */
-	@SuppressWarnings("deprecation")
-	public void setBehindWidth(int i) {
-		int width;
-		Display display = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE))
-				.getDefaultDisplay();
-		try {
-			Class<?> cls = Display.class;
-			Class<?>[] parameterTypes = {Point.class};
-			Point parameter = new Point();
-			Method method = cls.getMethod("getSize", parameterTypes);
-			method.invoke(display, parameter);
-			width = parameter.x;
-		} catch (Exception e) {
-			width = display.getWidth();
-		}
-		setBehindOffset(width-i);
-	}
-
-	/**
-	 * Sets the behind width.
-	 *
-	 * @param res The dimension resource id to be set as the behind width offset.
-	 * The menu, when open, will open this wide.
-	 */
-	public void setBehindWidthRes(int res) {
-		int i = (int) getContext().getResources().getDimension(res);
-		setBehindWidth(i);
-	}
-
-	/**
-	 * Gets the behind scroll scale.
-	 *
-	 * @return The scale of the parallax scroll
-	 */
-	public float getBehindScrollScale() {
-		return mViewBehind.getScrollScale();
-	}
-
-	/**
-	 * Sets the behind scroll scale.
-	 *
-	 * @param f The scale of the parallax scroll (i.e. 1.0f scrolls 1 pixel for every
-	 * 1 pixel that the above view scrolls and 0.0f scrolls 0 pixels)
-	 */
-	public void setBehindScrollScale(float f) {
-		if (f < 0 && f > 1)
-			throw new IllegalStateException("ScrollScale must be between 0 and 1");
-		mViewBehind.setScrollScale(f);
-	}
-
-	/**
-	 * Sets the behind canvas transformer.
-	 *
-	 * @param t the new behind canvas transformer
-	 */
-	public void setBehindCanvasTransformer(CanvasTransformer t) {
-		mViewBehind.setCanvasTransformer(t);
-	}
-
-	/**
-	 * Gets the touch mode above.
-	 *
-	 * @return the touch mode above
-	 */
-	public int getTouchModeAbove() {
-		return mViewAbove.getTouchMode();
-	}
-
-	/**
-	 * Controls whether the SlidingMenu can be opened with a swipe gesture.
-	 * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN}, {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN},
-	 * or {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
-	 *
-	 * @param i the new touch mode
-	 */
-	public void setTouchModeAbove(int i) {
-		if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN
-				&& i != TOUCHMODE_NONE) {
-			throw new IllegalStateException("TouchMode must be set to either" +
-					"TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
-		}
-		mViewAbove.setTouchMode(i);
-	}
-
-	/**
-	 * Controls whether the SlidingMenu can be opened with a swipe gesture.
-	 * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN}, {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN},
-	 * or {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
-	 *
-	 * @param i the new touch mode
-	 */
-	public void setTouchModeBehind(int i) {
-		if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN
-				&& i != TOUCHMODE_NONE) {
-			throw new IllegalStateException("TouchMode must be set to either" +
-					"TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
-		}
-		mViewBehind.setTouchMode(i);
-	}
-
-	/**
-	 * Sets the shadow drawable.
-	 *
-	 * @param resId the resource ID of the new shadow drawable
-	 */
-	public void setShadowDrawable(int resId) {
-		setShadowDrawable(getContext().getResources().getDrawable(resId));
-	}
-
-	/**
-	 * Sets the shadow drawable.
-	 *
-	 * @param d the new shadow drawable
-	 */
-	public void setShadowDrawable(Drawable d) {
-		mViewBehind.setShadowDrawable(d);
-	}
-
-	/**
-	 * Sets the secondary (right) shadow drawable.
-	 *
-	 * @param resId the resource ID of the new shadow drawable
-	 */
-	public void setSecondaryShadowDrawable(int resId) {
-		setSecondaryShadowDrawable(getContext().getResources().getDrawable(resId));
-	}
-
-	/**
-	 * Sets the secondary (right) shadow drawable.
-	 *
-	 * @param d the new shadow drawable
-	 */
-	public void setSecondaryShadowDrawable(Drawable d) {
-		mViewBehind.setSecondaryShadowDrawable(d);
-	}
-
-	/**
-	 * Sets the shadow width.
-	 *
-	 * @param resId The dimension resource id to be set as the shadow width.
-	 */
-	public void setShadowWidthRes(int resId) {
-		setShadowWidth((int)getResources().getDimension(resId));
-	}
-
-	/**
-	 * Sets the shadow width.
-	 *
-	 * @param pixels the new shadow width, in pixels
-	 */
-	public void setShadowWidth(int pixels) {
-		mViewBehind.setShadowWidth(pixels);
-	}
-
-	/**
-	 * Enables or disables the SlidingMenu's fade in and out
-	 *
-	 * @param b true to enable fade, false to disable it
-	 */
-	public void setFadeEnabled(boolean b) {
-		mViewBehind.setFadeEnabled(b);
-	}
-
-	/**
-	 * Sets how much the SlidingMenu fades in and out. Fade must be enabled, see
-	 * {@link #setFadeEnabled(boolean) setFadeEnabled(boolean)}
-	 *
-	 * @param f the new fade degree, between 0.0f and 1.0f
-	 */
-	public void setFadeDegree(float f) {
-		mViewBehind.setFadeDegree(f);
-	}
-
-	/**
-	 * Enables or disables whether the selector is drawn
-	 *
-	 * @param b true to draw the selector, false to not draw the selector
-	 */
-	public void setSelectorEnabled(boolean b) {
-		mViewBehind.setSelectorEnabled(true);
-	}
-
-	/**
-	 * Sets the selected view. The selector will be drawn here
-	 *
-	 * @param v the new selected view
-	 */
-	public void setSelectedView(View v) {
-		mViewBehind.setSelectedView(v);
-	}
-
-	/**
-	 * Sets the selector drawable.
-	 *
-	 * @param res a resource ID for the selector drawable
-	 */
-	public void setSelectorDrawable(int res) {
-		mViewBehind.setSelectorBitmap(BitmapFactory.decodeResource(getResources(), res));
-	}
-
-	/**
-	 * Sets the selector drawable.
-	 *
-	 * @param b the new selector bitmap
-	 */
-	public void setSelectorBitmap(Bitmap b) {
-		mViewBehind.setSelectorBitmap(b);
-	}
-
-	/**
-	 * Add a View ignored by the Touch Down event when mode is Fullscreen
-	 *
-	 * @param v a view to be ignored
-	 */
-	public void addIgnoredView(View v) {
-		mViewAbove.addIgnoredView(v);
-	}
-
-	/**
-	 * Remove a View ignored by the Touch Down event when mode is Fullscreen
-	 *
-	 * @param v a view not wanted to be ignored anymore
-	 */
-	public void removeIgnoredView(View v) {
-		mViewAbove.removeIgnoredView(v);
-	}
-
-	/**
-	 * Clear the list of Views ignored by the Touch Down event when mode is Fullscreen
-	 */
-	public void clearIgnoredViews() {
-		mViewAbove.clearIgnoredViews();
-	}
-
-	/**
-	 * Sets the OnOpenListener. {@link OnOpenListener#onOpen() OnOpenListener.onOpen()} will be called when the SlidingMenu is opened
-	 *
-	 * @param listener the new OnOpenListener
-	 */
-	public void setOnOpenListener(OnOpenListener listener) {
-		//mViewAbove.setOnOpenListener(listener);
-		mOpenListener = listener;
-	}
-
-	/**
-	 * Sets the OnCloseListener. {@link OnCloseListener#onClose() OnCloseListener.onClose()} will be called when the SlidingMenu is closed
-	 *
-	 * @param listener the new setOnCloseListener
-	 */
-	public void setOnCloseListener(OnCloseListener listener) {
-		//mViewAbove.setOnCloseListener(listener);
-		mCloseListener = listener;
-	}
-
-	/**
-	 * Sets the OnOpenedListener. {@link OnOpenedListener#onOpened() OnOpenedListener.onOpened()} will be called after the SlidingMenu is opened
-	 *
-	 * @param listener the new OnOpenedListener
-	 */
-	public void setOnOpenedListener(OnOpenedListener listener) {
-		mViewAbove.setOnOpenedListener(listener);
-	}
-
-	/**
-	 * Sets the OnClosedListener. {@link OnClosedListener#onClosed() OnClosedListener.onClosed()} will be called after the SlidingMenu is closed
-	 *
-	 * @param listener the new OnClosedListener
-	 */
-	public void setOnClosedListener(OnClosedListener listener) {
-		mViewAbove.setOnClosedListener(listener);
-	}
-
-	public static class SavedState extends BaseSavedState {
-
-		private final int mItem;
-
-		public SavedState(Parcelable superState, int item) {
-			super(superState);
-			mItem = item;
-		}
-
-		private SavedState(Parcel in) {
-			super(in);
-			mItem = in.readInt();
-		}
-
-		public int getItem() {
-			return mItem;
-		}
-
-		/* (non-Javadoc)
-		 * @see android.view.AbsSavedState#writeToParcel(android.os.Parcel, int)
-		 */
-		public void writeToParcel(Parcel out, int flags) {
-			super.writeToParcel(out, flags);
-			out.writeInt(mItem);
-		}
-
-		public static final Parcelable.Creator<SavedState> CREATOR =
-				new Parcelable.Creator<SavedState>() {
-			public SavedState createFromParcel(Parcel in) {
-				return new SavedState(in);
-			}
-
-			public SavedState[] newArray(int size) {
-				return new SavedState[size];
-			}
-		};
-
-	}
-
-	/* (non-Javadoc)
-	 * @see android.view.View#onSaveInstanceState()
-	 */
-	@Override
-	protected Parcelable onSaveInstanceState() {
-		Parcelable superState = super.onSaveInstanceState();
-		SavedState ss = new SavedState(superState, mViewAbove.getCurrentItem());
-		return ss;
-	}
-
-	/* (non-Javadoc)
-	 * @see android.view.View#onRestoreInstanceState(android.os.Parcelable)
-	 */
-	@Override
-	protected void onRestoreInstanceState(Parcelable state) {
-		SavedState ss = (SavedState)state;
-		super.onRestoreInstanceState(ss.getSuperState());
-		mViewAbove.setCurrentItem(ss.getItem());
-	}
-
-	/* (non-Javadoc)
-	 * @see android.view.ViewGroup#fitSystemWindows(android.graphics.Rect)
-	 */
-	@SuppressLint("NewApi")
-	@Override
-	protected boolean fitSystemWindows(Rect insets) {
-		int leftPadding = insets.left;
-		int rightPadding = insets.right;
-		int topPadding = insets.top;
-		int bottomPadding = insets.bottom;
-		if (!mActionbarOverlay) {
-			Log.v(TAG, "setting padding!");
-			setPadding(leftPadding, topPadding, rightPadding, bottomPadding);
-		}
-		return true;
-	}
-	
-	private Handler mHandler = new Handler();
-
-	@TargetApi(Build.VERSION_CODES.HONEYCOMB)
-	public void manageLayers(float percentOpen) {
-		if (Build.VERSION.SDK_INT < 11) return;
-
-		boolean layer = percentOpen > 0.0f && percentOpen < 1.0f;
-		final int layerType = layer ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;
-
-		if (layerType != getContent().getLayerType()) {
-			mHandler.post(new Runnable() {
-				public void run() {
-					Log.v(TAG, "changing layerType. hardware? " + (layerType == View.LAYER_TYPE_HARDWARE));
-					getContent().setLayerType(layerType, null);
-					getMenu().setLayerType(layerType, null);
-					if (getSecondaryMenu() != null) {
-						getSecondaryMenu().setLayerType(layerType, null);
-					}
-				}
-			});
-		}
-	}
-
-}
\ No newline at end of file
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivity.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivity.java
deleted file mode 100644
index f2b570c502..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivity.java
+++ /dev/null
@@ -1,152 +0,0 @@
-package com.slidingmenu.lib.app;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.slidingmenu.lib.SlidingMenu;
-
-public class SlidingActivity extends Activity implements SlidingActivityBase {
-
-	private SlidingActivityHelper mHelper;
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		mHelper = new SlidingActivityHelper(this);
-		mHelper.onCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onPostCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onPostCreate(Bundle savedInstanceState) {
-		super.onPostCreate(savedInstanceState);
-		mHelper.onPostCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#findViewById(int)
-	 */
-	@Override
-	public View findViewById(int id) {
-		View v = super.findViewById(id);
-		if (v != null)
-			return v;
-		return mHelper.findViewById(id);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
-	 */
-	@Override
-	protected void onSaveInstanceState(Bundle outState) {
-		super.onSaveInstanceState(outState);
-		mHelper.onSaveInstanceState(outState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(int)
-	 */
-	@Override
-	public void setContentView(int id) {
-		setContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View)
-	 */
-	@Override
-	public void setContentView(View v) {
-		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	@Override
-	public void setContentView(View v, LayoutParams params) {
-		super.setContentView(v, params);
-		mHelper.registerAboveContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(int)
-	 */
-	public void setBehindContentView(int id) {
-		setBehindContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View)
-	 */
-	public void setBehindContentView(View v) {
-		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	public void setBehindContentView(View v, LayoutParams params) {
-		mHelper.setBehindContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#getSlidingMenu()
-	 */
-	public SlidingMenu getSlidingMenu() {
-		return mHelper.getSlidingMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#toggle()
-	 */
-	public void toggle() {
-		mHelper.toggle();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showAbove()
-	 */
-	public void showContent() {
-		mHelper.showContent();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showBehind()
-	 */
-	public void showMenu() {
-		mHelper.showMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showSecondaryMenu()
-	 */
-	public void showSecondaryMenu() {
-		mHelper.showSecondaryMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setSlidingActionBarEnabled(boolean)
-	 */
-	public void setSlidingActionBarEnabled(boolean b) {
-		mHelper.setSlidingActionBarEnabled(b);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onKeyUp(int, android.view.KeyEvent)
-	 */
-	@Override
-	public boolean onKeyUp(int keyCode, KeyEvent event) {
-		boolean b = mHelper.onKeyUp(keyCode, event);
-		if (b) return b;
-		return super.onKeyUp(keyCode, event);
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivityBase.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivityBase.java
deleted file mode 100644
index 5028cfe7bb..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivityBase.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package com.slidingmenu.lib.app;
-
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.slidingmenu.lib.SlidingMenu;
-
-public interface SlidingActivityBase {
-	
-	/**
-	 * Set the behind view content to an explicit view. This view is placed directly into the behind view 's view hierarchy.
-	 * It can itself be a complex view hierarchy.
-	 *
-	 * @param view The desired content to display.
-	 * @param layoutParams Layout parameters for the view.
-	 */
-	public void setBehindContentView(View view, LayoutParams layoutParams);
-
-	/**
-	 * Set the behind view content to an explicit view. This view is placed directly into the behind view 's view hierarchy.
-	 * It can itself be a complex view hierarchy. When calling this method, the layout parameters of the specified
-	 * view are ignored. Both the width and the height of the view are set by default to MATCH_PARENT. To use your
-	 * own layout parameters, invoke setContentView(android.view.View, android.view.ViewGroup.LayoutParams) instead.
-	 *
-	 * @param view The desired content to display.
-	 */
-	public void setBehindContentView(View view);
-
-	/**
-	 * Set the behind view content from a layout resource. The resource will be inflated, adding all top-level views
-	 * to the behind view.
-	 *
-	 * @param layoutResID Resource ID to be inflated.
-	 */
-	public void setBehindContentView(int layoutResID);
-
-	/**
-	 * Gets the SlidingMenu associated with this activity.
-	 *
-	 * @return the SlidingMenu associated with this activity.
-	 */
-	public SlidingMenu getSlidingMenu();
-		
-	/**
-	 * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-	 */
-	public void toggle();
-	
-	/**
-	 * Close the SlidingMenu and show the content view.
-	 */
-	public void showContent();
-	
-	/**
-	 * Open the SlidingMenu and show the menu view.
-	 */
-	public void showMenu();
-
-	/**
-	 * Open the SlidingMenu and show the secondary (right) menu view. Will default to the regular menu
-	 * if there is only one.
-	 */
-	public void showSecondaryMenu();
-	
-	/**
-	 * Controls whether the ActionBar slides along with the above view when the menu is opened,
-	 * or if it stays in place.
-	 *
-	 * @param slidingActionBarEnabled True if you want the ActionBar to slide along with the SlidingMenu,
-	 * false if you want the ActionBar to stay in place
-	 */
-	public void setSlidingActionBarEnabled(boolean slidingActionBarEnabled);
-	
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivityHelper.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivityHelper.java
deleted file mode 100644
index 2128df8b9a..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingActivityHelper.java
+++ /dev/null
@@ -1,219 +0,0 @@
-package com.slidingmenu.lib.app;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.os.Handler;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.slidingmenu.lib.R;
-import com.slidingmenu.lib.SlidingMenu;
-
-public class SlidingActivityHelper {
-
-	private Activity mActivity;
-
-	private SlidingMenu mSlidingMenu;
-
-	private View mViewAbove;
-
-	private View mViewBehind;
-
-	private boolean mBroadcasting = false;
-
-	private boolean mOnPostCreateCalled = false;
-
-	private boolean mEnableSlide = true;
-
-	/**
-	 * Instantiates a new SlidingActivityHelper.
-	 *
-	 * @param activity the associated activity
-	 */
-	public SlidingActivityHelper(Activity activity) {
-		mActivity = activity;
-	}
-
-	/**
-	 * Sets mSlidingMenu as a newly inflated SlidingMenu. Should be called within the activitiy's onCreate()
-	 *
-	 * @param savedInstanceState the saved instance state (unused)
-	 */
-	public void onCreate(Bundle savedInstanceState) {
-		mSlidingMenu = (SlidingMenu) LayoutInflater.from(mActivity).inflate(R.layout.slidingmenumain, null);
-	}
-
-	/**
-	 * Further SlidingMenu initialization. Should be called within the activitiy's onPostCreate()
-	 *
-	 * @param savedInstanceState the saved instance state (unused)
-	 */
-	public void onPostCreate(Bundle savedInstanceState) {
-		if (mViewBehind == null || mViewAbove == null) {
-			throw new IllegalStateException("Both setBehindContentView must be called " +
-					"in onCreate in addition to setContentView.");
-		}
-
-		mOnPostCreateCalled = true;
-
-		mSlidingMenu.attachToActivity(mActivity, 
-				mEnableSlide ? SlidingMenu.SLIDING_WINDOW : SlidingMenu.SLIDING_CONTENT);
-		
-		final boolean open;
-		final boolean secondary;
-		if (savedInstanceState != null) {
-			open = savedInstanceState.getBoolean("SlidingActivityHelper.open");
-			secondary = savedInstanceState.getBoolean("SlidingActivityHelper.secondary");
-		} else {
-			open = false;
-			secondary = false;
-		}
-		new Handler().post(new Runnable() {
-			public void run() {
-				if (open) {
-					if (secondary) {
-						mSlidingMenu.showSecondaryMenu(false);
-					} else {
-						mSlidingMenu.showMenu(false);
-					}
-				} else {
-					mSlidingMenu.showContent(false);					
-				}
-			}
-		});
-	}
-
-	/**
-	 * Controls whether the ActionBar slides along with the above view when the menu is opened,
-	 * or if it stays in place.
-	 *
-	 * @param slidingActionBarEnabled True if you want the ActionBar to slide along with the SlidingMenu,
-	 * false if you want the ActionBar to stay in place
-	 */
-	public void setSlidingActionBarEnabled(boolean slidingActionBarEnabled) {
-		if (mOnPostCreateCalled)
-			throw new IllegalStateException("enableSlidingActionBar must be called in onCreate.");
-		mEnableSlide = slidingActionBarEnabled;
-	}
-
-	/**
-	 * Finds a view that was identified by the id attribute from the XML that was processed in onCreate(Bundle).
-	 * 
-	 * @param id the resource id of the desired view
-	 * @return The view if found or null otherwise.
-	 */
-	public View findViewById(int id) {
-		View v;
-		if (mSlidingMenu != null) {
-			v = mSlidingMenu.findViewById(id);
-			if (v != null)
-				return v;
-		}
-		return null;
-	}
-
-	/**
-	 * Called to retrieve per-instance state from an activity before being killed so that the state can be
-	 * restored in onCreate(Bundle) or onRestoreInstanceState(Bundle) (the Bundle populated by this method
-	 * will be passed to both). 
-	 *
-	 * @param outState Bundle in which to place your saved state.
-	 */
-	public void onSaveInstanceState(Bundle outState) {
-		outState.putBoolean("SlidingActivityHelper.open", mSlidingMenu.isMenuShowing());
-		outState.putBoolean("SlidingActivityHelper.secondary", mSlidingMenu.isSecondaryMenuShowing());
-	}
-
-	/**
-	 * Register the above content view.
-	 *
-	 * @param v the above content view to register
-	 * @param params LayoutParams for that view (unused)
-	 */
-	public void registerAboveContentView(View v, LayoutParams params) {
-		if (!mBroadcasting)
-			mViewAbove = v;
-	}
-
-	/**
-	 * Set the activity content to an explicit view. This view is placed directly into the activity's view
-	 * hierarchy. It can itself be a complex view hierarchy. When calling this method, the layout parameters
-	 * of the specified view are ignored. Both the width and the height of the view are set by default to
-	 * MATCH_PARENT. To use your own layout parameters, invoke setContentView(android.view.View,
-	 * android.view.ViewGroup.LayoutParams) instead.
-	 *
-	 * @param v The desired content to display.
-	 */
-	public void setContentView(View v) {
-		mBroadcasting = true;
-		mActivity.setContentView(v);
-	}
-
-	/**
-	 * Set the behind view content to an explicit view. This view is placed directly into the behind view 's view hierarchy.
-	 * It can itself be a complex view hierarchy.
-	 *
-	 * @param view The desired content to display.
-	 * @param layoutParams Layout parameters for the view. (unused)
-	 */
-	public void setBehindContentView(View view, LayoutParams layoutParams) {
-		mViewBehind = view;
-		mSlidingMenu.setMenu(mViewBehind);
-	}
-
-	/**
-	 * Gets the SlidingMenu associated with this activity.
-	 *
-	 * @return the SlidingMenu associated with this activity.
-	 */
-	public SlidingMenu getSlidingMenu() {
-		return mSlidingMenu;
-	}
-
-	/**
-	 * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-	 */
-	public void toggle() {
-		mSlidingMenu.toggle();
-	}
-
-	/**
-	 * Close the SlidingMenu and show the content view.
-	 */
-	public void showContent() {
-		mSlidingMenu.showContent();
-	}
-
-	/**
-	 * Open the SlidingMenu and show the menu view.
-	 */
-	public void showMenu() {
-		mSlidingMenu.showMenu();
-	}
-
-	/**
-	 * Open the SlidingMenu and show the secondary menu view. Will default to the regular menu
-	 * if there is only one.
-	 */
-	public void showSecondaryMenu() {
-		mSlidingMenu.showSecondaryMenu();
-	}
-
-	/**
-	 * On key up.
-	 *
-	 * @param keyCode the key code
-	 * @param event the event
-	 * @return true, if successful
-	 */
-	public boolean onKeyUp(int keyCode, KeyEvent event) {
-		if (keyCode == KeyEvent.KEYCODE_BACK && mSlidingMenu.isMenuShowing()) {
-			showContent();
-			return true;
-		}
-		return false;
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingFragmentActivity.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingFragmentActivity.java
deleted file mode 100644
index a5eddae746..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingFragmentActivity.java
+++ /dev/null
@@ -1,152 +0,0 @@
-package com.slidingmenu.lib.app;
-
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.slidingmenu.lib.SlidingMenu;
-
-public class SlidingFragmentActivity extends FragmentActivity implements SlidingActivityBase {
-
-	private SlidingActivityHelper mHelper;
-
-	/* (non-Javadoc)
-	 * @see android.support.v4.app.FragmentActivity#onCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		mHelper = new SlidingActivityHelper(this);
-		mHelper.onCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onPostCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onPostCreate(Bundle savedInstanceState) {
-		super.onPostCreate(savedInstanceState);
-		mHelper.onPostCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#findViewById(int)
-	 */
-	@Override
-	public View findViewById(int id) {
-		View v = super.findViewById(id);
-		if (v != null)
-			return v;
-		return mHelper.findViewById(id);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.support.v4.app.FragmentActivity#onSaveInstanceState(android.os.Bundle)
-	 */
-	@Override
-	protected void onSaveInstanceState(Bundle outState) {
-		super.onSaveInstanceState(outState);
-		mHelper.onSaveInstanceState(outState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(int)
-	 */
-	@Override
-	public void setContentView(int id) {
-		setContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View)
-	 */
-	@Override
-	public void setContentView(View v) {
-		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	@Override
-	public void setContentView(View v, LayoutParams params) {
-		super.setContentView(v, params);
-		mHelper.registerAboveContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(int)
-	 */
-	public void setBehindContentView(int id) {
-		setBehindContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View)
-	 */
-	public void setBehindContentView(View v) {
-		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	public void setBehindContentView(View v, LayoutParams params) {
-		mHelper.setBehindContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#getSlidingMenu()
-	 */
-	public SlidingMenu getSlidingMenu() {
-		return mHelper.getSlidingMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#toggle()
-	 */
-	public void toggle() {
-		mHelper.toggle();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showAbove()
-	 */
-	public void showContent() {
-		mHelper.showContent();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showBehind()
-	 */
-	public void showMenu() {
-		mHelper.showMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showSecondaryMenu()
-	 */
-	public void showSecondaryMenu() {
-		mHelper.showSecondaryMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setSlidingActionBarEnabled(boolean)
-	 */
-	public void setSlidingActionBarEnabled(boolean b) {
-		mHelper.setSlidingActionBarEnabled(b);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onKeyUp(int, android.view.KeyEvent)
-	 */
-	@Override
-	public boolean onKeyUp(int keyCode, KeyEvent event) {
-		boolean b = mHelper.onKeyUp(keyCode, event);
-		if (b) return b;
-		return super.onKeyUp(keyCode, event);
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingListActivity.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingListActivity.java
deleted file mode 100644
index cd12806f99..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingListActivity.java
+++ /dev/null
@@ -1,157 +0,0 @@
-package com.slidingmenu.lib.app;
-
-import android.app.ListActivity;
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.ListView;
-
-import com.slidingmenu.lib.SlidingMenu;
-
-public class SlidingListActivity extends ListActivity implements SlidingActivityBase {
-
-	private SlidingActivityHelper mHelper;
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		mHelper = new SlidingActivityHelper(this);
-		mHelper.onCreate(savedInstanceState);
-		ListView listView = new ListView(this);
-		listView.setId(android.R.id.list);
-		setContentView(listView);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onPostCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onPostCreate(Bundle savedInstanceState) {
-		super.onPostCreate(savedInstanceState);
-		mHelper.onPostCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#findViewById(int)
-	 */
-	@Override
-	public View findViewById(int id) {
-		View v = super.findViewById(id);
-		if (v != null)
-			return v;
-		return mHelper.findViewById(id);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
-	 */
-	@Override
-	protected void onSaveInstanceState(Bundle outState) {
-		super.onSaveInstanceState(outState);
-		mHelper.onSaveInstanceState(outState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(int)
-	 */
-	@Override
-	public void setContentView(int id) {
-		setContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View)
-	 */
-	@Override
-	public void setContentView(View v) {
-		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	@Override
-	public void setContentView(View v, LayoutParams params) {
-		super.setContentView(v, params);
-		mHelper.registerAboveContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(int)
-	 */
-	public void setBehindContentView(int id) {
-		setBehindContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View)
-	 */
-	public void setBehindContentView(View v) {
-		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	public void setBehindContentView(View v, LayoutParams params) {
-		mHelper.setBehindContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#getSlidingMenu()
-	 */
-	public SlidingMenu getSlidingMenu() {
-		return mHelper.getSlidingMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#toggle()
-	 */
-	public void toggle() {
-		mHelper.toggle();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showAbove()
-	 */
-	public void showContent() {
-		mHelper.showContent();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showBehind()
-	 */
-	public void showMenu() {
-		mHelper.showMenu();
-	}
-	
-	/*
-	 * (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showSecondaryMenu()
-	 */
-	public void showSecondaryMenu() {
-		mHelper.showSecondaryMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setSlidingActionBarEnabled(boolean)
-	 */
-	public void setSlidingActionBarEnabled(boolean b) {
-		mHelper.setSlidingActionBarEnabled(b);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onKeyUp(int, android.view.KeyEvent)
-	 */
-	@Override
-	public boolean onKeyUp(int keyCode, KeyEvent event) {
-		boolean b = mHelper.onKeyUp(keyCode, event);
-		if (b) return b;
-		return super.onKeyUp(keyCode, event);
-	}
-
-}
diff --git a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingPreferenceActivity.java b/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingPreferenceActivity.java
deleted file mode 100644
index 403ab0cb3d..0000000000
--- a/java-libs/SlidingMenu/src/com/slidingmenu/lib/app/SlidingPreferenceActivity.java
+++ /dev/null
@@ -1,151 +0,0 @@
-package com.slidingmenu.lib.app;
-
-import com.slidingmenu.lib.SlidingMenu;
-
-import android.os.Bundle;
-import android.preference.PreferenceActivity;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-public class SlidingPreferenceActivity extends PreferenceActivity implements SlidingActivityBase {
-
-	private SlidingActivityHelper mHelper;
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		mHelper = new SlidingActivityHelper(this);
-		super.onCreate(savedInstanceState);
-		mHelper.onCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onPostCreate(android.os.Bundle)
-	 */
-	@Override
-	public void onPostCreate(Bundle savedInstanceState) {
-		super.onPostCreate(savedInstanceState);
-		mHelper.onPostCreate(savedInstanceState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#findViewById(int)
-	 */
-	@Override
-	public View findViewById(int id) {
-		View v = super.findViewById(id);
-		if (v != null)
-			return v;
-		return mHelper.findViewById(id);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onSaveInstanceState(android.os.Bundle)
-	 */
-	@Override
-	protected void onSaveInstanceState(Bundle outState) {
-		super.onSaveInstanceState(outState);
-		mHelper.onSaveInstanceState(outState);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(int)
-	 */
-	@Override
-	public void setContentView(int id) {
-		setContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View)
-	 */
-	@Override
-	public void setContentView(View v) {
-		setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	@Override
-	public void setContentView(View v, LayoutParams params) {
-		super.setContentView(v, params);
-		mHelper.registerAboveContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(int)
-	 */
-	public void setBehindContentView(int id) {
-		setBehindContentView(getLayoutInflater().inflate(id, null));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View)
-	 */
-	public void setBehindContentView(View v) {
-		setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setBehindContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-	 */
-	public void setBehindContentView(View v, LayoutParams params) {
-		mHelper.setBehindContentView(v, params);
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#getSlidingMenu()
-	 */
-	public SlidingMenu getSlidingMenu() {
-		return mHelper.getSlidingMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#toggle()
-	 */
-	public void toggle() {
-		mHelper.toggle();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showAbove()
-	 */
-	public void showContent() {
-		mHelper.showContent();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showBehind()
-	 */
-	public void showMenu() {
-		mHelper.showMenu();
-	}
-	
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#showSecondaryMenu()
-	 */
-	public void showSecondaryMenu() {
-		mHelper.showSecondaryMenu();
-	}
-
-	/* (non-Javadoc)
-	 * @see com.slidingmenu.lib.app.SlidingActivityBase#setSlidingActionBarEnabled(boolean)
-	 */
-	public void setSlidingActionBarEnabled(boolean b) {
-		mHelper.setSlidingActionBarEnabled(b);
-	}
-
-	/* (non-Javadoc)
-	 * @see android.app.Activity#onKeyUp(int, android.view.KeyEvent)
-	 */
-	@Override
-	public boolean onKeyUp(int keyCode, KeyEvent event) {
-		boolean b = mHelper.onKeyUp(keyCode, event);
-		if (b) return b;
-		return super.onKeyUp(keyCode, event);
-	}
-}
diff --git a/vlc-android/project.properties b/vlc-android/project.properties
index fde0b26685..75dcc3057d 100644
--- a/vlc-android/project.properties
+++ b/vlc-android/project.properties
@@ -10,5 +10,4 @@
 # Project target.
 target=android-19
 android.library.reference.1=../java-libs/appcompat
-android.library.reference.2=../java-libs/SlidingMenu
-android.library.reference.3=../java-libs/WheelView
+android.library.reference.2=../java-libs/WheelView
diff --git a/vlc-android/res/drawable-hdpi/drawer_shadow.9.png b/vlc-android/res/drawable-hdpi/drawer_shadow.9.png
new file mode 100644
index 0000000000..224cc4ff43
Binary files /dev/null and b/vlc-android/res/drawable-hdpi/drawer_shadow.9.png differ
diff --git a/vlc-android/res/drawable-hdpi/ic_drawer.png b/vlc-android/res/drawable-hdpi/ic_drawer.png
new file mode 100644
index 0000000000..ff7b1def9a
Binary files /dev/null and b/vlc-android/res/drawable-hdpi/ic_drawer.png differ
diff --git a/vlc-android/res/drawable-mdpi/drawer_shadow.9.png b/vlc-android/res/drawable-mdpi/drawer_shadow.9.png
new file mode 100644
index 0000000000..3797f99c0e
Binary files /dev/null and b/vlc-android/res/drawable-mdpi/drawer_shadow.9.png differ
diff --git a/vlc-android/res/drawable-mdpi/ic_drawer.png b/vlc-android/res/drawable-mdpi/ic_drawer.png
new file mode 100644
index 0000000000..fb681ba263
Binary files /dev/null and b/vlc-android/res/drawable-mdpi/ic_drawer.png differ
diff --git a/vlc-android/res/drawable-xhdpi/drawer_shadow.9.png b/vlc-android/res/drawable-xhdpi/drawer_shadow.9.png
new file mode 100644
index 0000000000..fa3d853e90
Binary files /dev/null and b/vlc-android/res/drawable-xhdpi/drawer_shadow.9.png differ
diff --git a/vlc-android/res/drawable-xhdpi/ic_drawer.png b/vlc-android/res/drawable-xhdpi/ic_drawer.png
new file mode 100644
index 0000000000..b9bc3d70f1
Binary files /dev/null and b/vlc-android/res/drawable-xhdpi/ic_drawer.png differ
diff --git a/vlc-android/res/layout/main.xml b/vlc-android/res/layout/main.xml
index ab2a97200e..069624aff5 100644
--- a/vlc-android/res/layout/main.xml
+++ b/vlc-android/res/layout/main.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
-<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
+<android.support.v4.widget.DrawerLayout
+ xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/root_container"
     android:layout_width="match_parent"
     android:layout_height="match_parent" >
@@ -68,4 +69,7 @@
             android:layout_height="fill_parent" />
     </org.videolan.vlc.widget.SlidingPaneLayout>
 
-</RelativeLayout>
\ No newline at end of file
+    <!-- The navigation drawer -->
+	<include layout="@layout/sidebar"/>
+    
+</android.support.v4.widget.DrawerLayout>
diff --git a/vlc-android/res/layout/sidebar.xml b/vlc-android/res/layout/sidebar.xml
index a2f2bd8a81..34fe075f66 100644
--- a/vlc-android/res/layout/sidebar.xml
+++ b/vlc-android/res/layout/sidebar.xml
@@ -1,13 +1,15 @@
 <?xml version="1.0" encoding="utf-8"?>
-<ListView xmlns:android="http://schemas.android.com/apk/res/android"
-    android:id="@android:id/list"
-    android:layout_height="match_parent"
-    android:divider="?attr/background_menu_divider"
-    android:dividerHeight="0.2dp"
-    android:layout_width="208dp"
-    android:paddingTop="?attr/marginTopContent"
-    android:cacheColorHint="#0000"
-    android:fastScrollEnabled="true"
-    android:background="?attr/background_menu">
-
-</ListView>
+<merge xmlns:android="http://schemas.android.com/apk/res/android">
+	<ListView
+	    android:id="@+id/sidelist"
+	    android:layout_height="match_parent"
+	    android:divider="?attr/background_menu_divider"
+	    android:dividerHeight="0.2dp"
+	    android:layout_width="208dp"
+	    android:paddingTop="?attr/marginTopContent"
+	    android:layout_gravity="start"
+	    android:cacheColorHint="#0000"
+	    android:fastScrollEnabled="true"
+	    android:background="?attr/background_menu">
+	</ListView>
+</merge>
diff --git a/vlc-android/res/layout/sliding_menu.xml b/vlc-android/res/layout/sliding_menu.xml
deleted file mode 100644
index 0c91b5e9e1..0000000000
--- a/vlc-android/res/layout/sliding_menu.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<com.slidingmenu.lib.SlidingMenu xmlns:android="http://schemas.android.com/apk/res/android"
-    xmlns:sliding="http://schemas.android.com/apk/res-auto"
-    android:id="@+id/sliding_menu"
-    android:layout_width="match_parent"
-    android:layout_height="match_parent"
-    sliding:behindScrollScale="1.0"
-    sliding:shadowDrawable="@drawable/slidingmenu_shadow"
-    sliding:shadowWidth="@dimen/shadow_width" />
diff --git a/vlc-android/res/values/strings.xml b/vlc-android/res/values/strings.xml
index ed70538b60..1b50a91b15 100644
--- a/vlc-android/res/values/strings.xml
+++ b/vlc-android/res/values/strings.xml
@@ -293,6 +293,9 @@
     <string name="send_log">Send the log</string>
     <string name="sending_log">Sending the log</string>
 
+    <string name="drawer_open">Open navigation drawer</string>
+    <string name="drawer_close">Close navigation drawer</string>
+
     <string-array name="hardware_acceleration_list">
         <item>@string/automatic</item>
         <item>@string/hardware_acceleration_disabled</item>
diff --git a/vlc-android/src/org/videolan/vlc/gui/MainActivity.java b/vlc-android/src/org/videolan/vlc/gui/MainActivity.java
index 093ec814cd..416ee5287f 100644
--- a/vlc-android/src/org/videolan/vlc/gui/MainActivity.java
+++ b/vlc-android/src/org/videolan/vlc/gui/MainActivity.java
@@ -64,15 +64,18 @@
 import android.os.Handler;
 import android.os.Message;
 import android.preference.PreferenceManager;
+import android.support.v4.app.ActionBarDrawerToggle;
 import android.support.v4.app.Fragment;
 import android.support.v4.app.FragmentActivity;
 import android.support.v4.app.FragmentManager;
 import android.support.v4.app.FragmentTransaction;
+import android.support.v4.view.GravityCompat;
+import android.support.v4.widget.DrawerLayout;
+import android.support.v4.widget.DrawerLayout.LayoutParams;
 import android.support.v7.app.ActionBar;
 import android.support.v7.app.ActionBarActivity;
 import android.text.InputType;
 import android.util.Log;
-import android.view.Display;
 import android.view.LayoutInflater;
 import android.view.Menu;
 import android.view.MenuInflater;
@@ -88,8 +91,6 @@
 import android.widget.RelativeLayout;
 import android.widget.TextView;
 
-import com.slidingmenu.lib.SlidingMenu;
-
 public class MainActivity extends ActionBarActivity {
     public final static String TAG = "VLC/MainActivity";
 
@@ -105,12 +106,13 @@ public class MainActivity extends ActionBarActivity {
     private static final int ACTIVITY_SHOW_INFOLAYOUT = 2;
 
     private ActionBar mActionBar;
-    private SlidingMenu mMenu;
     private SidebarAdapter mSidebarAdapter;
     private AudioPlayer mAudioPlayer;
     private AudioServiceController mAudioController;
     private SlidingPaneLayout mSlidingPane;
-    private RelativeLayout mRootContainer;
+    private DrawerLayout mRootContainer;
+    private ListView mListView;
+    private ActionBarDrawerToggle mDrawerToggle;
 
     private View mInfoLayout;
     private ProgressBar mInfoProgress;
@@ -184,10 +186,6 @@ protected void onCreate(Bundle savedInstanceState) {
         /* Enable the indeterminate progress feature */
         requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
 
-        // Set up the sliding menu
-        mMenu = (SlidingMenu) LayoutInflater.from(this).inflate(R.layout.sliding_menu, null);
-        changeMenuOffset();
-
         SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(this);
         boolean enableBlackTheme = pref.getBoolean("enable_black_theme", false);
         if (enableBlackTheme)
@@ -199,35 +197,44 @@ protected void onCreate(Bundle savedInstanceState) {
         mSlidingPane = (SlidingPaneLayout) v_main.findViewById(R.id.pane);
         mSlidingPane.setPanelSlideListener(mPanelSlideListener);
 
-        View sidebar = LayoutInflater.from(this).inflate(R.layout.sidebar, null);
-        final ListView listView = (ListView)sidebar.findViewById(android.R.id.list);
-        listView.setFooterDividersEnabled(true);
+        mListView = (ListView)v_main.findViewById(R.id.sidelist);
+        mListView.setFooterDividersEnabled(true);
         mSidebarAdapter = new SidebarAdapter(this);
-        listView.setAdapter(mSidebarAdapter);
-        mMenu.setMenu(sidebar);
-        mMenu.attachToActivity(this, SlidingMenu.SLIDING_CONTENT, true);
+        mListView.setAdapter(mSidebarAdapter);
+
 
         /* Initialize UI variables */
         mInfoLayout = v_main.findViewById(R.id.info_layout);
         mInfoProgress = (ProgressBar) v_main.findViewById(R.id.info_progress);
         mInfoText = (TextView) v_main.findViewById(R.id.info_text);
         mAudioPlayerFilling = v_main.findViewById(R.id.audio_player_filling);
-        mRootContainer = (RelativeLayout) v_main.findViewById(R.id.root_container);
+        mRootContainer = (DrawerLayout) v_main.findViewById(R.id.root_container);
 
         /* Set up the action bar */
         prepareActionBar();
 
-        /* Set up the sidebar click listener */
-        listView.setOnItemClickListener(new OnItemClickListener() {
+        /* Set up the sidebar click listener
+         * no need to invalidate menu for now */
+        mDrawerToggle = new ActionBarDrawerToggle(this, mRootContainer,
+                R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {};
+
+        // Set the drawer toggle as the DrawerListener
+        mRootContainer.setDrawerListener(mDrawerToggle);
+        // set a custom shadow that overlays the main content when the drawer opens
+        mRootContainer.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);
+        getSupportActionBar().setDisplayHomeAsUpEnabled(true);
+        getSupportActionBar().setHomeButtonEnabled(true);
+
+        mListView.setOnItemClickListener(new OnItemClickListener() {
 
             @Override
             public void onItemClick(AdapterView<?> parent, View view,
                     int position, long id) {
-                SidebarAdapter.SidebarEntry entry = (SidebarEntry) listView.getItemAtPosition(position);
+                SidebarAdapter.SidebarEntry entry = (SidebarEntry) mListView.getItemAtPosition(position);
                 Fragment current = getSupportFragmentManager().findFragmentById(R.id.fragment_placeholder);
 
                 if(current == null || (entry != null && current.getTag().equals(entry.id))) { /* Already selected */
-                    mMenu.showContent();
+                    mRootContainer.closeDrawer(mListView);
                     return;
                 }
 
@@ -261,7 +268,7 @@ public void onItemClick(AdapterView<?> parent, View view,
                 if(current.getTag().equals("tracks"))
                     getFragment("audio").setUserVisibleHint(false);
 
-                mMenu.showContent();
+                mRootContainer.closeDrawer(mListView);
             }
         });
 
@@ -282,7 +289,7 @@ public void onItemClick(AdapterView<?> parent, View view,
             mHandler.postDelayed(new Runnable() {
                 @Override
                 public void run() {
-                    mMenu.showMenu();
+                    mRootContainer.openDrawer(mListView);
                 }
             }, 500);
         }
@@ -299,12 +306,12 @@ public void run() {
         reloadPreferences();
     }
 
-    private void changeMenuOffset() {
-        WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE);
-        Display display = wm.getDefaultDisplay();
-        @SuppressWarnings("deprecation")
-        int behindOffset_dp = Util.convertPxToDp(display.getWidth()) - 208;
-        mMenu.setBehindOffset(Util.convertDpToPx(behindOffset_dp));
+
+    @Override
+    protected void onPostCreate(Bundle savedInstanceState) {
+        super.onPostCreate(savedInstanceState);
+        // Sync the toggle state after onRestoreInstanceState has occurred.
+        mDrawerToggle.syncState();
     }
 
     @TargetApi(Build.VERSION_CODES.HONEYCOMB)
@@ -327,7 +334,7 @@ protected void onResume() {
         /* Load media items from database and storage */
         if (mScanNeeded)
             MediaLibrary.getInstance().loadMediaItems();
-    }
+   }
 
     @Override
     protected void onResumeFragments() {
@@ -422,9 +429,9 @@ protected void onRestart() {
 
     @Override
     public void onBackPressed() {
-        if(mMenu.isMenuShowing()) {
+        if(mRootContainer.isDrawerOpen(mListView)) {
             /* Close the menu first */
-            mMenu.showContent();
+            mRootContainer.closeDrawer(mListView);
             return;
         }
 
@@ -579,7 +586,7 @@ public boolean onPrepareOptionsMenu (Menu menu) {
     @Override
     public void onConfigurationChanged(Configuration newConfig) {
         super.onConfigurationChanged(newConfig);
-        changeMenuOffset();
+        mDrawerToggle.onConfigurationChanged(newConfig);
     }
 
     @Override
@@ -654,10 +661,9 @@ public boolean onOptionsItemSelected(MenuItem item) {
                     break;
                 }
                 /* Toggle the sidebar */
-                if(mMenu.isMenuShowing())
-                    mMenu.showContent();
-                else
-                    mMenu.showMenu();
+                if (mDrawerToggle.onOptionsItemSelected(item)) {
+                    return true;
+                }
                 break;
             case R.id.search_clear_history:
                 MediaDatabase.getInstance().clearSearchHistory();
@@ -871,21 +877,29 @@ public void onPanelOpened() {
                 if (resId != 0)
                     mSlidingPane.setShadowResource(resId);
                 mAudioPlayer.setHeaderVisibilities(false, false, true, true, true);
-                mMenu.setSlidingEnabled(true);
+                mRootContainer.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);
                 removeTipViewIfDisplayed();
                 mAudioPlayer.showAudioPlayerTips();
+                /*
+                 * TODO proper resolution of this bug
+                 * Drawer listview disappears when audio player is displayed
+                 * Here we restore it, this is just a workaround...
+                 */
+                if (findViewById(R.id.sidelist) == null){
+                	mRootContainer.addView(mListView);
+                }
             }
 
             @Override
             public void onPanelOpenedEntirely() {
                 mSlidingPane.setShadowDrawable(null);
-                mMenu.setSlidingEnabled(true);
+                mRootContainer.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);
             }
 
             @Override
             public void onPanelClosed() {
                 mAudioPlayer.setHeaderVisibilities(true, true, false, false, false);
-                mMenu.setSlidingEnabled(false);
+                mRootContainer.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
                 mAudioPlayer.showPlaylistTips();
             }
 
@@ -901,8 +915,8 @@ public void showTipViewIfNeeded(final int layoutId, final String settingKey) {
             removeTipViewIfDisplayed();
             View v = LayoutInflater.from(this).inflate(layoutId, null);
             mRootContainer.addView(v,
-                    new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT,
-                            RelativeLayout.LayoutParams.MATCH_PARENT));
+                    new DrawerLayout.LayoutParams(DrawerLayout.LayoutParams.MATCH_PARENT,
+                    		DrawerLayout.LayoutParams.MATCH_PARENT));
 
             v.setOnClickListener(new View.OnClickListener() {
                 @Override
