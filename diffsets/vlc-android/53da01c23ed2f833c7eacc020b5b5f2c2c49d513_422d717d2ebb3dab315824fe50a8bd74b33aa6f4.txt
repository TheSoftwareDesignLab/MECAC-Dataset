diff --git a/application/vlc-android/src/org/videolan/vlc/gui/helpers/BookmarkListDelegate.kt b/application/vlc-android/src/org/videolan/vlc/gui/helpers/BookmarkListDelegate.kt
index d1c899e658..55a8cf2b10 100644
--- a/application/vlc-android/src/org/videolan/vlc/gui/helpers/BookmarkListDelegate.kt
+++ b/application/vlc-android/src/org/videolan/vlc/gui/helpers/BookmarkListDelegate.kt
@@ -63,8 +63,6 @@ class BookmarkListDelegate(val activity: FragmentActivity, val service: Playback
     val visible: Boolean
         get() = rootView.visibility != View.GONE
 
-    private var lastBookmark: LastBookmarkSkip? = null
-
     fun show() {
         activity.findViewById<ViewStubCompat>(R.id.bookmarks_stub)?.let {
             rootView = it.inflate() as ConstraintLayout
@@ -89,13 +87,13 @@ class BookmarkListDelegate(val activity: FragmentActivity, val service: Playback
             bookmarkList.adapter = adapter
             bookmarkList.itemAnimator = null
             previousBookmarButton.setOnClickListener {
-                val bookmark = findPrevious()
+                val bookmark = bookmarkModel.findPrevious()
                 bookmark?.let {
                     service.setTime(it.time)
                 }
             }
             nextBookmarButton.setOnClickListener {
-                val bookmark = findNext()
+                val bookmark = bookmarkModel.findNext()
                 bookmark?.let {
                     service.setTime(it.time)
                 }
@@ -143,77 +141,6 @@ class BookmarkListDelegate(val activity: FragmentActivity, val service: Playback
         visibilityListener.invoke()
     }
 
-    /**
-     * Find the previous bookmark.
-     * If the user already used a button in the last 5 seconds, start from here
-     * Else find the first bookmark before the current time
-     *
-     * @return the previous bookmark or null if not found
-     */
-    private fun findPrevious(): Bookmark? {
-        lastBookmark?.let { lastBookmarkFound ->
-            if (System.currentTimeMillis() - 5000 < lastBookmarkFound.time) {
-                // the user already used a button in the last 5 seconds
-                var foundBookmark: Bookmark? = null
-                adapter.dataset.forEach {
-                    if (it.time < lastBookmarkFound.bookmark.time) foundBookmark = it
-                }
-                foundBookmark?.let {
-                    lastBookmark = LastBookmarkSkip(it, true, System.currentTimeMillis())
-                    return it
-                }
-            }
-        }
-
-        val currentTime = service.getTime()
-        var bookmark:Bookmark? = null
-        adapter.dataset.forEach {
-            if (it.time < currentTime) bookmark = it
-        }
-
-        bookmark?.let {
-            lastBookmark = LastBookmarkSkip(it, true, System.currentTimeMillis())
-        }
-
-        return bookmark
-    }
-
-    /**
-     * Find the next bookmark.
-     * If the user already used a button in the last 5 seconds, start from here
-     * Else find the first bookmark after the current time
-     *
-     * @return the next bookmark or null if not found
-     */
-    private fun findNext(): Bookmark? {
-
-        lastBookmark?.let { lastBookmarkFound ->
-            if (System.currentTimeMillis() - 5000 < lastBookmarkFound.time) {
-                // the user already used a button in the last 5 seconds
-                var foundBookmark: Bookmark? = null
-                adapter.dataset.reversed().forEach {
-                    if (it.time > lastBookmarkFound.bookmark.time) foundBookmark = it
-                }
-                foundBookmark?.let {
-                    lastBookmark = LastBookmarkSkip(it, false, System.currentTimeMillis())
-                    return it
-                }
-            }
-        }
-
-        val currentTime = service.getTime()
-        var bookmark:Bookmark? = null
-        adapter.dataset.reversed().forEach {
-            if (it.time > currentTime) bookmark = it
-        }
-
-        bookmark?.let {
-            lastBookmark = LastBookmarkSkip(it, false, System.currentTimeMillis())
-        }
-
-        return bookmark
-    }
-
     fun hide() {
         rootView.setGone()
         markerContainer.setGone()
@@ -259,6 +186,4 @@ class BookmarkListDelegate(val activity: FragmentActivity, val service: Playback
             bookmarkModel.refresh()
         }
     }
-}
-
-data class LastBookmarkSkip(val bookmark: Bookmark, val previous:Boolean, val time:Long)
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/application/vlc-android/src/org/videolan/vlc/viewmodels/BookmarkModel.kt b/application/vlc-android/src/org/videolan/vlc/viewmodels/BookmarkModel.kt
index fae61dcdb5..3340341baf 100644
--- a/application/vlc-android/src/org/videolan/vlc/viewmodels/BookmarkModel.kt
+++ b/application/vlc-android/src/org/videolan/vlc/viewmodels/BookmarkModel.kt
@@ -43,6 +43,8 @@ class BookmarkModel : ViewModel(), PlaybackService.Callback {
 
     val dataset = LiveDataset<Bookmark>()
     var service: PlaybackService? = null
+    private var lastBookmark: LastBookmarkSkip? = null
+
 
     init {
         PlaybackService.serviceFlow.onEach { onServiceChanged(it) }
@@ -131,4 +133,77 @@ class BookmarkModel : ViewModel(), PlaybackService.Callback {
         return bookmarks
     }
 
+    /**
+     * Find the previous bookmark.
+     * If the user already used a button in the last 5 seconds, start from here
+     * Else find the first bookmark before the current time
+     *
+     * @return the previous bookmark or null if not found
+     */
+    fun findPrevious(): Bookmark? {
+        val service = service ?: return null
+        lastBookmark?.let { lastBookmarkFound ->
+            if (System.currentTimeMillis() - 5000 < lastBookmarkFound.time) {
+                // the user already used a button in the last 5 seconds
+                var foundBookmark: Bookmark? = null
+                dataset.getList().sortedBy { it.time }.forEach {
+                    if (it.time < lastBookmarkFound.bookmark.time) foundBookmark = it
+                }
+                foundBookmark?.let {
+                    lastBookmark = LastBookmarkSkip(it, true, System.currentTimeMillis())
+                    return it
+                }
+            }
+        }
+
+        val currentTime = service.getTime()
+        var bookmark:Bookmark? = null
+        dataset.getList().sortedBy { it.time }.forEach {
+            if (it.time < currentTime) bookmark = it
+        }
+
+        bookmark?.let {
+            lastBookmark = LastBookmarkSkip(it, true, System.currentTimeMillis())
+        }
+
+        return bookmark
+    }
+
+    /**
+     * Find the next bookmark.
+     * If the user already used a button in the last 5 seconds, start from here
+     * Else find the first bookmark after the current time
+     *
+     * @return the next bookmark or null if not found
+     */
+    fun findNext(): Bookmark? {
+        val service = service ?: return null
+        lastBookmark?.let { lastBookmarkFound ->
+            if (System.currentTimeMillis() - 5000 < lastBookmarkFound.time) {
+                // the user already used a button in the last 5 seconds
+                var foundBookmark: Bookmark? = null
+                dataset.getList().sortedByDescending { it.time }.forEach {
+                    if (it.time > lastBookmarkFound.bookmark.time) foundBookmark = it
+                }
+                foundBookmark?.let {
+                    lastBookmark = LastBookmarkSkip(it, false, System.currentTimeMillis())
+                    return it
+                }
+            }
+        }
+
+        val currentTime = service.getTime()
+        var bookmark:Bookmark? = null
+        dataset.getList().sortedByDescending { it.time }.forEach {
+            if (it.time > currentTime) bookmark = it
+        }
+
+        bookmark?.let {
+            lastBookmark = LastBookmarkSkip(it, false, System.currentTimeMillis())
+        }
+
+        return bookmark
+    }
+
 }
+data class LastBookmarkSkip(val bookmark: Bookmark, val previous:Boolean, val time:Long)
\ No newline at end of file
