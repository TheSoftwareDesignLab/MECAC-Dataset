diff --git a/vlc-android/res/layout/audio_browser_card_item.xml b/vlc-android/res/layout/audio_browser_card_item.xml
new file mode 100644
index 0000000000..1d4c65ec58
--- /dev/null
+++ b/vlc-android/res/layout/audio_browser_card_item.xml
@@ -0,0 +1,140 @@
+<?xml version="1.0" encoding="utf-8"?>
+<layout xmlns:android="http://schemas.android.com/apk/res/android"
+    xmlns:tools="http://schemas.android.com/tools"
+    xmlns:vlc="http://schemas.android.com/apk/res-auto">
+
+    <data>
+
+        <import type="android.view.View" />
+
+        <import type="android.text.TextUtils" />
+
+        <import type="org.videolan.medialibrary.media.MediaLibraryItem" />
+
+        <variable
+            name="alignMode"
+            type="int" />
+
+
+        <variable
+            name="item"
+            type="MediaLibraryItem" />
+
+        <variable
+            name="imageWidth"
+            type="int" />
+
+        <variable
+            name="cover"
+            type="android.graphics.drawable.BitmapDrawable" />
+
+        <variable
+            name="bgColor"
+            type="int" />
+
+
+        <variable
+            name="holder"
+            type="org.videolan.vlc.gui.audio.AudioBrowserAdapter.MediaItemCardViewHolder" />
+    </data>
+
+    <androidx.cardview.widget.CardView
+        android:id="@+id/container"
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:clickable="true"
+        android:focusable="true"
+        android:longClickable="true"
+        android:foreground="?android:attr/selectableItemBackground"
+        android:onClick="@{holder::onClick}"
+        android:onLongClick="@{holder::onLongClick}">
+
+        <androidx.constraintlayout.widget.ConstraintLayout
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:background="@{bgColor}"
+            android:minHeight="@dimen/audio_browser_item_size">
+
+
+            <!-- Image loading is handled by org.videolan.vlc.gui.helpers.ImageLoader.loadImage() -->
+
+            <ImageView
+                android:id="@+id/media_cover"
+                android:layout_width="0dp"
+                android:layout_height="0dp"
+                android:layout_gravity="center"
+                android:background="@{cover}"
+                android:visibility="@{(item.getItemType() &amp; (MediaLibraryItem.TYPE_ALBUM|MediaLibraryItem.TYPE_ARTIST|MediaLibraryItem.TYPE_MEDIA|MediaLibraryItem.TYPE_PLAYLIST)) != 0 ? View.VISIBLE : View.GONE, default=gone}"
+                tools:srcCompat="@tools:sample/avatars"
+                vlc:imageWidth="@{imageWidth}"
+                vlc:layout_constraintDimensionRatio="1"
+                vlc:layout_constraintEnd_toEndOf="parent"
+                vlc:layout_constraintStart_toStartOf="parent"
+                vlc:layout_constraintTop_toTopOf="parent"
+                vlc:mediaWithWidth="@{item}" />
+
+
+            <!-- TextView must be set to singleLine
+                see https://code.google.com/p/android/issues/detail?id=33868 -->
+            <ImageButton
+                android:id="@+id/imageButton"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_margin="8dp"
+                android:background="@color/transparent"
+                android:src="@drawable/ic_play_circle"
+                android:onClick="@{holder::onMainActionClick}"
+                vlc:layout_constraintBottom_toBottomOf="@+id/media_cover"
+                vlc:layout_constraintRight_toRightOf="@+id/media_cover" />
+
+            <TextView
+                android:id="@+id/title"
+                style="@style/VLC.TextViewTitle"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_marginStart="8dp"
+                android:layout_marginTop="8dp"
+                android:layout_marginEnd="8dp"
+                android:ellipsize="end"
+                android:gravity="center_vertical"
+                android:maxLines="1"
+                tools:text="Title"
+                vlc:alignMode="@{alignMode}"
+                vlc:asyncText="@{item.title}"
+                vlc:layout_constraintEnd_toStartOf="@+id/item_more"
+                vlc:layout_constraintStart_toStartOf="parent"
+                vlc:layout_constraintTop_toBottomOf="@id/media_cover"
+                vlc:placeholder="@{item}" />
+
+            <TextView
+                android:id="@+id/subtitle"
+                style="@style/VLC.TextViewDescription"
+                android:layout_width="0dp"
+                android:layout_height="wrap_content"
+                android:layout_marginStart="8dp"
+                android:layout_marginEnd="8dp"
+                android:layout_marginBottom="8dp"
+                android:maxLines="1"
+                tools:text="Subitle"
+                vlc:asyncText="@{item}"
+                vlc:layout_constraintBottom_toBottomOf="parent"
+                vlc:layout_constraintEnd_toStartOf="@id/item_more"
+                vlc:layout_constraintStart_toStartOf="parent"
+                vlc:layout_constraintTop_toBottomOf="@+id/title"
+                vlc:placeholder="@{item}" />
+
+            <ImageView
+                android:id="@+id/item_more"
+                android:layout_width="wrap_content"
+                android:layout_height="wrap_content"
+                android:layout_marginEnd="4dp"
+                android:contentDescription="@string/more_actions"
+                android:onClick="@{holder::onMoreClick}"
+                android:scaleType="center"
+                android:src="@drawable/ic_more"
+                vlc:layout_constraintBottom_toBottomOf="@+id/subtitle"
+                vlc:layout_constraintEnd_toEndOf="parent"
+                vlc:layout_constraintTop_toTopOf="@+id/title" />
+        </androidx.constraintlayout.widget.ConstraintLayout>
+    </androidx.cardview.widget.CardView>
+</layout>
\ No newline at end of file
diff --git a/vlc-android/res/layout/song_header_item.xml b/vlc-android/res/layout/song_header_item.xml
index ebb4e92ab7..6c4bd8d115 100644
--- a/vlc-android/res/layout/song_header_item.xml
+++ b/vlc-android/res/layout/song_header_item.xml
@@ -5,7 +5,7 @@
     <data>
 
         <variable
-            name="header"
+            name="headerText"
             type="String" />
 
         <variable
@@ -32,7 +32,7 @@
             android:layout_width="0dp"
             android:layout_height="0dp"
             android:gravity="center"
-            android:text="@{header}"
+            android:text="@{headerText}"
             app:layout_constraintBottom_toBottomOf="parent"
             app:layout_constraintEnd_toEndOf="parent"
             app:layout_constraintStart_toStartOf="parent"
diff --git a/vlc-android/res/values/strings.xml b/vlc-android/res/values/strings.xml
index 13e12cd694..11474e99b2 100644
--- a/vlc-android/res/values/strings.xml
+++ b/vlc-android/res/values/strings.xml
@@ -700,4 +700,5 @@
     <string name="popup_force_legacy_title">Use custom Picture-in-Picture popup</string>
     <string name="popup_force_legacy_summary">Use custom Picture-in-Picture resizable popup</string>
     <string name="device_default">Device default</string>
+    <string name="track_number">%s tracks</string>
 </resources>
diff --git a/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java b/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java
index 7dc9492028..10fac37626 100644
--- a/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/HistoryFragment.java
@@ -260,6 +260,10 @@ public void onImageClick(@NotNull View v, int position, @NotNull MediaLibraryIte
     public void onCtxClick(View v, int position, MediaLibraryItem item) {}
 
 
+    @Override
+    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
+    }
+
     @Override
     public void onUpdateFinished(RecyclerView.Adapter adapter) {
         UiTools.updateSortTitles(this);
diff --git a/vlc-android/src/org/videolan/vlc/gui/PlaylistActivity.java b/vlc-android/src/org/videolan/vlc/gui/PlaylistActivity.java
index c46045344a..5e5c447196 100644
--- a/vlc-android/src/org/videolan/vlc/gui/PlaylistActivity.java
+++ b/vlc-android/src/org/videolan/vlc/gui/PlaylistActivity.java
@@ -237,6 +237,11 @@ public void onMove(int oldPosition, int newPosition) {
 
     }
 
+    @Override
+    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
+        MediaUtils.INSTANCE.openList(this, Arrays.asList(item.getTracks()), 0);
+    }
+
     @Override
     public void onStartDrag(@NotNull RecyclerView.ViewHolder viewHolder) {
         mItemTouchHelper.startDrag(viewHolder);
diff --git a/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt b/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
index f1800cbcf5..8140b181e9 100644
--- a/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/PlaylistFragment.kt
@@ -23,6 +23,7 @@ package org.videolan.vlc.gui
 
 import android.content.Intent
 import android.os.Bundle
+import android.util.Log
 import android.view.LayoutInflater
 import android.view.Menu
 import android.view.View
@@ -32,22 +33,24 @@ import androidx.coordinatorlayout.widget.CoordinatorLayout
 import androidx.lifecycle.Observer
 import androidx.lifecycle.ViewModelProviders
 import androidx.paging.PagedList
-import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.GridLayoutManager
 import androidx.recyclerview.widget.RecyclerView
 import androidx.swiperefreshlayout.widget.SwipeRefreshLayout
 import com.google.android.material.appbar.AppBarLayout
 import com.google.android.material.floatingactionbutton.FloatingActionButton
 import kotlinx.coroutines.launch
 import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.vlc.BuildConfig
 import org.videolan.vlc.R
 import org.videolan.vlc.databinding.PlaylistsFragmentBinding
 import org.videolan.vlc.gui.audio.AudioBrowserAdapter
 import org.videolan.vlc.gui.audio.AudioBrowserFragment
 import org.videolan.vlc.gui.audio.BaseAudioBrowser
 import org.videolan.vlc.gui.view.FastScroller
-import org.videolan.vlc.gui.view.RecyclerSectionItemDecoration
+import org.videolan.vlc.gui.view.RecyclerSectionItemGridDecoration
 import org.videolan.vlc.reloadLibrary
 import org.videolan.vlc.util.AppScope
+import org.videolan.vlc.util.getScreenWidth
 import org.videolan.vlc.viewmodels.paged.PagedPlaylistsModel
 
 class PlaylistFragment : BaseAudioBrowser(), Observer<PagedList<MediaLibraryItem>>, SwipeRefreshLayout.OnRefreshListener {
@@ -61,8 +64,7 @@ class PlaylistFragment : BaseAudioBrowser(), Observer<PagedList<MediaLibraryItem
         super.onCreate(savedInstanceState)
         if (viewModel == null) {
             viewModel = ViewModelProviders.of(requireActivity(), PagedPlaylistsModel.Factory(requireContext())).get(PagedPlaylistsModel::class.java)
-            playlistAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_PLAYLIST, this)
-            mAdapter = playlistAdapter
+
         }
     }
     override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
@@ -74,9 +76,39 @@ class PlaylistFragment : BaseAudioBrowser(), Observer<PagedList<MediaLibraryItem
     override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
         super.onViewCreated(view, savedInstanceState)
         binding.swipeLayout.setOnRefreshListener(this)
-        playlists.layoutManager = LinearLayoutManager(view.context, RecyclerView.VERTICAL, false)
+        val nbColumns = 2
+        val gridLayoutManager = GridLayoutManager(view.context, nbColumns)
+        gridLayoutManager.spanSizeLookup = object : GridLayoutManager.SpanSizeLookup() {
+            override fun getSpanSize(position: Int): Int {
+
+                if (position == playlistAdapter.getItemCount() - 1) {
+                    return 1
+                }
+                if (viewModel.isFirstInSection(position + 1)) {
+
+                    //calculate how many cell it must take
+                    val firstSection = viewModel.getPositionForSection(position)
+                    val nbItems = position - firstSection
+                    if (BuildConfig.DEBUG)
+                        Log.d("SongsBrowserFragment", "Position: " + position + " nb items: " + nbItems + " span: " + nbItems % nbColumns)
+
+                    return nbColumns - nbItems % nbColumns
+                }
+
+                return 1
+            }
+        }
+
+        //size of an item
+        val spacing = resources.getDimension(R.dimen.kl_small).toInt()
+        val itemSize = requireActivity().getScreenWidth() / nbColumns - spacing * 2
+
+        playlistAdapter = AudioBrowserAdapter(MediaLibraryItem.TYPE_PLAYLIST, this, itemSize)
+        mAdapter = playlistAdapter
+
+        playlists.layoutManager = gridLayoutManager
         playlists.adapter = playlistAdapter
-        playlists.addItemDecoration(RecyclerSectionItemDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_height), true, viewModel))
+        playlists.addItemDecoration(RecyclerSectionItemGridDecoration(resources.getDimensionPixelSize(R.dimen.recycler_section_header_height), spacing, true, nbColumns, viewModel))
         fastScroller = view.rootView.findViewById(R.id.songs_fast_scroller) as FastScroller
         fastScroller.attachToCoordinator(view.rootView.findViewById(R.id.appbar) as AppBarLayout, view.rootView.findViewById(R.id.coordinator) as CoordinatorLayout, view.rootView.findViewById(R.id.fab) as FloatingActionButton)
     }
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserAdapter.java b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserAdapter.java
index 6cfe39392f..13fbbb1425 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserAdapter.java
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/AudioBrowserAdapter.java
@@ -38,11 +38,11 @@
 import org.videolan.tools.MultiSelectAdapter;
 import org.videolan.tools.MultiSelectHelper;
 import org.videolan.vlc.R;
+import org.videolan.vlc.databinding.AudioBrowserCardItemBinding;
 import org.videolan.vlc.databinding.AudioBrowserItemBinding;
 import org.videolan.vlc.databinding.AudioBrowserTvItemBinding;
 import org.videolan.vlc.gui.helpers.ImageLoaderKt;
 import org.videolan.vlc.gui.helpers.SelectorViewHolder;
-import org.videolan.vlc.gui.tv.browser.SongsBrowserFragment;
 import org.videolan.vlc.gui.view.FastScroller;
 import org.videolan.vlc.interfaces.IEventsHandler;
 import org.videolan.vlc.interfaces.IListEventsHandler;
@@ -71,6 +71,7 @@ public class AudioBrowserAdapter extends PagedListAdapter<MediaLibraryItem, Audi
 
     private final IEventsHandler mIEventsHandler;
     private final IListEventsHandler mListEventsHandler;
+    private final int mType;
     private int itemSize = -1;
     private MultiSelectHelper<MediaLibraryItem> multiSelectHelper;
     private final BitmapDrawable mDefaultCover;
@@ -88,6 +89,7 @@ public AudioBrowserAdapter(int type, IEventsHandler eventsHandler, IListEventsHa
         mIEventsHandler = eventsHandler;
         mListEventsHandler = listEventsHandler;
         mReorder = canBeReordered;
+        mType = type;
         Context ctx = null;
         if (eventsHandler instanceof Context) ctx = (Context) eventsHandler;
         else if (eventsHandler instanceof Fragment) ctx = ((Fragment) eventsHandler).getContext();
@@ -98,8 +100,8 @@ public AudioBrowserAdapter(int type, IEventsHandler eventsHandler) {
         this(type, eventsHandler, null, false);
     }
 
-    public AudioBrowserAdapter(int typeMedia, SongsBrowserFragment eventsHandler, int itemSize) {
-        this(typeMedia, eventsHandler, null, false);
+    public AudioBrowserAdapter(int typeMedia, IEventsHandler eventsHandler, int itemSize) {
+        this(typeMedia, eventsHandler);
         this.itemSize = itemSize;
     }
 
@@ -107,7 +109,10 @@ public AudioBrowserAdapter(int typeMedia, SongsBrowserFragment eventsHandler, in
     @Override
     public AbstractMediaItemViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
         final LayoutInflater inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        if (!isTV) {
+        if (mType == MediaLibraryItem.TYPE_PLAYLIST) {
+            final AudioBrowserCardItemBinding binding = AudioBrowserCardItemBinding.inflate(inflater, parent, false);
+            return new MediaItemCardViewHolder(binding);
+        } else if (!isTV) {
             final AudioBrowserItemBinding binding = AudioBrowserItemBinding.inflate(inflater, parent, false);
             return new MediaItemViewHolder(binding);
         } else {
@@ -290,6 +295,52 @@ public void setCoverlay(boolean selected) {
         }
 
 
+    }
+
+    public class MediaItemCardViewHolder extends AbstractMediaItemViewHolder<AudioBrowserCardItemBinding> implements View.OnFocusChangeListener {
+        int coverlayResource = 0;
+
+        @TargetApi(Build.VERSION_CODES.M)
+        MediaItemCardViewHolder(AudioBrowserCardItemBinding binding) {
+            super(binding);
+            binding.setHolder(this);
+            if (mDefaultCover != null) binding.setCover(mDefaultCover);
+            if (AndroidUtil.isMarshMallowOrLater)
+                itemView.setOnContextClickListener(new View.OnContextClickListener() {
+                    @Override
+                    public boolean onContextClick(View v) {
+                        onMoreClick(v);
+                        return true;
+                    }
+                });
+            binding.setImageWidth(itemSize);
+            binding.container.getLayoutParams().width = itemSize;
+
+        }
+
+        @Override
+        public void setItem(MediaLibraryItem item) {
+            binding.setItem(item);
+        }
+
+        @Override
+        public void recycle() {
+            if (mDefaultCover != null) binding.setCover(mDefaultCover);
+            binding.title.setText("");
+            binding.subtitle.setText("");
+        }
+
+
+        @Override
+        public void setCoverlay(boolean selected) {
+            int resId = selected ? R.drawable.ic_action_mode_select : 0;
+            if (resId != coverlayResource) {
+                binding.mediaCover.setImageResource(selected ? R.drawable.ic_action_mode_select : 0);
+                coverlayResource = resId;
+            }
+        }
+
+
     }
 
     public class MediaItemTVViewHolder extends AbstractMediaItemViewHolder<AudioBrowserTvItemBinding> implements View.OnFocusChangeListener {
@@ -373,6 +424,12 @@ public void onImageClick(View v) {
             if (item != null) mIEventsHandler.onImageClick(v, position, item);
         }
 
+        public void onMainActionClick(View v) {
+            int position = getLayoutPosition();
+            final MediaLibraryItem item = getItem(position);
+            if (item != null) mIEventsHandler.onMainActionClick(v, position, item);
+        }
+
 
         @Override
         protected boolean isSelected() {
diff --git a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java
index 52939600e4..8dffcf70ce 100644
--- a/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java
+++ b/vlc-android/src/org/videolan/vlc/gui/audio/BaseAudioBrowser.java
@@ -281,6 +281,11 @@ public void onCtxClick(@NonNull View anchor, final int position, @NonNull MediaL
     }
 
 
+    @Override
+    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
+        MediaUtils.INSTANCE.openList(getActivity(), Arrays.asList(item.getTracks()), 0);
+    }
+
     @Override
     public void onUpdateFinished(RecyclerView.Adapter adapter) {
         UiTools.updateSortTitles(this);
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt
index 3f229c0cb1..1278ff143f 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/BaseBrowserFragment.kt
@@ -466,6 +466,8 @@ abstract class BaseBrowserFragment : MediaBrowserFragment<BrowserModel>(), IRefr
         onLongClick(v, position, item)
     }
 
+    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
+
     override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
         if (mSwipeRefreshLayout != null) mSwipeRefreshLayout.isRefreshing = false
         handler.sendEmptyMessage(MSG_HIDE_LOADING)
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java b/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java
index 2d41c920e5..1a5676244f 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/FileBrowserFragment.java
@@ -152,6 +152,10 @@ public void onCtxAction(int position, int option) {
         }
     }
 
+    @Override
+    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
+    }
+
     @Override
     public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
         if (!(this instanceof FilePickerFragment || this instanceof StorageBrowserFragment))
diff --git a/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt b/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt
index 532c259b68..9df3519a65 100644
--- a/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/browser/StorageBrowserFragment.kt
@@ -170,6 +170,8 @@ class StorageBrowserFragment : FileBrowserFragment(), EntryPointsEventsCb, Corou
         browse(mw, position, (DataBindingUtil.findBinding<BrowserItemBinding>(v))?.browserCheckbox?.state == ThreeStatesCheckbox.STATE_CHECKED)
     }
 
+    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
+
     fun checkBoxAction(v: View, mrl: String) {
         val tscb = v as ThreeStatesCheckbox
         val checked = tscb.state == ThreeStatesCheckbox.STATE_CHECKED
diff --git a/vlc-android/src/org/videolan/vlc/gui/helpers/ImageLoader.kt b/vlc-android/src/org/videolan/vlc/gui/helpers/ImageLoader.kt
index 9d510e7f79..665562e290 100644
--- a/vlc-android/src/org/videolan/vlc/gui/helpers/ImageLoader.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/helpers/ImageLoader.kt
@@ -19,7 +19,6 @@ import androidx.leanback.widget.ImageCardView
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
-import org.videolan.medialibrary.media.Folder
 import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.medialibrary.media.MediaWrapper
 import org.videolan.vlc.BR
@@ -28,6 +27,7 @@ import org.videolan.vlc.VLCApplication
 import org.videolan.vlc.util.AppScope
 import org.videolan.vlc.util.HttpImageLoader
 import org.videolan.vlc.util.ThumbnailsProvider
+import org.videolan.vlc.util.ThumbnailsProvider.obtainBitmap
 
 private val sBitmapCache = BitmapCache.getInstance()
 private val sMedialibrary = VLCApplication.getMLInstance()
@@ -56,6 +56,15 @@ fun loadImage(v: View, item: MediaLibraryItem?) {
     else AppScope.launch { getImage(v, findInLibrary(item, isMedia, isGroup), binding) }
 }
 
+@MainThread
+@BindingAdapter(value = ["bind:mediaWithWidth", "bind:imageWidth"], requireAll = true)
+fun loadPlaylistImageWithWidth(v: ImageView, item: MediaLibraryItem?, imageWidth: Int) {
+    if (imageWidth == 0) return
+    if (item == null) return
+    val binding = DataBindingUtil.findBinding<ViewDataBinding>(v)
+    AppScope.launch { getPlaylistImage(v, item, binding, imageWidth.toInt()) }
+}
+
 fun getAudioIconDrawable(context: Context?, type: Int): BitmapDrawable? = context?.let {
     when (type) {
         MediaLibraryItem.TYPE_ALBUM -> UiTools.getDefaultAlbumDrawable(it)
@@ -70,7 +79,7 @@ fun getMediaIconDrawable(context: Context, type: Int): BitmapDrawable? = when (t
     else -> UiTools.getDefaultAudioDrawable(context)
 }
 
-private var placeholderTvBg : Drawable? = null
+private var placeholderTvBg: Drawable? = null
 @MainThread
 @BindingAdapter("placeholder")
 fun placeHolderView(v: View, item: MediaLibraryItem?) {
@@ -141,14 +150,28 @@ private suspend fun getImage(v: View, item: MediaLibraryItem, binding: ViewDataB
     binding?.removeOnRebindCallback(rebindCallbacks!!)
 }
 
-private suspend fun obtainBitmap(item: MediaLibraryItem, width: Int) = withContext(Dispatchers.IO) {
-    when (item) {
-        is MediaWrapper -> ThumbnailsProvider.getMediaThumbnail(item, width)
-        is Folder -> ThumbnailsProvider.getFolderThumbnail(item, width)
-        else -> AudioUtil.readCoverBitmap(Uri.decode(item.artworkMrl), width)
+private suspend fun getPlaylistImage(v: View, item: MediaLibraryItem, binding: ViewDataBinding?, width: Int) {
+    var bindChanged = false
+    val rebindCallbacks = if (binding !== null) object : OnRebindCallback<ViewDataBinding>() {
+        override fun onPreBind(binding: ViewDataBinding): Boolean {
+            bindChanged = true
+            return super.onPreBind(binding)
+        }
+    } else null
+    if (binding !== null) {
+        binding.executePendingBindings()
+        binding.addOnRebindCallback(rebindCallbacks!!)
     }
+
+
+    var playlistImage = if (!bindChanged) ThumbnailsProvider.getPlaylistImage("playlist:${item.id}", item.tracks.toList(), width) else null
+    if (!bindChanged && playlistImage == null) playlistImage = UiTools.getDefaultAudioDrawable(VLCApplication.getAppContext()).bitmap
+    if (!bindChanged) updateImageView(playlistImage, v, binding)
+
+    binding?.removeOnRebindCallback(rebindCallbacks!!)
 }
 
+
 @MainThread
 fun updateImageView(bitmap: Bitmap?, target: View, vdb: ViewDataBinding?) {
     if (bitmap === null || bitmap.width <= 1 || bitmap.height <= 1) return
@@ -173,14 +196,15 @@ fun updateImageView(bitmap: Bitmap?, target: View, vdb: ViewDataBinding?) {
     }
 }
 
-private suspend fun findInLibrary(item: MediaLibraryItem, isMedia: Boolean, isGroup: Boolean) : MediaLibraryItem {
+private suspend fun findInLibrary(item: MediaLibraryItem, isMedia: Boolean, isGroup: Boolean): MediaLibraryItem {
     if (isMedia && !isGroup && item.id == 0L) {
         val mw = item as MediaWrapper
         val type = mw.type
         val isMediaFile = type == MediaWrapper.TYPE_AUDIO || type == MediaWrapper.TYPE_VIDEO
         val uri = mw.uri
         if (!isMediaFile && !(type == MediaWrapper.TYPE_DIR && "upnp" == uri.scheme)) return item
-        if (isMediaFile && "file" == uri.scheme) return withContext(Dispatchers.IO) { sMedialibrary.getMedia(uri) } ?: item
+        if (isMediaFile && "file" == uri.scheme) return withContext(Dispatchers.IO) { sMedialibrary.getMedia(uri) }
+                ?: item
     }
     return item
 }
\ No newline at end of file
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/SongHeaderAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/tv/SongHeaderAdapter.kt
index 454c08e170..b72ab5a687 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/SongHeaderAdapter.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/SongHeaderAdapter.kt
@@ -34,10 +34,10 @@ class SongHeaderAdapter(private val onHeaderSelected: OnHeaderSelected) : Recycl
     override fun onBindViewHolder(holder: SongHeaderAdapter.ViewHolder, position: Int) {
 
         if (sortType == Medialibrary.SORT_ALPHA) {
-            holder.binding.setHeader(alphaItems[position])
+            holder.binding.headerText = alphaItems[position]
             holder.binding.hasContent = items.contains(alphaItems[position])
         } else {
-            holder.binding.setHeader(items[position])
+            holder.binding.headerText = items[position]
             holder.binding.hasContent = true
         }
     }
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/browser/SongsBrowserFragment.java b/vlc-android/src/org/videolan/vlc/gui/tv/browser/SongsBrowserFragment.java
index a3ea0d2342..0c7c462762 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/browser/SongsBrowserFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/browser/SongsBrowserFragment.java
@@ -287,6 +287,10 @@ public void onImageClick(@NotNull View v, int position, @NotNull MediaLibraryIte
 
     }
 
+    @Override
+    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
+    }
+
     public void sort(@NotNull View v) {
         PopupMenu menu = new PopupMenu(v.getContext(), v);
         menu.inflate(R.menu.sort_options);
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
index a162d68515..5c227ea840 100644
--- a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
@@ -413,6 +413,10 @@ public void onCtxClick(@NotNull View v, int position, @NotNull MediaLibraryItem
     }
 
 
+    @Override
+    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
+    }
+
     @Override
     public void onUpdateFinished(@NotNull RecyclerView.Adapter adapter) {
         mHandler.post(new Runnable() {
diff --git a/vlc-android/src/org/videolan/vlc/interfaces/IEventsHandler.kt b/vlc-android/src/org/videolan/vlc/interfaces/IEventsHandler.kt
index 5cc5258e77..305a0e331a 100644
--- a/vlc-android/src/org/videolan/vlc/interfaces/IEventsHandler.kt
+++ b/vlc-android/src/org/videolan/vlc/interfaces/IEventsHandler.kt
@@ -10,4 +10,5 @@ interface IEventsHandler {
     fun onImageClick(v: View, position: Int, item: MediaLibraryItem)
     fun onCtxClick(v: View, position: Int, item: MediaLibraryItem)
     fun onUpdateFinished(adapter: RecyclerView.Adapter<*>)
+    fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem)
 }
diff --git a/vlc-android/src/org/videolan/vlc/util/Kextensions.kt b/vlc-android/src/org/videolan/vlc/util/Kextensions.kt
index 55dc8e6313..8d45dada88 100644
--- a/vlc-android/src/org/videolan/vlc/util/Kextensions.kt
+++ b/vlc-android/src/org/videolan/vlc/util/Kextensions.kt
@@ -24,6 +24,7 @@ import kotlinx.coroutines.*
 import org.videolan.libvlc.Media
 import org.videolan.libvlc.util.AndroidUtil
 import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.media.MediaLibraryItem
 import org.videolan.medialibrary.media.MediaWrapper
 import org.videolan.tools.SingletonHolder
 import org.videolan.vlc.VLCApplication
@@ -170,6 +171,22 @@ fun asyncText(view: TextView, text: CharSequence?) {
     (view as AppCompatTextView).setTextFuture(PrecomputedTextCompat.getTextFuture(text, params, null))
 }
 
+@BindingAdapter("app:asyncText", requireAll = false)
+fun asyncTextItem(view: TextView, item: MediaLibraryItem?) {
+    if (item == null) {
+        view.visibility = View.GONE
+        return
+    }
+    val text = if (item.itemType == MediaLibraryItem.TYPE_PLAYLIST) view.context.getString(org.videolan.vlc.R.string.track_number, item.tracks.size.toString()) else item.description
+    if (text.isNullOrEmpty()) {
+        view.visibility = View.GONE
+        return
+    }
+    view.visibility = View.VISIBLE
+    val params = TextViewCompat.getTextMetricsParams(view)
+    (view as AppCompatTextView).setTextFuture(PrecomputedTextCompat.getTextFuture(text, params, null))
+}
+
 fun isAppStarted() = ProcessLifecycleOwner.get().lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)
 
 fun Int.toPixel(): Int {
diff --git a/vlc-android/src/org/videolan/vlc/util/ThumbnailsProvider.java b/vlc-android/src/org/videolan/vlc/util/ThumbnailsProvider.java
deleted file mode 100644
index 6b81f9703b..0000000000
--- a/vlc-android/src/org/videolan/vlc/util/ThumbnailsProvider.java
+++ /dev/null
@@ -1,183 +0,0 @@
-package org.videolan.vlc.util;
-
-
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.media.ThumbnailUtils;
-import android.net.Uri;
-import android.provider.MediaStore;
-import android.text.TextUtils;
-
-import org.videolan.medialibrary.Medialibrary;
-import org.videolan.medialibrary.media.Folder;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.VLCApplication;
-import org.videolan.vlc.gui.helpers.AudioUtil;
-import org.videolan.vlc.gui.helpers.BitmapCache;
-import org.videolan.vlc.gui.helpers.BitmapUtil;
-import org.videolan.vlc.media.MediaGroup;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.util.Arrays;
-import java.util.List;
-
-import androidx.annotation.WorkerThread;
-
-import static org.videolan.medialibrary.Medialibrary.THUMBS_FOLDER_NAME;
-import static org.videolan.vlc.gui.helpers.AudioUtil.readCoverBitmap;
-
-public class ThumbnailsProvider {
-
-    private static final String TAG = "VLC/ThumbnailsProvider";
-
-    private static File appDir;
-    private static String cacheDir;
-    private static final int MAX_IMAGES = 4;
-    private static final Object lock = new Object();
-
-    @WorkerThread
-    public static Bitmap getFolderThumbnail(final Folder folder, int width) {
-        final List<MediaWrapper> media = Arrays.asList(folder.media(Folder.TYPE_FOLDER_VIDEO, Medialibrary.SORT_DEFAULT, true, 4, 0));
-        final Bitmap img = ThumbnailsProvider.getComposedImage("folder:"+folder.getTitle(), media, width);
-        return img;
-    }
-
-    @WorkerThread
-    public static Bitmap getMediaThumbnail(final MediaWrapper item, int width) {
-        if (item.getType() == MediaWrapper.TYPE_GROUP) return ThumbnailsProvider.getComposedImage("group:"+item.getTitle(), ((MediaGroup) item).getAll(), width);
-        if (item.getType() == MediaWrapper.TYPE_VIDEO && TextUtils.isEmpty(item.getArtworkMrl())) return getVideoThumbnail(item, width);
-        else return AudioUtil.readCoverBitmap(Uri.decode(item.getArtworkMrl()), width);
-    }
-
-    public static String getMediaCacheKey(boolean isMedia, MediaLibraryItem item) {
-        if (isMedia && ((MediaWrapper)item).getType() == MediaWrapper.TYPE_VIDEO && TextUtils.isEmpty(item.getArtworkMrl())) {
-            if (appDir == null) appDir = VLCApplication.getAppContext().getExternalFilesDir(null);
-            final boolean hasCache = appDir != null && appDir.exists();
-            if (hasCache && cacheDir == null) cacheDir = appDir.getAbsolutePath() + THUMBS_FOLDER_NAME;
-            return hasCache ? new StringBuilder(cacheDir).append('/').append(item.getTitle()).append(".jpg").toString() : null;
-        }
-        return item.getArtworkMrl();
-    }
-
-    @WorkerThread
-    private static Bitmap getVideoThumbnail(final MediaWrapper media, int width) {
-        final String filePath = media.getUri().getPath();
-        if (appDir == null) appDir = VLCApplication.getAppContext().getExternalFilesDir(null);
-        final boolean hasCache = appDir != null && appDir.exists();
-        final String thumbPath = getMediaCacheKey(true, media);
-        final Bitmap cacheBM = hasCache ? BitmapCache.getInstance().getBitmapFromMemCache(thumbPath) : null;
-        if (cacheBM != null) return cacheBM;
-        if (hasCache && new File(thumbPath).exists()) return readCoverBitmap(thumbPath, width);
-        if (media.isThumbnailGenerated()) return null;
-        final Bitmap bitmap;
-        synchronized (lock) {
-            bitmap = ThumbnailUtils.createVideoThumbnail(filePath, MediaStore.Video.Thumbnails.MINI_KIND);
-        }
-        if (bitmap != null) {
-            BitmapCache.getInstance().addBitmapToMemCache(thumbPath, bitmap);
-            if (hasCache) {
-                media.setThumbnail(thumbPath);
-                saveOnDisk(bitmap, thumbPath);
-                media.setArtworkURL(thumbPath);
-            }
-        } else if (media.getId() != 0L) {
-            Medialibrary.getInstance().requestThumbnail(media.getId());
-        }
-        return bitmap;
-    }
-
-    @WorkerThread
-    private static Bitmap getComposedImage(String key, List<MediaWrapper> mediaList, int width) {
-        final BitmapCache bmc = BitmapCache.getInstance();
-        Bitmap composedImage = bmc.getBitmapFromMemCache(key);
-        if (composedImage == null) {
-            composedImage = composeImage(mediaList, width);
-            if (composedImage != null) bmc.addBitmapToMemCache(key, composedImage);
-        }
-        return composedImage;
-    }
-    /**
-     * Compose 1 image from combined media thumbnails
-     * @param mediaList The media list fromwhich will extract thumbnails
-     * @return a Bitmap object
-     */
-    private static Bitmap composeImage(List<MediaWrapper> mediaList, int imageWidth) {
-        final Bitmap[] sourcesImages = new Bitmap[Math.min(MAX_IMAGES, mediaList.size())];
-        int count = 0, minWidth = Integer.MAX_VALUE, minHeight = Integer.MAX_VALUE;
-        for (MediaWrapper media : mediaList) {
-            final Bitmap bm = getVideoThumbnail(media, imageWidth);
-            if (bm != null) {
-                int width = bm.getWidth();
-                int height = bm.getHeight();
-                sourcesImages[count++] = bm;
-                minWidth = Math.min(minWidth, width);
-                minHeight = Math.min(minHeight, height);
-                if (count == MAX_IMAGES) break;
-            }
-        }
-        if (count == 0) return null;
-        if (count == 1) return sourcesImages[0];
-        return composeCanvas(sourcesImages, count, minWidth, minHeight);
-    }
-
-    private static Bitmap composeCanvas(Bitmap[] sourcesImages, int count, int minWidth, int minHeight) {
-        int overlayWidth, overlayHeight;
-        switch (count) {
-            case 4:
-                overlayWidth = 2*minWidth;
-                overlayHeight = 2*minHeight;
-                break;
-            default:
-                overlayWidth = minWidth;
-                overlayHeight = minHeight;
-                break;
-        }
-        Bitmap bmOverlay = Bitmap.createBitmap(overlayWidth, overlayHeight, sourcesImages[0].getConfig());
-
-        Canvas canvas = new Canvas(bmOverlay);
-        switch (count) {
-            case 2:
-                for (int i = 0; i < count; ++i)
-                    sourcesImages[i] = BitmapUtil.centerCrop(sourcesImages[i], minWidth/2, minHeight);
-                canvas.drawBitmap(sourcesImages[0], 0, 0, null);
-                canvas.drawBitmap(sourcesImages[1], minWidth / 2, 0, null);
-                break;
-            case 3:
-                sourcesImages[0] = BitmapUtil.centerCrop(sourcesImages[0], minWidth/2, minHeight/2);
-                sourcesImages[1] = BitmapUtil.centerCrop(sourcesImages[1], minWidth/2, minHeight/2);
-                sourcesImages[2] = BitmapUtil.centerCrop(sourcesImages[2], minWidth, minHeight/2);
-                canvas.drawBitmap(sourcesImages[0], 0, 0, null);
-                canvas.drawBitmap(sourcesImages[1], minWidth / 2, 0, null);
-                canvas.drawBitmap(sourcesImages[2], 0, minHeight/2, null);
-                break;
-            case 4:
-                for (int i = 0; i < count; ++i)
-                    sourcesImages[i] = BitmapUtil.centerCrop(sourcesImages[i], minWidth, minHeight);
-                canvas.drawBitmap(sourcesImages[0], 0, 0, null);
-                canvas.drawBitmap(sourcesImages[1], minWidth , 0, null);
-                canvas.drawBitmap(sourcesImages[2], 0, minHeight, null);
-                canvas.drawBitmap(sourcesImages[3], minWidth , minHeight, null);
-                break;
-        }
-        return bmOverlay;
-    }
-
-    private static void saveOnDisk(Bitmap bitmap, String destPath) {
-        final ByteArrayOutputStream stream = new ByteArrayOutputStream();
-        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream);
-        final byte[] byteArray = stream.toByteArray();
-        FileOutputStream fos = null;
-        try {
-            fos = new FileOutputStream(destPath);
-            fos.write(byteArray);
-        } catch (java.io.IOException e) {
-            e.printStackTrace();
-        } finally {
-            Util.close(fos);
-            Util.close(stream);
-        }
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/util/ThumbnailsProvider.kt b/vlc-android/src/org/videolan/vlc/util/ThumbnailsProvider.kt
new file mode 100644
index 0000000000..f124212356
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/util/ThumbnailsProvider.kt
@@ -0,0 +1,273 @@
+package org.videolan.vlc.util
+
+
+import android.graphics.Bitmap
+import android.graphics.Canvas
+import android.graphics.Rect
+import android.media.ThumbnailUtils
+import android.net.Uri
+import android.provider.MediaStore
+import android.text.TextUtils
+import androidx.annotation.WorkerThread
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.withContext
+import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.Medialibrary.THUMBS_FOLDER_NAME
+import org.videolan.medialibrary.media.Folder
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.VLCApplication
+import org.videolan.vlc.gui.helpers.AudioUtil
+import org.videolan.vlc.gui.helpers.AudioUtil.readCoverBitmap
+import org.videolan.vlc.gui.helpers.BitmapCache
+import org.videolan.vlc.gui.helpers.BitmapUtil
+import org.videolan.vlc.gui.helpers.UiTools
+import org.videolan.vlc.media.MediaGroup
+import java.io.ByteArrayOutputStream
+import java.io.File
+import java.io.FileOutputStream
+import java.util.*
+import kotlin.collections.ArrayList
+
+object ThumbnailsProvider {
+
+    private val TAG = "VLC/ThumbnailsProvider"
+
+    private var appDir: File? = null
+    private var cacheDir: String? = null
+    private const val MAX_IMAGES = 4
+    private val lock = Any()
+
+    @WorkerThread
+    fun getFolderThumbnail(folder: Folder, width: Int): Bitmap {
+        val media = Arrays.asList(*folder.media(Folder.TYPE_FOLDER_VIDEO, Medialibrary.SORT_DEFAULT, true, 4, 0))
+        return getComposedImage("folder:" + folder.title, media, width)
+    }
+
+    @WorkerThread
+    fun getMediaThumbnail(item: MediaWrapper, width: Int): Bitmap? {
+        if (item.type == MediaWrapper.TYPE_GROUP) return ThumbnailsProvider.getComposedImage("group:" + item.title, (item as MediaGroup).all, width)
+        return if (item.type == MediaWrapper.TYPE_VIDEO && TextUtils.isEmpty(item.artworkMrl))
+            getVideoThumbnail(item, width)
+        else
+            AudioUtil.readCoverBitmap(Uri.decode(item.artworkMrl), width)
+    }
+
+    fun getMediaCacheKey(isMedia: Boolean, item: MediaLibraryItem): String? {
+        if (isMedia && (item as MediaWrapper).type == MediaWrapper.TYPE_VIDEO && TextUtils.isEmpty(item.getArtworkMrl())) {
+            if (appDir == null) appDir = VLCApplication.getAppContext().getExternalFilesDir(null)
+            val hasCache = appDir != null && appDir!!.exists()
+            if (hasCache && cacheDir == null) cacheDir = appDir!!.absolutePath + THUMBS_FOLDER_NAME
+            return if (hasCache) StringBuilder(cacheDir!!).append('/').append(item.getTitle()).append(".jpg").toString() else null
+        }
+        return item.artworkMrl
+    }
+
+    @WorkerThread
+    private fun getVideoThumbnail(media: MediaWrapper, width: Int): Bitmap? {
+        val filePath = media.uri.path
+        if (appDir == null) appDir = VLCApplication.getAppContext().getExternalFilesDir(null)
+        val hasCache = appDir != null && appDir!!.exists()
+        val thumbPath = getMediaCacheKey(true, media)
+        val cacheBM = if (hasCache) BitmapCache.getInstance().getBitmapFromMemCache(thumbPath) else null
+        if (cacheBM != null) return cacheBM
+        if (hasCache && File(thumbPath).exists()) return readCoverBitmap(thumbPath, width)
+        if (media.isThumbnailGenerated) return null
+        val bitmap: Bitmap?
+        synchronized(lock) {
+            bitmap = ThumbnailUtils.createVideoThumbnail(filePath, MediaStore.Video.Thumbnails.MINI_KIND)
+        }
+        if (bitmap != null) {
+            BitmapCache.getInstance().addBitmapToMemCache(thumbPath, bitmap)
+            if (hasCache) {
+                media.setThumbnail(thumbPath)
+                saveOnDisk(bitmap, thumbPath)
+                media.artworkURL = thumbPath
+            }
+        } else if (media.id != 0L) {
+            Medialibrary.getInstance().requestThumbnail(media.id)
+        }
+        return bitmap
+    }
+
+    suspend fun getPlaylistImage(key: String, mediaList: List<MediaWrapper>, width: Int): Bitmap? {
+        val bmc = BitmapCache.getInstance()
+        var composedImage = bmc.getBitmapFromMemCache(key)
+        if (composedImage == null) {
+            composedImage = composePlaylistImage(mediaList, width)
+            if (composedImage != null) bmc.addBitmapToMemCache(key, composedImage)
+        }
+        return composedImage
+    }
+
+    /**
+     * Compose 1 image from tracks of a Playlist
+     * @param mediaList The track list of the playlist
+     * @return a Bitmap object
+     */
+    private suspend fun composePlaylistImage(mediaList: List<MediaWrapper>, width: Int): Bitmap? {
+        val url = mediaList[0].artworkURL
+        val isAllSameImage = !mediaList.any { it.artworkURL != url }
+
+        if (isAllSameImage) {
+
+            return obtainBitmap(mediaList[0], width)
+        }
+
+        val artworks = ArrayList<MediaWrapper>()
+        for (mediaWrapper in mediaList) {
+
+            val artworkAlreadyHere = artworks.any { it.artworkURL == mediaWrapper.artworkURL }
+
+            if (mediaWrapper.artworkURL != null && mediaWrapper.artworkURL.isNotBlank() && !artworkAlreadyHere) {
+                artworks.add(mediaWrapper)
+            }
+            if (artworks.size > 3) {
+                break
+            }
+        }
+
+        if (artworks.size == 2) {
+            artworks.add(artworks[1])
+            artworks.add(artworks[0])
+        } else if (artworks.size == 3) {
+            artworks.add(artworks[0])
+        }
+
+
+        val images = ArrayList<Bitmap>(4)
+        artworks.forEach {
+            val image = obtainBitmap(it, width / 2)
+            if (image != null) {
+                images.add(image)
+            }
+            if (images.size >= 4) {
+                return@forEach
+            }
+
+        }
+
+
+        for (i in 0..3) {
+            if (images.size < i + 1) {
+                images.add(UiTools.getDefaultAudioDrawable(VLCApplication.getAppContext()).bitmap)
+            }
+        }
+
+        val cs = Bitmap.createBitmap(width, width, Bitmap.Config.ARGB_8888)
+        val comboImage = Canvas(cs)
+        comboImage.drawBitmap(images[0], Rect(0, 0, images[0].width, images[0].height), Rect(0, 0, width / 2, width / 2), null)
+        comboImage.drawBitmap(images[1], Rect(0, 0, images[1].width, images[1].height), Rect(width / 2, 0, width, width / 2), null)
+        comboImage.drawBitmap(images[2], Rect(0, 0, images[2].width, images[2].height), Rect(0, width / 2, width / 2, width), null)
+        comboImage.drawBitmap(images[3], Rect(0, 0, images[3].width, images[3].height), Rect(width / 2, width / 2, width, width), null)
+
+        return cs
+    }
+
+    suspend fun obtainBitmap(item: MediaLibraryItem, width: Int) = withContext(Dispatchers.IO) {
+        when (item) {
+            is MediaWrapper -> getMediaThumbnail(item, width)
+            is Folder -> getFolderThumbnail(item, width)
+            else -> readCoverBitmap(Uri.decode(item.artworkMrl), width)
+        }
+    }
+
+
+    @WorkerThread
+    fun getComposedImage(key: String, mediaList: List<MediaWrapper>, width: Int): Bitmap {
+        val bmc = BitmapCache.getInstance()
+        var composedImage = bmc.getBitmapFromMemCache(key)
+        if (composedImage == null) {
+            composedImage = composeImage(mediaList, width)
+            if (composedImage != null) bmc.addBitmapToMemCache(key, composedImage)
+        }
+        return composedImage
+    }
+
+    /**
+     * Compose 1 image from combined media thumbnails
+     * @param mediaList The media list from which will extract thumbnails
+     * @return a Bitmap object
+     */
+    private fun composeImage(mediaList: List<MediaWrapper>, imageWidth: Int): Bitmap? {
+        val sourcesImages = arrayOfNulls<Bitmap>(Math.min(MAX_IMAGES, mediaList.size))
+        var count = 0
+        var minWidth = Integer.MAX_VALUE
+        var minHeight = Integer.MAX_VALUE
+        for (media in mediaList) {
+            val bm = getVideoThumbnail(media, imageWidth)
+            if (bm != null) {
+                val width = bm.width
+                val height = bm.height
+                sourcesImages[count++] = bm
+                minWidth = Math.min(minWidth, width)
+                minHeight = Math.min(minHeight, height)
+                if (count == MAX_IMAGES) break
+            }
+        }
+        if (count == 0) return null
+        val sources = Array(sourcesImages.size) {
+            sourcesImages[it]!!
+        }
+        return if (count == 1) sourcesImages[0] else composeCanvas(sources, count, minWidth, minHeight)
+    }
+
+    private fun composeCanvas(sourcesImages: Array<Bitmap>, count: Int, minWidth: Int, minHeight: Int): Bitmap {
+        val overlayWidth: Int
+        val overlayHeight: Int
+        when (count) {
+            4 -> {
+                overlayWidth = 2 * minWidth
+                overlayHeight = 2 * minHeight
+            }
+            else -> {
+                overlayWidth = minWidth
+                overlayHeight = minHeight
+            }
+        }
+        val bmOverlay = Bitmap.createBitmap(overlayWidth, overlayHeight, sourcesImages[0].config)
+
+        val canvas = Canvas(bmOverlay)
+        when (count) {
+            2 -> {
+                for (i in 0 until count)
+                    sourcesImages[i] = BitmapUtil.centerCrop(sourcesImages[i], minWidth / 2, minHeight)
+                canvas.drawBitmap(sourcesImages[0], 0f, 0f, null)
+                canvas.drawBitmap(sourcesImages[1], (minWidth / 2).toFloat(), 0f, null)
+            }
+            3 -> {
+                sourcesImages[0] = BitmapUtil.centerCrop(sourcesImages[0], minWidth / 2, minHeight / 2)
+                sourcesImages[1] = BitmapUtil.centerCrop(sourcesImages[1], minWidth / 2, minHeight / 2)
+                sourcesImages[2] = BitmapUtil.centerCrop(sourcesImages[2], minWidth, minHeight / 2)
+                canvas.drawBitmap(sourcesImages[0], 0f, 0f, null)
+                canvas.drawBitmap(sourcesImages[1], (minWidth / 2).toFloat(), 0f, null)
+                canvas.drawBitmap(sourcesImages[2], 0f, (minHeight / 2).toFloat(), null)
+            }
+            4 -> {
+                for (i in 0 until count)
+                    sourcesImages[i] = BitmapUtil.centerCrop(sourcesImages[i], minWidth, minHeight)
+                canvas.drawBitmap(sourcesImages[0], 0f, 0f, null)
+                canvas.drawBitmap(sourcesImages[1], minWidth.toFloat(), 0f, null)
+                canvas.drawBitmap(sourcesImages[2], 0f, minHeight.toFloat(), null)
+                canvas.drawBitmap(sourcesImages[3], minWidth.toFloat(), minHeight.toFloat(), null)
+            }
+        }
+        return bmOverlay
+    }
+
+    private fun saveOnDisk(bitmap: Bitmap, destPath: String?) {
+        val stream = ByteArrayOutputStream()
+        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream)
+        val byteArray = stream.toByteArray()
+        var fos: FileOutputStream? = null
+        try {
+            fos = FileOutputStream(destPath)
+            fos.write(byteArray)
+        } catch (e: java.io.IOException) {
+            e.printStackTrace()
+        } finally {
+            Util.close(fos)
+            Util.close(stream)
+        }
+    }
+}
