diff --git a/vlc-android/src/org/videolan/vlc/gui/helpers/PlayerOptionsDelegate.kt b/vlc-android/src/org/videolan/vlc/gui/helpers/PlayerOptionsDelegate.kt
index 8af5a2a41d..b08cd34bb1 100644
--- a/vlc-android/src/org/videolan/vlc/gui/helpers/PlayerOptionsDelegate.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/helpers/PlayerOptionsDelegate.kt
@@ -68,7 +68,7 @@ class PlayerOptionsDelegate(val activity: AppCompatActivity, val service: Playba
     var flags: Int = 0
     private val toast by lazy(LazyThreadSafetyMode.NONE) { Toast.makeText(activity, "", Toast.LENGTH_SHORT) }
 
-    private val primary = activity is VideoPlayerActivity && activity.mDisplayManager.isPrimary
+    private val primary = activity is VideoPlayerActivity && activity.displayManager.isPrimary
     private val video = activity is VideoPlayerActivity
     private val res = activity.resources
     private val tvUi by lazy(LazyThreadSafetyMode.NONE) { AndroidDevices.showTvUi(activity) }
diff --git a/vlc-android/src/org/videolan/vlc/gui/tv/MediaItemDetailsFragment.java b/vlc-android/src/org/videolan/vlc/gui/tv/MediaItemDetailsFragment.java
index 54271644dc..0ec26287c8 100644
--- a/vlc-android/src/org/videolan/vlc/gui/tv/MediaItemDetailsFragment.java
+++ b/vlc-android/src/org/videolan/vlc/gui/tv/MediaItemDetailsFragment.java
@@ -170,7 +170,7 @@ public void run() {
                         break;
                     case ID_PLAY_FROM_START:
                         mMediaStarted = false;
-                        VideoPlayerActivity.start(getActivity(), media.getUri(), true);
+                        VideoPlayerActivity.Companion.start(getActivity(), media.getUri(), true);
                         activity.finish();
                         break;
                 }
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/MediaInfoAdapter.java b/vlc-android/src/org/videolan/vlc/gui/video/MediaInfoAdapter.java
deleted file mode 100644
index a369733368..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/video/MediaInfoAdapter.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*****************************************************************************
- * MediaInfoAdapter.java
- *****************************************************************************
- * Copyright © 2011-2017 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.video;
-
-import android.content.Context;
-import android.content.res.Resources;
-import androidx.recyclerview.widget.RecyclerView;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-
-import org.videolan.libvlc.Media;
-import org.videolan.vlc.R;
-import org.videolan.vlc.util.Strings;
-
-import java.util.List;
-
-public class MediaInfoAdapter extends RecyclerView.Adapter<MediaInfoAdapter.ViewHolder> {
-    private LayoutInflater inflater;
-    private List<Media.Track> mDataset;
-
-    @Override
-    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
-        if (inflater == null)
-            inflater = (LayoutInflater) parent.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        return new ViewHolder(inflater.inflate(R.layout.info_item, parent, false));
-    }
-
-    @Override
-    public void onBindViewHolder(ViewHolder holder, int position) {
-        Media.Track track = mDataset.get(position);
-        String title;
-        StringBuilder textBuilder = new StringBuilder();
-        Resources res = holder.itemView.getContext().getResources();
-        switch (track.type) {
-            case Media.Track.Type.Audio:
-                title = res.getString(R.string.track_audio);
-                appendCommon(textBuilder, res, track);
-                appendAudio(textBuilder, res, (Media.AudioTrack)track);
-                break;
-            case Media.Track.Type.Video:
-                title = res.getString(R.string.track_video);
-                appendCommon(textBuilder, res, track);
-                appendVideo(textBuilder, res, (Media.VideoTrack) track);
-                break;
-            case Media.Track.Type.Text:
-                title = res.getString(R.string.track_text);
-                appendCommon(textBuilder, res, track);
-                break;
-            default:
-                title = res.getString(R.string.track_unknown);
-        }
-        holder.title.setText(title);
-        holder.text.setText(textBuilder.toString());
-    }
-
-    @Override
-    public int getItemCount() {
-        return mDataset == null ? 0 : mDataset.size();
-    }
-
-    public void setTracks(List<Media.Track> tracks) {
-        int size = getItemCount();
-        mDataset = tracks;
-        if (size > 0)
-            notifyItemRangeRemoved(0, size-1);
-        notifyItemRangeInserted(0, tracks.size());
-    }
-
-    private void appendCommon(StringBuilder textBuilder, Resources res, Media.Track track) {
-        if (track.bitrate != 0)
-            textBuilder.append(res.getString(R.string.track_bitrate_info, Strings.readableSize(track.bitrate)));
-        textBuilder.append(res.getString(R.string.track_codec_info, track.codec));
-        if (track.language != null && !track.language.equalsIgnoreCase("und"))
-            textBuilder.append(res.getString(R.string.track_language_info, track.language));
-    }
-
-    private void appendAudio(StringBuilder textBuilder, Resources res, Media.AudioTrack track) {
-        textBuilder.append(res.getQuantityString(R.plurals.track_channels_info_quantity, track.channels, track.channels));
-        textBuilder.append(res.getString(R.string.track_samplerate_info, track.rate));
-    }
-
-    private void appendVideo(StringBuilder textBuilder, Resources res, Media.VideoTrack track) {
-        final double framerate = track.frameRateNum / (double) track.frameRateDen;
-        if( track.width != 0 && track.height != 0 )
-            textBuilder.append(res.getString(R.string.track_resolution_info, track.width, track.height));
-        if( !Double.isNaN(framerate) )
-            textBuilder.append(res.getString(R.string.track_framerate_info, framerate));
-    }
-
-    class ViewHolder extends RecyclerView.ViewHolder {
-        private TextView title, text;
-
-        public ViewHolder(View itemView) {
-            super(itemView);
-            title = itemView.findViewById(R.id.title);
-            text = itemView.findViewById(R.id.subtitle);
-        }
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/MediaInfoAdapter.kt b/vlc-android/src/org/videolan/vlc/gui/video/MediaInfoAdapter.kt
new file mode 100644
index 0000000000..037e592225
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/MediaInfoAdapter.kt
@@ -0,0 +1,108 @@
+/*****************************************************************************
+ * MediaInfoAdapter.java
+ *
+ * Copyright © 2011-2017 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.video
+
+import android.content.Context
+import android.content.res.Resources
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import androidx.recyclerview.widget.RecyclerView
+import org.videolan.libvlc.Media
+import org.videolan.vlc.R
+import org.videolan.vlc.util.readableSize
+
+class MediaInfoAdapter : RecyclerView.Adapter<MediaInfoAdapter.ViewHolder>() {
+    private var inflater: LayoutInflater? = null
+    private var dataset: List<Media.Track>? = null
+
+    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
+        if (inflater == null)
+            inflater = parent.context.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
+        return ViewHolder(inflater!!.inflate(R.layout.info_item, parent, false))
+    }
+
+    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
+        val track = dataset!![position]
+        val title: String
+        val textBuilder = StringBuilder()
+        val res = holder.itemView.context.resources
+        when (track.type) {
+            Media.Track.Type.Audio -> {
+                title = res.getString(R.string.track_audio)
+                appendCommon(textBuilder, res, track)
+                appendAudio(textBuilder, res, track as Media.AudioTrack)
+            }
+            Media.Track.Type.Video -> {
+                title = res.getString(R.string.track_video)
+                appendCommon(textBuilder, res, track)
+                appendVideo(textBuilder, res, track as Media.VideoTrack)
+            }
+            Media.Track.Type.Text -> {
+                title = res.getString(R.string.track_text)
+                appendCommon(textBuilder, res, track)
+            }
+            else -> title = res.getString(R.string.track_unknown)
+        }
+        holder.title.text = title
+        holder.text.text = textBuilder.toString()
+    }
+
+    override fun getItemCount(): Int {
+        return if (dataset == null) 0 else dataset!!.size
+    }
+
+    fun setTracks(tracks: List<Media.Track>) {
+        val size = itemCount
+        dataset = tracks
+        if (size > 0)
+            notifyItemRangeRemoved(0, size - 1)
+        notifyItemRangeInserted(0, tracks.size)
+    }
+
+    private fun appendCommon(textBuilder: StringBuilder, res: Resources, track: Media.Track) {
+        if (track.bitrate != 0)
+            textBuilder.append(res.getString(R.string.track_bitrate_info, track.bitrate.toLong().readableSize()))
+        textBuilder.append(res.getString(R.string.track_codec_info, track.codec))
+        if (track.language != null && !track.language.equals("und", ignoreCase = true))
+            textBuilder.append(res.getString(R.string.track_language_info, track.language))
+    }
+
+    private fun appendAudio(textBuilder: StringBuilder, res: Resources, track: Media.AudioTrack) {
+        textBuilder.append(res.getQuantityString(R.plurals.track_channels_info_quantity, track.channels, track.channels))
+        textBuilder.append(res.getString(R.string.track_samplerate_info, track.rate))
+    }
+
+    private fun appendVideo(textBuilder: StringBuilder, res: Resources, track: Media.VideoTrack) {
+        val framerate = track.frameRateNum / track.frameRateDen.toDouble()
+        if (track.width != 0 && track.height != 0)
+            textBuilder.append(res.getString(R.string.track_resolution_info, track.width, track.height))
+        if (!java.lang.Double.isNaN(framerate))
+            textBuilder.append(res.getString(R.string.track_framerate_info, framerate))
+    }
+
+    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
+        val title: TextView = itemView.findViewById(R.id.title)
+        val text: TextView = itemView.findViewById(R.id.subtitle)
+
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/PopupManager.java b/vlc-android/src/org/videolan/vlc/gui/video/PopupManager.java
deleted file mode 100644
index f221154f70..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/video/PopupManager.java
+++ /dev/null
@@ -1,329 +0,0 @@
-/*
- * ************************************************************************
- *  PopupManager.java
- * *************************************************************************
- *  Copyright © 2016 VLC authors and VideoLAN
- *  Author: Geoffrey Métais
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *
- *  *************************************************************************
- */
-
-package org.videolan.vlc.gui.video;
-
-import android.app.PendingIntent;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
-import android.view.GestureDetector;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.SurfaceView;
-import android.view.View;
-import android.widget.ImageView;
-
-import org.jetbrains.annotations.NotNull;
-import org.videolan.libvlc.IVLCVout;
-import org.videolan.libvlc.Media;
-import org.videolan.libvlc.MediaPlayer;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.PlaybackService;
-import org.videolan.vlc.R;
-import org.videolan.vlc.gui.preferences.PreferencesActivity;
-import org.videolan.vlc.gui.view.PopupLayout;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.KextensionsKt;
-import org.videolan.vlc.util.Settings;
-
-import androidx.core.app.NotificationCompat;
-import androidx.core.view.GestureDetectorCompat;
-
-public class PopupManager implements PlaybackService.Callback, GestureDetector.OnDoubleTapListener,
-        View.OnClickListener, GestureDetector.OnGestureListener, IVLCVout.OnNewVideoLayoutListener, IVLCVout.Callback {
-
-    private static final String TAG ="VLC/PopupManager";
-
-    private static final int FLING_STOP_VELOCITY = 3000;
-    private static final int MSG_DELAY = 3000;
-
-    private static final int SHOW_BUTTONS = 0;
-    private static final int HIDE_BUTTONS = 1;
-
-    private PlaybackService mService;
-
-    private PopupLayout mRootView;
-    private ImageView mExpandButton;
-    private ImageView mCloseButton;
-    private ImageView mPlayPauseButton;
-    private final boolean mAlwaysOn;
-
-    public PopupManager(PlaybackService service) {
-        mService = service;
-        mAlwaysOn = Settings.INSTANCE.getInstance(service).getBoolean("popup_keepscreen", false);
-    }
-
-    public void removePopup() {
-        hideNotification();
-        if (mRootView == null) return;
-        mService.removeCallback(this);
-        final IVLCVout vlcVout = mService.getVout();
-        if (vlcVout != null) vlcVout.detachViews();
-        mRootView.close();
-        mRootView = null;
-    }
-
-    public void showPopup() {
-        mService.addCallback(this);
-        final LayoutInflater li = (LayoutInflater) mService.getApplicationContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        if (li == null) return;
-        mRootView = (PopupLayout) li.inflate(R.layout.video_popup, null);
-        if (mAlwaysOn) mRootView.setKeepScreenOn(true);
-        mPlayPauseButton = mRootView.findViewById(R.id.video_play_pause);
-        mCloseButton = mRootView.findViewById(R.id.popup_close);
-        mExpandButton = mRootView.findViewById(R.id.popup_expand);
-        mPlayPauseButton.setOnClickListener(this);
-        mCloseButton.setOnClickListener(this);
-        mExpandButton.setOnClickListener(this);
-
-        GestureDetectorCompat gestureDetector = new GestureDetectorCompat(mService, this);
-        gestureDetector.setOnDoubleTapListener(this);
-        mRootView.setGestureDetector(gestureDetector);
-
-        final IVLCVout vlcVout = mService.getVout();
-        if (vlcVout == null) return;
-        vlcVout.setVideoView((SurfaceView) mRootView.findViewById(R.id.player_surface));
-        vlcVout.addCallback(this);
-        vlcVout.attachViews(this);
-        mRootView.setVLCVOut(vlcVout);
-    }
-
-    @Override
-    public boolean onSingleTapConfirmed(MotionEvent e) {
-        if (mPlayPauseButton.getVisibility() == View.VISIBLE) return false;
-        mHandler.sendEmptyMessage(SHOW_BUTTONS);
-        mHandler.sendEmptyMessageDelayed(HIDE_BUTTONS, MSG_DELAY);
-        return true;
-    }
-
-    @Override
-    public boolean onDoubleTap(MotionEvent e) {
-        expandToVideoPlayer();
-        return true;
-    }
-
-    @Override
-    public boolean onDoubleTapEvent(MotionEvent e) {
-        return false;
-    }
-
-    @Override
-    public boolean onDown(MotionEvent e) {
-        return false;
-    }
-
-    @Override
-    public void onShowPress(MotionEvent e) {}
-
-    @Override
-    public boolean onSingleTapUp(MotionEvent e) {
-        return false;
-    }
-
-    @Override
-    public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
-        return false;
-    }
-
-    @Override
-    public void onLongPress(MotionEvent e) {}
-
-    @Override
-    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
-        if (Math.abs(velocityX) > FLING_STOP_VELOCITY || velocityY > FLING_STOP_VELOCITY) {
-            stopPlayback();
-            return true;
-        }
-        return false;
-    }
-
-    @Override
-    public void onNewVideoLayout(IVLCVout vlcVout, int width, int height,
-                                 int visibleWidth, int visibleHeight, int sarNum, int sarDen) {
-        if (mRootView == null) return;
-        int displayW = mRootView.getWidth(), displayH = mRootView.getHeight();
-
-        // sanity check
-        if (displayW * displayH == 0) {
-            Log.e(TAG, "Invalid surface size");
-            return;
-        }
-
-        if (width == 0 || height == 0) {
-            mRootView.setViewSize(displayW, displayH);
-            return;
-        }
-
-        // compute the aspect ratio
-        double dw = displayW, dh = displayH;
-        double ar;
-        if (sarDen == sarNum) {
-            /* No indication about the density, assuming 1:1 */
-            ar = (double)visibleWidth / (double)visibleHeight;
-        } else {
-            /* Use the specified aspect ratio */
-            double vw = visibleWidth * (double)sarNum / sarDen;
-            ar = vw / visibleHeight;
-        }
-
-        // compute the display aspect ratio
-        double dar = dw / dh;
-        if (dar < ar) dh = dw / ar;
-        else dw = dh * ar;
-
-        width = (int) Math.floor(dw);
-        height = (int) Math.floor(dh);
-        mRootView.setViewSize(width, height);
-    }
-
-    @Override
-    public void update() {}
-
-    @Override
-    public void onMediaEvent(@NotNull Media.Event event) {}
-
-    @Override
-    public void onMediaPlayerEvent(@NotNull MediaPlayer.Event event) {
-        switch (event.type) {
-            case MediaPlayer.Event.Playing:
-                if (mRootView != null) {
-                    if (!mAlwaysOn) mRootView.setKeepScreenOn(true);
-                    mPlayPauseButton.setImageResource(R.drawable.ic_popup_pause);
-                }
-                showNotification();
-                break;
-            case MediaPlayer.Event.Paused:
-                if (mRootView != null) {
-                    if (!mAlwaysOn) mRootView.setKeepScreenOn(false);
-                    mPlayPauseButton.setImageResource(R.drawable.ic_popup_play);
-                }
-                showNotification();
-                break;
-        }
-    }
-
-    private Handler mHandler = new Handler(Looper.getMainLooper()) {
-        @Override
-        public void handleMessage(Message msg) {
-            int visibility = msg.what == SHOW_BUTTONS ? View.VISIBLE : View.GONE;
-            mPlayPauseButton.setVisibility(visibility);
-            mCloseButton.setVisibility(visibility);
-            mExpandButton.setVisibility(visibility);
-        }
-    };
-
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.video_play_pause:
-                if (mService.hasMedia()) {
-                    if (mService.isPlaying())
-                        mService.pause();
-                    else
-                        mService.play();
-                }
-                break;
-            case R.id.popup_close:
-                stopPlayback();
-                break;
-            case R.id.popup_expand:
-                expandToVideoPlayer();
-                break;
-        }
-    }
-
-    private void expandToVideoPlayer() {
-        removePopup();
-        if (mService.hasMedia() && !mService.isPlaying())
-            mService.getCurrentMediaWrapper().setFlags(MediaWrapper.MEDIA_PAUSED);
-        mService.switchToVideo();
-    }
-
-    private void stopPlayback() {
-        long time = mService.getTime();
-        if (time != -1) {
-            // remove saved position if in the last 5 seconds
-            // else, go back 2 seconds, to compensate loading time
-            time = mService.getLength() - time < 5000 ? 0 :  2000;
-            // Save position
-            if (mService.isSeekable())
-                Settings.INSTANCE.getInstance(mService).edit()
-                        .putLong(PreferencesActivity.VIDEO_RESUME_TIME, time).apply();
-        }
-        mService.stop();
-    }
-
-    @SuppressWarnings("deprecation")
-    private void showNotification() {
-        final PendingIntent piStop = KextensionsKt.getPendingIntent(mService, new Intent(Constants.ACTION_REMOTE_STOP));
-        final NotificationCompat.Builder builder = new NotificationCompat.Builder(mService, "misc")
-                .setSmallIcon(R.drawable.ic_notif_video)
-                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
-                .setContentTitle(mService.getTitle())
-                .setContentText(mService.getString(R.string.popup_playback))
-                .setAutoCancel(false)
-                .setOngoing(true)
-                .setContentIntent(mService.getSessionPendingIntent())
-                .setDeleteIntent(piStop);
-
-        //Switch
-        final Intent notificationIntent = new Intent(Constants.ACTION_REMOTE_SWITCH_VIDEO);
-        final PendingIntent piExpand = KextensionsKt.getPendingIntent(mService, notificationIntent);
-        //PLay Pause
-        final PendingIntent piPlay = KextensionsKt.getPendingIntent(mService, new Intent(Constants.ACTION_REMOTE_PLAYPAUSE));
-
-        if (mService.isPlaying())
-            builder.addAction(R.drawable.ic_popup_pause, mService.getString(R.string.pause), piPlay);
-        else
-            builder.addAction(R.drawable.ic_popup_play, mService.getString(R.string.play), piPlay);
-        builder.addAction(R.drawable.ic_popup_expand_w, mService.getString(R.string.popup_expand), piExpand);
-        mService.startForeground(42, builder.build());
-    }
-
-    private void hideNotification() {
-        mService.stopForeground(true);
-    }
-
-    @Override
-    public void onSurfacesCreated(IVLCVout vlcVout) {
-        mService.setVideoAspectRatio(null);
-        mService.setVideoScale(0);
-        mService.setVideoTrackEnabled(true);
-        if (mService.hasMedia()) {
-            mService.flush();
-            mPlayPauseButton.setImageResource(mService.isPlaying() ? R.drawable.ic_popup_pause : R.drawable.ic_popup_play);
-        } else
-            mService.playIndex(mService.getCurrentMediaPosition());
-        showNotification();
-    }
-
-    @Override
-    public void onSurfacesDestroyed(IVLCVout vlcVout) {
-        vlcVout.removeCallback(this);
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/PopupManager.kt b/vlc-android/src/org/videolan/vlc/gui/video/PopupManager.kt
new file mode 100644
index 0000000000..31982c1ef1
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/PopupManager.kt
@@ -0,0 +1,299 @@
+/*
+ * ************************************************************************
+ *  PopupManager.java
+ * *************************************************************************
+ *  Copyright © 2016 VLC authors and VideoLAN
+ *  Author: Geoffrey Métais
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *
+ *  *************************************************************************
+ */
+
+package org.videolan.vlc.gui.video
+
+import android.content.Context
+import android.content.Intent
+import android.os.Handler
+import android.os.Looper
+import android.os.Message
+import android.util.Log
+import android.view.*
+import android.widget.ImageView
+import androidx.core.app.NotificationCompat
+import androidx.core.view.GestureDetectorCompat
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.IVLCVout
+import org.videolan.libvlc.Media
+import org.videolan.libvlc.MediaPlayer
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.PlaybackService
+import org.videolan.vlc.R
+import org.videolan.vlc.gui.preferences.PreferencesActivity
+import org.videolan.vlc.gui.view.PopupLayout
+import org.videolan.vlc.util.*
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class PopupManager constructor(private val mService: PlaybackService) : PlaybackService.Callback, GestureDetector.OnDoubleTapListener, View.OnClickListener, GestureDetector.OnGestureListener, IVLCVout.OnNewVideoLayoutListener, IVLCVout.Callback {
+
+    private var rootView: PopupLayout? = null
+    private lateinit var expandButton: ImageView
+    private lateinit var closeButton: ImageView
+    private lateinit var playPauseButton: ImageView
+    private val alwaysOn: Boolean = Settings.getInstance(mService).getBoolean("popup_keepscreen", false)
+
+    private val handler = object : Handler(Looper.getMainLooper()) {
+        override fun handleMessage(msg: Message) {
+            val visibility = if (msg.what == SHOW_BUTTONS) View.VISIBLE else View.GONE
+            playPauseButton.visibility = visibility
+            closeButton.visibility = visibility
+            expandButton.visibility = visibility
+        }
+    }
+
+    fun removePopup() {
+        hideNotification()
+        if (rootView == null) return
+        mService.removeCallback(this)
+        val vlcVout = mService.vout
+        vlcVout?.detachViews()
+        rootView!!.close()
+        rootView = null
+    }
+
+    fun showPopup() {
+        mService.addCallback(this)
+        val li = mService.applicationContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
+                ?: return
+        rootView = li.inflate(R.layout.video_popup, null) as PopupLayout
+        if (alwaysOn) rootView!!.keepScreenOn = true
+        playPauseButton = rootView!!.findViewById(R.id.video_play_pause)
+        closeButton = rootView!!.findViewById(R.id.popup_close)
+        expandButton = rootView!!.findViewById(R.id.popup_expand)
+        playPauseButton.setOnClickListener(this)
+        closeButton.setOnClickListener(this)
+        expandButton.setOnClickListener(this)
+
+        val gestureDetector = GestureDetectorCompat(mService, this)
+        gestureDetector.setOnDoubleTapListener(this)
+        rootView!!.setGestureDetector(gestureDetector)
+
+        val vlcVout = mService.vout ?: return
+        vlcVout.setVideoView(rootView!!.findViewById<View>(R.id.player_surface) as SurfaceView)
+        vlcVout.addCallback(this)
+        vlcVout.attachViews(this)
+        rootView!!.setVLCVOut(vlcVout)
+    }
+
+    override fun onSingleTapConfirmed(e: MotionEvent): Boolean {
+        if (playPauseButton.visibility == View.VISIBLE) return false
+        handler.sendEmptyMessage(SHOW_BUTTONS)
+        handler.sendEmptyMessageDelayed(HIDE_BUTTONS, MSG_DELAY.toLong())
+        return true
+    }
+
+    override fun onDoubleTap(e: MotionEvent): Boolean {
+        expandToVideoPlayer()
+        return true
+    }
+
+    override fun onDoubleTapEvent(e: MotionEvent): Boolean {
+        return false
+    }
+
+    override fun onDown(e: MotionEvent): Boolean {
+        return false
+    }
+
+    override fun onShowPress(e: MotionEvent) {}
+
+    override fun onSingleTapUp(e: MotionEvent): Boolean {
+        return false
+    }
+
+    override fun onScroll(e1: MotionEvent, e2: MotionEvent, distanceX: Float, distanceY: Float): Boolean {
+        return false
+    }
+
+    override fun onLongPress(e: MotionEvent) {}
+
+    override fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean {
+        if (Math.abs(velocityX) > FLING_STOP_VELOCITY || velocityY > FLING_STOP_VELOCITY) {
+            stopPlayback()
+            return true
+        }
+        return false
+    }
+
+    override fun onNewVideoLayout(vlcVout: IVLCVout, width: Int, height: Int,
+                                  visibleWidth: Int, visibleHeight: Int, sarNum: Int, sarDen: Int) {
+        var width = width
+        var height = height
+        if (rootView == null) return
+        val displayW = rootView!!.width
+        val displayH = rootView!!.height
+
+        // sanity check
+        if (displayW * displayH == 0) {
+            Log.e(TAG, "Invalid surface size")
+            return
+        }
+
+        if (width == 0 || height == 0) {
+            rootView!!.setViewSize(displayW, displayH)
+            return
+        }
+
+        // compute the aspect ratio
+        var dw = displayW.toDouble()
+        var dh = displayH.toDouble()
+        val ar: Double
+        ar = if (sarDen == sarNum) {
+            /* No indication about the density, assuming 1:1 */
+            visibleWidth.toDouble() / visibleHeight.toDouble()
+        } else {
+            /* Use the specified aspect ratio */
+            val vw = visibleWidth * sarNum.toDouble() / sarDen
+            vw / visibleHeight
+        }
+
+        // compute the display aspect ratio
+        val dar = dw / dh
+        if (dar < ar)
+            dh = dw / ar
+        else
+            dw = dh * ar
+
+        width = Math.floor(dw).toInt()
+        height = Math.floor(dh).toInt()
+        rootView!!.setViewSize(width, height)
+    }
+
+    override fun update() {}
+
+    override fun onMediaEvent(event: Media.Event) {}
+
+    override fun onMediaPlayerEvent(event: MediaPlayer.Event) {
+        when (event.type) {
+            MediaPlayer.Event.Playing -> {
+                if (rootView != null) {
+                    if (!alwaysOn) rootView!!.keepScreenOn = true
+                    playPauseButton.setImageResource(R.drawable.ic_popup_pause)
+                }
+                showNotification()
+            }
+            MediaPlayer.Event.Paused -> {
+                if (rootView != null) {
+                    if (!alwaysOn) rootView!!.keepScreenOn = false
+                    playPauseButton.setImageResource(R.drawable.ic_popup_play)
+                }
+                showNotification()
+            }
+        }
+    }
+
+    override fun onClick(v: View) {
+        when (v.id) {
+            R.id.video_play_pause -> if (mService.hasMedia()) {
+                if (mService.isPlaying)
+                    mService.pause()
+                else
+                    mService.play()
+            }
+            R.id.popup_close -> stopPlayback()
+            R.id.popup_expand -> expandToVideoPlayer()
+        }
+    }
+
+    private fun expandToVideoPlayer() {
+        removePopup()
+        if (mService.hasMedia() && !mService.isPlaying)
+            mService.currentMediaWrapper!!.flags = MediaWrapper.MEDIA_PAUSED
+        mService.switchToVideo()
+    }
+
+    private fun stopPlayback() {
+        var time = mService.time
+        if (time != -1L) {
+            // remove saved position if in the last 5 seconds
+            // else, go back 2 seconds, to compensate loading time
+            time = (if (mService.length - time < 5000) 0 else 2000).toLong()
+            // Save position
+            if (mService.isSeekable)
+                Settings.getInstance(mService).edit()
+                        .putLong(PreferencesActivity.VIDEO_RESUME_TIME, time).apply()
+        }
+        mService.stop()
+    }
+
+    private fun showNotification() {
+        val piStop = mService.getPendingIntent(Intent(ACTION_REMOTE_STOP))
+        val builder = NotificationCompat.Builder(mService, "misc")
+                .setSmallIcon(R.drawable.ic_notif_video)
+                .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
+                .setContentTitle(mService.title)
+                .setContentText(mService.getString(R.string.popup_playback))
+                .setAutoCancel(false)
+                .setOngoing(true)
+                .setContentIntent(mService.sessionPendingIntent)
+                .setDeleteIntent(piStop)
+
+        //Switch
+        val notificationIntent = Intent(ACTION_REMOTE_SWITCH_VIDEO)
+        val piExpand = mService.getPendingIntent(notificationIntent)
+        //PLay Pause
+        val piPlay = mService.getPendingIntent(Intent(ACTION_REMOTE_PLAYPAUSE))
+
+        if (mService.isPlaying)
+            builder.addAction(R.drawable.ic_popup_pause, mService.getString(R.string.pause), piPlay)
+        else
+            builder.addAction(R.drawable.ic_popup_play, mService.getString(R.string.play), piPlay)
+        builder.addAction(R.drawable.ic_popup_expand_w, mService.getString(R.string.popup_expand), piExpand)
+        mService.startForeground(42, builder.build())
+    }
+
+    private fun hideNotification() {
+        mService.stopForeground(true)
+    }
+
+    override fun onSurfacesCreated(vlcVout: IVLCVout) {
+        mService.setVideoAspectRatio(null)
+        mService.setVideoScale(0f)
+        mService.setVideoTrackEnabled(true)
+        if (mService.hasMedia()) {
+            mService.flush()
+            playPauseButton!!.setImageResource(if (mService.isPlaying) R.drawable.ic_popup_pause else R.drawable.ic_popup_play)
+        } else
+            mService.playIndex(mService.currentMediaPosition)
+        showNotification()
+    }
+
+    override fun onSurfacesDestroyed(vlcVout: IVLCVout) {
+        vlcVout.removeCallback(this)
+    }
+
+    companion object {
+
+        private val TAG = "VLC/PopupManager"
+
+        private const val FLING_STOP_VELOCITY = 3000
+        private const val MSG_DELAY = 3000
+
+        private const val SHOW_BUTTONS = 0
+        private const val HIDE_BUTTONS = 1
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
deleted file mode 100644
index 02de443089..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.java
+++ /dev/null
@@ -1,482 +0,0 @@
-/*****************************************************************************
- * VideoGridFragment.java
- *****************************************************************************
- * Copyright © 2011-2019 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.video;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-
-import org.jetbrains.annotations.NotNull;
-import org.videolan.medialibrary.Medialibrary;
-import org.videolan.medialibrary.media.Folder;
-import org.videolan.medialibrary.media.MediaLibraryItem;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.tools.MultiSelectHelper;
-import org.videolan.vlc.MediaParsingServiceKt;
-import org.videolan.vlc.R;
-import org.videolan.vlc.databinding.VideoGridBinding;
-import org.videolan.vlc.gui.MainActivity;
-import org.videolan.vlc.gui.SecondaryActivity;
-import org.videolan.vlc.gui.browser.MediaBrowserFragment;
-import org.videolan.vlc.gui.dialogs.ContextSheetKt;
-import org.videolan.vlc.gui.dialogs.CtxActionReceiver;
-import org.videolan.vlc.gui.dialogs.SavePlaylistDialog;
-import org.videolan.vlc.gui.helpers.ItemOffsetDecoration;
-import org.videolan.vlc.gui.helpers.UiTools;
-import org.videolan.vlc.gui.preferences.PreferencesActivity;
-import org.videolan.vlc.gui.view.SwipeRefreshLayout;
-import org.videolan.vlc.interfaces.IEventsHandler;
-import org.videolan.vlc.media.MediaGroup;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.media.PlaylistManager;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.Settings;
-import org.videolan.vlc.viewmodels.paged.PagedVideosModel;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import androidx.annotation.MainThread;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.appcompat.view.ActionMode;
-import androidx.fragment.app.FragmentActivity;
-import androidx.lifecycle.Observer;
-import androidx.paging.PagedList;
-import androidx.recyclerview.widget.RecyclerView;
-
-public class VideoGridFragment extends MediaBrowserFragment<PagedVideosModel> implements SwipeRefreshLayout.OnRefreshListener, IEventsHandler, Observer<PagedList<MediaWrapper>>, CtxActionReceiver {
-
-    private final static String TAG = "VLC/VideoListFragment";
-
-    private VideoListAdapter mAdapter;
-    private MultiSelectHelper<MediaWrapper> multiSelectHelper;
-    private VideoGridBinding mBinding;
-    private String mGroup;
-    private Folder mFolder;
-    private RecyclerView.ItemDecoration mGridItemDecoration;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        if (mAdapter == null) {
-            final SharedPreferences preferences = Settings.INSTANCE.getInstance(requireContext());
-            final boolean seenMarkVisible = preferences.getBoolean("media_seen", true);
-            mAdapter = new VideoListAdapter(this, seenMarkVisible);
-            multiSelectHelper = mAdapter.getMultiSelectHelper();
-            setViewModel(PagedVideosModel.Companion.get(requireContext(), this, mFolder));
-            getViewModel().getPagedList().observe(this, this);
-        }
-        if (savedInstanceState != null) setGroup(savedInstanceState.getString(Constants.KEY_GROUP));
-    }
-
-
-    @Override
-    public void onPrepareOptionsMenu(Menu menu) {
-        super.onPrepareOptionsMenu(menu);
-        menu.findItem(R.id.ml_menu_last_playlist).setVisible(true);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.ml_menu_last_playlist:
-                MediaUtils.INSTANCE.loadlastPlaylist(getActivity(), Constants.PLAYLIST_TYPE_VIDEO);
-                return true;
-            default:
-                return super.onOptionsItemSelected(item);
-        }
-    }
-
-    @Override
-    public View onCreateView(@NotNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        mBinding = VideoGridBinding.inflate(inflater, container, false);
-        return mBinding.getRoot();
-    }
-
-    @Override
-    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        final boolean empty = getViewModel().isEmpty();
-        mBinding.loadingFlipper.setVisibility(empty ? View.VISIBLE : View.GONE);
-        mBinding.loadingTitle.setVisibility(empty ? View.VISIBLE : View.GONE);
-        mBinding.setEmpty(empty);
-        mBinding.buttonNomedia.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                final FragmentActivity activity = requireActivity();
-                final Intent intent = new Intent(activity.getApplicationContext(), SecondaryActivity.class);
-                intent.putExtra("fragment", SecondaryActivity.STORAGE_BROWSER);
-                startActivity(intent);
-                activity.setResult(PreferencesActivity.RESULT_RESTART);
-            }
-        });
-    }
-
-    @Override
-    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
-        super.onActivityCreated(savedInstanceState);
-        getSwipeRefreshLayout().setOnRefreshListener(this);
-        mBinding.videoGrid.setAdapter(mAdapter);
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-        registerForContextMenu(mBinding.videoGrid);
-        updateViewMode();
-        setFabPlayVisibility(true);
-        getFabPlay().setImageResource(R.drawable.ic_fab_play);
-    }
-
-    @Override
-    protected void onRestart() {
-        if (getFilterQuery() == null) getViewModel().refresh();
-    }
-
-    @Override
-    public void onStop() {
-        super.onStop();
-        unregisterForContextMenu(mBinding.videoGrid);
-    }
-
-    @Override
-    public void onSaveInstanceState(@NonNull Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putString(Constants.KEY_GROUP, mGroup);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        mGridItemDecoration = null;
-        mAdapter.release();
-    }
-
-    @Override
-    public void onChanged(@Nullable PagedList<MediaWrapper> list) {
-        mAdapter.showFilename(getViewModel().getSort() == Medialibrary.SORT_FILENAME);
-        if (list != null) mAdapter.submitList(list);
-    }
-
-    @Override
-    public String getTitle() {
-        return mGroup == null ? mFolder == null ? getString(R.string.video) : mFolder.getTitle() : mGroup + "\u2026";
-    }
-
-    private void updateViewMode() {
-        if (getView() == null || getActivity() == null) {
-            Log.w(TAG, "Unable to setup the view");
-            return;
-        }
-        final Resources res = getResources();
-        if (mGridItemDecoration == null)
-            mGridItemDecoration = new ItemOffsetDecoration(getResources(), R.dimen.left_right_1610_margin, R.dimen.top_bottom_1610_margin);
-        final boolean listMode = res.getBoolean(R.bool.list_mode)
-                || (res.getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT &&
-                Settings.INSTANCE.getInstance(requireContext()).getBoolean("force_list_portrait", false));
-
-        // Select between grid or list
-        mBinding.videoGrid.removeItemDecoration(mGridItemDecoration);
-        if (!listMode) {
-            final int thumbnailWidth = res.getDimensionPixelSize(R.dimen.grid_card_thumb_width);
-            final int margin = mBinding.videoGrid.getPaddingStart() + mBinding.videoGrid.getPaddingEnd();
-            final int columnWidth = mBinding.videoGrid.getPerfectColumnWidth(thumbnailWidth, margin) - (res.getDimensionPixelSize(R.dimen.left_right_1610_margin) * 2);
-            mBinding.videoGrid.setColumnWidth(columnWidth);
-            mAdapter.setGridCardWidth(mBinding.videoGrid.getColumnWidth());
-            mBinding.videoGrid.addItemDecoration(mGridItemDecoration);
-        }
-        mBinding.videoGrid.setNumColumns(listMode ? 1 : -1);
-        if (mAdapter.isListMode() != listMode) mAdapter.setListMode(listMode);
-    }
-
-
-    private void playVideo(MediaWrapper media, boolean fromStart) {
-        media.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-        if (fromStart) media.addFlags(MediaWrapper.MEDIA_FROM_START);
-        MediaUtils.INSTANCE.openMedia(requireContext(), media);
-    }
-
-    private void playAudio(MediaWrapper media) {
-        media.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-        MediaUtils.INSTANCE.openMedia(getActivity(), media);
-    }
-
-    @Override
-    public void onFabPlayClick(View view) {
-        MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), 0, false);
-    }
-
-    @MainThread
-    public void updateList() {
-        getViewModel().refresh();
-        mHandler.sendEmptyMessageDelayed(SET_REFRESHING, 300);
-    }
-
-    private void updateEmptyView() {
-        final boolean empty = getViewModel().isEmpty();
-        final boolean working = getMediaLibrary().isWorking();
-        mBinding.loadingFlipper.setVisibility(empty && working ? View.VISIBLE : View.GONE);
-        mBinding.loadingTitle.setVisibility(empty && working ? View.VISIBLE : View.GONE);
-        mBinding.setEmpty(empty && !working);
-    }
-
-    public void setGroup(String prefix) {
-        mGroup = prefix;
-    }
-
-    public void setFolder(Folder folder) {
-        mFolder = folder;
-    }
-
-    @Override
-    public void onRefresh() {
-        final Activity activity = getActivity();
-        if (activity != null) MediaParsingServiceKt.reloadLibrary(activity);
-    }
-
-    @Override
-    public void clear() {
-        mAdapter.clear();
-    }
-
-    @Override
-    public void setFabPlayVisibility(boolean enable) {
-        super.setFabPlayVisibility(!getViewModel().isEmpty() && enable);
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    @Override
-    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
-        mode.getMenuInflater().inflate(R.menu.action_mode_video, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
-        final int count = multiSelectHelper.getSelectionCount();
-        if (count == 0) {
-            stopActionMode();
-            return false;
-        }
-        menu.findItem(R.id.action_video_info).setVisible(count == 1);
-        menu.findItem(R.id.action_video_append).setVisible(PlaylistManager.Companion.hasMedia());
-        return true;
-    }
-
-    @Override
-    public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
-        final List<MediaWrapper> list = new ArrayList<>();
-        for (MediaWrapper mw : multiSelectHelper.getSelection()) {
-            if (mw.getType() == MediaWrapper.TYPE_GROUP) list.addAll(((MediaGroup) mw).getAll());
-            else list.add(mw);
-        }
-        if (!list.isEmpty()) {
-            switch (item.getItemId()) {
-                case R.id.action_video_play:
-                    MediaUtils.INSTANCE.openList(getActivity(), list, 0);
-                    break;
-                case R.id.action_video_append:
-                    MediaUtils.INSTANCE.appendMedia(getActivity(), list);
-                    break;
-                case R.id.action_video_info:
-                    showInfoDialog(list.get(0));
-                    break;
-                //            case R.id.action_video_delete:
-                //                for (int position : rowsAdapter.getSelectedPositions())
-                //                    removeVideo(position, rowsAdapter.getItem(position));
-                //                break;
-                case R.id.action_video_download_subtitles:
-                    MediaUtils.INSTANCE.getSubs(requireActivity(), list);
-                    break;
-                case R.id.action_video_play_audio:
-                    for (MediaWrapper media : list) media.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-                    MediaUtils.INSTANCE.openList(getActivity(), list, 0);
-                    break;
-                case R.id.action_mode_audio_add_playlist:
-                    UiTools.addToPlaylist(getActivity(), list);
-                    break;
-                default:
-                    stopActionMode();
-                    return false;
-            }
-        }
-        stopActionMode();
-        return true;
-    }
-
-    @Override
-    public void onDestroyActionMode(ActionMode mode) {
-        setActionMode(null);
-        setFabPlayVisibility(true);
-        multiSelectHelper.clearSelection();
-    }
-
-    private static final int UPDATE_LIST = 14;
-    private static final int SET_REFRESHING = 15;
-    private static final int UNSET_REFRESHING = 16;
-    private Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            switch (msg.what) {
-                case UPDATE_LIST:
-                    removeMessages(UPDATE_LIST);
-                    updateList();
-                    break;
-                case SET_REFRESHING:
-                    getSwipeRefreshLayout().setRefreshing(true);
-                    break;
-                case UNSET_REFRESHING:
-                    removeMessages(SET_REFRESHING);
-                    getSwipeRefreshLayout().setRefreshing(false);
-                    break;
-                default:
-                    super.handleMessage(msg);
-            }
-        }
-    };
-
-    @Override
-    public void onClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        final MediaWrapper media = (MediaWrapper) item;
-        if (getActionMode() != null) {
-            multiSelectHelper.toggleSelection(position);
-            invalidateActionMode();
-            return;
-        }
-        final Activity activity = getActivity();
-        if (media instanceof MediaGroup) {
-            final String title = media.getTitle().substring(media.getTitle().toLowerCase().startsWith("the") ? 4 : 0);
-            if (activity instanceof MainActivity)
-                ((MainActivity) activity).getNavigator().showSecondaryFragment(SecondaryActivity.VIDEO_GROUP_LIST, title);
-        } else {
-            media.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-            final SharedPreferences settings = Settings.INSTANCE.getInstance(v.getContext());
-            if (settings.getBoolean("force_play_all", false)) {
-                MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), position, false);
-            } else {
-                playVideo(media, false);
-            }
-        }
-    }
-
-    @Override
-    public boolean onLongClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        if (getActionMode() != null) return false;
-        multiSelectHelper.toggleSelection(position);
-        startActionMode();
-        return true;
-    }
-
-    @Override
-    public void onImageClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {}
-
-    @Override
-    public void onCtxClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-        final MediaWrapper mw = (MediaWrapper) item;
-        final boolean group = mw.getType() == MediaWrapper.TYPE_GROUP;
-        int flags = group ? Constants.CTX_VIDEO_GOUP_FLAGS : Constants.CTX_VIDEO_FLAGS;
-        if (mw.getTime() != 0L && !group) flags |= Constants.CTX_PLAY_FROM_START;
-        if (getActionMode() == null)
-            ContextSheetKt.showContext(requireActivity(), this, position, item.getTitle(), flags);
-    }
-
-
-    @Override
-    public void onMainActionClick(@NotNull View v, int position, @NotNull MediaLibraryItem item) {
-    }
-
-    @Override
-    public void onUpdateFinished(@NotNull RecyclerView.Adapter adapter) {
-        mHandler.post(new Runnable() {
-            @Override
-            public void run() {
-                if (!isResumed()) return;
-                if (!getMediaLibrary().isWorking()) mHandler.sendEmptyMessage(UNSET_REFRESHING);
-                updateEmptyView();
-                setFabPlayVisibility(true);
-                UiTools.updateSortTitles(VideoGridFragment.this);
-            }
-        });
-    }
-
-    @Override
-    public void onItemFocused(@NotNull View v, @NotNull MediaLibraryItem item) {
-    }
-
-    public void updateSeenMediaMarker() {
-        mAdapter.setSeenMediaMarkerVisible(Settings.INSTANCE.getInstance(requireContext()).getBoolean("media_seen", true));
-        mAdapter.notifyItemRangeChanged(0, mAdapter.getItemCount() - 1, Constants.UPDATE_SEEN);
-    }
-
-    @Override
-    public void onCtxAction(int position, int option) {
-        if (position >= mAdapter.getItemCount()) return;
-        final MediaWrapper media = mAdapter.getItem(position);
-        if (media == null) return;
-        final Activity activity = getActivity();
-        if (activity == null) return;
-        switch (option) {
-            case Constants.CTX_PLAY_FROM_START:
-                playVideo(media, true);
-                break;
-            case Constants.CTX_PLAY_AS_AUDIO:
-                playAudio(media);
-                break;
-            case Constants.CTX_PLAY_ALL:
-                MediaUtils.INSTANCE.playAll(requireContext(), getViewModel(), position, false);
-                break;
-            case Constants.CTX_INFORMATION:
-                showInfoDialog(media);
-                break;
-            case Constants.CTX_DELETE:
-                removeItem(media);
-                break;
-            case Constants.CTX_PLAY_GROUP:
-                MediaUtils.INSTANCE.openList(activity, ((MediaGroup) media).getAll(), 0);
-                break;
-            case Constants.CTX_APPEND:
-                if (media instanceof MediaGroup)
-                    MediaUtils.INSTANCE.appendMedia(activity, ((MediaGroup) media).getAll());
-                else MediaUtils.INSTANCE.appendMedia(activity, media);
-                break;
-            case Constants.CTX_DOWNLOAD_SUBTITLES:
-                MediaUtils.INSTANCE.getSubs(requireActivity(), media);
-                break;
-            case Constants.CTX_ADD_TO_PLAYLIST:
-                UiTools.addToPlaylist(requireActivity(), media.getTracks(), SavePlaylistDialog.KEY_NEW_TRACKS);
-                break;
-        }
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.kt b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.kt
new file mode 100644
index 0000000000..5cea8fdc48
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoGridFragment.kt
@@ -0,0 +1,409 @@
+/*****************************************************************************
+ * VideoGridFragment.java
+ *
+ * Copyright © 2011-2019 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.video
+
+import android.annotation.TargetApi
+import android.content.Intent
+import android.content.res.Configuration
+import android.os.Build
+import android.os.Bundle
+import android.os.Handler
+import android.os.Message
+import android.util.Log
+import android.view.*
+import androidx.annotation.MainThread
+import androidx.appcompat.view.ActionMode
+import androidx.lifecycle.Observer
+import androidx.paging.PagedList
+import androidx.recyclerview.widget.RecyclerView
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.media.Folder
+import org.videolan.medialibrary.media.MediaLibraryItem
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.tools.MultiSelectHelper
+import org.videolan.vlc.R
+import org.videolan.vlc.databinding.VideoGridBinding
+import org.videolan.vlc.gui.MainActivity
+import org.videolan.vlc.gui.SecondaryActivity
+import org.videolan.vlc.gui.browser.MediaBrowserFragment
+import org.videolan.vlc.gui.dialogs.CtxActionReceiver
+import org.videolan.vlc.gui.dialogs.SavePlaylistDialog
+import org.videolan.vlc.gui.dialogs.showContext
+import org.videolan.vlc.gui.helpers.ItemOffsetDecoration
+import org.videolan.vlc.gui.helpers.UiTools
+import org.videolan.vlc.gui.preferences.PreferencesActivity
+import org.videolan.vlc.interfaces.IEventsHandler
+import org.videolan.vlc.media.MediaGroup
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.media.PlaylistManager
+import org.videolan.vlc.reloadLibrary
+import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.paged.PagedVideosModel
+import java.lang.ref.WeakReference
+import java.util.*
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class VideoGridFragment : MediaBrowserFragment<PagedVideosModel>(), androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListener, IEventsHandler, Observer<PagedList<MediaWrapper>>, CtxActionReceiver {
+
+    private var videoListAdapter: VideoListAdapter? = null
+    private var multiSelectHelper: MultiSelectHelper<MediaWrapper>? = null
+    private var binding: VideoGridBinding? = null
+    private var videoGroup: String? = null
+    private var videoFolder: Folder? = null
+    private var gridItemDecoration: RecyclerView.ItemDecoration? = null
+
+
+    class VideoGridFragmentHandler(private val videoGridFragment: WeakReference<VideoGridFragment>) : Handler() {
+
+        override fun handleMessage(msg: Message?) {
+            when (msg?.what) {
+                UPDATE_LIST -> {
+                    removeMessages(UPDATE_LIST)
+                    videoGridFragment.get()?.updateList()
+                }
+                SET_REFRESHING -> videoGridFragment.get()?.swipeRefreshLayout!!.isRefreshing = true
+                UNSET_REFRESHING -> {
+                    removeMessages(SET_REFRESHING)
+                    videoGridFragment.get()?.swipeRefreshLayout!!.isRefreshing = false
+                }
+                else -> super.handleMessage(msg)
+            }
+        }
+    }
+
+    private val handler = VideoGridFragmentHandler(WeakReference(this))
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        if (videoListAdapter == null) {
+            val preferences = Settings.getInstance(requireContext())
+            val seenMarkVisible = preferences.getBoolean("media_seen", true)
+            videoListAdapter = VideoListAdapter(this, seenMarkVisible)
+            multiSelectHelper = videoListAdapter!!.multiSelectHelper
+            viewModel = PagedVideosModel.get(requireContext(), this, videoFolder)
+            viewModel.pagedList.observe(this, this)
+        }
+        if (savedInstanceState != null) setGroup(savedInstanceState.getString(KEY_GROUP))
+    }
+
+
+    override fun onPrepareOptionsMenu(menu: Menu?) {
+        super.onPrepareOptionsMenu(menu)
+        menu!!.findItem(R.id.ml_menu_last_playlist).isVisible = true
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem?): Boolean {
+        return when (item!!.itemId) {
+            R.id.ml_menu_last_playlist -> {
+                MediaUtils.loadlastPlaylist(activity, PLAYLIST_TYPE_VIDEO)
+                true
+            }
+            else -> super.onOptionsItemSelected(item)
+        }
+    }
+
+    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
+        binding = VideoGridBinding.inflate(inflater, container, false)
+        return binding!!.root
+    }
+
+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
+        super.onViewCreated(view, savedInstanceState)
+        val empty = viewModel.isEmpty()
+        binding!!.loadingFlipper.visibility = if (empty) View.VISIBLE else View.GONE
+        binding!!.loadingTitle.visibility = if (empty) View.VISIBLE else View.GONE
+        binding!!.empty = empty
+        binding!!.buttonNomedia.setOnClickListener {
+            val activity = requireActivity()
+            val intent = Intent(activity.applicationContext, SecondaryActivity::class.java)
+            intent.putExtra("fragment", SecondaryActivity.STORAGE_BROWSER)
+            startActivity(intent)
+            activity.setResult(PreferencesActivity.RESULT_RESTART)
+        }
+    }
+
+    override fun onActivityCreated(savedInstanceState: Bundle?) {
+        super.onActivityCreated(savedInstanceState)
+        swipeRefreshLayout!!.setOnRefreshListener(this)
+        binding!!.videoGrid.adapter = videoListAdapter
+    }
+
+    override fun onStart() {
+        super.onStart()
+        registerForContextMenu(binding!!.videoGrid)
+        updateViewMode()
+        setFabPlayVisibility(true)
+        fabPlay?.setImageResource(R.drawable.ic_fab_play)
+    }
+
+    override fun onRestart() {
+        if (filterQuery == null) viewModel.refresh()
+    }
+
+    override fun onStop() {
+        super.onStop()
+        unregisterForContextMenu(binding!!.videoGrid)
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        super.onSaveInstanceState(outState)
+        outState.putString(KEY_GROUP, videoGroup)
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        gridItemDecoration = null
+        videoListAdapter!!.release()
+    }
+
+    override fun onChanged(list: PagedList<MediaWrapper>?) {
+        videoListAdapter!!.showFilename(viewModel.sort == Medialibrary.SORT_FILENAME)
+        if (list != null) videoListAdapter!!.submitList(list)
+    }
+
+    override fun getTitle(): String {
+        return if (videoGroup == null) if (videoFolder == null) getString(R.string.video) else videoFolder!!.title else videoGroup!! + "\u2026"
+    }
+
+    private fun updateViewMode() {
+        if (view == null || activity == null) {
+            Log.w(TAG, "Unable to setup the view")
+            return
+        }
+        val res = resources
+        if (gridItemDecoration == null)
+            gridItemDecoration = ItemOffsetDecoration(resources, R.dimen.left_right_1610_margin, R.dimen.top_bottom_1610_margin)
+        val listMode = res.getBoolean(R.bool.list_mode) || res.configuration.orientation == Configuration.ORIENTATION_PORTRAIT && Settings.getInstance(requireContext()).getBoolean("force_list_portrait", false)
+
+        // Select between grid or list
+        binding!!.videoGrid.removeItemDecoration(gridItemDecoration!!)
+        if (!listMode) {
+            val thumbnailWidth = res.getDimensionPixelSize(R.dimen.grid_card_thumb_width)
+            val margin = binding!!.videoGrid.paddingStart + binding!!.videoGrid.paddingEnd
+            val columnWidth = binding!!.videoGrid.getPerfectColumnWidth(thumbnailWidth, margin) - res.getDimensionPixelSize(R.dimen.left_right_1610_margin) * 2
+            binding!!.videoGrid.columnWidth = columnWidth
+            videoListAdapter!!.setGridCardWidth(binding!!.videoGrid.columnWidth)
+            binding!!.videoGrid.addItemDecoration(gridItemDecoration!!)
+        }
+        binding!!.videoGrid.setNumColumns(if (listMode) 1 else -1)
+        if (videoListAdapter!!.isListMode != listMode) videoListAdapter!!.isListMode = listMode
+    }
+
+
+    private fun playVideo(media: MediaWrapper, fromStart: Boolean) {
+        media.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+        if (fromStart) media.addFlags(MediaWrapper.MEDIA_FROM_START)
+        MediaUtils.openMedia(requireContext(), media)
+    }
+
+    private fun playAudio(media: MediaWrapper) {
+        media.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+        MediaUtils.openMedia(activity, media)
+    }
+
+    override fun onFabPlayClick(view: View) {
+        MediaUtils.playAll(requireContext(), viewModel, 0, false)
+    }
+
+    @MainThread
+    fun updateList() {
+        viewModel.refresh()
+        handler.sendEmptyMessageDelayed(SET_REFRESHING, 300)
+    }
+
+    private fun updateEmptyView() {
+        val empty = viewModel.isEmpty()
+        val working = mediaLibrary.isWorking
+        binding!!.loadingFlipper.visibility = if (empty && working) View.VISIBLE else View.GONE
+        binding!!.loadingTitle.visibility = if (empty && working) View.VISIBLE else View.GONE
+        binding!!.empty = empty && !working
+    }
+
+    fun setGroup(prefix: String?) {
+        videoGroup = prefix
+    }
+
+    fun setFolder(folder: Folder) {
+        videoFolder = folder
+    }
+
+    override fun onRefresh() {
+        val activity = activity
+        activity?.reloadLibrary()
+    }
+
+    override fun clear() {
+        videoListAdapter!!.clear()
+    }
+
+    override fun setFabPlayVisibility(enable: Boolean) {
+        super.setFabPlayVisibility(!viewModel.isEmpty() && enable)
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
+        mode.menuInflater.inflate(R.menu.action_mode_video, menu)
+        return true
+    }
+
+    override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
+        val count = multiSelectHelper!!.getSelectionCount()
+        if (count == 0) {
+            stopActionMode()
+            return false
+        }
+        menu.findItem(R.id.action_video_info).isVisible = count == 1
+        menu.findItem(R.id.action_video_append).isVisible = PlaylistManager.hasMedia()
+        return true
+    }
+
+    override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
+        val list = ArrayList<MediaWrapper>()
+        for (mw in multiSelectHelper!!.getSelection()) {
+            if (mw.type == MediaWrapper.TYPE_GROUP)
+                list.addAll((mw as MediaGroup).all)
+            else
+                list.add(mw)
+        }
+        if (list.isNotEmpty()) {
+            when (item.itemId) {
+                R.id.action_video_play -> MediaUtils.openList(activity, list, 0)
+                R.id.action_video_append -> MediaUtils.appendMedia(activity, list)
+                R.id.action_video_info -> showInfoDialog(list[0])
+                //            case R.id.action_video_delete:
+                //                for (int position : rowsAdapter.getSelectedPositions())
+                //                    removeVideo(position, rowsAdapter.getItem(position));
+                //                break;
+                R.id.action_video_download_subtitles -> MediaUtils.getSubs(requireActivity(), list)
+                R.id.action_video_play_audio -> {
+                    for (media in list) media.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+                    MediaUtils.openList(activity, list, 0)
+                }
+                R.id.action_mode_audio_add_playlist -> UiTools.addToPlaylist(activity, list)
+                else -> {
+                    stopActionMode()
+                    return false
+                }
+            }
+        }
+        stopActionMode()
+        return true
+    }
+
+    override fun onDestroyActionMode(mode: ActionMode) {
+        actionMode = null
+        setFabPlayVisibility(true)
+        multiSelectHelper!!.clearSelection()
+    }
+
+    override fun onClick(v: View, position: Int, item: MediaLibraryItem) {
+        val media = item as MediaWrapper
+        if (actionMode != null) {
+            multiSelectHelper!!.toggleSelection(position)
+            invalidateActionMode()
+            return
+        }
+        val activity = activity
+        if (media is MediaGroup) {
+            val title = media.getTitle().substring(if (media.getTitle().toLowerCase().startsWith("the")) 4 else 0)
+            if (activity is MainActivity)
+                activity.navigator.showSecondaryFragment(SecondaryActivity.VIDEO_GROUP_LIST, title)
+        } else {
+            media.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+            val settings = Settings.getInstance(v.context)
+            if (settings.getBoolean("force_play_all", false)) {
+                MediaUtils.playAll(requireContext(), viewModel, position, false)
+            } else {
+                playVideo(media, false)
+            }
+        }
+    }
+
+    override fun onLongClick(v: View, position: Int, item: MediaLibraryItem): Boolean {
+        if (actionMode != null) return false
+        multiSelectHelper!!.toggleSelection(position)
+        startActionMode()
+        return true
+    }
+
+    override fun onImageClick(v: View, position: Int, item: MediaLibraryItem) {}
+
+    override fun onCtxClick(v: View, position: Int, item: MediaLibraryItem) {
+        val mw = item as MediaWrapper
+        val group = mw.type == MediaWrapper.TYPE_GROUP
+        var flags = if (group) CTX_VIDEO_GOUP_FLAGS else CTX_VIDEO_FLAGS
+        if (mw.time != 0L && !group) flags = flags or CTX_PLAY_FROM_START
+        if (actionMode == null)
+            showContext(requireActivity(), this, position, item.getTitle(), flags)
+    }
+
+
+    override fun onMainActionClick(v: View, position: Int, item: MediaLibraryItem) {}
+
+    override fun onUpdateFinished(adapter: RecyclerView.Adapter<*>) {
+        handler.post(Runnable {
+            if (!isResumed) return@Runnable
+            if (!mediaLibrary.isWorking) handler.sendEmptyMessage(UNSET_REFRESHING)
+            updateEmptyView()
+            setFabPlayVisibility(true)
+            UiTools.updateSortTitles(this@VideoGridFragment)
+        })
+    }
+
+    override fun onItemFocused(v: View, item: MediaLibraryItem) {}
+
+    fun updateSeenMediaMarker() {
+        videoListAdapter!!.setSeenMediaMarkerVisible(Settings.getInstance(requireContext()).getBoolean("media_seen", true))
+        videoListAdapter!!.notifyItemRangeChanged(0, videoListAdapter!!.itemCount - 1, UPDATE_SEEN)
+    }
+
+    override fun onCtxAction(position: Int, option: Int) {
+        if (position >= videoListAdapter!!.itemCount) return
+        val media = videoListAdapter!!.getItem(position) ?: return
+        val activity = activity ?: return
+        when (option) {
+            CTX_PLAY_FROM_START -> playVideo(media, true)
+            CTX_PLAY_AS_AUDIO -> playAudio(media)
+            CTX_PLAY_ALL -> MediaUtils.playAll(requireContext(), viewModel, position, false)
+            CTX_INFORMATION -> showInfoDialog(media)
+            CTX_DELETE -> removeItem(media)
+            CTX_PLAY_GROUP -> MediaUtils.openList(activity, (media as MediaGroup).all, 0)
+            CTX_APPEND -> if (media is MediaGroup)
+                MediaUtils.appendMedia(activity, media.all)
+            else
+                MediaUtils.appendMedia(activity, media)
+            CTX_DOWNLOAD_SUBTITLES -> MediaUtils.getSubs(requireActivity(), media)
+            CTX_ADD_TO_PLAYLIST -> UiTools.addToPlaylist(requireActivity(), media.tracks, SavePlaylistDialog.KEY_NEW_TRACKS)
+        }
+    }
+
+    companion object {
+
+        private const val TAG = "VLC/VideoListFragment"
+
+        private const val UPDATE_LIST = 14
+        private const val SET_REFRESHING = 15
+        private const val UNSET_REFRESHING = 16
+    }
+}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java b/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java
deleted file mode 100644
index 9c5d1cd675..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.java
+++ /dev/null
@@ -1,2976 +0,0 @@
-/*****************************************************************************
- * VideoPlayerActivity.java
- *****************************************************************************
- * Copyright © 2011-2017 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.video;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.KeyguardManager;
-import android.app.PictureInPictureParams;
-import android.bluetooth.BluetoothA2dp;
-import android.bluetooth.BluetoothHeadset;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.content.pm.ActivityInfo;
-import android.content.res.Configuration;
-import android.media.AudioManager;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.os.PowerManager;
-import android.text.TextUtils;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.util.Rational;
-import android.view.Display;
-import android.view.KeyEvent;
-import android.view.MenuItem;
-import android.view.MotionEvent;
-import android.view.Surface;
-import android.view.SurfaceView;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.View.OnLongClickListener;
-import android.view.ViewGroup;
-import android.view.ViewGroup.LayoutParams;
-import android.view.WindowManager;
-import android.view.animation.Animation;
-import android.view.animation.AnimationSet;
-import android.view.animation.AnimationUtils;
-import android.view.animation.DecelerateInterpolator;
-import android.view.animation.RotateAnimation;
-import android.widget.ImageView;
-import android.widget.LinearLayout;
-import android.widget.RelativeLayout;
-import android.widget.SeekBar;
-import android.widget.SeekBar.OnSeekBarChangeListener;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.google.android.material.snackbar.Snackbar;
-
-import org.jetbrains.annotations.Nullable;
-import org.videolan.libvlc.IVLCVout;
-import org.videolan.libvlc.Media;
-import org.videolan.libvlc.MediaPlayer;
-import org.videolan.libvlc.RendererItem;
-import org.videolan.libvlc.util.AndroidUtil;
-import org.videolan.libvlc.util.DisplayManager;
-import org.videolan.libvlc.util.VLCVideoLayout;
-import org.videolan.medialibrary.Medialibrary;
-import org.videolan.medialibrary.Tools;
-import org.videolan.medialibrary.media.MediaWrapper;
-import org.videolan.vlc.BuildConfig;
-import org.videolan.vlc.PlaybackService;
-import org.videolan.vlc.R;
-import org.videolan.vlc.RendererDelegate;
-import org.videolan.vlc.VLCApplication;
-import org.videolan.vlc.database.models.ExternalSub;
-import org.videolan.vlc.databinding.PlayerHudBinding;
-import org.videolan.vlc.gui.MainActivity;
-import org.videolan.vlc.gui.audio.PlaylistAdapter;
-import org.videolan.vlc.gui.browser.FilePickerActivity;
-import org.videolan.vlc.gui.browser.FilePickerFragmentKt;
-import org.videolan.vlc.gui.dialogs.RenderersDialog;
-import org.videolan.vlc.gui.helpers.OnRepeatListener;
-import org.videolan.vlc.gui.helpers.PlayerOptionType;
-import org.videolan.vlc.gui.helpers.PlayerOptionsDelegate;
-import org.videolan.vlc.gui.helpers.SwipeDragItemTouchHelperCallback;
-import org.videolan.vlc.gui.helpers.UiTools;
-import org.videolan.vlc.gui.helpers.hf.StoragePermissionsDelegate;
-import org.videolan.vlc.gui.preferences.PreferencesActivity;
-import org.videolan.vlc.gui.tv.audioplayer.AudioPlayerActivity;
-import org.videolan.vlc.interfaces.IPlaybackSettingsController;
-import org.videolan.vlc.media.MediaUtils;
-import org.videolan.vlc.repository.ExternalSubRepository;
-import org.videolan.vlc.repository.SlaveRepository;
-import org.videolan.vlc.util.AndroidDevices;
-import org.videolan.vlc.util.Constants;
-import org.videolan.vlc.util.FileUtils;
-import org.videolan.vlc.util.Permissions;
-import org.videolan.vlc.util.Settings;
-import org.videolan.vlc.util.Strings;
-import org.videolan.vlc.util.Util;
-import org.videolan.vlc.util.WorkersKt;
-import org.videolan.vlc.viewmodels.PlaylistModel;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.StringRes;
-import androidx.annotation.WorkerThread;
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.app.AlertDialog;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.appcompat.widget.PopupMenu;
-import androidx.appcompat.widget.ViewStubCompat;
-import androidx.databinding.BindingAdapter;
-import androidx.databinding.DataBindingUtil;
-import androidx.lifecycle.Lifecycle;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.Observer;
-import androidx.lifecycle.ViewModelProviders;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import androidx.recyclerview.widget.ItemTouchHelper;
-import androidx.recyclerview.widget.LinearLayoutManager;
-import androidx.recyclerview.widget.RecyclerView;
-
-public class VideoPlayerActivity extends AppCompatActivity implements IPlaybackSettingsController, PlaybackService.Callback,PlaylistAdapter.IPlayer,
-        OnClickListener, OnLongClickListener, StoragePermissionsDelegate.CustomActionController,  Observer<PlaybackService> {
-
-    private final static String TAG = "VLC/VideoPlayerActivity";
-
-    private final static String ACTION_RESULT = Strings.buildPkgString("player.result");
-    private final static String EXTRA_POSITION = "extra_position";
-    private final static String EXTRA_DURATION = "extra_duration";
-    private final static String EXTRA_URI = "extra_uri";
-    private final static int RESULT_CONNECTION_FAILED = RESULT_FIRST_USER + 1;
-    private final static int RESULT_PLAYBACK_ERROR = RESULT_FIRST_USER + 2;
-    private final static int RESULT_VIDEO_TRACK_LOST = RESULT_FIRST_USER + 3;
-    static final float DEFAULT_FOV = 80f;
-
-    protected PlaybackService mService;
-    private Medialibrary mMedialibrary;
-    private VLCVideoLayout mVideoLayout;
-    public DisplayManager mDisplayManager;
-    private View mRootView;
-    private Uri mUri;
-    private boolean mAskResume = true;
-
-    private ImageView mPlaylistToggle;
-    private RecyclerView mPlaylist;
-    private PlaylistAdapter mPlaylistAdapter;
-    private PlaylistModel mPlaylistModel;
-
-    private ImageView mOrientationToggle;
-
-    private SharedPreferences mSettings;
-
-    /** Overlay */
-    private ActionBar mActionBar;
-    private ViewGroup mActionBarView;
-    private View mOverlayBackground;
-    private static final String KEY_TIME = "saved_time";
-    private static final String KEY_URI = "saved_uri";
-    private static final int OVERLAY_TIMEOUT = 4000;
-    private static final int OVERLAY_INFINITE = -1;
-    private static final int FADE_OUT = 1;
-    private static final int FADE_OUT_INFO = 2;
-    private static final int START_PLAYBACK = 3;
-    private static final int AUDIO_SERVICE_CONNECTION_FAILED = 4;
-    private static final int RESET_BACK_LOCK = 5;
-    private static final int CHECK_VIDEO_TRACKS = 6;
-    private static final int LOADING_ANIMATION = 7;
-    static final int SHOW_INFO = 8;
-    static final int HIDE_INFO = 9;
-
-    private static final int LOADING_ANIMATION_DELAY = 1000;
-
-    private boolean mDragging;
-    private boolean mShowing;
-    private boolean mShowingDialog;
-    private DelayState mPlaybackSetting = DelayState.OFF;
-    private TextView mTitle;
-    private TextView mInfo;
-    private View mOverlayInfo;
-    private View mVerticalBar;
-    private View mVerticalBarProgress;
-    private View mVerticalBarBoostProgress;
-    private boolean mIsLoading;
-    private boolean mIsPlaying = false;
-    private ImageView mLoading;
-    private ImageView mNavMenu;
-    private ImageView mRendererBtn;
-    private ImageView mSecondaryDisplayBtn;
-    private ImageView mPlaybackSettingPlus;
-    private ImageView mPlaybackSettingMinus;
-    protected boolean mEnableCloneMode;
-    private static volatile boolean sDisplayRemainingTime;
-    private int mScreenOrientation;
-    private int mScreenOrientationLock;
-    private int mCurrentScreenOrientation;
-    private String KEY_REMAINING_TIME_DISPLAY = "remaining_time_display";
-    private String KEY_BLUETOOTH_DELAY = "key_bluetooth_delay";
-    private long mSpuDelay = 0L;
-    private long mAudioDelay = 0L;
-    private int mCurrentAudioTrack = -2, mCurrentSpuTrack = -2;
-
-    private boolean mIsLocked = false;
-    /* -1 is a valid track (Disable) */
-    private int mLastAudioTrack = -2;
-    private int mLastSpuTrack = -2;
-    private int mOverlayTimeout = 0;
-    private boolean mLockBackButton = false;
-    boolean mWasPaused = false;
-    private long mSavedTime = -1;
-
-    /**
-     * For uninterrupted switching between audio and video mode
-     */
-    private boolean mSwitchingView;
-    private boolean mSwitchToPopup;
-
-    //Volume
-    private AudioManager mAudioManager;
-    private int mAudioMax;
-    private boolean audioBoostEnabled;
-    private boolean mMute = false;
-    private int mVolSave;
-    private float mVol;
-    private float mOriginalVol;
-    private Toast warningToast;
-
-    private float mFov;
-    private VideoTouchDelegate mTouchDelegate;
-    private boolean mIsTv;
-
-    // Tracks & Subtitles
-    private MediaPlayer.TrackDescription[] mAudioTracksList;
-    private MediaPlayer.TrackDescription[] mVideoTracksList;
-    private MediaPlayer.TrackDescription[] mSubtitleTracksList;
-
-    /**
-     * Flag to indicate whether the media should be paused once loaded
-     * (e.g. lock screen, or to restore the pause state)
-     */
-    private boolean mPlaybackStarted = false;
-
-    // Tips
-    private View mOverlayTips;
-    private static final String PREF_TIPS_SHOWN = "video_player_tips_shown";
-
-    // Navigation handling (DVD, Blu-Ray...)
-    private int mMenuIdx = -1;
-    private boolean mIsNavMenu = false;
-
-    /* for getTime and seek */
-    private long mForcedTime = -1;
-    private long mLastTime = -1;
-
-    private AlertDialog mAlertDialog;
-
-    protected boolean mIsBenchmark = false;
-
-    private ArrayList<ExternalSub> addedExternalSubs = new ArrayList<>();
-    private LiveData downloadedSubtitleLiveData = null;
-    private String previousMediaPath = null;
-
-    private static Boolean clone = null;
-
-    @Override
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        Util.checkCpuCompatibility(this);
-
-        mSettings = Settings.INSTANCE.getInstance(this);
-
-        /* Services and miscellaneous */
-        mAudioManager = (AudioManager) getApplicationContext().getSystemService(AUDIO_SERVICE);
-        mAudioMax = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
-        audioBoostEnabled = mSettings.getBoolean("audio_boost", false);
-
-        mEnableCloneMode = clone != null ? clone : mSettings.getBoolean("enable_clone_mode", false);
-        mDisplayManager = new DisplayManager(this, PlaybackService.Companion.getRenderer(), false, mEnableCloneMode, mIsBenchmark);
-        setContentView(mDisplayManager.isPrimary() ? R.layout.player : R.layout.player_remote_control);
-
-        /** initialize Views an their Events */
-        mActionBar = getSupportActionBar();
-        mActionBar.setDisplayShowHomeEnabled(false);
-        mActionBar.setDisplayShowTitleEnabled(false);
-        mActionBar.setBackgroundDrawable(null);
-        mActionBar.setDisplayShowCustomEnabled(true);
-        mActionBar.setCustomView(R.layout.player_action_bar);
-
-        mRootView = findViewById(R.id.player_root);
-        mActionBarView = (ViewGroup) mActionBar.getCustomView();
-
-        mTitle = mActionBarView.findViewById(R.id.player_overlay_title);
-
-        mPlaylistToggle = mActionBarView.findViewById(R.id.playlist_toggle);
-        mPlaylist = findViewById(R.id.video_playlist);
-
-        mSecondaryDisplayBtn = mActionBarView.findViewById(R.id.video_secondary_display);
-
-        mOrientationToggle = mActionBarView.findViewById(R.id.orientation_toggle);
-
-        mScreenOrientation = Integer.valueOf(
-                mSettings.getString("screen_orientation", "99" /*SCREEN ORIENTATION SENSOR*/));
-
-        mVideoLayout = findViewById(R.id.video_layout);
-
-        /* Loading view */
-        mLoading = findViewById(R.id.player_overlay_loading);
-        dimStatusBar(true);
-        mHandler.sendEmptyMessageDelayed(LOADING_ANIMATION, LOADING_ANIMATION_DELAY);
-
-        mSwitchingView = false;
-
-        mAskResume = mSettings.getBoolean("dialog_confirm_resume", false);
-        sDisplayRemainingTime = mSettings.getBoolean(KEY_REMAINING_TIME_DISPLAY, false);
-        // Clear the resume time, since it is only used for resumes in external
-        // videos.
-        final SharedPreferences.Editor editor = mSettings.edit();
-        editor.putLong(PreferencesActivity.VIDEO_RESUME_TIME, -1);
-        // Paused flag - per session too, like the subs list.
-        editor.apply();
-
-        final IntentFilter filter = new IntentFilter();
-        filter.addAction(Constants.SLEEP_INTENT);
-        registerReceiver(mReceiver, filter);
-
-        this.setVolumeControlStream(AudioManager.STREAM_MUSIC);
-
-        // 100 is the value for screen_orientation_start_lock
-        try {
-            setRequestedOrientation(getScreenOrientation(mScreenOrientation));
-        } catch (IllegalStateException ignored) {
-            Log.w(TAG, "onCreate: failed to set orientation");
-        }
-        // Extra initialization when no secondary display is detected
-        mIsTv = AndroidDevices.showTvUi(this);
-        if (mDisplayManager.isPrimary()) {
-            // Orientation
-            // Tips
-            if (!BuildConfig.DEBUG && !mIsTv && !mSettings.getBoolean(PREF_TIPS_SHOWN, false)
-                    && !mIsBenchmark) {
-                ((ViewStubCompat) findViewById(R.id.player_overlay_tips)).inflate();
-                mOverlayTips = findViewById(R.id.overlay_tips_layout);
-            }
-
-            //Set margins for TV overscan
-            if (mIsTv) {
-                int hm = getResources().getDimensionPixelSize(R.dimen.tv_overscan_horizontal);
-                int vm = getResources().getDimensionPixelSize(R.dimen.tv_overscan_vertical);
-
-                final RelativeLayout uiContainer = findViewById(R.id.player_ui_container);
-                final RelativeLayout.LayoutParams lp = (RelativeLayout.LayoutParams) uiContainer.getLayoutParams();
-                lp.setMargins(hm, 0, hm, vm);
-                uiContainer.setLayoutParams(lp);
-
-                final LinearLayout.LayoutParams titleParams = (LinearLayout.LayoutParams) mTitle.getLayoutParams();
-                titleParams.setMargins(0, vm, 0, 0);
-                mTitle.setLayoutParams(titleParams);
-            }
-        }
-
-
-        mMedialibrary = VLCApplication.getMLInstance();
-        final int touch;
-        if (!mIsTv) {
-            touch = (mSettings.getBoolean("enable_volume_gesture", true) ? VideoTouchDelegateKt.TOUCH_FLAG_AUDIO_VOLUME : 0)
-                    + (mSettings.getBoolean("enable_brightness_gesture", true) ? VideoTouchDelegateKt.TOUCH_FLAG_BRIGHTNESS : 0)
-                    + (mSettings.getBoolean("enable_double_tap_seek", true) ? VideoTouchDelegateKt.TOUCH_FLAG_SEEK : 0);
-        } else touch = 0;
-        mCurrentScreenOrientation = getResources().getConfiguration().orientation;
-        final DisplayMetrics dm = new DisplayMetrics();
-        getWindowManager().getDefaultDisplay().getMetrics(dm);
-        int yRange = Math.min(dm.widthPixels, dm.heightPixels);
-        int xRange = Math.max(dm.widthPixels, dm.heightPixels);
-        final ScreenConfig sc = new ScreenConfig(dm, xRange, yRange, mCurrentScreenOrientation);
-        mTouchDelegate = new VideoTouchDelegate(this, touch, sc, mIsTv);
-        UiTools.setRotationAnimation(this);
-        if (savedInstanceState != null) {
-            mSavedTime = savedInstanceState.getLong(KEY_TIME);
-            mUri = (Uri) savedInstanceState.getParcelable(KEY_URI);
-        }
-        PlaybackService.Companion.start(this);
-    }
-
-    @Override
-    protected void onResume() {
-        overridePendingTransition(0,0);
-        super.onResume();
-        mShowingDialog = false;
-        /*
-         * Set listeners here to avoid NPE when activity is closing
-         */
-        setListeners(true);
-
-        if (mIsLocked && mScreenOrientation == 99) setRequestedOrientation(mScreenOrientationLock);
-    }
-
-    private void setListeners(boolean enabled) {
-        if (mHudBinding != null) mHudBinding.playerOverlaySeekbar.setOnSeekBarChangeListener(enabled ? mSeekListener : null);
-        if (mNavMenu != null) mNavMenu.setOnClickListener(enabled ? this : null);
-        if (mOrientationToggle != null) {
-            mOrientationToggle.setOnClickListener(enabled ? this : null);
-            mOrientationToggle.setOnLongClickListener(enabled ? this : null);
-        }
-        UiTools.setViewOnClickListener(mRendererBtn, enabled ? this : null);
-    }
-
-    @Override
-    protected void onNewIntent(Intent intent) {
-        setIntent(intent);
-        if (mPlaybackStarted && mService.getCurrentMediaWrapper() != null) {
-            Uri uri = intent.hasExtra(Constants.PLAY_EXTRA_ITEM_LOCATION) ?
-                    (Uri) intent.getExtras().getParcelable(Constants.PLAY_EXTRA_ITEM_LOCATION) : intent.getData();
-            if (uri == null || uri.equals(mUri))
-                return;
-            if (TextUtils.equals("file", uri.getScheme()) && uri.getPath().startsWith("/sdcard")) {
-                Uri convertedUri = FileUtils.convertLocalUri(uri);
-                if (convertedUri == null || convertedUri.equals(mUri)) return;
-                else uri = convertedUri;
-            }
-            mUri = uri;
-            mTitle.setText(mService.getCurrentMediaWrapper().getTitle());
-            if (isPlaylistVisible()) {
-                mPlaylistAdapter.setCurrentIndex(mService.getCurrentMediaPosition());
-                mPlaylist.setVisibility(View.GONE);
-            }
-            if (mSettings.getBoolean("video_transition_show", true)) showTitle();
-            initUI();
-            mForcedTime = mLastTime = -1;
-            enableSubs();
-        }
-    }
-
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    @Override
-    protected void onPause() {
-        final boolean finishing = isFinishing();
-        if (finishing) overridePendingTransition(0, 0);
-        else hideOverlay(true);
-        super.onPause();
-        setListeners(false);
-
-        /* Stop the earliest possible to avoid vout error */
-
-        if (!isInPictureInPictureMode()) {
-            if (finishing ||
-                    (AndroidUtil.isNougatOrLater && !AndroidUtil.isOOrLater //Video on background on Nougat Android TVs
-                            && AndroidDevices.isAndroidTv && !requestVisibleBehind(true)))
-                stopPlayback();
-            else if (mDisplayManager.isPrimary() && !mShowingDialog && "2".equals(mSettings.getString(PreferencesActivity.KEY_VIDEO_APP_SWITCH, "0"))
-                    && isInteractive() && (mService != null && !mService.hasRenderer())) {
-                switchToPopup();
-            }
-        }
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        if (mUri != null && !"content".equals(mUri.getScheme())) {
-            outState.putLong(KEY_TIME, mSavedTime);
-            if (mPlaylistModel == null) outState.putParcelable(KEY_URI, mUri);
-        }
-        mUri = null;
-    }
-
-    @TargetApi(Build.VERSION_CODES.O)
-    public void switchToPopup() {
-        final MediaWrapper mw = mService != null ? mService.getCurrentMediaWrapper() : null;
-        if (mw == null || !AndroidDevices.pipAllowed
-                || !getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED)) return;
-
-        boolean forceLegacy = Settings.INSTANCE.getInstance(this).getBoolean("popup_force_legacy", false);
-        if (AndroidDevices.hasPiP && !forceLegacy) {
-            if (AndroidUtil.isOOrLater) try {
-                final SurfaceView videoSurface = (SurfaceView) (mVideoLayout != null ? mVideoLayout.findViewById(R.id.surface_video) : null);
-                final int height = videoSurface != null && videoSurface.getHeight() != 0 ? videoSurface.getHeight() : mw.getHeight();
-                final int width = Math.min(videoSurface != null && videoSurface.getWidth() != 0 ? videoSurface.getWidth() : mw.getWidth(), (int) (height*2.39f));
-                enterPictureInPictureMode(new PictureInPictureParams.Builder().setAspectRatio(new Rational(width, height)).build());
-            } catch (IllegalArgumentException e) { // Fallback with default parameters
-                //noinspection deprecation
-                enterPictureInPictureMode();
-            } else {
-                //noinspection deprecation
-                enterPictureInPictureMode();
-            }
-        } else {
-            if (Permissions.canDrawOverlays(this)) {
-                mSwitchingView = true;
-                mSwitchToPopup = true;
-                if (!mService.isPlaying())
-                    mw.addFlags(MediaWrapper.MEDIA_PAUSED);
-                cleanUI();
-                exitOK();
-            } else Permissions.checkDrawOverlaysPermission(this);
-        }
-    }
-
-    @TargetApi(Build.VERSION_CODES.KITKAT_WATCH)
-    private boolean isInteractive() {
-        final PowerManager pm = (PowerManager) getApplicationContext().getSystemService(Context.POWER_SERVICE);
-        return pm != null && (AndroidUtil.isLolliPopOrLater ? pm.isInteractive() : pm.isScreenOn());
-    }
-
-    @Override
-    public void onVisibleBehindCanceled() {
-        super.onVisibleBehindCanceled();
-        stopPlayback();
-        exitOK();
-    }
-
-    @Override
-    public void onConfigurationChanged(Configuration newConfig) {
-        super.onConfigurationChanged(newConfig);
-        mCurrentScreenOrientation = newConfig.orientation;
-        if (mScreenOrientation == 98) {
-            @StringRes int message;
-            if (mCurrentScreenOrientation == Configuration.ORIENTATION_LANDSCAPE)
-                message = R.string.locked_in_landscape_mode;
-            else
-                message = R.string.locked_in_portrait_mode;
-            if (mRootView != null) UiTools.snacker(mRootView, message);
-        }
-
-        if (mTouchDelegate != null) {
-            final DisplayMetrics dm = new DisplayMetrics();
-            getWindowManager().getDefaultDisplay().getMetrics(dm);
-            final ScreenConfig sc = new ScreenConfig(dm,
-                    Math.max(dm.widthPixels, dm.heightPixels),
-                    Math.min(dm.widthPixels, dm.heightPixels),
-                    mCurrentScreenOrientation);
-            mTouchDelegate.setScreenConfig(sc);
-        }
-        resetHudLayout();
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    public void resetHudLayout() {
-        if (mHudBinding == null) return;
-        final RelativeLayout.LayoutParams layoutParams = (RelativeLayout.LayoutParams)mHudBinding.playerOverlayButtons.getLayoutParams();
-        final int orientation = getScreenOrientation(100);
-        final boolean portrait = orientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT ||
-                orientation == ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_START, portrait ? 1 : 0);
-        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_END, portrait ? 1 : 0);
-        layoutParams.addRule(RelativeLayout.BELOW, portrait ? R.id.player_overlay_length : R.id.player_overlay_seekbar);
-        layoutParams.addRule(RelativeLayout.END_OF, portrait ? 0 : R.id.player_overlay_time);
-        layoutParams.addRule(RelativeLayout.START_OF, portrait ? 0 : R.id.player_overlay_length);
-        mHudBinding.playerOverlayButtons.setLayoutParams(layoutParams);
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    @Override
-    protected void onStart() {
-        super.onStart();
-        PlaybackService.Companion.getService().observe(this, this);
-        restoreBrightness();
-        final IntentFilter filter = new IntentFilter(Constants.PLAY_FROM_SERVICE);
-        filter.addAction(Constants.EXIT_PLAYER);
-        LocalBroadcastManager.getInstance(this).registerReceiver(
-                mServiceReceiver, filter);
-        final IntentFilter btFilter = new IntentFilter(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
-        btFilter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
-        registerReceiver(mBtReceiver, btFilter);
-        UiTools.setViewVisibility(mOverlayInfo, View.INVISIBLE);
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    @Override
-    protected void onStop() {
-        super.onStop();
-        PlaybackService.Companion.getService().removeObservers(this);
-        LocalBroadcastManager.getInstance(this).unregisterReceiver(mServiceReceiver);
-
-        unregisterReceiver(mBtReceiver);
-        if (mAlertDialog != null && mAlertDialog.isShowing())
-            mAlertDialog.dismiss();
-        if (mDisplayManager.isPrimary() && !isFinishing() && mService != null && mService.isPlaying()
-                && "1".equals(mSettings.getString(PreferencesActivity.KEY_VIDEO_APP_SWITCH, "0"))) {
-            switchToAudioMode(false);
-        }
-
-        cleanUI();
-        stopPlayback();
-
-        final SharedPreferences.Editor editor = mSettings.edit();
-        if (mSavedTime != -1) editor.putLong(PreferencesActivity.VIDEO_RESUME_TIME, mSavedTime);
-
-        editor.apply();
-
-        saveBrightness();
-
-        if (mService != null) {
-            mService.removeCallback(this);
-            mService = null;
-        }
-        // Clear Intent to restore playlist on activity restart
-        setIntent(new Intent());
-        mHandler.removeCallbacksAndMessages(null);
-    }
-
-    private void saveBrightness() {
-        // Save brightness if user wants to
-        if (mSettings.getBoolean("save_brightness", false)) {
-            float brightness = getWindow().getAttributes().screenBrightness;
-            if (brightness != -1f) {
-                SharedPreferences.Editor editor = mSettings.edit();
-                editor.putFloat("brightness_value", brightness);
-                editor.apply();
-            }
-        }
-    }
-
-    private void restoreBrightness() {
-        if (mSettings.getBoolean("save_brightness", false)) {
-            float brightness = mSettings.getFloat("brightness_value", -1f);
-            if (brightness != -1f) setWindowBrightness(brightness);
-        }
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        unregisterReceiver(mReceiver);
-        if (mPlaylistModel != null) {
-            mPlaylistModel.getDataset().removeObserver(mPlaylistObserver);
-            mPlaylistModel.onCleared();
-        }
-
-        // Dismiss the presentation when the activity is not visible.
-        mDisplayManager.release();
-        mAudioManager = null;
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    private void startPlayback() {
-        /* start playback only when audio service and both surfaces are ready */
-        if (mPlaybackStarted || mService == null)
-            return;
-
-        mPlaybackStarted = true;
-
-        final IVLCVout vlcVout = mService.getVout();
-        if (vlcVout != null && vlcVout.areViewsAttached()) {
-            if (mService.isPlayingPopup()) {
-                mService.stop();
-            } else
-                vlcVout.detachViews();
-        }
-        final MediaPlayer mediaPlayer = mService.getMediaplayer();
-        if (!mDisplayManager.isOnRenderer() && mVideoLayout != null) {
-            mediaPlayer.attachViews(mVideoLayout, mDisplayManager, true, false);
-            final MediaPlayer.ScaleType size = mIsBenchmark ? MediaPlayer.ScaleType.SURFACE_FILL : MediaPlayer.ScaleType.values()[mSettings.getInt(PreferencesActivity.VIDEO_RATIO, MediaPlayer.ScaleType.SURFACE_BEST_FIT.ordinal())];
-            mediaPlayer.setVideoScale(size);
-        }
-
-        initUI();
-
-        loadMedia();
-    }
-
-    private Observer<List<MediaWrapper>> mPlaylistObserver = new Observer<List<MediaWrapper>>() {
-        @Override
-        public void onChanged(List<MediaWrapper> mediaWrappers) {
-            if (mediaWrappers != null) mPlaylistAdapter.update(mediaWrappers);
-        }
-    };
-
-    private void initPlaylistUi() {
-        if (mService != null && mService.hasPlaylist()) {
-            mHasPlaylist = true;
-            if (mPlaylistAdapter == null) {
-                mPlaylistAdapter = new PlaylistAdapter(this);
-                final LinearLayoutManager layoutManager = new LinearLayoutManager(this, RecyclerView.VERTICAL, false);
-                mPlaylist.setLayoutManager(layoutManager);
-            }
-            if (mPlaylistModel == null) {
-                mPlaylistModel = ViewModelProviders.of(this).get(PlaylistModel.class);
-                mPlaylistAdapter.setModel(mPlaylistModel);
-                mPlaylistModel.getDataset().observe(this, mPlaylistObserver);
-            }
-            mPlaylistToggle.setVisibility(View.VISIBLE);
-            if (mHudBinding != null) {
-                mHudBinding.playlistPrevious.setVisibility(View.VISIBLE);
-                mHudBinding.playlistNext.setVisibility(View.VISIBLE);
-            }
-            mPlaylistToggle.setOnClickListener(VideoPlayerActivity.this);
-
-            final ItemTouchHelper.Callback callback =  new SwipeDragItemTouchHelperCallback(mPlaylistAdapter);
-            final ItemTouchHelper touchHelper = new ItemTouchHelper(callback);
-            touchHelper.attachToRecyclerView(mPlaylist);
-        }
-    }
-
-    private void initUI() {
-
-        /* Dispatch ActionBar touch events to the Activity */
-        mActionBarView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                onTouchEvent(event);
-                return true;
-            }
-        });
-
-        final boolean secondary = mDisplayManager.isSecondary();
-        if (secondary) mSecondaryDisplayBtn.setImageResource(R.drawable.ic_stop_screen_share);
-        mSecondaryDisplayBtn.setVisibility(UiTools.hasSecondaryDisplay(getApplicationContext()) ? View.VISIBLE : View.GONE);
-        mSecondaryDisplayBtn.setContentDescription(getResources().getString(secondary ? R.string.video_remote_disable : R.string.video_remote_enable));
-        if (!mIsBenchmark && mEnableCloneMode && !mSettings.contains("enable_clone_mode")) {
-            UiTools.snackerConfirm(mSecondaryDisplayBtn, getString(R.string.video_save_clone_mode), new Runnable() {
-                @Override
-                public void run() {
-                    mSettings.edit().putBoolean("enable_clone_mode", true).apply();
-                }
-            });
-        }
-
-        /* Listen for changes to media routes. */
-        if (!mIsBenchmark) mDisplayManager.setMediaRouterCallback();
-
-        if (mRootView != null) mRootView.setKeepScreenOn(true);
-    }
-
-    private void setPlaybackParameters() {
-        if (mAudioDelay != 0L && mAudioDelay != mService.getAudioDelay())
-            mService.setAudioDelay(mAudioDelay);
-        else if (mAudioManager != null && (mAudioManager.isBluetoothA2dpOn() || mAudioManager.isBluetoothScoOn()))
-            toggleBtDelay(true);
-        if (mSpuDelay != 0L && mSpuDelay != mService.getSpuDelay())
-            mService.setSpuDelay(mSpuDelay);
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    private void stopPlayback() {
-        if (!mPlaybackStarted) return;
-
-        if (!mDisplayManager.isPrimary() && !isFinishing() || mService == null) {
-            mPlaybackStarted = false;
-            return;
-        }
-        mWasPaused = !(mService.isPlaying() && isInteractive());
-        if (mWasPaused) mSettings.edit().putBoolean(PreferencesActivity.VIDEO_PAUSED, true).apply();
-        if (!isFinishing()) {
-            mCurrentAudioTrack = mService.getAudioTrack();
-            mCurrentSpuTrack = mService.getSpuTrack();
-        }
-
-        if (mMute) mute(false);
-
-        mPlaybackStarted = false;
-
-        mHandler.removeCallbacksAndMessages(null);
-        mService.getMediaplayer().detachViews();
-        if (mService.hasMedia() && mSwitchingView) {
-            if (BuildConfig.DEBUG) Log.d(TAG, "mLocation = \"" + mUri + "\"");
-            if (mSwitchToPopup)
-                mService.switchToPopup(mService.getCurrentMediaPosition());
-            else {
-                mService.getCurrentMediaWrapper().addFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-                mService.showWithoutParse(mService.getCurrentMediaPosition());
-            }
-            return;
-        }
-
-        if (mService.isSeekable()) {
-            mSavedTime = getTime();
-            long length = mService.getLength();
-            //remove saved position if in the last 5 seconds
-            if (length - mSavedTime < 5000) mSavedTime = 0;
-            else mSavedTime -= 2000; // go back 2 seconds, to compensate loading time
-        }
-        mService.stop();
-    }
-
-    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-    private void cleanUI() {
-
-        if (mRootView != null) mRootView.setKeepScreenOn(false);
-
-        /* Stop listening for changes to media routes. */
-        if (!mIsBenchmark) mDisplayManager.removeMediaRouterCallback();
-
-        if (!mDisplayManager.isSecondary() && mService != null) mService.getMediaplayer().detachViews();
-
-        mActionBarView.setOnTouchListener(null);
-    }
-
-    private boolean mAddNextTrack = false;
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, final Intent data) {
-        if(data == null) return;
-
-        if(data.hasExtra(FilePickerFragmentKt.EXTRA_MRL)) {
-            mService.addSubtitleTrack(Uri.parse(data.getStringExtra(FilePickerFragmentKt.EXTRA_MRL)), false);
-            final MediaWrapper mw = mService.getCurrentMediaWrapper();
-            if (mw != null) SlaveRepository.Companion.getInstance(this).saveSlave(mw.getLocation(), Media.Slave.Type.Subtitle, 2, data.getStringExtra(FilePickerFragmentKt.EXTRA_MRL));
-            mAddNextTrack = true;
-        } else if (BuildConfig.DEBUG) Log.d(TAG, "Subtitle selection dialog was cancelled");
-    }
-
-    public static void start(Context context, Uri uri) {
-        start(context, uri, null, false, -1);
-    }
-
-    public static void start(Context context, Uri uri, boolean fromStart) {
-        start(context, uri, null, fromStart, -1);
-    }
-
-    public static void start(Context context, Uri uri, String title) {
-        start(context, uri, title, false, -1);
-    }
-    public static void startOpened(Context context, Uri uri, int openedPosition) {
-        start(context, uri, null, false, openedPosition);
-    }
-
-    private static void start(Context context, Uri uri, String title, boolean fromStart, int openedPosition) {
-        final Intent intent = getIntent(context, uri, title, fromStart, openedPosition);
-        context.startActivity(intent);
-    }
-
-    public static Intent getIntent(String action, MediaWrapper mw, boolean fromStart, int openedPosition) {
-        return getIntent(action, VLCApplication.getAppContext(), mw.getUri(), mw.getTitle(), fromStart, openedPosition);
-    }
-
-    @NonNull
-    public static Intent getIntent(Context context, Uri uri, String title, boolean fromStart, int openedPosition) {
-        return getIntent(Constants.PLAY_FROM_VIDEOGRID, context, uri, title, fromStart, openedPosition);
-    }
-
-    @NonNull
-    public static Intent getIntent(String action, Context context, Uri uri, String title, boolean fromStart, int openedPosition) {
-        final Intent intent = new Intent(context, VideoPlayerActivity.class);
-        intent.setAction(action);
-        intent.putExtra(Constants.PLAY_EXTRA_ITEM_LOCATION, uri);
-        intent.putExtra(Constants.PLAY_EXTRA_ITEM_TITLE, title);
-        intent.putExtra(Constants.PLAY_EXTRA_FROM_START, fromStart);
-
-        if (openedPosition != -1 || !(context instanceof Activity)) {
-            if (openedPosition != -1)
-                intent.putExtra(Constants.PLAY_EXTRA_OPENED_POSITION, openedPosition);
-            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-        }
-        return intent;
-    }
-
-    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            final String action = intent.getAction();
-            if (Constants.SLEEP_INTENT.equalsIgnoreCase(action)) exitOK();
-        }
-    };
-
-    public void exit(int resultCode) {
-        if (isFinishing()) return;
-        final Intent resultIntent = new Intent(ACTION_RESULT);
-        if (mUri != null && mService != null) {
-            if (AndroidUtil.isNougatOrLater) resultIntent.putExtra(EXTRA_URI, mUri.toString());
-            else resultIntent.setData(mUri);
-            resultIntent.putExtra(EXTRA_POSITION, mService.getTime());
-            resultIntent.putExtra(EXTRA_DURATION, mService.getLength());
-        }
-        setResult(resultCode, resultIntent);
-        finish();
-    }
-
-    private void exitOK() {
-        exit(RESULT_OK);
-    }
-
-    @Override
-    public boolean onTrackballEvent(MotionEvent event) {
-        if (mIsLoading) return false;
-        showOverlay();
-        return true;
-    }
-
-    @Override
-    public boolean dispatchGenericMotionEvent(MotionEvent event) {
-        return !mIsLoading && mTouchDelegate != null && mTouchDelegate.dispatchGenericMotionEvent(event);
-    }
-
-    @Override
-    public void onBackPressed() {
-        if (mOptionsDelegate != null && mOptionsDelegate.isShowing()) {
-            mOptionsDelegate.hide();
-        } else if (mLockBackButton) {
-            mLockBackButton = false;
-            mHandler.sendEmptyMessageDelayed(RESET_BACK_LOCK, 2000);
-            Toast.makeText(getApplicationContext(), getString(R.string.back_quit_lock), Toast.LENGTH_SHORT).show();
-        } else if(isPlaylistVisible()) {
-            togglePlaylist();
-        } else if (isPlaybackSettingActive()){
-            endPlaybackSetting();
-        } else if (mIsTv && mShowing && !mIsLocked) {
-            hideOverlay(true);
-        } else {
-            exitOK();
-            super.onBackPressed();
-        }
-    }
-
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        if (mService == null || keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_BUTTON_B)
-            return super.onKeyDown(keyCode, event);
-        if (isPlaybackSettingActive() || isOptionsListShowing()) return false;
-        if (mIsLoading) {
-            switch (keyCode) {
-                case KeyEvent.KEYCODE_S:
-                case KeyEvent.KEYCODE_MEDIA_STOP:
-                    exitOK();
-                    return true;
-            }
-            return false;
-        }
-        //Handle playlist d-pad navigation
-        if (mPlaylist.hasFocus()) {
-            switch (keyCode) {
-                case KeyEvent.KEYCODE_DPAD_UP:
-                case KeyEvent.KEYCODE_DPAD_LEFT:
-                    mPlaylistAdapter.setCurrentIndex(mPlaylistAdapter.getCurrentIndex() - 1);
-                    break;
-                case KeyEvent.KEYCODE_DPAD_DOWN:
-                case KeyEvent.KEYCODE_DPAD_RIGHT:
-                    mPlaylistAdapter.setCurrentIndex(mPlaylistAdapter.getCurrentIndex() + 1);
-                    break;
-                case KeyEvent.KEYCODE_ENTER:
-                case KeyEvent.KEYCODE_DPAD_CENTER:
-                case KeyEvent.KEYCODE_BUTTON_A:
-                    mService.playIndex(mPlaylistAdapter.getCurrentIndex());
-                    break;
-            }
-            return true;
-        }
-        if (mShowing || (mFov == 0f && keyCode == KeyEvent.KEYCODE_DPAD_DOWN))
-            showOverlayTimeout(OVERLAY_TIMEOUT);
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_F:
-            case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
-                seekDelta(10000);
-                return true;
-            case KeyEvent.KEYCODE_R:
-            case KeyEvent.KEYCODE_MEDIA_REWIND:
-                seekDelta(-10000);
-                return true;
-            case KeyEvent.KEYCODE_BUTTON_R1:
-                seekDelta(60000);
-                return true;
-            case KeyEvent.KEYCODE_BUTTON_L1:
-                seekDelta(-60000);
-                return true;
-            case KeyEvent.KEYCODE_BUTTON_A:
-                if (mHudBinding != null && mHudBinding.progressOverlay.getVisibility() == View.VISIBLE)
-                    return false;
-            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
-            case KeyEvent.KEYCODE_MEDIA_PLAY:
-            case KeyEvent.KEYCODE_MEDIA_PAUSE:
-            case KeyEvent.KEYCODE_SPACE:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else if (keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE) //prevent conflict with remote control
-                    return super.onKeyDown(keyCode, event);
-                else
-                    doPlayPause();
-                return true;
-            case KeyEvent.KEYCODE_O:
-            case KeyEvent.KEYCODE_BUTTON_Y:
-            case KeyEvent.KEYCODE_MENU:
-                showAdvancedOptions();
-                return true;
-            case KeyEvent.KEYCODE_V:
-            case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
-            case KeyEvent.KEYCODE_BUTTON_X:
-                onAudioSubClick(mHudBinding != null ? mHudBinding.playerOverlayTracks : null);
-                return true;
-            case KeyEvent.KEYCODE_N:
-                showNavMenu();
-                return true;
-            case KeyEvent.KEYCODE_A:
-                resizeVideo();
-                return true;
-            case KeyEvent.KEYCODE_M:
-            case KeyEvent.KEYCODE_VOLUME_MUTE:
-                updateMute();
-                return true;
-            case KeyEvent.KEYCODE_S:
-            case KeyEvent.KEYCODE_MEDIA_STOP:
-                exitOK();
-                return true;
-            case KeyEvent.KEYCODE_DPAD_LEFT:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else if (!mShowing) {
-                    if (mFov == 0f) seekDelta(-10000);
-                    else mService.updateViewpoint(-5f, 0f, 0f, 0f, false);
-                    return true;
-                }
-            case KeyEvent.KEYCODE_DPAD_RIGHT:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else if (!mShowing) {
-                    if (mFov == 0f) seekDelta(10000);
-                    else mService.updateViewpoint(5f, 0f, 0f, 0f, false);
-                    return true;
-                }
-            case KeyEvent.KEYCODE_DPAD_UP:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else if (event.isCtrlPressed()) {
-                    volumeUp();
-                    return true;
-                } else if (!mShowing) {
-                    if (mFov == 0f) showAdvancedOptions();
-                    else mService.updateViewpoint(0f, -5f, 0f, 0f, false);
-                    return true;
-                }
-            case KeyEvent.KEYCODE_DPAD_DOWN:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else if (event.isCtrlPressed()) {
-                    volumeDown();
-                    return true;
-                } else if (!mShowing && mFov != 0f) {
-                    mService.updateViewpoint(0f, 5f, 0f, 0f, false);
-                    return true;
-                }
-            case KeyEvent.KEYCODE_DPAD_CENTER:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else if (!mShowing) {
-                    doPlayPause();
-                    return true;
-                }
-            case KeyEvent.KEYCODE_ENTER:
-                if (mIsNavMenu)
-                    return navigateDvdMenu(keyCode);
-                else
-                    return super.onKeyDown(keyCode, event);
-            case KeyEvent.KEYCODE_J:
-                delayAudio(-50000L);
-                return true;
-            case KeyEvent.KEYCODE_K:
-                delayAudio(50000L);
-                return true;
-            case KeyEvent.KEYCODE_G:
-                delaySubs(-50000L);
-                return true;
-            case KeyEvent.KEYCODE_H:
-                delaySubs(50000L);
-                return true;
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-                volumeDown();
-                return true;
-            case KeyEvent.KEYCODE_VOLUME_UP:
-                volumeUp();
-                return true;
-            case KeyEvent.KEYCODE_CAPTIONS:
-                selectSubtitles();
-                return true;
-            case KeyEvent.KEYCODE_PLUS:
-                mService.setRate(mService.getRate()*1.2f, true);
-                return true;
-            case KeyEvent.KEYCODE_EQUALS:
-                if (event.isShiftPressed()) {
-                    mService.setRate(mService.getRate() * 1.2f, true);
-                    return true;
-                }
-                return false;
-            case KeyEvent.KEYCODE_MINUS:
-                mService.setRate(mService.getRate()/1.2f, true);
-                return true;
-            case KeyEvent.KEYCODE_C:
-                resizeVideo();
-                return true;
-        }
-        return super.onKeyDown(keyCode, event);
-    }
-
-    int getAudioMax() {
-        return mAudioMax;
-    }
-
-    AudioManager getAudiomanager() {
-        return mAudioManager;
-    }
-
-    float getVolume() {
-        return mVol;
-    }
-
-    void setVolume(float vol) {
-        mVol = vol;
-    }
-
-    float getOriginalVol() {
-        return mOriginalVol;
-    }
-
-    void setOriginalVol(float vol) {
-        mOriginalVol = vol;
-    }
-
-    boolean isAudioBoostEnabled() {
-        return audioBoostEnabled;
-    }
-
-    private void volumeUp() {
-        if (mMute) {
-            updateMute();
-        } else {
-            int volume;
-            if (mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC) < mAudioMax)
-                volume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC) + 1;
-            else
-                volume = Math.round(((float)mService.getVolume())*mAudioMax/100 + 1);
-            volume = Math.min(Math.max(volume, 0), mAudioMax * (audioBoostEnabled ? 2 : 1));
-            setAudioVolume(volume);
-        }
-    }
-
-    private void volumeDown() {
-        int vol;
-        if (mService.getVolume() > 100)
-            vol = Math.round(((float)mService.getVolume())*mAudioMax/100 - 1);
-        else
-            vol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC) - 1;
-        vol = Math.min(Math.max(vol, 0), mAudioMax * (audioBoostEnabled ? 2 : 1));
-        mOriginalVol = vol;
-        setAudioVolume(vol);
-    }
-
-    boolean navigateDvdMenu(int keyCode) {
-        switch (keyCode) {
-            case KeyEvent.KEYCODE_DPAD_UP:
-                mService.navigate(MediaPlayer.Navigate.Up);
-                return true;
-            case KeyEvent.KEYCODE_DPAD_DOWN:
-                mService.navigate(MediaPlayer.Navigate.Down);
-                return true;
-            case KeyEvent.KEYCODE_DPAD_LEFT:
-                mService.navigate(MediaPlayer.Navigate.Left);
-                return true;
-            case KeyEvent.KEYCODE_DPAD_RIGHT:
-                mService.navigate(MediaPlayer.Navigate.Right);
-                return true;
-            case KeyEvent.KEYCODE_DPAD_CENTER:
-            case KeyEvent.KEYCODE_ENTER:
-            case KeyEvent.KEYCODE_BUTTON_X:
-            case KeyEvent.KEYCODE_BUTTON_A:
-                mService.navigate(MediaPlayer.Navigate.Activate);
-                return true;
-            default:
-                return false;
-        }
-    }
-
-    @Override
-    public void showAudioDelaySetting() {
-        mPlaybackSetting = DelayState.AUDIO;
-        showDelayControls();
-    }
-
-    @Override
-    public void showSubsDelaySetting() {
-        mPlaybackSetting = DelayState.SUBS;
-        showDelayControls();
-    }
-
-    public void showDelayControls(){
-        if (mTouchDelegate != null) mTouchDelegate.clearTouchAction();
-        if (!mDisplayManager.isPrimary()) showOverlayTimeout(OVERLAY_INFINITE);
-        ViewStubCompat vsc = findViewById(R.id.player_overlay_settings_stub);
-        if (vsc != null) {
-            vsc.inflate();
-            mPlaybackSettingPlus = findViewById(R.id.player_delay_plus);
-            mPlaybackSettingMinus = findViewById(R.id.player_delay_minus);
-
-        }
-        mPlaybackSettingMinus.setOnClickListener(this);
-        mPlaybackSettingPlus.setOnClickListener(this);
-        mPlaybackSettingMinus.setOnTouchListener(new OnRepeatListener(this));
-        mPlaybackSettingPlus.setOnTouchListener(new OnRepeatListener(this));
-        mPlaybackSettingMinus.setVisibility(View.VISIBLE);
-        mPlaybackSettingPlus.setVisibility(View.VISIBLE);
-        mPlaybackSettingPlus.requestFocus();
-        initPlaybackSettingInfo();
-    }
-
-
-    private void initPlaybackSettingInfo() {
-        initInfoOverlay();
-        UiTools.setViewVisibility(mVerticalBar, View.GONE);
-        UiTools.setViewVisibility(mOverlayInfo, View.VISIBLE);
-        String text = "";
-        if (mPlaybackSetting == DelayState.AUDIO) {
-            text += getString(R.string.audio_delay)+"\n";
-            text += mService.getAudioDelay() / 1000L;
-            text += " ms";
-        } else if (mPlaybackSetting == DelayState.SUBS) {
-            text += getString(R.string.spu_delay)+"\n";
-            text += mService.getSpuDelay() / 1000L;
-            text += " ms";
-        } else
-            text += "0";
-        mInfo.setText(text);
-    }
-
-    @Override
-    public void endPlaybackSetting() {
-        mService.saveMediaMeta();
-        if (mPlaybackSetting == DelayState.AUDIO
-                && (mAudioManager.isBluetoothA2dpOn() || mAudioManager.isBluetoothScoOn())) {
-            String msg = getString(R.string.audio_delay) + "\n"
-                    + mService.getAudioDelay() / 1000L
-                    + " ms";
-            Snackbar sb = Snackbar.make(mInfo, msg, Snackbar.LENGTH_LONG);
-            sb.setAction(R.string.save_bluetooth_delay, mBtSaveListener);
-            sb.show();
-        }
-        mPlaybackSetting = DelayState.OFF;
-        if (mPlaybackSettingMinus != null) {
-            mPlaybackSettingMinus.setOnClickListener(null);
-            mPlaybackSettingMinus.setVisibility(View.INVISIBLE);
-        }
-        if (mPlaybackSettingPlus != null) {
-            mPlaybackSettingPlus.setOnClickListener(null);
-            mPlaybackSettingPlus.setVisibility(View.INVISIBLE);
-        }
-        UiTools.setViewVisibility(mOverlayInfo, View.INVISIBLE);
-        mInfo.setText("");
-        if (mHudBinding != null) mHudBinding.playerOverlayPlay.requestFocus();
-    }
-
-    public void delayAudio(long delta) {
-        initInfoOverlay();
-        long delay = mService.getAudioDelay()+delta;
-        mService.setAudioDelay(delay);
-        mInfo.setText(getString(R.string.audio_delay)+"\n"+(delay/1000L)+" ms");
-        mAudioDelay = delay;
-        if (!isPlaybackSettingActive()) {
-            mPlaybackSetting = DelayState.AUDIO;
-            initPlaybackSettingInfo();
-        }
-    }
-
-    boolean isPlaybackSettingActive() {
-        return mPlaybackSetting != DelayState.OFF;
-    }
-
-    public void delaySubs(long delta) {
-        initInfoOverlay();
-        long delay = mService.getSpuDelay()+delta;
-        mService.setSpuDelay(delay);
-        mInfo.setText(getString(R.string.spu_delay) + "\n" + (delay / 1000L) + " ms");
-        mSpuDelay = delay;
-        if (!isPlaybackSettingActive()) {
-            mPlaybackSetting = DelayState.SUBS;
-            initPlaybackSettingInfo();
-        }
-    }
-
-    /**
-     * Lock screen rotation
-     */
-    private void lockScreen() {
-        if (mScreenOrientation != 100) {
-            mScreenOrientationLock = getRequestedOrientation();
-            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2)
-                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);
-            else
-                setRequestedOrientation(getScreenOrientation(100));
-        }
-        showInfo(R.string.locked, 1000);
-        if (mHudBinding != null) {
-            mHudBinding.lockOverlayButton.setImageResource(R.drawable.ic_locked_circle);
-            mHudBinding.playerOverlayTime.setEnabled(false);
-            mHudBinding.playerOverlaySeekbar.setEnabled(false);
-            mHudBinding.playerOverlayLength.setEnabled(false);
-            mHudBinding.playerOverlaySize.setEnabled(false);
-            mHudBinding.playlistNext.setEnabled(false);
-            mHudBinding.playlistPrevious.setEnabled(false);
-        }
-        hideOverlay(true);
-        mLockBackButton = true;
-        mIsLocked = true;
-    }
-
-    /**
-     * Remove screen lock
-     */
-    private void unlockScreen() {
-        if(mScreenOrientation != 100)
-            setRequestedOrientation(mScreenOrientationLock);
-        showInfo(R.string.unlocked, 1000);
-        if (mHudBinding != null) {
-            mHudBinding.lockOverlayButton.setImageResource(R.drawable.ic_lock_circle);
-            mHudBinding.playerOverlayTime.setEnabled(true);
-            mHudBinding.playerOverlaySeekbar.setEnabled(mService == null || mService.isSeekable());
-            mHudBinding.playerOverlayLength.setEnabled(true);
-            mHudBinding.playerOverlaySize.setEnabled(true);
-            mHudBinding.playlistNext.setEnabled(true);
-            mHudBinding.playlistPrevious.setEnabled(true);
-        }
-        mShowing = false;
-        mIsLocked = false;
-        showOverlay();
-        mLockBackButton = false;
-    }
-
-    /**
-     * Show text in the info view and vertical progress bar for "duration" milliseconds
-     * @param text
-     * @param duration
-     * @param barNewValue new volume/brightness value (range: 0 - 15)
-     */
-    private void showInfoWithVerticalBar(String text, int duration, int barNewValue, int max) {
-        showInfo(text, duration);
-        if (mVerticalBarProgress == null) return;
-        LinearLayout.LayoutParams layoutParams;
-        if (barNewValue <= 100) {
-            layoutParams = (LinearLayout.LayoutParams) mVerticalBarProgress.getLayoutParams();
-            layoutParams.weight = barNewValue * 100 / (float)max;
-            mVerticalBarProgress.setLayoutParams(layoutParams);
-            layoutParams = (LinearLayout.LayoutParams) mVerticalBarBoostProgress.getLayoutParams();
-            layoutParams.weight = 0;
-            mVerticalBarBoostProgress.setLayoutParams(layoutParams);
-        } else {
-            layoutParams = (LinearLayout.LayoutParams) mVerticalBarProgress.getLayoutParams();
-            layoutParams.weight = 100 * 100 / (float)max;
-            mVerticalBarProgress.setLayoutParams(layoutParams);
-            layoutParams = (LinearLayout.LayoutParams) mVerticalBarBoostProgress.getLayoutParams();
-            layoutParams.weight = (barNewValue - 100) * 100 / (float)max;
-            mVerticalBarBoostProgress.setLayoutParams(layoutParams);
-        }
-        mVerticalBar.setVisibility(View.VISIBLE);
-    }
-
-    /**
-     * Show text in the info view for "duration" milliseconds
-     * @param text
-     * @param duration
-     */
-    void showInfo(String text, int duration) {
-        if (isInPictureInPictureMode()) return;
-        initInfoOverlay();
-        UiTools.setViewVisibility(mVerticalBar, View.GONE);
-        UiTools.setViewVisibility(mOverlayInfo, View.VISIBLE);
-        mInfo.setText(text);
-        mHandler.removeMessages(FADE_OUT_INFO);
-        mHandler.sendEmptyMessageDelayed(FADE_OUT_INFO, duration);
-    }
-
-    private void initInfoOverlay() {
-        ViewStubCompat vsc = findViewById(R.id.player_info_stub);
-        if (vsc != null) {
-            vsc.inflate();
-            // the info textView is not on the overlay
-            mInfo = findViewById(R.id.player_overlay_textinfo);
-            mOverlayInfo = findViewById(R.id.player_overlay_info);
-            mVerticalBar = findViewById(R.id.verticalbar);
-            mVerticalBarProgress = findViewById(R.id.verticalbar_progress);
-            mVerticalBarBoostProgress = findViewById(R.id.verticalbar_boost_progress);
-        }
-    }
-
-    void showInfo(int textid, int duration) {
-        showInfo(getString(textid), duration);
-    }
-
-    /**
-     * hide the info view with "delay" milliseconds delay
-     * @param delay
-     */
-    private void hideInfo(int delay) {
-        mHandler.sendEmptyMessageDelayed(FADE_OUT_INFO, delay);
-    }
-
-    /**
-     * hide the info view
-     */
-    private void hideInfo() {
-        hideInfo(0);
-    }
-
-    private void fadeOutInfo() {
-        if (mOverlayInfo != null && mOverlayInfo.getVisibility() == View.VISIBLE) {
-            mOverlayInfo.startAnimation(AnimationUtils.loadAnimation(
-                    VideoPlayerActivity.this, android.R.anim.fade_out));
-            UiTools.setViewVisibility(mOverlayInfo, View.INVISIBLE);
-        }
-    }
-
-    /* PlaybackService.Callback */
-
-    @Override
-    public void update() {
-        if (mService == null || mPlaylistAdapter == null) return;
-        mPlaylistModel.update();
-    }
-
-    @Override
-    public void onMediaEvent(Media.Event event) {
-        switch (event.type) {
-            case Media.Event.ParsedChanged:
-                updateNavStatus();
-                break;
-            case Media.Event.MetaChanged:
-                break;
-        }
-    }
-
-    @Override
-    public void onMediaPlayerEvent(MediaPlayer.Event event) {
-        switch (event.type) {
-            case MediaPlayer.Event.Playing:
-                onPlaying();
-                break;
-            case MediaPlayer.Event.Paused:
-                updateOverlayPausePlay();
-                break;
-            case MediaPlayer.Event.Vout:
-                updateNavStatus();
-                if (event.getVoutCount() > 0 && mService != null)
-                    mService.getMediaplayer().updateVideoSurfaces();
-                if (mMenuIdx == -1)
-                    handleVout(event.getVoutCount());
-                break;
-            case MediaPlayer.Event.ESAdded:
-                if (mService != null && mMenuIdx == -1) {
-                    final MediaWrapper media = mMedialibrary.findMedia(mService.getCurrentMediaWrapper());
-                    if (media == null) return;
-                    if (event.getEsChangedType() == Media.Track.Type.Audio) {
-                        setESTrackLists();
-                        WorkersKt.runIO(new Runnable() {
-                            @Override
-                            public void run() {
-                                int audioTrack = (int) media.getMetaLong(MediaWrapper.META_AUDIOTRACK);
-                                if (audioTrack != 0 || mCurrentAudioTrack != -2)
-                                    mService.setAudioTrack(media.getId() == 0L ? mCurrentAudioTrack : audioTrack);
-                            }
-                        });
-                    } else if (event.getEsChangedType() == Media.Track.Type.Text) {
-                        setESTrackLists();
-                        WorkersKt.runIO(new Runnable() {
-                            @Override
-                            public void run() {
-                                int spuTrack = (int) media.getMetaLong(MediaWrapper.META_SUBTITLE_TRACK);
-                                if (mAddNextTrack) {
-                                    final MediaPlayer.TrackDescription[] tracks = mService.getSpuTracks();
-                                    if (!Util.isArrayEmpty(tracks)) mService.setSpuTrack(tracks[tracks.length-1].id);
-                                    mAddNextTrack = false;
-                                } else if (spuTrack != 0 || mCurrentSpuTrack != -2) {
-                                    mService.setSpuTrack(media.getId() == 0L ? mCurrentSpuTrack : spuTrack);
-                                }
-                            }
-                        });
-                    }
-                }
-            case MediaPlayer.Event.ESDeleted:
-                if (mService != null && mMenuIdx == -1 && event.getEsChangedType() == Media.Track.Type.Video) {
-                    mHandler.removeMessages(CHECK_VIDEO_TRACKS);
-                    mHandler.sendEmptyMessageDelayed(CHECK_VIDEO_TRACKS, 1000);
-                }
-                invalidateESTracks(event.getEsChangedType());
-                break;
-            case MediaPlayer.Event.ESSelected:
-                if (mService != null && event.getEsChangedType() == Media.VideoTrack.Type.Video) {
-                    Media.VideoTrack vt = mService.getCurrentVideoTrack();
-                    if (vt != null)
-                        mFov = vt.projection == Media.VideoTrack.Projection.Rectangular ? 0f : DEFAULT_FOV;
-                }
-                break;
-            case MediaPlayer.Event.SeekableChanged:
-                updateSeekable(event.getSeekable());
-                break;
-            case MediaPlayer.Event.PausableChanged:
-                updatePausable(event.getPausable());
-                break;
-            case MediaPlayer.Event.Buffering:
-                if (!mIsPlaying)
-                    break;
-                if (event.getBuffering() == 100f)
-                    stopLoading();
-                else if (!mHandler.hasMessages(LOADING_ANIMATION) && !mIsLoading
-                        && (mTouchDelegate == null || !mTouchDelegate.isSeeking()) && !mDragging)
-                    mHandler.sendEmptyMessageDelayed(LOADING_ANIMATION, LOADING_ANIMATION_DELAY);
-                break;
-        }
-    }
-
-    public Handler getHandler() {
-        return mHandler;
-    }
-
-    /**
-     * Handle resize of the surface and the overlay
-     */
-    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
-        @Override
-        public void handleMessage(Message msg) {
-            if (mService != null) switch (msg.what) {
-                case FADE_OUT:
-                    hideOverlay(false);
-                    break;
-                case FADE_OUT_INFO:
-                    fadeOutInfo();
-                    break;
-                case START_PLAYBACK:
-                    startPlayback();
-                    break;
-                case AUDIO_SERVICE_CONNECTION_FAILED:
-                    exit(RESULT_CONNECTION_FAILED);
-                    break;
-                case RESET_BACK_LOCK:
-                    mLockBackButton = true;
-                    break;
-                case CHECK_VIDEO_TRACKS:
-                    if (mService != null && mService.getVideoTracksCount() < 1 && mService.getAudioTracksCount() > 0) {
-                        Log.i(TAG, "No video track, open in audio mode");
-                        switchToAudioMode(true);
-                    }
-                    break;
-                case LOADING_ANIMATION:
-                    startLoading();
-                    break;
-                case HIDE_INFO:
-                    hideOverlay(true);
-                    break;
-                case SHOW_INFO:
-                    showOverlay();
-                    break;
-            }
-        }
-    };
-
-    private void onPlaying() {
-        final PlaybackService service = mService;
-        if (service == null) return;
-        mIsPlaying = true;
-        final MediaWrapper mw = service.getCurrentMediaWrapper();
-        if (mw == null) return;
-        setPlaybackParameters();
-        stopLoading();
-        updateOverlayPausePlay();
-        updateNavStatus();
-        if (!mw.hasFlag(MediaWrapper.MEDIA_PAUSED))
-            mHandler.sendEmptyMessageDelayed(FADE_OUT, OVERLAY_TIMEOUT);
-        else {
-            mw.removeFlags(MediaWrapper.MEDIA_PAUSED);
-            mWasPaused = false;
-        }
-        setESTracks();
-        if (mTitle != null && mTitle.length() == 0)
-            mTitle.setText(mw.getTitle());
-        // Get possible subtitles
-        observeDownloadedSubtitles();
-        if (mOptionsDelegate != null) mOptionsDelegate.setup();
-        mSettings.edit().remove(PreferencesActivity.VIDEO_PAUSED).apply();
-    }
-
-    private void encounteredError() {
-        if (isFinishing() || mService.hasNext()) return;
-        /* Encountered Error, exit player with a message */
-        mAlertDialog = new AlertDialog.Builder(VideoPlayerActivity.this)
-                .setOnCancelListener(new DialogInterface.OnCancelListener() {
-                    @Override
-                    public void onCancel(DialogInterface dialog) {
-                        exit(RESULT_PLAYBACK_ERROR);
-                    }
-                })
-                .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int id) {
-                        exit(RESULT_PLAYBACK_ERROR);
-                    }
-                })
-                .setTitle(R.string.encountered_error_title)
-                .setMessage(R.string.encountered_error_message)
-                .create();
-        mAlertDialog.show();
-    }
-
-    private final Runnable mSwitchAudioRunnable = new Runnable() {
-        @Override
-        public void run() {
-            if (mDisplayManager.isPrimary() && mService.hasMedia() && mService.getVideoTracksCount() == 0) {
-                Log.i(TAG, "Video track lost, switching to audio");
-                mSwitchingView = true;
-                exit(RESULT_VIDEO_TRACK_LOST);
-            }
-        }
-    };
-
-    private void handleVout(int voutCount) {
-        mHandler.removeCallbacks(mSwitchAudioRunnable);
-
-        final IVLCVout vlcVout = mService != null ? mService.getVout() : null;
-        if (vlcVout == null) return;
-        if (mDisplayManager.isPrimary() && vlcVout.areViewsAttached() && voutCount == 0) {
-            mHandler.postDelayed(mSwitchAudioRunnable, 4000);
-        }
-    }
-
-    @Override
-    public void recreate() {
-        mHandler.removeCallbacks(mSwitchAudioRunnable);
-        super.recreate();
-    }
-
-    public void switchToAudioMode(boolean showUI) {
-        if (mService == null) return;
-        mSwitchingView = true;
-        // Show the MainActivity if it is not in background.
-        if (showUI) {
-            Intent i = new Intent(this, mIsTv ? AudioPlayerActivity.class : MainActivity.class);
-            startActivity(i);
-        }
-        exitOK();
-    }
-
-    @Override
-    public boolean isInPictureInPictureMode() {
-        return AndroidUtil.isNougatOrLater && super.isInPictureInPictureMode();
-    }
-
-    @Override
-    public void onPictureInPictureModeChanged(boolean isInPictureInPictureMode) {
-        super.onPictureInPictureModeChanged(isInPictureInPictureMode);
-        if (mService != null) mService.getMediaplayer().updateVideoSurfaces();
-    }
-
-    void sendMouseEvent(int action, int x, int y) {
-        if (mService == null) return;
-        final IVLCVout vlcVout = mService.getVout();
-        vlcVout.sendMouseEvent(action, 0, x, y);
-    }
-
-    /**
-     * show/hide the overlay
-     */
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        return mService != null && mTouchDelegate != null && mTouchDelegate.onTouchEvent(event);
-    }
-
-    boolean updateViewpoint(float yaw, float pitch, float fov) {
-        return mService.updateViewpoint(yaw, pitch, 0, fov, false);
-    }
-
-    void initAudioVolume() {
-        if (mService.getVolume() <= 100) {
-            mVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
-            mOriginalVol = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);
-        }
-        else {
-            mVol = ((float)mService.getVolume()) * mAudioMax / 100;
-        }
-    }
-
-    public void toggleOverlay() {
-        if (!mShowing) showOverlay();
-        else hideOverlay(true);
-    }
-
-    //Toast that appears only once
-    public void displayWarningToast() {
-        if(warningToast != null) warningToast.cancel();
-        warningToast = Toast.makeText(getApplication(), R.string.audio_boost_warning, Toast.LENGTH_SHORT);
-        warningToast.show();
-    }
-
-    void setAudioVolume(int vol) {
-        if (AndroidUtil.isNougatOrLater && (vol <= 0 ^ mMute)) {
-            mute(!mMute);
-            return; //Android N+ throws "SecurityException: Not allowed to change Do Not Disturb state"
-        }
-
-        /* Since android 4.3, the safe volume warning dialog is displayed only with the FLAG_SHOW_UI flag.
-         * We don't want to always show the default UI volume, so show it only when volume is not set. */
-        if (vol <= mAudioMax) {
-            mService.setVolume(100);
-            if (vol !=  mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC)) {
-                try {
-                    mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, vol, 0);
-                    // High Volume warning can block volume setting
-                    if (mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC) != vol)
-                        mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, vol, AudioManager.FLAG_SHOW_UI);
-                } catch (RuntimeException ignored) {} //Some device won't allow us to change volume
-            }
-            vol = Math.round(vol * 100 / (float) mAudioMax);
-        } else {
-            vol = Math.round(vol * 100 / (float) mAudioMax);
-            mService.setVolume(Math.round(vol));
-        }
-        showInfoWithVerticalBar(getString(R.string.volume) + "\n" + Integer.toString(vol) + '%', 1000, vol, audioBoostEnabled ? 200 : 100);
-    }
-
-    private void mute(boolean mute) {
-        mMute = mute;
-        if (mMute)
-            mVolSave = mService.getVolume();
-        mService.setVolume(mMute ? 0 : mVolSave);
-    }
-
-    private void updateMute () {
-        mute(!mMute);
-        showInfo(mMute ? R.string.sound_off : R.string.sound_on, 1000);
-    }
-
-    void changeBrightness(float delta) {
-        // Estimate and adjust Brightness
-        final WindowManager.LayoutParams lp = getWindow().getAttributes();
-        float brightness =  Math.min(Math.max(lp.screenBrightness + delta, 0.01f), 1f);
-        setWindowBrightness(brightness);
-        brightness = Math.round(brightness * 100);
-        showInfoWithVerticalBar(getString(R.string.brightness) + "\n" + (int) brightness + '%', 1000, (int) brightness, 100);
-    }
-
-    void setWindowBrightness(float brightness) {
-        final WindowManager.LayoutParams lp = getWindow().getAttributes();
-        lp.screenBrightness = brightness;
-        // Set Brightness
-        getWindow().setAttributes(lp);
-    }
-
-    /**
-     * handle changes of the seekbar (slicer)
-     */
-    private final OnSeekBarChangeListener mSeekListener = new OnSeekBarChangeListener() {
-
-        @Override
-        public void onStartTrackingTouch(SeekBar seekBar) {
-            mDragging = true;
-            showOverlayTimeout(OVERLAY_INFINITE);
-        }
-
-        @Override
-        public void onStopTrackingTouch(SeekBar seekBar) {
-            mDragging = false;
-            showOverlay(true);
-        }
-
-        @Override
-        public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
-            if (!isFinishing() && fromUser && mService.isSeekable()) {
-                seek(progress);
-                showInfo(Tools.millisToString(progress), 1000);
-            }
-        }
-    };
-
-    public void onAudioSubClick(View anchor) {
-        int flags = 0;
-        if (enableSubs) {
-            flags |= Constants.CTX_DOWNLOAD_SUBTITLES_PLAYER;
-            if (mDisplayManager.isPrimary()) flags |= Constants.CTX_PICK_SUBS;
-        }
-        if (mService.getVideoTracksCount() > 2) flags |= Constants.CTX_VIDEO_TRACK;
-        if (mService.getAudioTracksCount() > 0) flags |= Constants.CTX_AUDIO_TRACK;
-        if (mService.getSpuTracksCount() > 0) flags |= Constants.CTX_SUBS_TRACK;
-
-        if (mOptionsDelegate == null) mOptionsDelegate = new PlayerOptionsDelegate(this, mService);
-        mOptionsDelegate.setFlags(flags);
-        mOptionsDelegate.show(PlayerOptionType.MEDIA_TRACKS);
-        hideOverlay(false);
-    }
-
-
-
-    @Override
-    public void onPopupMenu(View anchor, final int position, MediaWrapper media) {
-        final PopupMenu popupMenu = new PopupMenu(this, anchor);
-        popupMenu.getMenuInflater().inflate(R.menu.audio_player, popupMenu.getMenu());
-
-        popupMenu.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {
-            @Override
-            public boolean onMenuItemClick(MenuItem item) {
-                if(item.getItemId() == R.id.audio_player_mini_remove) {
-                    if (mService != null) {
-                        mPlaylistAdapter.remove(position);
-                        mService.remove(position);
-                        return true;
-                    }
-                }
-                return false;
-            }
-        });
-        popupMenu.show();
-    }
-
-    @Override
-    public void onSelectionSet(int position) {
-        mPlaylist.scrollToPosition(position);
-    }
-
-    @Override
-    public void playItem(int position, MediaWrapper item) {
-        mService.playIndex(position);
-    }
-
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.orientation_toggle:
-                toggleOrientation();
-                break;
-            case R.id.playlist_toggle:
-                togglePlaylist();
-                break;
-            case R.id.player_overlay_forward:
-                seekDelta(10000);
-                break;
-            case R.id.player_overlay_rewind:
-                seekDelta(-10000);
-                break;
-            case R.id.player_overlay_navmenu:
-                showNavMenu();
-                break;
-            case R.id.player_overlay_length:
-            case R.id.player_overlay_time:
-                toggleTimeDisplay();
-                break;
-            case R.id.player_delay_minus:
-                if (mPlaybackSetting == DelayState.AUDIO)
-                    delayAudio(-50000);
-                else if (mPlaybackSetting == DelayState.SUBS)
-                    delaySubs(-50000);
-                break;
-            case R.id.player_delay_plus:
-                if (mPlaybackSetting == DelayState.AUDIO)
-                    delayAudio(50000);
-                else if (mPlaybackSetting == DelayState.SUBS)
-                    delaySubs(50000);
-                break;
-            case R.id.video_renderer:
-                if (getSupportFragmentManager().findFragmentByTag("renderers") == null)
-                    new RenderersDialog().show(getSupportFragmentManager(), "renderers");
-                break;
-            case R.id.video_secondary_display:
-                clone = mDisplayManager.isSecondary();
-                recreate();
-                break;
-        }
-    }
-
-    @Override
-    public boolean onLongClick(View v) {
-        switch (v.getId()) {
-            case R.id.orientation_toggle:
-                return resetOrientation();
-        }
-
-        return false;
-    }
-
-    public void toggleTimeDisplay() {
-        sDisplayRemainingTime = !sDisplayRemainingTime;
-        showOverlay();
-        mSettings.edit().putBoolean(KEY_REMAINING_TIME_DISPLAY, sDisplayRemainingTime).apply();
-    }
-
-    public void toggleLock() {
-        if (mIsLocked) unlockScreen();
-        else lockScreen();
-    }
-
-    boolean isLoading() {
-        return mIsLoading;
-    }
-
-    boolean isShowing() {
-        return mShowing;
-    }
-
-    boolean isLocked() {
-        return mIsLocked;
-    }
-
-    float getFov() {
-        return mFov;
-    }
-
-    void setFov(float fov) {
-        mFov = fov;
-    }
-
-    boolean isOnPrimaryDisplay() {
-        return mDisplayManager.isPrimary();
-    }
-
-    public MediaPlayer.ScaleType getCurrentScaleType() {
-        return mService == null ? MediaPlayer.ScaleType.SURFACE_BEST_FIT : mService.getMediaplayer().getVideoScale();
-    }
-
-    public boolean toggleLoop(View v) {
-        if (mService == null) return false;
-        if (mService.getRepeatType() == Constants.REPEAT_ONE) {
-            showInfo(getString(R.string.repeat), 1000);
-            mService.setRepeatType(Constants.REPEAT_NONE);
-        } else {
-            mService.setRepeatType(Constants.REPEAT_ONE);
-            showInfo(getString(R.string.repeat_single), 1000);
-        }
-        return true;
-    }
-
-    @Override
-    public void onStorageAccessGranted() {
-        mHandler.sendEmptyMessage(START_PLAYBACK);
-    }
-
-    public boolean isOptionsListShowing() {
-        return mOptionsDelegate != null && mOptionsDelegate.isShowing();
-    }
-
-    public void hideOptions() {
-        if (mOptionsDelegate != null) mOptionsDelegate.hide();
-    }
-
-
-    private interface TrackSelectedListener {
-        void onTrackSelected(int trackID);
-    }
-
-    private void selectTrack(final MediaPlayer.TrackDescription[] tracks, int currentTrack, int titleId,
-                             final TrackSelectedListener listener) {
-        if (listener == null)
-            throw new IllegalArgumentException("listener must not be null");
-        if (tracks == null)
-            return;
-        final String[] nameList = new String[tracks.length];
-        final int[] idList = new int[tracks.length];
-        int i = 0;
-        int listPosition = 0;
-        for (MediaPlayer.TrackDescription track : tracks) {
-            idList[i] = track.id;
-            nameList[i] = track.name;
-            // map the track position to the list position
-            if (track.id == currentTrack) listPosition = i;
-            i++;
-        }
-
-        if (!isFinishing()) {
-            mAlertDialog = new AlertDialog.Builder(VideoPlayerActivity.this)
-                    .setTitle(titleId)
-                    .setSingleChoiceItems(nameList, listPosition, new DialogInterface.OnClickListener() {
-                        @Override
-                        public void onClick(DialogInterface dialog, int listPosition) {
-                            int trackID = -1;
-                            // Reverse map search...
-                            for (MediaPlayer.TrackDescription track : tracks) {
-                                if (idList[listPosition] == track.id) {
-                                    trackID = track.id;
-                                    break;
-                                }
-                            }
-                            listener.onTrackSelected(trackID);
-                            dialog.dismiss();
-                        }
-                    })
-                    .create();
-            mAlertDialog.setCanceledOnTouchOutside(true);
-            mAlertDialog.setOwnerActivity(VideoPlayerActivity.this);
-            mAlertDialog.show();
-        }
-    }
-
-    public void selectVideoTrack() {
-        setESTrackLists();
-        selectTrack(mVideoTracksList, mService.getVideoTrack(), R.string.track_video,
-                new TrackSelectedListener() {
-                    @Override
-                    public void onTrackSelected(int trackID) {
-                        if (trackID < -1 || mService == null) return;
-                        mService.setVideoTrack(trackID);
-                        seek(mService.getTime());
-                    }
-                });
-    }
-
-    public void selectAudioTrack() {
-        setESTrackLists();
-        selectTrack(mAudioTracksList, mService.getAudioTrack(), R.string.track_audio,
-                new TrackSelectedListener() {
-                    @Override
-                    public void onTrackSelected(final int trackID) {
-                        if (trackID < -1 || mService == null) return;
-                        mService.setAudioTrack(trackID);
-                        WorkersKt.runIO(new Runnable() {
-                            @Override
-                            public void run() {
-                                final MediaWrapper mw = mMedialibrary.findMedia(mService.getCurrentMediaWrapper());
-                                if (mw != null && mw.getId() != 0L) mw.setLongMeta(MediaWrapper.META_AUDIOTRACK, trackID);
-                            }
-                        });
-                    }
-                });
-    }
-
-    public void selectSubtitles() {
-        setESTrackLists();
-        selectTrack(mSubtitleTracksList, mService.getSpuTrack(), R.string.track_text,
-                new TrackSelectedListener() {
-                    @Override
-                    public void onTrackSelected(final int trackID) {
-                        if (trackID < -1 || mService == null) return;
-                        WorkersKt.runIO(new Runnable() {
-                            @Override
-                            public void run() {
-                                setSpuTrack(trackID);
-                            }
-                        });
-                    }
-                });
-    }
-
-    public void pickSubtitles() {
-        if (mUri == null) return;
-        mShowingDialog = true;
-        final Intent filePickerIntent = new Intent(this, FilePickerActivity.class);
-        filePickerIntent.setData(Uri.parse(FileUtils.getParent(mUri.toString())));
-        startActivityForResult(filePickerIntent, 0);
-    }
-
-
-    public void downloadSubtitles() {
-        final MediaWrapper mw = mService != null ? mService.getCurrentMediaWrapper() : null;
-        if (mw != null) MediaUtils.INSTANCE.getSubs(VideoPlayerActivity.this, mw);
-    }
-
-
-    @WorkerThread
-    private void setSpuTrack(final int trackID) {
-        WorkersKt.runOnMainThread(new Runnable() {
-            @Override
-            public void run() {
-                mService.setSpuTrack(trackID);
-            }
-        });
-        final MediaWrapper mw = mMedialibrary.findMedia(mService.getCurrentMediaWrapper());
-        if (mw != null && mw.getId() != 0L)
-            mw.setLongMeta(MediaWrapper.META_SUBTITLE_TRACK, trackID);
-    }
-
-    private void showNavMenu() {
-        if (mMenuIdx >= 0)
-            mService.setTitleIdx(mMenuIdx);
-    }
-
-    private void updateSeekable(boolean seekable) {
-        if (mHudBinding == null) return;
-        mHudBinding.playerOverlayRewind.setEnabled(seekable);
-        mHudBinding.playerOverlayRewind.setImageResource(seekable
-                ? R.drawable.ic_rewind_circle
-                : R.drawable.ic_rewind_circle_disable_o);
-        mHudBinding.playerOverlayForward.setEnabled(seekable);
-        mHudBinding.playerOverlayForward.setImageResource(seekable
-                ? R.drawable.ic_forward_circle
-                : R.drawable.ic_forward_circle_disable_o);
-        if (!mIsLocked)
-            mHudBinding.playerOverlaySeekbar.setEnabled(seekable);
-    }
-
-    private void updatePausable(boolean pausable) {
-        if (mHudBinding == null) return;
-        mHudBinding.playerOverlayPlay.setEnabled(pausable);
-        if (!pausable)
-            mHudBinding.playerOverlayPlay.setImageResource(R.drawable.ic_play_circle_disable_o);
-    }
-
-    public void doPlayPause() {
-        if (mService == null || !mService.isPausable()) return;
-        if (mService.isPlaying()) {
-            showOverlayTimeout(OVERLAY_INFINITE);
-            pause();
-        } else {
-            hideOverlay(true);
-            play();
-        }
-    }
-
-    private long getTime() {
-        long time = mService.getTime();
-        if (mForcedTime != -1 && mLastTime != -1) {
-            /* XXX: After a seek, playbackService.getTime can return the position before or after
-             * the seek position. Therefore we return mForcedTime in order to avoid the seekBar
-             * to move between seek position and the actual position.
-             * We have to wait for a valid position (that is after the seek position).
-             * to re-init mLastTime and mForcedTime to -1 and return the actual position.
-             */
-            if (mLastTime > mForcedTime) {
-                if (time <= mLastTime && time > mForcedTime || time > mLastTime)
-                    mLastTime = mForcedTime = -1;
-            } else {
-                if (time > mForcedTime)
-                    mLastTime = mForcedTime = -1;
-            }
-        } else if (time == 0) {
-            final MediaWrapper mw = mService.getCurrentMediaWrapper();
-            if (mw != null)
-                time = (int) mw.getTime();
-        }
-        return mForcedTime == -1 ? time : mForcedTime;
-    }
-
-    protected void seek(long position) {
-        seek(position, mService.getLength());
-    }
-
-    void seek(long position, long length) {
-        mForcedTime = position;
-        mLastTime = mService.getTime();
-        mService.seek(position, length);
-        mService.getPlaylistManager().getPlayer().updateProgress(position);
-    }
-
-    void seekDelta(int delta) {
-        // unseekable stream
-        if (mService.getLength() <= 0 || !mService.isSeekable()) return;
-
-        long position = getTime() + delta;
-        if (position < 0) position = 0;
-        seek(position);
-        StringBuilder sb = new StringBuilder();
-        if (delta > 0f)
-            sb.append('+');
-        sb.append((int)(delta/1000f))
-                .append("s (")
-                .append(Tools.millisToString(mService.getTime()))
-                .append(')');
-        showInfo(sb.toString(), 1000);
-    }
-
-    private void initSeekButton() {
-        if (mHudBinding == null) return;
-        mHudBinding.playerOverlayRewind.setOnClickListener(this);
-        mHudBinding.playerOverlayForward.setOnClickListener(this);
-        mHudBinding.playerOverlayRewind.setOnTouchListener(new OnRepeatListener(this));
-        mHudBinding.playerOverlayForward.setOnTouchListener(new OnRepeatListener(this));
-    }
-
-    public void resizeVideo() {
-        final int next = (mService.getMediaplayer().getVideoScale().ordinal()+1)%MediaPlayer.SURFACE_SCALES_COUNT;
-        final MediaPlayer.ScaleType scale = MediaPlayer.ScaleType.values()[next];
-        setVideoScale(scale);
-    }
-
-    void setVideoScale(MediaPlayer.ScaleType scale) {
-        mService.getMediaplayer().setVideoScale(scale);
-        final MediaPlayer.ScaleType newSize = mService.getMediaplayer().getVideoScale();
-        switch (newSize) {
-            case SURFACE_BEST_FIT:
-                showInfo(R.string.surface_best_fit, 1000);
-                break;
-            case SURFACE_FIT_SCREEN:
-                showInfo(R.string.surface_fit_screen, 1000);
-                break;
-            case SURFACE_FILL:
-                showInfo(R.string.surface_fill, 1000);
-                break;
-            case SURFACE_16_9:
-                showInfo("16:9", 1000);
-                break;
-            case SURFACE_4_3:
-                showInfo("4:3", 1000);
-                break;
-            case SURFACE_ORIGINAL:
-                showInfo(R.string.surface_original, 1000);
-                break;
-        }
-        mSettings.edit()
-                .putInt(PreferencesActivity.VIDEO_RATIO, newSize.ordinal())
-                .apply();
-    }
-
-    /**
-     * show overlay
-     * @param forceCheck: adjust the timeout in function of playing state
-     */
-    private void showOverlay(boolean forceCheck) {
-        if (forceCheck)
-            mOverlayTimeout = 0;
-        showOverlayTimeout(0);
-    }
-
-    /**
-     * show overlay with the previous timeout value
-     */
-    private void showOverlay() {
-        showOverlay(false);
-    }
-
-    /**
-     * show overlay
-     */
-    private void showOverlayTimeout(int timeout) {
-        if (mService == null) return;
-        if (isInPictureInPictureMode()) return;
-        initOverlay();
-        if (mHudBinding == null) return;
-        if (timeout != 0) mOverlayTimeout = timeout;
-        else mOverlayTimeout = mService.isPlaying() ? OVERLAY_TIMEOUT : OVERLAY_INFINITE;
-        if (mIsNavMenu){
-            mShowing = true;
-            return;
-        }
-        if (!mShowing) {
-            mShowing = true;
-            if (!mIsLocked) {
-                showControls(true);
-            }
-            dimStatusBar(false);
-            if (mHudBinding != null) mHudBinding.progressOverlay.setVisibility(View.VISIBLE);
-            if (!mDisplayManager.isPrimary())
-                mOverlayBackground.setVisibility(View.VISIBLE);
-            updateOverlayPausePlay();
-        }
-        mHandler.removeMessages(FADE_OUT);
-        if (mOverlayTimeout != OVERLAY_INFINITE)
-            mHandler.sendMessageDelayed(mHandler.obtainMessage(FADE_OUT), mOverlayTimeout);
-    }
-
-    private void showControls(boolean show) {
-        if (show && isInPictureInPictureMode()) return;
-        if (mHudBinding != null) {
-            mHudBinding.playerOverlayPlay.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-            if (mSeekButtons) {
-                mHudBinding.playerOverlayRewind.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-                mHudBinding.playerOverlayForward.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-            }
-            if (mDisplayManager.isPrimary()) mHudBinding.playerOverlaySize.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-            mHudBinding.playerOverlayTracks.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-            mHudBinding.playerOverlayAdvFunction.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-            if (mHasPlaylist) {
-                mHudBinding.playlistPrevious.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-                mHudBinding.playlistNext.setVisibility(show ? View.VISIBLE : View.INVISIBLE);
-            }
-        }
-    }
-
-    private PlayerHudBinding mHudBinding;
-    private boolean mSeekButtons, mHasPlaylist;
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
-    private void initOverlay() {
-        final ViewStubCompat vsc = findViewById(R.id.player_hud_stub);
-        if (vsc != null) {
-            mSeekButtons = mSettings.getBoolean("enable_seek_buttons", false);
-            vsc.inflate();
-            mHudBinding = DataBindingUtil.bind(findViewById(R.id.progress_overlay));
-            mHudBinding.setPlayer(this);
-            mHudBinding.setProgress(mService.getPlaylistManager().getPlayer().getProgress());
-            mHudBinding.setLifecycleOwner(this);
-            final RelativeLayout.LayoutParams layoutParams =
-                    (RelativeLayout.LayoutParams)mHudBinding.progressOverlay.getLayoutParams();
-            if (AndroidDevices.isPhone || !AndroidDevices.hasNavBar)
-                layoutParams.width = LayoutParams.MATCH_PARENT;
-            else
-                layoutParams.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE);
-            mHudBinding.progressOverlay.setLayoutParams(layoutParams);
-            mOverlayBackground = findViewById(R.id.player_overlay_background);
-            mNavMenu = findViewById(R.id.player_overlay_navmenu);
-            if (!AndroidDevices.isChromeBook && !mIsTv
-                    && Settings.INSTANCE.getInstance(this).getBoolean("enable_casting", true)) {
-                mRendererBtn = findViewById(R.id.video_renderer);
-                PlaybackService.Companion.getRenderer().observe(this, new Observer<RendererItem>() {
-                    @Override
-                    public void onChanged(@Nullable RendererItem rendererItem) {
-                        if (mRendererBtn != null) mRendererBtn.setImageResource(rendererItem == null ? R.drawable.ic_renderer_circle : R.drawable.ic_renderer_on_circle);
-                    }
-                });
-                RendererDelegate.INSTANCE.getRenderers().observe(this, new Observer<List<RendererItem>>() {
-                    @Override
-                    public void onChanged(@Nullable List<RendererItem> rendererItems) {
-                        UiTools.setViewVisibility(mRendererBtn, Util.isListEmpty(rendererItems) ? View.GONE : View.VISIBLE);
-                    }
-                });
-            }
-            if (mSeekButtons) initSeekButton();
-            resetHudLayout();
-            updateOverlayPausePlay();
-            updateSeekable(mService.isSeekable());
-            updatePausable(mService.isPausable());
-            updateNavStatus();
-            setListeners(true);
-            initPlaylistUi();
-            if (!mDisplayManager.isPrimary()) {
-                mHudBinding.lockOverlayButton.setVisibility(View.GONE);
-                mHudBinding.playerOverlaySize.setVisibility(View.GONE);
-            }
-
-            if(!mIsTv && !AndroidDevices.isChromeBook)
-                mOrientationToggle.setVisibility(View.VISIBLE);
-        } else if (mService != null && mHudBinding != null) {
-            mHudBinding.setProgress(mService.getPlaylistManager().getPlayer().getProgress());
-            mHudBinding.setLifecycleOwner(this);
-        }
-    }
-
-
-    /**
-     * hider overlay
-     */
-    void hideOverlay(boolean fromUser) {
-        if (mShowing) {
-            mHandler.removeMessages(FADE_OUT);
-            Log.i(TAG, "remove View!");
-            UiTools.setViewVisibility(mOverlayTips, View.INVISIBLE);
-            if (!mDisplayManager.isPrimary()) {
-                mOverlayBackground.startAnimation(AnimationUtils.loadAnimation(this, android.R.anim.fade_out));
-                mOverlayBackground.setVisibility(View.INVISIBLE);
-            }
-            if (mHudBinding != null) mHudBinding.progressOverlay.setVisibility(View.INVISIBLE);
-            showControls(false);
-            mShowing = false;
-            dimStatusBar(true);
-        } else if (!fromUser) {
-            /*
-             * Try to hide the Nav Bar again.
-             * It seems that you can't hide the Nav Bar if you previously
-             * showed it in the last 1-2 seconds.
-             */
-            dimStatusBar(true);
-        }
-    }
-
-    /**
-     * Dim the status bar and/or navigation icons when needed on Android 3.x.
-     * Hide it on Android 4.0 and later
-     */
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    private void dimStatusBar(boolean dim) {
-        if (mIsNavMenu) return;
-        if (dim || mIsLocked) mActionBar.hide();
-        else mActionBar.show();
-
-        int visibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
-        int navbar = 0;
-        if (dim || mIsLocked) {
-            getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
-            navbar |= View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |View.SYSTEM_UI_FLAG_LOW_PROFILE|View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
-            if (AndroidUtil.isKitKatOrLater) visibility |= View.SYSTEM_UI_FLAG_IMMERSIVE;
-            visibility |= View.SYSTEM_UI_FLAG_FULLSCREEN;
-        } else {
-            mActionBar.show();
-            getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
-            visibility |= View.SYSTEM_UI_FLAG_VISIBLE;
-        }
-
-        if (AndroidDevices.hasNavBar)
-            visibility |= navbar;
-        getWindow().getDecorView().setSystemUiVisibility(visibility);
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-    private void showTitle() {
-        if (mIsNavMenu) return;
-        mActionBar.show();
-
-        int visibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
-        int navbar = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
-        navbar |= View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
-
-        if (AndroidDevices.hasNavBar) visibility |= navbar;
-        getWindow().getDecorView().setSystemUiVisibility(visibility);
-
-    }
-
-    private void updateOverlayPausePlay() {
-        if (mService == null || mHudBinding == null) return;
-        if (mService.isPausable())
-            mHudBinding.playerOverlayPlay.setImageResource(mService.isPlaying() ? R.drawable.ic_pause_circle
-                    : R.drawable.ic_play_circle);
-        mHudBinding.playerOverlayPlay.requestFocus();
-    }
-
-    private void invalidateESTracks(int type) {
-        switch (type) {
-            case Media.Track.Type.Audio:
-                mAudioTracksList = null;
-                break;
-            case Media.Track.Type.Text:
-                mSubtitleTracksList = null;
-                break;
-        }
-    }
-
-    private void setESTracks() {
-        if (mLastAudioTrack >= -1) {
-            mService.setAudioTrack(mLastAudioTrack);
-            mLastAudioTrack = -2;
-        }
-        if (mLastSpuTrack >= -1) {
-            mService.setSpuTrack(mLastSpuTrack);
-            mLastSpuTrack = -2;
-        }
-    }
-
-    private void setESTrackLists() {
-        if (mAudioTracksList == null && mService.getAudioTracksCount() > 0)
-            mAudioTracksList = mService.getAudioTracks();
-        if (mSubtitleTracksList == null && mService.getSpuTracksCount() > 0)
-            mSubtitleTracksList = mService.getSpuTracks();
-        if (mVideoTracksList == null && mService.getVideoTracksCount() > 0)
-            mVideoTracksList = mService.getVideoTracks();
-    }
-
-
-    /**
-     *
-     */
-    private void play() {
-        mService.play();
-        if (mRootView != null)
-            mRootView.setKeepScreenOn(true);
-    }
-
-    /**
-     *
-     */
-    private void pause() {
-        mService.pause();
-        if (mRootView != null)
-            mRootView.setKeepScreenOn(false);
-    }
-
-    public void next() {
-        if (mService != null) mService.next();
-    }
-
-    public void previous() {
-        if (mService != null) mService.previous(false);
-    }
-
-    /*
-     * Additionnal method to prevent alert dialog to pop up
-     */
-    @SuppressWarnings({ "unchecked" })
-    private void loadMedia(boolean fromStart) {
-        mAskResume = false;
-        getIntent().putExtra(Constants.PLAY_EXTRA_FROM_START, fromStart);
-        loadMedia();
-    }
-
-    /**
-     * External extras:
-     * - position (long) - position of the video to start with (in ms)
-     * - subtitles_location (String) - location of a subtitles file to load
-     * - from_start (boolean) - Whether playback should start from start or from resume point
-     * - title (String) - video title, will be guessed from file if not set.
-     */
-    @SuppressLint("SdCardPath")
-    @TargetApi(12)
-    @SuppressWarnings({ "unchecked" })
-    protected void loadMedia() {
-        if (mService == null) return;
-        mIsPlaying = false;
-        String title = null;
-        boolean fromStart = false;
-        String itemTitle = null;
-        int positionInPlaylist = -1;
-        final Intent intent = getIntent();
-        final Bundle extras = intent.getExtras();
-        long savedTime = 0L;
-        final MediaWrapper currentMedia = mService.getCurrentMediaWrapper();
-        final boolean hasMedia = currentMedia != null;
-        final boolean isPlaying = mService.isPlaying();
-        /*
-         * If the activity has been paused by pressing the power button, then
-         * pressing it again will show the lock screen.
-         * But onResume will also be called, even if vlc-android is still in
-         * the background.
-         * To workaround this, pause playback if the lockscreen is displayed.
-         */
-        final KeyguardManager km = (KeyguardManager) getApplicationContext().getSystemService(KEYGUARD_SERVICE);
-        if (km != null && km.inKeyguardRestrictedInputMode())
-            mWasPaused = true;
-        if (mWasPaused && BuildConfig.DEBUG)
-            Log.d(TAG, "Video was previously paused, resuming in paused mode");
-        if (intent.getData() != null) mUri = intent.getData();
-        if (extras != null) {
-            if (intent.hasExtra(Constants.PLAY_EXTRA_ITEM_LOCATION))
-                mUri = extras.getParcelable(Constants.PLAY_EXTRA_ITEM_LOCATION);
-            fromStart = extras.getBoolean(Constants.PLAY_EXTRA_FROM_START, false);
-            // Consume fromStart option after first use to prevent
-            // restarting again when playback is paused.
-            intent.putExtra(Constants.PLAY_EXTRA_FROM_START, false);
-            mAskResume &= !fromStart;
-            savedTime = fromStart ? 0L : extras.getLong(Constants.PLAY_EXTRA_START_TIME); // position passed in by intent (ms)
-            if (!fromStart && savedTime == 0L) {
-                savedTime = extras.getInt(Constants.PLAY_EXTRA_START_TIME);
-            }
-            positionInPlaylist = extras.getInt(Constants.PLAY_EXTRA_OPENED_POSITION, -1);
-
-            final String path = extras.getString(Constants.PLAY_EXTRA_SUBTITLES_LOCATION);
-            if (!TextUtils.isEmpty(path)) mService.addSubtitleTrack(path, true);
-            if (intent.hasExtra(Constants.PLAY_EXTRA_ITEM_TITLE))
-                itemTitle = extras.getString(Constants.PLAY_EXTRA_ITEM_TITLE);
-        }
-        if (savedTime == 0L && mSavedTime > 0L) savedTime = mSavedTime;
-        final boolean restorePlayback = hasMedia && currentMedia.getUri().equals(mUri);
-
-        MediaWrapper openedMedia = null;
-        final boolean resumePlaylist = mService.isValidIndex(positionInPlaylist);
-        final boolean continueplayback = isPlaying && (restorePlayback || positionInPlaylist == mService.getCurrentMediaPosition());
-        if (resumePlaylist) {
-            // Provided externally from AudioService
-            if (BuildConfig.DEBUG) Log.d(TAG, "Continuing playback from PlaybackService at index " + positionInPlaylist);
-            openedMedia = mService.getMedias().get(positionInPlaylist);
-            if (openedMedia == null) {
-                encounteredError();
-                return;
-            }
-            itemTitle = openedMedia.getTitle();
-            updateSeekable(mService.isSeekable());
-            updatePausable(mService.isPausable());
-        }
-        if (mUri != null) {
-            MediaWrapper media = null;
-            if (!continueplayback) {
-                if (!resumePlaylist) {
-                    // restore last position
-                    media = mMedialibrary.getMedia(mUri);
-                    if (media == null && TextUtils.equals(mUri.getScheme(), "file") &&
-                            mUri.getPath() != null && mUri.getPath().startsWith("/sdcard")) {
-                        mUri = FileUtils.convertLocalUri(mUri);
-                        media = mMedialibrary.getMedia(mUri);
-                    }
-                    if (media != null && media.getId() != 0L && media.getTime() == 0L)
-                        media.setTime(media.getMetaLong(MediaWrapper.META_PROGRESS));
-                } else
-                    media = openedMedia;
-                if (media != null) {
-                    // in media library
-                    if (mAskResume && !fromStart && positionInPlaylist <= 0 && media.getTime() > 0) {
-                        showConfirmResumeDialog();
-                        return;
-                    }
-
-                    mLastAudioTrack = media.getAudioTrack();
-                    mLastSpuTrack = media.getSpuTrack();
-                } else if (!fromStart) {
-                    // not in media library
-                    if (mAskResume && savedTime > 0L) {
-                        showConfirmResumeDialog();
-                        return;
-                    } else {
-                        long rTime = mSettings.getLong(PreferencesActivity.VIDEO_RESUME_TIME, -1);
-                        if (rTime > 0) {
-                            if (mAskResume) {
-                                showConfirmResumeDialog();
-                                return;
-                            } else {
-                                mSettings.edit()
-                                        .putLong(PreferencesActivity.VIDEO_RESUME_TIME, -1)
-                                        .apply();
-                                savedTime = rTime;
-                            }
-                        }
-                    }
-                }
-            }
-
-            // Start playback & seek
-            /* prepare playback */
-            final boolean medialoaded = media != null;
-            if (!medialoaded) media = hasMedia ? currentMedia : new MediaWrapper(mUri);
-            if (mWasPaused)
-                media.addFlags(MediaWrapper.MEDIA_PAUSED);
-            if (intent.hasExtra(Constants.PLAY_DISABLE_HARDWARE))
-                media.addFlags(MediaWrapper.MEDIA_NO_HWACCEL);
-            media.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO);
-            media.addFlags(MediaWrapper.MEDIA_VIDEO);
-            if (fromStart) media.addFlags(MediaWrapper.MEDIA_FROM_START);
-
-            // Set resume point
-            if (!continueplayback && !fromStart) {
-                if (savedTime <= 0L && media.getTime() > 0L) savedTime = media.getTime();
-                if (savedTime > 0L) mService.saveStartTime(savedTime);
-            }
-
-            // Handle playback
-            if (resumePlaylist) {
-                if (continueplayback) {
-                    if (mDisplayManager.isPrimary()) mService.flush();
-                    onPlaying();
-                } else
-                    mService.playIndex(positionInPlaylist);
-            } else if (medialoaded)
-                mService.load(media);
-            else
-                mService.loadUri(mUri);
-
-            // Get the title
-            if (itemTitle == null && !TextUtils.equals(mUri.getScheme(), "content"))
-                title = mUri.getLastPathSegment();
-        } else if (mService.hasMedia() && !mDisplayManager.isPrimary()){
-            onPlaying();
-        } else {
-            mService.loadLastPlaylist(Constants.PLAYLIST_TYPE_VIDEO);
-        }
-        if (itemTitle != null) title = itemTitle;
-        mTitle.setText(title);
-
-        if (mWasPaused) {
-            // XXX: Workaround to update the seekbar position
-            mForcedTime = savedTime;
-            mForcedTime = -1;
-            showOverlay(true);
-        }
-        enableSubs();
-    }
-
-    private boolean enableSubs = true;
-    private void enableSubs() {
-        if (mUri != null) {
-            final String lastPath = mUri.getLastPathSegment();
-            enableSubs = !TextUtils.isEmpty(lastPath) && !lastPath.endsWith(".ts") && !lastPath.endsWith(".m2ts")
-                    && !lastPath.endsWith(".TS") && !lastPath.endsWith(".M2TS");
-        }
-    }
-
-    private Observer downloadedSubtitleObserver = new Observer<List<ExternalSub>>() {
-        @Override
-        public void onChanged(@Nullable List <ExternalSub> externalSubs) {
-            for (ExternalSub externalSub : externalSubs) {
-                if (!addedExternalSubs.contains(externalSub)) {
-                    mService.addSubtitleTrack(externalSub.getSubtitlePath(), mCurrentSpuTrack == -2);
-                    addedExternalSubs.add(externalSub);
-                }
-            }
-        }
-    };
-
-    public void removeDownloadedSubtitlesObserver() {
-        if (downloadedSubtitleLiveData != null)
-            downloadedSubtitleLiveData.removeObserver(downloadedSubtitleObserver);
-        downloadedSubtitleLiveData = null;
-    }
-
-    public void observeDownloadedSubtitles() {
-        if (previousMediaPath == null || !mService.getCurrentMediaWrapper().getUri().getPath().equals(previousMediaPath)) {
-            previousMediaPath = mService.getCurrentMediaWrapper().getUri().getPath();
-            removeDownloadedSubtitlesObserver();
-            downloadedSubtitleLiveData = ExternalSubRepository.Companion.getInstance(VideoPlayerActivity.this).getDownloadedSubtitles(mService.getCurrentMediaWrapper().getUri().getPath());
-            downloadedSubtitleLiveData.observe(this, downloadedSubtitleObserver);
-        }
-    }
-
-    private int getScreenRotation(){
-        final WindowManager wm = (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
-        return wm == null ? Surface.ROTATION_0 : wm.getDefaultDisplay().getRotation();
-    }
-
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private int getScreenOrientation(int mode){
-        switch(mode) {
-            case 98: //toggle button
-                if (mCurrentScreenOrientation == Configuration.ORIENTATION_LANDSCAPE)
-                    return ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT;
-                else
-                    return ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
-            case 99: //screen orientation user
-                return AndroidUtil.isJellyBeanMR2OrLater ?
-                        ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR :
-                        ActivityInfo.SCREEN_ORIENTATION_SENSOR;
-            case 101: //screen orientation landscape
-                return ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
-            case 102: //screen orientation portrait
-                return ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT;
-        }
-        /*
-         mScreenOrientation = 100, we lock screen at its current orientation
-         */
-        final WindowManager wm = (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
-        if (wm == null) return 0;
-        final Display display = wm.getDefaultDisplay();
-        int rot = getScreenRotation();
-        /*
-         * Since getRotation() returns the screen's "natural" orientation,
-         * which is not guaranteed to be SCREEN_ORIENTATION_PORTRAIT,
-         * we have to invert the SCREEN_ORIENTATION value if it is "naturally"
-         * landscape.
-         */
-        @SuppressWarnings("deprecation")
-        boolean defaultWide = display.getWidth() > display.getHeight();
-        if(rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270)
-            defaultWide = !defaultWide;
-        if(defaultWide) {
-            switch (rot) {
-                case Surface.ROTATION_0:
-                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-                case Surface.ROTATION_90:
-                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-                case Surface.ROTATION_180:
-                    // SCREEN_ORIENTATION_REVERSE_PORTRAIT only available since API
-                    // Level 9+
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
-                case Surface.ROTATION_270:
-                    // SCREEN_ORIENTATION_REVERSE_LANDSCAPE only available since API
-                    // Level 9+
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
-                default:
-                    return 0;
-            }
-        } else {
-            switch (rot) {
-                case Surface.ROTATION_0:
-                    return ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
-                case Surface.ROTATION_90:
-                    return ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
-                case Surface.ROTATION_180:
-                    // SCREEN_ORIENTATION_REVERSE_PORTRAIT only available since API
-                    // Level 9+
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT;
-                case Surface.ROTATION_270:
-                    // SCREEN_ORIENTATION_REVERSE_LANDSCAPE only available since API
-                    // Level 9+
-                    return ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
-                default:
-                    return 0;
-            }
-        }
-    }
-
-    public void showConfirmResumeDialog() {
-        if (isFinishing()) return;
-        mService.pause();
-        /* Encountered Error, exit player with a message */
-        mAlertDialog = new AlertDialog.Builder(VideoPlayerActivity.this)
-                .setMessage(R.string.confirm_resume)
-                .setPositiveButton(R.string.resume_from_position, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int id) {
-                        loadMedia(false);
-                    }
-                })
-                .setNegativeButton(R.string.play_from_start, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int id) {
-                        loadMedia(true);
-                    }
-                })
-                .create();
-        mAlertDialog.setCancelable(false);
-        mAlertDialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
-            @Override
-            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
-                if (keyCode == KeyEvent.KEYCODE_BACK) {
-                    dialog.dismiss();
-                    finish();
-                    return true;
-                }
-                return false;
-            }
-        });
-        mAlertDialog.show();
-    }
-
-    private PlayerOptionsDelegate mOptionsDelegate;
-    public void showAdvancedOptions() {
-        if (mOptionsDelegate == null) mOptionsDelegate = new PlayerOptionsDelegate(this, mService);
-        mOptionsDelegate.show(PlayerOptionType.ADVANCED);
-        hideOverlay(false);
-    }
-
-    private void toggleOrientation() {
-        mScreenOrientation = 98; //Rotate button
-        setRequestedOrientation(getScreenOrientation(mScreenOrientation));
-    }
-
-    private boolean resetOrientation() {
-        if (mScreenOrientation == 98) {
-            mScreenOrientation = Integer.valueOf(
-                    mSettings.getString("screen_orientation", "99" /*SCREEN ORIENTATION SENSOR*/));
-            UiTools.snacker(mRootView, R.string.reset_orientation);
-            setRequestedOrientation(getScreenOrientation(mScreenOrientation));
-            return true;
-        }
-        return false;
-    }
-
-    void togglePlaylist() {
-        if (isPlaylistVisible()) {
-            mPlaylist.setVisibility(View.GONE);
-            mPlaylist.setOnClickListener(null);
-            return;
-        }
-        hideOverlay(true);
-        mPlaylist.setVisibility(View.VISIBLE);
-        mPlaylist.setAdapter(mPlaylistAdapter);
-        update();
-    }
-
-    public boolean isPlaylistVisible() {
-        return mPlaylist.getVisibility() == View.VISIBLE;
-    }
-
-    private final BroadcastReceiver mBtReceiver = new BroadcastReceiver() {
-        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (intent == null || mService == null) return;
-            switch (intent.getAction()) {
-                case BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED:
-                case BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED:
-                    long savedDelay = mSettings.getLong(KEY_BLUETOOTH_DELAY, 0L);
-                    long currentDelay = mService.getAudioDelay();
-                    if (savedDelay != 0L) {
-                        boolean connected = intent.getIntExtra(BluetoothA2dp.EXTRA_STATE, -1) == BluetoothA2dp.STATE_CONNECTED;
-                        if (connected && currentDelay == 0L)
-                            toggleBtDelay(true);
-                        else if (!connected && savedDelay == currentDelay)
-                            toggleBtDelay(false);
-                    }
-            }
-        }
-    };
-
-    private void toggleBtDelay(boolean connected) {
-        mService.setAudioDelay(connected ? mSettings.getLong(KEY_BLUETOOTH_DELAY, 0) : 0L);
-    }
-
-    private OnClickListener mBtSaveListener = new OnClickListener() {
-        @Override
-        public void onClick(View view) {
-            mSettings.edit().putLong(KEY_BLUETOOTH_DELAY, mService.getAudioDelay()).apply();
-        }
-    };
-
-    /**
-     * Start the video loading animation.
-     */
-    private void startLoading() {
-        if (mIsLoading)
-            return;
-        mIsLoading = true;
-        final AnimationSet anim = new AnimationSet(true);
-        final RotateAnimation rotate = new RotateAnimation(0f, 360f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
-        rotate.setDuration(800);
-        rotate.setInterpolator(new DecelerateInterpolator());
-        rotate.setRepeatCount(RotateAnimation.INFINITE);
-        anim.addAnimation(rotate);
-        mLoading.setVisibility(View.VISIBLE);
-        mLoading.startAnimation(anim);
-    }
-
-    /**
-     * Stop the video loading animation.
-     */
-    private void stopLoading() {
-        mHandler.removeMessages(LOADING_ANIMATION);
-        if (!mIsLoading) return;
-        mIsLoading = false;
-        mLoading.setVisibility(View.INVISIBLE);
-        mLoading.clearAnimation();
-    }
-
-    public void onClickOverlayTips(View v) {
-        UiTools.setViewVisibility(mOverlayTips, View.GONE);
-    }
-
-    public void onClickDismissTips(View v) {
-        UiTools.setViewVisibility(mOverlayTips, View.GONE);
-        mSettings.edit().putBoolean(PREF_TIPS_SHOWN, true).apply();
-    }
-
-    private void updateNavStatus() {
-        if (mService == null) return;
-        mIsNavMenu = false;
-        mMenuIdx = -1;
-
-        WorkersKt.runIO(new Runnable() {
-            @Override
-            public void run() {
-                final MediaPlayer.Title[] titles = mService != null ? mService.getTitles() : null;
-                WorkersKt.runOnMainThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        if (isFinishing() || !getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED)) return;
-                        if (titles != null) {
-                            final int currentIdx = mService.getTitleIdx();
-                            for (int i = 0; i < titles.length; ++i) {
-                                final MediaPlayer.Title title = titles[i];
-                                if (title.isMenu()) {
-                                    mMenuIdx = i;
-                                    break;
-                                }
-                            }
-                            mIsNavMenu = mMenuIdx == currentIdx;
-                        }
-
-                        if (mIsNavMenu) {
-                            /*
-                             * Keep the overlay hidden in order to have touch events directly
-                             * transmitted to navigation handling.
-                             */
-                            hideOverlay(false);
-                        } else if (mMenuIdx != -1) setESTracks();
-
-                        UiTools.setViewVisibility(mNavMenu, mMenuIdx >= 0 && mNavMenu != null ? View.VISIBLE : View.GONE);
-                        supportInvalidateOptionsMenu();
-                    }
-                });
-            }
-        });
-    }
-
-    @Override
-    public void onChanged(PlaybackService service) {
-        if (service != null) {
-            mService = service;
-            //We may not have the permission to access files
-            if (Permissions.checkReadStoragePermission(this, true) && !mSwitchingView)
-                mHandler.sendEmptyMessage(START_PLAYBACK);
-            mSwitchingView = false;
-            mHandler.post(new Runnable() {
-                @Override
-                public void run() { // delay mediaplayer loading, prevent ANR
-                    if (mService.getVolume() > 100 && !audioBoostEnabled) mService.setVolume(100);
-                }
-            });
-            mService.addCallback(this);
-        } else if (mService != null) {
-            mService.removeCallback(this);
-            mService = null;
-            mHandler.sendEmptyMessage(AUDIO_SERVICE_CONNECTION_FAILED);
-        }
-    }
-
-    private BroadcastReceiver mServiceReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            if (TextUtils.equals(intent.getAction(), Constants.PLAY_FROM_SERVICE))
-                onNewIntent(intent);
-            else if (TextUtils.equals(intent.getAction(), Constants.EXIT_PLAYER))
-                exitOK();
-        }
-    };
-
-    @BindingAdapter({"length", "time"})
-    public static void setPlaybackTime(TextView view, long length, long time) {
-        view.setText(sDisplayRemainingTime && length > 0
-                ? "-" + '\u00A0' + Tools.millisToString(length - time)
-                : Tools.millisToString(length));
-    }
-
-    @BindingAdapter({"mediamax"})
-    public static void setProgressMax(SeekBar view, long length) {
-        view.setMax((int) length);
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.kt b/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.kt
new file mode 100644
index 0000000000..8e7d07a36e
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoPlayerActivity.kt
@@ -0,0 +1,2841 @@
+/*****************************************************************************
+ * VideoPlayerActivity.java
+ *
+ * Copyright © 2011-2017 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.video
+
+import android.annotation.SuppressLint
+import android.annotation.TargetApi
+import android.app.Activity
+import android.app.KeyguardManager
+import android.app.PictureInPictureParams
+import android.bluetooth.BluetoothA2dp
+import android.bluetooth.BluetoothHeadset
+import android.content.*
+import android.content.pm.ActivityInfo
+import android.content.res.Configuration
+import android.media.AudioManager
+import android.net.Uri
+import android.os.*
+import android.text.TextUtils
+import android.util.DisplayMetrics
+import android.util.Log
+import android.util.Rational
+import android.view.*
+import android.view.View.OnClickListener
+import android.view.View.OnLongClickListener
+import android.view.ViewGroup.LayoutParams
+import android.view.animation.*
+import android.widget.*
+import android.widget.SeekBar.OnSeekBarChangeListener
+import androidx.annotation.StringRes
+import androidx.annotation.WorkerThread
+import androidx.appcompat.app.ActionBar
+import androidx.appcompat.app.AlertDialog
+import androidx.appcompat.app.AppCompatActivity
+import androidx.appcompat.widget.PopupMenu
+import androidx.appcompat.widget.ViewStubCompat
+import androidx.databinding.BindingAdapter
+import androidx.databinding.DataBindingUtil
+import androidx.lifecycle.Lifecycle
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.Observer
+import androidx.lifecycle.ViewModelProviders
+import androidx.localbroadcastmanager.content.LocalBroadcastManager
+import androidx.recyclerview.widget.ItemTouchHelper
+import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.recyclerview.widget.RecyclerView
+import com.google.android.material.snackbar.Snackbar
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.Media
+import org.videolan.libvlc.MediaPlayer
+import org.videolan.libvlc.RendererItem
+import org.videolan.libvlc.util.AndroidUtil
+import org.videolan.libvlc.util.DisplayManager
+import org.videolan.libvlc.util.VLCVideoLayout
+import org.videolan.medialibrary.Medialibrary
+import org.videolan.medialibrary.Tools
+import org.videolan.medialibrary.media.MediaWrapper
+import org.videolan.vlc.*
+import org.videolan.vlc.database.models.ExternalSub
+import org.videolan.vlc.databinding.PlayerHudBinding
+import org.videolan.vlc.gui.MainActivity
+import org.videolan.vlc.gui.audio.PlaylistAdapter
+import org.videolan.vlc.gui.browser.EXTRA_MRL
+import org.videolan.vlc.gui.browser.FilePickerActivity
+import org.videolan.vlc.gui.dialogs.RenderersDialog
+import org.videolan.vlc.gui.helpers.*
+import org.videolan.vlc.gui.helpers.hf.StoragePermissionsDelegate
+import org.videolan.vlc.gui.preferences.PreferencesActivity
+import org.videolan.vlc.gui.tv.audioplayer.AudioPlayerActivity
+import org.videolan.vlc.interfaces.IPlaybackSettingsController
+import org.videolan.vlc.media.MediaUtils
+import org.videolan.vlc.repository.ExternalSubRepository
+import org.videolan.vlc.repository.SlaveRepository
+import org.videolan.vlc.util.*
+import org.videolan.vlc.viewmodels.PlaylistModel
+import java.util.*
+
+@Suppress("DEPRECATION")
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+open class VideoPlayerActivity : AppCompatActivity(), IPlaybackSettingsController, PlaybackService.Callback, PlaylistAdapter.IPlayer, OnClickListener, OnLongClickListener, StoragePermissionsDelegate.CustomActionController, Observer<PlaybackService> {
+
+    var mService: PlaybackService? = null
+    private var medialibrary: Medialibrary? = null
+    private var videoLayout: VLCVideoLayout? = null
+    lateinit var displayManager: DisplayManager
+    private var rootView: View? = null
+    private var videoUri: Uri? = null
+    private var askResume = true
+
+    private var playlistToggle: ImageView? = null
+    private var playlist: RecyclerView? = null
+    private var playlistAdapter: PlaylistAdapter? = null
+    private var playlistModel: PlaylistModel? = null
+
+    private var orientationToggle: ImageView? = null
+
+    private var settings: SharedPreferences? = null
+
+    /** Overlay  */
+    private var actionBar: ActionBar? = null
+    private var actionBarView: ViewGroup? = null
+    private var overlayBackground: View? = null
+
+    private var isDragging: Boolean = false
+    internal var isShowing: Boolean = false
+        private set
+    private var isShowingDialog: Boolean = false
+    private var playbackSetting: IPlaybackSettingsController.DelayState = IPlaybackSettingsController.DelayState.OFF
+    private var titleTextView: TextView? = null
+    private var info: TextView? = null
+    private var overlayInfo: View? = null
+    private var verticalBar: View? = null
+    private var verticalBarProgress: View? = null
+    private var verticalBarBoostProgress: View? = null
+    internal var isLoading: Boolean = false
+        private set
+    private var isPlaying = false
+    private var loadingImageView: ImageView? = null
+    private var navMenu: ImageView? = null
+    private var rendererBtn: ImageView? = null
+    private var secondaryDisplayBtn: ImageView? = null
+    private var playbackSettingPlus: ImageView? = null
+    private var playbackSettingMinus: ImageView? = null
+    protected var enableCloneMode: Boolean = false
+    private var screenOrientation: Int = 0
+    private var screenOrientationLock: Int = 0
+    private var currentScreenOrientation: Int = 0
+
+    private var spuDelay = 0L
+    private var audioDelay = 0L
+    private var currentAudioTrack = -2
+    private var currentSpuTrack = -2
+
+    internal var isLocked = false
+        private set
+    /* -1 is a valid track (Disable) */
+    private var lastAudioTrack = -2
+    private var lastSpuTrack = -2
+    private var overlayTimeout = 0
+    private var lockBackButton = false
+    private var wasPaused = false
+    private var mSavedTime: Long = -1
+
+    /**
+     * For uninterrupted switching between audio and video mode
+     */
+    private var switchingView: Boolean = false
+    private var switchToPopup: Boolean = false
+
+    //Volume
+    internal var audiomanager: AudioManager? = null
+        private set
+    internal var audioMax: Int = 0
+        private set
+    internal var isAudioBoostEnabled: Boolean = false
+        private set
+    private var isMute = false
+    private var volSave: Int = 0
+    internal var volume: Float = 0.toFloat()
+    internal var originalVol: Float = 0.toFloat()
+    private var warningToast: Toast? = null
+
+    internal var fov: Float = 0.toFloat()
+    private var touchDelegate: VideoTouchDelegate? = null
+    private var isTv: Boolean = false
+
+    // Tracks & Subtitles
+    private var audioTracksList: Array<MediaPlayer.TrackDescription>? = null
+    private var videoTracksList: Array<MediaPlayer.TrackDescription>? = null
+    private var subtitleTracksList: Array<MediaPlayer.TrackDescription>? = null
+
+    /**
+     * Flag to indicate whether the media should be paused once loaded
+     * (e.g. lock screen, or to restore the pause state)
+     */
+    private var playbackStarted = false
+
+    // Tips
+    private var overlayTips: View? = null
+
+    // Navigation handling (DVD, Blu-Ray...)
+    private var menuIdx = -1
+    private var isNavMenu = false
+
+    /* for getTime and seek */
+    private var forcedTime: Long = -1
+    private var lastTime: Long = -1
+
+    private var alertDialog: AlertDialog? = null
+
+    protected var isBenchmark = false
+
+    private val addedExternalSubs = ArrayList<ExternalSub>()
+    private var downloadedSubtitleLiveData: LiveData<List<ExternalSub>>? = null
+    private var previousMediaPath: String? = null
+
+    private val isInteractive: Boolean
+        @TargetApi(Build.VERSION_CODES.KITKAT_WATCH)
+        get() {
+            val pm = applicationContext.getSystemService(Context.POWER_SERVICE) as PowerManager
+            return if (AndroidUtil.isLolliPopOrLater) pm.isInteractive else pm.isScreenOn
+        }
+
+    private val playlistObserver = Observer<List<MediaWrapper>> { mediaWrappers -> if (mediaWrappers != null) playlistAdapter!!.update(mediaWrappers) }
+
+    private var addNextTrack = false
+
+    private val receiver = object : BroadcastReceiver() {
+        override fun onReceive(context: Context, intent: Intent) {
+            val action = intent.action
+            if (SLEEP_INTENT.equals(action!!, ignoreCase = true)) exitOK()
+        }
+    }
+
+    internal val isPlaybackSettingActive: Boolean
+        get() = playbackSetting != IPlaybackSettingsController.DelayState.OFF
+
+    /**
+     * Handle resize of the surface and the overlay
+     */
+    val handler: Handler = object : Handler(Looper.getMainLooper()) {
+        override fun handleMessage(msg: Message) {
+            if (mService != null)
+                when (msg.what) {
+                    FADE_OUT -> hideOverlay(false)
+                    FADE_OUT_INFO -> fadeOutInfo()
+                    START_PLAYBACK -> startPlayback()
+                    AUDIO_SERVICE_CONNECTION_FAILED -> exit(RESULT_CONNECTION_FAILED)
+                    RESET_BACK_LOCK -> lockBackButton = true
+                    CHECK_VIDEO_TRACKS -> if (mService != null && mService!!.videoTracksCount < 1 && mService!!.audioTracksCount > 0) {
+                        Log.i(TAG, "No video track, open in audio mode")
+                        switchToAudioMode(true)
+                    }
+                    LOADING_ANIMATION -> startLoading()
+                    HIDE_INFO -> hideOverlay(true)
+                    SHOW_INFO -> showOverlay()
+                }
+        }
+    }
+
+    private val switchAudioRunnable = Runnable {
+        if (displayManager.isPrimary && mService!!.hasMedia() && mService!!.videoTracksCount == 0) {
+            Log.i(TAG, "Video track lost, switching to audio")
+            switchingView = true
+            exit(RESULT_VIDEO_TRACK_LOST)
+        }
+    }
+
+    /**
+     * handle changes of the seekbar (slicer)
+     */
+    private val seekListener = object : OnSeekBarChangeListener {
+
+        override fun onStartTrackingTouch(seekBar: SeekBar) {
+            isDragging = true
+            showOverlayTimeout(OVERLAY_INFINITE)
+        }
+
+        override fun onStopTrackingTouch(seekBar: SeekBar) {
+            isDragging = false
+            showOverlay(true)
+        }
+
+        override fun onProgressChanged(seekBar: SeekBar, progress: Int, fromUser: Boolean) {
+            if (!isFinishing && fromUser && mService!!.isSeekable) {
+                seek(progress.toLong())
+                showInfo(Tools.millisToString(progress.toLong()), 1000)
+            }
+        }
+    }
+
+    internal val isOnPrimaryDisplay: Boolean
+        get() = displayManager.isPrimary
+
+    val currentScaleType: MediaPlayer.ScaleType
+        get() = if (mService == null) MediaPlayer.ScaleType.SURFACE_BEST_FIT else mService!!.mediaplayer.videoScale
+
+    val isOptionsListShowing: Boolean
+        get() = optionsDelegate != null && optionsDelegate!!.isShowing()
+
+    /* XXX: After a seek, playbackService.getTime can return the position before or after
+             * the seek position. Therefore we return forcedTime in order to avoid the seekBar
+             * to move between seek position and the actual position.
+             * We have to wait for a valid position (that is after the seek position).
+             * to re-init lastTime and forcedTime to -1 and return the actual position.
+             */
+    private val time: Long
+        get() {
+            var time = mService!!.time
+            if (forcedTime != -1L && lastTime != -1L) {
+                if (lastTime > forcedTime) {
+                    if (time in (forcedTime + 1)..lastTime || time > lastTime) {
+                        forcedTime = -1
+                        lastTime = forcedTime
+                    }
+                } else {
+                    if (time > forcedTime) {
+                        forcedTime = -1
+                        lastTime = forcedTime
+                    }
+                }
+            } else if (time == 0L) {
+                val mw = mService!!.currentMediaWrapper
+                if (mw != null)
+                    time = mw.time.toInt().toLong()
+            }
+            return if (forcedTime == -1L) time else forcedTime
+        }
+
+    private var hudBinding: PlayerHudBinding? = null
+    private var seekButtons: Boolean = false
+    private var hasPlaylist: Boolean = false
+
+    private var enableSubs = true
+
+    private val downloadedSubtitleObserver = Observer<List<ExternalSub>> { externalSubs ->
+        for (externalSub in externalSubs!!) {
+            if (!addedExternalSubs.contains(externalSub)) {
+                mService!!.addSubtitleTrack(externalSub.subtitlePath, currentSpuTrack == -2)
+                addedExternalSubs.add(externalSub)
+            }
+        }
+    }
+
+    private val screenRotation: Int
+        get() {
+            val wm = applicationContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager
+            return wm.defaultDisplay?.rotation ?: Surface.ROTATION_0
+        }
+
+    private var optionsDelegate: PlayerOptionsDelegate? = null
+
+    val isPlaylistVisible: Boolean
+        get() = playlist!!.visibility == View.VISIBLE
+
+    private val btReceiver = object : BroadcastReceiver() {
+        @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+        override fun onReceive(context: Context, intent: Intent?) {
+            if (intent == null || mService == null) return
+            when (intent.action) {
+                BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED, BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED -> {
+                    val savedDelay = settings!!.getLong(KEY_BLUETOOTH_DELAY, 0L)
+                    val currentDelay = mService!!.audioDelay
+                    if (savedDelay != 0L) {
+                        val connected = intent.getIntExtra(BluetoothA2dp.EXTRA_STATE, -1) == BluetoothA2dp.STATE_CONNECTED
+                        if (connected && currentDelay == 0L)
+                            toggleBtDelay(true)
+                        else if (!connected && savedDelay == currentDelay)
+                            toggleBtDelay(false)
+                    }
+                }
+            }
+        }
+    }
+
+    private val btSaveListener = OnClickListener { settings!!.edit().putLong(KEY_BLUETOOTH_DELAY, mService!!.audioDelay).apply() }
+
+    private val serviceReceiver = object : BroadcastReceiver() {
+        override fun onReceive(context: Context, intent: Intent) {
+            if (TextUtils.equals(intent.action, PLAY_FROM_SERVICE))
+                onNewIntent(intent)
+            else if (TextUtils.equals(intent.action, EXIT_PLAYER))
+                exitOK()
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+
+        Util.checkCpuCompatibility(this)
+
+        settings = Settings.getInstance(this)
+
+        /* Services and miscellaneous */
+        audiomanager = applicationContext.getSystemService(Context.AUDIO_SERVICE) as AudioManager
+        audioMax = audiomanager!!.getStreamMaxVolume(AudioManager.STREAM_MUSIC)
+        isAudioBoostEnabled = settings!!.getBoolean("audio_boost", false)
+
+        enableCloneMode = if (clone != null) clone!! else settings!!.getBoolean("enable_clone_mode", false)
+        displayManager = DisplayManager(this, PlaybackService.renderer, false, enableCloneMode, isBenchmark)
+        setContentView(if (displayManager.isPrimary) R.layout.player else R.layout.player_remote_control)
+
+        /** initialize Views an their Events  */
+        actionBar = supportActionBar
+        actionBar!!.setDisplayShowHomeEnabled(false)
+        actionBar!!.setDisplayShowTitleEnabled(false)
+        actionBar!!.setBackgroundDrawable(null)
+        actionBar!!.setDisplayShowCustomEnabled(true)
+        actionBar!!.setCustomView(R.layout.player_action_bar)
+
+        rootView = findViewById(R.id.player_root)
+        actionBarView = actionBar!!.customView as ViewGroup
+
+        titleTextView = actionBarView!!.findViewById(R.id.player_overlay_title)
+
+        playlistToggle = actionBarView!!.findViewById(R.id.playlist_toggle)
+        playlist = findViewById(R.id.video_playlist)
+
+        secondaryDisplayBtn = actionBarView!!.findViewById(R.id.video_secondary_display)
+
+        orientationToggle = actionBarView!!.findViewById(R.id.orientation_toggle)
+
+        screenOrientation = Integer.valueOf(
+                settings!!.getString("screen_orientation", "99" /*SCREEN ORIENTATION SENSOR*/)!!)
+
+        videoLayout = findViewById(R.id.video_layout)
+
+        /* Loading view */
+        loadingImageView = findViewById(R.id.player_overlay_loading)
+        dimStatusBar(true)
+        handler.sendEmptyMessageDelayed(LOADING_ANIMATION, LOADING_ANIMATION_DELAY.toLong())
+
+        switchingView = false
+
+        askResume = settings!!.getBoolean("dialog_confirm_resume", false)
+        sDisplayRemainingTime = settings!!.getBoolean(KEY_REMAINING_TIME_DISPLAY, false)
+        // Clear the resume time, since it is only used for resumes in external
+        // videos.
+        val editor = settings!!.edit()
+        editor.putLong(PreferencesActivity.VIDEO_RESUME_TIME, -1)
+        // Paused flag - per session too, like the subs list.
+        editor.apply()
+
+        val filter = IntentFilter()
+        filter.addAction(SLEEP_INTENT)
+        registerReceiver(receiver, filter)
+
+        this.volumeControlStream = AudioManager.STREAM_MUSIC
+
+        // 100 is the value for screen_orientation_start_lock
+        try {
+            requestedOrientation = getScreenOrientation(screenOrientation)
+        } catch (ignored: IllegalStateException) {
+            Log.w(TAG, "onCreate: failed to set orientation")
+        }
+
+        // Extra initialization when no secondary display is detected
+        isTv = AndroidDevices.showTvUi(this)
+        if (displayManager.isPrimary) {
+            // Orientation
+            // Tips
+            if (!BuildConfig.DEBUG && !isTv && !settings!!.getBoolean(PREF_TIPS_SHOWN, false)
+                    && !isBenchmark) {
+                (findViewById<View>(R.id.player_overlay_tips) as ViewStubCompat).inflate()
+                overlayTips = findViewById(R.id.overlay_tips_layout)
+            }
+
+            //Set margins for TV overscan
+            if (isTv) {
+                val hm = resources.getDimensionPixelSize(R.dimen.tv_overscan_horizontal)
+                val vm = resources.getDimensionPixelSize(R.dimen.tv_overscan_vertical)
+
+                val uiContainer = findViewById<RelativeLayout>(R.id.player_ui_container)
+                val lp = uiContainer.layoutParams as RelativeLayout.LayoutParams
+                lp.setMargins(hm, 0, hm, vm)
+                uiContainer.layoutParams = lp
+
+                val titleParams = titleTextView!!.layoutParams as LinearLayout.LayoutParams
+                titleParams.setMargins(0, vm, 0, 0)
+                titleTextView!!.layoutParams = titleParams
+            }
+        }
+
+
+        medialibrary = VLCApplication.getMLInstance()
+        val touch = if (!isTv) {
+            ((if (settings!!.getBoolean("enable_volume_gesture", true)) TOUCH_FLAG_AUDIO_VOLUME else 0)
+                    + (if (settings!!.getBoolean("enable_brightness_gesture", true)) TOUCH_FLAG_BRIGHTNESS else 0)
+                    + if (settings!!.getBoolean("enable_double_tap_seek", true)) TOUCH_FLAG_SEEK else 0)
+        } else
+            0
+        currentScreenOrientation = resources.configuration.orientation
+        val dm = DisplayMetrics()
+        windowManager.defaultDisplay.getMetrics(dm)
+        val yRange = Math.min(dm.widthPixels, dm.heightPixels)
+        val xRange = Math.max(dm.widthPixels, dm.heightPixels)
+        val sc = ScreenConfig(dm, xRange, yRange, currentScreenOrientation)
+        touchDelegate = VideoTouchDelegate(this, touch, sc, isTv)
+        UiTools.setRotationAnimation(this)
+        if (savedInstanceState != null) {
+            mSavedTime = savedInstanceState.getLong(KEY_TIME)
+            videoUri = savedInstanceState.getParcelable<Parcelable>(KEY_URI) as Uri?
+        }
+        PlaybackService.start(this)
+    }
+
+    override fun onResume() {
+        overridePendingTransition(0, 0)
+        super.onResume()
+        isShowingDialog = false
+        /*
+         * Set listeners here to avoid NPE when activity is closing
+         */
+        setListeners(true)
+
+        if (isLocked && screenOrientation == 99) requestedOrientation = screenOrientationLock
+    }
+
+    private fun setListeners(enabled: Boolean) {
+        if (hudBinding != null) hudBinding!!.playerOverlaySeekbar.setOnSeekBarChangeListener(if (enabled) seekListener else null)
+        if (navMenu != null) navMenu!!.setOnClickListener(if (enabled) this else null)
+        if (orientationToggle != null) {
+            orientationToggle!!.setOnClickListener(if (enabled) this else null)
+            orientationToggle!!.setOnLongClickListener(if (enabled) this else null)
+        }
+        UiTools.setViewOnClickListener(rendererBtn, if (enabled) this else null)
+    }
+
+    override fun onNewIntent(intent: Intent) {
+        setIntent(intent)
+        if (playbackStarted && mService!!.currentMediaWrapper != null) {
+            var uri: Uri? = if (intent.hasExtra(PLAY_EXTRA_ITEM_LOCATION))
+                intent.extras!!.getParcelable<Parcelable>(PLAY_EXTRA_ITEM_LOCATION) as Uri?
+            else
+                intent.data
+            if (uri == null || uri == videoUri)
+                return
+            if (TextUtils.equals("file", uri.scheme) && uri.path!!.startsWith("/sdcard")) {
+                val convertedUri = FileUtils.convertLocalUri(uri)
+                if (convertedUri == null || convertedUri == videoUri)
+                    return
+                else
+                    uri = convertedUri
+            }
+            videoUri = uri
+            titleTextView!!.text = mService!!.currentMediaWrapper!!.title
+            if (isPlaylistVisible) {
+                playlistAdapter!!.currentIndex = mService!!.currentMediaPosition
+                playlist!!.visibility = View.GONE
+            }
+            if (settings!!.getBoolean("video_transition_show", true)) showTitle()
+            initUI()
+            lastTime = -1
+            forcedTime = lastTime
+            enableSubs()
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    override fun onPause() {
+        val finishing = isFinishing
+        if (finishing)
+            overridePendingTransition(0, 0)
+        else
+            hideOverlay(true)
+        super.onPause()
+        setListeners(false)
+
+        /* Stop the earliest possible to avoid vout error */
+
+        if (!isInPictureInPictureMode) {
+            if (finishing || (AndroidUtil.isNougatOrLater && !AndroidUtil.isOOrLater //Video on background on Nougat Android TVs
+
+                            && AndroidDevices.isAndroidTv && !requestVisibleBehind(true)))
+                stopPlayback()
+            else if (displayManager.isPrimary && !isShowingDialog && "2" == settings!!.getString(PreferencesActivity.KEY_VIDEO_APP_SWITCH, "0")
+                    && isInteractive && mService != null && !mService!!.hasRenderer()) {
+                switchToPopup()
+            }
+        }
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        super.onSaveInstanceState(outState)
+        if (videoUri != null && "content" != videoUri!!.scheme) {
+            outState.putLong(KEY_TIME, mSavedTime)
+            if (playlistModel == null) outState.putParcelable(KEY_URI, videoUri)
+        }
+        videoUri = null
+    }
+
+    @TargetApi(Build.VERSION_CODES.O)
+    fun switchToPopup() {
+        val mw = if (mService != null) mService!!.currentMediaWrapper else null
+        if (mw == null || !AndroidDevices.pipAllowed
+                || !lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED))
+            return
+
+        val forceLegacy = Settings.getInstance(this).getBoolean("popup_force_legacy", false)
+        if (AndroidDevices.hasPiP && !forceLegacy) {
+            if (AndroidUtil.isOOrLater)
+                try {
+                    val videoSurface = (if (videoLayout != null) videoLayout!!.findViewById<View>(R.id.surface_video) else null) as SurfaceView
+                    val height = if (videoSurface != null && videoSurface.height != 0) videoSurface.height else mw.height
+                    val width = Math.min(if (videoSurface != null && videoSurface.width != 0) videoSurface.width else mw.width, (height * 2.39f).toInt())
+                    enterPictureInPictureMode(PictureInPictureParams.Builder().setAspectRatio(Rational(width, height)).build())
+                } catch (e: IllegalArgumentException) { // Fallback with default parameters
+
+                    enterPictureInPictureMode()
+                }
+            else {
+
+                enterPictureInPictureMode()
+            }
+        } else {
+            if (Permissions.canDrawOverlays(this)) {
+                switchingView = true
+                switchToPopup = true
+                if (!mService!!.isPlaying)
+                    mw.addFlags(MediaWrapper.MEDIA_PAUSED)
+                cleanUI()
+                exitOK()
+            } else
+                Permissions.checkDrawOverlaysPermission(this)
+        }
+    }
+
+    override fun onVisibleBehindCanceled() {
+        super.onVisibleBehindCanceled()
+        stopPlayback()
+        exitOK()
+    }
+
+    override fun onConfigurationChanged(newConfig: Configuration) {
+        super.onConfigurationChanged(newConfig)
+        currentScreenOrientation = newConfig.orientation
+        if (screenOrientation == 98) {
+            @StringRes val message: Int
+            if (currentScreenOrientation == Configuration.ORIENTATION_LANDSCAPE)
+                message = R.string.locked_in_landscape_mode
+            else
+                message = R.string.locked_in_portrait_mode
+            if (rootView != null) UiTools.snacker(rootView!!, message)
+        }
+
+        if (touchDelegate != null) {
+            val dm = DisplayMetrics()
+            windowManager.defaultDisplay.getMetrics(dm)
+            val sc = ScreenConfig(dm,
+                    Math.max(dm.widthPixels, dm.heightPixels),
+                    Math.min(dm.widthPixels, dm.heightPixels),
+                    currentScreenOrientation)
+            touchDelegate!!.screenConfig = sc
+        }
+        resetHudLayout()
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    fun resetHudLayout() {
+        if (hudBinding == null) return
+        val layoutParams = hudBinding!!.playerOverlayButtons.layoutParams as RelativeLayout.LayoutParams
+        val orientation = getScreenOrientation(100)
+        val portrait = orientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_START, if (portrait) 1 else 0)
+        layoutParams.addRule(RelativeLayout.ALIGN_PARENT_END, if (portrait) 1 else 0)
+        layoutParams.addRule(RelativeLayout.BELOW, if (portrait) R.id.player_overlay_length else R.id.player_overlay_seekbar)
+        layoutParams.addRule(RelativeLayout.END_OF, if (portrait) 0 else R.id.player_overlay_time)
+        layoutParams.addRule(RelativeLayout.START_OF, if (portrait) 0 else R.id.player_overlay_length)
+        hudBinding!!.playerOverlayButtons.layoutParams = layoutParams
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    override fun onStart() {
+        super.onStart()
+        PlaybackService.service.observe(this, this)
+        restoreBrightness()
+        val filter = IntentFilter(PLAY_FROM_SERVICE)
+        filter.addAction(EXIT_PLAYER)
+        LocalBroadcastManager.getInstance(this).registerReceiver(
+                serviceReceiver, filter)
+        val btFilter = IntentFilter(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)
+        btFilter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)
+        registerReceiver(btReceiver, btFilter)
+        UiTools.setViewVisibility(overlayInfo, View.INVISIBLE)
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    override fun onStop() {
+        super.onStop()
+        PlaybackService.service.removeObservers(this)
+        LocalBroadcastManager.getInstance(this).unregisterReceiver(serviceReceiver)
+
+        unregisterReceiver(btReceiver)
+        if (alertDialog != null && alertDialog!!.isShowing)
+            alertDialog!!.dismiss()
+        if (displayManager.isPrimary && !isFinishing && mService != null && mService!!.isPlaying
+                && "1" == settings!!.getString(PreferencesActivity.KEY_VIDEO_APP_SWITCH, "0")) {
+            switchToAudioMode(false)
+        }
+
+        cleanUI()
+        stopPlayback()
+
+        val editor = settings!!.edit()
+        if (mSavedTime != -1L) editor.putLong(PreferencesActivity.VIDEO_RESUME_TIME, mSavedTime)
+
+        editor.apply()
+
+        saveBrightness()
+
+        if (mService != null) {
+            mService!!.removeCallback(this)
+            mService = null
+        }
+        // Clear Intent to restore playlist on activity restart
+        intent = Intent()
+        handler.removeCallbacksAndMessages(null)
+    }
+
+    private fun saveBrightness() {
+        // Save brightness if user wants to
+        if (settings!!.getBoolean("save_brightness", false)) {
+            val brightness = window.attributes.screenBrightness
+            if (brightness != -1f) {
+                val editor = settings!!.edit()
+                editor.putFloat("brightness_value", brightness)
+                editor.apply()
+            }
+        }
+    }
+
+    private fun restoreBrightness() {
+        if (settings!!.getBoolean("save_brightness", false)) {
+            val brightness = settings!!.getFloat("brightness_value", -1f)
+            if (brightness != -1f) setWindowBrightness(brightness)
+        }
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        unregisterReceiver(receiver)
+        if (playlistModel != null) {
+            playlistModel!!.dataset.removeObserver(playlistObserver)
+            playlistModel!!.onCleared()
+        }
+
+        // Dismiss the presentation when the activity is not visible.
+        displayManager.release()
+        audiomanager = null
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    private fun startPlayback() {
+        /* start playback only when audio service and both surfaces are ready */
+        if (playbackStarted || mService == null)
+            return
+
+        playbackStarted = true
+
+        val vlcVout = mService!!.vout
+        if (vlcVout != null && vlcVout.areViewsAttached()) {
+            if (mService!!.isPlayingPopup) {
+                mService!!.stop()
+            } else
+                vlcVout.detachViews()
+        }
+        val mediaPlayer = mService!!.mediaplayer
+        if (!displayManager.isOnRenderer && videoLayout != null) {
+            mediaPlayer.attachViews(videoLayout!!, displayManager, true, false)
+            val size = if (isBenchmark) MediaPlayer.ScaleType.SURFACE_FILL else MediaPlayer.ScaleType.values()[settings!!.getInt(PreferencesActivity.VIDEO_RATIO, MediaPlayer.ScaleType.SURFACE_BEST_FIT.ordinal)]
+            mediaPlayer.videoScale = size
+        }
+
+        initUI()
+
+        loadMedia()
+    }
+
+    private fun initPlaylistUi() {
+        if (mService != null && mService!!.hasPlaylist()) {
+            hasPlaylist = true
+            if (playlistAdapter == null) {
+                playlistAdapter = PlaylistAdapter(this)
+                val layoutManager = LinearLayoutManager(this, RecyclerView.VERTICAL, false)
+                playlist!!.layoutManager = layoutManager
+            }
+            if (playlistModel == null) {
+                playlistModel = ViewModelProviders.of(this).get(PlaylistModel::class.java)
+                playlistAdapter!!.setModel(playlistModel!!)
+                playlistModel!!.dataset.observe(this, playlistObserver)
+            }
+            playlistToggle!!.visibility = View.VISIBLE
+            if (hudBinding != null) {
+                hudBinding!!.playlistPrevious.visibility = View.VISIBLE
+                hudBinding!!.playlistNext.visibility = View.VISIBLE
+            }
+            playlistToggle!!.setOnClickListener(this@VideoPlayerActivity)
+
+            val callback = SwipeDragItemTouchHelperCallback(playlistAdapter)
+            val touchHelper = ItemTouchHelper(callback)
+            touchHelper.attachToRecyclerView(playlist)
+        }
+    }
+
+    private fun initUI() {
+
+        /* Dispatch ActionBar touch events to the Activity */
+        actionBarView!!.setOnTouchListener { _, event ->
+            onTouchEvent(event)
+            true
+        }
+
+        val secondary = displayManager.isSecondary
+        if (secondary) secondaryDisplayBtn!!.setImageResource(R.drawable.ic_stop_screen_share)
+        secondaryDisplayBtn!!.visibility = if (UiTools.hasSecondaryDisplay(applicationContext)) View.VISIBLE else View.GONE
+        secondaryDisplayBtn!!.contentDescription = resources.getString(if (secondary) R.string.video_remote_disable else R.string.video_remote_enable)
+        if (!isBenchmark && enableCloneMode && !settings!!.contains("enable_clone_mode")) {
+            UiTools.snackerConfirm(secondaryDisplayBtn!!, getString(R.string.video_save_clone_mode)) { settings!!.edit().putBoolean("enable_clone_mode", true).apply() }
+        }
+
+        /* Listen for changes to media routes. */
+        if (!isBenchmark) displayManager.setMediaRouterCallback()
+
+        if (rootView != null) rootView!!.keepScreenOn = true
+    }
+
+    private fun setPlaybackParameters() {
+        if (audioDelay != 0L && audioDelay != mService!!.audioDelay)
+            mService!!.setAudioDelay(audioDelay)
+        else if (audiomanager != null && (audiomanager!!.isBluetoothA2dpOn || audiomanager!!.isBluetoothScoOn))
+            toggleBtDelay(true)
+        if (spuDelay != 0L && spuDelay != mService!!.spuDelay)
+            mService!!.setSpuDelay(spuDelay)
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private fun stopPlayback() {
+        if (!playbackStarted) return
+
+        if (!displayManager.isPrimary && !isFinishing || mService == null) {
+            playbackStarted = false
+            return
+        }
+        wasPaused = !(mService!!.isPlaying && isInteractive)
+        if (wasPaused) settings!!.edit().putBoolean(PreferencesActivity.VIDEO_PAUSED, true).apply()
+        if (!isFinishing) {
+            currentAudioTrack = mService!!.audioTrack
+            currentSpuTrack = mService!!.spuTrack
+        }
+
+        if (isMute) mute(false)
+
+        playbackStarted = false
+
+        handler.removeCallbacksAndMessages(null)
+        mService!!.mediaplayer.detachViews()
+        if (mService!!.hasMedia() && switchingView) {
+            if (BuildConfig.DEBUG) Log.d(TAG, "mLocation = \"$videoUri\"")
+            if (switchToPopup)
+                mService!!.switchToPopup(mService!!.currentMediaPosition)
+            else {
+                mService!!.currentMediaWrapper!!.addFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+                mService!!.showWithoutParse(mService!!.currentMediaPosition)
+            }
+            return
+        }
+
+        if (mService!!.isSeekable) {
+            mSavedTime = time
+            val length = mService!!.length
+            //remove saved position if in the last 5 seconds
+            if (length - mSavedTime < 5000)
+                mSavedTime = 0
+            else
+                mSavedTime -= 2000 // go back 2 seconds, to compensate loading time
+        }
+        mService!!.stop()
+    }
+
+    @TargetApi(Build.VERSION_CODES.HONEYCOMB)
+    private fun cleanUI() {
+
+        if (rootView != null) rootView!!.keepScreenOn = false
+
+        /* Stop listening for changes to media routes. */
+        if (!isBenchmark) displayManager.removeMediaRouterCallback()
+
+        if (!displayManager.isSecondary && mService != null) mService!!.mediaplayer.detachViews()
+
+        actionBarView!!.setOnTouchListener(null)
+    }
+
+    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        if (data == null) return
+
+        if (data.hasExtra(EXTRA_MRL)) {
+            mService!!.addSubtitleTrack(Uri.parse(data.getStringExtra(EXTRA_MRL)), false)
+            val mw = mService!!.currentMediaWrapper
+            if (mw != null) SlaveRepository.getInstance(this).saveSlave(mw.location, Media.Slave.Type.Subtitle, 2, data.getStringExtra(EXTRA_MRL))
+            addNextTrack = true
+        } else if (BuildConfig.DEBUG) Log.d(TAG, "Subtitle selection dialog was cancelled")
+    }
+
+    open fun exit(resultCode: Int) {
+        if (isFinishing) return
+        val resultIntent = Intent(ACTION_RESULT)
+        if (videoUri != null && mService != null) {
+            if (AndroidUtil.isNougatOrLater)
+                resultIntent.putExtra(EXTRA_URI, videoUri!!.toString())
+            else
+                resultIntent.data = videoUri
+            resultIntent.putExtra(EXTRA_POSITION, mService!!.time)
+            resultIntent.putExtra(EXTRA_DURATION, mService!!.length)
+        }
+        setResult(resultCode, resultIntent)
+        finish()
+    }
+
+    private fun exitOK() {
+        exit(Activity.RESULT_OK)
+    }
+
+    override fun onTrackballEvent(event: MotionEvent): Boolean {
+        if (isLoading) return false
+        showOverlay()
+        return true
+    }
+
+    override fun dispatchGenericMotionEvent(event: MotionEvent): Boolean {
+        return !isLoading && touchDelegate != null && touchDelegate!!.dispatchGenericMotionEvent(event)
+    }
+
+    override fun onBackPressed() {
+        if (optionsDelegate != null && optionsDelegate!!.isShowing()) {
+            optionsDelegate!!.hide()
+        } else if (lockBackButton) {
+            lockBackButton = false
+            handler.sendEmptyMessageDelayed(RESET_BACK_LOCK, 2000)
+            Toast.makeText(applicationContext, getString(R.string.back_quit_lock), Toast.LENGTH_SHORT).show()
+        } else if (isPlaylistVisible) {
+            togglePlaylist()
+        } else if (isPlaybackSettingActive) {
+            endPlaybackSetting()
+        } else if (isTv && isShowing && !isLocked) {
+            hideOverlay(true)
+        } else {
+            exitOK()
+            super.onBackPressed()
+        }
+    }
+
+    override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
+        if (mService == null || keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_BUTTON_B)
+            return super.onKeyDown(keyCode, event)
+        if (isPlaybackSettingActive || isOptionsListShowing) return false
+        if (isLoading) {
+            when (keyCode) {
+                KeyEvent.KEYCODE_S, KeyEvent.KEYCODE_MEDIA_STOP -> {
+                    exitOK()
+                    return true
+                }
+            }
+            return false
+        }
+        //Handle playlist d-pad navigation
+        if (playlist!!.hasFocus()) {
+            when (keyCode) {
+                KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_LEFT -> playlistAdapter!!.currentIndex = playlistAdapter!!.currentIndex - 1
+                KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT -> playlistAdapter!!.currentIndex = playlistAdapter!!.currentIndex + 1
+                KeyEvent.KEYCODE_ENTER, KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_BUTTON_A -> mService!!.playIndex(playlistAdapter!!.currentIndex)
+            }
+            return true
+        }
+        if (isShowing || fov == 0f && keyCode == KeyEvent.KEYCODE_DPAD_DOWN)
+            showOverlayTimeout(OVERLAY_TIMEOUT)
+        when (keyCode) {
+            KeyEvent.KEYCODE_F, KeyEvent.KEYCODE_MEDIA_FAST_FORWARD -> {
+                seekDelta(10000)
+                return true
+            }
+            KeyEvent.KEYCODE_R, KeyEvent.KEYCODE_MEDIA_REWIND -> {
+                seekDelta(-10000)
+                return true
+            }
+            KeyEvent.KEYCODE_BUTTON_R1 -> {
+                seekDelta(60000)
+                return true
+            }
+            KeyEvent.KEYCODE_BUTTON_L1 -> {
+                seekDelta(-60000)
+                return true
+            }
+            KeyEvent.KEYCODE_BUTTON_A -> {
+                if (hudBinding != null && hudBinding!!.progressOverlay.visibility == View.VISIBLE)
+                    return false
+                when {
+                    isNavMenu -> return navigateDvdMenu(keyCode)
+                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE
+                        //prevent conflict with remote control
+                    -> return super.onKeyDown(keyCode, event)
+                    else -> doPlayPause()
+                }
+                return true
+            }
+            KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE, KeyEvent.KEYCODE_MEDIA_PLAY, KeyEvent.KEYCODE_MEDIA_PAUSE, KeyEvent.KEYCODE_SPACE -> {
+                when {
+                    isNavMenu -> return navigateDvdMenu(keyCode)
+                    keyCode == KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE -> return super.onKeyDown(keyCode, event)
+                    else -> doPlayPause()
+                }
+                return true
+            }
+            KeyEvent.KEYCODE_O, KeyEvent.KEYCODE_BUTTON_Y, KeyEvent.KEYCODE_MENU -> {
+                showAdvancedOptions()
+                return true
+            }
+            KeyEvent.KEYCODE_V, KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK, KeyEvent.KEYCODE_BUTTON_X -> {
+                onAudioSubClick(if (hudBinding != null) hudBinding!!.playerOverlayTracks else null)
+                return true
+            }
+            KeyEvent.KEYCODE_N -> {
+                showNavMenu()
+                return true
+            }
+            KeyEvent.KEYCODE_A -> {
+                resizeVideo()
+                return true
+            }
+            KeyEvent.KEYCODE_M, KeyEvent.KEYCODE_VOLUME_MUTE -> {
+                updateMute()
+                return true
+            }
+            KeyEvent.KEYCODE_S, KeyEvent.KEYCODE_MEDIA_STOP -> {
+                exitOK()
+                return true
+            }
+            KeyEvent.KEYCODE_DPAD_LEFT -> {
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    if (fov == 0f)
+                        seekDelta(-10000)
+                    else
+                        mService!!.updateViewpoint(-5f, 0f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    if (fov == 0f)
+                        seekDelta(10000)
+                    else
+                        mService!!.updateViewpoint(5f, 0f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeUp()
+                    return true
+                } else if (!isShowing) {
+                    if (fov == 0f)
+                        showAdvancedOptions()
+                    else
+                        mService!!.updateViewpoint(0f, -5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeDown()
+                    return true
+                } else if (!isShowing && fov != 0f) {
+                    mService!!.updateViewpoint(0f, 5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    doPlayPause()
+                    return true
+                }
+                return if (isNavMenu)
+                    navigateDvdMenu(keyCode)
+                else
+                    super.onKeyDown(keyCode, event)
+            }
+            KeyEvent.KEYCODE_DPAD_RIGHT -> {
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    if (fov == 0f)
+                        seekDelta(10000)
+                    else
+                        mService!!.updateViewpoint(5f, 0f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeUp()
+                    return true
+                } else if (!isShowing) {
+                    if (fov == 0f)
+                        showAdvancedOptions()
+                    else
+                        mService!!.updateViewpoint(0f, -5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeDown()
+                    return true
+                } else if (!isShowing && fov != 0f) {
+                    mService!!.updateViewpoint(0f, 5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    doPlayPause()
+                    return true
+                }
+                return if (isNavMenu)
+                    navigateDvdMenu(keyCode)
+                else
+                    super.onKeyDown(keyCode, event)
+            }
+            KeyEvent.KEYCODE_DPAD_UP -> {
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeUp()
+                    return true
+                } else if (!isShowing) {
+                    if (fov == 0f)
+                        showAdvancedOptions()
+                    else
+                        mService!!.updateViewpoint(0f, -5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeDown()
+                    return true
+                } else if (!isShowing && fov != 0f) {
+                    mService!!.updateViewpoint(0f, 5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    doPlayPause()
+                    return true
+                }
+                return if (isNavMenu)
+                    navigateDvdMenu(keyCode)
+                else
+                    super.onKeyDown(keyCode, event)
+            }
+            KeyEvent.KEYCODE_DPAD_DOWN -> {
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (event.isCtrlPressed) {
+                    volumeDown()
+                    return true
+                } else if (!isShowing && fov != 0f) {
+                    mService!!.updateViewpoint(0f, 5f, 0f, 0f, false)
+                    return true
+                }
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    doPlayPause()
+                    return true
+                }
+                return if (isNavMenu)
+                    navigateDvdMenu(keyCode)
+                else
+                    super.onKeyDown(keyCode, event)
+            }
+            KeyEvent.KEYCODE_DPAD_CENTER -> {
+                if (isNavMenu)
+                    return navigateDvdMenu(keyCode)
+                else if (!isShowing) {
+                    doPlayPause()
+                    return true
+                }
+                return if (isNavMenu)
+                    navigateDvdMenu(keyCode)
+                else
+                    super.onKeyDown(keyCode, event)
+            }
+            KeyEvent.KEYCODE_ENTER -> return if (isNavMenu)
+                navigateDvdMenu(keyCode)
+            else
+                super.onKeyDown(keyCode, event)
+            KeyEvent.KEYCODE_J -> {
+                delayAudio(-50000L)
+                return true
+            }
+            KeyEvent.KEYCODE_K -> {
+                delayAudio(50000L)
+                return true
+            }
+            KeyEvent.KEYCODE_G -> {
+                delaySubs(-50000L)
+                return true
+            }
+            KeyEvent.KEYCODE_H -> {
+                delaySubs(50000L)
+                return true
+            }
+            KeyEvent.KEYCODE_VOLUME_DOWN -> {
+                volumeDown()
+                return true
+            }
+            KeyEvent.KEYCODE_VOLUME_UP -> {
+                volumeUp()
+                return true
+            }
+            KeyEvent.KEYCODE_CAPTIONS -> {
+                selectSubtitles()
+                return true
+            }
+            KeyEvent.KEYCODE_PLUS -> {
+                mService!!.setRate(mService!!.rate * 1.2f, true)
+                return true
+            }
+            KeyEvent.KEYCODE_EQUALS -> {
+                if (event.isShiftPressed) {
+                    mService!!.setRate(mService!!.rate * 1.2f, true)
+                    return true
+                }
+                return false
+            }
+            KeyEvent.KEYCODE_MINUS -> {
+                mService!!.setRate(mService!!.rate / 1.2f, true)
+                return true
+            }
+            KeyEvent.KEYCODE_C -> {
+                resizeVideo()
+                return true
+            }
+        }
+        return super.onKeyDown(keyCode, event)
+    }
+
+    private fun volumeUp() {
+        if (isMute) {
+            updateMute()
+        } else {
+            var volume = if (audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC) < audioMax)
+                audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC) + 1
+            else
+                Math.round(mService!!.volume.toFloat() * audioMax / 100 + 1)
+            volume = Math.min(Math.max(volume, 0), audioMax * if (isAudioBoostEnabled) 2 else 1)
+            setAudioVolume(volume)
+        }
+    }
+
+    private fun volumeDown() {
+        var vol = if (mService!!.volume > 100)
+            Math.round(mService!!.volume.toFloat() * audioMax / 100 - 1)
+        else
+            audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC) - 1
+        vol = Math.min(Math.max(vol, 0), audioMax * if (isAudioBoostEnabled) 2 else 1)
+        originalVol = vol.toFloat()
+        setAudioVolume(vol)
+    }
+
+    internal fun navigateDvdMenu(keyCode: Int): Boolean {
+        when (keyCode) {
+            KeyEvent.KEYCODE_DPAD_UP -> {
+                mService!!.navigate(MediaPlayer.Navigate.Up)
+                return true
+            }
+            KeyEvent.KEYCODE_DPAD_DOWN -> {
+                mService!!.navigate(MediaPlayer.Navigate.Down)
+                return true
+            }
+            KeyEvent.KEYCODE_DPAD_LEFT -> {
+                mService!!.navigate(MediaPlayer.Navigate.Left)
+                return true
+            }
+            KeyEvent.KEYCODE_DPAD_RIGHT -> {
+                mService!!.navigate(MediaPlayer.Navigate.Right)
+                return true
+            }
+            KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_ENTER, KeyEvent.KEYCODE_BUTTON_X, KeyEvent.KEYCODE_BUTTON_A -> {
+                mService!!.navigate(MediaPlayer.Navigate.Activate)
+                return true
+            }
+            else -> return false
+        }
+    }
+
+    override fun showAudioDelaySetting() {
+        playbackSetting = IPlaybackSettingsController.DelayState.AUDIO
+        showDelayControls()
+    }
+
+    override fun showSubsDelaySetting() {
+        playbackSetting = IPlaybackSettingsController.DelayState.SUBS
+        showDelayControls()
+    }
+
+    @SuppressLint("ClickableViewAccessibility")
+    fun showDelayControls() {
+        if (touchDelegate != null) touchDelegate!!.clearTouchAction()
+        if (!displayManager.isPrimary) showOverlayTimeout(OVERLAY_INFINITE)
+        val vsc = findViewById<ViewStubCompat>(R.id.player_overlay_settings_stub)
+        if (vsc != null) {
+            vsc.inflate()
+            playbackSettingPlus = findViewById(R.id.player_delay_plus)
+            playbackSettingMinus = findViewById(R.id.player_delay_minus)
+
+        }
+        playbackSettingMinus!!.setOnClickListener(this)
+        playbackSettingPlus!!.setOnClickListener(this)
+        playbackSettingMinus!!.setOnTouchListener(OnRepeatListener(this))
+        playbackSettingPlus!!.setOnTouchListener(OnRepeatListener(this))
+        playbackSettingMinus!!.visibility = View.VISIBLE
+        playbackSettingPlus!!.visibility = View.VISIBLE
+        playbackSettingPlus!!.requestFocus()
+        initPlaybackSettingInfo()
+    }
+
+
+    private fun initPlaybackSettingInfo() {
+        initInfoOverlay()
+        UiTools.setViewVisibility(verticalBar, View.GONE)
+        UiTools.setViewVisibility(overlayInfo, View.VISIBLE)
+        var text = ""
+        when (playbackSetting) {
+            IPlaybackSettingsController.DelayState.AUDIO -> {
+                text += getString(R.string.audio_delay) + "\n"
+                text += mService!!.audioDelay / 1000L
+                text += " ms"
+            }
+            IPlaybackSettingsController.DelayState.SUBS -> {
+                text += getString(R.string.spu_delay) + "\n"
+                text += mService!!.spuDelay / 1000L
+                text += " ms"
+            }
+            else -> text += "0"
+        }
+        info!!.text = text
+    }
+
+    override fun endPlaybackSetting() {
+        mService!!.saveMediaMeta()
+        if (playbackSetting == IPlaybackSettingsController.DelayState.AUDIO && (audiomanager!!.isBluetoothA2dpOn || audiomanager!!.isBluetoothScoOn)) {
+            val msg = (getString(R.string.audio_delay) + "\n"
+                    + mService!!.audioDelay / 1000L
+                    + " ms")
+            val sb = Snackbar.make(info!!, msg, Snackbar.LENGTH_LONG)
+            sb.setAction(R.string.save_bluetooth_delay, btSaveListener)
+            sb.show()
+        }
+        playbackSetting = IPlaybackSettingsController.DelayState.OFF
+        if (playbackSettingMinus != null) {
+            playbackSettingMinus!!.setOnClickListener(null)
+            playbackSettingMinus!!.visibility = View.INVISIBLE
+        }
+        if (playbackSettingPlus != null) {
+            playbackSettingPlus!!.setOnClickListener(null)
+            playbackSettingPlus!!.visibility = View.INVISIBLE
+        }
+        UiTools.setViewVisibility(overlayInfo, View.INVISIBLE)
+        info!!.text = ""
+        if (hudBinding != null) hudBinding!!.playerOverlayPlay.requestFocus()
+    }
+
+    private fun delayAudio(delta: Long) {
+        initInfoOverlay()
+        val delay = mService!!.audioDelay + delta
+        mService!!.setAudioDelay(delay)
+        info!!.text = getString(R.string.audio_delay) + "\n" + delay / 1000L + " ms"
+        audioDelay = delay
+        if (!isPlaybackSettingActive) {
+            playbackSetting = IPlaybackSettingsController.DelayState.AUDIO
+            initPlaybackSettingInfo()
+        }
+    }
+
+    private fun delaySubs(delta: Long) {
+        initInfoOverlay()
+        val delay = mService!!.spuDelay + delta
+        mService!!.setSpuDelay(delay)
+        info!!.text = getString(R.string.spu_delay) + "\n" + delay / 1000L + " ms"
+        spuDelay = delay
+        if (!isPlaybackSettingActive) {
+            playbackSetting = IPlaybackSettingsController.DelayState.SUBS
+            initPlaybackSettingInfo()
+        }
+    }
+
+    /**
+     * Lock screen rotation
+     */
+    private fun lockScreen() {
+        if (screenOrientation != 100) {
+            screenOrientationLock = requestedOrientation
+            requestedOrientation = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2)
+                ActivityInfo.SCREEN_ORIENTATION_LOCKED
+            else
+                getScreenOrientation(100)
+        }
+        showInfo(R.string.locked, 1000)
+        if (hudBinding != null) {
+            hudBinding!!.lockOverlayButton.setImageResource(R.drawable.ic_locked_circle)
+            hudBinding!!.playerOverlayTime.isEnabled = false
+            hudBinding!!.playerOverlaySeekbar.isEnabled = false
+            hudBinding!!.playerOverlayLength.isEnabled = false
+            hudBinding!!.playerOverlaySize.isEnabled = false
+            hudBinding!!.playlistNext.isEnabled = false
+            hudBinding!!.playlistPrevious.isEnabled = false
+        }
+        hideOverlay(true)
+        lockBackButton = true
+        isLocked = true
+    }
+
+    /**
+     * Remove screen lock
+     */
+    private fun unlockScreen() {
+        if (screenOrientation != 100)
+            requestedOrientation = screenOrientationLock
+        showInfo(R.string.unlocked, 1000)
+        if (hudBinding != null) {
+            hudBinding!!.lockOverlayButton.setImageResource(R.drawable.ic_lock_circle)
+            hudBinding!!.playerOverlayTime.isEnabled = true
+            hudBinding!!.playerOverlaySeekbar.isEnabled = mService == null || mService!!.isSeekable
+            hudBinding!!.playerOverlayLength.isEnabled = true
+            hudBinding!!.playerOverlaySize.isEnabled = true
+            hudBinding!!.playlistNext.isEnabled = true
+            hudBinding!!.playlistPrevious.isEnabled = true
+        }
+        isShowing = false
+        isLocked = false
+        showOverlay()
+        lockBackButton = false
+    }
+
+    /**
+     * Show text in the info view and vertical progress bar for "duration" milliseconds
+     * @param text
+     * @param duration
+     * @param barNewValue new volume/brightness value (range: 0 - 15)
+     */
+    private fun showInfoWithVerticalBar(text: String, duration: Int, barNewValue: Int, max: Int) {
+        showInfo(text, duration)
+        if (verticalBarProgress == null) return
+        var layoutParams: LinearLayout.LayoutParams
+        if (barNewValue <= 100) {
+            layoutParams = verticalBarProgress!!.layoutParams as LinearLayout.LayoutParams
+            layoutParams.weight = barNewValue * 100 / max.toFloat()
+            verticalBarProgress!!.layoutParams = layoutParams
+            layoutParams = verticalBarBoostProgress!!.layoutParams as LinearLayout.LayoutParams
+            layoutParams.weight = 0f
+            verticalBarBoostProgress!!.layoutParams = layoutParams
+        } else {
+            layoutParams = verticalBarProgress!!.layoutParams as LinearLayout.LayoutParams
+            layoutParams.weight = 100 * 100 / max.toFloat()
+            verticalBarProgress!!.layoutParams = layoutParams
+            layoutParams = verticalBarBoostProgress!!.layoutParams as LinearLayout.LayoutParams
+            layoutParams.weight = (barNewValue - 100) * 100 / max.toFloat()
+            verticalBarBoostProgress!!.layoutParams = layoutParams
+        }
+        verticalBar!!.visibility = View.VISIBLE
+    }
+
+    /**
+     * Show text in the info view for "duration" milliseconds
+     * @param text
+     * @param duration
+     */
+    internal fun showInfo(text: String, duration: Int) {
+        if (isInPictureInPictureMode) return
+        initInfoOverlay()
+        UiTools.setViewVisibility(verticalBar, View.GONE)
+        UiTools.setViewVisibility(overlayInfo, View.VISIBLE)
+        info!!.text = text
+        handler.removeMessages(FADE_OUT_INFO)
+        handler.sendEmptyMessageDelayed(FADE_OUT_INFO, duration.toLong())
+    }
+
+    private fun initInfoOverlay() {
+        val vsc = findViewById<ViewStubCompat>(R.id.player_info_stub)
+        if (vsc != null) {
+            vsc.inflate()
+            // the info textView is not on the overlay
+            info = findViewById(R.id.player_overlay_textinfo)
+            overlayInfo = findViewById(R.id.player_overlay_info)
+            verticalBar = findViewById(R.id.verticalbar)
+            verticalBarProgress = findViewById(R.id.verticalbar_progress)
+            verticalBarBoostProgress = findViewById(R.id.verticalbar_boost_progress)
+        }
+    }
+
+    internal fun showInfo(textid: Int, duration: Int) {
+        showInfo(getString(textid), duration)
+    }
+
+    /**
+     * hide the info view with "delay" milliseconds delay
+     * @param delay
+     */
+    private fun hideInfo(delay: Int = 0) {
+        handler.sendEmptyMessageDelayed(FADE_OUT_INFO, delay.toLong())
+    }
+
+    private fun fadeOutInfo() {
+        if (overlayInfo != null && overlayInfo!!.visibility == View.VISIBLE) {
+            overlayInfo!!.startAnimation(AnimationUtils.loadAnimation(
+                    this@VideoPlayerActivity, android.R.anim.fade_out))
+            UiTools.setViewVisibility(overlayInfo, View.INVISIBLE)
+        }
+    }
+
+    /* PlaybackService.Callback */
+
+    override fun update() {
+        if (mService == null || playlistAdapter == null) return
+        playlistModel!!.update()
+    }
+
+    override fun onMediaEvent(event: Media.Event) {
+        when (event.type) {
+            Media.Event.ParsedChanged -> updateNavStatus()
+            Media.Event.MetaChanged -> {
+            }
+        }
+    }
+
+    override fun onMediaPlayerEvent(event: MediaPlayer.Event) {
+        when (event.type) {
+            MediaPlayer.Event.Playing -> onPlaying()
+            MediaPlayer.Event.Paused -> updateOverlayPausePlay()
+            MediaPlayer.Event.Vout -> {
+                updateNavStatus()
+                if (event.voutCount > 0 && mService != null)
+                    mService!!.mediaplayer.updateVideoSurfaces()
+                if (menuIdx == -1)
+                    handleVout(event.voutCount)
+            }
+            MediaPlayer.Event.ESAdded -> {
+                if (mService != null && menuIdx == -1) {
+                    val media = medialibrary!!.findMedia(mService!!.currentMediaWrapper) ?: return
+                    if (event.esChangedType == Media.Track.Type.Audio) {
+                        setESTrackLists()
+                        runIO(Runnable {
+                            val audioTrack = media.getMetaLong(MediaWrapper.META_AUDIOTRACK).toInt()
+                            if (audioTrack != 0 || currentAudioTrack != -2)
+                                mService!!.setAudioTrack(if (media.id == 0L) currentAudioTrack else audioTrack)
+                        })
+                    } else if (event.esChangedType == Media.Track.Type.Text) {
+                        setESTrackLists()
+                        runIO(Runnable {
+                            val spuTrack = media.getMetaLong(MediaWrapper.META_SUBTITLE_TRACK).toInt()
+                            if (addNextTrack) {
+                                val tracks = mService!!.spuTracks
+                                if (!Util.isArrayEmpty<MediaPlayer.TrackDescription>(tracks)) mService!!.setSpuTrack(tracks!![tracks.size - 1].id)
+                                addNextTrack = false
+                            } else if (spuTrack != 0 || currentSpuTrack != -2) {
+                                mService!!.setSpuTrack(if (media.id == 0L) currentSpuTrack else spuTrack)
+                            }
+                        })
+                    }
+                }
+                if (mService != null && menuIdx == -1 && event.esChangedType == Media.Track.Type.Video) {
+                    handler.removeMessages(CHECK_VIDEO_TRACKS)
+                    handler.sendEmptyMessageDelayed(CHECK_VIDEO_TRACKS, 1000)
+                }
+                invalidateESTracks(event.esChangedType)
+            }
+            MediaPlayer.Event.ESDeleted -> {
+                if (mService != null && menuIdx == -1 && event.esChangedType == Media.Track.Type.Video) {
+                    handler.removeMessages(CHECK_VIDEO_TRACKS)
+                    handler.sendEmptyMessageDelayed(CHECK_VIDEO_TRACKS, 1000)
+                }
+                invalidateESTracks(event.esChangedType)
+            }
+            MediaPlayer.Event.ESSelected -> if (mService != null && event.esChangedType == Media.Track.Type.Video) {
+                val vt = mService!!.currentVideoTrack
+                if (vt != null)
+                    fov = if (vt.projection == Media.VideoTrack.Projection.Rectangular) 0f else DEFAULT_FOV
+            }
+            MediaPlayer.Event.SeekableChanged -> updateSeekable(event.seekable)
+            MediaPlayer.Event.PausableChanged -> updatePausable(event.pausable)
+            MediaPlayer.Event.Buffering -> {
+                if (isPlaying) {
+                    if (event.buffering == 100f)
+                        stopLoading()
+                    else if (!handler.hasMessages(LOADING_ANIMATION) && !isLoading
+                            && (touchDelegate == null || !touchDelegate!!.isSeeking()) && !isDragging)
+                        handler.sendEmptyMessageDelayed(LOADING_ANIMATION, LOADING_ANIMATION_DELAY.toLong())
+                }
+            }
+        }
+    }
+
+    private fun onPlaying() {
+        val service = mService ?: return
+        isPlaying = true
+        val mw = service.currentMediaWrapper ?: return
+        setPlaybackParameters()
+        stopLoading()
+        updateOverlayPausePlay()
+        updateNavStatus()
+        if (!mw.hasFlag(MediaWrapper.MEDIA_PAUSED))
+            handler.sendEmptyMessageDelayed(FADE_OUT, OVERLAY_TIMEOUT.toLong())
+        else {
+            mw.removeFlags(MediaWrapper.MEDIA_PAUSED)
+            wasPaused = false
+        }
+        setESTracks()
+        if (titleTextView != null && titleTextView!!.length() == 0)
+            titleTextView!!.text = mw.title
+        // Get possible subtitles
+        observeDownloadedSubtitles()
+        if (optionsDelegate != null) optionsDelegate!!.setup()
+        settings!!.edit().remove(PreferencesActivity.VIDEO_PAUSED).apply()
+    }
+
+    private fun encounteredError() {
+        if (isFinishing || mService!!.hasNext()) return
+        /* Encountered Error, exit player with a message */
+        alertDialog = AlertDialog.Builder(this@VideoPlayerActivity)
+                .setOnCancelListener { exit(RESULT_PLAYBACK_ERROR) }
+                .setPositiveButton(R.string.ok) { _, _ -> exit(RESULT_PLAYBACK_ERROR) }
+                .setTitle(R.string.encountered_error_title)
+                .setMessage(R.string.encountered_error_message)
+                .create()
+        alertDialog!!.show()
+    }
+
+    private fun handleVout(voutCount: Int) {
+        handler.removeCallbacks(switchAudioRunnable)
+
+        val vlcVout = (if (mService != null) mService!!.vout else null) ?: return
+        if (displayManager.isPrimary && vlcVout.areViewsAttached() && voutCount == 0) {
+            handler.postDelayed(switchAudioRunnable, 4000)
+        }
+    }
+
+    override fun recreate() {
+        handler.removeCallbacks(switchAudioRunnable)
+        super.recreate()
+    }
+
+    fun switchToAudioMode(showUI: Boolean) {
+        if (mService == null) return
+        switchingView = true
+        // Show the MainActivity if it is not in background.
+        if (showUI) {
+            val i = Intent(this, if (isTv) AudioPlayerActivity::class.java else MainActivity::class.java)
+            startActivity(i)
+        }
+        exitOK()
+    }
+
+    override fun isInPictureInPictureMode(): Boolean {
+        return AndroidUtil.isNougatOrLater && super.isInPictureInPictureMode()
+    }
+
+    override fun onPictureInPictureModeChanged(isInPictureInPictureMode: Boolean) {
+        super.onPictureInPictureModeChanged(isInPictureInPictureMode)
+        if (mService != null) mService!!.mediaplayer.updateVideoSurfaces()
+    }
+
+    internal fun sendMouseEvent(action: Int, x: Int, y: Int) {
+        if (mService == null) return
+        val vlcVout = mService!!.vout
+        vlcVout!!.sendMouseEvent(action, 0, x, y)
+    }
+
+    /**
+     * show/hide the overlay
+     */
+
+    override fun onTouchEvent(event: MotionEvent): Boolean {
+        return mService != null && touchDelegate != null && touchDelegate!!.onTouchEvent(event)
+    }
+
+    internal fun updateViewpoint(yaw: Float, pitch: Float, fov: Float): Boolean {
+        return mService!!.updateViewpoint(yaw, pitch, 0f, fov, false)
+    }
+
+    internal fun initAudioVolume() {
+        if (mService!!.volume <= 100) {
+            volume = audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC).toFloat()
+            originalVol = audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC).toFloat()
+        } else {
+            volume = mService!!.volume.toFloat() * audioMax / 100
+        }
+    }
+
+    fun toggleOverlay() {
+        if (!isShowing)
+            showOverlay()
+        else
+            hideOverlay(true)
+    }
+
+    //Toast that appears only once
+    fun displayWarningToast() {
+        if (warningToast != null) warningToast!!.cancel()
+        warningToast = Toast.makeText(application, R.string.audio_boost_warning, Toast.LENGTH_SHORT)
+        warningToast!!.show()
+    }
+
+    internal fun setAudioVolume(vol: Int) {
+        var vol = vol
+        if (AndroidUtil.isNougatOrLater && (vol <= 0) xor isMute) {
+            mute(!isMute)
+            return  //Android N+ throws "SecurityException: Not allowed to change Do Not Disturb state"
+        }
+
+        /* Since android 4.3, the safe volume warning dialog is displayed only with the FLAG_SHOW_UI flag.
+         * We don't want to always show the default UI volume, so show it only when volume is not set. */
+        if (vol <= audioMax) {
+            mService!!.setVolume(100)
+            if (vol != audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC)) {
+                try {
+                    audiomanager!!.setStreamVolume(AudioManager.STREAM_MUSIC, vol, 0)
+                    // High Volume warning can block volume setting
+                    if (audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC) != vol)
+                        audiomanager!!.setStreamVolume(AudioManager.STREAM_MUSIC, vol, AudioManager.FLAG_SHOW_UI)
+                } catch (ignored: RuntimeException) {
+                }
+                //Some device won't allow us to change volume
+            }
+            vol = Math.round(vol * 100 / audioMax.toFloat())
+        } else {
+            vol = Math.round(vol * 100 / audioMax.toFloat())
+            mService!!.setVolume(Math.round(vol.toFloat()))
+        }
+        showInfoWithVerticalBar(getString(R.string.volume) + "\n" + Integer.toString(vol) + '%'.toString(), 1000, vol, if (isAudioBoostEnabled) 200 else 100)
+    }
+
+    private fun mute(mute: Boolean) {
+        isMute = mute
+        if (isMute)
+            volSave = mService!!.volume
+        mService!!.setVolume(if (isMute) 0 else volSave)
+    }
+
+    private fun updateMute() {
+        mute(!isMute)
+        showInfo(if (isMute) R.string.sound_off else R.string.sound_on, 1000)
+    }
+
+    internal fun changeBrightness(delta: Float) {
+        // Estimate and adjust Brightness
+        val lp = window.attributes
+        var brightness = Math.min(Math.max(lp.screenBrightness + delta, 0.01f), 1f)
+        setWindowBrightness(brightness)
+        brightness = Math.round(brightness * 100).toFloat()
+        showInfoWithVerticalBar(getString(R.string.brightness) + "\n" + brightness.toInt() + '%'.toString(), 1000, brightness.toInt(), 100)
+    }
+
+    private fun setWindowBrightness(brightness: Float) {
+        val lp = window.attributes
+        lp.screenBrightness = brightness
+        // Set Brightness
+        window.attributes = lp
+    }
+
+    open fun onAudioSubClick(anchor: View?) {
+        var flags = 0
+        if (enableSubs) {
+            flags = flags or CTX_DOWNLOAD_SUBTITLES_PLAYER
+            if (displayManager.isPrimary) flags = flags or CTX_PICK_SUBS
+        }
+        if (mService!!.videoTracksCount > 2) flags = flags or CTX_VIDEO_TRACK
+        if (mService!!.audioTracksCount > 0) flags = flags or CTX_AUDIO_TRACK
+        if (mService!!.spuTracksCount > 0) flags = flags or CTX_SUBS_TRACK
+
+        if (optionsDelegate == null) optionsDelegate = PlayerOptionsDelegate(this, mService!!)
+        optionsDelegate!!.flags = flags
+        optionsDelegate!!.show(PlayerOptionType.MEDIA_TRACKS)
+        hideOverlay(false)
+    }
+
+
+    override fun onPopupMenu(view: View, position: Int, item: MediaWrapper?) {
+        val popupMenu = PopupMenu(this, view)
+        popupMenu.menuInflater.inflate(R.menu.audio_player, popupMenu.menu)
+
+        popupMenu.setOnMenuItemClickListener(PopupMenu.OnMenuItemClickListener { item ->
+            if (item.itemId == R.id.audio_player_mini_remove) {
+                if (mService != null) {
+                    playlistAdapter!!.remove(position)
+                    mService!!.remove(position)
+                    return@OnMenuItemClickListener true
+                }
+            }
+            false
+        })
+        popupMenu.show()
+    }
+
+    override fun onSelectionSet(position: Int) {
+        playlist!!.scrollToPosition(position)
+    }
+
+    override fun playItem(position: Int, item: MediaWrapper) {
+        mService!!.playIndex(position)
+    }
+
+    override fun onClick(v: View) {
+        when (v.id) {
+            R.id.orientation_toggle -> toggleOrientation()
+            R.id.playlist_toggle -> togglePlaylist()
+            R.id.player_overlay_forward -> seekDelta(10000)
+            R.id.player_overlay_rewind -> seekDelta(-10000)
+            R.id.player_overlay_navmenu -> showNavMenu()
+            R.id.player_overlay_length, R.id.player_overlay_time -> toggleTimeDisplay()
+            R.id.player_delay_minus -> if (playbackSetting == IPlaybackSettingsController.DelayState.AUDIO)
+                delayAudio(-50000)
+            else if (playbackSetting == IPlaybackSettingsController.DelayState.SUBS)
+                delaySubs(-50000)
+            R.id.player_delay_plus -> if (playbackSetting == IPlaybackSettingsController.DelayState.AUDIO)
+                delayAudio(50000)
+            else if (playbackSetting == IPlaybackSettingsController.DelayState.SUBS)
+                delaySubs(50000)
+            R.id.video_renderer -> if (supportFragmentManager.findFragmentByTag("renderers") == null)
+                RenderersDialog().show(supportFragmentManager, "renderers")
+            R.id.video_secondary_display -> {
+                clone = displayManager.isSecondary
+                recreate()
+            }
+        }
+    }
+
+    override fun onLongClick(v: View): Boolean {
+        when (v.id) {
+            R.id.orientation_toggle -> return resetOrientation()
+        }
+
+        return false
+    }
+
+    fun toggleTimeDisplay() {
+        sDisplayRemainingTime = !sDisplayRemainingTime
+        showOverlay()
+        settings!!.edit().putBoolean(KEY_REMAINING_TIME_DISPLAY, sDisplayRemainingTime).apply()
+    }
+
+    fun toggleLock() {
+        if (isLocked)
+            unlockScreen()
+        else
+            lockScreen()
+    }
+
+    fun toggleLoop(v: View): Boolean {
+        if (mService == null) return false
+        if (mService!!.repeatType == REPEAT_ONE) {
+            showInfo(getString(R.string.repeat), 1000)
+            mService!!.repeatType = REPEAT_NONE
+        } else {
+            mService!!.repeatType = REPEAT_ONE
+            showInfo(getString(R.string.repeat_single), 1000)
+        }
+        return true
+    }
+
+    override fun onStorageAccessGranted() {
+        handler.sendEmptyMessage(START_PLAYBACK)
+    }
+
+    fun hideOptions() {
+        if (optionsDelegate != null) optionsDelegate!!.hide()
+    }
+
+
+    private interface TrackSelectedListener {
+        fun onTrackSelected(trackID: Int)
+    }
+
+    private fun selectTrack(tracks: Array<MediaPlayer.TrackDescription>?, currentTrack: Int, titleId: Int,
+                            listener: TrackSelectedListener?) {
+        if (listener == null)
+            throw IllegalArgumentException("listener must not be null")
+        if (tracks == null)
+            return
+        val nameList = arrayOfNulls<String>(tracks.size)
+        val idList = IntArray(tracks.size)
+        var listPosition = 0
+        for ((i, track) in tracks.withIndex()) {
+            idList[i] = track.id
+            nameList[i] = track.name
+            // map the track position to the list position
+            if (track.id == currentTrack) listPosition = i
+        }
+
+        if (!isFinishing) {
+            alertDialog = AlertDialog.Builder(this@VideoPlayerActivity)
+                    .setTitle(titleId)
+                    .setSingleChoiceItems(nameList, listPosition) { dialog, listPosition ->
+                        var trackID = -1
+                        // Reverse map search...
+                        for (track in tracks) {
+                            if (idList[listPosition] == track.id) {
+                                trackID = track.id
+                                break
+                            }
+                        }
+                        listener.onTrackSelected(trackID)
+                        dialog.dismiss()
+                    }
+                    .create()
+            alertDialog!!.setCanceledOnTouchOutside(true)
+            alertDialog!!.ownerActivity = this@VideoPlayerActivity
+            alertDialog!!.show()
+        }
+    }
+
+    fun selectVideoTrack() {
+        setESTrackLists()
+        selectTrack(videoTracksList, mService!!.videoTrack, R.string.track_video,
+                object : TrackSelectedListener {
+                    override fun onTrackSelected(trackID: Int) {
+                        if (trackID < -1 || mService == null) return
+                        mService!!.setVideoTrack(trackID)
+                        seek(mService!!.time)
+                    }
+                })
+    }
+
+    fun selectAudioTrack() {
+        setESTrackLists()
+        selectTrack(audioTracksList, mService!!.audioTrack, R.string.track_audio,
+                object : TrackSelectedListener {
+                    override fun onTrackSelected(trackID: Int) {
+                        if (trackID < -1 || mService == null) return
+                        mService!!.setAudioTrack(trackID)
+                        runIO(Runnable {
+                            val mw = medialibrary!!.findMedia(mService!!.currentMediaWrapper)
+                            if (mw != null && mw.id != 0L) mw.setLongMeta(MediaWrapper.META_AUDIOTRACK, trackID.toLong())
+                        })
+                    }
+                })
+    }
+
+    fun selectSubtitles() {
+        setESTrackLists()
+        selectTrack(subtitleTracksList, mService!!.spuTrack, R.string.track_text,
+                object : TrackSelectedListener {
+                    override fun onTrackSelected(trackID: Int) {
+                        if (trackID < -1 || mService == null) return
+                        runIO(Runnable { setSpuTrack(trackID) })
+                    }
+                })
+    }
+
+    fun pickSubtitles() {
+        if (videoUri == null) return
+        isShowingDialog = true
+        val filePickerIntent = Intent(this, FilePickerActivity::class.java)
+        filePickerIntent.data = Uri.parse(FileUtils.getParent(videoUri!!.toString()))
+        startActivityForResult(filePickerIntent, 0)
+    }
+
+
+    fun downloadSubtitles() {
+        val mw = if (mService != null) mService!!.currentMediaWrapper else null
+        if (mw != null) MediaUtils.getSubs(this@VideoPlayerActivity, mw)
+    }
+
+
+    @WorkerThread
+    private fun setSpuTrack(trackID: Int) {
+        runOnMainThread(Runnable { mService!!.setSpuTrack(trackID) })
+        val mw = medialibrary!!.findMedia(mService!!.currentMediaWrapper)
+        if (mw != null && mw.id != 0L)
+            mw.setLongMeta(MediaWrapper.META_SUBTITLE_TRACK, trackID.toLong())
+    }
+
+    private fun showNavMenu() {
+        if (menuIdx >= 0)
+            mService!!.titleIdx = menuIdx
+    }
+
+    private fun updateSeekable(seekable: Boolean) {
+        if (hudBinding == null) return
+        hudBinding!!.playerOverlayRewind.isEnabled = seekable
+        hudBinding!!.playerOverlayRewind.setImageResource(if (seekable)
+            R.drawable.ic_rewind_circle
+        else
+            R.drawable.ic_rewind_circle_disable_o)
+        hudBinding!!.playerOverlayForward.isEnabled = seekable
+        hudBinding!!.playerOverlayForward.setImageResource(if (seekable)
+            R.drawable.ic_forward_circle
+        else
+            R.drawable.ic_forward_circle_disable_o)
+        if (!isLocked)
+            hudBinding!!.playerOverlaySeekbar.isEnabled = seekable
+    }
+
+    private fun updatePausable(pausable: Boolean) {
+        if (hudBinding == null) return
+        hudBinding!!.playerOverlayPlay.isEnabled = pausable
+        if (!pausable)
+            hudBinding!!.playerOverlayPlay.setImageResource(R.drawable.ic_play_circle_disable_o)
+    }
+
+    fun doPlayPause() {
+        if (mService == null || !mService!!.isPausable) return
+        if (mService!!.isPlaying) {
+            showOverlayTimeout(OVERLAY_INFINITE)
+            pause()
+        } else {
+            hideOverlay(true)
+            play()
+        }
+    }
+
+    protected fun seek(position: Long) {
+        seek(position, mService!!.length)
+    }
+
+    internal fun seek(position: Long, length: Long) {
+        forcedTime = position
+        lastTime = mService!!.time
+        mService!!.seek(position, length.toDouble())
+        mService!!.playlistManager.player.updateProgress(position)
+    }
+
+    internal fun seekDelta(delta: Int) {
+        // unseekable stream
+        if (mService!!.length <= 0 || !mService!!.isSeekable) return
+
+        var position = time + delta
+        if (position < 0) position = 0
+        seek(position)
+        val sb = StringBuilder()
+        if (delta > 0f)
+            sb.append('+')
+        sb.append((delta / 1000f).toInt())
+                .append("s (")
+                .append(Tools.millisToString(mService!!.time))
+                .append(')')
+        showInfo(sb.toString(), 1000)
+    }
+
+    @SuppressLint("ClickableViewAccessibility")
+    private fun initSeekButton() {
+        if (hudBinding == null) return
+        hudBinding!!.playerOverlayRewind.setOnClickListener(this)
+        hudBinding!!.playerOverlayForward.setOnClickListener(this)
+        hudBinding!!.playerOverlayRewind.setOnTouchListener(OnRepeatListener(this))
+        hudBinding!!.playerOverlayForward.setOnTouchListener(OnRepeatListener(this))
+    }
+
+    fun resizeVideo() {
+        val next = (mService!!.mediaplayer.videoScale.ordinal + 1) % MediaPlayer.SURFACE_SCALES_COUNT
+        val scale = MediaPlayer.ScaleType.values()[next]
+        setVideoScale(scale)
+    }
+
+    internal fun setVideoScale(scale: MediaPlayer.ScaleType) {
+        mService!!.mediaplayer.videoScale = scale
+        val newSize = mService!!.mediaplayer.videoScale
+        when (newSize) {
+            MediaPlayer.ScaleType.SURFACE_BEST_FIT -> showInfo(R.string.surface_best_fit, 1000)
+            MediaPlayer.ScaleType.SURFACE_FIT_SCREEN -> showInfo(R.string.surface_fit_screen, 1000)
+            MediaPlayer.ScaleType.SURFACE_FILL -> showInfo(R.string.surface_fill, 1000)
+            MediaPlayer.ScaleType.SURFACE_16_9 -> showInfo("16:9", 1000)
+            MediaPlayer.ScaleType.SURFACE_4_3 -> showInfo("4:3", 1000)
+            MediaPlayer.ScaleType.SURFACE_ORIGINAL -> showInfo(R.string.surface_original, 1000)
+        }
+        settings!!.edit()
+                .putInt(PreferencesActivity.VIDEO_RATIO, newSize.ordinal)
+                .apply()
+    }
+
+    /**
+     * show overlay
+     * @param forceCheck: adjust the timeout in function of playing state
+     */
+    private fun showOverlay(forceCheck: Boolean = false) {
+        if (forceCheck)
+            overlayTimeout = 0
+        showOverlayTimeout(0)
+    }
+
+    /**
+     * show overlay
+     */
+    private fun showOverlayTimeout(timeout: Int) {
+        if (mService == null) return
+        if (isInPictureInPictureMode) return
+        initOverlay()
+        if (hudBinding == null) return
+        overlayTimeout = when {
+            timeout != 0 -> timeout
+            mService!!.isPlaying -> OVERLAY_TIMEOUT
+            else -> OVERLAY_INFINITE
+        }
+        if (isNavMenu) {
+            isShowing = true
+            return
+        }
+        if (!isShowing) {
+            isShowing = true
+            if (!isLocked) {
+                showControls(true)
+            }
+            dimStatusBar(false)
+            if (hudBinding != null) hudBinding!!.progressOverlay.visibility = View.VISIBLE
+            if (!displayManager.isPrimary)
+                overlayBackground!!.visibility = View.VISIBLE
+            updateOverlayPausePlay()
+        }
+        handler.removeMessages(FADE_OUT)
+        if (overlayTimeout != OVERLAY_INFINITE)
+            handler.sendMessageDelayed(handler.obtainMessage(FADE_OUT), overlayTimeout.toLong())
+    }
+
+    private fun showControls(show: Boolean) {
+        if (show && isInPictureInPictureMode) return
+        if (hudBinding != null) {
+            hudBinding!!.playerOverlayPlay.visibility = if (show) View.VISIBLE else View.INVISIBLE
+            if (seekButtons) {
+                hudBinding!!.playerOverlayRewind.visibility = if (show) View.VISIBLE else View.INVISIBLE
+                hudBinding!!.playerOverlayForward.visibility = if (show) View.VISIBLE else View.INVISIBLE
+            }
+            if (displayManager.isPrimary) hudBinding!!.playerOverlaySize.visibility = if (show) View.VISIBLE else View.INVISIBLE
+            hudBinding!!.playerOverlayTracks.visibility = if (show) View.VISIBLE else View.INVISIBLE
+            hudBinding!!.playerOverlayAdvFunction.visibility = if (show) View.VISIBLE else View.INVISIBLE
+            if (hasPlaylist) {
+                hudBinding!!.playlistPrevious.visibility = if (show) View.VISIBLE else View.INVISIBLE
+                hudBinding!!.playlistNext.visibility = if (show) View.VISIBLE else View.INVISIBLE
+            }
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
+    private fun initOverlay() {
+        val vsc = findViewById<ViewStubCompat>(R.id.player_hud_stub)
+        if (vsc != null) {
+            seekButtons = settings!!.getBoolean("enable_seek_buttons", false)
+            vsc.inflate()
+            hudBinding = DataBindingUtil.bind(findViewById(R.id.progress_overlay))
+            hudBinding!!.player = this
+            hudBinding!!.progress = mService!!.playlistManager.player.progress
+            hudBinding!!.lifecycleOwner = this
+            val layoutParams = hudBinding!!.progressOverlay.layoutParams as RelativeLayout.LayoutParams
+            if (AndroidDevices.isPhone || !AndroidDevices.hasNavBar)
+                layoutParams.width = LayoutParams.MATCH_PARENT
+            else
+                layoutParams.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE)
+            hudBinding!!.progressOverlay.layoutParams = layoutParams
+            overlayBackground = findViewById(R.id.player_overlay_background)
+            navMenu = findViewById(R.id.player_overlay_navmenu)
+            if (!AndroidDevices.isChromeBook && !isTv
+                    && Settings.getInstance(this).getBoolean("enable_casting", true)) {
+                rendererBtn = findViewById(R.id.video_renderer)
+                PlaybackService.renderer.observe(this, Observer { rendererItem -> if (rendererBtn != null) rendererBtn!!.setImageResource(if (rendererItem == null) R.drawable.ic_renderer_circle else R.drawable.ic_renderer_on_circle) })
+                RendererDelegate.renderers.observe(this, Observer<List<RendererItem>> { rendererItems -> UiTools.setViewVisibility(rendererBtn, if (Util.isListEmpty(rendererItems)) View.GONE else View.VISIBLE) })
+            }
+            if (seekButtons) initSeekButton()
+            resetHudLayout()
+            updateOverlayPausePlay()
+            updateSeekable(mService!!.isSeekable)
+            updatePausable(mService!!.isPausable)
+            updateNavStatus()
+            setListeners(true)
+            initPlaylistUi()
+            if (!displayManager.isPrimary) {
+                hudBinding!!.lockOverlayButton.visibility = View.GONE
+                hudBinding!!.playerOverlaySize.visibility = View.GONE
+            }
+
+            if (!isTv && !AndroidDevices.isChromeBook)
+                orientationToggle!!.visibility = View.VISIBLE
+        } else if (mService != null && hudBinding != null) {
+            hudBinding!!.progress = mService!!.playlistManager.player.progress
+            hudBinding!!.lifecycleOwner = this
+        }
+    }
+
+
+    /**
+     * hider overlay
+     */
+    internal fun hideOverlay(fromUser: Boolean) {
+        if (isShowing) {
+            handler.removeMessages(FADE_OUT)
+            Log.i(TAG, "remove View!")
+            UiTools.setViewVisibility(overlayTips, View.INVISIBLE)
+            if (!displayManager.isPrimary) {
+                overlayBackground!!.startAnimation(AnimationUtils.loadAnimation(this, android.R.anim.fade_out))
+                overlayBackground!!.visibility = View.INVISIBLE
+            }
+            if (hudBinding != null) hudBinding!!.progressOverlay.visibility = View.INVISIBLE
+            showControls(false)
+            isShowing = false
+            dimStatusBar(true)
+        } else if (!fromUser) {
+            /*
+             * Try to hide the Nav Bar again.
+             * It seems that you can't hide the Nav Bar if you previously
+             * showed it in the last 1-2 seconds.
+             */
+            dimStatusBar(true)
+        }
+    }
+
+    /**
+     * Dim the status bar and/or navigation icons when needed on Android 3.x.
+     * Hide it on Android 4.0 and later
+     */
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private fun dimStatusBar(dim: Boolean) {
+        if (isNavMenu) return
+        if (dim || isLocked)
+            actionBar!!.hide()
+        else
+            actionBar!!.show()
+
+        var visibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+        var navbar = 0
+        if (dim || isLocked) {
+            window.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)
+            navbar = navbar or (View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_LOW_PROFILE or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION)
+            if (AndroidUtil.isKitKatOrLater) visibility = visibility or View.SYSTEM_UI_FLAG_IMMERSIVE
+            visibility = visibility or View.SYSTEM_UI_FLAG_FULLSCREEN
+        } else {
+            actionBar!!.show()
+            window.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)
+            visibility = visibility or View.SYSTEM_UI_FLAG_VISIBLE
+        }
+
+        if (AndroidDevices.hasNavBar)
+            visibility = visibility or navbar
+        window.decorView.systemUiVisibility = visibility
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    private fun showTitle() {
+        if (isNavMenu) return
+        actionBar!!.show()
+
+        var visibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+        var navbar = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+        navbar = navbar or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
+
+        if (AndroidDevices.hasNavBar) visibility = visibility or navbar
+        window.decorView.systemUiVisibility = visibility
+
+    }
+
+    private fun updateOverlayPausePlay() {
+        if (mService == null || hudBinding == null) return
+        if (mService!!.isPausable)
+            hudBinding!!.playerOverlayPlay.setImageResource(if (mService!!.isPlaying)
+                R.drawable.ic_pause_circle
+            else
+                R.drawable.ic_play_circle)
+        hudBinding!!.playerOverlayPlay.requestFocus()
+    }
+
+    private fun invalidateESTracks(type: Int) {
+        when (type) {
+            Media.Track.Type.Audio -> audioTracksList = null
+            Media.Track.Type.Text -> subtitleTracksList = null
+        }
+    }
+
+    private fun setESTracks() {
+        if (lastAudioTrack >= -1) {
+            mService!!.setAudioTrack(lastAudioTrack)
+            lastAudioTrack = -2
+        }
+        if (lastSpuTrack >= -1) {
+            mService!!.setSpuTrack(lastSpuTrack)
+            lastSpuTrack = -2
+        }
+    }
+
+    private fun setESTrackLists() {
+        if (audioTracksList == null && mService!!.audioTracksCount > 0)
+            audioTracksList = mService!!.audioTracks as Array<MediaPlayer.TrackDescription>?
+        if (subtitleTracksList == null && mService!!.spuTracksCount > 0)
+            subtitleTracksList = mService!!.spuTracks as Array<MediaPlayer.TrackDescription>?
+        if (videoTracksList == null && mService!!.videoTracksCount > 0)
+            videoTracksList = mService!!.videoTracks as Array<MediaPlayer.TrackDescription>?
+    }
+
+
+    /**
+     *
+     */
+    private fun play() {
+        mService!!.play()
+        if (rootView != null)
+            rootView!!.keepScreenOn = true
+    }
+
+    /**
+     *
+     */
+    private fun pause() {
+        mService!!.pause()
+        if (rootView != null)
+            rootView!!.keepScreenOn = false
+    }
+
+    operator fun next() {
+        if (mService != null) mService!!.next()
+    }
+
+    fun previous() {
+        if (mService != null) mService!!.previous(false)
+    }
+
+    /*
+     * Additionnal method to prevent alert dialog to pop up
+     */
+    private fun loadMedia(fromStart: Boolean) {
+        askResume = false
+        intent.putExtra(PLAY_EXTRA_FROM_START, fromStart)
+        loadMedia()
+    }
+
+    /**
+     * External extras:
+     * - position (long) - position of the video to start with (in ms)
+     * - subtitles_location (String) - location of a subtitles file to load
+     * - from_start (boolean) - Whether playback should start from start or from resume point
+     * - title (String) - video title, will be guessed from file if not set.
+     */
+    @SuppressLint("SdCardPath")
+    @TargetApi(12)
+    protected open fun loadMedia() {
+        if (mService == null) return
+        isPlaying = false
+        var title: String? = null
+        var fromStart = false
+        var itemTitle: String? = null
+        var positionInPlaylist = -1
+        val intent = intent
+        val extras = intent.extras
+        var savedTime = 0L
+        val currentMedia = mService!!.currentMediaWrapper
+        val hasMedia = currentMedia != null
+        val isPlaying = mService!!.isPlaying
+        /*
+         * If the activity has been paused by pressing the power button, then
+         * pressing it again will show the lock screen.
+         * But onResume will also be called, even if vlc-android is still in
+         * the background.
+         * To workaround this, pause playback if the lockscreen is displayed.
+         */
+        val km = applicationContext.getSystemService(Context.KEYGUARD_SERVICE) as KeyguardManager
+        if (km.inKeyguardRestrictedInputMode())
+            wasPaused = true
+        if (wasPaused && BuildConfig.DEBUG)
+            Log.d(TAG, "Video was previously paused, resuming in paused mode")
+        if (intent.data != null) videoUri = intent.data
+        if (extras != null) {
+            if (intent.hasExtra(PLAY_EXTRA_ITEM_LOCATION))
+                videoUri = extras.getParcelable(PLAY_EXTRA_ITEM_LOCATION)
+            fromStart = extras.getBoolean(PLAY_EXTRA_FROM_START, false)
+            // Consume fromStart option after first use to prevent
+            // restarting again when playback is paused.
+            intent.putExtra(PLAY_EXTRA_FROM_START, false)
+            askResume = askResume and !fromStart
+            savedTime = if (fromStart) 0L else extras.getLong(PLAY_EXTRA_START_TIME) // position passed in by intent (ms)
+            if (!fromStart && savedTime == 0L) {
+                savedTime = extras.getInt(PLAY_EXTRA_START_TIME).toLong()
+            }
+            positionInPlaylist = extras.getInt(PLAY_EXTRA_OPENED_POSITION, -1)
+
+            val path = extras.getString(PLAY_EXTRA_SUBTITLES_LOCATION)
+            if (!TextUtils.isEmpty(path)) mService!!.addSubtitleTrack(path!!, true)
+            if (intent.hasExtra(PLAY_EXTRA_ITEM_TITLE))
+                itemTitle = extras.getString(PLAY_EXTRA_ITEM_TITLE)
+        }
+        if (savedTime == 0L && mSavedTime > 0L) savedTime = mSavedTime
+        val restorePlayback = hasMedia && currentMedia!!.uri == videoUri
+
+        var openedMedia: MediaWrapper? = null
+        val resumePlaylist = mService!!.isValidIndex(positionInPlaylist)
+        val continueplayback = isPlaying && (restorePlayback || positionInPlaylist == mService!!.currentMediaPosition)
+        if (resumePlaylist) {
+            // Provided externally from AudioService
+            if (BuildConfig.DEBUG) Log.d(TAG, "Continuing playback from PlaybackService at index $positionInPlaylist")
+            openedMedia = mService!!.medias[positionInPlaylist]
+//            if (openedMedia == null) {
+//                encounteredError()
+//                return
+//            }
+            itemTitle = openedMedia.title
+            updateSeekable(mService!!.isSeekable)
+            updatePausable(mService!!.isPausable)
+        }
+        if (videoUri != null) {
+            var media: MediaWrapper? = null
+            if (!continueplayback) {
+                if (!resumePlaylist) {
+                    // restore last position
+                    media = medialibrary!!.getMedia(videoUri!!)
+                    if (media == null && TextUtils.equals(videoUri!!.scheme, "file") &&
+                            videoUri!!.path != null && videoUri!!.path!!.startsWith("/sdcard")) {
+                        videoUri = FileUtils.convertLocalUri(videoUri!!)
+                        media = medialibrary!!.getMedia(videoUri!!)
+                    }
+                    if (media != null && media.id != 0L && media.time == 0L)
+                        media.time = media.getMetaLong(MediaWrapper.META_PROGRESS)
+                } else
+                    media = openedMedia
+                if (media != null) {
+                    // in media library
+                    if (askResume && !fromStart && positionInPlaylist <= 0 && media.time > 0) {
+                        showConfirmResumeDialog()
+                        return
+                    }
+
+                    lastAudioTrack = media.audioTrack
+                    lastSpuTrack = media.spuTrack
+                } else if (!fromStart) {
+                    // not in media library
+                    if (askResume && savedTime > 0L) {
+                        showConfirmResumeDialog()
+                        return
+                    } else {
+                        val rTime = settings!!.getLong(PreferencesActivity.VIDEO_RESUME_TIME, -1)
+                        if (rTime > 0) {
+                            if (askResume) {
+                                showConfirmResumeDialog()
+                                return
+                            } else {
+                                settings!!.edit()
+                                        .putLong(PreferencesActivity.VIDEO_RESUME_TIME, -1)
+                                        .apply()
+                                savedTime = rTime
+                            }
+                        }
+                    }
+                }
+            }
+
+            // Start playback & seek
+            /* prepare playback */
+            val medialoaded = media != null
+            if (!medialoaded) media = if (hasMedia) currentMedia else MediaWrapper(videoUri!!)
+            if (wasPaused)
+                media!!.addFlags(MediaWrapper.MEDIA_PAUSED)
+            if (intent.hasExtra(PLAY_DISABLE_HARDWARE))
+                media!!.addFlags(MediaWrapper.MEDIA_NO_HWACCEL)
+            media!!.removeFlags(MediaWrapper.MEDIA_FORCE_AUDIO)
+            media.addFlags(MediaWrapper.MEDIA_VIDEO)
+            if (fromStart) media.addFlags(MediaWrapper.MEDIA_FROM_START)
+
+            // Set resume point
+            if (!continueplayback && !fromStart) {
+                if (savedTime <= 0L && media.time > 0L) savedTime = media.time
+                if (savedTime > 0L) mService!!.saveStartTime(savedTime)
+            }
+
+            // Handle playback
+            if (resumePlaylist) {
+                if (continueplayback) {
+                    if (displayManager.isPrimary) mService!!.flush()
+                    onPlaying()
+                } else
+                    mService!!.playIndex(positionInPlaylist)
+            } else if (medialoaded)
+                mService!!.load(media)
+            else
+                mService!!.loadUri(videoUri)
+
+            // Get the title
+            if (itemTitle == null && !TextUtils.equals(videoUri!!.scheme, "content"))
+                title = videoUri!!.lastPathSegment
+        } else if (mService!!.hasMedia() && !displayManager.isPrimary) {
+            onPlaying()
+        } else {
+            mService!!.loadLastPlaylist(PLAYLIST_TYPE_VIDEO)
+        }
+        if (itemTitle != null) title = itemTitle
+        titleTextView!!.text = title
+
+        if (wasPaused) {
+            // XXX: Workaround to update the seekbar position
+            forcedTime = savedTime
+            forcedTime = -1
+            showOverlay(true)
+        }
+        enableSubs()
+    }
+
+    private fun enableSubs() {
+        if (videoUri != null) {
+            val lastPath = videoUri!!.lastPathSegment
+            enableSubs = (!TextUtils.isEmpty(lastPath) && !lastPath!!.endsWith(".ts") && !lastPath.endsWith(".m2ts")
+                    && !lastPath.endsWith(".TS") && !lastPath.endsWith(".M2TS"))
+        }
+    }
+
+    private fun removeDownloadedSubtitlesObserver() {
+        if (downloadedSubtitleLiveData != null)
+            downloadedSubtitleLiveData!!.removeObserver(downloadedSubtitleObserver)
+        downloadedSubtitleLiveData = null
+    }
+
+    private fun observeDownloadedSubtitles() {
+        if (previousMediaPath == null || mService!!.currentMediaWrapper!!.uri.path != previousMediaPath) {
+            previousMediaPath = mService!!.currentMediaWrapper!!.uri.path
+            removeDownloadedSubtitlesObserver()
+            downloadedSubtitleLiveData = ExternalSubRepository.getInstance(this@VideoPlayerActivity).getDownloadedSubtitles(mService!!.currentMediaWrapper!!.uri.path!!)
+            downloadedSubtitleLiveData!!.observe(this, downloadedSubtitleObserver)
+        }
+    }
+
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)
+    private fun getScreenOrientation(mode: Int): Int {
+        when (mode) {
+            98 //toggle button
+            -> return if (currentScreenOrientation == Configuration.ORIENTATION_LANDSCAPE)
+                ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT
+            else
+                ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE
+            99 //screen orientation user
+            -> return if (AndroidUtil.isJellyBeanMR2OrLater)
+                ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR
+            else
+                ActivityInfo.SCREEN_ORIENTATION_SENSOR
+            101 //screen orientation landscape
+            -> return ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE
+            102 //screen orientation portrait
+            -> return ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT
+        }
+        /*
+         screenOrientation = 100, we lock screen at its current orientation
+         */
+        val wm = applicationContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager
+        val display = wm.defaultDisplay
+        val rot = screenRotation
+        /*
+         * Since getRotation() returns the screen's "natural" orientation,
+         * which is not guaranteed to be SCREEN_ORIENTATION_PORTRAIT,
+         * we have to invert the SCREEN_ORIENTATION value if it is "naturally"
+         * landscape.
+         */
+        var defaultWide = display.width > display.height
+        if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270)
+            defaultWide = !defaultWide
+        return if (defaultWide) {
+            when (rot) {
+                Surface.ROTATION_0 -> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
+                Surface.ROTATION_90 -> ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
+                Surface.ROTATION_180 ->
+                    // SCREEN_ORIENTATION_REVERSE_PORTRAIT only available since API
+                    // Level 9+
+                    ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
+                Surface.ROTATION_270 ->
+                    // SCREEN_ORIENTATION_REVERSE_LANDSCAPE only available since API
+                    // Level 9+
+                    ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT
+                else -> 0
+            }
+        } else {
+            when (rot) {
+                Surface.ROTATION_0 -> ActivityInfo.SCREEN_ORIENTATION_PORTRAIT
+                Surface.ROTATION_90 -> ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
+                Surface.ROTATION_180 ->
+                    // SCREEN_ORIENTATION_REVERSE_PORTRAIT only available since API
+                    // Level 9+
+                    ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT
+                Surface.ROTATION_270 ->
+                    // SCREEN_ORIENTATION_REVERSE_LANDSCAPE only available since API
+                    // Level 9+
+                    ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE
+                else -> 0
+            }
+        }
+    }
+
+    private fun showConfirmResumeDialog() {
+        if (isFinishing) return
+        mService!!.pause()
+        /* Encountered Error, exit player with a message */
+        alertDialog = AlertDialog.Builder(this@VideoPlayerActivity)
+                .setMessage(R.string.confirm_resume)
+                .setPositiveButton(R.string.resume_from_position) { _, _ -> loadMedia(false) }
+                .setNegativeButton(R.string.play_from_start) { _, _ -> loadMedia(true) }
+                .create()
+        alertDialog!!.setCancelable(false)
+        alertDialog!!.setOnKeyListener(DialogInterface.OnKeyListener { dialog, keyCode, _ ->
+            if (keyCode == KeyEvent.KEYCODE_BACK) {
+                dialog.dismiss()
+                finish()
+                return@OnKeyListener true
+            }
+            false
+        })
+        alertDialog!!.show()
+    }
+
+    fun showAdvancedOptions() {
+        if (optionsDelegate == null) optionsDelegate = PlayerOptionsDelegate(this, mService!!)
+        optionsDelegate!!.show(PlayerOptionType.ADVANCED)
+        hideOverlay(false)
+    }
+
+    private fun toggleOrientation() {
+        screenOrientation = 98 //Rotate button
+        requestedOrientation = getScreenOrientation(screenOrientation)
+    }
+
+    private fun resetOrientation(): Boolean {
+        if (screenOrientation == 98) {
+            screenOrientation = Integer.valueOf(
+                    settings!!.getString("screen_orientation", "99" /*SCREEN ORIENTATION SENSOR*/)!!)
+            UiTools.snacker(rootView!!, R.string.reset_orientation)
+            requestedOrientation = getScreenOrientation(screenOrientation)
+            return true
+        }
+        return false
+    }
+
+    internal fun togglePlaylist() {
+        if (isPlaylistVisible) {
+            playlist!!.visibility = View.GONE
+            playlist!!.setOnClickListener(null)
+            return
+        }
+        hideOverlay(true)
+        playlist!!.visibility = View.VISIBLE
+        playlist!!.adapter = playlistAdapter
+        update()
+    }
+
+    private fun toggleBtDelay(connected: Boolean) {
+        mService!!.setAudioDelay(if (connected) settings!!.getLong(KEY_BLUETOOTH_DELAY, 0) else 0L)
+    }
+
+    /**
+     * Start the video loading animation.
+     */
+    private fun startLoading() {
+        if (isLoading)
+            return
+        isLoading = true
+        val anim = AnimationSet(true)
+        val rotate = RotateAnimation(0f, 360f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f)
+        rotate.duration = 800
+        rotate.interpolator = DecelerateInterpolator()
+        rotate.repeatCount = RotateAnimation.INFINITE
+        anim.addAnimation(rotate)
+        loadingImageView!!.visibility = View.VISIBLE
+        loadingImageView!!.startAnimation(anim)
+    }
+
+    /**
+     * Stop the video loading animation.
+     */
+    private fun stopLoading() {
+        handler.removeMessages(LOADING_ANIMATION)
+        if (!isLoading) return
+        isLoading = false
+        loadingImageView!!.visibility = View.INVISIBLE
+        loadingImageView!!.clearAnimation()
+    }
+
+    fun onClickOverlayTips(v: View) {
+        UiTools.setViewVisibility(overlayTips, View.GONE)
+    }
+
+    fun onClickDismissTips(v: View) {
+        UiTools.setViewVisibility(overlayTips, View.GONE)
+        settings!!.edit().putBoolean(PREF_TIPS_SHOWN, true).apply()
+    }
+
+    private fun updateNavStatus() {
+        if (mService == null) return
+        isNavMenu = false
+        menuIdx = -1
+
+        runIO(Runnable {
+            val titles = if (mService != null) mService!!.titles else null
+            runOnMainThread(Runnable {
+                if (isFinishing || !lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)) return@Runnable
+                if (titles != null) {
+                    val currentIdx = mService!!.titleIdx
+                    for (i in titles.indices) {
+                        val title = titles[i]
+                        if (title.isMenu) {
+                            menuIdx = i
+                            break
+                        }
+                    }
+                    isNavMenu = menuIdx == currentIdx
+                }
+
+                if (isNavMenu) {
+                    /*
+                             * Keep the overlay hidden in order to have touch events directly
+                             * transmitted to navigation handling.
+                             */
+                    hideOverlay(false)
+                } else if (menuIdx != -1) setESTracks()
+
+                UiTools.setViewVisibility(navMenu, if (menuIdx >= 0 && navMenu != null) View.VISIBLE else View.GONE)
+                supportInvalidateOptionsMenu()
+            })
+        })
+    }
+
+    override fun onChanged(service: PlaybackService?) {
+        if (service != null) {
+            mService = service
+            //We may not have the permission to access files
+            if (Permissions.checkReadStoragePermission(this, true) && !switchingView)
+                handler.sendEmptyMessage(START_PLAYBACK)
+            switchingView = false
+            handler.post {
+                // delay mediaplayer loading, prevent ANR
+                if (mService!!.volume > 100 && !isAudioBoostEnabled) mService!!.setVolume(100)
+            }
+            mService!!.addCallback(this)
+        } else if (mService != null) {
+            mService!!.removeCallback(this)
+            mService = null
+            handler.sendEmptyMessage(AUDIO_SERVICE_CONNECTION_FAILED)
+        }
+    }
+
+    companion object {
+
+        private const val TAG = "VLC/VideoPlayerActivity"
+
+        private val ACTION_RESULT = "player.result".buildPkgString()
+        private const val EXTRA_POSITION = "extra_position"
+        private const val EXTRA_DURATION = "extra_duration"
+        private const val EXTRA_URI = "extra_uri"
+        private const val RESULT_CONNECTION_FAILED = Activity.RESULT_FIRST_USER + 1
+        private const val RESULT_PLAYBACK_ERROR = Activity.RESULT_FIRST_USER + 2
+        private const val RESULT_VIDEO_TRACK_LOST = Activity.RESULT_FIRST_USER + 3
+        internal const val DEFAULT_FOV = 80f
+        private const val KEY_TIME = "saved_time"
+        private const val KEY_URI = "saved_uri"
+        private const val OVERLAY_TIMEOUT = 4000
+        private const val OVERLAY_INFINITE = -1
+        private const val FADE_OUT = 1
+        private const val FADE_OUT_INFO = 2
+        private const val START_PLAYBACK = 3
+        private const val AUDIO_SERVICE_CONNECTION_FAILED = 4
+        private const val RESET_BACK_LOCK = 5
+        private const val CHECK_VIDEO_TRACKS = 6
+        private const val LOADING_ANIMATION = 7
+        internal const val SHOW_INFO = 8
+        internal const val HIDE_INFO = 9
+        private const val KEY_REMAINING_TIME_DISPLAY = "remaining_time_display"
+        private const val KEY_BLUETOOTH_DELAY = "key_bluetooth_delay"
+
+        private const val LOADING_ANIMATION_DELAY = 1000
+        @Volatile
+        internal var sDisplayRemainingTime: Boolean = false
+        private const val PREF_TIPS_SHOWN = "video_player_tips_shown"
+
+        private var clone: Boolean? = null
+
+        fun start(context: Context, uri: Uri) {
+            start(context, uri, null, false, -1)
+        }
+
+        fun start(context: Context, uri: Uri, fromStart: Boolean) {
+            start(context, uri, null, fromStart, -1)
+        }
+
+        fun start(context: Context, uri: Uri, title: String) {
+            start(context, uri, title, false, -1)
+        }
+
+        fun startOpened(context: Context, uri: Uri, openedPosition: Int) {
+            start(context, uri, null, false, openedPosition)
+        }
+
+        private fun start(context: Context, uri: Uri, title: String?, fromStart: Boolean, openedPosition: Int) {
+            val intent = getIntent(context, uri, title, fromStart, openedPosition)
+            context.startActivity(intent)
+        }
+
+        fun getIntent(action: String, mw: MediaWrapper, fromStart: Boolean, openedPosition: Int): Intent {
+            return getIntent(action, VLCApplication.getAppContext(), mw.uri, mw.title, fromStart, openedPosition)
+        }
+
+        fun getIntent(context: Context, uri: Uri, title: String?, fromStart: Boolean, openedPosition: Int): Intent {
+            return getIntent(PLAY_FROM_VIDEOGRID, context, uri, title, fromStart, openedPosition)
+        }
+
+        fun getIntent(action: String, context: Context, uri: Uri, title: String?, fromStart: Boolean, openedPosition: Int): Intent {
+            val intent = Intent(context, VideoPlayerActivity::class.java)
+            intent.action = action
+            intent.putExtra(PLAY_EXTRA_ITEM_LOCATION, uri)
+            intent.putExtra(PLAY_EXTRA_ITEM_TITLE, title)
+            intent.putExtra(PLAY_EXTRA_FROM_START, fromStart)
+
+            if (openedPosition != -1 || context !is Activity) {
+                if (openedPosition != -1)
+                    intent.putExtra(PLAY_EXTRA_OPENED_POSITION, openedPosition)
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
+            }
+            return intent
+        }
+
+
+    }
+}
+
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+@BindingAdapter("length", "time")
+fun setPlaybackTime(view: TextView, length: Long, time: Long) {
+    view.text = if (VideoPlayerActivity.sDisplayRemainingTime && length > 0)
+        "-" + '\u00A0'.toString() + Tools.millisToString(length - time)
+    else
+        Tools.millisToString(length)
+}
+
+@BindingAdapter("mediamax")
+fun setProgressMax(view: SeekBar, length: Long) {
+    view.max = length.toInt()
+}
+/**
+ * hide the info view
+ */
+/**
+ * show overlay with the previous timeout value
+ */
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt b/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt
index 32c32291f0..b84f31ce34 100644
--- a/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt
+++ b/vlc-android/src/org/videolan/vlc/gui/video/VideoTouchDelegate.kt
@@ -7,6 +7,8 @@ import android.util.DisplayMetrics
 import android.view.*
 import androidx.core.view.GestureDetectorCompat
 import androidx.core.view.ScaleGestureDetectorCompat
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
 import org.videolan.libvlc.MediaPlayer
 import org.videolan.medialibrary.Tools
 import org.videolan.vlc.R
@@ -28,6 +30,8 @@ private const val MAX_FOV = 150f
 //stick event
 private const val JOYSTICK_INPUT_DELAY = 300
 
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
 class VideoTouchDelegate(private val player: VideoPlayerActivity,
                          private val mTouchControls: Int,
                          var screenConfig: ScreenConfig,
@@ -194,7 +198,7 @@ class VideoTouchDelegate(private val player: VideoPlayerActivity,
                     player.changeBrightness(-y / 10f)
                 }
             } else if (Math.abs(rz) > 0.3) {
-                player.volume = player.audiomanager.getStreamVolume(AudioManager.STREAM_MUSIC).toFloat()
+                player.volume = player.audiomanager!!.getStreamVolume(AudioManager.STREAM_MUSIC).toFloat()
                 val delta = -(rz / 7 * player.audioMax).toInt()
                 val vol = Math.min(Math.max(player.volume + delta, 0f), player.audioMax.toFloat()).toInt()
                 player.setAudioVolume(vol)
@@ -232,13 +236,13 @@ class VideoTouchDelegate(private val player: VideoPlayerActivity,
         var coef = coef
         if (coef == 0) coef = 1
         // No seek action if coef > 0.5 and gesturesize < 1cm
-        if (Math.abs(gesturesize) < 1 || !player.mService.isSeekable) return
+        if (Math.abs(gesturesize) < 1 || !player.mService!!.isSeekable) return
 
         if (mTouchAction != TOUCH_NONE && mTouchAction != TOUCH_SEEK) return
         mTouchAction = TOUCH_SEEK
 
-        val length = player.mService.length
-        val time = player.mService.time
+        val length = player.mService!!.length
+        val time = player.mService!!.time
 
         // Size of the jump, 10 minutes max (600000), with a bi-cubic progression, for a 8cm gesture
         var jump = (Math.signum(gesturesize) * (600000 * Math.pow((gesturesize / 8).toDouble(), 4.0) + 3000) / coef).toInt()
@@ -340,7 +344,7 @@ class VideoTouchDelegate(private val player: VideoPlayerActivity,
                     savedScale = player.currentScaleType
                     player.setVideoScale(MediaPlayer.ScaleType.SURFACE_FIT_SCREEN)
                 } else if (!grow && savedScale != null) {
-                    player.setVideoScale(savedScale)
+                    player.setVideoScale(savedScale!!)
                     savedScale = null
                 } else if (!grow && player.currentScaleType == MediaPlayer.ScaleType.SURFACE_FIT_SCREEN) {
                     player.setVideoScale(MediaPlayer.ScaleType.SURFACE_BEST_FIT)
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/BenchActivity.java b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/BenchActivity.java
deleted file mode 100644
index 4f2575668c..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/BenchActivity.java
+++ /dev/null
@@ -1,608 +0,0 @@
-/*****************************************************************************
- * BenchActivity.java
- *****************************************************************************
- * Copyright © 2011-2014 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.video.benchmark;
-
-import android.Manifest;
-import android.annotation.TargetApi;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.graphics.Bitmap;
-import android.graphics.PixelFormat;
-import android.hardware.display.VirtualDisplay;
-import android.media.Image;
-import android.media.ImageReader;
-import android.media.projection.MediaProjection;
-import android.media.projection.MediaProjectionManager;
-import android.os.Bundle;
-import android.os.Environment;
-import android.os.Handler;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.View;
-
-import org.videolan.libvlc.Media;
-import org.videolan.libvlc.MediaPlayer;
-import org.videolan.vlc.PlaybackService;
-import org.videolan.vlc.util.Settings;
-import org.videolan.vlc.util.VLCInstance;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.nio.Buffer;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.core.app.ActivityCompat;
-
-/**
- * BenchActivity is a class that overrides VideoPlayerActivity through ShallowVideoPlayer.
- * BenchActivity can perform several tests:
- * - PLAYBACK:
- *  The class just plays the video, sending back statistics to VLCBenchmark.
- * - SCREENSHOTS:
- *  The class waits for the video to buffer the first time to do the initial setup.
- *  Then it starts an activity that asks for the permission to take screenshots.
- *  If that permission is granted, a seek is performed to the first screenshot timestamp.
- *  Once the buffering is finished, a callback is set on the next image available.
- *  That callback writes the image bitmap to a file, and calls the seek to the next timestamp.
- */
-
-public class BenchActivity extends ShallowVideoPlayer {
-
-    private static final String EXTRA_TIMESTAMPS = "extra_benchmark_timestamps";
-    private static final String EXTRA_ACTION_QUALITY = "extra_benchmark_action_quality";
-    private static final String EXTRA_ACTION_PLAYBACK = "extra_benchmark_action_playback";
-    private static final String EXTRA_SCREENSHOT_DIR = "extra_benchmark_screenshot_dir";
-    private static final String EXTRA_ACTION = "extra_benchmark_action";
-    private static final String EXTRA_HARDWARE = "extra_benchmark_disable_hardware";
-    public static final String EXTRA_BENCHMARK = "extra_benchmark";
-
-    private static final String TAG = "VLCBenchmark";
-    private static final int REQUEST_SCREENSHOT = 666;
-
-    private static final int RESULT_FAILED = 6;
-    private static final int RESULT_NO_HW = 1;
-
-    private static final int VIRTUAL_DISPLAY_FLAGS = 0;
-
-    private static final int PERMISSION_REQUEST_WRITE = 1;
-
-    private Runnable mTimeOut = null;
-
-    private int mWidth;
-    private int mHeight;
-    private int mDensity;
-    private VirtualDisplay mVirtualDisplay = null;
-    private MediaProjectionManager mProjectionManager;
-    private MediaProjection mMediaProjection = null;
-    private ImageReader mImageReader = null;
-    private Handler mHandler = null;
-    private List<Long> mTimestamp;
-    private boolean mIsScreenshot = false;
-    private int mScreenshotCount = 0;
-    private int mScreenshotNumber = 0;
-    private int mLateFrameCounter = 0;
-    private boolean mSetup = false;
-    /* Differentiates between buffering due or not to seeking */
-    private boolean mSeeking = false;
-    /* set to true when VLC crashes */
-    private boolean mVLCFailed = false;
-    /* set to true when video is in hardware decoding */
-    private boolean mIsHardware = false;
-    /* set to true when Vout event is received
-     * used to check if hardware decoder works */
-    private boolean mHasVout = false;
-    /* screenshot directory location */
-    private String screenshotDir;
-    /* bool to wait in pause for user permission */
-    private boolean mWritePermission = false;
-
-    /* android_display vout is forced on hardware tests */
-    /* this option is set using the opengl sharedPref */
-    /* Saves the original value to reset it after the benchmark */
-    private String mOldOpenglValue = "-2";
-
-    /* Used to determine when a playback is stuck */
-    private float mPosition = 0;
-    private int mPositionCounter = 0;
-
-
-    @Override
-    public void onChanged(PlaybackService service) {
-        super.onChanged(service);
-        if (mIsHardware && mService != null) {
-            final SharedPreferences sharedPref = Settings.INSTANCE.getInstance(this);
-            mOldOpenglValue = sharedPref.getString("opengl", "-1");
-            final SharedPreferences.Editor editor = sharedPref.edit();
-            editor.putString("opengl", "0");
-            editor.commit();
-            VLCInstance.restart();
-            mService.restartMediaPlayer();
-        }
-    }
-
-    @Override
-    protected void loadMedia() {
-        if (mService != null) {
-            mService.setBenchmark();
-            if (mIsHardware) {
-                mService.setHardware();
-            }
-        }
-        super.loadMedia();
-    }
-
-    @Override
-    final public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-        // checking for permission other than granted
-        if ((requestCode == PERMISSION_REQUEST_WRITE) &&
-                grantResults.length >= 1 && grantResults[0] != PackageManager.PERMISSION_GRANTED) {
-            errorFinish("Failed to get write permission for screenshots");
-        } else if ((requestCode == PERMISSION_REQUEST_WRITE) && grantResults.length >= 1) {
-            mWritePermission = true;
-            if (mIsScreenshot) {
-                /* Temporizing for the authorisation popup to disappear */
-                mHandler.postDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        seekScreenshot();
-                    }
-                }, 1000);
-            }
-        }
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        /* Crash handler setup */
-        StartActivityOnCrash.setUp(this);
-
-        Intent intent = getIntent();
-
-        /* Enabling hardware mode if necessary*/
-        /* Stops the hardware decoder falling back to software */
-        mIsHardware = !intent.getBooleanExtra(EXTRA_HARDWARE, true);
-        mIsBenchmark = true;
-
-        super.onCreate(savedInstanceState);
-
-        /* Determining the benchmark mode */
-        if (!intent.hasExtra(EXTRA_ACTION)) {
-            errorFinish("Missing action intent extra");
-            return;
-        }
-        switch (intent.getStringExtra(EXTRA_ACTION)) {
-            case EXTRA_ACTION_PLAYBACK:
-                break;
-            case EXTRA_ACTION_QUALITY:
-                if (!intent.hasExtra(EXTRA_SCREENSHOT_DIR)) {
-                    errorFinish("Failed to get screenshot directory location");
-                    return;
-                }
-                screenshotDir = intent.getStringExtra(EXTRA_SCREENSHOT_DIR);
-                mIsScreenshot = intent.hasExtra(EXTRA_TIMESTAMPS);
-                if (!mIsScreenshot) {
-                    errorFinish("Missing screenshots timestamps");
-                    return;
-                }
-                if (intent.getSerializableExtra(EXTRA_TIMESTAMPS) instanceof List) {
-                    mTimestamp = (List<Long>) intent.getSerializableExtra(EXTRA_TIMESTAMPS);
-                } else {
-                    errorFinish("Failed to get timestamps");
-                    return;
-                }
-
-                /* Deactivates secondary displays */
-                mEnableCloneMode = true;
-                mDisplayManager.release();
-                break;
-        }
-
-        // blocking display in landscape orientation
-        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
-        // Minimum apk for benchmark is 21, so this warning is a non-issue
-        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LOCKED);
-
-        // Check for write permission, if false will ask
-        // for them after asking for screenshot permission
-        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)
-            mWritePermission = false;
-        else
-            mWritePermission = true;
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        setTimeout();
-    }
-
-    /**
-     * On some weak devices, the hardware decoder will end up hung.
-     * To avoid stopping the benchmark, a timeout is set to stop vlc
-     * and return to the benchmark for the next test.
-     */
-    private void setTimeout() {
-        if (mSetup && mHandler != null) {
-            if (mTimeOut != null) {
-                mHandler.removeCallbacks(mTimeOut);
-                mTimeOut = null;
-            }
-            mTimeOut = new Runnable() {
-                @Override
-                public void run() {
-                    Log.e(TAG, "VLC Seek Froze" );
-                    errorFinish("VLC Seek Froze");
-                }
-            };
-            mHandler.postDelayed(mTimeOut, 10000);
-        }
-    }
-
-    /**
-     * Reacts on the event buffering before calling super:
-     * <p/>
-     * if end of buffering, initialises screen info,
-     * the projectionManager, and handler used, and starts
-     * the activity that asks for the screenshot permission.
-     *
-     * if end of buffering, and boolean seeking is true
-     * sets screenshot callback.
-     *
-     * if not end of buffering, and seeking, checks for seek timeouts.
-     *
-     * @param event mediaPlayer events
-     */
-    @Override
-    @TargetApi(21)
-    public void onMediaPlayerEvent(MediaPlayer.Event event) {
-        switch (event.type) {
-            case MediaPlayer.Event.Vout:
-                mHasVout = true;
-                break;
-            case MediaPlayer.Event.TimeChanged:
-                setTimeout();
-                break;
-            case MediaPlayer.Event.PositionChanged:
-                float pos = event.getPositionChanged();
-                if (!mIsScreenshot) {
-                    if (pos != mPosition) {
-                        mPosition = pos;
-                        mPositionCounter = 0;
-                    } else if (mPositionCounter > 50){
-                        errorFinish("VLC Playback Froze");
-                    } else {
-                        mPositionCounter += 1;
-                    }
-                }
-                break;
-            case MediaPlayer.Event.Buffering:
-                if (event.getBuffering() == 100f) {
-                    /* initial setup that has to be done when the video
-                     * has finished the first buffering */
-                    if (!mSetup) {
-                        mSetup = true;
-                        if (mIsScreenshot) {
-                            mService.pause();
-                            DisplayMetrics metrics = new DisplayMetrics();
-                            getWindowManager().getDefaultDisplay().getRealMetrics(metrics);
-                            mWidth = metrics.widthPixels;
-                            mHeight = metrics.heightPixels;
-                            mDensity = metrics.densityDpi;
-                            mProjectionManager =
-                                    (MediaProjectionManager) getSystemService(MEDIA_PROJECTION_SERVICE);
-                            if (mProjectionManager == null) {
-                                errorFinish("Failed to create MediaProjectionManager");
-                            }
-                            mHandler = new Handler();
-                            Intent screenshotIntent;
-                            screenshotIntent = mProjectionManager.createScreenCaptureIntent();
-                            screenshotIntent.setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
-                            screenshotIntent.setFlags(Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP);
-                            startActivityForResult(screenshotIntent, REQUEST_SCREENSHOT);
-                        }
-                    }
-                    /* Screenshot callback setup */
-                    if (mIsScreenshot && mSetup && mScreenshotNumber < mTimestamp.size() && mSeeking) {
-                        mSeeking = false;
-                        mImageReader = ImageReader.newInstance(mWidth, mHeight, PixelFormat.RGBA_8888, 2);
-                        mVirtualDisplay =
-                                mMediaProjection.createVirtualDisplay("testScreenshot", mWidth,
-                                        mHeight, mDensity, VIRTUAL_DISPLAY_FLAGS,
-                                        mImageReader.getSurface(), null, mHandler);
-
-                        if (mVirtualDisplay == null) {
-                            errorFinish("Failed to create Virtual Display");
-                        }
-                        try {
-                            mImageReader.setOnImageAvailableListener(new ImageAvailableListener(), mHandler);
-                        } catch (IllegalArgumentException e) {
-                            errorFinish("Failed to create screenshot callback");
-                        }
-                    }
-                }
-                break;
-        }
-        super.onMediaPlayerEvent(event);
-    }
-
-    /**
-     * Seeks to the position of the next screenshot,
-     * triggering the buffering of the video.
-     * At the end of the video buffering, the screenshot callback is set.
-     */
-    private void seekScreenshot() {
-        if (mProjectionManager != null && mScreenshotCount < mTimestamp.size()) {
-            setTimeout();
-            seek(mTimestamp.get(mScreenshotCount));
-            ++mScreenshotCount;
-            mSeeking = true;
-        } else {
-            finish();
-        }
-    }
-
-    /**
-     * Called on return of launched activities,
-     * and particularly the screenshot authorisation activity.
-     * If successful, sets up the mediaProjection for later virtual displays
-     *
-     * @param requestCode activity request code
-     * @param resultCode  activity result code
-     * @param resultData  activity result data
-     */
-    @Override
-    @TargetApi(21)
-    public void onActivityResult(int requestCode, int resultCode, Intent resultData) {
-        if (requestCode == REQUEST_SCREENSHOT && resultData != null && resultCode == RESULT_OK) {
-            /* Hiding navigation bar */
-            View decorView = getWindow().getDecorView();
-            int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                    | View.SYSTEM_UI_FLAG_FULLSCREEN;
-            decorView.setSystemUiVisibility(uiOptions);
-
-            /* Creating the MediaProjection used later for each VirtualDisplay creation */
-            mMediaProjection = mProjectionManager.getMediaProjection(resultCode, resultData);
-            if (mMediaProjection == null) {
-                errorFinish("Failed to create MediaProjection");
-            }
-            if (mWritePermission) {
-                /* Temporizing for the authorisation popup to disappear */
-                mHandler.postDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        seekScreenshot();
-                    }
-                }, 1000);
-            } else {
-                ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, PERMISSION_REQUEST_WRITE);
-            }
-        } else {
-            errorFinish("Failed to get screenshot permission");
-        }
-    }
-
-    /**
-     * Override of VideoPlayerActivity's exit aiming to catch the resultCode
-     * if the resultCode is different from RESULT_OK, boolean mVLCFailed is set to true,
-     * then we will not override the finish(), and change the resultCode.
-     * @param resultCode VideoPlayerActivity's resultCode
-     */
-    @Override
-    public void exit (int resultCode) {
-        if (resultCode != RESULT_OK) {
-            mVLCFailed = true;
-        }
-        super.exit(resultCode);
-    }
-
-    /**
-     * To be called when the error is big enough to return to VLCBenchmark
-     * @param resultString error description for display in VLCBenchmark
-     */
-    private void errorFinish(String resultString) {
-        Log.e(TAG, "errorFinish: " + resultString);
-        Intent sendIntent = new Intent();
-        sendIntent.putExtra("Error", resultString);
-        setResult(RESULT_FAILED, sendIntent);
-        super.finish();
-    }
-    /**
-     * Method analysing VLC logs to find warnings,
-     * and report them to VLCBenchmark
-     */
-    private void checkLogs() {
-        int counter = 0;
-
-        try {
-            int pid = android.os.Process.myPid();
-            /*Displays priority, tag, and PID of the process issuing the message from this pid*/
-            Process process = Runtime.getRuntime().exec("logcat -d -v brief --pid=" + pid);
-            BufferedReader bufferedReader = new BufferedReader(
-                    new InputStreamReader(process.getInputStream()));
-            String line;
-            while ((line = bufferedReader.readLine()) != null) {
-                if (line.contains("W/") || line.contains("E/")) {
-                    if (line.contains(" late ")) {
-                        counter += 1;
-                    }
-                }
-            }
-            /* Clear logs, so that next test is not polluted by current one */
-            new ProcessBuilder()
-            .command("logcat", "-c")
-            .redirectErrorStream(true)
-            .start();
-        } catch (IOException ex) {
-            Log.e(TAG, ex.toString());
-        }
-        mLateFrameCounter = counter;
-    }
-
-    /**
-     * Sets up the benchmark statistics to be returned
-     * before calling super
-     */
-    @Override
-    @TargetApi(21)
-    public void finish() {
-        /* Resetting vout preference to it value before the benchmark */
-        if (mIsHardware && !mOldOpenglValue.equals("-2")) {
-            final SharedPreferences sharedPref = Settings.INSTANCE.getInstance(this);
-            final SharedPreferences.Editor editor= sharedPref.edit();
-            editor.putString("opengl", mOldOpenglValue);
-            editor.commit();
-            VLCInstance.restart();
-        }
-        /* Case of error in VideoPlayerActivity, then finish is not overridden */
-        if (mVLCFailed) {
-            super.finish();
-            return;
-        }
-        if (!mHasVout) {
-            setResult(RESULT_NO_HW, null);
-            super.finish();
-        }
-        Intent sendIntent = new Intent();
-        checkLogs();
-        if (mService != null) {
-            Media.Stats stats = mService.getLastStats();
-            sendIntent.putExtra("percent_of_bad_seek", 0.0);
-            sendIntent.putExtra("number_of_dropped_frames", (stats == null ? 100 : stats.lostPictures));
-            sendIntent.putExtra("screenshot_folder", Environment.getExternalStorageDirectory() + File.separator + "screenshotFolder");
-            sendIntent.putExtra("late_frames", mLateFrameCounter);
-            setResult(RESULT_OK, sendIntent);
-            super.finish();
-        } else {
-            errorFinish("PlaybackService is null");
-        }
-    }
-
-    @Override
-    @TargetApi(21)
-    protected void onDestroy() {
-        if (mImageReader != null) {
-            try {
-                mImageReader.setOnImageAvailableListener(null, null);
-            } catch (IllegalArgumentException e) {
-                Log.e(TAG, "Failed to destroy screenshot callback");
-            }
-        }
-        if (mVirtualDisplay != null) {
-            mVirtualDisplay.release();
-        }
-        if (mMediaProjection != null) {
-            mMediaProjection.stop();
-        }
-        if (mTimeOut != null && mHandler != null) {
-            mHandler.removeCallbacks(mTimeOut);
-        }
-        super.onDestroy();
-    }
-
-    /**
-     * Callback that is called when the first image is available after setting up
-     * ImageReader in onEventReceive(...) at the end of the video buffering.
-     * <p/>
-     * It takes the screenshot.
-     */
-    @TargetApi(19)
-    private class ImageAvailableListener implements ImageReader.OnImageAvailableListener {
-        @Override
-        @TargetApi(21)
-        public void onImageAvailable(ImageReader reader) {
-            mHandler.postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    FileOutputStream outputStream = null;
-                    Image image = null;
-                    Bitmap bitmap;
-                    try {
-                        image = mImageReader.acquireLatestImage();
-                    } catch (IllegalArgumentException e) {
-                        Log.e(TAG, "Failed to acquire latest image for screenshot.");
-                    }
-                    if (image != null) {
-                        Image.Plane[] planes = image.getPlanes();
-                        Buffer buffer = planes[0].getBuffer().rewind();
-                        int pixelStride = planes[0].getPixelStride();
-                        int rowStride = planes[0].getRowStride();
-                        int rowPadding = rowStride - pixelStride * mWidth;
-
-                        bitmap = Bitmap.createBitmap(mWidth + rowPadding / pixelStride, mHeight,
-                                Bitmap.Config.ARGB_8888);
-                        if (bitmap != null) {
-                            bitmap.copyPixelsFromBuffer(buffer);
-                            File folder = new File(screenshotDir);
-
-                            if (!folder.exists()) {
-                                if (!folder.mkdir()) {
-                                    errorFinish("Failed to create screenshot directory");
-                                }
-                            }
-                            File imageFile = new File(folder.getAbsolutePath() + File.separator + "Screenshot_" + mScreenshotNumber + ".png");
-                            mScreenshotNumber += 1;
-                            try {
-                                outputStream = new FileOutputStream(imageFile);
-                            } catch (IOException e) {
-                                Log.e(TAG, "Failed to create outputStream");
-                            }
-                            if (outputStream != null) {
-                                bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream);
-                            }
-
-                            bitmap.recycle();
-                            image.close();
-                            if (outputStream != null) {
-                                try {
-                                    outputStream.flush();
-                                    outputStream.close();
-                                } catch (IOException e) {
-                                    Log.e(TAG, "Failed to release outputStream");
-                                }
-                            }
-                        }
-                    }
-                    try {
-                        mImageReader.setOnImageAvailableListener(null, null);
-                    } catch (IllegalArgumentException e) {
-                        Log.e(TAG, "Failed to delete ImageReader callback");
-                    }
-                    mVirtualDisplay.release();
-                    mVirtualDisplay = null;
-                    mImageReader.close();
-                    if (mScreenshotNumber < mTimestamp.size()) {
-                        seekScreenshot();
-                    } else {
-                        finish();
-                    }
-                }
-            }, 1000);
-        }
-    }
-}
-
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/BenchActivity.kt b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/BenchActivity.kt
new file mode 100644
index 0000000000..6a59305570
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/BenchActivity.kt
@@ -0,0 +1,576 @@
+/*****************************************************************************
+ * BenchActivity.java
+ *
+ * Copyright © 2011-2014 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.video.benchmark
+
+import android.Manifest
+import android.annotation.TargetApi
+import android.app.Activity
+import android.content.Context
+import android.content.Intent
+import android.content.pm.ActivityInfo
+import android.content.pm.PackageManager
+import android.graphics.Bitmap
+import android.graphics.PixelFormat
+import android.hardware.display.VirtualDisplay
+import android.media.Image
+import android.media.ImageReader
+import android.media.projection.MediaProjection
+import android.media.projection.MediaProjectionManager
+import android.os.Bundle
+import android.os.Environment
+import android.os.Handler
+import android.util.DisplayMetrics
+import android.util.Log
+import android.view.View
+import androidx.core.app.ActivityCompat
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
+import org.videolan.libvlc.MediaPlayer
+import org.videolan.vlc.PlaybackService
+import org.videolan.vlc.util.Settings
+import org.videolan.vlc.util.VLCInstance
+import java.io.*
+
+/**
+ * BenchActivity is a class that overrides VideoPlayerActivity through ShallowVideoPlayer.
+ * BenchActivity can perform several tests:
+ * - PLAYBACK:
+ * The class just plays the video, sending back statistics to VLCBenchmark.
+ * - SCREENSHOTS:
+ * The class waits for the video to buffer the first time to do the initial setup.
+ * Then it starts an activity that asks for the permission to take screenshots.
+ * If that permission is granted, a seek is performed to the first screenshot timestamp.
+ * Once the buffering is finished, a callback is set on the next image available.
+ * That callback writes the image bitmap to a file, and calls the seek to the next timestamp.
+ */
+
+@ObsoleteCoroutinesApi
+@ExperimentalCoroutinesApi
+class BenchActivity : ShallowVideoPlayer() {
+
+    private var mTimeOut: Runnable? = null
+
+    private var mWidth: Int = 0
+    private var mHeight: Int = 0
+    private var mDensity: Int = 0
+    private var mVirtualDisplay: VirtualDisplay? = null
+    private var mProjectionManager: MediaProjectionManager? = null
+    private var mMediaProjection: MediaProjection? = null
+    private var mImageReader: ImageReader? = null
+    private var mHandler: Handler? = null
+    private var mTimestamp: List<Long>? = null
+    private var mIsScreenshot = false
+    private var mScreenshotCount = 0
+    private var mScreenshotNumber = 0
+    private var mLateFrameCounter = 0
+    private var mSetup = false
+    /* Differentiates between buffering due or not to seeking */
+    private var mSeeking = false
+    /* set to true when VLC crashes */
+    private var mVLCFailed = false
+    /* set to true when video is in hardware decoding */
+    private var mIsHardware = false
+    /* set to true when Vout event is received
+     * used to check if hardware decoder works */
+    private var mHasVout = false
+    /* screenshot directory location */
+    private var screenshotDir: String? = null
+    /* bool to wait in pause for user permission */
+    private var mWritePermission = false
+
+    /* android_display vout is forced on hardware tests */
+    /* this option is set using the opengl sharedPref */
+    /* Saves the original value to reset it after the benchmark */
+    private var mOldOpenglValue: String? = "-2"
+
+    /* Used to determine when a playback is stuck */
+    private var mPosition = 0f
+    private var mPositionCounter = 0
+
+
+    override fun onChanged(service: PlaybackService?) {
+        super.onChanged(service)
+        if (mIsHardware && mService != null) {
+            val sharedPref = Settings.getInstance(this)
+            mOldOpenglValue = sharedPref.getString("opengl", "-1")
+            val editor = sharedPref.edit()
+            editor.putString("opengl", "0")
+            editor.commit()
+            VLCInstance.restart()
+            mService?.restartMediaPlayer()
+        }
+    }
+
+    override fun loadMedia() {
+        if (mService != null) {
+            mService!!.setBenchmark()
+            if (mIsHardware) {
+                mService!!.setHardware()
+            }
+        }
+        super.loadMedia()
+    }
+
+    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
+        // checking for permission other than granted
+        if (requestCode == PERMISSION_REQUEST_WRITE &&
+                grantResults.isNotEmpty() && grantResults[0] != PackageManager.PERMISSION_GRANTED) {
+            errorFinish("Failed to get write permission for screenshots")
+        } else if (requestCode == PERMISSION_REQUEST_WRITE && grantResults.isNotEmpty()) {
+            mWritePermission = true
+            if (mIsScreenshot) {
+                /* Temporizing for the authorisation popup to disappear */
+                mHandler!!.postDelayed({ seekScreenshot() }, 1000)
+            }
+        }
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        /* Crash handler setup */
+        StartActivityOnCrash.setUp(this)
+
+        val intent = intent
+
+        /* Enabling hardware mode if necessary*/
+        /* Stops the hardware decoder falling back to software */
+        mIsHardware = !intent.getBooleanExtra(EXTRA_HARDWARE, true)
+        isBenchmark = true
+
+        super.onCreate(savedInstanceState)
+
+        /* Determining the benchmark mode */
+        if (!intent.hasExtra(EXTRA_ACTION)) {
+            errorFinish("Missing action intent extra")
+            return
+        }
+        when (intent.getStringExtra(EXTRA_ACTION)) {
+            EXTRA_ACTION_PLAYBACK -> {
+            }
+            EXTRA_ACTION_QUALITY -> {
+                if (!intent.hasExtra(EXTRA_SCREENSHOT_DIR)) {
+                    errorFinish("Failed to get screenshot directory location")
+                    return
+                }
+                screenshotDir = intent.getStringExtra(EXTRA_SCREENSHOT_DIR)
+                mIsScreenshot = intent.hasExtra(EXTRA_TIMESTAMPS)
+                if (!mIsScreenshot) {
+                    errorFinish("Missing screenshots timestamps")
+                    return
+                }
+                if (intent.getSerializableExtra(EXTRA_TIMESTAMPS) is List<*>) {
+                    mTimestamp = intent.getSerializableExtra(EXTRA_TIMESTAMPS) as List<Long>
+                } else {
+                    errorFinish("Failed to get timestamps")
+                    return
+                }
+
+                /* Deactivates secondary displays */
+                enableCloneMode = true
+                displayManager.release()
+            }
+        }
+
+        // blocking display in landscape orientation
+        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
+        // Minimum apk for benchmark is 21, so this warning is a non-issue
+        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LOCKED
+
+        // Check for write permission, if false will ask
+        // for them after asking for screenshot permission
+        mWritePermission = ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED
+    }
+
+    override fun onResume() {
+        super.onResume()
+        setTimeout()
+    }
+
+    /**
+     * On some weak devices, the hardware decoder will end up hung.
+     * To avoid stopping the benchmark, a timeout is set to stop vlc
+     * and return to the benchmark for the next test.
+     */
+    private fun setTimeout() {
+        if (mSetup && mHandler != null) {
+            if (mTimeOut != null) {
+                mHandler!!.removeCallbacks(mTimeOut)
+                mTimeOut = null
+            }
+            mTimeOut = Runnable {
+                Log.e(TAG, "VLC Seek Froze")
+                errorFinish("VLC Seek Froze")
+            }
+            mHandler!!.postDelayed(mTimeOut, 10000)
+        }
+    }
+
+    /**
+     * Reacts on the event buffering before calling super:
+     *
+     *
+     * if end of buffering, initialises screen info,
+     * the projectionManager, and handler used, and starts
+     * the activity that asks for the screenshot permission.
+     *
+     * if end of buffering, and boolean seeking is true
+     * sets screenshot callback.
+     *
+     * if not end of buffering, and seeking, checks for seek timeouts.
+     *
+     * @param event mediaPlayer events
+     */
+    @TargetApi(21)
+    override fun onMediaPlayerEvent(event: MediaPlayer.Event) {
+        when (event.type) {
+            MediaPlayer.Event.Vout -> mHasVout = true
+            MediaPlayer.Event.TimeChanged -> setTimeout()
+            MediaPlayer.Event.PositionChanged -> {
+                val pos = event.positionChanged
+                if (!mIsScreenshot) {
+                    when {
+                        pos != mPosition -> {
+                            mPosition = pos
+                            mPositionCounter = 0
+                        }
+                        mPositionCounter > 50 -> errorFinish("VLC Playback Froze")
+                        else -> mPositionCounter += 1
+                    }
+                }
+            }
+            MediaPlayer.Event.Buffering -> if (event.buffering == 100f) {
+                /* initial setup that has to be done when the video
+                     * has finished the first buffering */
+                if (!mSetup) {
+                    mSetup = true
+                    if (mIsScreenshot) {
+                        mService?.pause()
+                        val metrics = DisplayMetrics()
+                        windowManager.defaultDisplay.getRealMetrics(metrics)
+                        mWidth = metrics.widthPixels
+                        mHeight = metrics.heightPixels
+                        mDensity = metrics.densityDpi
+                        mProjectionManager = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager
+                        if (mProjectionManager == null) {
+                            errorFinish("Failed to create MediaProjectionManager")
+                        }
+                        mHandler = Handler()
+                        val screenshotIntent: Intent = mProjectionManager!!.createScreenCaptureIntent()
+                        screenshotIntent.flags = Intent.FLAG_ACTIVITY_NO_ANIMATION
+                        screenshotIntent.flags = Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP
+                        startActivityForResult(screenshotIntent, REQUEST_SCREENSHOT)
+                    }
+                }
+                /* Screenshot callback setup */
+                if (mIsScreenshot && mSetup && mScreenshotNumber < mTimestamp!!.size && mSeeking) {
+                    mSeeking = false
+                    mImageReader = ImageReader.newInstance(mWidth, mHeight, PixelFormat.RGBA_8888, 2)
+                    mVirtualDisplay = mMediaProjection!!.createVirtualDisplay("testScreenshot", mWidth,
+                            mHeight, mDensity, VIRTUAL_DISPLAY_FLAGS,
+                            mImageReader!!.surface, null, mHandler)
+
+                    if (mVirtualDisplay == null) {
+                        errorFinish("Failed to create Virtual Display")
+                    }
+                    try {
+                        mImageReader!!.setOnImageAvailableListener(ImageAvailableListener(), mHandler)
+                    } catch (e: IllegalArgumentException) {
+                        errorFinish("Failed to create screenshot callback")
+                    }
+
+                }
+            }
+        }
+        super.onMediaPlayerEvent(event)
+    }
+
+    /**
+     * Seeks to the position of the next screenshot,
+     * triggering the buffering of the video.
+     * At the end of the video buffering, the screenshot callback is set.
+     */
+    private fun seekScreenshot() {
+        if (mProjectionManager != null && mScreenshotCount < mTimestamp!!.size) {
+            setTimeout()
+            seek(mTimestamp!![mScreenshotCount])
+            ++mScreenshotCount
+            mSeeking = true
+        } else {
+            finish()
+        }
+    }
+
+    /**
+     * Called on return of launched activities,
+     * and particularly the screenshot authorisation activity.
+     * If successful, sets up the mediaProjection for later virtual displays
+     *
+     * @param requestCode activity request code
+     * @param resultCode  activity result code
+     * @param resultData  activity result data
+     */
+    @TargetApi(21)
+    public override fun onActivityResult(requestCode: Int, resultCode: Int, resultData: Intent?) {
+        if (requestCode == REQUEST_SCREENSHOT && resultData != null && resultCode == Activity.RESULT_OK) {
+            /* Hiding navigation bar */
+            val decorView = window.decorView
+            val uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_FULLSCREEN
+            decorView.systemUiVisibility = uiOptions
+
+            /* Creating the MediaProjection used later for each VirtualDisplay creation */
+            mMediaProjection = mProjectionManager!!.getMediaProjection(resultCode, resultData)
+            if (mMediaProjection == null) {
+                errorFinish("Failed to create MediaProjection")
+            }
+            if (mWritePermission) {
+                /* Temporizing for the authorisation popup to disappear */
+                mHandler!!.postDelayed({ seekScreenshot() }, 1000)
+            } else {
+                ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE), PERMISSION_REQUEST_WRITE)
+            }
+        } else {
+            errorFinish("Failed to get screenshot permission")
+        }
+    }
+
+    /**
+     * Override of VideoPlayerActivity's exit aiming to catch the resultCode
+     * if the resultCode is different from RESULT_OK, boolean mVLCFailed is set to true,
+     * then we will not override the finish(), and change the resultCode.
+     * @param resultCode VideoPlayerActivity's resultCode
+     */
+    override fun exit(resultCode: Int) {
+        if (resultCode != Activity.RESULT_OK) {
+            mVLCFailed = true
+        }
+        super.exit(resultCode)
+    }
+
+    /**
+     * To be called when the error is big enough to return to VLCBenchmark
+     * @param resultString error description for display in VLCBenchmark
+     */
+    private fun errorFinish(resultString: String) {
+        Log.e(TAG, "errorFinish: $resultString")
+        val sendIntent = Intent()
+        sendIntent.putExtra("Error", resultString)
+        setResult(RESULT_FAILED, sendIntent)
+        super.finish()
+    }
+
+    /**
+     * Method analysing VLC logs to find warnings,
+     * and report them to VLCBenchmark
+     */
+    private fun checkLogs() {
+        var counter = 0
+
+        try {
+            val pid = android.os.Process.myPid()
+            /*Displays priority, tag, and PID of the process issuing the message from this pid*/
+            val process = Runtime.getRuntime().exec("logcat -d -v brief --pid=$pid")
+            val bufferedReader = BufferedReader(
+                    InputStreamReader(process.inputStream))
+            var line = bufferedReader.readLine()
+            while (line != null) {
+                if (line.contains("W/") || line.contains("E/")) {
+                    if (line.contains(" late ")) {
+                        counter += 1
+                    }
+                }
+                line = bufferedReader.readLine()
+            }
+            /* Clear logs, so that next test is not polluted by current one */
+            ProcessBuilder()
+                    .command("logcat", "-c")
+                    .redirectErrorStream(true)
+                    .start()
+        } catch (ex: IOException) {
+            Log.e(TAG, ex.toString())
+        }
+
+        mLateFrameCounter = counter
+    }
+
+    /**
+     * Sets up the benchmark statistics to be returned
+     * before calling super
+     */
+    @TargetApi(21)
+    override fun finish() {
+        /* Resetting vout preference to it value before the benchmark */
+        if (mIsHardware && mOldOpenglValue != "-2") {
+            val sharedPref = Settings.getInstance(this)
+            val editor = sharedPref.edit()
+            editor.putString("opengl", mOldOpenglValue)
+            editor.commit()
+            VLCInstance.restart()
+        }
+        /* Case of error in VideoPlayerActivity, then finish is not overridden */
+        if (mVLCFailed) {
+            super.finish()
+            return
+        }
+        if (!mHasVout) {
+            setResult(RESULT_NO_HW, null)
+            super.finish()
+        }
+        val sendIntent = Intent()
+        checkLogs()
+        if (mService != null) {
+            val stats = mService!!.lastStats
+            sendIntent.putExtra("percent_of_bad_seek", 0.0)
+            sendIntent.putExtra("number_of_dropped_frames", stats?.lostPictures ?: 100)
+            sendIntent.putExtra("screenshot_folder", Environment.getExternalStorageDirectory().toString() + File.separator + "screenshotFolder")
+            sendIntent.putExtra("late_frames", mLateFrameCounter)
+            setResult(Activity.RESULT_OK, sendIntent)
+            super.finish()
+        } else {
+            errorFinish("PlaybackService is null")
+        }
+    }
+
+    @TargetApi(21)
+    override fun onDestroy() {
+        if (mImageReader != null) {
+            try {
+                mImageReader!!.setOnImageAvailableListener(null, null)
+            } catch (e: IllegalArgumentException) {
+                Log.e(TAG, "Failed to destroy screenshot callback")
+            }
+
+        }
+        if (mVirtualDisplay != null) {
+            mVirtualDisplay!!.release()
+        }
+        if (mMediaProjection != null) {
+            mMediaProjection!!.stop()
+        }
+        if (mTimeOut != null && mHandler != null) {
+            mHandler!!.removeCallbacks(mTimeOut)
+        }
+        super.onDestroy()
+    }
+
+    /**
+     * Callback that is called when the first image is available after setting up
+     * ImageReader in onEventReceive(...) at the end of the video buffering.
+     *
+     *
+     * It takes the screenshot.
+     */
+    @TargetApi(19)
+    private inner class ImageAvailableListener : ImageReader.OnImageAvailableListener {
+        @TargetApi(21)
+        override fun onImageAvailable(reader: ImageReader) {
+            mHandler!!.postDelayed({
+                var outputStream: FileOutputStream? = null
+                var image: Image? = null
+                val bitmap: Bitmap?
+                try {
+                    image = mImageReader!!.acquireLatestImage()
+                } catch (e: IllegalArgumentException) {
+                    Log.e(TAG, "Failed to acquire latest image for screenshot.")
+                }
+
+                if (image != null) {
+                    val planes = image.planes
+                    val buffer = planes[0].buffer.rewind()
+                    val pixelStride = planes[0].pixelStride
+                    val rowStride = planes[0].rowStride
+                    val rowPadding = rowStride - pixelStride * mWidth
+
+                    bitmap = Bitmap.createBitmap(mWidth + rowPadding / pixelStride, mHeight,
+                            Bitmap.Config.ARGB_8888)
+                    if (bitmap != null) {
+                        bitmap.copyPixelsFromBuffer(buffer)
+                        val folder = File(screenshotDir)
+
+                        if (!folder.exists()) {
+                            if (!folder.mkdir()) {
+                                errorFinish("Failed to create screenshot directory")
+                            }
+                        }
+                        val imageFile = File(folder.absolutePath + File.separator + "Screenshot_" + mScreenshotNumber + ".png")
+                        mScreenshotNumber += 1
+                        try {
+                            outputStream = FileOutputStream(imageFile)
+                        } catch (e: IOException) {
+                            Log.e(TAG, "Failed to create outputStream")
+                        }
+
+                        if (outputStream != null) {
+                            bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
+                        }
+
+                        bitmap.recycle()
+                        image.close()
+                        if (outputStream != null) {
+                            try {
+                                outputStream.flush()
+                                outputStream.close()
+                            } catch (e: IOException) {
+                                Log.e(TAG, "Failed to release outputStream")
+                            }
+
+                        }
+                    }
+                }
+                try {
+                    mImageReader!!.setOnImageAvailableListener(null, null)
+                } catch (e: IllegalArgumentException) {
+                    Log.e(TAG, "Failed to delete ImageReader callback")
+                }
+
+                mVirtualDisplay!!.release()
+                mVirtualDisplay = null
+                mImageReader!!.close()
+                if (mScreenshotNumber < mTimestamp!!.size) {
+                    seekScreenshot()
+                } else {
+                    finish()
+                }
+            }, 1000)
+        }
+    }
+
+    companion object {
+
+        private const val EXTRA_TIMESTAMPS = "extra_benchmark_timestamps"
+        private const val EXTRA_ACTION_QUALITY = "extra_benchmark_action_quality"
+        private const val EXTRA_ACTION_PLAYBACK = "extra_benchmark_action_playback"
+        private const val EXTRA_SCREENSHOT_DIR = "extra_benchmark_screenshot_dir"
+        private const val EXTRA_ACTION = "extra_benchmark_action"
+        private const val EXTRA_HARDWARE = "extra_benchmark_disable_hardware"
+        val EXTRA_BENCHMARK = "extra_benchmark"
+
+        private const val TAG = "VLCBenchmark"
+        private const val REQUEST_SCREENSHOT = 666
+
+        private const val RESULT_FAILED = 6
+        private const val RESULT_NO_HW = 1
+
+        private const val VIRTUAL_DISPLAY_FLAGS = 0
+
+        private const val PERMISSION_REQUEST_WRITE = 1
+    }
+}
+
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/ShallowVideoPlayer.java b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/ShallowVideoPlayer.kt
similarity index 50%
rename from vlc-android/src/org/videolan/vlc/gui/video/benchmark/ShallowVideoPlayer.java
rename to vlc-android/src/org/videolan/vlc/gui/video/benchmark/ShallowVideoPlayer.kt
index b6889443b0..06dcc838f5 100644
--- a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/ShallowVideoPlayer.java
+++ b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/ShallowVideoPlayer.kt
@@ -1,6 +1,6 @@
 /*****************************************************************************
  * ShallowVideoPlayer.java
- *****************************************************************************
+ *
  * Copyright © 2011-2014 VLC authors and VideoLAN
  *
  * This program is free software; you can redistribute it and/or modify
@@ -16,52 +16,48 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
+ */
 
-package org.videolan.vlc.gui.video.benchmark;
+package org.videolan.vlc.gui.video.benchmark
 
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.View;
+import android.view.KeyEvent
+import android.view.MotionEvent
+import android.view.View
+import kotlinx.coroutines.ExperimentalCoroutinesApi
+import kotlinx.coroutines.ObsoleteCoroutinesApi
 
-import org.videolan.vlc.gui.video.VideoPlayerActivity;
+import org.videolan.vlc.gui.video.VideoPlayerActivity
 
 
 /**
  * Class to store the overriden methods in BenchActivity
  * for code readability
  */
-public class ShallowVideoPlayer extends VideoPlayerActivity {
-    @Override
-    public boolean onGenericMotionEvent(MotionEvent event) {
-        return true;
+@ExperimentalCoroutinesApi
+@ObsoleteCoroutinesApi
+open class ShallowVideoPlayer : VideoPlayerActivity() {
+    override fun onGenericMotionEvent(event: MotionEvent): Boolean {
+        return true
     }
 
-    @Override
-    public boolean onTrackballEvent(MotionEvent event) {
-        return true;
+    override fun onTrackballEvent(event: MotionEvent): Boolean {
+        return true
     }
 
-    @Override
-    public boolean dispatchGenericMotionEvent(MotionEvent event) {
-        return true;
+    override fun dispatchGenericMotionEvent(event: MotionEvent): Boolean {
+        return true
     }
 
-    @Override
-    public boolean onKeyDown(int keyCode, KeyEvent event) {
-        return true;
+    override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
+        return true
     }
 
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        return true;
+    override fun onTouchEvent(event: MotionEvent): Boolean {
+        return true
     }
 
-    @Override
-    public void onAudioSubClick(View anchor) {
-    }
 
-    @Override
-    public void onClick(View v) {
-    }
+    override fun onAudioSubClick(anchor: View?) {}
+
+    override fun onClick(v: View) {}
 }
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/StartActivityOnCrash.java b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/StartActivityOnCrash.java
deleted file mode 100644
index 08c31c243b..0000000000
--- a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/StartActivityOnCrash.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*****************************************************************************
- * StartActivityOnCrash.java
- *****************************************************************************
- * Copyright © 2011-2014 VLC authors and VideoLAN
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-package org.videolan.vlc.gui.video.benchmark;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.util.Log;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-
-public final class StartActivityOnCrash implements Thread.UncaughtExceptionHandler {
-
-    private static final String SHARED_PREFERENCE = "org.videolab.vlc.gui.video.benchmark.UNCAUGHT_EXCEPTIONS";
-    private static final String SHARED_PREFERENCE_STACK_TRACE = "org.videolab.vlc.gui.video.benchmark.STACK_TRACE";
-
-    private static final int MAX_STACK_TRACE_SIZE = 131071; //128 KB - 1
-
-    private SharedPreferences preferences;
-    private Activity context;
-
-    StartActivityOnCrash(Activity context) {
-        //noinspection deprecation
-        preferences = context.getSharedPreferences(SHARED_PREFERENCE, Context.MODE_WORLD_READABLE);
-        this.context = context;
-    }
-
-    @Override
-    public void uncaughtException(Thread thread, final Throwable throwable) {
-        String exceptionMessage = throwable.getMessage();
-
-        //see TransactionTooLargeException
-        if (exceptionMessage.length() > MAX_STACK_TRACE_SIZE)
-            exceptionMessage = exceptionMessage.substring(0, MAX_STACK_TRACE_SIZE - 3) + "...";
-
-        preferences.edit().putString(SHARED_PREFERENCE_STACK_TRACE, exceptionMessage).commit();
-        android.os.Process.killProcess(android.os.Process.myPid());
-        System.exit(10);
-    }
-
-    public static boolean setUp(Activity context) {
-        try {
-            Thread.setDefaultUncaughtExceptionHandler(new StartActivityOnCrash(context));
-        } catch (Exception e) {
-            return false;
-        }
-        return true;
-    }
-}
diff --git a/vlc-android/src/org/videolan/vlc/gui/video/benchmark/StartActivityOnCrash.kt b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/StartActivityOnCrash.kt
new file mode 100644
index 0000000000..60d8a78953
--- /dev/null
+++ b/vlc-android/src/org/videolan/vlc/gui/video/benchmark/StartActivityOnCrash.kt
@@ -0,0 +1,65 @@
+/*****************************************************************************
+ * StartActivityOnCrash.java
+ *
+ * Copyright © 2011-2014 VLC authors and VideoLAN
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ */
+
+package org.videolan.vlc.gui.video.benchmark
+
+import android.app.Activity
+import android.content.Context
+import android.content.SharedPreferences
+
+class StartActivityOnCrash internal constructor(private val context: Activity) : Thread.UncaughtExceptionHandler {
+
+    private val preferences: SharedPreferences
+
+    init {
+
+        preferences = context.getSharedPreferences(SHARED_PREFERENCE, Context.MODE_WORLD_READABLE)
+    }
+
+    override fun uncaughtException(thread: Thread, throwable: Throwable) {
+        var exceptionMessage = throwable.message
+
+        //see TransactionTooLargeException
+        if (exceptionMessage?.length ?: 0 > MAX_STACK_TRACE_SIZE)
+            exceptionMessage = exceptionMessage?.substring(0, MAX_STACK_TRACE_SIZE - 3) + "..."
+
+        preferences.edit().putString(SHARED_PREFERENCE_STACK_TRACE, exceptionMessage).commit()
+        android.os.Process.killProcess(android.os.Process.myPid())
+        System.exit(10)
+    }
+
+    companion object {
+
+        private const val SHARED_PREFERENCE = "org.videolab.vlc.gui.video.benchmark.UNCAUGHT_EXCEPTIONS"
+        private const val SHARED_PREFERENCE_STACK_TRACE = "org.videolab.vlc.gui.video.benchmark.STACK_TRACE"
+
+        private const val MAX_STACK_TRACE_SIZE = 131071 //128 KB - 1
+
+        fun setUp(context: Activity): Boolean {
+            try {
+                Thread.setDefaultUncaughtExceptionHandler(StartActivityOnCrash(context))
+            } catch (e: Exception) {
+                return false
+            }
+
+            return true
+        }
+    }
+}
