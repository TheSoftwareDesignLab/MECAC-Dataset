diff --git a/Mastodon/Scene/Profile/RemoteProfileViewModel.swift b/Mastodon/Scene/Profile/RemoteProfileViewModel.swift
index 1e1388c950..78575e5e4b 100644
--- a/Mastodon/Scene/Profile/RemoteProfileViewModel.swift
+++ b/Mastodon/Scene/Profile/RemoteProfileViewModel.swift
@@ -17,38 +17,42 @@ final class RemoteProfileViewModel: ProfileViewModel {
     init(context: AppContext, authContext: AuthContext, userID: Mastodon.Entity.Account.ID) {
         super.init(context: context, authContext: authContext, optionalMastodonUser: nil)
         
-        let domain = authContext.mastodonAuthenticationBox.domain
-        let authorization = authContext.mastodonAuthenticationBox.userAuthorization
-        Just(userID)
-            .asyncMap { userID in
-                try await context.apiService.accountInfo(
-                    domain: domain,
-                    userID: userID,
-                    authorization: authorization
-                )
-            }
-            .retry(3)
-            .sink { completion in
-                switch completion {
-                case .failure(let error):
-                    // TODO: handle error
-                    os_log(.info, log: .debug, "%{public}s[%{public}ld], %{public}s: remote user %s fetch failed: %s", ((#file as NSString).lastPathComponent), #line, #function, userID, error.localizedDescription)
-                case .finished:
-                    os_log(.info, log: .debug, "%{public}s[%{public}ld], %{public}s: remote user %s fetched", ((#file as NSString).lastPathComponent), #line, #function, userID)
+        Task { @MainActor in
+            let domain = authContext.mastodonAuthenticationBox.domain
+            let authorization = authContext.mastodonAuthenticationBox.userAuthorization
+            Just(userID)
+                .asyncMap { userID in
+                    try await context.apiService.accountInfo(
+                        domain: domain,
+                        userID: userID,
+                        authorization: authorization
+                    )
                 }
-            } receiveValue: { [weak self] response in
-                guard let self = self else { return }
-                let managedObjectContext = context.managedObjectContext
-                let request = MastodonUser.sortedFetchRequest
-                request.fetchLimit = 1
-                request.predicate = MastodonUser.predicate(domain: domain, id: response.value.id)
-                guard let mastodonUser = managedObjectContext.safeFetch(request).first else {
-                    assertionFailure()
-                    return
+                .retry(3)
+                .sink { completion in
+                    switch completion {
+                    case .failure(let error):
+                        // TODO: handle error
+                        os_log(.info, log: .debug, "%{public}s[%{public}ld], %{public}s: remote user %s fetch failed: %s", ((#file as NSString).lastPathComponent), #line, #function, userID, error.localizedDescription)
+                    case .finished:
+                        os_log(.info, log: .debug, "%{public}s[%{public}ld], %{public}s: remote user %s fetched", ((#file as NSString).lastPathComponent), #line, #function, userID)
+                    }
+                } receiveValue: { [weak self] response in
+                    guard let self = self else { return }
+                    let managedObjectContext = context.managedObjectContext
+                    let request = MastodonUser.sortedFetchRequest
+                    request.fetchLimit = 1
+                    request.predicate = MastodonUser.predicate(domain: domain, id: response.value.id)
+                    guard let mastodonUser = managedObjectContext.safeFetch(request).first else {
+                        assertionFailure()
+                        return
+                    }
+                    DispatchQueue.main.async {
+                        self.user = mastodonUser
+                    }
                 }
-                self.user = mastodonUser
-            }
-            .store(in: &disposeBag)
+                .store(in: &disposeBag)
+        }
     }
     
     init(context: AppContext, authContext: AuthContext, notificationID: Mastodon.Entity.Notification.ID) {
diff --git a/Mastodon/Scene/Thread/ThreadViewModel+LoadThreadState.swift b/Mastodon/Scene/Thread/ThreadViewModel+LoadThreadState.swift
index 1c6c40190a..96ea928db3 100644
--- a/Mastodon/Scene/Thread/ThreadViewModel+LoadThreadState.swift
+++ b/Mastodon/Scene/Thread/ThreadViewModel+LoadThreadState.swift
@@ -73,11 +73,12 @@ extension ThreadViewModel.LoadThreadState {
                 return
             }
             
-            Task {
+            Task { @MainActor in
                 do {
                     let response = try await viewModel.context.apiService.statusContext(
                         statusID: threadContext.statusID,
-                        authenticationBox: viewModel.authContext.mastodonAuthenticationBox
+                        authenticationBox: viewModel.authContext.mastodonAuthenticationBox,
+                        domain: threadContext.domain
                     )
                     
                     await enter(state: NoMore.self)
