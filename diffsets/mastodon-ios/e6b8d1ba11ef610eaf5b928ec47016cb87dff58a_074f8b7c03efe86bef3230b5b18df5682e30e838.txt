diff --git a/Mastodon.xcodeproj/project.pbxproj b/Mastodon.xcodeproj/project.pbxproj
index 7a13d7dad1..2da7c24dc0 100644
--- a/Mastodon.xcodeproj/project.pbxproj
+++ b/Mastodon.xcodeproj/project.pbxproj
@@ -512,6 +512,7 @@
 		FB7C4CCE2CD55DFF00F6129A /* NewDonationNavigationFlow.swift in Sources */ = {isa = PBXBuildFile; fileRef = FB7C4CCD2CD55DFE00F6129A /* NewDonationNavigationFlow.swift */; };
 		FB91184C2D9EB96E003F410B /* Bodega in Frameworks */ = {isa = PBXBuildFile; productRef = FB91184B2D9EB96E003F410B /* Bodega */; };
 		FB91188D2D9EECE7003F410B /* BodegaPersistence.swift in Sources */ = {isa = PBXBuildFile; fileRef = FB91188C2D9EC208003F410B /* BodegaPersistence.swift */; };
+		FBA2EA9B2E1C0CEA005ADEF0 /* MastoParse in Frameworks */ = {isa = PBXBuildFile; productRef = FBA2EA9A2E1C0CEA005ADEF0 /* MastoParse */; };
 		FBD689B52CCBF0AC00CE29F3 /* DonationCampaignViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = FBD689B42CCBF09F00CE29F3 /* DonationCampaignViewModel.swift */; };
 /* End PBXBuildFile section */
 
@@ -1346,6 +1347,7 @@
 			files = (
 				357FEEAF29523D470021C9DC /* MastodonSDKDynamic in Frameworks */,
 				DBF96326262EC0A6001D8D25 /* AuthenticationServices.framework in Frameworks */,
+				FBA2EA9B2E1C0CEA005ADEF0 /* MastoParse in Frameworks */,
 				FB91184C2D9EB96E003F410B /* Bodega in Frameworks */,
 				D84FA0932AE6915800987F47 /* MBProgressHUD in Frameworks */,
 				D87364F92AE28DB500C8F919 /* Kanna in Frameworks */,
@@ -3206,6 +3208,7 @@
 				D87364F82AE28DB500C8F919 /* Kanna */,
 				D84FA0922AE6915800987F47 /* MBProgressHUD */,
 				FB91184B2D9EB96E003F410B /* Bodega */,
+				FBA2EA9A2E1C0CEA005ADEF0 /* MastoParse */,
 			);
 			productName = Mastodon;
 			productReference = DB427DD225BAA00100D1B89D /* Mastodon.app */;
@@ -3392,6 +3395,7 @@
 				D87364F72AE28DB500C8F919 /* XCRemoteSwiftPackageReference "Kanna" */,
 				D84FA0912AE6915800987F47 /* XCRemoteSwiftPackageReference "MBProgressHUD" */,
 				FB91184A2D9EB96E003F410B /* XCRemoteSwiftPackageReference "Bodega" */,
+				FBA2EA992E1C0CEA005ADEF0 /* XCRemoteSwiftPackageReference "MastoParse" */,
 			);
 			productRefGroup = DB427DD325BAA00100D1B89D /* Products */;
 			projectDirPath = "";
@@ -5481,6 +5485,14 @@
 				minimumVersion = 2.1.3;
 			};
 		};
+		FBA2EA992E1C0CEA005ADEF0 /* XCRemoteSwiftPackageReference "MastoParse" */ = {
+			isa = XCRemoteSwiftPackageReference;
+			repositoryURL = "https://github.com/mastodon/MastoParse.git";
+			requirement = {
+				branch = main;
+				kind = branch;
+			};
+		};
 /* End XCRemoteSwiftPackageReference section */
 
 /* Begin XCSwiftPackageProductDependency section */
@@ -5532,6 +5544,11 @@
 			package = FB91184A2D9EB96E003F410B /* XCRemoteSwiftPackageReference "Bodega" */;
 			productName = Bodega;
 		};
+		FBA2EA9A2E1C0CEA005ADEF0 /* MastoParse */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = FBA2EA992E1C0CEA005ADEF0 /* XCRemoteSwiftPackageReference "MastoParse" */;
+			productName = MastoParse;
+		};
 /* End XCSwiftPackageProductDependency section */
 	};
 	rootObject = DB427DCA25BAA00100D1B89D /* Project object */;
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TextViewWithCustomEmoji.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TextViewWithCustomEmoji.swift
index 9a3ed53bc0..d8e45a6027 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TextViewWithCustomEmoji.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TextViewWithCustomEmoji.swift	
@@ -2,13 +2,13 @@
 
 import MastodonSDK
 import MastodonMeta
-import MetaTextKit
 import SwiftUI
+import MastoParse
 
 public enum TextViewWithCustomEmoji {
     public typealias Emojis = [Mastodon.Entity.Emoji]
     
-    case timelinePost(heightCacheID: String, html: String, emojis: Emojis, didSelect: (Meta?)->())
+    case timelinePost(heightCacheID: String, html: String, emojis: Emojis)
     case authorHeader(html: String, emojis: Emojis)
     case socialContextHeader(html: String, emojis: Emojis, isPrivate: Bool)
     case linkPreviewCardAuthorButton(html: String, emojis: Emojis)
@@ -17,18 +17,28 @@ public enum TextViewWithCustomEmoji {
 
 extension TextViewWithCustomEmoji: View {
     public var body: some View {
-        switch self {
-        case .timelinePost(let id, let html, let emojis, let didSelect):
-            MetaTextViewSwiftUI(id: id, html: html, emojis: emojis, format: .fullPost, didSelectMeta: didSelect)
-        case .authorHeader(let html, let emojis):
-            MetaTextViewSwiftUI(html: html, emojis: emojis, format: .authorHeader)
-        case .socialContextHeader(let html, let emojis, let isPrivate):
-            MetaTextViewSwiftUI(html: html, emojis: emojis, format: isPrivate ? .socialContextHeaderPrivate : .socialContextHeader)
-        case .linkPreviewCardAuthorButton(let html, let emojis):
-            MetaTextViewSwiftUI(html: html, emojis: emojis, format: .linkPreviewCardAuthor)
-        case .pollOption(let html, let emojis):
-            MetaTextViewSwiftUI(html: html, emojis: emojis, format: .pollOption)
-        }
+            switch self {
+            case .timelinePost(let id, let html, let emojis):
+                if let blocks = try? getParseBlocks(from: html) {
+                    TimelinePostContentView(contentBlocks: blocks)
+                }
+            case .authorHeader(let html, let emojis):
+                if let blocks = try? getParseBlocks(from: html) {
+                    TimelinePostContentView(contentBlocks: blocks)
+                }
+            case .socialContextHeader(let html, let emojis, let isPrivate):
+                    if let blocks = try? getParseBlocks(from: html) {
+                        TimelinePostContentView(contentBlocks: blocks)
+                    }
+            case .linkPreviewCardAuthorButton(let html, let emojis):
+                    if let blocks = try? getParseBlocks(from: html) {
+                        TimelinePostContentView(contentBlocks: blocks)
+                    }
+            case .pollOption(let html, let emojis):
+                    if let blocks = try? getParseBlocks(from: html) {
+                        TimelinePostContentView(contentBlocks: blocks)
+                    }
+            }
     }
 }
 
@@ -67,85 +77,124 @@ class CalculatedHeightCache {
     }
 }
 
-let heightCache = CalculatedHeightCache()
 
-struct MetaTextViewSwiftUI: UIViewRepresentable {
-    
-    let id: String?
-    let html: String
-    let emojis: [Mastodon.Entity.Emoji]
-    let format: MastodonHtmlFormat
-    let metaText: MetaText
-    let metaTapHandler: MetaTapHandler?
-    
-    init(id: String? = nil, html: String, emojis: [Mastodon.Entity.Emoji], format: MastodonHtmlFormat, didSelectMeta: ((Meta?)->())? = nil) {
-        self.id = id
-        self.html = html
-        self.emojis = emojis
-        self.format = format
-        self.metaText = format.metaText
-        if let didSelectMeta {
-            self.metaTapHandler = MetaTapHandler(onTap: didSelectMeta)
-        } else {
-            self.metaTapHandler = nil
-        }
-    }
+struct TimelinePostContentView: View {
+    let contentBlocks: [MastoParseContentBlock]
     
-    public func makeUIView(context: Context) -> MetaTextView {
-        let metaText = format.metaText
-        metaText.textView.setContentCompressionResistancePriority(.defaultHigh, for: .horizontal)
-        metaText.textView.setContentHuggingPriority(.defaultHigh, for: .horizontal)
-        metaText.textView.setContentHuggingPriority(.defaultHigh, for: .vertical)
-        
-        // Remove padding so that layout plays reasonably nicely with SwiftUI
-        metaText.textView.textContainerInset = .zero
-        metaText.textView.textContainer.lineFragmentPadding = 0
-        
-        // Disable scrolling and editing
-        metaText.textView.isEditable = false
-        metaText.textView.isScrollEnabled = false
-        
-        metaText.textView.linkDelegate = metaTapHandler
-        
-        return metaText.textView
-    }
-    
-    func updateUIView(_ uiView: MetaTextView, context: Context) {
-        let content = MastodonContent(content: html, emojis:  mapEmojiShortcodeToEmojis(emojis))
-        if let metaContent = try? MastodonMetaContent.convert(document: content) {
-            metaText.configure(content: metaContent)
-            uiView.attributedText = metaText.textView.attributedText
-            uiView.backgroundColor = .clear
+    var body: some View {
+        VStack(alignment: .leading) {
+            ForEach(contentBlocks) { block in
+                if let blockquote = block as? MastoParseBlockquote {
+                    BlockquoteView(block: blockquote)
+                } else if let row = block as? MastoParseContentRow {
+                    RowView(row: row)
+                } else {
+                    Text("CASE NOT HANDLED")
+                }
+            }
         }
     }
+}
+
+let indent: CGFloat = 16
+let nestedBlockQuoteIndicatorWidth: CGFloat = 2
+let indicatorToBlockQuoteSpacing: CGFloat = 4
+
+let blockquoteColor = Color.purple.opacity(0.5)
+struct BlockquoteView: View {
+    let block: MastoParseBlockquote
     
-    func sizeThatFits(_ proposal: ProposedViewSize, uiView: MetaTextView, context: Context) -> CGSize? {
-        guard let width = proposal.width else { return nil }
-        if let id, let cachedHeight = heightCache.cachedHeight(for: id, withProposedWidth: width) {
-            return CGSize(width: width, height: cachedHeight)
-        } else {
-            let size = uiView.sizeThatFits(.init(width: width, height: proposal.height ?? .infinity))
-            guard size.width > 0, size.width < .greatestFiniteMagnitude, size.height > 0, size.height < .greatestFiniteMagnitude else { return .zero }
-            if let id {
-                heightCache.cache(height: size.height, forProposedWidth: width, forID: id)
+    var body: some View {
+        HStack {
+            VStack {
+                Image(systemName: "quote.opening")
+                    .font(.title)
+                    .fontWeight(.bold)
+                    .foregroundStyle(blockquoteColor)
+                
+                Spacer()
+            }
+            VStack(alignment: .leading, spacing: 0) {
+                ForEach(Array(block.contents.enumerated()), id: \.offset) { idx, element in
+                    RowView(row: element)
+                }
             }
-            return size
         }
     }
 }
 
-class MetaTapHandler: MetaTextViewDelegate {
-    let onTap: (Meta?)->()
+enum TextElement {
+    case image(Image)
+    case text(LocalizedStringKey)
+    case code(String)
+}
+
+struct RowView: View {
+    static let font: Font.TextStyle = .body
+    @ScaledMetric(relativeTo: font) private var imgBaseline: CGFloat = -5 // without this, the custom emoji sit too high amidst the surrounding text
     
-    init(onTap: @escaping (Meta?) -> Void) {
-        self.onTap = onTap
-    }
+    let row: MastoParseContentRow
     
-    func metaTextView(_ metaTextView: MetaTextKit.MetaTextView, didSelectMeta meta: Meta) {
-        onTap(meta)
+    var body: some View {
+        let totalFormattingSpaceRequired = row.nestedFormatting.reduce(into: CGFloat.zero) { partialResult, format in
+            switch format {
+            case .listLevel:
+                partialResult += indent
+            case .subordinateBlockquote:
+                partialResult += nestedBlockQuoteIndicatorWidth + indicatorToBlockQuoteSpacing
+            case .topLevelBlockquote:
+                break
+            }
+        }
+        
+        combineElements(row.contents.map({ element in
+            switch element.type {
+            case .text:
+                return .text(LocalizedStringKey(element.contents))
+            case .code:
+                return .code(element.contents)
+            }
+            
+        }))
+        .padding(EdgeInsets(top: 0, leading: totalFormattingSpaceRequired, bottom: 0, trailing: 0))
+        .background() {
+            // Putting the nested blockquote bar in a background correctly expands its height to match the contents of the row. Trying to include it in the same HStack as the content leaves the bar too short.
+            HStack(spacing: 0) {
+                ForEach(Array(row.nestedFormatting.enumerated()), id: \.offset) { idx, indicator in
+                    switch indicator {
+                    case .topLevelBlockquote:
+                        EmptyView()
+                    case .subordinateBlockquote:
+                        blockquoteColor
+                            .frame(width: nestedBlockQuoteIndicatorWidth)
+                        Spacer()
+                            .frame(maxWidth: indicatorToBlockQuoteSpacing)
+                    case .listLevel:
+                        Spacer()
+                            .frame(width: indent)
+                    }
+                }
+                Spacer()
+                    .frame(maxWidth: .infinity)
+            }
+        }
     }
     
-    func metaTextViewDidTapNonEntity(_ metaTextView: MetaTextKit.MetaTextView) {
-        onTap(nil)
+    @ViewBuilder func combineElements(_ elements: [TextElement]) -> some View {
+        let pieces = elements.map { element in
+            switch element {
+            case .image(let image):
+                return Text("\(image)").baselineOffset(imgBaseline)
+            case .text(let text):
+                return Text(text)
+            case .code(let text):
+                var attributed = AttributedString(text)
+                attributed.backgroundColor = blockquoteColor
+                attributed.font = .system(.body, design: .monospaced)
+                return Text(attributed)
+            }
+        }
+        pieces.reduce(Text(""), +)
+            .fixedSize(horizontal: false, vertical: true)
     }
 }
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/HomeTimelineListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/HomeTimelineListViewController.swift
index 89de927319..11181d105a 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/HomeTimelineListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/HomeTimelineListViewController.swift	
@@ -1168,15 +1168,15 @@ fileprivate extension MastodonPostViewModel {
     }
 
     func textContentView() -> TextViewWithCustomEmoji {
-        let emptyTextContent: TextViewWithCustomEmoji = .timelinePost(heightCacheID: "empty", html: "", emojis: TextViewWithCustomEmoji.Emojis(), didSelect: { [weak self] meta in self?.didSelect(meta: meta) })
+        let emptyTextContent: TextViewWithCustomEmoji = .timelinePost(heightCacheID: "empty", html: "", emojis: TextViewWithCustomEmoji.Emojis())
         
         guard let actionablePost = fullPost?.actionablePost, let untranslatedContent = actionablePost.content.htmlWithEntities?.html else { return emptyTextContent }
         let emojis = actionablePost.content.htmlWithEntities?.emojis ?? TextViewWithCustomEmoji.Emojis()
         
         if isShowingTranslation == true, let translation = actionHandler?.translation(forContentPostId: actionablePost.id)?.content {
-            return .timelinePost(heightCacheID: actionablePost.id+"translated", html: translation, emojis: emojis, didSelect: { [weak self] meta in self?.didSelect(meta: meta) })
+            return .timelinePost(heightCacheID: actionablePost.id+"translated", html: translation, emojis: emojis)
         } else {
-            return .timelinePost(heightCacheID: actionablePost.id, html: untranslatedContent, emojis: emojis, didSelect: { [weak self] meta in self?.didSelect(meta: meta) })
+            return .timelinePost(heightCacheID: actionablePost.id, html: untranslatedContent, emojis: emojis)
         }
     }
 
