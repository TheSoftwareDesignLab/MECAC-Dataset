diff --git a/Mastodon.xcodeproj/project.pbxproj b/Mastodon.xcodeproj/project.pbxproj
index 3de3873204..f91253c748 100644
--- a/Mastodon.xcodeproj/project.pbxproj
+++ b/Mastodon.xcodeproj/project.pbxproj
@@ -1218,6 +1218,8 @@
 				Notifications/InlinePostPreview.swift,
 				Notifications/NotificationInfo.swift,
 				Notifications/NotificationsCacheManager.swift,
+				Timeline/CentralPostViewModelCache.swift,
+				Timeline/PrecalculatedRowHeights.swift,
 				Timeline/ThreadedConversationModel.swift,
 				Timeline/TimelineFeedLoader.swift,
 				Timeline/TimelineListViewController.swift,
diff --git a/Mastodon/BodegaPersistence.swift b/Mastodon/BodegaPersistence.swift
index 2a9d35f1cb..f81e152450 100644
--- a/Mastodon/BodegaPersistence.swift
+++ b/Mastodon/BodegaPersistence.swift
@@ -46,11 +46,10 @@ public actor BodegaPersistence {
             let timeline: [TimelineItem] = cached.compactMap {
                 switch $0 {
                 case .cachedPost(let info):
-                    let viewModel = MastodonPostViewModel(info, filterContext: .home, threadedConversationContext: nil)
+                    let viewModel = MastodonPostViewModel(info)
                     return .post(viewModel)
                 case .missingPosts(let newerThan, let olderThan):
                     return nil // loading results missing from the middle of a feed is no longer supported
-                    break
                 }
             }
             return timeline
@@ -148,7 +147,7 @@ extension BodegaPersistence {
         var posts = [(CacheKey, Mastodon.Entity.Status)]()
         for item in timeline {
             switch item {
-            case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .account:
+            case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .account, .noItem:
                 break
             case .post(let viewModel):
                 if let fullPost = await viewModel.fullPost {
@@ -168,7 +167,7 @@ extension BodegaPersistence {
             switch item {
             case .post(let viewModel):
                 return .cachedPost(viewModel.initialDisplayInfo)
-            case .loadingIndicator, .filteredNotificationsInfo, .account, .hashtag:
+            case .loadingIndicator, .filteredNotificationsInfo, .account, .hashtag, .noItem:
                 return nil
             case .notification:
                 // TODO: cache notifications? or give up on all caching?
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift
index cd3952adb4..663a23005a 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift	
@@ -111,9 +111,9 @@ struct FrameReader: UIViewRepresentable {
 }
 
 struct VisibilityTrackingView: View {
-    let visibilityDidChange: (Bool)->()
     let scrollCoordinateSpace: String
     let visibleAreaHeight: CGFloat
+    let visibilityDidChange: (Bool)->()
     
     @State var isVisible: Bool = false
     
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonTimelineOverlayView/BoostOrQuoteDialog.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonTimelineOverlayView/BoostOrQuoteDialog.swift
index 900516e859..3f45fa954a 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonTimelineOverlayView/BoostOrQuoteDialog.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonTimelineOverlayView/BoostOrQuoteDialog.swift	
@@ -7,6 +7,7 @@ import MastodonCore
 
 struct BoostOrQuoteDialog: View {
     @Environment(MastodonPostViewModel.self) var viewModel
+    let actionHandler: MastodonPostMenuActionHandler?
     
     var body: some View {
         if let actionablePost = viewModel.fullPost?.actionablePost {
@@ -17,7 +18,7 @@ struct BoostOrQuoteDialog: View {
                 VStack(spacing: 0) {
                     if actionablePost.content.myActions.boosted {
                         Button {
-                            viewModel.actionHandler?.doAction(.unboost, forPost: viewModel)
+                            actionHandler?.doAction(.unboost, forPost: viewModel)
                         } label: {
                             Text(L10n.Common.Alerts.BoostAPost.unboost)
                                 .padding()
@@ -25,7 +26,7 @@ struct BoostOrQuoteDialog: View {
                         .foregroundStyle(Asset.Colors.accent.swiftUIColor)
                     } else {
                         Button {
-                            viewModel.actionHandler?.doAction(.boost, forPost: viewModel)
+                            actionHandler?.doAction(.boost, forPost: viewModel)
                         } label: {
                             Text(L10n.Common.Alerts.BoostAPost.boost)
                                 .padding()
@@ -40,7 +41,7 @@ struct BoostOrQuoteDialog: View {
                     if let buttonTitle = quoteButtonInfo.title {
                         Button {
                             guard let composeViewModel = viewModel.composeViewModelQuotingThisPost else { return }
-                            viewModel.actionHandler?.presentScene(.compose(viewModel: composeViewModel), fromPost: nil, transition: .modal(animated: true, completion: nil))
+                            actionHandler?.presentScene(.compose(viewModel: composeViewModel), fromPost: nil, transition: .modal(animated: true, completion: nil))
                         } label: {
                             VStack {
                                 Text(buttonTitle)
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostRowView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostRowView.swift
index d63f0bf74c..a05b05084f 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostRowView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostRowView.swift	
@@ -12,6 +12,10 @@ struct MastodonPostRowView: View {
     @Environment(ContentConcealViewModel.self) private var contentConcealModel
 
     let contentWidth: CGFloat
+    let precalculatedHeight: CGFloat?
+    let actionHandler: MastodonPostMenuActionHandler?
+    let threadedContext: ThreadedConversationModel.ThreadContext?
+    let filterContext: Mastodon.Entity.FilterContext?
     
     let distanceFromAvatarLeadingEdgeToContentLeadingEdge: CGFloat = spacingBetweenGutterAndContent + AvatarSize.large
     
@@ -21,7 +25,7 @@ struct MastodonPostRowView: View {
         let instanceCanQuotePosts = AuthenticationServiceProvider.shared.currentActiveUser.value?.authentication.instanceConfiguration?.isAvailable(.quotePosts) ?? false
         
         VStack(alignment: .gutterAlign, spacing: 0) {  // gutterAlign keeps the content and social context headers properly aligned with the gap between avatar and content
-            if let threadedContext = viewModel.threadedContext {
+            if let threadedContext {
                 // MARK: Conversation thread line decoration
                 ZStack(alignment: Alignment(horizontal: .gutterAlign, vertical: .center)) {
                     if threadedContext.drawsLineAbove {
@@ -38,7 +42,7 @@ struct MastodonPostRowView: View {
                     VStack(spacing: 0) {
                         Spacer()
                             .frame(height: standardPadding)
-                        viewModel.socialContextHeader
+                        viewModel.socialContextHeader(inThreadContext: threadedContext, getAccount: { accountID in actionHandler?.account(accountID) })
                             .frame(maxWidth: contentWidth, alignment: .leading)
                     }
                 }
@@ -48,7 +52,7 @@ struct MastodonPostRowView: View {
                 VStack(spacing: 0) {
                     Spacer()
                         .frame(height: standardPadding)
-                    viewModel.socialContextHeader
+                    viewModel.socialContextHeader(inThreadContext: threadedContext, getAccount: { accountID in actionHandler?.account(accountID) })
                         .frame(maxWidth: contentWidth, alignment: .leading)
                 }
                 .accessibilityHidden(true)
@@ -60,38 +64,56 @@ struct MastodonPostRowView: View {
                     AvatarView(size: .large, authorAvatarUrl: author?.avatarURL ?? viewModel.initialDisplayInfo.actionableAuthorStaticAvatar, goToProfile: {
                         goToProfile(author)
                     })
-                    if let threadedContext = viewModel.threadedContext, threadedContext.drawsLineBelow {
+                    if let threadedContext, threadedContext.drawsLineBelow {
+                        let lowerThreadDecorationHeight: CGFloat? = {
+                            if let precalculatedHeight {
+                                return precalculatedHeight - standardPadding - AvatarSize.large
+                            } else {
+                                return nil
+                            }
+                        }()
                         threadingDecoration(withSpacerAtTop: !threadedContext.isContiguous, withSpacerAtBottom: false)
-                            .frame(width: AvatarSize.large)
+                            .frame(width: AvatarSize.large, height: lowerThreadDecorationHeight)
                     }
                 }
                 .accessibilityHidden(true)
                 
                 VStack(alignment: .leading, spacing: spacingBetweenGutterAndContent) {
                     // MARK: Author info
-                    AuthorHeaderView()
+                    AuthorHeaderView(threadedContext: threadedContext, getAccount: { accountID in actionHandler?.account(accountID) })
                         .onTapGesture {
                             goToProfile(author)
                         }
+#if DEBUG
+                    Text(viewModel.initialDisplayInfo.id)
+                        .font(.footnote)
+                        .border(.red)
+                    if viewModel.initialDisplayInfo.id != viewModel.initialDisplayInfo.actionablePostID {
+                        Text("actionable: \(viewModel.initialDisplayInfo.actionablePostID)")
+                            .font(.footnote)
+                            .border(.red)
+                    }
+#endif
                    
                     // MARK: Content warned and/or filtered
                     contentConcealLozenge
                         .frame(width: contentWidth)
                         .fixedSize(horizontal: false, vertical: true)
                     
-                    if contentConcealModel.currentMode.isShowingContent, let actionHandler = viewModel.actionHandler {
-                        if viewModel.isShowingTranslation == true, let translatablePost = viewModel.fullPost?.actionablePost, let translation = actionHandler.translation(forContentPostId: translatablePost.id) {
+                    if contentConcealModel.currentMode.isShowingContent {
+                        if viewModel.isShowingTranslation == true, let translatablePost = viewModel.fullPost?.actionablePost, let translation = actionHandler?.translation(forContentPostId: translatablePost.id) {
                             // MARK: Translation info line
-                            TranslationInfoView(translationInfo: translation, showOriginal: { actionHandler.doAction(.showOriginalLanguage, forPost: viewModel) }
+                            TranslationInfoView(translationInfo: translation, showOriginal: { actionHandler?.doAction(.showOriginalLanguage, forPost: viewModel) }
                             )
                             .frame(width: contentWidth, alignment: .leading)
                         }
                         
                         // MARK: Text content
-                        viewModel.textContentView(isInlinePreview: false)
+                        viewModel.textContentView(isInlinePreview: false, actionHandler: actionHandler)
                             .frame(width: contentWidth, alignment: .leading)
                             .environment(\.openURL, OpenURLAction { url in
-                                if viewModel.openURL(url) {
+                                guard let actionHandler else { return .systemAction(url) }
+                                if viewModel.openURL(url, actionHandler: actionHandler) {
                                     return .handled
                                 } else {
                                     return .systemAction(url)
@@ -111,7 +133,7 @@ struct MastodonPostRowView: View {
                                     .frame(width: contentWidth)
                             case .linkPreviewCard(let card):
                                 LinkPreviewCard(cardEntity: card, fittingWidth: contentWidth, navigateToScene: { (scene, transition) in
-                                    actionHandler.presentScene(scene, fromPost: viewModel.initialDisplayInfo.id, transition: transition)
+                                    actionHandler?.presentScene(scene, fromPost: viewModel.initialDisplayInfo.id, transition: transition)
                                 })
                                 .frame(width: contentWidth)
                             }
@@ -119,14 +141,15 @@ struct MastodonPostRowView: View {
                         
                         // MARK: Quoted post
                         if let quotedPostViewModel = viewModel.fullQuotedPostViewModel {
-                            if quotedPostViewModel.initialDisplayInfo.shouldFilterOut {
+                            if let filterContext, quotedPostViewModel.initialDisplayInfo.filterOutInContexts.contains(filterContext) {
                                 QuotedPostHiddenByFilterView()
                             } else {
-                                EmbeddedPostView(layoutWidth: contentWidth, isSummary: false)
+                                EmbeddedPostView(layoutWidth: contentWidth, isSummary: false, actionHandler: actionHandler)
                                     .environment(quotedPostViewModel)
                                     .environment(contentConcealModel.nestedContentConcealModel ?? .alwaysShow)
                                     .onTapGesture {
-                                        quotedPostViewModel.openThreadView()
+                                        guard let actionHandler else { return }
+                                        quotedPostViewModel.openThreadView(actionHandler: actionHandler)
                                     }
                             }
                         } else if let quotePlaceholder = viewModel.placeholderQuotedPost {
@@ -150,14 +173,14 @@ struct MastodonPostRowView: View {
                     if let actionablePost = viewModel.fullPost?.actionablePost {
                         Spacer()
                             .frame(height: 0)  // gives double spacing between bottom of post content and action bar
-                        ActionBar(instanceCanQuotePosts: instanceCanQuotePosts)
+                        ActionBar(instanceCanQuotePosts: instanceCanQuotePosts, actionHandler: actionHandler)
                             .frame(width: contentWidth, alignment: .leading)
                             .accessibilityElement(children: .ignore)
                             .accessibilityLabel(viewModel.accessibilityActionBarLabel)
                     }
                     
                     // MARK: Thread view extra info for focused post
-                    switch viewModel.threadedContext {
+                    switch threadedContext {
                     case .focused:
                         threadFocusDetailFooter
                     default:
@@ -185,11 +208,11 @@ struct MastodonPostRowView: View {
                     }
                 }
                 ForEach(MastodonPostMenuAction.authorA11yMenuItems(forPostBy: relationshipToAuthor, isQuotingMe: viewModel.isQuotingMe, isShowingTranslation: viewModel.isShowingTranslation), id: \.self.id) { action in
-                    viewModel.accessibilityActionButton(action)
+                    viewModel.accessibilityActionButton(action, actionHandler: actionHandler)
                 }
                 
                 // REPLY
-                viewModel.accessibilityActionButton(.reply)
+                viewModel.accessibilityActionButton(.reply, actionHandler: actionHandler)
                 
                 // QUOTE
                 if instanceCanQuotePosts {
@@ -198,14 +221,14 @@ struct MastodonPostRowView: View {
                     Button(fullTitle) {
                         if isEnabled {
                             guard let composeViewModel = viewModel.composeViewModelQuotingThisPost else { return }
-                            viewModel.actionHandler?.presentScene(.compose(viewModel: composeViewModel), fromPost: nil, transition: .modal(animated: true, completion: nil))
+                            actionHandler?.presentScene(.compose(viewModel: composeViewModel), fromPost: nil, transition: .modal(animated: true, completion: nil))
                         }
                     }
                 }
                 
                 // POST ACTIONS
                 ForEach(MastodonPostMenuAction.postA11yMenuItemsOtherThanReply(forPostBy: relationshipToAuthor, myActions: viewModel.fullPost?.actionablePost?.content.myActions, isShowingTranslation: viewModel.isShowingTranslation), id: \.self.id) { action in
-                    viewModel.accessibilityActionButton(action)
+                    viewModel.accessibilityActionButton(action, actionHandler: actionHandler)
                 }
             }
         }
@@ -213,16 +236,16 @@ struct MastodonPostRowView: View {
     
     func goToProfile(_ account: MastodonAccount?) {
         guard let account else { return }
-        viewModel.goToProfile(account)
+        viewModel.goToProfile(account, actionHandler: actionHandler)
     }
 }
 
 extension MastodonPostViewModel {
-    var a11yHeaderLabel: String {
+    func a11yHeaderLabel(inThreadedContext threadedContext: ThreadedConversationModel.ThreadContext?, getAccount: (Mastodon.Entity.Account.ID)->(MastodonAccount?)) -> String {
         let visibilityString = initialDisplayInfo.actionableVisibility.a11yLabel
         let dateString = initialDisplayInfo.actionableCreatedAt.localizedShortTimeAgo(since: .now)
         let authorString = "\(visibilityString) post from \(initialDisplayInfo.actionableAuthorDisplayName)" + ", \(dateString)"
-        if let socialContext {
+        if let socialContext = socialContext(inThreadContext: threadedContext, getAccount: getAccount) {
             switch socialContext {
             case .boosted(let author, _):
                 return "\(authorString), boosted by \(author)"
@@ -302,7 +325,7 @@ extension MastodonPostRowView {
                                 do {
                                     let edits = try await APIService.shared.getHistory(forStatusID: fullPost.id, authenticationBox: authBox).value
                                     let editsViewModel = StatusEditHistoryViewModel(status: fullPost._legacyEntity, edits: edits, appContext: AppContext.shared, authenticationBox: authBox)
-                                    viewModel.actionHandler?.presentScene(.editHistory(viewModel: editsViewModel), fromPost: nil, transition: .show)
+                                    actionHandler?.presentScene(.editHistory(viewModel: editsViewModel), fromPost: nil, transition: .show)
                                 } catch {
                                 }
                             }
@@ -328,7 +351,7 @@ extension MastodonPostRowView {
                                 authenticationBox: authBox,
                                 kind: .rebloggedBy(status: MastodonStatus(entity: fullPost._legacyEntity, showDespiteContentWarning: false))
                             )
-                            viewModel.actionHandler?.presentScene(.rebloggedBy(viewModel: userListViewModel), fromPost: nil, transition: .show)
+                            actionHandler?.presentScene(.rebloggedBy(viewModel: userListViewModel), fromPost: nil, transition: .show)
                         } label: {
                             HStack {
                                 Text(L10n.Plural.Count.reblog(boostCount))
@@ -346,7 +369,7 @@ extension MastodonPostRowView {
                                 authenticationBox: authBox,
                                 kind: .favoritedBy(status: MastodonStatus(entity: fullPost._legacyEntity, showDespiteContentWarning: false))
                             )
-                            viewModel.actionHandler?.presentScene(.favoritedBy(viewModel: userListViewModel), fromPost: nil, transition: .show)
+                            actionHandler?.presentScene(.favoritedBy(viewModel: userListViewModel), fromPost: nil, transition: .show)
                         } label: {
                             HStack {
                                 Text(L10n.Plural.Count.favorite(favoriteCount))
@@ -382,6 +405,7 @@ private struct ActionBar: View {
     
     @Environment(MastodonPostViewModel.self) private var viewModel
     let instanceCanQuotePosts: Bool
+    let actionHandler: MastodonPostMenuActionHandler?
     
     var anyButtonHasNonZeroCount: Bool {
         guard let metrics = viewModel.fullPost?.actionablePost?.content.metrics else { return false }
@@ -400,7 +424,7 @@ private struct ActionBar: View {
                     Spacer()
                     actionButton(forPost: actionablePost, action: .bookmark, layout: .adaptive)
                     Spacer()
-                    ActionBarMenuButton(instanceCanQuotePosts: instanceCanQuotePosts)
+                    ActionBarMenuButton(instanceCanQuotePosts: instanceCanQuotePosts, actionHandler: actionHandler)
                 }
             }
             
@@ -414,7 +438,7 @@ private struct ActionBar: View {
                     Spacer()
                     actionButton(forPost: actionablePost, action: .bookmark, layout: .forceSmall)
                     Spacer()
-                    ActionBarMenuButton(instanceCanQuotePosts: instanceCanQuotePosts)
+                    ActionBarMenuButton(instanceCanQuotePosts: instanceCanQuotePosts, actionHandler: actionHandler)
                 }
             }
         }
@@ -423,6 +447,7 @@ private struct ActionBar: View {
     struct ActionBarMenuButton: View {
         @Environment(MastodonPostViewModel.self) private var viewModel
         let instanceCanQuotePosts: Bool
+        let actionHandler: MastodonPostMenuActionHandler?
         
         var body: some View {
             Menu {
@@ -431,8 +456,7 @@ private struct ActionBar: View {
                         ForEach(submenu.items, id: \.self) { menuAction in
                             if let actionablePost = viewModel.fullPost?.actionablePost {
                                 Button(role: menuAction.isDestructive ? .destructive : nil) {
-                                    
-                                    viewModel.actionHandler?.doAction(menuAction, forPost: viewModel)
+                                    actionHandler?.doAction(menuAction, forPost: viewModel)
                                 }
                                 label: {
                                     Label(menuAction.labelText(username: actionablePost.metaData.author.displayInfo.displayName, postLanguage: actionablePost.content.language), systemImage: menuAction.iconSystemName)
@@ -477,7 +501,7 @@ private struct ActionBar: View {
         switch action {
         case .reply:
             StatefulCountedActionButton(type: .reply, layoutSize: layout, showCountLabel: showCountLabel, actionState: .init(count: metrics.replyCount, isSelected: .isFalse), doAction: {
-                viewModel.actionHandler?.doAction(.reply, forPost: viewModel)
+                actionHandler?.doAction(.reply, forPost: viewModel)
             })
         case .boost:
             let state = overrideState ?? AsyncBool.fromBool(myActions.boosted)
@@ -494,12 +518,12 @@ private struct ActionBar: View {
             StatefulCountedActionButton(type: .boost, layoutSize: layout, showCountLabel: showCountLabel, actionState: .init(count: metrics.boostCount, isSelected: state), doAction: {
                 guard actionablePost.isBoostable else { return }
                 if instanceCanQuotePosts {
-                    viewModel.actionHandler?.showSheet(.boostOrQuoteDialog(viewModel))
+                    actionHandler?.showSheet(.boostOrQuoteDialog(viewModel))
                 } else {
                     if iHaveBoosted {
-                        viewModel.actionHandler?.doAction(.unboost, forPost: viewModel)
+                        actionHandler?.doAction(.unboost, forPost: viewModel)
                     } else {
-                        viewModel.actionHandler?.doAction(.boost, forPost: viewModel)
+                        actionHandler?.doAction(.boost, forPost: viewModel)
                     }
                 }
             })
@@ -509,9 +533,9 @@ private struct ActionBar: View {
             StatefulCountedActionButton(type: .favourite, layoutSize: layout, showCountLabel: showCountLabel, actionState: .init(count: metrics.favoriteCount, isSelected: state), doAction: {
                 switch state {
                 case .isFalse:
-                    viewModel.actionHandler?.doAction(.favourite, forPost: viewModel)
+                    actionHandler?.doAction(.favourite, forPost: viewModel)
                 case .isTrue:
-                    viewModel.actionHandler?.doAction(.unfavourite, forPost: viewModel)
+                    actionHandler?.doAction(.unfavourite, forPost: viewModel)
                 default:
                     break
                 }
@@ -521,9 +545,9 @@ private struct ActionBar: View {
             StatefulCountedActionButton(type: .bookmark, layoutSize: layout, showCountLabel: showCountLabel, actionState: .init(count: nil, isSelected: state), doAction: {
                 switch state {
                 case .isFalse:
-                    viewModel.actionHandler?.doAction(.bookmark, forPost: viewModel)
+                    actionHandler?.doAction(.bookmark, forPost: viewModel)
                 case .isTrue:
-                    viewModel.actionHandler?.doAction(.unbookmark, forPost: viewModel)
+                    actionHandler?.doAction(.unbookmark, forPost: viewModel)
                 default:
                     break
                 }
@@ -575,7 +599,7 @@ extension MastodonContentPost {
     
     @MainActor
     var isBoostable: Bool {
-        let info = self.initialDisplayInfo(inContext: nil)
+        let info = self.initialDisplayInfo()
         switch info.actionableVisibility {
         case .mentionedOnly:
             return false
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostViewModel.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostViewModel.swift
index 6ea38877eb..d08a5e624c 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostViewModel.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/MastodonPostViewModel.swift	
@@ -5,10 +5,21 @@ import MastodonSDK
 import MastodonCore
 import MastodonLocalization
 
+struct PrecalculatedHeight {
+    let contentWidth: CGFloat
+    let contentConcealed: ContentConcealViewModel.ContentDisplayMode
+    let showingTranslation: Bool
+    let calculatedHeight: CGFloat
+}
+
 @MainActor
 @Observable class MastodonPostViewModel {
     
-    let threadedContext: ThreadedConversationModel.ThreadContext?
+    var precalculatedHeights = [PrecalculatedHeight]()
+    
+#if DEBUG
+    var actualLayoutHeight: CGFloat?
+#endif
     
     var fullQuotedPostViewModel: MastodonPostViewModel?
     var placeholderQuotedPost: MastodonQuotedPost?
@@ -30,8 +41,7 @@ import MastodonLocalization
     func deriveNewQuotedPostViewModel() {
         if let potentialQuotePost = fullPost?.actionablePost as? MastodonBasicPost {
             if let quoted = potentialQuotePost.quotedPost, let quotedFullPost = quoted.fullPost {
-                let updated = MastodonPostViewModel(quotedFullPost.initialDisplayInfo(inContext: filterContext), fullPost: quotedFullPost, filterContext: filterContext, threadedConversationContext: nil)
-                updated.actionHandler = actionHandler
+                let updated = MastodonPostViewModel(quotedFullPost.initialDisplayInfo(), fullPost: quotedFullPost)
                 self.fullQuotedPostViewModel = updated
                 placeholderQuotedPost = nil
             } else {
@@ -59,12 +69,6 @@ import MastodonLocalization
     var isShowingTranslation: Bool? = nil
     var isDoingAction: MastodonPostMenuAction? = nil
     
-    var actionHandler: MastodonPostMenuActionHandler? = nil {
-        didSet {
-            fullQuotedPostViewModel?.actionHandler = actionHandler
-        }
-    }
-    let filterContext: Mastodon.Entity.FilterContext?
     
     private(set) var translation: Mastodon.Entity.Translation? = nil
     
@@ -88,17 +92,13 @@ import MastodonLocalization
     }
     
     nonisolated
-    init(_ initialDisplay: GenericMastodonPost.InitialDisplayInfo, filterContext: Mastodon.Entity.FilterContext?, threadedConversationContext: ThreadedConversationModel.ThreadContext?) {
+    init(_ initialDisplay: GenericMastodonPost.InitialDisplayInfo) {
         self.initialDisplayInfo = initialDisplay
-        self.filterContext = filterContext
-        self.threadedContext = threadedConversationContext
     }
     
-    private init(_ initialDisplay: GenericMastodonPost.InitialDisplayInfo, fullPost: GenericMastodonPost? = nil, isShowingTranslation: Bool? = nil, isDoingAction: MastodonPostMenuAction? = nil, myRelationshipToAuthor: MastodonAccount.Relationship? = nil, actionHandler: MastodonPostMenuActionHandler? = nil, translation: Mastodon.Entity.Translation? = nil, filterContext: Mastodon.Entity.FilterContext?, threadedConversationContext: ThreadedConversationModel.ThreadContext?) {
+    private init(_ initialDisplay: GenericMastodonPost.InitialDisplayInfo, fullPost: GenericMastodonPost? = nil, isShowingTranslation: Bool? = nil, isDoingAction: MastodonPostMenuAction? = nil, myRelationshipToAuthor: MastodonAccount.Relationship? = nil, actionHandler: MastodonPostMenuActionHandler? = nil, translation: Mastodon.Entity.Translation? = nil) {
         self.initialDisplayInfo = initialDisplay
         self.fullPost = fullPost
-        self.filterContext = filterContext
-        self.threadedContext = threadedConversationContext
         self.deriveNewQuotedPostViewModel()
     }
     
@@ -123,9 +123,9 @@ import MastodonLocalization
         return pollTranslation.options.map { $0.title }
     }
     
-    func openThreadView() {
+    func openThreadView(actionHandler: MastodonPostMenuActionHandler) {
         guard let actionablePost = fullPost?.actionablePost, let currentUser = AuthenticationServiceProvider.shared.currentActiveUser.value else { return }
-        actionHandler?.presentScene(
+        actionHandler.presentScene(
             .thread(
                 viewModel: ThreadViewModel(
                     authenticationBox: currentUser,
@@ -137,22 +137,22 @@ import MastodonLocalization
                                     false))))), fromPost: initialDisplayInfo.id, transition: .show)
     }
     
-    func openURL(_ url: URL) -> Bool {
+    func openURL(_ url: URL, actionHandler: MastodonPostMenuActionHandler) -> Bool {
         if let mention = fullPost?.actionablePost?.content.htmlWithEntities?.mentions.first(where: { $0.url == url.absoluteString }) {
-            goToProfile(mention)
+            goToProfile(mention, actionHandler: actionHandler)
             return true
         } else if let hashtag = fullPost?.actionablePost?.content.htmlWithEntities?.tags.first(where: { $0.name.lowercased() == url.lastPathComponent.lowercased() && url.pathComponents.contains("tags") }) {
-            guard let currentUser = AuthenticationServiceProvider.shared.currentActiveUser.value else { return false }
-            actionHandler?.presentScene(.hashtagTimeline(hashtag), fromPost: initialDisplayInfo.id, transition: .show)
+            guard AuthenticationServiceProvider.shared.currentActiveUser.value != nil else { return false }
+            actionHandler.presentScene(.hashtagTimeline(hashtag), fromPost: initialDisplayInfo.id, transition: .show)
             return true
         } else {
             // fix non-ascii character URL link can not open issue
-            actionHandler?.presentScene(.safari(url: url), fromPost: initialDisplayInfo.id, transition: .safariPresent(animated: true, completion: nil))
+            actionHandler.presentScene(.safari(url: url), fromPost: initialDisplayInfo.id, transition: .safariPresent(animated: true, completion: nil))
             return true
         }
     }
     
-    func goToProfile(_ account: MastodonAccount) {
+    func goToProfile(_ account: MastodonAccount, actionHandler: MastodonPostMenuActionHandler?) {
         guard let me = AuthenticationServiceProvider.shared.currentActiveUser.value?.cachedAccount else { return }
         if let relationshipToAuthor = myRelationshipToAuthor {
             switch relationshipToAuthor {
@@ -180,7 +180,7 @@ import MastodonLocalization
         }
     }
     
-    func goToProfile(_ mention: Mastodon.Entity.Mention) {
+    func goToProfile(_ mention: Mastodon.Entity.Mention, actionHandler: MastodonPostMenuActionHandler) {
         Task {
             guard let currentUser = AuthenticationServiceProvider.shared.currentActiveUser.value else { return }
             let account = try await APIService.shared.accountInfo(
@@ -189,7 +189,7 @@ import MastodonLocalization
                     mention.id,
                 authorization: currentUser.userAuthorization
             )
-            goToProfile(MastodonAccount.fromEntity(account))
+            goToProfile(MastodonAccount.fromEntity(account), actionHandler: actionHandler)
         }
     }
 }
@@ -199,7 +199,7 @@ extension MastodonPostViewModel {
         guard let currentUser = AuthenticationServiceProvider.shared.currentActiveUser.value, let quotedPost = fullPost?.actionablePost else { return nil }
         return ComposeViewModel(authenticationBox: currentUser, composeContext: .composeStatus(quoting: (quotedPost._legacyEntity, {
             AnyView(
-                EmbeddedPostView(layoutWidth: 200, isSummary: false)
+                EmbeddedPostView(layoutWidth: 200, isSummary: false, actionHandler: nil)
                     .environment(self)
                     .environment(TimestampUpdater.timestamper(withInterval: 30))
                     .environment(ContentConcealViewModel.alwaysShow)
@@ -209,10 +209,10 @@ extension MastodonPostViewModel {
 }
 
 extension MastodonPostViewModel {
-    @ViewBuilder func accessibilityActionButton(_ action: MastodonPostMenuAction) -> some View {
-        Button(action.labelText(username: fullPost?.initialDisplayInfo(inContext: nil).actionableAuthorDisplayName, postLanguage: (fullPost?.actionablePost as? MastodonContentPost)?.content.language)) { [weak self] in
+    @ViewBuilder func accessibilityActionButton(_ action: MastodonPostMenuAction, actionHandler: MastodonPostMenuActionHandler?) -> some View {
+        Button(action.labelText(username: fullPost?.initialDisplayInfo().actionableAuthorDisplayName, postLanguage: (fullPost?.actionablePost as? MastodonContentPost)?.content.language)) { [weak self] in
             guard let self else { return }
-            self.actionHandler?.doAction(action, forPost: self)
+            actionHandler?.doAction(action, forPost: self)
         }
     }
     
@@ -250,15 +250,15 @@ extension MastodonPostViewModel {
 
 extension MastodonPostViewModel {
     
-    @ViewBuilder var socialContextHeader: some View {
-        if let socialContext {
+    @ViewBuilder func socialContextHeader(inThreadContext threadedContext: ThreadedConversationModel.ThreadContext?, getAccount: (Mastodon.Entity.Account.ID)->MastodonAccount?) -> some View {
+        if let socialContext = socialContext(inThreadContext: threadedContext, getAccount: getAccount) {
             socialContext
         } else {
             EmptyView()
         }
     }
     
-    var socialContext: SocialContextHeader? {
+    func socialContext(inThreadContext threadedContext: ThreadedConversationModel.ThreadContext?, getAccount: (Mastodon.Entity.Account.ID)->(MastodonAccount?)) -> SocialContextHeader? {
         guard let fullPost else { return nil }
         if fullPost is MastodonBoostPost {
             // BOOSTED BY
@@ -281,7 +281,7 @@ extension MastodonPostViewModel {
             if isPrivate || threadedContext == nil {
                 let replyInfo = basicPost.inReplyTo
                 if let replyInfo {
-                    let replyToAccount = actionHandler?.account(replyInfo.accountID)
+                    let replyToAccount = getAccount(replyInfo.accountID)// actionHandler?.account(replyInfo.accountID)
                     return SocialContextHeader.reply(to: replyToAccount?.displayInfo.displayName ?? "unknown", isPrivate: isPrivate, isNotification: false, emojis: replyToAccount?.displayInfo.emojis ?? [])
                 } else if isPrivate {
                     return SocialContextHeader.mention(isPrivate: true)
@@ -293,7 +293,7 @@ extension MastodonPostViewModel {
         return nil
     }
 
-    func textContentView(isInlinePreview: Bool) -> MastodonContentView {
+    func textContentView(isInlinePreview: Bool, actionHandler: MastodonPostMenuActionHandler?) -> MastodonContentView {
         let emptyTextContent: MastodonContentView = .timelinePost(html: "", emojis: MastodonContentView.Emojis(), isInlinePreview: false)
         
         guard let actionablePost = fullPost?.actionablePost, let untranslatedContent = actionablePost.content.htmlWithEntities?.html else { return emptyTextContent }
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/AuthorHeaderView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/AuthorHeaderView.swift
index 7bcca97625..de01efc9c2 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/AuthorHeaderView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/AuthorHeaderView.swift	
@@ -6,6 +6,8 @@ import SwiftUI
 struct AuthorHeaderView: View {
     
     @Environment(MastodonPostViewModel.self) private var postViewModel
+    let threadedContext: ThreadedConversationModel.ThreadContext?
+    let getAccount: (Mastodon.Entity.Account.ID)->(MastodonAccount?)
     
     var body: some View {
         VStack(alignment: .leading, spacing: 0) {
@@ -28,7 +30,7 @@ struct AuthorHeaderView: View {
                 .frame(maxWidth: .infinity, alignment: .leading)
         }
         .accessibilityElement(children: .ignore)
-        .accessibilityLabel(postViewModel.a11yHeaderLabel)
+        .accessibilityLabel(postViewModel.a11yHeaderLabel(inThreadedContext: threadedContext, getAccount: getAccount))
     }
     
     @ViewBuilder var authorDisplayName: some View {
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/EmbeddedPostView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/EmbeddedPostView.swift
index 760d31016a..4a0345b98b 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/EmbeddedPostView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/EmbeddedPostView.swift	
@@ -10,13 +10,14 @@ struct EmbeddedPostView: View {
     @Environment(ContentConcealViewModel.self) private var contentConcealViewModel
     let layoutWidth: CGFloat
     let isSummary: Bool
+    let actionHandler: MastodonPostMenuActionHandler?
     
     var body: some View {
         if viewModel.fullPost != nil {
             if !contentConcealViewModel.currentMode.isShowingContent {
                 EmbeddedPostContentConcealedView()
             } else {
-                EmbeddedPostContentDisplayedView(layoutWidth: layoutWidth, isSummary: isSummary) // TODO: add blur content option for blur filters and hide-media-only CWs
+                EmbeddedPostContentDisplayedView(layoutWidth: layoutWidth, isSummary: isSummary, actionHandler: actionHandler) // TODO: add blur content option for blur filters and hide-media-only CWs
             }
         }
     }
@@ -166,6 +167,7 @@ struct EmbeddedPostContentDisplayedView: View {
     @Environment(\.colorScheme) private var colorScheme
     let layoutWidth: CGFloat
     let isSummary: Bool
+    let actionHandler: MastodonPostMenuActionHandler?
     
     let padding: CGFloat = 12
     
@@ -175,15 +177,15 @@ struct EmbeddedPostContentDisplayedView: View {
             VStack(alignment: .leading) {
                 header
                     .accessibilityElement(children: .ignore)
-                    .accessibilityLabel(viewModel.a11yHeaderLabel)
+                    .accessibilityLabel(viewModel.a11yHeaderLabel(inThreadedContext: nil, getAccount: { accountID in actionHandler?.account(accountID) }))
                 if viewModel.fullPost != nil {
-                    viewModel.textContentView(isInlinePreview: true)
+                    viewModel.textContentView(isInlinePreview: true, actionHandler: actionHandler)
                         .font(.footnote)
                         .lineLimit(4)
                         .fixedSize(horizontal: false, vertical: true)
                         .accessibilityElement(children: .combine)
                 }
-                if let attachmentInfo = viewModel.fullPost?.actionablePost?.content.attachment, let actionHandler = viewModel.actionHandler {
+                if let attachmentInfo = viewModel.fullPost?.actionablePost?.content.attachment, let actionHandler {
                     if isSummary {
                         if let iconName = attachmentInfo.iconName, let labelText = attachmentInfo.labelText {
                             HStack {
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/MediaAttachmentView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/MediaAttachmentView.swift
index df1de16309..09c93ff001 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/MediaAttachmentView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/MediaAttachmentView.swift	
@@ -176,13 +176,13 @@ enum MediaAttachment {
 
 extension MediaAttachment {
     @MainActor
-    @ViewBuilder func view(actionHandler: MastodonPostMenuActionHandler) -> some View {
+    @ViewBuilder func view(actionHandler: MastodonPostMenuActionHandler?) -> some View {
         switch self {
         case .emptyAttachment:
             Image(systemName: "questionmark.square.dashed")
         case .images(let attachments, let altTextTranslations):
             ConcealableMediaAttachmentView() {
-                ImageGridView(mediaPreviewableViewController: actionHandler.mediaPreviewableViewController)
+                ImageGridView(actionHandler: actionHandler)
                     .environment(ImageGalleryViewModel(imageAttachments: attachments, altTextTranslations: altTextTranslations, actionHandler: actionHandler))
             }
         case .audio:
@@ -193,7 +193,7 @@ extension MediaAttachment {
             }
         case .openInBrowser(let url):
             Button {
-                actionHandler.presentScene(.safari(url: url), fromPost: nil, transition: .show)
+                actionHandler?.presentScene(.safari(url: url), fromPost: nil, transition: .show)
             } label: {
                 HStack {
                     VStack(alignment: .leading) {
@@ -267,7 +267,7 @@ struct ConcealableMediaAttachmentView<Content: View>: View {
 struct ImageGridView: View {
     @Environment(ImageGalleryViewModel.self) private var viewModel
     @Environment(ContentConcealViewModel.self) private var contentConcealViewModel
-    let mediaPreviewableViewController: MediaPreviewableViewController?
+    let actionHandler: MastodonPostMenuActionHandler?
     @State var waitingToShowFullSize: String? = nil
     
     var body: some View {
@@ -299,9 +299,9 @@ struct ImageGridView: View {
                     if let altText = img.basicData.altText, altText.isNotEmpty {
                         Button {
                             if let translation = viewModel.altTextTranslations?[img.id] {
-                                viewModel.actionHandler.showOverlay(.altText(translation))
+                                actionHandler?.showOverlay(.altText(translation))
                             } else {
-                                viewModel.actionHandler.showOverlay(.altText(altText))
+                                actionHandler?.showOverlay(.altText(altText))
                             }
                         } label: {
                             Text("ALT")
@@ -327,7 +327,7 @@ struct ImageGridView: View {
     }
     
     func showImageGallery(focusing: Mastodon.Entity.Attachment.ID, withPlaceholderImages placeholderImages: [UIImage?]) {
-        guard let presentingViewController = viewModel.actionHandler.mediaPreviewableViewController else { return }
+        guard let presentingViewController = viewModel.actionHandler?.mediaPreviewableViewController else { return }
         
         let focusedIndex = viewModel.imageAttachments.firstIndex { $0.id == focusing }
         
@@ -367,7 +367,7 @@ struct ImageGridView: View {
         let mediaPreviewViewModel = MediaPreviewViewModel(
             item: previewItem,
             transitionItem: mediaPreviewTransitionItem)
-        viewModel.actionHandler.presentScene(.mediaPreview(viewModel: mediaPreviewViewModel),
+        actionHandler?.presentScene(.mediaPreview(viewModel: mediaPreviewViewModel),
                                              fromPost: nil,
                                              transition: .custom(transitioningDelegate: presentingViewController.mediaPreviewTransitionController)
         )
@@ -422,9 +422,9 @@ class ImageGalleryViewModel {
     private var frames = [Mastodon.Entity.Attachment.ID : CGRect]()
     let altTextTranslations: [String : String]?
     var blurhashes = [ Mastodon.Entity.Attachment.ID : UIImage ]()
-    let actionHandler: MastodonPostMenuActionHandler
+    let actionHandler: MastodonPostMenuActionHandler?
     
-    init(imageAttachments: [MastodonImageAttachment], altTextTranslations: [String: String]?, actionHandler: MastodonPostMenuActionHandler) {
+    init(imageAttachments: [MastodonImageAttachment], altTextTranslations: [String: String]?, actionHandler: MastodonPostMenuActionHandler?) {
         self.imageAttachments = imageAttachments
         self.altTextTranslations = altTextTranslations
         self.actionHandler = actionHandler
@@ -610,10 +610,10 @@ struct VideoPlayerView: View {
     let url: URL
     @Environment(ContentConcealViewModel.self) private var contentConcealViewModel
     @StateObject var playerObserver = PlayerObserver()
-    let actionHandler: MastodonPostMenuActionHandler
+    let actionHandler: MastodonPostMenuActionHandler?
     @State var waitingToShowFullSize = false
     
-    init?(media: MediaAttachment, actionHandler: MastodonPostMenuActionHandler) {
+    init?(media: MediaAttachment, actionHandler: MastodonPostMenuActionHandler?) {
         switch media {
         case .video, .gifv:
             break
@@ -721,7 +721,7 @@ struct VideoPlayerView: View {
     
     func showFullSize() {
         playerObserver.didPressPause()
-        guard let _legacyEntity = media.attachmentInfo?._legacyEntity, let previewableViewController = actionHandler.mediaPreviewableViewController else { return }
+        guard let _legacyEntity = media.attachmentInfo?._legacyEntity, let previewableViewController = actionHandler?.mediaPreviewableViewController else { return }
         let previewItem: MediaPreviewViewModel.PreviewItem = .attachments([_legacyEntity], initialIndex: 0, placeholderImages: [playerObserver.blurImage], altTexts: [media.attachmentInfo?.basicData.altText ?? ""])
         let mediaPreviewTransitionItem: MediaPreviewTransitionItem = {
             let item = MediaPreviewTransitionItem(source: .swiftUI(sourceFramesInScreenCoordinates: [playerObserver.mostRecentFrameInScreenCoordinates]), previewableViewController: previewableViewController)
@@ -744,7 +744,7 @@ struct VideoPlayerView: View {
         let mediaPreviewViewModel = MediaPreviewViewModel(
             item: previewItem,
             transitionItem: mediaPreviewTransitionItem)
-        actionHandler.presentScene(.mediaPreview(viewModel: mediaPreviewViewModel),
+        actionHandler?.presentScene(.mediaPreview(viewModel: mediaPreviewViewModel),
                                    fromPost: nil,
                                    transition: .custom(transitioningDelegate: previewableViewController.mediaPreviewTransitionController)
         )
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/PollView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/PollView.swift
index 2ee1d63016..2b25b49874 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/PollView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/Molecules/PollView.swift	
@@ -344,9 +344,9 @@ class PollViewModel: ObservableObject {
     private var entity: Mastodon.Entity.Poll
     private let containingPostID: Mastodon.Entity.Status.ID
     private let optionTranslations: [String]?
-    private let actionHandler: MastodonPostMenuActionHandler
+    private let actionHandler: MastodonPostMenuActionHandler?
     
-    init(pollEntity: Mastodon.Entity.Poll, emojis: [Mastodon.Entity.Emoji]?, optionTranslations: [String]?, containingPostID: Mastodon.Entity.Status.ID, actionHandler: MastodonPostMenuActionHandler) {
+    init(pollEntity: Mastodon.Entity.Poll, emojis: [Mastodon.Entity.Emoji]?, optionTranslations: [String]?, containingPostID: Mastodon.Entity.Status.ID, actionHandler: MastodonPostMenuActionHandler?) {
         entity = pollEntity
         self.containingPostID = containingPostID
         self.optionTranslations = optionTranslations
@@ -363,6 +363,7 @@ class PollViewModel: ObservableObject {
     func submitVote() {
         if case let .selecting(selectionState) = votingState, !selectionState.selectedIndexes.isEmpty {
             votingState = .submittingVote(selectionState)
+            guard let actionHandler else { return }
             Task { @MainActor in
                 do {
                     let updatedPoll = try await actionHandler.vote(poll: entity, choices: selectionState.selectedIndexes, containingPostID: containingPostID)
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowView.swift
index 3c90022e37..45590a2446 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowView.swift	
@@ -444,7 +444,8 @@ struct FilteredNotificationsRowView: View {
 struct NotificationRowView: View {
     
     @Environment(NotificationRowViewModel.self) var viewModel
-    var contentWidth: CGFloat
+    let contentWidth: CGFloat
+    let actionHandler: MastodonPostMenuActionHandler?
     
     var body: some View {
         VStack(alignment: .gutterAlign, spacing: 0) {
@@ -509,11 +510,12 @@ struct NotificationRowView: View {
             
             // OPTIONAL INLINE POST VIEW
             if let postViewModel = viewModel.inlinePostViewModel {
-                EmbeddedPostView(layoutWidth: contentWidth, isSummary: true)
+                EmbeddedPostView(layoutWidth: contentWidth, isSummary: true, actionHandler: actionHandler)
                     .environment(postViewModel)
                     .environment(viewModel.contentConcealViewModel ?? .alwaysShow)
                     .onTapGesture {
-                        postViewModel.openThreadView()
+                        guard let actionHandler else { return }
+                        postViewModel.openThreadView(actionHandler: actionHandler)
                     }
             }
         }
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowViewModel.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowViewModel.swift
index eee2ac882e..81fbbed4ea 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowViewModel.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/NotificationRowViewModel.swift	
@@ -117,7 +117,7 @@ nonisolated struct MastodonNotificationInfo {
             avatarRowAdditionalElement = .noneNeeded
             if let status {
                 let inlinePost = GenericMastodonPost.fromStatus(status)
-                inlinePostViewModel = MastodonPostViewModel(inlinePost.initialDisplayInfo(inContext: .notifications), filterContext: .notifications, threadedConversationContext: nil)
+                inlinePostViewModel = MastodonPostViewModel(inlinePost.initialDisplayInfo())
                 inlinePostViewModel?.initialSetFullPost(inlinePost)
                 usePrivateBackground = status.visibility == .direct
             }
@@ -134,7 +134,7 @@ nonisolated struct MastodonNotificationInfo {
             avatarRowAdditionalElement = .noneNeeded
             if let status {
                 let inlinePost = GenericMastodonPost.fromStatus(status)
-                inlinePostViewModel = MastodonPostViewModel(inlinePost.initialDisplayInfo(inContext: .notifications), filterContext: .notifications, threadedConversationContext: nil)
+                inlinePostViewModel = MastodonPostViewModel(inlinePost.initialDisplayInfo())
                 inlinePostViewModel?.initialSetFullPost(inlinePost)
             }
         default:
diff --git a/Mastodon/In Progress New Layout and Datamodel/FeedLoader/MastodonFeedLoader.swift b/Mastodon/In Progress New Layout and Datamodel/FeedLoader/MastodonFeedLoader.swift
index 0adbf8c18b..96e30ea5a3 100644
--- a/Mastodon/In Progress New Layout and Datamodel/FeedLoader/MastodonFeedLoader.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/FeedLoader/MastodonFeedLoader.swift	
@@ -132,16 +132,13 @@ public class MastodonFeedLoader<PublishedType: Identifiable, CachedType: Cacheab
 extension MastodonFeedLoader {
     public func doFirstLoad() {
         Task {
-            do {
-                try loadCached()
-            } catch {
-            }
             do {
                 if let authBox = AuthenticationServiceProvider.shared.currentActiveUser.value {
                     let markers = try await APIService.shared.lastReadMarkers(authenticationBox: authBox)
                     cacheManager.didFetchMarkers(markers)
                 }
             } catch {
+                currentError = error
             }
             requestLoad(.reload)
         }
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/CentralPostViewModelCache.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/CentralPostViewModelCache.swift
new file mode 100644
index 0000000000..4856c9b32d
--- /dev/null
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/CentralPostViewModelCache.swift	
@@ -0,0 +1,49 @@
+// Copyright  2025 Mastodon gGmbH. All rights reserved.
+
+import Combine
+import Foundation
+import MastodonSDK
+
+@MainActor
+class CentralPostViewModelCache {
+    
+    static let shared = CentralPostViewModelCache()
+    
+    private var updateSubscription: AnyCancellable?
+    
+    private init() {
+        self.updateSubscription = FeedCoordinator.shared.$mostRecentUpdate
+            .receive(on: DispatchQueue.main)
+            .sink { [weak self] update in
+                guard let self, let update else { return }
+                switch update {
+                case .deletedPost(let deletedID):
+                    return
+                default:
+                    break
+                }
+                for (key, weakWrapper) in _cache {
+                    if let postModel = weakWrapper.value {
+                        postModel.incorporateUpdate(update)
+                    } else {
+                        _cache.removeValue(forKey: key)
+                    }
+                }
+            }
+    }
+    
+    private struct WeakPostViewModel {
+        weak var value: MastodonPostViewModel?
+    }
+    
+    private var _cache = [ String : WeakPostViewModel ]()
+    
+    func cachedModel(for postID: Mastodon.Entity.Status.ID) -> MastodonPostViewModel? {
+        return _cache[postID]?.value
+    }
+    
+    func addToCache(_ model: MastodonPostViewModel) {
+        let weakWrapper = WeakPostViewModel(value: model)
+        _cache[model.initialDisplayInfo.id] = weakWrapper
+    }
+}
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/PrecalculatedRowHeights.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/PrecalculatedRowHeights.swift
new file mode 100644
index 0000000000..454ea260fc
--- /dev/null
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/PrecalculatedRowHeights.swift	
@@ -0,0 +1,71 @@
+// Copyright  2025 Mastodon gGmbH. All rights reserved.
+
+import MastodonSDK
+import SwiftUI
+
+@MainActor
+final class ViewMeasurer {
+    static let shared = ViewMeasurer()
+    
+    private let host = UIHostingController(rootView: AnyView(EmptyView()))
+    
+    init() {
+        let throwawayView = Text("This is some text just to give the system something to layout so that it gets the correct measurements when we measure things for real. Without this, the first use of the measurer gives a height that is too short.")
+        let _ = immediatelyMeasureHeight(throwawayView, width: 300)
+    }
+    
+    func calculateHeightImmediately(for viewModel: MastodonPostViewModel, contentConcealModel: ContentConcealViewModel, filterContext: Mastodon.Entity.FilterContext?, threadedContext: ThreadedConversationModel.ThreadContext?, contentWidth: CGFloat, totalWidth: CGFloat) -> PrecalculatedHeight {
+        
+        let contentSizeCategory = UIApplication.shared.preferredContentSizeCategory // so that this offscreen view still respects the user's current settings
+        
+        let view = MastodonPostRowView(contentWidth: contentWidth, precalculatedHeight: nil, actionHandler: nil, threadedContext: threadedContext, filterContext: filterContext)
+            .environment(viewModel)
+            .environment(contentConcealModel)
+            .environment(TimestampUpdater.timestamper(withInterval: 60))
+            .environment(\.sizeCategory, ContentSizeCategory(contentSizeCategory) ?? .medium)
+            .padding(EdgeInsets(top: 0, leading: standardPadding, bottom: 0, trailing: doublePadding))
+        let height = immediatelyMeasureHeight(view, width: totalWidth)
+        return PrecalculatedHeight(contentWidth: contentWidth, contentConcealed: contentConcealModel.currentMode, showingTranslation: viewModel.isShowingTranslation == true, calculatedHeight: height)
+    }
+    
+    func calculateHeight(for viewModel: MastodonPostViewModel, contentConcealModel: ContentConcealViewModel, filterContext: Mastodon.Entity.FilterContext?, threadedContext: ThreadedConversationModel.ThreadContext?, contentWidth: CGFloat, totalWidth: CGFloat) async -> PrecalculatedHeight {
+        
+        let contentSizeCategory = UIApplication.shared.preferredContentSizeCategory // so that this offscreen view still respects the user's current settings
+        
+        let view = MastodonPostRowView(contentWidth: contentWidth, precalculatedHeight: nil, actionHandler: nil, threadedContext: threadedContext, filterContext: filterContext)
+            .environment(viewModel)
+            .environment(contentConcealModel)
+            .environment(TimestampUpdater.timestamper(withInterval: 60))
+            .environment(\.sizeCategory, ContentSizeCategory(contentSizeCategory) ?? .medium)
+            .padding(EdgeInsets(top: 0, leading: standardPadding, bottom: 0, trailing: doublePadding))
+        let height = await measureHeight(view, width: totalWidth)
+        return PrecalculatedHeight(contentWidth: contentWidth, contentConcealed: contentConcealModel.currentMode, showingTranslation: viewModel.isShowingTranslation == true, calculatedHeight: height)
+    }
+  
+#if DEBUG
+    let SECONDS_DELAY_BETWEEN_MEASUREMENTS: Int = 1
+#else
+    let SECONDS_DELAY_BETWEEN_MEASUREMENTS: Int = 0
+#endif
+    
+    func measureHeight<V: View>(_ view: V, width: CGFloat) async -> CGFloat {
+        host.rootView = AnyView(view)
+        host.view.bounds = CGRect(x: 0, y: 0, width: width, height: .greatestFiniteMagnitude)
+        host.view.setNeedsLayout()
+        host.view.layoutIfNeeded()
+        let result = await withCheckedContinuation { continuation in
+            DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(SECONDS_DELAY_BETWEEN_MEASUREMENTS)) {
+                continuation.resume(returning: self.host.sizeThatFits(in: CGSize(width: width, height: .greatestFiniteMagnitude)).height)
+            }
+        }
+        return ceil(result + 0.5) // the ceil and + 0.5 arrived at through observation, attempting to mimic the actual system layout behavior as closely as possible.
+    }
+    
+    func immediatelyMeasureHeight<V: View>(_ view: V, width: CGFloat) -> CGFloat {
+        host.rootView = AnyView(view)
+        host.view.bounds = CGRect(x: 0, y: 0, width: width, height: .greatestFiniteMagnitude)
+        host.view.layoutIfNeeded()
+        let result = self.host.sizeThatFits(in: CGSize(width: width, height: .greatestFiniteMagnitude)).height
+        return result
+    }
+}
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift
index 6ed2cc08ce..a8c5978511 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift	
@@ -130,6 +130,35 @@ public enum MastodonTimelineType: Equatable {
             return false
         }
     }
+    
+    public var filterContext: Mastodon.Entity.FilterContext? {
+        switch self {
+        case .following:
+                .home
+        case .hashtag:
+                .public
+        case .list:
+                .home
+        case .local:
+                .public
+        case .discover:
+                .public
+        case .search:
+            nil
+        case .userPosts:
+                .account
+        case .thread, .remoteThread:
+                .account
+        case .myFollowedHashtags:
+            nil
+        case .myBookmarks:
+            nil
+        case .myFavorites:
+            nil
+        case .notifications:
+                .notifications
+        }
+    }
 }
 
 public struct TimelineQueryFilter: Equatable {
@@ -152,7 +181,7 @@ extension GenericMastodonPost {
     struct InitialDisplayInfo: Codable {
         let id: Mastodon.Entity.Status.ID
         let actionablePostID: Mastodon.Entity.Status.ID
-        let shouldFilterOut: Bool
+        let filterOutInContexts: Set<Mastodon.Entity.FilterContext>
         let actionableAuthorId: String
         let actionableAuthorStaticAvatar: URL?
         let actionableAuthorHandle: String
@@ -171,8 +200,28 @@ enum TimelineItem: Identifiable {
         Mastodon.Entity.NotificationPolicy?,
         FilteredNotificationsRowView.ViewModel?)
     case loadingIndicator
+    case noItem
     
     var id: String {
+        switch self {
+        case .post(let postViewModel):
+            return "post-\(postViewModel.initialDisplayInfo.id)"
+        case .notification(let groupedNotificationInfo):
+            return "notification-\(groupedNotificationInfo.id)"
+        case .hashtag(let tagViewModel):
+            return "hashtag-\(tagViewModel.id)"
+        case .account(let accountViewModel):
+            return "account-\(accountViewModel.id)"
+        case .filteredNotificationsInfo:
+            return "filteredNotifications"
+        case .loadingIndicator:
+            return "loading..."
+        case .noItem:
+            return "NO ITEM"
+        }
+    }
+    
+    var mastodonID: String? {
         switch self {
         case .post(let postViewModel):
             return postViewModel.initialDisplayInfo.id
@@ -183,9 +232,11 @@ enum TimelineItem: Identifiable {
         case .account(let accountViewModel):
             return accountViewModel.id
         case .filteredNotificationsInfo:
-            return "filteredNotifications"
+            return nil
         case .loadingIndicator:
-            return "loading..."
+            return nil
+        case .noItem:
+            return nil
         }
     }
     
@@ -193,7 +244,7 @@ enum TimelineItem: Identifiable {
         switch self {
         case .post, .notification, .hashtag, .account:
             return true
-        case .filteredNotificationsInfo, .loadingIndicator:
+        case .filteredNotificationsInfo, .loadingIndicator, .noItem:
             return false
         }
     }
@@ -227,8 +278,6 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
     private var _createArtificialGapForTesting = false
 #endif
     
-    private let filterContext: Mastodon.Entity.FilterContext?
-    
     private let authenticatedUser: MastodonAuthenticationBox
     
     private var cachedRelationships = [Mastodon.Entity.Account.ID : MastodonAccount.Relationship]()
@@ -253,34 +302,6 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
         let trackLastRead = timeline == .following
         let cacheManager = TimelineCacheManager(currentUser: currentUser, trackLastRead: trackLastRead, useDiskCache: false)
         
-        switch timeline {
-        case .following:
-            self.filterContext = .home
-        case .hashtag:
-            self.filterContext = .public
-        case .list:
-            self.filterContext = .home
-        case .local:
-            self.filterContext = .public
-        case .discover:
-            self.filterContext = .public
-        case .search:
-            self.filterContext = nil
-        case .userPosts:
-            self.filterContext = .account
-        case .thread, .remoteThread:
-            self.filterContext = .account
-        case .myFollowedHashtags:
-            self.filterContext = nil
-        case .myBookmarks:
-            self.filterContext = nil
-        case .myFavorites:
-            self.filterContext = nil
-        case .notifications:
-            self.filterContext = .notifications
-        }
-        
-        
         super.init(cacheManager)
         
         self.updateSubscription = FeedCoordinator.shared.$mostRecentUpdate
@@ -303,13 +324,13 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
                         switch item {
                         case .account(let accountModel):
                             accountModel.incorporateUpdate(update)
-                        case .post(let postModel):
-                            postModel.incorporateUpdate(update)
+                        case .post:
+                            break // this update is handled by the CentralPostViewModelCache
                         case .notification(let notificationModel):
                             notificationModel.incorporateUpdate(update)
                         case .hashtag(let hashtagModel):
                             hashtagModel.incorporateUpdate(update)
-                        case .filteredNotificationsInfo, .loadingIndicator:
+                        case .filteredNotificationsInfo, .loadingIndicator, .noItem:
                             break
                         }
                     }
@@ -331,9 +352,9 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
             let mostRecentID = {
                 switch records.allRecords.count {
                 case 0, 1:
-                    return records.allRecords.first?.id
+                    return records.allRecords.first?.mastodonID
                 default:
-                    return records.allRecords[1].id  // we want to allow the possibility of an overlap in order to detect gaps
+                    return records.allRecords[1].mastodonID  // we want to allow the possibility of an overlap in order to detect gaps
                 }
             }()
             itemsNoOlderThan = mostRecentID
@@ -345,9 +366,9 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
                 let count = records.allRecords.count
                 switch count {
                 case 0, 1:
-                    return records.allRecords.last?.id
+                    return records.allRecords.last?.mastodonID
                 default:
-                    return records.allRecords[count - 2].id  // we want to allow the possibility of an overlap in order to detect gaps
+                    return records.allRecords[count - 2].mastodonID  // we want to allow the possibility of an overlap in order to detect gaps
                 }
             }()
             itemsImmediatelyBefore = olderThan
@@ -382,16 +403,24 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
             return timelineItem(fromPost: post)
         }
         func timelineItem(fromPost post: GenericMastodonPost) -> TimelineItem {
-            let initialDisplayInfo = post.initialDisplayInfo(inContext: filterContext)
+            let initialDisplayInfo = post.initialDisplayInfo()
             let viewModel = {
                 if let existing = postViewModels[initialDisplayInfo.id] {
                     existing.incorporateUpdate(.post(post))
                     return existing
                 } else {
-                    let model = MastodonPostViewModel(initialDisplayInfo, filterContext: filterContext, threadedConversationContext: threadedConversationModel?.context(for: initialDisplayInfo.id))
-                    newPostModels[initialDisplayInfo.id] = model
-                    model.initialSetFullPost(post)
-                    return model
+                    // possible that another timeline has a view model for this post, even though we don't
+                    if let existingElsewhere = CentralPostViewModelCache.shared.cachedModel(for: initialDisplayInfo.id) {
+                        existingElsewhere.incorporateUpdate(.post(post))
+                        newPostModels[initialDisplayInfo.id] = existingElsewhere
+                        return existingElsewhere
+                    } else {
+                        let model = MastodonPostViewModel(initialDisplayInfo)
+                        model.initialSetFullPost(post)
+                        newPostModels[initialDisplayInfo.id] = model
+                        CentralPostViewModelCache.shared.addToCache(model)
+                        return model
+                    }
                 }
             }()
             return TimelineItem.post(viewModel)
@@ -426,7 +455,8 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
         let newBatch: [TimelineItem]
         switch timeline {
         case .following:
-            newBatch = try await APIService.shared.homeTimeline(itemsNoOlderThan: itemsNoOlderThan, itemsImmediatelyAfter: itemsImmediatelyAfter, itemsImmediatelyBefore: itemsImmediatelyBefore, authenticationBox: authenticatedUser).value.map { timelineItem(fromStatus:$0) }
+            let result = try await APIService.shared.homeTimeline(itemsNoOlderThan: itemsNoOlderThan, itemsImmediatelyAfter: itemsImmediatelyAfter, itemsImmediatelyBefore: itemsImmediatelyBefore, authenticationBox: authenticatedUser).value
+            newBatch = result.map { timelineItem(fromStatus:$0) }
         case .local:
             newBatch = try await APIService.shared.publicTimeline(
                 query: .init(local: true, maxID: itemsImmediatelyBefore, sinceID: itemsNoOlderThan, minID: itemsImmediatelyAfter),
@@ -607,7 +637,7 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
     }
     
     override func filteredResults(fromCachedType cached: CacheableTimeline) -> [TimelineItem] {
-        cached.filteredItems(inContext: filterContext)
+        cached.filteredItems(inContext: timeline.filterContext)
     }
     
 }
@@ -643,13 +673,17 @@ struct CacheableTimeline: CacheableFeed {
             switch item {
             case .loadingIndicator, .filteredNotificationsInfo:
                 return true
+            case .noItem:
+                return false
             case .post(let postViewModel):
                 if let contentPost = postViewModel.fullPost as? MastodonContentPost {
                     return !contentPost.content.shouldBeRemovedFromFeed(inContext: context)
                 } else if let boost = postViewModel.fullPost as? MastodonBoostPost {
                     return !boost.boostedPost.content.shouldBeRemovedFromFeed(inContext: context)
+                } else if let context {
+                    return !postViewModel.initialDisplayInfo.filterOutInContexts.contains(context)
                 } else {
-                    return !postViewModel.initialDisplayInfo.shouldFilterOut
+                    return true
                 }
             case .notification(let groupedInfo):
                 // TODO: filter based on contained statuses
@@ -670,7 +704,7 @@ struct CacheableTimeline: CacheableFeed {
         
         let oldestIdInNewBatch = newer.last(where: { item in
             switch item {
-            case .loadingIndicator, .filteredNotificationsInfo: return false
+            case .loadingIndicator, .filteredNotificationsInfo, .noItem: return false
             case .post: return true
             case .notification: return true
             case .hashtag: return true
@@ -689,7 +723,7 @@ struct CacheableTimeline: CacheableFeed {
                     return item.id == oldestIdInNewBatch
                 case .account:
                     return item.id == oldestIdInNewBatch
-                case .loadingIndicator, .filteredNotificationsInfo:
+                case .loadingIndicator, .filteredNotificationsInfo, .noItem:
                     return false
                 }
             })
@@ -723,6 +757,8 @@ struct CacheableTimeline: CacheableFeed {
             case .notification:
                 // TODO: anything?
                 return true
+            case .noItem:
+                return false
             }
         }
         
@@ -816,6 +852,19 @@ class TimelineCacheManager: MastodonFeedCacheManager {
 }
 
 extension GenericMastodonPost.PostContent {
+    var removeFromFeedInContexts: Set<Mastodon.Entity.FilterContext> {
+        guard let filterResults = filtered else { return Set() }
+        var contexts = Set<Mastodon.Entity.FilterContext>()
+        for result in filterResults {
+            if result.filter.filterAction == .hide {
+                for filterContext in result.filter.context {
+                    contexts.insert(filterContext)
+                }
+            }
+        }
+        return contexts
+    }
+    
     func shouldBeRemovedFromFeed(inContext context: Mastodon.Entity.FilterContext?) -> Bool {
         guard let context else { return false }
         guard let filterResults = filtered else { return false }
@@ -895,11 +944,11 @@ extension TimelineFeedLoader {
     private func createContentConcealViewModels(_ cache: CacheableTimeline) {
         for item in cache.items {
             switch item {
-            case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .account:
+            case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .account, .noItem:
                 break
             case .post(let postViewModel):
                 if let contentPost = postViewModel.fullPost?.actionablePost, contentConcealViewModels[contentPost.id] == nil {
-                    contentConcealViewModels[contentPost.id] = ContentConcealViewModel(contentPost: contentPost, context: filterContext)
+                    contentConcealViewModels[contentPost.id] = ContentConcealViewModel(contentPost: contentPost, context: timeline.filterContext)
                 }
             case .notification:
                 // TODO: create conceal models for summarized statuses?
@@ -915,9 +964,9 @@ extension TimelineFeedLoader {
 }
 
 extension GenericMastodonPost {
-    func initialDisplayInfo(inContext context: Mastodon.Entity.FilterContext?) -> GenericMastodonPost.InitialDisplayInfo {
+    func initialDisplayInfo() -> GenericMastodonPost.InitialDisplayInfo {
         let author = actionablePost?.metaData.author ?? metaData.author
-        return GenericMastodonPost.InitialDisplayInfo(id: id, actionablePostID: actionablePost?.id ?? id, shouldFilterOut: actionablePost?.content.shouldBeRemovedFromFeed(inContext: context) ?? false, actionableAuthorId: author.id, actionableAuthorStaticAvatar: author.displayInfo.avatarUrl, actionableAuthorHandle: author.handle, actionableAuthorDisplayName: author.displayName(whenViewedBy: nil)?.plainString ?? "", actionableVisibility: actionablePost?.metaData.privacyLevel ?? metaData.privacyLevel ?? .loudPublic, actionableCreatedAt: actionablePost?.metaData.createdAt ?? metaData.createdAt)
+        return GenericMastodonPost.InitialDisplayInfo(id: id, actionablePostID: actionablePost?.id ?? id, filterOutInContexts: actionablePost?.content.removeFromFeedInContexts ?? Set(), actionableAuthorId: author.id, actionableAuthorStaticAvatar: author.displayInfo.avatarUrl, actionableAuthorHandle: author.handle, actionableAuthorDisplayName: author.displayName(whenViewedBy: nil)?.plainString ?? "", actionableVisibility: actionablePost?.metaData.privacyLevel ?? metaData.privacyLevel ?? .loudPublic, actionableCreatedAt: actionablePost?.metaData.createdAt ?? metaData.createdAt)
     }
 }
 
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift
index 5d69d76a25..f791706f58 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
@@ -39,15 +39,13 @@ enum TimelineViewType {
     }
 }
 
-class TimelineListViewController: UIHostingController<TimelineListView>
+class TimelineListViewController: UIHostingController<AnyView>
 {
     public let type: TimelineViewType
     private let viewModel: TimelineListViewModel
     private var navigationFlow: NavigationFlow?
     private let _mediaPreviewTransitionController = MediaPreviewTransitionController()
     
-    private var scrollToTopUpdateSubscription: AnyCancellable?
-    
     init(_ type: TimelineViewType) {
         self.type = type
         switch type {
@@ -74,8 +72,8 @@ class TimelineListViewController: UIHostingController<TimelineListView>
         case .hashtag(let tag):
             viewModel = TimelineListViewModel(timeline: .hashtag(tag, includeHeader: true))
         }
-        let root = TimelineListView(viewModel: viewModel)
-        super.init(rootView: root)
+        let root = TimelineListView().environment(viewModel)
+        super.init(rootView: AnyView(root))
         viewModel.parentVcPresentScene = { (scene, transition) in
             self.sceneCoordinator?.present(scene: scene, from: self, transition: transition)
         }
@@ -96,7 +94,6 @@ class TimelineListViewController: UIHostingController<TimelineListView>
         switch type {
         case .home:
             setUpTimelineSelectorButton()
-            setUpScrollToTop()
             self.navigationItem.rightBarButtonItem = settingBarButtonItem
         case .notifications:
             setUpNotificationsNavBarControls()
@@ -104,7 +101,7 @@ class TimelineListViewController: UIHostingController<TimelineListView>
                 NotificationCenter.default.addObserver(self, selector: #selector(notificationFilteringPolicyDidChange), name: .notificationFilteringChanged, object: nil)
             }
         case .thread(let focusedPost):
-            let authorHandle = focusedPost.initialDisplayInfo(inContext: .thread).actionableAuthorHandle
+            let authorHandle = focusedPost.initialDisplayInfo().actionableAuthorHandle
             navigationItem.title = L10n.Scene.Thread.title("@\(authorHandle)")
             
         case .discover, .myBookmarks, .myFavorites, .profilePosts, .remoteThread:
@@ -146,8 +143,6 @@ class TimelineListViewController: UIHostingController<TimelineListView>
     
     lazy var picker = { UISegmentedControl(items: [ NotificationsScope.everything.pickerLabel, NotificationsScope.mentions.pickerLabel ]) }()
     
-    var scrollToTopButton: UIButton?
-    
     lazy var timelineSelectorButton = {
         let button = UIButton(type: .custom)
         
@@ -199,26 +194,6 @@ class TimelineListViewController: UIHostingController<TimelineListView>
 
 extension TimelineListViewController {
     // MARK: HomeTimeline Nav Bar controls
-    func setUpScrollToTop() {
-        let button = UIButton(configuration: .plain())
-        button.addTarget(self, action: #selector(scrollToTop), for: .touchUpInside)
-        self.scrollToTopButton = button
-        self.navigationItem.titleView = button
-        scrollToTopUpdateSubscription = viewModel.$unreadCount.sink { [weak self] unread in
-            self?.updateScrollToTopButton(unread)
-        }
-    }
-    
-    func updateScrollToTopButton(_ waitingCount: Int) {
-        if waitingCount > 0 {
-            scrollToTopButton?.isHidden = false
-            scrollToTopButton?.configuration?.title = "\(waitingCount)+ Unread ^"
-            scrollToTopButton?.configuration?.baseForegroundColor = Asset.Colors.accent.color
-        } else {
-            scrollToTopButton?.isHidden = true
-        }
-    }
-    
     @objc func scrollToTop() {
         viewModel.scrollToTop()
     }
@@ -253,21 +228,6 @@ extension TimelineListViewController {
     }
     
     private func generateTimelineSelectorMenu() -> UIMenu {
-        let useLazyVStackAction: UIAction
-        if viewModel.useLazyVStack {
-            useLazyVStackAction = UIAction(title: "Using LazyVStack") { [weak self] _ in
-                guard let self else { return }
-                viewModel.useLazyVStack = false
-                timelineSelectorButton.menu = generateTimelineSelectorMenu()
-            }
-        } else {
-            useLazyVStackAction = UIAction(title: "Using VStack") { [weak self] _ in
-                guard let self else { return }
-                viewModel.useLazyVStack = true
-                timelineSelectorButton.menu = generateTimelineSelectorMenu()
-            }
-        }
-        
         let showFollowingAction = UIAction(title: L10n.Scene.HomeTimeline.TimelineMenu.following, image: .init(systemName: "house")) { [weak self] _ in
             guard let self else { return }
             
@@ -399,13 +359,8 @@ extension TimelineListViewController {
         )
         
         let listsDivider = UIMenu(title: "", options: .displayInline, children: [listsMenu, hashtagsMenu])
-        
-//        if UserDefaults.isDebugOrTestflightOrSimulator {
-//            return UIMenu(children: [useLazyVStackAction, showFollowingAction, showLocalTimelineAction, listsDivider])
-//        } else {
+ 
         return UIMenu(children: [showFollowingAction, showLocalTimelineAction, listsDivider])
-//        }
-        
     }
     
     private func generateNotificationRequestMenu(_ request: Mastodon.Entity.NotificationRequest) -> UIMenu {
@@ -641,7 +596,24 @@ enum MastodonTimelineSheet {
 }
 
 @MainActor
-private class TimelineListViewModel: ObservableObject {
+@Observable private class TimelineListViewModel {
+    
+    private(set) var authenticatedUser: MastodonAuthenticationBox? = AuthenticationServiceProvider.shared.currentActiveUser.value
+    
+    var unreadCount: Int = 0
+    private(set) var waitingReplacementItems: [TimelineItem]?
+    
+    var presentedDonationCampaign: Mastodon.Entity.DonationCampaign?
+    
+    var isPerformingPostAction: (action: MastodonPostMenuAction, post: MastodonContentPost)? = nil
+    var isPerformingAccountAction: (action: MastodonPostMenuAction, account: MastodonAccount)? = nil
+    
+    var feedIsEmpty: Bool = false
+    
+    var currentDisplaySlice = ArraySlice<TimelineItem>()
+    var currentUseableWidth: CGFloat?
+    var scrollAnchorItem: TimelineItem = .noItem
+    var ignoreNextTopItemBecomeVisible: Bool = false // This is required to correct for the fact that the system will not update the scrollPosition when the user taps the status bar to scroll all the way to the top, and that the system will initially layout the view with the content scrolled all the way to the top any time the view reappears.
     
     enum ReloadReason {
         case notificationFilterPolicyUpdated
@@ -651,9 +623,8 @@ private class TimelineListViewModel: ObservableObject {
     
     public var parentVcPresentScene: ((SceneCoordinator.Scene, SceneCoordinator.Transition) -> ())?
     public var presentDonationDialog: ((Mastodon.Entity.DonationCampaign) -> ())?
-    @Published private(set) var authenticatedUser: MastodonAuthenticationBox? = AuthenticationServiceProvider.shared.currentActiveUser.value
     
-    var instanceConfigurationUpdateSubscription: AnyCancellable?
+    private var instanceConfigurationUpdateSubscription: AnyCancellable?
 
     var hostingViewController: MediaPreviewableViewController?
     
@@ -664,77 +635,64 @@ private class TimelineListViewModel: ObservableObject {
     var errorsWaitingToDisplay = [Error]()
     var activeAlert: MastodonPostMenuAction.AlertType = .noAlert {
         didSet {
-            if !isPresentingAlert && activeAlert.shouldBePresented {
-                isPresentingAlert = true
-            }
             displayNextErrorIfPossible()
         }
     }
-    var activeOverlay: MastodonTimelineOverlayView? = nil {
-        didSet {
-            if !isShowingOverlay && activeOverlay != nil {
-                isShowingOverlay = true
-            } else if isShowingOverlay && activeOverlay == nil {
-                isShowingOverlay = false
-            }
-        }
-    }
-    var activeSheet: MastodonTimelineSheet? = nil {
-        didSet {
-            if !isShowingSheet && activeSheet != nil {
-                isShowingSheet = true
-            } else if isShowingSheet && activeSheet == nil {
-                isShowingSheet = false
-            }
-        }
-    }
-    
-    @Published var isShowingOverlay: Bool = false
-    @Published var isShowingSheet: Bool = false
-    @Published var isPresentingAlert: Bool = false
-    @Published var presentedDonationCampaign: Mastodon.Entity.DonationCampaign?
-    
-    @Published var isPerformingPostAction: (action: MastodonPostMenuAction, post: MastodonContentPost)? = nil
-    @Published var isPerformingAccountAction: (action: MastodonPostMenuAction, account: MastodonAccount)? = nil
+    var activeOverlay: MastodonTimelineOverlayView? = nil
+    var activeSheet: MastodonTimelineSheet? = nil
     
-    @Published var feedIsEmpty: Bool = false
-    
-    @Published var useLazyVStack: Bool = false
-    
-    @Published var currentDisplaySlice = ArraySlice<TimelineItem>()
-    func setCurrentDisplaySlice(_ newSlice: ArraySlice<TimelineItem>) {
+    func setCurrentDisplaySlice(_ newSlice: ArraySlice<TimelineItem>, newScrollAnchor: TimelineItem?, mayNeedHeightCalculations: Bool, addLoadingIndicator: Bool) {
         // space to add any necessary bookkeeping before setting the slice
-        switch timeline {
-        case .notifications(.everything), .notifications(.mentions):
-            if newSlice.startIndex == 0 {
-                self.currentDisplaySlice = [.filteredNotificationsInfo(filteredNotificationsViewModel.policy, filteredNotificationsViewModel)] + newSlice
-            } else {
-                self.currentDisplaySlice = newSlice
+        let prefix: [TimelineItem] = {
+            switch timeline {
+            case .notifications(.everything), .notifications(.mentions):
+                if newSlice.startIndex == 0 {
+                    return [.filteredNotificationsInfo(filteredNotificationsViewModel.policy, filteredNotificationsViewModel)]
+                } else {
+                    return []
+                }
+            default:
+                return []
             }
-        default:
-            self.currentDisplaySlice = newSlice
+        }()
+        
+        let suffix: [TimelineItem] = addLoadingIndicator ? [.loadingIndicator] : []
+        if let newScrollAnchor {
+            scrollAnchorItem = newScrollAnchor
+
+            switch newScrollAnchor {
+            case .post:
+                let fullList = prefix + newSlice + suffix
+                let split = fullList.split(maxSplits: 1, omittingEmptySubsequences: true) { item in
+                    return item == newScrollAnchor
+                }
+                if !mayNeedHeightCalculations || split.count == 1 {
+                    currentDisplaySlice = fullList.prefix(fullList.count)
+                    self.resetToUntrackedAfterDelay()
+                } else if let belowAnchor = split.last, let aboveSplit = split.first {
+                    currentDisplaySlice = [newScrollAnchor] + belowAnchor
+                    self.requestCalculateHeightsAndPrependToCurrentDisplay(aboveSplit)
+                }
+            case .notification, .hashtag, .account, .filteredNotificationsInfo, .loadingIndicator, .noItem:
+                currentDisplaySlice = prefix + newSlice + suffix
+                self.resetToUntrackedAfterDelay()
+            }
+        } else {
+            currentDisplaySlice = prefix + newSlice + suffix
+            self.resetToUntrackedAfterDelay()
         }
     }
     
-    private var fullFeed = MastodonFeedLoaderResult(allRecords: [TimelineItem](), canLoadOlder: false)
-    private let displaySliceLength = 100
-    
-    @Published var unreadCount: Int = 0
-    @Published var scrollToTopRequested: Bool = false
-    
     private var followersAndBlockedChangeSubscription: AnyCancellable?
     private var feedLoader: TimelineFeedLoader?
     private var feedLoaderResultsSubscription: AnyCancellable?
     private var feedLoaderErrorSubscription: AnyCancellable?
     private var notificationCountUpdateSubscription: AnyCancellable?
-    
-    var scrollManager: ScrollManager?
-    
-    private let displayPrepBatchSize = 10
+
     private var currentlyPreparingForDisplay: [String]?
     private var displayPrepRequested: [MastodonPostViewModel]? // only keep the latest batch requested, to avoid getting bogged down while fast scrolling
     
-    public var lastReadState: LastReadState = .initializing
+    public var loadingState: LoadingState = .initializing
     
     public var threadedConversationModel: ThreadedConversationModel? {
         return feedLoader?.threadedConversationModel
@@ -765,9 +723,8 @@ private class TimelineListViewModel: ObservableObject {
         didSet {
             guard feedLoader?.timeline != timeline else { return }
             feedLoader = nil
-            lastReadState = .untracked
+            loadingState = .untracked
             currentDisplaySlice = ArraySlice([.loadingIndicator])
-            fullFeed = MastodonFeedLoaderResult(allRecords: [], canLoadOlder: true)
             Task {
                 try await doInitialLoad()
             }
@@ -793,41 +750,7 @@ private class TimelineListViewModel: ObservableObject {
         return feedLoader?.threadedConversationModel != nil
     }
     
-    private func getDisplaySlice(from items: [TimelineItem], startItemID: Mastodon.Entity.Status.ID?, canLoadOlder: Bool) -> ArraySlice<TimelineItem> {
-        if useLazyVStack || isThreadView {
-            return items[items.startIndex..<items.endIndex]
-        } else {
-            let startIndex = items.firstIndex(where: { $0.id == startItemID}) ?? 0
-            let endIndex = min(startIndex + displaySliceLength, items.endIndex)
-            return items[startIndex..<endIndex] + (endIndex != items.endIndex || canLoadOlder ? [.loadingIndicator] : [])
-        }
-    }
-    
-    private func getDisplaySlice(from items: [TimelineItem], midIndex: Int, canLoadOlder: Bool) -> ArraySlice<TimelineItem> {
-        if useLazyVStack || isThreadView {
-            return items[items.startIndex..<items.endIndex]
-        } else {
-            let startIndex = max(0, midIndex - (self.displaySliceLength / 2))
-            let endIndex = min(startIndex + self.displaySliceLength, items.endIndex)
-            return items[startIndex..<endIndex] + (endIndex < items.endIndex || canLoadOlder ? [.loadingIndicator] : [])
-        }
-    }
-    
-    private func getDisplaySlice(from items: [TimelineItem], endIndex: Int, canLoadOlder: Bool) -> ArraySlice<TimelineItem> {
-        if useLazyVStack || isThreadView {
-            return items[items.startIndex..<items.endIndex]
-        } else {
-            let startIndex = max(0, endIndex - self.displaySliceLength)
-            let endIndex = min(startIndex + self.displaySliceLength, items.endIndex)
-            return items[startIndex..<endIndex] + (endIndex < items.endIndex || canLoadOlder ? [.loadingIndicator] : [])
-        }
-    }
-    
-    func doInitialLoad() async throws {
-        guard feedLoader == nil else { return }
-        guard let authenticatedUser else { return }
-        clearPendingActions()
-        feedLoader = TimelineFeedLoader(currentUser: authenticatedUser, timeline: timeline)
+    func setUpFeedLoaderResultsSubscription() {
         feedLoaderResultsSubscription = feedLoader?.$records
             .sink{ [weak self] results in
                 
@@ -840,10 +763,9 @@ private class TimelineListViewModel: ObservableObject {
                     self?.feedIsEmpty = false
                 }
                 
-                
                 let needsPrep: [TimelineItem] = results.allRecords.compactMap { item -> TimelineItem? in
                     switch item {
-                    case .loadingIndicator, .filteredNotificationsInfo, .hashtag:
+                    case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .noItem:
                         return nil
                     case .account:
                         return item
@@ -854,57 +776,118 @@ private class TimelineListViewModel: ObservableObject {
                     }
                 }
                 
-                self?.doPrepareForDisplay(needsPrep, contentWidth: 0, completion: {
+                func doTheDisplay() {
                     DispatchQueue.main.async {
-                        guard let self else { return }
-                        
-                        debugScroll("doPrepareForDisplay is done")
-                        
-                        let currentFirstItemID = self.currentDisplaySlice.first(where: {
-                            switch $0 {
-                            case .post: return true
-                            default: return false
-                            }
-                        })?.id
-                        
-                        let newDisplaySlice: ArraySlice<TimelineItem>?
-
-                        if currentFirstItemID == nil {
-                            // current timeline is empty, so take the top slice of these items to display
-                            newDisplaySlice = self.getDisplaySlice(from: results.allRecords, startItemID: nil, canLoadOlder: results.canLoadOlder)
-                            self.resetToUntrackedAfterDelay()
-                        } else {
-                            switch self.lastReadState {
-                            case .initializing:
-                                self.resetToUntrackedAfterDelay()
-                                newDisplaySlice = nil // don't mess with the visible items
-                            case .untracked:
-                                newDisplaySlice = nil // don't mess with the visible items
-                            case .requestedReloadFromBottom:
-                                let lastCurrentItem = self.currentDisplaySlice.last(where: { $0.isRealItem })
-                                newDisplaySlice = self.getDisplaySlice(from: results.allRecords, startItemID: lastCurrentItem?.id, canLoadOlder: results.canLoadOlder)
-                            case .requestedReloadFromTop:
-                                assertionFailure("reload from top should only cause a new slice to be taken from the already available feed")
-                                if let firstCurrentItem = self.currentDisplaySlice.first(where: { $0.isRealItem}), let newIndex = results.allRecords.lastIndex(where: { $0.id == firstCurrentItem.id }) {
-                                    newDisplaySlice = self.getDisplaySlice(from: results.allRecords, endIndex: newIndex, canLoadOlder: results.canLoadOlder)
-                                } else {
-                                 // possible that the new set of results doesn't include what we were just looking at; in that case, jump to the top
-                                    newDisplaySlice = self.getDisplaySlice(from: results.allRecords, startItemID: nil, canLoadOlder: results.canLoadOlder)
-                                }
-                            case .pullToRefresh:
-                                // jump to the top
-                                newDisplaySlice = self.getDisplaySlice(from: results.allRecords, startItemID: nil, canLoadOlder: results.canLoadOlder)
-                            }
-                        }
-                        if let newDisplaySlice {
-                            self.fullFeed = results
-                            self.setCurrentDisplaySlice(newDisplaySlice)
-                        } else {
-                            self.fullFeed = results
-                        }
+                        self?.displayPreparedFeedloaderResults(items: results.allRecords, canLoadOlder: results.canLoadOlder)
                     }
+                }
+                if needsPrep.isEmpty {
+                    doTheDisplay()
+                } else {
+                    self?.doPrepareForDisplay(needsPrep, completion: {
+                        debugScroll("doPrepareForDisplay is done")
+                        doTheDisplay()
+                    })
+                }
+            }
+    }
+    
+    func displayPreparedFeedloaderResults(items: [TimelineItem], canLoadOlder: Bool) {
+        // first, ensure that the scrollAnchor is not the loadingIndicator
+        switch self.scrollAnchorItem {
+        case .noItem, .filteredNotificationsInfo:
+            // the new items will appear scrolled to the top, which is correct
+            break
+        case .loadingIndicator:
+            // if there was anything else in the feed, override this to be the last item before the loading indicator, to avoid jumping to the bottom of the new items
+            if let indexOfLoadingIndicator = self.currentDisplaySlice.lastIndex(of: .loadingIndicator), indexOfLoadingIndicator > 0 {
+                self.scrollAnchorItem = self.currentDisplaySlice[indexOfLoadingIndicator - 1]
+            }
+        default:
+            // the new items will appear scrolled to this current item if possible, which is correct
+            break
+        }
+        
+        // now, figure out how to handle these new items
+        let safeToSetNewItemsImmediately: Bool
+        let newItemsCount: Int
+        let newScrollAnchor: TimelineItem?
+        switch self.loadingState {
+        case .initializing:
+            newScrollAnchor = nil // we will jump to the top of this brand new feed
+            newItemsCount = 0 // ... so there will be no new items above the visible point
+            safeToSetNewItemsImmediately = true
+            
+        case .requestedReloadFromTop, .requestedPrependedHeightCalculations, .untracked:
+            // The new set of results may not include the current scroll anchor.  In that case, just show the new items snackbar and wait to do the actual reload (by tapping on the snackbar or doing a pull to refresh).
+            let previousFirstItem = self.currentDisplaySlice.first(where: { $0.isRealItem })
+            let currentFeedIsEmpty = previousFirstItem == nil
+            
+            safeToSetNewItemsImmediately = {
+                if self.scrollAnchorItem == .noItem || currentFeedIsEmpty {
+                    return true
+                } else if items.firstIndex(of: self.scrollAnchorItem) == nil {
+                    return false
+                } else {
+                    return true
+                }
+            }()
+            
+            newScrollAnchor = nil // leave the scrollAnchor alone
+            
+            if self.scrollAnchorItem == .noItem || currentFeedIsEmpty {
+                newItemsCount = 0  // will jump to top
+            } else {
+                let indexItem = previousFirstItem ?? self.scrollAnchorItem // this will always be the previousFirstItem, because the current feed is not empty
+                if let newIndexOfPreviousFirstItem = items.firstIndex(of: indexItem) {
+                    newItemsCount = newIndexOfPreviousFirstItem
+                } else if let newIndexOfScrollAnchor = items.firstIndex(of: self.scrollAnchorItem) {
+                    // we may be missing an edge case here, where the first item in the old feed got deleted, but there is still overlap with the new feed.  in that case, this may overestimate the number of truly new items, but at least they will be items above the scrollAnchor
+                    newItemsCount = newIndexOfScrollAnchor
+                } else {
+                    assert(!safeToSetNewItemsImmediately)
+                    newItemsCount = items.count
+                }
+            }
+            
+        case .requestedReloadFromBottom:
+            // leave the scrollPosition alone, it should work
+            safeToSetNewItemsImmediately = true
+            newScrollAnchor = nil
+            newItemsCount = self.unreadCount
+        }
+        
+        // if this is a thread view, we might need to do the initial scroll to the focused post
+        let initialThreadAnchorItem: TimelineItem? = {
+            if let threadedModel = self.threadedConversationModel, !threadedModel.hasScrolledToFocusedPost {
+                threadedModel.hasScrolledToFocusedPost = true
+                return items.first(where: { item in
+                    item.id.hasSuffix(threadedModel.focusedID)
                 })
+            } else {
+                return nil
             }
+        }()
+        
+        if timeline.canDisplayNewItemsSnackbar {
+            self.unreadCount = newItemsCount
+        }
+        
+        if safeToSetNewItemsImmediately {
+            self.resetToUntrackedAfterDelay()
+            self.setCurrentDisplaySlice(items.prefix(items.count), newScrollAnchor: initialThreadAnchorItem ?? newScrollAnchor, mayNeedHeightCalculations: true, addLoadingIndicator: canLoadOlder)
+        } else {
+            self.waitingReplacementItems = items
+        }
+    }
+    
+    func doInitialLoad() async throws {
+        guard feedLoader == nil else { return }
+        guard let authenticatedUser else { return }
+        clearPendingActions()
+        feedLoader = TimelineFeedLoader(currentUser: authenticatedUser, timeline: timeline)
+        
+        setUpFeedLoaderResultsSubscription()
         
         feedLoaderErrorSubscription = feedLoader?.$currentError
             .receive(on: DispatchQueue.main)
@@ -953,50 +936,18 @@ private class TimelineListViewModel: ObservableObject {
     }
     
     func loadMoreFromBottom() {
-        lastReadState = .requestedReloadFromBottom
-        if currentDisplaySlice.endIndex < fullFeed.allRecords.endIndex {
-            let scrollToTop = currentDisplaySlice.last(where: {
-                $0.isRealItem
-            })
-            guard let scrollToTop else {
-                debugScroll("could not find a tail item in the current slice")
-                resetToUntrackedAfterDelay()
-                return
-            }
-            setCurrentDisplaySlice(getDisplaySlice(from: fullFeed.allRecords, startItemID: scrollToTop.id, canLoadOlder: fullFeed.canLoadOlder))
-        } else {
-            guard let feedLoader else {
-                // this is a valid state when switching between timelines
-                resetToUntrackedAfterDelay()
-                return
-            }
-            feedLoader.requestLoad(.older)
-        }
-    }
-    
-    func loadNewerSlice() {
-        if currentDisplaySlice.startIndex > 0 {
-            lastReadState = .requestedReloadFromTop
-            let lastVisibleHeadIndex = currentDisplaySlice.firstIndex(where: { $0.isRealItem })
-            guard let lastVisibleHeadIndex else {
-                debugScroll("could not find a head index in the current slice")
-                resetToUntrackedAfterDelay()
-                return
-            }
-            setCurrentDisplaySlice(getDisplaySlice(from: fullFeed.allRecords, endIndex: lastVisibleHeadIndex, canLoadOlder: fullFeed.canLoadOlder))
-        } else {
+        loadingState = .requestedReloadFromBottom
+        guard let feedLoader else {
+            // this is a valid state when switching between timelines
             resetToUntrackedAfterDelay()
+            return
         }
+        feedLoader.requestLoad(.older)
     }
     
     func refreshFromTop() async {
-        assert(lastReadState == .pullToRefresh)
-        if currentDisplaySlice.startIndex == 0 {
-            await forceReload(.userRequestedRefresh)
-        } else {
-            lastReadState = .requestedReloadFromTop
-            loadNewerSlice()
-        }
+        assert(loadingState == .requestedReloadFromTop)
+        await forceReload(.userRequestedRefresh)
     }
     
     func forceReload(_ reason: ReloadReason) async {
@@ -1010,7 +961,7 @@ private class TimelineListViewModel: ObservableObject {
         case .notificationCountUpdated:
             fetchFilteredNotificationsPolicy(andReloadFeed: true)
         case .notificationFilterPolicyUpdated:
-            lastReadState = .pullToRefresh
+            loadingState = .requestedReloadFromTop
             feedLoader.requestLoad(.reload)
         case .userRequestedRefresh:
             if timeline.canDisplayFilteredNotifications {
@@ -1025,23 +976,11 @@ private class TimelineListViewModel: ObservableObject {
     }
     
     func scrollToTop() {
-        setCurrentDisplaySlice(getDisplaySlice(from: fullFeed.allRecords, startItemID: nil, canLoadOlder: fullFeed.canLoadOlder))
-        scrollToTopRequested = true
-    }
-    
-    func didAppear(_ postViewModel: MastodonPostViewModel, contentWidth: CGFloat) {
-        guard currentDisplaySlice.endIndex < fullFeed.allRecords.endIndex || fullFeed.canLoadOlder == true else {
-            debugScroll("have loaded as far back as possible")
-            return
-        }
-        switch lastReadState {
-        case .initializing:
-            resetToUntrackedAfterDelay()
-        case .untracked:
-            break
-        case .requestedReloadFromTop, .requestedReloadFromBottom, .pullToRefresh:
-            debugScroll("head or tail item appeared.  ignoring because state is \(lastReadState)")
-            break
+        if let waitingReplacementItems, !waitingReplacementItems.isEmpty {
+            self.waitingReplacementItems = nil
+            setCurrentDisplaySlice(waitingReplacementItems.prefix(waitingReplacementItems.count), newScrollAnchor: waitingReplacementItems.first ?? .noItem, mayNeedHeightCalculations: false, addLoadingIndicator: true)
+        } else {
+            scrollAnchorItem = currentDisplaySlice.first ?? .noItem
         }
     }
     
@@ -1064,6 +1003,46 @@ private class TimelineListViewModel: ObservableObject {
     }
 }
 
+extension TimelineListViewModel {
+    
+    func requestCalculateHeightsAndPrependToCurrentDisplay(_ items: ArraySlice<TimelineItem>) {
+        let token = UUID()
+        loadingState = .requestedPrependedHeightCalculations(token)
+        let toCalculate = items.compactMap({ item in
+            switch item {
+            case .post(let viewModel):
+                return viewModel
+            default:
+                assertionFailure("precalculating height is not supported for \(item.id)")
+                return nil
+            }
+        })
+        Task {
+            for model in toCalculate {
+                await calculateHeight(model)
+            }
+            let calculatedItems = toCalculate.map { model in
+                TimelineItem.post(model)
+            }
+            switch loadingState {
+            case .requestedPrependedHeightCalculations(token):
+                setCurrentDisplaySlice(calculatedItems + currentDisplaySlice, newScrollAnchor: nil, mayNeedHeightCalculations: false, addLoadingIndicator: false)
+            default:
+                assertionFailure("outran the height calculations. \(calculatedItems.count) items may never be added to the display")
+                break
+            }
+        }
+    }
+    
+    func calculateHeight(_ model: MastodonPostViewModel) async {
+        guard let currentUseableWidth else { return }
+        let contentWidth = contentWidth(forUseableWidth: currentUseableWidth)
+        let height = await ViewMeasurer.shared.calculateHeight(for: model, contentConcealModel: contentConcealModel(forActionablePost: model.initialDisplayInfo.actionablePostID), filterContext: timeline.filterContext, threadedContext: threadedConversationModel?.context(for: model.initialDisplayInfo.id), contentWidth: contentWidth, totalWidth: currentUseableWidth)
+        model.precalculatedHeights.insert(height, at: 0)
+    }
+    
+}
+
 extension TimelineListViewModel {
     func fetchFilteredNotificationsPolicy(andReloadFeed reload: Bool) {
         guard
@@ -1085,10 +1064,10 @@ extension TimelineListViewModel {
         filteredNotificationsViewModel.policy = policy
         guard reload else { return }
         
-        switch lastReadState {
+        switch loadingState {
         case .initializing:
             break
-        case .pullToRefresh, .requestedReloadFromBottom, .requestedReloadFromTop:
+        case .requestedReloadFromTop, .requestedReloadFromBottom, .requestedPrependedHeightCalculations:
             break
         case .untracked:
             Task {
@@ -1099,31 +1078,8 @@ extension TimelineListViewModel {
 }
 
 extension TimelineListViewModel {
-    private func createPrepBatch(anchoredAt anchorIndex: Int) -> [TimelineItem]? {
-        guard let feedLoaderRecords = feedLoader?.records.allRecords else { return nil }
-        let batchStart = max(0, anchorIndex - displayPrepBatchSize / 2)
-        guard batchStart < feedLoaderRecords.count else { return nil }
-        let batchItems = feedLoaderRecords[batchStart...].prefix(displayPrepBatchSize).compactMap { item -> TimelineItem? in
-            switch item {
-            case .loadingIndicator, .filteredNotificationsInfo, .hashtag:
-                return nil
-            case .post(let postViewModel):
-                // not donePreparing, not included in currently preparing (inclusion in requested does not matter, because this batch may replace the current requested batch)
-                guard postViewModel.displayPrepStatus == .unprepared else { return nil }
-                return item
-            case .notification(let notificationViewModel):
-                guard notificationViewModel.displayPrepStatus == .unprepared else { return nil }
-                return item
-            case .account:
-                return item
-            }
-        }
-        
-        guard !batchItems.isEmpty else { return nil }
-        return batchItems
-    }
     
-    private func doPrepareForDisplay(_ batch: [TimelineItem], contentWidth: CGFloat, completion: (()->())? = nil) {
+    private func doPrepareForDisplay(_ batch: [TimelineItem], completion: (()->())? = nil) {
         guard let feedLoader else { completion?(); return }
         guard currentlyPreparingForDisplay == nil else { completion?(); return }
         currentlyPreparingForDisplay = batch.compactMap { item in
@@ -1136,7 +1092,7 @@ extension TimelineListViewModel {
                 return nil
             case .account:
                 return item.id
-            case .filteredNotificationsInfo, .loadingIndicator:
+            case .filteredNotificationsInfo, .loadingIndicator, .noItem:
                 return nil
             }
         }
@@ -1178,7 +1134,7 @@ extension TimelineListViewModel {
                 relationshipsToFetch.insert(accountRowViewModel.id)
             case .hashtag:
                 break
-            case .filteredNotificationsInfo, .loadingIndicator:
+            case .filteredNotificationsInfo, .loadingIndicator, .noItem:
                 break
             }
         }
@@ -1203,9 +1159,6 @@ extension TimelineListViewModel {
                     
                     postModel.prepareForDisplay(relationship: relationship, theirAccountIsLocked: postModel.fullPost?.actionablePost?.metaData.author.locked ?? false)
                 }
-                if postModel.actionHandler == nil {
-                    postModel.actionHandler = self
-                }
                 postModel.displayPrepStatus = .donePreparing
             }
             
@@ -1233,7 +1186,7 @@ extension TimelineListViewModel {
                     break
                 case .hashtag:
                     break
-                case .filteredNotificationsInfo, .loadingIndicator:
+                case .filteredNotificationsInfo, .loadingIndicator, .noItem:
                     break
                 }
             }
@@ -1246,20 +1199,19 @@ extension TimelineListViewModel {
 }
 
 extension TimelineListViewModel {
-    enum LastReadState {
+    enum LoadingState: Equatable {
         case initializing
         case untracked
-        case requestedReloadFromTop
+        case requestedPrependedHeightCalculations(UUID)
         case requestedReloadFromBottom
-        case pullToRefresh
-        
+        case requestedReloadFromTop
     }
     
     func resetToUntrackedAfterDelay() {
         debugScroll("will reset to untracked")
         DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(500)) {
             // the delay prevents loads immediately triggering new loads
-            self.lastReadState = .untracked
+            self.loadingState = .untracked
             debugScroll("did reset to untracked")
         }
     }
@@ -1305,20 +1257,21 @@ extension TimelineListViewModel {
 
 private let scrollViewCoordinateSpace = "ScrollViewCoordinateSpace"
 
+var avatarSize = AvatarSize.large
+func useableWidth(fromGeoProxy geo: GeometryProxy) -> CGFloat {
+    return geo.size.width - geo.safeAreaInsets.leading - geo.safeAreaInsets.trailing
+}
+
+func contentWidth(forUseableWidth useableWidth: CGFloat) -> CGFloat {
+    return max(1, useableWidth - (standardPadding /*left margin*/ + spacingBetweenGutterAndContent /*avatar trailing to content leading*/ + doublePadding /*right margin*/) - avatarSize)
+}
+
 struct TimelineListView: View {
-    @ObservedObject private var viewModel: TimelineListViewModel
-    @State private var scrollManager = ScrollManager()
-    
-    @ScaledMetric private var avatarSize = AvatarSize.large
-    
-    fileprivate init(viewModel: TimelineListViewModel) {
-        self.viewModel = viewModel
-        viewModel.scrollManager = scrollManager
-    }
+    @Environment(TimelineListViewModel.self) private var viewModel
     
     var body: some View {
         GeometryReader { geo in
-            ZStack(alignment: .bottom) { // to show ALT text when needed, and donation banner
+            ZStack(alignment: .bottom) { // to show ALT text when needed, and donation banner, and snackbar
                 if viewModel.feedIsEmpty {
                     Image(uiImage: Asset.Asset.friends.image)
                         .resizable()
@@ -1338,93 +1291,59 @@ struct TimelineListView: View {
                 } else {
                     ScrollViewReader { proxy in
                         ScrollView(showsIndicators: false) {
-                            if viewModel.useLazyVStack {
-                                LazyVStack {
-                                    feedContents(geo)
-                                }
-                            } else {
-                                VStack {
-                                    feedContents(geo)
-                                }
+                            LazyVStack(spacing: 0) {
+                                feedContents(geo)
                             }
+                            .scrollTargetLayout()
                         }
-                        .onChange(of: viewModel.currentDisplaySlice, initial: true) { oldValue, newValue in
-                            if let threadedModel = viewModel.threadedConversationModel, !threadedModel.hasScrolledToFocusedPost {
-                                threadedModel.hasScrolledToFocusedPost = true
-                                scrollManager.scrollTo(lastReadID: threadedModel.focusedID, anchor: .top, items: newValue, proxy: proxy) { success in
-                                    viewModel.resetToUntrackedAfterDelay()
-                                }
-                            } else {
-                                
-                                switch viewModel.lastReadState {
-                                case .untracked, .initializing:
-                                    debugScroll("NOTHING TO SCROLL TO")
-                                    break
-                                case .pullToRefresh, .requestedReloadFromTop:
-                                    debugScroll("pull to refresh replaced the current slice, doing nothing should jump to the top")
-                                    viewModel.resetToUntrackedAfterDelay()
-                                case .requestedReloadFromBottom:
-                                    debugScroll("reload from bottom replaced the current slice")
-                                    
-                                    DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(100)) {
-                                        if let topItemID = newValue.first(where: { $0.isRealItem })?.id {
-                                            // without requesting scroll, the view seems to automatically peg the loading indicator as the thing that shouldn't move, so you're stuck at the end
-                                            debugScroll("scrolling to the top item in the new lower slice")
-                                            if let anchorIndex = viewModel.currentDisplaySlice.firstIndex(where: { $0.id == topItemID }) {
-                                                debugScroll("will try to scroll to \(topItemID), which is at index \(anchorIndex) in slice \(viewModel.currentDisplaySlice.startIndex)-\(viewModel.currentDisplaySlice.endIndex)")
-                                            }
-                                            scrollManager.scrollTo(lastReadID: topItemID, anchor: .bottom, items: self.viewModel.currentDisplaySlice, proxy: proxy) { success in
-                                                viewModel.resetToUntrackedAfterDelay()
-                                            }
-                                        } else {
-                                            viewModel.resetToUntrackedAfterDelay()
-                                        }
-                                    }
-                                }
-                            }
+                        .scrollPosition(id: Binding(get: {
+                            return viewModel.scrollAnchorItem
+                        }, set: { newAnchorItem in
+                            viewModel.scrollAnchorItem = newAnchorItem ?? .noItem
+                        }), anchor: .top)
+                        .onChange(of: geo.size.width, initial: true) { _, _ in
+                            viewModel.currentUseableWidth = useableWidth(fromGeoProxy: geo)
                         }
-                        .onChange(of: viewModel.scrollToTopRequested, { oldValue, newValue in
-                            debugScroll("scroll to top requested")
-                            if newValue == true, let anchorID = viewModel.currentDisplaySlice.first?.id { // TODO: jump all the way to the top, or possibly even reload from server
-                                Task {
-                                    if let anchorIndex = viewModel.currentDisplaySlice.firstIndex(where: { $0.id == anchorID }) {
-                                        debugScroll("will try to scroll to \(anchorID), which is at index \(anchorIndex) in slice \(viewModel.currentDisplaySlice.startIndex)-\(viewModel.currentDisplaySlice.endIndex)")
-                                    }
-                                    scrollManager.scrollTo(lastReadID: anchorID, anchor: .top, items: viewModel.currentDisplaySlice, proxy: proxy, completion: { success in
-                                        debugScroll("scroll to top completed! \(success)")
-                                        DispatchQueue.main.async {
-                                            viewModel.scrollToTopRequested = false
-                                        }
-                                    })
+                        .onChange(of: geo.safeAreaInsets, initial: true) { oldValue, newValue in
+                            viewModel.currentUseableWidth = useableWidth(fromGeoProxy: geo)
+                        }
+                        .onChange(of: viewModel.scrollAnchorItem) { oldValue, newValue in
+                            if viewModel.unreadCount > 0 {
+                                if let indexOfNewScrollAnchor = viewModel.currentDisplaySlice.firstIndex(of: newValue), indexOfNewScrollAnchor < viewModel.unreadCount {
+                                    viewModel.unreadCount = indexOfNewScrollAnchor
                                 }
                             }
-                        })
+                        }
                         .refreshable {
                             debugScroll("REFRESHABLE?")
-                            switch viewModel.lastReadState {
+                            switch viewModel.loadingState {
                             case .initializing:
                                 break
                             case .untracked:
-                                viewModel.lastReadState = .pullToRefresh
+                                viewModel.loadingState = .requestedReloadFromTop
                                 debugScroll("refreshing feed")
-                                await viewModel.refreshFromTop()
-                                viewModel.resetToUntrackedAfterDelay()
-                            case .pullToRefresh, .requestedReloadFromBottom, .requestedReloadFromTop:
-                                debugScroll("not refreshing feed.  current state is \(viewModel.lastReadState)")
+                                if let waiting = viewModel.waitingReplacementItems, !waiting.isEmpty {
+                                    viewModel.scrollToTop()
+                                } else {
+                                    await viewModel.refreshFromTop()
+                                    viewModel.resetToUntrackedAfterDelay()
+                                }
+                            case .requestedReloadFromTop, .requestedReloadFromBottom, .requestedPrependedHeightCalculations:
+                                debugScroll("not refreshing feed.  current state is \(viewModel.loadingState)")
                                 break
                             }
                         }
                         .accessibilityAction(named: L10n.Common.Controls.Actions.loadNewer) {
-                            switch viewModel.lastReadState {
+                            switch viewModel.loadingState {
                             case .initializing:
                                 break
                             case .untracked:
-                                viewModel.lastReadState = .pullToRefresh
+                                viewModel.loadingState = .requestedReloadFromTop
                                 Task {
                                     await viewModel.refreshFromTop()
                                     viewModel.resetToUntrackedAfterDelay()
                                 }
-                            case .pullToRefresh, .requestedReloadFromBottom, .requestedReloadFromTop:
+                            case .requestedReloadFromTop, .requestedReloadFromBottom, .requestedPrependedHeightCalculations:
                                 break
                             }
                         }
@@ -1447,12 +1366,23 @@ struct TimelineListView: View {
                         })
                         .fixedSize(horizontal: false, vertical: true)
                     }
+                    
+                    if viewModel.unreadCount > 0 {
+                        VStack(alignment: .trailing) {
+                            Snackbar(barType: .newUnreadItems(viewModel.unreadCount))
+                                .onTapGesture {
+                                    viewModel.scrollToTop()
+                                }
+                            Spacer()
+                                .frame(maxWidth: .infinity, maxHeight: .infinity)
+                        }
+                        .padding(tinySpacing)
+                    }
                 }
-            }
-        }
+            } // ZStack(alignment: .bottom)
+        } // GeometryReader
         .onAppear() {
             viewModel.clearPendingActions()
-            scrollManager.viewDidAppear()
             if viewModel.timeline.canDisplayDonationBanner {
                 Task {
                     await viewModel.askForDonationIfPossible()
@@ -1469,17 +1399,29 @@ struct TimelineListView: View {
             }
         }
         .onDisappear() {
-            viewModel.lastReadState = .untracked
-            scrollManager.viewDidDisappear()
+            viewModel.ignoreNextTopItemBecomeVisible = true
+            viewModel.loadingState = .untracked
         }
-        .alert(viewModel.activeAlert.title, isPresented: $viewModel.isPresentingAlert, presenting: viewModel.activeAlert) { alert in
+        .alert(viewModel.activeAlert.title, isPresented: Binding(get: {
+            return viewModel.activeAlert.shouldBePresented
+        }, set: { isPresenting in
+            if !isPresenting {
+                viewModel.activeAlert = .noAlert
+            }
+        }), presenting: viewModel.activeAlert) { alert in
             alertContents(alert)
         } message: { alert in
             if let messageText = alert.messageText {
                 Text(messageText)
             }
         }
-        .sheet(isPresented: $viewModel.isShowingSheet) {
+        .sheet(isPresented: Binding(get: {
+            viewModel.activeSheet != nil
+        }, set: { isPresented in
+            if !isPresented {
+                viewModel.activeSheet = nil
+            }
+        })) {
             switch viewModel.activeSheet {
             case .postInteractionSettingsEdit(let editModel):
                 PostInteractionSettingsView(closeAndSave: { save in
@@ -1502,7 +1444,7 @@ struct TimelineListView: View {
                 .presentationDragIndicator(.hidden)
                 .interactiveDismissDisabled(true)
             case .boostOrQuoteDialog(let postViewModel):
-                BoostOrQuoteDialog()
+                BoostOrQuoteDialog(actionHandler: viewModel)
                     .environment(postViewModel)
                     .presentationDetents([.fraction(0.3), .medium, .large])
             case .none:
@@ -1510,7 +1452,7 @@ struct TimelineListView: View {
             }
         }
         .overlay {
-            if viewModel.isShowingOverlay, let activeOverlay = viewModel.activeOverlay {
+            if let activeOverlay = viewModel.activeOverlay {
                 GeometryReader { geo in
                     ZStack(alignment: .topLeading) {
                         ZStack {
@@ -1538,9 +1480,19 @@ struct TimelineListView: View {
         .environment(TimestampUpdater.timestamper(withInterval: 30))
     }
     
+    func precalculatedHeight(fromCalculations calculations: [PrecalculatedHeight], contentWidth width: CGFloat, contentConcealMode: ContentConcealViewModel.ContentDisplayMode, isShowingTranslation: Bool) -> CGFloat? {
+        return calculations.first(where: { precalculated in
+            precalculated.contentWidth == width
+            && precalculated.contentConcealed.isShowingContent == contentConcealMode.isShowingContent
+            && precalculated.contentConcealed.isShowingMedia == contentConcealMode.isShowingMedia
+            && precalculated.showingTranslation == isShowingTranslation
+        })?.calculatedHeight
+    }
+    
     @ViewBuilder func feedContents(_ geo: GeometryProxy) -> some View {
-        let usableWidth = geo.size.width - geo.safeAreaInsets.leading - geo.safeAreaInsets.trailing
-        let contentWidth = max(1, usableWidth - (standardPadding /*left margin*/ + spacingBetweenGutterAndContent /*avatar trailing to content leading*/ + doublePadding /*right margin*/) - avatarSize)
+        let useableWidth = useableWidth(fromGeoProxy: geo)
+        let contentWidth = contentWidth(forUseableWidth: useableWidth)
+
         ForEach(viewModel.currentDisplaySlice, id: \.self) { item in
             switch item {
             case .loadingIndicator:
@@ -1552,16 +1504,17 @@ struct TimelineListView: View {
                 }
                 .padding(EdgeInsets(top: 100, leading: 0, bottom: 100, trailing: 0))
                 .accessibilityAction(named: L10n.Common.Controls.Actions.loadOlder) {
-                    switch viewModel.lastReadState {
+                    switch viewModel.loadingState {
                     case .untracked:
                         viewModel.loadMoreFromBottom()
                     default:
                         break
                     }
                 }
-                VisibilityTrackingView(visibilityDidChange: { isVisible in
+                VisibilityTrackingView(scrollCoordinateSpace: scrollViewCoordinateSpace,
+                                       visibleAreaHeight: geo.size.height, visibilityDidChange: { isVisible in
                     if isVisible {
-                        switch viewModel.lastReadState {
+                        switch viewModel.loadingState {
                         case .initializing:
                             viewModel.resetToUntrackedAfterDelay()
                         case .untracked:
@@ -1570,9 +1523,7 @@ struct TimelineListView: View {
                             break
                         }
                     }
-                },
-                                       scrollCoordinateSpace: scrollViewCoordinateSpace,
-                                       visibleAreaHeight: geo.size.height)
+                })
                 .frame(width: 10, height: 1)
                 
             case .filteredNotificationsInfo(_, let filteredNotificationsViewModel):
@@ -1580,7 +1531,7 @@ struct TimelineListView: View {
                     FilteredNotificationsRowView(contentWidth: contentWidth)
                         .environment(filteredNotificationsViewModel)
                         .padding(EdgeInsets(top: standardPadding, leading: standardPadding, bottom: standardPadding, trailing: doublePadding))
-                        .frame(width: usableWidth)
+                        .frame(width: useableWidth)
                         .accessibilityElement(children: .combine)
                         .accessibilityAction {
                             goToFilteredNotifications(filteredNotificationsViewModel)
@@ -1591,7 +1542,7 @@ struct TimelineListView: View {
                 } else {
                     Text("Some notifications have been filtered.")
                         .padding(EdgeInsets(top: standardPadding, leading: standardPadding, bottom: standardPadding, trailing: doublePadding))
-                        .frame(width: usableWidth)
+                        .frame(width: useableWidth)
                 }
                 Divider()
                 
@@ -1607,11 +1558,60 @@ struct TimelineListView: View {
                 }
 #endif
                 
-                MastodonPostRowView(contentWidth: contentWidth)
+                let contentConcealModel = viewModel.contentConcealModel(forActionablePost: postViewModel.initialDisplayInfo.actionablePostID)
+                let expectedHeight: CGFloat? = postViewModel.initialDisplayInfo.id == viewModel.threadedConversationModel?.focusedID ? nil :  precalculatedHeight(fromCalculations: postViewModel.precalculatedHeights, contentWidth: contentWidth, contentConcealMode: contentConcealModel.currentMode, isShowingTranslation: postViewModel.isShowingTranslation == true)
+                MastodonPostRowView(contentWidth: contentWidth, precalculatedHeight: expectedHeight, actionHandler: viewModel, threadedContext: viewModel.threadedConversationModel?.context(for: postViewModel.initialDisplayInfo.id), filterContext: viewModel.timeline.filterContext)
                 .environment(postViewModel)
-                .environment(viewModel.contentConcealModel(forActionablePost: postViewModel.initialDisplayInfo.actionablePostID))
+                .environment(contentConcealModel)
                 .padding(EdgeInsets(top: 0, leading: standardPadding, bottom: 0, trailing: doublePadding))
-                .frame(width: usableWidth)
+                .frame(width: useableWidth, height: expectedHeight, alignment: .top)
+                #if DEBUG
+                .background {
+                    ZStack(alignment: .topTrailing) {
+                        HStack {
+                            Spacer()
+                                .frame(width: AvatarSize.large + spacingBetweenGutterAndContent)
+                            Rectangle()
+                                .fill(viewModel.scrollAnchorItem == item ? .yellow.opacity(0.2) : .clear)
+                                .frame(width: spacingBetweenGutterAndContent)
+                            Spacer()
+                                .frame(maxWidth: .infinity)
+                        }
+                        
+#if DEBUG
+                        if let expectedHeight {
+                            let difference: CGFloat? = {
+                                guard let actual = postViewModel.actualLayoutHeight else { return nil }
+                                return actual - expectedHeight
+                            }()
+                            Text("calculated: \(expectedHeight)\nactual: \(postViewModel.actualLayoutHeight)\ndifference: \(difference)")
+                                .foregroundStyle(.red)
+                                .padding()
+                                .background {
+                                    RoundedRectangle(cornerRadius: 10)
+                                        .fill(.white.opacity(0.3))
+                                }
+                            FrameReader() { newFrame in
+                                postViewModel.actualLayoutHeight = newFrame.size.height
+                            }
+                        }
+#endif
+                        
+                        if item == viewModel.currentDisplaySlice.first {
+                            VisibilityTrackingView(scrollCoordinateSpace: scrollViewCoordinateSpace,
+                                                   visibleAreaHeight: geo.size.height, visibilityDidChange: { isVisible in
+                                if isVisible {
+                                    if !viewModel.ignoreNextTopItemBecomeVisible && viewModel.scrollAnchorItem.id != item.id {
+                                        viewModel.scrollAnchorItem = .noItem
+                                    } else {
+                                        viewModel.ignoreNextTopItemBecomeVisible = false
+                                    }
+                                }
+                            })
+                        }
+                    }
+                }
+#endif
                 .contentShape(Rectangle())
                 .onTapGesture {
                     switch viewModel.timeline {
@@ -1622,7 +1622,7 @@ struct TimelineListView: View {
                     default:
                         break
                     }
-                    postViewModel.openThreadView()
+                    postViewModel.openThreadView(actionHandler: viewModel)
                 }
                 .background() {
                     switch viewModel.timeline {
@@ -1638,10 +1638,10 @@ struct TimelineListView: View {
                     }
                 }
             case .notification(let notificationViewModel):
-                NotificationRowView(contentWidth: contentWidth)
+                NotificationRowView(contentWidth: contentWidth, actionHandler: viewModel)
                     .environment(notificationViewModel)
                     .padding(EdgeInsets(top: standardPadding, leading: standardPadding, bottom: standardPadding, trailing: doublePadding))
-                    .frame(width: usableWidth)
+                    .frame(width: useableWidth)
                     .background() {
                         if let inlinePost = notificationViewModel.inlinePostViewModel {
                             switch inlinePost.initialDisplayInfo.actionableVisibility {
@@ -1658,17 +1658,17 @@ struct TimelineListView: View {
                     HashtagHeaderView()
                         .environment(tagViewModel)
                         .padding(EdgeInsets(top: doublePadding, leading: doublePadding, bottom: standardPadding, trailing: doublePadding))
-                        .frame(width: usableWidth)
+                        .frame(width: useableWidth)
                     Divider()
                 case .myFollowedHashtags:
                     HashtagHeaderView()
                         .environment(tagViewModel)
                         .padding(EdgeInsets(top: doublePadding, leading: doublePadding, bottom: standardPadding, trailing: doublePadding))
-                        .frame(width: usableWidth)
+                        .frame(width: useableWidth)
                 default:
                     HashtagRowView()
                         .padding(EdgeInsets(top: doublePadding, leading: doublePadding, bottom: standardPadding, trailing: doublePadding))
-                        .frame(width: usableWidth)
+                        .frame(width: useableWidth)
                         .environment(tagViewModel)
                         .onTapGesture {
                             viewModel.presentScene(.hashtagTimeline(tagViewModel.entity), fromPost: nil, transition: .show)
@@ -1678,10 +1678,12 @@ struct TimelineListView: View {
                 AccountRowView(contentWidth: contentWidth)
                     .environment(accountViewModel)
                     .padding(EdgeInsets(top: standardPadding, leading: doublePadding, bottom: standardPadding, trailing: standardPadding))
-                    .frame(width: usableWidth)
+                    .frame(width: useableWidth)
                     .onTapGesture {
                         accountViewModel.goToProfile()
                     }
+            case .noItem:
+                EmptyView()
             }
         }
         if viewModel.threadedConversationModel != nil {
@@ -1830,84 +1832,6 @@ struct TimelineListView: View {
 }
 
 
-fileprivate let totalRetryCount: Int = 5
-fileprivate class ScrollManager {
-    public var isAppeared: Bool = false
-    
-    private var visibleItems = Set<String>()
-    
-    func isVisible(_ id: String) -> Bool {
-        return visibleItems.contains(id)
-    }
-    
-    func reset() {
-        visibleItems.removeAll()
-    }
-    
-    func viewDidAppear() {
-        assert(!isAppeared)
-        isAppeared = true
-        debugScroll("view appeared +")
-    }
-    
-    func viewDidDisappear() {
-        assert(isAppeared)
-        isAppeared = false
-        debugScroll("view DISAPPEARED -")
-    }
-    
-    func didAppear(_ itemID: String) {
-        visibleItems.insert(itemID)
-        debugScroll("item appeared + \(itemID)")
-    }
-    
-    func didDisappear(_ itemID: String) {
-        visibleItems.remove(itemID)
-        debugScroll("item disappeared - \(itemID)")
-    }
-
-    func scrollTo(lastReadID: String?, anchor: UnitPoint?, items: ArraySlice<TimelineItem>, proxy: ScrollViewProxy, retryCount: Int = totalRetryCount, completion: @escaping (Bool)->()) {
-        guard isAppeared else {
-            // the proxy scroll does not behave correctly until the view is on screen
-            debugScroll("cannot scroll! have not appeared!")
-            return
-        }
-        let lastReadMatch = items.first(where: { lastReadID == $0.id })
-        guard let anchorItem = lastReadMatch else {
-            // there is nothing to scroll to
-            debugScroll("will not scroll because there is no match!")
-            return
-        }
-        DispatchQueue.main.async {
-            let firstVisibleItem = items.first(where: { self.visibleItems.contains($0.id) })
-            debugScroll("attempting scroll to \(anchorItem.id) with \(retryCount) retries left. top visible item is \(firstVisibleItem?.id ?? "NIL").  All \(self.visibleItems.count) visible items:")
-            for itemID in self.visibleItems {
-                debugScroll(itemID)
-            }
-            proxy.scrollTo(anchorItem, anchor: anchor)
-            
-            DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(100 * (totalRetryCount - retryCount))) { [weak self] in
-                guard let self, retryCount > 0 else {
-                    debugScroll("failed all retries!")
-                    completion(false)
-                    return
-                }
-                if let lastReadID, !self.visibleItems.contains(lastReadID) {
-                    scrollTo(lastReadID: lastReadID, anchor: anchor, items: items, proxy: proxy, retryCount: retryCount - 1, completion: completion)
-                } else {
-                    debugScroll("Success with \(retryCount) tries left!")
-                    completion(true)
-                }
-            }
-        }
-    }
-    
-    func topVisibleIndex(in items: ArraySlice<TimelineItem>) -> Int {
-        let index = items.firstIndex(where: { visibleItems.contains($0.id) })
-        debugScroll("top visible index is \(index ?? 0) (with a list of \(visibleItems.count) visible items)")
-        return index ?? 0
-    }
-}
 
 extension MastodonTimelineOverlayView {
     @MainActor
@@ -2036,7 +1960,7 @@ extension TimelineListViewModel: MastodonPostMenuActionHandler {
                     feedLoader?.updateCachedResults({ timeline in
                         for item in timeline.items {
                             switch item {
-                            case .loadingIndicator, .filteredNotificationsInfo, .hashtag:
+                            case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .noItem:
                                 break
                             case .post(let viewModel):
                                 if viewModel.fullPost?.actionablePost?.id == actionablePost.id {
@@ -2051,7 +1975,7 @@ extension TimelineListViewModel: MastodonPostMenuActionHandler {
                     feedLoader?.updateCachedResults({ timeline in
                         for item in timeline.items {
                             switch item {
-                            case .loadingIndicator, .filteredNotificationsInfo, .hashtag:
+                            case .loadingIndicator, .filteredNotificationsInfo, .hashtag, .noItem:
                                 break
                             case .post(let viewModel):
                                 if viewModel.fullPost?.actionablePost?.id == actionablePost.id {
@@ -2076,7 +2000,7 @@ extension TimelineListViewModel: MastodonPostMenuActionHandler {
                         composeContext: .editStatus(status: MastodonStatus(entity: statusEntityToEdit, showDespiteContentWarning: true), statusSource: statusSourceToEdit, quoting: {
                             if let quotedPostViewModel = postViewModel.fullQuotedPostViewModel {
                                 AnyView(
-                                    EmbeddedPostView(layoutWidth: 200, isSummary: false)
+                                    EmbeddedPostView(layoutWidth: 200, isSummary: false, actionHandler: nil)
                                         .environment(quotedPostViewModel)
                                         .environment(TimestampUpdater.timestamper(withInterval: 30))
                                         .environment(ContentConcealViewModel.alwaysShow)
@@ -2238,7 +2162,7 @@ extension TimelineListViewModel: MastodonPostMenuActionHandler {
     
     func doRemoveQuote(from quotingPost: MastodonContentPost, askFirst: Bool) async throws {
         if askFirst {
-            activeAlert = .confirmRemoveQuote(username: quotingPost.initialDisplayInfo(inContext: nil).actionableAuthorDisplayName, didConfirm: { confirmed in
+            activeAlert = .confirmRemoveQuote(username: quotingPost.initialDisplayInfo().actionableAuthorDisplayName, didConfirm: { confirmed in
                 guard confirmed else { return }
                 Task {
                     await self.commitRemoveQuote(from: quotingPost)
@@ -2667,3 +2591,39 @@ struct GapLoaderView: View {
         }
     }
 }
+
+struct Snackbar: View {
+    enum SnackbarType {
+        case newUnreadItems(Int)
+    }
+    
+    let barType: SnackbarType
+    
+    var body: some View {
+        switch barType {
+        case .newUnreadItems(let int):
+            HStack(spacing: tinySpacing) {
+                Image(systemName: "chevron.up")
+                Text("\(int) new")
+            }
+            .font(.footnote)
+            .foregroundStyle(.white)
+            .padding(EdgeInsets(top: tinySpacing, leading: standardPadding, bottom: tinySpacing, trailing: standardPadding))
+            .background {
+                Capsule()
+                    .fill(Asset.Colors.accent.swiftUIColor)
+            }
+        }
+    }
+}
+
+extension MastodonTimelineType {
+    var canDisplayNewItemsSnackbar: Bool {
+        switch self {
+        case .following:
+            true
+        default:
+            false
+        }
+    }
+}
