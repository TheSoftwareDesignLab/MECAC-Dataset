diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/AuthorHeaderView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/AuthorHeaderView.swift
index ad5a63690a..ae80db2db5 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/AuthorHeaderView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/AuthorHeaderView.swift	
@@ -6,7 +6,6 @@ import SwiftUI
 struct AuthorHeaderView: View {
     
     @Environment(MastodonPostViewModel.self) private var postViewModel
-    @ObservedObject var timestamper: TimestampUpdater
     
     var body: some View {
         VStack(alignment: .leading, spacing: 0) {
@@ -25,7 +24,7 @@ struct AuthorHeaderView: View {
                 //                .foregroundStyle(.secondary)
                 //                .frame(maxWidth: .infinity, alignment: .leading)
             }
-            VisibilityAndTimestampWithUserHandle(timestamper: timestamper, referenceDate: postedDate, visibility: postViewModel.fullPost?.actionablePost?.metaData.privacyLevel ?? postViewModel.initialDisplayInfo.actionableVisibility, handle: authorHandle)
+            VisibilityAndTimestampWithUserHandle(referenceDate: postedDate, visibility: postViewModel.fullPost?.actionablePost?.metaData.privacyLevel ?? postViewModel.initialDisplayInfo.actionableVisibility, handle: authorHandle)
                 .frame(maxWidth: .infinity, alignment: .leading)
         }
     }
@@ -79,14 +78,14 @@ extension MastodonAccount: AccountInfo {
 
 struct VisibilityAndTimestamp: View {
     @ScaledMetric private var actionSuperheaderHeight = baseActionSuperheaderHeight
-    @ObservedObject var timestamper: TimestampUpdater
+    @Environment(TimestampUpdater.self) var timestamper
     let referenceDate: Date
-    let visibility: GenericMastodonPost.PrivacyLevel
+    let visibility: GenericMastodonPost.PrivacyLevel?
     
     var body: some View {
         HStack(spacing: tinySpacing) {
-            if shouldShowVisibilityIndicator {
-                Image(systemName: visibility.iconName)
+            if let visibilityIconName {
+                Image(systemName: visibilityIconName)
             }
             Text(referenceDate.localizedExtremelyAbbreviatedTimeElapsedUntil(now: timestamper.timestamp))
                 .fixedSize(horizontal: true, vertical: false)
@@ -97,27 +96,29 @@ struct VisibilityAndTimestamp: View {
         .accessibilityLabel(referenceDate.localizedAbbreviatedSlowedTimeAgoSinceNow)
     }
     
-    var shouldShowVisibilityIndicator: Bool {
+    var visibilityIconName: String? {
         switch visibility {
         case .loudPublic:
-            return false
+            return nil // we consider this one the default, so we don't want to show the icon for it
+        case nil:
+            return nil
         default:
-            return true
+            return visibility!.iconName
         }
     }
 }
 
 struct VisibilityAndTimestampWithUserHandle: View {
     @ScaledMetric private var actionSuperheaderHeight = baseActionSuperheaderHeight
-    @ObservedObject var timestamper: TimestampUpdater
+    @Environment(TimestampUpdater.self) var timestamper
     let referenceDate: Date
-    let visibility: GenericMastodonPost.PrivacyLevel
+    let visibility: GenericMastodonPost.PrivacyLevel?
     let handle: String
     
     var body: some View {
         HStack(spacing: tinySpacing) {
-            if shouldShowVisibilityIndicator {
-                Image(systemName: visibility.iconName)
+            if let visibilityIconName {
+                Image(systemName: visibilityIconName)
             }
             (Text(referenceDate.localizedExtremelyAbbreviatedTimeElapsedUntil(now: timestamper.timestamp)) + Text(" Â· @\(handle)"))
                 .lineLimit(1)
@@ -128,12 +129,14 @@ struct VisibilityAndTimestampWithUserHandle: View {
         .accessibilityLabel(referenceDate.localizedAbbreviatedSlowedTimeAgoSinceNow + ", \(handle)")
     }
     
-    var shouldShowVisibilityIndicator: Bool {
+    var visibilityIconName: String? {
         switch visibility {
         case .loudPublic:
-            return false
+            return nil // we consider this one the default, so we don't want to show the icon for it
+        case nil:
+            return nil
         default:
-            return true
+            return visibility!.iconName
         }
     }
 }
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonPostRowView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonPostRowView.swift
index c454233f4a..55f4ebe9ea 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonPostRowView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MastodonPostRowView.swift	
@@ -50,7 +50,6 @@ import MastodonLocalization
             fullQuotedPostViewModel?.actionHandler = actionHandler
         }
     }
-    let timestamper: TimestampUpdater = TimestampUpdater.timestamper(withInterval: 30)
     let filterContext: Mastodon.Entity.FilterContext?
     
     private(set) var translation: Mastodon.Entity.Translation? = nil
@@ -253,7 +252,7 @@ struct HomeTimelinePostRowView: View {
                 }
                 
                 VStack(spacing: spacingBetweenGutterAndContent) {
-                    AuthorHeaderView(timestamper: viewModel.timestamper)
+                    AuthorHeaderView()
                     
                     contentConcealLozenge
                         .frame(width: contentWidth)
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/QuotedPostView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/QuotedPostView.swift
index 9c8ad5de2c..15f7905fe4 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/QuotedPostView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/QuotedPostView.swift	
@@ -121,6 +121,7 @@ extension Mastodon.Entity.Quote.AcceptanceState {
 
 struct QuotedPostContentDisplayedView: View {
     @Environment(MastodonPostViewModel.self) private var viewModel
+    @Environment(TimestampUpdater.self) private var timestamper
     @Environment(ContentConcealViewModel.self) private var contentConcealViewModel
     @Environment(\.colorScheme) private var colorScheme
     let layoutWidth: CGFloat
@@ -193,7 +194,7 @@ struct QuotedPostContentDisplayedView: View {
                 HStack(spacing: 0) {
                     authorDisplayName
                     Spacer(minLength: doublePadding)
-                    Text(viewModel.initialDisplayInfo.actionableCreatedAt.localizedExtremelyAbbreviatedTimeElapsedUntil(now: viewModel.timestamper.timestamp))
+                    Text(viewModel.initialDisplayInfo.actionableCreatedAt.localizedExtremelyAbbreviatedTimeElapsedUntil(now: timestamper.timestamp))
                         .foregroundStyle(.secondary)
                 }
                 HStack(spacing: 0) {
diff --git a/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationListViewController.swift
index 0b9467bc4c..64fe95304b 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationListViewController.swift	
@@ -199,7 +199,8 @@ struct NotificationListView: View {
         case .notification:
             Text("obsolete item")
         case .groupedNotification(let viewModel):
-            NotificationRowView(viewModel: viewModel)
+            NotificationRowView(contentWidth: 300)
+                .environment(viewModel)
                 .padding(.vertical, 4)
                 .listRowBackground(
                     backgroundView(isPrivate: viewModel.usePrivateBackground, isUnread: isUnread)
@@ -533,7 +534,9 @@ private class NotificationListViewModel: ObservableObject {
         }()
         
         func notificationListItem(fromInfo info: GroupedNotificationInfo) -> NotificationListItem {
-            let rowViewModel = NotificationRowViewModel(info, timestamper: self.timestampUpdater, myAccountID: authBox.userID, myAccountDomain: authBox.domain, navigateToScene: navigateToScene, presentError: presentError)
+            let rowViewModel = NotificationRowViewModel(info, myAccountDomain: authBox.domain)
+            rowViewModel.navigateToScene = navigateToScene
+            rowViewModel.presentError = presentError
             return NotificationListItem.groupedNotification(rowViewModel)
         }
         
@@ -727,8 +730,8 @@ extension Error {
     }
 }
 
-class TimestampUpdater: ObservableObject {
-    @Published var timestamp: Date = .now
+@Observable class TimestampUpdater {
+    var timestamp: Date = .now
     private var timer: Timer?
     
     private init(_ interval: TimeInterval) {
diff --git a/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowView.swift b/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowView.swift
index 3c0ad0d0f0..d784389361 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowView.swift	
@@ -266,7 +266,7 @@ struct NotificationIconView: View {
             Image(systemName: systemName)
                 .foregroundStyle(color)
         }
-        .font(.system(size: 35))
+        .font(.system(size: 25))
         .frame(width: AvatarSize.large, alignment: .center)
         .fontWeight(.semibold)
     }
@@ -526,139 +526,106 @@ struct FilteredNotificationsRowView: View {
     }
 }
 
-let baseActionSuperheaderHeight: CGFloat = 20
-
 struct NotificationRowView: View {
 
-    @ScaledMetric private var actionSuperheaderHeight: CGFloat = baseActionSuperheaderHeight
-    private let smallAvatarSize = AvatarSize.small
-    
-    @ObservedObject var viewModel: NotificationRowViewModel
-    @ObservedObject var timestamper: TimestampUpdater
-    
-    init(viewModel: NotificationRowViewModel) {
-        self.viewModel = viewModel
-        self.timestamper = viewModel.timestampUpdater
-    }
+    @Environment(NotificationRowViewModel.self) var viewModel
+    var contentWidth: CGFloat
     
     var body: some View {
-        HStack(alignment: .top, spacing: avatarSpacing) {
-            if let iconStyle = viewModel.iconStyle {
-                // LEFT GUTTER WITH TOP-ALIGNED ICON or AVATAR
-                VStack(spacing: 4) {
-                    if let actionSuperheader = viewModel.actionSuperheader {
-                        HStack {
-                            Spacer()
-                            if let iconName = actionSuperheader.iconName {
-                                Image(systemName: iconName)
-                                    .font(.footnote)
-                                    .bold()
-                                    .foregroundStyle(actionSuperheader.color)
-                                    .frame(height: actionSuperheaderHeight)
-                            } else {
-                                Spacer()
-                                    .frame(height: actionSuperheaderHeight)
-                            }
-                        }
-                    }
-                    
-                    switch iconStyle {
-                    case .icon(let name, let color):
-                        NotificationIconView(systemName: name, color: color)
-                    case .avatar:
-                        if let author = viewModel.notification.sourceAccounts.primaryAuthorAccount {
-                            AvatarView(size: .large, authorAvatarUrl: author.avatarURL, goToProfile: { try await viewModel.navigateToProfile(author) } )
-                        }
-                    }
-                    Spacer().frame(maxHeight: .infinity)
-                }
-                .fixedSize(horizontal: true, vertical: false)
-            }
-            
-            // VSTACK OF HEADER AND CONTENT COMPONENT VIEWS
-            VStack(spacing: 4) {
-                if let actionSuperheader = viewModel.actionSuperheader {
-                    componentView(.weightedText(actionSuperheader.text, .bold))
-                        .font(.footnote)
-                        .foregroundColor(actionSuperheader.color)
-                        .frame(height: actionSuperheaderHeight)
-                }
-                
-                ForEach(viewModel.headerComponents) {
-                    componentView($0)
-                }
+        VStack(alignment: .gutterAlign, spacing: 0) {
+            HStack(alignment: .top, spacing: 0) {
+                // ICON
+                NotificationIconView(systemName: viewModel.iconName, color: viewModel.iconColor)
                 
-                if !viewModel.contentComponents.isEmpty && !viewModel.notification.type.wantsFullStatusLayout {
-                    Spacer().frame(height: 2)
-                }
+                Spacer()
+                    .frame(width: spacingBetweenGutterAndContent)
                 
-                ForEach(viewModel.contentComponents) {
-                    componentView($0)
-                }
+                // CONTENT
+                contentView
+                    .font(.subheadline)
+                    .frame(width: contentWidth)
             }
         }
-        .fixedSize(horizontal: false, vertical: true)
-        .accessibilityActions {
-            ForEach(viewModel.a11yActions) { a11y in
-                Button(a11y.title) {
-                    a11y.doAction()
-                }
-            }
+        .onTapGesture {
+            // viewModel.primaryNavigation
         }
-        .accessibilityElement(children: .combine)
     }
     
     @ViewBuilder
-    func componentView(_ component: NotificationViewComponent) -> some View {
-        switch component {
-        case .avatarRow(let accountInfo, let addition):
-            avatarRow(accountInfo: accountInfo, trailingElement: addition)
-        case .text(let string):
-            Text(string)
-                .frame(maxWidth: .infinity, alignment: .leading)
-        case .timeSinceLabel(let date):
-            Text(date.localizedExtremelyAbbreviatedTimeElapsedUntil(now: timestamper.timestamp))
-                .font(.footnote)
-                .frame(height: actionSuperheaderHeight)
-                .fixedSize(horizontal: true, vertical: false)
-                .foregroundColor(.secondary)
-                .accessibilityLabel(date.localizedAbbreviatedSlowedTimeAgoSinceNow)
-        case .weightedText(let string, let weight):
-            textComponent(string, fontWeight: weight)
-        case .status(let statusViewModel):
-            InlinePostPreview(viewModel: statusViewModel)
-                .onTapGesture {
-                    statusViewModel.navigateToStatus()
+    var contentView: some View {
+        VStack {
+            // AVATAR ROW
+            if let sourceAccounts = viewModel.avatarRowSourceAccounts {
+                avatarRow(accountInfo: sourceAccounts, trailingElement: viewModel.avatarRowAdditionalElement)
+            }
+            
+            // HEADLINE AND TIMESTAMP
+            HStack(spacing: 0) {
+                headlineView
+                if let timestamp = viewModel.notification.timestamp {
+                    Spacer(minLength: standardPadding)
+                    VisibilityAndTimestamp(referenceDate: timestamp, visibility: nil)
+                }
+            }
+            
+            // ADDITIONAL CONTENT
+            switch viewModel.notification.type {
+            case .adminReport(let report, let url):
+                if let comment = report?
+                    .displayableComment
+                {
+                    Text(comment)
                 }
-        case .hyperlink(let label, _):
-            Text(label)
-                .bold()
-                .foregroundStyle(Color(asset: Asset.Colors.accent))
-        case ._other(let string):
-            Text(string)
-        case .textAndTimeLabel(let string, let date):
-            HStack(alignment: .top, spacing: 2) {
-                Text(string)
-                    .frame(maxWidth: .infinity, alignment: .leading)
-                Text(date.localizedExtremelyAbbreviatedTimeElapsedUntil(now: timestamper.timestamp))
-                    .font(.footnote)
-                    .frame(height: actionSuperheaderHeight)
-                    .fixedSize(horizontal: true, vertical: false)
-                    .foregroundColor(.secondary)
-                    .accessibilityLabel(date.localizedAbbreviatedSlowedTimeAgoSinceNow)
+            case .severedRelationships:
+                let label = L10n.Scene.Notification.learnMoreAboutServerBlocks
+                Text(label)
+                    .bold()
+                    .foregroundStyle(Color(asset: Asset.Colors.accent))
+            case .moderationWarning(let accountWarning, _):
+                if let accountWarningText = accountWarning?.text {
+                    Text(accountWarningText)
+                }
+                let label = L10n.Scene.Notification.Warning.learnMore
+                Text(label)
+                    .bold()
+                    .foregroundStyle(Color(asset: Asset.Colors.accent))
+            default:
+                EmptyView()
+            }
+            
+            // OPTIONAL INLINE POST VIEW
+            if let post = viewModel.inlinePost {
+                Text("INLINE POST PREVIEW")
             }
         }
     }
+    
+    @ViewBuilder var headlineView: some View {
+        switch viewModel.notification.type {
+        case .follow, .followRequest, .reblog, .favourite, .poll, .update, .quotedUpdate, .adminSignUp:
+            if let sourceAccounts = viewModel.avatarRowSourceAccounts,
+               sourceAccounts.primaryAuthorAccount?.displayNameWithFallback != nil,
+               let actionLabel = viewModel.notification.type.actionSummaryLabel(sourceAccounts) {
+                Text(actionLabel)  // TODO: use RowView with emoji parsing, bold the name using html
+            }
+        case .mention(let status), .status(let status), .quote(let status):
+            Text("This notification type expects to be presented as a MastodonPostRowView, not a NotificationRowView")
+        case .adminReport(let report, _):
+            if let summary = report?.summary {
+                Text(summary)
+            }
+        case .severedRelationships(let severanceEvent, _):
+            if let summary = severanceEvent?.summary(myDomain: viewModel.myAccountDomain ?? "")
+            {
+                Text(summary)
+            }
+        case .moderationWarning(let accountWarning, _):
+            if let actionDescription = accountWarning?.action.actionDescription {
+                Text(actionDescription)
+            }
 
-    func displayableAvatarCount(
-        fittingWidth: CGFloat, totalAvatarCount: Int, totalActorCount: Int
-    ) -> Int {
-        let maxAvatarCount = Int(
-            floor(fittingWidth / (smallAvatarSize + avatarSpacing)))
-        if maxAvatarCount < totalActorCount {
-            return maxAvatarCount - 1
-        } else {
-            return maxAvatarCount
+        case ._other(let typeString):
+                Text("UNEXPECTED NOTIFICATION TYPE: \(typeString)")
         }
     }
 
@@ -735,7 +702,7 @@ struct NotificationRowView: View {
                 Button(action: {
                     viewModel.doAvatarRowButtonAction(false)
                 }) {
-                    lightwieghtImageView("xmark.circle", size: smallAvatarSize)
+                    lightwieghtImageView("xmark.circle", size: AvatarSize.small)
                 }
                 .buttonStyle(
                     ImageButton(
@@ -745,7 +712,7 @@ struct NotificationRowView: View {
                     viewModel.doAvatarRowButtonAction(true)
                 }) {
                     lightwieghtImageView(
-                        "checkmark.circle", size: smallAvatarSize)
+                        "checkmark.circle", size: AvatarSize.small)
                 }
                 .buttonStyle(
                     ImageButton(
@@ -753,21 +720,33 @@ struct NotificationRowView: View {
             }
         case (.iHaveAnsweredTheirRequestToFollowMe(let didAccept), false):
             if didAccept {
-                lightwieghtImageView("checkmark", size: smallAvatarSize)
+                lightwieghtImageView("checkmark", size: AvatarSize.small)
                     .accessibilityLabel(L10n.Scene.Notification.FollowRequest.accepted)
             } else {
-                lightwieghtImageView("xmark", size: smallAvatarSize)
+                lightwieghtImageView("xmark", size: AvatarSize.small)
                     .accessibilityLabel(L10n.Scene.Notification.FollowRequest.rejected)
             }
         case (.error(_), _):
             lightwieghtImageView(
-                "exclamationmark.triangle", size: smallAvatarSize)
+                "exclamationmark.triangle", size: AvatarSize.small)
         default:
             Spacer().frame(width: 0)
         }
     }
 }
 
+let baseActionSuperheaderHeight: CGFloat = 20
+    func displayableAvatarCount(
+        fittingWidth: CGFloat, totalAvatarCount: Int, totalActorCount: Int
+    ) -> Int {
+        let maxAvatarCount = Int(
+            floor(fittingWidth / (AvatarSize.small + avatarSpacing)))
+        if maxAvatarCount < totalActorCount {
+            return maxAvatarCount - 1
+        } else {
+            return maxAvatarCount
+        }
+    }
 @ViewBuilder
 func textComponent(_ string: String, fontWeight: SwiftUICore.Font.Weight?)
     -> some View
@@ -777,38 +756,6 @@ func textComponent(_ string: String, fontWeight: SwiftUICore.Font.Weight?)
         .frame(maxWidth: .infinity, alignment: .leading)
 }
 
-enum NotificationViewComponent: Identifiable {
-    case avatarRow(NotificationSourceAccounts, RelationshipElement)
-    case text(AttributedString)
-    case textAndTimeLabel(AttributedString, Date)
-    case timeSinceLabel(Date)
-    case weightedText(String, SwiftUICore.Font.Weight)
-    case status(Mastodon.Entity.Status.ViewModel)
-    case hyperlink(String, URL?)
-    case _other(String)
-
-    var id: String {
-        switch self {
-        case .avatarRow:
-            return "avatar_row"
-        case .text(let string):
-            return string.description
-        case .timeSinceLabel(_):
-            return "time_label"
-        case .weightedText(let string, _):
-            return string
-        case .status:
-            return "status"
-        case .hyperlink(let text, _):
-            return text
-        case ._other(let string):
-            return string
-        case .textAndTimeLabel(let string, _):
-            return string.description + "+date"
-        }
-    }
-}
-
 func styledNameComponent(_ name: String, style: AttributeContainer, emojis: [MastodonContent.Shortcode: String]?) -> AttributedString {
     var nameComponent = attributedString(fromHtml: name, emojis: emojis ?? [:])
     nameComponent.setAttributes(style)
diff --git a/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowViewModel.swift b/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowViewModel.swift
index 47adce6c9c..6940d3350c 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowViewModel.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Notifications/NotificationRowViewModel.swift	
@@ -29,66 +29,68 @@ struct MastodonNotificationInfo {
     }
 }
 
-class NotificationRowViewModel: ObservableObject {
-    let timestampUpdater: TimestampUpdater
-   
-    let navigateToScene:
-    (SceneCoordinator.Scene, SceneCoordinator.Transition) -> Void
-    let presentError: (Error) -> Void
+@Observable class NotificationRowViewModel {
+    var navigateToScene:
+    ((SceneCoordinator.Scene, SceneCoordinator.Transition) -> Void)?
+
+    var presentError: ((Error) -> Void)?
+    
     let primaryNavigation: NotificationNavigation?
     
     let notification: MastodonNotificationInfo
-    let iconStyle: GroupedNotificationType.MainIconStyle?
-    let usePrivateBackground: Bool
-    let actionSuperheader: (iconName: String?, text: String, color: Color)?
+    let myAccountDomain: String?
     
-    @Published public var headerComponents: [NotificationViewComponent] = []
-    public var contentComponents: [NotificationViewComponent] = []
-
-    private(set) var avatarRow: NotificationViewComponent? {
-        didSet {
-            resetHeaderComponents()
+    var avatarRowSourceAccounts: NotificationSourceAccounts? {
+        switch notification.type {
+        case .follow, .followRequest:
+            return notification.sourceAccounts
+        case .reblog, .favourite, .quotedUpdate, .poll, .update, .adminSignUp:
+            return notification.sourceAccounts
+        case .adminReport, .moderationWarning, .severedRelationships:
+            return nil
+        case .mention, .status, .quote:
+            // Note: these types are expected to use the MastodonPostRowView, not the NotificationRowView
+            return nil
+        case ._other:
+            return nil
         }
     }
-    private(set) var headerTextComponents: [NotificationViewComponent] = [] {
-        didSet {
-            resetHeaderComponents()
+    var avatarRowAdditionalElement: RelationshipElement
+    
+    private var iconStyle: GroupedNotificationType.MainIconStyle? {
+        return notification.type.mainIconStyle
+    }
+    public var iconName: String {
+        switch iconStyle {
+        case .icon(let name, _):
+            return name
+        case .avatar:
+            return "person.fill.viewfinder"
+        case nil:
+            return "questionmark.square.dashed"
         }
     }
-
-    private func resetHeaderComponents() {
-        headerComponents = ([avatarRow] + headerTextComponents).compactMap {
-            $0
+    public var iconColor: Color {
+        switch iconStyle {
+        case .icon(_, let color):
+            return color
+        case .avatar:
+            return .secondary
+        case nil:
+            return .secondary
         }
     }
+    
+    var inlinePost: GenericMastodonPost? = nil
+    var usePrivateBackground: Bool = false
 
-    init(
-        _ notificationInfo: GroupedNotificationInfo,
-        timestamper: TimestampUpdater,
-        myAccountID: String,
-        myAccountDomain: String,
-        navigateToScene: @escaping (
-            SceneCoordinator.Scene, SceneCoordinator.Transition
-        ) -> Void, presentError: @escaping (Error) -> Void
-    ) {
-        self.timestampUpdater = timestamper
-        self.iconStyle = notificationInfo.groupedNotificationType.mainIconStyle
-        self.navigateToScene = navigateToScene
-        self.presentError = presentError
+    init(_ notificationInfo: GroupedNotificationInfo, myAccountDomain: String?) {
         self.primaryNavigation = notificationInfo.primaryNavigation
         self.notification = MastodonNotificationInfo(notificationInfo)
+        self.myAccountDomain = myAccountDomain
         
-        var needsPrivateBackground = false
-        
-        func newStatusViewModel(_ status: Mastodon.Entity.Status) -> Mastodon.Entity.Status.ViewModel {
-            return statusViewModel(status, myAccountID: myAccountID, myAccountDomain: myAccountDomain, navigateToScene: navigateToScene)
-        }
-
         switch notificationInfo.groupedNotificationType {
-
         case .follow, .followRequest:
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: false, myAccountID: myAccountID)
-            let avatarRowAdditionalElement: RelationshipElement
             if notificationInfo.sourceAccounts
                 .primaryAuthorAccount != nil
             {
@@ -97,265 +99,45 @@ class NotificationRowViewModel: ObservableObject {
             } else {
                 avatarRowAdditionalElement = .error(nil)
             }
-            avatarRow = .avatarRow(
-                notificationInfo.sourceAccounts,
-                avatarRowAdditionalElement)
-            if (notificationInfo.sourceAccounts
-                .primaryAuthorAccount?
-                .displayNameWithFallback) != nil
-            {
-                if let timestamp = notificationInfo.timestamp {
-                    headerTextComponents = [
-                        .textAndTimeLabel(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "", timestamp)
-                    ]
-                } else {
-                    headerTextComponents = [
-                        .text(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "")
-                    ]
-                }
-            }
-        case .mention(let status), .status(let status), .quote(let status):
-            // TODO: eventually make this full status style, not inline
-            if let status
-            {
-                let statusViewModel = newStatusViewModel(status)
-                actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: statusViewModel.isReplyToMe, isPrivateStatus: statusViewModel.visibility == .direct, myAccountID: myAccountID)
-                if let timestamp = notificationInfo.timestamp {
-                    headerTextComponents = [
-                        .textAndTimeLabel(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "", timestamp)
-                    ]
-                } else {
-                    headerTextComponents = [
-                        .text(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "")
-                    ]
-                }
-                contentComponents = [.status(statusViewModel)]
-                needsPrivateBackground = status.visibility == .direct
-            } else {
-                actionSuperheader = nil
-                headerTextComponents = [._other("POST BY UNKNOWN ACCOUNT")]
-            }
-        case .reblog(let status), .favourite(let status):
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: status?.visibility == .direct, myAccountID: myAccountID)
-            if let status {
-                let statusViewModel = newStatusViewModel(status)
-                avatarRow = .avatarRow(
-                    notificationInfo.sourceAccounts,
-                    .noneNeeded)
-                if let timestamp = notificationInfo.timestamp {
-                    headerTextComponents = [
-                        .textAndTimeLabel(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "", timestamp)
-                    ]
-                } else {
-                    headerTextComponents = [
-                        .text(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "")
-                    ]
-                }
-                contentComponents = [.status(statusViewModel)]
-                needsPrivateBackground = statusViewModel.visibility == .direct
-            } else {
-                headerTextComponents = [
-                    ._other("REBLOGGED/FAVOURITED/QUOTED BY UNKNOWN ACCOUNT")
-                ]
-            }
-        case .poll(let status), .update(let status), .quotedUpdate(let status):
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: status?.visibility == .direct, myAccountID: myAccountID)
+        case .mention, .status, .quote:
+            avatarRowAdditionalElement = .noneNeeded
+            break
+        case .reblog(let status), .favourite(let status), .poll(let status), .update(let status), .quotedUpdate(let status):
+            avatarRowAdditionalElement = .noneNeeded
             if let status {
-                let statusViewModel = newStatusViewModel(status)
-                if let timestamp = notificationInfo.timestamp {
-                    headerTextComponents = [
-                        .textAndTimeLabel(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "", timestamp)
-                    ]
-                } else {
-                    headerTextComponents = [
-                        .text(
-                            notificationInfo.groupedNotificationType
-                                .actionSummaryLabel(notificationInfo.sourceAccounts)
-                            ?? "")
-                    ]
-                }
-                contentComponents = [.status(statusViewModel)]
-                needsPrivateBackground = statusViewModel.visibility == .direct
-            } else {
-                headerTextComponents = [
-                    ._other("POLL/UPDATE FROM UNKNOWN ACCOUNT")
-                ]
+                inlinePost = GenericMastodonPost.fromStatus(status)
+                usePrivateBackground = status.visibility == .direct
             }
-        case .adminSignUp:
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: false, myAccountID: myAccountID)
-            avatarRow = .avatarRow(
-                notificationInfo.sourceAccounts,
-                .noneNeeded)
-            if let timestamp = notificationInfo.timestamp {
-                headerTextComponents = [
-                    .textAndTimeLabel(
-                        notificationInfo.groupedNotificationType
-                            .actionSummaryLabel(notificationInfo.sourceAccounts)
-                        ?? "", timestamp)
-                ]
-            } else {
-                headerTextComponents = [
-                    .text(
-                        notificationInfo.groupedNotificationType
-                            .actionSummaryLabel(notificationInfo.sourceAccounts)
-                        ?? "")
-                ]
-            }
-        case .adminReport(let report, _):
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: false, myAccountID: myAccountID)
-            if let summary = report?.summary {
-                if let timestamp = notificationInfo.timestamp {
-                    headerTextComponents = [
-                        .textAndTimeLabel(summary, timestamp)
-                    ]
-                } else {
-                    headerTextComponents = [
-                        .text(summary)
-                    ]
-                }
-            }
-            if let comment = report?
-                .displayableComment
-            {
-                contentComponents = [.text(comment)]
-            }
-        case .severedRelationships(let severanceEvent, let url):
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: false, myAccountID: myAccountID)
-            if let summary = severanceEvent?.summary(myDomain: myAccountDomain)
-            {
-                if let timestamp = notificationInfo.timestamp {
-                    headerTextComponents = [
-                        .textAndTimeLabel(summary, timestamp)
-                    ]
-                } else {
-                    headerTextComponents = [
-                        .text(summary)
-                    ]
-                }
-            } else {
-                headerTextComponents = [
-                    ._other(
-                        "An admin action removed some of your followers or accounts that you followed."
-                    )
-                ]
-            }
-            contentComponents = [
-                .hyperlink(
-                    L10n.Scene.Notification.learnMoreAboutServerBlocks,
-                    url)
-            ]
-        case .moderationWarning(let accountWarning, let url):
-            actionSuperheader = NotificationRowViewModel.actionSuperheader(notificationInfo.groupedNotificationType, isReply: false, isPrivateStatus: false, myAccountID: myAccountID)
-            if let timestamp = notificationInfo.timestamp {
-                headerTextComponents = [
-                    .textAndTimeLabel(
-                        AttributedString((accountWarning?.action ?? .none).actionDescription), timestamp)
-                ]
-            } else {
-                headerTextComponents = [
-                    .weightedText(
-                        (accountWarning?.action ?? .none).actionDescription,
-                        .regular)
-                ]
-            }
-
-            let learnMoreButton = NotificationViewComponent.hyperlink(
-                L10n.Scene.Notification.Warning.learnMore, url)
-
-            if let accountWarningText = accountWarning?.text {
-                contentComponents = [
-                    .weightedText(accountWarningText, .regular),
-                    learnMoreButton,
-                ]
-            } else {
-                contentComponents = [
-                    learnMoreButton
-                ]
-            }
-
-        case ._other(let text):
-            actionSuperheader = nil
-            headerTextComponents = [
-                ._other("UNEXPECTED NOTIFICATION TYPE: \(text)")
-            ]
+        case .adminSignUp, .adminReport, .severedRelationships, .moderationWarning:
+            avatarRowAdditionalElement = .noneNeeded
+        case ._other:
+            avatarRowAdditionalElement = .noneNeeded
         }
-        
-        usePrivateBackground = needsPrivateBackground
-        
-        resetHeaderComponents()
     }
     
-    static func actionSuperheader(_ notificationType: GroupedNotificationType, isReply: Bool, isPrivateStatus: Bool?, myAccountID: String?) -> (iconName: String?, text: String, color: Color)? {
-        let isPrivateStatus = isPrivateStatus ?? false
-        let color = isPrivateStatus ? Asset.Colors.accent.swiftUIColor : .secondary
-        switch notificationType {
-        case .mention:
-            switch (isReply, isPrivateStatus) {
-            case (true, false):
-                return (iconName: PostAction.reply.systemIconName(filled: false), text: L10n.Common.Controls.Status.reply, color: color)
-            case (true, true):
-                return (iconName: PostAction.reply.systemIconName(filled: false), text: L10n.Common.Controls.Status.privateReply, color: color)
-            case (false, false):
-                return (iconName: "at", text: L10n.Common.Controls.Status.mention, color: color)
-            case (false, true):
-                return (iconName: "at", text: L10n.Common.Controls.Status.privateMention, color: color)
-            }
-        case .quote(let status):
-            let author = status?.account.displayName(whenViewedBy: myAccountID)
-            return (iconName: "quote.opening", text: L10n.Scene.Notification.GroupedNotificationDescription.singleNameQuoted(author?.plainString ?? ""), color: .secondary)
-        default:
-            return nil
-        }
-    }
-
     public func prepareForDisplay() {
-        if let avatarRow {
-            switch avatarRow {
-            case .avatarRow(let sourceAccounts, let additionalElement):
-                switch additionalElement {
-                case .unfetched:
-                    fetchRelationshipElement(sourceAccounts: sourceAccounts)
-                default:
-                    break
-                }
-            case .text, .weightedText, .status, .hyperlink, ._other, .timeSinceLabel, .textAndTimeLabel:
-                break
+        switch avatarRowAdditionalElement {
+        case .unfetched:
+            if let avatarRowSourceAccounts {
+                fetchRelationshipElement(sourceAccounts: avatarRowSourceAccounts)
             }
+        default:
+            break
         }
-
     }
-
+    
     private func fetchRelationshipElement(
         sourceAccounts: NotificationSourceAccounts
     ) {
-        switch notification.type {
-        case .follow, .followRequest:
+        switch avatarRowAdditionalElement {
+        case .noneNeeded, .fetching:
+            break
+        default:
             guard let accountID = sourceAccounts.firstAccountID,
                   let accountIsLocked = sourceAccounts.primaryAuthorAccount?
                 .locked
             else { return }
-            avatarRow = .avatarRow(sourceAccounts, .fetching)
+            avatarRowAdditionalElement = .fetching
 
             Task { @MainActor in
                 let element: RelationshipElement
@@ -383,10 +165,8 @@ class NotificationRowViewModel: ObservableObject {
                     element = .error(error)
                 }
 
-                avatarRow = .avatarRow(notification.sourceAccounts, element)
+                avatarRowAdditionalElement = element
             }
-        default:
-            avatarRow = .avatarRow(notification.sourceAccounts, .noneNeeded)
         }
     }
     
@@ -432,7 +212,7 @@ extension NotificationRowViewModel {
                 .currentActiveUser.value?.cachedAccount
         else { return }
         if me.id == info.id {
-            navigateToScene(.profile(.me(me)), .show)
+            navigateToScene?(.profile(.me(me)), .show)
         } else {
             var account = info.fullAccount
             if account == nil {
@@ -440,7 +220,7 @@ extension NotificationRowViewModel {
             }
             guard let account else { return }
             let relationship = try await fetchRelationship(to: info.id)
-            navigateToScene(
+            navigateToScene?(
                 .profile(
                     .notMe(
                         me: me, displayAccount: account,
@@ -458,7 +238,7 @@ extension NotificationRowViewModel {
             Task {
                 guard let scene = await primaryNavigation.destinationScene()
                 else { return }
-                navigateToScene(scene, .show)
+                navigateToScene?(scene, .show)
             }
         }
     }
@@ -467,34 +247,35 @@ extension NotificationRowViewModel {
         var actions = [A11yActionInfo]()
         if let primaryNavigationTitle = primaryNavigation?.a11yTitle { actions.append(A11yActionInfo(title: primaryNavigationTitle, doAction: { [weak self] in self?.doPrimaryNavigation() }))
         }
-        for component in self.headerComponents + self.contentComponents {
-            actions.append(contentsOf: a11yActions(forComponent: component))
-        }
+        // TODO: replace the below
+//        for component in self.headerComponents + self.contentComponents {
+//            actions.append(contentsOf: a11yActions(forComponent: component))
+//        }
         return actions
     }
 
-    private func a11yActions(forComponent component: NotificationViewComponent?) -> [A11yActionInfo]  {
-        switch component {
-        case .none:
-            return []
-        case let .avatarRow(sourceAccounts, relationshipElement):
-            let relationshipActions = a11yActions(forRelationshipElement: relationshipElement, isGrouped: sourceAccounts.totalActorCount > 1)
-            let accountNavigations = sourceAccounts.accounts.compactMap { account in
-                A11yActionInfo(title: L10n.Common.Controls.Status.MetaEntity.mention(account.displayName(whenViewedBy: nil)?.plainString ?? ""), doAction: {
-                    Task { [weak self] in
-                        try await self?.navigateToProfile(account)
-                    }
-                })
-            }
-            return relationshipActions + accountNavigations
-        case let .status(statusViewModel):
-            return [A11yActionInfo(title: L10n.Common.Controls.Status.showPost, doAction: { statusViewModel.navigateToStatus() })]
-        case .hyperlink(_, _):
-            return []
-        case .text, .textAndTimeLabel, .timeSinceLabel, .weightedText, ._other:
-            return []
-        }
-    }
+//    private func a11yActions(forComponent component: NotificationViewComponent?) -> [A11yActionInfo]  {
+//        switch component {
+//        case .none:
+//            return []
+//        case let .avatarRow(sourceAccounts, relationshipElement):
+//            let relationshipActions = a11yActions(forRelationshipElement: relationshipElement, isGrouped: sourceAccounts.totalActorCount > 1)
+//            let accountNavigations = sourceAccounts.accounts.compactMap { account in
+//                A11yActionInfo(title: L10n.Common.Controls.Status.MetaEntity.mention(account.displayName(whenViewedBy: nil)?.plainString ?? ""), doAction: {
+//                    Task { [weak self] in
+//                        try await self?.navigateToProfile(account)
+//                    }
+//                })
+//            }
+//            return relationshipActions + accountNavigations
+//        case let .status(statusViewModel):
+//            return [A11yActionInfo(title: L10n.Common.Controls.Status.showPost, doAction: { statusViewModel.navigateToStatus() })]
+//        case .hyperlink(_, _):
+//            return []
+//        case .text, .textAndTimeLabel, .timeSinceLabel, .weightedText, ._other:
+//            return []
+//        }
+//    }
     
     private func a11yActions(forRelationshipElement relationshipElement: RelationshipElement, isGrouped: Bool) -> [A11yActionInfo] {
         
@@ -524,21 +305,19 @@ extension NotificationRowViewModel: Equatable {
 extension NotificationRowViewModel {
 
     public func doAvatarRowButtonAction(_ accept: Bool = true) {
-        guard let avatarRow else { return }
         FeedbackGenerator.shared.generate(.selectionChanged)
         Task {
-            switch avatarRow {
-            case .avatarRow(let accountInfo, let relationshipElement):
-                switch relationshipElement {
-                case .iDoNotFollowThem, .iFollowThem,
+            switch avatarRowAdditionalElement {
+            case .iDoNotFollowThem, .iFollowThem,
                     .iHaveRequestedToFollowThem:
+                if let avatarRowSourceAccounts {
                     await doFollowAction(
-                        relationshipElement.followAction,
-                        notificationSourceAccounts: accountInfo)
-                case .theyHaveRequestedToFollowMe:
-                    await doAnswerFollowRequest(accountInfo, accept: accept)
-                default:
-                    return
+                        avatarRowAdditionalElement.followAction,
+                        notificationSourceAccounts: avatarRowSourceAccounts)
+                }
+            case .theyHaveRequestedToFollowMe:
+                if let avatarRowSourceAccounts {
+                    await doAnswerFollowRequest(avatarRowSourceAccounts, accept: accept)
                 }
             default:
                 return
@@ -557,8 +336,8 @@ extension NotificationRowViewModel {
             let authBox = AuthenticationServiceProvider.shared.currentActiveUser
                 .value
         else { return }
-        let startingAvatarRow = avatarRow
-        avatarRow = .avatarRow(notificationSourceAccounts, .fetching)
+        let startingAvatarRelationshipElement = avatarRowAdditionalElement
+        avatarRowAdditionalElement = .fetching
         do {
             let updatedElement: RelationshipElement
             let response: Mastodon.Entity.Relationship
@@ -582,10 +361,10 @@ extension NotificationRowViewModel {
                 updatedElement = .iDoNotFollowThem(
                     theirAccountIsLocked: theirAccountIsLocked)
             }
-            avatarRow = .avatarRow(notificationSourceAccounts, updatedElement)
+            avatarRowAdditionalElement = updatedElement
         } catch {
-            presentError(error)
-            avatarRow = startingAvatarRow
+            presentError?(error)
+            avatarRowAdditionalElement = startingAvatarRelationshipElement
         }
     }
 
@@ -597,8 +376,8 @@ extension NotificationRowViewModel {
             let authBox = AuthenticationServiceProvider.shared.currentActiveUser
                 .value
         else { return }
-        let startingAvatarRow = avatarRow
-        avatarRow = .avatarRow(accountInfo, .fetching)
+        let startingAvatarRowRelationshipElement = avatarRowAdditionalElement
+        avatarRowAdditionalElement = .fetching
         do {
             let expectedFollowedByResult = accept
             let newRelationship = try await APIService.shared.followRequest(
@@ -607,15 +386,13 @@ extension NotificationRowViewModel {
                 authenticationBox: authBox
             ).value
             guard newRelationship.followedBy == expectedFollowedByResult else {
-                self.avatarRow = .avatarRow(accountInfo, .error(nil))
+                self.avatarRowAdditionalElement = .error(nil)
                 return
             }
-            self.avatarRow = .avatarRow(
-                accountInfo,
-                .iHaveAnsweredTheirRequestToFollowMe(didAccept: accept))
+            self.avatarRowAdditionalElement = .iHaveAnsweredTheirRequestToFollowMe(didAccept: accept)
         } catch {
-            presentError(error)
-            self.avatarRow = startingAvatarRow
+            presentError?(error)
+            self.avatarRowAdditionalElement = startingAvatarRowRelationshipElement
         }
     }
 }
@@ -631,10 +408,11 @@ extension NotificationRowViewModel {
         ) -> Void, presentError: @escaping (Error) -> Void
     ) -> [NotificationRowViewModel] {
         return results.map { info in
-            NotificationRowViewModel(
-                info, timestamper: timestamper, myAccountID: myAccountID, myAccountDomain: myAccountDomain,
-                navigateToScene: navigateToScene,
-                presentError: presentError)
+            let model = NotificationRowViewModel(
+                info,myAccountDomain: myAccountDomain)
+            model.navigateToScene = navigateToScene
+            model.presentError = presentError
+            return model
         }
     }
 
@@ -670,10 +448,11 @@ extension NotificationRowViewModel {
                     groupedNotificationType, isGrouped: false,
                                                 primaryAccount: notification.primaryAuthorAccount))
 
-            return NotificationRowViewModel(
-                info, timestamper: timestamper, myAccountID: myAccountID, myAccountDomain: myAccountDomain,
-                navigateToScene: navigateToScene,
-                presentError: presentError)
+            let model = NotificationRowViewModel(
+                info, myAccountDomain: myAccountDomain)
+            model.navigateToScene = navigateToScene
+            model.presentError = presentError
+            return model
         }
     }
 
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift
index a1c2c48c71..f9581fc9cd 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineFeedLoader.swift	
@@ -93,7 +93,7 @@ extension GenericMastodonPost {
 
 enum TimelineItem: Identifiable {
     case post(MastodonPostViewModel)
-    case notification(GroupedNotificationInfo)
+    case notification(NotificationRowViewModel)
     case filteredNotificationsInfo(
         Mastodon.Entity.NotificationPolicy?,
         FilteredNotificationsRowView.ViewModel?)
@@ -334,12 +334,11 @@ final class TimelineFeedLoader: MastodonFeedLoader<TimelineItem, CacheableTimeli
                 authenticationBox: authenticatedUser
             ).value.map { timelineItem(fromStatus: $0) }
         case .notifications(scope: let scope):
-            // TODO: include filtered notifications banner
             newBatch = try await NotificationsLoader.getNotifications(withScope: scope, olderThan: itemsImmediatelyAfter, newerThan: itemsImmediatelyBefore).map { groupedNotificationInfo in
                 if groupedNotificationInfo.groupedNotificationType.wantsFullStatusLayout, let post = groupedNotificationInfo.post {
                     return timelineItem(fromPost: post)
                 } else {
-                    return TimelineItem.notification(groupedNotificationInfo)
+                    return TimelineItem.notification(NotificationRowViewModel(groupedNotificationInfo, myAccountDomain: authenticatedUser.domain))
                 }
             }
         }
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift
index 1aa5ce9cf0..12dea2c804 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
@@ -1202,6 +1202,7 @@ struct TimelineListView: View {
                 }
             }
         }
+        .environment(TimestampUpdater.timestamper(withInterval: 30))
     }
     
     @ViewBuilder func feedContents(_ geo: GeometryProxy) -> some View {
@@ -1283,9 +1284,24 @@ struct TimelineListView: View {
                         EmptyView()
                     }
                 }
-            case .notification(let groupedInfo):
-//                NotificationRowView()
-                Text("A NOTIFICATION")
+            case .notification(let viewModel):
+                NotificationRowView(contentWidth: contentWidth)
+                    .environment(viewModel)
+                    .padding(EdgeInsets(top: standardPadding, leading: standardPadding, bottom: standardPadding, trailing: doublePadding))
+                    .frame(width: usableWidth)
+                    .background() {
+                        if let inlinePost = viewModel.inlinePost {
+                            switch inlinePost.initialDisplayInfo(inContext: .notifications).actionableVisibility {
+                            case .mentionedOnly:
+                                backgroundView(isPrivate: true, isUnread: false) // TODO: implement unread for notifications
+                            default:
+                                EmptyView()
+                            }
+                        }
+                    }
+                    .onAppear() {
+                        viewModel.prepareForDisplay()
+                    }
             }
         }
         if viewModel.threadedConversationModel != nil {
