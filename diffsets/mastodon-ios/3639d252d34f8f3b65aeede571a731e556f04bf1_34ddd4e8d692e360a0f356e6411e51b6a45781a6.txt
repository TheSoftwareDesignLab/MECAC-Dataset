diff --git a/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift b/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift
index 0ce9ca62e0..7dab1dc0ee 100644
--- a/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift	
@@ -406,7 +406,7 @@ extension GroupedNotificationFeedLoader {
 
 extension GroupedNotificationFeedLoader {
     public func markAsRead(_ identifier: Mastodon.Entity.Notification.ID) {
-        cacheManager?.updateToNewerMarker(.local(lastReadID: identifier))
+        cacheManager?.updateToNewerMarker(.local(lastReadID: identifier), enforceForwardProgress: true)
     }
     
     public func isUnread(_ identifier: Mastodon.Entity.Notification.ID) -> Bool {
diff --git a/Mastodon/In Progress New Layout and Datamodel/LastReadMarkers.swift b/Mastodon/In Progress New Layout and Datamodel/LastReadMarkers.swift
index 99eabb96be..acf6f9aa38 100644
--- a/Mastodon/In Progress New Layout and Datamodel/LastReadMarkers.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/LastReadMarkers.swift	
@@ -54,9 +54,9 @@ struct LastReadMarkers: Identifiable, Codable {
         }
     }
     
-    func bySettingLastRead(_ newPosition: MarkerPosition, forKind kind: MastodonFeedKind) -> LastReadMarkers {
+    func bySettingPosition(_ newPosition: MarkerPosition, forKind kind: MastodonFeedKind, enforceForwardProgress: Bool) -> LastReadMarkers {
         if let previous = lastRead(forKind: kind) {
-            guard previous.lastReadID < newPosition.lastReadID else { return self }
+            guard !enforceForwardProgress || previous.lastReadID < newPosition.lastReadID else { return self }
         }
         switch kind {
         case .notificationsAll:
diff --git a/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift
index a19cd82d27..d482804036 100644
--- a/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift	
@@ -156,6 +156,12 @@ struct NotificationListView: View {
                 .refreshable {
                     await viewModel.refreshFeedFromTop()
                 }
+                .onChange(of: viewModel.notificationItems, initial: true) { oldValue, newValue in
+                    if let newest = newValue.first?.rowViewModel, let stableScroll = scrollManager.stableScroll(withNewestOfAll: newest, newestRead: newValue.first(where: { !(viewModel.isUnread($0) ?? false) })?.rowViewModel)
+                    {
+                        doScrollRequest(stableScroll, currentItems: viewModel.notificationItems, proxy: proxy)
+                    }
+                }
                 .onAppear() {
                     viewDidAppear()
                 }
@@ -197,6 +203,13 @@ struct NotificationListView: View {
                 .listRowBackground(
                     backgroundView(isPrivate: viewModel.usePrivateBackground, isUnread: isUnread)
                 )
+#if DEBUG && false
+                .overlay {
+                    Text(viewModel.identifier.id)
+                        .padding()
+                        .background(Color.secondary.opacity(0.5))
+                }
+#endif
         }
     }
     
@@ -290,6 +303,53 @@ struct NotificationListView: View {
     }
 }
 
+fileprivate extension NotificationListView {
+    func calculateStableScroll(newItems: [NotificationListItem], oldItems: [NotificationListItem]) -> ScrollManager.ScrollRequest? {
+        
+        let newestRead = oldItems.first(where: { item in
+            if let isUnread = viewModel.isUnread(item) {
+                return !isUnread
+            } else {
+                return false
+            }
+        })
+        guard let newestRead else {
+            return nil
+        }
+        
+        func newItemWithID(_ id: String) -> NotificationListItem? {
+            return newItems.first { item in
+                return item.id == id
+            }
+        }
+        
+        if let newestOfAllModel = newItems.first?.rowViewModel, let newestReadModel = newestRead.rowViewModel, let stableScroll = scrollManager.stableScroll(withNewestOfAll: newestOfAllModel, newestRead: newestReadModel) {
+            scrollManager.reset()
+            return stableScroll
+        } else {
+            return nil
+        }
+    }
+    
+    func doScrollRequest(_ stableScroll: ScrollManager.ScrollRequest, currentItems: [NotificationListItem], proxy: ScrollViewProxy) {
+        switch stableScroll {
+        case .middle(let id):
+            if let scrollItem = currentItems.first(where: { $0.id == id }) {
+                proxy.scrollTo(scrollItem, anchor: .center)
+            }
+        case .top(let id):
+            if let anchorItem = currentItems.first(where: { $0.id == id }), let anchorIndex = currentItems.firstIndex(of: anchorItem) {
+                if anchorIndex > 0 {
+                    let firstUnreadItem = currentItems[anchorIndex - 1]
+                    proxy.scrollTo(firstUnreadItem)
+                } else {
+                    proxy.scrollTo(anchorItem, anchor: .top)
+                }
+            }
+        }
+    }
+}
+
 @MainActor
 private class NotificationListViewModel: ObservableObject {
 
@@ -430,6 +490,7 @@ private class NotificationListViewModel: ObservableObject {
     }
 
     private func createNewFeedLoader() {
+        guard navigateToScene != nil && presentError != nil else { return }
         fetchFilteredNotificationsPolicy()
         feedLoader = GroupedNotificationFeedLoader(
             kind: displayedNotifications.feedKind,
@@ -486,7 +547,6 @@ fileprivate class ScrollManager {
     }
     
     public var isAppeared: Bool = false
-    public var pendingStableScroll: ScrollRequest? = nil
     
     private var visibleItems = Set<NotificationRowViewModel>()
     
@@ -507,6 +567,27 @@ fileprivate class ScrollManager {
         return newest
     }
     
+    
+    
+    func stableScroll(withNewestOfAll newestOfAll: NotificationRowViewModel, newestRead: NotificationRowViewModel?) -> ScrollRequest? {
+        guard let newestVisibleItem else {
+            if let newestRead {
+                return .middle(newestRead.identifier.id)
+            } else {
+                return nil
+            }
+        }
+       
+        if let newestRead, newestRead.matchesIdentifier(newestVisibleItem) {
+            // The most recent notification that has already been read is also the most recent visible item.
+            // We ask to scroll it down to the middle to reveal newer, unread items.
+            return .middle(newestRead.identifier.id)
+        } else {
+            let topID = newestVisibleItem.identifier.id
+            return .top(topID)
+        }
+    }
+    
     func reset() {
         visibleItems.removeAll()
     }
@@ -540,3 +621,9 @@ fileprivate class ScrollManager {
     }
 }
 
+extension NotificationRowViewModel {
+    func matchesIdentifier(_ other: NotificationRowViewModel?) -> Bool {
+        guard let other else { return false }
+        return identifier.id == other.identifier.id
+    }
+}
diff --git a/Mastodon/In Progress New Layout and Datamodel/NotificationsCacheManager.swift b/Mastodon/In Progress New Layout and Datamodel/NotificationsCacheManager.swift
index 6fcb557eed..b4e008c9d8 100644
--- a/Mastodon/In Progress New Layout and Datamodel/NotificationsCacheManager.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/NotificationsCacheManager.swift	
@@ -12,7 +12,7 @@ protocol NotificationsCacheManager<T> {
     var mostRecentlyFetchedResults: T? { get }
     func updateByInserting(newlyFetched: NotificationsResultType, at insertionPoint: GroupedNotificationFeedLoader.FeedLoadRequest.InsertLocation)
     func didFetchMarkers(_ updatedMarkers: Mastodon.Entity.Marker)
-    func updateToNewerMarker(_ newMarker: LastReadMarkers.MarkerPosition)
+    func updateToNewerMarker(_ newMarker: LastReadMarkers.MarkerPosition, enforceForwardProgress: Bool)
     func commitToCache() async
 }
 
@@ -122,14 +122,14 @@ class UngroupedNotificationCacheManager: NotificationsCacheManager {
     func didFetchMarkers(_ updatedMarkers: Mastodon.Entity.Marker) {
         var updatable = mostRecentMarkers ?? staleMarkers ?? LastReadMarkers(userGUID: userIdentifier.globallyUniqueUserIdentifier, home: nil, notifications: nil, mentions: nil)
         if let notifications = updatedMarkers.notifications {
-            updatable = updatable.bySettingLastRead(.fromServer(notifications), forKind: .notificationsAll)
+            updatable = updatable.bySettingPosition(.fromServer(notifications), forKind: .notificationsAll, enforceForwardProgress: true)
         }
         mostRecentMarkers = updatable
     }
  
-    func updateToNewerMarker(_ newMarker: LastReadMarkers.MarkerPosition) {
+    func updateToNewerMarker(_ newMarker: LastReadMarkers.MarkerPosition, enforceForwardProgress: Bool) {
         let updatable = mostRecentMarkers ?? staleMarkers ?? LastReadMarkers(userGUID: userIdentifier.globallyUniqueUserIdentifier, home: nil, notifications: nil, mentions: nil)
-        mostRecentMarkers = updatable.bySettingLastRead(newMarker, forKind: feedKind)
+        mostRecentMarkers = updatable.bySettingPosition(newMarker, forKind: feedKind, enforceForwardProgress: enforceForwardProgress)
     }
     
     func commitToCache() async {
@@ -285,15 +285,15 @@ class GroupedNotificationCacheManager: NotificationsCacheManager {
         mostRecentlyFetchedResults = Mastodon.Entity.GroupedNotificationsResults(notificationGroups: Array(truncatedGroups), fullAccounts: accounts, partialAccounts: partialAccounts, statuses: statuses)
     }
     
-    func updateToNewerMarker(_ newMarker: LastReadMarkers.MarkerPosition) {
+    func updateToNewerMarker(_ newMarker: LastReadMarkers.MarkerPosition, enforceForwardProgress: Bool) {
         let updatable = mostRecentMarkers.value ?? staleMarkers.value ?? LastReadMarkers(userGUID: userIdentifier.globallyUniqueUserIdentifier, home: nil, notifications: nil, mentions: nil)
-        mostRecentMarkers = .known(updatable.bySettingLastRead(newMarker, forKind: feedKind))
+        mostRecentMarkers = .known(updatable.bySettingPosition(newMarker, forKind: feedKind, enforceForwardProgress: enforceForwardProgress))
     }
     
     func didFetchMarkers(_ updatedMarkers: Mastodon.Entity.Marker) {
         var updatable = mostRecentMarkers.value ?? staleMarkers.value ?? LastReadMarkers(userGUID: userIdentifier.globallyUniqueUserIdentifier, home: nil, notifications: nil, mentions: nil)
         if let notifications = updatedMarkers.notifications {
-            updatable = updatable.bySettingLastRead(.fromServer(notifications), forKind: .notificationsAll)
+            updatable = updatable.bySettingPosition(.fromServer(notifications), forKind: .notificationsAll, enforceForwardProgress: true)
         }
         mostRecentMarkers = .known(updatable)
     }
