diff --git a/Mastodon.xcodeproj/project.pbxproj b/Mastodon.xcodeproj/project.pbxproj
index f91253c748..fb6bd88d6d 100644
--- a/Mastodon.xcodeproj/project.pbxproj
+++ b/Mastodon.xcodeproj/project.pbxproj
@@ -1193,6 +1193,7 @@
 				"Common Components/Views/TimelineRowViews/AccountRowViewModel.swift",
 				"Common Components/Views/TimelineRowViews/HashtagRowView.swift",
 				"Common Components/Views/TimelineRowViews/HashtagRowViewModel.swift",
+				"Common Components/Views/TimelineRowViews/InteractiveLoadingIndicatorRow.swift",
 				"Common Components/Views/TimelineRowViews/MastodonPostRowView.swift",
 				"Common Components/Views/TimelineRowViews/MastodonPostViewModel.swift",
 				"Common Components/Views/TimelineRowViews/Molecules/AuthorHeaderView.swift",
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/InteractiveLoadingIndicatorRow.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/InteractiveLoadingIndicatorRow.swift
new file mode 100644
index 0000000000..d8dd62cf85
--- /dev/null
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/TimelineRowViews/InteractiveLoadingIndicatorRow.swift	
@@ -0,0 +1,222 @@
+// Copyright Â© 2025 Mastodon gGmbH. All rights reserved.
+
+import SwiftUI
+
+@MainActor
+@Observable class InteractiveLoadingTriggerModel {
+    enum TriggerState {
+        case progressing(DisplaySpecs)
+        case triggered(DisplaySpecs)
+        
+        var steppedProgress: Double {
+            switch self {
+            case .progressing(let specs), .triggered(let specs):
+                return specs.steppedProgress
+            }
+        }
+        
+        var opacity: Double {
+            switch self {
+            case .progressing(let specs), .triggered(let specs):
+                return specs.opacity
+            }
+        }
+        
+        var scale: Double {
+            switch self {
+            case .progressing(let specs), .triggered(let specs):
+                return specs.scale
+            }
+        }
+    }
+    
+    struct DisplaySpecs {
+        let steppedProgress: Double
+        let opacity: Double
+        let scale: Double
+        
+        static let baseScale: Double = 2
+        
+        static func defaultSpecs(triggered: Bool) -> Self {
+            if triggered {
+                .init(steppedProgress: 1, opacity: 1, scale: baseScale)
+            } else {
+                .init(steppedProgress: 0, opacity: 0, scale: baseScale)
+            }
+        }
+    }
+    
+    var triggerFrame: CGRect?
+    var onTrigger: (()->(Bool))?
+    
+    var triggerState: TriggerState = .progressing(.defaultSpecs(triggered: false))
+    
+    func reset(triggered: Bool) {
+        if triggered {
+            triggerState = .triggered(.defaultSpecs(triggered: true))
+            visiblePercent = 1
+        } else {
+            triggerState = .progressing(.defaultSpecs(triggered: false))
+            visiblePercent = 0
+        }
+    }
+    
+    fileprivate var visiblePercent: Double = 0 {
+        didSet {
+            let progress = max(0, min(visiblePercent, 1))
+            
+            switch triggerState {
+            case .progressing:
+                let steppedProgress = steppedProgress(progress)
+                let opacity = opacity(progress)
+                let scale = scale(progress)
+                
+                let displaySpecs = DisplaySpecs(
+                    steppedProgress: steppedProgress,
+                    opacity: opacity,
+                    scale: scale
+                )
+                if steppedProgress == 1 {
+                    if onTrigger?() == true {
+                        triggerState = .triggered(.defaultSpecs(triggered: true))
+                    } else {
+                        reset(triggered: false)
+                    }
+                } else {
+                    triggerState = .progressing(displaySpecs)
+                }
+            case .triggered:
+                break
+            }
+        }
+    }
+    
+    var currentState: Double = 0
+    
+    let totalSteps: Double = 8
+    let singleStepPercentage: Double = 0.125
+    func steppedProgress(_ progress: Double) -> Double {
+        let currentStep = ceil(progress / singleStepPercentage)
+        let result = currentStep * singleStepPercentage
+        return result
+    }
+    
+    func opacity(_ progress: Double) -> Double {
+        // fade in the first step
+        if progress < singleStepPercentage {
+            return progress / singleStepPercentage
+        } else {
+            return 1
+        }
+    }
+
+    func scale(_ progress: Double) -> Double {
+        if progress == 1 {
+            return DisplaySpecs.baseScale
+        }
+        
+        let progressOfFinalStep = min(0, progress - ((totalSteps - 1) * singleStepPercentage))
+        return DisplaySpecs.baseScale + (progressOfFinalStep)
+    }
+}
+
+extension InteractiveLoadingTriggerModel.TriggerState : CustomDebugStringConvertible {
+    var debugDescription: String {
+        switch self {
+        case .progressing(let specs):
+            return "SteppedProgress: \(specs.steppedProgress)"
+        case .triggered:
+            return "TRIGGERED"
+        }
+    }
+}
+
+struct InteractiveLoadingIndicatorRow: View {
+   
+    @Environment(InteractiveLoadingTriggerModel.self) var triggerModel
+    
+    var body: some View {
+        VStack {
+                HStack {
+                    Spacer()
+                    ZStack {
+                        ProgressView()
+                            .progressViewStyle(.circular)
+                            .scaleEffect(triggerModel.triggerState.scale)
+                            .opacity(triggerModel.triggerState.opacity)
+                            .mask(
+                                PartialPie(startAngle: progressViewMaskStartAngle, percentCovered: triggerModel.triggerState.steppedProgress)
+                                    .frame(width: 30, height: 30)
+                                    .scaleEffect(triggerModel.triggerState.scale)
+                            )
+                    }
+                    Spacer()
+                }
+                .padding(EdgeInsets(top: 100, leading: 0, bottom: 100, trailing: 0))
+                .background() {
+                    GeometryReader { geo in
+                        Color.clear
+                            .frame(maxHeight: .infinity)
+                            .onChange(of: geo.frame(in: .global)) { oldValue, newValue in
+                                triggerModel.visiblePercent = visibleRatio(withFrame: newValue)
+                            }
+                            .onAppear() {
+                                triggerModel.visiblePercent = visibleRatio(withFrame: geo.frame(in: .global))
+                            }
+                    }
+                }
+        }
+    }
+    
+    let delayPadding: CGFloat = 150
+    
+    var progressViewMaskStartAngle: Angle {
+        Angle(degrees: -90 - (180 / triggerModel.totalSteps)) // start a little before "noon", so that the topmost element of the progress view displays in full)
+    }
+                                                  
+    func visibleRatio(withFrame frame: CGRect) -> Double {
+        guard let triggerFrame = triggerModel.triggerFrame else { return 0 }
+        let frameHeight = frame.size.height
+        let visibleHeight = max(0, (triggerFrame.maxY - delayPadding) - frame.minY)
+        if visibleHeight >= frameHeight {
+            return 1
+        } else {
+            let clamped =  min(1, visibleHeight / frameHeight)
+            return clamped
+        }
+    }
+}
+
+struct PartialPie: Shape {
+    
+    var startAngle: Angle
+    var percentCovered: Double
+    
+    func path(in rect: CGRect) -> Path {
+        let radius = min(rect.width, rect.height) / 2
+        let center = CGPoint(x: rect.midX, y: rect.midY)
+        
+        let startAngle = startAngle
+        let endAngle = startAngle + Angle.degrees(percentCovered * 360)
+       
+        var path = Path()
+        
+        path.move(to: CGPoint(
+            x: center.x + radius * cos(CGFloat(startAngle.radians)),
+            y: center.y + radius * sin(CGFloat(startAngle.radians))
+        ))
+        
+        path.addArc(
+            center: center,
+            radius: radius,
+            startAngle: startAngle,
+            endAngle: endAngle,
+            clockwise: false
+        )
+        
+        path.addLine(to: center)
+        path.closeSubpath()
+        
+        return path
+    }
+}
diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift
index f791706f58..f6c9286dcc 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
@@ -615,6 +615,8 @@ enum MastodonTimelineSheet {
     var scrollAnchorItem: TimelineItem = .noItem
     var ignoreNextTopItemBecomeVisible: Bool = false // This is required to correct for the fact that the system will not update the scrollPosition when the user taps the status bar to scroll all the way to the top, and that the system will initially layout the view with the content scrolled all the way to the top any time the view reappears.
     
+    let interactiveReloadTriggerModel = InteractiveLoadingTriggerModel()
+    
     enum ReloadReason {
         case notificationFilterPolicyUpdated
         case userRequestedRefresh
@@ -642,6 +644,16 @@ enum MastodonTimelineSheet {
     var activeSheet: MastodonTimelineSheet? = nil
     
     func setCurrentDisplaySlice(_ newSlice: ArraySlice<TimelineItem>, newScrollAnchor: TimelineItem?, mayNeedHeightCalculations: Bool, addLoadingIndicator: Bool) {
+        
+        defer {
+            switch loadingState {
+            case .initializing:
+                break
+            default:
+                interactiveReloadTriggerModel.reset(triggered: false)
+            }
+        }
+        
         // space to add any necessary bookkeeping before setting the slice
         let prefix: [TimelineItem] = {
             switch timeline {
@@ -884,6 +896,21 @@ enum MastodonTimelineSheet {
     func doInitialLoad() async throws {
         guard feedLoader == nil else { return }
         guard let authenticatedUser else { return }
+        
+        interactiveReloadTriggerModel.reset(triggered: true)
+        
+        interactiveReloadTriggerModel.onTrigger = {
+            switch self.loadingState {
+            case .initializing:
+                return false
+            case .untracked:
+                self.loadMoreFromBottom()
+                return true
+            case .requestedPrependedHeightCalculations, .requestedReloadFromBottom, .requestedReloadFromTop:
+                return false
+            }
+        }
+        
         clearPendingActions()
         feedLoader = TimelineFeedLoader(currentUser: authenticatedUser, timeline: timeline)
         
@@ -1301,6 +1328,12 @@ struct TimelineListView: View {
                         }, set: { newAnchorItem in
                             viewModel.scrollAnchorItem = newAnchorItem ?? .noItem
                         }), anchor: .top)
+                        .onAppear() {
+                            viewModel.interactiveReloadTriggerModel.triggerFrame = geo.frame(in: .global)
+                        }
+                        .onChange(of: geo.frame(in: .global)) { _, newValue in
+                            viewModel.interactiveReloadTriggerModel.triggerFrame = newValue
+                        }
                         .onChange(of: geo.size.width, initial: true) { _, _ in
                             viewModel.currentUseableWidth = useableWidth(fromGeoProxy: geo)
                         }
@@ -1492,39 +1525,20 @@ struct TimelineListView: View {
     @ViewBuilder func feedContents(_ geo: GeometryProxy) -> some View {
         let useableWidth = useableWidth(fromGeoProxy: geo)
         let contentWidth = contentWidth(forUseableWidth: useableWidth)
-
+        
         ForEach(viewModel.currentDisplaySlice, id: \.self) { item in
             switch item {
             case .loadingIndicator:
-                HStack {
-                    Spacer()
-                    ProgressView()
-                        .progressViewStyle(.circular)
-                    Spacer()
-                }
-                .padding(EdgeInsets(top: 100, leading: 0, bottom: 100, trailing: 0))
-                .accessibilityAction(named: L10n.Common.Controls.Actions.loadOlder) {
-                    switch viewModel.loadingState {
-                    case .untracked:
-                        viewModel.loadMoreFromBottom()
-                    default:
-                        break
-                    }
-                }
-                VisibilityTrackingView(scrollCoordinateSpace: scrollViewCoordinateSpace,
-                                       visibleAreaHeight: geo.size.height, visibilityDidChange: { isVisible in
-                    if isVisible {
+                InteractiveLoadingIndicatorRow()
+                    .environment(viewModel.interactiveReloadTriggerModel)
+                    .accessibilityAction(named: L10n.Common.Controls.Actions.loadOlder) {
                         switch viewModel.loadingState {
-                        case .initializing:
-                            viewModel.resetToUntrackedAfterDelay()
                         case .untracked:
                             viewModel.loadMoreFromBottom()
                         default:
                             break
                         }
                     }
-                })
-                .frame(width: 10, height: 1)
                 
             case .filteredNotificationsInfo(_, let filteredNotificationsViewModel):
                 if let filteredNotificationsViewModel {
