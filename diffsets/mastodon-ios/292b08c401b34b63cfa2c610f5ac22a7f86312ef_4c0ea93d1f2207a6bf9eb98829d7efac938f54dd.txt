diff --git a/Localization/app.json b/Localization/app.json
index c009d8cce7..81aee4d5e0 100644
--- a/Localization/app.json
+++ b/Localization/app.json
@@ -241,6 +241,7 @@
             "friendship": {
                 "follow": "Follow",
                 "following": "Following",
+                "mutual": "Mutual"
                 "request": "Request",
                 "pending": "Pending",
                 "block": "Block",
diff --git a/Mastodon.xcodeproj/project.pbxproj b/Mastodon.xcodeproj/project.pbxproj
index ef4ad57d2c..727919bac1 100644
--- a/Mastodon.xcodeproj/project.pbxproj
+++ b/Mastodon.xcodeproj/project.pbxproj
@@ -1275,6 +1275,7 @@
 		FBBEA04F2D3819080000A900 /* PBXFileSystemSynchronizedBuildFileExceptionSet */ = {
 			isa = PBXFileSystemSynchronizedBuildFileExceptionSet;
 			membershipExceptions = (
+				GroupedNotificationFeedLoader.swift,
 				InlinePostPreview.swift,
 				NotificationListViewController.swift,
 				NotificationRowView.swift,
diff --git a/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift b/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift
new file mode 100644
index 0000000000..2f527cb773
--- /dev/null
+++ b/Mastodon/In Progress New Layout and Datamodel/GroupedNotificationFeedLoader.swift	
@@ -0,0 +1,255 @@
+//
+//  GroupedNotificationFeedLoader.swift
+//  MastodonSDK
+//
+//  Created by Shannon Hughes on 1/31/25.
+//
+
+import Combine
+import Foundation
+import MastodonCore
+import MastodonSDK
+import UIKit
+import os.log
+
+@MainActor
+final public class GroupedNotificationFeedLoader {
+
+    struct FeedLoadRequest: Equatable {
+        let olderThan: MastodonFeedItemIdentifier?
+        let newerThan: MastodonFeedItemIdentifier?
+
+        var maxID: String? { olderThan?.id }
+
+        var resultsInsertionPoint: InsertLocation {
+            if olderThan != nil {
+                return .end
+            } else if newerThan != nil {
+                return .start
+            } else {
+                return .replace
+            }
+        }
+        enum InsertLocation {
+            case start
+            case end
+            case replace
+        }
+    }
+
+    private let logger = Logger(
+        subsystem: "GroupedNotificationFeedLoader", category: "Data")
+    private static let entryNotFoundMessage =
+        "Failed to find suitable record. Depending on the context this might result in errors (data not being updated) or can be discarded (e.g. when there are mixed data sources where an entry might or might not exist)."
+
+    @Published private(set) var records: [_NotificationViewModel] = []
+
+    private let kind: MastodonFeedKind
+    private let presentError: (Error) -> Void
+
+    private var activeFilterBoxSubscription: AnyCancellable?
+
+    public init(kind: MastodonFeedKind, presentError: @escaping (Error) -> Void)
+    {
+        self.kind = kind
+        self.presentError = presentError
+
+        activeFilterBoxSubscription = StatusFilterService.shared
+            .$activeFilterBox
+            .sink { filterBox in
+                if filterBox != nil {
+                    Task { [weak self] in
+                        guard let self else { return }
+                        await self.setRecordsAfterFiltering(self.records)
+                    }
+                }
+            }
+    }
+
+    private var mostRecentLoad: FeedLoadRequest?
+
+    public func loadMore(
+        olderThan: MastodonFeedItemIdentifier?,
+        newerThan: MastodonFeedItemIdentifier?
+    ) {
+        let request = FeedLoadRequest(
+            olderThan: olderThan, newerThan: newerThan)
+        Task {
+            let unfiltered = try await load(request)
+            await insertRecordsAfterFiltering(
+                at: request.resultsInsertionPoint, additionalRecords: unfiltered
+            )
+        }
+    }
+
+    private func load(_ request: FeedLoadRequest) async throws
+        -> [_NotificationViewModel]
+    {
+        guard request != mostRecentLoad else { throw AppError.badRequest }
+        mostRecentLoad = request
+        switch kind {
+        case .notificationsAll:
+            return try await loadNotifications(
+                withScope: .everything, olderThan: request.maxID)
+        case .notificationsMentionsOnly:
+            return try await loadNotifications(
+                withScope: .mentions, olderThan: request.maxID)
+        case .notificationsWithAccount(let accountID):
+            return try await loadNotifications(
+                withAccountID: accountID, olderThan: request.maxID)
+        }
+    }
+}
+
+// MARK: - Filtering
+extension GroupedNotificationFeedLoader {
+    private func setRecordsAfterFiltering(
+        _ newRecords: [_NotificationViewModel]
+    ) async {
+        guard let filterBox = StatusFilterService.shared.activeFilterBox else {
+            self.records = newRecords
+            return
+        }
+        let filtered = await self.filter(
+            newRecords, forFeed: kind, with: filterBox)
+        self.records = filtered.removingDuplicates()
+    }
+
+    private func insertRecordsAfterFiltering(
+        at insertionPoint: FeedLoadRequest.InsertLocation,
+        additionalRecords: [_NotificationViewModel]
+    ) async {
+        guard let filterBox = StatusFilterService.shared.activeFilterBox else {
+            self.records += additionalRecords
+            return
+        }
+        let newRecords = await self.filter(
+            additionalRecords, forFeed: kind, with: filterBox)
+        var combinedRecords = self.records
+        switch insertionPoint {
+        case .start:
+            combinedRecords = newRecords + combinedRecords
+        case .end:
+            combinedRecords.append(contentsOf: newRecords)
+        case .replace:
+            combinedRecords = newRecords
+        }
+        self.records = combinedRecords.removingDuplicates()
+    }
+
+    private func filter(
+        _ records: [_NotificationViewModel], forFeed feedKind: MastodonFeedKind,
+        with filterBox: Mastodon.Entity.FilterBox
+    ) async -> [_NotificationViewModel] {
+        return records
+    }
+}
+
+// MARK: - Notifications
+extension GroupedNotificationFeedLoader {
+    private func loadNotifications(
+        withScope scope: APIService.MastodonNotificationScope,
+        olderThan maxID: String? = nil
+    ) async throws -> [_NotificationViewModel] {
+        let useGroupedNotifications = UserDefaults.standard
+            .useGroupedNotifications
+        if useGroupedNotifications {
+            return try await _getGroupedNotifications(
+                withScope: scope, olderThan: maxID)
+        } else {
+            return try await _getUngroupedNotifications(
+                withScope: scope, olderThan: maxID)
+        }
+    }
+
+    private func loadNotifications(
+        withAccountID accountID: String, olderThan maxID: String? = nil
+    ) async throws -> [_NotificationViewModel] {
+        let useGroupedNotifications = UserDefaults.standard
+            .useGroupedNotifications
+        if useGroupedNotifications {
+            return try await _getGroupedNotifications(
+                accountID: accountID, olderThan: maxID)
+        } else {
+            return try await _getUngroupedNotifications(
+                accountID: accountID, olderThan: maxID)
+        }
+    }
+
+    private func _getUngroupedNotifications(
+        withScope scope: APIService.MastodonNotificationScope? = nil,
+        accountID: String? = nil, olderThan maxID: String? = nil
+    ) async throws -> [_NotificationViewModel] {
+
+        assert(scope != nil || accountID != nil, "need a scope or an accountID")
+        guard
+            let authenticationBox = AuthenticationServiceProvider.shared
+                .currentActiveUser.value
+        else { throw APIService.APIError.implicit(.authenticationMissing) }
+
+        let notifications = try await APIService.shared.notifications(
+            olderThan: maxID, fromAccount: accountID, scope: scope,
+            authenticationBox: authenticationBox
+        ).value
+
+        return notifications.map {
+            _NotificationViewModel(
+                $0,
+                presentError: { [weak self] error in self?.presentError(error) }
+            )
+        }
+    }
+
+    private func _getGroupedNotifications(
+        withScope scope: APIService.MastodonNotificationScope? = nil,
+        accountID: String? = nil, olderThan maxID: String? = nil
+    ) async throws -> [_NotificationViewModel] {
+
+        assert(scope != nil || accountID != nil, "need a scope or an accountID")
+
+        guard
+            let authenticationBox = AuthenticationServiceProvider.shared
+                .currentActiveUser.value
+        else { throw APIService.APIError.implicit(.authenticationMissing) }
+
+        let results = try await APIService.shared.groupedNotifications(
+            olderThan: maxID, fromAccount: accountID, scope: scope,
+            authenticationBox: authenticationBox
+        ).value
+
+        return
+            _NotificationViewModel
+            .viewModelsFromGroupedNotificationResults(
+                results,
+                myAccountID: authenticationBox.userID,
+                presentError: { [weak self] error in self?.presentError(error) }
+            )
+    }
+
+    private func _getGroupedNotificationResults(
+        withScope scope: APIService.MastodonNotificationScope? = nil,
+        accountID: String? = nil, olderThan maxID: String? = nil
+    ) async throws -> Mastodon.Entity.GroupedNotificationsResults {
+
+        assert(scope != nil || accountID != nil, "need a scope or an accountID")
+
+        guard
+            let authenticationBox = AuthenticationServiceProvider.shared
+                .currentActiveUser.value
+        else { throw APIService.APIError.implicit(.authenticationMissing) }
+
+        let results = try await APIService.shared.groupedNotifications(
+            olderThan: maxID, fromAccount: accountID, scope: scope,
+            authenticationBox: authenticationBox
+        ).value
+
+        return results
+    }
+}
+
+
+extension _NotificationViewModel: Hashable {
+    func hash(into hasher: inout Hasher) {
+        hasher.combine(identifier)
+    }
+}
diff --git a/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift
index ecbf061182..69d02c2e2b 100644
--- a/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/NotificationListViewController.swift	
@@ -11,6 +11,13 @@ class NotificationListViewController: UIHostingController<NotificationListView>
         let viewModel = NotificationListViewModel()
         let root = NotificationListView(viewModel: viewModel)
         super.init(rootView: root)
+        
+        viewModel.presentError = { error in
+            let alert = UIAlertController(title: "Error", message: error.localizedDescription, preferredStyle: .alert)
+            alert.addAction(UIAlertAction(title: "OK", style: .default))
+            self.sceneCoordinator?.rootViewController?.topMost?.present(alert, animated: true)
+        }
+        
         viewModel.navigateToScene = { [weak self] scene, transition in
             guard let self else { return }
             self.sceneCoordinator?.present(scene: scene, from: self, transition: transition)
@@ -77,6 +84,14 @@ struct NotificationListView: View {
             List {
                 ForEach(viewModel.notificationItems) { item in
                     rowView(item)
+                        .onAppear {
+                            switch item {
+                            case .groupedNotification(let viewModel):
+                                viewModel.prepareForDisplay()
+                            default:
+                                break
+                            }
+                        }
                         .onTapGesture {
                             didTap(item: item)
                         }
@@ -94,9 +109,10 @@ struct NotificationListView: View {
         case .filteredNotificationsInfo:
             Text("filtered notifications not yet implemented")
         case .notification(let feedItemIdentifier):
+            Text("obsolete item")
+        case .groupedNotification(let viewModel):
             // TODO: implement unread using Mastodon.Entity.Marker
-            let viewModel = NotificationRowViewModel.viewModel(feedItemIdentifier: feedItemIdentifier, isUnread: false)
-            GroupedNotificationRowView(viewModel: viewModel)
+            _NotificationRowView(viewModel: viewModel)
         }
     }
     
@@ -137,20 +153,21 @@ fileprivate class NotificationListViewModel: ObservableObject {
     @Published var notificationItems: [NotificationListItem] = []
     
     private var feedSubscription: AnyCancellable?
-    private var feedLoader = MastodonFeedLoader(kind: .notificationsAll)
-    
-    init() {
-        createNewFeedLoader()
+    private var feedLoader = GroupedNotificationFeedLoader(kind: .notificationsAll, presentError: { _ in })
+    fileprivate var presentError: ((Error)->()) = { _ in } {
+        didSet {
+            createNewFeedLoader()
+        }
     }
     
     private func createNewFeedLoader() {
-        feedLoader = MastodonFeedLoader(kind: displayedNotifications.feedKind)
+        feedLoader = GroupedNotificationFeedLoader(kind: displayedNotifications.feedKind, presentError: presentError)
         feedSubscription = feedLoader.$records
             .receive(on: DispatchQueue.main)
             .sink { [weak self] records in
                 // TODO: add middle loader and bottom loader?
-                let updatedItems = records.compactMap {
-                    NotificationListItem.fromMastodonFeedItemIdentifier($0)
+                let updatedItems = records.map {
+                    NotificationListItem.groupedNotification($0)
                 }
                 // TODO: add the filtered notifications announcement if needed
                 self?.notificationItems = updatedItems
diff --git a/Mastodon/In Progress New Layout and Datamodel/NotificationRowView.swift b/Mastodon/In Progress New Layout and Datamodel/NotificationRowView.swift
index db6b0add2e..a51f3e9290 100644
--- a/Mastodon/In Progress New Layout and Datamodel/NotificationRowView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/NotificationRowView.swift	
@@ -18,8 +18,8 @@ struct GroupedNotificationRowView: View {
     
     var body: some View {
             HStack(alignment: .top) {
-                if let iconName = viewModel.type.iconSystemName(grouped: viewModel.grouped) {
-                    NotificationIconView(for: viewModel.type, iconName: iconName)
+                if viewModel.type.shouldShowIcon(grouped: viewModel.grouped) {
+                    NotificationIconView(NotificationIconInfo(notificationType: viewModel.type, isGrouped: viewModel.grouped))
                 }
                 VStack(alignment: .leading) {
                     contentView()
@@ -40,30 +40,6 @@ struct GroupedNotificationRowView: View {
         // TODO: implement unread with Mastodon.Entity.Marker
         
         switch viewModel {
-        case is FollowNotificationViewModel:
-            if viewModel.grouped {
-                AvatarGroupRow(avatars: viewModel.authorAvatarUrls)
-                Text("\(viewModel.authorsDescription) followed you")
-            } else {
-                let viewModel = viewModel as! FollowNotificationViewModel
-                HStack {
-                    AvatarGroupRow(avatars: viewModel.authorAvatarUrls)
-                    switch viewModel.followButtonAction {
-                    case .action(let buttonText):
-                        Button(buttonText) {}
-                            .buttonStyle(.borderedProminent)
-                            .controlSize(.small)
-                            .bold()
-                        // TODO: implement follow action
-                    case .unfetched, .fetching:
-                        ProgressView()
-                            .progressViewStyle(.circular)
-                    case .noneNeeded, .error:
-                        Spacer().frame(width: 0)
-                    }
-                }
-                Text("\(viewModel.authorName) followed you")
-            }
         case is StatusNotificationViewModel:
             if viewModel.type == .status {
                 TimelinePostCell(viewModel.feedItemIdentifier, includePadding: false)
@@ -139,6 +115,11 @@ struct AvatarGroupRow: View {
 }
 
 extension Mastodon.Entity.NotificationType {
+    
+    func shouldShowIcon(grouped: Bool) -> Bool {
+        return iconSystemName(grouped: grouped) != nil
+    }
+    
     func iconSystemName(grouped: Bool = false) -> String? {
         switch self {
         case .favourite:
@@ -152,16 +133,26 @@ extension Mastodon.Entity.NotificationType {
                 return "person.fill.badge.plus"
             }
         case .poll:
-            return "chart.bar.xaxis"
+            return "chart.bar.yaxis"
         case .adminReport:
             return "info.circle"
         case .severedRelationships:
             return "person.badge.minus"
         case .moderationWarning:
-            return "exclamationmark.shield"
+            return "exclamationmark.shield.fill"
         case ._other:
             return "questionmark.square.dashed"
-        case .followRequest, .mention, .status, .update, .adminSignUp:
+        case .mention:
+            // TODO: make this nil when full status view is available
+            return "quote.bubble.fill"
+        case .status:
+            // TODO: make this nil when full status view is available
+            return "bell.fill"
+        case .followRequest:
+            return "person.fill.badge.plus"
+        case .update:
+            return "pencil"
+        case .adminSignUp:
             return nil
         }
     }
@@ -172,29 +163,123 @@ extension Mastodon.Entity.NotificationType {
             return .orange
         case .reblog:
             return .green
-        case .follow:
+        case .follow, .followRequest, .status, .mention, .update:
             return Color(asset: Asset.Colors.accent)
-        case .poll:
-            return .secondary
-        case .adminReport:
-            return Color(asset: Asset.Colors.accent)
-        case .severedRelationships:
+        case .poll, .severedRelationships, .moderationWarning,  .adminReport, .adminSignUp:
             return .secondary
-        case .moderationWarning:
-            return Color(asset: Asset.Colors.accent)
         case ._other:
             return .gray
-        case .followRequest, .mention, .status, .update, .adminSignUp:
-            return .gray
+        }
+    }
+    
+    enum AuthorName {
+        case me
+        case other(named: String)
+        
+        var string: String {
+            switch self {
+            case .me:
+                return "You"
+            case .other(let name):
+                return name
+            }
+        }
+    }
+    func actionSummaryLabel(firstAuthor: AuthorName, totalAuthorCount: Int) -> AttributedString {
+        // TODO: L10n strings
+        switch firstAuthor {
+        case .me:
+            assert(totalAuthorCount == 1)
+            assert(self == .poll)
+            return "Your poll has ended"
+        case .other(let firstAuthorName):
+            let nameComponent = boldedNameStringComponent(firstAuthorName)
+            var composedString: AttributedString
+            if totalAuthorCount == 1 {
+                switch self {
+                case .favourite:
+                    composedString = nameComponent + AttributedString(" favorited:")
+                case .follow:
+                    composedString = nameComponent + AttributedString(" followed you")
+                case .followRequest:
+                    composedString = nameComponent + AttributedString(" requested to follow you")
+                case .reblog:
+                    composedString = nameComponent + AttributedString(" boosted:")
+                case .mention:
+                    composedString = nameComponent + AttributedString(" mentioned you:")
+                case .status:
+                    composedString = nameComponent + AttributedString(" posted:")
+                case .adminSignUp:
+                    composedString = nameComponent + AttributedString(" signed up")
+                default:
+                    composedString = nameComponent + AttributedString("did something?")
+                }
+            } else {
+                switch self {
+                case .favourite:
+                    composedString = nameComponent + AttributedString(" and \(totalAuthorCount - 1) others favorited:")
+                case .follow:
+                    composedString = nameComponent + AttributedString(" and \(totalAuthorCount - 1) others followed you")
+                case .reblog:
+                    composedString = nameComponent + AttributedString(" and \(totalAuthorCount - 1) others boosted:")
+                default:
+                    composedString = nameComponent + AttributedString(" and \(totalAuthorCount - 1) others did something")
+                }
+            }
+            let nameStyling = AttributeContainer.font(.system(.body, weight: .bold))
+            let nameContainer = AttributeContainer.personNameComponent(.givenName)
+            composedString.replaceAttributes(nameContainer, with: nameStyling)
+            return composedString
         }
     }
 }
 
+extension Mastodon.Entity.Report {
+    // TODO: localization (inc. plurals)
+    // "Someone reported X posts from someone else for rule violation"
+    var summary: AttributedString {
+        if let targetedAccountName = targetAccount?.displayNameWithFallback {
+            let boldedName = boldedNameStringComponent(targetedAccountName)
+            if let postCount = flaggedStatusIDs?.count {
+                return AttributedString("Someone reported \(postCount) posts from ") + boldedName + AttributedString(" for rule violation.")
+            } else {
+                    return AttributedString("Someone reported ") + boldedName + AttributedString(" for rule violation.")
+            }
+        } else {
+            return AttributedString("RULE VIOLATION REPORT")
+        }
+    }
+    var displayableComment: AttributedString? {
+        if let comment {
+            return AttributedString(comment)
+        } else {
+            return nil
+        }
+    }
+}
+
+var listFormatter = ListFormatter()
+
+extension Mastodon.Entity.RelationshipSeveranceEvent {
+    // TODO: details and localization
+    // Ideal example: "An admin from a.b has blocked c.d, including x of your followers and y accounts you follow."
+    // For now: "An admin action has blocked x of your followers and y accounts that you follow"
+    var summary: AttributedString? {
+        let baseString = "Your admins have blocked "
+        let lostFollowersString = followersCount > 0 ? "\(followersCount) of your followers" : nil
+        let lostFollowingString = followingCount > 0 ? "\(followingCount) accounts that you follow" : nil
+        guard let followersAndFollowingString = listFormatter.string(from: [lostFollowersString, lostFollowingString].compactMap { $0 } ) else {
+            return nil
+        }
+        return AttributedString(baseString + followersAndFollowingString + ".")
+    }
+}
+
 @ViewBuilder
-func NotificationIconView(for type: Mastodon.Entity.NotificationType, iconName: String) -> some View {
+func NotificationIconView(_ info: NotificationIconInfo) -> some View {
     HStack {
-        Image(systemName: iconName)
-            .foregroundStyle(type.iconColor)
+        Image(systemName: info.notificationType.iconSystemName(grouped: info.isGrouped) ?? "questionmark.square.dashed")
+            .foregroundStyle(info.notificationType.iconColor)
     }
     .font(.system(size: 25))
     .frame(width: 44)
@@ -202,50 +287,82 @@ func NotificationIconView(for type: Mastodon.Entity.NotificationType, iconName:
     .fontWeight(.semibold)
 }
 
-enum AvailableFollowAction: Equatable {
-    case unfetched
-    case fetching
-    case error(Error)
+
+enum RelationshipElement: Equatable {
     case noneNeeded
-    case action(buttonText: String)
+    case unfetched(Mastodon.Entity.NotificationType, accountID: String)
+    case fetching
+    case error(Error?)
+    case followButton
+    case requestButton
+    case acceptRejectButtons(isFollowing: Bool)
+    case acceptedLabel
+    case rejectedLabel
+    case mutualLabel
+    case followingLabel
+    case pendingRequestLabel
     
     var description: String {
         switch self {
+        case .noneNeeded:
+            return "noneNeeded"
         case .unfetched:
             return "unfetched"
         case .fetching:
             return "fetching"
-        case .error(let error):
-            return "error(\(error.localizedDescription))"
-        case .noneNeeded:
-            return "noneNeeded"
-        case .action(let buttonText):
-            return "action(\(buttonText))"
+        case .error:
+            return "error"
+        case .followButton:
+            return "follow"
+        case .requestButton:
+            return "request"
+        case .acceptRejectButtons:
+            return "acceptReject"
+        case .acceptedLabel:
+            return "accepted"
+        case .rejectedLabel:
+            return "rejected"
+        case .mutualLabel:
+            return "mutual"
+        case .followingLabel:
+            return "following"
+        case .pendingRequestLabel:
+            return "pending"
         }
     }
     
-    static func == (lhs: AvailableFollowAction, rhs: AvailableFollowAction) -> Bool {
+    static func == (lhs: RelationshipElement, rhs: RelationshipElement) -> Bool {
         return lhs.description == rhs.description
     }
     
 }
 
 protocol NotificationInfo {
+    var id: String { get }
     var type: Mastodon.Entity.NotificationType { get }
     var isGrouped: Bool { get }
+    var notificationsCount: Int { get }
     var authorsCount: Int { get }
     var primaryAuthorAccount: Mastodon.Entity.Account? { get }
-    var authorName: String { get }
+    var authorName: Mastodon.Entity.NotificationType.AuthorName? { get }
     var authorAvatarUrls: [URL] { get }
-    func availableFollowAction() async -> AvailableFollowAction?
-    func fetchAvailableFollowAction() async -> AvailableFollowAction
+    func availableRelationshipElement() async -> RelationshipElement?
+    func fetchRelationshipElement() async -> RelationshipElement
+    var statusViewModel: Mastodon.Entity.Status.ViewModel? { get }
+    var ruleViolationReport: Mastodon.Entity.Report? { get }
+    var relationshipSeveranceEvent: Mastodon.Entity.RelationshipSeveranceEvent? { get }
 }
 extension NotificationInfo {
-    var authorsDescription: String {
-        if authorsCount > 1 {
-            return "\(authorName) and \(authorsCount - 1) others"
-        } else {
-            return authorName
+    var authorsDescription: String? {
+        switch authorName {
+        case .me, .none:
+            return nil
+        case .other(let name):
+            if authorsCount > 1 {
+                return "\(name) and \(authorsCount - 1) others"
+            } else {
+                return name
+            }
         }
     }
     var avatarCount: Int {
@@ -256,10 +373,55 @@ extension NotificationInfo {
     }
 }
 
+struct GroupedNotificationInfo: NotificationInfo {
+    func availableRelationshipElement() async -> RelationshipElement? {
+        return relationshipElement
+    }
+    
+    func fetchRelationshipElement() async -> RelationshipElement {
+        return relationshipElement
+    }
+    
+    let id: String
+    
+    let type: MastodonSDK.Mastodon.Entity.NotificationType
+    
+    let authorsCount: Int
+    
+    let notificationsCount: Int
+    
+    let primaryAuthorAccount: MastodonSDK.Mastodon.Entity.Account?
+    
+    let authorName: Mastodon.Entity.NotificationType.AuthorName?
+    
+    let authorAvatarUrls: [URL]
+    
+    var relationshipElement: RelationshipElement {
+        switch type {
+        case .follow, .followRequest:
+            if let primaryAuthorAccount {
+                return .unfetched(type, accountID: primaryAuthorAccount.id)
+            } else {
+                return .error(nil)
+            }
+        default:
+            return .noneNeeded
+        }
+    }
+    
+    let statusViewModel: Mastodon.Entity.Status.ViewModel?
+    let ruleViolationReport: Mastodon.Entity.Report?
+    let relationshipSeveranceEvent: Mastodon.Entity.RelationshipSeveranceEvent?
+}
+
 extension Mastodon.Entity.Notification: NotificationInfo {
+    
     var authorsCount: Int { 1 }
+    var notificationsCount: Int { 1 }
     var primaryAuthorAccount: Mastodon.Entity.Account? { account }
-    var authorName: String { account.displayNameWithFallback }
+    var authorName: Mastodon.Entity.NotificationType.AuthorName? {
+        .other(named: account.displayNameWithFallback)
+    }
     var authorAvatarUrls: [URL] {
         if let domain = account.domain {
             return [account.avatarImageURLWithFallback(domain: domain)]
@@ -271,21 +433,19 @@ extension Mastodon.Entity.Notification: NotificationInfo {
     }
     
     @MainActor
-    func availableFollowAction() -> AvailableFollowAction? {
+    func availableRelationshipElement() -> RelationshipElement? {
         if let relationship = MastodonFeedItemCacheManager.shared.currentRelationship(toAccount: account.id) {
-            if let text = relationship.followButtonText {
-                return .action(buttonText: text)
-            }
+            return relationship.relationshipElement
         }
         return nil
     }
     
     @MainActor
-    func fetchAvailableFollowAction() async -> AvailableFollowAction {
+    func fetchRelationshipElement() async -> RelationshipElement {
         do {
             try await fetchRelationship()
-            if let availableAction = availableFollowAction() {
-                return availableAction
+            if let available = availableRelationshipElement() {
+                return available
             } else {
                 return .noneNeeded
             }
@@ -298,6 +458,10 @@ extension Mastodon.Entity.Notification: NotificationInfo {
         let relationship = try await APIService.shared.relationship(forAccounts: [account], authenticationBox: authBox)
         await MastodonFeedItemCacheManager.shared.addToCache(relationship)
     }
+    
+    var statusViewModel: Mastodon.Entity.Status.ViewModel? {
+        return status?.viewModel()
+    }
 }
 
 extension Mastodon.Entity.NotificationGroup: NotificationInfo {
@@ -311,9 +475,9 @@ extension Mastodon.Entity.NotificationGroup: NotificationInfo {
     var authorsCount: Int { notificationsCount }
     
     @MainActor
-    var authorName: String {
-        guard let firstAccountID = sampleAccountIDs.first, let firstAccount = MastodonFeedItemCacheManager.shared.fullAccount(firstAccountID) else { return "" }
-        return firstAccount.displayNameWithFallback
+    var authorName: Mastodon.Entity.NotificationType.AuthorName? {
+        guard let firstAccountID = sampleAccountIDs.first, let firstAccount = MastodonFeedItemCacheManager.shared.fullAccount(firstAccountID) else { return .none }
+        return .other(named: firstAccount.displayNameWithFallback)
     }
     
     @MainActor
@@ -334,21 +498,21 @@ extension Mastodon.Entity.NotificationGroup: NotificationInfo {
     }
     
     @MainActor
-    func availableFollowAction() -> AvailableFollowAction? {
+    func availableRelationshipElement() -> RelationshipElement? {
         guard authorsCount == 1 && type == .follow else { return .noneNeeded }
         guard let firstAccountID = sampleAccountIDs.first else { return .noneNeeded }
-        if let relationship = MastodonFeedItemCacheManager.shared.currentRelationship(toAccount: firstAccountID), let text = relationship.followButtonText {
-            return .action(buttonText: text)
+        if let relationship = MastodonFeedItemCacheManager.shared.currentRelationship(toAccount: firstAccountID) {
+            return relationship.relationshipElement
         }
         return nil
     }
     
     @MainActor
-    func fetchAvailableFollowAction() async -> AvailableFollowAction {
+    func fetchRelationshipElement() async -> RelationshipElement {
         do {
             try await fetchRelationship()
-            if let availableAction = availableFollowAction() {
-                return availableAction
+            if let available = availableRelationshipElement() {
+                return available
             } else {
                 return .noneNeeded
             }
@@ -364,24 +528,503 @@ extension Mastodon.Entity.NotificationGroup: NotificationInfo {
             await MastodonFeedItemCacheManager.shared.addToCache(relationship)
         }
     }
+    
+    var statusViewModel: MastodonSDK.Mastodon.Entity.Status.ViewModel? {
+        return nil
+    }
 }
 
 extension Mastodon.Entity.Relationship {
     @MainActor
-    var followButtonText: String? {
-        if following {
-            return L10n.Common.Controls.Friendship.following
-        } else {
+    var relationshipElement: RelationshipElement? {
+        switch (following, followedBy) {
+        case (true, true):
+            return .mutualLabel
+        case (true, false):
+            return .followingLabel
+        case (false, true):
             if let account: NotificationAuthor = MastodonFeedItemCacheManager.shared.fullAccount(id) ?? MastodonFeedItemCacheManager.shared.partialAccount(id),
                account.locked
             {
                 if requested {
-                    return L10n.Common.Controls.Friendship.pending
+                    return .pendingRequestLabel
                 } else {
-                    return L10n.Common.Controls.Friendship.request
+                    return .requestButton
+                }
+            }
+            return .followButton
+        case (false, false):
+            return nil
+        }
+    }
+}
+
+struct NotificationIconInfo {
+    let notificationType: Mastodon.Entity.NotificationType
+    let isGrouped: Bool
+}
+
+struct NotificationSourceAccounts {
+    let firstAccountID: String?
+    let avatarUrls: [URL]
+    let totalActorCount: Int
+    
+    init(firstAccountID: String?, avatarUrls: [URL], totalActorCount: Int) {
+        self.firstAccountID = firstAccountID
+        self.avatarUrls = avatarUrls.removingDuplicates()
+        self.totalActorCount = totalActorCount
+    }
+}
+
+struct _NotificationRowView: View {
+    @ObservedObject var viewModel: _NotificationViewModel
+    
+    var body: some View {
+        HStack {
+            if let iconInfo = viewModel.iconInfo {
+                // LEFT GUTTER WITH TOP-ALIGNED ICON
+                VStack {
+                    Spacer()
+                    NotificationIconView(iconInfo)
+                    Spacer().frame(maxHeight: .infinity)
+                }
+            }
+            
+            // VSTACK OF CONTENT COMPONENT VIEWS
+            VStack() {
+                ForEach(viewModel.contentComponents) {
+                    componentView($0)
+                }
+            }
+        }
+    }
+    
+    @ViewBuilder
+    func componentView(_ component: NotificationViewComponent) -> some View {
+        switch component {
+        case .avatarRow(let accountInfo, let addition):
+            avatarRow(accountInfo: accountInfo, trailingElement: addition)
+        case .text(let string):
+            Text(string)
+                .frame(maxWidth: .infinity, alignment: .leading)
+        case .status(let viewModel):
+            InlinePostPreview(viewModel: viewModel)
+        case .hyperlinkButton(let label, let url):
+            Button(label) {
+                // TODO: open url
+            }
+            .bold()
+            .tint(Color(asset: Asset.Colors.accent))
+        case ._other(let string):
+            Text(string)
+        }
+    }
+    
+    @ScaledMetric private var smallAvatarSize: CGFloat = 32
+    private let avatarShape = RoundedRectangle(cornerRadius: 8)
+    private let maxAvatars = 8
+    @ViewBuilder
+    func avatarRow(accountInfo: NotificationSourceAccounts, trailingElement: RelationshipElement) -> some View {
+        let needsMoreLabel = accountInfo.totalActorCount > max(maxAvatars, accountInfo.avatarUrls.count)
+        HStack(alignment: .center) {
+            ForEach(accountInfo.avatarUrls.prefix(maxAvatars), id: \.self) {
+                AsyncImage(
+                    url: $0,
+                    content: { image in
+                        image.resizable()
+                            .aspectRatio(contentMode: .fit)
+                            .clipShape(avatarShape)
+                    },
+                    placeholder: {
+                        avatarShape
+                            .foregroundStyle(Color(UIColor.secondarySystemFill))
+                    }
+                )
+                .frame(width: smallAvatarSize, height: smallAvatarSize)
+            }
+            if needsMoreLabel {
+                Text("+ more")
+            }
+            Spacer().frame(minWidth: 0, maxWidth: .infinity)
+            avatarRowTrailingElement(trailingElement, grouped: accountInfo.totalActorCount > 1)
+        }
+    }
+    
+    @ViewBuilder
+    func avatarRowTrailingElement(_ elementType: RelationshipElement, grouped: Bool) -> some View {
+        switch (elementType, grouped) {
+        case (.fetching, false):
+            ProgressView().progressViewStyle(.circular)
+        case (.followButton, false):
+            Button(L10n.Common.Controls.Friendship.follow) {
+                viewModel.doAvatarRowButtonAction()
+            }
+            .buttonStyle(.borderedProminent)
+            .controlSize(.small)
+            .bold()
+        case (.requestButton, false):
+            Button(L10n.Common.Controls.Friendship.request) {
+                viewModel.doAvatarRowButtonAction()
+            }
+            .buttonStyle(.borderedProminent)
+            .controlSize(.small)
+            .bold()
+        case (.acceptRejectButtons(let isFollowing), false):
+            HStack {
+                
+                if isFollowing {
+                    Text(L10n.Common.Controls.Friendship.following)
+                }
+                
+                Button(L10n.Scene.Notification.FollowRequest.reject) {
+                    viewModel.doAvatarRowButtonAction(false)
+                }
+                .buttonStyle(.borderedProminent)
+                .controlSize(.small)
+                .bold()
+                
+                Button(L10n.Scene.Notification.FollowRequest.accept) {
+                    viewModel.doAvatarRowButtonAction(true)
+                }
+                .buttonStyle(.borderedProminent)
+                .controlSize(.small)
+                .bold()
+            }
+        case (.acceptedLabel, false):
+            Text(L10n.Scene.Notification.FollowRequest.accepted)
+        case (.rejectedLabel, false):
+            Text(L10n.Scene.Notification.FollowRequest.rejected)
+        case (.mutualLabel, false):
+            Text(L10n.Common.Controls.Friendship.mutual)
+        case (.followingLabel, false):
+            Text(L10n.Common.Controls.Friendship.following)
+        case (.pendingRequestLabel, false):
+            Text(L10n.Common.Controls.Friendship.pending)
+        case (.error(_), _):
+            Image(systemName: "exclamationmark.triangle").foregroundStyle(.gray)
+        default:
+            Spacer().frame(width: 0)
+        }
+    }
+}
+
+enum NotificationViewComponent: Identifiable {
+    case avatarRow(NotificationSourceAccounts, RelationshipElement)
+    case text(AttributedString)
+    case status(Mastodon.Entity.Status.ViewModel)
+    case hyperlinkButton(String, URL?)
+    case _other(String)
+    
+    var id: String {
+        switch self {
+        case .avatarRow:
+            return "avatar_row"
+        case .text(let string):
+            return string.description
+        case .status:
+            return "status"
+        case .hyperlinkButton(let text, _):
+            return text
+        case ._other(let string):
+            return string
+        }
+    }
+}
+
+class _NotificationViewModel: ObservableObject {
+    let identifier: MastodonFeedItemIdentifier
+    let type: Mastodon.Entity.NotificationType
+    let presentError: (Error) -> ()
+    public let iconInfo: NotificationIconInfo?
+    @Published public var contentComponents: [NotificationViewComponent] = []
+    
+    private(set) var avatarRow: NotificationViewComponent? {
+        didSet {
+            resetContentComponents()
+        }
+    }
+    private(set) var additionalComponents: [NotificationViewComponent] = [] {
+        didSet {
+            resetContentComponents()
+        }
+    }
+    
+    private func resetContentComponents() {
+        contentComponents = ([avatarRow] + additionalComponents).compactMap { $0 }
+    }
+    
+    init(_ notificationInfo: NotificationInfo, presentError: @escaping (Error)->()) {
+        
+        self.identifier = .notificationGroup(id: notificationInfo.id)
+        self.type = notificationInfo.type
+        self.iconInfo = NotificationIconInfo(notificationType: notificationInfo.type, isGrouped: notificationInfo.isGrouped)
+        self.presentError = presentError
+        
+        switch notificationInfo.type {
+            
+        case .follow, .followRequest:
+            let avatarRowAdditionalElement: RelationshipElement
+            let accountID: String?
+            if let account = notificationInfo.primaryAuthorAccount {
+                accountID = account.id
+                avatarRowAdditionalElement = .unfetched(notificationInfo.type, accountID: account.id)
+            } else {
+                accountID = nil
+                avatarRowAdditionalElement = .error(nil)
+            }
+            avatarRow = .avatarRow(NotificationSourceAccounts(firstAccountID: accountID, avatarUrls: notificationInfo.authorAvatarUrls, totalActorCount: notificationInfo.authorsCount), avatarRowAdditionalElement)
+            if let accountName = notificationInfo.primaryAuthorAccount?.displayNameWithFallback {
+                additionalComponents = [.text(notificationInfo.type.actionSummaryLabel(firstAuthor: .other(named: accountName), totalAuthorCount: notificationInfo.authorsCount))]
+            }
+        case .mention, .status:
+            // TODO: eventually make this full status style, not inline
+            // TODO: distinguish mentions from replies
+            if let primaryAuthorAccount = notificationInfo.primaryAuthorAccount, let statusViewModel = notificationInfo.statusViewModel {
+                avatarRow = .avatarRow(NotificationSourceAccounts(firstAccountID: primaryAuthorAccount.id, avatarUrls: notificationInfo.authorAvatarUrls, totalActorCount: notificationInfo.authorsCount), .noneNeeded)
+                additionalComponents = [
+                    .text(notificationInfo.type.actionSummaryLabel(firstAuthor: .other(named: primaryAuthorAccount.displayNameWithFallback), totalAuthorCount: notificationInfo.authorsCount)),
+                    .status(statusViewModel)
+                ]
+            } else {
+                additionalComponents = [._other("POST BY UNKNOWN ACCOUNT")]
+            }
+        case .reblog, .favourite:
+            if let primaryAuthorAccount = notificationInfo.primaryAuthorAccount, let statusViewModel = notificationInfo.statusViewModel {
+                avatarRow = .avatarRow(NotificationSourceAccounts(firstAccountID: primaryAuthorAccount.id, avatarUrls: notificationInfo.authorAvatarUrls, totalActorCount: notificationInfo.authorsCount), .noneNeeded)
+                additionalComponents = [
+                    .text(notificationInfo.type.actionSummaryLabel(firstAuthor: .other(named: primaryAuthorAccount.displayNameWithFallback), totalAuthorCount: notificationInfo.authorsCount)),
+                    .status(statusViewModel)
+                ]
+            } else {
+                additionalComponents = [._other("REBLOGGED/FAVOURITED BY UNKNOWN ACCOUNT")]
+            }
+        case .poll, .update:
+            if let author = notificationInfo.authorName, let statusViewModel = notificationInfo.statusViewModel {
+                additionalComponents = [
+                    .text(notificationInfo.type.actionSummaryLabel(firstAuthor: author, totalAuthorCount: notificationInfo.authorsCount)),
+                    .status(statusViewModel)
+                ]
+            } else {
+                additionalComponents = [._other("POLL/UPDATE FROM UNKNOWN ACCOUNT")]
+            }
+        case .adminSignUp:
+            if let primaryAuthorAccount = notificationInfo.primaryAuthorAccount, let authorName = notificationInfo.authorName {
+                avatarRow = .avatarRow(NotificationSourceAccounts(firstAccountID: primaryAuthorAccount.id, avatarUrls: notificationInfo.authorAvatarUrls, totalActorCount: notificationInfo.authorsCount), .noneNeeded)
+                additionalComponents = [.text(notificationInfo.type.actionSummaryLabel(firstAuthor: authorName, totalAuthorCount: notificationInfo.authorsCount))]
+            } else {
+                additionalComponents = [._other("ADMIN_SIGNUP NOTIFICATION")]
+            }
+        case .adminReport:
+            var components = [NotificationViewComponent?]()
+            if let summary = notificationInfo.ruleViolationReport?.summary {
+                components.append(.text(summary))
+            }
+            if let comment = notificationInfo.ruleViolationReport?.displayableComment {
+                components.append(.text(comment))
+            }
+            additionalComponents = components.compactMap { $0 }
+        case .severedRelationships:
+            var components = [NotificationViewComponent?]()
+            if let summary = notificationInfo.relationshipSeveranceEvent?.summary {
+                components.append(.text(summary))
+            } else {
+                components.append(._other("An admin action removed some of your followers or accounts that you followed."))
+            }
+            components.append(.hyperlinkButton("Learn more about server blocks", nil)) // TODO: localization and go somewhere
+            additionalComponents = components.compactMap { $0 }
+        case .moderationWarning:
+            additionalComponents = [
+                .text(AttributedString("Your account has received a moderation warning.")), // TODO: localization
+                .hyperlinkButton("Learn more", nil) // TODO: localization and go somewhere
+            ]
+        case ._other(let text):
+            additionalComponents = [._other("UNEXPECTED NOTIFICATION TYPE: \(text)")]
+        }
+        resetContentComponents()
+    }
+    
+    public func prepareForDisplay() {
+        if let avatarRow {
+            switch avatarRow {
+            case .avatarRow(let sourceAccounts, let additionalElement):
+                switch additionalElement {
+                case .unfetched:
+                    fetchRelationshipElement(sourceAccounts: sourceAccounts)
+                default:
+                    break
+                }
+            case .text, .status, .hyperlinkButton, ._other:
+                break
+            }
+        }
+        
+    }
+    
+    private func fetchRelationshipElement(sourceAccounts: NotificationSourceAccounts) {
+        switch type {
+        case .follow, .followRequest:
+            guard let accountID = sourceAccounts.firstAccountID else { return }
+            avatarRow = .avatarRow(sourceAccounts, .fetching)
+            
+            Task { @MainActor in
+                let element: RelationshipElement
+                do {
+                    if let relationship = try await fetchRelationship(to: accountID) {
+                        
+                        switch (type, relationship.following) {
+                        case (.follow, true):
+                            element = .mutualLabel
+                        case (.follow, false):
+                            element = .followButton
+                        case (.followRequest, _):
+                            element = .acceptRejectButtons(isFollowing: relationship.following)
+                        default:
+                            element = .noneNeeded
+                        }
+                    } else {
+                        element = .noneNeeded
+                    }
+                } catch {
+                    element = .error(error)
+                }
+                
+                avatarRow = .avatarRow(sourceAccounts, element)
+            }
+        default:
+            avatarRow = .avatarRow(sourceAccounts, .noneNeeded)
+        }
+    }
+    
+    private func fetchRelationship(to accountID: String) async throws -> Mastodon.Entity.Relationship? {
+        guard let authBox = await AuthenticationServiceProvider.shared.currentActiveUser.value else { return nil }
+        if let relationship = try await APIService.shared.relationship(forAccountIds: [accountID], authenticationBox: authBox).value.first {
+            return relationship
+        } else {
+            return nil
+        }
+    }
+}
+
+extension _NotificationViewModel: Equatable {
+    public static func ==(lhs: _NotificationViewModel, rhs: _NotificationViewModel) -> Bool {
+        return lhs.identifier == rhs.identifier
+    }
+}
+    
+extension _NotificationViewModel {
+    
+    public func doAvatarRowButtonAction(_ accept: Bool = true) {
+        guard let avatarRow else { return }
+        FeedbackGenerator.shared.generate(.selectionChanged)
+        Task {
+            switch avatarRow {
+            case .avatarRow(let accountInfo, let relationshipElement):
+                switch relationshipElement {
+                case .followButton, .requestButton:
+                    await doFollow(accountInfo)
+                case .acceptRejectButtons:
+                    await doAcceptFollowRequest(accountInfo, accept: accept)
+                default:
+                    return
+                }
+            default:
+                return
+            }
+        }
+    }
+    
+    @MainActor
+    private func doFollow(_ accountInfo: NotificationSourceAccounts) async {
+        guard let accountID = accountInfo.firstAccountID, let authBox = AuthenticationServiceProvider.shared.currentActiveUser.value else { return }
+        let startingAvatarRow = avatarRow
+        avatarRow = .avatarRow(accountInfo, .fetching)
+        do {
+            let updatedElement: RelationshipElement
+            let response = try await APIService.shared.follow(accountID, authenticationBox: authBox)
+            if response.following {
+                updatedElement = .followingLabel
+            } else if response.requested {
+                updatedElement = .pendingRequestLabel
+            } else {
+                updatedElement = .error(nil)
+            }
+            avatarRow = .avatarRow(accountInfo, updatedElement)
+        } catch {
+            presentError(error)
+            avatarRow = startingAvatarRow
+        }
+    }
+    
+    @MainActor
+    private func doAcceptFollowRequest(_ accountInfo: NotificationSourceAccounts, accept: Bool) async {
+        guard let accountID = accountInfo.firstAccountID, let authBox = AuthenticationServiceProvider.shared.currentActiveUser.value else { return }
+        let startingAvatarRow = avatarRow
+        avatarRow = .avatarRow(accountInfo, .fetching)
+        do {
+            let expectedFollowedByResult = accept
+            let newRelationship = try await APIService.shared.followRequest(
+                userID: accountID,
+                query: accept ? .accept : .reject,
+                authenticationBox: authBox
+            ).value
+            guard newRelationship.followedBy == expectedFollowedByResult else {
+                self.avatarRow = .avatarRow(accountInfo, .error(nil))
+                return
+            }
+            self.avatarRow = .avatarRow(accountInfo, accept ? .acceptedLabel : .rejectedLabel)
+        } catch {
+            presentError(error)
+            self.avatarRow = startingAvatarRow
+        }
+    }
+}
+
+extension _NotificationViewModel {
+    static func viewModelsFromGroupedNotificationResults(_ results: Mastodon.Entity.GroupedNotificationsResults, myAccountID: String, presentError: @escaping (Error)->()) -> [_NotificationViewModel] {
+        let fullAccounts = results.accounts.reduce(into: [String : Mastodon.Entity.Account]()) { partialResult, account in
+            partialResult[account.id] = account
+        }
+        let partialAccounts = results.partialAccounts? .reduce(into: [String : Mastodon.Entity.PartialAccountWithAvatar]()) { partialResult, account in
+            partialResult[account.id] = account
+        }
+        
+        let statuses = results.statuses.reduce(into: [String: Mastodon.Entity.Status](), { partialResult, status in
+            partialResult[status.id] = status
+        })
+        
+        return results.notificationGroups.map { group in
+            var primaryAccount: Mastodon.Entity.Account? = nil
+            for accountID in group.sampleAccountIDs {
+                if let fullAccount = fullAccounts[accountID] {
+                    primaryAccount = fullAccount
+                    break
                 }
             }
-            return L10n.Common.Controls.Friendship.follow
+            
+            let avatarUrls = group.sampleAccountIDs.compactMap { accountID in
+                return fullAccounts[accountID]?.avatarURL ?? partialAccounts?[accountID]?.avatarURL
+            }
+            
+            let authorName: Mastodon.Entity.NotificationType.AuthorName?
+            if primaryAccount?.id == myAccountID {
+                authorName = .me
+            } else if let name = primaryAccount?.displayNameWithFallback {
+                authorName = .other(named: name)
+            } else {
+                authorName = nil
+            }
+            
+            let status = group.statusID == nil ? nil : statuses[group.statusID!]
+            
+            let info = GroupedNotificationInfo(id: group.id, type: group.type, authorsCount: group.authorsCount, notificationsCount: group.notificationsCount, primaryAuthorAccount: primaryAccount, authorName: authorName, authorAvatarUrls: avatarUrls, statusViewModel: status?.viewModel(), ruleViolationReport: group.ruleViolationReport, relationshipSeveranceEvent: group.relationshipSeveranceEvent)
+            
+            return _NotificationViewModel(info, presentError: presentError)
         }
     }
 }
+
+func boldedNameStringComponent(_ name: String) -> AttributedString {
+    let nameComponent = PersonNameComponents(givenName: name).formatted(.name(style: .long).attributed)
+    return nameComponent
+}
+
diff --git a/Mastodon/In Progress New Layout and Datamodel/NotificationRowViewModel.swift b/Mastodon/In Progress New Layout and Datamodel/NotificationRowViewModel.swift
index c8fb8d101a..1c4f891344 100644
--- a/Mastodon/In Progress New Layout and Datamodel/NotificationRowViewModel.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/NotificationRowViewModel.swift	
@@ -14,13 +14,13 @@ class NotificationRowViewModel: ObservableObject {
     let grouped: Bool
     let authorAvatarUrls: [URL]
     let authorsDescription: String
-    let authorName: String
+    let authorName: Mastodon.Entity.NotificationType.AuthorName?
     
     static func viewModel(feedItemIdentifier: MastodonFeedItemIdentifier, isUnread: Bool) -> NotificationRowViewModel {
         guard let notificationInfo = MastodonFeedItemCacheManager.shared.cachedItem(feedItemIdentifier) as? NotificationInfo else { return MissingNotificationViewModel(nil, feedItemIdentifier: feedItemIdentifier, isUnread: false) }
         switch notificationInfo.type {
-        case .follow:
-            return FollowNotificationViewModel(notificationInfo, feedItemIdentifier: feedItemIdentifier, isUnread: isUnread)
+//        case .follow:
+//            return FollowNotificationViewModel(notificationInfo, feedItemIdentifier: feedItemIdentifier, isUnread: isUnread)
         case .status, .reblog, .mention, .favourite:
             return StatusNotificationViewModel(notificationInfo, feedItemIdentifier: feedItemIdentifier, isUnread: isUnread)
         default:
@@ -36,7 +36,7 @@ class NotificationRowViewModel: ObservableObject {
         self.isUnread = isUnread
         let item = MastodonFeedItemCacheManager.shared.cachedItem(feedItemIdentifier) as? NotificationInfo
         grouped = item?.isGrouped ?? false
-        authorName = item?.authorName ?? ""
+        authorName = item?.authorName
         authorsDescription = item?.authorsDescription ?? ""
         authorAvatarUrls = item?.authorAvatarUrls ?? []
     }
@@ -45,34 +45,34 @@ class NotificationRowViewModel: ObservableObject {
 class MissingNotificationViewModel: NotificationRowViewModel {
 }
 
-class FollowNotificationViewModel: NotificationRowViewModel {
-    @Published var followButtonAction: AvailableFollowAction = .unfetched
-    
-    init(_ notification: NotificationInfo, feedItemIdentifier: MastodonFeedItemIdentifier, isUnread: Bool) {
-        assert(notification.type == .follow)
-        super.init(notification, feedItemIdentifier: feedItemIdentifier, isUnread: isUnread)
-        if notification.type == .follow && !notification.isGrouped {
-            followButtonAction = .fetching
-            print("about to fetch for \(notification.authorName)")
-            updateAvailableFollowAction()
-        } else {
-            followButtonAction = .noneNeeded
-        }
-    }
-    
-    private func updateAvailableFollowAction() {
-        Task {
-            guard let notificationInfo else { followButtonAction = .noneNeeded; return }
-            if let followAction = await notificationInfo.availableFollowAction() {
-                print("had cached answer for \(notificationInfo.authorName)")
-                followButtonAction = followAction
-            } else {
-                print("fetching relationship to derive answer for \(notificationInfo.authorName)")
-                followButtonAction = await notificationInfo.fetchAvailableFollowAction()
-            }
-        }
-    }
-}
+//class FollowNotificationViewModel: NotificationRowViewModel {
+//    @Published var followButtonAction: RelationshipElement = .unfetched(<#Mastodon.Entity.NotificationType#>, accountID: <#String#>)
+//
+//    init(_ notification: NotificationInfo, feedItemIdentifier: MastodonFeedItemIdentifier, isUnread: Bool) {
+//        assert(notification.type == .follow)
+//        super.init(notification, feedItemIdentifier: feedItemIdentifier, isUnread: isUnread)
+//        if notification.type == .follow && !notification.isGrouped {
+//            followButtonAction = .fetching
+//            print("about to fetch for \(notification.authorName)")
+//            updateAvailableFollowAction()
+//        } else {
+//            followButtonAction = .noneNeeded
+//        }
+//    }
+//    
+//    private func updateAvailableFollowAction() {
+//        Task {
+//            guard let notificationInfo else { followButtonAction = .noneNeeded; return }
+//            if let followAction = await notificationInfo.availableFollowAction() {
+//                print("had cached answer for \(notificationInfo.authorName)")
+//                followButtonAction = followAction
+//            } else {
+//                print("fetching relationship to derive answer for \(notificationInfo.authorName)")
+//                followButtonAction = await notificationInfo.fetchAvailableFollowAction()
+//            }
+//        }
+//    }
+//}
 
 class StatusNotificationViewModel: NotificationRowViewModel {
     let postedContent: Mastodon.Entity.Status? // TODO: make this non-optional eventually
diff --git a/Mastodon/In Progress New Layout and Datamodel/TimelinePostCell/TimelinePostCell.swift b/Mastodon/In Progress New Layout and Datamodel/TimelinePostCell/TimelinePostCell.swift
index 6d40289347..335648f9b6 100644
--- a/Mastodon/In Progress New Layout and Datamodel/TimelinePostCell/TimelinePostCell.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/TimelinePostCell/TimelinePostCell.swift	
@@ -25,7 +25,7 @@ class TimelinePostViewModel {
         self.includePadding = includePadding
         self.feedItemIdentifier = feedItemIdentifier
         if let notification = MastodonFeedItemCacheManager.shared.cachedItem(feedItemIdentifier) as? NotificationInfo {
-            boostingAccountName = notification.type == .reblog ? notification.authorName : nil
+            boostingAccountName = notification.type == .reblog ? notification.authorName?.string : nil
         } else {
             boostingAccountName = nil
         }
diff --git a/Mastodon/Scene/Notification/NotificationListItem.swift b/Mastodon/Scene/Notification/NotificationListItem.swift
index 9d32639982..4d8cc513d3 100644
--- a/Mastodon/Scene/Notification/NotificationListItem.swift
+++ b/Mastodon/Scene/Notification/NotificationListItem.swift
@@ -11,7 +11,8 @@ import MastodonSDK
 
 enum NotificationListItem: Hashable {
     case filteredNotificationsInfo(policy: Mastodon.Entity.NotificationPolicy)
-    case notification(MastodonFeedItemIdentifier)
+    case notification(MastodonFeedItemIdentifier) // TODO: remove
+    case groupedNotification(_NotificationViewModel)
     case bottomLoader
     
     var fetchAnchor: MastodonFeedItemIdentifier? {
@@ -20,6 +21,8 @@ enum NotificationListItem: Hashable {
             return nil
         case .notification(let identifier):
             return identifier
+        case .groupedNotification(let viewModel):
+            return viewModel.identifier
         case .bottomLoader:
             return nil
         }
@@ -35,6 +38,8 @@ extension NotificationListItem: Identifiable {
             return "filtered_notifications_info"
         case .notification(let identifier):
             return identifier.id
+        case .groupedNotification(let viewModel):
+            return viewModel.identifier.id
         case .bottomLoader:
             return "bottom_loader"
         }
diff --git a/Mastodon/Scene/Notification/NotificationSection.swift b/Mastodon/Scene/Notification/NotificationSection.swift
index 61d211a8ed..3b835090bd 100644
--- a/Mastodon/Scene/Notification/NotificationSection.swift
+++ b/Mastodon/Scene/Notification/NotificationSection.swift
@@ -57,6 +57,9 @@ extension NotificationSection {
                     )
                     return cell
                 }
+            case .groupedNotification:
+                assertionFailure("grouped notifications cannot be displayed in the legacy notification screen")
+                return nil
             case .bottomLoader:
                 let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: TimelineBottomLoaderTableViewCell.self), for: indexPath) as! TimelineBottomLoaderTableViewCell
                 cell.activityIndicatorView.startAnimating()
diff --git a/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewController+DataSourceProvider.swift b/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewController+DataSourceProvider.swift
index fada3f022d..9791158906 100644
--- a/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewController+DataSourceProvider.swift
+++ b/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewController+DataSourceProvider.swift
@@ -56,6 +56,9 @@ extension NotificationTimelineViewController: DataSourceProvider {
                 assertionFailure("unexpected item in notifications feed")
                 return nil
             }
+        case .groupedNotification:
+            assertionFailure("grouped notifications are not supported in the legacy NotificationTimelineViewController")
+            return nil
         case .filteredNotificationsInfo(let policy):
             return DataSourceItem.notificationBanner(policy: policy)
         case .bottomLoader:
diff --git a/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewModel.swift b/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewModel.swift
index 0ea2065f8e..0b6d7573a8 100644
--- a/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewModel.swift
+++ b/Mastodon/Scene/Notification/NotificationTimeline/NotificationTimelineViewModel.swift
@@ -143,6 +143,8 @@ extension NotificationTimelineViewModel {
                 return diffableDataSource?.snapshot().itemIdentifiers.last(where: { $0.fetchAnchor != nil })?.fetchAnchor
             case .filteredNotificationsInfo:
                 return  diffableDataSource?.snapshot().itemIdentifiers.first(where: { $0.fetchAnchor != nil })?.fetchAnchor
+            case .groupedNotification(let viewModel):
+                return viewModel.identifier
             case .none:
                 return nil
             }
diff --git a/MastodonSDK/Sources/MastodonCore/DataController/MastodonFeedLoader.swift b/MastodonSDK/Sources/MastodonCore/DataController/MastodonFeedLoader.swift
index 277ac85eb0..3a100e81a6 100644
--- a/MastodonSDK/Sources/MastodonCore/DataController/MastodonFeedLoader.swift
+++ b/MastodonSDK/Sources/MastodonCore/DataController/MastodonFeedLoader.swift
@@ -322,6 +322,17 @@ private extension MastodonFeedLoader {
             return MastodonFeedItemIdentifier.notificationGroup(id: $0.id)
         }
     }
+    
+    private func _getGroupedNotificationResults(withScope scope: APIService.MastodonNotificationScope? = nil, accountID: String? = nil, olderThan maxID: String? = nil) async throws -> Mastodon.Entity.GroupedNotificationsResults {
+        
+        assert(scope != nil || accountID != nil, "need a scope or an accountID")
+        
+        guard let authenticationBox = AuthenticationServiceProvider.shared.currentActiveUser.value else { throw APIService.APIError.implicit(.authenticationMissing) }
+        
+        let results = try await APIService.shared.groupedNotifications(olderThan: maxID, fromAccount: accountID, scope: scope, authenticationBox: authenticationBox).value
+        
+        return results
+    }
 }
 
 extension MastodonFeedKind {
diff --git a/MastodonSDK/Sources/MastodonCore/Service/API/APIService+Follow.swift b/MastodonSDK/Sources/MastodonCore/Service/API/APIService+Follow.swift
index cae26cf3f4..2bf6bd1eb3 100644
--- a/MastodonSDK/Sources/MastodonCore/Service/API/APIService+Follow.swift
+++ b/MastodonSDK/Sources/MastodonCore/Service/API/APIService+Follow.swift
@@ -60,6 +60,16 @@ extension APIService {
 
         return response
     }
+    
+    public func follow(_ accountID: String, authenticationBox: MastodonAuthenticationBox) async throws -> Mastodon.Entity.Relationship {
+        return try await Mastodon.API.Account.follow(
+            session: session,
+            domain: authenticationBox.domain,
+            accountID: accountID,
+            followQueryType: .follow(query: .init()),
+            authorization: authenticationBox.userAuthorization
+        ).singleOutput().value
+    }
 
     public func toggleShowReblogs(
       for user: Mastodon.Entity.Account,
diff --git a/MastodonSDK/Sources/MastodonLocalization/Generated/Strings.swift b/MastodonSDK/Sources/MastodonLocalization/Generated/Strings.swift
index 02eb6c4627..4fd565ef6f 100644
--- a/MastodonSDK/Sources/MastodonLocalization/Generated/Strings.swift
+++ b/MastodonSDK/Sources/MastodonLocalization/Generated/Strings.swift
@@ -269,6 +269,8 @@ public enum L10n {
         public static func muteUser(_ p1: Any) -> String {
           return L10n.tr("Localizable", "Common.Controls.Friendship.MuteUser", String(describing: p1), fallback: "Mute %@")
         }
+        /// Mutual
+        public static let mutual = L10n.tr("Localizable", "Common.Controls.Friendship.Mutual", fallback: "Mutual")
         /// Pending
         public static let pending = L10n.tr("Localizable", "Common.Controls.Friendship.Pending", fallback: "Pending")
         /// Request
diff --git a/MastodonSDK/Sources/MastodonLocalization/Resources/Base.lproj/Localizable.strings b/MastodonSDK/Sources/MastodonLocalization/Resources/Base.lproj/Localizable.strings
index 540946e6be..0cad1e22f3 100644
--- a/MastodonSDK/Sources/MastodonLocalization/Resources/Base.lproj/Localizable.strings
+++ b/MastodonSDK/Sources/MastodonLocalization/Resources/Base.lproj/Localizable.strings
@@ -90,6 +90,7 @@ Please check your internet connection.";
 "Common.Controls.Friendship.EditInfo" = "Edit Info";
 "Common.Controls.Friendship.Follow" = "Follow";
 "Common.Controls.Friendship.Following" = "Following";
+"Common.Controls.Friendship.Mutual" = "Mutual";
 "Common.Controls.Friendship.HideReblogs" = "Hide Boosts";
 "Common.Controls.Friendship.Mute" = "Mute";
 "Common.Controls.Friendship.MuteUser" = "Mute %@";
diff --git a/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Notification.swift b/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Notification.swift
index 631fefcab9..37aa2ed214 100644
--- a/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Notification.swift
+++ b/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Notification.swift
@@ -25,7 +25,7 @@ extension Mastodon.Entity {
         public let groupKey: String?
         public let account: Account
         public let status: Status?
-        public let report: Report?
+        public let ruleViolationReport: Report?
         public let relationshipSeveranceEvent: RelationshipSeveranceEvent?
         public let accountWarning: AccountWarning?
 
@@ -36,7 +36,7 @@ extension Mastodon.Entity {
             case createdAt = "created_at"
             case account
             case status
-            case report
+            case ruleViolationReport = "report"
             case accountWarning = "moderation_warning"
             case relationshipSeveranceEvent = "event"
         }
@@ -62,7 +62,7 @@ extension Mastodon.Entity {
         public let latestPageNotificationAt: Date? // Date at which the most recent notification from this group within the current page has been created. This is only returned when paginating through notification groups.
         public let sampleAccountIDs: [String] // IDs of some of the accounts who most recently triggered notifications in this group.
         public let statusID: ID?
-        public let report: Report? // Attached when type of the notification is admin.report
+        public let ruleViolationReport: Report? // Attached when type of the notification is admin.report
         public let relationshipSeveranceEvent: RelationshipSeveranceEvent? // Attached when type of the notification is severed_relationships
         public let accountWarning: AccountWarning?
         
@@ -76,7 +76,7 @@ extension Mastodon.Entity {
             case latestPageNotificationAt = "latest_page_notification_at"
             case sampleAccountIDs = "sample_account_ids"
             case statusID = "status_id"
-            case report = "report"
+            case ruleViolationReport = "report"
             case accountWarning = "moderation_warning"
             case relationshipSeveranceEvent = "event"
         }
diff --git a/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Report.swift b/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Report.swift
index a6e817bbe1..c9f0b1d352 100644
--- a/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Report.swift
+++ b/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+Report.swift
@@ -11,9 +11,9 @@ extension Mastodon.Entity {
     /// Report
     ///
     /// - Since: ?
-    /// - Version: 3.3.0
+    /// - Version: 4.0
     /// # Last Update
-    ///   2021/1/29
+    ///   2025/02/03
     /// # Reference
     ///  [Document](https://docs.joinmastodon.org/entities/report/)
     public struct Report: Codable, Sendable {
@@ -21,10 +21,16 @@ extension Mastodon.Entity {
         
         public let id: ID                   //  undocumented
         public let actionTaken: Bool?       //  undocumented
+        public let targetAccount: Account?   // The account that was reported.
+        public let flaggedStatusIDs: [String]? // IDs of statuses that have been attached to this report for additional context.
+        public let comment: String? // The reason for the report.
         
         enum CodingKeys: String, CodingKey {
             case id
             case actionTaken = "action_taken"
+            case targetAccount = "target_account"
+            case flaggedStatusIDs = "status_ids"
+            case comment
         }
     }
 }
diff --git a/MastodonSDK/Sources/MastodonSDK/MastodonFeed.swift b/MastodonSDK/Sources/MastodonSDK/MastodonFeed.swift
index 3034bd911c..048d840f3d 100644
--- a/MastodonSDK/Sources/MastodonSDK/MastodonFeed.swift
+++ b/MastodonSDK/Sources/MastodonSDK/MastodonFeed.swift
@@ -147,13 +147,11 @@ public extension Mastodon.Entity.Status {
         }
     }
     
-    @MainActor
     func viewModel() -> ViewModel {
         let displayableContent = contentAsAttributedString(content)
         return ViewModel(content: displayableContent, isPinned: false, accountDisplayName: account.displayName, accountFullName: account.acctWithDomain)
     }
     
-    @MainActor
     private func contentAsAttributedString(_ htmlContent: String?) -> AttributedString {
         guard let htmlContent else { return AttributedString() }
         let data = Data(htmlContent.utf8)
