diff --git a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift
index 3c00825da9..8244fcef00 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Timeline/TimelineListViewController.swift	
@@ -84,17 +84,15 @@ class TimelineListViewController: UIHostingController<TimelineListView>
             setUpTimelineSelectorButton()
             setUpScrollToTop()
             showSettingsButton(true)
+        case .notifications(.everything), .notifications(.mentions):
+            fetchFilteredNotificationsPolicy()
+            setUpNotificationsNavBarControls()
+            NotificationCenter.default.addObserver(self, selector: #selector(notificationFilteringPolicyDidChange), name: .notificationFilteringChanged, object: nil)
         default:
             break
         }
     }
     
-    @objc private func settingBarButtonItemPressed(_ sender: UIBarButtonItem) {
-        guard let setting = SettingService.shared.currentSetting.value else { return }
-        
-        _ = self.sceneCoordinator?.present(scene: .settings(setting: setting), from: self, transition: .none)
-    }
-    
     required init?(coder aDecoder: NSCoder) {
         fatalError(
             "init(coder:) not implemented for HomeTimelineListViewController")
@@ -110,12 +108,40 @@ class TimelineListViewController: UIHostingController<TimelineListView>
         return barButtonItem
     }()
     
-    func setUpTimelineSelectorButton() {
-        self.navigationItem.leftBarButtonItem = UIBarButtonItem(customView: timelineSelectorButton)
-    }
+    lazy var picker = { UISegmentedControl(items: [ NotificationsScope.everything.pickerLabel, NotificationsScope.mentions.pickerLabel ]) }()
     
     var scrollToTopButton: UIButton?
     
+    lazy var timelineSelectorButton = {
+        let button = UIButton(type: .custom)
+        
+        button.setAttributedTitle(
+            .init(string: L10n.Scene.HomeTimeline.TimelineMenu.following, attributes: [
+                .font: UIFontMetrics(forTextStyle: .headline).scaledFont(for: .systemFont(ofSize: 20, weight: .semibold))
+            ]),
+            for: .normal)
+        
+        let imageConfiguration = UIImage.SymbolConfiguration(paletteColors: [.secondaryLabel, .secondarySystemFill])
+            .applying(UIImage.SymbolConfiguration(textStyle: .subheadline))
+            .applying(UIImage.SymbolConfiguration(pointSize: 16, weight: .bold, scale: .medium))
+        
+        button.configuration = {
+            var config = UIButton.Configuration.plain()
+            config.contentInsets = .init(top: 0, leading: 0, bottom: 0, trailing: 0)
+            config.imagePadding = 8
+            config.image = UIImage(systemName: "chevron.down.circle.fill", withConfiguration: imageConfiguration)
+            config.imagePlacement = .trailing
+            return config
+        }()
+        
+        button.showsMenuAsPrimaryAction = true
+        button.menu = generateTimelineSelectorMenu()
+        return button
+    }()
+}
+
+extension TimelineListViewController {
+    // MARK: HomeTimeline Nav Bar controls
     func setUpScrollToTop() {
         let button = UIButton(configuration: .plain())
         button.addTarget(self, action: #selector(scrollToTop), for: .touchUpInside)
@@ -140,6 +166,12 @@ class TimelineListViewController: UIHostingController<TimelineListView>
         viewModel.scrollToTop()
     }
     
+    @objc private func settingBarButtonItemPressed(_ sender: UIBarButtonItem) {
+        guard let setting = SettingService.shared.currentSetting.value else { return }
+        
+        _ = self.sceneCoordinator?.present(scene: .settings(setting: setting), from: self, transition: .none)
+    }
+    
     func showSettingsButton(_ show: Bool) {
         if show {
             self.navigationItem.rightBarButtonItem = settingBarButtonItem
@@ -148,32 +180,9 @@ class TimelineListViewController: UIHostingController<TimelineListView>
         }
     }
     
-    lazy var timelineSelectorButton = {
-        let button = UIButton(type: .custom)
-        
-        button.setAttributedTitle(
-            .init(string: L10n.Scene.HomeTimeline.TimelineMenu.following, attributes: [
-                .font: UIFontMetrics(forTextStyle: .headline).scaledFont(for: .systemFont(ofSize: 20, weight: .semibold))
-            ]),
-            for: .normal)
-        
-        let imageConfiguration = UIImage.SymbolConfiguration(paletteColors: [.secondaryLabel, .secondarySystemFill])
-            .applying(UIImage.SymbolConfiguration(textStyle: .subheadline))
-            .applying(UIImage.SymbolConfiguration(pointSize: 16, weight: .bold, scale: .medium))
-        
-        button.configuration = {
-            var config = UIButton.Configuration.plain()
-            config.contentInsets = .init(top: 0, leading: 0, bottom: 0, trailing: 0)
-            config.imagePadding = 8
-            config.image = UIImage(systemName: "chevron.down.circle.fill", withConfiguration: imageConfiguration)
-            config.imagePlacement = .trailing
-            return config
-        }()
-        
-        button.showsMenuAsPrimaryAction = true
-        button.menu = generateTimelineSelectorMenu()
-        return button
-    }()
+    func setUpTimelineSelectorButton() {
+        self.navigationItem.leftBarButtonItem = UIBarButtonItem(customView: timelineSelectorButton)
+    }
     
     private func generateTimelineSelectorMenu() -> UIMenu {
         let useLazyVStackAction: UIAction
@@ -332,6 +341,121 @@ class TimelineListViewController: UIHostingController<TimelineListView>
     }
 }
 
+extension NotificationsScope {
+    var pickerLabel: String {
+        switch self {
+        case .everything:
+            L10n.Scene.Notification.Title.everything
+        case .mentions:
+            L10n.Scene.Notification.Title.mentions
+        case .fromAccount:
+            ""
+        }
+    }
+}
+
+extension TimelineListViewController {
+    // MARK: Notifications Nav Bar controls
+    
+    func setUpNotificationsNavBarControls() {
+        navigationItem.rightBarButtonItem = UIBarButtonItem(image: UIImage(systemName: "line.3.horizontal.decrease.circle"), style: .plain, target: self, action: #selector(showNotificationPolicySettings))
+        
+        picker.translatesAutoresizingMaskIntoConstraints = false
+        picker.selectedSegmentIndex = 0
+        navigationItem.titleView = picker
+        NSLayoutConstraint.activate([
+            picker.widthAnchor.constraint(greaterThanOrEqualToConstant: 287)
+        ])
+        picker.addTarget(self, action: #selector(pickerValueChanged(_:)), for: .valueChanged)
+    }
+    
+    @objc private func pickerValueChanged(_ sender: UISegmentedControl) {
+        let newScope: NotificationsScope
+        switch sender.selectedSegmentIndex {
+        case 0:
+            newScope = .everything
+        case 1:
+            newScope = .mentions
+        default:
+            newScope = .everything
+        }
+        switch viewModel.timeline {
+        case .notifications(let scope):
+            if scope != newScope {
+                viewModel.resetToUntrackedAfterDelay()
+                viewModel.timeline = .notifications(scope: newScope)
+            }
+        default:
+            break
+        }
+    }
+    
+    @objc private func showNotificationPolicySettings(_ sender: Any) {
+        guard let policy = viewModel.filteredNotificationsViewModel.policy else { return }
+        Task {
+            let adminSettings: AdminNotificationFilterSettings? = await {
+                guard let user = AuthenticationServiceProvider.shared.currentActiveUser.value, let role = user.cachedAccount?.role else { print("no role"); return nil }
+                let permissions = role.rolePermissions()
+                let hasAdminPermissions = permissions.contains(.administrator) || permissions.contains(.manageReports) || permissions.contains(.manageUsers)
+                guard hasAdminPermissions else { print("no permissions"); return nil }
+                if let existingPreferences = await BodegaPersistence.Notifications.currentPreferences(for: user.authentication) {
+                    return existingPreferences
+                } else {
+                    return AdminNotificationFilterSettings(forReports: .accept, forSignups: .accept)
+                }
+            }()
+            
+            let policyViewModel = await NotificationPolicyViewModel(
+                NotificationFilterSettings(
+                    forNotFollowing: policy.forNotFollowing,
+                    forNotFollowers: policy.forNotFollowers,
+                    forNewAccounts: policy.forNewAccounts,
+                    forPrivateMentions: policy.forPrivateMentions,
+                    forLimitedAccounts: policy.forLimitedAccounts
+                ),
+                adminSettings: adminSettings
+            )
+            
+            guard let policyViewController = self.sceneCoordinator?.present(scene: .notificationPolicy(viewModel: policyViewModel), transition: .formSheet(policyViewModel.adminFilterSettings != nil ? [.large()] : nil)) as? NotificationPolicyViewController else { return }
+            
+            policyViewController.delegate = self
+        }
+    }
+}
+
+extension TimelineListViewController: NotificationPolicyViewControllerDelegate {
+    func policyUpdated(_ viewController: NotificationPolicyViewController, newPolicy: MastodonSDK.Mastodon.Entity.NotificationPolicy) {
+        updateFilteredNotificationsPolicy(newPolicy)
+    }
+    
+    @objc func notificationFilteringPolicyDidChange(_ notification: Notification) {
+        fetchFilteredNotificationsPolicy()
+    }
+
+    private func fetchFilteredNotificationsPolicy() {
+        guard
+            let authBox = AuthenticationServiceProvider.shared.currentActiveUser
+                .value
+        else { return }
+        Task {
+            let policy = try? await APIService.shared.notificationPolicy(
+                authenticationBox: authBox)
+            updateFilteredNotificationsPolicy(policy?.value)
+        }
+    }
+
+    func updateFilteredNotificationsPolicy(
+        _ policy: Mastodon.Entity.NotificationPolicy?
+    ) {
+
+        viewModel.filteredNotificationsViewModel.policy = policy
+        Task {
+            try await viewModel.doInitialLoad()
+        }
+    }
+
+}
+
 extension TimelineListViewController: MediaPreviewableViewController {
     var mediaPreviewTransitionController: MediaPreviewTransitionController {
         return _mediaPreviewTransitionController
@@ -419,6 +543,19 @@ private class TimelineListViewModel: ObservableObject {
     private var instanceConfiguration: MastodonAuthentication.InstanceConfiguration?
     var hostingViewController: MediaPreviewableViewController?
     
+    var filteredNotificationsViewModel =
+        FilteredNotificationsRowView.ViewModel(policy: nil)
+    private var notificationPolicyBannerRow: [NotificationListItem] {
+        if filteredNotificationsViewModel.shouldShow {
+            return [
+                NotificationListItem.filteredNotificationsInfo(
+                    nil, filteredNotificationsViewModel)
+            ]
+        } else {
+            return []
+        }
+    }
+    
     var activeAlert: MastodonPostMenuAction.AlertType = .noAlert {
         didSet {
             if !isPresentingAlert && activeAlert.shouldBePresented {
