diff --git a/Mastodon.xcodeproj/project.pbxproj b/Mastodon.xcodeproj/project.pbxproj
index 88acd549ac..7a13d7dad1 100644
--- a/Mastodon.xcodeproj/project.pbxproj
+++ b/Mastodon.xcodeproj/project.pbxproj
@@ -1278,6 +1278,7 @@
 				"Common Components/Common Actions on Statuses and Accounts/ContentConcealViewModel.swift",
 				"Common Components/Common Actions on Statuses and Accounts/MastodonPostMenuAction.swift",
 				"Common Components/Common Actions on Statuses and Accounts/PostActions.swift",
+				"Common Components/GeometryHelpers.swift",
 				"Common Components/HtmlHelpers.swift",
 				"Common Components/ProportionalImageGridLayout.swift",
 				"Common Components/Views/AuthorHeaderView.swift",
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift
new file mode 100644
index 0000000000..7765fc04e3
--- /dev/null
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/GeometryHelpers.swift	
@@ -0,0 +1,117 @@
+// Copyright Â© 2025 Mastodon gGmbH. All rights reserved.
+import SwiftUI
+
+struct ReferencePointReader: View {
+    static let referenceSpace = "ReferencePointReaderSpace"
+    let id: String
+    
+    let referencePoint: PositionReferencePoint
+    
+    enum PositionReferencePoint {
+        case trailingCenter
+        case leadingTop
+    }
+    
+    var body: some View {
+        GeometryReader { metrics in
+            let position =  {
+                switch referencePoint {
+                case .trailingCenter:
+                    CGPoint(
+                        x: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).maxX,
+                        y: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).midY
+                    )
+                case .leadingTop:
+                    CGPoint(
+                        x: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).minX,
+                        y: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).minY
+                    )
+                }
+               
+            }()
+            
+            Rectangle()
+                .fill(Color.clear)
+                .preference(
+                    key: PositionKey.self,
+                    value: [PositionValue(id: id, referencePosition: position)]
+                )
+        }
+    }
+}
+
+struct PositionValue: Equatable {
+    typealias ID = String
+    let id: ID
+    let referencePosition: CGPoint
+}
+
+struct PositionKey: PreferenceKey {
+    static var defaultValue: [PositionValue] = []
+    static func reduce(value: inout [PositionValue], nextValue: () -> [PositionValue]) {
+        value.append(contentsOf: nextValue())
+    }
+}
+
+extension Array<PositionValue> {
+    func deltaFrom(_ startKey: PositionValue.ID, to endKey: PositionValue.ID) -> CGPoint? {
+        var startPoint: CGPoint?
+        var endPoint: CGPoint?
+        for pref in self {
+            if pref.id == startKey {
+                startPoint = pref.referencePosition
+            } else if pref.id == endKey {
+                endPoint = pref.referencePosition
+            }
+        }
+        guard let endPoint, let startPoint else { return nil }
+        let deltaX = endPoint.x - startPoint.x
+        let deltaY = endPoint.y - startPoint.y
+        return CGPoint(x: deltaX, y: deltaY)
+    }
+}
+
+struct FrameReader: UIViewRepresentable {
+    var frame: CGRect // this is ignored, but necessary to trigger frame updates when scrolling
+    
+    struct AnimationFrames {
+        let clippingFrame: CGRect
+        let imageFrame: CGRect
+        
+        static func forView(_ uiView: UIView) -> Self? {
+            guard let window = uiView.window else { return nil }
+            let frameInWindow = uiView.convert(uiView.bounds, to: window).integral
+            return AnimationFrames(clippingFrame: frameInWindow, imageFrame: CGRect(x: 0, y: 0, width: frameInWindow.width, height: frameInWindow.height).integral)
+        }
+    }
+    
+    var frameDidUpdate: (AnimationFrames)->()
+    
+    class Coordinator: NSObject {
+        var frameDidUpdate: ((AnimationFrames)->())?
+    }
+    
+    func makeCoordinator() -> Coordinator {
+        let coordinator = Coordinator()
+        coordinator.frameDidUpdate = frameDidUpdate
+        return coordinator
+    }
+    
+    func makeUIView(context: Context) -> UIView {
+        let view = UIView()
+        DispatchQueue.main.async {
+            if let frames = AnimationFrames.forView(view) {
+                context.coordinator.frameDidUpdate?(frames)
+            }
+        }
+        return view
+    }
+    
+    func updateUIView(_ uiView: UIView, context: Context) {
+        DispatchQueue.main.async {
+            if let frames = AnimationFrames.forView(uiView) {
+                context.coordinator.frameDidUpdate?(frames)
+            }
+        }
+    }
+}
diff --git a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MediaAttachmentView.swift b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MediaAttachmentView.swift
index 9e5d73b4e0..bfdbad1c34 100644
--- a/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MediaAttachmentView.swift	
+++ b/Mastodon/In Progress New Layout and Datamodel/Common Components/Views/MediaAttachmentView.swift	
@@ -174,7 +174,7 @@ extension MediaAttachment {
             Image(systemName: "questionmark.square.dashed")
         case .images(let attachments, let altTextTranslations):
             ConcealableMediaAttachmentView(contentConcealViewModel: contentConceal) {
-                ImageGridView(viewModel: ImageGalleryViewModel(imageAttachments: attachments, contentConcealViewModel: contentConceal, altTextTranslations: altTextTranslations, actionHandler: actionHandler), transitionController: actionHandler.mediaPreviewableViewController?.mediaPreviewTransitionController)
+                ImageGridView(viewModel: ImageGalleryViewModel(imageAttachments: attachments, contentConcealViewModel: contentConceal, altTextTranslations: altTextTranslations, actionHandler: actionHandler), mediaPreviewableViewController: actionHandler.mediaPreviewableViewController)
             }
         case .audio, .gifv, .video:
             ConcealableMediaAttachmentView(contentConcealViewModel: contentConceal) {
@@ -233,7 +233,7 @@ struct ConcealableMediaAttachmentView<Content: View>: View {
 
 struct ImageGridView: View {
     @ObservedObject var viewModel: ImageGalleryViewModel
-    let transitionController: MediaPreviewTransitionController?
+    let mediaPreviewableViewController: MediaPreviewableViewController?
     
     var body: some View {
         // The images
@@ -246,6 +246,14 @@ struct ImageGridView: View {
                         .onTapGesture {
                             showImageGallery(focusing: img.id)
                         }
+                        .background {
+                            GeometryReader { geo in  // necessary to trigger read of updated frames after scrolling
+                                FrameReader(frame: geo.frame(in: .global)) { updatedFrames in
+                                    viewModel.updateFrames(updatedFrames, forID: img.basicData.id)
+                                }
+                                .frame(width: geo.size.width, height: geo.size.height)
+                            }
+                        }
                     
                     if let altText = img.basicData.altText, altText.isNotEmpty {
                         Button {
@@ -280,33 +288,24 @@ struct ImageGridView: View {
     func showImageGallery(focusing: Mastodon.Entity.Attachment.ID) {
         guard let presentingViewController = viewModel.actionHandler.mediaPreviewableViewController else { return }
         
-        let images: [(Mastodon.Entity.Attachment.ID, URL)] = viewModel.imageAttachments.compactMap { img in
-            if let url = img.basicData.fullsizeUrl {
-                return (img.id, url)
-            } else {
-                return nil
-            }
-        }
-        let blurhashes = viewModel.blurhashes
-        let altText = viewModel.imageAttachments.reduce(into: [String : String]()) { partialResult, img in
-            partialResult[img.id] = img.basicData.altText
-        }
-        let altTextTranslations = viewModel.altTextTranslations
-        let imageViewModel = ImageGalleryViewModel(imageAttachments: viewModel.imageAttachments, contentConcealViewModel: .alwaysShow, altTextTranslations: altTextTranslations, actionHandler: viewModel.actionHandler)
-        
         let focusedIndex = viewModel.imageAttachments.firstIndex { $0.id == focusing }
+        
+        let altTextTranslations = viewModel.altTextTranslations
         let altTexts = viewModel.imageAttachments.map { altTextTranslations?[$0.id] ?? $0.basicData.altText }
+       
         let previewItem: MediaPreviewViewModel.PreviewItem = .attachments(viewModel.imageAttachments.map{ $0._legacyEntity }, initialIndex: focusedIndex, altTexts: altTexts)
         let mediaPreviewTransitionItem: MediaPreviewTransitionItem = {
             let item = MediaPreviewTransitionItem(source: .swiftUI, previewableViewController: presentingViewController)
             
-            item.initialContainerFrame = {
-                let initialFrame = CGRect(x: 50, y: 50, width: 50, height: 50) //mediaView.superview!.convert(mediaView.frame, to: nil)
+            item.initialClippingFrame = {
+                // this is the current frame of the image view
+                let initialFrame = viewModel.frames(forID: focusing)?.clippingFrame ?? CGRect(x: 50, y: 50, width: 50, height: 50)
                 assert(initialFrame != .zero)
                 return initialFrame
             }()
-            item.initialFrame = {
-                let initialFrame = CGRect(x: 50, y: 50, width: 50, height: 50)//mediaView.contentView().frame
+            item.initialimageFrame = {
+                // this is the current frame of the image in the view, accounting for focus point if cropping
+                let initialFrame = viewModel.frames(forID: focusing)?.imageFrame ?? CGRect(x: 50, y: 50, width: 50, height: 50)
                 assert(initialFrame != .zero)
                 return initialFrame
             }()
@@ -315,11 +314,12 @@ struct ImageGridView: View {
             
             item.aspectRatio = {
                 guard let focusedIndex else { return nil }
-                return imageViewModel.imageAttachments[focusedIndex].imageDetails.originalSize
+                return viewModel.imageAttachments[focusedIndex].imageDetails.originalSize
             }()
             
             return item
         }()
+        
         let mediaPreviewViewModel = MediaPreviewViewModel(
             item: previewItem,
             transitionItem: mediaPreviewTransitionItem)
@@ -372,6 +372,7 @@ struct BlurhashImageView: View {
 
 class ImageGalleryViewModel: ObservableObject {
     let imageAttachments: [MastodonImageAttachment]
+    private var frames = [Mastodon.Entity.Attachment.ID : FrameReader.AnimationFrames]()
     let altTextTranslations: [String : String]?
     @Published var blurhashes = [ Mastodon.Entity.Attachment.ID : UIImage ]()
     @ObservedObject var contentConcealViewModel: ContentConcealViewModel
@@ -407,6 +408,14 @@ class ImageGalleryViewModel: ObservableObject {
             return !showAnyway
         }
     }
+    
+    func frames(forID id: Mastodon.Entity.Attachment.ID) -> FrameReader.AnimationFrames? {
+        return frames[id]
+    }
+    
+    func updateFrames(_ newFrames: FrameReader.AnimationFrames, forID id: Mastodon.Entity.Attachment.ID) {
+        frames[id] = newFrames
+    }
 }
 
 struct PlayerView: View {
diff --git a/Mastodon/Protocol/Provider/DataSourceFacade+Media.swift b/Mastodon/Protocol/Provider/DataSourceFacade+Media.swift
index 48fc6e4f77..fb7abec984 100644
--- a/Mastodon/Protocol/Provider/DataSourceFacade+Media.swift
+++ b/Mastodon/Protocol/Provider/DataSourceFacade+Media.swift
@@ -91,12 +91,12 @@ extension DataSourceFacade {
             
             let mediaView = previewContext.mediaView
 
-            item.initialContainerFrame = {
+            item.initialClippingFrame = {
                 let initialFrame = mediaView.superview!.convert(mediaView.frame, to: nil)
                 assert(initialFrame != .zero)
                 return initialFrame
             }()
-            item.initialFrame = {
+            item.initialimageFrame = {
                 let initialFrame = mediaView.contentView().frame
                 assert(initialFrame != .zero)
                 return initialFrame
@@ -174,7 +174,7 @@ extension DataSourceFacade {
         )
 
         let imageView = previewContext.imageView
-        mediaPreviewTransitionItem.initialFrame = imageView.superview?.convert(imageView.frame, to: nil)
+        mediaPreviewTransitionItem.initialimageFrame = imageView.superview?.convert(imageView.frame, to: nil)
         mediaPreviewTransitionItem.image = thumbnail
         mediaPreviewTransitionItem.aspectRatio = thumbnail?.size ?? CGSize(width: 100, height: 100)
         mediaPreviewTransitionItem.sourceImageViewCornerRadius = {
diff --git a/Mastodon/Scene/Notification/Notification Filtering/NotificationPolicyHostingViewController.swift b/Mastodon/Scene/Notification/Notification Filtering/NotificationPolicyHostingViewController.swift
index c09f1bb171..0a2fd22adc 100644
--- a/Mastodon/Scene/Notification/Notification Filtering/NotificationPolicyHostingViewController.swift	
+++ b/Mastodon/Scene/Notification/Notification Filtering/NotificationPolicyHostingViewController.swift	
@@ -613,73 +613,3 @@ extension FilterAction {
         }
     }
 }
-
-struct ReferencePointReader: View {
-    static let referenceSpace = "ReferencePointReaderSpace"
-    let id: String
-    
-    let referencePoint: PositionReferencePoint
-    
-    enum PositionReferencePoint {
-        case trailingCenter
-        case leadingTop
-    }
-    
-    var body: some View {
-        GeometryReader { metrics in
-            let position =  {
-                switch referencePoint {
-                case .trailingCenter:
-                    CGPoint(
-                        x: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).maxX,
-                        y: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).midY
-                    )
-                case .leadingTop:
-                    CGPoint(
-                        x: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).minX,
-                        y: metrics.frame(in: .named(ReferencePointReader.referenceSpace)).minY
-                    )
-                }
-               
-            }()
-            
-            Rectangle()
-                .fill(Color.clear)
-                .preference(
-                    key: PositionKey.self,
-                    value: [PositionValue(id: id, referencePosition: position)]
-                )
-        }
-    }
-}
-
-struct PositionValue: Equatable {
-    typealias ID = String
-    let id: ID
-    let referencePosition: CGPoint
-}
-
-struct PositionKey: PreferenceKey {
-    static var defaultValue: [PositionValue] = []
-    static func reduce(value: inout [PositionValue], nextValue: () -> [PositionValue]) {
-        value.append(contentsOf: nextValue())
-    }
-}
-
-extension Array<PositionValue> {
-    func deltaFrom(_ startKey: PositionValue.ID, to endKey: PositionValue.ID) -> CGPoint? {
-        var startPoint: CGPoint?
-        var endPoint: CGPoint?
-        for pref in self {
-            if pref.id == startKey {
-                startPoint = pref.referencePosition
-            } else if pref.id == endKey {
-                endPoint = pref.referencePosition
-            }
-        }
-        guard let endPoint, let startPoint else { return nil }
-        let deltaX = endPoint.x - startPoint.x
-        let deltaY = endPoint.y - startPoint.y
-        return CGPoint(x: deltaX, y: deltaY)
-    }
-}
diff --git a/Mastodon/Scene/Transition/MediaPreview/MediaHostToMediaPreviewViewControllerAnimatedTransitioning.swift b/Mastodon/Scene/Transition/MediaPreview/MediaHostToMediaPreviewViewControllerAnimatedTransitioning.swift
index 20c947f056..d6ecdaba61 100644
--- a/Mastodon/Scene/Transition/MediaPreview/MediaHostToMediaPreviewViewControllerAnimatedTransitioning.swift
+++ b/Mastodon/Scene/Transition/MediaPreview/MediaHostToMediaPreviewViewControllerAnimatedTransitioning.swift
@@ -60,23 +60,23 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
         transitionItem.source.updateAppearance(position: .start, index: toVC.viewModel.currentPage)
         
         // Set transition image view
-        assert(transitionItem.initialFrame != nil)
-        let initialContainerFrame = transitionItem.initialContainerFrame ?? toViewEndFrame
-        let initialFrame = transitionItem.initialFrame ?? toViewEndFrame
+        assert(transitionItem.initialimageFrame != nil)
+        let initialClippingFrame = transitionItem.initialClippingFrame ?? toViewEndFrame
+        let initialImageFrame = transitionItem.initialimageFrame ?? toViewEndFrame
         
         let transitionTargetFrame: CGRect = {
-            let aspectRatio = transitionItem.aspectRatio ?? CGSize(width: initialContainerFrame.width, height: initialContainerFrame.height)
+            let aspectRatio = transitionItem.aspectRatio ?? CGSize(width: initialClippingFrame.width, height: initialClippingFrame.height)
             return AVMakeRect(aspectRatio: aspectRatio, insideRect: toView.bounds.inset(by: toView.safeAreaInsets))
         }()
         
         // We need an additional clipping container because the image origin can be shifted with the focus point
-        let transitionContainer: UIView = {
-            let view = UIView(frame: transitionContext.containerView.convert(initialContainerFrame, from: nil))
+        let transitionClippingView: UIView = {
+            let view = UIView(frame: transitionContext.containerView.convert(initialClippingFrame, from: nil))
             view.clipsToBounds = true
             return view
         }()
         let transitionImageView: UIImageView = {
-            let imageView = UIImageView(frame: initialFrame)
+            let imageView = UIImageView(frame: initialImageFrame)
             imageView.clipsToBounds = true
             imageView.contentMode = .scaleAspectFill
             imageView.isUserInteractionEnabled = false
@@ -85,10 +85,10 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
             imageView.accessibilityIgnoresInvertColors = true
             return imageView
         }()
-        transitionContainer.addSubview(transitionImageView)
-        transitionContext.containerView.addSubview(transitionContainer)
+        transitionClippingView.addSubview(transitionImageView)
+        transitionContext.containerView.addSubview(transitionClippingView)
         transitionItem.targetFrame = transitionTargetFrame
-        transitionItem.transitionView = transitionContainer
+        transitionItem.transitionView = transitionClippingView
         
         toVC.topToolbar.alpha = 0
 
@@ -99,7 +99,7 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
         let animator = MediaHostToMediaPreviewViewControllerAnimatedTransitioning.animator(initialVelocity: .zero)
 
         animator.addAnimations {
-            transitionContainer.frame = transitionTargetFrame
+            transitionClippingView.frame = transitionTargetFrame
             transitionImageView.frame = CGRect(origin: .zero, size: transitionTargetFrame.size)
             toView.alpha = 1
             if UIAccessibility.isReduceTransparencyEnabled {
@@ -109,7 +109,7 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
 
         animator.addCompletion { position in
             toVC.pagingViewController.view.alpha = 1
-            transitionContainer.removeFromSuperview()
+            transitionClippingView.removeFromSuperview()
             UIView.animate(withDuration: 0.33, delay: 0, options: [.curveEaseInOut]) {
                 toVC.topToolbar.alpha = 1
             }
@@ -222,8 +222,8 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
 
         transitionItem.transitionView = mediaPreviewTransitionContext.transitionView
         transitionItem.snapshotTransitioning = mediaPreviewTransitionContext.snapshot
-        transitionItem.initialContainerFrame = transitionContainerView.frame
-        transitionItem.initialFrame = mediaPreviewTransitionContext.snapshot.frame
+        transitionItem.initialClippingFrame = transitionContainerView.frame
+        transitionItem.initialimageFrame = mediaPreviewTransitionContext.snapshot.frame
         transitionItem.containerSnapshotTransitioning = transitionContainerView
 
         // assert view hierarchy not change
@@ -487,8 +487,8 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
                 }
                 
             } else {
-                if let initialFrame = self.transitionItem.initialFrame,
-                   let initialContainerFrame = self.transitionItem.initialContainerFrame {
+                if let initialFrame = self.transitionItem.initialimageFrame,
+                   let initialContainerFrame = self.transitionItem.initialClippingFrame {
                     self.transitionItem.snapshotTransitioning?.frame = initialFrame
                     self.transitionItem.containerSnapshotTransitioning?.frame = initialContainerFrame
                 } else {
@@ -520,7 +520,7 @@ extension MediaHostToMediaPreviewViewControllerAnimatedTransitioning {
     private func updateTransitionItemPosition(of translation: CGPoint) {
         let progress = progressStep(for: translation)
 
-        let initialSize = transitionItem.initialFrame!.size
+        let initialSize = transitionItem.initialimageFrame!.size
         guard initialSize != .zero else { return }
         // assert(initialSize != .zero)
 
diff --git a/Mastodon/Scene/Transition/MediaPreview/MediaPreviewTransitionItem.swift b/Mastodon/Scene/Transition/MediaPreview/MediaPreviewTransitionItem.swift
index 21be1e7fab..b444ce1869 100644
--- a/Mastodon/Scene/Transition/MediaPreview/MediaPreviewTransitionItem.swift
+++ b/Mastodon/Scene/Transition/MediaPreview/MediaPreviewTransitionItem.swift
@@ -18,8 +18,8 @@ class MediaPreviewTransitionItem: Identifiable {
     // source
     var image: UIImage?
     var aspectRatio: CGSize?
-    var initialContainerFrame: CGRect? = nil
-    var initialFrame: CGRect? = nil
+    var initialClippingFrame: CGRect? = nil
+    var initialimageFrame: CGRect? = nil
     var sourceImageView: UIImageView?
     var sourceImageViewCornerRadius: CGFloat?
     
