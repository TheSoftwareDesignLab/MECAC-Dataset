diff --git a/Localization/app.json b/Localization/app.json
index a28b6e7f78..b5d375a15d 100644
--- a/Localization/app.json
+++ b/Localization/app.json
@@ -9,16 +9,20 @@
                 "locale": "locale",
                 "reason": "reason"
             },
-            "ERR_BLOCKED": "is blocked",
-            "ERR_UNREACHABLE": "is unreachable",
-            "ERR_TAKEN": "is taken",
-            "ERR_RESERVED": "is reserved",
+            "itemDetail": {
+                "emailInvalid": "It's not a valid e-mail address",
+                "usernameInvalid": "username only contains alphanumeric characters and underscores"
+            },
+            "ERR_BLOCKED": "contains a disallowed e-mail provider",
+            "ERR_UNREACHABLE": "does not seem to exist",
+            "ERR_TAKEN": "is already in use",
+            "ERR_RESERVED": "is a reserved keyword or username",
             "ERR_ACCEPTED": "must be accepted",
-            "ERR_BLANK": "can't be blank",
+            "ERR_BLANK": "is required",
             "ERR_INVALID": "is invalid",
-            "ERR_TOO_LONG": "is too long",
-            "ERR_TOO_SHORT": "is too short",
-            "ERR_INCLUSION": "is inclusion"
+            "ERR_TOO_LONG": "is too long ( can't be longer than 30 characters)",
+            "ERR_TOO_SHORT": "is too short (must be at least 8 characters)",
+            "ERR_INCLUSION": "is not a supported value"
         },
         "alerts": {
             "sign_up_failure": {
diff --git a/Mastodon/Extension/Mastodon+Entidy+ErrorDetailReson.swift b/Mastodon/Extension/Mastodon+Entidy+ErrorDetailReson.swift
index c78e4dfc47..e72e2771f9 100644
--- a/Mastodon/Extension/Mastodon+Entidy+ErrorDetailReson.swift
+++ b/Mastodon/Extension/Mastodon+Entidy+ErrorDetailReson.swift
@@ -38,53 +38,51 @@ extension Mastodon.Entity.ErrorDetailReason {
 extension Mastodon.Entity.ErrorDetail {
     func localizedDescription() -> String {
         var messages: [String?] = []
-        if let username = self.username {
-            if !username.isEmpty {
-                let errors = username.map {
-                    L10n.Common.Errors.Item.username + " " + $0.localizedDescription()
+
+        if let username = self.username, !username.isEmpty {
+            let errors = username.map { errorDetailReason -> String in
+                if errorDetailReason.error == .ERR_INVALID {
+                    return L10n.Common.Errors.Itemdetail.usernameinvalid
+                } else {
+                    return L10n.Common.Errors.Item.username + " " + errorDetailReason.localizedDescription()
                 }
-                messages.append(contentsOf: errors)
             }
+            messages.append(contentsOf: errors)
         }
-        if let email = self.email {
-            if !email.isEmpty {
-                let errors = email.map {
-                    L10n.Common.Errors.Item.email + " " + $0.localizedDescription()
+
+        if let email = self.email, !email.isEmpty {
+            let errors = email.map { errorDetailReason -> String in
+                if errorDetailReason.error == .ERR_INVALID {
+                    return L10n.Common.Errors.Itemdetail.emailinvalid
+                } else {
+                    return L10n.Common.Errors.Item.email + " " + errorDetailReason.localizedDescription()
                 }
-                messages.append(contentsOf: errors)
             }
+            messages.append(contentsOf: errors)
         }
-        if let password = self.password {
-            if !password.isEmpty {
-                let errors = password.map {
-                    L10n.Common.Errors.Item.password + " " + $0.localizedDescription()
-                }
-                messages.append(contentsOf: errors)
+        if let password = self.password,!password.isEmpty {
+            let errors = password.map {
+                L10n.Common.Errors.Item.password + " " + $0.localizedDescription()
             }
+            messages.append(contentsOf: errors)
         }
-        if let agreement = self.agreement {
-            if !agreement.isEmpty {
-                let errors = agreement.map {
-                    L10n.Common.Errors.Item.agreement + " " + $0.localizedDescription()
-                }
-                messages.append(contentsOf: errors)
+        if let agreement = self.agreement, !agreement.isEmpty {
+            let errors = agreement.map {
+                L10n.Common.Errors.Item.agreement + " " + $0.localizedDescription()
             }
+            messages.append(contentsOf: errors)
         }
-        if let locale = self.locale {
-            if !locale.isEmpty {
-                let errors = locale.map {
-                    L10n.Common.Errors.Item.locale + " " + $0.localizedDescription()
-                }
-                messages.append(contentsOf: errors)
+        if let locale = self.locale, !locale.isEmpty {
+            let errors = locale.map {
+                L10n.Common.Errors.Item.locale + " " + $0.localizedDescription()
             }
+            messages.append(contentsOf: errors)
         }
-        if let reason = self.reason {
-            if !reason.isEmpty {
-                let errors = reason.map {
-                    L10n.Common.Errors.Item.reason + " " + $0.localizedDescription()
-                }
-                messages.append(contentsOf: errors)
+        if let reason = self.reason, !reason.isEmpty {
+            let errors = reason.map {
+                L10n.Common.Errors.Item.reason + " " + $0.localizedDescription()
             }
+            messages.append(contentsOf: errors)
         }
         let message = messages
             .compactMap { $0 }
diff --git a/Mastodon/Generated/Strings.swift b/Mastodon/Generated/Strings.swift
index ce4ab38f8e..d9e7de9e51 100644
--- a/Mastodon/Generated/Strings.swift
+++ b/Mastodon/Generated/Strings.swift
@@ -85,23 +85,23 @@ internal enum L10n {
     internal enum Errors {
       /// must be accepted
       internal static let errAccepted = L10n.tr("Localizable", "Common.Errors.ErrAccepted")
-      /// can't be blank
+      /// is required
       internal static let errBlank = L10n.tr("Localizable", "Common.Errors.ErrBlank")
-      /// is blocked
+      /// contains a disallowed e-mail provider
       internal static let errBlocked = L10n.tr("Localizable", "Common.Errors.ErrBlocked")
-      /// is inclusion
+      /// is not a supported value
       internal static let errInclusion = L10n.tr("Localizable", "Common.Errors.ErrInclusion")
       /// is invalid
       internal static let errInvalid = L10n.tr("Localizable", "Common.Errors.ErrInvalid")
-      /// is reserved
+      /// is a reserved keyword or username
       internal static let errReserved = L10n.tr("Localizable", "Common.Errors.ErrReserved")
-      /// is taken
+      /// is already in use
       internal static let errTaken = L10n.tr("Localizable", "Common.Errors.ErrTaken")
-      /// is too long
+      /// is too long ( can't be longer than 30 characters)
       internal static let errTooLong = L10n.tr("Localizable", "Common.Errors.ErrTooLong")
-      /// is too short
+      /// is too short (must be at least 8 characters)
       internal static let errTooShort = L10n.tr("Localizable", "Common.Errors.ErrTooShort")
-      /// is unreachable
+      /// does not seem to exist
       internal static let errUnreachable = L10n.tr("Localizable", "Common.Errors.ErrUnreachable")
       internal enum Item {
         /// agreement
@@ -117,6 +117,12 @@ internal enum L10n {
         /// username
         internal static let username = L10n.tr("Localizable", "Common.Errors.Item.Username")
       }
+      internal enum Itemdetail {
+        /// It's not a valid e-mail address
+        internal static let emailinvalid = L10n.tr("Localizable", "Common.Errors.Itemdetail.Emailinvalid")
+        /// username only contains alphanumeric characters and underscores
+        internal static let usernameinvalid = L10n.tr("Localizable", "Common.Errors.Itemdetail.Usernameinvalid")
+      }
     }
   }
 
diff --git a/Mastodon/Resources/en.lproj/Localizable.strings b/Mastodon/Resources/en.lproj/Localizable.strings
index 663ad25adc..d127a93a33 100644
--- a/Mastodon/Resources/en.lproj/Localizable.strings
+++ b/Mastodon/Resources/en.lproj/Localizable.strings
@@ -24,21 +24,23 @@
 "Common.Countable.Photo.Multiple" = "photos";
 "Common.Countable.Photo.Single" = "photo";
 "Common.Errors.ErrAccepted" = "must be accepted";
-"Common.Errors.ErrBlank" = "can't be blank";
-"Common.Errors.ErrBlocked" = "is blocked";
-"Common.Errors.ErrInclusion" = "is inclusion";
+"Common.Errors.ErrBlank" = "is required";
+"Common.Errors.ErrBlocked" = "contains a disallowed e-mail provider";
+"Common.Errors.ErrInclusion" = "is not a supported value";
 "Common.Errors.ErrInvalid" = "is invalid";
-"Common.Errors.ErrReserved" = "is reserved";
-"Common.Errors.ErrTaken" = "is taken";
-"Common.Errors.ErrTooLong" = "is too long";
-"Common.Errors.ErrTooShort" = "is too short";
-"Common.Errors.ErrUnreachable" = "is unreachable";
+"Common.Errors.ErrReserved" = "is a reserved keyword or username";
+"Common.Errors.ErrTaken" = "is already in use";
+"Common.Errors.ErrTooLong" = "is too long ( can't be longer than 30 characters)";
+"Common.Errors.ErrTooShort" = "is too short (must be at least 8 characters)";
+"Common.Errors.ErrUnreachable" = "does not seem to exist";
 "Common.Errors.Item.Agreement" = "agreement";
 "Common.Errors.Item.Email" = "email";
 "Common.Errors.Item.Locale" = "locale";
 "Common.Errors.Item.Password" = "password";
 "Common.Errors.Item.Reason" = "reason";
 "Common.Errors.Item.Username" = "username";
+"Common.Errors.Itemdetail.Emailinvalid" = "It's not a valid e-mail address";
+"Common.Errors.Itemdetail.Usernameinvalid" = "username only contains alphanumeric characters and underscores";
 "Scene.ConfirmEmail.Button.DontReceiveEmail" = "I never got an email";
 "Scene.ConfirmEmail.Button.OpenEmailApp" = "Open Email App";
 "Scene.ConfirmEmail.DontReceiveEmail.Description" = "Check if your email address is correct as well as your junk folder if you havenâ€™t.";
diff --git a/Mastodon/Scene/Onboarding/Register/MastodonRegisterViewModel.swift b/Mastodon/Scene/Onboarding/Register/MastodonRegisterViewModel.swift
index 8f930771a7..a32e5d040e 100644
--- a/Mastodon/Scene/Onboarding/Register/MastodonRegisterViewModel.swift
+++ b/Mastodon/Scene/Onboarding/Register/MastodonRegisterViewModel.swift
@@ -160,7 +160,7 @@ extension MastodonRegisterViewModel {
         let falseColor = UIColor.clear
         let attributeString = NSMutableAttributedString()
         
-        let start = NSAttributedString(string: "Your password needs at least:\n", attributes: [NSAttributedString.Key.font: font, NSAttributedString.Key.foregroundColor: color])
+        let start = NSAttributedString(string: "Your password needs at least:", attributes: [NSAttributedString.Key.font: font, NSAttributedString.Key.foregroundColor: color])
         attributeString.append(start)
         
         attributeString.append(checkmarkImage(color: eightCharacters ? color : falseColor))
diff --git a/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+ErrorDetail.swift b/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+ErrorDetail.swift
index 4d90779bb4..7881aaa0da 100644
--- a/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+ErrorDetail.swift
+++ b/MastodonSDK/Sources/MastodonSDK/Entity/Mastodon+Entity+ErrorDetail.swift
@@ -7,15 +7,15 @@
 
 import Foundation
 extension Mastodon.Entity.Error {
-    ///        ERR_BLOCKED    When e-mail provider is not allowed
-    ///        ERR_UNREACHABLE    When e-mail address does not resolve to any IP via DNS (MX, A, AAAA)
-    ///        ERR_TAKEN    When username or e-mail are already taken
-    ///        ERR_RESERVED    When a username is reserved, e.g. "webmaster" or "admin"
-    ///        ERR_ACCEPTED    When agreement has not been accepted
-    ///        ERR_BLANK    When a required attribute is blank
-    ///        ERR_INVALID    When an attribute is malformed, e.g. wrong characters or invalid e-mail address
-    ///        ERR_TOO_LONG    When an attribute is over the character limit
-    ///        ERR_INCLUSION    When an attribute is not one of the allowed values, e.g. unsupported locale
+    /// ERR_BLOCKED    When e-mail provider is not allowed
+    /// ERR_UNREACHABLE    When e-mail address does not resolve to any IP via DNS (MX, A, AAAA)
+    /// ERR_TAKEN    When username or e-mail are already taken
+    /// ERR_RESERVED    When a username is reserved, e.g. "webmaster" or "admin"
+    /// ERR_ACCEPTED    When agreement has not been accepted
+    /// ERR_BLANK    When a required attribute is blank
+    /// ERR_INVALID    When an attribute is malformed, e.g. wrong characters or invalid e-mail address
+    /// ERR_TOO_LONG    When an attribute is over the character limit
+    /// ERR_INCLUSION    When an attribute is not one of the allowed values, e.g. unsupported locale
     public enum SignUpError: RawRepresentable, Codable {
         case ERR_BLOCKED
         case ERR_UNREACHABLE
