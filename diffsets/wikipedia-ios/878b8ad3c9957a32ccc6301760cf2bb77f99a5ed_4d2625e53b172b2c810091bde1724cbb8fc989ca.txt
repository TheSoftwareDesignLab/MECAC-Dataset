diff --git a/Wikipedia/Code/NotificationsCenterViewController.swift b/Wikipedia/Code/NotificationsCenterViewController.swift
index 5da55d1aa5a..1a7fd533335 100644
--- a/Wikipedia/Code/NotificationsCenterViewController.swift
+++ b/Wikipedia/Code/NotificationsCenterViewController.swift
@@ -19,8 +19,26 @@ final class NotificationsCenterViewController: ViewController {
 
     // MARK: - Properties - Cell Swipe Actions
 
+    fileprivate struct CellSwipeData {
+        var activelyPannedCellIndexPath: IndexPath? // `IndexPath` of actively panned or open or opening cell
+        var activelyPannedCellTranslationX: CGFloat? // current translation on x-axis of open or opening cell
+
+        func activeCell(in collectionView: UICollectionView) -> NotificationsCenterCell? {
+            guard let activelyPannedCellIndexPath = activelyPannedCellIndexPath else {
+                return nil
+            }
+
+            return collectionView.cellForItem(at: activelyPannedCellIndexPath) as? NotificationsCenterCell
+        }
+
+        mutating func resetActiveData() {
+            activelyPannedCellIndexPath = nil
+            activelyPannedCellTranslationX = nil
+        }
+    }
+
     fileprivate lazy var cellPanGestureRecognizer = UIPanGestureRecognizer()
-    fileprivate var activelyPannedCellIndexPath: IndexPath?
+    fileprivate lazy var cellSwipeData = CellSwipeData()
 
     // MARK: - Lifecycle
 
@@ -64,10 +82,16 @@ final class NotificationsCenterViewController: ViewController {
         viewModel.refreshNotifications()
     }
 
+    override func viewWillDisappear(_ animated: Bool) {
+        super.viewWillDisappear(animated)
+        closeSwipeActionsPanelIfNecessary()
+    }
+
     override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
         super.traitCollectionDidChange(previousTraitCollection)
 
         if previousTraitCollection?.preferredContentSizeCategory != traitCollection.preferredContentSizeCategory {
+            closeSwipeActionsPanelIfNecessary()
             notificationsView.collectionView.reloadData()
         }
     }
@@ -109,7 +133,7 @@ final class NotificationsCenterViewController: ViewController {
 //MARK: Private
 
 private extension NotificationsCenterViewController {
-    
+
     func setupDataSource() {
         dataSource = DataSource(
         collectionView: notificationsView.collectionView,
@@ -166,6 +190,8 @@ private extension NotificationsCenterViewController {
         notificationsView.collectionView.indexPathsForSelectedItems?.forEach {
             notificationsView.collectionView.deselectItem(at: $0, animated: false)
         }
+
+        closeSwipeActionsPanelIfNecessary()
     }
     
     /// Calls cell configure methods again without instantiating a new cell.
@@ -203,6 +229,7 @@ private extension NotificationsCenterViewController {
             }
         }
     }
+
 }
 
 // MARK: - NotificationCenterViewModelDelegate
@@ -246,7 +273,7 @@ extension NotificationsCenterViewController: UICollectionViewDelegate {
         guard let cellViewModel = dataSource?.itemIdentifier(for: indexPath) else {
             return
         }
-        
+
         viewModel.updateCellDisplayStates(cellViewModels: [cellViewModel], isSelected: true)
         reconfigureCells(with: [cellViewModel])
         
@@ -264,7 +291,7 @@ extension NotificationsCenterViewController: UICollectionViewDelegate {
         guard let cellViewModel = dataSource?.itemIdentifier(for: indexPath) else {
             return
         }
-        
+
         viewModel.updateCellDisplayStates(cellViewModels: [cellViewModel], isSelected: false)
         reconfigureCells(with: [cellViewModel])
     }
@@ -274,6 +301,18 @@ extension NotificationsCenterViewController: UICollectionViewDelegate {
 
 @objc extension NotificationsCenterViewController: UIGestureRecognizerDelegate {
 
+    override func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
+        super.scrollViewWillBeginDragging(scrollView)
+        closeSwipeActionsPanelIfNecessary()
+    }
+
+    func closeSwipeActionsPanelIfNecessary() {
+        if let activeCell = cellSwipeData.activeCell(in: notificationsView.collectionView) {
+            animateSwipePanel(open: false, for: activeCell)
+            cellSwipeData.resetActiveData()
+        }
+    }
+
     /// Only allow cell pan gesture if user's horizontal cell panning behavior seems intentional
     func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {
         if gestureRecognizer == cellPanGestureRecognizer {
@@ -286,19 +325,98 @@ extension NotificationsCenterViewController: UICollectionViewDelegate {
         return false
     }
 
+    fileprivate func animateSwipePanel(open: Bool, for cell: NotificationsCenterCell) {
+        let isRTL = UIApplication.shared.wmf_isRTL
+        UIView.animate(withDuration: 0.25, delay: 0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.5, options: [.allowUserInteraction, .beginFromCurrentState], animations: {
+            if open {
+                let translationX = isRTL ? cell.swipeActionButtonStack.frame.size.width : -cell.swipeActionButtonStack.frame.size.width
+                cell.foregroundContentContainer.transform = CGAffineTransform.identity.translatedBy(x: translationX, y: 0)
+            } else {
+                cell.foregroundContentContainer.transform = CGAffineTransform.identity
+            }
+        }, completion: nil)
+    }
+
     @objc fileprivate func userDidPanCell(_ gestureRecognizer: UIPanGestureRecognizer) {
+        let isRTL = UIApplication.shared.wmf_isRTL
+        let triggerVelocity: CGFloat = 400
+        let swipeEdgeBuffer = NotificationsCenterCell.swipeEdgeBuffer
+        let touchPosition = gestureRecognizer.location(in: notificationsView.collectionView)
+        let translationX = gestureRecognizer.translation(in: notificationsView.collectionView).x
+        let velocityX = gestureRecognizer.velocity(in: notificationsView.collectionView).x
+
         switch gestureRecognizer.state {
         case .began:
-            let touchPosition = gestureRecognizer.location(in: notificationsView.collectionView)
-            guard let cellIndexPath = notificationsView.collectionView.indexPathForItem(at: touchPosition) else {
+            guard let touchCellIndexPath = notificationsView.collectionView.indexPathForItem(at: touchPosition), let cell = notificationsView.collectionView.cellForItem(at: touchCellIndexPath) as? NotificationsCenterCell else {
                 gestureRecognizer.state = .ended
                 break
             }
 
-            activelyPannedCellIndexPath = cellIndexPath
+            // If the new touch is on a new cell, and a current cell is already open, close it first
+            if let currentlyActiveIndexPath = cellSwipeData.activelyPannedCellIndexPath, currentlyActiveIndexPath != touchCellIndexPath, let cell = notificationsView.collectionView.cellForItem(at: currentlyActiveIndexPath) as? NotificationsCenterCell {
+                animateSwipePanel(open: false, for: cell)
+            }
+
+            if cell.foregroundContentContainer.transform.isIdentity {
+                cellSwipeData.activelyPannedCellTranslationX = nil
+                if velocityX > 0 {
+                    gestureRecognizer.state = .ended
+                    break
+                }
+            } else {
+                cellSwipeData.activelyPannedCellTranslationX = isRTL ? -cell.foregroundContentContainer.transform.tx : cell.foregroundContentContainer.transform.tx
+            }
+
+            cellSwipeData.activelyPannedCellIndexPath = touchCellIndexPath
+        case .changed:
+            guard let cell = cellSwipeData.activeCell(in: notificationsView.collectionView) else {
+                break
+            }
+
+            let swipeStackWidth = cell.swipeActionButtonStack.frame.size.width
+            var totalTranslationX = translationX + (cellSwipeData.activelyPannedCellTranslationX ?? 0)
+
+            let maximumTranslationX = swipeStackWidth + swipeEdgeBuffer
+
+            // The user is trying to pan too far left
+            if totalTranslationX < -maximumTranslationX {
+                totalTranslationX = -maximumTranslationX - log(abs(translationX))
+            }
+
+            // Extends too far right
+            if totalTranslationX > swipeEdgeBuffer {
+                totalTranslationX = swipeEdgeBuffer + log(abs(translationX))
+            }
+
+            let finalTranslationX = isRTL ? -totalTranslationX : totalTranslationX
+            cell.foregroundContentContainer.transform = CGAffineTransform(translationX: finalTranslationX, y: 0)
         case .ended:
-            userDidSwipeCell(indexPath: activelyPannedCellIndexPath)
-            activelyPannedCellIndexPath = nil
+            guard let cell = cellSwipeData.activeCell(in: notificationsView.collectionView) else {
+                break
+            }
+
+            var shouldOpenSwipePanel: Bool
+            let currentCellTranslationX = isRTL ? -cell.foregroundContentContainer.transform.tx : cell.foregroundContentContainer.transform.tx
+
+            if currentCellTranslationX > 0 {
+                shouldOpenSwipePanel = false
+            } else {
+                if velocityX < -triggerVelocity {
+                    shouldOpenSwipePanel = true
+                } else {
+                    shouldOpenSwipePanel = abs(currentCellTranslationX) > (0.5 * cell.swipeActionButtonStack.frame.size.width)
+                }
+            }
+
+            if velocityX > triggerVelocity {
+                shouldOpenSwipePanel = false
+            }
+
+            if !shouldOpenSwipePanel {
+                cellSwipeData.resetActiveData()
+            }
+
+            animateSwipePanel(open: shouldOpenSwipePanel, for: cell)
         default:
             return
         }
@@ -336,7 +454,7 @@ extension NotificationsCenterViewController: NotificationsCenterCellDelegate {
                 alertAction = UIAlertAction(title: data.text, style: .default, handler: { alertAction in
                     let shouldMarkRead = cellViewModel.isRead ? false : true
                     self.viewModel.markAsReadOrUnread(viewModels: [cellViewModel], shouldMarkRead: shouldMarkRead)
-                    self.closeActiveSwipePanelIfNecessary()
+                    self.closeSwipeActionsPanelIfNecessary()
                 })
             case .notificationSubscriptionSettings(let data):
                 alertAction = UIAlertAction(title: data.text, style: .default, handler: { alertAction in
@@ -369,7 +487,7 @@ extension NotificationsCenterViewController: NotificationsCenterCellDelegate {
             return
         }
 
-        closeActiveSwipePanelIfNecessary()
+        closeSwipeActionsPanelIfNecessary()
         viewModel.markAsReadOrUnread(viewModels: [cellViewModel], shouldMarkRead: !cellViewModel.isRead)
     }
     
