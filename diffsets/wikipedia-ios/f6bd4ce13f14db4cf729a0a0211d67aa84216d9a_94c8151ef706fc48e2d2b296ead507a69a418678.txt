diff --git a/WMF Framework/CollectionViewCellActionsView.swift b/WMF Framework/CollectionViewCellActionsView.swift
index 2dd0ed5010a..15cebce2d74 100644
--- a/WMF Framework/CollectionViewCellActionsView.swift	
+++ b/WMF Framework/CollectionViewCellActionsView.swift	
@@ -40,7 +40,6 @@ public protocol ActionsViewDelegate: NSObjectProtocol {
 
 public class CollectionViewCellActionsView: UIView {
     
-    var cell: ArticleCollectionViewCell
     var maximumWidth: CGFloat = 0
     public var theme = Theme.standard
     
@@ -50,72 +49,8 @@ public class CollectionViewCellActionsView: UIView {
         }
     }
     
-    var swipeType: CollectionViewCellSwipeType = .none {
-        didSet {
-            setNeedsLayout()
-        }
-    }
-    
-    init(frame: CGRect, cell: ArticleCollectionViewCell) {
-        self.cell = cell
-        super.init(frame: frame)
-        
-        self.isUserInteractionEnabled = false
-    }
-    
     override public func layoutSubviews() {
         super.layoutSubviews()
-        swipeType == .primary ? layoutPrimaryActions() : layoutSecondaryActions()
-    }
-    
-    func createSubviews(for actions: [CollectionViewCellAction]) {
-        
-        for view in self.subviews {
-            view.removeFromSuperview()
-        }
-        
-        var maxButtonWidth: CGFloat = 0
-        
-        for (index, action) in actions.enumerated() {
-            let button = UIButton(type: .custom)
-            button.setTitle(action.title, for: .normal)
-            button.titleLabel?.numberOfLines = 1
-            button.contentEdgeInsets = UIEdgeInsetsMake(0, 14, 0, 14)
-            button.tag = index
-            
-            switch (action.type) {
-            case .delete:
-                button.backgroundColor = theme.colors.destructive
-            case .share:
-                button.backgroundColor = theme.colors.secondaryAction
-            case .save:
-                button.backgroundColor = theme.colors.link
-            case .unsave:
-                button.backgroundColor = self.theme.colors.link
-            }
-            
-            button.addTarget(self, action: #selector(didPerformAction(_:)), for: .touchUpInside)
-            
-            // Wrapper around each button.
-            let wrapper = UIView(frame: .zero)
-            wrapper.clipsToBounds = true
-            wrapper.addSubview(button)
-            self.addSubview(wrapper)
-            maxButtonWidth = max(maxButtonWidth, button.intrinsicContentSize.width)
-        }
-        
-        maximumWidth = maxButtonWidth * CGFloat(self.subviews.count)
-    }
-
-    public weak var delegate: ActionsViewDelegate?
-    
-    @objc func didPerformAction(_ sender: UIButton) {
-        let action = cell.actions[sender.tag]
-        delegate?.didPerformAction(action)
-    }
-    
-    func layoutPrimaryActions() {
-        
         let numberOfButtonWrappers = self.subviews.count
         
         let buttonWrapperWidth = maximumWidth / CGFloat(numberOfButtonWrappers)
@@ -157,14 +92,52 @@ public class CollectionViewCellActionsView: UIView {
                 buttonWrapper.backgroundColor = UIColor.clear
             }
         }
-        
     }
     
-    func layoutSecondaryActions() {
+    func createSubviews(for actions: [CollectionViewCellAction]) {
+        
+        for view in self.subviews {
+            view.removeFromSuperview()
+        }
+        
+        var maxButtonWidth: CGFloat = 0
+        
+        for (index, action) in actions.enumerated() {
+            let button = UIButton(type: .custom)
+            button.setTitle(action.title, for: .normal)
+            button.titleLabel?.numberOfLines = 1
+            button.contentEdgeInsets = UIEdgeInsetsMake(0, 14, 0, 14)
+            button.tag = index
+            
+            switch (action.type) {
+            case .delete:
+                button.backgroundColor = theme.colors.destructive
+            case .share:
+                button.backgroundColor = theme.colors.secondaryAction
+            case .save:
+                button.backgroundColor = theme.colors.link
+            case .unsave:
+                button.backgroundColor = self.theme.colors.link
+            }
+            
+            button.addTarget(self, action: #selector(didPerformAction(_:)), for: .touchUpInside)
+            
+            // Wrapper around each button.
+            let wrapper = UIView(frame: .zero)
+            wrapper.clipsToBounds = true
+            wrapper.addSubview(button)
+            self.addSubview(wrapper)
+            maxButtonWidth = max(maxButtonWidth, button.intrinsicContentSize.width)
+        }
         
+        maximumWidth = maxButtonWidth * CGFloat(self.subviews.count)
     }
+
+    public weak var delegate: ActionsViewDelegate?
     
-    required public init?(coder aDecoder: NSCoder) {
-        fatalError("init(coder:) has not been implemented")
+    @objc func didPerformAction(_ sender: UIButton) {
+        let action = actions[sender.tag]
+        delegate?.didPerformAction(action)
     }
+    
 }
diff --git a/WMF Framework/CollectionViewSwipeToEditController.swift b/WMF Framework/CollectionViewSwipeToEditController.swift
index aa30fae7dca..7394fbe8877 100644
--- a/WMF Framework/CollectionViewSwipeToEditController.swift	
+++ b/WMF Framework/CollectionViewSwipeToEditController.swift	
@@ -12,12 +12,6 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
     
     let collectionView: UICollectionView
     
-    var currentState: CollectionViewCellState = .idle {
-        didSet {
-            currentState == .idle ? didEnterIdleState() : didEnterOpenState()
-        }
-    }
-    
     var activeCell: ArticleCollectionViewCell? {
         guard let indexPath = activeIndexPath else {
             return nil
@@ -26,6 +20,7 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
     }
     
     var activeIndexPath: IndexPath?
+    var initialSwipeTranslation: CGFloat = 0
     var activeDirectionIsPrimary: Bool?
     
     public var primaryActions: [CollectionViewCellAction] = []
@@ -86,8 +81,7 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
         
         let position = gestureRecognizer.location(in: collectionView)
         
-        guard let indexPath = collectionView.indexPathForItem(at: position),
-            let cell = collectionView.cellForItem(at: indexPath) as? ArticleCollectionViewCell else {
+        guard let indexPath = collectionView.indexPathForItem(at: position) else {
                 return false
         }
 
@@ -98,6 +92,10 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
             return false
         }
         
+        defer {
+            initialSwipeTranslation = activeCell?.swipeTranslation ?? 0
+        }
+        
         let isPrimary = velocity.x < 0
         
         if indexPath == activeIndexPath && isPrimary != activeDirectionIsPrimary {
@@ -121,13 +119,8 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
             return false
         }
         
-        cell.actions = actions
-        cell.actionsView?.delegate = self
-        
-        activeDirectionIsPrimary = isPrimary
         activeIndexPath = indexPath
-        
-        cell.swipeType = isPrimary ? .primary : .secondary
+        activeCell?.actionsView.actions = primaryActions
         
         return true
     }
@@ -166,19 +159,35 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
         guard let cell = activeCell else {
             return
         }
-        
+        cell.actionsView.delegate = self
+        let deltaX = sender.translation(in: collectionView).x
+        let velocityX = sender.velocity(in: collectionView).x
+        var swipeTranslation = deltaX + initialSwipeTranslation
         switch (sender.state) {
         case .began:
-            let position = sender.location(in: cell)
-            let velocityX = sender.velocity(in: cell).x
-            cell.beginSwipe(with: position, velocity: velocityX)
-            currentState = .open
+            cell.isSwiping = true
+            fallthrough
         case .changed:
-            let position = sender.location(in: cell)
-            let velocityX = sender.velocity(in: cell).x
-            cell.updateSwipe(with: position, velocity: velocityX)
+            if swipeTranslation > 0 {
+                swipeTranslation = sqrt(swipeTranslation)
+            }
+            if abs(swipeTranslation) > abs(cell.actionsView.maximumWidth) {
+                swipeTranslation = 0 - cell.actionsView.maximumWidth - sqrt(abs(swipeTranslation) - abs(cell.actionsView.maximumWidth))
+            }
+            cell.swipeVelocity = velocityX
+            cell.swipeTranslation = swipeTranslation
         case .cancelled:
-            currentState = .idle
+            fallthrough
+        case .failed:
+            fallthrough
+        case .ended:
+            if -swipeTranslation > 0.5 * cell.actionsView.maximumWidth {
+                cell.openActionPane()
+            } else {
+                cell.closeActionPane()
+                activeIndexPath = nil
+            }
+            fallthrough
         default:
             break
         }
@@ -191,7 +200,6 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
         
         switch (sender.state) {
         case .ended:
-            currentState = .idle
             sender.isEnabled = false
             sender.isEnabled = true
         default:
@@ -223,7 +231,7 @@ public class CollectionViewSwipeToEditController: NSObject, UIGestureRecognizerD
     }
     
     func closeActionPane() {
-        currentState = .idle
+
     }
     
 }
diff --git a/Wikipedia/Code/ArticleCollectionViewCell.swift b/Wikipedia/Code/ArticleCollectionViewCell.swift
index 0bc13349f31..dd089377531 100644
--- a/Wikipedia/Code/ArticleCollectionViewCell.swift
+++ b/Wikipedia/Code/ArticleCollectionViewCell.swift
@@ -9,7 +9,8 @@ open class ArticleCollectionViewCell: CollectionViewCell {
     @objc public let imageView = UIImageView()
     @objc public let saveButton = SaveButton()
     @objc public var extractLabel: UILabel?
-
+    @objc public let actionsView = CollectionViewCellActionsView()
+    
     private var kvoButtonTitleContext = 0
     
     open override func setup() {
@@ -26,7 +27,6 @@ open class ArticleCollectionViewCell: CollectionViewCell {
         imageView.isOpaque = true
         saveButton.isOpaque = true
         
-        actionsView = CollectionViewCellActionsView(frame: CGRect.zero, cell: self)
         contentView.addSubview(imageView)
         contentView.addSubview(titleLabel)
         contentView.addSubview(descriptionLabel)
@@ -76,9 +76,9 @@ open class ArticleCollectionViewCell: CollectionViewCell {
         let size = super.sizeThatFits(size, apply: apply)
         if apply {
             contentView.frame = CGRect(origin: CGPoint(x: swipeTranslation, y: 0), size: size)
-            let actionsViewWidth = actionsView?.maximumWidth ?? 0
-            actionsView?.frame = CGRect(x: size.width - actionsViewWidth, y: 0, width: actionsViewWidth, height: size.height)
-            actionsView?.layoutSubviews()
+            let actionsViewWidth = actionsView.maximumWidth
+            actionsView.frame = CGRect(x: size.width - actionsViewWidth, y: 0, width: actionsViewWidth, height: size.height)
+            actionsView.layoutSubviews()
         }
         return size
     }
@@ -168,18 +168,21 @@ open class ArticleCollectionViewCell: CollectionViewCell {
         return self.superview as? UICollectionView
     }
     
-    public var actionsView: CollectionViewCellActionsView?
-    
-    var swipeType: CollectionViewCellSwipeType = .none
-    
-    var swipeInitialFramePosition: CGFloat = 0
-    var swipeStartPosition: CGPoint = .zero
-    var swipePastBounds: Bool = false
-    var deletePending: Bool = false
     var swipeVelocity: CGFloat = 0
-    var originalStartPosition: CGPoint = .zero
-    
-    
+    var isSwiping: Bool = false {
+        didSet {
+            if isSwiping && actionsView.superview == nil {
+                insertSubview(actionsView, belowSubview: contentView)
+                actionsView.layoutSubviews()
+                contentView.backgroundColor = backgroundView?.backgroundColor
+                clipsToBounds = true
+            } else if !isSwiping && actionsView.superview != nil {
+                actionsView.removeFromSuperview()
+                contentView.backgroundColor = .clear
+                clipsToBounds = false
+            }
+        }
+    }
     var swipeTranslation: CGFloat = 0 {
         didSet {
             setNeedsLayout()
@@ -187,55 +190,20 @@ open class ArticleCollectionViewCell: CollectionViewCell {
     }
     
     var minimumSwipeTrackingPosition: CGFloat {
-        guard let actionsView = actionsView else { return 0 }
         return -actionsView.maximumWidth
     }
     
-    public var actions: [CollectionViewCellAction] {
-        get {
-            return self.actionsView?.actions ?? []
-        }
-        set {
-            self.actionsView?.actions = newValue
-        }
-    }
-    
-    var theme: Theme {
-        get {
-            return actionsView?.theme ?? Theme.standard
-        }
-        set {
-            actionsView?.theme = newValue
-        }
-    }
-    
     var actionsViewRect: CGRect {
-        guard let actionsView = actionsView, actionsView.superview != nil else { return .zero }
+        guard actionsView.superview != nil else { return .zero }
         let bounds = actionsView.bounds
         let rect = self.convert(bounds, from: actionsView)
         return rect
     }
     
-    func beginSwipe(with position: CGPoint, velocity: CGFloat) {
-        swipeInitialFramePosition = 0
-        swipeStartPosition = position
-        swipePastBounds = false
-        
-        showActionsView(with: swipeType)
-        UIView.performWithoutAnimation {
-            updateSwipe(with: position, velocity: velocity)
-        }
-    }
-    
-    func updateSwipe(with touchPosition: CGPoint, velocity: CGFloat) {
-  
-    }
-    
     func showActionsView(with swipeType: CollectionViewCellSwipeType) {
         // We don't need to do this if the view is already visible.
-        guard let actionsView = actionsView, actionsView.superview == nil else { return }
+        guard actionsView.superview == nil else { return }
         
-        actionsView.swipeType = swipeType
         insertSubview(actionsView, belowSubview: contentView)
         layoutSubviews()
         actionsView.layoutIfNeeded()
@@ -244,61 +212,36 @@ open class ArticleCollectionViewCell: CollectionViewCell {
     // MARK: Opening & closing action pane
     
     func openActionPane() {
-        // Make sure we don't swipe twice on the same cell.
-        guard let actionsView = actionsView, swipeTranslation >= 0 else { return }
-        
-        clipsToBounds = true
-        
-        let swipeType = actionsView.swipeType
-        
-        showActionsView(with: swipeType)
-        
-        let targetTranslation = swipeType == .primary ? minimumSwipeTrackingPosition : -minimumSwipeTrackingPosition
-        
+        let targetTranslation = 0 - actionsView.maximumWidth
         let totalDistance = swipeTranslation - targetTranslation
         let duration: CGFloat = 0.40
         let springVelocity = abs(swipeVelocity) * duration / totalDistance
         contentView.backgroundColor = backgroundView?.backgroundColor
-        UIView.animate(withDuration: TimeInterval(duration), delay: 0, usingSpringWithDamping: 10, initialSpringVelocity: springVelocity, options: .beginFromCurrentState, animations: {
-            self.swipeTranslation = targetTranslation
+        swipeTranslation = targetTranslation
+        isSwiping = true
+        UIView.animate(withDuration: TimeInterval(duration), delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: springVelocity, options: .beginFromCurrentState, animations: {
             self.layoutIfNeeded()
         }, completion: { (finished: Bool) in
-            actionsView.isUserInteractionEnabled = true
         })
     }
     
     func closeActionPane() {
-        
-        let targetTranslation = swipeType == .primary ? -swipeTranslation : swipeTranslation
-        
-        let totalDistance = targetTranslation
+        let totalDistance = abs(swipeTranslation)
         let duration: CGFloat = 0.40
         let springVelocity = abs(swipeVelocity) * duration / totalDistance
-        
-        UIView.animate(withDuration: TimeInterval(duration), delay: 0, usingSpringWithDamping: 10, initialSpringVelocity: springVelocity, options: .beginFromCurrentState, animations: {
-            self.swipeTranslation = 0
+        swipeTranslation = 0
+        UIView.animate(withDuration: TimeInterval(duration), delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: springVelocity, options: .beginFromCurrentState, animations: {
             self.layoutIfNeeded()
         }, completion: { (finished: Bool) in
-            self.removeActionsView()
-            self.contentView.isUserInteractionEnabled = true
-            self.actionsView?.isUserInteractionEnabled = false
-            self.swipeInitialFramePosition = 0
-            self.clipsToBounds = false
-            self.contentView.backgroundColor = .clear
-
+            self.isSwiping = false
         })
     }
     
-    func removeActionsView() {
-        actionsView?.removeFromSuperview()
-    }
-    
     // MARK: Prepare for reuse
     
     func resetSwipeable() {
-        deletePending = false
-        swipePastBounds = false
         swipeTranslation = 0
+        swipeVelocity = 0
     }
     
 }
