diff --git a/WMF Framework/Widget/WidgetController.swift b/WMF Framework/Widget/WidgetController.swift
index 299d152fb15..e3c512d2687 100644
--- a/WMF Framework/Widget/WidgetController.swift	
+++ b/WMF Framework/Widget/WidgetController.swift	
@@ -181,6 +181,14 @@ public final class WidgetController: NSObject {
 /// When the old widget data loading model is removed, this should be moved out of this extension into the class itself and refactored (e.g. the properties here don't need to be computed).
 public extension WidgetController {
 
+    // MARK: - Computed Properties
+
+    var featuredContentSiteURL: URL {
+        return sharedCache.loadCache().settings.siteURL
+    }
+
+    // MARK: - Utility
+
     /// This is currently unused. It will be useful when we update the main app to also update the widget's cache when it performs any updates to the featured content in the explore feed.
     func updateCacheWith(featuredContent: WidgetFeaturedContent) {
         var updatedCache = sharedCache.loadCache()
@@ -194,8 +202,6 @@ public extension WidgetController {
         sharedCache.saveCache(updatedCache)
     }
 
-    // MARK: - Utility
-
     /// Returns cached content if it's available for the current date in the current app selected language
     private func cachedContentIfAvailable() -> WidgetFeaturedContent? {
         let widgetCache = sharedCache.loadCache()
@@ -208,7 +214,7 @@ public extension WidgetController {
 
     // MARK: - Fetch Featured Content
 
-    func fetchFeaturedContent(useCacheIfAvailable: Bool = true, completion: @escaping (WidgetContentFetcher.FeaturedContentResult) -> Void) {
+    private func fetchFeaturedContent(useCacheIfAvailable: Bool = true, completion: @escaping (WidgetContentFetcher.FeaturedContentResult) -> Void) {
         func performCompletion(result: WidgetContentFetcher.FeaturedContentResult) {
             DispatchQueue.main.async {
                 completion(result)
@@ -237,7 +243,72 @@ public extension WidgetController {
         }
     }
 
-    // MARK: - Fetch Featured Article Widget
+    // MARK: - Fetch Top Read Widget Content
+
+    func fetchTopReadContent(isSnapshot: Bool = false, completion: @escaping (WidgetContentFetcher.TopReadResult) -> Void) {
+        func performCompletion(result: WidgetContentFetcher.TopReadResult) {
+            DispatchQueue.main.async {
+                completion(result)
+            }
+        }
+
+        let fetcher = WidgetContentFetcher.shared
+        var widgetCache = sharedCache.loadCache()
+
+        guard !isSnapshot else {
+            let previewSnapshot = widgetCache.featuredContent ?? WidgetFeaturedContent.previewContent() ?? WidgetFeaturedContent()
+            if let previewTopRead = previewSnapshot.topRead {
+                performCompletion(result: .success(previewTopRead))
+            } else {
+                performCompletion(result: .failure(.contentFailure))
+            }
+            return
+        }
+
+        fetchFeaturedContent { result in
+            switch result {
+            case .success(var featuredContent):
+                if var topRead = featuredContent.topRead {
+                    // Fetch images, if available, for the top four elements
+                    let group = DispatchGroup()
+                    for (index, element) in topRead.topFourElements.enumerated() {
+                        group.enter()
+                        guard let thumbnailImageSource = element.thumbnailImageSource else {
+                            group.leave()
+                            continue
+                        }
+
+                        fetcher.fetchImageDataFrom(imageSource: thumbnailImageSource) { result in
+                            switch result {
+                            case .success(let imageData):
+                                topRead.elements[index].thumbnailImageSource?.data = imageData
+                                group.leave()
+                            case .failure:
+                                group.leave()
+                            }
+                        }
+                    }
+
+                    group.notify(queue: .main) {
+                        featuredContent.topRead = topRead
+                        widgetCache.featuredContent = featuredContent
+                        self.sharedCache.saveCache(widgetCache)
+                        if let featuredTopReadContent = featuredContent.topRead {
+                            performCompletion(result: .success(featuredTopReadContent))
+                        } else {
+                            performCompletion(result: .failure(.contentFailure))
+                        }
+                    }
+                } else {
+                    performCompletion(result: .failure(.contentFailure))
+                }
+            case .failure(let error):
+                performCompletion(result: .failure(error))
+            }
+        }
+    }
+
+    // MARK: - Fetch Featured Article Widget Content
 
     func fetchFeaturedArticleContent(isSnapshot: Bool = false, completion: @escaping (WidgetContentFetcher.FeaturedArticleResult) -> Void) {
         func performCompletion(result: WidgetContentFetcher.FeaturedArticleResult) {
diff --git a/Widgets/Widgets/TopReadWidget.swift b/Widgets/Widgets/TopReadWidget.swift
index 9585f8b538e..554a5eb0ad5 100644
--- a/Widgets/Widgets/TopReadWidget.swift
+++ b/Widgets/Widgets/TopReadWidget.swift
@@ -25,80 +25,51 @@ final class TopReadData {
 
     static let shared = TopReadData()
 
-    let maximumRankedArticles = 4
-
     var placeholder: TopReadEntry {
-        return TopReadEntry(date: Date())
+        return TopReadEntry(isPlaceholder: true, date: Date())
     }
 
-    func fetchLatestAvailableTopRead(usingCache: Bool = false, completion userCompletion: @escaping (TopReadEntry) -> Void) {
+    // MARK: - Public
+
+    func fetchTopReadEntryData(usingCache: Bool = false, completion: @escaping (TopReadEntry) -> Void) {
         let widgetController = WidgetController.shared
-        widgetController.startWidgetUpdateTask(userCompletion) { (dataStore, widgetUpdateTaskCompletion) in
-            widgetController.fetchNewestWidgetContentGroup(with: .topRead, in: dataStore, isNetworkFetchAllowed: !usingCache) { (contentGroup) in
-                guard let contentGroup = contentGroup else {
-                    widgetUpdateTaskCompletion(self.placeholder)
-                    return
+        widgetController.fetchTopReadContent(isSnapshot: usingCache) { result in
+            switch result {
+            case .success(let topReadContent):
+                let topFourElements = topReadContent.topFourElements
+                let layoutDirection: LayoutDirection = (topFourElements.first?.isRTL ?? false) ? .rightToLeft : .leftToRight
+                var rankedElements: [TopReadEntry.RankedElement] = []
+
+                let midnightUTCDate: Date
+                let backupMidnightDate: Date = (Date() as NSDate).wmf_midnightUTCDateFromLocal ?? Date()
+                let utcDateFormatter = DateFormatter.wmf_utcMonthNameDayOfMonthNumber()
+
+                if let dateString = topReadContent.dateString {
+                    midnightUTCDate = utcDateFormatter?.date(from: dateString) ?? backupMidnightDate
+                } else {
+                    midnightUTCDate = backupMidnightDate
                 }
-                self.assembleTopReadFromContentGroup(contentGroup, with: dataStore, usingImageCache: usingCache, completion: widgetUpdateTaskCompletion)
-            }
-        }
-    }
 
-    // MARK: Private
-    
-    private func assembleTopReadFromContentGroup(_ topRead: WMFContentGroup, with dataStore: MWKDataStore, usingImageCache: Bool = false, completion: @escaping (TopReadEntry) -> Void) {
-        guard let articlePreviews = topRead.contentPreview as? [WMFFeedTopReadArticlePreview] else {
-            completion(placeholder)
-            return
-        }
-
-        // The WMFContentGroup can only be accessed synchronously
-        // re-accessing it from the main queue or another queue might lead to unexpected behavior
-        let layoutDirection: LayoutDirection = topRead.isRTL ? .rightToLeft : .leftToRight
-        let groupURL = topRead.url
-        let isCurrent = topRead.isForToday // even though the top read data is from yesterday, the content group is for today
-        var rankedElements: [TopReadEntry.RankedElement] = []
-
-        for articlePreview in articlePreviews {
-            if let fetchedArticle = dataStore.fetchArticle(with: articlePreview.articleURL), let viewCounts = fetchedArticle.pageViewsSortedByDate {
-                let title = fetchedArticle.displayTitle ?? articlePreview.displayTitle
-                let description = fetchedArticle.wikidataDescription ?? articlePreview.wikidataDescription ?? fetchedArticle.snippet ?? articlePreview.snippet ?? ""
-                let rankedElement = TopReadEntry.RankedElement(title: title, description: description, articleURL: articlePreview.articleURL, thumbnailURL: articlePreview.thumbnailURL, viewCounts: viewCounts)
-                rankedElements.append(rankedElement)
-            }
-        }
-
-        rankedElements = Array(rankedElements.prefix(maximumRankedArticles))
+                let groupURL = WMFContentGroup.topReadURL(forSiteURL: widgetController.featuredContentSiteURL, midnightUTCDate: midnightUTCDate)
 
-        let group = DispatchGroup()
+                for rankedElement in topFourElements {
+                    let title = rankedElement.displayTitle.removingHTML
+                    let description = rankedElement.description?.removingHTML ?? ""
+                    let url = URL(string: rankedElement.contentURL.desktop.page)
+                    let viewCounts: [NSNumber] = rankedElement.viewHistory.compactMap { NSNumber(value: $0.views) }
+                    var image: UIImage?
+                    if let imageData = rankedElement.thumbnailImageSource?.data {
+                        image = UIImage(data: imageData)
+                    }
 
-        for (index, element) in rankedElements.enumerated() {
-            group.enter()
-            guard let thumbnailURL = element.thumbnailURL else {
-                group.leave()
-                continue
-            }
-            
-            let fetcher = dataStore.cacheController.imageCache
-            
-            if usingImageCache {
-                if let cachedImage = fetcher.cachedImage(withURL: thumbnailURL) {
-                    rankedElements[index].image = cachedImage.staticImage
+                    let displayElement = TopReadEntry.RankedElement(title: title, description: description, articleURL: url, image: image, viewCounts: viewCounts)
+                    rankedElements.append(displayElement)
                 }
-                group.leave()
-                continue
-            }
-
-            fetcher.fetchImage(withURL: thumbnailURL, failure: { _ in
-                group.leave()
-            }, success: { fetchedImage in
-                rankedElements[index].image = fetchedImage.image.staticImage
-                group.leave()
-            })
-        }
 
-        group.notify(queue: .main) {
-            completion(TopReadEntry(date: Date(), rankedElements: rankedElements, groupURL: groupURL, isCurrent: isCurrent, contentLayoutDirection: layoutDirection))
+                completion(TopReadEntry(date: Date(), rankedElements: rankedElements, groupURL: groupURL, contentLayoutDirection: layoutDirection))
+            case .failure:
+                completion(self.placeholder)
+            }
         }
     }
 
@@ -114,14 +85,14 @@ struct TopReadEntry: TimelineEntry {
         let description: String
         var articleURL: URL? = nil
         var image: UIImage? = nil
-        var thumbnailURL: URL? = nil
         let viewCounts: [NSNumber]
     }
 
+    var isPlaceholder: Bool = false
+
     let date: Date // for Timeline Entry
     var rankedElements: [RankedElement] = Array(repeating: RankedElement.init(title: "–", description: "–", image: nil, viewCounts: [.init(floatLiteral: 0)]), count: 4)
     var groupURL: URL? = nil
-    var isCurrent: Bool = false
     var contentLayoutDirection: LayoutDirection = .leftToRight
 }
 
@@ -144,22 +115,24 @@ struct TopReadProvider: TimelineProvider {
     }
 
     func getTimeline(in context: Context, completion: @escaping (Timeline<TopReadEntry>) -> Void) {
-        dataStore.fetchLatestAvailableTopRead { entry in
-            let isError = entry.groupURL == nil || !entry.isCurrent
+        dataStore.fetchTopReadEntryData { entry in
             let nextUpdate: Date
             let currentDate = Date()
-            if !isError {
-                nextUpdate = currentDate.randomDateShortlyAfterMidnight() ?? currentDate
-            } else {
+
+            // Schedule an earlier refresh if this is placeholder content or not valid for today
+            if entry.isPlaceholder || !(entry.date as NSDate).wmf_UTCDateIsTodayLocal() {
                 let components = DateComponents(hour: 2)
                 nextUpdate = Calendar.current.date(byAdding: components, to: currentDate) ?? currentDate
+            } else {
+                nextUpdate = currentDate.randomDateShortlyAfterMidnight() ?? currentDate
             }
+
             completion(Timeline(entries: [entry], policy: .after(nextUpdate)))
         }
     }
 
     func getSnapshot(in context: Context, completion: @escaping (TopReadEntry) -> Void) {
-        dataStore.fetchLatestAvailableTopRead(usingCache: context.isPreview) { (entry) in
+        dataStore.fetchTopReadEntryData(usingCache: context.isPreview) { entry in
             completion(entry)
         }
     }
