diff --git a/Wikipedia/Code/MWKDataStore.h b/Wikipedia/Code/MWKDataStore.h
index 5ecf278d720..d97559b944c 100644
--- a/Wikipedia/Code/MWKDataStore.h
+++ b/Wikipedia/Code/MWKDataStore.h
@@ -188,4 +188,6 @@ extern NSString* const MWKArticleKey;
 - (void)startCacheRemoval;
 - (void)stopCacheRemoval;
 
+- (NSArray *)legacyImageURLsForArticle:(MWKArticle *)article;
+
 @end
diff --git a/Wikipedia/Code/MWKDataStore.m b/Wikipedia/Code/MWKDataStore.m
index 85cbac22feb..682009fd611 100644
--- a/Wikipedia/Code/MWKDataStore.m
+++ b/Wikipedia/Code/MWKDataStore.m
@@ -507,17 +507,8 @@ - (void)removeTitlesFromCache:(NSArray*)titlesToRemove {
     });
 }
 
-#pragma mark - Deletion
-
-- (NSError*)removeFolderAtBasePath {
-    NSError* err;
-    [[NSFileManager defaultManager] removeItemAtPath:self.basePath error:&err];
-    return err;
-}
-
-- (void)deleteArticle:(MWKArticle*)article {
+- (NSArray *)legacyImageURLsForArticle:(MWKArticle *)article {
     NSString* path = [self pathForArticle:article];
-    
     NSDictionary *legacyImageDictionary = [NSDictionary dictionaryWithContentsOfFile:[path stringByAppendingPathComponent:@"Images.plist"]];
     if ([legacyImageDictionary isKindOfClass:[NSDictionary class]]) {
         NSArray *legacyImageURLStrings = [legacyImageDictionary objectForKey:@"entries"];
@@ -529,10 +520,25 @@ - (void)deleteArticle:(MWKArticle*)article {
                     return nil;
                 }
             }];
-            [[WMFImageController sharedInstance] deleteImagesWithURLs:legacyImageURLs];
+            return legacyImageURLs;
         }
     }
+    return @[];
+}
 
+#pragma mark - Deletion
+
+- (NSError*)removeFolderAtBasePath {
+    NSError* err;
+    [[NSFileManager defaultManager] removeItemAtPath:self.basePath error:&err];
+    return err;
+}
+
+- (void)deleteArticle:(MWKArticle*)article {
+    NSString* path = [self pathForArticle:article];
+
+    [[WMFImageController sharedInstance] deleteImagesWithURLs:[self legacyImageURLsForArticle:article]];
+    
     // delete article images *before* metadata (otherwise we won't be able to retrieve image lists)
     [[WMFImageController sharedInstance] deleteImagesWithURLs:[[article allImageURLs] allObjects]];
 
diff --git a/Wikipedia/Code/SavedArticlesFetcher.m b/Wikipedia/Code/SavedArticlesFetcher.m
index 83d9414e4c7..cb2b2a7ccb2 100644
--- a/Wikipedia/Code/SavedArticlesFetcher.m
+++ b/Wikipedia/Code/SavedArticlesFetcher.m
@@ -192,58 +192,26 @@ - (void)downloadImageDataForArticle:(MWKArticle*)article failure:(WMFErrorHandle
 
 - (void)migrateLegacyImagesInArticle:(MWKArticle *)article {
     //  Removes up old saved article image list folders, copies old cached images to original and article image width locations. This ensures articles saved with 5.0.4 and older will still have images availble offline in 5.0.5. The migration is idempotent - the enumerated folders are removed so they won't be processed the next time around.
-    
-    //Get the folder that contains legacy saved article images for example - articles/Barack_Obama/Images/
-    NSString *imagesFolderPath = [self.savedPageList.dataStore pathForImagesWithTitle:article.title];
-    NSURL *imagesFolderURL = [NSURL fileURLWithPath:imagesFolderPath isDirectory:YES];
-    NSEnumerator *enumerator = [[NSFileManager defaultManager] enumeratorAtURL:imagesFolderURL includingPropertiesForKeys:@[NSURLIsDirectoryKey] options:NSDirectoryEnumerationSkipsSubdirectoryDescendants errorHandler:^BOOL(NSURL * _Nonnull url, NSError * _Nonnull error) {
-        DDLogError(@"Error enumerating image directory: %@", error);
-        return YES;
-    }];
-    
     WMFImageController *imageController = [WMFImageController sharedInstance];
+    NSArray *legacyImageURLs = [self.savedPageList.dataStore legacyImageURLsForArticle:article];
     NSUInteger articleImageWidth = [[UIScreen mainScreen] wmf_articleImageWidthForScale];
-    NSFileManager *fileManager = [NSFileManager defaultManager];
-    
-    for (NSURL *imageFolderURL in enumerator) { //Enumerate each subfolder of the image folder. There is one subfolder per saved image.
-        NSNumber *isDirectoryNumber = nil;
-        NSError *isDirectoryError = nil;
-        if (![imageFolderURL getResourceValue:&isDirectoryNumber forKey:NSURLIsDirectoryKey error:&isDirectoryError]) {
-            DDLogError(@"Error reading from article image cache: %@", isDirectoryError);
-            continue;
-        }
-        
-        if (![isDirectoryNumber boolValue]) {
-            continue;
-        }
-        
-        NSURL *imagePlistURL = [imageFolderURL URLByAppendingPathComponent:@"Image.plist"];
-        NSDictionary *imageDictionary = [NSDictionary dictionaryWithContentsOfURL:imagePlistURL];
-        if (![imageDictionary isKindOfClass:[NSDictionary class]]) {
-            continue;
-        }
-        
-        NSString *imageURLString = imageDictionary[@"sourceURL"];
-        if (![imageURLString isKindOfClass:[NSString class]]) {
-            continue;
-        }
-        
-        NSUInteger width = WMFParseSizePrefixFromSourceURL(imageURLString);
+    for (NSURL *legacyImageURL in legacyImageURLs) {
+        NSString *legacyImageURLString = legacyImageURL.absoluteString;
+        NSUInteger width = WMFParseSizePrefixFromSourceURL(legacyImageURLString);
         if (width != articleImageWidth && width != NSNotFound) {
-            NSURL *imageURL = [NSURL URLWithString:imageURLString];
-            if (imageURL != nil && [imageController hasDataOnDiskForImageWithURL:imageURL]) {
-                NSURL *cachedFileURL = [NSURL fileURLWithPath:[imageController cachePathForImageWithURL:imageURL] isDirectory:NO];
+            if (legacyImageURL != nil && [imageController hasDataOnDiskForImageWithURL:legacyImageURL]) {
+                NSURL *cachedFileURL = [NSURL fileURLWithPath:[imageController cachePathForImageWithURL:legacyImageURL] isDirectory:NO];
                 if (cachedFileURL != nil) {
-                    NSString *imageExtension = [imageURL pathExtension];
+                    NSString *imageExtension = [legacyImageURL pathExtension];
                     NSString *imageMIMEType = [imageExtension wmf_asMIMEType];
                     
-                    NSString *imageURLStringAtArticleWidth = WMFChangeImageSourceURLSizePrefix(imageURLString, articleImageWidth);
+                    NSString *imageURLStringAtArticleWidth = WMFChangeImageSourceURLSizePrefix(legacyImageURLString, articleImageWidth);
                     NSURL *imageURLAtArticleWidth = [NSURL URLWithString:imageURLStringAtArticleWidth];
                     if (imageURLAtArticleWidth != nil && ![imageController hasDataOnDiskForImageWithURL:imageURLAtArticleWidth]) {
                         [imageController cacheImageFromFileURL:cachedFileURL forURL:imageURLAtArticleWidth MIMEType:imageMIMEType];
                     }
                     
-                    NSString *originalImageURLString = WMFOriginalImageURLStringFromURLString(imageURLString);
+                    NSString *originalImageURLString = WMFOriginalImageURLStringFromURLString(legacyImageURLString);
                     NSURL *originalImageURL = [NSURL URLWithString:originalImageURLString];
                     if (![imageController hasDataOnDiskForImageWithURL:originalImageURL]) {
                         [imageController cacheImageFromFileURL:cachedFileURL forURL:originalImageURL MIMEType:imageMIMEType];
@@ -251,15 +219,6 @@ - (void)migrateLegacyImagesInArticle:(MWKArticle *)article {
                 }
             }
         }
-        
-        //if this is the article image, don't delete it because it should be preserved
-        BOOL isArticleImage = [article.imageURL isEqualToString:imageURLString];
-        if (!isArticleImage) {
-            NSError *removalError = nil;
-            if (![fileManager removeItemAtURL:imageFolderURL error:&removalError]) {
-                DDLogError(@"Error removing old image list image: %@", removalError);
-            }
-        }
     }
 }
 
