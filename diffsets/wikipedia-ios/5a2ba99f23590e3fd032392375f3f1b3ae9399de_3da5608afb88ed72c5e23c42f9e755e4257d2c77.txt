diff --git a/MediaWikiKit/MediaWikiKit/MWKArticle.h b/MediaWikiKit/MediaWikiKit/MWKArticle.h
index eeaf166b69f..30c809183bd 100644
--- a/MediaWikiKit/MediaWikiKit/MWKArticle.h
+++ b/MediaWikiKit/MediaWikiKit/MWKArticle.h
@@ -57,6 +57,7 @@ static const NSInteger kMWKArticleSectionNone = -1;
 @property (readwrite, copy, nonatomic) NSString* imageURL;       // optional; pulled in article request
 
 @property (readonly, copy, nonatomic) NSString* entityDescription;            // optional; currently pulled separately via wikidata
+@property (readonly, copy, nonatomic) NSString* searchSnippet; //Snippet returned from search results
 
 @property (readonly, strong, nonatomic) MWKSectionList* sections;
 
@@ -66,6 +67,7 @@ static const NSInteger kMWKArticleSectionNone = -1;
 
 - (instancetype)initWithTitle:(MWKTitle*)title dataStore:(MWKDataStore*)dataStore;
 - (instancetype)initWithTitle:(MWKTitle*)title dataStore:(MWKDataStore*)dataStore dict:(NSDictionary*)dict;
+- (instancetype)initWithTitle:(MWKTitle*)title dataStore:(MWKDataStore*)dataStore searchResultsDict:(NSDictionary*)dict;
 
 /**
  * Import article and section metadata (and text if available)
@@ -88,6 +90,13 @@ static const NSInteger kMWKArticleSectionNone = -1;
  */
 - (MWKImage*)importImageData:(NSData*)data image:(MWKImage*)image;
 
+/**
+ *  Loads the image in the "thumbnailURL" property from disk
+ *  if it has been cached.
+ */
+- (void)loadThumbnailFromDisk;
+
+
 - (BOOL)isEqualToArticle:(MWKArticle*)article;
 - (BOOL)isDeeplyEqualToArticle:(MWKArticle*)article;
 
diff --git a/MediaWikiKit/MediaWikiKit/MWKArticle.m b/MediaWikiKit/MediaWikiKit/MWKArticle.m
index 18a68356c98..b60f71a185d 100644
--- a/MediaWikiKit/MediaWikiKit/MWKArticle.m
+++ b/MediaWikiKit/MediaWikiKit/MWKArticle.m
@@ -37,6 +37,7 @@ @interface MWKArticle ()
 @property (readwrite, assign, nonatomic, getter = isMain) BOOL main;
 
 @property (readwrite, copy, nonatomic) NSString* entityDescription;            // optional; currently pulled separately via wikidata
+@property (readwrite, copy, nonatomic) NSString* snippet;
 
 @property (readwrite, strong, nonatomic) MWKSectionList* sections;
 
@@ -67,6 +68,17 @@ - (instancetype)initWithTitle:(MWKTitle*)title dataStore:(MWKDataStore*)dataStor
     return self;
 }
 
+- (instancetype)initWithTitle:(MWKTitle*)title dataStore:(MWKDataStore*)dataStore searchResultsDict:(NSDictionary*)dict{
+    self = [self initWithTitle:title dataStore:dataStore];
+    if (self) {
+        self.entityDescription = [self optionalString:@"description" dict:dict];
+        self.snippet = [self optionalString:@"snippet" dict:dict];
+    }
+    
+    return self;
+}
+
+
 #pragma mark - NSObject
 
 - (BOOL)isEqual:(id)object {
@@ -156,7 +168,6 @@ - (void)importMobileViewJSON:(NSDictionary*)dict {
     self.redirected        = [self optionalTitle:@"redirected" dict:dict];
     self.displaytitle      = [self optionalString:@"displaytitle" dict:dict];
     self.entityDescription = [self optionalString:@"description" dict:dict];
-
     // From mobileview API...
     if (dict[@"thumb"]) {
         self.imageURL = dict[@"thumb"][@"url"]; // optional
@@ -227,6 +238,40 @@ - (MWKImage*)imageWithURL:(NSString*)url {
     return [self.dataStore imageWithURL:url article:self];
 }
 
+- (void)loadThumbnailFromDisk{
+    
+    /**
+     *  The folowing logic was pulled from the Article Fetcher
+     *  Putting it here to being to coalesce populating Article data
+     *  in a single place. This will be addressed natuarlly as we
+     *  refactor model class mapping in the network layer.
+     */
+    if(!self.thumbnailURL){
+        return;
+    }
+    
+    if ([[self existingImageWithURL:self.thumbnailURL] isCached]) {
+        return;
+    }
+
+    NSString* cacheFilePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)
+                                firstObject]
+                               stringByAppendingPathComponent:self.thumbnailURL.lastPathComponent];
+    BOOL isDirectory      = NO;
+    BOOL cachedFileExists = [[NSFileManager defaultManager] fileExistsAtPath:cacheFilePath
+                                                                 isDirectory:&isDirectory];
+    if (cachedFileExists) {
+        NSError* error = nil;
+        NSData* data   = [NSData dataWithContentsOfFile:cacheFilePath options:0 error:&error];
+        if (!error) {
+            // Copy Search/Nearby thumb binary to core data store so it doesn't have to be re-downloaded.
+            MWKImage* image = [self importImageURL:self.thumbnailURL sectionId:kMWKArticleSectionNone];
+            [self importImageData:data image:image];
+        }
+    }
+}
+
+
 /**
  * Return image object if folder for that image exists
  * else return nil
diff --git a/PromiseKit/PromiseKit.h b/PromiseKit/PromiseKit.h
new file mode 100755
index 00000000000..06e599fedc7
--- /dev/null
+++ b/PromiseKit/PromiseKit.h
@@ -0,0 +1,707 @@
+
+/**
+ *  Unable to add as a Pod in iOS 7
+ *  See for details: https://github.com/PromiseKit/EZiOS7
+ *
+ */
+
+#define PMKEZBake
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-w"
+#import <Foundation/NSObjCRuntime.h>
+#import <Foundation/NSString.h>
+
+FOUNDATION_EXPORT double PromiseKitVersionNumber;
+FOUNDATION_EXPORT const unsigned char PromiseKitVersionString[];
+
+extern NSString * const PMKErrorDomain;
+
+#define PMKFailingPromiseIndexKey @"PMKFailingPromiseIndexKey"
+#define PMKURLErrorFailingURLResponseKey @"PMKURLErrorFailingURLResponseKey"
+#define PMKURLErrorFailingDataKey @"PMKURLErrorFailingDataKey"
+#define PMKURLErrorFailingStringKey @"PMKURLErrorFailingStringKey"
+#define PMKJSONErrorJSONObjectKey @"PMKJSONErrorJSONObjectKey"
+
+#define PMKUnexpectedError 1l
+#define PMKUnknownError 2l
+#define PMKInvalidUsageError 3l
+#define PMKAccessDeniedError 4l
+#define PMKOperationCancelled 5l
+#define PMKNotFoundError 6l
+#define PMKJSONError 7l
+#define PMKOperationFailed 8l
+#define PMKTaskError 9l
+
+#define PMKTaskErrorLaunchPathKey @"PMKTaskErrorLaunchPathKey"
+#define PMKTaskErrorArgumentsKey @"PMKTaskErrorArgumentsKey"
+#define PMKTaskErrorStandardOutputKey @"PMKTaskErrorStandardOutputKey"
+#define PMKTaskErrorStandardErrorKey @"PMKTaskErrorStandardErrorKey"
+#define PMKTaskErrorExitStatusKey @"PMKTaskErrorExitStatusKey"
+#import <dispatch/object.h>
+#import <dispatch/queue.h>
+#import <Foundation/NSObject.h>
+
+typedef void (^PMKResolver)(id);
+
+typedef NS_ENUM(NSInteger, PMKCatchPolicy) {
+    PMKCatchPolicyAllErrors,
+    PMKCatchPolicyAllErrorsExceptCancellation
+};
+
+
+
+#if defined(PMKEZBake) && defined(SWIFT_CLASS)
+  // https://github.com/PromiseKit/EZiOS7/issues/2
+  #define PMKPromise AnyPromise
+#else
+
+__attribute__((objc_runtime_name("PMKAnyPromise")))
+__attribute__((objc_subclassing_restricted))
+@interface PMKPromise : NSObject
+@property (nonatomic, readonly) BOOL pending;
+@property (nonatomic, readonly) BOOL resolved;
+@property (nonatomic, readonly) BOOL fulfilled;
+@property (nonatomic, readonly) BOOL rejected;
+@end
+
+@compatibility_alias AnyPromise PMKPromise;
+
+#endif
+
+
+
+/**
+ @see AnyPromise.swift
+*/
+@interface AnyPromise (objc)
+
+/**
+ The provided block is executed when its receiver is resolved.
+
+ If you provide a block that takes a parameter, the value of the receiver will be passed as that parameter.
+
+ @param block The block that is executed when the receiver is resolved.
+
+    [NSURLConnection GET:url].then(^(NSData *data){
+        // do something with data
+    });
+
+ @return A new promise that is resolved with the value returned from the provided block. For example:
+
+    [NSURLConnection GET:url].then(^(NSData *data){
+        return data.length;
+    }).then(^(NSNumber *number){
+        //…
+    });
+
+ @warning *Important* The block passed to `then` may take zero, one, two or three arguments, and return an object or return nothing. This flexibility is why the method signature for then is `id`, which means you will not get completion for the block parameter, and must type it yourself. It is safe to type any block syntax here, so to start with try just: `^{}`.
+
+ @warning *Important* If an exception is thrown inside your block, or you return an `NSError` object the next `Promise` will be rejected. See `catch` for documentation on error handling.
+
+ @warning *Important* `then` is always executed on the main queue.
+
+ @see thenOn
+ @see thenInBackground
+*/
+- (AnyPromise *(^)(id))then;
+
+
+/**
+ The provided block is executed on the default queue when the receiver is fulfilled.
+
+ This method is provided as a convenience for `thenOn`.
+
+ @see then
+ @see thenOn
+*/
+- (AnyPromise *(^)(id))thenInBackground;
+
+/**
+ The provided block is executed on the dispatch queue of your choice when the receiver is fulfilled.
+
+ @see then
+ @see thenInBackground
+*/
+- (AnyPromise *(^)(dispatch_queue_t, id))thenOn;
+
+#ifndef __cplusplus
+/**
+ The provided block is executed when the receiver is rejected.
+
+ Provide a block of form `^(NSError *){}` or simply `^{}`. The parameter has type `id` to give you the freedom to choose either.
+
+ The provided block always runs on the main queue.
+ 
+ @warning *Note* Cancellation errors are not caught.
+ 
+ @warning *Note* Since catch is a c++ keyword, this method is not availble in Objective-C++ files. Instead use catchWithPolicy.
+
+ @see catchWithPolicy
+*/
+- (AnyPromise *(^)(id))catch;
+#endif
+
+/**
+ The provided block is executed when the receiver is rejected with the specified policy.
+
+ @param policy The policy with which to catch. Either for all errors, or all errors *except* cancellation errors.
+
+ @see catch
+*/
+- (AnyPromise *(^)(PMKCatchPolicy, id))catchWithPolicy;
+
+/**
+ The provided block is executed when the receiver is resolved.
+
+ The provided block always runs on the main queue.
+
+ @see finallyOn
+*/
+- (AnyPromise *(^)(dispatch_block_t))finally;
+
+/**
+ The provided block is executed on the dispatch queue of your choice when the receiver is resolved.
+
+ @see finally
+ */
+- (AnyPromise *(^)(dispatch_queue_t, dispatch_block_t))finallyOn;
+
+/**
+ The value of the asynchronous task this promise represents.
+
+ A promise has `nil` value if the asynchronous task it represents has not
+ finished. If the value is `nil` the promise is still `pending`.
+
+ @warning *Note* Our Swift variant’s value property returns nil if the
+ promise is rejected where AnyPromise will return the error object. This
+ fits with the pattern where AnyPromise is not strictly typed and is more
+ dynamic, but you should be aware of the distinction.
+
+ @return If `resolved`, the object that was used to resolve this promise;
+ if `pending`, nil.
+*/
+- (id)value;
+
+/**
+ Creates a resolved promise.
+
+ When developing your own promise systems, it is ocassionally useful to be able to return an already resolved promise.
+
+ @param value The value with which to resolve this promise. Passing an `NSError` will cause the promise to be rejected, otherwise the promise will be fulfilled.
+
+ @return A resolved promise.
+*/
++ (instancetype)promiseWithValue:(id)value;
+
+/**
+ Create a new promise that resolves with the provided block.
+
+ Use this method when wrapping asynchronous code that does *not* use
+ promises so that this code can be used in promise chains.
+ 
+ If `resolve` is called with an `NSError` object, the promise is
+ rejected, otherwise the promise is fulfilled.
+
+ Don’t use this method if you already have promises! Instead, just
+ return your promise.
+
+ Should you need to fulfill a promise but have no sensical value to use:
+ your promise is a `void` promise: fulfill with `nil`.
+
+ The block you pass is executed immediately on the calling thread.
+
+ @param block The provided block is immediately executed, inside the block
+ call `resolve` to resolve this promise and cause any attached handlers to
+ execute. If you are wrapping a delegate-based system, we recommend
+ instead to use: promiseWithResolver:
+
+ @return A new promise.
+ 
+ @warning *Important* Resolving a promise with `nil` fulfills it.
+
+ @see http://promisekit.org/sealing-your-own-promises/
+ @see http://promisekit.org/wrapping-delegation/
+*/
++ (instancetype)promiseWithResolverBlock:(void (^)(PMKResolver resolve))resolverBlock;
+
+/**
+ Create a new promise with an associated resolver.
+
+ Use this method when wrapping asynchronous code that does *not* use
+ promises so that this code can be used in promise chains. Generally,
+ prefer resolverWithBlock: as the resulting code is more elegant.
+
+    PMKResolver resolve;
+    AnyPromise *promise = [AnyPromise promiseWithResolver:&resolve];
+
+    // later
+    resolve(@"foo");
+
+ @param resolver A reference to a block pointer of PMKResolver type.
+ You can then call your resolver to resolve this promise.
+
+ @return A new promise.
+
+ @warning *Important* The resolver strongly retains the promise.
+
+ @see promiseWithResolverBlock:
+*/
+- (instancetype)initWithResolver:(PMKResolver __strong *)resolver;
+
+@end
+
+
+
+@interface AnyPromise (Unavailable)
+
+- (instancetype)init __attribute__((unavailable("It is illegal to create an unresolvable promise.")));
++ (instancetype)new __attribute__((unavailable("It is illegal to create an unresolvable promise.")));
+
+@end
+
+
+
+typedef void (^PMKAdapter)(id, NSError *);
+typedef void (^PMKIntegerAdapter)(NSInteger, NSError *);
+typedef void (^PMKBooleanAdapter)(BOOL, NSError *);
+
+@interface AnyPromise (Adapters)
+
+/**
+ Create a new promise by adapting an existing asynchronous system.
+
+ The pattern of a completion block that passes two parameters, the first
+ the result and the second an `NSError` object is so common that we
+ provide this convenience adapter to make wrapping such systems more
+ elegant.
+
+    return [PMKPromise promiseWithAdapter:^(PMKAdapter adapter){
+        PFQuery *query = [PFQuery …];
+        [query findObjectsInBackgroundWithBlock:adapter];
+    }];
+
+ @warning *Important* If both parameters are nil, the promise fulfills,
+ if both are non-nil the promise rejects. This is per the convention.
+
+ @see http://promisekit.org/sealing-your-own-promises/
+ */
++ (instancetype)promiseWithAdapterBlock:(void (^)(PMKAdapter adapter))block;
+
+/**
+ Create a new promise by adapting an existing asynchronous system.
+
+ Adapts asynchronous systems that complete with `^(NSInteger, NSError *)`.
+ NSInteger will cast to enums provided the enum has been wrapped with
+ `NS_ENUM`. All of Apple’s enums are, so if you find one that hasn’t you
+ may need to make a pull-request.
+
+ @see promiseWithAdapter
+ */
++ (instancetype)promiseWithIntegerAdapterBlock:(void (^)(PMKIntegerAdapter adapter))block;
+
+/**
+ Create a new promise by adapting an existing asynchronous system.
+
+ Adapts asynchronous systems that complete with `^(BOOL, NSError *)`.
+
+ @see promiseWithAdapter
+ */
++ (instancetype)promiseWithBooleanAdapterBlock:(void (^)(PMKBooleanAdapter adapter))block;
+
+@end
+
+
+
+/**
+ Whenever resolving a promise you may resolve with a tuple, eg.
+ returning from a `then` or `catch` handler or resolving a new promise.
+
+ Consumers of your Promise are not compelled to consume any arguments and
+ in fact will often only consume the first parameter. Thus ensure the
+ order of parameters is: from most-important to least-important.
+
+ Currently PromiseKit limits you to THREE parameters to the manifold.
+*/
+#define PMKManifold(...) __PMKManifold(__VA_ARGS__, 3, 2, 1)
+#define __PMKManifold(_1, _2, _3, N, ...) __PMKArrayWithCount(N, _1, _2, _3)
+extern id __PMKArrayWithCount(NSUInteger, ...);
+@import Foundation.NSPointerArray;
+
+#if TARGET_OS_IPHONE
+    #define NSPointerArrayMake(N) ({ \
+        NSPointerArray *aa = [NSPointerArray strongObjectsPointerArray]; \
+        aa.count = N; \
+        aa; \
+    })
+#else
+    static inline NSPointerArray *NSPointerArrayMake(NSUInteger count) {
+      #pragma clang diagnostic push
+      #pragma clang diagnostic ignored "-Wdeprecated-declarations"
+        NSPointerArray *aa = [[NSPointerArray class] respondsToSelector:@selector(strongObjectsPointerArray)]
+            ? [NSPointerArray strongObjectsPointerArray]
+            : [NSPointerArray pointerArrayWithStrongObjects];
+      #pragma clang diagnostic pop
+        aa.count = count;
+        return aa;
+    }
+#endif
+
+#define IsError(o) [o isKindOfClass:[NSError class]]
+#define IsPromise(o) [o isKindOfClass:[AnyPromise class]]
+
+
+@interface AnyPromise (Swift)
+- (void)pipe:(void (^)(id))body;
+- (AnyPromise *)initWithBridge:(void (^)(PMKResolver))resolver;
++ (void)__consume:(id)obj;
+@end
+
+extern NSError *PMKProcessUnhandledException(id thrown);
+
+// TODO really this is not valid, we should instead nest the errors with NSUnderlyingError
+// since a special error subclass may be being used and we may not setup it up correctly
+// with our copy
+#define NSErrorSupplement(_err, supplements) ({ \
+    NSError *err = _err; \
+    id userInfo = err.userInfo.mutableCopy ?: [NSMutableArray new]; \
+    [userInfo addEntriesFromDictionary:supplements]; \
+    [[[err class] alloc] initWithDomain:err.domain code:err.code userInfo:userInfo]; \
+})
+#import <Foundation/NSError.h>
+
+#if !defined(SWIFT_PASTE)
+# define SWIFT_PASTE_HELPER(x, y) x##y
+# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
+#endif
+
+#if !defined(SWIFT_EXTENSION)
+# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
+#endif
+
+@interface NSError (SWIFT_EXTENSION(PromiseKit))
++ (NSError * __nonnull)cancelledError;
++ (void)registerCancelledErrorDomain:(NSString * __nonnull)domain code:(NSInteger)code;
+@property (nonatomic, readonly) BOOL cancelled;
+@end
+/**
+ This header provides some compatibility for PromiseKit 1.x’s
+ PMKPromise class. It will eventually be deprecated.
+*/
+
+
+typedef void (^PMKFulfiller)(id);
+typedef void (^PMKRejecter)(NSError *);
+
+typedef PMKFulfiller PMKPromiseFulfiller;
+typedef PMKRejecter PMKPromiseRejecter;
+
+#define PMKUnderlyingExceptionKey NSUnderlyingErrorKey
+
+
+
+@interface PMKPromise (BackCompat)
+
+/**
+ Create a new promise that is fulfilled or rejected with the provided
+ blocks.
+
+ Use this method when wrapping asynchronous code that does *not* use
+ promises so that this code can be used in promise chains.
+
+ Don’t use this method if you already have promises! Instead, just
+ return your promise.
+
+ Should you need to fulfill a promise but have no sensical value to use;
+ your promise is a `void` promise: fulfill with `nil`.
+
+ The block you pass is executed immediately on the calling thread.
+
+ @param block The provided block is immediately executed, any exceptions that occur will be caught and cause the returned promise to be rejected.
+
+  - @param fulfill fulfills the returned promise with the provided value
+  - @param reject rejects the returned promise with the provided `NSError`
+
+ @return A new promise.
+
+ @see http://promisekit.org/sealing-your-own-promises/
+ @see http://promisekit.org/wrapping-delegation/
+*/
++ (instancetype)new:(void(^)(PMKFulfiller fulfill, PMKRejecter reject))block __attribute__((deprecated("Use +promiseWithResolverBlock:")));
+
+/**
+ Loops until one or more promises have resolved.
+
+ Because Promises are single-shot, the block to until must return one or more promises. They are then `when`’d. If they succeed the until loop is concluded. If they fail then the @param `catch` handler is executed.
+
+ If the `catch` throws or returns an `NSError` then the loop is ended.
+
+ If the `catch` handler returns a Promise then re-execution of the loop is suspended upon resolution of that Promise. If the Promise succeeds then the loop continues. If it fails the loop ends.
+
+ An example usage is an app starting up that must get data from the Internet before the main ViewController can be shown. You can `until` the poll Promise and in the catch handler decide if the poll should be reattempted or not, perhaps returning a `UIAlertView.promise` allowing the user to choose if they continue or not.
+*/
++ (PMKPromise *)until:(id (^)(void))blockReturningPromises catch:(id)failHandler;
+
+@end
+
+
+
+@import Foundation.NSDate;
+
+@interface PMKPromise (Deprecated)
+
++ (PMKPromise *)when:(id)input __attribute__((deprecated("Use PMKWhen()")));
++ (PMKPromise *)pause:(NSTimeInterval)duration __attribute__((deprecated("Use PMKAfter()")));
++ (PMKPromise *)join:(id)input __attribute__((deprecated("Use PMKJoin()")));
+
+- (PMKPromise *( ^ ) ( id ))thenUnleashZalgo __attribute__((unavailable("If you need this, open a ticket, we will provide it, I just want to say hi.")));
+
++ (PMKPromise *)promiseWithResolver:(PMKResolver)block __attribute__((deprecated("Use +promiseWithResolverBlock:")));
++ (instancetype)promiseWithAdapter:(void (^)(PMKAdapter adapter))block __attribute__((deprecated("Use +promiseWithAdapterBlock:")));
++ (instancetype)promiseWithIntegerAdapter:(void (^)(PMKIntegerAdapter adapter))block __attribute__((deprecated("Use +promiseWithIntegerAdapterBlock:")));
++ (instancetype)promiseWithBooleanAdapter:(void (^)(PMKBooleanAdapter adapter))block __attribute__((deprecated("Use +promiseWithBooleanAdapterBlock:")));
+
+@end
+
+
+
+extern void (^PMKUnhandledErrorHandler)(NSError *) __attribute__((unavailable("Use PMKSetUnhandledErrorHandler()")));
+#import <dispatch/queue.h>
+#import <Foundation/NSDate.h>
+#import <Foundation/NSObject.h>
+
+
+
+/**
+ @return A new promise that resolves after the specified duration.
+
+ @parameter duration The duration in seconds to wait before this promise is resolve.
+
+ For example:
+
+    PMKAfter(1).then(^{
+        //…
+    });
+*/
+extern AnyPromise * __nonnull PMKAfter(NSTimeInterval duration);
+
+
+
+/**
+ `when` is a mechanism for waiting more than one asynchronous task and responding when they are all complete.
+
+ `PMKWhen` accepts varied input. If an array is passed then when those promises fulfill, when’s promise fulfills with an array of fulfillment values. If a dictionary is passed then the same occurs, but when’s promise fulfills with a dictionary of fulfillments keyed as per the input.
+
+ Interestingly, if a single promise is passed then when waits on that single promise, and if a single non-promise object is passed then when fulfills immediately with that object. If the array or dictionary that is passed contains objects that are not promises, then these objects are considered fulfilled promises. The reason we do this is to allow a pattern know as "abstracting away asynchronicity".
+
+ If *any* of the provided promises reject, the returned promise is immediately rejected with that promise’s rejection. The error’s `userInfo` object is supplemented with `PMKFailingPromiseIndexKey`.
+
+ For example:
+
+    PMKWhen(@[promise1, promise2]).then(^(NSArray *results){
+        //…
+    });
+
+ @warning *Important* In the event of rejection the other promises will continue to resolve and as per any other promise will eithe fulfill or reject. This is the right pattern for `getter` style asynchronous tasks, but often for `setter` tasks (eg. storing data on a server), you most likely will need to wait on all tasks and then act based on which have succeeded and which have failed. In such situations use `PMKJoin`.
+
+ @param input The input upon which to wait before resolving this promise.
+
+ @return A promise that is resolved with either:
+
+  1. An array of values from the provided array of promises.
+  2. The value from the provided promise.
+  3. The provided non-promise object.
+
+ @see PMKJoin
+
+*/
+extern AnyPromise * __nonnull PMKWhen(id __nonnull input);
+
+
+
+/**
+ Creates a new promise that resolves only when all provided promises have resolved.
+
+ Typically, you should use `PMKWhen`.
+
+ For example:
+
+    PMKJoin(@[promise1, promise2]).then(^(NSArray *results, NSArray *values, NSArray *errors){
+        //…
+    });
+
+ @warning *Important* This promise is not rejectable. Thus it is up to you to propogate an error if you want any subsequent chain to continue being rejected.
+
+ @param promises An array of promises.
+
+ @return A promise that thens three parameters:
+
+  1) An array of mixed values and errors from the resolved input.
+  2) An array of values from the promises that fulfilled.
+  3) An array of errors from the promises that rejected or nil if all promises fulfilled.
+
+ @see when
+*/
+AnyPromise *__nonnull PMKJoin(NSArray * __nonnull promises);
+
+
+
+/**
+ Literally hangs this thread until the promise has resolved.
+ 
+ Do not use hang… unless you are testing, playing or debugging.
+ 
+ If you use it in production code I will literally and honestly cry like a child.
+ 
+ @return The resolved value of the promise.
+
+ @warning T SAFE. IT IS NOT SAFE. IT IS NOT SAFE. IT IS NOT SAFE. IT IS NO
+*/
+extern id __nullable PMKHang(AnyPromise * __nonnull promise);
+
+
+
+/**
+ Sets the unhandled error handler.
+
+ If a promise is rejected and no catch handler is called in its chain, the
+ provided handler is called. The default handler logs the error.
+
+    PMKSetUnhandledErrorHandler(^(NSError *error){
+        NSLog(@"Unhandled error: %@", error);
+    });
+
+ @warning *Important* The handler is executed on an undefined queue.
+ 
+ @warning *Important* Don’t use promises in your handler, or you risk an
+ infinite error loop.
+ 
+ @warning *Important* This function is totally not thread-safe and if
+ some promise is already executing when you set this the results are
+ undefined (though safe if you are programming safely because either
+ your handler or the previous handler will be called). So do this at
+ application startup and *NOWHERE ELSE!*
+
+ @return The previous unhandled error handler.
+*/
+extern id __nonnull PMKSetUnhandledErrorHandler(void (^__nonnull handler)(NSError * __nonnull));
+
+
+
+/**
+ Sets the unhandled exception handler.
+
+ If an exception is thrown inside an AnyPromise handler it is caught and
+ this handler is executed to determine if the promise is rejected.
+ 
+ The default handler rejects the promise if an NSError or an NSString is
+ thrown.
+ 
+ The default handler in PromiseKit 1.x would reject whatever object was
+ thrown (including nil).
+
+ @warning *Important* This handler is provided to allow you to customize
+ which exceptions cause rejection and which abort. You should either
+ return a fully-formed NSError object or nil. Returning nil causes the
+ exception to be re-thrown.
+
+ @warning *Important* The handler is executed on an undefined queue.
+
+ @warning *Important* This function is thread-safe, but to facilitate this
+ it can only be called once per application lifetime and it must be called
+ before any promise in the app throws an exception. Subsequent calls will
+ silently fail.
+*/
+extern void PMKSetUnhandledExceptionHandler(NSError * __nullable (^__nonnull handler)(id __nullable));
+
+
+
+/**
+ Executes the provided block on a background queue.
+
+ dispatch_promise is a convenient way to start a promise chain where the
+ first step needs to run synchronously on a background queue.
+
+    dispatch_promise(^{
+        return md5(input);
+    }).then(^(NSString *md5){
+        NSLog(@"md5: %@", md5);
+    });
+
+ @param block The block to be executed in the background. Returning an `NSError` will reject the promise, everything else (including void) fulfills the promise.
+
+ @return A promise resolved with the return value of the provided block.
+
+ @see dispatch_async
+*/
+extern AnyPromise * __nonnull dispatch_promise(id __nonnull block);
+
+
+
+/**
+ Executes the provided block on the specified background queue.
+
+    dispatch_promise_on(myDispatchQueue, ^{
+        return md5(input);
+    }).then(^(NSString *md5){
+        NSLog(@"md5: %@", md5);
+    });
+
+ @param block The block to be executed in the background. Returning an `NSError` will reject the promise, everything else (including void) fulfills the promise.
+
+ @return A promise resolved with the return value of the provided block.
+
+ @see dispatch_promise
+*/
+extern AnyPromise * __nonnull dispatch_promise_on(dispatch_queue_t __nonnull queue, id __nonnull block);
+
+
+
+#define PMKJSONDeserializationOptions ((NSJSONReadingOptions)(NSJSONReadingAllowFragments | NSJSONReadingMutableContainers))
+
+#define PMKHTTPURLResponseIsJSON(rsp) [@[@"application/json", @"text/json", @"text/javascript"] containsObject:[rsp MIMEType]]
+#define PMKHTTPURLResponseIsImage(rsp) [@[@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap"] containsObject:[rsp MIMEType]]
+#define PMKHTTPURLResponseIsText(rsp) [[rsp MIMEType] hasPrefix:@"text/"]
+
+
+
+#if defined(__has_include)
+  #if __has_include(<PromiseKit/ACAccountStore+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/AVAudioSession+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CKContainer+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CKDatabase+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CLGeocoder+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CLLocationManager+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/NSNotificationCenter+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/NSTask+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/NSURLConnection+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/MKDirections+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/MKMapSnapshotter+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CALayer+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/SLRequest+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/SKRequest+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/SCNetworkReachability+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIActionSheet+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIAlertView+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIView+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIViewController+AnyPromise.h>)
+  #endif
+#endif
+#pragma clang diagnostic pop
diff --git a/PromiseKit/PromiseKit.m b/PromiseKit/PromiseKit.m
new file mode 100755
index 00000000000..c090c3a05c0
--- /dev/null
+++ b/PromiseKit/PromiseKit.m
@@ -0,0 +1,1338 @@
+@import Foundation;
+#import <Foundation/NSObjCRuntime.h>
+#import <Foundation/NSString.h>
+
+FOUNDATION_EXPORT double PromiseKitVersionNumber;
+FOUNDATION_EXPORT const unsigned char PromiseKitVersionString[];
+
+extern NSString * const PMKErrorDomain;
+
+#define PMKFailingPromiseIndexKey @"PMKFailingPromiseIndexKey"
+#define PMKURLErrorFailingURLResponseKey @"PMKURLErrorFailingURLResponseKey"
+#define PMKURLErrorFailingDataKey @"PMKURLErrorFailingDataKey"
+#define PMKURLErrorFailingStringKey @"PMKURLErrorFailingStringKey"
+#define PMKJSONErrorJSONObjectKey @"PMKJSONErrorJSONObjectKey"
+
+#define PMKUnexpectedError 1l
+#define PMKUnknownError 2l
+#define PMKInvalidUsageError 3l
+#define PMKAccessDeniedError 4l
+#define PMKOperationCancelled 5l
+#define PMKNotFoundError 6l
+#define PMKJSONError 7l
+#define PMKOperationFailed 8l
+#define PMKTaskError 9l
+
+#define PMKTaskErrorLaunchPathKey @"PMKTaskErrorLaunchPathKey"
+#define PMKTaskErrorArgumentsKey @"PMKTaskErrorArgumentsKey"
+#define PMKTaskErrorStandardOutputKey @"PMKTaskErrorStandardOutputKey"
+#define PMKTaskErrorStandardErrorKey @"PMKTaskErrorStandardErrorKey"
+#define PMKTaskErrorExitStatusKey @"PMKTaskErrorExitStatusKey"
+#import <dispatch/object.h>
+#import <dispatch/queue.h>
+#import <Foundation/NSObject.h>
+
+typedef void (^PMKResolver)(id);
+
+typedef NS_ENUM(NSInteger, PMKCatchPolicy) {
+    PMKCatchPolicyAllErrors,
+    PMKCatchPolicyAllErrorsExceptCancellation
+};
+
+
+
+#if defined(PMKEZBake) && defined(SWIFT_CLASS)
+  // https://github.com/PromiseKit/EZiOS7/issues/2
+  #define PMKPromise AnyPromise
+#else
+
+__attribute__((objc_runtime_name("PMKAnyPromise")))
+__attribute__((objc_subclassing_restricted))
+@interface PMKPromise : NSObject
+@property (nonatomic, readonly) BOOL pending;
+@property (nonatomic, readonly) BOOL resolved;
+@property (nonatomic, readonly) BOOL fulfilled;
+@property (nonatomic, readonly) BOOL rejected;
+@end
+
+@compatibility_alias AnyPromise PMKPromise;
+
+#endif
+
+
+
+/**
+ @see AnyPromise.swift
+*/
+@interface AnyPromise (objc)
+
+/**
+ The provided block is executed when its receiver is resolved.
+
+ If you provide a block that takes a parameter, the value of the receiver will be passed as that parameter.
+
+ @param block The block that is executed when the receiver is resolved.
+
+    [NSURLConnection GET:url].then(^(NSData *data){
+        // do something with data
+    });
+
+ @return A new promise that is resolved with the value returned from the provided block. For example:
+
+    [NSURLConnection GET:url].then(^(NSData *data){
+        return data.length;
+    }).then(^(NSNumber *number){
+        //…
+    });
+
+ @warning *Important* The block passed to `then` may take zero, one, two or three arguments, and return an object or return nothing. This flexibility is why the method signature for then is `id`, which means you will not get completion for the block parameter, and must type it yourself. It is safe to type any block syntax here, so to start with try just: `^{}`.
+
+ @warning *Important* If an exception is thrown inside your block, or you return an `NSError` object the next `Promise` will be rejected. See `catch` for documentation on error handling.
+
+ @warning *Important* `then` is always executed on the main queue.
+
+ @see thenOn
+ @see thenInBackground
+*/
+- (AnyPromise *(^)(id))then;
+
+
+/**
+ The provided block is executed on the default queue when the receiver is fulfilled.
+
+ This method is provided as a convenience for `thenOn`.
+
+ @see then
+ @see thenOn
+*/
+- (AnyPromise *(^)(id))thenInBackground;
+
+/**
+ The provided block is executed on the dispatch queue of your choice when the receiver is fulfilled.
+
+ @see then
+ @see thenInBackground
+*/
+- (AnyPromise *(^)(dispatch_queue_t, id))thenOn;
+
+#ifndef __cplusplus
+/**
+ The provided block is executed when the receiver is rejected.
+
+ Provide a block of form `^(NSError *){}` or simply `^{}`. The parameter has type `id` to give you the freedom to choose either.
+
+ The provided block always runs on the main queue.
+ 
+ @warning *Note* Cancellation errors are not caught.
+ 
+ @warning *Note* Since catch is a c++ keyword, this method is not availble in Objective-C++ files. Instead use catchWithPolicy.
+
+ @see catchWithPolicy
+*/
+- (AnyPromise *(^)(id))catch;
+#endif
+
+/**
+ The provided block is executed when the receiver is rejected with the specified policy.
+
+ @param policy The policy with which to catch. Either for all errors, or all errors *except* cancellation errors.
+
+ @see catch
+*/
+- (AnyPromise *(^)(PMKCatchPolicy, id))catchWithPolicy;
+
+/**
+ The provided block is executed when the receiver is resolved.
+
+ The provided block always runs on the main queue.
+
+ @see finallyOn
+*/
+- (AnyPromise *(^)(dispatch_block_t))finally;
+
+/**
+ The provided block is executed on the dispatch queue of your choice when the receiver is resolved.
+
+ @see finally
+ */
+- (AnyPromise *(^)(dispatch_queue_t, dispatch_block_t))finallyOn;
+
+/**
+ The value of the asynchronous task this promise represents.
+
+ A promise has `nil` value if the asynchronous task it represents has not
+ finished. If the value is `nil` the promise is still `pending`.
+
+ @warning *Note* Our Swift variant’s value property returns nil if the
+ promise is rejected where AnyPromise will return the error object. This
+ fits with the pattern where AnyPromise is not strictly typed and is more
+ dynamic, but you should be aware of the distinction.
+
+ @return If `resolved`, the object that was used to resolve this promise;
+ if `pending`, nil.
+*/
+- (id)value;
+
+/**
+ Creates a resolved promise.
+
+ When developing your own promise systems, it is ocassionally useful to be able to return an already resolved promise.
+
+ @param value The value with which to resolve this promise. Passing an `NSError` will cause the promise to be rejected, otherwise the promise will be fulfilled.
+
+ @return A resolved promise.
+*/
++ (instancetype)promiseWithValue:(id)value;
+
+/**
+ Create a new promise that resolves with the provided block.
+
+ Use this method when wrapping asynchronous code that does *not* use
+ promises so that this code can be used in promise chains.
+ 
+ If `resolve` is called with an `NSError` object, the promise is
+ rejected, otherwise the promise is fulfilled.
+
+ Don’t use this method if you already have promises! Instead, just
+ return your promise.
+
+ Should you need to fulfill a promise but have no sensical value to use:
+ your promise is a `void` promise: fulfill with `nil`.
+
+ The block you pass is executed immediately on the calling thread.
+
+ @param block The provided block is immediately executed, inside the block
+ call `resolve` to resolve this promise and cause any attached handlers to
+ execute. If you are wrapping a delegate-based system, we recommend
+ instead to use: promiseWithResolver:
+
+ @return A new promise.
+ 
+ @warning *Important* Resolving a promise with `nil` fulfills it.
+
+ @see http://promisekit.org/sealing-your-own-promises/
+ @see http://promisekit.org/wrapping-delegation/
+*/
++ (instancetype)promiseWithResolverBlock:(void (^)(PMKResolver resolve))resolverBlock;
+
+/**
+ Create a new promise with an associated resolver.
+
+ Use this method when wrapping asynchronous code that does *not* use
+ promises so that this code can be used in promise chains. Generally,
+ prefer resolverWithBlock: as the resulting code is more elegant.
+
+    PMKResolver resolve;
+    AnyPromise *promise = [AnyPromise promiseWithResolver:&resolve];
+
+    // later
+    resolve(@"foo");
+
+ @param resolver A reference to a block pointer of PMKResolver type.
+ You can then call your resolver to resolve this promise.
+
+ @return A new promise.
+
+ @warning *Important* The resolver strongly retains the promise.
+
+ @see promiseWithResolverBlock:
+*/
+- (instancetype)initWithResolver:(PMKResolver __strong *)resolver;
+
+@end
+
+
+
+@interface AnyPromise (Unavailable)
+
+- (instancetype)init __attribute__((unavailable("It is illegal to create an unresolvable promise.")));
++ (instancetype)new __attribute__((unavailable("It is illegal to create an unresolvable promise.")));
+
+@end
+
+
+
+typedef void (^PMKAdapter)(id, NSError *);
+typedef void (^PMKIntegerAdapter)(NSInteger, NSError *);
+typedef void (^PMKBooleanAdapter)(BOOL, NSError *);
+
+@interface AnyPromise (Adapters)
+
+/**
+ Create a new promise by adapting an existing asynchronous system.
+
+ The pattern of a completion block that passes two parameters, the first
+ the result and the second an `NSError` object is so common that we
+ provide this convenience adapter to make wrapping such systems more
+ elegant.
+
+    return [PMKPromise promiseWithAdapter:^(PMKAdapter adapter){
+        PFQuery *query = [PFQuery …];
+        [query findObjectsInBackgroundWithBlock:adapter];
+    }];
+
+ @warning *Important* If both parameters are nil, the promise fulfills,
+ if both are non-nil the promise rejects. This is per the convention.
+
+ @see http://promisekit.org/sealing-your-own-promises/
+ */
++ (instancetype)promiseWithAdapterBlock:(void (^)(PMKAdapter adapter))block;
+
+/**
+ Create a new promise by adapting an existing asynchronous system.
+
+ Adapts asynchronous systems that complete with `^(NSInteger, NSError *)`.
+ NSInteger will cast to enums provided the enum has been wrapped with
+ `NS_ENUM`. All of Apple’s enums are, so if you find one that hasn’t you
+ may need to make a pull-request.
+
+ @see promiseWithAdapter
+ */
++ (instancetype)promiseWithIntegerAdapterBlock:(void (^)(PMKIntegerAdapter adapter))block;
+
+/**
+ Create a new promise by adapting an existing asynchronous system.
+
+ Adapts asynchronous systems that complete with `^(BOOL, NSError *)`.
+
+ @see promiseWithAdapter
+ */
++ (instancetype)promiseWithBooleanAdapterBlock:(void (^)(PMKBooleanAdapter adapter))block;
+
+@end
+
+
+
+/**
+ Whenever resolving a promise you may resolve with a tuple, eg.
+ returning from a `then` or `catch` handler or resolving a new promise.
+
+ Consumers of your Promise are not compelled to consume any arguments and
+ in fact will often only consume the first parameter. Thus ensure the
+ order of parameters is: from most-important to least-important.
+
+ Currently PromiseKit limits you to THREE parameters to the manifold.
+*/
+#define PMKManifold(...) __PMKManifold(__VA_ARGS__, 3, 2, 1)
+#define __PMKManifold(_1, _2, _3, N, ...) __PMKArrayWithCount(N, _1, _2, _3)
+extern id __PMKArrayWithCount(NSUInteger, ...);
+@import Foundation.NSPointerArray;
+
+#if TARGET_OS_IPHONE
+    #define NSPointerArrayMake(N) ({ \
+        NSPointerArray *aa = [NSPointerArray strongObjectsPointerArray]; \
+        aa.count = N; \
+        aa; \
+    })
+#else
+    static inline NSPointerArray *NSPointerArrayMake(NSUInteger count) {
+      #pragma clang diagnostic push
+      #pragma clang diagnostic ignored "-Wdeprecated-declarations"
+        NSPointerArray *aa = [[NSPointerArray class] respondsToSelector:@selector(strongObjectsPointerArray)]
+            ? [NSPointerArray strongObjectsPointerArray]
+            : [NSPointerArray pointerArrayWithStrongObjects];
+      #pragma clang diagnostic pop
+        aa.count = count;
+        return aa;
+    }
+#endif
+
+#define IsError(o) [o isKindOfClass:[NSError class]]
+#define IsPromise(o) [o isKindOfClass:[AnyPromise class]]
+
+
+@interface AnyPromise (Swift)
+- (void)pipe:(void (^)(id))body;
+- (AnyPromise *)initWithBridge:(void (^)(PMKResolver))resolver;
++ (void)__consume:(id)obj;
+@end
+
+extern NSError *PMKProcessUnhandledException(id thrown);
+
+// TODO really this is not valid, we should instead nest the errors with NSUnderlyingError
+// since a special error subclass may be being used and we may not setup it up correctly
+// with our copy
+#define NSErrorSupplement(_err, supplements) ({ \
+    NSError *err = _err; \
+    id userInfo = err.userInfo.mutableCopy ?: [NSMutableArray new]; \
+    [userInfo addEntriesFromDictionary:supplements]; \
+    [[[err class] alloc] initWithDomain:err.domain code:err.code userInfo:userInfo]; \
+})
+#import <Foundation/NSError.h>
+
+#if !defined(SWIFT_PASTE)
+# define SWIFT_PASTE_HELPER(x, y) x##y
+# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
+#endif
+
+#if !defined(SWIFT_EXTENSION)
+# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
+#endif
+
+@interface NSError (SWIFT_EXTENSION(PromiseKit))
++ (NSError * __nonnull)cancelledError;
++ (void)registerCancelledErrorDomain:(NSString * __nonnull)domain code:(NSInteger)code;
+@property (nonatomic, readonly) BOOL cancelled;
+@end
+/**
+ This header provides some compatibility for PromiseKit 1.x’s
+ PMKPromise class. It will eventually be deprecated.
+*/
+
+
+typedef void (^PMKFulfiller)(id);
+typedef void (^PMKRejecter)(NSError *);
+
+typedef PMKFulfiller PMKPromiseFulfiller;
+typedef PMKRejecter PMKPromiseRejecter;
+
+#define PMKUnderlyingExceptionKey NSUnderlyingErrorKey
+
+
+
+@interface PMKPromise (BackCompat)
+
+/**
+ Create a new promise that is fulfilled or rejected with the provided
+ blocks.
+
+ Use this method when wrapping asynchronous code that does *not* use
+ promises so that this code can be used in promise chains.
+
+ Don’t use this method if you already have promises! Instead, just
+ return your promise.
+
+ Should you need to fulfill a promise but have no sensical value to use;
+ your promise is a `void` promise: fulfill with `nil`.
+
+ The block you pass is executed immediately on the calling thread.
+
+ @param block The provided block is immediately executed, any exceptions that occur will be caught and cause the returned promise to be rejected.
+
+  - @param fulfill fulfills the returned promise with the provided value
+  - @param reject rejects the returned promise with the provided `NSError`
+
+ @return A new promise.
+
+ @see http://promisekit.org/sealing-your-own-promises/
+ @see http://promisekit.org/wrapping-delegation/
+*/
++ (instancetype)new:(void(^)(PMKFulfiller fulfill, PMKRejecter reject))block __attribute__((deprecated("Use +promiseWithResolverBlock:")));
+
+/**
+ Loops until one or more promises have resolved.
+
+ Because Promises are single-shot, the block to until must return one or more promises. They are then `when`’d. If they succeed the until loop is concluded. If they fail then the @param `catch` handler is executed.
+
+ If the `catch` throws or returns an `NSError` then the loop is ended.
+
+ If the `catch` handler returns a Promise then re-execution of the loop is suspended upon resolution of that Promise. If the Promise succeeds then the loop continues. If it fails the loop ends.
+
+ An example usage is an app starting up that must get data from the Internet before the main ViewController can be shown. You can `until` the poll Promise and in the catch handler decide if the poll should be reattempted or not, perhaps returning a `UIAlertView.promise` allowing the user to choose if they continue or not.
+*/
++ (PMKPromise *)until:(id (^)(void))blockReturningPromises catch:(id)failHandler;
+
+@end
+
+
+
+@import Foundation.NSDate;
+
+@interface PMKPromise (Deprecated)
+
++ (PMKPromise *)when:(id)input __attribute__((deprecated("Use PMKWhen()")));
++ (PMKPromise *)pause:(NSTimeInterval)duration __attribute__((deprecated("Use PMKAfter()")));
++ (PMKPromise *)join:(id)input __attribute__((deprecated("Use PMKJoin()")));
+
+- (PMKPromise *( ^ ) ( id ))thenUnleashZalgo __attribute__((unavailable("If you need this, open a ticket, we will provide it, I just want to say hi.")));
+
++ (PMKPromise *)promiseWithResolver:(PMKResolver)block __attribute__((deprecated("Use +promiseWithResolverBlock:")));
++ (instancetype)promiseWithAdapter:(void (^)(PMKAdapter adapter))block __attribute__((deprecated("Use +promiseWithAdapterBlock:")));
++ (instancetype)promiseWithIntegerAdapter:(void (^)(PMKIntegerAdapter adapter))block __attribute__((deprecated("Use +promiseWithIntegerAdapterBlock:")));
++ (instancetype)promiseWithBooleanAdapter:(void (^)(PMKBooleanAdapter adapter))block __attribute__((deprecated("Use +promiseWithBooleanAdapterBlock:")));
+
+@end
+
+
+
+extern void (^PMKUnhandledErrorHandler)(NSError *) __attribute__((unavailable("Use PMKSetUnhandledErrorHandler()")));
+#import <dispatch/queue.h>
+#import <Foundation/NSDate.h>
+#import <Foundation/NSObject.h>
+
+
+
+/**
+ @return A new promise that resolves after the specified duration.
+
+ @parameter duration The duration in seconds to wait before this promise is resolve.
+
+ For example:
+
+    PMKAfter(1).then(^{
+        //…
+    });
+*/
+extern AnyPromise * __nonnull PMKAfter(NSTimeInterval duration);
+
+
+
+/**
+ `when` is a mechanism for waiting more than one asynchronous task and responding when they are all complete.
+
+ `PMKWhen` accepts varied input. If an array is passed then when those promises fulfill, when’s promise fulfills with an array of fulfillment values. If a dictionary is passed then the same occurs, but when’s promise fulfills with a dictionary of fulfillments keyed as per the input.
+
+ Interestingly, if a single promise is passed then when waits on that single promise, and if a single non-promise object is passed then when fulfills immediately with that object. If the array or dictionary that is passed contains objects that are not promises, then these objects are considered fulfilled promises. The reason we do this is to allow a pattern know as "abstracting away asynchronicity".
+
+ If *any* of the provided promises reject, the returned promise is immediately rejected with that promise’s rejection. The error’s `userInfo` object is supplemented with `PMKFailingPromiseIndexKey`.
+
+ For example:
+
+    PMKWhen(@[promise1, promise2]).then(^(NSArray *results){
+        //…
+    });
+
+ @warning *Important* In the event of rejection the other promises will continue to resolve and as per any other promise will eithe fulfill or reject. This is the right pattern for `getter` style asynchronous tasks, but often for `setter` tasks (eg. storing data on a server), you most likely will need to wait on all tasks and then act based on which have succeeded and which have failed. In such situations use `PMKJoin`.
+
+ @param input The input upon which to wait before resolving this promise.
+
+ @return A promise that is resolved with either:
+
+  1. An array of values from the provided array of promises.
+  2. The value from the provided promise.
+  3. The provided non-promise object.
+
+ @see PMKJoin
+
+*/
+extern AnyPromise * __nonnull PMKWhen(id __nonnull input);
+
+
+
+/**
+ Creates a new promise that resolves only when all provided promises have resolved.
+
+ Typically, you should use `PMKWhen`.
+
+ For example:
+
+    PMKJoin(@[promise1, promise2]).then(^(NSArray *results, NSArray *values, NSArray *errors){
+        //…
+    });
+
+ @warning *Important* This promise is not rejectable. Thus it is up to you to propogate an error if you want any subsequent chain to continue being rejected.
+
+ @param promises An array of promises.
+
+ @return A promise that thens three parameters:
+
+  1) An array of mixed values and errors from the resolved input.
+  2) An array of values from the promises that fulfilled.
+  3) An array of errors from the promises that rejected or nil if all promises fulfilled.
+
+ @see when
+*/
+AnyPromise *__nonnull PMKJoin(NSArray * __nonnull promises);
+
+
+
+/**
+ Literally hangs this thread until the promise has resolved.
+ 
+ Do not use hang… unless you are testing, playing or debugging.
+ 
+ If you use it in production code I will literally and honestly cry like a child.
+ 
+ @return The resolved value of the promise.
+
+ @warning T SAFE. IT IS NOT SAFE. IT IS NOT SAFE. IT IS NOT SAFE. IT IS NO
+*/
+extern id __nullable PMKHang(AnyPromise * __nonnull promise);
+
+
+
+/**
+ Sets the unhandled error handler.
+
+ If a promise is rejected and no catch handler is called in its chain, the
+ provided handler is called. The default handler logs the error.
+
+    PMKSetUnhandledErrorHandler(^(NSError *error){
+        NSLog(@"Unhandled error: %@", error);
+    });
+
+ @warning *Important* The handler is executed on an undefined queue.
+ 
+ @warning *Important* Don’t use promises in your handler, or you risk an
+ infinite error loop.
+ 
+ @warning *Important* This function is totally not thread-safe and if
+ some promise is already executing when you set this the results are
+ undefined (though safe if you are programming safely because either
+ your handler or the previous handler will be called). So do this at
+ application startup and *NOWHERE ELSE!*
+
+ @return The previous unhandled error handler.
+*/
+extern id __nonnull PMKSetUnhandledErrorHandler(void (^__nonnull handler)(NSError * __nonnull));
+
+
+
+/**
+ Sets the unhandled exception handler.
+
+ If an exception is thrown inside an AnyPromise handler it is caught and
+ this handler is executed to determine if the promise is rejected.
+ 
+ The default handler rejects the promise if an NSError or an NSString is
+ thrown.
+ 
+ The default handler in PromiseKit 1.x would reject whatever object was
+ thrown (including nil).
+
+ @warning *Important* This handler is provided to allow you to customize
+ which exceptions cause rejection and which abort. You should either
+ return a fully-formed NSError object or nil. Returning nil causes the
+ exception to be re-thrown.
+
+ @warning *Important* The handler is executed on an undefined queue.
+
+ @warning *Important* This function is thread-safe, but to facilitate this
+ it can only be called once per application lifetime and it must be called
+ before any promise in the app throws an exception. Subsequent calls will
+ silently fail.
+*/
+extern void PMKSetUnhandledExceptionHandler(NSError * __nullable (^__nonnull handler)(id __nullable));
+
+
+
+/**
+ Executes the provided block on a background queue.
+
+ dispatch_promise is a convenient way to start a promise chain where the
+ first step needs to run synchronously on a background queue.
+
+    dispatch_promise(^{
+        return md5(input);
+    }).then(^(NSString *md5){
+        NSLog(@"md5: %@", md5);
+    });
+
+ @param block The block to be executed in the background. Returning an `NSError` will reject the promise, everything else (including void) fulfills the promise.
+
+ @return A promise resolved with the return value of the provided block.
+
+ @see dispatch_async
+*/
+extern AnyPromise * __nonnull dispatch_promise(id __nonnull block);
+
+
+
+/**
+ Executes the provided block on the specified background queue.
+
+    dispatch_promise_on(myDispatchQueue, ^{
+        return md5(input);
+    }).then(^(NSString *md5){
+        NSLog(@"md5: %@", md5);
+    });
+
+ @param block The block to be executed in the background. Returning an `NSError` will reject the promise, everything else (including void) fulfills the promise.
+
+ @return A promise resolved with the return value of the provided block.
+
+ @see dispatch_promise
+*/
+extern AnyPromise * __nonnull dispatch_promise_on(dispatch_queue_t __nonnull queue, id __nonnull block);
+
+
+
+#define PMKJSONDeserializationOptions ((NSJSONReadingOptions)(NSJSONReadingAllowFragments | NSJSONReadingMutableContainers))
+
+#define PMKHTTPURLResponseIsJSON(rsp) [@[@"application/json", @"text/json", @"text/javascript"] containsObject:[rsp MIMEType]]
+#define PMKHTTPURLResponseIsImage(rsp) [@[@"image/tiff", @"image/jpeg", @"image/gif", @"image/png", @"image/ico", @"image/x-icon", @"image/bmp", @"image/x-bmp", @"image/x-xbitmap", @"image/x-win-bitmap"] containsObject:[rsp MIMEType]]
+#define PMKHTTPURLResponseIsText(rsp) [[rsp MIMEType] hasPrefix:@"text/"]
+
+
+
+#if defined(__has_include)
+  #if __has_include(<PromiseKit/ACAccountStore+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/AVAudioSession+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CKContainer+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CKDatabase+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CLGeocoder+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CLLocationManager+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/NSNotificationCenter+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/NSTask+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/NSURLConnection+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/MKDirections+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/MKMapSnapshotter+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/CALayer+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/SLRequest+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/SKRequest+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/SCNetworkReachability+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIActionSheet+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIAlertView+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIView+AnyPromise.h>)
+  #endif
+  #if __has_include(<PromiseKit/UIViewController+AnyPromise.h>)
+  #endif
+#endif
+#import <Foundation/NSMethodSignature.h>
+
+struct PMKBlockLiteral {
+    void *isa; // initialized to &_NSConcreteStackBlock or &_NSConcreteGlobalBlock
+    int flags;
+    int reserved;
+    void (*invoke)(void *, ...);
+    struct block_descriptor {
+        unsigned long int reserved;	// NULL
+    	unsigned long int size;         // sizeof(struct Block_literal_1)
+        // optional helper functions
+    	void (*copy_helper)(void *dst, void *src);     // IFF (1<<25)
+    	void (*dispose_helper)(void *src);             // IFF (1<<25)
+        // required ABI.2010.3.16
+        const char *signature;                         // IFF (1<<30)
+    } *descriptor;
+    // imported variables
+};
+
+typedef NS_OPTIONS(NSUInteger, PMKBlockDescriptionFlags) {
+    PMKBlockDescriptionFlagsHasCopyDispose = (1 << 25),
+    PMKBlockDescriptionFlagsHasCtor = (1 << 26), // helpers have C++ code
+    PMKBlockDescriptionFlagsIsGlobal = (1 << 28),
+    PMKBlockDescriptionFlagsHasStret = (1 << 29), // IFF BLOCK_HAS_SIGNATURE
+    PMKBlockDescriptionFlagsHasSignature = (1 << 30)
+};
+
+// It appears 10.7 doesn't support quotes in method signatures. Remove them
+// via @rabovik's method. See https://github.com/OliverLetterer/SLObjectiveCRuntimeAdditions/pull/2
+#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_8
+NS_INLINE static const char * pmk_removeQuotesFromMethodSignature(const char *str){
+    char *result = malloc(strlen(str) + 1);
+    BOOL skip = NO;
+    char *to = result;
+    char c;
+    while ((c = *str++)) {
+        if ('"' == c) {
+            skip = !skip;
+            continue;
+        }
+        if (skip) continue;
+        *to++ = c;
+    }
+    *to = '\0';
+    return result;
+}
+#endif
+
+static NSMethodSignature *NSMethodSignatureForBlock(id block) {
+    if (!block)
+        return nil;
+
+    struct PMKBlockLiteral *blockRef = (__bridge struct PMKBlockLiteral *)block;
+    PMKBlockDescriptionFlags flags = (PMKBlockDescriptionFlags)blockRef->flags;
+
+    if (flags & PMKBlockDescriptionFlagsHasSignature) {
+        void *signatureLocation = blockRef->descriptor;
+        signatureLocation += sizeof(unsigned long int);
+        signatureLocation += sizeof(unsigned long int);
+
+        if (flags & PMKBlockDescriptionFlagsHasCopyDispose) {
+            signatureLocation += sizeof(void(*)(void *dst, void *src));
+            signatureLocation += sizeof(void (*)(void *src));
+        }
+
+        const char *signature = (*(const char **)signatureLocation);
+#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_8
+        signature = pmk_removeQuotesFromMethodSignature(signature);
+        NSMethodSignature *nsSignature = [NSMethodSignature signatureWithObjCTypes:signature];
+        free((void *)signature);
+
+        return nsSignature;
+#endif
+        return [NSMethodSignature signatureWithObjCTypes:signature];
+    }
+    return 0;
+}
+#import <dispatch/once.h>
+#import <Foundation/NSDictionary.h>
+#import <Foundation/NSError.h>
+#import <Foundation/NSException.h>
+#import <string.h>
+
+#ifndef PMKLog
+#define PMKLog NSLog
+#endif
+
+@interface PMKArray : NSObject {
+@public
+    id objs[3];
+    NSUInteger count;
+} @end
+
+@implementation PMKArray
+
+- (id)objectAtIndexedSubscript:(NSUInteger)idx {
+    if (count <= idx) {
+        // this check is necessary due to lack of checks in `pmk_safely_call_block`
+        return nil;
+    }
+    return objs[idx];
+}
+
+@end
+
+id __PMKArrayWithCount(NSUInteger count, ...) {
+    PMKArray *this = [PMKArray new];
+    this->count = count;
+    va_list args;
+    va_start(args, count);
+    for (NSUInteger x = 0; x < count; ++x)
+        this->objs[x] = va_arg(args, id);
+    va_end(args);
+    return this;
+}
+
+
+static inline id _PMKCallVariadicBlock(id frock, id result) {
+    NSCAssert(frock, @"");
+
+    NSMethodSignature *sig = NSMethodSignatureForBlock(frock);
+    const NSUInteger nargs = sig.numberOfArguments;
+    const char rtype = sig.methodReturnType[0];
+
+    #define call_block_with_rtype(type) ({^type{ \
+        switch (nargs) { \
+            case 1: \
+                return ((type(^)(void))frock)(); \
+            case 2: { \
+                const id arg = [result class] == [PMKArray class] ? result[0] : result; \
+                return ((type(^)(id))frock)(arg); \
+            } \
+            case 3: { \
+                type (^block)(id, id) = frock; \
+                return [result class] == [PMKArray class] \
+                    ? block(result[0], result[1]) \
+                    : block(result, nil); \
+            } \
+            case 4: { \
+                type (^block)(id, id, id) = frock; \
+                return [result class] == [PMKArray class] \
+                    ? block(result[0], result[1], result[2]) \
+                    : block(result, nil, nil); \
+            } \
+            default: \
+                @throw [NSException exceptionWithName:NSInvalidArgumentException reason:@"PromiseKit: The provided block’s argument count is unsupported." userInfo:nil]; \
+        }}();})
+
+    switch (rtype) {
+        case 'v':
+            call_block_with_rtype(void);
+            return nil;
+        case '@':
+            return call_block_with_rtype(id) ?: nil;
+        case '*': {
+            char *str = call_block_with_rtype(char *);
+            return str ? @(str) : nil;
+        }
+        case 'c': return @(call_block_with_rtype(char));
+        case 'i': return @(call_block_with_rtype(int));
+        case 's': return @(call_block_with_rtype(short));
+        case 'l': return @(call_block_with_rtype(long));
+        case 'q': return @(call_block_with_rtype(long long));
+        case 'C': return @(call_block_with_rtype(unsigned char));
+        case 'I': return @(call_block_with_rtype(unsigned int));
+        case 'S': return @(call_block_with_rtype(unsigned short));
+        case 'L': return @(call_block_with_rtype(unsigned long));
+        case 'Q': return @(call_block_with_rtype(unsigned long long));
+        case 'f': return @(call_block_with_rtype(float));
+        case 'd': return @(call_block_with_rtype(double));
+        case 'B': return @(call_block_with_rtype(_Bool));
+        case '^':
+            if (strcmp(sig.methodReturnType, "^v") == 0) {
+                call_block_with_rtype(void);
+                return nil;
+            }
+            // else fall through!
+        default:
+            @throw [NSException exceptionWithName:@"PromiseKit" reason:@"PromiseKit: Unsupported method signature." userInfo:nil];
+    }
+}
+
+static id PMKCallVariadicBlock(id frock, id result) {
+    @try {
+        return _PMKCallVariadicBlock(frock, result);
+    } @catch (id thrown) {
+        return PMKProcessUnhandledException(thrown);
+    }
+}
+
+
+static dispatch_once_t onceToken;
+static NSError *(^PMKUnhandledExceptionHandler)(id);
+
+NSError *PMKProcessUnhandledException(id thrown) {
+
+    dispatch_once(&onceToken, ^{
+        PMKUnhandledExceptionHandler = ^id(id reason){
+            if ([reason isKindOfClass:[NSError class]])
+                return reason;
+            if ([reason isKindOfClass:[NSString class]])
+                return [NSError errorWithDomain:PMKErrorDomain code:PMKUnexpectedError userInfo:@{NSLocalizedDescriptionKey: reason}];
+            return nil;
+        };
+    });
+
+    id err = PMKUnhandledExceptionHandler(thrown);
+    if (!err) @throw thrown;
+    return err;
+}
+
+void PMKSetUnhandledExceptionHandler(NSError *(^newHandler)(id)) {
+    dispatch_once(&onceToken, ^{
+        PMKUnhandledExceptionHandler = newHandler;
+    });
+}
+@import Dispatch;
+@import Foundation.NSDate;
+@import Foundation.NSValue;
+
+AnyPromise *PMKAfter(NSTimeInterval duration) {
+    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {
+        dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC));
+        dispatch_after(time, dispatch_get_global_queue(0, 0), ^{
+            resolve(@(duration));
+        });
+    }];
+}
+@import Foundation.NSKeyValueCoding;
+
+NSString *const PMKErrorDomain = @"PMKErrorDomain";
+
+
+@implementation AnyPromise (objc)
+
+- (instancetype)initWithResolver:(PMKResolver __strong *)resolver {
+    return [self initWithBridge:^(PMKResolver resolve){
+        *resolver = resolve;
+    }];
+}
+
++ (instancetype)promiseWithResolverBlock:(void (^)(PMKResolver))resolveBlock {
+    return [[self alloc] initWithBridge:resolveBlock];
+}
+
++ (instancetype)promiseWithValue:(id)value {
+    return [[self alloc] initWithBridge:^(PMKResolver resolve){
+        resolve(value);
+    }];
+}
+
+static inline AnyPromise *AnyPromiseWhen(AnyPromise *when, void(^then)(id, PMKResolver)) {
+    return [[[when class] alloc] initWithBridge:^(PMKResolver resolve){
+        [when pipe:^(id obj){
+            then(obj, resolve);
+        }];
+    }];
+}
+
+static inline AnyPromise *__then(AnyPromise *self, dispatch_queue_t queue, id block) {
+    return AnyPromiseWhen(self, ^(id obj, PMKResolver resolve) {
+        if (IsError(obj)) {
+            resolve(obj);
+        } else dispatch_async(queue, ^{
+            resolve(PMKCallVariadicBlock(block, obj));
+        });
+    });
+}
+
+- (AnyPromise *(^)(id))then {
+    return ^(id block) {
+        return __then(self, dispatch_get_main_queue(), block);
+    };
+}
+
+- (AnyPromise *(^)(dispatch_queue_t, id))thenOn {
+    return ^(dispatch_queue_t queue, id block) {
+        return __then(self, queue, block);
+    };
+}
+
+- (AnyPromise *(^)(id))thenInBackground {
+    return ^(id block) {
+        return __then(self, dispatch_get_global_queue(0, 0), block);
+    };
+}
+
+static inline AnyPromise *__catch(AnyPromise *self, BOOL includeCancellation, id block) {
+    return AnyPromiseWhen(self, ^(id obj, PMKResolver resolve) {
+        if (IsError(obj) && (includeCancellation || ![obj cancelled])) {
+            [[self class] __consume:obj];
+            dispatch_async(dispatch_get_main_queue(), ^{
+                resolve(PMKCallVariadicBlock(block, obj));
+            });
+        } else {
+            resolve(obj);
+        }
+    });
+}
+
+- (AnyPromise *(^)(id))catch {
+    return ^(id block) {
+        return __catch(self, NO, block);
+    };
+}
+
+- (AnyPromise *(^)(PMKCatchPolicy, id))catchWithPolicy {
+    return ^(PMKCatchPolicy policy, id block) {
+        return __catch(self, policy == PMKCatchPolicyAllErrors, block);
+    };
+}
+
+static inline AnyPromise *__finally(AnyPromise *self, dispatch_queue_t queue, dispatch_block_t block) {
+    return AnyPromiseWhen(self, ^(id obj, PMKResolver resolve) {
+        dispatch_async(queue, ^{
+            block();
+            resolve(obj);
+        });
+    });
+}
+
+- (AnyPromise *(^)(dispatch_block_t))finally {
+    return ^(dispatch_block_t block) {
+        return __finally(self, dispatch_get_main_queue(), block);
+    };
+}
+
+- (AnyPromise *(^)(dispatch_queue_t, dispatch_block_t))finallyOn {
+    return ^(dispatch_queue_t queue, dispatch_block_t block) {
+        return __finally(self, queue, block);
+    };
+}
+
+- (id)value {
+    id result = [self valueForKey:@"__value"];
+    return [result isKindOfClass:[PMKArray class]]
+        ? result[0]
+        : result;
+}
+
+@end
+
+
+
+@implementation AnyPromise (Adapters)
+
++ (instancetype)promiseWithAdapterBlock:(void (^)(PMKAdapter))block {
+    return [self promiseWithResolverBlock:^(PMKResolver resolve) {
+        block(^(id value, id error){
+            resolve(error ?: value);
+        });
+    }];
+}
+
++ (instancetype)promiseWithIntegerAdapterBlock:(void (^)(PMKIntegerAdapter))block {
+    return [self promiseWithResolverBlock:^(PMKResolver resolve) {
+        block(^(NSInteger value, id error){
+            if (error) {
+                resolve(error);
+            } else {
+                resolve(@(value));
+            }
+        });
+    }];
+}
+
++ (instancetype)promiseWithBooleanAdapterBlock:(void (^)(PMKBooleanAdapter adapter))block {
+    return [self promiseWithResolverBlock:^(PMKResolver resolve) {
+        block(^(BOOL value, id error){
+            if (error) {
+                resolve(error);
+            } else {
+                resolve(@(value));
+            }
+        });
+    }];
+}
+
+@end
+
+
+
+@interface AnyPromise (XP)
++ (id)setUnhandledErrorHandler:(id)handler;
+@end
+
+id PMKSetUnhandledErrorHandler(void (^handler)(NSError *)) {
+    return [AnyPromise setUnhandledErrorHandler:handler];
+}
+@import Dispatch;
+
+AnyPromise *dispatch_promise(id block) {
+    return dispatch_promise_on(dispatch_get_global_queue(0, 0), block);
+}
+
+AnyPromise *dispatch_promise_on(dispatch_queue_t queue, id block) {
+    return [AnyPromise promiseWithValue:nil].thenOn(queue, block);
+}
+@import CoreFoundation.CFRunLoop;
+
+id PMKHang(AnyPromise *promise) {
+    if (promise.pending) {
+        static CFRunLoopSourceContext context;
+
+        CFRunLoopRef runLoop = CFRunLoopGetCurrent();
+        CFRunLoopSourceRef runLoopSource = CFRunLoopSourceCreate(NULL, 0, &context);
+        CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
+
+        promise.finally(^{
+            CFRunLoopStop(runLoop);
+        });
+        while (promise.pending) {
+            CFRunLoopRun();
+        }
+        CFRunLoopRemoveSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
+        CFRelease(runLoopSource);
+    }
+
+    return promise.value;
+}
+@import Foundation.NSDictionary;
+@import Foundation.NSError;
+@import Foundation.NSNull;
+
+@implementation AnyPromise (join)
+
+AnyPromise *PMKJoin(NSArray *promises) {
+    if (promises == nil)
+        return [AnyPromise promiseWithValue:[NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:@{NSLocalizedDescriptionKey: @"PMKJoin(nil)"}]];
+
+    if (promises.count == 0)
+        return [AnyPromise promiseWithValue:PMKManifold(promises, promises)];
+
+    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {
+        NSPointerArray *results = NSPointerArrayMake(promises.count);
+
+        __block NSUInteger x = 0;
+
+        [promises enumerateObjectsUsingBlock:^(AnyPromise *promise, NSUInteger ii, BOOL *stop) {
+            [promise pipe:^(id value) {
+                [results replacePointerAtIndex:ii withPointer:(__bridge void *)(value ?: [NSNull null])];
+                if (++x == promises.count) {
+                    id apples = results.allObjects;
+                    id values = [NSMutableArray new];
+                    id errors = [NSMutableArray new];
+                    for (id apple in apples)
+                        [IsError(apple) ? errors : values addObject:apple];
+                    if ([errors count] == 0)
+                        errors = nil;
+                    resolve(PMKManifold(apples, values, errors));
+                }
+            }];
+        }];
+    }];
+}
+
+@end
+@import Foundation.NSDictionary;
+
+#ifndef PMKLog
+#define PMKLog NSLog
+#endif
+
+
+@implementation PMKPromise (BackCompat)
+
++ (instancetype)new:(void(^)(PMKFulfiller, PMKRejecter))block {
+    return [self promiseWithResolverBlock:^(PMKResolver resolve) {
+        id rejecter = ^(id error){
+            if (error == nil) {
+                error = [NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:nil];
+            } else if (IsPromise(error)) {
+                error = ((PMKPromise *)error).value;
+            }
+            if (!IsError(error)) {
+                id userInfo = @{
+                    NSLocalizedDescriptionKey: [error description],
+                    NSUnderlyingErrorKey: error
+                };
+                error = [NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:userInfo];
+            }
+            resolve(error);
+        };
+
+        id fulfiller = ^(id result){
+            if (IsError(result))
+                PMKLog(@"PromiseKit: Warning: PMKFulfiller called with NSError.");
+            resolve(result);
+        };
+
+        @try {
+            block(fulfiller, rejecter);
+        } @catch (id thrown) {
+            resolve(PMKProcessUnhandledException(thrown));
+        }
+    }];
+}
+
++ (instancetype)until:(id (^)(void))blockReturningPromises catch:(id)failHandler {
+
+    #pragma clang diagnostic push
+    #pragma clang diagnostic ignored "-Warc-retain-cycles"
+
+    return [PMKPromise promiseWithResolverBlock:^(PMKResolver resolve) {
+        __block void (^block)() = ^{
+            AnyPromise *next = PMKWhen(blockReturningPromises());
+            next.then(^(id o){
+                resolve(o);
+                block = nil;
+            });
+            next.catch(^(NSError *error){
+                [AnyPromise promiseWithValue:error].catch(failHandler).then(block).catch(^{
+                    resolve(error);
+                    block = nil;
+                });
+            });
+        };
+        block();
+    }];
+
+    #pragma clang diagnostic pop
+}
+
+@end
+
+
+
+@implementation PMKPromise (Deprecated)
+
++ (instancetype)when:(id)input {
+    return PMKWhen(input);
+}
+
++ (instancetype)pause:(NSTimeInterval)duration {
+    return PMKAfter(duration);
+}
+
++ (instancetype)join:(id)input {
+    return PMKJoin(input).then(^(id a, id b, id c){
+        // preserving PMK 1.x behavior
+        return PMKManifold(b, c);
+    });
+}
+
++ (instancetype)promiseWithResolver:(PMKResolver)block {
+    return [self promiseWithResolverBlock:block];
+}
+
++ (instancetype)promiseWithAdapter:(void (^)(PMKAdapter adapter))block {
+    return [self promiseWithAdapterBlock:block];
+}
+
++ (instancetype)promiseWithIntegerAdapter:(void (^)(PMKIntegerAdapter adapter))block {
+    return [self promiseWithIntegerAdapterBlock:block];
+}
+
++ (instancetype)promiseWithBooleanAdapter:(void (^)(PMKBooleanAdapter adapter))block {
+    return [self promiseWithBooleanAdapterBlock:block];
+}
+
+@end
+@import Foundation.NSDictionary;
+@import Foundation.NSError;
+@import Foundation.NSProgress;
+@import Foundation.NSNull;
+
+// NSProgress resources:
+//  * https://robots.thoughtbot.com/asynchronous-nsprogress
+//  * http://oleb.net/blog/2014/03/nsprogress/
+// NSProgress! Beware!
+//  * https://github.com/AFNetworking/AFNetworking/issues/2261
+
+
+AnyPromise *PMKWhen(id promises) {
+    if (promises == nil)
+        return [AnyPromise promiseWithValue:[NSError errorWithDomain:PMKErrorDomain code:PMKInvalidUsageError userInfo:@{NSLocalizedDescriptionKey: @"PMKWhen(nil)"}]];
+
+    if ([promises isKindOfClass:[NSArray class]] || [promises isKindOfClass:[NSDictionary class]]) {
+        if ([promises count] == 0)
+            return [AnyPromise promiseWithValue:promises];
+    } else if ([promises isKindOfClass:[AnyPromise class]]) {
+        promises = @[promises];
+    } else {
+        return [AnyPromise promiseWithValue:promises];
+    }
+
+#ifndef PMKDisableProgress
+    NSProgress *progress = [NSProgress progressWithTotalUnitCount:[promises count]];
+    progress.pausable = NO;
+    progress.cancellable = NO;
+#endif
+
+    PMKResolver resolve;
+    AnyPromise *rootPromise = [[AnyPromise alloc] initWithResolver:&resolve];
+    __block void (^fulfill)();
+
+    __block NSInteger countdown = [promises count];
+    void (^yield)(id, id, void(^)(id)) = ^(AnyPromise *promise, id key, void(^set)(id)) {
+        if (![promise isKindOfClass:[AnyPromise class]])
+            promise = [AnyPromise promiseWithValue:promise];
+        [promise pipe:^(id value){
+            if (!rootPromise.pending) {
+                // suppress “already resolved” log message
+            } else if (IsError(value)) {
+              #ifndef PMKDisableProgress
+                progress.completedUnitCount = progress.totalUnitCount;
+              #endif
+                resolve(NSErrorSupplement(value, @{PMKFailingPromiseIndexKey: key}));
+            } else {
+              #ifndef PMKDisableProgress
+                progress.completedUnitCount++;
+              #endif
+                set(promise.value);  // we use -value to unwrap PMKManifolds
+                if (--countdown == 0)
+                    fulfill();
+            }
+        }];
+    };
+
+    if ([promises isKindOfClass:[NSDictionary class]]) {
+        NSMutableDictionary *results = [NSMutableDictionary new];
+        fulfill = ^{ resolve(results); };
+
+        for (id key in promises) {
+            yield(promises[key], key, ^(id value){
+                results[key] = value;
+            });
+        }
+    } else {
+        NSPointerArray *results = NSPointerArrayMake([promises count]);
+        fulfill = ^{ resolve(results.allObjects); };
+
+        [promises enumerateObjectsUsingBlock:^(id promise, NSUInteger ii, BOOL *stop) {
+            yield(promise, @(ii), ^(id value){
+                [results replacePointerAtIndex:ii withPointer:(__bridge void *)(value ?: [NSNull null])];
+            });
+        }];
+    }
+    
+    return rootPromise;
+}
diff --git a/PromiseKit/PromiseKit.swift b/PromiseKit/PromiseKit.swift
new file mode 100755
index 00000000000..2d6ba749aa0
--- /dev/null
+++ b/PromiseKit/PromiseKit.swift
@@ -0,0 +1,1276 @@
+import Dispatch
+import Foundation.NSDate
+
+/**
+ @return A new promise that resolves after the specified duration.
+
+ @parameter duration The duration in seconds to wait before this promise is resolve.
+
+ For example:
+
+    after(1).then {
+        //…
+    }
+*/
+public func after(delay: NSTimeInterval) -> Promise<Void> {
+    return Promise { fulfill, _ in
+        let delta = delay * NSTimeInterval(NSEC_PER_SEC)
+        let when = dispatch_time(DISPATCH_TIME_NOW, Int64(delta))
+        dispatch_after(when, dispatch_get_global_queue(0, 0)) {
+            fulfill()
+        }
+    }
+}
+import Foundation.NSError
+
+/**
+ AnyPromise is a Promise that can be used in Objective-C code
+
+ Swift code can only convert Promises to AnyPromises or vice versa.
+
+ Libraries that only provide promises will require you to write a
+ small Swift function that can convert those promises into AnyPromises
+ as you require them.
+
+ To effectively use AnyPromise in Objective-C code you must use `#import`
+ rather than `@import PromiseKit;`
+
+     #import <PromiseKit/PromiseKit.h>
+*/
+
+/**
+ Resolution.Fulfilled takes an Any. When retrieving the Any you cannot
+ convert it into an AnyObject?. By giving Fulfilled an object that has
+ an AnyObject? property we never have to cast and everything is fine.
+*/
+private class Box {
+    let obj: AnyObject?
+    
+    init(_ obj: AnyObject?) {
+        self.obj = obj
+    }
+}
+
+private func box(obj: AnyObject?) -> Resolution {
+    if let error = obj as? NSError {
+        unconsume(error)
+        return .Rejected(error)
+    } else {
+        return .Fulfilled(Box(obj))
+    }
+}
+
+private func unbox(resolution: Resolution) -> AnyObject? {
+    switch resolution {
+    case .Fulfilled(let box):
+        return (box as! Box).obj
+    case .Rejected(let error):
+        return error
+    }
+}
+
+
+
+@objc(PMKAnyPromise) public class AnyPromise: NSObject {
+    var state: State
+
+    /**
+     @return A new AnyPromise bound to a Promise<T>.
+
+     The two promises represent the same task, any changes to either
+     will instantly reflect on both.
+    */
+    public init<T: AnyObject>(bound: Promise<T>) {
+        //WARNING copy pasta from below. FIXME how?
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        bound.pipe { resolution in
+            switch resolution {
+            case .Fulfilled:
+                resolve(box(bound.value))
+            case .Rejected(let error):
+                resolve(box(error))
+            }
+        }
+    }
+
+    public init<T: AnyObject>(bound: Promise<T?>) {
+        //WARNING copy pasta from above. FIXME how?
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        bound.pipe { resolution in
+            switch resolution {
+            case .Fulfilled:
+                resolve(box(bound.value!))
+            case .Rejected(let error):
+                resolve(box(error))
+            }
+        }
+    }
+
+    /**
+     @return A new AnyPromise bound to a Promise<[T]>.
+
+     The two promises represent the same task, any changes to either
+     will instantly reflect on both.
+    
+     The value is converted to an NSArray so Objective-C can use it.
+    */
+    public init<T: AnyObject>(bound: Promise<[T]>) {
+        //WARNING copy pasta from above. FIXME how?
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        bound.pipe { resolution in
+            switch resolution {
+            case .Fulfilled:
+                resolve(box(NSArray(array: bound.value!)))
+            case .Rejected(let error):
+                resolve(box(error))
+            }
+        }
+    }
+
+    /**
+    @return A new AnyPromise bound to a Promise<[T]>.
+
+    The two promises represent the same task, any changes to either
+    will instantly reflect on both.
+
+    The value is converted to an NSArray so Objective-C can use it.
+    */
+    public init<T: AnyObject, U: AnyObject>(bound: Promise<[T:U]>) {
+        //WARNING copy pasta from above. FIXME how?
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        bound.pipe { resolution in
+            switch resolution {
+            case .Fulfilled:
+                resolve(box(bound.value! as NSDictionary))
+            case .Rejected(let error):
+                resolve(box(error))
+            }
+        }
+    }
+
+    convenience public init(bound: Promise<Int>) {
+        self.init(bound: bound.then(on: zalgo) { NSNumber(integer: $0) })
+    }
+
+    convenience public init(bound: Promise<Void>) {
+        self.init(bound: bound.then(on: zalgo) { _ -> AnyObject? in return nil })
+    }
+
+    @objc init(@noescape bridge: ((AnyObject?) -> Void) -> Void) {
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        bridge { result in
+            func preresolve(obj: AnyObject?) {
+                resolve(box(obj))
+            }
+            if let next = result as? AnyPromise {
+                next.pipe(preresolve)
+            } else {
+                preresolve(result)
+            }
+        }
+    }
+
+    @objc func pipe(body: (AnyObject?) -> Void) {
+        state.get { seal in
+            func prebody(resolution: Resolution) {
+                body(unbox(resolution))
+            }
+            switch seal {
+            case .Pending(let handlers):
+                handlers.append(prebody)
+            case .Resolved(let resolution):
+                prebody(resolution)
+            }
+        }
+    }
+
+    @objc var __value: AnyObject? {
+        if let resolution = state.get() {
+            return unbox(resolution)
+        } else {
+            return nil
+        }
+    }
+
+    /**
+     A promise starts pending and eventually resolves.
+
+     @return True if the promise has not yet resolved.
+    */
+    @objc public var pending: Bool {
+        return state.get() == nil
+    }
+
+    /**
+     A promise starts pending and eventually resolves.
+
+     @return True if the promise has resolved.
+    */
+    @objc public var resolved: Bool {
+        return !pending
+    }
+
+    /**
+     A promise starts pending and eventually resolves.
+    
+     A fulfilled promise is resolved and succeeded.
+
+     @return True if the promise was fulfilled.
+    */
+    @objc public var fulfilled: Bool {
+        switch state.get() {
+        case .Some(.Fulfilled):
+            return true
+        default:
+            return false
+        }
+    }
+
+    /**
+     A promise starts pending and eventually resolves.
+    
+     A rejected promise is resolved and failed.
+
+     @return True if the promise was rejected.
+    */
+    @objc public var rejected: Bool {
+        switch state.get() {
+        case .Some(.Rejected):
+            return true
+        default:
+            return false
+        }
+    }
+
+    // because you can’t access top-level Swift functions in objc
+    @objc class func setUnhandledErrorHandler(body: (NSError) -> Void) -> (NSError) -> Void {
+        let oldHandler = PMKUnhandledErrorHandler
+        PMKUnhandledErrorHandler = body
+        return oldHandler
+    }
+}
+
+
+extension AnyPromise: DebugPrintable {
+    override public var debugDescription: String {
+        return "AnyPromise: \(state)"
+    }
+}
+import Dispatch
+import Foundation.NSError
+
+public func dispatch_promise<T>(on queue: dispatch_queue_t = dispatch_get_global_queue(0, 0), body: () -> T) -> Promise<T> {
+    return Promise { sealant in
+        contain_zalgo(queue) {
+            sealant.resolve(body())
+        }
+    }
+}
+
+// TODO Swift 1.2 thinks that usage of the following two is ambiguous
+//public func dispatch_promise<T>(on queue: dispatch_queue_t = dispatch_get_global_queue(0, 0), body: () -> Promise<T>) -> Promise<T> {
+//    return Promise { sealant in
+//        contain_zalgo(queue) {
+//            body().pipe(sealant.handler)
+//        }
+//    }
+//}
+
+public func dispatch_promise<T>(on: dispatch_queue_t = dispatch_get_global_queue(0, 0), body: () -> (T!, NSError!)) -> Promise<T> {
+    return Promise{ (sealant: Sealant) -> Void in
+        contain_zalgo(on) {
+            let (a, b) = body()
+            sealant.resolve(a, b)
+        }
+    }
+}
+import Foundation.NSError
+
+/**
+ The unhandled error handler.
+
+ If a promise is rejected and no catch handler is called in its chain, the
+ provided handler is called. The default handler logs the error.
+
+    PMKUnhandledErrorHandler = { error in
+        println("Unhandled error: \(error)")
+    }
+
+ @warning *Important* The handler is executed on an undefined queue.
+
+ @warning *Important* Don’t use promises in your handler, or you risk an
+ infinite error loop.
+
+ @return The previous unhandled error handler.
+*/
+public var PMKUnhandledErrorHandler = { (error: NSError) -> Void in
+    if !error.cancelled {
+        NSLog("PromiseKit: Unhandled error: %@", error)
+    }
+}
+
+private class Consumable: NSObject {
+    let parentError: NSError
+    var consumed: Bool = false
+
+    deinit {
+        if !consumed {
+            PMKUnhandledErrorHandler(parentError)
+        }
+    }
+    
+    init(parent: NSError) {
+        // we take a copy to avoid a retain cycle. A weak ref
+        // is no good because then the error is deallocated
+        // before we can call PMKUnhandledErrorHandler()
+        parentError = parent.copy() as! NSError
+    }
+}
+
+private var handle: UInt8 = 0
+
+func consume(error: NSError) {
+    let pmke = objc_getAssociatedObject(error, &handle) as! Consumable
+    pmke.consumed = true
+}
+
+extension AnyPromise {
+    // objc can't see Swift top-level function :(
+    //TODO move this and the one in AnyPromise to a compat something
+    @objc class func __consume(error: NSError) {
+        consume(error)
+    }
+}
+
+func unconsume(error: NSError) {
+    if let pmke = objc_getAssociatedObject(error, &handle) as! Consumable? {
+        pmke.consumed = false
+    } else {
+        // this is how we know when the error is deallocated
+        // because we will be deallocated at the same time
+        objc_setAssociatedObject(error, &handle, Consumable(parent: error), objc_AssociationPolicy(OBJC_ASSOCIATION_RETAIN_NONATOMIC))
+    }
+}
+
+
+
+private struct ErrorPair: Hashable {
+    let domain: String
+    let code: Int
+    init(_ d: String, _ c: Int) {
+        domain = d; code = c
+    }
+    var hashValue: Int {
+        return "\(domain):\(code)".hashValue
+    }
+}
+
+private func ==(lhs: ErrorPair, rhs: ErrorPair) -> Bool {
+    return lhs.domain == rhs.domain && lhs.code == rhs.code
+}
+
+private var cancelledErrorIdentifiers = Set([
+    ErrorPair(PMKErrorDomain, PMKOperationCancelled),
+    ErrorPair(NSURLErrorDomain, NSURLErrorCancelled)
+])
+
+extension NSError {
+    public class func cancelledError() -> NSError {
+        let info: [NSObject: AnyObject] = [NSLocalizedDescriptionKey: "The operation was cancelled"]
+        return NSError(domain: PMKErrorDomain, code: PMKOperationCancelled, userInfo: info)
+    }
+
+    /**
+      You may only call this on the main thread.
+     */
+    public class func registerCancelledErrorDomain(domain: String, code: Int) {
+        cancelledErrorIdentifiers.insert(ErrorPair(domain, code))
+    }
+
+    public var cancelled: Bool {
+        return cancelledErrorIdentifiers.contains(ErrorPair(domain, code))
+    }
+}
+import Foundation
+
+private func b0rkedEmptyRailsResponse() -> NSData {
+    return NSData(bytes: " ", length: 1)
+}
+
+public func NSJSONFromData(data: NSData) -> Promise<NSArray> {
+    if data == b0rkedEmptyRailsResponse() {
+        return Promise(NSArray())
+    } else {
+        return NSJSONFromDataT(data)
+    }
+}
+
+public func NSJSONFromData(data: NSData) -> Promise<NSDictionary> {
+    if data == b0rkedEmptyRailsResponse() {
+        return Promise(NSDictionary())
+    } else {
+        return NSJSONFromDataT(data)
+    }
+}
+
+private func NSJSONFromDataT<T>(data: NSData) -> Promise<T> {
+    var error: NSError?
+    let json: AnyObject? = NSJSONSerialization.JSONObjectWithData(data, options:nil, error:&error)
+
+    if let cast = json as? T {
+        return Promise(cast)
+    } else if let error = error {
+        // NSJSONSerialization gives awful errors, so we wrap it
+        let debug = error.userInfo!["NSDebugDescription"] as? String
+        let description = "The server’s JSON response could not be decoded. (\(debug))"
+        return Promise(NSError(domain: PMKErrorDomain, code: PMKJSONError, userInfo: [
+            NSLocalizedDescriptionKey: "There was an error decoding the server’s JSON response.",
+            NSUnderlyingErrorKey: error
+        ]))
+    } else {
+        var info = [NSObject: AnyObject]()
+        info[NSLocalizedDescriptionKey] = "The server returned JSON in an unexpected arrangement"
+        info[PMKJSONErrorJSONObjectKey] = json
+        return Promise(NSError(domain: PMKErrorDomain, code: PMKJSONError, userInfo: info))
+    }
+}
+import Foundation.NSError
+
+extension Promise {
+    /**
+     @return The error with which this promise was rejected; nil if this promise is not rejected.
+    */
+    public var error: NSError? {
+        switch state.get() {
+        case .None:
+            return nil
+        case .Some(.Fulfilled):
+            return nil
+        case .Some(.Rejected(let error)):
+            return error
+        }
+    }
+
+    /**
+     @return `YES` if the promise has not yet resolved.
+    */
+    public var pending: Bool {
+        return state.get() == nil
+    }
+
+    /**
+     @return `YES` if the promise has resolved.
+    */
+    public var resolved: Bool {
+        return !pending
+    }
+
+    /**
+     @return `YES` if the promise was fulfilled.
+    */
+    public var fulfilled: Bool {
+        return value != nil
+    }
+
+    /**
+     @return `YES` if the promise was rejected.
+    */
+    public var rejected: Bool {
+        return error != nil
+    }
+}
+import Foundation.NSError
+
+public let PMKOperationQueue = NSOperationQueue()
+
+public enum CatchPolicy {
+    case AllErrors
+    case AllErrorsExceptCancellation
+}
+
+/**
+ A promise represents the future value of a task.
+
+ To obtain the value of a promise we call `then`.
+
+ Promises are chainable: `then` returns a promise, you can call `then` on
+ that promise, which  returns a promise, you can call `then` on that
+ promise, et cetera.
+
+ 0.2.4.6.8.0.2.4.6.8.0.2.4.6.8.0.2.4.6.8.0.2.4.6.8.0.2.4.6.8.0.2.4.6.8.0.2
+ Promises start in a pending state and *resolve* with a value to become
+ *fulfilled* or with an `NSError` to become rejected.
+
+ @see [PromiseKit `then` Guide](http://promisekit.org/then/)
+ @see [PromiseKit Chaining Guide](http://promisekit.org/chaining/)
+*/
+public class Promise<T> {
+    let state: State
+
+    /**
+     Create a new pending promise.
+
+     Use this method when wrapping asynchronous systems that do *not* use
+     promises so that they can be involved in promise chains.
+
+     Don’t use this method if you already have promises! Instead, just return
+     your promise!
+
+     The closure you pass is executed immediately on the calling thread.
+
+        func fetchKitten() -> Promise<UIImage> {
+            return Promise { fulfill, reject in
+                KittenFetcher.fetchWithCompletionBlock({ img, err in
+                    if err == nil {
+                        fulfill(img)
+                    } else {
+                        reject(err)
+                    }
+                })
+            }
+        }
+
+     @param resolvers The provided closure is called immediately. Inside,
+     execute your asynchronous system, calling fulfill if it suceeds and
+     reject for any errors.
+
+     @return A new promise.
+
+     @warning *Note* If you are wrapping a delegate-based system, we recommend
+     to use instead: defer
+
+     @see http://promisekit.org/sealing-your-own-promises/
+     @see http://promisekit.org/wrapping-delegation/
+    */
+    public convenience init(@noescape resolvers: (fulfill: (T) -> Void, reject: (NSError) -> Void) -> Void) {
+        self.init(sealant: { sealant in
+            resolvers(fulfill: sealant.resolve, reject: sealant.resolve)
+        })
+    }
+
+    /**
+     Create a new pending promise.
+
+     This initializer is convenient when wrapping asynchronous systems that
+     use common patterns. For example:
+
+        func fetchKitten() -> Promise<UIImage> {
+            return Promise { sealant in
+                KittenFetcher.fetchWithCompletionBlock(sealant.resolve)
+            }
+        }
+
+     @see Sealant
+     @see init(resolvers:)
+    */
+    public init(@noescape sealant: (Sealant<T>) -> Void) {
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        sealant(Sealant(body: resolve))
+    }
+
+    /**
+     Create a new fulfilled promise.
+    */
+    public init(_ value: T) {
+        state = SealedState(resolution: .Fulfilled(value))
+    }
+
+    /**
+     Create a new rejected promise.
+    */
+    public init(_ error: NSError) {
+        unconsume(error)
+        state = SealedState(resolution: .Rejected(error))
+    }
+
+    /**
+      I’d prefer this to be the designated initializer, but then there would be no
+      public designated unsealed initializer! Making this convenience would be
+      inefficient. Not very inefficient, but still it seems distasteful to me.
+     */
+    init(passthru: ((Resolution) -> Void) -> Void) {
+        var resolve: ((Resolution) -> Void)!
+        state = UnsealedState(resolver: &resolve)
+        passthru(resolve)
+    }
+
+    /**
+     defer is convenient for wrapping delegates or larger asynchronous systems.
+
+        class Foo: BarDelegate {
+            let (promise, fulfill, reject) = Promise<Int>.defer()
+    
+            func barDidFinishWithResult(result: Int) {
+                fulfill(result)
+            }
+    
+            func barDidError(error: NSError) {
+                reject(error)
+            }
+        }
+
+     @return A tuple consisting of:
+
+      1) A promise
+      2) A function that fulfills that promise
+      3) A function that rejects that promise
+    */
+
+    public class func defer() -> (promise: Promise, fulfill: (T) -> Void, reject: (NSError) -> Void) {
+        var sealant: Sealant<T>!
+        let promise = Promise { sealant = $0 }
+        return (promise, sealant.resolve, sealant.resolve)
+    }
+
+    func pipe(body: (Resolution) -> Void) {
+        state.get { seal in
+            switch seal {
+            case .Pending(let handlers):
+                handlers.append(body)
+            case .Resolved(let resolution):
+                body(resolution)
+            }
+        }
+    }
+
+    private convenience init<U>(when: Promise<U>, body: (Resolution, (Resolution) -> Void) -> Void) {
+        self.init(passthru: { resolve in
+            when.pipe{ body($0, resolve) }
+        })
+    }
+
+    /**
+     The provided block is executed when this Promise is resolved.
+
+     If you provide a block that takes a parameter, the value of the receiver will be passed as that parameter.
+
+     @param on The queue on which body should be executed.
+
+     @param body The closure that is executed when this Promise is fulfilled.
+
+        [NSURLConnection GET:url].then(^(NSData *data){
+            // do something with data
+        });
+
+     @return A new promise that is resolved with the value returned from the provided closure. For example:
+
+        [NSURLConnection GET:url].then(^(NSData *data){
+            return data.length;
+        }).then(^(NSNumber *number){
+            //…
+        });
+
+     @see thenInBackground
+    */
+    public func then<U>(on q: dispatch_queue_t = dispatch_get_main_queue(), _ body: (T) -> U) -> Promise<U> {
+        return Promise<U>(when: self) { resolution, resolve in
+            switch resolution {
+            case .Rejected:
+                resolve(resolution)
+            case .Fulfilled(let value):
+                contain_zalgo(q) {
+                    resolve(.Fulfilled(body(value as! T)))
+                }
+            }
+        }
+    }
+
+    public func then<U>(on q: dispatch_queue_t = dispatch_get_main_queue(), _ body: (T) -> Promise<U>) -> Promise<U> {
+        return Promise<U>(when: self) { resolution, resolve in
+            switch resolution {
+            case .Rejected:
+                resolve(resolution)
+            case .Fulfilled(let value):
+                contain_zalgo(q) {
+                    body(value as! T).pipe(resolve)
+                }
+            }
+        }
+    }
+
+    public func then(on q: dispatch_queue_t = dispatch_get_main_queue(), body: (T) -> AnyPromise) -> Promise<AnyObject?> {
+        return Promise<AnyObject?>(when: self) { resolution, resolve in
+            switch resolution {
+            case .Rejected:
+                resolve(resolution)
+            case .Fulfilled(let value):
+                contain_zalgo(q) {
+                    let anypromise = body(value as! T)
+                    anypromise.pipe { obj in
+                        if let error = obj as? NSError {
+                            resolve(.Rejected(error))
+                        } else {
+                            // possibly the value of this promise is a PMKManifold, if so
+                            // calling the objc `value` method will return the first item.
+                            let obj: AnyObject? = anypromise.valueForKey("value")
+                            resolve(.Fulfilled(obj))
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     The provided closure is executed on the default background queue when this Promise is fulfilled.
+
+     This method is provided as a convenience for `then`.
+
+     @see then
+    */
+    public func thenInBackground<U>(body: (T) -> U) -> Promise<U> {
+        return then(on: dispatch_get_global_queue(0, 0), body)
+    }
+
+    public func thenInBackground<U>(body: (T) -> Promise<U>) -> Promise<U> {
+        return then(on: dispatch_get_global_queue(0, 0), body)
+    }
+
+    /**
+     The provided closure is executed when this Promise is rejected.
+
+     Rejecting a promise cascades: rejecting all subsequent promises (unless
+     recover is invoked) thus you will typically place your catch at the end
+     of a chain. Often utility promises will not have a catch, instead
+     delegating the error handling to the caller.
+
+     The provided closure always runs on the main queue.
+
+     @param policy The default policy does not execute your handler for
+     cancellation errors. See registerCancellationError for more
+     documentation.
+
+     @param body The handler to execute when this Promise is rejected.
+
+     @see registerCancellationError
+    */
+    public func catch(policy: CatchPolicy = .AllErrorsExceptCancellation, _ body: (NSError) -> Void) {
+        pipe { resolution in
+            switch resolution {
+            case .Fulfilled:
+                break
+            case .Rejected(let error):
+                if policy == .AllErrors || !error.cancelled {
+                    dispatch_async(dispatch_get_main_queue()) {
+                        consume(error)
+                        body(error)
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     The provided closure is executed when this Promise is rejected giving you
+     an opportunity to recover from the error and continue the promise chain.
+    */
+    public func recover(on q: dispatch_queue_t = dispatch_get_main_queue(), _ body: (NSError) -> Promise<T>) -> Promise<T> {
+        return Promise(when: self) { resolution, resolve in
+            switch resolution {
+            case .Rejected(let error):
+                contain_zalgo(q) {
+                    consume(error)
+                    body(error).pipe(resolve)
+                }
+            case .Fulfilled:
+                resolve(resolution)
+            }
+        }
+    }
+
+    /**
+     The provided closure is executed when this Promise is resolved.
+
+     @param on The queue on which body should be executed.
+
+     @param body The closure that is executed when this Promise is resolved.
+
+         UIApplication.sharedApplication().networkActivityIndicatorVisible = true
+         somePromise().then {
+             //…
+         }.finally {
+            UIApplication.sharedApplication().networkActivityIndicatorVisible = false
+         }
+    */
+    public func finally(on q: dispatch_queue_t = dispatch_get_main_queue(), _ body: () -> Void) -> Promise<T> {
+        return Promise(when: self) { resolution, resolve in
+            contain_zalgo(q) {
+                body()
+                resolve(resolution)
+            }
+        }
+    }
+    
+    /**
+     @return The value with which this promise was fulfilled or nil if this
+     promise is not fulfilled.
+    */
+    public var value: T? {
+        switch state.get() {
+        case .None:
+            return nil
+        case .Some(.Fulfilled(let value)):
+            return (value as! T)
+        case .Some(.Rejected):
+            return nil
+        }
+    }
+}
+
+
+/**
+ Zalgo is dangerous.
+
+ Pass as the `on` parameter for a `then`. Causes the handler to be executed
+ as soon as it is resolved. That means it will be executed on the queue it
+ is resolved. This means you cannot predict the queue.
+
+ In the case that the promise is already resolved the handler will be
+ executed immediately.
+
+ zalgo is provided for libraries providing promises that have good tests
+ that prove unleashing zalgo is safe. You can also use it in your
+ application code in situations where performance is critical, but be
+ careful: read the essay at the provided link to understand the risks.
+
+ @see http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony
+*/
+public let zalgo: dispatch_queue_t = dispatch_queue_create("Zalgo", nil)
+
+/**
+ Waldo is dangerous.
+
+ Waldo is zalgo, unless the current queue is the main thread, in which case
+ we dispatch to the default background queue.
+
+ If your block is likely to take more than a few milliseconds to execute,
+ then you should use waldo: 60fps means the main thread cannot hang longer
+ than 17 milliseconds. Don’t contribute to UI lag.
+
+ Conversely if your then block is trivial, use zalgo: GCD is not free and
+ for whatever reason you may already be on the main thread so just do what
+ you are doing quickly and pass on execution.
+
+ It is considered good practice for asynchronous APIs to complete onto the
+ main thread. Apple do not always honor this, nor do other developers.
+ However, they *should*. In that respect waldo is a good choice if your
+ then is going to take a while and doesn’t interact with the UI.
+
+ Please note (again) that generally you should not use zalgo or waldo. The
+ performance gains are neglible and we provide these functions only out of
+ a misguided sense that library code should be as optimized as possible.
+ If you use zalgo or waldo without tests proving their correctness you may
+ unwillingly introduce horrendous, near-impossible-to-trace bugs.
+
+ @see zalgo
+*/
+public let waldo: dispatch_queue_t = dispatch_queue_create("Waldo", nil)
+
+func contain_zalgo(q: dispatch_queue_t, block: () -> Void) {
+    if q === zalgo {
+        block()
+    } else if q === waldo {
+        if NSThread.isMainThread() {
+            dispatch_async(dispatch_get_global_queue(0, 0), block)
+        } else {
+            block()
+        }
+    } else {
+        dispatch_async(q, block)
+    }
+}
+
+
+extension Promise {
+    /**
+     Creates a rejected Promise with `PMKErrorDomain` and a specified localizedDescription and error code.
+    */
+    public convenience init(error: String, code: Int = PMKUnexpectedError) {
+        let error = NSError(domain: "PMKErrorDomain", code: code, userInfo: [NSLocalizedDescriptionKey: error])
+        self.init(error)
+    }
+    
+    /**
+     Promise<Any> is more flexible, and often needed. However Swift won't cast
+     <T> to <Any> directly. Once that is possible we will deprecate this
+     function.
+    */
+    public func asAny() -> Promise<Any> {
+        return Promise<Any>(passthru: pipe)
+    }
+
+    /**
+     Promise<AnyObject> is more flexible, and often needed. However Swift won't
+     cast <T> to <AnyObject> directly. Once that is possible we will deprecate
+     this function.
+    */
+    public func asAnyObject() -> Promise<AnyObject> {
+        return Promise<AnyObject>(passthru: pipe)
+    }
+
+    /**
+     Swift (1.2) seems to be much less fussy about Void promises.
+    */
+    public func asVoid() -> Promise<Void> {
+        return then(on: zalgo) { _ in return }
+    }
+}
+
+
+extension Promise: DebugPrintable {
+    public var debugDescription: String {
+        return "Promise: \(state)"
+    }
+}
+
+/**
+ Firstly can make chains more readable.
+
+ Compare:
+
+    NSURLConnection.GET(url1).then {
+        NSURLConnection.GET(url2)
+    }.then {
+        NSURLConnection.GET(url3)
+    }
+
+ With:
+
+    firstly {
+        NSURLConnection.GET(url1)
+    }.then {
+        NSURLConnection.GET(url2)
+    }.then {
+        NSURLConnection.GET(url3)
+    }
+*/
+public func firstly<T>(promise: () -> Promise<T>) -> Promise<T> {
+    return promise()
+}
+
+public func race<T>(promises: Promise<T>...) -> Promise<T> {
+    return Promise(passthru: { resolve in
+        for promise in promises {
+            promise.pipe(resolve)
+        }
+    })
+}
+import Foundation.NSError
+
+public class Sealant<T> {
+    let handler: (Resolution) -> ()
+
+    init(body: (Resolution) -> Void) {
+        handler = body
+    }
+
+    /** internal because it is dangerous */
+    func __resolve(obj: AnyObject) {
+        switch obj {
+        case is NSError:
+            resolve(obj as! NSError)
+        default:
+            handler(.Fulfilled(obj))
+        }
+    }
+
+    public func resolve(value: T) {
+        handler(.Fulfilled(value))
+    }
+
+    public func resolve(error: NSError!) {
+        unconsume(error)
+        handler(.Rejected(error))
+    }
+
+    /**
+     Makes wrapping (typical) asynchronous patterns easy.
+
+     For example, here we wrap an `MKLocalSearch`:
+
+         func search() -> Promise<MKLocalSearchResponse> {
+             return Promise { sealant in
+                 MKLocalSearch(request: …).startWithCompletionHandler(sealant.resolve)
+             }
+         }
+
+     To get this to work you often have to help the compiler by specifiying
+     the type. In future versions of Swift, this should become unecessary.
+    */
+    public func resolve(obj: T!, var _ error: NSError!) {
+        if obj != nil {
+            handler(.Fulfilled(obj))
+        } else if error != nil {
+            resolve(error)
+        } else {
+            //FIXME couldn't get the constants from the umbrella header :(
+            error = NSError(domain: PMKErrorDomain, code: /*PMKUnexpectedError*/ 1, userInfo: nil)
+            resolve(error)
+        }
+    }
+    
+    public func resolve(obj: T, _ error: NSError!) {
+        if error == nil {
+            handler(.Fulfilled(obj))
+        } else  {
+            resolve(error)
+        }
+    }
+
+    /**
+     Provided for APIs that *still* return [AnyObject] because they suck.
+     FIXME fails
+    */
+//    public func convert(objects: [AnyObject]!, _ error: NSError!) {
+//        if error != nil {
+//            resolve(error)
+//        } else {
+//            handler(.Fulfilled(objects))
+//        }
+//    }
+
+    /**
+     For the case where T is Void. If it isn’t stuff will crash at some point.
+     FIXME crashes when T is Void and .Fulfilled contains Void. Fucking sigh.
+    */
+//    public func ignore<U>(obj: U, _ error: NSError!) {
+//        if error == nil {
+//            handler(.Fulfilled(T))
+//        } else {
+//            resolve(error)
+//        }
+//    }
+}
+import Foundation.NSError
+
+enum Resolution {
+    case Fulfilled(Any)    //TODO make type T when Swift can handle it
+    case Rejected(NSError)
+}
+
+enum Seal {
+    case Pending(Handlers)
+    case Resolved(Resolution)
+}
+
+protocol State {
+    func get() -> Resolution?
+    func get(body: (Seal) -> Void)
+}
+
+class UnsealedState: State {
+    private let barrier = dispatch_queue_create("org.promisekit.barrier", DISPATCH_QUEUE_CONCURRENT)
+    private var seal: Seal
+
+    /**
+     Quick return, but will not provide the handlers array
+     because it could be modified while you are using it by
+     another thread. If you need the handlers, use the second
+     `get` variant.
+    */
+    func get() -> Resolution? {
+        var result: Resolution?
+        dispatch_sync(barrier) {
+            switch self.seal {
+            case .Resolved(let resolution):
+                result = resolution
+            case .Pending:
+                break
+            }
+        }
+        return result
+    }
+
+    func get(body: (Seal) -> Void) {
+        var sealed = false
+        dispatch_sync(barrier) {
+            switch self.seal {
+            case .Resolved:
+                sealed = true
+            case .Pending:
+                sealed = false
+            }
+        }
+        if !sealed {
+            dispatch_barrier_sync(barrier) {
+                switch (self.seal) {
+                case .Pending:
+                    body(self.seal)
+                case .Resolved:
+                    sealed = true  // welcome to race conditions
+                }
+            }
+        }
+        if sealed {
+            body(seal)
+        }
+    }
+
+    init(inout resolver: ((Resolution) -> Void)!) {
+        seal = .Pending(Handlers())
+        resolver = { resolution in
+            var handlers: Handlers?
+            dispatch_barrier_sync(self.barrier) {
+                switch self.seal {
+                case .Pending(let hh):
+                    self.seal = .Resolved(resolution)
+                    handlers = hh
+                case .Resolved:
+                    break
+                }
+            }
+            if let handlers = handlers {
+                for handler in handlers {
+                    handler(resolution)
+                }
+            }
+        }
+    }
+}
+
+class SealedState: State {
+    private let resolution: Resolution
+    
+    init(resolution: Resolution) {
+        self.resolution = resolution
+    }
+    
+    func get() -> Resolution? {
+        return resolution
+    }
+    func get(body: (Seal) -> Void) {
+        body(.Resolved(resolution))
+    }
+}
+
+
+class Handlers: SequenceType {
+    var bodies: [(Resolution)->()] = []
+
+    func append(body: (Resolution)->()) {
+        bodies.append(body)
+    }
+
+    func generate() -> IndexingGenerator<[(Resolution)->()]> {
+        return bodies.generate()
+    }
+
+    var count: Int {
+        return bodies.count
+    }
+}
+
+
+extension Resolution: DebugPrintable {
+    var debugDescription: String {
+        switch self {
+        case Fulfilled(let value):
+            return "Fulfilled with value: \(value)"
+        case Rejected(let error):
+            return "Rejected with error: \(error)"
+        }
+    }
+}
+
+extension UnsealedState: DebugPrintable {
+    var debugDescription: String {
+        var rv: String?
+        get { seal in
+            switch seal {
+            case .Pending(let handlers):
+                rv = "Pending with \(handlers.count) handlers"
+            case .Resolved(let resolution):
+                rv = "\(resolution)"
+            }
+        }
+        return "UnsealedState: \(rv!)"
+    }
+}
+
+extension SealedState: DebugPrintable {
+    var debugDescription: String {
+        return "SealedState: \(resolution)"
+    }
+}
+import Foundation.NSProgress
+
+private func when<T>(promises: [Promise<T>]) -> Promise<Void> {
+    let (rootPromise, fulfill, reject) = Promise<Void>.defer()
+#if !PMKDisableProgress
+    let progress = NSProgress(totalUnitCount: Int64(promises.count))
+    progress.cancellable = false
+    progress.pausable = false
+#else
+    var progress: (completedUnitCount: Int, totalUnitCount: Int) = (0, 0)
+#endif
+    var countdown = promises.count
+
+    for (index, promise) in enumerate(promises) {
+        promise.pipe { resolution in
+            if rootPromise.pending {
+                switch resolution {
+                case .Rejected(let error):
+                    progress.completedUnitCount = progress.totalUnitCount
+                    //TODO PMKFailingPromiseIndexKey
+                    reject(error)
+                case .Fulfilled:
+                    progress.completedUnitCount++
+                    if --countdown == 0 {
+                        fulfill()
+                    }
+                }
+            }
+        }
+    }
+
+    return rootPromise
+}
+
+public func when<T>(promises: [Promise<T>]) -> Promise<[T]> {
+    return when(promises).then(on: zalgo) { promises.map{ $0.value! } }
+}
+
+public func when<T>(promises: Promise<T>...) -> Promise<[T]> {
+    return when(promises)
+}
+
+public func when(promises: Promise<Void>...) -> Promise<Void> {
+    return when(promises)
+}
+
+public func when<U, V>(pu: Promise<U>, pv: Promise<V>) -> Promise<(U, V)> {
+    return when(pu.asVoid(), pv.asVoid()).then(on: zalgo) { (pu.value!, pv.value!) }
+}
+
+public func when<U, V, X>(pu: Promise<U>, pv: Promise<V>, px: Promise<X>) -> Promise<(U, V, X)> {
+    return when(pu.asVoid(), pv.asVoid(), px.asVoid()).then(on: zalgo) { (pu.value!, pv.value!, px.value!) }
+}
+
+@availability(*, unavailable, message="Use `when`")
+public func join<T>(promises: Promise<T>...) {}
+let PMKErrorDomain = "PMKErrorDomain"
+let PMKFailingPromiseIndexKey = "PMKFailingPromiseIndexKey"
+let PMKURLErrorFailingURLResponseKey = "PMKURLErrorFailingURLResponseKey"
+let PMKURLErrorFailingDataKey = "PMKURLErrorFailingDataKey"
+let PMKURLErrorFailingStringKey = "PMKURLErrorFailingStringKey"
+let PMKJSONErrorJSONObjectKey = "PMKJSONErrorJSONObjectKey"
+let PMKUnexpectedError = 1
+let PMKUnknownError = 2
+let PMKInvalidUsageError = 3
+let PMKAccessDeniedError = 4
+let PMKOperationCancelled = 5
+let PMKNotFoundError = 6
+let PMKJSONError = 7
+let PMKOperationFailed = 8
+let PMKTaskError = 9
+let PMKTaskErrorLaunchPathKey = "PMKTaskErrorLaunchPathKey"
+let PMKTaskErrorArgumentsKey = "PMKTaskErrorArgumentsKey"
+let PMKTaskErrorStandardOutputKey = "PMKTaskErrorStandardOutputKey"
+let PMKTaskErrorStandardErrorKey = "PMKTaskErrorStandardErrorKey"
+let PMKTaskErrorExitStatusKey = "PMKTaskErrorExitStatusKey"
diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index 1ae90d21796..a7abd13fae0 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -188,6 +188,11 @@
 		0E2B06F61B2CE45800EA2F53 /* WMFSavedPagesDataSource.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E2B06F51B2CE45800EA2F53 /* WMFSavedPagesDataSource.m */; };
 		0E2B07021B2D1DE200EA2F53 /* WMFBottomStackLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E2B07011B2D1DE200EA2F53 /* WMFBottomStackLayout.m */; };
 		0E366B361B2F176700ABFB86 /* WMFOffScreenFlowLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B351B2F176700ABFB86 /* WMFOffScreenFlowLayout.m */; };
+		0E366B3A1B2F33BC00ABFB86 /* WMFSearchResults.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B391B2F33BC00ABFB86 /* WMFSearchResults.m */; };
+		0E366B3F1B2F5C4500ABFB86 /* WMFSearchFetcher.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B3E1B2F5C4500ABFB86 /* WMFSearchFetcher.m */; };
+		0E366B471B2F614E00ABFB86 /* PromiseKit.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B451B2F614E00ABFB86 /* PromiseKit.m */; };
+		0E366B481B2F614E00ABFB86 /* PromiseKit.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B461B2F614E00ABFB86 /* PromiseKit.swift */; };
+		0E366B4B1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E366B4A1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m */; };
 		0E36C2271AE0B59D00C58CFF /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = D4991453181D51DE00E6073C /* Images.xcassets */; };
 		0E7955C71B2B389800B055A2 /* TGLStackedLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */; };
 		0E7955D01B2B659500B055A2 /* WMFArticleCardTranstion.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E7955CD1B2B659500B055A2 /* WMFArticleCardTranstion.m */; };
@@ -723,11 +728,21 @@
 		0E2B07011B2D1DE200EA2F53 /* WMFBottomStackLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFBottomStackLayout.m; sourceTree = "<group>"; };
 		0E366B341B2F176700ABFB86 /* WMFOffScreenFlowLayout.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFOffScreenFlowLayout.h; sourceTree = "<group>"; };
 		0E366B351B2F176700ABFB86 /* WMFOffScreenFlowLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFOffScreenFlowLayout.m; sourceTree = "<group>"; };
+		0E366B381B2F33BC00ABFB86 /* WMFSearchResults.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFSearchResults.h; sourceTree = "<group>"; };
+		0E366B391B2F33BC00ABFB86 /* WMFSearchResults.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFSearchResults.m; sourceTree = "<group>"; };
+		0E366B3D1B2F5C4500ABFB86 /* WMFSearchFetcher.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFSearchFetcher.h; sourceTree = "<group>"; };
+		0E366B3E1B2F5C4500ABFB86 /* WMFSearchFetcher.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFSearchFetcher.m; sourceTree = "<group>"; };
+		0E366B441B2F614E00ABFB86 /* PromiseKit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PromiseKit.h; sourceTree = "<group>"; };
+		0E366B451B2F614E00ABFB86 /* PromiseKit.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = PromiseKit.m; sourceTree = "<group>"; };
+		0E366B461B2F614E00ABFB86 /* PromiseKit.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = PromiseKit.swift; sourceTree = "<group>"; };
+		0E366B491B308A2600ABFB86 /* UIStoryboard+WMFExtensions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIStoryboard+WMFExtensions.h"; sourceTree = "<group>"; };
+		0E366B4A1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIStoryboard+WMFExtensions.m"; sourceTree = "<group>"; };
 		0E36C2281AE0B5BD00C58CFF /* SourceIcons.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = SourceIcons.xcassets; path = Wikipedia/SourceIcons.xcassets; sourceTree = "<group>"; };
 		0E7955C21B2B389800B055A2 /* TGLStackedLayout.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TGLStackedLayout.h; sourceTree = "<group>"; };
 		0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TGLStackedLayout.m; sourceTree = "<group>"; };
 		0E7955CC1B2B659500B055A2 /* WMFArticleCardTranstion.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFArticleCardTranstion.h; sourceTree = "<group>"; };
 		0E7955CD1B2B659500B055A2 /* WMFArticleCardTranstion.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFArticleCardTranstion.m; sourceTree = "<group>"; };
+		0E7C6D4C1B3106A800F1F985 /* WMFArticleListDataSource.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = WMFArticleListDataSource.h; sourceTree = "<group>"; };
 		0E94AFE91B209721000BC5EA /* iPhone_Root.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; path = iPhone_Root.storyboard; sourceTree = "<group>"; };
 		0E94AFEB1B20976A000BC5EA /* WMFAppViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFAppViewController.h; sourceTree = "<group>"; };
 		0E94AFEC1B20976A000BC5EA /* WMFAppViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFAppViewController.m; sourceTree = "<group>"; };
@@ -1930,6 +1945,7 @@
 		0E2B06F71B2D126700EA2F53 /* Data Sources */ = {
 			isa = PBXGroup;
 			children = (
+				0E7C6D4C1B3106A800F1F985 /* WMFArticleListDataSource.h */,
 				0E2B06F41B2CE45800EA2F53 /* WMFSavedPagesDataSource.h */,
 				0E2B06F51B2CE45800EA2F53 /* WMFSavedPagesDataSource.m */,
 			);
@@ -1941,10 +1957,7 @@
 			children = (
 				0E94AFEE1B209792000BC5EA /* WMFArticleListCollectionViewController.h */,
 				0E94AFEF1B209792000BC5EA /* WMFArticleListCollectionViewController.m */,
-				0E366B341B2F176700ABFB86 /* WMFOffScreenFlowLayout.h */,
-				0E366B351B2F176700ABFB86 /* WMFOffScreenFlowLayout.m */,
-				0E2B07001B2D1DE200EA2F53 /* WMFBottomStackLayout.h */,
-				0E2B07011B2D1DE200EA2F53 /* WMFBottomStackLayout.m */,
+				0E366B371B2F2ACF00ABFB86 /* Layouts */,
 				0E7955BF1B2B389800B055A2 /* TGLStackedViewController */,
 				0E2B06FC1B2D12C400EA2F53 /* Cell */,
 				0E2B06FB1B2D12B300EA2F53 /* Transition */,
@@ -1957,6 +1970,10 @@
 			children = (
 				0E94AFF11B209857000BC5EA /* WMFSearchViewController.h */,
 				0E94AFF21B209857000BC5EA /* WMFSearchViewController.m */,
+				0E366B381B2F33BC00ABFB86 /* WMFSearchResults.h */,
+				0E366B391B2F33BC00ABFB86 /* WMFSearchResults.m */,
+				0E366B3D1B2F5C4500ABFB86 /* WMFSearchFetcher.h */,
+				0E366B3E1B2F5C4500ABFB86 /* WMFSearchFetcher.m */,
 			);
 			name = Search;
 			sourceTree = "<group>";
@@ -1988,6 +2005,27 @@
 			name = Cell;
 			sourceTree = "<group>";
 		};
+		0E366B371B2F2ACF00ABFB86 /* Layouts */ = {
+			isa = PBXGroup;
+			children = (
+				0E366B341B2F176700ABFB86 /* WMFOffScreenFlowLayout.h */,
+				0E366B351B2F176700ABFB86 /* WMFOffScreenFlowLayout.m */,
+				0E2B07001B2D1DE200EA2F53 /* WMFBottomStackLayout.h */,
+				0E2B07011B2D1DE200EA2F53 /* WMFBottomStackLayout.m */,
+			);
+			name = Layouts;
+			sourceTree = "<group>";
+		};
+		0E366B431B2F614E00ABFB86 /* PromiseKit */ = {
+			isa = PBXGroup;
+			children = (
+				0E366B441B2F614E00ABFB86 /* PromiseKit.h */,
+				0E366B451B2F614E00ABFB86 /* PromiseKit.m */,
+				0E366B461B2F614E00ABFB86 /* PromiseKit.swift */,
+			);
+			path = PromiseKit;
+			sourceTree = "<group>";
+		};
 		0E7955BF1B2B389800B055A2 /* TGLStackedViewController */ = {
 			isa = PBXGroup;
 			children = (
@@ -2003,6 +2041,8 @@
 				0E94AFE91B209721000BC5EA /* iPhone_Root.storyboard */,
 				0E94AFEB1B20976A000BC5EA /* WMFAppViewController.h */,
 				0E94AFEC1B20976A000BC5EA /* WMFAppViewController.m */,
+				0E366B491B308A2600ABFB86 /* UIStoryboard+WMFExtensions.h */,
+				0E366B4A1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m */,
 				0E2B06F81B2D127A00EA2F53 /* Article List */,
 				0E2B06F91B2D128D00EA2F53 /* Search */,
 				0E94AFF41B209882000BC5EA /* WMFArticleViewController.h */,
@@ -2460,6 +2500,7 @@
 				D499143E181D51DE00E6073C /* Wikipedia */,
 				0EFB0EF91B31EE2D00D05C08 /* LegacyCoreData */,
 				BCB669A31A83F6C300C7B1FE /* MediaWikiKit */,
+				0E366B431B2F614E00ABFB86 /* PromiseKit */,
 				04E9A78218F73C7200F7ECF7 /* www */,
 				D4991453181D51DE00E6073C /* Images.xcassets */,
 				0E36C2281AE0B5BD00C58CFF /* SourceIcons.xcassets */,
@@ -3050,6 +3091,7 @@
 				BCB669B61A83F6C400C7B1FE /* MWKImageList.m in Sources */,
 				0EFB0F231B31EE2D00D05C08 /* ImageData.m in Sources */,
 				BCB848831AAE0C5C0077EC24 /* WMFImageGalleryCollectionViewCell.m in Sources */,
+				0E366B481B2F614E00ABFB86 /* PromiseKit.swift in Sources */,
 				04B0EA4A190B2348007458AF /* PreviewLicenseView.m in Sources */,
 				0462A6D11A1FE016009412D4 /* SearchResultAttributedString.m in Sources */,
 				0487047F19F8262600B7D307 /* AccountCreator.m in Sources */,
@@ -3111,6 +3153,7 @@
 				0487048119F8262600B7D307 /* ArticleFetcher.m in Sources */,
 				04142A8F184F974E006EF779 /* NSDate-Utilities.m in Sources */,
 				0487048C19F8262600B7D307 /* SearchResultFetcher.m in Sources */,
+				0E366B471B2F614E00ABFB86 /* PromiseKit.m in Sources */,
 				BC23759A1AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.m in Sources */,
 				04090A3B187FB7D000577EDF /* UIView+Debugging.m in Sources */,
 				BCC185D81A9E5628005378F8 /* UILabel+WMFStyling.m in Sources */,
@@ -3212,6 +3255,7 @@
 				04C695D218ED213000D9F2DA /* UIScrollView+NoHorizontalScrolling.m in Sources */,
 				BC3166B21B279AC30096EE8E /* WikipediaAppUtils.m in Sources */,
 				04F0E2EE186FB2D100468738 /* TOCSectionCellView.m in Sources */,
+				0E366B4B1B308A2600ABFB86 /* UIStoryboard+WMFExtensions.m in Sources */,
 				04B0E3EA1AE8252800379AE0 /* NSURL+WMFRest.m in Sources */,
 				040D835E1AB0EE45000896D5 /* WMFGeometry.c in Sources */,
 				BC86B9361A92966B00B4C039 /* AFHTTPRequestOperationManager+UniqueRequests.m in Sources */,
@@ -3247,6 +3291,7 @@
 				0487048219F8262600B7D307 /* AssetsFileFetcher.m in Sources */,
 				BC955BC71A82BEFD000EF9E4 /* MWKImageInfoFetcher.m in Sources */,
 				04C7576E1A1AA2D00084AC39 /* RecentSearchCell.m in Sources */,
+				0E366B3F1B2F5C4500ABFB86 /* WMFSearchFetcher.m in Sources */,
 				BCB58F541A894D3E00465627 /* WMFImageGalleryDetailOverlayView.m in Sources */,
 				04292FF8185FBB0B002A13FC /* SearchResultsController.m in Sources */,
 				BCAFC5D31AFD5F7E004615BA /* MWKArticle+WMFSharing.m in Sources */,
@@ -3258,6 +3303,7 @@
 				0487048319F8262600B7D307 /* FetcherBase.m in Sources */,
 				D4F277FE194235B50032BA38 /* ToCInteractionFunnel.m in Sources */,
 				BCB669B31A83F6C400C7B1FE /* MWKDataStore.m in Sources */,
+				0E366B3A1B2F33BC00ABFB86 /* WMFSearchResults.m in Sources */,
 				0487048D19F8262600B7D307 /* ThumbnailFetcher.m in Sources */,
 				BCB669B01A83F6C400C7B1FE /* MWKRecentSearchEntry.m in Sources */,
 				BC955BCF1A82C2FA000EF9E4 /* AFHTTPRequestOperationManager+WMFConfig.m in Sources */,
diff --git a/Wikipedia/Defines/Defines.h b/Wikipedia/Defines/Defines.h
index 86ef94d2df5..acdef0504fb 100644
--- a/Wikipedia/Defines/Defines.h
+++ b/Wikipedia/Defines/Defines.h
@@ -13,7 +13,6 @@
 #define MENUS_SCALE_MULTIPLIER (CHROME_MENUS_HEIGHT / CHROME_MENUS_HEIGHT_PHONE)
 
 #define SEARCH_THUMBNAIL_WIDTH (48 * 3)
-#define SEARCH_MAX_RESULTS 24
 
 #define HIDE_KEYBOARD_ON_SCROLL_THRESHOLD 55.0f
 
diff --git a/Wikipedia/Global.h b/Wikipedia/Global.h
index e10cd5c892e..5a3ca22fc91 100644
--- a/Wikipedia/Global.h
+++ b/Wikipedia/Global.h
@@ -4,6 +4,7 @@
 
 #import "WMFLogging.h"
 #import "WMFGCDHelpers.h"
+#import <BlocksKit/BlocksKit.h>
 
 #import <libextobjc/EXTScope.h>
 
diff --git a/Wikipedia/Networking/Fetchers/SearchResultFetcher.h b/Wikipedia/Networking/Fetchers/SearchResultFetcher.h
index d30cf11640e..70450e15ff6 100644
--- a/Wikipedia/Networking/Fetchers/SearchResultFetcher.h
+++ b/Wikipedia/Networking/Fetchers/SearchResultFetcher.h
@@ -4,6 +4,7 @@
 #import <Foundation/Foundation.h>
 #import "FetcherBase.h"
 #import "Defines.h"
+#import <AFNetworking/AFHTTPRequestOperation.h>
 
 typedef NS_ENUM (NSInteger, SearchResultFetcherErrorType) {
     SEARCH_RESULT_ERROR_UNKNOWN    = 0,
@@ -36,6 +37,8 @@ typedef NS_ENUM (NSInteger, SearchReason) {
 @property (nonatomic, strong, readonly) NSArray* searchResults;
 @property (nonatomic, strong, readonly) NSString* searchSuggestion;
 
+@property (nonatomic, strong, readonly) NSDictionary* articleTitleToImageMap;
+
 // Kick-off method. Results are reported to "delegate" via the FetchFinishedDelegate protocol method.
 - (instancetype)initAndSearchForTerm:(NSString*)searchTerm
                           searchType:(SearchType)searchType
@@ -44,4 +47,15 @@ typedef NS_ENUM (NSInteger, SearchReason) {
                           maxResults:(NSUInteger)maxResults
                          withManager:(AFHTTPRequestOperationManager*)manager
                   thenNotifyDelegate:(id <FetchFinishedDelegate>)delegate;
+
+
+- (AFHTTPRequestOperation*)searchForTerm:(NSString*)searchTerm
+                              searchType:(SearchType)searchType
+                            searchReason:(SearchReason)searchReason
+                                language:(NSString*)language
+                              maxResults:(NSUInteger)maxResults
+                             withManager:(AFHTTPRequestOperationManager*)manager
+                      thenNotifyDelegate:(id <FetchFinishedDelegate>)delegate;
+
+
 @end
diff --git a/Wikipedia/Networking/Fetchers/SearchResultFetcher.m b/Wikipedia/Networking/Fetchers/SearchResultFetcher.m
index d2625b49984..8600b91d8d3 100644
--- a/Wikipedia/Networking/Fetchers/SearchResultFetcher.m
+++ b/Wikipedia/Networking/Fetchers/SearchResultFetcher.m
@@ -24,6 +24,9 @@ @interface SearchResultFetcher ()
 @property (nonatomic, strong) NSRegularExpression* spaceCollapsingRegex;
 @property (nonatomic, strong) NSString* language;
 
+@property (nonatomic, strong, readwrite) NSDictionary* articleTitleToImageMap;
+
+
 @end
 
 @implementation SearchResultFetcher
@@ -37,29 +40,43 @@ - (instancetype)initAndSearchForTerm:(NSString*)searchTerm
                   thenNotifyDelegate:(id <FetchFinishedDelegate>)delegate {
     self = [super init];
     if (self) {
-        self.searchResults         = @[];
-        self.searchSuggestion      = nil;
-        self.searchTerm            = searchTerm ? searchTerm : @"";
-        self.searchType            = searchType;
-        self.searchReason          = searchReason;
-        self.language              = language;
-        self.fetchFinishedDelegate = delegate;
-        self.maxSearchResults      = maxResults ? maxResults : SEARCH_MAX_RESULTS;
-        self.spaceCollapsingRegex  =
-            [NSRegularExpression regularExpressionWithPattern:@"\\s{2,}+" options:NSRegularExpressionCaseInsensitive error:nil];
-        [self searchWithManager:manager];
+        [self searchForTerm:searchTerm searchType:searchType searchReason:searchReason language:language maxResults:maxResults withManager:manager thenNotifyDelegate:delegate];
     }
     return self;
 }
 
-- (void)searchWithManager:(AFHTTPRequestOperationManager*)manager {
+- (AFHTTPRequestOperation*)searchForTerm:(NSString*)searchTerm
+                              searchType:(SearchType)searchType
+                            searchReason:(SearchReason)searchReason
+                                language:(NSString*)language
+                              maxResults:(NSUInteger)maxResults
+                             withManager:(AFHTTPRequestOperationManager*)manager
+                      thenNotifyDelegate:(id <FetchFinishedDelegate>)delegate{
+    
+    
+    self.searchResults         = @[];
+    self.searchSuggestion      = nil;
+    self.searchTerm            = searchTerm ? searchTerm : @"";
+    self.searchType            = searchType;
+    self.searchReason          = searchReason;
+    self.language              = language;
+    self.fetchFinishedDelegate = delegate;
+    self.maxSearchResults      = maxResults;
+    self.spaceCollapsingRegex  =
+    [NSRegularExpression regularExpressionWithPattern:@"\\s{2,}+" options:NSRegularExpressionCaseInsensitive error:nil];
+    return [self searchWithManager:manager];
+
+}
+
+
+- (AFHTTPRequestOperation* )searchWithManager:(AFHTTPRequestOperationManager*)manager {
     NSString* url = [[SessionSingleton sharedInstance] searchApiUrlForLanguage:self.language];
 
     NSDictionary* params = [self getParams];
 
     [[MWNetworkActivityIndicatorManager sharedManager] push];
 
-    [manager GET:url parameters:params success:^(AFHTTPRequestOperation* operation, id responseObject) {
+    return [manager GET:url parameters:params success:^(AFHTTPRequestOperation* operation, id responseObject) {
         //NSLog(@"JSON: %@", responseObject);
         [[MWNetworkActivityIndicatorManager sharedManager] pop];
 
@@ -84,8 +101,7 @@ - (void)searchWithManager:(AFHTTPRequestOperationManager*)manager {
 
             // Populate the map so the article fetcher can grab thumb
             // from temp dir.
-            NSMutableDictionary* map = [SessionSingleton sharedInstance].titleToTempDirThumbURLMap;
-            [map removeAllObjects];
+            NSMutableDictionary* map = [NSMutableDictionary dictionary];
             for (NSDictionary* result in self.searchResults) {
                 NSString* title = result[@"title"];
                 NSString* thumbUrl = result[@"thumbnail"][@"source"];
@@ -93,20 +109,12 @@ - (void)searchWithManager:(AFHTTPRequestOperationManager*)manager {
                     map[title] = thumbUrl;
                 }
             }
-        }
-
-        // If no matches set error.
-        if (self.searchResults.count == 0) {
-            NSMutableDictionary* errorDict = @{}.mutableCopy;
-
-            errorDict[NSLocalizedDescriptionKey] = MWLocalizedString(@"search-no-matches", nil);
-
-            // Set error condition so dependent ops don't even start and so the errorBlock below will fire.
-            error = [NSError errorWithDomain:@"Search Result Fetcher" code:SEARCH_RESULT_ERROR_NO_MATCHES userInfo:errorDict];
+            self.articleTitleToImageMap = map;
+            
         }
 
         [self finishWithError:error
-                  fetchedData:nil];
+                  fetchedData:self.searchResults];
     } failure:^(AFHTTPRequestOperation* operation, NSError* error) {
         //NSLog(@"CAPTCHA RESETTER FAIL = %@", error);
 
diff --git a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
index ae348ee6a45..f0566e4af69 100644
--- a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
+++ b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
@@ -81,8 +81,8 @@ - (instancetype)initWithCoder:(NSCoder*)aDecoder {
 }
 
 - (void)initLayout {
-    self.layoutMargin = UIEdgeInsetsMake(20.0, 0.0, 0.0, 0.0);
-    self.topReveal    = 120.0;
+    self.layoutMargin = UIEdgeInsetsMake(0.0, 0.0, 0.0, 0.0);
+    self.topReveal    = 140.0;
     self.bounceFactor = 0.2;
 }
 
diff --git a/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h
new file mode 100644
index 00000000000..e0801bf8be0
--- /dev/null
+++ b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h
@@ -0,0 +1,10 @@
+
+#import <UIKit/UIKit.h>
+
+@interface UIStoryboard (WMFExtensions)
+
++ (UIStoryboard*)wmf_appRootStoryBoard;
+
+- (id)wmf_instantiateViewControllerWithIdentifierFromClass:(Class)viewControllerClass;
+
+@end
diff --git a/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m
new file mode 100644
index 00000000000..7237dd27479
--- /dev/null
+++ b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m
@@ -0,0 +1,18 @@
+
+#import "UIStoryboard+WMFExtensions.h"
+
+NSString* const WMFDefaultStoryBoardName = @"iPhone_Root";
+
+@implementation UIStoryboard (WMFExtensions)
+
++ (UIStoryboard*)wmf_appRootStoryBoard {
+    return [UIStoryboard storyboardWithName:WMFDefaultStoryBoardName bundle:nil];
+}
+
+- (id)wmf_instantiateViewControllerWithIdentifierFromClass:(Class)viewControllerClass{
+    
+    return [self instantiateViewControllerWithIdentifier:NSStringFromClass(viewControllerClass)];
+}
+
+
+@end
diff --git a/Wikipedia/UI-V5/WMFAppViewController.h b/Wikipedia/UI-V5/WMFAppViewController.h
index f1bcf6cc47a..fd56304edb2 100644
--- a/Wikipedia/UI-V5/WMFAppViewController.h
+++ b/Wikipedia/UI-V5/WMFAppViewController.h
@@ -1,12 +1,6 @@
 
 #import <UIKit/UIKit.h>
 
-@interface UIStoryboard (WMFDefaultStoryBoard)
-
-+ (UIStoryboard*)wmf_defaultStoryBoard;
-
-@end
-
 @interface WMFAppViewController : UIViewController
 
 + (instancetype)initialAppViewControllerFromDefaultStoryBoard;
diff --git a/Wikipedia/UI-V5/WMFAppViewController.m b/Wikipedia/UI-V5/WMFAppViewController.m
index e9fde108d7e..3a4c24ce132 100644
--- a/Wikipedia/UI-V5/WMFAppViewController.m
+++ b/Wikipedia/UI-V5/WMFAppViewController.m
@@ -6,18 +6,12 @@
 #import "WMFArticleListCollectionViewController.h"
 #import "DataMigrationProgressViewController.h"
 #import "WMFSavedPagesDataSource.h"
-
-NSString* const WMFDefaultStoryBoardName = @"iPhone_Root";
-
-@implementation UIStoryboard (WMFDefaultStoryBoard)
-
-+ (UIStoryboard*)wmf_defaultStoryBoard {
-    return [UIStoryboard storyboardWithName:WMFDefaultStoryBoardName bundle:nil];
-}
-
-@end
+#import "UIStoryboard+WMFExtensions.h"
+#import <Masonry/Masonry.h>
 
 @interface WMFAppViewController ()<WMFSearchViewControllerDelegate>
+@property (strong, nonatomic) IBOutlet UIView *searchContainerView;
+@property (strong, nonatomic) IBOutlet UIView *articleListContainerView;
 
 @property (nonatomic, strong) IBOutlet UIView* splashView;
 @property (nonatomic, strong) WMFArticleListCollectionViewController* listViewController;
@@ -25,17 +19,31 @@ @interface WMFAppViewController ()<WMFSearchViewControllerDelegate>
 
 @property (nonatomic, strong) SessionSingleton* session;
 
+@property (nonatomic, strong) MASConstraint *articleListVisibleConstraint;
+@property (nonatomic, strong) MASConstraint *articleListMinimizedConstraint;
+
 @end
 
 @implementation WMFAppViewController
 
+- (SessionSingleton*)session{
+    
+    if(!_session){
+        
+        _session = [SessionSingleton sharedInstance];
+    }
+    
+    return _session;
+}
+
 #pragma mark - Setup
 
 + (WMFAppViewController*)initialAppViewControllerFromDefaultStoryBoard {
-    return [[UIStoryboard wmf_defaultStoryBoard] instantiateInitialViewController];
+    return [[UIStoryboard wmf_appRootStoryBoard] instantiateInitialViewController];
 }
 
 - (void)launchAppInWindow:(UIWindow*)window {
+    
     WMFStyleManager* manager = [WMFStyleManager new];
     [manager applyStyleToWindow:window];
     [WMFStyleManager setSharedStyleManager:manager];
@@ -45,8 +53,12 @@ - (void)launchAppInWindow:(UIWindow*)window {
 }
 
 - (void)loadMainUI {
-    WMFSavedPagesDataSource* dataSource = [[WMFSavedPagesDataSource alloc] initWithUserDataStore:[self userDataStore]];
-    self.listViewController.dataSource = dataSource;
+    
+    [self updateListViewBasedOnSearchState:self.searchViewController.state];
+
+    self.searchViewController.searchSite = [self.session searchSite];
+    self.searchViewController.dataStore = [self.session dataStore];
+    self.listViewController.dataSource = [[WMFSavedPagesDataSource alloc] initWithUserDataStore:[self userDataStore]];;
 }
 
 - (void)resumeApp {
@@ -68,8 +80,6 @@ - (MWKUserDataStore*)userDataStore {
 - (void)viewDidLoad {
     [super viewDidLoad];
 
-    self.session = [SessionSingleton sharedInstance];
-
     [self showSplashView];
 
     [self runDataMigrationIfNeededWithCompletion:^{
@@ -79,13 +89,13 @@ - (void)viewDidLoad {
 }
 
 - (void)prepareForSegue:(UIStoryboardSegue*)segue sender:(id)sender {
-    if ([segue.destinationViewController isKindOfClass:[WMFArticleListCollectionViewController class]]) {
-        self.listViewController = segue.destinationViewController;
-    }
     if ([segue.destinationViewController isKindOfClass:[WMFSearchViewController class]]) {
         self.searchViewController = segue.destinationViewController;
         self.searchViewController.delegate = self;
     }
+    if ([segue.destinationViewController isKindOfClass:[WMFArticleListCollectionViewController class]]) {
+        self.listViewController = segue.destinationViewController;
+    }
 }
 
 - (BOOL)shouldAutorotate {
@@ -145,15 +155,43 @@ - (void)runDataMigrationIfNeededWithCompletion:(dispatch_block_t)completion {
 
 #pragma mark - WMFSearchViewControllerDelegate
 
-- (void)searchControllerSearchDidStartSearching:(WMFSearchViewController*)controller{
-    
-    [self.listViewController setListMode:WMFArticleListModeBottomStacked animated:YES];
+- (void)searchController:(WMFSearchViewController*)controller searchStateDidChange:(WMFSearchState)state{
+
+    [self updateListViewBasedOnSearchState:state];
 }
 
-- (void)searchControllerSearchDidFinishSearching:(WMFSearchViewController*)controller{
+- (void)updateListViewBasedOnSearchState:(WMFSearchState)state{
     
-    [self.listViewController setListMode:WMFArticleListModeNormal animated:YES];
+    switch (state) {
+        case WMFSearchStateInactive:{
+          
+            [self.articleListMinimizedConstraint uninstall];
+            [self.articleListContainerView mas_makeConstraints:^(MASConstraintMaker *make) {
+                self.articleListVisibleConstraint = make.top.equalTo(self.view.mas_top).with.offset(64.0);
+            }];
+            [self.view layoutIfNeeded];
+            
+            [self.listViewController setListMode:WMFArticleListModeNormal animated:YES completion:NULL];
+            
+        }
+            break;
+        case WMFSearchStateActive:{
+            
+            @weakify(self);
+            [self.listViewController setListMode:WMFArticleListModeBottomStacked animated:YES completion:^{
+                @strongify(self);
+                [self.articleListVisibleConstraint uninstall];
+                [self.articleListContainerView mas_makeConstraints:^(MASConstraintMaker *make) {
+                    self.articleListMinimizedConstraint = make.top.equalTo(self.view.mas_bottom).with.offset(-50.0);
+                }];
+                [self.view layoutIfNeeded];
+            }];
+
+        }
+            break;
+    }
 }
 
 
+
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
index f1972e47598..e394c886567 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
@@ -1,17 +1,8 @@
 
 #import <UIKit/UIKit.h>
+#import "WMFArticleListDataSource.h"
 
-@protocol WMFArticleListDataSource <NSObject>
-
-- (NSString*)displayTitle;
-
-- (NSUInteger) articleCount;
-- (MWKArticle*)articleForIndexPath:(NSIndexPath*)indexPath;
-
-- (BOOL)canDeleteItemAtIndexpath:(NSIndexPath*)indexPath;
-- (void)deleteArticleAtIndexPath:(NSIndexPath*)indexPath;
-
-@end
+NS_ASSUME_NONNULL_BEGIN
 
 typedef NS_ENUM(NSUInteger, WMFArticleListMode) {
     
@@ -21,10 +12,13 @@ typedef NS_ENUM(NSUInteger, WMFArticleListMode) {
 
 @interface WMFArticleListCollectionViewController : UICollectionViewController
 
-@property (nonatomic, strong) id<WMFArticleListDataSource> dataSource;
+@property (nonatomic, strong, nullable) id<WMFArticleListDataSource> dataSource;
 
 @property (nonatomic, assign, readonly) WMFArticleListMode mode;
 
-- (void)setListMode:(WMFArticleListMode)mode animated:(BOOL)animated;
+- (void)setListMode:(WMFArticleListMode)mode animated:(BOOL)animated completion:(nullable dispatch_block_t)completion;
 
 @end
+
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
index 70acaa5ee61..c87f773cc3b 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
@@ -26,9 +26,20 @@ @interface WMFArticleListCollectionViewController ()<TGLStackedLayoutDelegate>
 
 @implementation WMFArticleListCollectionViewController
 
+- (void)setDataSource:(id<WMFArticleListDataSource> __nullable)dataSource{
+    
+    _dataSource = dataSource;
+    
+    self.title = [_dataSource displayTitle];
+
+    if([self isViewLoaded]){
+        [self.collectionView reloadData];
+    }
+}
+
 #pragma mark - List Mode
 
-- (void)setListMode:(WMFArticleListMode)mode animated:(BOOL)animated{
+- (void)setListMode:(WMFArticleListMode)mode animated:(BOOL)animated completion:(nullable dispatch_block_t)completion{
     
     if(_mode == mode){
         return;
@@ -37,11 +48,11 @@ - (void)setListMode:(WMFArticleListMode)mode animated:(BOOL)animated{
     _mode = mode;
     
     if([self isViewLoaded]){
-        [self updateListForMode:_mode animated:animated];
+        [self updateListForMode:_mode animated:animated completion:completion];
     }
 }
 
-- (void)updateListForMode:(WMFArticleListMode)mode animated:(BOOL)animated{
+- (void)updateListForMode:(WMFArticleListMode)mode animated:(BOOL)animated completion:(nullable dispatch_block_t)completion{
 
 
     UICollectionViewLayout* layout;
@@ -62,15 +73,19 @@ - (void)updateListForMode:(WMFArticleListMode)mode animated:(BOOL)animated{
     }
     
 
-    __weak __typeof(self)weakSelf = self;
+    @weakify(self);
     [self setOffsecreenLayoutAnimated:animated completion:^(BOOL finished) {
-        __strong __typeof(weakSelf)strongSelf = weakSelf;
-        [strongSelf.collectionView setCollectionViewLayout:layout animated:animated completion:^(BOOL finished) {
-            __strong __typeof(weakSelf)strongSelf = weakSelf;
+        @strongify(self);
+        [self.collectionView wmf_setCollectionViewLayout:layout animated:animated alwaysFireCompletion:^(BOOL finished) {
+            @strongify(self);
             if(mode == WMFArticleListModeBottomStacked){
-                strongSelf.collectionView.scrollEnabled = NO;
+                self.collectionView.scrollEnabled = NO;
             }else{
-                strongSelf.collectionView.scrollEnabled = YES;
+                self.collectionView.scrollEnabled = YES;
+            }
+            
+            if(completion){
+                completion();
             }
         }];
     }];
@@ -121,10 +136,10 @@ - (WMFBottomStackLayout*)bottomStackLayout {
 
 - (void)viewDidLoad {
     [super viewDidLoad];
-
-    self.title = [self.dataSource displayTitle];
     
-    [self updateListForMode:self.mode animated:NO];
+    self.collectionView.backgroundColor = [UIColor clearColor];
+
+    [self updateListForMode:self.mode animated:NO completion:NULL];
 }
 
 - (void)viewWillAppear:(BOOL)animated {
@@ -133,7 +148,6 @@ - (void)viewWillAppear:(BOOL)animated {
 
 - (void)viewDidAppear:(BOOL)animated {
     [super viewDidAppear:animated];
-    [self updateCellSizeBasedOnViewFrame];
 
 
 
@@ -150,6 +164,7 @@ - (void)viewDidAppear:(BOOL)animated {
 
 - (void)viewDidLayoutSubviews {
     [super viewDidLayoutSubviews];
+    [self updateCellSizeBasedOnViewFrame];
 }
 
 - (BOOL)shouldAutorotate {
@@ -250,7 +265,10 @@ - (BOOL)stackLayout:(TGLStackedLayout*)layout canDeleteItemAtIndexPath:(NSIndexP
 }
 
 - (void)stackLayout:(TGLStackedLayout*)layout deleteItemAtIndexPath:(NSIndexPath*)indexPath {
-    [self.dataSource deleteArticleAtIndexPath:indexPath];
+    
+    if([self.dataSource respondsToSelector:@selector(deleteArticleAtIndexPath:)]){
+        [self.dataSource deleteArticleAtIndexPath:indexPath];        
+    }
 }
 
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleListDataSource.h b/Wikipedia/UI-V5/WMFArticleListDataSource.h
new file mode 100644
index 00000000000..e5d8a8373c9
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticleListDataSource.h
@@ -0,0 +1,20 @@
+
+#import <Foundation/Foundation.h>
+
+NS_ASSUME_NONNULL_BEGIN
+
+@protocol WMFArticleListDataSource <NSObject>
+
+- (nullable NSString*)displayTitle;
+
+- (NSUInteger)articleCount;
+- (MWKArticle*)articleForIndexPath:(NSIndexPath*)indexPath;
+
+- (BOOL)canDeleteItemAtIndexpath:(NSIndexPath*)indexPath;
+
+@optional
+- (void)deleteArticleAtIndexPath:(NSIndexPath*)indexPath;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSavedPagesDataSource.h b/Wikipedia/UI-V5/WMFSavedPagesDataSource.h
index c78b11cef6a..b51d9361288 100644
--- a/Wikipedia/UI-V5/WMFSavedPagesDataSource.h
+++ b/Wikipedia/UI-V5/WMFSavedPagesDataSource.h
@@ -1,11 +1,15 @@
 
 #import <Foundation/Foundation.h>
-#import "WMFArticleListCollectionViewController.h"
+#import "WMFArticleListDataSource.h"
+
+NS_ASSUME_NONNULL_BEGIN
 
 @interface WMFSavedPagesDataSource : NSObject<WMFArticleListDataSource>
 
 @property (nonatomic, strong, readonly) MWKUserDataStore* userDataStore;
 
-- (instancetype)initWithUserDataStore:(MWKUserDataStore*)store;
+- (nonnull instancetype)initWithUserDataStore:(MWKUserDataStore*)store;
 
 @end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSavedPagesDataSource.m b/Wikipedia/UI-V5/WMFSavedPagesDataSource.m
index 2fc6e93428f..830f233c0d3 100644
--- a/Wikipedia/UI-V5/WMFSavedPagesDataSource.m
+++ b/Wikipedia/UI-V5/WMFSavedPagesDataSource.m
@@ -5,6 +5,8 @@
 #import "MWKSavedPageEntry.h"
 #import "MWKArticle.h"
 
+NS_ASSUME_NONNULL_BEGIN
+
 @interface WMFSavedPagesDataSource ()
 
 @property (nonatomic, strong, readwrite) MWKUserDataStore* userDataStore;
@@ -20,8 +22,8 @@ - (instancetype)initWithUserDataStore:(MWKUserDataStore*)store {
     }
     return self;
 }
-
-- (NSString*)displayTitle {
+    
+- (nullable NSString*)displayTitle{
     return MWLocalizedString(@"saved-pages-title", nil);
 }
 
@@ -56,3 +58,5 @@ - (void)deleteArticleAtIndexPath:(NSIndexPath*)indexPath {
 }
 
 @end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSearchFetcher.h b/Wikipedia/UI-V5/WMFSearchFetcher.h
new file mode 100644
index 00000000000..2fb435ee421
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFSearchFetcher.h
@@ -0,0 +1,22 @@
+
+#import <Foundation/Foundation.h>
+#import "PromiseKit.h"
+
+@class MWKSite;
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface WMFSearchFetcher : NSObject
+
+@property (nonatomic, strong, readonly) MWKSite* searchSite;
+@property (nonatomic, strong, readonly) MWKDataStore* dataStore;
+
+- (instancetype)initWithSearchSite:(MWKSite*)site dataStore:(MWKDataStore*)dataStore;
+
+@property (nonatomic, assign) NSUInteger maxSearchResults;
+
+- (AnyPromise*)searchArticleTitlesForSearchTerm:(NSString*)searchTerm;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSearchFetcher.m b/Wikipedia/UI-V5/WMFSearchFetcher.m
new file mode 100644
index 00000000000..399093acd9a
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFSearchFetcher.m
@@ -0,0 +1,106 @@
+
+#import "WMFSearchFetcher.h"
+#import "AFHTTPRequestOperationManager+WMFConfig.h"
+#import "SearchResultFetcher.h"
+#import "WMFSearchResults.h"
+
+NSUInteger const kWMFmaxSearchResults = 24;
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface WMFSearchFetcher ()<FetchFinishedDelegate>
+
+@property (nonatomic, strong, readwrite) MWKSite* searchSite;
+@property (nonatomic, strong, readwrite) MWKDataStore* dataStore;
+
+@property (nonatomic, strong) AFHTTPRequestOperationManager* operationManager;
+
+@property (nonatomic, strong) SearchResultFetcher* fetcher;
+
+@property (nonatomic, strong, nullable) AFHTTPRequestOperation* operation;
+@property (nonatomic, copy, nullable) PMKResolver resolver;
+
+@property (nonatomic, strong, nullable) WMFSearchResults* previousResults;
+
+@end
+
+@implementation WMFSearchFetcher
+
+- (instancetype)initWithSearchSite:(MWKSite*)site dataStore:(MWKDataStore*)dataStore{
+
+    self = [super init];
+    if (self) {
+        self.searchSite = site;
+        self.dataStore = dataStore;
+        self.maxSearchResults = kWMFmaxSearchResults;
+        AFHTTPRequestOperationManager* manager = [AFHTTPRequestOperationManager wmf_createDefaultManager];
+        manager.responseSerializer = [AFHTTPResponseSerializer serializer];
+        self.operationManager = manager;
+    }
+    return self;
+}
+
+- (AnyPromise*)searchArticleTitlesForSearchTerm:(NSString*)searchTerm searchType:(SearchType)type{
+    
+    [self.operation cancel];
+    
+    return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {
+        
+        self.resolver = resolve;
+        
+        self.fetcher = [[SearchResultFetcher alloc] init];
+        self.operation = [self.fetcher searchForTerm:searchTerm searchType:type searchReason:SEARCH_REASON_UNKNOWN language:self.searchSite.language maxResults:self.maxSearchResults withManager:self.operationManager thenNotifyDelegate:self];
+    }];
+}
+
+- (AnyPromise*)searchArticleTitlesForSearchTerm:(NSString*)searchTerm{
+    
+    return [self searchArticleTitlesForSearchTerm:searchTerm searchType:SEARCH_TYPE_TITLES];
+}
+
+
+- (AnyPromise*)searchFullArticleTextForSearchTerm:(NSString*)searchTerm appendToPreviousResults:(WMFSearchResults*)results{
+    
+    self.previousResults = results;
+    return [self searchArticleTitlesForSearchTerm:searchTerm searchType:SEARCH_TYPE_IN_ARTICLES];
+}
+
+- (void)fetchFinished:(id)sender
+          fetchedData:(id)fetchedData
+               status:(FetchFinalStatus)status
+                error:(NSError*)error{
+    
+    if(self.resolver){
+
+        if(!error){
+            self.resolver([self searchResultsFromFetcher:sender]);
+        }else{
+            self.resolver(error);
+        }
+        self.operation = nil;
+        self.resolver = nil;
+    }
+}
+
+- (WMFSearchResults*)searchResultsFromFetcher:(SearchResultFetcher*)resultsFetcher{
+    
+    NSArray* articles = [resultsFetcher.searchResults bk_map:^id(NSDictionary* obj) {
+        
+        MWKTitle* title = [MWKTitle titleWithString:obj[@"title"] site:self.searchSite];
+        MWKArticle* article = [[MWKArticle alloc] initWithTitle:title dataStore:self.dataStore searchResultsDict:obj];
+        article.thumbnailURL = resultsFetcher.articleTitleToImageMap[title.text];
+        [article loadThumbnailFromDisk];
+        
+        return article;
+    }];
+    
+    WMFSearchResults* results = [[WMFSearchResults alloc] initWithSearchTerm:resultsFetcher.searchTerm articles:articles searchSuggestion:resultsFetcher.searchSuggestion];
+
+    return results;
+}
+
+
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSearchResults.h b/Wikipedia/UI-V5/WMFSearchResults.h
new file mode 100644
index 00000000000..a7cc7452507
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFSearchResults.h
@@ -0,0 +1,19 @@
+
+#import <Foundation/Foundation.h>
+#import "WMFArticleListDataSource.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface WMFSearchResults : NSObject<WMFArticleListDataSource>
+
+@property (nonatomic, copy, readonly) NSString* searchTerm;
+@property (nonatomic, strong, nullable, readonly) NSArray* resultArticles;
+@property (nonatomic, copy, nullable, readonly) NSString* searchSuggestion;
+
+- (instancetype)initWithSearchTerm:(NSString*)searchTerm articles:(nullable NSArray*)articles searchSuggestion:(nullable NSString*)suggestion;
+
+- (BOOL)noResults;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSearchResults.m b/Wikipedia/UI-V5/WMFSearchResults.m
new file mode 100644
index 00000000000..984473cc0e2
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFSearchResults.m
@@ -0,0 +1,55 @@
+
+#import "WMFSearchResults.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface WMFSearchResults ()
+
+@property (nonatomic, copy, readwrite) NSString* searchTerm;
+@property (nonatomic, strong, nullable, readwrite) NSArray* resultArticles;
+@property (nonatomic, copy, nullable, readwrite) NSString* searchSuggestion;
+
+@end
+
+@implementation WMFSearchResults
+
+- (instancetype)initWithSearchTerm:(NSString*)searchTerm articles:(nullable NSArray*)articles searchSuggestion:(nullable NSString*)suggestion{
+
+    self = [super init];
+    if (self) {
+        self.searchTerm = searchTerm;
+        self.resultArticles = articles;
+        self.searchSuggestion = suggestion;
+    }
+    return self;
+}
+
+- (nullable NSString*)displayTitle{
+    return self.searchTerm;
+}
+
+- (NSUInteger)articleCount{
+    return [self.resultArticles count];
+}
+
+- (MWKArticle*)articleForIndexPath:(NSIndexPath*)indexPath {
+    return self.resultArticles[indexPath.row];
+}
+
+- (BOOL)canDeleteItemAtIndexpath:(NSIndexPath*)indexPath{
+    return NO;
+}
+
+
+- (BOOL)noResults{
+    
+    if(self.searchTerm && [self.resultArticles count] == 0){
+        return YES;
+    }
+    return NO;
+}
+
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/WMFSearchViewController.h b/Wikipedia/UI-V5/WMFSearchViewController.h
index 6cf9960e187..f17947d6154 100644
--- a/Wikipedia/UI-V5/WMFSearchViewController.h
+++ b/Wikipedia/UI-V5/WMFSearchViewController.h
@@ -1,23 +1,30 @@
-//
-//  WMFSearchViewController.h
-//  Wikipedia
-//
-//  Created by Corey Floyd on 6/4/15.
-//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
-//
 
 @protocol WMFSearchViewControllerDelegate;
 
+NS_ASSUME_NONNULL_BEGIN
+
+typedef NS_ENUM(NSUInteger, WMFSearchState) {
+    
+    WMFSearchStateInactive,
+    WMFSearchStateActive
+};
+
 @interface WMFSearchViewController : UIViewController
 
-@property(nonatomic, weak) id<WMFSearchViewControllerDelegate> delegate;
+@property (nonatomic, strong) MWKSite* searchSite;
+@property (nonatomic, strong) MWKDataStore* dataStore;
+
+@property(nonatomic, weak, nullable) id<WMFSearchViewControllerDelegate> delegate;
+
+@property (nonatomic, assign, readonly) WMFSearchState state;
+
 @end
 
 
 @protocol WMFSearchViewControllerDelegate <NSObject>
 
-- (void)searchControllerSearchDidStartSearching:(WMFSearchViewController*)controller;
-
-- (void)searchControllerSearchDidFinishSearching:(WMFSearchViewController*)controller;
+- (void)searchController:(WMFSearchViewController*)controller searchStateDidChange:(WMFSearchState)state;
 
 @end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/Wikipedia/UI-V5/WMFSearchViewController.m b/Wikipedia/UI-V5/WMFSearchViewController.m
index d4db31059aa..80409420fd7 100644
--- a/Wikipedia/UI-V5/WMFSearchViewController.m
+++ b/Wikipedia/UI-V5/WMFSearchViewController.m
@@ -1,26 +1,47 @@
-//
-//  WMFSearchViewController.m
-//  Wikipedia
-//
-//  Created by Corey Floyd on 6/4/15.
-//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
-//
 
 #import "WMFSearchViewController.h"
 #import "WMFArticleListCollectionViewController.h"
 
+#import "WMFSearchFetcher.h"
+#import "WMFSearchResults.h"
+
+#import "SearchDidYouMeanButton.h"
+
 @interface WMFSearchViewController ()
 
 @property (nonatomic, strong) WMFArticleListCollectionViewController* resultsListController;
 @property (strong, nonatomic) IBOutlet UISearchBar *searchBar;
+@property (strong, nonatomic) IBOutlet UIButton *searchSuggestionButton;
+
+@property (nonatomic, strong) WMFSearchFetcher* fetcher;
+
+@property (nonatomic, assign, readwrite) WMFSearchState state;
 
 @end
 
 @implementation WMFSearchViewController
 
+- (NSString*)currentSearchTerm{
+    return [(WMFSearchResults*)self.resultsListController.dataSource searchTerm];
+}
+
+- (void)updateSearchStateAndNotifyDelegate:(WMFSearchState)state{
+    
+    if(self.state == state){
+        return;
+    }
+    
+    self.state = state;
+
+    [self.delegate searchController:self searchStateDidChange:self.state];
+}
+
+#pragma mark - UIViewController
+
 - (void)viewDidLoad {
     [super viewDidLoad];
-    // Do any additional setup after loading the view.
+    
+    self.searchSuggestionButton.hidden = YES;
 }
 
 - (void)prepareForSegue:(UIStoryboardSegue*)segue sender:(id)sender {
@@ -29,18 +50,39 @@ - (void)prepareForSegue:(UIStoryboardSegue*)segue sender:(id)sender {
     }
 }
 
-
 #pragma mark - UISearchBarDelegate
 
 - (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar{
     
-    [self.delegate searchControllerSearchDidStartSearching:self];
+    [self updateSearchStateAndNotifyDelegate:WMFSearchStateActive];
+    
     [self.searchBar setShowsCancelButton:YES animated:YES];
+    
+    self.fetcher = [[WMFSearchFetcher alloc] initWithSearchSite:self.searchSite dataStore:self.dataStore];
+    
+    if([self.searchBar.text length] > 2){
+        
+        if(![[self currentSearchTerm] isEqualToString:self.searchBar.text]){
+            [self searchForSearchTerm:self.searchBar.text];
+        }
+
+    }else{
+        
+        self.resultsListController.dataSource = nil;
+    }
 }
 
 - (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText{
     
-    
+    if(searchText.length > 2){
+        
+        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
+            
+            if([searchText isEqualToString:self.searchBar.text]){
+                [self searchForSearchTerm:searchText];
+            }
+        });
+    }
 }
 
 
@@ -56,12 +98,46 @@ - (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar{
 
 - (void)searchBarCancelButtonClicked:(UISearchBar *)searchBar{
     
-    
-    [self.delegate searchControllerSearchDidFinishSearching:self];
+    [self updateSearchStateAndNotifyDelegate:WMFSearchStateInactive];
+
     [self.searchBar setShowsCancelButton:NO animated:YES];
     [self.searchBar resignFirstResponder];
 }
 
 
+#pragma mark - Search
+
+- (void)searchForSearchTerm:(NSString*)searchTerm{
+    
+    [self.fetcher searchArticleTitlesForSearchTerm:searchTerm].then(^(WMFSearchResults* results){
+        
+        self.title = results.searchTerm;
+        
+        [self updateSearchButtonWithResults:results];
+        
+        self.resultsListController.dataSource = results;
+
+    }).catch(^(NSError* error){
+        
+        NSLog(@"%@", [error description]);
+    });
+    
+}
+
+- (void)updateSearchButtonWithResults:(WMFSearchResults*)results{
+    
+//    if(![results noResults] && [results.searchSuggestion length]){
+//        
+//        self.searchSuggestionButton.hidden = NO;
+//        
+//        [self.searchSuggestionButton setTitle:[NSString stringWithFormat:@"%@:%@", MWLocalizedString(@"search-did-you-mean", nil), results.searchSuggestion] forState:UIControlStateNormal];
+//        
+//    }else{
+//        
+//        self.searchSuggestionButton.hidden = YES;
+//    }
+
+}
+
 
 @end
diff --git a/Wikipedia/UI-V5/iPhone_Root.storyboard b/Wikipedia/UI-V5/iPhone_Root.storyboard
index 62b1cb1511d..0f11e9ec398 100644
--- a/Wikipedia/UI-V5/iPhone_Root.storyboard
+++ b/Wikipedia/UI-V5/iPhone_Root.storyboard
@@ -69,7 +69,7 @@
                         <animations/>
                         <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
                         <constraints>
-                            <constraint firstItem="h62-i6-ynd" firstAttribute="top" secondItem="tHL-ym-Gfa" secondAttribute="bottom" constant="44" id="1MN-55-LYg"/>
+                            <constraint firstItem="h62-i6-ynd" firstAttribute="top" secondItem="tHL-ym-Gfa" secondAttribute="bottom" constant="44" placeholder="YES" id="1MN-55-LYg"/>
                             <constraint firstItem="Z7M-3D-caW" firstAttribute="top" secondItem="tHL-ym-Gfa" secondAttribute="bottom" id="7ZA-Cs-TAj"/>
                             <constraint firstItem="N6E-ZW-sLh" firstAttribute="top" secondItem="zy6-Kl-9CO" secondAttribute="top" id="Ajx-0d-fdf"/>
                             <constraint firstItem="N6E-ZW-sLh" firstAttribute="trailing" secondItem="h62-i6-ynd" secondAttribute="trailing" id="Iua-p1-CTQ"/>
@@ -79,17 +79,13 @@
                             <constraint firstItem="N6E-ZW-sLh" firstAttribute="bottom" secondItem="fKi-Ok-D1o" secondAttribute="bottom" id="Z4Z-Fq-OZ6"/>
                             <constraint firstAttribute="bottomMargin" secondItem="Z7M-3D-caW" secondAttribute="bottom" id="beT-9B-7ns"/>
                             <constraint firstItem="N6E-ZW-sLh" firstAttribute="trailing" secondItem="Z7M-3D-caW" secondAttribute="trailing" id="gla-Pw-6j8"/>
-                            <constraint firstItem="h62-i6-ynd" firstAttribute="top" secondItem="Z7M-3D-caW" secondAttribute="bottom" id="hWm-ty-xVF"/>
                             <constraint firstAttribute="trailing" secondItem="N6E-ZW-sLh" secondAttribute="trailing" id="hmi-rN-wSd"/>
                             <constraint firstItem="N6E-ZW-sLh" firstAttribute="leading" secondItem="zy6-Kl-9CO" secondAttribute="leading" id="lfR-SP-Ly1"/>
                         </constraints>
-                        <variation key="default">
-                            <mask key="constraints">
-                                <exclude reference="hWm-ty-xVF"/>
-                            </mask>
-                        </variation>
                     </view>
                     <connections>
+                        <outlet property="articleListContainerView" destination="h62-i6-ynd" id="f4M-5W-HJP"/>
+                        <outlet property="searchContainerView" destination="Z7M-3D-caW" id="Av2-aS-bzC"/>
                         <outlet property="splashView" destination="N6E-ZW-sLh" id="y7k-7q-Bof"/>
                     </connections>
                 </viewController>
@@ -100,7 +96,7 @@
         <!--Search View Controller-->
         <scene sceneID="25p-jW-rHl">
             <objects>
-                <viewController automaticallyAdjustsScrollViewInsets="NO" id="tkf-8P-b2O" customClass="WMFSearchViewController" sceneMemberID="viewController">
+                <viewController storyboardIdentifier="WMFSearchViewController" automaticallyAdjustsScrollViewInsets="NO" useStoryboardIdentifierAsRestorationIdentifier="YES" id="tkf-8P-b2O" customClass="WMFSearchViewController" sceneMemberID="viewController">
                     <layoutGuides>
                         <viewControllerLayoutGuide type="top" id="CKX-gH-RjL"/>
                         <viewControllerLayoutGuide type="bottom" id="8Yb-zt-F5o"/>
@@ -117,20 +113,33 @@
                                     <outlet property="delegate" destination="tkf-8P-b2O" id="jHa-CL-iNk"/>
                                 </connections>
                             </searchBar>
-                            <containerView opaque="NO" contentMode="scaleToFill" fixedFrame="YES" translatesAutoresizingMaskIntoConstraints="NO" id="Ia7-49-Gwu">
+                            <containerView opaque="NO" contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="Ia7-49-Gwu">
                                 <rect key="frame" x="0.0" y="44" width="600" height="536"/>
                                 <animations/>
                                 <connections>
-                                    <segue destination="Zko-q0-dZ1" kind="embed" id="5Ma-1s-NCI"/>
+                                    <segue destination="qVm-oc-aaW" kind="embed" id="2dT-rC-ziD"/>
                                 </connections>
                             </containerView>
+                            <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" buttonType="roundedRect" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="ukX-0p-5ey">
+                                <rect key="frame" x="277" y="79" width="46" height="30"/>
+                                <animations/>
+                                <state key="normal" title="Button">
+                                    <color key="titleShadowColor" white="0.5" alpha="1" colorSpace="calibratedWhite"/>
+                                </state>
+                            </button>
                         </subviews>
                         <animations/>
                         <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
                         <constraints>
+                            <constraint firstItem="ukX-0p-5ey" firstAttribute="top" secondItem="ZNj-Jo-URc" secondAttribute="bottom" constant="35" id="32n-FT-n9y"/>
                             <constraint firstAttribute="centerY" secondItem="ZNj-Jo-URc" secondAttribute="centerY" id="7um-O6-iBm"/>
+                            <constraint firstItem="Ia7-49-Gwu" firstAttribute="leading" secondItem="xp5-j8-6jN" secondAttribute="leading" id="AdT-tS-YIU"/>
                             <constraint firstItem="ZNj-Jo-URc" firstAttribute="top" secondItem="CKX-gH-RjL" secondAttribute="bottom" id="HTd-6H-IdL"/>
+                            <constraint firstAttribute="trailing" secondItem="Ia7-49-Gwu" secondAttribute="trailing" id="PnC-FC-Xud"/>
+                            <constraint firstItem="Ia7-49-Gwu" firstAttribute="top" secondItem="ZNj-Jo-URc" secondAttribute="bottom" id="VR7-y0-CDG"/>
+                            <constraint firstItem="8Yb-zt-F5o" firstAttribute="top" secondItem="Ia7-49-Gwu" secondAttribute="bottom" id="XlJ-cb-ymV"/>
                             <constraint firstAttribute="centerX" secondItem="ZNj-Jo-URc" secondAttribute="centerX" id="cxv-4Q-C8N"/>
+                            <constraint firstAttribute="centerX" secondItem="ukX-0p-5ey" secondAttribute="centerX" id="h5k-7F-xym"/>
                             <constraint firstItem="ZNj-Jo-URc" firstAttribute="leading" secondItem="xp5-j8-6jN" secondAttribute="leading" id="lud-F9-Eww"/>
                             <constraint firstAttribute="trailing" secondItem="ZNj-Jo-URc" secondAttribute="trailing" id="zhb-KY-6d8"/>
                         </constraints>
@@ -144,6 +153,7 @@
                     <toolbarItems/>
                     <connections>
                         <outlet property="searchBar" destination="ZNj-Jo-URc" id="Y5b-g5-7Mc"/>
+                        <outlet property="searchSuggestionButton" destination="ukX-0p-5ey" id="O0X-WP-Nym"/>
                     </connections>
                 </viewController>
                 <placeholder placeholderIdentifier="IBFirstResponder" id="A7p-O3-yFe" userLabel="First Responder" sceneMemberID="firstResponder"/>
@@ -151,47 +161,9 @@
             <point key="canvasLocation" x="950" y="11"/>
         </scene>
         <!--Article List Collection View Controller-->
-        <scene sceneID="egu-kI-JsY">
-            <objects>
-                <collectionViewController id="Zko-q0-dZ1" customClass="WMFArticleListCollectionViewController" sceneMemberID="viewController">
-                    <collectionView key="view" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" dataMode="prototypes" id="R5q-7X-ljm">
-                        <rect key="frame" x="0.0" y="0.0" width="600" height="536"/>
-                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
-                        <animations/>
-                        <collectionViewFlowLayout key="collectionViewLayout" minimumLineSpacing="10" minimumInteritemSpacing="10" id="jOa-aU-Xuf">
-                            <size key="itemSize" width="50" height="50"/>
-                            <size key="headerReferenceSize" width="0.0" height="0.0"/>
-                            <size key="footerReferenceSize" width="0.0" height="0.0"/>
-                            <inset key="sectionInset" minX="0.0" minY="0.0" maxX="0.0" maxY="0.0"/>
-                        </collectionViewFlowLayout>
-                        <cells>
-                            <collectionViewCell opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" id="rMg-lS-cGR">
-                                <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
-                                <autoresizingMask key="autoresizingMask"/>
-                                <view key="contentView" opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center">
-                                    <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
-                                    <autoresizingMask key="autoresizingMask"/>
-                                    <animations/>
-                                    <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="calibratedWhite"/>
-                                </view>
-                                <animations/>
-                                <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
-                            </collectionViewCell>
-                        </cells>
-                        <connections>
-                            <outlet property="dataSource" destination="Zko-q0-dZ1" id="yq2-Fr-Nyh"/>
-                            <outlet property="delegate" destination="Zko-q0-dZ1" id="4Nc-pA-7gk"/>
-                        </connections>
-                    </collectionView>
-                </collectionViewController>
-                <placeholder placeholderIdentifier="IBFirstResponder" id="gG2-mA-ufK" userLabel="First Responder" sceneMemberID="firstResponder"/>
-            </objects>
-            <point key="canvasLocation" x="1750" y="33"/>
-        </scene>
-        <!--Article List Collection View Controller-->
         <scene sceneID="r64-5z-ebS">
             <objects>
-                <collectionViewController id="qVm-oc-aaW" customClass="WMFArticleListCollectionViewController" sceneMemberID="viewController">
+                <collectionViewController storyboardIdentifier="WMFArticleListCollectionViewController" useStoryboardIdentifierAsRestorationIdentifier="YES" id="qVm-oc-aaW" customClass="WMFArticleListCollectionViewController" sceneMemberID="viewController">
                     <collectionView key="view" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" alwaysBounceVertical="YES" dataMode="prototypes" id="cbI-aA-luO">
                         <rect key="frame" x="0.0" y="0.0" width="600" height="536"/>
                         <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
@@ -300,4 +272,7 @@
     <resources>
         <image name="logo-onboarding" width="210" height="192"/>
     </resources>
+    <inferredMetricsTieBreakers>
+        <segue reference="2dT-rC-ziD"/>
+    </inferredMetricsTieBreakers>
 </document>
diff --git a/Wikipedia/View Controllers/SearchResults/SearchResultsController.m b/Wikipedia/View Controllers/SearchResults/SearchResultsController.m
index e75e0d42b81..66c7a3cd3d0 100644
--- a/Wikipedia/View Controllers/SearchResults/SearchResultsController.m	
+++ b/Wikipedia/View Controllers/SearchResults/SearchResultsController.m	
@@ -1,7 +1,6 @@
 
 #import "SearchResultsController.h"
 #import "WikipediaAppUtils.h"
-#import "Defines.h"
 #import "QueuesSingleton.h"
 #import "SearchResultCell.h"
 #import "SessionSingleton.h"
@@ -29,6 +28,8 @@
 static NSUInteger const kWMFMaxStringLength = 100;
 static CGFloat const kWMFDefaultCellHeight  = 80.0;
 
+#define SEARCH_MAX_RESULTS 24
+
 typedef NS_ENUM (NSUInteger, WMFSearchResultsControllerType) {
     WMFSearchResultsControllerTypeStandard,
     WMFSearchResultsControllerTypeReadMore
