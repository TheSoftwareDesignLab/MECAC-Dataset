diff --git a/Wikipedia/Code/DiffListChangeCell.swift b/Wikipedia/Code/DiffListChangeCell.swift
index 903deaabfb7..d2c4488970c 100644
--- a/Wikipedia/Code/DiffListChangeCell.swift
+++ b/Wikipedia/Code/DiffListChangeCell.swift
@@ -63,6 +63,15 @@ class DiffListChangeCell: UICollectionViewCell {
         apply(theme: viewModel.theme)
     }
     
+    func yLocationOfItem(index: Int, convertView: UIView) -> CGFloat? {
+        
+        guard let item = textStackView.arrangedSubviews[safeIndex: index] else {
+            return nil
+        }
+        
+        return textStackView.convert(item.frame, to: convertView).minY
+    }
+    
     @objc func tappedLabelWithSender(_ sender: UITapGestureRecognizer) {
         if let sender = sender.view as? UILabel,
             let item = viewModel?.items[safeIndex: sender.tag],
diff --git a/Wikipedia/Code/DiffListContextViewModel.swift b/Wikipedia/Code/DiffListContextViewModel.swift
index 86d3e391fe9..ea608e6f328 100644
--- a/Wikipedia/Code/DiffListContextViewModel.swift
+++ b/Wikipedia/Code/DiffListContextViewModel.swift
@@ -100,7 +100,7 @@ final class DiffListContextViewModel: DiffListGroupViewModel {
     private(set) var expandedHeight: CGFloat = 0
     private(set) var innerPadding: NSDirectionalEdgeInsets
     
-    static let contextItemTextPadding = NSDirectionalEdgeInsets(top: 8, leading: 8, bottom: 8, trailing: 8)
+    static let contextItemTextPadding = NSDirectionalEdgeInsets(top: 3, leading: 8, bottom: 8, trailing: 8)
     static let contextItemStackSpacing: CGFloat = 5
     static let containerStackSpacing: CGFloat = 15
     
diff --git a/Wikipedia/Code/DiffListViewController.swift b/Wikipedia/Code/DiffListViewController.swift
index 594916cbf72..df0d49ea0b9 100644
--- a/Wikipedia/Code/DiffListViewController.swift
+++ b/Wikipedia/Code/DiffListViewController.swift
@@ -52,6 +52,8 @@ class DiffListViewController: ViewController {
     private let chunkedHeightCalculationsConcurrentQueue = DispatchQueue(label: "org.wikipedia.diff.chunkedHeightCalculations", qos: .userInteractive, attributes: .concurrent)
     private let layoutSubviewsHeightCalculationsSerialQueue = DispatchQueue(label: "org.wikipedia.diff.layoutHeightCalculations", qos: .userInteractive)
     
+    private var scrollDidFinishInfo: (indexPathToScrollTo: IndexPath, changeItemToScrollTo: Int)?
+    
     init(theme: Theme, delegate: DiffListDelegate?, type: DiffContainerViewModel.DiffType) {
         self.type = type
         super.init(nibName: nil, bundle: nil)
@@ -79,35 +81,35 @@ class DiffListViewController: ViewController {
         collectionView.register(DiffListUneditedCell.wmf_classNib(), forCellWithReuseIdentifier: DiffListUneditedCell.reuseIdentifier)
     }
     
-        override func viewDidLayoutSubviews() {
-            super.viewDidLayoutSubviews()
+    override func viewDidLayoutSubviews() {
+        super.viewDidLayoutSubviews()
+        
+        if updateWidthsOnLayoutSubviews {
             
-            if updateWidthsOnLayoutSubviews {
-                
-                //More improvements could be size caching & putting layoutSubviewsHeightCalculationsSerialQueue instead into an NSOperation to be cancelled if another viewDidLayoutSubviews is called.
-                //tonitodo: clean up - move this and updateListViewModel methods into separate class, DiffListSizeCalculator or something
-                let updateType = ListUpdateType.layoutUpdate(collectionViewWidth: self.collectionView.frame.width, traitCollection: self.traitCollection)
+            //More improvements could be size caching & putting layoutSubviewsHeightCalculationsSerialQueue instead into an NSOperation to be cancelled if another viewDidLayoutSubviews is called.
+            //tonitodo: clean up - move this and updateListViewModel methods into separate class, DiffListSizeCalculator or something
+            let updateType = ListUpdateType.layoutUpdate(collectionViewWidth: self.collectionView.frame.width, traitCollection: self.traitCollection)
+            
+            //actually not sure if this serial queue is needed or simply calling on the main thread (also serial) is the same. this also seems faster than without though.
+            layoutSubviewsHeightCalculationsSerialQueue.async {
                 
-                //actually not sure if this serial queue is needed or simply calling on the main thread (also serial) is the same. this also seems faster than without though.
-                layoutSubviewsHeightCalculationsSerialQueue.async {
+                self.backgroundUpdateListViewModels(listViewModel: self.dataSource, updateType: updateType) {
                     
-                    self.backgroundUpdateListViewModels(listViewModel: self.dataSource, updateType: updateType) {
+                    DispatchQueue.main.async {
+                        self.applyListViewModelChanges(updateType: updateType)
                         
-                        DispatchQueue.main.async {
-                            self.applyListViewModelChanges(updateType: updateType)
-                            
-                            if let indexPathBeforeRotating = self.indexPathBeforeRotating {
-                                self.collectionView.scrollToItem(at: indexPathBeforeRotating, at: .centeredVertically, animated: false)
-                                self.indexPathBeforeRotating = nil
-                            }
-                            
-                            self.updateScrollViewInsets()
+                        if let indexPathBeforeRotating = self.indexPathBeforeRotating {
+                            self.collectionView.scrollToItem(at: indexPathBeforeRotating, at: .centeredVertically, animated: false)
+                            self.indexPathBeforeRotating = nil
                         }
                         
+                        self.updateScrollViewInsets()
                     }
+                    
                 }
             }
         }
+    }
     
     override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
         super.viewWillTransition(to: size, with: coordinator)
@@ -143,6 +145,15 @@ class DiffListViewController: ViewController {
         delegate?.diffListScrollViewDidScroll(scrollView)
     }
     
+    override func scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) {
+        super.scrollViewDidEndScrollingAnimation(scrollView)
+        
+        if let scrollDidFinishInfo = scrollDidFinishInfo {
+            scrollToChangeItem(cellIndexPath: scrollDidFinishInfo.indexPathToScrollTo, itemIndex: scrollDidFinishInfo.changeItemToScrollTo)
+            self.scrollDidFinishInfo = nil
+        }
+    }
+    
     func updateListViewModels(listViewModel: [DiffListGroupViewModel], updateType: DiffListViewController.ListUpdateType) {
         
         switch updateType {
@@ -175,22 +186,18 @@ class DiffListViewController: ViewController {
         }
     }
     
-    func backgroundUpdateListViewModels(listViewModel: [DiffListGroupViewModel], updateType: DiffListViewController.ListUpdateType, completion: @escaping () -> Void) {
-
-        let group = DispatchGroup()
-
-        let chunked = listViewModel.chunked(into: 10)
-
-        for chunk in chunked {
-            chunkedHeightCalculationsConcurrentQueue.async(group: group) {
-                
-                self.updateListViewModels(listViewModel: chunk, updateType: updateType)
-            }
+    override func apply(theme: Theme) {
+        
+        super.apply(theme: theme)
+        
+        guard isViewLoaded else {
+            return
         }
+        
+        updateListViewModels(listViewModel: dataSource, updateType: .theme(theme: theme))
+        applyListViewModelChanges(updateType: .theme(theme: theme))
 
-        group.notify(queue: layoutSubviewsHeightCalculationsSerialQueue) {
-            completion()
-        }
+        collectionView.backgroundColor = theme.colors.paperBackground
     }
     
     func applyListViewModelChanges(updateType: DiffListViewController.ListUpdateType) {
@@ -198,24 +205,41 @@ class DiffListViewController: ViewController {
         case .itemExpandUpdate:
             
             collectionView.setCollectionViewLayout(layoutCopy, animated: true)
- 
+
         default:
             collectionView.reloadData()
         }
     }
+}
+
+private extension DiffListViewController {
     
-    override func apply(theme: Theme) {
-        
-        super.apply(theme: theme)
-        
-        guard isViewLoaded else {
-            return
-        }
-        
-        updateListViewModels(listViewModel: dataSource, updateType: .theme(theme: theme))
-        applyListViewModelChanges(updateType: .theme(theme: theme))
+    func backgroundUpdateListViewModels(listViewModel: [DiffListGroupViewModel], updateType: DiffListViewController.ListUpdateType, completion: @escaping () -> Void) {
 
-        collectionView.backgroundColor = theme.colors.paperBackground
+       let group = DispatchGroup()
+
+       let chunked = listViewModel.chunked(into: 10)
+
+       for chunk in chunked {
+           chunkedHeightCalculationsConcurrentQueue.async(group: group) {
+               
+               self.updateListViewModels(listViewModel: chunk, updateType: updateType)
+           }
+       }
+
+       group.notify(queue: layoutSubviewsHeightCalculationsSerialQueue) {
+           completion()
+       }
+   }
+   
+   func scrollToChangeItem(cellIndexPath: IndexPath, itemIndex: Int) {
+       if let cell = collectionView.cellForItem(at: cellIndexPath) as? DiffListChangeCell,
+           let offsetToView = cell.yLocationOfItem(index: itemIndex, convertView: view) {
+           
+           let midPointTarget = collectionView.frame.height / 2
+           let delta = midPointTarget - offsetToView
+           collectionView.setContentOffset(CGPoint(x: collectionView.contentOffset.x, y: collectionView.contentOffset.y - delta), animated: true)
+       }
     }
 }
 
@@ -230,8 +254,6 @@ extension DiffListViewController: UICollectionViewDataSource {
             return UICollectionViewCell()
         }
         
-        //tonitodo: clean up
-        
         if let viewModel = viewModel as? DiffListChangeViewModel,
             let cell = collectionView.dequeueReusableCell(withReuseIdentifier: DiffListChangeCell.reuseIdentifier, for: indexPath) as? DiffListChangeCell {
             cell.update(viewModel)
@@ -302,21 +324,44 @@ extension DiffListViewController: DiffListChangeCellDelegate {
         }
         
         let tappedLinkId = tappedMoveInfo.linkId
+        let moveDirection = tappedMoveInfo.linkDirection
         
-        var indexToScrollTo: Int?
+        var indexOfOtherMoveCell: Int?
+        var changeItemToScrollTo: Int?
         for (index, viewModel) in dataSource.enumerated() {
             if let changeViewModel = viewModel as? DiffListChangeViewModel {
-                for item in changeViewModel.items {
+                for (subindex, item) in changeViewModel.items.enumerated() {
                     if let moveInfo = item.moveInfo,
                         moveInfo.id == tappedLinkId {
-                        indexToScrollTo = index
+                        indexOfOtherMoveCell = index
+                        changeItemToScrollTo = subindex
                     }
                 }
             }
         }
         
-        if let indexToScrollTo = indexToScrollTo {
-            collectionView.scrollToItem(at: IndexPath(item: indexToScrollTo, section: 0), at: .top, animated: true)
+        if let indexOfOtherMoveCell = indexOfOtherMoveCell,
+            let changeItemToScrollTo = changeItemToScrollTo {
+
+            let indexPathOfOtherMoveCell = IndexPath(item: indexOfOtherMoveCell, section: 0)
+            let visibleIndexPaths = collectionView.indexPathsForVisibleItems
+            
+            if visibleIndexPaths.contains(indexPathOfOtherMoveCell) { //cell already configured, skip straight to detecting offset needed to get top of *item* on screen.
+                
+                scrollToChangeItem(cellIndexPath: indexPathOfOtherMoveCell, itemIndex: changeItemToScrollTo)
+            } else {
+                
+                //avoids weird bouncing when scrolling up if we choose the index path below
+                let indexAfterIndexOfOtherMoveCell = indexOfOtherMoveCell + 1
+                let indexToScrollTo = moveDirection == .down ? indexOfOtherMoveCell : ((dataSource.count) > indexAfterIndexOfOtherMoveCell) ? indexAfterIndexOfOtherMoveCell : indexOfOtherMoveCell
+                let indexPathToScrollTo = IndexPath(item: indexToScrollTo, section: 0)
+                
+                //first scroll to cell, scrollViewDidEndAnimation will then scroll to item
+                scrollDidFinishInfo = (indexPathOfOtherMoveCell, changeItemToScrollTo)
+                collectionView.scrollToItem(at: indexPathToScrollTo, at: UICollectionView.ScrollPosition.top, animated: true)
+            }
         }
     }
+    
+    
 }
