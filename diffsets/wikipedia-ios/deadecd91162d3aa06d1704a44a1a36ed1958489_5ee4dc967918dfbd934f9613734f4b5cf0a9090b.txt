diff --git a/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift b/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
index 68e840da8db..1fa3670c2ad 100644
--- a/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
+++ b/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
@@ -19,19 +19,29 @@ extension WMFArticleViewController : WMFTableOfContentsViewControllerDelegate {
 
     public func tableOfContentsController(controller: WMFTableOfContentsViewController,
                                           didSelectItem item: TableOfContentsItem) {
-
+        var dismissVCCompletionHandler: (() -> Void)?
         if let section = item as? MWKSection {
             // HAX: webview has issues scrolling when browser view is out of bounds, disable animation if needed
             self.webViewController.scrollToSection(section, animated: self.webViewController.isWebContentVisible)
+            dismissVCCompletionHandler = {
+                // HAX: This is terrible, but iOS events not under our control would steal our focus if we didn't wait long enough here and due to problems in UIWebView, we cannot work around it either.
+                dispatchOnMainQueueAfterDelayInSeconds(1) {
+                    self.webViewController.accessibilityCursorToSection(section)
+                }
+            }
         } else if let footerItem = item as? TableOfContentsFooterItem {
-            self.webViewController.scrollToFooterAtIndex(UInt(footerItem.footerViewIndex.rawValue))
+            let footerIndex = UInt(footerItem.footerViewIndex.rawValue)
+            self.webViewController.scrollToFooterAtIndex(footerIndex)
+            dismissVCCompletionHandler = {
+                self.webViewController.accessibilityCursorToFooterAtIndex(footerIndex)
+            }
         } else {
             assertionFailure("Unsupported selection of TOC item \(item)")
         }
 
         // Don't dismiss immediately - it looks jarring - let the user see the ToC selection before dismissing
         dispatchOnMainQueueAfterDelayInSeconds(0.25) {
-            self.dismissViewControllerAnimated(true, completion: nil)
+            self.dismissViewControllerAnimated(true, completion: dismissVCCompletionHandler)
         }
     }
 
diff --git a/Wikipedia/Code/WebViewController.h b/Wikipedia/Code/WebViewController.h
index a29f2be7a15..5ee03c4dc27 100644
--- a/Wikipedia/Code/WebViewController.h
+++ b/Wikipedia/Code/WebViewController.h
@@ -58,6 +58,8 @@ NS_ASSUME_NONNULL_BEGIN
  */
 - (void)scrollToSection:(MWKSection*)section animated:(BOOL)animated;
 
+- (void)accessibilityCursorToSection:(MWKSection*)section;
+
 - (nullable MWKSection*)currentVisibleSection;
 
 - (void)scrollToVerticalOffset:(CGFloat)offset;
@@ -90,7 +92,9 @@ NS_ASSUME_NONNULL_BEGIN
  */
 @property (nonatomic, strong, nullable) NSArray<UIViewController*>* footerViewControllers;
 
+- (UIView*)footerAtIndex:(NSUInteger)index;
 - (void)scrollToFooterAtIndex:(NSUInteger)index;
+- (void)accessibilityCursorToFooterAtIndex:(NSUInteger)index;
 
 - (NSInteger)visibleFooterIndex;
 
diff --git a/Wikipedia/Code/WebViewController.m b/Wikipedia/Code/WebViewController.m
index afc2b4f2618..2d19fa71bd9 100644
--- a/Wikipedia/Code/WebViewController.m
+++ b/Wikipedia/Code/WebViewController.m
@@ -182,17 +182,25 @@ - (void)observeWebScrollViewContentSize {
 
 #pragma mark - Headers & Footers
 
-- (void)scrollToFooterAtIndex:(NSUInteger)index {
+- (UIView*)footerAtIndex:(NSUInteger)index {
     UIView* footerView       = self.footerViewControllers[index].view;
     UIView* footerViewHeader = self.footerViewHeadersByIndex[@(index)];
-    UIView* viewToScrollTo   = footerViewHeader ? : footerView;
+    return footerViewHeader ? : footerView;
+}
 
+- (void)scrollToFooterAtIndex:(NSUInteger)index {
+    UIView* viewToScrollTo = [self footerAtIndex:index];
     CGPoint footerViewOrigin = [self.webView.scrollView convertPoint:viewToScrollTo.frame.origin
                                                             fromView:self.footerContainerView];
     footerViewOrigin.y -= self.webView.scrollView.contentInset.top;
     [self.webView.scrollView setContentOffset:footerViewOrigin animated:YES];
 }
 
+- (void)accessibilityCursorToFooterAtIndex:(NSUInteger)index {
+    UIView* viewToScrollTo = [self footerAtIndex:index];
+    UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, viewToScrollTo);
+}
+
 - (NSInteger)visibleFooterIndex {
     CGRect const scrollViewContentFrame = self.webView.scrollView.wmf_contentFrame;
     if (!CGRectIntersectsRect(scrollViewContentFrame, self.footerContainerView.frame)) {
@@ -409,6 +417,11 @@ - (void)scrollToSection:(MWKSection*)section animated:(BOOL)animated {
     [self scrollToFragment:section.anchor animated:animated];
 }
 
+- (void)accessibilityCursorToSection:(MWKSection*)section {
+    NSString *js = [NSString stringWithFormat:@"focus_element = document.getElementById('%@'); other_element = document.body;  other_element.setAttribute('tabindex', 0); focus_element.setAttribute('tabindex', 0); other_element.focus(); focus_element.focus();", section.anchor];
+    [self.webView stringByEvaluatingJavaScriptFromString:js];
+}
+
 - (nullable MWKSection*)currentVisibleSection {
     NSInteger indexOfFirstOnscreenSection =
         [self.webView getIndexOfTopOnScreenElementWithPrefix:@"section_heading_and_content_block_"
