diff --git a/Wikipedia-iOS.xcodeproj/project.pbxproj b/Wikipedia-iOS.xcodeproj/project.pbxproj
index b1dc036311f..7f370ea8890 100644
--- a/Wikipedia-iOS.xcodeproj/project.pbxproj
+++ b/Wikipedia-iOS.xcodeproj/project.pbxproj
@@ -7,6 +7,12 @@
 	objects = {
 
 /* Begin PBXBuildFile section */
+		04090A33187F53E400577EDF /* clear.png in Resources */ = {isa = PBXBuildFile; fileRef = 04090A32187F53E400577EDF /* clear.png */; };
+		04090A34187F53E400577EDF /* clear.png in Resources */ = {isa = PBXBuildFile; fileRef = 04090A32187F53E400577EDF /* clear.png */; };
+		04090A37187F818400577EDF /* TOCImageView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04090A36187F818400577EDF /* TOCImageView.m */; };
+		04090A38187F818400577EDF /* TOCImageView.m in Sources */ = {isa = PBXBuildFile; fileRef = 04090A36187F818400577EDF /* TOCImageView.m */; };
+		04090A3B187FB7D000577EDF /* UIView+Debugging.m in Sources */ = {isa = PBXBuildFile; fileRef = 04090A3A187FB7D000577EDF /* UIView+Debugging.m */; };
+		04090A3C187FB7D000577EDF /* UIView+Debugging.m in Sources */ = {isa = PBXBuildFile; fileRef = 04090A3A187FB7D000577EDF /* UIView+Debugging.m */; };
 		040E5C4D184564D0007AFE6F /* ArticleDataModel.m in Sources */ = {isa = PBXBuildFile; fileRef = 040E5C4C184564D0007AFE6F /* ArticleDataModel.m */; };
 		040E5C4F184566F4007AFE6F /* CoreData.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 040E5C4E184566F4007AFE6F /* CoreData.framework */; };
 		040E5C841846AC13007AFE6F /* ArticleDataContextSingleton.m in Sources */ = {isa = PBXBuildFile; fileRef = 040E5C831846AC13007AFE6F /* ArticleDataContextSingleton.m */; };
@@ -174,6 +180,11 @@
 /* End PBXContainerItemProxy section */
 
 /* Begin PBXFileReference section */
+		04090A32187F53E400577EDF /* clear.png */ = {isa = PBXFileReference; lastKnownFileType = image.png; path = clear.png; sourceTree = "<group>"; };
+		04090A35187F818400577EDF /* TOCImageView.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TOCImageView.h; sourceTree = "<group>"; };
+		04090A36187F818400577EDF /* TOCImageView.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TOCImageView.m; sourceTree = "<group>"; };
+		04090A39187FB7D000577EDF /* UIView+Debugging.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIView+Debugging.h"; sourceTree = "<group>"; };
+		04090A3A187FB7D000577EDF /* UIView+Debugging.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIView+Debugging.m"; sourceTree = "<group>"; };
 		040E5C4C184564D0007AFE6F /* ArticleDataModel.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ArticleDataModel.m; sourceTree = "<group>"; };
 		040E5C4E184566F4007AFE6F /* CoreData.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreData.framework; path = System/Library/Frameworks/CoreData.framework; sourceTree = SDKROOT; };
 		040E5C821846AC13007AFE6F /* ArticleDataContextSingleton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArticleDataContextSingleton.h; sourceTree = "<group>"; };
@@ -449,6 +460,7 @@
 		0466F44C183A30CC00EA1FD7 /* Images */ = {
 			isa = PBXGroup;
 			children = (
+				04090A32187F53E400577EDF /* clear.png */,
 				04478643185155750050563B /* history-search.png */,
 				04478644185155750050563B /* history-search@2x.png */,
 				04478649185159700050563B /* history-external.png */,
@@ -523,6 +535,8 @@
 		04C43AB7183442FC006C643B /* Categories */ = {
 			isa = PBXGroup;
 			children = (
+				04090A39187FB7D000577EDF /* UIView+Debugging.h */,
+				04090A3A187FB7D000577EDF /* UIView+Debugging.m */,
 				04F0E2E8186EDC1A00468738 /* UIWebView+ElementLocation.h */,
 				04F0E2E9186EDC1A00468738 /* UIWebView+ElementLocation.m */,
 				044786861856E4DB0050563B /* UIWebView+Reveal.h */,
@@ -610,6 +624,8 @@
 				04F3958F186CF80100B0D6FC /* TOCViewController.m */,
 				04F0E2EC186FB2D000468738 /* TOCSectionCellView.h */,
 				04F0E2ED186FB2D100468738 /* TOCSectionCellView.m */,
+				04090A35187F818400577EDF /* TOCImageView.h */,
+				04090A36187F818400577EDF /* TOCImageView.m */,
 			);
 			path = TableOfContents;
 			sourceTree = "<group>";
@@ -816,6 +832,7 @@
 				047E74141860509000916964 /* SavedPagesResultPrototypeView.xib in Resources */,
 				04A47629183EF835009C0D82 /* w.png in Resources */,
 				D4BC22B4181E9E6300CAC673 /* empty.png in Resources */,
+				04090A33187F53E400577EDF /* clear.png in Resources */,
 				04478645185155750050563B /* history-search.png in Resources */,
 				04478651185159700050563B /* history-external@2x.png in Resources */,
 				0447864F185159700050563B /* history-external.png in Resources */,
@@ -839,6 +856,7 @@
 				04478654185159700050563B /* history-link.png in Resources */,
 				047E74151860509000916964 /* SavedPagesResultPrototypeView.xib in Resources */,
 				04478632185145090050563B /* HistoryResultPrototypeView.xib in Resources */,
+				04090A34187F53E400577EDF /* clear.png in Resources */,
 				04478648185155750050563B /* history-search@2x.png in Resources */,
 				04CF1CB7187C8F4400E9516F /* Languages in Resources */,
 				04478650185159700050563B /* history-external.png in Resources */,
@@ -878,6 +896,7 @@
 				04D34DE11868E21F00610A87 /* Article+Convenience.m in Sources */,
 				04D34DB91863F69500610A87 /* DiscoveryContext.m in Sources */,
 				04142A8F184F974E006EF779 /* NSDate-Utilities.m in Sources */,
+				04090A3B187FB7D000577EDF /* UIView+Debugging.m in Sources */,
 				04C43AC2183442FC006C643B /* NSURLRequest+DictionaryRequest.m in Sources */,
 				04A70FD7185BB6C300E24515 /* URLCache.m in Sources */,
 				044786881856E4DB0050563B /* UIWebView+Reveal.m in Sources */,
@@ -887,6 +906,7 @@
 				04D34DC11863F6B200610A87 /* History.m in Sources */,
 				04D34DAF1863D2D600610A87 /* XPathQuery.m in Sources */,
 				04CF1CB3187BDB5C00E9516F /* Image.m in Sources */,
+				04090A37187F818400577EDF /* TOCImageView.m in Sources */,
 				04C43ABE183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m in Sources */,
 				04C43AA6183440C1006C643B /* MWNetworkOp.m in Sources */,
 				040E5C841846AC13007AFE6F /* ArticleDataContextSingleton.m in Sources */,
@@ -934,6 +954,7 @@
 				04D34DDA1863F70A00610A87 /* Section.m in Sources */,
 				04293001185FC2C7002A13FC /* QueuesSingleton.m in Sources */,
 				04C43AA5183440C1006C643B /* MWNetworkActivityIndicatorManager.m in Sources */,
+				04090A3C187FB7D000577EDF /* UIView+Debugging.m in Sources */,
 				04C43ABF183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m in Sources */,
 				D4EE00BD1824459D0090790F /* PageTitleTests.m in Sources */,
 				04292FE7185FB9D7002A13FC /* SearchNavController.m in Sources */,
@@ -943,6 +964,7 @@
 				04D34DA2186283AA00610A87 /* MainMenuSectionHeadingLabel.m in Sources */,
 				04D34DC21863F6B200610A87 /* History.m in Sources */,
 				04A70FD8185BB6C300E24515 /* URLCache.m in Sources */,
+				04090A38187F818400577EDF /* TOCImageView.m in Sources */,
 				04478634185145090050563B /* HistoryViewController.m in Sources */,
 				04C43AC1183442FC006C643B /* NSString+Extras.m in Sources */,
 				04FD6C7B184EBFCD002CA02F /* ArticleData.xcdatamodeld in Sources */,
diff --git a/Wikipedia-iOS/AppDelegate.m b/Wikipedia-iOS/AppDelegate.m
index 54bd34ac6c9..56d81784987 100644
--- a/Wikipedia-iOS/AppDelegate.m
+++ b/Wikipedia-iOS/AppDelegate.m
@@ -81,6 +81,11 @@ -(void)systemWideStyleOverrides
     }
     
     [[UIButton appearance] setTitleShadowColor:[UIColor clearColor] forState:UIControlStateNormal];
+
+    // Make buttons look the same on iOS 6 & 7.
+    [[UIButton appearance] setBackgroundImage:[UIImage imageNamed:@"clear.png"] forState:UIControlStateNormal];
+    [[UIButton appearance] setTitleColor:[UIColor lightGrayColor] forState:UIControlStateDisabled];
+    [[UIButton appearance] setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
 }
 
 - (void)applicationWillResignActive:(UIApplication *)application
diff --git a/Wikipedia-iOS/Base.lproj/Main_iPhone.storyboard b/Wikipedia-iOS/Base.lproj/Main_iPhone.storyboard
index bd39ffa1be9..961bd99e87f 100644
--- a/Wikipedia-iOS/Base.lproj/Main_iPhone.storyboard
+++ b/Wikipedia-iOS/Base.lproj/Main_iPhone.storyboard
@@ -45,7 +45,7 @@
                         <rect key="frame" x="0.0" y="0.0" width="320" height="568"/>
                         <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                         <subviews>
-                            <scrollView clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="sgu-W1-m18" userLabel="TOC Scroll View">
+                            <scrollView clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" showsHorizontalScrollIndicator="NO" translatesAutoresizingMaskIntoConstraints="NO" id="sgu-W1-m18" userLabel="TOC Scroll View">
                                 <rect key="frame" x="0.0" y="0.0" width="320" height="568"/>
                                 <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                 <subviews>
@@ -59,7 +59,7 @@
                                         </constraints>
                                     </view>
                                 </subviews>
-                                <color key="backgroundColor" red="0.24956154336734693" green="0.24956154336734693" blue="0.24956154336734693" alpha="0.70000000000000007" colorSpace="calibratedRGB"/>
+                                <color key="backgroundColor" red="0.22052375637755106" green="0.22052375637755106" blue="0.22052375637755106" alpha="1" colorSpace="calibratedRGB"/>
                                 <constraints>
                                     <constraint firstAttribute="trailing" secondItem="VGj-z3-9mh" secondAttribute="trailing" id="2FA-L1-7e4"/>
                                     <constraint firstItem="VGj-z3-9mh" firstAttribute="top" secondItem="sgu-W1-m18" secondAttribute="top" id="P6f-Yb-NbR"/>
@@ -307,6 +307,8 @@
                         <outlet property="forwardButton" destination="cq9-Zs-YsN" id="cPh-wD-WgL"/>
                         <outlet property="tocButton" destination="UVB-P9-soS" id="0Y3-wf-tat"/>
                         <outlet property="webView" destination="WeL-Mj-Zsh" id="iQJ-zA-CLH"/>
+                        <outlet property="webViewLeftConstraint" destination="3Zs-jL-a48" id="fnl-sG-tsS"/>
+                        <outlet property="webViewRightConstraint" destination="QSr-uN-iN4" id="EG4-9F-vyJ"/>
                         <segue destination="0U8-c6-wgE" kind="push" identifier="ShowHistorySegue" id="ajd-Ao-Blc"/>
                         <segue destination="5JY-JE-rua" kind="push" identifier="ShowSavedPagesSegue" id="LQ6-al-Ud5"/>
                     </connections>
diff --git a/Wikipedia-iOS/Categories/UIView+Debugging.h b/Wikipedia-iOS/Categories/UIView+Debugging.h
new file mode 100644
index 00000000000..5b5217aced7
--- /dev/null
+++ b/Wikipedia-iOS/Categories/UIView+Debugging.h
@@ -0,0 +1,9 @@
+//  Created by Monte Hurd on 8/28/13.
+
+#import <UIKit/UIKit.h>
+
+@interface UIView (Debugging)
+
+-(void)randomlyColorSubviews;
+
+@end
diff --git a/Wikipedia-iOS/Categories/UIView+Debugging.m b/Wikipedia-iOS/Categories/UIView+Debugging.m
new file mode 100644
index 00000000000..6e912a7b133
--- /dev/null
+++ b/Wikipedia-iOS/Categories/UIView+Debugging.m
@@ -0,0 +1,26 @@
+//  Created by Monte Hurd on 8/28/13.
+
+#import "UIView+Debugging.h"
+
+@implementation UIView (Debugging)
+
+-(void)randomlyColorSubviews
+{
+    // Add borders and random background colors to view and its subviews
+    // Makes debugging autolayout easier
+    float(^color)() = ^float() {
+        return (float)arc4random_uniform(100) / 100.0f;
+    };
+    for (UIView *subView in self.subviews) {
+        subView.layer.borderWidth = 1.0f;
+        subView.layer.borderColor = [UIColor colorWithWhite:0.0f alpha:0.5f].CGColor;
+        subView.layer.backgroundColor = [UIColor colorWithRed : color()
+                                                        green : color()
+                                                         blue : color()
+                                                        alpha : 0.5
+                                         ].CGColor;
+        [subView randomlyColorSubviews];
+    }
+}
+
+@end
diff --git a/Wikipedia-iOS/Images/clear.png b/Wikipedia-iOS/Images/clear.png
new file mode 100644
index 00000000000..1074531063a
Binary files /dev/null and b/Wikipedia-iOS/Images/clear.png differ
diff --git a/Wikipedia-iOS/View Controllers/MainMenu/MainMenuSectionHeadingLabel.m b/Wikipedia-iOS/View Controllers/MainMenu/MainMenuSectionHeadingLabel.m
index 328fdf6d17c..7165e5a0381 100644
--- a/Wikipedia-iOS/View Controllers/MainMenu/MainMenuSectionHeadingLabel.m	
+++ b/Wikipedia-iOS/View Controllers/MainMenu/MainMenuSectionHeadingLabel.m	
@@ -12,7 +12,7 @@ - (id)init
         self.numberOfLines = 2;
         self.lineBreakMode = NSLineBreakByWordWrapping;
         self.font = [UIFont fontWithName:@"HelveticaNeue-Bold" size:20.0];
-//self.backgroundColor = [UIColor colorWithRed:1 green:0 blue:0 alpha:0.1];
+        self.backgroundColor = [UIColor clearColor];
         self.textColor = [UIColor colorWithWhite:0.0 alpha:0.7];
         self.useDottedLine = NO;
     }
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCImageView.h b/Wikipedia-iOS/View Controllers/TableOfContents/TOCImageView.h
new file mode 100644
index 00000000000..78d9f0cf794
--- /dev/null
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCImageView.h	
@@ -0,0 +1,7 @@
+//  Created by Monte Hurd on 1/9/14.
+
+#import <UIKit/UIKit.h>
+
+@interface TOCImageView : UIImageView
+
+@end
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCImageView.m b/Wikipedia-iOS/View Controllers/TableOfContents/TOCImageView.m
new file mode 100644
index 00000000000..afd06c51c3b
--- /dev/null
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCImageView.m	
@@ -0,0 +1,24 @@
+//  Created by Monte Hurd on 1/9/14.
+
+#import "TOCImageView.h"
+
+@implementation TOCImageView
+
+- (id)initWithFrame:(CGRect)frame
+{
+    self = [super initWithFrame:frame];
+    if (self) {
+        // Initialization code
+    }
+    return self;
+}
+
+// Effectively turn off the image view's intrinsic content size
+// to make constraining it *without* the layout system taking
+// into account the size of its UIImage easier.
+-(CGSize)intrinsicContentSize
+{
+    return CGSizeMake(UIViewNoIntrinsicMetric, UIViewNoIntrinsicMetric);
+}
+
+@end
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m b/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m
index e32e947b676..bcc69ff756c 100644
--- a/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m	
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCSectionCellView.m	
@@ -3,6 +3,8 @@
 #import "TOCSectionCellView.h"
 #import "ArticleCoreDataObjects.h"
 #import "ArticleDataContextSingleton.h"
+#import "TFHpple.h"
+#import "TOCImageView.h"
 
 @interface TOCSectionCellView(){
 
@@ -58,7 +60,8 @@ - (id)init
         
         self.clipsToBounds = YES;
 
-        self.backgroundColor = [UIColor colorWithWhite:0.0 alpha:0.7];
+        self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
+        self.titleLabel.backgroundColor = [UIColor clearColor];
 
         //self.layer.borderColor = [UIColor colorWithWhite:1.0f alpha:0.3f].CGColor;
         //self.layer.borderWidth = 1.0 / [UIScreen mainScreen].scale;
@@ -69,9 +72,9 @@ - (id)init
 -(void)setIsHighlighted:(BOOL)isHighlighted
 {
     if (isHighlighted) {
-        self.titleLabel.textColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:1.0];
+        self.backgroundColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:1.0];
     }else{
-        self.titleLabel.textColor = [UIColor colorWithWhite:1.0 alpha:1.0];
+        self.backgroundColor = [UIColor darkGrayColor];
     }
     
     if (isHighlighted) self.alpha = 1.0f;
@@ -79,6 +82,43 @@ -(void)setIsHighlighted:(BOOL)isHighlighted
     _isHighlighted = isHighlighted;
 }
 
+- (NSString *)getStringWithoutHTML:(NSString *)string
+{
+    // Strips html from string with xpath / hpple.
+    if (!string) return string;
+    NSData *stringData = [string dataUsingEncoding:NSUTF8StringEncoding];
+    TFHpple *parser = [TFHpple hppleWithHTMLData:stringData];
+    NSArray *textNodes = [parser searchWithXPathQuery:@"//text()"];
+    NSMutableArray *results = [@[] mutableCopy];
+    for (TFHppleElement *node in textNodes) {
+        if(node.isTextNode) [results addObject:node.raw];
+    }
+    return [results componentsJoinedByString:@""];
+}
+
+-(NSAttributedString *)getAttributedTitleForSection:(Section *)section
+{
+    NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];
+    paragraphStyle.alignment = NSTextAlignmentLeft;
+    
+    NSMutableAttributedString *(^styleText)(NSString *, CGFloat) = ^NSMutableAttributedString *(NSString *str, CGFloat size){
+        return [[NSMutableAttributedString alloc]
+                initWithString:str attributes: @{
+                                                 NSFontAttributeName : [UIFont fontWithName:@"HelveticaNeue" size:size],
+                                                 NSParagraphStyleAttributeName : paragraphStyle,
+                                                 NSStrokeWidthAttributeName : @0.0f, //@-1.0f,
+                                                 NSStrokeColorAttributeName : [UIColor blackColor],
+                                                 NSForegroundColorAttributeName : [UIColor whiteColor],
+                                                 }];
+    };
+    
+    return (section.index.integerValue == 0) ?
+        styleText([self getStringWithoutHTML:section.article.title], 22)
+        :
+        styleText([self getStringWithoutHTML:section.title], 15)
+    ;
+}
+
 -(void)setSectionId:(NSManagedObjectID *)sectionId
 {
     if (sectionId) {
@@ -87,17 +127,11 @@ -(void)setSectionId:(NSManagedObjectID *)sectionId
         
         self.tag = section.index.integerValue;
 
-        self.titleLabel.text = (section.index.integerValue == 0) ? section.article.title : section.title;
-        
+        self.titleLabel.attributedText = [self getAttributedTitleForSection:section];
+
         // Add tocLevel for debugging.
         //self.titleLabel.text = [NSString stringWithFormat:@"%@-%@ : %@", section.index, section.tocLevel, self.titleLabel.text];
         
-        if (section.index.integerValue == 0) {
-            self.titleLabel.font = [UIFont fontWithName:@"Georgia" size:24];
-        }else{
-            self.titleLabel.font = [UIFont fontWithName:@"Georgia" size:18];
-        }
-        
         // Remove previous images.
         [self.sectionImageViews makeObjectsPerformSelector:@selector(removeFromSuperview)];
         [self.sectionImageViews removeAllObjects];
@@ -106,7 +140,7 @@ -(void)setSectionId:(NSManagedObjectID *)sectionId
             [self addSectionImageViews];
             [self resetSectionImageViewsBorderStyle];
         }
-//TODO: if section index is 0 tack a toggle view on top of it (on right side) then hook up to animate changes to
+//TODO: (maybe) if section index is 0 tack a toggle view on top of it (on right side) then hook up to animate changes to
 // label and image constraints to provide for switching between current layout and a larger vertically stacked
 // image layout and another layout with just a single tiny thumbnail (from 1st img) to left of section title w/
 // section title tabbed over at tocLevel.
@@ -136,7 +170,7 @@ -(void)addSectionImageViews
     NSUInteger i = 0;
     for (NSManagedObjectID *sectionImageId in self.sectionImageIds) {
         SectionImage *sectionImage = (SectionImage *)[articleDataContext_.mainContext objectWithID:sectionImageId];
-        UIImageView *imageView = [[UIImageView alloc] init];
+        TOCImageView *imageView = [[TOCImageView alloc] init];
         // Tag will make it easy to take the tapped image and find its sectionImageId from sectionImageIds.
         imageView.tag = i; // Don't use this--> sectionImage.index.integerValue; (not all images are shown)
         i++;
@@ -144,28 +178,33 @@ -(void)addSectionImageViews
         imageView.clipsToBounds = YES;
         imageView.userInteractionEnabled = YES;
 
-        imageView.layer.borderWidth = 4.0 / [UIScreen mainScreen].scale;
-
         // Needed because sometimes these images have transparency.
         imageView.backgroundColor = [UIColor colorWithWhite:1.0f alpha:0.5f];
         
         imageView.translatesAutoresizingMaskIntoConstraints = NO;
         imageView.image = [UIImage imageWithData:sectionImage.image.data];
+
         [self.sectionImageViews addObject:imageView];
-        [self addSubview:imageView];
+        [self insertSubview:imageView belowSubview:self.titleLabel];
     }
 }
 
 -(void)updateConstraints
 {
     [self removeConstraints:self.constraints];
+
     [self constrainTitleLabel:self.tocLevel];
-    [self constrainSectionImages:self.tocLevel];
+    [self constrainSectionImagesBelowTitleLabel:self.tocLevel];
+
+    // Experimental constraints:
+    //[self constrainTitleLabelToLeftOfCell];
+    //[self constrainSectionImagesFillingCell];
+    //[self constrainSectionImagesFillingCellSideBySide];
     
     [super updateConstraints];
 }
 
--(void)constrainSectionImages:(NSNumber *)tocLevel
+-(void)constrainSectionImagesBelowTitleLabel:(NSNumber *)tocLevel
 {
     [self removeConstraints:self.imageViewsConstraints];
     
@@ -192,15 +231,17 @@ -(void)constrainSectionImages:(NSNumber *)tocLevel
         [self.imageViewsConstraints addObject:constraint];
     };
 
-    UIImageView *prevImage = nil;
-    for (UIImageView *imageView in self.sectionImageViews) {
+    TOCImageView *prevImage = nil;
+    for (TOCImageView *imageView in self.sectionImageViews) {
+
+        imageView.layer.borderWidth = 1.0 / [UIScreen mainScreen].scale;
 
         // Default layout with horizontal row of images beneath title label.
         constrain(imageView, NSLayoutAttributeBottom, self, NSLayoutAttributeBottom, -self.imageMargin);
         constrain(imageView, NSLayoutAttributeWidth, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.width);
         constrain(imageView, NSLayoutAttributeHeight, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.height);
         if (self.sectionImageViews.firstObject == imageView) {
-            constrain(imageView, NSLayoutAttributeTop, self.titleLabel, NSLayoutAttributeBottom, 0);
+            constrain(imageView, NSLayoutAttributeTop, self.titleLabel, NSLayoutAttributeBottom, self.imageMargin);
             constrain(imageView, NSLayoutAttributeLeft, self, NSLayoutAttributeLeft, (tocLevel.floatValue * self.imageIndentMargin) + self.imageIndentMarginMin);
         }
         if (prevImage) {
@@ -212,8 +253,8 @@ -(void)constrainSectionImages:(NSNumber *)tocLevel
         continue;
         
         // Layout with vertically stacked image beneath title layout.
-        self.imageSize = CGSizeMake(160.0f, 160.0f);
-        constrain(imageView, NSLayoutAttributeRight, self, NSLayoutAttributeRight, -self.imageMargin);
+        self.imageSize = CGSizeMake(150.0f, 150.0f);
+        constrain(imageView, NSLayoutAttributeCenterX, self, NSLayoutAttributeCenterX, 0);
         constrain(imageView, NSLayoutAttributeWidth, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.width);
         constrain(imageView, NSLayoutAttributeHeight, nil, NSLayoutAttributeNotAnAttribute, self.imageSize.height);
         if (self.sectionImageViews.firstObject == imageView) {
@@ -248,12 +289,16 @@ -(void)constrainTitleLabel:(NSNumber *)tocLevel
     NSInteger tocLevelToUse = ((self.tocLevel.intValue - 1) < 0) ? 0 : self.tocLevel.intValue - 1;
     constrainTitleLabel(NSLayoutAttributeLeft, (tocLevelToUse * self.indentMargin) + self.indentMarginMin);
     constrainTitleLabel(NSLayoutAttributeRight, -5);
-    constrainTitleLabel(NSLayoutAttributeTop, 0);
-    constrainTitleLabel(NSLayoutAttributeBottom, 0);
-    
-    NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat: @"V:[titleLabel(>=50)]"
+    constrainTitleLabel(NSLayoutAttributeTop, 5);
+    constrainTitleLabel(NSLayoutAttributeBottom, -5);
+
+    // The label's instrinsic content size will keep it above "1" height. This allows labels above
+    // images to be narrower vertically than a label for a section which has no images.
+    CGFloat minTitleLabelHeight = (self.sectionImageViews.count > 0) ? 1 : 40;
+
+    NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat: @"V:[titleLabel(>=height)]"
                                              options: 0
-                                             metrics: 0
+                                             metrics: @{@"height": @(minTitleLabelHeight)}
                                                views: @{@"titleLabel": self.titleLabel}];
     [self addConstraints:constraints];
     [self.titleLabelConstraints addObjectsFromArray:constraints];
@@ -271,6 +316,97 @@ -(NSArray *)imagesIntersectingYOffset:(CGFloat)yOffset inView:(UIView *)view;
     return imagesIntersectingYOffset;
 }
 
+#pragma mark Experimental constraints
+
+//Places images side by side - for example, 3 images would be 33.3% of cell width each.
+-(void)constrainSectionImagesFillingCellSideBySide
+{
+    [self removeConstraints:self.imageViewsConstraints];
+    if(self.sectionImageViews.count == 0)return;
+
+    void (^constrain)(UIView *, NSLayoutAttribute, NSLayoutRelation, UIView *, NSLayoutAttribute, CGFloat, CGFloat) = ^void(UIView *view1, NSLayoutAttribute a1, NSLayoutRelation relation, UIView *view2, NSLayoutAttribute a2, CGFloat multiplier, CGFloat constant) {
+        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem: view1
+                                      attribute: a1
+                                      relatedBy: relation
+                                         toItem: view2
+                                      attribute: a2
+                                     multiplier: multiplier
+                                       constant: constant];
+        [self addConstraint:constraint];
+        [self.imageViewsConstraints addObject:constraint];
+    };
+    TOCImageView *prevImage = nil;
+    for (TOCImageView *imageView in self.sectionImageViews) {
+        imageView.alpha = 0.5;
+
+        constrain(imageView, NSLayoutAttributeWidth, NSLayoutRelationEqual, self, NSLayoutAttributeWidth, 1.0f / self.sectionImageViews.count, 0.0f);
+        constrain(imageView, NSLayoutAttributeCenterY, NSLayoutRelationEqual, self, NSLayoutAttributeCenterY, 1.0f, 0.0f);
+        
+        NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat:@"V:|-(5)-[imageView]-(5)-|" options:0 metrics:nil views:@{@"imageView": imageView}];
+        [self addConstraints:constraints];
+        [self.imageViewsConstraints addObjectsFromArray:constraints];
+
+        if (self.sectionImageViews.firstObject == imageView) {
+            constrain(imageView, NSLayoutAttributeLeft, NSLayoutRelationEqual, self, NSLayoutAttributeLeft, 1.0f, 0.0f);
+        }
+        if (prevImage) {
+            constrain(imageView, NSLayoutAttributeLeft, NSLayoutRelationEqual, prevImage, NSLayoutAttributeRight, 1.0f, 0.0f);
+        }
+        prevImage = imageView;
+    }
+}
+
+-(void)constrainSectionImagesFillingCell
+{
+    [self removeConstraints:self.imageViewsConstraints];
+    if(self.sectionImageViews.count == 0)return;
+    for (TOCImageView *imageView in self.sectionImageViews) {
+    
+        imageView.alpha = (self.sectionImageViews.firstObject == imageView) ? 0.5f : 0.0f;
+        NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat:@"V:|-(5)-[imageView]-(5)-|" options:0 metrics:nil views:@{@"imageView": imageView}];
+        [self addConstraints:constraints];
+        [self.imageViewsConstraints addObjectsFromArray:constraints];
+
+        constraints = [NSLayoutConstraint constraintsWithVisualFormat:@"H:|-(5)-[imageView]-(5)-|" options:0 metrics:nil views:@{@"imageView": imageView}];
+        [self addConstraints:constraints];
+        [self.imageViewsConstraints addObjectsFromArray:constraints];
+    }
+}
+
+-(void)constrainTitleLabelToLeftOfCell
+{
+    [self removeConstraints:self.titleLabelConstraints];
+    void (^constrain)(UIView *, NSLayoutAttribute, NSLayoutRelation, UIView *, NSLayoutAttribute, CGFloat) = ^void(UIView *view1, NSLayoutAttribute a1, NSLayoutRelation relation, UIView *view2, NSLayoutAttribute a2, CGFloat constant) {
+        NSLayoutConstraint *constraint = [NSLayoutConstraint constraintWithItem: view1
+                                      attribute: a1
+                                      relatedBy: relation
+                                         toItem: view2
+                                      attribute: a2
+                                     multiplier: 1.0
+                                       constant: constant];
+        [self addConstraint:constraint];
+        [self.titleLabelConstraints addObject:constraint];
+    };
+    
+    
+    UIView *firstImage = nil;
+    if(self.sectionImageViews.count > 0) firstImage = self.sectionImageViews[0];
+
+    
+    NSInteger tocLevelToUse = ((self.tocLevel.intValue - 1) < 0) ? 0 : self.tocLevel.intValue - 1;
+    constrain(self.titleLabel, NSLayoutAttributeLeft, NSLayoutRelationEqual, self, NSLayoutAttributeLeft, (tocLevelToUse * self.indentMargin) + self.indentMarginMin);
+    constrain(self.titleLabel, NSLayoutAttributeRight, NSLayoutRelationEqual, self, NSLayoutAttributeRight, -5);
+    constrain(self.titleLabel, NSLayoutAttributeTop, NSLayoutRelationEqual, self, NSLayoutAttributeTop, 5);
+    constrain(self.titleLabel, NSLayoutAttributeBottom, NSLayoutRelationEqual, self, NSLayoutAttributeBottom, -5);
+    
+    NSArray *constraints = [NSLayoutConstraint constraintsWithVisualFormat: @"V:[titleLabel(>=height)]"
+                                             options: 0
+                                             metrics: @{@"height": @(40)}
+                                               views: @{@"titleLabel": self.titleLabel}];
+    [self addConstraints:constraints];
+    [self.titleLabelConstraints addObjectsFromArray:constraints];
+}
+
 /*
 // Only override drawRect: if you perform custom drawing.
 // An empty implementation adversely affects performance during animation.
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.h b/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.h
index 8fff49004ba..050a9d4f0d8 100644
--- a/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.h	
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.h	
@@ -2,9 +2,15 @@
 
 #import <UIKit/UIKit.h>
 
+@class WebViewController;
+
 @interface TOCViewController : UIViewController <UITextFieldDelegate, UIScrollViewDelegate>
 
 @property (strong, nonatomic) IBOutlet UIView *scrollContainer;
 @property (strong, nonatomic) IBOutlet UIScrollView *scrollView;
 
+@property (weak, nonatomic) WebViewController *webVC;
+
+-(void)centerCellForWebViewTopMostSection;
+
 @end
diff --git a/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m b/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m
index 0f98893bef4..b5f501e0a7c 100644
--- a/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m	
+++ b/Wikipedia-iOS/View Controllers/TableOfContents/TOCViewController.m	
@@ -8,8 +8,11 @@
 #import "TOCSectionCellView.h"
 #import "WebViewController.h"
 #import "UIWebView+ElementLocation.h"
+#import "UIView+Debugging.h"
 
-#define TOC_SECTION_MARGIN 0.0f
+#define TOC_SECTION_MARGIN 1.0f
+#define TOC_SELECTION_OFFSET_Y 48.0f
+#define TOC_DELAY_BETWEEN_SELECTION_AND_ZOOM 0.35f
 
 @interface TOCViewController (){
 
@@ -24,7 +27,7 @@ @interface TOCViewController (){
 
 @property (strong, nonatomic) NSMutableArray *sectionCells;
 
-@property (nonatomic) BOOL animateWebScrollAsFocalCellChanges;
+@property (strong, nonatomic) NSMutableArray *viewConstraints;
 
 @end
 
@@ -37,10 +40,8 @@ - (void)viewDidLoad
     [super viewDidLoad];
     // Do any additional setup after loading the view.
 
-    // If this is YES the focal cell's selection will be scrolled to when the TOC stops sliding.
-    // If this is NO the focal cell's section will be jumped to as soon as cell becomes focal.
-    self.animateWebScrollAsFocalCellChanges = NO;
- 
+    self.viewConstraints = [@[] mutableCopy];
+
     self.sectionIds = [@[]mutableCopy];
     self.sectionImageIds = [@{} mutableCopy];
     self.sectionCells = [@[]mutableCopy];
@@ -64,9 +65,7 @@ - (void)viewDidLoad
 
     UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tocTapped:)];
     [self.view addGestureRecognizer:tap];
-    
-    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(hideTOC) name:@"SearchFieldBecameFirstResponder" object:nil];
-    
+
     [self constrainScrollContainer];
 
     self.scrollContainer.backgroundColor = [UIColor clearColor];
@@ -76,62 +75,30 @@ -(void)viewWillAppear:(BOOL)animated
 {
     [super viewWillAppear:animated];
 
-    //WebViewController *webVC = (WebViewController *)self.parentViewController;
-
-//TODO: Need to remove and reset these web view animations on rotate before using them.
-/*
- Have the web view controller do this after rotate conditionally if it sees these animations
- are in effect - for it to do this the shrinkReset and skewReset methods would need to
- remove animations for keys WEBVIEW_SHRINK and WEBVIEW_SKEW once they finish resetting.
- This way the webVC can know if either of these animations are in effect by just looking
- for animations for these keys.
-*/
-    //[webVC shrinkAndAlignRightWithScale:0.6f];
-    //[webVC skewWithEyePosition:-2000.0f angle:7.5f];
-
     if (self.sectionCells.count == 0) return;
     
-    // Temporarily set content insets to allow top cell to be completely off bottom of screen.
-    [self insetToRestrictScrollingToHeight:@(self.scrollView.frame.size.height)];
-
-    // Move all cells just off bottom of screen.
-    [self setScrollViewContentOffset:CGPointMake(0.0f, -self.scrollView.frame.size.height)];
-
     [self updateHighlightedCellToReflectWebView];
 }
 
--(void)viewWillDisappear:(BOOL)animated
-{
-    [super viewWillDisappear:animated];
-
-    //WebViewController *webVC = (WebViewController *)self.parentViewController;
-    //[webVC shrinkReset];
-    //[webVC skewReset];
-}
-
--(void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation
-{
-    [self scrollHighlightedCellToScreenCenter];
-    [self cascadeSectionCellsAlphaFromMiddle];
-}
-
 -(void)viewDidAppear:(BOOL)animated
 {
     [super viewDidAppear:animated];
-    
+
+    [self insetToRestrictScrollingTopAndBottomCellsPastCenter];
+
     // Don't start monitoring scrollView scrolling until view has appeared.
     self.scrollView.delegate = self;
 
-    [self scrollHighlightedCellToScreenCenter];
-
-    [self cascadeSectionCellsAlphaFromMiddle];
+    [self scrollHighlightedCellToSelectionLineAnimated:NO];
+    
+    //[self.view randomlyColorSubviews];
 }
 
 #pragma mark Data retrieval
 
 //TODO: these 2 methods have a lot in common... refactor and stuff.
 
--(void) getSectionIds
+-(void)getSectionIds
 {
     NSString *lastViewedArticleTitle = [[NSUserDefaults standardUserDefaults] objectForKey:@"LastViewedArticleTitle"];
     if(lastViewedArticleTitle) {
@@ -149,7 +116,7 @@ -(void) getSectionIds
     }
 }
 
--(void) getSectionImageIds
+-(void)getSectionImageIds
 {
     NSString *lastViewedArticleTitle = [[NSUserDefaults standardUserDefaults] objectForKey:@"LastViewedArticleTitle"];
     if(lastViewedArticleTitle) {
@@ -179,14 +146,7 @@ -(void)tocTapped:(id)sender
         [self unHighlightAllCells];
         [self navigateToSelection:sender];
     }
-
-    [self performSelector:@selector(hideTOC) withObject:nil afterDelay:0.15f];
-}
-
--(void)hideTOC
-{
-    WebViewController *webVC = (WebViewController *)self.parentViewController;
-    [webVC tocToggle];
+    [self.webVC performSelector:@selector(tocToggle) withObject:nil afterDelay:TOC_DELAY_BETWEEN_SELECTION_AND_ZOOM ];
 }
 
 #pragma mark Navigate
@@ -198,16 +158,16 @@ -(void)navigateToSelection:(UITapGestureRecognizer *)sender
     CGPoint loc = [tapRecognizer locationInView:view];
     UIView *subview = [view hitTest:loc withEvent:nil];
 
-    if ([subview isMemberOfClass:[UIImageView class]]) {
+    if ([subview isKindOfClass:[UIImageView class]]) {
         if ([subview.superview isMemberOfClass:[TOCSectionCellView class]]) {
             TOCSectionCellView *cell = (TOCSectionCellView*)subview.superview;
             cell.isHighlighted = YES;
         }
 
-        [self scrollWebViewToImageForCell:(UIImageView *)subview animated:NO];
+        [self scrollWebViewToImageForCell:(UIImageView *)subview animated:YES];
         //NSLog(@"image tap index = %ld, section index = %ld", (long)subview.tag, (long)subview.superview.tag);
     }else if ([subview isMemberOfClass:[TOCSectionCellView class]]) {
-        [self scrollWebViewToSectionForCell:(TOCSectionCellView *)subview animated:NO];
+        [self scrollWebViewToSectionForCell:(TOCSectionCellView *)subview animated:YES];
         //NSLog(@"section cell tap index = %ld", (long)subview.tag);
     }
 }
@@ -216,11 +176,10 @@ -(void)scrollWebViewToSectionForCell:(TOCSectionCellView *)cell animated:(BOOL)a
 {
     cell.isHighlighted = YES;
 
-    WebViewController *webVC = (WebViewController *)self.parentViewController;
     NSString *elementId = [NSString stringWithFormat:@"content_block_%ld", (long)cell.tag];
-    CGPoint p = [webVC.webView getWebViewRectForHtmlElementWithId:elementId].origin;
+    CGPoint p = [self.webVC.webView getWebViewRectForHtmlElementWithId:elementId].origin;
 
-    [self scrollWebView:webVC.webView toPoint:p animated:animated];
+    [self scrollWebView:self.webVC.webView toPoint:p animated:animated];
 }
 
 -(void)scrollWebViewToImageForCell:(UIImageView *)imageView animated:(BOOL)animated
@@ -232,17 +191,19 @@ -(void)scrollWebViewToImageForCell:(UIImageView *)imageView animated:(BOOL)anima
     ArticleDataContextSingleton *articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
     SectionImage *sectionImage = (SectionImage *)[articleDataContext_.mainContext objectWithID:sectionImageId];
     
-    WebViewController *webVC = (WebViewController *)self.parentViewController;
-    CGPoint p = [webVC.webView getWebViewCoordsForHtmlImageWithSrc:sectionImage.image.sourceUrl];
+    CGPoint p = [self.webVC.webView getWebViewCoordsForHtmlImageWithSrc:sectionImage.image.sourceUrl];
     p.y = p.y - 23;
 
-    [self scrollWebView:webVC.webView toPoint:p animated:animated];
+    [self scrollWebView:self.webVC.webView toPoint:p animated:animated];
 }
 
 -(void)scrollWebView:(UIWebView *)webView toPoint:(CGPoint)point animated:(BOOL)animated
 {
     point.x = webView.scrollView.contentOffset.x;
     [webView.scrollView setContentOffset:point animated:animated];
+    
+    // Give the scrolling a bit of time to finish, then record the new scroll location.
+    [self.webVC performSelector:@selector(saveWebViewScrollOffset) withObject:nil afterDelay:0.3];
 }
 
 #pragma mark Highlight and scroll to focal cell.
@@ -257,91 +218,31 @@ -(void)unHighlightAllCells
 - (void)scrollViewDidScroll:(UIScrollView *)scrollView
 {
     if (scrollView == self.scrollView) {
-        CGFloat focalOffset = self.scrollView.frame.size.height / 2.0f;
         for (TOCSectionCellView *cell in self.sectionCells) {
 
 //TODO: TOCSectionCellView has a "TODO:" about making a section image object for managing their state. Do that.
 // Expecially note the "v.layer.borderColor" stuff below - doesn't belong here.
             [cell resetSectionImageViewsBorderStyle];
-            NSArray *centerlineIntersectingCellImages = [cell imagesIntersectingYOffset:focalOffset inView:self.scrollView.superview];
             
 //TODO: allow this image border highlighting for vertically stacked image layout.
 /*
-            for (UIImageView *v in centerlineIntersectingCellImages) {
-                v.layer.borderColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:1.0].CGColor;
-            }
+NSArray *centerlineIntersectingCellImages = [cell imagesIntersectingYOffset:focalOffset inView:self.scrollView.superview];
+for (UIImageView *v in centerlineIntersectingCellImages) {
+    v.layer.borderColor = [UIColor colorWithRed:0.03 green:0.48 blue:0.92 alpha:1.0].CGColor;
+}
 */
             if ([self isCellFocalCell:cell]) {
                 [self unHighlightAllCells];
                 cell.isHighlighted = YES;
             }
-
-            BOOL shouldAttemptScrollToImage = (centerlineIntersectingCellImages.count > 0) ? YES : NO;
-            BOOL shouldAttemptScrollToSection = ((!shouldAttemptScrollToImage) && cell.isHighlighted) ? YES : NO;
-
-//TODO: allow "shouldAttemptScrollToImage" to be used for vertically stacked image layout.
-shouldAttemptScrollToImage = NO;
-
-            /*
-             // Probably never do this here - to much "bridge" traffic for each scroll pixel move...
-             WebViewController *webVC = (WebViewController *)self.parentViewController;
-             NSInteger indexOfFirstOnscreenSection = [webVC.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:self.sectionCells.count];
-             NSString *elementId = [NSString stringWithFormat:@"content_block_%ld", (long)indexOfFirstOnscreenSection];
-             CGPoint p = [webVC.webView getWebViewRectForHtmlElementWithId:elementId].origin;
-             if ((p.y < 0) || (p.y > 100)) shouldAttemptScrollToSection = YES;
-             */
-            
-            if (shouldAttemptScrollToImage) {
-                UIImageView *i = (UIImageView *)centerlineIntersectingCellImages[0];
-                    [self scrollWebViewToImageForCell:i animated:NO];
-            }
-
-            if (shouldAttemptScrollToSection){
-                if (!self.animateWebScrollAsFocalCellChanges) {
-                        [self scrollWebViewToSectionForCell:cell animated:NO];
-                }
-            }
         }
     }
-    [self cascadeSectionCellsAlphaFromMiddle];
-}
-
--(void)cascadeSectionCellsAlphaFromMiddle
-{
-
-//TODO: the layout with the large vertically stacked images should *not* cascasde cell alpha.
-//return;
-
-    CGFloat minAlpha = 0.25f;
-
-    //CGFloat whiteLevel = 0.0f;
-    CGFloat halfContainerHeight = self.scrollView.frame.size.height / 2.0f;
-    // Proportionately fade out cells around middle cell.
-    for (TOCSectionCellView *cell in self.sectionCells) {
-//      if (cell.isHighlighted) continue;
-
-        //if (self.sectionCells.firstObject != cell) continue;
-        //if (self.sectionCells.lastObject != cell) continue;
-
-        CGFloat distanceFromCenter = [self offsetFromCenterForView:cell];
-
-        //if (distanceFromCenter < 0) distanceFromCenter *= 1.5;
-
-        CGFloat alpha = fabsf((fabsf(distanceFromCenter) - halfContainerHeight) / halfContainerHeight);
-        //alpha = 1.0f - alpha; // Inverts alpha.
-        alpha = MAX(alpha, minAlpha);
-        
-        if(fabsf(distanceFromCenter) > halfContainerHeight) alpha = minAlpha;
-        
-        cell.alpha = alpha;
-        //cell.backgroundColor = [UIColor colorWithWhite:whiteLevel alpha:alpha];
-    }
 }
 
 -(BOOL)isCellFocalCell:(TOCSectionCellView *)cell
 {
     // "offset" is distance from top of scrollView highlighting starts.
-    CGFloat focalOffset = self.scrollView.frame.size.height / 2.0f;
+    CGFloat focalOffset = [self getSelectionLine];
     //offset = 0.0f; // <--makes selection window be at top of scrollView
     CGPoint p = [cell convertPoint:CGPointZero toView:self.scrollView.superview];
     p.x -= self.scrollView.frame.origin.x;
@@ -354,7 +255,7 @@ -(BOOL)isCellFocalCell:(TOCSectionCellView *)cell
     return NO;
 }
 
-#pragma mark Scroll if self.animateWebScrollAsFocalCellChanges == YES
+#pragma mark Scroll ended
 
 - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
 {
@@ -367,15 +268,44 @@ -(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView{
 
 - (void)scrollViewScrollingEnded:(UIScrollView *)scrollView
 {
-    if (!self.animateWebScrollAsFocalCellChanges) return;
     for (TOCSectionCellView *cell in self.sectionCells) {
         if (cell.isHighlighted) {
-            [self scrollWebViewToSectionForCell:cell animated:YES];
-            break;
+
+            CGFloat focalOffset = [self getSelectionLine];
+            NSArray *centerlineIntersectingCellImages = [cell imagesIntersectingYOffset:focalOffset inView:self.scrollView.superview];
+            
+            BOOL shouldAttemptScrollToImage = (centerlineIntersectingCellImages.count > 0) ? YES : NO;
+//TODO: enable scroll to image for vertically stacked image layout.
+shouldAttemptScrollToImage = NO;
+            BOOL shouldAttemptScrollToSection = (!shouldAttemptScrollToImage) ? YES : NO;
+
+            if (shouldAttemptScrollToImage) {
+                UIImageView *i = (UIImageView *)centerlineIntersectingCellImages[0];
+                    [self scrollWebViewToImageForCell:i animated:YES];
+                    break;
+            }
+
+            if (shouldAttemptScrollToSection){
+                [self scrollWebViewToSectionForCell:cell animated:YES];
+                break;
+            }
         }
     }
 }
 
+-(void)centerCellForWebViewTopMostSection
+{
+    if (!self.scrollView.isDragging) {
+        // Setting delegate to nil prevents flicker of TOC selection when scrolling *web
+        // view* to new section. Does so by ignoring TOC did scroll events until after
+        // scrollHighlightedCellToSelectionLineAnimated finishes scrolling the TOC.
+        self.scrollView.delegate = nil;
+        [self updateHighlightedCellToReflectWebView];
+        [self scrollHighlightedCellToSelectionLineAnimated:YES];
+        [self.scrollView performSelector:@selector(setDelegate:) withObject:self afterDelay:0.3];
+    }
+}
+
 #pragma mark Constraints
 
 -(void)constrainScrollContainer
@@ -395,27 +325,6 @@ -(void)updateViewConstraints
     [super updateViewConstraints];
 
     [self constrainSectionCells];
-
-    [self constrainTOCView];
-}
-
-- (void)constrainTOCView
-{
-    float margin = 0.0f;
-    void (^constrain)(NSLayoutAttribute, float) = ^void(NSLayoutAttribute a, float constant) {
-        [self.view.superview addConstraint:[NSLayoutConstraint constraintWithItem:self.view
-                                                                        attribute:a
-                                                                        relatedBy:NSLayoutRelationEqual
-                                                                           toItem:self.view.superview
-                                                                        attribute:a
-                                                                       multiplier:1.0
-                                                                         constant:constant]];
-    };
-    
-    constrain(NSLayoutAttributeLeft, margin);
-    constrain(NSLayoutAttributeRight, -margin);
-    constrain(NSLayoutAttributeTop, margin);
-    constrain(NSLayoutAttributeBottom, -margin);
 }
 
 #pragma mark Highlighted cell
@@ -428,7 +337,7 @@ -(TOCSectionCellView *)getHighlightedCell
     return nil;
 }
 
--(void)scrollHighlightedCellToScreenCenter
+-(void)scrollHighlightedCellToSelectionLineAnimated:(BOOL)animated
 {
     if (self.sectionCells.count == 0) return;
     TOCSectionCellView *highlightedCell = [self getHighlightedCell];
@@ -436,27 +345,35 @@ -(void)scrollHighlightedCellToScreenCenter
     // Return if no cell highlighted.
     if (!highlightedCell) return;
 
-    // Temporarily set content insets to allow top cell to be completely off bottom of screen.
-    [self insetToRestrictScrollingToHeight:@(self.scrollView.frame.size.height)];
+    // Calculate highlighted cell's offset from selection line.
+    CGFloat distanceFromCenter = [self offsetFromSelectionLineForView:highlightedCell];
 
-    // Calculate highlighted cell's offset from screen center.
-    CGFloat distanceFromCenter = [self offsetFromCenterForView:highlightedCell];
-
-    // Scroll highlighted to screen center (animated).
+    // Scroll highlighted to selection line (animated).
     CGPoint contentOffset = self.scrollView.contentOffset;
     contentOffset.y += distanceFromCenter;
-    
-    //NSLog(@"contentOffset.y = %f", contentOffset.y);
-    [self setScrollViewContentOffset:contentOffset];
 
-    // After delay (to allow animated scroll above to complete) reset content
-    // insets to prevent first and last cells from scrolling past screen center.
-    [self performSelector:@selector(insetToRestrictScrollingTopAndBottomCellsPastCenter) withObject:nil afterDelay:0.35f];
+    // Ensure the top cell's top isn't below the top of the scroll container.
+    contentOffset.y = fmaxf(contentOffset.y, 0);
+
+    [self setScrollViewContentOffset:contentOffset animated:animated];
+}
+
+-(CGFloat)getSelectionLine
+{
+    // Selection line is y coordinate of imaginary horizontal line. TOC cell will be considered selected
+    // if it intersects this line.
+    return TOC_SELECTION_OFFSET_Y;
 }
 
--(CGFloat)offsetFromCenterForView:(UIView *)view
+-(CGFloat)offsetFromSelectionLineForView:(UIView *)view
 {
-    return view.center.y - self.scrollView.contentOffset.y - self.scrollView.frame.size.height / 2.0f;
+    // Since the selection line is not to far from the top of the page, ignore it for the purpose
+    // of scrolling the highlighted cell to the selection line and instead just use an offset that
+    // scrolls the section *exactly* to the top of the scroll view container. This keeps a small
+    // gap from being left between the top of the screen and the selected cell. Would need to change
+    // this to actually take the value from [self getSelectionLine] into account if the selection
+    // is ever moved from near the top of the screen.
+    return view.frame.origin.y - self.scrollView.contentOffset.y /*- [self getSelectionLine]*/;
 }
 
 #pragma mark Scroll limits
@@ -467,37 +384,27 @@ -(void)insetToRestrictScrollingToHeight:(NSNumber *)height
     self.scrollView.delegate = nil;
 
     self.scrollView.contentInset = UIEdgeInsetsMake(
-        height.floatValue - TOC_SECTION_MARGIN,
+        height.floatValue - TOC_SECTION_MARGIN - (((UIView *)self.sectionCells.firstObject).frame.size.height / 2.0f),
         0,
-        height.floatValue - TOC_SECTION_MARGIN,
+        height.floatValue - TOC_SECTION_MARGIN - (((UIView *)self.sectionCells.lastObject).frame.size.height / 2.0f),
         0
     );
     self.scrollView.delegate = self;
 }
 
--(void)setScrollViewContentOffset:(CGPoint)contentOffset
+-(void)setScrollViewContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;
 {
-    // Don't report scrolling when changing offset.
-    self.scrollView.delegate = nil;
-    [self.scrollView setContentOffset:contentOffset animated:NO];
-    self.scrollView.delegate = self;
+    [self.scrollView setContentOffset:contentOffset animated:animated];
 }
 
 -(void)insetToRestrictScrollingTopAndBottomCellsPastCenter
 {
     // Don't report scrolling when changing inset.
     self.scrollView.delegate = nil;
-    CGFloat halfHeight = self.scrollView.frame.size.height / 2.0f;
-
-//TODO: the vertially stacked image layout should do "insetToRestrictScrollingToHeight", but the default layout
-// should not. Presently both are using "insetToRestrictScrollingToHeight" because of the line below.
-[self insetToRestrictScrollingToHeight:@(halfHeight)];
-return;
-    
     self.scrollView.contentInset = UIEdgeInsetsMake(
-        halfHeight - TOC_SECTION_MARGIN - (((UIView *)self.sectionCells.firstObject).frame.size.height / 2.0f),
         0,
-        halfHeight - TOC_SECTION_MARGIN - (((UIView *)self.sectionCells.lastObject).frame.size.height / 2.0f),
+        0,
+        self.scrollView.frame.size.height - ((UIView *)self.sectionCells.lastObject).frame.size.height,
         0
     );
     self.scrollView.delegate = self;
@@ -507,9 +414,10 @@ -(void)updateHighlightedCellToReflectWebView
 {
     // Highlight cell for section currently nearest top of webview.
     if (self.sectionCells.count > 0){
+
         [self unHighlightAllCells];
-        WebViewController *webVC = (WebViewController *)self.parentViewController;
-        NSInteger indexOfFirstOnscreenSection = [webVC.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:self.sectionCells.count];
+
+        NSInteger indexOfFirstOnscreenSection = [self.webVC.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:self.sectionCells.count];
         if (indexOfFirstOnscreenSection < self.sectionCells.count) {
             ((TOCSectionCellView *)self.sectionCells[indexOfFirstOnscreenSection]).isHighlighted = YES;
         }
@@ -549,8 +457,8 @@ -(void)constrainSectionCells
     //margin = 0.0f;
     TOCSectionCellView *prevCell = nil;
     for (TOCSectionCellView *cell in self.sectionCells) {
-        constrain(cell, NSLayoutAttributeLeft, self.scrollContainer, NSLayoutAttributeLeft, margin);
-        constrain(cell, NSLayoutAttributeRight, self.scrollContainer, NSLayoutAttributeRight, -margin);
+        constrain(cell, NSLayoutAttributeLeft, self.scrollContainer, NSLayoutAttributeLeft, 0.0f);
+        constrain(cell, NSLayoutAttributeRight, self.scrollContainer, NSLayoutAttributeRight, 0.0f);
         if (self.sectionCells.firstObject == cell) {
             constrain(cell, NSLayoutAttributeTop, self.scrollContainer, NSLayoutAttributeTop, margin);
         }else if (self.sectionCells.lastObject == cell) {
diff --git a/Wikipedia-iOS/View Controllers/WebView/WebViewController.h b/Wikipedia-iOS/View Controllers/WebView/WebViewController.h
index 4e25cc42687..b87154c2eba 100644
--- a/Wikipedia-iOS/View Controllers/WebView/WebViewController.h	
+++ b/Wikipedia-iOS/View Controllers/WebView/WebViewController.h	
@@ -24,7 +24,11 @@
 @property (weak, nonatomic) IBOutlet UIButton *forwardButton;
 @property (weak, nonatomic) IBOutlet UIButton *tocButton;
 
+@property (weak, nonatomic) IBOutlet NSLayoutConstraint *webViewLeftConstraint;
+@property (weak, nonatomic) IBOutlet NSLayoutConstraint *webViewRightConstraint;
+
 -(void)tocToggle;
+-(void)saveWebViewScrollOffset;
 
 - (IBAction)tocButtonPushed:(id)sender;
 - (IBAction)backButtonPushed:(id)sender;
@@ -33,9 +37,4 @@
 - (IBAction)actionButtonPushed:(id)sender;
 - (IBAction)bookmarkButtonPushed:(id)sender;
 
--(void)shrinkAndAlignRightWithScale:(CGFloat)scale;
--(void)shrinkReset;
--(void)skewWithEyePosition:(CGFloat)eyePosition angle:(CGFloat)angle;
--(void)skewReset;
-
 @end
diff --git a/Wikipedia-iOS/View Controllers/WebView/WebViewController.m b/Wikipedia-iOS/View Controllers/WebView/WebViewController.m
index 4b0baf05d01..f94ad60f12d 100644
--- a/Wikipedia-iOS/View Controllers/WebView/WebViewController.m	
+++ b/Wikipedia-iOS/View Controllers/WebView/WebViewController.m	
@@ -29,6 +29,9 @@
 #import "TOCViewController.h"
 #import "UIWebView+ElementLocation.h"
 
+#define WEB_VIEW_SCALE_WHEN_TOC_VISIBLE (UIInterfaceOrientationIsPortrait(self.interfaceOrientation) ? 0.45f : 0.70f)
+#define TOC_TOGGLE_ANIMATION_DURATION 0.35f
+
 @interface WebViewController (){
 
 }
@@ -41,7 +44,9 @@ @interface WebViewController (){
 @property (nonatomic) BOOL unsafeToScroll;
 @property (nonatomic) NSInteger indexOfFirstOnscreenSectionBeforeRotate;
 @property (strong, nonatomic) NSDictionary *adjacentHistoryArticleTitles;
-@property (nonatomic) BOOL tocIsVisible;
+@property (nonatomic) BOOL tocVisible;
+
+@property (strong, nonatomic) NSMutableArray *tocConstraints;
 
 @end
 
@@ -76,7 +81,9 @@ - (void)viewDidLoad
 {
     [super viewDidLoad];
 
-    self.tocIsVisible = NO;
+    self.tocConstraints = [@[] mutableCopy];
+
+    self.tocVisible = NO;
     self.forwardButton.transform = CGAffineTransformMakeScale(-1.0, 1.0);
 
     self.searchNavController = (SearchNavController *)self.navigationController;
@@ -100,6 +107,8 @@ - (void)viewDidLoad
 
     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(savedPagesToggle) name:@"SavedPagesToggle" object:nil];
 
+    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(tocHide) name:@"SearchFieldBecameFirstResponder" object:nil];
+
     self.alertLabel.text = @"";
 
     articleDataContext_ = [ArticleDataContextSingleton sharedInstance];
@@ -116,35 +125,128 @@ - (void)viewDidLoad
 
     // Observe chages to the search box search term.
     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(searchStringChanged) name:@"SearchStringChanged" object:nil];
+
+    [self updateBottomBarButtonsEnabledState];
 }
 
 #pragma mark Table of contents
 
--(void)tocToggle
+-(TOCViewController *)getTOCViewController
 {
     for (UIViewController *childVC in self.childViewControllers) {
         if([childVC isMemberOfClass:[TOCViewController class]]){
-            TOCViewController *vc = (TOCViewController *)childVC;
-            [vc.view removeFromSuperview];
-            [vc removeFromParentViewController];
-            [self showBottomBarAnimated:NO];
-            self.tocIsVisible = NO;
-            return;
+            return (TOCViewController *)childVC;
         }
     }
+    return nil;
+}
 
-    TOCViewController *tocVC = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"TOCViewController"];
-    [self addChildViewController:tocVC];
-    
-    [self.view addSubview:tocVC.view];
-    
-    [tocVC didMoveToParentViewController:self];
+-(void)setTocVisible:(BOOL)tocVisible
+{
+    if(_tocVisible != tocVisible){
+        _tocVisible = tocVisible;
+        
+        TOCViewController *tocVC = [self getTOCViewController];
+        
+        // Hide toc.
+        if(!tocVisible){
+            // Ensure one exists to be hidden.
+            if (tocVC) {
+                [UIView animateWithDuration:TOC_TOGGLE_ANIMATION_DURATION animations:^{
+                    self.webView.transform = CGAffineTransformIdentity;
+                    self.webViewLeftConstraint.constant = 0;
+                    self.bottomBarViewBottomConstraint.constant = 0;
+                    [self.view layoutIfNeeded];
+                } completion:^(BOOL done){
+                    [tocVC.view removeFromSuperview];
+                    [tocVC removeFromParentViewController];
+                }];
+            }
+        }else{
+            // Show toc.
+            // Ensure it doesn't already exist. Needed because the animation for "hide" case
+            // above takes some time to complete - just to be safe.
+            if (!tocVC) {
+                tocVC = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"TOCViewController"];
+                tocVC.webVC = self;
+                [self addChildViewController:tocVC];
+                
+                tocVC.view.translatesAutoresizingMaskIntoConstraints = NO;
+                [self.view addSubview:tocVC.view];
+                
+                [self constrainTOCView:tocVC.view];
+                [self.view layoutIfNeeded];
+                
+                [tocVC didMoveToParentViewController:self];
+                
+                CGAffineTransform xf = CGAffineTransformMakeScale(WEB_VIEW_SCALE_WHEN_TOC_VISIBLE, WEB_VIEW_SCALE_WHEN_TOC_VISIBLE);
+                [UIView animateWithDuration:TOC_TOGGLE_ANIMATION_DURATION animations:^{
+                    self.bottomBarViewBottomConstraint.constant = -self.bottomBarViewHeightConstraint.constant;
+                    self.webView.transform = xf;
+                    self.webViewLeftConstraint.constant = self.view.frame.size.width * (1.0f - WEB_VIEW_SCALE_WHEN_TOC_VISIBLE);
+                    [self.view layoutIfNeeded];
+                }];
+            }
+        }
+    }
+}
+
+-(void)tocHide
+{
+    self.tocVisible = NO;
+}
 
-    [self hideBottomBarAnimated:NO];
+-(void)tocToggle
+{
+    self.tocVisible = !self.tocVisible;
+}
 
-    self.tocIsVisible = YES;
+-(void)constrainTOCView:(UIView *)tocView
+{
+    [self.view removeConstraints:self.tocConstraints];
+    [self.tocConstraints removeAllObjects];
 
-    //[self debugScrollLeadSanFranciscoArticleImageToTopLeft];
+    NSLayoutConstraint *constraint = nil;
+    
+    constraint = [NSLayoutConstraint constraintWithItem:tocView
+                                              attribute:NSLayoutAttributeTop
+                                              relatedBy:NSLayoutRelationEqual
+                                                 toItem:self.view
+                                              attribute:NSLayoutAttributeTop
+                                             multiplier:1.0
+                                               constant:0];
+    [self.view addConstraint:constraint];
+    [self.tocConstraints addObject:constraint];
+    
+    constraint = [NSLayoutConstraint constraintWithItem:tocView
+                                              attribute:NSLayoutAttributeBottom
+                                              relatedBy:NSLayoutRelationEqual
+                                                 toItem:self.view
+                                              attribute:NSLayoutAttributeBottom
+                                             multiplier:1.0
+                                               constant:0];
+    [self.view addConstraint:constraint];
+    [self.tocConstraints addObject:constraint];
+    
+    constraint = [NSLayoutConstraint constraintWithItem:tocView
+                                              attribute:NSLayoutAttributeRight
+                                              relatedBy:NSLayoutRelationEqual
+                                                 toItem:self.webView
+                                              attribute:NSLayoutAttributeLeft
+                                             multiplier:1.0
+                                               constant:0];
+    [self.view addConstraint:constraint];
+    [self.tocConstraints addObject:constraint];
+    
+    constraint = [NSLayoutConstraint constraintWithItem:tocView
+                                              attribute:NSLayoutAttributeWidth
+                                              relatedBy:NSLayoutRelationEqual
+                                                 toItem:self.webView
+                                              attribute:NSLayoutAttributeWidth
+                                             multiplier:1.0f - WEB_VIEW_SCALE_WHEN_TOC_VISIBLE
+                                               constant:0];
+    [self.view addConstraint:constraint];
+    [self.tocConstraints addObject:constraint];
 }
 
 -(BOOL)shouldAutomaticallyForwardAppearanceMethods
@@ -197,6 +299,9 @@ -(void)resetBridge
     __weak WebViewController *weakSelf = self;
     [self.bridge addListener:@"linkClicked" withBlock:^(NSString *messageType, NSDictionary *payload) {
         NSString *href = payload[@"href"];
+        
+        weakSelf.tocVisible = NO;
+        
         if ([href hasPrefix:@"/wiki/"]) {
             NSString *title = [href substringWithRange:NSMakeRange(6, href.length - 6)];
             [weakSelf navigateToPage:title discoveryMethod:DISCOVERY_METHOD_LINK];
@@ -209,6 +314,13 @@ -(void)resetBridge
         }
     }];
 
+    [self.bridge addListener:@"nonAnchorTouchEndedWithoutDragging" withBlock:^(NSString *messageType, NSDictionary *payload) {
+        NSLog(@"nonAnchorTouchEndedWithoutDragging = %@", payload);
+        // nonAnchorTouchEndedWithoutDragging is used so TOC may be hidden if user tapped, but did *not* drag.
+        // Used because UIWebView is difficult to attach one-finger touch events to.
+        weakSelf.tocVisible = NO;
+    }];
+
     self.unsafeToScroll = NO;
     self.scrollOffset = CGPointZero;
 }
@@ -272,6 +384,8 @@ -(void)mainMenuToggle
         [self.navigationController popToViewController:self animated:NO];
     }
     
+    self.tocVisible = NO;
+
     self.mainMenuTableViewController = [self.navigationController.storyboard instantiateViewControllerWithIdentifier:@"MainMenuTableViewController"];
     [self.navigationController pushViewController:self.mainMenuTableViewController animated:NO];
 }
@@ -349,19 +463,31 @@ -(void)scrollViewScrollingEnded:(UIScrollView *)scrollView
 
         //[self printLiveContentLocationTestingOutputToConsole];
         //NSLog(@"%@", NSStringFromCGPoint(scrollView.contentOffset));
-
-        [articleDataContext_.workerContext performBlock:^(){
-            // Save scroll location
-            NSManagedObjectID *articleID = [articleDataContext_.workerContext getArticleIDForTitle:[self getCurrentArticleTitle]];
-            Article *article = (Article *)[articleDataContext_.workerContext objectWithID:articleID];
-            article.lastScrollX = @(scrollView.contentOffset.x);
-            article.lastScrollY = @(scrollView.contentOffset.y);
-            NSError *error = nil;
-            [articleDataContext_.workerContext save:&error];
-        }];
+        [self saveWebViewScrollOffset];
+        
+        for (UIViewController *childVC in self.childViewControllers) {
+            if([childVC isMemberOfClass:[TOCViewController class]]){
+                TOCViewController *vc = (TOCViewController *)childVC;
+                [vc centerCellForWebViewTopMostSection];
+                break;
+            }
+        }
     }
 }
 
+-(void)saveWebViewScrollOffset
+{
+    [articleDataContext_.workerContext performBlock:^(){
+        // Save scroll location
+        NSManagedObjectID *articleID = [articleDataContext_.workerContext getArticleIDForTitle:[self getCurrentArticleTitle]];
+        Article *article = (Article *)[articleDataContext_.workerContext objectWithID:articleID];
+        article.lastScrollX = @(self.webView.scrollView.contentOffset.x);
+        article.lastScrollY = @(self.webView.scrollView.contentOffset.y);
+        NSError *error = nil;
+        [articleDataContext_.workerContext save:&error];
+    }];
+}
+
 #pragma mark Web view html content live location retrieval
 
 -(void)printLiveContentLocationTestingOutputToConsole
@@ -564,7 +690,7 @@ - (void)navigateToPage:(NSString *)title discoveryMethod:(NSString *)discoveryMe
         [self retrieveArticleForPageTitle:cleanTitle discoveryMethod:discoveryMethod];
         
         // Update the back and forward buttons enabled state.
-        [self updateBackAndForwardButtonsEnabledState];
+        [self updateBottomBarButtonsEnabledState];
     }];
 }
 
@@ -730,7 +856,7 @@ - (void)retrieveArticleForPageTitle:(NSString *)pageTitle discoveryMethod:(NSStr
         [articleDataContext_.workerContext save:&error];
 
         // Update the back and forward buttons enabled state now that there's a new history entry.
-        [self updateBackAndForwardButtonsEnabledState];
+        [self updateBottomBarButtonsEnabledState];
 
         [self createSectionImageRecordsForSectionHtml:section0.objectID];
 
@@ -920,60 +1046,6 @@ - (void)displayArticle:(Article *)article
     }];
 }
 
-#pragma mark Shrink and skew
-
--(CABasicAnimation *)animationForPath:(NSString *)path toValue:(NSValue *)value duration:(CGFloat)duration
-{
-    CABasicAnimation *a = [CABasicAnimation animationWithKeyPath:path];
-    a.fillMode = kCAFillModeForwards;
-    a.autoreverses = NO;
-    a.duration = duration;
-    a.removedOnCompletion = NO;
-    CGFloat delay = 0.0f;
-    [a setBeginTime:CACurrentMediaTime() + delay];
-    a.toValue = value;
-    return a;
-}
-
--(void)shrinkAndAlignRightWithScale:(CGFloat)scale
-{
-    // Shrink web view and move it up against right side of screen.
-    CGSize size = self.webView.frame.size;
-    CGPoint alignRightOffset = CGPointMake(
-        (size.width - (size.width * scale)) / 2.0f,
-        -(size.height - (size.height * scale)) / 2.0f
-    );
-    CATransform3D xf = CATransform3DIdentity;
-    xf = CATransform3DTranslate(xf, alignRightOffset.x, alignRightOffset.y, 0);
-    xf = CATransform3DScale(xf, scale, scale, 1.0f);
-    CABasicAnimation *shrinkAnimation = [self animationForPath:@"transform" toValue:[NSValue valueWithCATransform3D:xf] duration:0.2f];
-    [self.webView.layer addAnimation:shrinkAnimation forKey:@"WEBVIEW_SHRINK"];
-}
-
--(void)skewWithEyePosition:(CGFloat)eyePosition angle:(CGFloat)angle
-{
-    // Skew the web view a bit.
-    //CGFloat eyePosition = -2000;
-    //CGFloat angle = 7.5f;
-    CATransform3D perspective = CATransform3DIdentity;
-    perspective.m34 = -1.0 / eyePosition;
-    CATransform3D rotationAndPerspectiveTransform = CATransform3DRotate(perspective, angle * M_PI / 180.0f, 0.0f, 1.0f, 0.0f);
-    CABasicAnimation *skewAnimation = [self animationForPath:@"sublayerTransform" toValue:[NSValue valueWithCATransform3D:rotationAndPerspectiveTransform] duration:0.2f];
-    [self.webView.layer addAnimation:skewAnimation forKey:@"WEBVIEW_SKEW"];
-}
-
--(void)shrinkReset
-{
-    CABasicAnimation *resetShrinkAnimation = [self animationForPath:@"transform" toValue:[NSValue valueWithCATransform3D:CATransform3DIdentity] duration:0.2f];
-    [self.webView.layer addAnimation:resetShrinkAnimation forKey:@"WEBVIEW_SHRINK_RESET"];
-}
-
--(void)skewReset
-{
-    CABasicAnimation *resetSkewAnimation = [self animationForPath:@"sublayerTransform" toValue:[NSValue valueWithCATransform3D:CATransform3DIdentity] duration:0.2f];
-    [self.webView.layer addAnimation:resetSkewAnimation forKey:@"WEBVIEW_SKEW_RESET"];
-}
-
 #pragma mark Bottom bar button methods
 
 //TODO: Pull bottomBarView and into own object (and its subviews - the back and forward view/buttons/methods, etc).
@@ -1027,35 +1099,13 @@ -(NSDictionary *)getTitlesForAdjacentHistoryArticles
     return result;
 }
 
--(void)updateBackAndForwardButtonsEnabledState
+-(void)updateBottomBarButtonsEnabledState
 {
     self.adjacentHistoryArticleTitles = [self getTitlesForAdjacentHistoryArticles];
     self.forwardButton.enabled = (self.adjacentHistoryArticleTitles[@"after"]) ? YES : NO;
     self.backButton.enabled = (self.adjacentHistoryArticleTitles[@"before"]) ? YES : NO;
-}
-
--(void)hideBottomBarAnimated:(BOOL)animated
-{
-    self.bottomBarViewBottomConstraint.constant = -self.bottomBarViewHeightConstraint.constant;
-    if (!animated) {
-        [self.view layoutIfNeeded];
-        return;
-    }
-    [UIView animateWithDuration:0.2 animations:^{
-        [self.view layoutIfNeeded];
-    }];
-}
-
--(void)showBottomBarAnimated:(BOOL)animated
-{
-    self.bottomBarViewBottomConstraint.constant = 0;
-    if (!animated) {
-        [self.view layoutIfNeeded];
-        return;
-    }
-    [UIView animateWithDuration:0.2 animations:^{
-        [self.view layoutIfNeeded];
-    }];
+    NSString *currentArticleTitle = [self getCurrentArticleTitle];
+    self.tocButton.enabled = (currentArticleTitle && (currentArticleTitle.length > 0)) ? YES : NO;
 }
 
 - (IBAction)tocButtonPushed:(id)sender
@@ -1096,6 +1146,8 @@ -(void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrien
         self.indexOfFirstOnscreenSectionBeforeRotate = [self.webView getIndexOfTopOnScreenElementWithPrefix:@"content_block_" count:article.section.count];
     }];    
     //self.view.alpha = 0.0f;
+
+    self.tocVisible = NO;
 }
 
 -(void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation
diff --git a/Wikipedia-iOS/mw-bridge/js/main.js b/Wikipedia-iOS/mw-bridge/js/main.js
index c473fe06b3e..33bfccad321 100644
--- a/Wikipedia-iOS/mw-bridge/js/main.js
+++ b/Wikipedia-iOS/mw-bridge/js/main.js
@@ -156,5 +156,20 @@
              event.preventDefault();
          }
      }
+
+    touchDownY = 0.0;
+    function touchStart(event){
+        touchDownY = parseInt(event.changedTouches[0].clientY);
+    }
+    document.addEventListener("touchstart", touchStart, "false");
+
+    function touchEnd(event){
+        var touchobj = event.changedTouches[0];
+        touchEndY = parseInt(touchobj.clientY);
+         if ( event.target.tagName != "A" && ((touchDownY - touchEndY) == 0) && (event.changedTouches.length == 1)) {
+             bridge.sendMessage( 'nonAnchorTouchEndedWithoutDragging', { id: event.target.getAttribute( "id" ), tagName: event.target.tagName});
+         }
+    }
+    document.addEventListener("touchend", touchEnd, "false");
  
 } )();
