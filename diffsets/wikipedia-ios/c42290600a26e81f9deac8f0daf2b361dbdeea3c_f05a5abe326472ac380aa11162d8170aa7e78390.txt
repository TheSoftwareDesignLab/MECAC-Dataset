diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index e86f416030d..3e8769f8e5f 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -195,6 +195,7 @@
 		0E3007361B30B97300D95147 /* Section.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E3007271B30B97300D95147 /* Section.m */; };
 		0E3007371B30B97300D95147 /* SectionImage.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E3007291B30B97300D95147 /* SectionImage.m */; };
 		0E36C2271AE0B59D00C58CFF /* Images.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = D4991453181D51DE00E6073C /* Images.xcassets */; };
+		0E7955C71B2B389800B055A2 /* TGLStackedLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */; };
 		0E94AFEA1B209721000BC5EA /* iPhone_Root.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 0E94AFE91B209721000BC5EA /* iPhone_Root.storyboard */; };
 		0E94AFED1B20976A000BC5EA /* WMFAppViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E94AFEC1B20976A000BC5EA /* WMFAppViewController.m */; };
 		0E94AFF01B209792000BC5EA /* WMFArticleListCollectionViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = 0E94AFEF1B209792000BC5EA /* WMFArticleListCollectionViewController.m */; };
@@ -206,6 +207,8 @@
 		0EBC56681AD3656900E82CDD /* WMFAsyncTestCase.m in Sources */ = {isa = PBXBuildFile; fileRef = BC7ACB631AB34C9C00791497 /* WMFAsyncTestCase.m */; };
 		0EBC567F1AD442CC00E82CDD /* BITHockeyManager+WMFExtensions.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EBC567E1AD442CC00E82CDD /* BITHockeyManager+WMFExtensions.m */; };
 		0EBC56971AD5B69300E82CDD /* BITHockeyManager+WMFExtensions.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EBC567E1AD442CC00E82CDD /* BITHockeyManager+WMFExtensions.m */; };
+		0ED44D751B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.m in Sources */ = {isa = PBXBuildFile; fileRef = 0ED44D741B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.m */; };
+		0ED44D781B28DA4D00F284BA /* UICollectionView+WMFEnumeration.m in Sources */ = {isa = PBXBuildFile; fileRef = 0ED44D771B28DA4D00F284BA /* UICollectionView+WMFEnumeration.m */; };
 		0EE7687B1AF982C100A5D046 /* WMFArticleProtocol.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EE7687A1AF982C100A5D046 /* WMFArticleProtocol.m */; };
 		0EE768811AFD25CC00A5D046 /* WMFSearchFunnel.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EE768801AFD25CC00A5D046 /* WMFSearchFunnel.m */; };
 		0EFB0F191B31EE2D00D05C08 /* Article.m in Sources */ = {isa = PBXBuildFile; fileRef = 0EFB0EFB1B31EE2D00D05C08 /* Article.m */; };
@@ -730,6 +733,8 @@
 		08D631F91A69B8CD00D87AD0 /* WMFImageGalleryCollectionViewCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = WMFImageGalleryCollectionViewCell.m; path = "Image Gallery/WMFImageGalleryCollectionViewCell.m"; sourceTree = "<group>"; };
 		08F646F7D0488CE3C6D6A763 /* Pods.beta.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = Pods.beta.xcconfig; path = "Pods/Target Support Files/Pods/Pods.beta.xcconfig"; sourceTree = "<group>"; };
 		0E36C2281AE0B5BD00C58CFF /* SourceIcons.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = SourceIcons.xcassets; path = Wikipedia/SourceIcons.xcassets; sourceTree = "<group>"; };
+		0E7955C21B2B389800B055A2 /* TGLStackedLayout.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TGLStackedLayout.h; sourceTree = "<group>"; };
+		0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = TGLStackedLayout.m; sourceTree = "<group>"; };
 		0E94AFE91B209721000BC5EA /* iPhone_Root.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; path = iPhone_Root.storyboard; sourceTree = "<group>"; };
 		0E94AFEB1B20976A000BC5EA /* WMFAppViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFAppViewController.h; sourceTree = "<group>"; };
 		0E94AFEC1B20976A000BC5EA /* WMFAppViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFAppViewController.m; sourceTree = "<group>"; };
@@ -746,6 +751,11 @@
 		0EA4402D1AA6281200B09DBA /* NSDateFormatter+WMFExtensions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = "NSDateFormatter+WMFExtensions.m"; path = "Wikipedia/Categories/NSDateFormatter+WMFExtensions.m"; sourceTree = SOURCE_ROOT; };
 		0EBC567D1AD442CC00E82CDD /* BITHockeyManager+WMFExtensions.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = "BITHockeyManager+WMFExtensions.h"; path = "Wikipedia/Categories/BITHockeyManager+WMFExtensions.h"; sourceTree = SOURCE_ROOT; };
 		0EBC567E1AD442CC00E82CDD /* BITHockeyManager+WMFExtensions.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = "BITHockeyManager+WMFExtensions.m"; path = "Wikipedia/Categories/BITHockeyManager+WMFExtensions.m"; sourceTree = SOURCE_ROOT; };
+		0ED44D6E1B2893C500F284BA /* Global.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = Global.h; sourceTree = "<group>"; };
+		0ED44D731B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFArticleViewControllerContainerCell.h; sourceTree = "<group>"; };
+		0ED44D741B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFArticleViewControllerContainerCell.m; sourceTree = "<group>"; };
+		0ED44D761B28DA4D00F284BA /* UICollectionView+WMFEnumeration.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UICollectionView+WMFEnumeration.h"; sourceTree = "<group>"; };
+		0ED44D771B28DA4D00F284BA /* UICollectionView+WMFEnumeration.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UICollectionView+WMFEnumeration.m"; sourceTree = "<group>"; };
 		0EE768791AF982C100A5D046 /* WMFArticleProtocol.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WMFArticleProtocol.h; path = Wikipedia/Protocols/WMFArticleProtocol.h; sourceTree = SOURCE_ROOT; };
 		0EE7687A1AF982C100A5D046 /* WMFArticleProtocol.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = WMFArticleProtocol.m; path = Wikipedia/Protocols/WMFArticleProtocol.m; sourceTree = SOURCE_ROOT; };
 		0EE7687F1AFD25CC00A5D046 /* WMFSearchFunnel.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFSearchFunnel.h; sourceTree = "<group>"; };
@@ -2120,6 +2130,15 @@
 			path = Categories;
 			sourceTree = "<group>";
 		};
+		0E7955BF1B2B389800B055A2 /* TGLStackedViewController */ = {
+			isa = PBXGroup;
+			children = (
+				0E7955C21B2B389800B055A2 /* TGLStackedLayout.h */,
+				0E7955C31B2B389800B055A2 /* TGLStackedLayout.m */,
+			);
+			path = TGLStackedViewController;
+			sourceTree = "<group>";
+		};
 		0E94AFE81B2096D5000BC5EA /* UI-V5 */ = {
 			isa = PBXGroup;
 			children = (
@@ -2128,6 +2147,8 @@
 				0E94AFEC1B20976A000BC5EA /* WMFAppViewController.m */,
 				0E94AFEE1B209792000BC5EA /* WMFArticleListCollectionViewController.h */,
 				0E94AFEF1B209792000BC5EA /* WMFArticleListCollectionViewController.m */,
+				0ED44D731B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.h */,
+				0ED44D741B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.m */,
 				0E94AFF11B209857000BC5EA /* WMFSearchViewController.h */,
 				0E94AFF21B209857000BC5EA /* WMFSearchViewController.m */,
 				0E94AFF41B209882000BC5EA /* WMFArticleViewController.h */,
@@ -2135,6 +2156,9 @@
 				0E94AFF71B209E0A000BC5EA /* WMFArticleViewController.xib */,
 				0E94AFF91B20A22C000BC5EA /* WMFStyleManager.h */,
 				0E94AFFA1B20A22C000BC5EA /* WMFStyleManager.m */,
+				0ED44D761B28DA4D00F284BA /* UICollectionView+WMFEnumeration.h */,
+				0ED44D771B28DA4D00F284BA /* UICollectionView+WMFEnumeration.m */,
+				0E7955BF1B2B389800B055A2 /* TGLStackedViewController */,
 			);
 			path = "UI-V5";
 			sourceTree = "<group>";
@@ -3176,6 +3200,7 @@
 				D42E75EB18D11237002EA7E5 /* MWLanguageInfo.m in Sources */,
 				0EFB0F1A1B31EE2D00D05C08 /* ArticleData.xcdatamodeld in Sources */,
 				043F8BF21A11699A00D1AE44 /* UIView+WMFRoundCorners.m in Sources */,
+				0ED44D751B28AC1E00F284BA /* WMFArticleViewControllerContainerCell.m in Sources */,
 				0487048019F8262600B7D307 /* AccountLogin.m in Sources */,
 				04D149DD18877343006B4104 /* AlertLabel.m in Sources */,
 				BCB669AE1A83F6C400C7B1FE /* MWKHistoryEntry.m in Sources */,
@@ -3210,6 +3235,7 @@
 				BCE24FDE1B0CF0C7003F054B /* LegacyDataMigrator.m in Sources */,
 				0EFB0F1E1B31EE2D00D05C08 /* NSManagedObjectModel+LegacyCoreData.m in Sources */,
 				BC86B9401A929D7900B4C039 /* UICollectionViewFlowLayout+WMFItemSizeThatFits.m in Sources */,
+				0E7955C71B2B389800B055A2 /* TGLStackedLayout.m in Sources */,
 				C96335911AA92AAC00A1EB2C /* WMFCrashAlertView.m in Sources */,
 				D401C2C01A659E5000D4D127 /* DataMigrationProgressViewController.m in Sources */,
 				04CCCFF01935093A00E3F60C /* SecondaryMenuViewController.m in Sources */,
@@ -3221,6 +3247,7 @@
 				BCB58F631A8A9F1000465627 /* MWKLicense.m in Sources */,
 				041C55D21950B27D006CE0EF /* EditSummaryViewController.m in Sources */,
 				04CCA0C01983086D000E982A /* ReferencesVC.m in Sources */,
+				0ED44D781B28DA4D00F284BA /* UICollectionView+WMFEnumeration.m in Sources */,
 				043B6E8E1ACDE0CF0005C60B /* NSAttributedString+WMFSavedPagesAttributedStrings.m in Sources */,
 				04C43ABE183442FC006C643B /* NSRunLoop+TimeOutAndFlag.m in Sources */,
 				0487048719F8262600B7D307 /* LoginTokenFetcher.m in Sources */,
diff --git a/Wikipedia/AppDelegate.m b/Wikipedia/AppDelegate.m
index c45fe1dd137..9da6b2495e2 100644
--- a/Wikipedia/AppDelegate.m
+++ b/Wikipedia/AppDelegate.m
@@ -2,7 +2,6 @@
 
 #import "AppDelegate.h"
 #import "BITHockeyManager+WMFExtensions.h"
-#import "WMFStyleManager.h"
 #import "WMFAppViewController.h"
 
 @interface AppDelegate ()
@@ -42,10 +41,6 @@ - (UIWindow*)window {
 - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions {
     [[BITHockeyManager sharedHockeyManager] wmf_setupAndStart];
 
-    WMFStyleManager* manager = [WMFStyleManager new];
-    [manager applyStyleToWindow:self.window];
-    [WMFStyleManager setSharedStyleManager:manager];
-
     WMFAppViewController* vc = [WMFAppViewController initialAppViewControllerFromDefaultStoryBoard];
     [vc launchAppInWindow:self.window];
     self.appViewController = vc;
diff --git a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h
new file mode 100644
index 00000000000..637e4a3735a
--- /dev/null
+++ b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h
@@ -0,0 +1,119 @@
+//
+//  TGLStackedLayout.h
+//  TGLStackedViewController
+//
+//  Created by Tim Gleue on 07.04.14.
+//  Copyright (c) 2014 Tim Gleue ( http://gleue-interactive.com )
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+
+#import <UIKit/UIKit.h>
+
+@protocol TGLStackedLayoutDelegate;
+
+@interface TGLStackedLayout : UICollectionViewLayout
+
+@property (nonatomic, weak) id<TGLStackedLayoutDelegate> delegate;
+
+
+/** Margins between collection view and items. Default is UIEdgeInsetsMake(20.0, 0.0, 0.0, 0.0) */
+@property (assign, nonatomic) UIEdgeInsets layoutMargin;
+
+/** Size of items if set to value not equal CGSizeZero.
+ *
+ * If set to CGSizeZero (default) item sizes are computed
+ * from the collection view's bounds minus the margins defined
+ * in property -layoutMargin.
+ */
+@property (assign, nonatomic) CGSize itemSize;
+
+/** Amount to show of each stacked item. Default is 120.0 */
+@property (assign, nonatomic) CGFloat topReveal;
+
+/** Amount of compression/expansing when scrolling bounces. Default is 0.2 */
+@property (assign, nonatomic) CGFloat bounceFactor;
+
+/** Set to YES to ignore -topReveal and arrange items evenly in collection view's bounds, if items do not fill entire height. Default is NO. */
+@property (assign, nonatomic, getter = isFillingHeight) BOOL fillHeight;
+
+/** Set to YES to enable bouncing even when items do not fill entire height. Default is NO. */
+@property (assign, nonatomic, getter = isAlwaysBouncing) BOOL alwaysBounce;
+
+/** Use -contentOffset instead of collection view's actual content offset for next layout */
+@property (assign, nonatomic) BOOL overwriteContentOffset;
+
+/** Content offset value to replace actual value when -overwriteContentOffset is YES */
+@property (assign, nonatomic) CGPoint contentOffset;
+
+/** Index path of item currently being moved, and thus being hidden */
+@property (strong, nonatomic) NSIndexPath *movingIndexPath;
+
+@end
+
+
+
+@protocol TGLStackedLayoutDelegate <UICollectionViewDelegateFlowLayout>
+
+@optional
+
+/** Check whether a given cell can be moved.
+ *
+ *
+ * Implement this method to prevent items from
+ * being dragged to another location.
+ *
+ * @param layout The layout requesting the information
+ * @param indexPath Index path of item to be moved.
+ *
+ * @return YES if item can be moved (default); otherwise NO.
+ */
+- (BOOL)stackLayout:(TGLStackedLayout*)layout canMoveItemAtIndexPath:(NSIndexPath*)indexPath;
+
+/** Retarget a item's proposed index path while being moved.
+ *
+ * Implement this method to modify an item's target location
+ * while being dragged to another location, e.g. to prevent
+ * it from being moved to certain locations.
+ *
+ * @param layout The layout requesting the information
+ * @param sourceIndexPath Moving item's original index path.
+ * @param proposedDestinationIndexPath The item's proposed index path during move.
+ *
+ * @return The item's desired index path. Return proposedDestinationIndexPath if
+ *         it is suitable (default); or nil if item should not be moved.
+ */
+- (NSIndexPath*)stackLayout:(TGLStackedLayout*)layout targetIndexPathForMoveFromItemAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;
+
+/** Move item in data source while dragging.
+ *
+ * Implement this method to update the collection
+ * view's data source.
+ *
+ * @param layout The layout making the movee
+ * @param fromIndexPath Original item indexPath
+ * @param toIndexPath New item indexPath
+ */
+- (void)stackLayout:(TGLStackedLayout*)layout moveItemAtIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath;
+
+
+- (BOOL)stackLayout:(TGLStackedLayout*)layout canDeleteItemAtIndexPath:(NSIndexPath*)indexPath;
+
+- (void)stackLayout:(TGLStackedLayout*)layout deleteItemAtIndexPath:(NSIndexPath*)indexPath;
+
+@end
diff --git a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
new file mode 100644
index 00000000000..c680ac6d25e
--- /dev/null
+++ b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
@@ -0,0 +1,806 @@
+//
+//  TGLStackedLayout.m
+//  TGLStackedViewController
+//
+//  Created by Tim Gleue on 07.04.14.
+//  Copyright (c) 2014 Tim Gleue ( http://gleue-interactive.com )
+//
+//  Permission is hereby granted, free of charge, to any person obtaining a copy
+//  of this software and associated documentation files (the "Software"), to deal
+//  in the Software without restriction, including without limitation the rights
+//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+//  copies of the Software, and to permit persons to whom the Software is
+//  furnished to do so, subject to the following conditions:
+//
+//  The above copyright notice and this permission notice shall be included in
+//  all copies or substantial portions of the Software.
+//
+//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+//  THE SOFTWARE.
+
+#import "TGLStackedLayout.h"
+
+#define MOVE_ZOOM 0.95
+
+#define SCROLL_PER_FRAME 5.0
+#define SCROLL_ZONE_TOP 100.0
+#define SCROLL_ZONE_BOTTOM 100.0
+
+typedef NS_ENUM(NSInteger, TGLStackedViewControllerScrollDirection) {
+
+    TGLStackedViewControllerScrollDirectionNone = 0,
+    TGLStackedViewControllerScrollDirectionDown,
+    TGLStackedViewControllerScrollDirectionUp
+};
+
+@interface TGLStackedLayout ()<UIGestureRecognizerDelegate>
+
+@property (strong, nonatomic) UIView *movingView;
+@property (strong, nonatomic) UILongPressGestureRecognizer *moveGestureRecognizer;
+
+@property (assign, nonatomic) TGLStackedViewControllerScrollDirection scrollDirection;
+@property (strong, nonatomic) CADisplayLink *scrollDisplayLink;
+
+@property (nonatomic, strong) UIPanGestureRecognizer* deletePanGesture;
+@property (nonatomic, strong) NSIndexPath* panningIndexPath;
+@property (nonatomic, strong) NSIndexPath* deletingIndexPath;
+
+@property (nonatomic, strong) NSDictionary *layoutAttributes;
+
+// Set to YES when layout is currently arranging
+// items so that they evenly fill entire height
+//
+@property (nonatomic, assign) BOOL filling;
+
+@end
+
+@implementation TGLStackedLayout
+
+- (instancetype)init {
+
+    self = [super init];
+
+    if (self) [self initLayout];
+
+    return self;
+}
+
+- (instancetype)initWithCoder:(NSCoder *)aDecoder {
+
+    self = [super initWithCoder:aDecoder];
+
+    if (self) [self initLayout];
+
+    return self;
+}
+
+- (void)initLayout {
+
+    self.layoutMargin = UIEdgeInsetsMake(20.0, 0.0, 0.0, 0.0);
+    self.topReveal = 120.0;
+    self.bounceFactor = 0.2;
+}
+
+#pragma mark - Accessors
+
+- (void)setLayoutMargin:(UIEdgeInsets)margins {
+
+    if (!UIEdgeInsetsEqualToEdgeInsets(margins, self.layoutMargin)) {
+
+        _layoutMargin = margins;
+
+        [self invalidateLayout];
+    }
+}
+
+- (void)setTopReveal:(CGFloat)topReveal {
+
+    if (topReveal != self.topReveal) {
+
+        _topReveal = topReveal;
+
+        [self invalidateLayout];
+    }
+}
+
+- (void)setItemSize:(CGSize)itemSize {
+
+    if (!CGSizeEqualToSize(itemSize, self.itemSize)) {
+
+        _itemSize = itemSize;
+
+        [self invalidateLayout];
+    }
+}
+
+- (void)setBounceFactor:(CGFloat)bounceFactor {
+
+    if (bounceFactor != self.bounceFactor) {
+
+        _bounceFactor = bounceFactor;
+
+        [self invalidateLayout];
+    }
+}
+
+- (void)setFillHeight:(BOOL)fillHeight {
+
+    if (fillHeight != self.isFillingHeight) {
+
+        _fillHeight = fillHeight;
+
+        [self invalidateLayout];
+    }
+}
+
+- (void)setAlwaysBounce:(BOOL)alwaysBounce {
+
+    if (alwaysBounce != self.alwaysBounce) {
+
+        _alwaysBounce = alwaysBounce;
+
+        [self invalidateLayout];
+    }
+}
+
+#pragma mark - UICollectionViewLayout
+
+- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset {
+
+    // Honor overwritten contentOffset
+    //
+    // See http://stackoverflow.com/a/25416243
+    //
+    return self.overwriteContentOffset ? self.contentOffset : proposedContentOffset;
+}
+
+- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds {
+
+    return YES;
+}
+
+- (CGSize)collectionViewContentSize {
+
+    CGSize contentSize = CGSizeMake(CGRectGetWidth(self.collectionView.bounds), self.layoutMargin.top + self.topReveal * [self.collectionView numberOfItemsInSection:0] + self.layoutMargin.bottom - self.collectionView.contentInset.bottom);
+
+    if (contentSize.height < CGRectGetHeight(self.collectionView.bounds)) {
+
+        contentSize.height = CGRectGetHeight(self.collectionView.bounds) - self.collectionView.contentInset.top - self.collectionView.contentInset.bottom;
+
+        // Adding an extra point of content height
+        // enables scrolling/bouncing
+        //
+        if (self.isAlwaysBouncing) contentSize.height += 1.0;
+
+        self.filling = self.isFillingHeight;
+
+    } else {
+
+        self.filling = NO;
+    }
+
+    return contentSize;
+}
+
+- (void)prepareLayout {
+
+    // Force update of property -filling
+    // used to decide whether to arrange
+    // items evenly in collection view's
+    // full height
+    //
+    [self collectionViewContentSize];
+
+    if(!self.moveGestureRecognizer){
+        self.moveGestureRecognizer = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(handleLongPress:)];
+        self.moveGestureRecognizer.delegate = self;
+        [self.collectionView addGestureRecognizer:self.moveGestureRecognizer];
+    }
+
+    if(!self.deletePanGesture){
+        self.deletePanGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panWithGesture:)];
+        self.deletePanGesture.maximumNumberOfTouches = 1;
+        self.deletePanGesture.delegate = self;
+        [self.collectionView addGestureRecognizer:self.deletePanGesture];
+        [self.collectionView.panGestureRecognizer requireGestureRecognizerToFail:self.deletePanGesture];
+        [self.moveGestureRecognizer requireGestureRecognizerToFail:self.deletePanGesture];
+    }
+
+    CGFloat itemReveal = self.topReveal;
+
+    if (self.filling) {
+
+        itemReveal = floor((CGRectGetHeight(self.collectionView.bounds) - self.layoutMargin.top - self.layoutMargin.bottom - self.collectionView.contentInset.top - self.collectionView.contentInset.bottom) / [self.collectionView numberOfItemsInSection:0]);
+    }
+
+    CGSize itemSize = self.itemSize;
+
+    if (CGSizeEqualToSize(itemSize, CGSizeZero)) {
+
+        itemSize = CGSizeMake(CGRectGetWidth(self.collectionView.bounds) - self.layoutMargin.left - self.layoutMargin.right, CGRectGetHeight(self.collectionView.bounds) - self.layoutMargin.top - self.layoutMargin.bottom - self.collectionView.contentInset.top - self.collectionView.contentInset.bottom);
+    }
+
+    // Honor overwritten contentOffset
+    //
+    CGPoint contentOffset = self.overwriteContentOffset ? self.contentOffset : self.collectionView.contentOffset;
+
+    NSMutableDictionary *layoutAttributes = [NSMutableDictionary dictionary];
+    UICollectionViewLayoutAttributes *previousTopOverlappingAttributes[2] = { nil, nil };
+    NSInteger itemCount = [self.collectionView numberOfItemsInSection:0];
+
+    static NSInteger firstCompressingItem = -1;
+
+    for (NSInteger item = 0; item < itemCount; item++) {
+
+        NSIndexPath *indexPath = [NSIndexPath indexPathForItem:item inSection:0];
+        UICollectionViewLayoutAttributes *attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:indexPath];
+
+        // Cards overlap each other
+        // via z depth
+        //
+        attributes.zIndex = item;
+
+        // The moving item is hidden
+        //
+        attributes.hidden = [attributes.indexPath isEqual:self.movingIndexPath];
+
+        // By default all items are layed
+        // out evenly with each revealing
+        // only top part ...
+        //
+        attributes.frame = CGRectMake(self.layoutMargin.left, self.layoutMargin.top + itemReveal * item, itemSize.width, itemSize.height);
+
+        if (contentOffset.y + self.collectionView.contentInset.top < 0.0) {
+
+            // Expand cells when reaching top
+            // and user scrolls further down,
+            // i.e. when bouncing
+            //
+            CGRect frame = attributes.frame;
+
+            frame.origin.y -= self.bounceFactor * (contentOffset.y + self.collectionView.contentInset.top) * item;
+
+            attributes.frame = frame;
+
+        } else if (CGRectGetMinY(attributes.frame) < contentOffset.y + self.layoutMargin.top) {
+
+            // Topmost cells overlap stack, but
+            // are placed directly above each
+            // other such that only one cell
+            // is visible
+            //
+            CGRect frame = attributes.frame;
+
+            frame.origin.y = contentOffset.y + self.layoutMargin.top;
+
+            attributes.frame = frame;
+
+            // Keep queue of last two items'
+            // attributes and hide any item
+            // below top overlapping item to
+            // improve performance
+            //
+            if (previousTopOverlappingAttributes[1]) previousTopOverlappingAttributes[1].hidden = YES;
+
+            previousTopOverlappingAttributes[1] = previousTopOverlappingAttributes[0];
+            previousTopOverlappingAttributes[0] = attributes;
+
+        } else if (self.collectionViewContentSize.height > CGRectGetHeight(self.collectionView.bounds) && contentOffset.y > self.collectionViewContentSize.height - CGRectGetHeight(self.collectionView.bounds)) {
+
+            // Compress cells when reaching bottom
+            // and user scrolls further up,
+            // i.e. when bouncing
+            //
+            if (firstCompressingItem < 0) {
+
+                firstCompressingItem = item;
+
+            } else {
+
+                CGRect frame = attributes.frame;
+                CGFloat delta = contentOffset.y + CGRectGetHeight(self.collectionView.bounds) - self.collectionViewContentSize.height;
+
+                frame.origin.y += self.bounceFactor * delta * (firstCompressingItem - item);
+                frame.origin.y = MAX(frame.origin.y, contentOffset.y + self.layoutMargin.top);
+
+                attributes.frame = frame;
+            }
+
+        } else {
+
+            firstCompressingItem = -1;
+        }
+
+        layoutAttributes[indexPath] = attributes;
+    }
+
+    self.layoutAttributes = layoutAttributes;
+}
+
+- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
+
+    NSMutableArray *layoutAttributes = [NSMutableArray array];
+
+    [self.layoutAttributes enumerateKeysAndObjectsUsingBlock:^(NSIndexPath *indexPath, UICollectionViewLayoutAttributes *attributes, BOOL *stop) {
+
+        if (CGRectIntersectsRect(rect, attributes.frame)) {
+
+            [layoutAttributes addObject:attributes];
+            if([self.panningIndexPath isEqual:attributes.indexPath]){
+                [self updateAttibutesWithPanTranslation:attributes];
+            }
+
+        }
+    }];
+
+    return layoutAttributes;
+}
+
+- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath {
+
+    UICollectionViewLayoutAttributes* item = self.layoutAttributes[indexPath];
+    if([self.panningIndexPath isEqual:indexPath]){
+        [self updateAttibutesWithPanTranslation:item];
+    }
+    return item;
+}
+
+- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDisappearingItemAtIndexPath:(NSIndexPath *)itemIndexPath{
+
+    if([self.deletingIndexPath isEqual:itemIndexPath]){
+        UICollectionViewLayoutAttributes* item = [self layoutAttributesForItemAtIndexPath:itemIndexPath];
+        [self updateAttibutesForDeletion:item];
+        return item;
+    }
+    return [super finalLayoutAttributesForDisappearingItemAtIndexPath:itemIndexPath];
+}
+
+
+#pragma mark - Update Attributes
+
+- (void)updateAttibutesWithPanTranslation:(UICollectionViewLayoutAttributes*)item{
+    CGPoint translation = [self.deletePanGesture translationInView:self.collectionView];
+
+    CGRect frame = item.frame;
+    frame.origin.x = translation.x;
+    item.frame = frame;
+}
+
+- (void)resetAttibutesWithPanTranslation:(UICollectionViewLayoutAttributes*)item{
+
+    CGPoint translation = [self.deletePanGesture translationInView:self.collectionView];
+
+    CGRect frame = item.frame;
+    frame.origin.x = 0;
+    item.frame = frame;
+}
+
+- (void)updateAttibutesForDeletion:(UICollectionViewLayoutAttributes*)item{
+
+    CGRect frame = item.frame;
+    frame.origin.x = self.collectionView.bounds.size.width*2;
+    item.frame = frame;
+}
+
+
+#pragma mark - Drag Action
+
+- (IBAction)handleLongPress:(UILongPressGestureRecognizer *)recognizer {
+
+    static CGPoint startCenter;
+    static CGPoint startLocation;
+
+    switch (recognizer.state) {
+
+        case UIGestureRecognizerStateBegan: {
+
+            startLocation = [recognizer locationInView:self.collectionView];
+
+            NSIndexPath *indexPath = [self.collectionView indexPathForItemAtPoint:startLocation];
+
+            BOOL canMove = [self.delegate respondsToSelector:@selector(stackLayout:canMoveItemAtIndexPath:)] ? [self.delegate stackLayout:self canMoveItemAtIndexPath:indexPath] : YES;
+
+            if (indexPath && canMove) {
+
+                UICollectionViewCell *movingCell = [self.collectionView cellForItemAtIndexPath:indexPath];
+
+                self.movingView = [[UIView alloc] initWithFrame:movingCell.frame];
+
+                startCenter = self.movingView.center;
+
+                UIImageView *movingImageView = [[UIImageView alloc] initWithImage:[self screenshotImageOfItem:movingCell]];
+
+                movingImageView.alpha = 0.0f;
+
+                [self.movingView addSubview:movingImageView];
+                [self.collectionView addSubview:self.movingView];
+
+                self.movingIndexPath = indexPath;
+
+                __weak typeof(self) weakSelf = self;
+
+                [UIView animateWithDuration:0.3
+                                      delay:0.0
+                                    options:UIViewAnimationOptionBeginFromCurrentState
+                                 animations:^ (void) {
+
+                                     __strong typeof(self) strongSelf = weakSelf;
+
+                                     if (strongSelf) {
+
+                                         strongSelf.movingView.transform = CGAffineTransformMakeScale(MOVE_ZOOM, MOVE_ZOOM);
+                                         movingImageView.alpha = 1.0f;
+                                     }
+                                 }
+                                 completion:^ (BOOL finished) {
+                                 }];
+
+                self.movingIndexPath = self.movingIndexPath;
+                [self invalidateLayout];
+            }
+
+            break;
+        }
+
+        case UIGestureRecognizerStateChanged: {
+
+            if (self.movingIndexPath) {
+
+                CGPoint currentLocation = [recognizer locationInView:self.collectionView];
+                CGPoint currentCenter = startCenter;
+
+                currentCenter.y += (currentLocation.y - startLocation.y);
+
+                self.movingView.center = currentCenter;
+
+                if (currentLocation.y < CGRectGetMinY(self.collectionView.bounds) + SCROLL_ZONE_TOP && self.collectionView.contentOffset.y > SCROLL_ZONE_TOP) {
+
+                    [self startScrollingUp];
+
+                } else if (currentLocation.y > CGRectGetMaxY(self.collectionView.bounds) - SCROLL_ZONE_BOTTOM && self.collectionView.contentOffset.y < self.collectionView.contentSize.height - CGRectGetHeight(self.collectionView.bounds) - SCROLL_ZONE_BOTTOM) {
+
+                    [self startScrollingDown];
+
+                } else if (self.scrollDirection != TGLStackedViewControllerScrollDirectionNone) {
+
+                    [self stopScrolling];
+                }
+
+                if (self.scrollDirection == TGLStackedViewControllerScrollDirectionNone) {
+
+                    [self updateLayoutAtMovingLocation:currentLocation];
+                }
+            }
+
+            break;
+        }
+
+        case UIGestureRecognizerStateEnded:
+        case UIGestureRecognizerStateCancelled: {
+
+            if (self.movingIndexPath) {
+
+                [self stopScrolling];
+
+                UICollectionViewLayoutAttributes *layoutAttributes = [self layoutAttributesForItemAtIndexPath:self.movingIndexPath];
+
+                self.movingIndexPath = nil;
+
+                __weak typeof(self) weakSelf = self;
+
+                [UIView animateWithDuration:0.3
+                                      delay:0.0
+                                    options:UIViewAnimationOptionBeginFromCurrentState
+                                 animations:^ (void) {
+
+                                     __strong typeof(self) strongSelf = weakSelf;
+
+                                     if (strongSelf) {
+
+                                         strongSelf.movingView.transform = CGAffineTransformMakeScale(1.0f, 1.0f);
+                                         strongSelf.movingView.frame = layoutAttributes.frame;
+                                     }
+                                 }
+                                 completion:^ (BOOL finished) {
+
+                                     __strong typeof(self) strongSelf = weakSelf;
+
+                                     if (strongSelf) {
+
+                                         [strongSelf.movingView removeFromSuperview];
+                                         strongSelf.movingView = nil;
+
+                                         self.movingIndexPath = nil;
+                                         [strongSelf invalidateLayout];
+                                     }
+                                 }];
+            }
+
+            break;
+        }
+
+        default:
+
+            break;
+    }
+}
+
+#pragma mark - Drag Helpers
+
+- (void)startScrollingUp {
+
+    [self startScrollingInDirection:TGLStackedViewControllerScrollDirectionUp];
+}
+
+- (void)startScrollingDown {
+
+    [self startScrollingInDirection:TGLStackedViewControllerScrollDirectionDown];
+}
+
+- (void)startScrollingInDirection:(TGLStackedViewControllerScrollDirection)direction {
+
+    if (direction != TGLStackedViewControllerScrollDirectionNone && direction != self.scrollDirection) {
+
+        [self stopScrolling];
+
+        self.scrollDirection = direction;
+        self.scrollDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleScrolling:)];
+
+        [self.scrollDisplayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];
+    }
+}
+
+- (void)stopScrolling {
+
+    if (self.scrollDirection != TGLStackedViewControllerScrollDirectionNone) {
+
+        self.scrollDirection = TGLStackedViewControllerScrollDirectionNone;
+
+        [self.scrollDisplayLink invalidate];
+        self.scrollDisplayLink = nil;
+    }
+}
+
+- (void)handleScrolling:(CADisplayLink *)displayLink {
+
+    switch (self.scrollDirection) {
+
+        case TGLStackedViewControllerScrollDirectionUp: {
+
+            CGPoint offset = self.collectionView.contentOffset;
+
+            offset.y -= SCROLL_PER_FRAME;
+
+            if (offset.y > 0.0) {
+
+                self.collectionView.contentOffset = offset;
+
+                CGPoint center = self.movingView.center;
+
+                center.y -= SCROLL_PER_FRAME;
+                self.movingView.center = center;
+
+            } else {
+
+                [self stopScrolling];
+
+                CGPoint currentLocation = [self.moveGestureRecognizer locationInView:self.collectionView];
+
+                [self updateLayoutAtMovingLocation:currentLocation];
+            }
+
+            break;
+        }
+
+        case TGLStackedViewControllerScrollDirectionDown: {
+
+            CGPoint offset = self.collectionView.contentOffset;
+
+            offset.y += SCROLL_PER_FRAME;
+
+            if (offset.y < self.collectionView.contentSize.height - CGRectGetHeight(self.collectionView.bounds)) {
+
+                self.collectionView.contentOffset = offset;
+
+                CGPoint center = self.movingView.center;
+
+                center.y += SCROLL_PER_FRAME;
+                self.movingView.center = center;
+
+            } else {
+
+                [self stopScrolling];
+
+                CGPoint currentLocation = [self.moveGestureRecognizer locationInView:self.collectionView];
+
+                [self updateLayoutAtMovingLocation:currentLocation];
+            }
+
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+- (UIImage *)screenshotImageOfItem:(UICollectionViewCell *)item {
+
+    UIGraphicsBeginImageContextWithOptions(item.bounds.size, item.isOpaque, 0.0f);
+
+    [item.layer renderInContext:UIGraphicsGetCurrentContext()];
+
+    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
+
+    UIGraphicsEndImageContext();
+
+    return image;
+}
+
+- (void)updateLayoutAtMovingLocation:(CGPoint)movingLocation {
+
+    NSIndexPath *oldMovingIndexPath = self.movingIndexPath;
+    NSIndexPath *newMovingIndexPath = [self.collectionView indexPathForItemAtPoint:movingLocation];
+
+    if([self.delegate respondsToSelector:@selector(stackLayout:targetIndexPathForMoveFromItemAtIndexPath:toProposedIndexPath:)]){
+        newMovingIndexPath = [self.delegate stackLayout:self targetIndexPathForMoveFromItemAtIndexPath:oldMovingIndexPath toProposedIndexPath:newMovingIndexPath];
+    }
+
+    if (newMovingIndexPath != nil && ![newMovingIndexPath isEqual:oldMovingIndexPath]) {
+
+        __weak typeof(self) weakSelf = self;
+
+        [self.collectionView performBatchUpdates:^ (void) {
+
+            [weakSelf.collectionView deleteItemsAtIndexPaths:@[ oldMovingIndexPath ]];
+
+            weakSelf.movingIndexPath = newMovingIndexPath;
+
+            if([weakSelf.delegate respondsToSelector:@selector(stackLayout:moveItemAtIndexPath:toIndexPath:)]){
+                [weakSelf.delegate stackLayout:weakSelf moveItemAtIndexPath:oldMovingIndexPath toIndexPath:newMovingIndexPath];
+            }
+
+            [weakSelf.collectionView insertItemsAtIndexPaths:@[ newMovingIndexPath ]];
+
+        }
+                                      completion:nil];
+    }
+}
+
+
+#pragma mark - UIGestureRecognizer
+
+- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
+
+    if(![gestureRecognizer isEqual:self.deletePanGesture]){
+        return YES;
+    }
+
+    CGPoint attachmentPoint = [gestureRecognizer locationInView:self.collectionView];
+    NSIndexPath* touchedIndexPath = [self.collectionView indexPathForItemAtPoint:attachmentPoint];
+
+    if(!touchedIndexPath){
+        return NO;
+    }
+
+    if([self.delegate respondsToSelector:@selector(stackLayout:canDeleteItemAtIndexPath:)] && ![self.delegate stackLayout:self canDeleteItemAtIndexPath:touchedIndexPath]){
+        return NO;
+    }
+
+    CGPoint velocity = [(UIPanGestureRecognizer*)gestureRecognizer velocityInView:self.collectionView];
+    if(velocity.y > 0 || velocity.y < 0){
+        return NO;
+    }
+
+    return YES;
+}
+
+#pragma mark - Pan Action
+
+- (IBAction)panWithGesture:(UIPanGestureRecognizer*)pan{
+
+    switch (pan.state) {
+        case UIGestureRecognizerStateBegan:
+        {
+
+            CGPoint attachmentPoint = [pan locationInView:self.collectionView];
+
+            NSIndexPath* touchedIndexPath = [self.collectionView indexPathForItemAtPoint:attachmentPoint];
+            if(!touchedIndexPath){
+                [self cancelTouchesInGestureRecognizer:pan];
+                return;
+            }
+
+            UICollectionViewLayoutAttributes* attributes = [self layoutAttributesForItemAtIndexPath:touchedIndexPath];
+
+            if(!attributes){
+                [self cancelTouchesInGestureRecognizer:pan];
+                return;
+            }
+
+            self.panningIndexPath = touchedIndexPath;
+            [self invalidateLayout];
+
+        }
+            break;
+
+        case UIGestureRecognizerStateChanged:
+        {
+            [self invalidateLayout];
+        }
+            break;
+
+        case UIGestureRecognizerStateEnded:
+        case UIGestureRecognizerStateCancelled:
+        {
+
+            CGPoint translation = [pan translationInView:self.collectionView];
+            CGFloat originalX = [super layoutAttributesForItemAtIndexPath:self.panningIndexPath].frame.origin.x;
+
+            if(translation.x >= (originalX + self.collectionView.bounds.size.width/2)){
+                [self completeDeletionPanAnimation];
+                return;
+            }
+
+            CGPoint velocity = [pan velocityInView:self.collectionView];
+            if(velocity.x > 500){
+                [self completeDeletionPanAnimation];
+                return;
+            }
+
+            [self cancelDeletionPanAnimation];
+
+        }
+            break;
+
+        default:
+            break;
+    }
+}
+
+- (void)cancelTouchesInGestureRecognizer:(UIGestureRecognizer*)gesture{
+    gesture.enabled = NO;
+    gesture.enabled = YES;
+}
+
+- (void)completeDeletionPanAnimation{
+
+    self.deletingIndexPath = self.panningIndexPath;
+    self.panningIndexPath = nil;
+
+    [self.collectionView performBatchUpdates:^{
+
+        UICollectionViewLayoutAttributes* item = [self layoutAttributesForItemAtIndexPath:self.deletingIndexPath];
+        [self resetAttibutesWithPanTranslation:item];
+
+        [self.collectionView deleteItemsAtIndexPaths:@[self.deletingIndexPath]];
+        if([self.delegate respondsToSelector:@selector(stackLayout:deleteItemAtIndexPath:)]){
+            [self.delegate stackLayout:self deleteItemAtIndexPath:self.deletingIndexPath];
+        }
+
+    } completion:^(BOOL finished) {
+
+        self.deletingIndexPath = nil;
+
+    }];
+
+}
+
+- (void)cancelDeletionPanAnimation{
+
+    self.panningIndexPath = nil;
+
+    [self.collectionView performBatchUpdates:^{
+
+        [self invalidateLayout];
+
+    } completion:nil];
+}
+
+
+@end
diff --git a/Wikipedia/UI-V5/UICollectionView+WMFEnumeration.h b/Wikipedia/UI-V5/UICollectionView+WMFEnumeration.h
new file mode 100755
index 00000000000..1a54517ea40
--- /dev/null
+++ b/Wikipedia/UI-V5/UICollectionView+WMFEnumeration.h
@@ -0,0 +1,10 @@
+
+@import UIKit;
+
+@interface UICollectionView (WMFEnumeration)
+
+- (void)wmf_enumerateIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block;
+
+- (void)wmf_enumerateVisibleIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block;
+
+@end
diff --git a/Wikipedia/UI-V5/UICollectionView+WMFEnumeration.m b/Wikipedia/UI-V5/UICollectionView+WMFEnumeration.m
new file mode 100755
index 00000000000..f6d8026638d
--- /dev/null
+++ b/Wikipedia/UI-V5/UICollectionView+WMFEnumeration.m
@@ -0,0 +1,39 @@
+
+#import "UICollectionView+WMFEnumeration.h"
+
+@implementation UICollectionView (WMFEnumeration)
+
+- (void)wmf_enumerateIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block{
+
+    BOOL stop = NO;
+
+    NSInteger sectionCount = [self numberOfSections];
+
+    for (NSInteger section = 0; section < sectionCount; section++) {
+
+        NSInteger rowCount = [self numberOfItemsInSection:section];
+
+        for (NSInteger row = 0; row < rowCount; row++) {
+
+            NSIndexPath* indexPath = [NSIndexPath indexPathForItem:row inSection:section];
+
+            if(block)
+                block(indexPath, &stop);
+
+            if(stop)
+                return;
+        }
+    }
+}
+
+- (void)wmf_enumerateVisibleIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block{
+
+    [self.indexPathsForVisibleItems enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
+
+        if(block)
+            block(obj, stop);
+
+    }];
+}
+
+@end
diff --git a/Wikipedia/UI-V5/WMFAppViewController.m b/Wikipedia/UI-V5/WMFAppViewController.m
index 06dae14766c..558f9322ce9 100644
--- a/Wikipedia/UI-V5/WMFAppViewController.m
+++ b/Wikipedia/UI-V5/WMFAppViewController.m
@@ -1,5 +1,6 @@
 
 #import "WMFAppViewController.h"
+#import "SessionSingleton.h"
 #import "WMFStyleManager.h"
 #import "WMFSearchViewController.h"
 #import "WMFArticleListCollectionViewController.h"
@@ -21,6 +22,7 @@ @interface WMFAppViewController ()
 @property (nonatomic, strong) WMFArticleListCollectionViewController* listViewController;
 @property (nonatomic, strong) WMFSearchViewController* searchViewController;
 
+@property (nonatomic, strong) SessionSingleton* session;
 
 @end
 
@@ -33,19 +35,40 @@ + (WMFAppViewController*)initialAppViewControllerFromDefaultStoryBoard {
 }
 
 - (void)launchAppInWindow:(UIWindow*)window {
+    WMFStyleManager* manager = [WMFStyleManager new];
+    [manager applyStyleToWindow:window];
+    [WMFStyleManager setSharedStyleManager:manager];
+
     [window setRootViewController:self];
     [window makeKeyAndVisible];
 }
 
+- (void)loadMainUI {
+    self.listViewController.userDataStore = [self userDataStore];
+    [self.listViewController setListType:WMFArticleListTypeSaved animated:NO];
+}
+
 - (void)resumeApp {
     //TODO: restore any UI, show Today
 }
 
+#pragma mark - Accessors
+
+- (MWKDataStore*)dataStore {
+    return self.session.dataStore;
+}
+
+- (MWKUserDataStore*)userDataStore {
+    return self.session.userDataStore;
+}
+
 #pragma mark - UIViewController
 
 - (void)viewDidLoad {
     [super viewDidLoad];
 
+    self.session = [SessionSingleton sharedInstance];
+
     [self showSplashView];
 
     [self runDataMigrationIfNeededWithCompletion:^{
@@ -63,6 +86,14 @@ - (void)prepareForSegue:(UIStoryboardSegue*)segue sender:(id)sender {
     }
 }
 
+- (BOOL)shouldAutorotate {
+    return YES;
+}
+
+- (NSUInteger)supportedInterfaceOrientations {
+    return UIInterfaceOrientationMaskAll;
+}
+
 #pragma mark - Splash
 
 - (void)showSplashView {
@@ -74,7 +105,6 @@ - (void)showSplashView {
 - (void)hideSplashViewAnimated:(BOOL)animated {
     NSTimeInterval duration = animated ? 0.3 : 0.0;
 
-
     [UIView animateWithDuration:duration animations:^{
         self.splashView.layer.transform = CATransform3DMakeScale(10.0f, 10.0f, 1.0f);
         self.splashView.alpha = 0.0;
@@ -88,10 +118,6 @@ - (BOOL)isShowingSplashView {
     return self.splashView.hidden == NO;
 }
 
-- (void)loadMainUI {
-    //TODO: Tell embeded VCs to load their data
-}
-
 #pragma mark - Migration
 
 - (void)runDataMigrationIfNeededWithCompletion:(dispatch_block_t)completion {
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
index 5d123b48f75..33f93389d19 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
@@ -1,13 +1,30 @@
-//
-//  WMFArticleListCollectionViewController.h
-//  Wikipedia
-//
-//  Created by Corey Floyd on 6/4/15.
-//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
-//
 
 #import <UIKit/UIKit.h>
 
+typedef NS_ENUM (NSUInteger, WMFArticleListType) {
+    WMFArticleListTypeSaved,
+    WMFArticleListTypeSearch,
+    WMFArticleListTypeHistory
+};
+
 @interface WMFArticleListCollectionViewController : UICollectionViewController
 
+
+@property (nonatomic, assign, readonly) WMFArticleListType listType;
+
+/**
+ *  Set the list type, optionally animating the change
+ *
+ *  @param type     The type of list to display
+ *  @param animated Whether the change should be animated
+ */
+- (void)setListType:(WMFArticleListType)type animated:(BOOL)animated;
+
+/**
+ *  Must be set to display data
+ */
+@property (nonatomic, strong) MWKUserDataStore* userDataStore;
+
+
+
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
index 1ec3e37976f..c59d5a9b15d 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
@@ -1,97 +1,174 @@
-//
-//  WMFArticleListCollectionViewController.m
-//  Wikipedia
-//
-//  Created by Corey Floyd on 6/4/15.
-//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
-//
 
 #import "WMFArticleListCollectionViewController.h"
+#import "MWKUserDataStore.h"
+#import "MWKSavedPageList.h"
 
-@interface WMFArticleListCollectionViewController ()
+#import "WMFArticleViewControllerContainerCell.h"
+#import "WMFArticleViewController.h"
+
+#import "TGLStackedLayout.h"
+
+@interface WMFArticleListCollectionViewController ()<TGLStackedLayoutDelegate>
+
+@property (nonatomic, assign, readwrite) WMFArticleListType listType;
+@property (nonatomic, strong, readonly) TGLStackedLayout* stackedLayout;
 
 @end
 
 @implementation WMFArticleListCollectionViewController
 
-static NSString* const reuseIdentifier = @"Cell";
+#pragma mark - Accessors
+
+- (MWKSavedPageList*)savedPages {
+    return [self.userDataStore savedPageList];
+}
+
+- (TGLStackedLayout*)stackedLayout{
+
+    if([self.collectionView.collectionViewLayout isKindOfClass:[TGLStackedLayout class]]){
+        return (id)self.collectionView.collectionViewLayout;
+    }
+
+    return nil;
+}
+
+#pragma mark - List Type
+
+- (NSString*)titleForListType:(WMFArticleListType)type {
+    //Do not make static so translations are always fresh
+    return @{@(WMFArticleListTypeSaved): MWLocalizedString(@"saved-pages-title", nil)}[@(type)];
+}
+
+- (void)setListType:(WMFArticleListType)type animated:(BOOL)animated {
+    if (self.listType == type) {
+        return;
+    }
+
+    self.listType = type;
+    [self.collectionView reloadData];
+}
+
+#pragma mark - Saved pages / Article Access
+
+- (MWKSavedPageEntry*)savedPageForIndexPath:(NSIndexPath*)indexPath {
+    MWKSavedPageEntry* savedEntry = [self.savedPages entryAtIndex:indexPath.row];
+    return savedEntry;
+}
+
+- (MWKArticle*)articleForIndexPath:(NSIndexPath*)indexPath {
+    MWKSavedPageEntry* savedEntry = [self savedPageForIndexPath:indexPath];
+    return [self.userDataStore.dataStore articleWithTitle:savedEntry.title];
+}
+
+
+#pragma mark - UIViewController
 
 - (void)viewDidLoad {
     [super viewDidLoad];
 
-    // Uncomment the following line to preserve selection between presentations
-    // self.clearsSelectionOnViewWillAppear = NO;
+    self.title = [self titleForListType:self.listType];
+    self.stackedLayout.fillHeight = YES;
+    self.stackedLayout.alwaysBounce = YES;
+    self.stackedLayout.delegate = self;
+}
 
-    // Register cell classes
-    [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:reuseIdentifier];
+- (void)viewWillAppear:(BOOL)animated {
+    [super viewWillAppear:animated];
+}
 
-    // Do any additional setup after loading the view.
+- (void)viewDidAppear:(BOOL)animated {
+    [super viewDidAppear:animated];
+    self.stackedLayout.itemSize = CGSizeMake(self.view.bounds.size.width, 200);
 }
 
-- (void)didReceiveMemoryWarning {
-    [super didReceiveMemoryWarning];
-    // Dispose of any resources that can be recreated.
+- (void)viewDidLayoutSubviews {
+    [super viewDidLayoutSubviews];
 }
 
-/*
-   #pragma mark - Navigation
+- (BOOL)shouldAutorotate {
+    return YES;
+}
 
-   // In a storyboard-based application, you will often want to do a little preparation before navigation
-   - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
-    // Get the new view controller using [segue destinationViewController].
-    // Pass the selected object to the new view controller.
-   }
- */
+- (NSUInteger)supportedInterfaceOrientations {
+    return UIInterfaceOrientationMaskAll;
+}
 
-#pragma mark <UICollectionViewDataSource>
+// iOS 7 Rotation Support
+- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration {
+    [UIView animateWithDuration:duration animations:^{
+        self.stackedLayout.itemSize = CGSizeMake(self.view.bounds.size.width, 200);
+    }];
 
-- (NSInteger)numberOfSectionsInCollectionView:(UICollectionView*)collectionView {
-#warning Incomplete method implementation -- Return the number of sections
-    return 0;
+    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];
 }
 
+// iOS 8+ Rotation Support
+- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator {
+
+    [coordinator animateAlongsideTransition:^(id <UIViewControllerTransitionCoordinatorContext> context)
+    {
+        self.stackedLayout.itemSize = CGSizeMake(self.view.bounds.size.width, 200);
+    }                            completion:NULL];
+
+    [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];
+}
+
+#pragma mark - <UICollectionViewDataSource>
+
 - (NSInteger)collectionView:(UICollectionView*)collectionView numberOfItemsInSection:(NSInteger)section {
-#warning Incomplete method implementation -- Return the number of items in the section
-    return 0;
+    return [[self savedPages] length];
 }
 
 - (UICollectionViewCell*)collectionView:(UICollectionView*)collectionView cellForItemAtIndexPath:(NSIndexPath*)indexPath {
-    UICollectionViewCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:reuseIdentifier forIndexPath:indexPath];
+    WMFArticleViewControllerContainerCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:NSStringFromClass([WMFArticleViewControllerContainerCell class]) forIndexPath:indexPath];
+
+    if (cell.viewController == nil) {
+        [cell setViewControllerAndAddViewToContentView:[[WMFArticleViewController alloc] init]];
+    }
+
+    [self addChildViewController:cell.viewController];
 
-    // Configure the cell
+    MWKArticle* article = [self articleForIndexPath:indexPath];
+    cell.viewController.article = article;
 
     return cell;
 }
 
-#pragma mark <UICollectionViewDelegate>
+#pragma mark - <UICollectionViewDelegate>
 
-/*
-   // Uncomment this method to specify if the specified item should be highlighted during tracking
-   - (BOOL)collectionView:(UICollectionView *)collectionView shouldHighlightItemAtIndexPath:(NSIndexPath *)indexPath {
-        return YES;
-   }
- */
+- (void)collectionView:(UICollectionView*)collectionView willDisplayCell:(UICollectionViewCell*)cell forItemAtIndexPath:(NSIndexPath*)indexPath {
+    WMFArticleViewControllerContainerCell* containerCell = (id)cell;
+    [containerCell.viewController didMoveToParentViewController:self];
+}
+
+- (void)collectionView:(UICollectionView*)collectionView didEndDisplayingCell:(UICollectionViewCell*)cell forItemAtIndexPath:(NSIndexPath*)indexPath {
+    WMFArticleViewControllerContainerCell* containerCell = (id)cell;
+    [containerCell.viewController willMoveToParentViewController:nil];
+    [containerCell.viewController removeFromParentViewController];
+}
+
+#pragma mark - TGLStackedLayoutDelegate
+
+- (BOOL)stackLayout:(TGLStackedLayout*)layout canMoveItemAtIndexPath:(NSIndexPath*)indexPath{
+
+    return NO;
+}
+
+- (BOOL)stackLayout:(TGLStackedLayout*)layout canDeleteItemAtIndexPath:(NSIndexPath*)indexPath{
 
-/*
-   // Uncomment this method to specify if the specified item should be selected
-   - (BOOL)collectionView:(UICollectionView *)collectionView shouldSelectItemAtIndexPath:(NSIndexPath *)indexPath {
     return YES;
-   }
- */
+}
 
-/*
-   // Uncomment these methods to specify if an action menu should be displayed for the specified item, and react to actions performed on the item
-   - (BOOL)collectionView:(UICollectionView *)collectionView shouldShowMenuForItemAtIndexPath:(NSIndexPath *)indexPath {
-        return NO;
-   }
+- (void)stackLayout:(TGLStackedLayout*)layout deleteItemAtIndexPath:(NSIndexPath*)indexPath{
 
-   - (BOOL)collectionView:(UICollectionView *)collectionView canPerformAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender {
-        return NO;
-   }
+    MWKSavedPageEntry* savedEntry = [self savedPageForIndexPath:indexPath];
+    if (savedEntry) {
+        [self.savedPages removeEntry:savedEntry];
+        [self.userDataStore save];
+
+    }
+}
 
-   - (void)collectionView:(UICollectionView *)collectionView performAction:(SEL)action forItemAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender {
 
-   }
- */
 
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.h b/Wikipedia/UI-V5/WMFArticleViewController.h
index feef54cac2c..eca0f778d8c 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.h
+++ b/Wikipedia/UI-V5/WMFArticleViewController.h
@@ -1,13 +1,8 @@
-//
-//  WMFArticleViewController.h
-//  Wikipedia
-//
-//  Created by Corey Floyd on 6/4/15.
-//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
-//
 
 #import <UIKit/UIKit.h>
 
 @interface WMFArticleViewController : UIViewController
 
+@property (nonatomic, strong) MWKArticle* article;
+
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.m b/Wikipedia/UI-V5/WMFArticleViewController.m
index 2ec3f625db0..ead6501bb15 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleViewController.m
@@ -10,28 +10,35 @@
 
 @interface WMFArticleViewController ()
 
+@property (strong, nonatomic) IBOutlet UILabel* titleLabel;
+
 @end
 
 @implementation WMFArticleViewController
 
+#pragma mark - Accessors
+
+- (void)setArticle:(MWKArticle*)article {
+    if ([_article isEqual:article]) {
+        return;
+    }
+
+    _article = article;
+
+    [self updateUIAnimated:NO];
+}
+
+#pragma mark UIViewController
+
 - (void)viewDidLoad {
     [super viewDidLoad];
     // Do any additional setup after loading the view.
 }
 
-- (void)didReceiveMemoryWarning {
-    [super didReceiveMemoryWarning];
-    // Dispose of any resources that can be recreated.
-}
+#pragma mark UI Updates
 
-/*
-   #pragma mark - Navigation
-
-   // In a storyboard-based application, you will often want to do a little preparation before navigation
-   - (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {
-    // Get the new view controller using [segue destinationViewController].
-    // Pass the selected object to the new view controller.
-   }
- */
+- (void)updateUIAnimated:(BOOL)animated {
+    self.titleLabel.text = self.article.title.text;
+}
 
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.xib b/Wikipedia/UI-V5/WMFArticleViewController.xib
index 97b2b216edc..5605b08981e 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.xib
+++ b/Wikipedia/UI-V5/WMFArticleViewController.xib
@@ -1,16 +1,44 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<document type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="3.0" toolsVersion="7706" systemVersion="14D136" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES">
+<document type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="3.0" toolsVersion="7706" systemVersion="15A178w" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES">
     <dependencies>
         <deployment identifier="iOS"/>
         <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="7703"/>
     </dependencies>
     <objects>
-        <placeholder placeholderIdentifier="IBFilesOwner" id="-1" userLabel="File's Owner"/>
+        <placeholder placeholderIdentifier="IBFilesOwner" id="-1" userLabel="File's Owner" customClass="WMFArticleViewController">
+            <connections>
+                <outlet property="titleLabel" destination="axv-7a-pls" id="yIM-GB-F81"/>
+                <outlet property="view" destination="iN0-l3-epB" id="Idy-V2-3Ra"/>
+            </connections>
+        </placeholder>
         <placeholder placeholderIdentifier="IBFirstResponder" id="-2" customClass="UIResponder"/>
         <view contentMode="scaleToFill" id="iN0-l3-epB">
             <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
             <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
+            <subviews>
+                <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="2dt-yS-wEZ">
+                    <rect key="frame" x="2" y="2" width="596" height="596"/>
+                    <animations/>
+                    <color key="backgroundColor" red="0.91030293703079224" green="0.12721729278564453" blue="0.28739702701568604" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
+                </view>
+                <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="Title" lineBreakMode="tailTruncation" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="axv-7a-pls">
+                    <rect key="frame" x="283" y="20" width="33" height="21"/>
+                    <animations/>
+                    <fontDescription key="fontDescription" type="system" pointSize="17"/>
+                    <color key="textColor" cocoaTouchSystemColor="darkTextColor"/>
+                    <nil key="highlightedColor"/>
+                </label>
+            </subviews>
+            <animations/>
             <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
+            <constraints>
+                <constraint firstAttribute="trailing" secondItem="2dt-yS-wEZ" secondAttribute="trailing" constant="2" id="6K1-Za-40h"/>
+                <constraint firstItem="2dt-yS-wEZ" firstAttribute="leading" secondItem="iN0-l3-epB" secondAttribute="leading" constant="2" id="7dE-PP-1SB"/>
+                <constraint firstItem="2dt-yS-wEZ" firstAttribute="top" secondItem="iN0-l3-epB" secondAttribute="top" constant="2" id="B6i-7t-Y9g"/>
+                <constraint firstItem="axv-7a-pls" firstAttribute="top" secondItem="iN0-l3-epB" secondAttribute="top" constant="20" id="aPq-lx-yZk"/>
+                <constraint firstAttribute="bottom" secondItem="2dt-yS-wEZ" secondAttribute="bottom" constant="2" id="lM6-qv-K2F"/>
+                <constraint firstAttribute="centerX" secondItem="axv-7a-pls" secondAttribute="centerX" id="rOH-Sg-WbJ"/>
+            </constraints>
         </view>
     </objects>
 </document>
diff --git a/Wikipedia/UI-V5/WMFArticleViewControllerContainerCell.h b/Wikipedia/UI-V5/WMFArticleViewControllerContainerCell.h
new file mode 100644
index 00000000000..16f0e27eee7
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticleViewControllerContainerCell.h
@@ -0,0 +1,12 @@
+
+#import <UIKit/UIKit.h>
+
+@class WMFArticleViewController;
+
+@interface WMFArticleViewControllerContainerCell : UICollectionViewCell
+
+@property(nonatomic, strong, readonly) WMFArticleViewController* viewController;
+
+- (void)setViewControllerAndAddViewToContentView:(WMFArticleViewController*)viewController;
+
+@end
diff --git a/Wikipedia/UI-V5/WMFArticleViewControllerContainerCell.m b/Wikipedia/UI-V5/WMFArticleViewControllerContainerCell.m
new file mode 100644
index 00000000000..ee2449b612a
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticleViewControllerContainerCell.m
@@ -0,0 +1,27 @@
+
+#import "WMFArticleViewControllerContainerCell.h"
+#import "WMFArticleViewController.h"
+#import <Masonry/Masonry.h>
+
+@interface WMFArticleViewControllerContainerCell ()
+
+@property(nonatomic, strong, readwrite) WMFArticleViewController* viewController;
+
+@end
+
+@implementation WMFArticleViewControllerContainerCell
+
+- (void)prepareForReuse {
+    self.viewController.article = nil;
+}
+
+- (void)setViewControllerAndAddViewToContentView:(WMFArticleViewController*)viewController {
+    self.viewController = viewController;
+    [self.contentView addSubview:viewController.view];
+
+    [viewController.view mas_makeConstraints:^(MASConstraintMaker* make) {
+        make.edges.equalTo(self.contentView);
+    }];
+}
+
+@end
diff --git a/Wikipedia/UI-V5/iPhone_Root.storyboard b/Wikipedia/UI-V5/iPhone_Root.storyboard
index be4362f5590..0437a57e5b6 100644
--- a/Wikipedia/UI-V5/iPhone_Root.storyboard
+++ b/Wikipedia/UI-V5/iPhone_Root.storyboard
@@ -129,27 +129,24 @@
         <scene sceneID="r64-5z-ebS">
             <objects>
                 <collectionViewController id="qVm-oc-aaW" customClass="WMFArticleListCollectionViewController" sceneMemberID="viewController">
-                    <collectionView key="view" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" dataMode="prototypes" id="cbI-aA-luO">
+                    <collectionView key="view" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" alwaysBounceVertical="YES" dataMode="prototypes" id="cbI-aA-luO">
                         <rect key="frame" x="0.0" y="0.0" width="600" height="536"/>
                         <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                         <animations/>
-                        <collectionViewFlowLayout key="collectionViewLayout" minimumLineSpacing="10" minimumInteritemSpacing="10" id="UBo-wc-8zo">
-                            <size key="itemSize" width="50" height="50"/>
-                            <size key="headerReferenceSize" width="0.0" height="0.0"/>
-                            <size key="footerReferenceSize" width="0.0" height="0.0"/>
-                            <inset key="sectionInset" minX="0.0" minY="0.0" maxX="0.0" maxY="0.0"/>
-                        </collectionViewFlowLayout>
+                        <collectionViewLayout key="collectionViewLayout" id="OM6-RR-VUO" customClass="TGLStackedLayout"/>
                         <cells>
-                            <collectionViewCell opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" id="sY3-kZ-Xb4">
+                            <collectionViewCell opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" reuseIdentifier="WMFArticleViewControllerContainerCell" id="sY3-kZ-Xb4" customClass="WMFArticleViewControllerContainerCell">
                                 <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
                                 <autoresizingMask key="autoresizingMask"/>
                                 <view key="contentView" opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center">
-                                    <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
+                                    <rect key="frame" x="0.0" y="0.0" width="274" height="241"/>
                                     <autoresizingMask key="autoresizingMask"/>
                                     <animations/>
                                     <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="calibratedWhite"/>
                                 </view>
                                 <animations/>
+                                <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
+                                <size key="customSize" width="274" height="241"/>
                             </collectionViewCell>
                         </cells>
                         <connections>
diff --git a/Wikipedia/Wikipedia-Info.plist b/Wikipedia/Wikipedia-Info.plist
index 0e714ee7e02..9732651a9c0 100644
--- a/Wikipedia/Wikipedia-Info.plist
+++ b/Wikipedia/Wikipedia-Info.plist
@@ -45,6 +45,7 @@
 		<string>UIInterfaceOrientationPortrait</string>
 		<string>UIInterfaceOrientationLandscapeLeft</string>
 		<string>UIInterfaceOrientationLandscapeRight</string>
+		<string>UIInterfaceOrientationPortraitUpsideDown</string>
 	</array>
 	<key>UISupportedInterfaceOrientations~ipad</key>
 	<array>
diff --git a/Wikipedia/Wikipedia-Prefix.pch b/Wikipedia/Wikipedia-Prefix.pch
index 8ebc7346c05..67a0279c048 100644
--- a/Wikipedia/Wikipedia-Prefix.pch
+++ b/Wikipedia/Wikipedia-Prefix.pch
@@ -1,8 +1,3 @@
-//
-//  Prefix header
-//
-//  The contents of this file are implicitly included at the beginning of every source file.
-//
 
 #import <Availability.h>
 
