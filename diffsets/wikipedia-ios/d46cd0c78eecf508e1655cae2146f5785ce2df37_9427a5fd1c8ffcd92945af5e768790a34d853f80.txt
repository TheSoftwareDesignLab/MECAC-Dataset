diff --git a/Wikipedia/Code/MWKSectionList.h b/Wikipedia/Code/MWKSectionList.h
index 73b72bc7aab..479750c6f5a 100644
--- a/Wikipedia/Code/MWKSectionList.h
+++ b/Wikipedia/Code/MWKSectionList.h
@@ -36,7 +36,7 @@ NS_ASSUME_NONNULL_END
 /// @return The first section whose `text` is not empty, or `nil` if all sections (or the receiver) are empty.
 - (nullable MWKSection *)firstNonEmptySection;
 
-- (nullable MWKSection *)sectionWithFragment:(nonnull NSString *)fragment;
+- (nullable MWKSection *)sectionWithAnchor:(nonnull NSString *)anchor;
 
 NS_ASSUME_NONNULL_BEGIN
 - (BOOL)save:(NSError **)outError;
diff --git a/Wikipedia/Code/MWKSectionList.m b/Wikipedia/Code/MWKSectionList.m
index 26badbc55e7..55486af7e2c 100644
--- a/Wikipedia/Code/MWKSectionList.m
+++ b/Wikipedia/Code/MWKSectionList.m
@@ -176,14 +176,14 @@ - (MWKSection *)firstNonEmptySection {
     return nil;
 }
 
-- (MWKSection *)sectionWithFragment:(NSString *)fragment {
-    NSString *lowercaseFragment = [[fragment lowercaseString] precomposedStringWithCanonicalMapping];
-    if (lowercaseFragment == nil) {
-        return nil;
+- (MWKSection *)sectionWithAnchor:(NSString *)anchor {
+    NSString *lowercaseAnchor = [[anchor lowercaseString] precomposedStringWithCanonicalMapping];
+    if (lowercaseAnchor.length == 0) {
+        return self.sections.firstObject;
     }
     for (MWKSection *section in self.sections) {
-        NSString *lowercaseAnchor = [[section.anchor lowercaseString] precomposedStringWithCanonicalMapping];
-        if ([lowercaseAnchor isEqualToString:lowercaseFragment]) {
+        NSString *lowercaseSectionAnchor = [[section.anchor lowercaseString] precomposedStringWithCanonicalMapping];
+        if ([lowercaseSectionAnchor isEqualToString:lowercaseAnchor]) {
             return section;
         }
     }
diff --git a/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift b/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
index 4f61b767e6e..d2bcf7c3917 100644
--- a/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
+++ b/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
@@ -23,8 +23,8 @@ extension WMFArticleViewController : WMFTableOfContentsViewControllerDelegate {
         case .inline:
             if let section = item as? MWKSection {
                 self.currentSection = section
-                self.sectionToRestoreScrollOffset = section
-                self.webViewController.scroll(to: section, animated: true)
+                self.anchorToRestoreScrollOffset = section.anchor
+                self.webViewController.scroll(toAnchor: section.anchor, animated: true)
                 dispatchOnMainQueueAfterDelayInSeconds(1) {
                     self.webViewController.accessibilityCursor(to: section)
                 }
@@ -39,7 +39,7 @@ extension WMFArticleViewController : WMFTableOfContentsViewControllerDelegate {
             if let section = item as? MWKSection {
                 self.currentSection = section
                 // HAX: webview has issues scrolling when browser view is out of bounds, disable animation if needed
-                self.webViewController.scroll(to: section, animated: true)
+                self.webViewController.scroll(toAnchor: section.anchor, animated: true)
                 dismissVCCompletionHandler = {
                     // HAX: This is terrible, but iOS events not under our control would steal our focus if we didn't wait long enough here and due to problems in UIWebView, we cannot work around it either.
                     dispatchOnMainQueueAfterDelayInSeconds(1) {
@@ -60,9 +60,9 @@ extension WMFArticleViewController : WMFTableOfContentsViewControllerDelegate {
     private func scrollToFooterSection(for item: TableOfContentsItem) {
         switch item {
         case is TableOfContentsAboutThisArticleItem:
-            self.webViewController.scroll(toFragment: "pagelib_footer_container_menu", animated: true)
+            self.webViewController.scroll(toAnchor: "pagelib_footer_container_menu", animated: true)
         case is TableOfContentsReadMoreItem:
-            self.webViewController.scroll(toFragment: "pagelib_footer_container_readmore", animated: true)
+            self.webViewController.scroll(toAnchor: "pagelib_footer_container_readmore", animated: true)
         default:
             assertionFailure("Unsupported selection of TOC item \(item)")
             break
diff --git a/Wikipedia/Code/WMFArticleViewController.h b/Wikipedia/Code/WMFArticleViewController.h
index aebc9d292b4..40a94550518 100644
--- a/Wikipedia/Code/WMFArticleViewController.h
+++ b/Wikipedia/Code/WMFArticleViewController.h
@@ -48,7 +48,7 @@ extern NSString *const WMFEditPublishedNotification;
 @property (nonatomic, getter=isUpdateTableOfContentsSectionOnScrollEnabled) BOOL updateTableOfContentsSectionOnScrollEnabled;
 
 @property (nonatomic, strong, nullable) MWKSection *currentSection;               //doesn't actually update the view, only here for access from Swift category
-@property (nonatomic, strong, nullable) MWKSection *sectionToRestoreScrollOffset; //doesn't actually update the view, only here for access from Swift category
+@property (nonatomic, strong, nullable) NSString *anchorToRestoreScrollOffset; //doesn't actually update the view, only here for access from Swift category
 
 @property (nonatomic, getter=isSavingOpenArticleTitleEnabled) BOOL savingOpenArticleTitleEnabled;
 @property (nonatomic, getter=isAddingArticleToHistoryListEnabled) BOOL addingArticleToHistoryListEnabled;
diff --git a/Wikipedia/Code/WMFArticleViewController.m b/Wikipedia/Code/WMFArticleViewController.m
index 169c4619ad0..a0440471201 100644
--- a/Wikipedia/Code/WMFArticleViewController.m
+++ b/Wikipedia/Code/WMFArticleViewController.m
@@ -1051,8 +1051,8 @@ - (void)updateTableOfContentsLayoutAnimated:(BOOL)animated {
             CGFloat previousOffsetPercentage = scrollView.contentOffset.y / scrollView.contentSize.height;
 
             [self layoutForSize:self.view.bounds.size];
-            if (self.sectionToRestoreScrollOffset) {
-                [self.webViewController scrollToSection:self.currentSection animated:NO];
+            if (self.anchorToRestoreScrollOffset) {
+                [self scrollToAnchor:self.anchorToRestoreScrollOffset animated:NO completion:NULL];
             } else {
                 scrollView.contentOffset = CGPointMake(0, previousOffsetPercentage * scrollView.contentSize.height);
             }
@@ -1534,6 +1534,20 @@ - (void)showReadingThemesControlsPopup {
     [self.readingThemesControlsPresenter objCShowReadingThemesControlsPopupOn:self theme:self.theme];
 }
 
+#pragma mark - Scrolling to anchors
+
+- (void)scrollToAnchor:(NSString *)anchor animated:(BOOL)animated completion:(nullable dispatch_block_t)completion {
+    self.updateTableOfContentsSectionOnScrollEnabled = NO;
+    [self.webViewController scrollToAnchor:self.initialFragment
+                                    animated:NO
+                                  completion:^{
+                                     self.updateTableOfContentsSectionOnScrollEnabled = YES;
+        if (completion) {
+            completion();
+        }
+                                  }];
+}
+
 #pragma mark - WMFWebViewControllerDelegate
 
 - (void)webViewController:(WebViewController *)controller
@@ -1570,7 +1584,7 @@ - (void)webViewController:(WebViewController *)controller didLoadArticleContent:
             self.articleContentLoadCompletion = nil;
         }
         if (self.initialFragment) {
-            [self.webViewController scrollToFragment:self.initialFragment
+            [self scrollToAnchor:self.initialFragment
                                             animated:NO
                                           completion:^{
                                               [self showWebView];
@@ -1582,13 +1596,13 @@ - (void)webViewController:(WebViewController *)controller didLoadArticleContent:
     });
 }
 
-- (void)webViewController:(WebViewController *)controller didScrollToSection:(MWKSection *)section {
-    self.visibleSectionAnchor = section.anchor;
-}
-
-- (void)webViewController:(WebViewController *)controller didScrollToFragment:(NSString *)fragment {
-    self.visibleSectionAnchor = fragment;
-    [self updateTOCHighlightIfNecessaryWithScrollView:controller.webView.scrollView force:true];
+- (void)webViewController:(WebViewController *)controller didScrollToAnchor:(NSString *)anchor {
+    self.visibleSectionAnchor = anchor;
+    MWKSection *section = [self.article.sections sectionWithAnchor:anchor];
+    if (!section) {
+        return;
+    }
+    [self selectAndScrollToTableOfContentsItemForSection:section animated:NO];
 }
 
 - (void)webViewController:(WebViewController *)controller didTapEditForSection:(MWKSection *)section {
@@ -1643,7 +1657,7 @@ - (void)updateTOCHighlightIfNecessaryWithScrollView:(UIScrollView *)scrollView f
             return;
         }
     }
-    self.sectionToRestoreScrollOffset = nil;
+    self.anchorToRestoreScrollOffset = nil;
     @weakify(self);
 
     [self.webViewController getCurrentVisibleSectionCompletion:^(MWKSection *_Nullable section, NSError *_Nullable error) {
diff --git a/Wikipedia/Code/WebViewController.h b/Wikipedia/Code/WebViewController.h
index eaa1ce88d0e..49f28f50c3d 100644
--- a/Wikipedia/Code/WebViewController.h
+++ b/Wikipedia/Code/WebViewController.h
@@ -37,16 +37,16 @@ NS_ASSUME_NONNULL_BEGIN
 - (void)setArticle:(MWKArticle *_Nullable)article articleURL:(NSURL *)articleURL;
 
 /**
- *  Scroll to the @c anchor of the given section.
+ *  Scroll to the @c fragment provided
  *
- *  @param section  The section to scroll to.
+ *  @param fragment  The fragment to scroll to.
  *  @param animated Whether or not to animate.
+ *  @param completion called when the scroll completes.
  *
- *  @see scrollToFragment:animated:
  */
-- (void)scrollToSection:(MWKSection *)section animated:(BOOL)animated;
+- (void)scrollToAnchor:(nullable NSString *)anchor animated:(BOOL)animated completion:(nullable dispatch_block_t)completion;
 
-- (void)scrollToFragment:(NSString *)fragment animated:(BOOL)animated completion:(nullable dispatch_block_t)completion;
+- (void)scrollToAnchor:(nullable NSString *)anchor animated:(BOOL)animated;
 
 - (void)accessibilityCursorToSection:(MWKSection *)section;
 
@@ -89,8 +89,7 @@ NS_ASSUME_NONNULL_BEGIN
 - (void)webViewController:(WebViewController *)controller didTapFooterMenuItem:(WMFArticleFooterMenuItem)item payload:(NSArray *)payload;
 - (void)webViewController:(WebViewController *)controller didTapFooterReadMoreSaveForLaterForArticleURL:(NSURL *)url didSave:(BOOL)didSave;
 - (void)webViewController:(WebViewController *)controller didTapAddTitleDescriptionForArticle:(MWKArticle *)article;
-- (void)webViewController:(WebViewController *)controller didScrollToSection:(MWKSection *)section;
-- (void)webViewController:(WebViewController *)controller didScrollToFragment:(NSString *)fragment;
+- (void)webViewController:(WebViewController *)controller didScrollToAnchor:(NSString *)fragment;
 
 @end
 
diff --git a/Wikipedia/Code/WebViewController.m b/Wikipedia/Code/WebViewController.m
index ab4a730b03b..b5e108bdb41 100644
--- a/Wikipedia/Code/WebViewController.m
+++ b/Wikipedia/Code/WebViewController.m
@@ -230,7 +230,7 @@ - (void)handleLinkClickedScriptMessage:(NSDictionary *)messageDict {
                                            } else {
                                                // A standard external link, either explicitly http(s) or left protocol-relative on web meaning http(s)
                                                if ([href hasPrefix:@"#"]) {
-                                                   [self scrollToFragment:[href substringFromIndex:1]];
+                                                   [self scrollToAnchor:[href substringFromIndex:1] animated:YES];
                                                } else {
                                                    if ([href hasPrefix:@"//"]) {
                                                        // Expand protocol-relative link to https -- secure by default!
@@ -785,19 +785,19 @@ - (CGFloat)headerHeightForCurrentArticle {
 
 #pragma mark - Scrolling
 
-- (void)scrollToFragment:(NSString *)fragment {
-    [self scrollToFragment:fragment animated:YES completion:NULL];
+- (void)scrollToAnchor:(NSString *)anchor animated:(BOOL)animated {
+    [self scrollToAnchor:anchor animated:animated completion:NULL];
 }
 
-- (void)scrollToFragment:(NSString *)fragment animated:(BOOL)animated completion:(nullable dispatch_block_t)completion {
-    if (fragment.length == 0) {
+- (void)scrollToAnchor:(NSString *)anchor animated:(BOOL)animated completion:(nullable dispatch_block_t)completion {
+    if (anchor.length == 0) {
         // No section so scroll to top. (Used when "Introduction" is selected.)
         [self.webView.scrollView scrollRectToVisible:CGRectMake(0, 1, 1, 1) animated:animated];
         if (completion) {
             completion();
         }
     } else {
-        [self.webView getScrollViewRectForHtmlElementWithId:fragment
+        [self.webView getScrollViewRectForHtmlElementWithId:anchor
                                                  completion:^(CGRect rect) {
                                                      if (!CGRectIsNull(rect)) {
                                                          [self scrollToOffset:CGPointMake(self.webView.scrollView.contentOffset.x, rect.origin.y + [self.webView iOS12yOffsetHack] + self.delegate.navigationBar.hiddenHeight)
@@ -806,9 +806,7 @@ - (void)scrollToFragment:(NSString *)fragment animated:(BOOL)animated completion
                                                                        if (completion) {
                                                                            completion();
                                                                        }
-                                                                       dispatchOnMainQueueAfterDelayInSeconds(0.1, ^{
-                                                                           [self.delegate webViewController:self didScrollToFragment:fragment];
-                                                                       });
+                                                                        [self.delegate webViewController:self didScrollToAnchor:anchor];
                                                                    }];
                                                      } else if (completion) {
                                                          completion();
@@ -817,11 +815,6 @@ - (void)scrollToFragment:(NSString *)fragment animated:(BOOL)animated completion
     }
 }
 
-- (void)scrollToSection:(MWKSection *)section animated:(BOOL)animated {
-    [self scrollToFragment:section.anchor animated:animated completion:NULL];
-    [self.delegate webViewController:self didScrollToSection:section];
-}
-
 - (void)accessibilityCursorToSection:(MWKSection *)section {
     // This might shift the visual scroll position. To prevent it affecting other users,
     // we will only do it when we detect than an assistive technology which actually needs this is running.
@@ -931,7 +924,7 @@ - (void)refererenceLinkTappedWithNotification:(NSNotification *)notification {
                                            MWLanguageInfo *languageInfo = [MWLanguageInfo languageInfoForCode:domain];
                                            NSString *baseUrl = [NSString stringWithFormat:@"https://%@.wikipedia.org/", languageInfo.code];
                                            if ([URL.absoluteString hasPrefix:[NSString stringWithFormat:@"%@%@", baseUrl, @"#"]]) {
-                                               [self scrollToFragment:URL.fragment];
+                                               [self scrollToAnchor:URL.fragment animated:YES];
                                            } else if ([URL.absoluteString hasPrefix:[NSString stringWithFormat:@"%@%@", baseUrl, @"wiki/"]]) {
 #pragma warning Assuming that the url is on the same language wiki - what about other wikis ?
                                                [self.delegate webViewController:self
