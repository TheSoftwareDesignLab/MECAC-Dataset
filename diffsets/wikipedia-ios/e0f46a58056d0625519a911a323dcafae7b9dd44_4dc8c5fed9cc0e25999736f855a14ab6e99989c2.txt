diff --git a/WMF Framework/WidgetController.swift b/WMF Framework/WidgetController.swift
index 08e3a97df44..cc2d67110cc 100644
--- a/WMF Framework/WidgetController.swift	
+++ b/WMF Framework/WidgetController.swift	
@@ -6,7 +6,8 @@ public final class WidgetController {
     // MARK: Nested Types
 
     public enum SupportedWidget: String {
-        case pictureOfTheDay = "org.wikipedia.widgets.potd"
+        case pictureOfTheDay = "org.wikimedia.wikipedia.widgets.potd"
+        case topRead = "org.wikimedia.wikipedia.widgets.topRead"
 
         public var identifier: String {
             return self.rawValue
diff --git a/Widgets/Extension/Widgets.swift b/Widgets/Extension/Widgets.swift
index 683d3bf8b32..b0e4cb3876b 100644
--- a/Widgets/Extension/Widgets.swift
+++ b/Widgets/Extension/Widgets.swift
@@ -7,7 +7,7 @@ struct WikipediaWidgets: WidgetBundle {
 	@WidgetBundleBuilder
 	var body: some Widget {
 		PictureOfTheDayWidget()
-		// We can support more widgets just by adding them here
+        TopReadWidget()
 	}
 
 }
diff --git a/Widgets/Utilities/CGPoint+Extensions.swift b/Widgets/Utilities/CGPoint+Extensions.swift
new file mode 100644
index 00000000000..6aa76c887d2
--- /dev/null
+++ b/Widgets/Utilities/CGPoint+Extensions.swift
@@ -0,0 +1,17 @@
+import CoreGraphics
+
+/// Adapted from WMFSparklineView.swift
+extension CGPoint {
+    
+    static func midPointFrom(_ fromPoint: CGPoint, to toPoint: CGPoint) -> CGPoint {
+        return CGPoint(x: 0.5*(fromPoint.x + toPoint.x), y: 0.5*(fromPoint.y + toPoint.y))
+    }
+    
+    static func quadCurveControlPointFrom(_ fromPoint: CGPoint, to toPoint: CGPoint) -> CGPoint {
+        var controlPoint = midPointFrom(fromPoint, to: toPoint)
+        let deltaY = toPoint.y - controlPoint.y
+        controlPoint.y += deltaY
+        return controlPoint
+    }
+    
+}
diff --git a/Widgets/Utilities/UIColor+Extensions.swift b/Widgets/Utilities/UIColor+Extensions.swift
new file mode 100644
index 00000000000..7a38000ed3b
--- /dev/null
+++ b/Widgets/Utilities/UIColor+Extensions.swift
@@ -0,0 +1,9 @@
+import SwiftUI
+
+extension UIColor {
+
+	var asColor: Color {
+		return Color(self)
+	}
+
+}
diff --git a/Widgets/Utilities/View+Extensions.swift b/Widgets/Utilities/View+Extensions.swift
index 325bd528bea..0af4f5f17c2 100644
--- a/Widgets/Utilities/View+Extensions.swift
+++ b/Widgets/Utilities/View+Extensions.swift
@@ -2,8 +2,8 @@ import SwiftUI
 
 extension View {
 
-	func readableShadow() -> some View {
-		return self.shadow(color: Color.black.opacity(0.80), radius: 5, x:0, y: 0)
-	}
+    func readableShadow(intensity: Double = 0.80) -> some View {
+        return self.shadow(color: Color.black.opacity(intensity), radius: 5, x:0, y: 0)
+    }
 
 }
diff --git a/Widgets/Views/Sparkline.swift b/Widgets/Views/Sparkline.swift
new file mode 100644
index 00000000000..8ff09e16e58
--- /dev/null
+++ b/Widgets/Views/Sparkline.swift
@@ -0,0 +1,153 @@
+import SwiftUI
+import WMF
+
+private struct SparklineShape: Shape {
+
+	// MARK: Private Properties
+
+	private let data: [CGFloat]
+
+	// MARK: Public
+
+	init(data: [NSNumber]?) {
+		self.data = data?.compactMap { CGFloat($0.doubleValue) } ?? []
+	}
+
+	// MARK: Shape
+
+    func path(in rect: CGRect) -> Path {
+        var path = Path()
+        
+        guard data.count > 1, let min = data.min(), let max = data.max() else {
+            return path
+        }
+
+        guard min != max else {
+            path.move(to: CGPoint(x: rect.minX, y: rect.midY))
+            path.addLine(to: CGPoint(x: rect.maxX, y: rect.midY))
+            return path
+        }
+                        
+        let minY = rect.minY
+        let width = rect.width / CGFloat(data.count - 1)
+        let height = rect.maxY - rect.minY
+        
+        var points: [CGPoint] = []
+        
+        for (index, dataPoint) in data.enumerated() {
+            let relativeY = dataPoint - CGFloat(min)
+            let normalizedY = 1 - relativeY/(CGFloat(max-min))
+            let y = minY + height * normalizedY
+            let x = width * CGFloat(index)
+            points.append(CGPoint(x: x, y: y))
+        }
+        
+        path.move(to: points[0])
+        for (index, point) in points[1...points.count-1].enumerated() {
+            let fromPoint = points[index]
+            let midPoint = CGPoint.midPointFrom(fromPoint, to: point)
+            let midPointControlPoint = CGPoint.quadCurveControlPointFrom(midPoint, to: fromPoint)
+            path.addQuadCurve(to: midPoint, control: midPointControlPoint)
+            let toPointControlPoint = CGPoint.quadCurveControlPointFrom(midPoint, to: point)
+            path.addQuadCurve(to: point, control: toPointControlPoint)
+        }
+    
+        return path
+    }
+    
+}
+
+struct SparklineGrid: View {
+	@Environment(\.colorScheme) private var colorScheme
+
+	// MARK: Properties
+
+	var gridStyle: Sparkline.GridStyle
+
+	// MARK: View
+
+	var body: some View {
+		// TODO
+		Rectangle()
+	}
+}
+
+struct Sparkline: View {
+    @Environment(\.colorScheme) private var colorScheme
+
+	// MARK: Nested Types
+
+	enum Style {
+		case compact
+        case compactWithViewCount
+		case expanded
+	}
+    
+    enum GridStyle {
+        case horizontal
+        case horizontalAndVertical
+    }
+
+	// MARK: Properties
+
+	var style: Style = .compact
+    var gridStyle: GridStyle = .horizontal
+    var lineWidth: CGFloat = 1.5
+    
+	var timeSeries: [NSNumber]? = []
+	var containerBackgroundColor: Color = Color.white
+    
+    var gradientStartColor: Color {
+        colorScheme == .light
+            ? Theme.light.colors.rankGradientStart.asColor
+            : Theme.dark.colors.rankGradientStart.asColor
+    }
+
+    var gradientEndColor: Color {
+        colorScheme == .light
+            ? Theme.light.colors.rankGradientEnd.asColor
+            : Theme.dark.colors.rankGradientEnd.asColor
+    }
+
+	// MARK: View
+
+	var body: some View {
+		if style == .compact || style == .compactWithViewCount {
+			HStack {
+				Spacer().frame(width: 4)
+				SparklineShape(data: timeSeries)
+					.stroke(
+						LinearGradient(gradient: Gradient(colors: [gradientStartColor, gradientEndColor]), startPoint: /*@START_MENU_TOKEN@*/.leading/*@END_MENU_TOKEN@*/, endPoint: /*@START_MENU_TOKEN@*/.trailing/*@END_MENU_TOKEN@*/), style: StrokeStyle(lineWidth: lineWidth, lineCap: .round, lineJoin: .round))
+					.frame(width: 30, alignment: .leading)
+					.padding([.top, .bottom], 3)
+					// TODO
+					// .background(SparklineGrid(gridStyle: gridStyle).frame(height: proxy.size.height / 2))
+				if style == .compactWithViewCount {
+					Text("\(currentViewCountOrEmpty)")
+						.font(.system(size: 12))
+						.fontWeight(.medium)
+						.foregroundColor(Theme.light.colors.rankGradientEnd.asColor)
+					}
+					Spacer().frame(width: 4)
+			}
+			.background(containerBackgroundColor)
+		} else {
+			ZStack {
+				Rectangle()
+				Rectangle().inset(by: 5).fill(Color.secondary)
+			}
+			.background(containerBackgroundColor)
+		}
+	}
+
+	// MARK: Private
+
+	private var currentViewCountOrEmpty: String {
+		guard let currentViewCount = timeSeries?.last else {
+			return "–"
+		}
+
+		return NumberFormatter.localizedThousandsStringFromNumber(currentViewCount)
+	}
+
+}
diff --git a/Widgets/Widgets/TopReadWidget+LocalizedStrings.swift b/Widgets/Widgets/TopReadWidget+LocalizedStrings.swift
new file mode 100644
index 00000000000..786802bec17
--- /dev/null
+++ b/Widgets/Widgets/TopReadWidget+LocalizedStrings.swift
@@ -0,0 +1,11 @@
+import Foundation
+import WMF
+
+extension TopReadWidget {
+
+	enum LocalizedStrings {
+		static let topReadWidgetTitle = WMFLocalizedString("top-read-widget-title", value:"Top read", comment: "Text for title of Top read widget.")
+		static let topReadWidgetDescription = WMFLocalizedString("top-read-widget-description", value:"Learn what the world is reading today on Wikipedia", comment: "Text for description of top read widget displayed when adding to home screen.")
+	}
+
+}
diff --git a/Widgets/Widgets/TopReadWidget.swift b/Widgets/Widgets/TopReadWidget.swift
new file mode 100644
index 00000000000..11573068df4
--- /dev/null
+++ b/Widgets/Widgets/TopReadWidget.swift
@@ -0,0 +1,334 @@
+import SwiftUI
+import WidgetKit
+import WMF
+
+// MARK: - Widget
+
+struct TopReadWidget: Widget {
+	private let kind: String = WidgetController.SupportedWidget.topRead.identifier
+
+	public var body: some WidgetConfiguration {
+		StaticConfiguration(kind: kind, provider: TopReadProvider(), content: { entry in
+			TopReadView(entry: entry)
+		})
+		.configurationDisplayName(LocalizedStrings.topReadWidgetTitle)
+		.description(LocalizedStrings.topReadWidgetDescription)
+		.supportedFamilies([.systemSmall, .systemMedium, .systemLarge])
+	}
+}
+
+// MARK: - Data
+
+final class TopReadData {
+
+	// MARK: Properties
+
+	static let shared = TopReadData()
+
+	let maximumRankedArticles = 4
+
+	var placeholder: TopReadEntry {
+		return TopReadEntry(date: Date())
+	}
+
+	// MARK: Public
+
+	private var dataStore: MWKDataStore {
+		MWKDataStore.shared()
+	}
+
+	func fetchLatestAvailableTopRead(_ completion: @escaping (TopReadEntry) -> Void) {
+		guard
+			let appLanguage = dataStore.languageLinkController.appLanguage,
+			let topRead = dataStore.viewContext.group(of: .topRead, for: Date(), siteURL: appLanguage.siteURL()),
+			let results = topRead.contentPreview as? [WMFFeedTopReadArticlePreview] else {
+				completion(placeholder)
+				return
+		}
+
+		var rankedElements: [TopReadEntry.RankedElement] = []
+
+		for article in results {
+			if let articlePreview = self.dataStore.fetchArticle(with: article.articleURL) {
+				if let viewCounts = articlePreview.pageViewsSortedByDate {
+					rankedElements.append(.init(title: article.displayTitle, description: article.wikidataDescription ?? article.snippet ?? "", articleURL: article.articleURL, thumbnailURL: article.thumbnailURL, viewCounts: viewCounts))
+				}
+			}
+		}
+
+		rankedElements = Array(rankedElements.prefix(maximumRankedArticles))
+
+		let group = DispatchGroup()
+
+		for (index, element) in rankedElements.enumerated() {
+			group.enter()
+			guard let thumbnailURL = element.thumbnailURL, let fetcher = ImageCacheController.shared else {
+				group.leave()
+				return
+			}
+
+			fetcher.fetchImage(withURL: thumbnailURL, failure: { _ in
+				group.leave()
+			}, success: { fetchedImage in
+				rankedElements[index].image = fetchedImage.image.staticImage
+				group.leave()
+			})
+		}
+
+		group.notify(queue: .main) {
+			completion(TopReadEntry(date: Date(), rankedElements: rankedElements))
+		}
+	}
+
+}
+
+// MARK: - Model
+
+struct TopReadEntry: TimelineEntry {
+	struct RankedElement: Identifiable {
+		var id: String = UUID().uuidString
+
+		let title: String
+		let description: String
+		var articleURL: URL? = nil
+		var image: UIImage? = nil
+		var thumbnailURL: URL? = nil
+		let viewCounts: [NSNumber]
+	}
+
+	let date: Date // for Timeline Entry
+	var rankedElements: [RankedElement] = Array(repeating: RankedElement.init(title: "–", description: "–", image: nil, viewCounts: [.init(floatLiteral: 0)]), count: 4)
+}
+
+// MARK: - TimelineProvider
+
+struct TopReadProvider: TimelineProvider {
+
+	// MARK: Nested Types
+
+	public typealias Entry = TopReadEntry
+
+	// MARK: Properties
+
+	private let dataStore = TopReadData.shared
+
+	// MARK: TimelineProvider
+
+	func placeholder(in: Context) -> TopReadEntry {
+		return dataStore.placeholder
+	}
+
+	func getTimeline(in context: Context, completion: @escaping (Timeline<TopReadEntry>) -> Void) {
+		dataStore.fetchLatestAvailableTopRead { entry in
+			let timeline = Timeline(entries: [entry], policy: .atEnd)
+			completion(timeline)
+		}
+	}
+
+	func getSnapshot(in context: Context, completion: @escaping (TopReadEntry) -> Void) {
+		// TODO: Support context.isPreview
+		dataStore.fetchLatestAvailableTopRead { entry in
+			completion(entry)
+		}
+	}
+
+}
+
+// MARK: - Views
+
+struct TopReadView: View {
+	@Environment(\.widgetFamily) private var family
+	@Environment(\.colorScheme) private var colorScheme
+
+	var entry: TopReadProvider.Entry?
+
+	@ViewBuilder
+	var body: some View {
+		GeometryReader { proxy in
+			switch family {
+			case .systemMedium:
+				rowBasedWidget(.systemMedium)
+			case .systemLarge:
+				rowBasedWidget(.systemLarge)
+			default:
+				smallWidget
+					.frame(width: proxy.size.width, height: proxy.size.height, alignment: .center)
+					.overlay(TopReadOverlayView(rankedElement: entry?.rankedElements.first))
+					.widgetURL(entry?.rankedElements.first?.articleURL)
+			}
+		}
+	}
+
+	// MARK: View Components
+
+	@ViewBuilder
+	var smallWidget: some View {
+		if let image = entry?.rankedElements.first?.image {
+			Image(uiImage: image).resizable().scaledToFill()
+		} else {
+			Rectangle().foregroundColor(Color(.systemFill)).scaledToFill()
+		}
+	}
+
+	@ViewBuilder
+	func rowBasedWidget(_ family: WidgetFamily) -> some View {
+		let showSparkline = family == .systemLarge ? true : false
+		let rowCount = family == .systemLarge ? 4 : 2
+
+		VStack(alignment: .leading, spacing: 8) {
+			Text(TopReadWidget.LocalizedStrings.topReadWidgetTitle)
+				.font(.headline)
+			ForEach(entry?.rankedElements.indices.prefix(rowCount) ?? 0..<0) { elementIndex in
+				if let articleURL = entry?.rankedElements[elementIndex].articleURL {
+					Link(destination: articleURL, label: {
+						elementRow(elementIndex, rowCount: rowCount, showSparkline: showSparkline)
+					})
+				} else {
+					elementRow(elementIndex, rowCount: rowCount, showSparkline: showSparkline)
+				}
+			}
+		}
+		.padding(16)
+	}
+
+	@ViewBuilder
+	func elementRow(_ index: Int, rowCount: Int, showSparkline: Bool = false) -> some View {
+		let rankColor = colorScheme == .light ? Theme.light.colors.rankGradient.color(at: CGFloat(index)/CGFloat(rowCount)).asColor : Theme.dark.colors.rankGradient.color(at: CGFloat(index)/CGFloat(rowCount)).asColor
+		GeometryReader { proxy in
+			HStack(alignment: .center) {
+				Circle()
+					.strokeBorder(rankColor, lineWidth: 1)
+					.frame(width: 22, height: 22, alignment: .leading)
+					.overlay(
+						Text("\(NumberFormatter.localizedThousandsStringFromNumber(NSNumber(value: index + 1)))")
+							.font(.footnote)
+							.fontWeight(.light)
+							.foregroundColor(rankColor)
+					)
+					.padding(EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 7))
+				VStack(alignment: .leading, spacing: 5) {
+					Text("\(entry?.rankedElements[index].title ?? "–")")
+						.font(.caption)
+						.bold()
+						.foregroundColor(Color(.label))
+					Text("\(entry?.rankedElements[index].description ?? "–")")
+						.lineLimit(2)
+						.font(.caption)
+						.foregroundColor(Color(.secondaryLabel))
+					if showSparkline {
+						Sparkline(style: .compactWithViewCount, timeSeries: entry?.rankedElements[index].viewCounts, containerBackgroundColor: UIColor.gray.withAlphaComponent(0.05).asColor)
+							.cornerRadius(4)
+							.frame(height: proxy.size.height / 3.0, alignment: .leading)
+					}
+				}
+				Spacer()
+				elementImageOrPlaceholder(index)
+					.frame(width: proxy.size.height / 1.1, height: proxy.size.height / 1.1, alignment: .trailing)
+					.mask(
+						RoundedRectangle(cornerRadius: 5, style: .continuous)
+					)
+			}
+		}
+	}
+
+	@ViewBuilder
+	func elementImageOrPlaceholder(_ elementIndex: Int) -> some View {
+		if let image = entry?.rankedElements[elementIndex].image {
+			Image(uiImage: image)
+				.resizable()
+				.aspectRatio(contentMode: .fill)
+		} else {
+			Rectangle().fill(Color.gray)
+		}
+	}
+}
+
+struct TopReadOverlayView: View {
+	@Environment(\.colorScheme) var colorScheme
+
+	var rankedElement: TopReadEntry.RankedElement?
+
+	var isExpandedStyle: Bool {
+		return rankedElement?.image == nil
+	}
+
+	var readersForegroundColor: Color {
+		colorScheme == .light
+			? Theme.light.colors.rankGradientEnd.asColor
+			: Theme.dark.colors.rankGradientEnd.asColor
+	}
+
+	private var currentViewCountOrEmpty: String {
+		guard let currentViewCount = rankedElement?.viewCounts.last else {
+			return "–"
+		}
+
+		return NumberFormatter.localizedThousandsStringFromNumber(currentViewCount)
+	}
+
+	var body: some View {
+		if isExpandedStyle {
+			content
+		} else {
+			content
+				.background(
+					Rectangle()
+						.foregroundColor(.black)
+						.mask(LinearGradient(gradient: Gradient(colors: [.clear, .black]), startPoint: .center, endPoint: .bottom))
+						.opacity(0.35)
+				)
+		}
+	}
+
+	// MARK: View Components
+
+	var content: some View {
+		VStack(alignment: .leading) {
+			sparkline(expanded: isExpandedStyle)
+			Spacer()
+			description(includeReaderCount: isExpandedStyle)
+		}
+		.foregroundColor(.white)
+	}
+
+	func sparkline(expanded: Bool) -> some View {
+		HStack(alignment: .top) {
+			Spacer()
+			if expanded {
+				Sparkline(style: .expanded, timeSeries: rankedElement?.viewCounts)
+					.padding(EdgeInsets(top: 16, leading: 8, bottom: 0, trailing: 16))
+			} else {
+				Sparkline(style: .compact, timeSeries: rankedElement?.viewCounts)
+					.cornerRadius(4)
+					.frame(height: 20, alignment: .trailing)
+					.padding(EdgeInsets(top: 16, leading: 0, bottom: 0, trailing: 16))
+					// TODO: Apply shadow just to final content – not children views as well
+					// .clipped()
+					// .readableShadow(intensity: 0.60)
+			}
+		}
+	}
+
+	func description(includeReaderCount: Bool = false) -> some View {
+		VStack(alignment: .leading, spacing: 5) {
+			Text(TopReadWidget.LocalizedStrings.topReadWidgetTitle)
+				.font(.caption2)
+				.fontWeight(.heavy)
+				.aspectRatio(contentMode: .fit)
+				.readableShadow()
+			Text("\(rankedElement?.title ?? "–")")
+				.lineLimit(nil)
+				.font(.headline)
+				.readableShadow()
+			if includeReaderCount {
+				// TODO: Localize
+				Text("\(currentViewCountOrEmpty) Readers")
+					.lineLimit(nil)
+					.font(.caption)
+					.foregroundColor(readersForegroundColor)
+					.readableShadow()
+			}
+		}
+		.padding(EdgeInsets(top: 0, leading: 16, bottom: 16, trailing: 16))
+	}
+}
diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index 06aa2a817a9..22f864976b5 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -13,6 +13,11 @@
 		00021DEA24D48EFE00476F97 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 00021DE924D48EFE00476F97 /* Assets.xcassets */; };
 		00021DEE24D48EFE00476F97 /* WidgetsExtension.appex in Embed App Extensions */ = {isa = PBXBuildFile; fileRef = 00021DE124D48EFD00476F97 /* WidgetsExtension.appex */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
 		00021E0424D4A42A00476F97 /* PictureOfTheDayWidget.swift in Sources */ = {isa = PBXBuildFile; fileRef = 00021E0324D4A42A00476F97 /* PictureOfTheDayWidget.swift */; };
+		0033D79924F818EC00CAB5B3 /* TopReadWidget+LocalizedStrings.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0033D79724F818EB00CAB5B3 /* TopReadWidget+LocalizedStrings.swift */; };
+		0033D79A24F818EC00CAB5B3 /* TopReadWidget.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0033D79824F818EC00CAB5B3 /* TopReadWidget.swift */; };
+		0033D79D24F8193900CAB5B3 /* UIColor+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0033D79B24F8193900CAB5B3 /* UIColor+Extensions.swift */; };
+		0033D79E24F8193900CAB5B3 /* CGPoint+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0033D79C24F8193900CAB5B3 /* CGPoint+Extensions.swift */; };
+		0033D7A124F8199300CAB5B3 /* Sparkline.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0033D7A024F8199300CAB5B3 /* Sparkline.swift */; };
 		0062597324DE0A2500C95037 /* WidgetController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0062597224DE0A2500C95037 /* WidgetController.swift */; };
 		006D273524D8BAFB00947551 /* View+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 006D273424D8BAFB00947551 /* View+Extensions.swift */; };
 		006D273724D8D8D100947551 /* Date+Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = 006D273624D8D8D100947551 /* Date+Extensions.swift */; };
@@ -3246,6 +3251,11 @@
 		00021DE924D48EFE00476F97 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
 		00021DEB24D48EFE00476F97 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
 		00021E0324D4A42A00476F97 /* PictureOfTheDayWidget.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PictureOfTheDayWidget.swift; sourceTree = "<group>"; usesTabs = 0; };
+		0033D79724F818EB00CAB5B3 /* TopReadWidget+LocalizedStrings.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "TopReadWidget+LocalizedStrings.swift"; sourceTree = "<group>"; };
+		0033D79824F818EC00CAB5B3 /* TopReadWidget.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = TopReadWidget.swift; sourceTree = "<group>"; };
+		0033D79B24F8193900CAB5B3 /* UIColor+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "UIColor+Extensions.swift"; sourceTree = "<group>"; };
+		0033D79C24F8193900CAB5B3 /* CGPoint+Extensions.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "CGPoint+Extensions.swift"; sourceTree = "<group>"; };
+		0033D7A024F8199300CAB5B3 /* Sparkline.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Sparkline.swift; sourceTree = "<group>"; };
 		0062597224DE0A2500C95037 /* WidgetController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WidgetController.swift; sourceTree = "<group>"; usesTabs = 0; };
 		006D273424D8BAFB00947551 /* View+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "View+Extensions.swift"; sourceTree = "<group>"; usesTabs = 0; };
 		006D273624D8D8D100947551 /* Date+Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Date+Extensions.swift"; sourceTree = "<group>"; usesTabs = 0; };
@@ -5003,6 +5013,7 @@
 				00D5593424DB152300C78F08 /* WidgetsExtension.entitlements */,
 				00021DFF24D48F3000476F97 /* Extension */,
 				00021DFE24D48F2200476F97 /* Widgets */,
+				0033D79F24F8197A00CAB5B3 /* Views */,
 				006D273324D8BAE500947551 /* Utilities */,
 				00021DEB24D48EFE00476F97 /* Info.plist */,
 			);
@@ -5013,6 +5024,8 @@
 			isa = PBXGroup;
 			children = (
 				00021E0324D4A42A00476F97 /* PictureOfTheDayWidget.swift */,
+				0033D79824F818EC00CAB5B3 /* TopReadWidget.swift */,
+				0033D79724F818EB00CAB5B3 /* TopReadWidget+LocalizedStrings.swift */,
 			);
 			path = Widgets;
 			sourceTree = "<group>";
@@ -5026,11 +5039,21 @@
 			path = Extension;
 			sourceTree = "<group>";
 		};
+		0033D79F24F8197A00CAB5B3 /* Views */ = {
+			isa = PBXGroup;
+			children = (
+				0033D7A024F8199300CAB5B3 /* Sparkline.swift */,
+			);
+			path = Views;
+			sourceTree = "<group>";
+		};
 		006D273324D8BAE500947551 /* Utilities */ = {
 			isa = PBXGroup;
 			children = (
 				006D273424D8BAFB00947551 /* View+Extensions.swift */,
 				006D273624D8D8D100947551 /* Date+Extensions.swift */,
+				0033D79C24F8193900CAB5B3 /* CGPoint+Extensions.swift */,
+				0033D79B24F8193900CAB5B3 /* UIColor+Extensions.swift */,
 			);
 			path = Utilities;
 			sourceTree = "<group>";
@@ -9851,8 +9874,13 @@
 			buildActionMask = 2147483647;
 			files = (
 				00021DE824D48EFD00476F97 /* Widgets.swift in Sources */,
+				0033D79A24F818EC00CAB5B3 /* TopReadWidget.swift in Sources */,
+				0033D79E24F8193900CAB5B3 /* CGPoint+Extensions.swift in Sources */,
+				0033D79924F818EC00CAB5B3 /* TopReadWidget+LocalizedStrings.swift in Sources */,
 				006D273724D8D8D100947551 /* Date+Extensions.swift in Sources */,
+				0033D79D24F8193900CAB5B3 /* UIColor+Extensions.swift in Sources */,
 				006D273524D8BAFB00947551 /* View+Extensions.swift in Sources */,
+				0033D7A124F8199300CAB5B3 /* Sparkline.swift in Sources */,
 				00021E0424D4A42A00476F97 /* PictureOfTheDayWidget.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
diff --git a/Wikipedia.xcodeproj/xcshareddata/xcschemes/WidgetsExtension.xcscheme b/Wikipedia.xcodeproj/xcshareddata/xcschemes/WidgetsExtension.xcscheme
new file mode 100644
index 00000000000..573e0428486
--- /dev/null
+++ b/Wikipedia.xcodeproj/xcshareddata/xcschemes/WidgetsExtension.xcscheme
@@ -0,0 +1,123 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Scheme
+   LastUpgradeVersion = "1200"
+   wasCreatedForAppExtension = "YES"
+   version = "2.0">
+   <BuildAction
+      parallelizeBuildables = "YES"
+      buildImplicitDependencies = "YES">
+      <BuildActionEntries>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "00021DE024D48EFD00476F97"
+               BuildableName = "WidgetsExtension.appex"
+               BlueprintName = "WidgetsExtension"
+               ReferencedContainer = "container:Wikipedia.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+         <BuildActionEntry
+            buildForTesting = "YES"
+            buildForRunning = "YES"
+            buildForProfiling = "YES"
+            buildForArchiving = "YES"
+            buildForAnalyzing = "YES">
+            <BuildableReference
+               BuildableIdentifier = "primary"
+               BlueprintIdentifier = "D4991434181D51DE00E6073C"
+               BuildableName = "Wikipedia.app"
+               BlueprintName = "Wikipedia"
+               ReferencedContainer = "container:Wikipedia.xcodeproj">
+            </BuildableReference>
+         </BuildActionEntry>
+      </BuildActionEntries>
+   </BuildAction>
+   <TestAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
+      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
+      shouldUseLaunchSchemeArgsEnv = "YES">
+      <Testables>
+      </Testables>
+   </TestAction>
+   <LaunchAction
+      buildConfiguration = "Debug"
+      selectedDebuggerIdentifier = ""
+      selectedLauncherIdentifier = "Xcode.IDEFoundation.Launcher.PosixSpawn"
+      launchStyle = "0"
+      askForAppToLaunch = "Yes"
+      useCustomWorkingDirectory = "NO"
+      ignoresPersistentStateOnLaunch = "NO"
+      debugDocumentVersioning = "YES"
+      debugServiceExtension = "internal"
+      allowLocationSimulation = "YES"
+      launchAutomaticallySubstyle = "2">
+      <RemoteRunnable
+         runnableDebuggingMode = "2"
+         BundleIdentifier = "com.apple.springboard">
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "00021DE024D48EFD00476F97"
+            BuildableName = "WidgetsExtension.appex"
+            BlueprintName = "WidgetsExtension"
+            ReferencedContainer = "container:Wikipedia.xcodeproj">
+         </BuildableReference>
+      </RemoteRunnable>
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "D4991434181D51DE00E6073C"
+            BuildableName = "Wikipedia.app"
+            BlueprintName = "Wikipedia"
+            ReferencedContainer = "container:Wikipedia.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
+      <EnvironmentVariables>
+         <EnvironmentVariable
+            key = "_XCWidgetKind"
+            value = "org.wikimedia.wikipedia.widgets.topRead"
+            isEnabled = "NO">
+         </EnvironmentVariable>
+         <EnvironmentVariable
+            key = "_XCWidgetDefaultView"
+            value = "timeline"
+            isEnabled = "NO">
+         </EnvironmentVariable>
+         <EnvironmentVariable
+            key = "_XCWidgetFamily"
+            value = "large"
+            isEnabled = "NO">
+         </EnvironmentVariable>
+      </EnvironmentVariables>
+   </LaunchAction>
+   <ProfileAction
+      buildConfiguration = "Release"
+      shouldUseLaunchSchemeArgsEnv = "YES"
+      savedToolIdentifier = ""
+      useCustomWorkingDirectory = "NO"
+      debugDocumentVersioning = "YES"
+      launchAutomaticallySubstyle = "2">
+      <BuildableProductRunnable
+         runnableDebuggingMode = "0">
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "D4991434181D51DE00E6073C"
+            BuildableName = "Wikipedia.app"
+            BlueprintName = "Wikipedia"
+            ReferencedContainer = "container:Wikipedia.xcodeproj">
+         </BuildableReference>
+      </BuildableProductRunnable>
+   </ProfileAction>
+   <AnalyzeAction
+      buildConfiguration = "Debug">
+   </AnalyzeAction>
+   <ArchiveAction
+      buildConfiguration = "Release"
+      revealArchiveInOrganizer = "YES">
+   </ArchiveAction>
+</Scheme>
