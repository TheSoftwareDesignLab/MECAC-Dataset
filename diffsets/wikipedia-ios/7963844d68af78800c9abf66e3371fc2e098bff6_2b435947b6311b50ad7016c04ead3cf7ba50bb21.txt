diff --git a/MediaWikiKit/MediaWikiKit/MWKImageList.h b/MediaWikiKit/MediaWikiKit/MWKImageList.h
index 3693c2968ef..c2353b932ef 100644
--- a/MediaWikiKit/MediaWikiKit/MWKImageList.h
+++ b/MediaWikiKit/MediaWikiKit/MWKImageList.h
@@ -85,6 +85,9 @@
  */
 - (NSArray*)uniqueLargestVariants;
 
+/// @return The `sourceURL` of each entry in `uniqueLargestVariants` as a NSURL.
+- (NSArray*)uniqueLargestVariantSourceURLs;
+
 @property (readonly) BOOL dirty;
 
 - (void)save;
diff --git a/MediaWikiKit/MediaWikiKit/MWKImageList.m b/MediaWikiKit/MediaWikiKit/MWKImageList.m
index afa015dfb70..0e39288ec2a 100644
--- a/MediaWikiKit/MediaWikiKit/MWKImageList.m
+++ b/MediaWikiKit/MediaWikiKit/MWKImageList.m
@@ -207,6 +207,18 @@ - (NSArray*)uniqueLargestVariants {
     return [resultBuilder array];
 }
 
+- (NSArray*)uniqueLargestVariantSourceURLs {
+    NSArray* uniqueLargestVariants = self.uniqueLargestVariants;
+    return [uniqueLargestVariants bk_reduce:[NSMutableArray arrayWithCapacity:uniqueLargestVariants.count]
+                                  withBlock:^NSMutableArray*(NSMutableArray* memo, MWKImage* image) {
+        NSURL* url = [NSURL wmf_optionalURLWithString:image.sourceURL];
+        if (url) {
+            [memo addObject:url];
+        }
+        return memo;
+    }];
+}
+
 - (BOOL)addImageURLIfAbsent:(NSString*)imageURL {
     imageURL = [imageURL wmf_schemelessURL];
     if (imageURL && imageURL.length > 0 && ![self.mutableEntries containsObject:imageURL]) {
diff --git a/Wikipedia.xcodeproj/project.pbxproj b/Wikipedia.xcodeproj/project.pbxproj
index 924f11ba3fa..b4615cb6310 100644
--- a/Wikipedia.xcodeproj/project.pbxproj
+++ b/Wikipedia.xcodeproj/project.pbxproj
@@ -250,7 +250,7 @@
 		BC0FED751AAA026C002488D7 /* NSArray+BKIndexTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BCB58F7B1A8D0C8E00465627 /* NSArray+BKIndexTests.m */; };
 		BC0FED761AAA026C002488D7 /* NSString+WMFHTMLParsingTests.m in Sources */ = {isa = PBXBuildFile; fileRef = C983151B1AA5205700E25EE1 /* NSString+WMFHTMLParsingTests.m */; };
 		BC0FED771AAA026C002488D7 /* WMFImageURLParsingTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BCBDE0AB1AA76EAC006BD29A /* WMFImageURLParsingTests.m */; };
-		BC23759A1AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.m in Sources */ = {isa = PBXBuildFile; fileRef = BC2375991AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.m */; };
+		BC23759A1AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.m in Sources */ = {isa = PBXBuildFile; fileRef = BC2375991AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.m */; };
 		BC23759E1AB8928600B0BAA8 /* WMFDateFormatterTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BC23759D1AB8928600B0BAA8 /* WMFDateFormatterTests.m */; };
 		BC2375C11ABB14CC00B0BAA8 /* WMFArticleImageInjectionTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BC2375C01ABB14CC00B0BAA8 /* WMFArticleImageInjectionTests.m */; };
 		BC2CBB8E1AA10F400079A313 /* UIView+WMFFrameUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BC2CBB8D1AA10F400079A313 /* UIView+WMFFrameUtils.m */; };
@@ -261,6 +261,11 @@
 		BC32A1D91B4B1B8A00A286DE /* WMFLegacyImageDataMigration.swift in Sources */ = {isa = PBXBuildFile; fileRef = BC32A1D81B4B1B8A00A286DE /* WMFLegacyImageDataMigration.swift */; };
 		BC34E46A1B31AD8B00258928 /* MWKLanguageLinkController.m in Sources */ = {isa = PBXBuildFile; fileRef = BC34E4691B31AD8B00258928 /* MWKLanguageLinkController.m */; };
 		BC49B3641AEECFD8009F55BE /* ArticleLoadingTests.m in Sources */ = {isa = PBXBuildFile; fileRef = BC49B3631AEECFD8009F55BE /* ArticleLoadingTests.m */; };
+		BC505EEB1B59461400537006 /* WMFCollectionViewPageLayout.m in Sources */ = {isa = PBXBuildFile; fileRef = BC505EEA1B59461400537006 /* WMFCollectionViewPageLayout.m */; };
+		BC505EEE1B594B5700537006 /* WMFImageCollectionViewCell.m in Sources */ = {isa = PBXBuildFile; fileRef = BC505EED1B594B5700537006 /* WMFImageCollectionViewCell.m */; };
+		BC505EF41B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = BC505EF31B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.m */; };
+		BC505EF71B59643400537006 /* WMFPageCollectionViewController.m in Sources */ = {isa = PBXBuildFile; fileRef = BC505EF61B59643400537006 /* WMFPageCollectionViewController.m */; };
+		BC505F061B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.m in Sources */ = {isa = PBXBuildFile; fileRef = BC505F051B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.m */; };
 		BC50C37F1A83C784006DC7AF /* WMFNetworkUtilities.m in Sources */ = {isa = PBXBuildFile; fileRef = BC50C37E1A83C784006DC7AF /* WMFNetworkUtilities.m */; };
 		BC50C3871A83CBDA006DC7AF /* MWKImageInfoResponseSerializer.m in Sources */ = {isa = PBXBuildFile; fileRef = BC50C3861A83CBDA006DC7AF /* MWKImageInfoResponseSerializer.m */; };
 		BC5FE5701B1DF02900273BC0 /* ENWikiSiteInfo.json in Resources */ = {isa = PBXBuildFile; fileRef = BC5FE56F1B1DF02900273BC0 /* ENWikiSiteInfo.json */; };
@@ -336,7 +341,7 @@
 		BCBDC88E1B3A42E7003A6D17 /* SwiftUtilities.swift in Sources */ = {isa = PBXBuildFile; fileRef = BCBDC88D1B3A42E7003A6D17 /* SwiftUtilities.swift */; };
 		BCC185D81A9E5628005378F8 /* UILabel+WMFStyling.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185D71A9E5628005378F8 /* UILabel+WMFStyling.m */; };
 		BCC185E01A9EC836005378F8 /* UIButton+FrameUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185DF1A9EC836005378F8 /* UIButton+FrameUtils.m */; };
-		BCC185E81A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */; };
+		BCC185E81A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.m in Sources */ = {isa = PBXBuildFile; fileRef = BCC185E71A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.m */; };
 		BCCE8EBA1B4D5DD90009FBBC /* XCTestCase+PromiseKit.swift in Sources */ = {isa = PBXBuildFile; fileRef = BCCE8EB91B4D5DD90009FBBC /* XCTestCase+PromiseKit.swift */; };
 		BCCE8EBC1B4D7F590009FBBC /* XCTestCase+SwiftDefaults.swift in Sources */ = {isa = PBXBuildFile; fileRef = BCCE8EBB1B4D7F590009FBBC /* XCTestCase+SwiftDefaults.swift */; };
 		BCCEC1211B1F68CF00A8B522 /* golden-gate.jpg in Resources */ = {isa = PBXBuildFile; fileRef = BCD41DDE1B11CC5800231BB1 /* golden-gate.jpg */; };
@@ -836,8 +841,8 @@
 		BC092BA01B19135700093C59 /* WMFApiJsonResponseSerializer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WMFApiJsonResponseSerializer.h; path = Serializers/WMFApiJsonResponseSerializer.h; sourceTree = "<group>"; };
 		BC092BA11B19135700093C59 /* WMFApiJsonResponseSerializer.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; name = WMFApiJsonResponseSerializer.m; path = Serializers/WMFApiJsonResponseSerializer.m; sourceTree = "<group>"; };
 		BC092BA61B19189100093C59 /* MWKSiteInfoFetcherTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MWKSiteInfoFetcherTests.m; sourceTree = "<group>"; };
-		BC2375981AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSParagraphStyle+WMFNaturalAlignmentStyle.h"; sourceTree = "<group>"; };
-		BC2375991AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSParagraphStyle+WMFNaturalAlignmentStyle.m"; sourceTree = "<group>"; };
+		BC2375981AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSParagraphStyle+WMFParagraphStyles.h"; sourceTree = "<group>"; };
+		BC2375991AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSParagraphStyle+WMFParagraphStyles.m"; sourceTree = "<group>"; };
 		BC23759D1AB8928600B0BAA8 /* WMFDateFormatterTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFDateFormatterTests.m; sourceTree = "<group>"; };
 		BC2375C01ABB14CC00B0BAA8 /* WMFArticleImageInjectionTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFArticleImageInjectionTests.m; sourceTree = "<group>"; };
 		BC282E271AE7FBB1005A5277 /* WMFTestFixtureUtilities.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = WMFTestFixtureUtilities.h; sourceTree = "<group>"; };
@@ -853,6 +858,16 @@
 		BC34E4721B31D92100258928 /* LangaugeSelectionDelegate.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LangaugeSelectionDelegate.h; sourceTree = "<group>"; };
 		BC4273521A7C736800068882 /* WikipediaUnitTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = WikipediaUnitTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 		BC49B3631AEECFD8009F55BE /* ArticleLoadingTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ArticleLoadingTests.m; sourceTree = "<group>"; };
+		BC505EE91B59461400537006 /* WMFCollectionViewPageLayout.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFCollectionViewPageLayout.h; sourceTree = "<group>"; };
+		BC505EEA1B59461400537006 /* WMFCollectionViewPageLayout.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFCollectionViewPageLayout.m; sourceTree = "<group>"; };
+		BC505EEC1B594B5700537006 /* WMFImageCollectionViewCell.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFImageCollectionViewCell.h; sourceTree = "<group>"; };
+		BC505EED1B594B5700537006 /* WMFImageCollectionViewCell.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFImageCollectionViewCell.m; sourceTree = "<group>"; };
+		BC505EF21B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFArticleHeaderImageGalleryViewController.h; sourceTree = "<group>"; };
+		BC505EF31B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFArticleHeaderImageGalleryViewController.m; sourceTree = "<group>"; };
+		BC505EF51B59643400537006 /* WMFPageCollectionViewController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFPageCollectionViewController.h; sourceTree = "<group>"; };
+		BC505EF61B59643400537006 /* WMFPageCollectionViewController.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFPageCollectionViewController.m; sourceTree = "<group>"; };
+		BC505F041B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "NSArray+WMFLayoutDirectionUtilities.h"; sourceTree = "<group>"; };
+		BC505F051B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "NSArray+WMFLayoutDirectionUtilities.m"; sourceTree = "<group>"; };
 		BC50C37D1A83C784006DC7AF /* WMFNetworkUtilities.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WMFNetworkUtilities.h; sourceTree = "<group>"; };
 		BC50C37E1A83C784006DC7AF /* WMFNetworkUtilities.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFNetworkUtilities.m; sourceTree = "<group>"; };
 		BC50C3821A83C88F006DC7AF /* WMFJoinedPropertyParametersTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = WMFJoinedPropertyParametersTests.m; sourceTree = "<group>"; };
@@ -1014,8 +1029,8 @@
 		BCC185D71A9E5628005378F8 /* UILabel+WMFStyling.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UILabel+WMFStyling.m"; sourceTree = "<group>"; };
 		BCC185DE1A9EC836005378F8 /* UIButton+FrameUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UIButton+FrameUtils.h"; sourceTree = "<group>"; };
 		BCC185DF1A9EC836005378F8 /* UIButton+FrameUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UIButton+FrameUtils.m"; sourceTree = "<group>"; };
-		BCC185E61A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UICollectionViewFlowLayout+AttributeUtils.h"; sourceTree = "<group>"; };
-		BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UICollectionViewFlowLayout+AttributeUtils.m"; sourceTree = "<group>"; };
+		BCC185E61A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = "UICollectionViewLayout+AttributeUtils.h"; sourceTree = "<group>"; };
+		BCC185E71A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = "UICollectionViewLayout+AttributeUtils.m"; sourceTree = "<group>"; };
 		BCCE8EB91B4D5DD90009FBBC /* XCTestCase+PromiseKit.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "XCTestCase+PromiseKit.swift"; sourceTree = "<group>"; };
 		BCCE8EBB1B4D7F590009FBBC /* XCTestCase+SwiftDefaults.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = "XCTestCase+SwiftDefaults.swift"; sourceTree = "<group>"; };
 		BCCED2CF1AE03BE20094EB7E /* MWKSectionListTests.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = MWKSectionListTests.m; sourceTree = "<group>"; };
@@ -1762,8 +1777,8 @@
 				BC86B93C1A929CC500B4C039 /* UICollectionViewFlowLayout+NSCopying.m */,
 				BC86B93E1A929D7900B4C039 /* UICollectionViewFlowLayout+WMFItemSizeThatFits.h */,
 				BC86B93F1A929D7900B4C039 /* UICollectionViewFlowLayout+WMFItemSizeThatFits.m */,
-				BCC185E61A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.h */,
-				BCC185E71A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m */,
+				BCC185E61A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.h */,
+				BCC185E71A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.m */,
 				BCC185D61A9E5628005378F8 /* UILabel+WMFStyling.h */,
 				BCC185D71A9E5628005378F8 /* UILabel+WMFStyling.m */,
 				BCC185DE1A9EC836005378F8 /* UIButton+FrameUtils.h */,
@@ -1774,8 +1789,8 @@
 				0EA4402D1AA6281200B09DBA /* NSDateFormatter+WMFExtensions.m */,
 				BCA96E751AAA35EE009A61FA /* UIView+WMFDefaultNib.h */,
 				BCA96E761AAA35EE009A61FA /* UIView+WMFDefaultNib.m */,
-				BC2375981AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.h */,
-				BC2375991AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.m */,
+				BC2375981AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.h */,
+				BC2375991AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.m */,
 				BCA6765B1AC0686600A16160 /* Article+ConvenienceAccessors.h */,
 				BCA6765C1AC0686600A16160 /* Article+ConvenienceAccessors.m */,
 				BCE912B81ACC5E6900B74B42 /* NSIndexSet+BKReduce.h */,
@@ -1798,6 +1813,8 @@
 				BC060B391B456D030086EBFB /* AnyPromise+WMFExtensions.m */,
 				BC3047C01B45E65400D7DF1A /* SDWebImageManager+WMFCacheRemoval.h */,
 				BC3047C11B45E65400D7DF1A /* SDWebImageManager+WMFCacheRemoval.m */,
+				BC505F041B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.h */,
+				BC505F051B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.m */,
 			);
 			path = Categories;
 			sourceTree = "<group>";
@@ -1946,6 +1963,8 @@
 				043699901B45B68D002FD81D /* WMFArticleSectionCell.m */,
 				04A9C2A01B4F326D008B996F /* WMFArticleReadMoreCell.h */,
 				04A9C2A11B4F326D008B996F /* WMFArticleReadMoreCell.m */,
+				BC505EF21B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.h */,
+				BC505EF31B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.m */,
 			);
 			name = Table;
 			sourceTree = "<group>";
@@ -2535,6 +2554,12 @@
 				0480AE9F1AA4F4DA00A9950C /* WMFIntrinsicContentSizeAwareTableView.m */,
 				BCA96E711AAA354D009A61FA /* WMFGradientView.h */,
 				BCA96E721AAA354D009A61FA /* WMFGradientView.m */,
+				BC505EE91B59461400537006 /* WMFCollectionViewPageLayout.h */,
+				BC505EEA1B59461400537006 /* WMFCollectionViewPageLayout.m */,
+				BC505EEC1B594B5700537006 /* WMFImageCollectionViewCell.h */,
+				BC505EED1B594B5700537006 /* WMFImageCollectionViewCell.m */,
+				BC505EF51B59643400537006 /* WMFPageCollectionViewController.h */,
+				BC505EF61B59643400537006 /* WMFPageCollectionViewController.m */,
 			);
 			path = "Custom Views";
 			sourceTree = "<group>";
@@ -3179,6 +3204,7 @@
 				04DB0BEA18BD37F900B4BCF3 /* UIScrollView+ScrollSubviewToLocation.m in Sources */,
 				0487048B19F8262600B7D307 /* RandomArticleFetcher.m in Sources */,
 				042BEAEF1A92EE66002CF320 /* UIWebView+WMFTrackingView.m in Sources */,
+				BC505F061B5D683A00537006 /* NSArray+WMFLayoutDirectionUtilities.m in Sources */,
 				C99844571A8C1F23001D58FD /* UIWebView+WMFSuppressSelection.m in Sources */,
 				04AE1C701891B302002D5487 /* NSObject+Extras.m in Sources */,
 				04B7B9BD18B5570E00A63551 /* CaptchaViewController.m in Sources */,
@@ -3265,7 +3291,7 @@
 				0487048C19F8262600B7D307 /* SearchResultFetcher.m in Sources */,
 				0E366B471B2F614E00ABFB86 /* PromiseKit.m in Sources */,
 				0E869F121B56B83F002604C3 /* MWKList.m in Sources */,
-				BC23759A1AB78D8A00B0BAA8 /* NSParagraphStyle+WMFNaturalAlignmentStyle.m in Sources */,
+				BC23759A1AB78D8A00B0BAA8 /* NSParagraphStyle+WMFParagraphStyles.m in Sources */,
 				04090A3B187FB7D000577EDF /* UIView+Debugging.m in Sources */,
 				BCC185D81A9E5628005378F8 /* UILabel+WMFStyling.m in Sources */,
 				BCBDC8841B38E441003A6D17 /* WMFImageController.swift in Sources */,
@@ -3314,6 +3340,7 @@
 				047ED63918C13E4900442BE3 /* PreviewWebView.m in Sources */,
 				0480AEA01AA4F4DA00A9950C /* WMFIntrinsicContentSizeAwareTableView.m in Sources */,
 				0484B9061ABB50FA00874073 /* WMFArticleParsing.m in Sources */,
+				BC505EF41B594E8E00537006 /* WMFArticleHeaderImageGalleryViewController.m in Sources */,
 				04B6925018E77B2A00F88D8A /* UIWebView+HideScrollGradient.m in Sources */,
 				048830D21AB775E3005BF3A1 /* UIScrollView+WMFScrollsToTop.m in Sources */,
 				047E95511996DD030046A122 /* NearbyViewController.m in Sources */,
@@ -3367,7 +3394,7 @@
 				BC50C37F1A83C784006DC7AF /* WMFNetworkUtilities.m in Sources */,
 				BCB58F441A890D9700465627 /* MWKImageInfo+MWKImageComparison.m in Sources */,
 				BCB669AD1A83F6C400C7B1FE /* MWKSavedPageList.m in Sources */,
-				BCC185E81A9FA498005378F8 /* UICollectionViewFlowLayout+AttributeUtils.m in Sources */,
+				BCC185E81A9FA498005378F8 /* UICollectionViewLayout+AttributeUtils.m in Sources */,
 				04D686F81AB2949C0009B44A /* PaddedLabel.m in Sources */,
 				04C695D218ED213000D9F2DA /* UIScrollView+NoHorizontalScrolling.m in Sources */,
 				BC3166B21B279AC30096EE8E /* WikipediaAppUtils.m in Sources */,
@@ -3384,6 +3411,7 @@
 				04C9509D19EF02980013F3C0 /* EventLogger.m in Sources */,
 				0EFB0F1B1B31EE2D00D05C08 /* ArticleDataContextSingleton.m in Sources */,
 				04F39590186CF80100B0D6FC /* TOCViewController.m in Sources */,
+				BC505EF71B59643400537006 /* WMFPageCollectionViewController.m in Sources */,
 				BCE24FDF1B0CF0C7003F054B /* LegacyPhoneGapDataMigrator.m in Sources */,
 				042950D41A9D3BA7009BE784 /* UIColor+WMFHexColor.m in Sources */,
 				BCBDC88C1B3A0715003A6D17 /* Cancellable.swift in Sources */,
@@ -3445,7 +3473,9 @@
 				04CCCFEE1935093A00E3F60C /* SecondaryMenuRowView.m in Sources */,
 				04D686CE1AB292160009B44A /* WMFFaceDetector.m in Sources */,
 				0442F57B19006DCC00F55DF9 /* PageHistoryLabel.m in Sources */,
+				BC505EEE1B594B5700537006 /* WMFImageCollectionViewCell.m in Sources */,
 				041C6206199ED2A20061516F /* MWKSection+TOC.m in Sources */,
+				BC505EEB1B59461400537006 /* WMFCollectionViewPageLayout.m in Sources */,
 				BC2CBB8E1AA10F400079A313 /* UIView+WMFFrameUtils.m in Sources */,
 				0447862F185145090050563B /* HistoryResultCell.m in Sources */,
 				BCA6765D1AC0686600A16160 /* Article+ConvenienceAccessors.m in Sources */,
diff --git a/Wikipedia/Categories/NSArray+BKIndex.h b/Wikipedia/Categories/NSArray+BKIndex.h
index e3a73f265a9..f7fae4931c7 100644
--- a/Wikipedia/Categories/NSArray+BKIndex.h
+++ b/Wikipedia/Categories/NSArray+BKIndex.h
@@ -8,6 +8,8 @@
 
 #import <Foundation/Foundation.h>
 
+NS_ASSUME_NONNULL_BEGIN
+
 /// Extends BlocksKit with indexing functionality.
 @interface NSArray (BKIndex)
 
@@ -29,3 +31,5 @@
 - (NSDictionary*)bk_indexWithKeypath:(NSString*)keypath;
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/Categories/NSArray+BKIndex.m b/Wikipedia/Categories/NSArray+BKIndex.m
index d6f71b778a8..ec7bef74d04 100644
--- a/Wikipedia/Categories/NSArray+BKIndex.m
+++ b/Wikipedia/Categories/NSArray+BKIndex.m
@@ -9,20 +9,26 @@
 #import "NSArray+BKIndex.h"
 #import <BlocksKit/BlocksKit.h>
 
+NS_ASSUME_NONNULL_BEGIN
+
 @implementation NSArray (BKIndex)
 
 - (NSDictionary*)bk_index:(id<NSCopying>(^)(id))index {
     return [self bk_reduce:[NSMutableDictionary dictionaryWithCapacity:self.count]
                  withBlock:^NSMutableDictionary*(NSMutableDictionary* acc, id obj) {
-        acc[index(obj)] = obj;
+        id<NSCopying> key = index(obj);
+        acc[key] = obj;
         return acc;
     }];
 }
 
 - (NSDictionary*)bk_indexWithKeypath:(NSString*)keypath {
+    NSParameterAssert(keypath.length);
     return [self bk_index:^id < NSCopying > (id obj) {
         return [obj valueForKeyPath:keypath];
     }];
 }
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/Categories/NSArray+WMFLayoutDirectionUtilities.h b/Wikipedia/Categories/NSArray+WMFLayoutDirectionUtilities.h
new file mode 100644
index 00000000000..dd50bc4615e
--- /dev/null
+++ b/Wikipedia/Categories/NSArray+WMFLayoutDirectionUtilities.h
@@ -0,0 +1,21 @@
+//
+//  NSArray+WMFLayoutDirectionUtilities.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/20/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <Foundation/Foundation.h>
+
+@interface NSArray (WMFLayoutDirectionUtilities)
+
+- (NSUInteger)wmf_startingIndexForApplicationLayoutDirection;
+
+- (NSUInteger)wmf_startingIndexForLayoutDirection:(UIUserInterfaceLayoutDirection)layoutDirection;
+
+- (instancetype)wmf_reverseArrayIfApplicationIsRTL;
+
+- (instancetype)wmf_reverseArrayIfRTL:(UIUserInterfaceLayoutDirection)layoutDirection;
+
+@end
diff --git a/Wikipedia/Categories/NSArray+WMFLayoutDirectionUtilities.m b/Wikipedia/Categories/NSArray+WMFLayoutDirectionUtilities.m
new file mode 100644
index 00000000000..d2d70f2fc1d
--- /dev/null
+++ b/Wikipedia/Categories/NSArray+WMFLayoutDirectionUtilities.m
@@ -0,0 +1,30 @@
+//
+//  NSArray+WMFLayoutDirectionUtilities.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/20/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "NSArray+WMFLayoutDirectionUtilities.h"
+#import "NSArray+WMFExtensions.h"
+
+@implementation NSArray (WMFLayoutDirectionUtilities)
+
+- (NSUInteger)wmf_startingIndexForApplicationLayoutDirection {
+    return [self wmf_startingIndexForLayoutDirection:[[UIApplication sharedApplication] userInterfaceLayoutDirection]];
+}
+
+- (NSUInteger)wmf_startingIndexForLayoutDirection:(UIUserInterfaceLayoutDirection)layoutDirection {
+    return layoutDirection == UIUserInterfaceLayoutDirectionRightToLeft ? self.count - 1 : 0;
+}
+
+- (instancetype)wmf_reverseArrayIfApplicationIsRTL {
+    return [self wmf_reverseArrayIfRTL:[[UIApplication sharedApplication] userInterfaceLayoutDirection]];
+}
+
+- (instancetype)wmf_reverseArrayIfRTL:(UIUserInterfaceLayoutDirection)layoutDirection {
+    return layoutDirection == UIUserInterfaceLayoutDirectionRightToLeft ? [self wmf_reverseArray] : self;
+}
+
+@end
diff --git a/Wikipedia/Categories/NSParagraphStyle+WMFNaturalAlignmentStyle.m b/Wikipedia/Categories/NSParagraphStyle+WMFNaturalAlignmentStyle.m
deleted file mode 100644
index 7e5c3252418..00000000000
--- a/Wikipedia/Categories/NSParagraphStyle+WMFNaturalAlignmentStyle.m
+++ /dev/null
@@ -1,24 +0,0 @@
-//
-//  NSParagraphStyle+WMFNaturalAlignmentStyle.m
-//  Wikipedia
-//
-//  Created by Brian Gerstle on 3/16/15.
-//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
-//
-
-#import "NSParagraphStyle+WMFNaturalAlignmentStyle.h"
-
-@implementation NSParagraphStyle (WMFNaturalAlignmentStyle)
-
-+ (NSParagraphStyle*)wmf_naturalAlignmentStyle {
-    NSParameterAssert([NSThread isMainThread]);
-    static NSParagraphStyle* naturalAlignmentStyle = nil;
-    if (!naturalAlignmentStyle) {
-        NSMutableParagraphStyle* style = [NSMutableParagraphStyle new];
-        style.alignment       = NSTextAlignmentNatural;
-        naturalAlignmentStyle = [style copy];
-    }
-    return naturalAlignmentStyle;
-}
-
-@end
diff --git a/Wikipedia/Categories/NSParagraphStyle+WMFNaturalAlignmentStyle.h b/Wikipedia/Categories/NSParagraphStyle+WMFParagraphStyles.h
similarity index 66%
rename from Wikipedia/Categories/NSParagraphStyle+WMFNaturalAlignmentStyle.h
rename to Wikipedia/Categories/NSParagraphStyle+WMFParagraphStyles.h
index c92d4d1df48..cc6bf5dee49 100644
--- a/Wikipedia/Categories/NSParagraphStyle+WMFNaturalAlignmentStyle.h
+++ b/Wikipedia/Categories/NSParagraphStyle+WMFParagraphStyles.h
@@ -1,5 +1,5 @@
 //
-//  NSParagraphStyle+WMFNaturalAlignmentStyle.h
+//  NSParagraphStyle+WMFParagraphStyles.h
 //  Wikipedia
 //
 //  Created by Brian Gerstle on 3/16/15.
@@ -8,9 +8,11 @@
 
 #import <UIKit/UIKit.h>
 
-@interface NSParagraphStyle (WMFNaturalAlignmentStyle)
+@interface NSParagraphStyle (WMFParagraphStyles)
 
 /// Provides a backwards-compatible way to have "natural" text alignment of labels & buttons.
 + (NSParagraphStyle*)wmf_naturalAlignmentStyle;
 
++ (NSParagraphStyle*)wmf_tailTruncatingNaturalAlignmentStyle;
+
 @end
diff --git a/Wikipedia/Categories/NSParagraphStyle+WMFParagraphStyles.m b/Wikipedia/Categories/NSParagraphStyle+WMFParagraphStyles.m
new file mode 100644
index 00000000000..cfd3e7ae38c
--- /dev/null
+++ b/Wikipedia/Categories/NSParagraphStyle+WMFParagraphStyles.m
@@ -0,0 +1,36 @@
+//
+//  NSParagraphStyle+WMFParagraphStyles.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 3/16/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "NSParagraphStyle+WMFParagraphStyles.h"
+
+@implementation NSParagraphStyle (WMFParagraphStyles)
+
++ (NSParagraphStyle*)wmf_naturalAlignmentStyle {
+    NSParameterAssert([NSThread isMainThread]);
+    static NSParagraphStyle* naturalAlignmentStyle = nil;
+    if (!naturalAlignmentStyle) {
+        NSMutableParagraphStyle* style = [NSMutableParagraphStyle new];
+        style.alignment       = NSTextAlignmentNatural;
+        naturalAlignmentStyle = [style copy];
+    }
+    return naturalAlignmentStyle;
+}
+
++ (NSParagraphStyle*)wmf_tailTruncatingNaturalAlignmentStyle {
+    NSParameterAssert([NSThread isMainThread]);
+    static NSParagraphStyle* tailTruncatingNaturalAlignmentStyle = nil;
+    if (!tailTruncatingNaturalAlignmentStyle) {
+        NSMutableParagraphStyle* style = [NSMutableParagraphStyle new];
+        style.alignment                     = NSTextAlignmentNatural;
+        style.lineBreakMode                 = NSLineBreakByTruncatingTail;
+        tailTruncatingNaturalAlignmentStyle = [style copy];
+    }
+    return tailTruncatingNaturalAlignmentStyle;
+}
+
+@end
diff --git a/Wikipedia/Categories/UICollectionViewFlowLayout+AttributeUtils.h b/Wikipedia/Categories/UICollectionViewLayout+AttributeUtils.h
similarity index 88%
rename from Wikipedia/Categories/UICollectionViewFlowLayout+AttributeUtils.h
rename to Wikipedia/Categories/UICollectionViewLayout+AttributeUtils.h
index b0513228df5..daaf6822e0c 100644
--- a/Wikipedia/Categories/UICollectionViewFlowLayout+AttributeUtils.h
+++ b/Wikipedia/Categories/UICollectionViewLayout+AttributeUtils.h
@@ -1,5 +1,5 @@
 //
-//  UICollectionViewFlowLayout+AttributeUtils.h
+//  UICollectionViewLayout+AttributeUtils.h
 //  Wikipedia
 //
 //  Created by Brian Gerstle on 2/26/15.
@@ -13,10 +13,10 @@
  * @warning Most of these methods were naively implemented and only support layouts configured with a horizontal
  *          scrolling direction.
  */
-@interface UICollectionViewFlowLayout (AttributeUtils)
+@interface UICollectionViewLayout (AttributeUtils)
 
-/// The @c NSIndexPath for the item closest to the current @c contentOffset of the receiver's @c collectionView.
-- (NSIndexPath*)wmf_indexPathClosestToContentOffset;
+/// The @c NSIndexPath for the item closest to the current @c contentOffset.x of the receiver's @c collectionView.
+- (NSIndexPath*)wmf_indexPathHorizontallyClosestToContentOffset;
 
 /**
  * Sort an array of @c UICollectionViewLayoutAttribute objects by their distance to @c point in ascending order.
diff --git a/Wikipedia/Categories/UICollectionViewFlowLayout+AttributeUtils.m b/Wikipedia/Categories/UICollectionViewLayout+AttributeUtils.m
similarity index 85%
rename from Wikipedia/Categories/UICollectionViewFlowLayout+AttributeUtils.m
rename to Wikipedia/Categories/UICollectionViewLayout+AttributeUtils.m
index eb8cc103f97..04e52f43bbd 100644
--- a/Wikipedia/Categories/UICollectionViewFlowLayout+AttributeUtils.m
+++ b/Wikipedia/Categories/UICollectionViewLayout+AttributeUtils.m
@@ -1,17 +1,17 @@
 //
-//  UICollectionViewFlowLayout+AttributeUtils.m
+//  UICollectionViewLayout+AttributeUtils.m
 //  Wikipedia
 //
 //  Created by Brian Gerstle on 2/26/15.
 //  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
 //
 
-#import "UICollectionViewFlowLayout+AttributeUtils.h"
+#import "UICollectionViewLayout+AttributeUtils.h"
 #import <BlocksKit/BlocksKit.h>
 
-@implementation UICollectionViewFlowLayout (AttributeUtils)
+@implementation UICollectionViewLayout (AttributeUtils)
 
-- (NSIndexPath*)wmf_indexPathClosestToContentOffset {
+- (NSIndexPath*)wmf_indexPathHorizontallyClosestToContentOffset {
     return [[[self wmf_layoutAttributesByDistanceToPoint:self.collectionView.contentOffset] firstObject] indexPath];
 }
 
diff --git a/Wikipedia/Custom Views/WMFCollectionViewPageLayout.h b/Wikipedia/Custom Views/WMFCollectionViewPageLayout.h
new file mode 100644
index 00000000000..85948a211f9
--- /dev/null
+++ b/Wikipedia/Custom Views/WMFCollectionViewPageLayout.h	
@@ -0,0 +1,13 @@
+//
+//  WMFCollectionViewPageLayout.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface WMFCollectionViewPageLayout : UICollectionViewFlowLayout
+
+@end
diff --git a/Wikipedia/Custom Views/WMFCollectionViewPageLayout.m b/Wikipedia/Custom Views/WMFCollectionViewPageLayout.m
new file mode 100644
index 00000000000..f615ae96823
--- /dev/null
+++ b/Wikipedia/Custom Views/WMFCollectionViewPageLayout.m	
@@ -0,0 +1,24 @@
+//
+//  WMFCollectionViewPageLayout.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "WMFCollectionViewPageLayout.h"
+#import "UICollectionViewFlowLayout+WMFItemSizeThatFits.h"
+
+@implementation WMFCollectionViewPageLayout
+
+- (void)prepareLayout {
+    [super prepareLayout];
+    [self wmf_itemSizeToFit];
+}
+
+- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds {
+    return [super shouldInvalidateLayoutForBoundsChange:newBounds]
+           || !CGSizeEqualToSize(newBounds.size, self.itemSize);
+}
+
+@end
diff --git a/Wikipedia/Custom Views/WMFImageCollectionViewCell.h b/Wikipedia/Custom Views/WMFImageCollectionViewCell.h
new file mode 100644
index 00000000000..46758cc7818
--- /dev/null
+++ b/Wikipedia/Custom Views/WMFImageCollectionViewCell.h	
@@ -0,0 +1,13 @@
+//
+//  WMFImageCollectionViewCell.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <UIKit/UIKit.h>
+
+@interface WMFImageCollectionViewCell : UICollectionViewCell
+@property (weak, nonatomic) IBOutlet UIImageView* imageView;
+@end
diff --git a/Wikipedia/Custom Views/WMFImageCollectionViewCell.m b/Wikipedia/Custom Views/WMFImageCollectionViewCell.m
new file mode 100644
index 00000000000..2a8f238e937
--- /dev/null
+++ b/Wikipedia/Custom Views/WMFImageCollectionViewCell.m	
@@ -0,0 +1,18 @@
+//
+//  WMFImageCollectionViewCell.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "WMFImageCollectionViewCell.h"
+
+@implementation WMFImageCollectionViewCell
+
+- (void)prepareForReuse {
+    [super prepareForReuse];
+    self.imageView.image = nil;
+}
+
+@end
diff --git a/Wikipedia/Custom Views/WMFPageCollectionViewController.h b/Wikipedia/Custom Views/WMFPageCollectionViewController.h
new file mode 100644
index 00000000000..3591cc3df5a
--- /dev/null
+++ b/Wikipedia/Custom Views/WMFPageCollectionViewController.h	
@@ -0,0 +1,29 @@
+//
+//  WMFPagingCollectionViewController.h
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import <UIKit/UIKit.h>
+
+/**
+ * View controller which displays "pages" of content using a collection view.
+ */
+@interface WMFPageCollectionViewController : UICollectionViewController
+
+@property (nonatomic) NSUInteger currentPage;
+
+- (void)setCurrentPage:(NSUInteger)currentPage animated:(BOOL)animated;
+
+/**
+ * Flag which dictates whether or not the current `currentPage` has been applied.
+ *
+ * Check this whenever doing work while view size is transitioning or device is rotating, as
+ * `WMFPageCollectionViewController` will set/reset this flag as necessary to ensure `currentPage` is maintained
+ * through a transition.
+ */
+@property (nonatomic) BOOL didApplyCurrentPage;
+
+@end
diff --git a/Wikipedia/Custom Views/WMFPageCollectionViewController.m b/Wikipedia/Custom Views/WMFPageCollectionViewController.m
new file mode 100644
index 00000000000..71149c33e06
--- /dev/null
+++ b/Wikipedia/Custom Views/WMFPageCollectionViewController.m	
@@ -0,0 +1,107 @@
+//
+//  WMFPagingCollectionViewController.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "WMFPageCollectionViewController.h"
+#import "UICollectionViewLayout+AttributeUtils.h"
+
+@interface WMFPageCollectionViewController ()
+
+/// Set the current page without triggering any UI updates.
+- (void)primitiveSetCurrentPage:(NSUInteger)page;
+
+@end
+
+@implementation WMFPageCollectionViewController
+
+- (void)applyCurrentPage:(BOOL)animated {
+    if ([self isViewLoaded]) {
+        // can't use scrollToItem because it doesn't handle post-rotation scrolling well on iOS 6
+        UICollectionViewLayoutAttributes* currentPageAttributes =
+            [self.collectionViewLayout layoutAttributesForItemAtIndexPath:
+             [NSIndexPath indexPathForItem:self.currentPage inSection:0]];
+        NSAssert(currentPageAttributes,
+                 @"Layout attributes for current page were nil because %@ was called too early!",
+                 NSStringFromSelector(_cmd));
+        [self.collectionView setContentOffset:currentPageAttributes.frame.origin animated:animated];
+    }
+}
+
+- (void)setCurrentPage:(NSUInteger)currentPage {
+    [self setCurrentPage:currentPage animated:NO];
+}
+
+- (void)setCurrentPage:(NSUInteger)currentPage animated:(BOOL)animated {
+    [self setCurrentPage:currentPage animated:animated forceViewUpdate:NO];
+}
+
+- (void)setCurrentPage:(NSUInteger)currentPage animated:(BOOL)animated forceViewUpdate:(BOOL)force {
+    if (!force && currentPage == _currentPage) {
+        return;
+    }
+    [self primitiveSetCurrentPage:currentPage];
+    [self applyCurrentPage:animated];
+}
+
+- (void)primitiveSetCurrentPage:(NSUInteger)page {
+    NSParameterAssert(page < [self.collectionView numberOfItemsInSection:0]);
+    _currentPage = page;
+}
+
+- (NSUInteger)mostVisibleItemIndex {
+    return [self.collectionViewLayout wmf_indexPathHorizontallyClosestToContentOffset].item;
+}
+
+#pragma mark - View event handling
+
+#if __IPHONE_OS_VERSION_MIN_REQUIRED >= __IPHONE_8_0
+#error Remove willRotate now that iOS 7 is dropped
+#endif
+- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation
+                                duration:(NSTimeInterval)duration {
+    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];
+    // reset currentPageIndex flags so that the current image stays visible after rotation
+    _didApplyCurrentPage = NO;
+    _currentPage         = [self mostVisibleItemIndex];
+}
+
+- (void)viewWillTransitionToSize:(CGSize)size
+       withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator {
+    [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];
+    NSUInteger const currentImageIndex = [self mostVisibleItemIndex];
+    [coordinator notifyWhenInteractionEndsUsingBlock:^(id < UIViewControllerTransitionCoordinatorContext > _) {
+        [self setCurrentPage:currentImageIndex animated:NO forceViewUpdate:YES];
+    }];
+}
+
+- (void)viewDidLayoutSubviews {
+    [super viewDidLayoutSubviews];
+    /*
+       only apply visible image index once the collection view has been populated with cells, otherwise calls to get
+       layout attributes of the item at `currentPageIndex` will return `nil` (on iOS 6, at least)
+     */
+    if (!self.didApplyCurrentPage && self.collectionView.visibleCells.count) {
+        [self applyCurrentPage:NO];
+        /*
+           only set the flag *after* the visible index has been updated, to make sure UICollectionViewDelegate callbacks
+           don't override it
+         */
+        self.didApplyCurrentPage = YES;
+    }
+}
+
+- (void)scrollViewDidEndDragging:(UIScrollView*)scrollView willDecelerate:(BOOL)decelerate {
+    if (!decelerate) {
+        _currentPage = [self mostVisibleItemIndex];
+    }
+}
+
+- (void)scrollViewDidEndDecelerating:(UIScrollView*)scrollView {
+    _currentPage = [self mostVisibleItemIndex];
+}
+
+@end
diff --git a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h
index 321ecef13fb..97c8d67771b 100644
--- a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h
+++ b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h
@@ -1,11 +1,18 @@
 
 @import UIKit;
 
+NS_ASSUME_NONNULL_BEGIN
+
+typedef void (^ WMFIndexPathEnumerator)(NSIndexPath* indexPath, BOOL* stop);
+typedef void (^ WMFCellEnumerator)(id cell, NSIndexPath* indexPath, BOOL* stop);
+
 @interface UICollectionView (WMFExtensions)
 
-- (void)wmf_enumerateIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block;
+- (void)wmf_enumerateIndexPathsUsingBlock:(WMFIndexPathEnumerator)block;
 
-- (void)wmf_enumerateVisibleIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block;
+- (void)wmf_enumerateVisibleIndexPathsUsingBlock:(WMFIndexPathEnumerator)block;
+
+- (void)wmf_enumerateVisibleCellsUsingBlock:(WMFCellEnumerator)block;
 
 /**
  *  Like other UIKit methods, the completion isn't called if you pass animated = false.
@@ -14,3 +21,5 @@
 - (void)wmf_setCollectionViewLayout:(UICollectionViewLayout*)layout animated:(BOOL)animated alwaysFireCompletion:(void (^)(BOOL finished))completion;
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m
index eabd833f3f5..61885ca146b 100644
--- a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m
+++ b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m
@@ -1,23 +1,20 @@
 
 #import "UICollectionView+WMFExtensions.h"
 
-@implementation UICollectionView (WMFExtensions)
+NS_ASSUME_NONNULL_BEGIN
 
-- (void)wmf_enumerateIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block {
-    BOOL stop = NO;
+@implementation UICollectionView (WMFExtensions)
 
+- (void)wmf_enumerateIndexPathsUsingBlock:(WMFIndexPathEnumerator)block {
+    BOOL stop              = NO;
     NSInteger sectionCount = [self numberOfSections];
-
     for (NSInteger section = 0; section < sectionCount; section++) {
         NSInteger rowCount = [self numberOfItemsInSection:section];
-
         for (NSInteger row = 0; row < rowCount; row++) {
             NSIndexPath* indexPath = [NSIndexPath indexPathForItem:row inSection:section];
-
             if (block) {
                 block(indexPath, &stop);
             }
-
             if (stop) {
                 return;
             }
@@ -25,7 +22,7 @@ - (void)wmf_enumerateIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL
     }
 }
 
-- (void)wmf_enumerateVisibleIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPath, BOOL* stop))block {
+- (void)wmf_enumerateVisibleIndexPathsUsingBlock:(WMFIndexPathEnumerator)block {
     [self.indexPathsForVisibleItems enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL* stop) {
         if (block) {
             block(obj, stop);
@@ -33,6 +30,15 @@ - (void)wmf_enumerateVisibleIndexPathsUsingBlock:(void (^)(NSIndexPath* indexPat
     }];
 }
 
+- (void)wmf_enumerateVisibleCellsUsingBlock:(WMFCellEnumerator)block {
+    [self wmf_enumerateVisibleIndexPathsUsingBlock:^(NSIndexPath* path, BOOL* stop) {
+        id cell = [self cellForItemAtIndexPath:path];
+        if (cell) {
+            block(cell, path, stop);
+        }
+    }];
+}
+
 /**
  *  Like other UIKit methods, the completion isn't called if you pass animated = false.
  *  This method ensures the completion block is always called.
@@ -50,3 +56,5 @@ - (void)wmf_setCollectionViewLayout:(UICollectionViewLayout*)layout animated:(BO
 }
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h
index 8840feacc0c..62fd3822416 100644
--- a/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h
+++ b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.h
@@ -3,10 +3,6 @@
 
 @interface UIStoryboard (WMFExtensions)
 
-+ (UIStoryboard*)wmf_appRootStoryBoard;
-
-+ (UIStoryboard*)wmf_storyBoardForViewControllerClass:(Class)viewControllerClass;
-
-- (id)wmf_instantiateViewControllerWithIdentifierFromClass:(Class)viewControllerClass;
++ (instancetype)wmf_appRootStoryBoard;
 
 @end
diff --git a/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m
index e603fdc8b22..8973fe4557c 100644
--- a/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m
+++ b/Wikipedia/UI-V5/UIStoryboard+WMFExtensions.m
@@ -1,22 +1,13 @@
 
 #import "UIStoryboard+WMFExtensions.h"
+#import "UIViewController+WMFStoryboardUtilities.h"
 
-NSString* const WMFDefaultStoryBoardName = @"iPhone_Root";
+static NSString* const WMFDefaultStoryBoardName = @"iPhone_Root";
 
 @implementation UIStoryboard (WMFExtensions)
 
-+ (UIStoryboard*)wmf_appRootStoryBoard {
-    return [UIStoryboard storyboardWithName:WMFDefaultStoryBoardName bundle:nil];
-}
-
-+ (UIStoryboard*)wmf_storyBoardForViewControllerClass:(Class)viewControllerClass {
-    id sb = [UIStoryboard storyboardWithName:NSStringFromClass(viewControllerClass) bundle:nil];
-    NSAssert(sb, @"Instantiating storyboard %@ returned nil!", NSStringFromClass(viewControllerClass));
-    return sb;
-}
-
-- (id)wmf_instantiateViewControllerWithIdentifierFromClass:(Class)viewControllerClass {
-    return [self instantiateViewControllerWithIdentifier:NSStringFromClass(viewControllerClass)];
++ (instancetype)wmf_appRootStoryBoard {
+    return [self storyboardWithName:WMFDefaultStoryBoardName bundle:nil];
 }
 
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleFetcher.m b/Wikipedia/UI-V5/WMFArticleFetcher.m
index 727e9bedf7f..1b80f700292 100644
--- a/Wikipedia/UI-V5/WMFArticleFetcher.m
+++ b/Wikipedia/UI-V5/WMFArticleFetcher.m
@@ -7,7 +7,6 @@
 
 NS_ASSUME_NONNULL_BEGIN
 
-
 @interface WMFArticleFetcher ()
 
 @property (nonatomic, strong, readwrite) MWKDataStore* dataStore;
@@ -39,13 +38,14 @@ - (ArticleFetcher*)fetcher {
 
 - (AnyPromise*)fetchArticleForPageTitle:(MWKTitle*)pageTitle progress:(WMFProgressHandler __nullable)progress {
     return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {
-        AFHTTPRequestOperation* operation = [self.fetcher fetchSectionsForTitle:pageTitle
-                                                                    inDataStore:self.dataStore
-                                                                    withManager:self.operationManager
-                                                                  progressBlock:progress
-                                                                completionBlock:resolve
-                                                                     errorBlock:resolve];
-        if (operation == nil) {
+        AFHTTPRequestOperation* operation =
+            [self.fetcher fetchSectionsForTitle:pageTitle
+                                    inDataStore:self.dataStore
+                                    withManager:self.operationManager
+                                  progressBlock:progress
+                                completionBlock:resolve
+                                     errorBlock:resolve];
+        if (!operation) {
             resolve([NSError wmf_errorWithType:WMFErrorTypeStringMissingParameter userInfo:nil]);
         }
     }];
diff --git a/Wikipedia/UI-V5/WMFArticleHeaderImageGalleryViewController.h b/Wikipedia/UI-V5/WMFArticleHeaderImageGalleryViewController.h
new file mode 100644
index 00000000000..ba24ed582e8
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticleHeaderImageGalleryViewController.h
@@ -0,0 +1,33 @@
+#import <Foundation/Foundation.h>
+#import "WMFPageCollectionViewController.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@class MWKArticle;
+
+@class WMFArticleHeaderImageGalleryViewController;
+@protocol WMFArticleHeaderImageGalleryViewControllerDelegate <NSObject>
+
+- (void)headerImageGallery:(WMFArticleHeaderImageGalleryViewController*)gallery didSelectImageAtIndex:(NSUInteger)index;
+
+@end
+
+@interface WMFArticleHeaderImageGalleryViewController : WMFPageCollectionViewController
+
+@property (nonatomic, weak) id<WMFArticleHeaderImageGalleryViewControllerDelegate> delegate;
+
+/// URLs of images that should be displayed in the gallery.
+@property (nonatomic, copy, null_resettable) NSArray* imageURLs;
+
+/**
+ * Reset the contents of the receiver's `imageURLs` array to contain the images from the specified article.
+ *
+ * If the article is not cached, it will only populate the gallery with either the lead or thumbnail image URL.
+ *
+ * @param article The article whose images should populate the gallery.
+ */
+- (void)setImageURLsFromArticle:(MWKArticle*)article;
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/WMFArticleHeaderImageGalleryViewController.m b/Wikipedia/UI-V5/WMFArticleHeaderImageGalleryViewController.m
new file mode 100644
index 00000000000..0e07089f361
--- /dev/null
+++ b/Wikipedia/UI-V5/WMFArticleHeaderImageGalleryViewController.m
@@ -0,0 +1,96 @@
+//
+//  WMFHeaderGalleryDataSource.m
+//  Wikipedia
+//
+//  Created by Brian Gerstle on 7/17/15.
+//  Copyright (c) 2015 Wikimedia Foundation. All rights reserved.
+//
+
+#import "WMFArticleHeaderImageGalleryViewController.h"
+
+// Utils
+#import "Wikipedia-Swift.h"
+#import "PromiseKit.h"
+#import "NSArray+WMFLayoutDirectionUtilities.h"
+
+// View
+#import "WMFImageCollectionViewCell.h"
+#import "UIView+WMFDefaultNib.h"
+
+// Model
+#import "MWKArticle.h"
+#import "MWKImage.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@implementation WMFArticleHeaderImageGalleryViewController
+
+- (void)setImageURLs:(NSArray* __nullable)imageURLs {
+    if (WMF_EQUAL(_imageURLs, isEqualToArray:, imageURLs)) {
+        return;
+    }
+    _imageURLs       = [(imageURLs ? : @[]) wmf_reverseArrayIfApplicationIsRTL];
+    self.currentPage = [_imageURLs wmf_startingIndexForApplicationLayoutDirection];
+    if ([self isViewLoaded]) {
+        [self.collectionView reloadData];
+    }
+}
+
+- (void)setImageURLsFromArticle:(MWKArticle* __nonnull)article {
+    if (article.isCached) {
+        [self setImageURLsFromCachedArticle:article];
+    } else {
+        [self setImageURLsFromUncachedArticle:article];
+    }
+}
+
+- (void)setImageURLsFromCachedArticle:(MWKArticle* __nonnull)article {
+    NSParameterAssert(article.isCached);
+    self.imageURLs = [article.images.uniqueLargestVariantSourceURLs wmf_reverseArrayIfApplicationIsRTL];
+}
+
+- (void)setImageURLsFromUncachedArticle:(MWKArticle* __nonnull)article {
+    NSParameterAssert(!article.isCached);
+    NSURL* url = [NSURL wmf_optionalURLWithString:article.imageURL];
+    if (url) {
+        self.imageURLs = [NSMutableArray arrayWithObject:url];
+    } else if ((url = [NSURL wmf_optionalURLWithString:article.thumbnailURL])) {
+        self.imageURLs = [NSMutableArray arrayWithObject:url];
+    } else {
+        self.imageURLs = nil;
+    }
+}
+
+#pragma mark - UICollectionView Protocols
+
+- (void)collectionView:(UICollectionView*)collectionView didSelectItemAtIndexPath:(NSIndexPath*)indexPath {
+    [self.delegate headerImageGallery:self didSelectImageAtIndex:indexPath.item];
+}
+
+- (UICollectionViewCell*)collectionView:(UICollectionView*)collectionView cellForItemAtIndexPath:(NSIndexPath*)indexPath {
+    WMFImageCollectionViewCell* cell = (WMFImageCollectionViewCell*)
+                                       [collectionView dequeueReusableCellWithReuseIdentifier:[WMFImageCollectionViewCell wmf_nibName]
+                                                                                 forIndexPath:indexPath];
+    @weakify(self);
+    [[WMFImageController sharedInstance] fetchImageWithURL:self.imageURLs[indexPath.item]]
+    .then(^(UIImage* image) {
+        @strongify(self);
+        [self setImage:image forCellAtIndexPath:indexPath];
+    });
+    return cell;
+}
+
+- (void)setImage:(UIImage*)image forCellAtIndexPath:(NSIndexPath*)path {
+    WMFImageCollectionViewCell* cell = (WMFImageCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:path];
+    if (cell) {
+        cell.imageView.image = image;
+    }
+}
+
+- (NSInteger)collectionView:(UICollectionView*)collectionView numberOfItemsInSection:(NSInteger)section {
+    return self.imageURLs.count;
+}
+
+@end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
index 3922164e686..a1c57615817 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.h
@@ -26,5 +26,4 @@ typedef NS_ENUM (NSUInteger, WMFArticleListMode) {
 
 @end
 
-
-NS_ASSUME_NONNULL_END
\ No newline at end of file
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
index 966d2810878..6ec64105f5e 100644
--- a/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleListCollectionViewController.m
@@ -1,11 +1,12 @@
-
 #import "WMFArticleListCollectionViewController.h"
 #import "UICollectionView+WMFExtensions.h"
 #import "WMFArticleViewControllerContainerCell.h"
 #import "WMFArticleViewController.h"
 
+#import "UICollectionView+WMFExtensions.h"
 #import "TGLStackedLayout.h"
 #import "WMFOffScreenFlowLayout.h"
+#import "UIView+WMFDefaultNib.h"
 
 #import "WMFArticleListTranstion.h"
 
@@ -112,8 +113,8 @@ - (WMFOffScreenFlowLayout*)offScreenLayout {
 }
 
 - (void)refreshVisibleCells {
-    [[self.collectionView indexPathsForVisibleItems] enumerateObjectsUsingBlock:^(NSIndexPath* obj, NSUInteger idx, BOOL* stop) {
-        WMFArticleViewControllerContainerCell* cell = (id)[self.collectionView cellForItemAtIndexPath:obj];
+    [self.collectionView wmf_enumerateVisibleCellsUsingBlock:
+     ^(WMFArticleViewControllerContainerCell* cell, NSIndexPath* path, BOOL* _) {
         [cell.viewController updateUI];
     }];
 }
@@ -150,7 +151,8 @@ - (NSUInteger)supportedInterfaceOrientations {
 }
 
 // iOS 7 Rotation Support
-- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration {
+- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation
+                                duration:(NSTimeInterval)duration {
     [UIView animateWithDuration:duration animations:^{
         [self updateCellSizeBasedOnViewFrame];
     }];
@@ -159,11 +161,11 @@ - (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrie
 }
 
 // iOS 8+ Rotation Support
-- (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator {
-    [coordinator animateAlongsideTransition:^(id < UIViewControllerTransitionCoordinatorContext > context)
-    {
+- (void)viewWillTransitionToSize:(CGSize)size
+       withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator {
+    [coordinator animateAlongsideTransition:^(id < UIViewControllerTransitionCoordinatorContext > context) {
         [self updateCellSizeBasedOnViewFrame];
-    }                            completion:NULL];
+    } completion:NULL];
 
     [super viewWillTransitionToSize:size withTransitionCoordinator:coordinator];
 }
@@ -181,11 +183,15 @@ - (NSInteger)collectionView:(UICollectionView*)collectionView numberOfItemsInSec
     return [self.dataSource articleCount];
 }
 
-- (UICollectionViewCell*)collectionView:(UICollectionView*)collectionView cellForItemAtIndexPath:(NSIndexPath*)indexPath {
-    WMFArticleViewControllerContainerCell* cell = [collectionView dequeueReusableCellWithReuseIdentifier:NSStringFromClass([WMFArticleViewControllerContainerCell class]) forIndexPath:indexPath];
+- (UICollectionViewCell*)collectionView:(UICollectionView*)collectionView
+                 cellForItemAtIndexPath:(NSIndexPath*)indexPath {
+    WMFArticleViewControllerContainerCell* cell =
+        [collectionView dequeueReusableCellWithReuseIdentifier:[WMFArticleViewControllerContainerCell wmf_nibName]
+                                                  forIndexPath:indexPath];
 
     if (cell.viewController == nil) {
-        WMFArticleViewController* vc = [WMFArticleViewController articleViewControllerWithDataStore:self.dataStore savedPages:self.savedPages];
+        WMFArticleViewController* vc =
+            [WMFArticleViewController articleViewControllerWithDataStore:self.dataStore savedPages:self.savedPages];
         [vc setMode:WMFArticleControllerModeList animated:NO];
         [cell setViewControllerAndAddViewToContentView:vc];
     }
@@ -198,25 +204,34 @@ - (UICollectionViewCell*)collectionView:(UICollectionView*)collectionView cellFo
 
 #pragma mark - <UICollectionViewDelegate>
 
-- (void)collectionView:(UICollectionView*)collectionView willDisplayCell:(UICollectionViewCell*)cell forItemAtIndexPath:(NSIndexPath*)indexPath {
+- (void)collectionView:(UICollectionView*)collectionView
+       willDisplayCell:(UICollectionViewCell*)cell
+    forItemAtIndexPath:(NSIndexPath*)indexPath {
     WMFArticleViewControllerContainerCell* containerCell = (id)cell;
     [containerCell.viewController didMoveToParentViewController:self];
 }
 
-- (void)collectionView:(UICollectionView*)collectionView didEndDisplayingCell:(UICollectionViewCell*)cell forItemAtIndexPath:(NSIndexPath*)indexPath {
-    [[UIApplication sharedApplication] sendAction:@selector(respondsToSelector:) to:nil from:nil forEvent:nil];
+- (void)  collectionView:(UICollectionView*)collectionView
+    didEndDisplayingCell:(UICollectionViewCell*)cell
+      forItemAtIndexPath:(NSIndexPath*)indexPath {
     WMFArticleViewControllerContainerCell* containerCell = (id)cell;
     [containerCell.viewController willMoveToParentViewController:nil];
     [containerCell.viewController removeFromParentViewController];
 }
 
 - (void)collectionView:(UICollectionView*)collectionView didSelectItemAtIndexPath:(NSIndexPath*)indexPath {
-    WMFArticleViewControllerContainerCell* cell = (WMFArticleViewControllerContainerCell*)[collectionView cellForItemAtIndexPath:indexPath];
+    WMFArticleViewControllerContainerCell* cell =
+        (WMFArticleViewControllerContainerCell*)[collectionView cellForItemAtIndexPath:indexPath];
 
-    WMFArticleViewController* vc = [WMFArticleViewController articleViewControllerWithDataStore:self.dataStore savedPages:self.savedPages];
+    WMFArticleViewController* vc = [WMFArticleViewController articleViewControllerWithDataStore:self.dataStore
+                                                                                     savedPages:self.savedPages];
     vc.article = cell.viewController.article;
 
-    self.cardTransition                             = [[WMFArticleListTranstion alloc] initWithPresentingViewController:self presentedViewController:vc contentScrollView:vc.tableView];
+    self.cardTransition =
+        [[WMFArticleListTranstion alloc] initWithPresentingViewController:self
+                                                  presentedViewController:vc
+                                                        contentScrollView:vc.tableView];
+
     self.cardTransition.nonInteractiveDuration      = 0.5;
     self.cardTransition.presentCardOffset           = vc.tableView.contentInset.top;
     self.cardTransition.offsetOfNextOverlappingCard = self.stackedLayout.topReveal;
@@ -254,7 +269,10 @@ - (void)stackLayout:(TGLStackedLayout*)layout deleteItemAtIndexPath:(NSIndexPath
 #pragma mark - DataSource KVO
 
 - (void)observeDataSource {
-    [self.KVOController observe:_dataSource keyPath:WMF_SAFE_KEYPATH(_dataSource, articles) options:0 block:^(id observer, id object, NSDictionary* change) {
+    [self.KVOController observe:_dataSource
+                        keyPath:WMF_SAFE_KEYPATH(_dataSource, articles)
+                        options:0
+                          block:^(id observer, id object, NSDictionary* change) {
         NSKeyValueChange changeKind = [change[NSKeyValueChangeKindKey] unsignedIntegerValue];
         NSArray* indexPaths = indexPathsWithIndexSet(change[NSKeyValueChangeIndexesKey], 0);
         [self updateCellsAtIndexPaths:indexPaths change:changeKind];
diff --git a/Wikipedia/UI-V5/WMFArticleTableHeaderView.h b/Wikipedia/UI-V5/WMFArticleTableHeaderView.h
index 970d39e8c35..1204c1380f0 100644
--- a/Wikipedia/UI-V5/WMFArticleTableHeaderView.h
+++ b/Wikipedia/UI-V5/WMFArticleTableHeaderView.h
@@ -5,10 +5,9 @@
 
 @interface WMFArticleTableHeaderView : UIView
 
-@property (strong, nonatomic) IBOutlet UIButton* readButton;
-@property (strong, nonatomic) IBOutlet UIButton* saveButton;
-@property (strong, nonatomic) IBOutlet UILabel* titleLabel;
-@property (strong, nonatomic) IBOutlet UILabel* descriptionLabel;
-@property (strong, nonatomic) IBOutlet UIImageView* image;
+@property (weak, nonatomic) IBOutlet UIButton* readButton;
+@property (weak, nonatomic) IBOutlet UIButton* saveButton;
+@property (weak, nonatomic) IBOutlet UILabel* titleLabel;
+@property (weak, nonatomic) IBOutlet UILabel* descriptionLabel;
 
 @end
diff --git a/Wikipedia/UI-V5/WMFArticleTableHeaderView.m b/Wikipedia/UI-V5/WMFArticleTableHeaderView.m
index da96a19125f..859cdea4475 100644
--- a/Wikipedia/UI-V5/WMFArticleTableHeaderView.m
+++ b/Wikipedia/UI-V5/WMFArticleTableHeaderView.m
@@ -12,4 +12,3 @@ - (void)awakeFromNib {
 }
 
 @end
-
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.m b/Wikipedia/UI-V5/WMFArticleViewController.m
index df22d8f923c..e23487858fe 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.m
+++ b/Wikipedia/UI-V5/WMFArticleViewController.m
@@ -1,24 +1,34 @@
 #import "WMFArticleViewController.h"
+
+// Frameworks
 #import <Masonry/Masonry.h>
+#import <BlocksKit/BlocksKit+UIKit.h>
 #import "Wikipedia-Swift.h"
 #import "PromiseKit.h"
-#import "UIButton+WMFButton.h"
+
+
+// Models & Controllers
 #import "WebViewController.h"
-#import "UIStoryboard+WMFExtensions.h"
-#import "UIViewController+WMFStoryboardUtilities.h"
+#import "WMFArticleHeaderImageGalleryViewController.h"
+#import "WMFArticleFetcher.h"
+#import "WMFSearchFetcher.h"
+#import "WMFSearchResults.h"
+#import "WMFImageGalleryViewController.h"
 
+// Views
 #import "WMFArticleTableHeaderView.h"
 #import "WMFArticleSectionCell.h"
 #import "PaddedLabel.h"
 #import "WMFArticleSectionHeaderCell.h"
 #import "WMFArticleExtractCell.h"
-#import "NSString+Extras.h"
+#import "WMFArticleReadMoreCell.h"
 
+// Categories
+#import "NSString+Extras.h"
+#import "UIButton+WMFButton.h"
+#import "UIStoryboard+WMFExtensions.h"
+#import "UIViewController+WMFStoryboardUtilities.h"
 #import "MWKArticle+WMFSharing.h"
-#import "WMFArticleFetcher.h"
-#import "WMFSearchFetcher.h"
-#import "WMFSearchResults.h"
-#import "WMFArticleReadMoreCell.h"
 #import "UIView+WMFDefaultNib.h"
 
 typedef NS_ENUM (NSInteger, WMFArticleSectionType) {
@@ -29,7 +39,14 @@ typedef NS_ENUM (NSInteger, WMFArticleSectionType) {
 
 NS_ASSUME_NONNULL_BEGIN
 
-@interface WMFArticleViewController () <UITableViewDataSource, UITableViewDelegate>
+@interface WMFArticleViewController ()
+<UITableViewDataSource,
+ UITableViewDelegate,
+ WMFArticleHeaderImageGalleryViewControllerDelegate,
+ WMFImageGalleryViewControllerDelegate>
+
+@property (nonatomic, weak) IBOutlet UIView* galleryContainerView;
+@property (nonatomic, weak) IBOutlet WMFArticleTableHeaderView* headerView;
 
 @property (nonatomic, strong, readwrite) MWKDataStore* dataStore;
 @property (nonatomic, strong, readwrite) MWKSavedPageList* savedPages;
@@ -37,43 +54,46 @@ @interface WMFArticleViewController () <UITableViewDataSource, UITableViewDelega
 
 @property (nonatomic, strong) WMFArticleFetcher* articleFetcher;
 
+/// Promise representing the request for the current article's data.
+@property (nonatomic, weak, nullable) AnyPromise* articleRequest;
+
 @property (nonatomic, strong) WMFSearchFetcher* readMoreFetcher;
 @property (nonatomic, strong) WMFSearchResults* readMoreResults;
 
+@property (nonatomic, strong) WMFArticleHeaderImageGalleryViewController* headerGalleryViewController;
+@property (nonatomic, weak) IBOutlet UITapGestureRecognizer* expandGalleryTapRecognizer;
+
 @end
 
 @implementation WMFArticleViewController
 
 + (instancetype)articleViewControllerWithDataStore:(MWKDataStore*)dataStore savedPages:(MWKSavedPageList*)savedPages {
-    WMFArticleViewController* vc = (id)[[UIStoryboard wmf_storyBoardForViewControllerClass:[WMFArticleViewController class]] instantiateInitialViewController];
+    WMFArticleViewController* vc = [self wmf_initialViewControllerFromClassStoryboard];
     vc.dataStore  = dataStore;
     vc.savedPages = savedPages;
     return vc;
 }
 
-#pragma - Tear Down
+#pragma mark - Accessors
 
-- (void)dealloc {
-    [self unobserveArticleUpdates];
+- (void)setHeaderGalleryViewController:(WMFArticleHeaderImageGalleryViewController* __nonnull)galleryViewController {
+    _headerGalleryViewController = galleryViewController;
+    [_headerGalleryViewController setImageURLsFromArticle:self.article];
 }
 
-#pragma mark - Accessors
-
 - (void)setArticle:(MWKArticle* __nullable)article {
-    if ([_article isEqual:article]) {
+    if (WMF_EQUAL(_article, isEqualToArticle:, article)) {
         return;
     }
 
     [self unobserveArticleUpdates];
     [[WMFImageController sharedInstance] cancelFetchForURL:[NSURL wmf_optionalURLWithString:[_article bestThumbnailImageURL]]];
 
-    _article = article;
+    // TODO cancel
+    self.articleRequest = nil;
 
-    DDLogVerbose(@"\n");
-    DDLogVerbose(@"%@", article.title.text);
-    DDLogVerbose(@"%@", article.entityDescription); //not saved? only seeing it in search results not saved panels
-    DDLogVerbose(@"%@", article.thumbnailURL);
-    DDLogVerbose(@"%lu", [article.sections count]);
+    _article = article;
+    [self.headerGalleryViewController setImageURLsFromArticle:article];
 
     [self updateUI];
     [self observeAndFetchArticleIfNeeded];
@@ -94,10 +114,6 @@ - (BOOL)isSaved {
     return [self.savedPages isSaved:self.article.title];
 }
 
-- (WMFArticleTableHeaderView*)headerView {
-    return (WMFArticleTableHeaderView*)self.tableView.tableHeaderView;
-}
-
 - (UIButton*)saveButton {
     return [[self headerView] saveButton];
 }
@@ -157,14 +173,21 @@ - (void)fetchArticle {
 }
 
 - (void)fetchArticleForTitle:(MWKTitle*)title {
-    [self.articleFetcher fetchArticleForPageTitle:title progress:nil].then(^(MWKArticle* article) {
-        // re-entry, should result in being article being observed
+    @weakify(self)
+    self.articleRequest = [self.articleFetcher fetchArticleForPageTitle:title progress:nil];
+
+    self.articleRequest.then(^(MWKArticle* article){
+        @strongify(self)
+        [self.headerGalleryViewController setImageURLsFromArticle : article];
         self.article = article;
-    }).catch(^(NSError* error) {
+    })
+    .catch(^(NSError* error){
+        @strongify(self)
         if ([error wmf_isWMFErrorOfType:WMFErrorTypeRedirected]) {
             [self fetchArticleForTitle:[[error userInfo] wmf_redirectTitle]];
-        } else {
-            NSLog(@"Article Fetch Error: %@", [error localizedDescription]);
+        } else if (!self.presentingViewController) {
+            // only do error handling if not presenting gallery
+            DDLogError(@"Article Fetch Error: %@", [error localizedDescription]);
         }
     });
 }
@@ -174,7 +197,8 @@ - (void)fetchReadMoreForTitle:(MWKTitle*)title {
     // card collection view controller sets it a lot as you scroll through the cards. "fetchReadMoreForTitle:" however
     // is only called when the card is expanded, so self.readMoreFetcher is set here as well so it's not needlessly
     // repeatedly set.
-    self.readMoreFetcher                  = [[WMFSearchFetcher alloc] initWithSearchSite:self.article.title.site dataStore:self.dataStore];
+    self.readMoreFetcher =
+        [[WMFSearchFetcher alloc] initWithSearchSite:self.article.title.site dataStore:self.dataStore];
     self.readMoreFetcher.maxSearchResults = 3;
 
     @weakify(self)
@@ -213,18 +237,11 @@ - (void)updateHeaderView {
 //      see old LeadImageTitleAttributedString.m for example from old native lead image
     headerView.titleLabel.text       = [self.article.title.text wmf_stringByRemovingHTML];
     headerView.descriptionLabel.text = [self.article.entityDescription wmf_stringByCapitalizingFirstCharacter];
-
-    [[WMFImageController sharedInstance] fetchImageWithURL:[NSURL wmf_optionalURLWithString:[self.article bestThumbnailImageURL]]].then(^(UIImage* image){
-        headerView.image.image = image;
-    }).catch(^(NSError* error){
-        NSLog(@"Image Fetch Error: %@", [error localizedDescription]);
-    });
 }
 
 - (void)clearHeaderView {
     WMFArticleTableHeaderView* headerView = [self headerView];
     headerView.titleLabel.attributedText = nil;
-    headerView.image.image               = [UIImage imageNamed:@"lead-default"];
 }
 
 - (void)updateSavedButtonState {
@@ -245,6 +262,7 @@ - (void)updateUIForMode:(WMFArticleControllerMode)mode animated:(BOOL)animated {
             break;
         }
     }
+    self.headerGalleryViewController.view.userInteractionEnabled = mode == WMFArticleControllerModeNormal;
 }
 
 #pragma mark - Actions
@@ -278,14 +296,30 @@ - (void)configureForDynamicCellHeight {
 
 #pragma mark - UIViewController
 
+- (BOOL)prefersStatusBarHidden {
+    return YES;
+}
+
+- (void)prepareForSegue:(UIStoryboardSegue*)segue sender:(id)sender {
+    [super prepareForSegue:segue sender:sender];
+    if ([segue.destinationViewController isKindOfClass:[WMFArticleHeaderImageGalleryViewController class]]) {
+        self.headerGalleryViewController          = segue.destinationViewController;
+        self.headerGalleryViewController.delegate = self;
+    }
+}
+
 - (void)viewDidLoad {
     [super viewDidLoad];
 
+    UICollectionViewFlowLayout* galleryLayout = (UICollectionViewFlowLayout*)_headerGalleryViewController.collectionViewLayout;
+    galleryLayout.minimumInteritemSpacing = 0;
+    galleryLayout.minimumLineSpacing      = 0;
+    galleryLayout.scrollDirection         = UICollectionViewScrollDirectionHorizontal;
+
     [self clearHeaderView];
     [self configureForDynamicCellHeight];
     [self updateUI];
     [self updateUIForMode:self.mode animated:NO];
-    [self observeArticleUpdates];
 }
 
 - (void)viewWillAppear:(BOOL)animated {
@@ -354,11 +388,13 @@ - (WMFArticleReadMoreCell*)readMoreCellAtIndexPath:(NSIndexPath*)indexPath {
     [cell setNeedsDisplay];
     [cell layoutIfNeeded];
 
-    [[WMFImageController sharedInstance] fetchImageWithURL:[NSURL wmf_optionalURLWithString:readMoreArticle.thumbnailURL]].then(^(UIImage* image){
+    NSURL* url = [NSURL wmf_optionalURLWithString:readMoreArticle.thumbnailURL];
+    [[WMFImageController sharedInstance] fetchImageWithURL:url].then(^(UIImage* image){
         cell.thumbnailImageView.image = image;
     }).catch(^(NSError* error){
         NSLog(@"Image Fetch Error: %@", [error localizedDescription]);
     });
+
     return cell;
 }
 
@@ -400,16 +436,48 @@ - (void)presentArticleScrolledToSectionForIndexPath:(NSIndexPath*)indexPath {
 - (MWKTitle*)titleForSelectedIndexPath:(NSIndexPath*)indexPath {
     switch ((WMFArticleSectionType)indexPath.section) {
         case WMFArticleSectionTypeSummary:
-            return [[MWKTitle alloc] initWithSite:self.article.title.site normalizedTitle:self.article.title.text fragment:@""];
+            return [[MWKTitle alloc] initWithSite:self.article.title.site
+                                  normalizedTitle:self.article.title.text
+                                         fragment:@""];
         case WMFArticleSectionTypeTOC:
-            return [[MWKTitle alloc] initWithSite:self.article.title.site normalizedTitle:self.article.title.text fragment:self.article.sections[indexPath.row + 1].anchor];
+            return [[MWKTitle alloc] initWithSite:self.article.title.site
+                                  normalizedTitle:self.article.title.text
+                                         fragment:self.article.sections[indexPath.row + 1].anchor];
         case WMFArticleSectionTypeReadMore: {
             MWKArticle* readMoreArticle = ((MWKArticle*)self.readMoreResults.articles[indexPath.row]);
-            return [[MWKTitle alloc] initWithSite:readMoreArticle.site normalizedTitle:readMoreArticle.title.text fragment:@""];
+            return [[MWKTitle alloc] initWithSite:readMoreArticle.site
+                                  normalizedTitle:readMoreArticle.title.text
+                                         fragment:@""];
         }
     }
 }
 
+#pragma mark - WMFArticleHeadermageGalleryViewControllerDelegate
+
+- (void)headerImageGallery:(WMFArticleHeaderImageGalleryViewController* __nonnull)gallery
+     didSelectImageAtIndex:(NSUInteger)index {
+    NSParameterAssert(![self.presentingViewController isKindOfClass:[WMFImageGalleryViewController class]]);
+    WMFImageGalleryViewController* detailGallery = [[WMFImageGalleryViewController alloc] initWithArticle:nil];
+    detailGallery.delegate = self;
+    if (self.article.isCached) {
+        detailGallery.article     = self.article;
+        detailGallery.currentPage = index;
+    } else {
+        if (!self.articleRequest) {
+            [self fetchArticle];
+        }
+        [detailGallery setArticleWithPromise:self.articleRequest];
+    }
+    [self presentViewController:detailGallery animated:YES completion:nil];
+}
+
+#pragma mark - WMFImageGalleryViewControllerDelegate
+
+- (void)willDismissGalleryController:(WMFImageGalleryViewController* __nonnull)gallery {
+    self.headerGalleryViewController.currentPage = gallery.currentPage;
+    [self dismissViewControllerAnimated:YES completion:nil];
+}
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/WMFArticleViewController.storyboard b/Wikipedia/UI-V5/WMFArticleViewController.storyboard
index c30aed55cbf..771694fd00b 100644
--- a/Wikipedia/UI-V5/WMFArticleViewController.storyboard
+++ b/Wikipedia/UI-V5/WMFArticleViewController.storyboard
@@ -20,24 +20,19 @@
                             <rect key="frame" x="0.0" y="0.0" width="600" height="200"/>
                             <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMaxY="YES"/>
                             <subviews>
-                                <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="Plo-DT-ZEo">
-                                    <rect key="frame" x="0.0" y="0.0" width="600" height="1"/>
-                                    <animations/>
-                                    <color key="backgroundColor" white="0.0" alpha="1" colorSpace="calibratedWhite"/>
-                                    <constraints>
-                                        <constraint firstAttribute="height" constant="1" id="JXZ-fH-w96"/>
-                                    </constraints>
-                                </view>
-                                <imageView userInteractionEnabled="NO" contentMode="scaleAspectFill" horizontalHuggingPriority="251" verticalHuggingPriority="251" translatesAutoresizingMaskIntoConstraints="NO" id="mVV-Qc-NtZ">
+                                <containerView opaque="NO" contentMode="scaleToFill" misplaced="YES" translatesAutoresizingMaskIntoConstraints="NO" id="N3F-xg-lcP">
                                     <rect key="frame" x="0.0" y="0.0" width="600" height="200"/>
-                                    <animations/>
-                                </imageView>
-                                <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="VfG-2f-on3" userLabel="Gray overlay">
+                                    <connections>
+                                        <segue destination="7Or-9F-7Br" kind="embed" id="HdJ-OF-Rfg"/>
+                                    </connections>
+                                </containerView>
+                                <view opaque="NO" userInteractionEnabled="NO" contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="VfG-2f-on3" userLabel="Gray overlay">
                                     <rect key="frame" x="0.0" y="0.0" width="600" height="200"/>
                                     <animations/>
                                     <color key="backgroundColor" red="0.0" green="0.0" blue="0.0" alpha="0.20000000000000001" colorSpace="calibratedRGB"/>
+                                    <gestureRecognizers/>
                                 </view>
-                                <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" horizontalCompressionResistancePriority="751" text="" lineBreakMode="wordWrap" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="Pfp-fe-IJA" userLabel="Title Label">
+                                <label opaque="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" horizontalCompressionResistancePriority="751" text="" lineBreakMode="wordWrap" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="Pfp-fe-IJA" userLabel="Title Label">
                                     <rect key="frame" x="10" y="16" width="542" height="60"/>
                                     <animations/>
                                     <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="calibratedWhite"/>
@@ -48,7 +43,7 @@
                                     <color key="textColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
                                     <nil key="highlightedColor"/>
                                 </label>
-                                <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="" lineBreakMode="wordWrap" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="86U-jy-8DP" userLabel="Description Label">
+                                <label opaque="NO" contentMode="left" horizontalHuggingPriority="251" verticalHuggingPriority="251" text="" lineBreakMode="wordWrap" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="86U-jy-8DP" userLabel="Description Label">
                                     <rect key="frame" x="10" y="86" width="580" height="40"/>
                                     <constraints>
                                         <constraint firstAttribute="height" constant="40" placeholder="YES" id="XZZ-TX-U51"/>
@@ -69,7 +64,7 @@
                                         <action selector="readButtonTapped:" destination="Btv-Tg-s8D" eventType="touchUpInside" id="gMV-xS-hg3"/>
                                     </connections>
                                 </button>
-                                <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="7Lr-kU-lXN">
+                                <button opaque="NO" contentMode="scaleToFill" contentHorizontalAlignment="center" contentVerticalAlignment="center" lineBreakMode="middleTruncation" translatesAutoresizingMaskIntoConstraints="NO" id="7Lr-kU-lXN" userLabel="Save Button">
                                     <rect key="frame" x="560" y="16" width="30" height="30"/>
                                     <animations/>
                                     <constraints>
@@ -82,33 +77,29 @@
                                 </button>
                             </subviews>
                             <animations/>
-                            <color key="backgroundColor" white="1" alpha="1" colorSpace="calibratedWhite"/>
+                            <color key="backgroundColor" white="0.0" alpha="1" colorSpace="calibratedWhite"/>
                             <constraints>
                                 <constraint firstAttribute="trailing" secondItem="86U-jy-8DP" secondAttribute="trailing" constant="10" id="5T0-hY-Alv"/>
                                 <constraint firstItem="86U-jy-8DP" firstAttribute="leading" secondItem="fN6-15-6k9" secondAttribute="leading" constant="10" id="693-Xk-pZj"/>
                                 <constraint firstItem="86U-jy-8DP" firstAttribute="top" secondItem="Pfp-fe-IJA" secondAttribute="bottom" constant="10" id="8B4-ss-UOe"/>
                                 <constraint firstItem="VfG-2f-on3" firstAttribute="leading" secondItem="fN6-15-6k9" secondAttribute="leading" id="AYX-u0-Ejg"/>
                                 <constraint firstAttribute="trailing" secondItem="VfG-2f-on3" secondAttribute="trailing" id="Aze-dY-4tH"/>
-                                <constraint firstItem="Plo-DT-ZEo" firstAttribute="top" secondItem="fN6-15-6k9" secondAttribute="top" id="Bgk-No-Fj0"/>
+                                <constraint firstAttribute="bottom" secondItem="N3F-xg-lcP" secondAttribute="bottom" id="CD2-kI-NCt"/>
                                 <constraint firstItem="Qnl-ta-cXb" firstAttribute="top" secondItem="86U-jy-8DP" secondAttribute="bottom" constant="10" id="Efc-az-cHC"/>
-                                <constraint firstAttribute="trailing" secondItem="mVV-Qc-NtZ" secondAttribute="trailing" id="IT5-hu-Tg1"/>
                                 <constraint firstItem="Pfp-fe-IJA" firstAttribute="leading" secondItem="fN6-15-6k9" secondAttribute="leading" constant="10" id="JQ5-YK-uKU"/>
-                                <constraint firstItem="mVV-Qc-NtZ" firstAttribute="top" secondItem="fN6-15-6k9" secondAttribute="top" id="NPq-Xj-qwq"/>
+                                <constraint firstItem="N3F-xg-lcP" firstAttribute="top" secondItem="fN6-15-6k9" secondAttribute="top" id="Mpl-Ow-U0n"/>
                                 <constraint firstItem="Pfp-fe-IJA" firstAttribute="leading" secondItem="Qnl-ta-cXb" secondAttribute="leading" id="QCJ-on-7NG"/>
+                                <constraint firstAttribute="trailing" secondItem="N3F-xg-lcP" secondAttribute="trailing" id="RMB-Db-paF"/>
                                 <constraint firstItem="VfG-2f-on3" firstAttribute="top" secondItem="fN6-15-6k9" secondAttribute="top" id="S2v-Gg-G1U"/>
                                 <constraint firstAttribute="trailing" secondItem="7Lr-kU-lXN" secondAttribute="trailing" constant="10" id="V8a-5S-mA5"/>
-                                <constraint firstAttribute="trailing" secondItem="Plo-DT-ZEo" secondAttribute="trailing" id="VZg-ah-TvG"/>
-                                <constraint firstItem="Plo-DT-ZEo" firstAttribute="leading" secondItem="fN6-15-6k9" secondAttribute="leading" id="YJe-nt-mwu"/>
                                 <constraint firstItem="7Lr-kU-lXN" firstAttribute="top" secondItem="Pfp-fe-IJA" secondAttribute="top" id="adQ-ba-sap"/>
                                 <constraint firstItem="Pfp-fe-IJA" firstAttribute="top" secondItem="fN6-15-6k9" secondAttribute="top" constant="16" id="fPR-1u-NRG"/>
                                 <constraint firstAttribute="bottom" secondItem="VfG-2f-on3" secondAttribute="bottom" id="rCf-yj-jsI"/>
                                 <constraint firstItem="7Lr-kU-lXN" firstAttribute="leading" secondItem="Pfp-fe-IJA" secondAttribute="trailing" constant="8" id="rVh-FS-9Id"/>
-                                <constraint firstAttribute="bottom" secondItem="mVV-Qc-NtZ" secondAttribute="bottom" id="vH9-MI-Q17"/>
-                                <constraint firstItem="mVV-Qc-NtZ" firstAttribute="leading" secondItem="fN6-15-6k9" secondAttribute="leading" id="z5d-9m-1O5"/>
+                                <constraint firstItem="N3F-xg-lcP" firstAttribute="leading" secondItem="fN6-15-6k9" secondAttribute="leading" id="xAt-od-Qyd"/>
                             </constraints>
                             <connections>
                                 <outlet property="descriptionLabel" destination="86U-jy-8DP" id="XET-dV-IBS"/>
-                                <outlet property="image" destination="mVV-Qc-NtZ" id="cjG-Tl-RT1"/>
                                 <outlet property="readButton" destination="Qnl-ta-cXb" id="6FX-YK-M86"/>
                                 <outlet property="saveButton" destination="7Lr-kU-lXN" id="ZPh-eh-tgH"/>
                                 <outlet property="titleLabel" destination="Pfp-fe-IJA" id="CBh-Ne-1sg"/>
@@ -125,7 +116,7 @@
                                             <rect key="frame" x="10" y="10" width="580" height="23"/>
                                             <animations/>
                                             <fontDescription key="fontDescription" type="system" pointSize="17"/>
-                                            <color key="textColor" cocoaTouchSystemColor="darkTextColor"/>
+                                            <color key="textColor" red="0.0" green="0.0" blue="0.0" alpha="1" colorSpace="calibratedRGB"/>
                                             <nil key="highlightedColor"/>
                                         </label>
                                     </subviews>
@@ -182,7 +173,7 @@
                                             <rect key="frame" x="10" y="10" width="580" height="23"/>
                                             <animations/>
                                             <fontDescription key="fontDescription" type="system" pointSize="17"/>
-                                            <color key="textColor" cocoaTouchSystemColor="darkTextColor"/>
+                                            <color key="textColor" red="0.0" green="0.0" blue="0.0" alpha="1" colorSpace="calibratedRGB"/>
                                             <nil key="highlightedColor"/>
                                         </label>
                                     </subviews>
@@ -209,10 +200,10 @@
                                     <autoresizingMask key="autoresizingMask"/>
                                     <subviews>
                                         <view contentMode="scaleToFill" translatesAutoresizingMaskIntoConstraints="NO" id="59N-e6-kQK">
-                                            <rect key="frame" x="10" y="10" width="580" height="60"/>
+                                            <rect key="frame" x="10" y="10" width="580" height="59"/>
                                             <subviews>
                                                 <imageView clipsSubviews="YES" userInteractionEnabled="NO" contentMode="scaleAspectFill" horizontalHuggingPriority="251" verticalHuggingPriority="251" image="logo-placeholder-search" translatesAutoresizingMaskIntoConstraints="NO" id="9A4-UO-dRq">
-                                                    <rect key="frame" x="0.0" y="0.0" width="60" height="60"/>
+                                                    <rect key="frame" x="0.0" y="0.0" width="60" height="59"/>
                                                     <constraints>
                                                         <constraint firstAttribute="height" priority="999" constant="60" id="XNN-TH-Cle"/>
                                                         <constraint firstAttribute="width" constant="60" id="eJC-BC-qun"/>
@@ -221,11 +212,11 @@
                                                 <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="751" verticalHuggingPriority="751" horizontalCompressionResistancePriority="751" verticalCompressionResistancePriority="751" text="Label" lineBreakMode="wordWrap" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="3Lp-j9-yQ7" userLabel="Title Label">
                                                     <rect key="frame" x="70" y="0.0" width="510" height="21"/>
                                                     <fontDescription key="fontDescription" type="system" pointSize="17"/>
-                                                    <color key="textColor" cocoaTouchSystemColor="darkTextColor"/>
+                                                    <color key="textColor" red="0.0" green="0.0" blue="0.0" alpha="1" colorSpace="calibratedRGB"/>
                                                     <nil key="highlightedColor"/>
                                                 </label>
                                                 <label opaque="NO" userInteractionEnabled="NO" contentMode="left" horizontalHuggingPriority="750" verticalHuggingPriority="750" text="Label" lineBreakMode="wordWrap" numberOfLines="0" baselineAdjustment="alignBaselines" adjustsFontSizeToFit="NO" translatesAutoresizingMaskIntoConstraints="NO" id="Pp3-fv-o0m" userLabel="Description Label">
-                                                    <rect key="frame" x="70" y="21" width="510" height="40"/>
+                                                    <rect key="frame" x="70" y="21" width="510" height="38"/>
                                                     <fontDescription key="fontDescription" type="system" pointSize="15"/>
                                                     <color key="textColor" white="0.33333333333333331" alpha="1" colorSpace="calibratedWhite"/>
                                                     <nil key="highlightedColor"/>
@@ -267,10 +258,58 @@
                             <outlet property="delegate" destination="Btv-Tg-s8D" id="gQp-CK-ZEP"/>
                         </connections>
                     </tableView>
+                    <connections>
+                        <outlet property="galleryContainerView" destination="N3F-xg-lcP" id="bfT-6r-zz1"/>
+                        <outlet property="headerView" destination="fN6-15-6k9" id="PIa-WF-y9F"/>
+                    </connections>
                 </tableViewController>
                 <placeholder placeholderIdentifier="IBFirstResponder" id="MMe-1R-ehz" userLabel="First Responder" sceneMemberID="firstResponder"/>
             </objects>
-            <point key="canvasLocation" x="2580" y="488"/>
+            <point key="canvasLocation" x="2190" y="475"/>
+        </scene>
+        <!--Article Header Image Gallery View Controller-->
+        <scene sceneID="1YE-Ob-8lm">
+            <objects>
+                <collectionViewController id="7Or-9F-7Br" customClass="WMFArticleHeaderImageGalleryViewController" sceneMemberID="viewController">
+                    <collectionView key="view" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="scaleToFill" pagingEnabled="YES" showsHorizontalScrollIndicator="NO" showsVerticalScrollIndicator="NO" dataMode="prototypes" id="L4r-1P-bh8">
+                        <rect key="frame" x="0.0" y="0.0" width="600" height="200"/>
+                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
+                        <collectionViewLayout key="collectionViewLayout" id="s93-Y9-at2" customClass="WMFCollectionViewPageLayout"/>
+                        <cells>
+                            <collectionViewCell opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" placeholderIntrinsicWidth="50" placeholderIntrinsicHeight="50" reuseIdentifier="WMFImageCollectionViewCell" id="BsT-fo-lkV" customClass="WMFImageCollectionViewCell">
+                                <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
+                                <autoresizingMask key="autoresizingMask"/>
+                                <view key="contentView" opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center">
+                                    <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
+                                    <autoresizingMask key="autoresizingMask"/>
+                                    <subviews>
+                                        <imageView userInteractionEnabled="NO" contentMode="scaleAspectFill" horizontalHuggingPriority="251" verticalHuggingPriority="251" translatesAutoresizingMaskIntoConstraints="NO" id="GiH-fi-DXA">
+                                            <rect key="frame" x="0.0" y="0.0" width="50" height="50"/>
+                                        </imageView>
+                                    </subviews>
+                                    <color key="backgroundColor" white="0.0" alpha="0.0" colorSpace="calibratedWhite"/>
+                                </view>
+                                <constraints>
+                                    <constraint firstAttribute="trailing" secondItem="GiH-fi-DXA" secondAttribute="trailing" id="8if-am-5Cn"/>
+                                    <constraint firstItem="GiH-fi-DXA" firstAttribute="top" secondItem="BsT-fo-lkV" secondAttribute="top" id="INH-u7-tdm"/>
+                                    <constraint firstItem="GiH-fi-DXA" firstAttribute="leading" secondItem="BsT-fo-lkV" secondAttribute="leading" id="QqE-aK-cnG"/>
+                                    <constraint firstAttribute="bottom" secondItem="GiH-fi-DXA" secondAttribute="bottom" id="RKq-Y1-asb"/>
+                                </constraints>
+                                <size key="customSize" width="50" height="50"/>
+                                <connections>
+                                    <outlet property="imageView" destination="GiH-fi-DXA" id="ZH0-he-mhY"/>
+                                </connections>
+                            </collectionViewCell>
+                        </cells>
+                        <connections>
+                            <outlet property="dataSource" destination="7Or-9F-7Br" id="Wrp-y0-SDo"/>
+                            <outlet property="delegate" destination="7Or-9F-7Br" id="a7i-bT-yhS"/>
+                        </connections>
+                    </collectionView>
+                </collectionViewController>
+                <placeholder placeholderIdentifier="IBFirstResponder" id="XsP-Rr-Pfo" userLabel="First Responder" sceneMemberID="firstResponder"/>
+            </objects>
+            <point key="canvasLocation" x="2105" y="1116"/>
         </scene>
     </scenes>
     <resources>
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.h b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.h
index b87aa10640b..5f9e2bd0f34 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.h	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.h	
@@ -9,7 +9,6 @@
 #import <UIKit/UIKit.h>
 
 @class WMFImageGalleryDetailOverlayView;
-@class WMFGradientView;
 
 @interface WMFImageGalleryCollectionViewCell : UICollectionViewCell
 
@@ -24,12 +23,15 @@
  * @note This setter takes precedence over @c imageView.image since other cell elements need to be laid out as a result
  *       of the image changing.
  */
-@property (nonatomic) UIImage* image;
+@property (nonatomic, strong) UIImage* image;
 
 /// The subview which displays additional information about the image.
 @property (nonatomic, weak, readonly) WMFImageGalleryDetailOverlayView* detailOverlayView;
 
-/// Set @c alpha for the gradient & detail overlay views. This is preferred to hiding & showing them.
-- (void)setDetailViewAlpha:(float)alpha;
+@property (nonatomic, getter = isZoomEnabled) BOOL zoomEnabled;
+
+@property (nonatomic, getter = isLoading) BOOL loading;
+
+- (void)startLoadingAfterDelay:(NSTimeInterval)seconds;
 
 @end
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.m b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.m
index cfb4dafc43e..ae769b53c1b 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.m	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryCollectionViewCell.m	
@@ -22,6 +22,7 @@ @interface WMFImageGalleryCollectionViewCell ()
 @property (nonatomic, weak, readonly) UIImageView* imageView;
 @property (nonatomic, weak, readonly) UIScrollView* imageContainerView;
 @property (nonatomic, weak, readonly) WMFGradientView* gradientView;
+@property (nonatomic, weak, readonly) UIActivityIndicatorView* loadingIndicator;
 
 /**
  * Use this getter (instead of @c imageSize or <code>image.size</code>) to resolve the image size for display &
@@ -37,6 +38,7 @@ @implementation WMFImageGalleryCollectionViewCell
 - (instancetype)initWithFrame:(CGRect)frame {
     self = [super initWithFrame:frame];
     if (self) {
+        _zoomEnabled                   = YES;
         self.contentView.clipsToBounds = YES;
 
         _imageSize = CGSizeZero;
@@ -55,6 +57,16 @@ - (instancetype)initWithFrame:(CGRect)frame {
         [self.imageContainerView addSubview:imageView];
         _imageView = imageView;
 
+        WMFImageGalleryDetailOverlayView* detailOverlayView = [WMFImageGalleryDetailOverlayView wmf_viewFromClassNib];
+        detailOverlayView.userInteractionEnabled = NO;
+        [self.contentView addSubview:detailOverlayView];
+        _detailOverlayView = detailOverlayView;
+
+        [self.detailOverlayView mas_makeConstraints:^(MASConstraintMaker* make) {
+            make.height.lessThanOrEqualTo(@(WMFImageGalleryMaxDetailHeight)).with.priorityHigh();
+            make.leading.trailing.and.bottom.equalTo(self.contentView);
+        }];
+
         WMFGradientView* gradientView = [WMFGradientView new];
         [gradientView.gradientLayer setLocations:@[@0, @1]];
         [gradientView.gradientLayer setColors:@[(id)[UIColor colorWithWhite:0.0 alpha:1.0].CGColor,
@@ -63,27 +75,22 @@ - (instancetype)initWithFrame:(CGRect)frame {
         [gradientView.gradientLayer setStartPoint:CGPointMake(0.5, 1.0)];
         [gradientView.gradientLayer setEndPoint:CGPointMake(0.5, 0.0)];
         gradientView.userInteractionEnabled = NO;
-        [self.contentView addSubview:gradientView];
+        [self.detailOverlayView addSubview:gradientView];
+        [self.detailOverlayView sendSubviewToBack:gradientView];
         _gradientView = gradientView;
 
-        WMFImageGalleryDetailOverlayView* detailOverlayView = [WMFImageGalleryDetailOverlayView wmf_viewFromClassNib];
-        detailOverlayView.userInteractionEnabled = NO;
-        [self.contentView addSubview:detailOverlayView];
-        _detailOverlayView = detailOverlayView;
-
-        [self.detailOverlayView mas_makeConstraints:^(MASConstraintMaker* make) {
-            make.height.lessThanOrEqualTo(@(WMFImageGalleryMaxDetailHeight)).with.priorityHigh();
-            make.leading.equalTo(self.contentView.mas_leading);
-            make.trailing.equalTo(self.contentView.mas_trailing);
-            make.bottom.equalTo(self.contentView.mas_bottom);
+        [self.gradientView mas_makeConstraints:^(MASConstraintMaker* make) {
+            make.edges.equalTo(self.detailOverlayView);
         }];
 
-        [self.gradientView mas_makeConstraints:^(MASConstraintMaker* make) {
-            make.leading.equalTo(self.contentView.mas_leading);
-            make.trailing.equalTo(self.contentView.mas_trailing);
-            make.bottom.equalTo(self.detailOverlayView.mas_bottom);
-            make.top.equalTo(self.detailOverlayView.mas_top);
+        UIActivityIndicatorView* loadingIndicator =
+            [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];
+        loadingIndicator.hidesWhenStopped = YES;
+        [self.contentView addSubview:loadingIndicator];
+        [loadingIndicator mas_makeConstraints:^(MASConstraintMaker* make) {
+            make.center.equalTo(self.contentView);
         }];
+        _loadingIndicator = loadingIndicator;
     }
     return self;
 }
@@ -92,12 +99,26 @@ - (void)prepareForReuse {
     [super prepareForReuse];
     [self.detailOverlayView setImageDescription:nil];
     [self.detailOverlayView setLicense:nil owner:nil];
-    self.gradientView.hidden                = NO;
-    self.detailOverlayView.hidden           = NO;
-    self.detailOverlayView.ownerTapCallback = nil;
-    self.image                              = nil;
-    self.imageSize                          = CGSizeZero;
-    self.imageContainerView.contentOffset   = CGPointZero;
+    self.gradientView.hidden                       = NO;
+    self.detailOverlayView.hidden                  = NO;
+    self.detailOverlayView.ownerTapCallback        = nil;
+    self.image                                     = nil;
+    self.imageSize                                 = CGSizeZero;
+    self.imageContainerView.contentOffset          = CGPointZero;
+    self.imageContainerView.userInteractionEnabled = YES;
+    self.zoomEnabled                               = YES;
+    self.loading                                   = NO;
+}
+
+- (void)setZoomEnabled:(BOOL)zoomEnabled {
+    if (_zoomEnabled == zoomEnabled) {
+        return;
+    }
+    _zoomEnabled               = zoomEnabled;
+    self.imageView.contentMode = _zoomEnabled ?
+                                 UIViewContentModeScaleAspectFit : UIViewContentModeScaleAspectFill;
+    // trigger layout to recalculate zoom factors & frames
+    [self setNeedsLayout];
 }
 
 #pragma mark - Layout
@@ -130,14 +151,23 @@ - (void)layoutSubviews {
      */
     self.imageContainerView.frame       = self.contentView.bounds;
     self.imageContainerView.contentSize = self.contentView.bounds.size;
-    self.imageView.frame                = (CGRect){
-        .origin = CGPointZero,
-        .size   = self.effectiveImageSize
-    };
 
-    // once frames are set, transforms & insets can be applied
-    [self resetScaleFactors];
-    [self centerImageInScrollView];
+    if (self.isZoomEnabled) {
+        self.imageView.frame = (CGRect){
+            .origin = CGPointZero,
+            .size   = self.effectiveImageSize
+        };
+    } else {
+        self.imageView.frame = self.imageContainerView.bounds;
+    }
+
+    if (self.isZoomEnabled) {
+        // once frames are set, transforms & insets can be applied
+        [self resetScaleFactors];
+        [self centerImageInScrollView];
+    } else {
+        self.imageContainerView.contentInset = UIEdgeInsetsZero;
+    }
 }
 
 #pragma mark - View Updates
@@ -167,7 +197,6 @@ - (void)centerImageInScrollView {
 
 /**
  * Set the min/max/current @c zoomScale for <code>imageContainerView</code>. See implementation comments for details.
- * @note This is invoked automatically by @c centerImageInScrollView
  */
 - (void)resetScaleFactors {
     if (self.image) {
@@ -176,7 +205,7 @@ - (void)resetScaleFactors {
         double const heightScale = self.contentView.frame.size.height / self.effectiveImageSize.height;
         /*
            The minimum & maximum scales need to be rounded *down*, otherwise there's an "off by one" error where the
-           contents of @c imageContainerView are _just_ larger than its @c contentSize, which causes paging glitches.
+           contents of imageContainerView are _just_ larger than its contentSize, which causes paging glitches.
          */
         double const minScale = FlooredPercentage(fmin(widthScale, heightScale));
 
@@ -222,9 +251,35 @@ - (void)setImageSize:(CGSize)imageSize {
     [self setNeedsLayout];
 }
 
-- (void)setDetailViewAlpha:(float)alpha {
-    self.gradientView.alpha = alpha;
-    [self.detailOverlayView setGroupAlpha:alpha];
+#pragma mark - Loading
+
+- (void)startLoadingAfterDelay:(NSTimeInterval)seconds {
+    // cancel any previous calls
+    [self cancelStartLoading];
+    // schedule a call that will start the loading indicator animating in `seconds`
+    [self.loadingIndicator performSelector:@selector(startAnimating)
+                                withObject:nil
+                                afterDelay:seconds];
+}
+
+- (void)cancelStartLoading {
+    [NSObject cancelPreviousPerformRequestsWithTarget:self.loadingIndicator
+                                             selector:@selector(startAnimating)
+                                               object:nil];
+}
+
+- (BOOL)isLoading {
+    return self.loadingIndicator.isAnimating;
+}
+
+- (void)setLoading:(BOOL)loading {
+    [self cancelStartLoading];
+
+    if (loading) {
+        [self.loadingIndicator startAnimating];
+    } else {
+        [self.loadingIndicator stopAnimating];
+    }
 }
 
 #pragma mark - UIScrollViewDelegate
@@ -235,7 +290,7 @@ - (void)scrollViewDidZoom:(UIScrollView*)scrollView {
 }
 
 - (UIView*)viewForZoomingInScrollView:(UIScrollView*)imageScrollView {
-    return self.imageView;
+    return self.isZoomEnabled ? self.imageView : nil;
 }
 
 @end
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.h b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.h
index 69ca1bbce94..983260ddca2 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.h	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.h	
@@ -19,7 +19,4 @@
 
 - (void)setLicense:(MWKLicense*)license owner:(NSString*)owner;
 
-/// Set all child view alphas to @c alpha. This is preferred to hiding & showing them.
-- (void)setGroupAlpha:(float)alpha;
-
 @end
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m
index 63346ccfb76..e2c82bf7c91 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.m	
@@ -12,7 +12,7 @@
 #import "WikiGlyph_Chars.h"
 #import "UILabel+WMFStyling.h"
 #import "MWKLicense+ToGlyph.h"
-#import "NSParagraphStyle+WMFNaturalAlignmentStyle.h"
+#import "NSParagraphStyle+WMFParagraphStyles.h"
 
 static double const WMFImageGalleryLicenseFontSize       = 19.0;
 static double const WMFImageGalleryLicenseBaselineOffset = -1.5;
@@ -26,7 +26,6 @@ - (IBAction)didTapOwnerButton;
 
 @end
 
-
 static NSAttributedString* ConcatOwnerAndLicense(NSString* owner, MWKLicense* license){
     if (!owner && !license) {
         return nil;
@@ -53,7 +52,7 @@ - (IBAction)didTapOwnerButton;
     [result appendAttributedString:attributedOwnerAndSeparator];
 
     [result addAttribute:NSParagraphStyleAttributeName
-                   value:[NSParagraphStyle wmf_naturalAlignmentStyle]
+                   value:[NSParagraphStyle wmf_tailTruncatingNaturalAlignmentStyle]
                    range:NSMakeRange(0, result.length)];
 
     return result;
@@ -79,12 +78,6 @@ - (IBAction)didTapOwnerButton {
     }
 }
 
-- (void)setGroupAlpha:(float)alpha {
-    self.alpha                       = alpha;
-    self.imageDescriptionLabel.alpha = alpha;
-    self.ownerButton.alpha           = alpha;
-}
-
 - (NSString*)imageDescription {
     return self.imageDescriptionLabel.attributedText.string;
 }
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib
index 90d370667de..f587facd61b 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryDetailOverlayView.xib	
@@ -1,8 +1,8 @@
 <?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<document type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="3.0" toolsVersion="6751" systemVersion="14C1510" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES">
+<document type="com.apple.InterfaceBuilder3.CocoaTouch.XIB" version="3.0" toolsVersion="7706" systemVersion="14E46" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES">
     <dependencies>
         <deployment identifier="iOS"/>
-        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="6736"/>
+        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="7703"/>
     </dependencies>
     <objects>
         <placeholder placeholderIdentifier="IBFilesOwner" id="-1" userLabel="File's Owner"/>
@@ -36,6 +36,7 @@
             <constraints>
                 <constraint firstItem="I6f-Vm-XuX" firstAttribute="top" secondItem="iN0-l3-epB" secondAttribute="top" constant="100" id="0L5-I0-Yi9"/>
                 <constraint firstItem="I6f-Vm-XuX" firstAttribute="leading" secondItem="iN0-l3-epB" secondAttribute="leading" constant="20" symbolic="YES" id="2k3-u8-8nA"/>
+                <constraint firstAttribute="trailing" relation="greaterThanOrEqual" secondItem="l6E-b6-poB" secondAttribute="trailing" constant="20" symbolic="YES" id="K6P-qF-bWO"/>
                 <constraint firstAttribute="bottom" secondItem="l6E-b6-poB" secondAttribute="bottom" constant="8" id="PWz-xR-vOr"/>
                 <constraint firstItem="l6E-b6-poB" firstAttribute="leading" secondItem="iN0-l3-epB" secondAttribute="leading" constant="20" symbolic="YES" id="e6B-Lc-WcL"/>
                 <constraint firstItem="l6E-b6-poB" firstAttribute="top" secondItem="I6f-Vm-XuX" secondAttribute="bottom" constant="8" symbolic="YES" id="eSj-hx-LwA"/>
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.h b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.h
index eb445d0131a..fc8c9f32f71 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.h	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.h	
@@ -7,27 +7,94 @@
 //
 
 #import <UIKit/UIKit.h>
+#import "WMFPageCollectionViewController.h"
+#import "Wikipedia-Swift.h"
+#import "PromiseKit.h"
 
 @class MWKArticle, MWKImage;
 
-/// View controller which renders an article's images in a fullscreen, scrollable gallery.
-@interface WMFImageGalleryViewController : UICollectionViewController
+NS_ASSUME_NONNULL_BEGIN
 
-/// The article whose images are being displayed.
-@property (nonatomic, readonly) MWKArticle* article;
+@class WMFImageGalleryViewController;
+@protocol WMFImageGalleryViewControllerDelegate <NSObject>
 
-/// Index of the currently visible image within the article's images.
-@property (nonatomic) NSUInteger visibleImageIndex;
+
+@optional
+
+/**
+ * Optional. Called when a gallery's close button is tapped before it is dismissed.
+ *
+ * @param gallery The gallery being dismissed.
+ */
+- (void)willDismissGalleryController:(WMFImageGalleryViewController*)gallery;
+
+/**
+ * Optional. Called when a gallery's close button is tapped before it is dismissed.
+ *
+ * @param gallery The gallery being dismissed.
+ */
+- (void)didDismissGalleryController:(WMFImageGalleryViewController*)gallery;
+
+@end
+
+/// View controller which renders an article's images in a pageable gallery.
+@interface WMFImageGalleryViewController : WMFPageCollectionViewController
+
+/**
+ * The article whose images are being displayed.
+ *
+ * Set to `nil` to empty the gallery.
+ */
+@property (nonatomic, strong, nullable) MWKArticle* article;
+
+/// Promise which will eventually resolve to a `MWKArticle`, that will be used to set the receiver's `article`.
+- (void)setArticleWithPromise:(AnyPromise*)articlePromise;
 
 /**
- * Designated initializer.
+ * The gallery's delegate.
+ *
+ * Only necessary if extra work needs to be done when the gallery is dismissed or it wasn't presented modally.
+ *
+ * @see WMFImageGalleryViewControllerDelegate.
+ */
+@property (nonatomic, weak, nullable) id<WMFImageGalleryViewControllerDelegate> delegate;
+
+/**
+ * Controls whether auxilliary image information and controls are visible (e.g. close button & image metadata).
+ *
+ * Set to `YES` to hide image metadata, close button, and gradients. Only has an effect if `chromeEnabled` is `YES`.
+ *
+ * @see chromeEnabled
+ */
+@property (nonatomic, getter = isChromeHidden) BOOL chromeHidden;
+
+/**
+ * Whether or not chrome UI is able to be shown.
+ *
+ * Defaults to `YES`. Set to `NO` to both hide the chrome and prevent it from being shown.
+ *
+ * @see chromeHidden
+ */
+@property (nonatomic, getter = isChromeEnabled) BOOL chromeEnabled;
+
+/**
+ * Controls whether or not the user is allowed to pan or zoom images.
+ *
+ * Defaults to `YES`.
+ */
+@property (nonatomic, getter = isZoomEnabled) BOOL zoomEnabled;
+
+/**
+ * Initialize an instance with the given article.
  * @param article The article which will be the source of images for the gallery.
  * @return A new @c MWKImageGalleryViewController.
  */
-- (instancetype)initWithArticle:(MWKArticle*)article;
+- (instancetype)initWithArticle:(MWKArticle* __nullable)article NS_DESIGNATED_INITIALIZER;
 
 - (void)setVisibleImage:(MWKImage*)visibleImage animated:(BOOL)animated;
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated;
+- (void)setChromeHidden:(BOOL)hidden animated:(BOOL)animated;
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m
index 732922db5c8..790ede491c2 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageGalleryViewController.m	
@@ -17,6 +17,7 @@
 #import "WikipediaAppUtils.h"
 #import "SessionSingleton.h"
 #import "MWNetworkActivityIndicatorManager.h"
+#import "NSArray+WMFLayoutDirectionUtilities.h"
 
 // View
 #import <Masonry/Masonry.h>
@@ -26,14 +27,14 @@
 #import "WikiGlyph_Chars.h"
 #import "UICollectionViewFlowLayout+NSCopying.h"
 #import "UICollectionViewFlowLayout+WMFItemSizeThatFits.h"
+#import "WMFCollectionViewPageLayout.h"
 #import "UIViewController+Alert.h"
-#import "UICollectionViewFlowLayout+AttributeUtils.h"
+#import "UICollectionViewLayout+AttributeUtils.h"
 #import "UILabel+WMFStyling.h"
 #import "UIButton+FrameUtils.h"
 #import "UIView+WMFFrameUtils.h"
 #import "WMFGradientView.h"
-
-#import "WMFImageInfoController.h"
+#import "UICollectionView+WMFExtensions.h"
 
 // Model
 #import "MWKDataStore.h"
@@ -45,22 +46,17 @@
 // Networking
 #import "AFHTTPRequestOperationManager+UniqueRequests.h"
 #import "MWKImageInfoResponseSerializer.h"
-
-#undef LOG_LEVEL_DEF
-#define LOG_LEVEL_DEF WMFImageGalleryLogLevel
-
-static const int LOG_LEVEL_DEF = DDLogLevelDebug;
+#import "WMFImageInfoController.h"
 
 NS_ASSUME_NONNULL_BEGIN
 
+typedef void (^ WMFGalleryCellEnumerator)(WMFImageGalleryCollectionViewCell* cell, NSIndexPath* indexPath);
+
 static double const WMFImageGalleryTopGradientHeight = 150.0;
 
 @interface WMFImageGalleryViewController ()
 <UIGestureRecognizerDelegate, UICollectionViewDelegateFlowLayout, WMFImageInfoControllerDelegate>
 
-@property (nonatomic) BOOL didApplyInitialVisibleImageIndex;
-@property (nonatomic, getter = isChromeHidden) BOOL chromeHidden;
-
 @property (nonatomic, weak, readonly) UICollectionViewFlowLayout* collectionViewFlowLayout;
 @property (nonatomic, weak, readonly) UIButton* closeButton;
 @property (nonatomic, weak, readonly) WMFGradientView* topGradientView;
@@ -72,6 +68,10 @@ @interface WMFImageGalleryViewController ()
 
 @property (nonatomic, strong, readonly) WMFImageInfoController* infoController;
 
+@property (nonatomic, weak) UIActivityIndicatorView* loadingIndicator;
+
+@property (nonatomic, weak) PMKResolver articlePromiseResolve;
+
 - (MWKDataStore*)dataStore;
 
 @end
@@ -81,19 +81,26 @@ - (MWKDataStore*)dataStore;
 @implementation WMFImageGalleryViewController
 @synthesize infoController = _infoController;
 
-- (instancetype)initWithArticle:(MWKArticle*)article {
-    // TODO(bgerstle): use non-zero inset, disable bouncing, and customize scroll target to land images in center
-    UICollectionViewFlowLayout* defaultLayout = [[UICollectionViewFlowLayout alloc] init];
++ (UICollectionViewFlowLayout*)wmf_defaultGalleryLayout {
+    UICollectionViewFlowLayout* defaultLayout = [[WMFCollectionViewPageLayout alloc] init];
     defaultLayout.sectionInset            = UIEdgeInsetsZero;
     defaultLayout.minimumInteritemSpacing = 0.f;
     defaultLayout.minimumLineSpacing      = 0.f;
     defaultLayout.scrollDirection         = UICollectionViewScrollDirectionHorizontal;
-    // itemSize is based on view bounds, so we need to wait until it is about to appear to set it
+    return defaultLayout;
+}
+
+- (instancetype)init {
+    return [self initWithArticle:nil];
+}
 
-    self = [super initWithCollectionViewLayout:defaultLayout];
+- (instancetype)initWithArticle:(MWKArticle* __nullable)article {
+    self = [super initWithCollectionViewLayout:[[self class] wmf_defaultGalleryLayout]];
     if (self) {
-        _article      = article;
-        _chromeHidden = NO;
+        _article       = article;
+        _chromeHidden  = NO;
+        _chromeEnabled = YES;
+        _zoomEnabled   = YES;
     }
     return self;
 }
@@ -108,6 +115,55 @@ - (void)didReceiveMemoryWarning {
 
 #pragma mark - Getters
 
+- (void)setArticleWithPromise:(AnyPromise*)articlePromise {
+    if (self.articlePromiseResolve) {
+        self.articlePromiseResolve([NSError cancelledError]);
+    }
+
+    [self.loadingIndicator startAnimating];
+
+    __block id articlePromiseResolve;
+    // wrap articlePromise in a promise we can cancel if a new one comes in
+    AnyPromise* cancellableArticlePromise = [AnyPromise promiseWithResolverBlock:^(PMKResolver resolve) {
+        articlePromiseResolve = resolve;
+    }];
+    self.articlePromiseResolve = articlePromiseResolve;
+
+    articlePromise.then(articlePromiseResolve).catchWithPolicy(PMKCatchPolicyAllErrors, articlePromiseResolve);
+
+    // chain off the cancellable promise
+    @weakify(self);
+    cancellableArticlePromise.then(^(MWKArticle* article) {
+        @strongify(self);
+        self.article = article;
+    })
+    .catch(^(NSError* error) {
+        @strongify(self);
+        [self.loadingIndicator stopAnimating];
+        [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:2.f];
+    });
+}
+
+- (void)setArticle:(MWKArticle* __nullable)article {
+    if (WMF_EQUAL(_article, isEqualToArticle:, article)) {
+        return;
+    }
+    _article = article;
+    if (self.article) {
+        NSAssert(self.article.isCached, @"gallery assumes article data is already downloaded");
+        self.infoController.article = article;
+        self.currentPage            = [self.uniqueArticleImages wmf_startingIndexForApplicationLayoutDirection];
+        [self.infoController fetchBatchContainingIndex:self.currentPage];
+    } else {
+        self.infoController.article = nil;
+        self.currentPage            = 0;
+    }
+
+    if ([self isViewLoaded]) {
+        [self.collectionView reloadData];
+    }
+}
+
 - (WMFImageInfoController*)infoController {
     if (!_infoController) {
         _infoController          = [[WMFImageInfoController alloc] initWithArticle:self.article batchSize:50];
@@ -136,65 +192,28 @@ - (UICollectionViewFlowLayout*)collectionViewFlowLayout {
     return nil;
 }
 
-- (NSUInteger)mostVisibleItemIndex {
-    return [self.collectionViewFlowLayout wmf_indexPathClosestToContentOffset].item;
-}
-
-- (void)forEachVisibleCell:(void (^)(WMFImageGalleryCollectionViewCell*, NSIndexPath*))block {
-    if (!block) {
-        return;
-    }
-    [self.collectionView.indexPathsForVisibleItems bk_each:^(NSIndexPath* path) {
-        WMFImageGalleryCollectionViewCell* cell =
-            (WMFImageGalleryCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:path];
-        if (cell) {
-            block(cell, path);
-        }
-    }];
-}
-
-#pragma mark - View event handling
-
-- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation
-                                duration:(NSTimeInterval)duration {
-    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];
-    NSUInteger const currentImageIndex = [self mostVisibleItemIndex];
-    [UIView animateWithDuration:duration
-                          delay:0
-                        options:UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionAllowAnimatedContent
-                     animations:^{
-        [self.collectionViewFlowLayout invalidateLayout];
-    }
-                     completion:^(BOOL finished) {
-        [self setVisibleImageIndex:currentImageIndex animated:NO forceViewUpdate:YES];
-    }];
-}
-
-- (void)viewDidLayoutSubviews {
-    [super viewDidLayoutSubviews];
-    /*
-       only apply visible image index once the collection view has been populated with cells, otherwise calls to get
-       layout attributes of the item at `visibleImageIndex` will return `nil` (on iOS 6, at least)
-     */
-    if (!self.didApplyInitialVisibleImageIndex && self.collectionView.visibleCells.count) {
-        [self applyVisibleImageIndex:NO];
-        /*
-           only set the flag *after* the visible index has been updated, to make sure UICollectionViewDelegate callbacks
-           don't override it
-         */
-        self.didApplyInitialVisibleImageIndex = YES;
-    }
-}
-
 - (void)viewDidAppear:(BOOL)animated {
     [super viewDidAppear:animated];
     // fetch after appearing so we don't do work while the animation is rendering
-    [self.infoController fetchBatchContainingIndex:self.visibleImageIndex];
+    [self.infoController fetchBatchContainingIndex:self.currentPage];
 }
 
 - (void)viewDidLoad {
     [super viewDidLoad];
 
+    UIActivityIndicatorView* loadingIndicator =
+        [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];
+    loadingIndicator.hidesWhenStopped = YES;
+    [loadingIndicator stopAnimating];
+    [self.view addSubview:loadingIndicator];
+    [loadingIndicator mas_makeConstraints:^(MASConstraintMaker* make) {
+        make.center.equalTo(self.view);
+    }];
+    self.loadingIndicator = loadingIndicator;
+
+    self.collectionView.showsHorizontalScrollIndicator = NO;
+    self.collectionView.showsVerticalScrollIndicator   = NO;
+
     WMFGradientView* topGradientView = [WMFGradientView new];
     topGradientView.userInteractionEnabled = NO;
     [topGradientView.gradientLayer setLocations:@[@0, @1]];
@@ -225,7 +244,7 @@ - (void)viewDidLoad {
 
     // setup actions
     [closeButton addTarget:self
-                    action:@selector(didTouchCloseButton:)
+                    action:@selector(closeButtonTapped:)
           forControlEvents:UIControlEventTouchUpInside];
 
     [self.view addSubview:closeButton];
@@ -274,6 +293,8 @@ - (void)viewDidLoad {
     [self.collectionView registerClass:[WMFImageGalleryCollectionViewCell class]
             forCellWithReuseIdentifier:WMFImageGalleryCollectionViewCellReuseId];
     self.collectionView.pagingEnabled = YES;
+
+    [self applyChromeHidden:NO];
 }
 
 #pragma mark - Chrome
@@ -291,7 +312,8 @@ - (void)setChromeHidden:(BOOL)hidden {
 }
 
 - (void)setChromeHidden:(BOOL)hidden animated:(BOOL)animated {
-    if (_chromeHidden == hidden) {
+    if (_chromeHidden == hidden || !self.isChromeEnabled) {
+        // no-op of chromeHidden state is already equal to `hidden` or chrome is disabled
         return;
     }
     _chromeHidden = hidden;
@@ -299,6 +321,9 @@ - (void)setChromeHidden:(BOOL)hidden animated:(BOOL)animated {
 }
 
 - (void)applyChromeHidden:(BOOL)animated {
+    if (![self isViewLoaded]) {
+        return;
+    }
     dispatch_block_t animations = ^{
         self.topGradientView.hidden = [self isChromeHidden];
         self.closeButton.hidden     = [self isChromeHidden];
@@ -318,43 +343,51 @@ - (void)applyChromeHidden:(BOOL)animated {
     }
 }
 
-#pragma mark - Dismissal
+- (void)setChromeEnabled:(BOOL)chromeEnabled {
+    // NOTE(bgerstle): don't bail if _chromeEnabled == chromeEnabled, as chromeHidden state might need to be updated
+    _chromeEnabled = chromeEnabled;
 
-- (void)didTouchCloseButton:(id)sender {
-    [self dismissViewControllerAnimated:YES completion:nil];
+    if (!_chromeHidden && !_chromeEnabled) {
+        // force chrome to be hidden if it is shown and chrome becomes disabled
+        _chromeHidden = YES;
+        [self applyChromeHidden:NO];
+    }
 }
 
-#pragma mark - Visible Image Index
+#pragma mark - Zoom
 
-- (void)applyVisibleImageIndex:(BOOL)animated {
-    if ([self isViewLoaded]) {
-        // can't use scrollToItem because it doesn't handle post-rotation scrolling well on iOS 6
-        UICollectionViewLayoutAttributes* visibleImageAttributes =
-            [self.collectionViewFlowLayout layoutAttributesForItemAtIndexPath:
-             [NSIndexPath indexPathForItem:self.visibleImageIndex inSection:0]];
-        NSAssert(visibleImageAttributes,
-                 @"Layout attributes for visible image were nil because %@ was called too early!",
-                 NSStringFromSelector(_cmd));
-        [self.collectionView setContentOffset:visibleImageAttributes.frame.origin animated:animated];
+- (void)setZoomEnabled:(BOOL)zoomEnabled {
+    if (_zoomEnabled == zoomEnabled) {
+        return;
     }
+    _zoomEnabled = zoomEnabled;
+    [self applyZoomEnabled];
 }
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated {
-    [self setVisibleImageIndex:visibleImageIndex animated:animated forceViewUpdate:NO];
+- (void)applyZoomEnabled {
+    if ([self isViewLoaded]) {
+        [self.collectionView wmf_enumerateVisibleCellsUsingBlock:^(WMFImageGalleryCollectionViewCell* cell,
+                                                                   NSIndexPath* indexPath,
+                                                                   BOOL* _) {
+            cell.zoomEnabled = self.isZoomEnabled;
+        }];
+    }
 }
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex animated:(BOOL)animated forceViewUpdate:(BOOL)force {
-    if (!force && visibleImageIndex == _visibleImageIndex) {
-        return;
+#pragma mark - Dismissal
+
+- (void)closeButtonTapped:(id)sender {
+    if ([self.delegate respondsToSelector:@selector(willDismissGalleryController:)]) {
+        [self.delegate willDismissGalleryController:self];
     }
-    NSParameterAssert(visibleImageIndex < self.uniqueArticleImages.count);
-    _visibleImageIndex = visibleImageIndex;
-    [self applyVisibleImageIndex:animated];
+    [self dismissViewControllerAnimated:YES completion:^{
+        if ([self.delegate respondsToSelector:@selector(didDismissGalleryController:)]) {
+            [self.delegate didDismissGalleryController:self];
+        }
+    }];
 }
 
-- (void)setVisibleImageIndex:(NSUInteger)visibleImageIndex {
-    [self setVisibleImageIndex:visibleImageIndex animated:NO];
-}
+#pragma mark - Visible Image Index
 
 - (void)setVisibleImage:(MWKImage*)visibleImage animated:(BOOL)animated {
     NSInteger selectedImageIndex = [self.uniqueArticleImages indexOfObjectPassingTest:^BOOL (MWKImage* image,
@@ -368,11 +401,11 @@ - (void)setVisibleImage:(MWKImage*)visibleImage animated:(BOOL)animated {
     }];
 
     if (selectedImageIndex == NSNotFound) {
-        NSLog(@"WARNING: falling back to showing the first image.");
+        DDLogWarn(@"Falling back to showing the first image.");
         selectedImageIndex = 0;
     }
 
-    self.visibleImageIndex = selectedImageIndex;
+    self.currentPage = selectedImageIndex;
 }
 
 #pragma mark - UIGestureRecognizerDelegate
@@ -391,21 +424,15 @@ - (BOOL)                  gestureRecognizer:(UIGestureRecognizer*)gestureRecogni
 
 #pragma mark Delegate
 
-- (CGSize)  collectionView:(UICollectionView*)collectionView
-                    layout:(UICollectionViewLayout*)collectionViewLayout
-    sizeForItemAtIndexPath:(NSIndexPath*)indexPath {
-    return [self.collectionViewFlowLayout wmf_itemSizeThatFits:self.view.bounds.size];
-}
-
 - (void)collectionView:(UICollectionView*)collectionView
        willDisplayCell:(UICollectionViewCell*)cell
     forItemAtIndexPath:(NSIndexPath*)indexPath {
     /*
        since we have to wait until the cells are laid out before applying visibleImageIndex, this method can be
-       called before visibleImageIndex has been applied.  as a result, we check the flag here to ensure our first fetch
+       called before currentPage has been applied.  as a result, we check the flag here to ensure our first fetch
        doesn't involve the first image if the user tapped on the last image.
      */
-    if (self.didApplyInitialVisibleImageIndex) {
+    if (self.didApplyCurrentPage) {
         [self.infoController fetchBatchContainingIndex:indexPath.item withNthNeighbor:5];
     }
 }
@@ -432,6 +459,10 @@ - (void)updateCell:(WMFImageGalleryCollectionViewCell*)cell atIndexPath:(NSIndex
     MWKImage* imageStub        = self.uniqueArticleImages[indexPath.item];
     MWKImageInfo* infoForImage = [self.infoController infoForImage:imageStub];
 
+    cell.zoomEnabled = self.zoomEnabled;
+
+    [cell startLoadingAfterDelay:0.25];
+
     [self updateDetailVisibilityForCell:cell withInfo:infoForImage];
 
     if (infoForImage) {
@@ -453,6 +484,8 @@ - (void)updateCell:(WMFImageGalleryCollectionViewCell*)cell atIndexPath:(NSIndex
     [self updateImageForCell:cell atIndexPath:indexPath image:imageStub info:infoForImage];
 }
 
+#pragma mark - Image Details
+
 - (void)updateDetailVisibilityForCellAtIndexPath:(NSIndexPath*)indexPath {
     WMFImageGalleryCollectionViewCell* cell =
         (WMFImageGalleryCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:indexPath];
@@ -470,9 +503,26 @@ - (void)updateDetailVisibilityForCell:(WMFImageGalleryCollectionViewCell*)cell
                              withInfo:(MWKImageInfo*)info {
     BOOL const shouldHideDetails = [self isChromeHidden]
                                    || (!info.imageDescription && !info.owner && !info.license);
-    [cell setDetailViewAlpha:shouldHideDetails ? 0.0 : 1.0];
+    cell.detailOverlayView.alpha = shouldHideDetails ? 0.0 : 1.0;
 }
 
+#pragma mark - Error Handling
+
+- (void)showError:(NSError*)error forCellAtIndexPath:(NSIndexPath*)path {
+    WMFImageGalleryCollectionViewCell* cell =
+        (WMFImageGalleryCollectionViewCell*)[self.collectionView cellForItemAtIndexPath:path];
+    [self showError:error inCell:cell atIndexPath:path];
+}
+
+- (void)showError:(NSError*)error
+           inCell:(WMFImageGalleryCollectionViewCell*)cell
+      atIndexPath:(NSIndexPath*)indexPath {
+    cell.loading = NO;
+    // TODO: show error UI for cell
+}
+
+#pragma mark - Image Handling
+
 - (void)updateImageAtIndexPath:(NSIndexPath*)indexPath {
     NSParameterAssert(indexPath);
     MWKImage* image                         = self.uniqueArticleImages[indexPath.item];
@@ -503,8 +553,9 @@ - (void)updateImageForCell:(WMFImageGalleryCollectionViewCell*)cell
         [self setPlaceholderImage : placeholderImage ofInfo : infoForImage forCellAtIndexPath : indexPath];
     }]
     .catch(^(NSError* error) {
-        // TODO: show alert if any errors trickle down from above (i.e. network error fetching high-res image)
         DDLogWarn(@"Failed to load image for cell at %@: %@", indexPath, error);
+        @strongify(self);
+        [self showError:error forCellAtIndexPath:indexPath];
     });
 }
 
@@ -520,6 +571,7 @@ - (void)      setImage:(UIImage*)image
     }
     cell.image     = image;
     cell.imageSize = info.thumbSize;
+    cell.loading   = NO;
 }
 
 - (void)setPlaceholderImage:(UIImage* __nullable)image
@@ -546,13 +598,20 @@ - (void)setPlaceholderImage:(UIImage* __nullable)image
        the higher-res image is downloaded
      */
     cell.imageSize = info ? info.thumbSize : image.size;
+    if (!info) {
+        // only stop loading if info is nil, meaning that there's no high-res image coming
+        cell.loading = NO;
+    }
 }
 
 #pragma mark - WMFImageInfoControllerDelegate
 
 - (void)imageInfoController:(WMFImageInfoController*)controller didFetchBatch:(NSRange)range {
     NSIndexSet* fetchedIndexes = [NSIndexSet indexSetWithIndexesInRange:range];
-    [self forEachVisibleCell:^(WMFImageGalleryCollectionViewCell* cell, NSIndexPath* indexPath) {
+    [self.loadingIndicator stopAnimating];
+    [self.collectionView wmf_enumerateVisibleCellsUsingBlock:^(WMFImageGalleryCollectionViewCell* cell,
+                                                               NSIndexPath* indexPath,
+                                                               BOOL* _) {
         if ([fetchedIndexes containsIndex:indexPath.item]) {
             [self updateCell:cell atIndexPath:indexPath];
         }
@@ -562,8 +621,15 @@ - (void)imageInfoController:(WMFImageInfoController*)controller didFetchBatch:(N
 - (void)imageInfoController:(WMFImageInfoController*)controller
          failedToFetchBatch:(NSRange)range
                       error:(NSError*)error {
-    // TODO: only show errors on the cells for which we failed to get image info
     [self showAlert:error.localizedDescription type:ALERT_TYPE_TOP duration:-1];
+    NSIndexSet* failedIndexes = [NSIndexSet indexSetWithIndexesInRange:range];
+    [self.collectionView wmf_enumerateVisibleCellsUsingBlock:^(WMFImageGalleryCollectionViewCell* cell,
+                                                               NSIndexPath* indexPath,
+                                                               BOOL* _) {
+        if ([failedIndexes containsIndex:indexPath.item]) {
+            [self showError:error inCell:cell atIndexPath:indexPath];
+        }
+    }];
 }
 
 @end
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.h b/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.h
index 2def44e4234..08f9f22302d 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.h	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.h	
@@ -4,6 +4,8 @@
 
 #import <UIKit/UIKit.h>
 
+NS_ASSUME_NONNULL_BEGIN
+
 @class MWKArticle;
 @class MWKImage;
 @class MWKImageInfo;
@@ -22,7 +24,7 @@
 
 @interface WMFImageInfoController : NSObject
 
-@property (nonatomic, strong, readonly) MWKArticle* article;
+@property (nonatomic, strong, nullable) MWKArticle* article;
 
 @property (nonatomic, weak) id<WMFImageInfoControllerDelegate> delegate;
 
@@ -30,17 +32,17 @@
 @property (nonatomic, readonly) NSUInteger infoBatchSize;
 
 /// Lazily calculated snapshot of the uniqued images in the receiver's @c article.
-@property (nonatomic, readonly) NSArray* uniqueArticleImages;
+@property (nonatomic, strong, readonly) NSArray* uniqueArticleImages;
 
 ///
 /// @name Initialization
 ///
 
 /// Initialize with @c article, letting the receiver create the default @c fetcher and @c imageFetcher.
-- (instancetype)initWithArticle:(MWKArticle*)article batchSize:(NSUInteger)batchSize;
+- (instancetype)initWithArticle:(MWKArticle* __nullable)article batchSize:(NSUInteger)batchSize;
 
 /// Designated initializer.
-- (instancetype)initWithArticle:(MWKArticle*)article
+- (instancetype)initWithArticle:(MWKArticle* __nullable)article
                       batchSize:(NSUInteger)batchSize
                     infoFetcher:(MWKImageInfoFetcher*)fetcher;
 
@@ -54,10 +56,10 @@
  * @return The request to fetch the specified batch, or @c nil if it has already been fetched or the index is
  *         out of bounds.
  */
-- (id<MWKImageInfoRequest>)fetchBatchContainingIndex:(NSInteger)index;
+- (id<MWKImageInfoRequest> __nullable)fetchBatchContainingIndex:(NSInteger)index;
 
 /// Convenience for fetching batches for multiple target indexes at once.
-- (NSArray*)fetchBatchesContainingIndexes:(NSIndexSet*)indexes;
+- (NSArray* __nullable)fetchBatchesContainingIndexes:(NSIndexSet*)indexes;
 
 /**
  * Convenience for fetching the specified @c index as well as its neighbor.
@@ -70,16 +72,18 @@
  * Note that this will either result in one fetch (@c index and <code>index + next</code> is in the same batch or
  * two fetches if @c index and <code>index + next</code> are in different batches.
  */
-- (NSArray*)fetchBatchContainingIndex:(NSInteger)index withNthNeighbor:(NSUInteger)next;
+- (NSArray* __nullable)fetchBatchContainingIndex:(NSInteger)index withNthNeighbor:(NSUInteger)next;
 
 ///
 /// @name Getters
 ///
 
 /// @return The @c MWKImageInfo object which is associated with @c image, or @c nil if none exists.
-- (MWKImageInfo*)infoForImage:(MWKImage*)image;
+- (MWKImageInfo* __nullable)infoForImage:(MWKImage*)image;
 
 /// @return The index of the @c MWKImage associated with @c info, or @c NSNotFound.
 - (NSUInteger)indexOfImageAssociatedWithInfo:(MWKImageInfo*)info;
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.m b/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.m
index 8000893b35d..612249a3ce8 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.m	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController.m	
@@ -10,16 +10,18 @@
 #import "WikipediaAppUtils.h"
 #import "SessionSingleton.h"
 #import "MWNetworkActivityIndicatorManager.h"
-#import "NSArray+WMFExtensions.h"
+#import "NSArray+WMFLayoutDirectionUtilities.h"
 #import "NSIndexSet+BKReduce.h"
 
+NS_ASSUME_NONNULL_BEGIN
+
 #undef LOG_LEVEL_DEF
 #define LOG_LEVEL_DEF WMFImageInfoControllerLogLevel
 
 static const int LOG_LEVEL_DEF = DDLogLevelDebug;
 
 
-NSDictionary* WMFIndexImageInfo(NSArray* imageInfo){
+NSDictionary* WMFIndexImageInfo(NSArray* __nullable imageInfo){
     return [imageInfo bk_index:^id < NSCopying > (MWKImageInfo* info) {
         return info.imageAssociationValue ? : [NSNull null];
     }];
@@ -32,18 +34,17 @@ @implementation WMFImageInfoController
 @synthesize fetchedIndices      = _fetchedIndices;
 @synthesize uniqueArticleImages = _uniqueArticleImages;
 
-- (instancetype)initWithArticle:(MWKArticle*)article batchSize:(NSUInteger)batchSize {
+- (instancetype)initWithArticle:(MWKArticle* __nullable)article batchSize:(NSUInteger)batchSize {
     return [self initWithArticle:article batchSize:batchSize infoFetcher:[[MWKImageInfoFetcher alloc] initWithDelegate:nil]];
 }
 
-- (instancetype)initWithArticle:(MWKArticle*)article
+- (instancetype)initWithArticle:(MWKArticle* __nullable)article
                       batchSize:(NSUInteger)batchSize
                     infoFetcher:(MWKImageInfoFetcher*)fetcher {
     NSAssert(batchSize <= 50, @"Only up to 50 titles can be retrieved at a time.");
     self = [super init];
     if (self) {
         _article          = article;
-        _dataStore        = article.dataStore;
         _imageInfoFetcher = fetcher;
         _infoBatchSize    = batchSize;
     }
@@ -52,13 +53,28 @@ - (instancetype)initWithArticle:(MWKArticle*)article
 
 #pragma mark - Accessors
 
+- (void)setArticle:(MWKArticle* __nullable)article {
+    if ([_article isEqualToArticle:article]) {
+        return;
+    }
+    _article = article;
+
+    // reset all lazily-calculated properties and state
+    _uniqueArticleImages = nil;
+    _imageFilePageTitles = nil;
+    _indexedImageInfo    = nil;
+    _fetchedIndices      = nil;
+}
+
 - (NSArray*)uniqueArticleImages {
+    if (!self.article) {
+        return @[];
+    }
     if (!_uniqueArticleImages) {
         NSArray* uniqueArticleImages = [self.article.images uniqueLargestVariants];
 
         // reverse article images if current language is RTL
-        _uniqueArticleImages =
-            [WikipediaAppUtils isDeviceLanguageRTL] ? [uniqueArticleImages wmf_reverseArray] : uniqueArticleImages;
+        _uniqueArticleImages = [uniqueArticleImages wmf_reverseArrayIfApplicationIsRTL];;
 
         NSMutableArray* imageFilePageTitles = [NSMutableArray arrayWithCapacity:_uniqueArticleImages.count];
 
@@ -80,10 +96,13 @@ - (NSArray*)uniqueArticleImages {
         // strictly evaluate iamgeFilePageTitles to filter out any images don't have a canonicalFilename
         _imageFilePageTitles = [imageFilePageTitles copy];
     }
-    return _uniqueArticleImages;
+    return _uniqueArticleImages ? : @[];
 }
 
 - (NSDictionary*)indexedImageInfo {
+    if (!self.article) {
+        return @{};
+    }
     if (!_indexedImageInfo) {
         _indexedImageInfo =
             WMFIndexImageInfo([self.dataStore imageInfoForArticle:self.article]) ? : [NSMutableDictionary new];
@@ -91,6 +110,10 @@ - (NSDictionary*)indexedImageInfo {
     return _indexedImageInfo;
 }
 
+- (MWKDataStore* __nullable)dataStore {
+    return self.article.dataStore;
+}
+
 - (NSUInteger)indexOfImageAssociatedWithInfo:(MWKImageInfo*)info {
     return [self.uniqueArticleImages indexOfObjectPassingTest:^BOOL (MWKImage* img, NSUInteger idx, BOOL* stop) {
         if ([img isAssociatedWithInfo:info]) {
@@ -114,25 +137,25 @@ - (NSMutableIndexSet*)fetchedIndices {
             return acc;
         }];
     }
-    return _fetchedIndices;
+    return _fetchedIndices ? : [NSMutableIndexSet new];
 }
 
 - (BOOL)hasFetchedAllItems {
     return [self.fetchedIndices containsIndexesInRange:NSMakeRange(0, self.uniqueArticleImages.count)];
 }
 
-- (MWKImageInfo*)infoForImage:(MWKImage*)image {
+- (MWKImageInfo* __nullable)infoForImage:(MWKImage*)image {
     return self.indexedImageInfo[image.infoAssociationValue];
 }
 
 #pragma mark - Public Fetch
 
-- (id<MWKImageInfoRequest>)fetchBatchContainingIndex:(NSInteger)index {
+- (id<MWKImageInfoRequest> __nullable)fetchBatchContainingIndex:(NSInteger)index {
     return [self fetchBatch:[self batchRangeForTargetIndex:index]];
 }
 
-- (NSArray*)fetchBatchesContainingIndexes:(NSIndexSet*)indexes {
-    if (indexes.count == 0) {
+- (NSArray* __nullable)fetchBatchesContainingIndexes:(NSIndexSet*)indexes {
+    if (indexes.count == 0 || !self.article) {
         return nil;
     } else {
         return [indexes bk_reduce:[NSMutableArray new]
@@ -146,7 +169,7 @@ - (NSArray*)fetchBatchesContainingIndexes:(NSIndexSet*)indexes {
     }
 }
 
-- (NSArray*)fetchBatchContainingIndex:(NSInteger)index withNthNeighbor:(NSUInteger)next {
+- (NSArray* __nullable)fetchBatchContainingIndex:(NSInteger)index withNthNeighbor:(NSUInteger)next {
     NSAssert(next >= 0, @"No reason to call this method with next == 0");
     NSMutableIndexSet* indexes     = [NSMutableIndexSet indexSetWithIndex:index];
     NSUInteger const neighborIndex = index + next;
@@ -159,6 +182,9 @@ - (NSArray*)fetchBatchContainingIndex:(NSInteger)index withNthNeighbor:(NSUInteg
 #pragma mark - Private Fetch
 
 - (NSRange)batchRangeForTargetIndex:(NSUInteger)index {
+    if (!self.article) {
+        return WMFRangeMakeNotFound();
+    }
     NSParameterAssert(index < self.uniqueArticleImages.count);
     if (index > self.uniqueArticleImages.count) {
         DDLogWarn(@"Attempted to fetch %lu which is beoynd upper bound of %lu",
@@ -174,7 +200,10 @@ - (NSRange)batchRangeForTargetIndex:(NSUInteger)index {
     return range;
 }
 
-- (id<MWKImageInfoRequest>)fetchBatch:(NSRange)batch {
+- (id<MWKImageInfoRequest> __nullable)fetchBatch:(NSRange)batch {
+    if (!self.article) {
+        return nil;
+    }
     NSParameterAssert(!WMFRangeIsNotFoundOrEmpty(batch));
     if (WMFRangeIsNotFoundOrEmpty(batch)) {
         DDLogWarn(@"Attempted to fetch not found or empty range: %@", NSStringFromRange(batch));
@@ -194,13 +223,14 @@ - (NSRange)batchRangeForTargetIndex:(NSUInteger)index {
 
     [[MWNetworkActivityIndicatorManager sharedManager] push];
 
+    __weak MWKArticle* currentArticle = self.article;
     __weak __typeof__((self)) weakSelf = self;
     return [self.imageInfoFetcher fetchInfoForPageTitles:titlesToFetch
                                                 fromSite:self.article.site
                                                  success:^(NSArray* infoObjects) {
         [[MWNetworkActivityIndicatorManager sharedManager] pop];
         __typeof__((weakSelf)) strSelf = weakSelf;
-        if (!strSelf) {
+        if (!strSelf || ![currentArticle isEqualToArticle:strSelf.article]) {
             return;
         }
         NSDictionary* indexedInfo = WMFIndexImageInfo(infoObjects);
@@ -228,3 +258,5 @@ - (NSRange)batchRangeForTargetIndex:(NSUInteger)index {
 }
 
 @end
+
+NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController_Private.h b/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController_Private.h
index bf40e92719d..b23932d62fe 100644
--- a/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController_Private.h	
+++ b/Wikipedia/View Controllers/Image Gallery/WMFImageInfoController_Private.h	
@@ -19,6 +19,8 @@
 #import "MWKImageInfoFetcher.h"
 #import "MWKImageInfoResponseSerializer.h"
 
+NS_ASSUME_NONNULL_BEGIN
+
 extern NSDictionary* WMFIndexImageInfo(NSArray* imageInfo);
 
 @interface WMFImageInfoController ()
@@ -31,7 +33,7 @@ extern NSDictionary* WMFIndexImageInfo(NSArray* imageInfo);
 @property (nonatomic, strong, readonly) MWKImageInfoFetcher* imageInfoFetcher;
 
 /// Convenience getter for the receiver's <code>article.dataStore</code>.
-@property (nonatomic, strong, readonly) MWKDataStore* dataStore;
+@property (nonatomic, strong, nullable, readonly) MWKDataStore* dataStore;
 
 /// Lazily calculated array of "File:" titles from the contents of @c uniqueArticleImages
 @property (nonatomic, strong, readonly) NSArray* imageFilePageTitles;
@@ -40,6 +42,8 @@ extern NSDictionary* WMFIndexImageInfo(NSArray* imageInfo);
 
 - (NSRange)batchRangeForTargetIndex:(NSUInteger)index;
 
-- (id<MWKImageInfoRequest>)fetchBatch:(NSRange)batch;
+- (id<MWKImageInfoRequest> __nullable)fetchBatch:(NSRange)batch;
 
 @end
+
+NS_ASSUME_NONNULL_END
