diff --git a/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift b/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
index 62bc5d4fc7f..5d9796f5ce5 100644
--- a/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
+++ b/Wikipedia/Code/WMFArticleContainerViewController+TOC.swift
@@ -22,30 +22,54 @@ extension WMFArticleViewController : WMFTableOfContentsViewControllerDelegate {
 
     public func tableOfContentsController(controller: WMFTableOfContentsViewController,
                                           didSelectItem item: TableOfContentsItem) {
-        var dismissVCCompletionHandler: (() -> Void)?
-        if let section = item as? MWKSection {
-            // HAX: webview has issues scrolling when browser view is out of bounds, disable animation if needed
-            self.webViewController.scrollToSection(section, animated: true)
-            dismissVCCompletionHandler = {
-                // HAX: This is terrible, but iOS events not under our control would steal our focus if we didn't wait long enough here and due to problems in UIWebView, we cannot work around it either.
+        
+        switch tableOfContentsDisplayMode {
+        case WMFTableOfContentsDisplayModeInline:
+            updateTableOfContentsSectionOnScrollEnabled = false
+            if let section = item as? MWKSection {
+                self.webViewController.scrollToSection(section, animated: true)
                 dispatchOnMainQueueAfterDelayInSeconds(1) {
                     self.webViewController.accessibilityCursorToSection(section)
+                     self.updateTableOfContentsSectionOnScrollEnabled = true
+                }
+            } else if let footerItem = item as? TableOfContentsFooterItem {
+                let footerIndex = Int(footerItem.footerViewIndex.rawValue)
+                self.webViewController.scrollToFooterAtIndex(footerIndex)
+                dispatchOnMainQueueAfterDelayInSeconds(1) {
+                    self.webViewController.accessibilityCursorToFooterAtIndex(footerIndex)
+                    self.updateTableOfContentsSectionOnScrollEnabled = true
                 }
             }
-        } else if let footerItem = item as? TableOfContentsFooterItem {
-            let footerIndex = Int(footerItem.footerViewIndex.rawValue)
-            self.webViewController.scrollToFooterAtIndex(footerIndex)
-            dismissVCCompletionHandler = {
-                self.webViewController.accessibilityCursorToFooterAtIndex(footerIndex)
+        case WMFTableOfContentsDisplayModeModal:
+            fallthrough
+        default:
+            tableOfContentsDisplayState = WMFTableOfContentsDisplayStateModalHidden
+            var dismissVCCompletionHandler: (() -> Void)?
+            if let section = item as? MWKSection {
+                // HAX: webview has issues scrolling when browser view is out of bounds, disable animation if needed
+                self.webViewController.scrollToSection(section, animated: true)
+                dismissVCCompletionHandler = {
+                    // HAX: This is terrible, but iOS events not under our control would steal our focus if we didn't wait long enough here and due to problems in UIWebView, we cannot work around it either.
+                    dispatchOnMainQueueAfterDelayInSeconds(1) {
+                        self.webViewController.accessibilityCursorToSection(section)
+                    }
+                }
+            } else if let footerItem = item as? TableOfContentsFooterItem {
+                let footerIndex = Int(footerItem.footerViewIndex.rawValue)
+                self.webViewController.scrollToFooterAtIndex(footerIndex)
+                dismissVCCompletionHandler = {
+                    self.webViewController.accessibilityCursorToFooterAtIndex(footerIndex)
+                }
+            } else {
+                assertionFailure("Unsupported selection of TOC item \(item)")
+            }
+            
+            // Don't dismiss immediately - it looks jarring - let the user see the ToC selection before dismissing
+            dispatchOnMainQueueAfterDelayInSeconds(0.25) {
+                self.dismissViewControllerAnimated(true, completion: dismissVCCompletionHandler)
             }
-        } else {
-            assertionFailure("Unsupported selection of TOC item \(item)")
-        }
-
-        // Don't dismiss immediately - it looks jarring - let the user see the ToC selection before dismissing
-        dispatchOnMainQueueAfterDelayInSeconds(0.25) {
-            self.dismissViewControllerAnimated(true, completion: dismissVCCompletionHandler)
         }
+        
     }
 
     public func tableOfContentsControllerDidCancel(controller: WMFTableOfContentsViewController) {
@@ -144,7 +168,7 @@ extension WMFArticleViewController {
             }
         #endif
         
-        return tableOfContentsModal && !NSUserDefaults.standardUserDefaults().wmf_didPeekTableOfContents()
+        return (self.tableOfContentsDisplayMode == WMFTableOfContentsDisplayModeModal) && !NSUserDefaults.standardUserDefaults().wmf_didPeekTableOfContents()
     }
 
     public func peekTableOfContentsIfNeccesary() {
diff --git a/Wikipedia/Code/WMFArticleViewController.h b/Wikipedia/Code/WMFArticleViewController.h
index 340b4ab918d..ef6df344e86 100644
--- a/Wikipedia/Code/WMFArticleViewController.h
+++ b/Wikipedia/Code/WMFArticleViewController.h
@@ -8,6 +8,18 @@
 @class WMFShareFunnel;
 @class WMFArticleViewController;
 
+typedef enum : NSUInteger {
+    WMFTableOfContentsDisplayModeModal,
+    WMFTableOfContentsDisplayModeInline
+} WMFTableOfContentsDisplayMode;
+
+typedef enum : NSUInteger {
+    WMFTableOfContentsDisplayStateInlineVisible,
+    WMFTableOfContentsDisplayStateInlineHidden,
+    WMFTableOfContentsDisplayStateModalVisible,
+    WMFTableOfContentsDisplayStateModalHidden
+} WMFTableOfContentsDisplayState;
+
 NS_ASSUME_NONNULL_BEGIN
 
 
@@ -36,9 +48,9 @@ NS_ASSUME_NONNULL_BEGIN
 
 @property (nonatomic, weak) id<WMFArticleViewControllerDelegate> delegate;
 
-@property (nonatomic, getter=isTableOfContentsModal) BOOL tableOfContentsModal; //whether or not the TOC is or should be presented modally
-@property (nonatomic, getter=isTableOfContentsVisible) BOOL tableOfContentsVisible; //whether or not the TOC is visible in non-modal mode
-@property (nonatomic, getter=isTableOfContentsSectionUpdateEnabled) BOOL tableOfContentsSectionUpdateEnabled;
+@property (nonatomic) WMFTableOfContentsDisplayMode tableOfContentsDisplayMode;
+@property (nonatomic) WMFTableOfContentsDisplayState tableOfContentsDisplayState;
+@property (nonatomic, getter=isUpdateTableOfContentsSectionOnScrollEnabled) BOOL updateTableOfContentsSectionOnScrollEnabled;
 
 @end
 
diff --git a/Wikipedia/Code/WMFArticleViewController.m b/Wikipedia/Code/WMFArticleViewController.m
index dd6781eaf3a..11cd2ec60a7 100644
--- a/Wikipedia/Code/WMFArticleViewController.m
+++ b/Wikipedia/Code/WMFArticleViewController.m
@@ -419,14 +419,23 @@ - (void)getShareText:(void (^)(NSString* text))completion {
             self.findInPageToolbarItem,
             [UIBarButtonItem wmf_barButtonItemOfFixedWidth:2.f],
             nil];
-    if (self.isTableOfContentsModal) {
-        [articleToolbarItems addObject:[UIBarButtonItem flexibleSpaceToolbarItem]];
-        [articleToolbarItems addObject:[UIBarButtonItem wmf_barButtonItemOfFixedWidth:8.f]];
-        [articleToolbarItems addObject:self.tableOfContentsToolbarItem];
-    } else {
-        [articleToolbarItems insertObject:self.tableOfContentsToolbarItem atIndex:0];
-        [articleToolbarItems insertObject:[UIBarButtonItem wmf_barButtonItemOfFixedWidth:8.f] atIndex:1];
-        [articleToolbarItems insertObject:[UIBarButtonItem flexibleSpaceToolbarItem] atIndex:2];
+    
+    switch (self.tableOfContentsDisplayMode) {
+        case WMFTableOfContentsDisplayModeModal:
+        {
+            [articleToolbarItems addObject:[UIBarButtonItem flexibleSpaceToolbarItem]];
+            [articleToolbarItems addObject:[UIBarButtonItem wmf_barButtonItemOfFixedWidth:8.f]];
+            [articleToolbarItems addObject:self.tableOfContentsToolbarItem];
+        }
+            break;
+        case WMFTableOfContentsDisplayModeInline:
+        default:
+        {
+            [articleToolbarItems insertObject:self.tableOfContentsToolbarItem atIndex:0];
+            [articleToolbarItems insertObject:[UIBarButtonItem wmf_barButtonItemOfFixedWidth:8.f] atIndex:1];
+            [articleToolbarItems insertObject:[UIBarButtonItem flexibleSpaceToolbarItem] atIndex:2];
+        }
+            break;
     }
     return articleToolbarItems;
 }
@@ -710,15 +719,15 @@ - (void)setUpTitleBarButton {
 - (void)viewDidLoad {
     [super viewDidLoad];
     
-    [self updateTableOfContentsWithTraitCollection:self.traitCollection];
-    self.tableOfContentsVisible = !self.tableOfContentsModal;
+    [self updateTableOfContentsDisplayModeWithTraitCollection:self.traitCollection];
+    
+    self.tableOfContentsDisplayState = self.tableOfContentsDisplayMode == WMFTableOfContentsDisplayModeInline ? WMFTableOfContentsDisplayStateInlineVisible : WMFTableOfContentsDisplayStateModalHidden;
     
     [self.navigationController.toolbar wmf_applySolidWhiteBackgroundWithTopShadow];
 
     [self updateToolbar];
 
     [self setUpTitleBarButton];
-    self.view.clipsToBounds                   = NO;
     self.automaticallyAdjustsScrollViewInsets = YES;
     self.view.backgroundColor = [UIColor whiteColor];
 
@@ -775,13 +784,13 @@ - (void)traitCollectionDidChange:(nullable UITraitCollection*)previousTraitColle
 
 - (void)layoutForSize:(CGSize)size {
     CGFloat separatorWidth = WMFArticleViewControllerTableOfContentsSeparatorWidth;
-    CGFloat tocWidth = size.width*WMFArticleViewControllerExpandedTableOfContentsWidthPercentage;
-    BOOL isTOCVisible = !self.isTableOfContentsModal && [self hasTableOfContents] && self.isTableOfContentsVisible;
+    CGFloat tocWidth = round(size.width*WMFArticleViewControllerExpandedTableOfContentsWidthPercentage);
+    BOOL isTOCVisible = self.tableOfContentsDisplayState == WMFTableOfContentsDisplayStateInlineVisible;
     CGFloat tocOriginX = isTOCVisible ? 0 : 0 - tocWidth - separatorWidth;
     CGFloat separatorOriginX = isTOCVisible ? tocWidth : 0 - separatorWidth;
     
     CGPoint origin = CGPointZero;
-    if (!self.isTableOfContentsModal) {
+    if (self.tableOfContentsDisplayMode != WMFTableOfContentsDisplayModeModal) {
         self.tableOfContentsViewController.view.frame = CGRectMake(tocOriginX, origin.y, tocWidth, size.height);
         self.tableOfContentsSeparatorView.frame = CGRectMake(separatorOriginX, origin.y, separatorWidth, size.height);
     }
@@ -796,8 +805,17 @@ - (void)viewDidLayoutSubviews {
     [self layoutForSize:self.view.bounds.size];
 }
 
-- (void)updateTableOfContentsWithTraitCollection:(UITraitCollection *)traitCollection {
-    self.tableOfContentsModal = traitCollection.horizontalSizeClass == UIUserInterfaceSizeClassCompact;
+- (void)updateTableOfContentsDisplayModeWithTraitCollection:(UITraitCollection *)traitCollection {
+    self.tableOfContentsDisplayMode = traitCollection.horizontalSizeClass == UIUserInterfaceSizeClassCompact ? WMFTableOfContentsDisplayModeModal : WMFTableOfContentsDisplayModeInline;
+    switch (self.tableOfContentsDisplayMode) {
+        case WMFTableOfContentsDisplayModeInline:
+            self.updateTableOfContentsSectionOnScrollEnabled = YES;
+            break;
+        case WMFTableOfContentsDisplayModeModal:
+        default:
+            self.updateTableOfContentsSectionOnScrollEnabled = NO;
+            break;
+    }
 }
 
 - (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator {
@@ -809,8 +827,8 @@ - (void)viewWillTransitionToSize:(CGSize)size withTransitionCoordinator:(id<UIVi
 
 - (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id <UIViewControllerTransitionCoordinator>)coordinator {
     [super willTransitionToTraitCollection:newCollection withTransitionCoordinator:coordinator];
-    [self updateTableOfContentsWithTraitCollection:newCollection];
-    [self setupTableOfContentsViewControllerForDisplayModal:self.tableOfContentsModal];
+    [self updateTableOfContentsDisplayModeWithTraitCollection:newCollection];
+    [self setupTableOfContentsViewController];
 }
 
 #pragma mark - Web View Setup
@@ -831,38 +849,77 @@ - (void)setupWebView {
 #pragma mark - Table of Contents
 
 - (void)hideOrShowTableOfContents {
-    if (self.tableOfContentsModal) {
-        [self presentViewController:self.tableOfContentsViewController animated:YES completion:NULL];
-    } else {
-        self.tableOfContentsVisible = !self.tableOfContentsVisible;
-        [UIView animateWithDuration:0.25 animations:^{
-            [self layoutForSize:self.view.bounds.size];
-        }];
+    switch (self.tableOfContentsDisplayMode) {
+        case WMFTableOfContentsDisplayModeInline:
+        {
+            self.tableOfContentsDisplayState = self.tableOfContentsDisplayState == WMFTableOfContentsDisplayStateInlineVisible ? WMFTableOfContentsDisplayStateInlineHidden : WMFTableOfContentsDisplayStateInlineVisible;
+            [UIView animateWithDuration:0.25 animations:^{
+                [self layoutForSize:self.view.bounds.size];
+            }];
+        }
+            break;
+        case WMFTableOfContentsDisplayModeModal:
+        default:
+        {
+            self.tableOfContentsDisplayState = WMFTableOfContentsDisplayStateModalVisible;
+            [self presentViewController:self.tableOfContentsViewController animated:YES completion:NULL];
+        }
+            break;
     }
 }
 
-- (void)setupTableOfContentsViewControllerForDisplayModal:(BOOL)modal {
-    if (modal) {
-        if (self.tableOfContentsViewController.parentViewController == self) {
-            [self.tableOfContentsViewController willMoveToParentViewController:nil];
-            [self.tableOfContentsViewController.view removeFromSuperview];
-            [self.tableOfContentsViewController removeFromParentViewController];
-            [self.tableOfContentsSeparatorView removeFromSuperview];
-        }
-    } else if (self.tableOfContentsViewController.parentViewController != self) {
-        if (!modal && self.presentedViewController == self.tableOfContentsViewController) {
-            [self dismissViewControllerAnimated:NO completion:NULL];
-            self.tableOfContentsVisible = YES;
+- (void)setupTableOfContentsViewController {
+    switch (self.tableOfContentsDisplayMode) {
+        case WMFTableOfContentsDisplayModeInline:
+        {
+            if (self.tableOfContentsViewController.parentViewController != self) {
+                if (self.presentedViewController == self.tableOfContentsViewController) {
+                    [self dismissViewControllerAnimated:NO completion:NULL];
+                    
+                }
+                
+                switch (self.tableOfContentsDisplayState) {
+                    case WMFTableOfContentsDisplayStateModalHidden:
+                        self.tableOfContentsDisplayState = WMFTableOfContentsDisplayStateInlineHidden;
+                        break;
+                    case WMFTableOfContentsDisplayStateModalVisible:
+                        self.tableOfContentsDisplayState = WMFTableOfContentsDisplayStateInlineVisible;
+                    default:
+                        break;
+                }
+
+                if (self.tableOfContentsSeparatorView == nil) {
+                    self.tableOfContentsSeparatorView = [[UIView alloc] init];
+                    self.tableOfContentsSeparatorView.backgroundColor = [UIColor wmf_lightGrayColor];
+                }
+                [self.view insertSubview:self.tableOfContentsSeparatorView atIndex:0];
+                [self createTableOfContentsViewControllerIfNeeded];
+                [self addChildViewController:self.tableOfContentsViewController];
+                [self.view insertSubview:self.tableOfContentsViewController.view atIndex:0];
+                [self.tableOfContentsViewController didMoveToParentViewController:self];
+            }
         }
-        if (self.tableOfContentsSeparatorView == nil) {
-            self.tableOfContentsSeparatorView = [[UIView alloc] init];
-            self.tableOfContentsSeparatorView.backgroundColor = [UIColor wmf_lightGrayColor];
+        break;
+        default:
+        case WMFTableOfContentsDisplayModeModal:
+        {
+            switch (self.tableOfContentsDisplayState) {
+                case WMFTableOfContentsDisplayStateInlineVisible:
+                case WMFTableOfContentsDisplayStateInlineHidden:
+                    self.tableOfContentsDisplayState = WMFTableOfContentsDisplayStateModalHidden;
+                    break;
+                default:
+                    break;
+            }
+            if (self.tableOfContentsViewController.parentViewController == self) {
+                [self.tableOfContentsViewController willMoveToParentViewController:nil];
+                [self.tableOfContentsViewController.view removeFromSuperview];
+                [self.tableOfContentsViewController removeFromParentViewController];
+                [self.tableOfContentsSeparatorView removeFromSuperview];
+            }
+
         }
-        [self.view insertSubview:self.tableOfContentsSeparatorView atIndex:0];
-        [self createTableOfContentsViewControllerIfNeeded];
-        [self addChildViewController:self.tableOfContentsViewController];
-        [self.view insertSubview:self.tableOfContentsViewController.view atIndex:0];
-        [self.tableOfContentsViewController didMoveToParentViewController:self];
+        break;
     }
     [self updateToolbar];
 }
@@ -1122,8 +1179,8 @@ - (void)webViewController:(WebViewController*)controller didLoadArticle:(MWKArti
         });
     }];
 
-    if (!self.isTableOfContentsModal) {
-        [self setupTableOfContentsViewControllerForDisplayModal:self.isTableOfContentsModal];
+    if (self.tableOfContentsDisplayMode != WMFTableOfContentsDisplayModeModal) {
+        [self setupTableOfContentsViewController];
         [self layoutForSize:self.view.bounds.size];
         [self.tableOfContentsViewController selectAndScrollToItemAtIndex:0 animated:NO];
     }
@@ -1158,7 +1215,7 @@ - (nullable NSString*)webViewController:(WebViewController*)controller titleForF
 }
 
 - (void)webViewController:(WebViewController*)controller scrollViewDidScroll:(UIScrollView*)scrollView {
-    if (self.isTableOfContentsSectionUpdateEnabled && ABS(self.previousContentOffsetYForTOCUpdate - scrollView.contentOffset.y) > WMFArticleViewControllerTableOfContentsSectionUpdateScrollDistance) {
+    if (self.isUpdateTableOfContentsSectionOnScrollEnabled && ABS(self.previousContentOffsetYForTOCUpdate - scrollView.contentOffset.y) > WMFArticleViewControllerTableOfContentsSectionUpdateScrollDistance) {
         
         [self.webViewController getCurrentVisibleSectionCompletion:^(MWKSection * _Nullable section, NSError * _Nullable error) {
             if (section) {
