diff --git a/wikipedia/View Controllers/Root/RootViewController.h b/wikipedia/View Controllers/Root/RootViewController.h
index ef586a62be3..b661a750e5e 100644
--- a/wikipedia/View Controllers/Root/RootViewController.h	
+++ b/wikipedia/View Controllers/Root/RootViewController.h	
@@ -12,7 +12,9 @@
 
 @property (nonatomic) BOOL topMenuHidden;
 
-- (void)animateTopAndBottomMenuToggle;
+@property (nonatomic) BOOL isAnimatingTopAndBottomMenuHidden;
+
+- (void)animateTopAndBottomMenuHidden:(BOOL)hidden;
 
 - (void)togglePrimaryMenu;
 
diff --git a/wikipedia/View Controllers/Root/RootViewController.m b/wikipedia/View Controllers/Root/RootViewController.m
index 73aac5a881b..3c536fd68b7 100644
--- a/wikipedia/View Controllers/Root/RootViewController.m	
+++ b/wikipedia/View Controllers/Root/RootViewController.m	
@@ -50,9 +50,9 @@ -(void)setTopMenuHidden:(BOOL)topMenuHidden
     // Fade out the top menu when it is hidden.
     CGFloat alpha = topMenuHidden ? 0.0 : 1.0;
 
-    self.topMenuViewController.navBarContainer.alpha = alpha;
-
+    // Note: don't fade out the navBarContainer or the line at its bottom gets hidden!
     //self.topMenuViewController.navBarContainer.alpha = alpha;
+    
     for (UIView *v in self.topMenuViewController.navBarContainer.subviews) {
         v.alpha = alpha;
     }
@@ -230,14 +230,19 @@ -(void)updateTopMenuVisibilityConstraint
     self.centerContainerTopConstraint.constant = topMenuHeight;
 }
 
--(void)animateTopAndBottomMenuToggle
+-(void)animateTopAndBottomMenuHidden:(BOOL)hidden
 {
+    // Don't toggle if hidden state isn't different or if it's already toggling.
+    if ((self.topMenuHidden == hidden) || self.isAnimatingTopAndBottomMenuHidden) return;
+
+    self.isAnimatingTopAndBottomMenuHidden = YES;
+    
     // Queue it up so web view doesn't get blanked out.
     [[NSOperationQueue mainQueue] addOperationWithBlock:^{
 
-        [UIView animateWithDuration:0.15f delay:0.0f options:UIViewAnimationOptionBeginFromCurrentState animations:^{
+        [UIView animateWithDuration:0.12f delay:0.0f options:UIViewAnimationOptionBeginFromCurrentState animations:^{
             
-            self.topMenuHidden = !self.topMenuHidden;
+            self.topMenuHidden = hidden;
 
             WebViewController *webVC = [NAV searchNavStackForViewControllerOfClass:[WebViewController class]];
             webVC.bottomMenuHidden = self.topMenuHidden;
@@ -250,6 +255,7 @@ -(void)animateTopAndBottomMenuToggle
             [self.view.superview layoutIfNeeded];
             
         } completion:^(BOOL done){
+            self.isAnimatingTopAndBottomMenuHidden = NO;
         }];
         
     }];
diff --git a/wikipedia/View Controllers/WebView/WebViewController.m b/wikipedia/View Controllers/WebView/WebViewController.m
index 27ecee1f513..224ce08393d 100644
--- a/wikipedia/View Controllers/WebView/WebViewController.m	
+++ b/wikipedia/View Controllers/WebView/WebViewController.m	
@@ -868,6 +868,10 @@ -(void)resetBridge
         
         // @todo merge this link title extraction into MWSite
         if ([href hasPrefix:@"/wiki/"]) {
+
+            // Ensure the menu is visible when navigating to new page.
+            [weakSelf animateTopAndBottomMenuReveal];
+        
             NSString *title = [href substringWithRange:NSMakeRange(6, href.length - 6)];
             MWPageTitle *pageTitle = [MWPageTitle titleWithString:title];
 
@@ -925,11 +929,7 @@ -(void)resetBridge
     [self.bridge addListener:@"nonAnchorTouchEndedWithoutDragging" withBlock:^(NSString *messageType, NSDictionary *payload) {
         NSLog(@"nonAnchorTouchEndedWithoutDragging = %@", payload);
 
-        if (!weakSelf.tocVC) {
-            if (ROOT.topMenuViewController.navBarMode != NAVBAR_MODE_SEARCH) {
-                [ROOT animateTopAndBottomMenuToggle];
-            }
-        }
+        [weakSelf animateTopAndBottomMenuReveal];
 
         // nonAnchorTouchEndedWithoutDragging is used so TOC may be hidden if user tapped, but did *not* drag.
         // Used because UIWebView is difficult to attach one-finger touch events to.
@@ -1073,25 +1073,6 @@ -(void)webViewFinishedLoading
 
 - (void)scrollViewDidScroll:(UIScrollView *)scrollView
 {
-    /*
-    // Hides nav bar when a scroll threshold is exceeded. Probably only want to do this
-    // when the webView's scrollView scrolls. Probably also want to set the status bar to
-    // be not transparent when the nav bar is hidden - if not possible could position a
-    // view just behind it, but above the webView.
-    if (scrollView == self.webView.scrollView) {
-        CGFloat f = scrollViewDragBeganVerticalOffset_ - scrollView.contentOffset.y;
-        if (f < -55 && ![UIApplication sharedApplication].statusBarHidden) {
-            [self.navigationController setNavigationBarHidden:YES animated:YES];
-            //[[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:UIStatusBarAnimationNone];
-            //[[UIApplication sharedApplication] setStatusBarHidden:YES withAnimation:UIStatusBarAnimationSlide];
-        }else if (f > 55 && [UIApplication sharedApplication].statusBarHidden) {
-              [self.navigationController setNavigationBarHidden:NO animated:YES];
-            //[[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationNone];
-            //[[UIApplication sharedApplication] setStatusBarHidden:NO withAnimation:UIStatusBarAnimationSlide];
-        }
-    }
-    */
-
     // Hide the keyboard if it was visible when the results are scrolled, but only if
     // the results have been scrolled in excess of some small distance threshold first.
     // This prevents tiny scroll adjustments, which seem to occur occasionally for some
@@ -1104,6 +1085,8 @@ - (void)scrollViewDidScroll:(UIScrollView *)scrollView
         //NSLog(@"Keyboard Hidden!");
     }
     
+    [self adjustTopAndBottomMenuVisibilityOnScroll];
+
     [self updatePullToRefreshForScrollView:scrollView];
 }
 
@@ -1118,7 +1101,39 @@ - (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView
     [self saveWebViewScrollOffset];
 }
 
-#pragma Memory
+#pragma mark Menus auto show-hide on scroll / reveal on tap
+
+-(void)adjustTopAndBottomMenuVisibilityOnScroll
+{
+    // This method causes the menus to hide when user scrolls down and show when they scroll up.
+    if (self.webView.scrollView.isDragging && ![self tocDrawerIsOpen]){
+        CGFloat distanceScrolled = scrollViewDragBeganVerticalOffset_ - self.webView.scrollView.contentOffset.y;
+        CGFloat minPixelsScrolled = 20;
+        if (fabsf(distanceScrolled) < minPixelsScrolled) return;
+        [ROOT animateTopAndBottomMenuHidden:((distanceScrolled > 0) ? NO : YES)];
+    }
+}
+
+-(void)animateTopAndBottomMenuReveal
+{
+    // Toggle the menus closed on tap (only if they were showing).
+    if (!self.tocVC) {
+        if (ROOT.topMenuViewController.navBarMode != NAVBAR_MODE_SEARCH) {
+            if (![self tocDrawerIsOpen]){
+                [ROOT animateTopAndBottomMenuHidden:NO];
+            }
+        }
+    }
+}
+
+- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView
+{
+    // Called when the title bar is tapped.
+    [self animateTopAndBottomMenuReveal];
+    return YES;
+}
+
+#pragma mark Memory
 
 - (void)didReceiveMemoryWarning
 {
@@ -1800,6 +1815,8 @@ -(void)constrainPullToRefresh
 
 - (void)updatePullToRefreshForScrollView:(UIScrollView *)scrollView
 {
+    if (ROOT.isAnimatingTopAndBottomMenuHidden) return;
+
     CGFloat pullDistance = (UIInterfaceOrientationIsPortrait(self.interfaceOrientation)) ? 85.0f : 55.0f;
 
     UIGestureRecognizerState state = ((UIPinchGestureRecognizer *)scrollView.pinchGestureRecognizer).state;
