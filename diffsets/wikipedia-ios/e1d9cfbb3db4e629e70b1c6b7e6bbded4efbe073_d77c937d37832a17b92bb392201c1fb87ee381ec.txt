diff --git a/Wikipedia/Code/ArticleScrolling.swift b/Wikipedia/Code/ArticleScrolling.swift
index d0c1afa5665..0ad72d97c55 100644
--- a/Wikipedia/Code/ArticleScrolling.swift
+++ b/Wikipedia/Code/ArticleScrolling.swift
@@ -16,10 +16,10 @@ extension ArticleScrolling where Self: ViewController {
     // There is also some related code in ViewController.scrollViewDidEndScrollingAnimation
     // It's a tad hacky, but we need to call something on it and the function can't be overridden here.
 
-    func scroll(to anchor: String, centered: Bool = false, highlighted: Bool = false, animated: Bool, completion: (() -> Void)? = nil) {
+    func scroll(to anchor: String, centered: Bool = false, highlighted: Bool = false, animated: Bool, completion: ((Bool) -> Void)? = nil) {
         guard !anchor.isEmpty else {
             webView.scrollView.scrollRectToVisible(CGRect(x: 0, y: 1, width: 1, height: 1), animated: animated)
-            completion?()
+            completion?(true)
             return
         }
 
@@ -28,8 +28,10 @@ extension ArticleScrolling where Self: ViewController {
             switch result {
             case .failure(let error):
                 self.showError(error)
-                completion?()
+                completion?(false)
             case .success:
+                // The actual scroll happens via a callback event from the WebView
+                // When that event is received, the scrollToAnchorCompletion is called
                 let scrollCompletion: ScrollToAnchorCompletion = { (anchor, rect) in
                     let point = CGPoint(x: self.webView.scrollView.contentOffset.x, y: rect.origin.y + self.webView.scrollView.contentOffset.y)
                     self.scroll(to: point, centered: centered, animated: animated, completion: completion)
@@ -39,11 +41,11 @@ extension ArticleScrolling where Self: ViewController {
         }
     }
 
-    func scroll(to offset: CGPoint, centered: Bool = false, animated: Bool, completion: (() -> Void)? = nil) {
+    func scroll(to offset: CGPoint, centered: Bool = false, animated: Bool, completion: ((Bool) -> Void)? = nil) {
         assert(Thread.isMainThread)
         let scrollView = webView.scrollView
         guard !offset.x.isNaN && !offset.x.isInfinite && !offset.y.isNaN && !offset.y.isInfinite else {
-            completion?()
+            completion?(false)
             return
         }
         let overlayTop = self.webView.iOS12yOffsetHack + self.navigationBar.hiddenHeight
@@ -55,18 +57,26 @@ extension ArticleScrolling where Self: ViewController {
         } else {
             adjustmentY = overlayTop
         }
+        let y = offset.y + adjustmentY
         let minY = 0 - scrollView.contentInset.top
+        guard y > minY else {
+            completion?(false)
+            return
+        }
         let maxY = scrollView.contentSize.height - scrollView.bounds.height + scrollView.contentInset.bottom
-        let boundedY = min(maxY,  max(minY, offset.y + adjustmentY))
-        let boundedOffset = CGPoint(x: scrollView.contentOffset.x, y: boundedY)
+        guard y < maxY else {
+            completion?(false)
+            return
+        }
+        let boundedOffset = CGPoint(x: scrollView.contentOffset.x, y: y)
         guard WMFDistanceBetweenPoints(boundedOffset, scrollView.contentOffset) >= 2 else {
             scrollView.flashScrollIndicators()
-            completion?()
+            completion?(true)
             return
         }
         guard animated else {
             scrollView.setContentOffset(boundedOffset, animated: false)
-            completion?()
+            completion?(true)
             return
         }
         /*
@@ -79,9 +89,7 @@ extension ArticleScrolling where Self: ViewController {
          It appears the only reliable way to get a callback after the default
          animation is to use scrollViewDidEndScrollingAnimation
          */
-        if let completion = completion {
-            scrollViewAnimationCompletions.insert(completion, at: 0)
-        }
+        scrollViewAnimationCompletions.insert({ completion?(true) }, at: 0)
         scrollView.setContentOffset(boundedOffset, animated: true)
     }
 
diff --git a/Wikipedia/Code/ArticleViewController+References.swift b/Wikipedia/Code/ArticleViewController+References.swift
index ac54f2b2237..e9b23c4fc56 100644
--- a/Wikipedia/Code/ArticleViewController+References.swift
+++ b/Wikipedia/Code/ArticleViewController+References.swift
@@ -17,7 +17,7 @@ extension ArticleViewController: ReferenceBackLinksViewControllerDelegate, WMFRe
     }
 
     func referenceBackLinksViewControllerUserDidNavigateTo(referenceBackLink: ReferenceBackLink, referenceBackLinksViewController: ReferenceBackLinksViewController) {
-        scroll(to: referenceBackLink.id, centered: true, highlighted: true, animated: true) { [weak self] in
+        scroll(to: referenceBackLink.id, centered: true, highlighted: true, animated: true) { [weak self] (_) in
             self?.webView.wmf_accessibilityCursor(toFragment: referenceBackLink.id)
         }
     }
@@ -29,7 +29,7 @@ extension ArticleViewController: ReferenceBackLinksViewControllerDelegate, WMFRe
             return
         }
         let backLink = "back_link_\(referenceId)"
-        scroll(to: backLink, highlighted: true, animated: true) { [weak self] in
+        scroll(to: backLink, highlighted: true, animated: true) { [weak self] (_) in
             self?.webView.wmf_accessibilityCursor(toFragment: backLink)
             dispatchOnMainQueueAfterDelayInSeconds(1.0) { [weak self] in
                 self?.messagingController.removeElementHighlights()
diff --git a/Wikipedia/Code/ArticleViewController.swift b/Wikipedia/Code/ArticleViewController.swift
index 21e1d4781aa..dd11995a539 100644
--- a/Wikipedia/Code/ArticleViewController.swift
+++ b/Wikipedia/Code/ArticleViewController.swift
@@ -27,8 +27,6 @@ class ArticleViewController: ViewController, HintPresenting {
     /// Scroll to the last viewed scroll position in this case
     /// Also prioritize pulling data from cache (without revision/etag validation) so the user sees the article as quickly as possible
     var isRestoringState: Bool = false
-    /// Set internally to wait for content size changes to chill before restoring the scroll offset
-    var isRestoringStateOnNextContentSizeChange: Bool = false
     
     /// Called when initial load starts
     @objc public var loadCompletion: (() -> Void)?
@@ -116,8 +114,6 @@ class ArticleViewController: ViewController, HintPresenting {
     lazy var webView: WKWebView = {
         return WMFWebView(frame: view.bounds, configuration: webViewConfiguration)
     }()
-
-    private var verticalOffsetPercentageToRestore: CGFloat?
     
     // MARK: HintPresenting
     
@@ -250,22 +246,6 @@ class ArticleViewController: ViewController, HintPresenting {
         updateLeadImageMargins()
     }
 
-    internal func stashOffsetPercentage() {
-        let offset = webView.scrollView.verticalOffsetPercentage
-        // negative and 0 offsets make small errors in scrolling, allow it to automatically handle those cases
-        if offset > 0 {
-            verticalOffsetPercentageToRestore = offset
-        }
-    }
-
-    private func restoreOffsetPercentageIfNecessary() {
-        guard let verticalOffsetPercentage = verticalOffsetPercentageToRestore else {
-            return
-        }
-        verticalOffsetPercentageToRestore = nil
-        webView.scrollView.verticalOffsetPercentage = verticalOffsetPercentage
-    }
-
     override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
         stashOffsetPercentage()
         super.viewWillTransition(to: size, with: coordinator)
@@ -371,7 +351,7 @@ class ArticleViewController: ViewController, HintPresenting {
     }
     
     /// Waits for the article and article summary to finish loading (or re-loading) and performs post load actions
-    func setupArticleLoadWaitGroup() {
+    private func setupArticleLoadWaitGroup() {
         assert(Thread.isMainThread)
         
         guard articleLoadWaitGroup == nil else {
@@ -383,6 +363,7 @@ class ArticleViewController: ViewController, HintPresenting {
         articleLoadWaitGroup?.notify(queue: DispatchQueue.main) { [weak self] in
             self?.setupFooter()
             self?.shareIfNecessary()
+            self?.restoreScrollStateIfNecessary()
             self?.articleLoadWaitGroup = nil
         }
         
@@ -477,7 +458,67 @@ class ArticleViewController: ViewController, HintPresenting {
         significantlyViewedTimer = nil
     }
     
-    // MARK: State Restoration
+    // MARK: Scroll State Restoration
+    
+    /// Tracks restoring scroll position, either through state restoration, rotating the article, or opening an article to a particular section
+    private enum ScrollRestorationState {
+        case none
+        /// Scroll to absolute Y offset
+        case scrollToOffset(_ offsetY: CGFloat, animated: Bool, attempt: Int = 1, completion: (() -> Void)? = nil)
+        /// Scroll to percentage Y offset
+        case scrollToPercentage(_ percentageOffsetY: CGFloat)
+        /// Scroll to anchor, an id of an element on the page
+        case scrollToAnchor(_ anchor: String, attempt: Int = 1)
+    }
+    
+    private var scrollRestorationState: ScrollRestorationState = .none
+    
+    /// Checks scrollRestorationState and performs the neessary scroll restoration
+    private func restoreScrollStateIfNecessary() {
+        switch scrollRestorationState {
+        case .none:
+            break
+        case .scrollToOffset(let offset, let animated, let attempt, let completion):
+            scrollRestorationState = .none
+            self.scroll(to: CGPoint(x: 0, y: offset), animated: animated) { [weak self] (success) in
+                // Retry on failure up to 5 times
+                guard !success, attempt < 5 else {
+                    return
+                }
+                completion?()
+                self?.scrollRestorationState = .scrollToOffset(offset, animated: animated, attempt: attempt + 1, completion: completion)
+            }
+        case .scrollToPercentage(let verticalOffsetPercentage):
+            scrollRestorationState = .none
+            webView.scrollView.verticalOffsetPercentage = verticalOffsetPercentage
+        case .scrollToAnchor(let anchor, let attempt):
+            scrollRestorationState = .none
+            self.scroll(to: anchor, animated: true) { [weak self] (success) in
+                // Retry on failure up to 5 times
+                guard !success, attempt < 5 else {
+                    return
+                }
+                self?.scrollRestorationState = .scrollToAnchor(anchor, attempt: attempt + 1)
+            }
+        }
+    }
+    
+    internal func stashOffsetPercentage() {
+        let offset = webView.scrollView.verticalOffsetPercentage
+        // negative and 0 offsets make small errors in scrolling, allow it to automatically handle those cases
+        if offset > 0 {
+            scrollRestorationState = .scrollToPercentage(offset)
+        }
+    }
+    
+    private func checkForScrollToAnchor(in response: HTTPURLResponse) {
+        guard let fragment = response.url?.fragment else {
+            return
+        }
+        scrollRestorationState = .scrollToAnchor(fragment, attempt: 1)
+    }
+    
+    // MARK: Article State Restoration
     
     /// Save article scroll position for restoration later
     func saveArticleScrollPosition() {
@@ -503,36 +544,16 @@ class ArticleViewController: ViewController, HintPresenting {
             return
         }
         isRestoringState = false
-        isRestoringStateOnNextContentSizeChange = true
-        perform(#selector(restoreState), with: nil, afterDelay: 0.5) // failsafe, attempt to restore state after half a second regardless
-    }
-    
-    /// If state is supposed to be restored after the next content size change, restore that state
-    /// This should be called in a debounced manner when article content size changes
-    func restoreStateIfNecessaryOnContentSizeChange() {
-        guard isRestoringStateOnNextContentSizeChange else {
-            return
-        }
-        isRestoringStateOnNextContentSizeChange = false
         let scrollPosition = CGFloat(article.viewedScrollPosition)
-        guard scrollPosition < webView.scrollView.bottomOffsetY else {
-            return
+        if scrollPosition > 0 {
+            scrollRestorationState = .scrollToOffset(scrollPosition, animated: false, completion: { [weak self] in
+                self?.setWebViewHidden(false, animated: true)
+            })
+        } else if let fragment = article.viewedFragment {
+            scrollRestorationState = .scrollToAnchor(fragment)
         }
-        restoreState()
     }
     
-    /// Scroll to the state restoration scroll position now, canceling any previous attempts
-    @objc func restoreState() {
-        NSObject.cancelPreviousPerformRequests(withTarget: self, selector: #selector(restoreState), object: nil)
-        let scrollPosition = CGFloat(article.viewedScrollPosition)
-        if scrollPosition > 0 && scrollPosition < webView.scrollView.bottomOffsetY {
-            scroll(to: CGPoint(x: 0, y: scrollPosition), animated: false)
-        } else if let anchor = article.viewedFragment {
-            scroll(to: anchor, animated: false)
-        }
-        setWebViewHidden(false, animated: true)
-    }
-
     func setWebViewHidden(_ hidden: Bool, animated: Bool, completion: ((Bool) -> Void)? = nil) {
         let block = {
             self.webView.alpha = hidden ? 0 : 1
@@ -793,8 +814,7 @@ private extension ArticleViewController {
     }
     
     @objc func debouncedContentSizeDidChange() {
-        restoreOffsetPercentageIfNecessary()
-        restoreStateIfNecessaryOnContentSizeChange()
+        restoreScrollStateIfNecessary()
     }
     
     @objc func didReceiveArticleUpdatedNotification(_ notification: Notification) {
@@ -1009,6 +1029,7 @@ extension ArticleViewController: WKNavigationDelegate {
             return
         }
         currentETag = response.allHeaderFields[HTTPURLResponse.etagHeaderKey] as? String
+        checkForScrollToAnchor(in: response)
     }
     
     func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
@@ -1032,7 +1053,6 @@ extension ArticleViewController: WKNavigationDelegate {
             shouldPerformWebRefreshAfterScrollViewDeceleration = false
         }
     }
-
 }
 
 extension ViewController  { // Putting extension on ViewController rather than ArticleVC allows for re-use by EditPreviewVC
diff --git a/Wikipedia/Code/ReferenceBackLinksViewControllerDelegate.swift b/Wikipedia/Code/ReferenceBackLinksViewControllerDelegate.swift
index 2d00bdf3a17..28dfbd45540 100644
--- a/Wikipedia/Code/ReferenceBackLinksViewControllerDelegate.swift
+++ b/Wikipedia/Code/ReferenceBackLinksViewControllerDelegate.swift
@@ -48,7 +48,7 @@ extension ReferenceBackLinksViewControllerDelegate where Self: ViewController {
             showGenericError()
             return
         }
-        scroll(to: "back_link_\(referenceId)", highlighted: true, animated: true) { [weak self] in
+        scroll(to: "back_link_\(referenceId)", highlighted: true, animated: true) { [weak self] (_) in
             dispatchOnMainQueueAfterDelayInSeconds(1.0) { [weak self] in
                 self?.messagingController.removeElementHighlights()
             }
diff --git a/Wikipedia/Code/ReferenceShowing.swift b/Wikipedia/Code/ReferenceShowing.swift
index f227b3d4da6..410a04a923c 100644
--- a/Wikipedia/Code/ReferenceShowing.swift
+++ b/Wikipedia/Code/ReferenceShowing.swift
@@ -24,8 +24,8 @@ extension ReferenceShowing where Self: ViewController & WMFReferencePageViewAppe
         } else {
             if !isBoundingClientRectVisible(referencesBoundingClientRect) {
                 let center = referenceRectInScrollCoordinates.center
-                scroll(to: center, centered: true, animated: true) {
-                    self.showReferencesPopover(with: scriptMessageReferences[selectedIndex], referenceRectInScrollCoordinates: referenceRectInScrollCoordinates, animated: animated)
+                scroll(to: center, centered: true, animated: true) { [weak self] (_) in
+                    self?.showReferencesPopover(with: scriptMessageReferences[selectedIndex], referenceRectInScrollCoordinates: referenceRectInScrollCoordinates, animated: animated)
                 }
             } else {
                 showReferencesPopover(with: scriptMessageReferences[selectedIndex], referenceRectInScrollCoordinates: referenceRectInScrollCoordinates, animated: animated)
@@ -112,8 +112,10 @@ private extension ReferenceShowing where Self: ViewController  {
 
         let oldY = webView.scrollView.contentOffset.y
         let scrollPoint = referenceRectInScrollCoordinates.offsetBy(dx: 0, dy: 0.5 * panelRectInWindowCoordinates.height).center
-        scroll(to: scrollPoint, centered: true, animated: animated) {
-            let newY = self.webView.scrollView.contentOffset.y
+        scroll(to: scrollPoint, centered: true, animated: animated) { [weak self] (_) in
+            guard let newY = self?.webView.scrollView.contentOffset.y else {
+                return
+            }
             let delta = newY - oldY
             viewController.backgroundView.clearRect = referenceRectInWindowCoordinates.offsetBy(dx: 0, dy: 0 - delta)
         }
