diff --git a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h
index edc97ffb2cc..4b5da1a2c86 100644
--- a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h
+++ b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.h
@@ -61,8 +61,6 @@
 /** Content offset value to replace actual value when -overwriteContentOffset is YES */
 @property (assign, nonatomic) CGPoint contentOffset;
 
-/** Index path of item currently being moved, and thus being hidden */
-@property (strong, nonatomic) NSIndexPath* movingIndexPath;
 
 @end
 
diff --git a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
index 1f29d7b739a..3b985ec88db 100644
--- a/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
+++ b/Wikipedia/UI-V5/TGLStackedViewController/TGLStackedLayout.m
@@ -24,6 +24,7 @@
 //  THE SOFTWARE.
 
 #import "TGLStackedLayout.h"
+#import "UICollectionView+WMFExtensions.h"
 
 #define MOVE_ZOOM 0.95
 
@@ -39,15 +40,22 @@ typedef NS_ENUM (NSInteger, TGLStackedViewControllerScrollDirection) {
 
 @interface TGLStackedLayout ()<UIGestureRecognizerDelegate>
 
-@property (strong, nonatomic) UIView* movingView;
-@property (strong, nonatomic) UILongPressGestureRecognizer* moveGestureRecognizer;
 
 @property (assign, nonatomic) TGLStackedViewControllerScrollDirection scrollDirection;
 @property (strong, nonatomic) CADisplayLink* scrollDisplayLink;
 
+
+@property (strong, nonatomic) UILongPressGestureRecognizer* moveGestureRecognizer;
+
 @property (nonatomic, strong) UIPanGestureRecognizer* deletePanGesture;
-@property (nonatomic, strong) NSIndexPath* panningIndexPath;
-@property (nonatomic, strong) NSIndexPath* deletingIndexPath;
+
+@property (assign, nonatomic) CGPoint gestureStartLocation;
+
+/** Index path of item currently being moved, and thus being hidden */
+@property (strong, nonatomic) NSIndexPath* movingIndexPath;
+@property (assign, nonatomic) CGPoint movingCellCenter;
+@property (strong, nonatomic) UIView* movingSnapshotView;
+@property (strong, nonatomic) UIView* bottomSnapshotView;
 
 @property (nonatomic, strong) NSDictionary* layoutAttributes;
 
@@ -300,9 +308,6 @@ - (NSArray*)layoutAttributesForElementsInRect:(CGRect)rect {
     [self.layoutAttributes enumerateKeysAndObjectsUsingBlock:^(NSIndexPath* indexPath, UICollectionViewLayoutAttributes* attributes, BOOL* stop) {
         if (CGRectIntersectsRect(rect, attributes.frame)) {
             [layoutAttributes addObject:attributes];
-            if ([self.panningIndexPath isEqual:attributes.indexPath]) {
-                [self updateAttibutesWithPanTranslation:attributes];
-            }
         }
     }];
 
@@ -311,21 +316,9 @@ - (NSArray*)layoutAttributesForElementsInRect:(CGRect)rect {
 
 - (UICollectionViewLayoutAttributes*)layoutAttributesForItemAtIndexPath:(NSIndexPath*)indexPath {
     UICollectionViewLayoutAttributes* item = self.layoutAttributes[indexPath];
-    if ([self.panningIndexPath isEqual:indexPath]) {
-        [self updateAttibutesWithPanTranslation:item];
-    }
     return item;
 }
 
-- (UICollectionViewLayoutAttributes*)finalLayoutAttributesForDisappearingItemAtIndexPath:(NSIndexPath*)itemIndexPath {
-    if ([self.deletingIndexPath isEqual:itemIndexPath]) {
-        UICollectionViewLayoutAttributes* item = [self layoutAttributesForItemAtIndexPath:itemIndexPath];
-        [self updateAttibutesForDeletion:item];
-        return item;
-    }
-    return [super finalLayoutAttributesForDisappearingItemAtIndexPath:itemIndexPath];
-}
-
 - (void)prepareForTransitionToLayout:(UICollectionViewLayout*)newLayout {
     [self.collectionView removeGestureRecognizer:self.moveGestureRecognizer];
     [self.collectionView removeGestureRecognizer:self.deletePanGesture];
@@ -343,18 +336,6 @@ - (void)updateAttibutesWithPanTranslation:(UICollectionViewLayoutAttributes*)ite
     item.frame     = frame;
 }
 
-- (void)resetAttibutesWithPanTranslation:(UICollectionViewLayoutAttributes*)item {
-    CGRect frame = item.frame;
-    frame.origin.x = 0;
-    item.frame     = frame;
-}
-
-- (void)updateAttibutesForDeletion:(UICollectionViewLayoutAttributes*)item {
-    CGRect frame = item.frame;
-    frame.origin.x = self.collectionView.bounds.size.width * 2;
-    item.frame     = frame;
-}
-
 #pragma mark - Drag Action
 
 - (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
@@ -372,16 +353,13 @@ - (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
             if (indexPath && canMove) {
                 UICollectionViewCell* movingCell = [self.collectionView cellForItemAtIndexPath:indexPath];
 
-                self.movingView = [[UIView alloc] initWithFrame:movingCell.frame];
-
-                startCenter = self.movingView.center;
+                self.movingSnapshotView       = [movingCell snapshotViewAfterScreenUpdates:YES];
+                self.movingSnapshotView.frame = movingCell.frame;
 
-                UIImageView* movingImageView = [[UIImageView alloc] initWithImage:[self screenshotImageOfItem:movingCell]];
+                startCenter = self.movingSnapshotView.center;
 
-                movingImageView.alpha = 0.0f;
-
-                [self.movingView addSubview:movingImageView];
-                [self.collectionView addSubview:self.movingView];
+                self.movingSnapshotView.alpha = 0.0f;
+                [self.collectionView addSubview:self.movingSnapshotView];
 
                 self.movingIndexPath = indexPath;
 
@@ -394,8 +372,8 @@ - (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
                     __strong typeof(self) strongSelf = weakSelf;
 
                     if (strongSelf) {
-                        strongSelf.movingView.transform = CGAffineTransformMakeScale(MOVE_ZOOM, MOVE_ZOOM);
-                        movingImageView.alpha = 1.0f;
+                        strongSelf.movingSnapshotView.transform = CGAffineTransformMakeScale(MOVE_ZOOM, MOVE_ZOOM);
+                        strongSelf.movingSnapshotView.alpha = 1.0f;
                     }
                 }
                                  completion:^(BOOL finished) {
@@ -415,7 +393,7 @@ - (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
 
                 currentCenter.y += (currentLocation.y - startLocation.y);
 
-                self.movingView.center = currentCenter;
+                self.movingSnapshotView.center = currentCenter;
 
                 if (currentLocation.y < CGRectGetMinY(self.collectionView.bounds) + SCROLL_ZONE_TOP && self.collectionView.contentOffset.y > SCROLL_ZONE_TOP) {
                     [self startScrollingUp];
@@ -451,16 +429,16 @@ - (IBAction)handleLongPress:(UILongPressGestureRecognizer*)recognizer {
                     __strong typeof(self) strongSelf = weakSelf;
 
                     if (strongSelf) {
-                        strongSelf.movingView.transform = CGAffineTransformMakeScale(1.0f, 1.0f);
-                        strongSelf.movingView.frame = layoutAttributes.frame;
+                        strongSelf.movingSnapshotView.transform = CGAffineTransformMakeScale(1.0f, 1.0f);
+                        strongSelf.movingSnapshotView.frame = layoutAttributes.frame;
                     }
                 }
                                  completion:^(BOOL finished) {
                     __strong typeof(self) strongSelf = weakSelf;
 
                     if (strongSelf) {
-                        [strongSelf.movingView removeFromSuperview];
-                        strongSelf.movingView = nil;
+                        [strongSelf.movingSnapshotView removeFromSuperview];
+                        strongSelf.movingSnapshotView = nil;
 
                         self.movingIndexPath = nil;
                         [strongSelf invalidateLayout];
@@ -517,10 +495,10 @@ - (void)handleScrolling:(CADisplayLink*)displayLink {
             if (offset.y > 0.0) {
                 self.collectionView.contentOffset = offset;
 
-                CGPoint center = self.movingView.center;
+                CGPoint center = self.movingSnapshotView.center;
 
-                center.y              -= SCROLL_PER_FRAME;
-                self.movingView.center = center;
+                center.y                      -= SCROLL_PER_FRAME;
+                self.movingSnapshotView.center = center;
             } else {
                 [self stopScrolling];
 
@@ -540,10 +518,10 @@ - (void)handleScrolling:(CADisplayLink*)displayLink {
             if (offset.y < self.collectionView.contentSize.height - CGRectGetHeight(self.collectionView.bounds)) {
                 self.collectionView.contentOffset = offset;
 
-                CGPoint center = self.movingView.center;
+                CGPoint center = self.movingSnapshotView.center;
 
-                center.y              += SCROLL_PER_FRAME;
-                self.movingView.center = center;
+                center.y                      += SCROLL_PER_FRAME;
+                self.movingSnapshotView.center = center;
             } else {
                 [self stopScrolling];
 
@@ -560,18 +538,6 @@ - (void)handleScrolling:(CADisplayLink*)displayLink {
     }
 }
 
-- (UIImage*)screenshotImageOfItem:(UICollectionViewCell*)item {
-    UIGraphicsBeginImageContextWithOptions(item.bounds.size, item.isOpaque, 0.0f);
-
-    [item.layer renderInContext:UIGraphicsGetCurrentContext()];
-
-    UIImage* image = UIGraphicsGetImageFromCurrentImageContext();
-
-    UIGraphicsEndImageContext();
-
-    return image;
-}
-
 - (void)updateLayoutAtMovingLocation:(CGPoint)movingLocation {
     NSIndexPath* oldMovingIndexPath = self.movingIndexPath;
     NSIndexPath* newMovingIndexPath = [self.collectionView indexPathForItemAtPoint:movingLocation];
@@ -601,26 +567,12 @@ - (void)updateLayoutAtMovingLocation:(CGPoint)movingLocation {
 #pragma mark - UIGestureRecognizer
 
 - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer*)gestureRecognizer {
-    if (![gestureRecognizer isEqual:self.deletePanGesture]) {
-        return YES;
-    }
-
-    CGPoint attachmentPoint       = [gestureRecognizer locationInView:self.collectionView];
-    NSIndexPath* touchedIndexPath = [self.collectionView indexPathForItemAtPoint:attachmentPoint];
-
-    if (!touchedIndexPath) {
-        return NO;
-    }
-
-    if ([self.delegate respondsToSelector:@selector(stackLayout:canDeleteItemAtIndexPath:)] && ![self.delegate stackLayout:self canDeleteItemAtIndexPath:touchedIndexPath]) {
-        return NO;
-    }
-
-    CGPoint velocity = [(UIPanGestureRecognizer*)gestureRecognizer velocityInView:self.collectionView];
-    if (velocity.y > 0 || velocity.y < 0) {
-        return NO;
+    if ([gestureRecognizer isEqual:self.deletePanGesture]) {
+        CGPoint velocity = [(UIPanGestureRecognizer*)gestureRecognizer velocityInView:self.collectionView];
+        if (velocity.y > 0 || velocity.y < 0) {
+            return NO;
+        }
     }
-
     return YES;
 }
 
@@ -633,47 +585,72 @@ - (IBAction)panWithGesture:(UIPanGestureRecognizer*)pan {
             CGPoint attachmentPoint = [pan locationInView:self.collectionView];
 
             NSIndexPath* touchedIndexPath = [self.collectionView indexPathForItemAtPoint:attachmentPoint];
+
+            //bail if no index path
             if (!touchedIndexPath) {
                 [self cancelTouchesInGestureRecognizer:pan];
                 return;
             }
 
-            UICollectionViewLayoutAttributes* attributes = [self layoutAttributesForItemAtIndexPath:touchedIndexPath];
+            //bail if we can't move
+            if ([self.delegate respondsToSelector:@selector(stackLayout:canDeleteItemAtIndexPath:)] && ![self.delegate stackLayout:self canDeleteItemAtIndexPath:touchedIndexPath]) {
+                [self cancelTouchesInGestureRecognizer:pan];
+                return;
+            }
+
+            UICollectionViewCell* movingCell = [self.collectionView cellForItemAtIndexPath:touchedIndexPath];
 
-            if (!attributes) {
+            //bail if there is no cell
+            if (!movingCell) {
                 [self cancelTouchesInGestureRecognizer:pan];
                 return;
             }
 
-            self.panningIndexPath = touchedIndexPath;
+            self.movingSnapshotView       = [self.collectionView wmf_snapshotOfCellAtIndexPath:touchedIndexPath];
+            self.movingSnapshotView.frame = movingCell.frame;
+            self.movingCellCenter         = self.movingSnapshotView.center;
+            self.movingIndexPath          = touchedIndexPath;
+
+            self.bottomSnapshotView       = [self.collectionView wmf_snapshotOfCellsAfterIndexPath:touchedIndexPath];
+            self.bottomSnapshotView.frame = [self.collectionView wmf_rectEnclosingCellsAtIndexPaths:[self.collectionView wmf_visibleIndexPathsOfItemsAfterIndexPath:touchedIndexPath]];
+
+            [self.collectionView addSubview:self.movingSnapshotView];
+            [self.collectionView addSubview:self.bottomSnapshotView];
+
             [self invalidateLayout];
         }
         break;
 
         case UIGestureRecognizerStateChanged:
         {
-            [self invalidateLayout];
+            if (self.movingIndexPath) {
+                CGPoint translation   = [pan translationInView:self.collectionView];
+                CGPoint currentCenter = self.movingCellCenter;
+                currentCenter.x               += translation.x;
+                self.movingSnapshotView.center = currentCenter;
+            }
         }
         break;
 
         case UIGestureRecognizerStateEnded:
         case UIGestureRecognizerStateCancelled:
         {
-            CGPoint translation = [pan translationInView:self.collectionView];
-            CGFloat originalX   = [super layoutAttributesForItemAtIndexPath:self.panningIndexPath].frame.origin.x;
+            if (self.movingIndexPath) {
+                CGPoint translation = [pan translationInView:self.collectionView];
 
-            if (translation.x >= (originalX + self.collectionView.bounds.size.width / 2)) {
-                [self completeDeletionPanAnimation];
-                return;
-            }
+                if (fabs(translation.x) >= self.collectionView.bounds.size.width / 2) {
+                    [self completeDeletionPanAnimationWithGestureRecognizer:pan];
+                    return;
+                }
 
-            CGPoint velocity = [pan velocityInView:self.collectionView];
-            if (velocity.x > 500) {
-                [self completeDeletionPanAnimation];
-                return;
-            }
+                CGPoint velocity = [pan velocityInView:self.collectionView];
+                if (fabs(velocity.x) > 500) {
+                    [self completeDeletionPanAnimationWithGestureRecognizer:pan];
+                    return;
+                }
 
-            [self cancelDeletionPanAnimation];
+                [self cancelDeletionPanAnimationWithGestureRecognizer:pan];
+            }
         }
         break;
 
@@ -687,29 +664,65 @@ - (void)cancelTouchesInGestureRecognizer:(UIGestureRecognizer*)gesture {
     gesture.enabled = YES;
 }
 
-- (void)completeDeletionPanAnimation {
-    self.deletingIndexPath = self.panningIndexPath;
-    self.panningIndexPath  = nil;
+- (void)completeDeletionPanAnimationWithGestureRecognizer:(UIPanGestureRecognizer*)pan {
+    CGPoint velocity         = [pan velocityInView:self.collectionView];
+    CGPoint finalDestination = self.movingCellCenter;
 
-    [self.collectionView performBatchUpdates:^{
-        UICollectionViewLayoutAttributes* item = [self layoutAttributesForItemAtIndexPath:self.deletingIndexPath];
-        [self resetAttibutesWithPanTranslation:item];
+    if (velocity.x > 0) {
+        finalDestination.x += CGRectGetWidth(self.collectionView.bounds);
+    } else {
+        finalDestination.x -= CGRectGetWidth(self.collectionView.bounds);
+    }
 
-        [self.collectionView deleteItemsAtIndexPaths:@[self.deletingIndexPath]];
-        if ([self.delegate respondsToSelector:@selector(stackLayout:deleteItemAtIndexPath:)]) {
-            [self.delegate stackLayout:self deleteItemAtIndexPath:self.deletingIndexPath];
-        }
+    NSIndexPath* indexPath = self.movingIndexPath;
+
+    [UIView animateWithDuration:0.25 delay:0.0 usingSpringWithDamping:0.8 initialSpringVelocity:velocity.x / finalDestination.x options:0 animations:^{
+        self.movingSnapshotView.center = finalDestination;
     } completion:^(BOOL finished) {
-        self.deletingIndexPath = nil;
+        self.movingIndexPath = nil;
+        self.gestureStartLocation = CGPointZero;
+        self.movingCellCenter = CGPointZero;
+        [self.movingSnapshotView removeFromSuperview];
+        self.movingSnapshotView = nil;
+        [self.bottomSnapshotView removeFromSuperview];
+        self.bottomSnapshotView = nil;
+
+        [self.collectionView performBatchUpdates:^{
+            if ([self.delegate respondsToSelector:@selector(stackLayout:deleteItemAtIndexPath:)]) {
+                [self.delegate stackLayout:self deleteItemAtIndexPath:indexPath];
+            }
+            [self.collectionView deleteItemsAtIndexPaths:@[indexPath]];
+
+            [self invalidateLayout];
+        } completion:^(BOOL finished) {
+        }];
     }];
 }
 
-- (void)cancelDeletionPanAnimation {
-    self.panningIndexPath = nil;
+- (void)cancelDeletionPanAnimationWithGestureRecognizer:(UIPanGestureRecognizer*)pan {
+    CGPoint velocity         = [pan velocityInView:self.collectionView];
+    CGPoint finalDestination = self.movingCellCenter;
 
-    [self.collectionView performBatchUpdates:^{
-        [self invalidateLayout];
-    } completion:nil];
+    [UIView animateWithDuration:0.25 delay:0.0 usingSpringWithDamping:0.8 initialSpringVelocity:velocity.x / finalDestination.x options:0 animations:^{
+        self.movingSnapshotView.center = finalDestination;
+    } completion:^(BOOL finished) {
+        self.movingIndexPath = nil;
+        self.gestureStartLocation = CGPointZero;
+        self.movingCellCenter = CGPointZero;
+
+        [self.collectionView performBatchUpdates:^{
+            [self invalidateLayout];
+        } completion:^(BOOL finished) {
+            //For some reason this completion blick fires before the layout is finished resulting in a flicker when updating the moving view.
+            // To compensate, we add a delay in to be sure it is finished before moving
+            dispatchOnMainQueueAfterDelayInSeconds(0.1, ^{
+                [self.movingSnapshotView removeFromSuperview];
+                self.movingSnapshotView = nil;
+                [self.bottomSnapshotView removeFromSuperview];
+                self.bottomSnapshotView = nil;
+            });
+        }];
+    }];
 }
 
 @end
diff --git a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h
index 97c8d67771b..f92bb554162 100644
--- a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h
+++ b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.h
@@ -20,6 +20,24 @@ typedef void (^ WMFCellEnumerator)(id cell, NSIndexPath* indexPath, BOOL* stop);
  */
 - (void)wmf_setCollectionViewLayout:(UICollectionViewLayout*)layout animated:(BOOL)animated alwaysFireCompletion:(void (^)(BOOL finished))completion;
 
+
+
+- (NSArray*)wmf_visibleIndexPathsOfItemsBeforeIndexPath:(NSIndexPath*)indexPath;
+- (NSArray*)wmf_visibleIndexPathsOfItemsAfterIndexPath:(NSIndexPath*)indexPath;
+
+- (CGRect)wmf_rectEnclosingCellsAtIndexPaths:(NSArray*)indexPaths;
+
+- (UIView*)wmf_snapshotOfVisibleCells;
+
+- (UIView*)wmf_snapshotOfCellAtIndexPath:(NSIndexPath*)indexPath;
+
+- (UIView*)wmf_snapshotOfCellsAtIndexPaths:(NSArray*)indexPaths;
+
+- (UIView*)wmf_snapshotOfCellsBeforeIndexPath:(NSIndexPath*)indexPath;
+
+- (UIView*)wmf_snapshotOfCellsAfterIndexPath:(NSIndexPath*)indexPath;
+
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m
index 61885ca146b..80ef0a94367 100644
--- a/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m
+++ b/Wikipedia/UI-V5/UICollectionView+WMFExtensions.m
@@ -55,6 +55,81 @@ - (void)wmf_setCollectionViewLayout:(UICollectionViewLayout*)layout animated:(BO
     }
 }
 
+- (NSArray*)wmf_visibleIndexPathsOfItemsBeforeIndexPath:(NSIndexPath*)indexPath {
+    return [[self indexPathsForVisibleItems] bk_select:^BOOL (NSIndexPath* obj) {
+        if (obj.section > indexPath.section) {
+            return NO;
+        }
+
+        if (obj.row < indexPath.row) {
+            return YES;
+        }
+
+        return NO;
+    }];
+}
+
+- (NSArray*)wmf_visibleIndexPathsOfItemsAfterIndexPath:(NSIndexPath*)indexPath {
+    return [[self indexPathsForVisibleItems] bk_select:^BOOL (NSIndexPath* obj) {
+        if (obj.section < indexPath.section) {
+            return NO;
+        }
+
+        if (obj.row > indexPath.row) {
+            return YES;
+        }
+
+        return NO;
+    }];
+}
+
+- (CGRect)wmf_rectEnclosingCellsAtIndexPaths:(NSArray*)indexPaths {
+    __block CGRect enclosingRect = CGRectZero;
+
+    [indexPaths enumerateObjectsUsingBlock:^(NSIndexPath* obj, NSUInteger idx, BOOL* stop) {
+        UICollectionViewCell* cell = [self cellForItemAtIndexPath:obj];
+
+        if (!cell) {
+            return;
+        }
+
+        if (CGRectIsEmpty(enclosingRect)) {
+            enclosingRect = cell.frame;
+        } else {
+            enclosingRect = CGRectUnion(enclosingRect, cell.frame);
+        }
+    }];
+
+    return enclosingRect;
+}
+
+- (UIView*)wmf_snapshotOfVisibleCells {
+    NSArray* indexpaths = [self indexPathsForVisibleItems];
+    return [self wmf_snapshotOfCellsAtIndexPaths:indexpaths];
+}
+
+- (UIView*)wmf_snapshotOfCellAtIndexPath:(NSIndexPath*)indexPath {
+    return [self wmf_snapshotOfCellsAtIndexPaths:@[indexPath]];
+}
+
+- (UIView*)wmf_snapshotOfCellsAtIndexPaths:(NSArray*)indexPaths {
+    __block CGRect snapShotRect = [self wmf_rectEnclosingCellsAtIndexPaths:indexPaths];
+
+    if (CGRectIsEmpty(snapShotRect)) {
+        return nil;
+    } else {
+        return [self resizableSnapshotViewFromRect:snapShotRect afterScreenUpdates:YES withCapInsets:UIEdgeInsetsZero];
+    }
+}
+
+- (UIView*)wmf_snapshotOfCellsBeforeIndexPath:(NSIndexPath*)indexPath {
+    return [self wmf_snapshotOfCellsAtIndexPaths:[self wmf_visibleIndexPathsOfItemsBeforeIndexPath:indexPath]];
+}
+
+- (UIView*)wmf_snapshotOfCellsAfterIndexPath:(NSIndexPath*)indexPath {
+    return [self wmf_snapshotOfCellsAtIndexPaths:[self wmf_visibleIndexPathsOfItemsAfterIndexPath:indexPath]];
+}
+
 @end
 
 NS_ASSUME_NONNULL_END
